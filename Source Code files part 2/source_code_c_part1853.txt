CallBacks.GetVideoPortConnectInfo)
        {
            lpVideoPortCallBacks->GetVideoPortConnectInfo = DvpGetVideoPortConnectInfo;
        }
        if (VideoPortCallBacks.GetVideoPortFlipStatus)
        {
            lpVideoPortCallBacks->GetVideoPortFlipStatus = DvpGetVideoPortFlipStatus;
        }
        if (VideoPortCallBacks.WaitForVideoPortSync)
        {
            lpVideoPortCallBacks->WaitForVideoPortSync = DvpWaitForVideoPortSync;
        }
        if (VideoPortCallBacks.GetVideoSignalStatus)
        {
            lpVideoPortCallBacks->GetVideoSignalStatus = DvpGetVideoSignalStatus;
        }
        if (VideoPortCallBacks.ColorControl)
        {
            lpVideoPortCallBacks->ColorControl = DvpColorControl;
        }
    }
    else if (IsEqualIID(&lpGetDriverInfoData->guidInfo, &GUID_ColorControlCallbacks))
    {
        DD_COLORCONTROLCALLBACKS        ColorControlCallBacks;
        LPDDHAL_DDCOLORCONTROLCALLBACKS lpColorControlCallBacks;

        // Translate ColorControl call-backs to user-mode:

        lpColorControlCallBacks          = lpGetDriverInfoData->lpvData;
        GetDriverInfoData.lpvData        = &ColorControlCallBacks;
        GetDriverInfoData.dwExpectedSize = sizeof(ColorControlCallBacks);

        dwRet = NtGdiDdGetDriverInfo(hDirectDraw, &GetDriverInfoData);

        RtlZeroMemory(lpColorControlCallBacks, sizeof(*lpColorControlCallBacks));
        lpGetDriverInfoData->dwActualSize    = sizeof(*lpColorControlCallBacks);
        lpColorControlCallBacks->dwSize      = sizeof(*lpColorControlCallBacks);
        lpColorControlCallBacks->dwFlags = ColorControlCallBacks.dwFlags;

        if (ColorControlCallBacks.ColorControl)
        {
            lpColorControlCallBacks->ColorControl = DdColorControl;
        }
    }
    else if (IsEqualIID(&lpGetDriverInfoData->guidInfo, &GUID_MiscellaneousCallbacks))
    {
        DD_MISCELLANEOUSCALLBACKS           MiscellaneousCallBacks;
        LPDDHAL_DDMISCELLANEOUSCALLBACKS    lpMiscellaneousCallBacks;

        // Translate miscellaneous call-backs to user-mode:

        lpMiscellaneousCallBacks         = lpGetDriverInfoData->lpvData;
        GetDriverInfoData.lpvData        = &MiscellaneousCallBacks;
        GetDriverInfoData.dwExpectedSize = sizeof(MiscellaneousCallBacks);
        lpMiscellaneousCallBacks->dwFlags = 0;

        // Don't return what the driver returns because we always want this
        // to suceed

        NtGdiDdGetDriverInfo(hDirectDraw, &GetDriverInfoData);
        GetDriverInfoData.dwActualSize = sizeof(MiscellaneousCallBacks);
        GetDriverInfoData.ddRVal = DD_OK;
        dwRet = DDHAL_DRIVER_HANDLED;

        RtlZeroMemory(lpMiscellaneousCallBacks, sizeof(*lpMiscellaneousCallBacks));
        lpGetDriverInfoData->dwActualSize     = sizeof(*lpMiscellaneousCallBacks);
        lpMiscellaneousCallBacks->dwSize      = sizeof(*lpMiscellaneousCallBacks);
        lpMiscellaneousCallBacks->dwFlags = MiscellaneousCallBacks.dwFlags;

        //We always implement this callback now that kernel owns vidmem management
        lpMiscellaneousCallBacks->GetAvailDriverMemory = DdGetAvailDriverMemory;
        lpMiscellaneousCallBacks->dwFlags |= DDHAL_MISCCB32_GETAVAILDRIVERMEMORY;
    }
    else if (IsEqualIID(&lpGetDriverInfoData->guidInfo, &GUID_Miscellaneous2Callbacks))
    {
        DD_MISCELLANEOUS2CALLBACKS          Miscellaneous2CallBacks;
        LPDDHAL_DDMISCELLANEOUS2CALLBACKS   lpMiscellaneous2CallBacks;

        // Translate miscellaneous call-backs to user-mode:

        lpMiscellaneous2CallBacks        = lpGetDriverInfoData->lpvData;
        GetDriverInfoData.lpvData        = &Miscellaneous2CallBacks;
        GetDriverInfoData.dwExpectedSize = sizeof(Miscellaneous2CallBacks);

        dwRet = NtGdiDdGetDriverInfo(hDirectDraw, &GetDriverInfoData);

        RtlZeroMemory(lpMiscellaneous2CallBacks, sizeof(*lpMiscellaneous2CallBacks));
        lpGetDriverInfoData->dwActualSize     = sizeof(*lpMiscellaneous2CallBacks);
        lpMiscellaneous2CallBacks->dwSize      = sizeof(*lpMiscellaneous2CallBacks);
        lpMiscellaneous2CallBacks->dwFlags = Miscellaneous2CallBacks.dwFlags;

        if (Miscellaneous2CallBacks.AlphaBlt)
        {
            lpMiscellaneous2CallBacks->AlphaBlt = DdAlphaBlt;
        }
        if (Miscellaneous2CallBacks.GetDriverState)
        {
            lpMiscellaneous2CallBacks->GetDriverState = 
                (LPDDHAL_GETDRIVERSTATE)NtGdiDdGetDriverState;
        }
        if (Miscellaneous2CallBacks.CreateSurfaceEx)
        {
            lpMiscellaneous2CallBacks->CreateSurfaceEx = 
                (LPDDHAL_CREATESURFACEEX)DdCreateSurfaceEx;
        }
        // Dont pass back DestroyDDLocal
    }
    else if (IsEqualIID(&lpGetDriverInfoData->guidInfo, &GUID_NTCallbacks))
    {
        DD_NTCALLBACKS          NTCallBacks;
        LPDDHAL_DDNTCALLBACKS   lpNTCallBacks;

        // Translate NT call-backs to user-mode:

        lpNTCallBacks                    = lpGetDriverInfoData->lpvData;
        GetDriverInfoData.lpvData        = &NTCallBacks;
        GetDriverInfoData.dwExpectedSize = sizeof(NTCallBacks);

        dwRet = NtGdiDdGetDriverInfo(hDirectDraw, &GetDriverInfoData);

        RtlZeroMemory(lpNTCallBacks, sizeof(*lpNTCallBacks));
        lpGetDriverInfoData->dwActualSize = sizeof(*lpNTCallBacks);
        lpNTCallBacks->dwSize             = sizeof(*lpNTCallBacks);
        lpNTCallBacks->dwFlags            = NTCallBacks.dwFlags;

        // FreeDriverMemory is also an NTCallback but it will only be called
        // from kernel-mode, so we don't have a user-mode thunk function.

        if (NTCallBacks.SetExclusiveMode)
        {
            lpNTCallBacks->SetExclusiveMode = DdSetExclusiveMode;
        }

        if (NTCallBacks.FlipToGDISurface)
        {
            lpNTCallBacks->FlipToGDISurface = DdFlipToGDISurface;
        }
    }
    else if (IsEqualIID(&lpGetDriverInfoData->guidInfo, &GUID_D3DCallbacks2))
    {
        // Fill NULL for D3DCALLBACKS2.
        LPD3DHAL_CALLBACKS2 lpD3dCallbacks2;
        lpD3dCallbacks2 = lpGetDriverInfoData->lpvData;
        RtlZeroMemory(lpD3dCallbacks2, sizeof(*lpD3dCallbacks2));
        lpGetDriverInfoData->dwActualSize = sizeof(*lpD3dCallbacks2);
        lpD3dCallbacks2->dwSize = sizeof(*lpD3dCallbacks2);
        GetDriverInfoData.ddRVal = DDERR_GENERIC;
        dwRet = DDHAL_DRIVER_HANDLED;
    }
    else if (IsEqualIID(&lpGetDriverInfoData->guidInfo, &GUID_D3DCallbacks3))
    {
        D3DNTHAL_CALLBACKS3 D3dCallbacks3;
        LPD3DHAL_CALLBACKS3 lpD3dCallbacks3;

        // Translate D3DNTHAL_CALLBACKS3 to user-mode.

        lpD3dCallbacks3 = lpGetDriverInfoData->lpvData;
        GetDriverInfoData.lpvData = &D3dCallbacks3;
        GetDriverInfoData.dwExpectedSize = sizeof(D3dCallbacks3);

        dwRet = NtGdiDdGetDriverInfo(hDirectDraw, &GetDriverInfoData);

        RtlZeroMemory((PVOID)lpD3dCallbacks3, sizeof(*lpD3dCallbacks3));
        lpGetDriverInfoData->dwActualSize = sizeof(*lpD3dCallbacks3);
        lpD3dCallbacks3->dwSize = sizeof(*lpD3dCallbacks3);
        lpD3dCallbacks3->dwFlags = D3dCallbacks3.dwFlags;
        lpD3dCallbacks3->Clear2 = NULL;
        lpD3dCallbacks3->lpvReserved = NULL;

        if (D3dCallbacks3.ValidateTextureStageState != NULL)
        {
            lpD3dCallbacks3->ValidateTextureStageState =
                (LPD3DHAL_VALIDATETEXTURESTAGESTATECB)NtGdiD3dValidateTextureStageState;
        }
        if (D3dCallbacks3.DrawPrimitives2 != NULL)
        {
            lpD3dCallbacks3->DrawPrimitives2 =
                (LPD3DHAL_DRAWPRIMITIVES2CB)D3dDrawPrimitives2;
        }
    }
    else if (IsEqualIID(&lpGetDriverInfoData->guidInfo,
                        &GUID_D3DParseUnknownCommandCallback))
    {
        // On NT we ignore this callback
        lpGetDriverInfoData->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    }
    else if (IsEqualIID(&lpGetDriverInfoData->guidInfo, &GUID_MotionCompCallbacks))
    {
        DD_MOTIONCOMPCALLBACKS         MotionCompCallbacks;
        LPDDHAL_DDMOTIONCOMPCALLBACKS  lpMotionCompCallbacks;

        // Translate Video call-backs to user-mode:

        lpMotionCompCallbacks            = lpGetDriverInfoData->lpvData;
        GetDriverInfoData.lpvData        = &MotionCompCallbacks;
        GetDriverInfoData.dwExpectedSize = sizeof(MotionCompCallbacks);

        dwRet = NtGdiDdGetDriverInfo(hDirectDraw, &GetDriverInfoData);

        RtlZeroMemory(lpMotionCompCallbacks, sizeof(*lpMotionCompCallbacks));
        lpGetDriverInfoData->dwActualSize = sizeof(*lpMotionCompCallbacks);
        lpMotionCompCallbacks->dwSize     = sizeof(*lpMotionCompCallbacks);
        lpMotionCompCallbacks->dwFlags    = MotionCompCallbacks.dwFlags
                                       | DDHAL_MOCOMP32_CREATE
                                       | DDHAL_MOCOMP32_DESTROY;
        lpMotionCompCallbacks->CreateMoComp = DdCreateMoComp;
        lpMotionCompCallbacks->DestroyMoComp = DdDestroyMoComp;

        if (MotionCompCallbacks.GetMoCompGuids)
        {
            lpMotionCompCallbacks->GetMoCompGuids = DdGetMoCompGuids;
        }
        if (MotionCompCallbacks.GetMoCompFormats)
        {
            lpMotionCompCallbacks->GetMoCompFormats = DdGetMoCompFormats;
        }
        if (MotionCompCallbacks.GetMoCompBuffInfo)
        {
            lpMotionCompCallbacks->GetMoCompBuffInfo = DdGetMoCompBuffInfo;
        }
        if (MotionCompCallbacks.GetInternalMoCompInfo)
        {
            lpMotionCompCallbacks->GetInternalMoCompInfo = DdGetInternalMoCompInfo;
        }
        if (MotionCompCallbacks.BeginMoCompFrame)
        {
            lpMotionCompCallbacks->BeginMoCompFrame = DdBeginMoCompFrame;
        }
        if (MotionCompCallbacks.EndMoCompFrame)
        {
            lpMotionCompCallbacks->EndMoCompFrame = DdEndMoCompFrame;
        }
        if (MotionCompCallbacks.RenderMoComp)
        {
            lpMotionCompCallbacks->RenderMoComp = DdRenderMoComp;
        }
        if (MotionCompCallbacks.QueryMoCompStatus)
        {
            lpMotionCompCallbacks->QueryMoCompStatus = DdQueryMoCompStatus;
        }
    }
    else if (IsEqualIID(&lpGetDriverInfoData->guidInfo, &GUID_VPE2Callbacks))
    {
        LPDDHAL_DDVPE2CALLBACKS   lpVPE2CallBacks;

        // Translate NT call-backs to user-mode:

        lpVPE2CallBacks                   = lpGetDriverInfoData->lpvData;

        RtlZeroMemory(lpVPE2CallBacks, sizeof(*lpVPE2CallBacks));
        lpGetDriverInfoData->dwActualSize = sizeof(*lpVPE2CallBacks);
        lpVPE2CallBacks->dwSize           = sizeof(*lpVPE2CallBacks);
        lpVPE2CallBacks->dwFlags          = DDHAL_VPE2CB32_ACQUIRENOTIFICATION |
                                            DDHAL_VPE2CB32_RELEASENOTIFICATION;
        lpVPE2CallBacks->AcquireNotification = DvpAcquireNotification;
        lpVPE2CallBacks->ReleaseNotification = DvpReleaseNotification;

        GetDriverInfoData.ddRVal = DD_OK;
        dwRet = DDHAL_DRIVER_HANDLED;
    }
    else
    {
        // Do data call:

        GetDriverInfoData.dwExpectedSize = lpGetDriverInfoData->dwExpectedSize;
        GetDriverInfoData.lpvData        = lpGetDriverInfoData->lpvData;

        dwRet = NtGdiDdGetDriverInfo(hDirectDraw, &GetDriverInfoData);

        lpGetDriverInfoData->dwActualSize = GetDriverInfoData.dwActualSize;
    }

    lpGetDriverInfoData->ddRVal = GetDriverInfoData.ddRVal;

    return(dwRet);
}

/******************************Public*Routine******************************\
* DdCreateDirectDrawObject
*
* When 'hdc' is 0, this function creates a 'global' DirectDraw object that
* may be used by any process, as a work-around for the DirectDraw folks.
* In reality, we still create a local DirectDraw object that is specific
* to this process, and whenever we're called with this 'special' global
* handle, we substitute the process-specific handle.  See the declaration
* of 'ghDirectDraw' for a commonet on why we do this.
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
DdCreateDirectDrawObject(                       // AKA 'GdiEntry1'
    LPDDRAWI_DIRECTDRAW_GBL pDirectDrawGlobal,
    HDC                     hdc
    )
{
    BOOL b;

    b = FALSE;

    if (hdc == 0)
    {
        // Only one 'global' DirectDraw object may be active at a time.
        //
        // Note that this 'ghDirectDraw' assignment isn't thread safe;
        // DirectDraw must have its own critical section held when making
        // this call.  (Naturally, the kernel always properly synchronizes
        // itself in the NtGdi call.)

        if (ghDirectDraw == 0)
        {
            hdc = CreateDCW(L"Display", NULL, NULL, NULL);
            if (hdc != 0)
            {
                ghDirectDraw = NtGdiDdCreateDirectDrawObject(hdc);

                DeleteDC(hdc);
            }
        }

        if (ghDirectDraw)
        {
            gcDirectDraw++;
            b = TRUE;
        }

        // Mark the DirectDraw object handle stored in the DirectDraw
        // object as 'special' by making it zero:

        pDirectDrawGlobal->hDD = 0;
    }
    else
    {
#if defined(BUILD_WOW6432)
        // No Accelerated HW under WOW64
        return(FALSE);
#else    
        pDirectDrawGlobal->hDD = (ULONG_PTR) NtGdiDdCreateDirectDrawObject(hdc);
#endif // defined(BUILD_WOW6432)

        b = (pDirectDrawGlobal->hDD != 0);
    }

    return(b);
}

/*****************************Private*Routine******************************\
* DdQueryDirectDrawObject
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
DdQueryDirectDrawObject(                        // AKA 'GdiEntry2'
    LPDDRAWI_DIRECTDRAW_GBL     pDirectDrawGlobal,
    LPDDHALINFO                 pHalInfo,
    LPDDHAL_DDCALLBACKS         pDDCallBacks,
    LPDDHAL_DDSURFACECALLBACKS  pDDSurfaceCallBacks,
    LPDDHAL_DDPALETTECALLBACKS  pDDPaletteCallBacks,
    LPD3DHAL_CALLBACKS          pD3dCallbacks,
    LPD3DHAL_GLOBALDRIVERDATA   pD3dDriverData,
    LPDDHAL_DDEXEBUFCALLBACKS   pD3dBufferCallbacks,
    LPDDSURFACEDESC             pD3dTextureFormats,
    LPDWORD                     pdwFourCC,      // May be NULL
    LPVIDMEM                    pvmList         // May be NULL
    )
{
#if defined(BUILD_WOW6432)
    //
    // No Accelerated HW under WOW64
    //
    
    UNREFERENCED_PARAMETER(pDirectDrawGlobal);
    UNREFERENCED_PARAMETER(pHalInfo);
    UNREFERENCED_PARAMETER(pDDCallBacks);
    UNREFERENCED_PARAMETER(pDDSurfaceCallBacks);
    UNREFERENCED_PARAMETER(pDDPaletteCallBacks);
    UNREFERENCED_PARAMETER(pD3dCallbacks);
    UNREFERENCED_PARAMETER(pD3dDriverData);
    UNREFERENCED_PARAMETER(pD3dBufferCallbacks);
    UNREFERENCED_PARAMETER(pD3dTextureFormats);
    UNREFERENCED_PARAMETER(pdwFourCC);
    UNREFERENCED_PARAMETER(pvmList);
    
    return(FALSE); 
#else    
    DD_HALINFO      HalInfo;
    DWORD           adwCallBackFlags[3];
    DWORD           dwFlags;
    VIDEOMEMORY*    pVideoMemoryList;
    VIDEOMEMORY*    pVideoMemory;
    DWORD           dwNumHeaps;
    DWORD           dwNumFourCC;
    D3DNTHAL_CALLBACKS D3dCallbacks;
    D3DNTHAL_GLOBALDRIVERDATA D3dDriverData;
    DD_D3DBUFCALLBACKS D3dBufferCallbacks;

    pVideoMemoryList = NULL;
    if (pvmList != NULL)
    {
        pVideoMemoryList = (VIDEOMEMORY*) LocalAlloc(LMEM_ZEROINIT,
            sizeof(VIDEOMEMORY) * pHalInfo->vmiData.dwNumHeaps);
            
        if (pVideoMemoryList == NULL)
            return(FALSE);
    }

    //
    // Initialize to zero, so that Wow64's genthnk won't 
    // thunk bogus pointers.
    //
    RtlZeroMemory(&HalInfo, sizeof(HalInfo));
    RtlZeroMemory(&D3dCallbacks, sizeof(D3dCallbacks));
    RtlZeroMemory(&D3dDriverData, sizeof(D3dDriverData));
    RtlZeroMemory(&D3dBufferCallbacks, sizeof(D3dBufferCallbacks));

    if (!NtGdiDdQueryDirectDrawObject(DD_HANDLE(pDirectDrawGlobal->hDD),
                                      &HalInfo,
                                      &adwCallBackFlags[0],
                                      &D3dCallbacks,
                                      &D3dDriverData,
                                      &D3dBufferCallbacks,
                                      pD3dTextureFormats,
                                      &dwNumHeaps,
                                      pVideoMemoryList,
                                      &dwNumFourCC,
                                      pdwFourCC))
    {
        if (pVideoMemoryList != NULL)
            LocalFree(pVideoMemoryList);

        return(FALSE);
    }

    // Convert from the kernel-mode data structures to the user-mode
    // ones:

    memset(pHalInfo, 0, sizeof(DDHALINFO));

    pHalInfo->dwSize                   = sizeof(DDHALINFO);
    pHalInfo->lpDDCallbacks            = pDDCallBacks;
    pHalInfo->lpDDSurfaceCallbacks     = pDDSurfaceCallBacks;
    pHalInfo->lpDDPaletteCallbacks     = pDDPaletteCallBacks;
    if (D3dCallbacks.dwSize != 0 && D3dDriverData.dwSize != 0)
    {
        pHalInfo->lpD3DGlobalDriverData = (LPVOID)pD3dDriverData;
        pHalInfo->lpD3DHALCallbacks     = (LPVOID)pD3dCallbacks;
        if( D3dBufferCallbacks.dwSize != 0 )
            pHalInfo->lpDDExeBufCallbacks     = (LPDDHAL_DDEXEBUFCALLBACKS)pD3dBufferCallbacks;
    }
    pHalInfo->vmiData.fpPrimary        = 0;
    pHalInfo->vmiData.dwFlags          = HalInfo.vmiData.dwFlags;
    pHalInfo->vmiData.dwDisplayWidth   = HalInfo.vmiData.dwDisplayWidth;
    pHalInfo->vmiData.dwDisplayHeight  = HalInfo.vmiData.dwDisplayHeight;
    pHalInfo->vmiData.lDisplayPitch    = HalInfo.vmiData.lDisplayPitch;
    pHalInfo->vmiData.ddpfDisplay      = HalInfo.vmiData.ddpfDisplay;
    pHalInfo->vmiData.dwOffscreenAlign = HalInfo.vmiData.dwOffscreenAlign;
    pHalInfo->vmiData.dwOverlayAlign   = HalInfo.vmiData.dwOverlayAlign;
    pHalInfo->vmiData.dwTextureAlign   = HalInfo.vmiData.dwTextureAlign;
    pHalInfo->vmiData.dwZBufferAlign   = HalInfo.vmiData.dwZBufferAlign;
    pHalInfo->vmiData.dwAlphaAlign     = HalInfo.vmiData.dwAlphaAlign;
    pHalInfo->vmiData.dwNumHeaps       = dwNumHeaps;
    pHalInfo->vmiData.pvmList          = pvmList;

    ASSERTGDI(sizeof(pHalInfo->ddCaps) == sizeof(HalInfo.ddCaps),
              "DdQueryDirectDrawObject():DDCORECAPS structure size is not equal to DDNTCORECAPS\n");
    RtlCopyMemory(&(pHalInfo->ddCaps),&(HalInfo.ddCaps),sizeof(HalInfo.ddCaps));

    pHalInfo->ddCaps.dwNumFourCCCodes  = dwNumFourCC;
    pHalInfo->ddCaps.dwRops[0xCC / 32] = 1 << (0xCC % 32);     // Only SRCCOPY
    pHalInfo->lpdwFourCC               = pdwFourCC;
    pHalInfo->dwFlags                  = HalInfo.dwFlags | DDHALINFO_GETDRIVERINFOSET;
    pHalInfo->GetDriverInfo            = DdGetDriverInfo;

    if (pDDCallBacks != NULL)
    {
        memset(pDDCallBacks, 0, sizeof(DDHAL_DDCALLBACKS));

        dwFlags = adwCallBackFlags[0];

        pDDCallBacks->dwSize  = sizeof(DDHAL_DDCALLBACKS);
        pDDCallBacks->dwFlags = dwFlags;

        // Always set CreateSurface so that the kernel mode
        // heap manager has a chance to allocate the surface if
        // necessary.  It will take care of calling the driver
        // if necessary.
        pDDCallBacks->CreateSurface = DdCreateSurface;
        pDDCallBacks->dwFlags |= DDHAL_CB32_CREATESURFACE;

        if (dwFlags & DDHAL_CB32_WAITFORVERTICALBLANK)
            pDDCallBacks->WaitForVerticalBlank = DdWaitForVerticalBlank;

        if (dwFlags & DDHAL_CB32_CANCREATESURFACE)
            pDDCallBacks->CanCreateSurface = DdCanCreateSurface;

        if (dwFlags & DDHAL_CB32_GETSCANLINE)
            pDDCallBacks->GetScanLine = DdGetScanLine;
    }

    if (pDDSurfaceCallBacks != NULL)
    {
        memset(pDDSurfaceCallBacks, 0, sizeof(DDHAL_DDSURFACECALLBACKS));

        dwFlags = adwCallBackFlags[1];

        pDDSurfaceCallBacks->dwSize  = sizeof(DDHAL_DDSURFACECALLBACKS);
        pDDSurfaceCallBacks->dwFlags = (DDHAL_SURFCB32_LOCK
                                      | DDHAL_SURFCB32_UNLOCK
                                      | DDHAL_SURFCB32_SETCOLORKEY
                                      | DDHAL_SURFCB32_DESTROYSURFACE)
                                      | dwFlags;

        pDDSurfaceCallBacks->Lock = DdLock;
        pDDSurfaceCallBacks->Unlock = DdUnlock;
        pDDSurfaceCallBacks->SetColorKey = DdSetColorKey;
        pDDSurfaceCallBacks->DestroySurface = DdDestroySurface;

        if (dwFlags & DDHAL_SURFCB32_FLIP)
            pDDSurfaceCallBacks->Flip = DdFlip;

        if (dwFlags & DDHAL_SURFCB32_BLT)
            pDDSurfaceCallBacks->Blt = DdBlt;

        if (dwFlags & DDHAL_SURFCB32_GETBLTSTATUS)
            pDDSurfaceCallBacks->GetBltStatus = DdGetBltStatus;

        if (dwFlags & DDHAL_SURFCB32_GETFLIPSTATUS)
            pDDSurfaceCallBacks->GetFlipStatus = DdGetFlipStatus;

        if (dwFlags & DDHAL_SURFCB32_UPDATEOVERLAY)
            pDDSurfaceCallBacks->UpdateOverlay = DdUpdateOverlay;

        if (dwFlags & DDHAL_SURFCB32_SETOVERLAYPOSITION)
            pDDSurfaceCallBacks->SetOverlayPosition = DdSetOverlayPosition;

        if (dwFlags & DDHAL_SURFCB32_ADDATTACHEDSURFACE)
            pDDSurfaceCallBacks->AddAttachedSurface = DdAddAttachedSurface;
    }

    if (pDDPaletteCallBacks != NULL)
    {
        memset(pDDPaletteCallBacks, 0, sizeof(DDHAL_DDPALETTECALLBACKS));

        dwFlags = adwCallBackFlags[2];

        pDDPaletteCallBacks->dwSize  = sizeof(DDHAL_DDPALETTECALLBACKS);
        pDDPaletteCallBacks->dwFlags = dwFlags;
    }

    if (pD3dCallbacks != NULL)
    {
        memset(pD3dCallbacks, 0, sizeof(D3DHAL_CALLBACKS));

        if (D3dCallbacks.dwSize > 0)
        {
            pD3dCallbacks->dwSize = sizeof(D3DHAL_CALLBACKS);
            if (D3dCallbacks.ContextCreate != NULL)
            {
                pD3dCallbacks->ContextCreate = D3dContextCreate;
            }
            if (D3dCallbacks.ContextDestroy != NULL)
            {
                pD3dCallbacks->ContextDestroy =
                    (LPD3DHAL_CONTEXTDESTROYCB)NtGdiD3dContextDestroy;
            }
            if (D3dCallbacks.ContextDestroyAll != NULL)
            {
                pD3dCallbacks->ContextDestroyAll =
                    (LPD3DHAL_CONTEXTDESTROYALLCB)NtGdiD3dContextDestroyAll;
            }
            pD3dCallbacks->SceneCapture = NULL;
            pD3dCallbacks->TextureCreate = NULL;
            pD3dCallbacks->TextureDestroy = NULL;
            pD3dCallbacks->TextureSwap = NULL;
            pD3dCallbacks->TextureGetSurf = NULL;
        }
    }

    if (pD3dDriverData != NULL)
    {
        *pD3dDriverData = *(D3DHAL_GLOBALDRIVERDATA *)&D3dDriverData;
        pD3dDriverData->lpTextureFormats = pD3dTextureFormats;
    }

    if (pD3dBufferCallbacks != NULL)
    {
        memset( pD3dBufferCallbacks, 0, sizeof(DDHAL_DDEXEBUFCALLBACKS));

        if (D3dBufferCallbacks.dwSize > 0)
        {
            pD3dBufferCallbacks->dwSize  = sizeof(DDHAL_DDEXEBUFCALLBACKS);
            pD3dBufferCallbacks->dwFlags = D3dBufferCallbacks.dwFlags;
            if (D3dBufferCallbacks.CanCreateD3DBuffer != NULL)
            {
                pD3dBufferCallbacks->CanCreateExecuteBuffer =
                    (LPDDHALEXEBUFCB_CANCREATEEXEBUF)DdCanCreateD3DBuffer;
            }
            if (D3dBufferCallbacks.CreateD3DBuffer != NULL)
            {
                pD3dBufferCallbacks->CreateExecuteBuffer =
                    (LPDDHALEXEBUFCB_CREATEEXEBUF)DdCreateD3DBuffer;
            }
            if (D3dBufferCallbacks.DestroyD3DBuffer != NULL)
            {
                pD3dBufferCallbacks->DestroyExecuteBuffer =
                    (LPDDHALEXEBUFCB_DESTROYEXEBUF)DdDestroyD3DBuffer;
            }
            if (D3dBufferCallbacks.LockD3DBuffer != NULL)
            {
                pD3dBufferCallbacks->LockExecuteBuffer =
                    (LPDDHALEXEBUFCB_LOCKEXEBUF)DdLockD3D;
            }
            if (D3dBufferCallbacks.UnlockD3DBuffer != NULL)
            {
                pD3dBufferCallbacks->UnlockExecuteBuffer =
                    (LPDDHALEXEBUFCB_UNLOCKEXEBUF)DdUnlockD3D;
            }
        }
    }

    if (pVideoMemoryList != NULL)
    {
        pVideoMemory = pVideoMemoryList;

        while (dwNumHeaps-- != 0)
        {
            pvmList->dwFlags    = pVideoMemory->dwFlags;
            pvmList->fpStart    = pVideoMemory->fpStart;
            pvmList->fpEnd      = pVideoMemory->fpEnd;
            pvmList->ddsCaps    = pVideoMemory->ddsCaps;
            pvmList->ddsCapsAlt = pVideoMemory->ddsCapsAlt;
            pvmList->dwHeight   = pVideoMemory->dwHeight;

            pvmList++;
            pVideoMemory++;
        }

        LocalFree(pVideoMemoryList);
    }

    return(TRUE);
#endif // defined(BUILD_WOW6432)    
}

/*****************************Private*Routine******************************\
* DdDeleteDirectDrawObject
*
* Note that all associated surface objects must be deleted before the
* DirectDrawObject can be deleted.
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
DdDeleteDirectDrawObject(                       // AKA 'GdiEntry3'
    LPDDRAWI_DIRECTDRAW_GBL pDirectDrawGlobal
    )
{
    BOOL b = FALSE;

    if (pDirectDrawGlobal->hDD != 0)
    {
        b = NtGdiDdDeleteDirectDrawObject((HANDLE) pDirectDrawGlobal->hDD);
    }
    else if (ghDirectDraw != 0)
    {
        b = TRUE;

        if (--gcDirectDraw == 0)
        {
            b = NtGdiDdDeleteDirectDrawObject(ghDirectDraw);
            ghDirectDraw = 0;
        }
    }

    return(b);
}

/*****************************Private*Routine******************************\
* bDdCreateSurfaceObject
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDdCreateSurfaceObject(
    LPDDRAWI_DDRAWSURFACE_LCL   pSurfaceLocal,
    BOOL                        bComplete
    )
{
    LPDDRAWI_DDRAWSURFACE_GBL   pSurfaceGlobal;
    DD_SURFACE_GLOBAL           SurfaceGlobal;
    DD_SURFACE_LOCAL            SurfaceLocal;
    DD_SURFACE_MORE             SurfaceMore;
    LPATTACHLIST                pAttach;
    BOOL                        bAttached;

    //
    // Wow64 genthnk will automatically thunk these structures, however,
    // since these structures are pointer dependent, we need to make sure
    // to NULL out these pointers so that Wow64 won't thunk them
    //
    RtlZeroMemory(&SurfaceLocal, sizeof(SurfaceLocal));
    RtlZeroMemory(&SurfaceGlobal, sizeof(SurfaceGlobal));
    RtlZeroMemory(&SurfaceMore, sizeof(SurfaceMore));

    SurfaceLocal.dwFlags      = pSurfaceLocal->dwFlags;
    SurfaceLocal.ddsCaps      = pSurfaceLocal->ddsCaps;

    SurfaceMore.ddsCapsEx       = pSurfaceLocal->lpSurfMore->ddsCapsEx;
    SurfaceMore.dwSurfaceHandle = pSurfaceLocal->lpSurfMore->dwSurfaceHandle;

    pSurfaceGlobal = pSurfaceLocal->lpGbl;

    SurfaceGlobal.fpVidMem    = pSurfaceGlobal->fpVidMem;
    SurfaceGlobal.lPitch      = pSurfaceGlobal->lPitch;
    SurfaceGlobal.wHeight     = pSurfaceGlobal->wHeight;
    SurfaceGlobal.wWidth      = pSurfaceGlobal->wWidth;

    // If HASPIXELFORMAT is not set, we have to get the pixel format out
    // of the global DirectDraw object:

    if (pSurfaceLocal->dwFlags & DDRAWISURF_HASPIXELFORMAT)
    {
        SurfaceGlobal.ddpfSurface = pSurfaceGlobal->ddpfSurface;
    }
    else
    {
        SurfaceGlobal.ddpfSurface = pSurfaceGlobal->lpDD->vmiData.ddpfDisplay;
    }

    pSurfaceLocal->hDDSurface = (ULONG_PTR)
                NtGdiDdCreateSurfaceObject(DD_HANDLE(pSurfaceGlobal->lpDD->hDD),
                                           (HANDLE) pSurfaceLocal->hDDSurface,
                                           &SurfaceLocal,
                                           &SurfaceMore,
                                           &SurfaceGlobal,
                                           bComplete);

    return(pSurfaceLocal->hDDSurface != 0);
}

/*****************************Private*Routine******************************\
* DdCreateSurfaceObject
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
DdCreateSurfaceObject(                          // AKA 'GdiEntry4'
    LPDDRAWI_DDRAWSURFACE_LCL   pSurfaceLocal,
    BOOL                        bUnused
    )
{
    // TRUE means surface is now complete:

    return(bDdCreateSurfaceObject(pSurfaceLocal, TRUE));
}

/*****************************Private*Routine******************************\
* DdDeleteSurfaceObject
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
DdDeleteSurfaceObject(                          // AKA 'GdiEntry5'
    LPDDRAWI_DDRAWSURFACE_LCL pSurfaceLocal
    )
{
    BOOL b;

    b = TRUE;

    if (pSurfaceLocal->hDDSurface != 0)
    {
        b = NtGdiDdDeleteSurfaceObject((HANDLE) pSurfaceLocal->hDDSurface);
        pSurfaceLocal->hDDSurface = 0;  // Needed so CreateSurfaceObject works
    }

    return(b);
}

/*****************************Private*Routine******************************\
* DdResetVisrgn
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
DdResetVisrgn(                                  // AKA 'GdiEntry6'
    LPDDRAWI_DDRAWSURFACE_LCL pSurfaceLocal,
    HWND                      hWnd
    )
{
    return(NtGdiDdResetVisrgn((HANDLE) pSurfaceLocal->hDDSurface, hWnd));
}

/*****************************Private*Routine******************************\
* DdGetDC
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

HDC
APIENTRY
DdGetDC(                                        // AKA 'GdiEntry7'
    LPDDRAWI_DDRAWSURFACE_LCL pSurfaceLocal,
    LPPALETTEENTRY            pPalette
    )
{
    return(NtGdiDdGetDC((HANDLE) pSurfaceLocal->hDDSurface, pPalette));
}

/*****************************Private*Routine******************************\
* DdReleaseDC
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
DdReleaseDC(
    LPDDRAWI_DDRAWSURFACE_LCL pSurfaceLocal     // AKA 'GdiEntry8'
    )
{
    return(NtGdiDdReleaseDC((HANDLE) pSurfaceLocal->hDDSurface));
}

/******************************Public*Routine******************************\
* DdCreateDIBSection
*
* Cloned from CreateDIBSection.
*
* The only difference from CreateDIBSection is that at 8bpp, we create the
* DIBSection to act like a device-dependent bitmap and don't create a palette.
* This way, the application is always ensured an identity translate on a blt,
* and doesn't have to worry about GDI's goofy colour matching.
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

HBITMAP
APIENTRY
DdCreateDIBSection(                             // AKA 'GdiEntry9'
    HDC               hdc,
    CONST BITMAPINFO* pbmi,
    UINT              iUsage,
    VOID**            ppvBits,
    HANDLE            hSectionApp,
    DWORD             dwOffset
    )
{
    HBITMAP hbm = NULL;
    PVOID   pjBits = NULL;
    BITMAPINFO * pbmiNew = NULL;
    INT     cjHdr;

    pbmiNew = pbmiConvertInfo(pbmi, iUsage, &cjHdr, FALSE);

    // dwOffset has to be a multiple of 4 (sizeof(DWORD))
    // if there is a section.  If the section is NULL we do
    // not care

    if ( (hSectionApp == NULL) ||
         ((dwOffset & 3) == 0) )
    {
        hbm = NtGdiCreateDIBSection(
                                hdc,
                                hSectionApp,
                                dwOffset,
                                (LPBITMAPINFO) pbmiNew,
                                iUsage,
                                cjHdr,
                                CDBI_NOPALETTE,
                                0,
                                (PVOID *)&pjBits);

        if ((hbm == NULL) || (pjBits == NULL))
        {
            hbm = 0;
            pjBits = NULL;
        }
#if TRACE_SURFACE_ALLOCS
        else
        {
            PULONG  pUserAlloc;

            PSHARED_GET_VALIDATE(pUserAlloc, hbm, SURF_TYPE);

            if (pUserAlloc != NULL)
            {
                pUserAlloc[1] = RtlWalkFrameChain((PVOID *)&pUserAlloc[2], pUserAlloc[0], 0);
            }
        }
#endif

    }

    // Assign the appropriate value to the caller's pointer

    if (ppvBits != NULL)
    {
        *ppvBits = pjBits;
    }

    if (pbmiNew && (pbmiNew != pbmi))
        LocalFree(pbmiNew);

    return(hbm);
}

/*****************************Private*Routine******************************\
* DdReenableDirectDrawObject
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
DdReenableDirectDrawObject(                     // AKA 'GdiEntry10'
    LPDDRAWI_DIRECTDRAW_GBL pDirectDrawGlobal,
    BOOL*                   pbNewMode
    )
{
#if defined(BUILD_WOW6432)
    //
    // No Accelerated HW under WOW64
    //
    
    //
    // Imitate parameter usage to prevent compiler warning
    //
    UNREFERENCED_PARAMETER(pDirectDrawGlobal);
    UNREFERENCED_PARAMETER(pbNewMode);
    
    return(FALSE);
#else
    return(NtGdiDdReenableDirectDrawObject(DD_HANDLE(pDirectDrawGlobal->hDD),
                                           pbNewMode));
#endif // defined(BUILD_WOW6432)                              
}

/*****************************Private*Routine******************************\
* DdAttachSurface
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
DdAttachSurface(                                // AKA 'GdiEntry11'
    LPDDRAWI_DDRAWSURFACE_LCL   pSurfaceFrom,
    LPDDRAWI_DDRAWSURFACE_LCL   pSurfaceTo
    )
{
    BOOL bRet = TRUE;

    // We may be called to attach the surfaces before the kernel objects
    // have been created; if so, create a kernel surface on the fly but
    // mark it as incomplete:

    // must test failure case for leak

    if (pSurfaceFrom->hDDSurface == 0)
    {
        bRet &= bDdCreateSurfaceObject(pSurfaceFrom, FALSE);
    }
    if (pSurfaceTo->hDDSurface == 0)
    {
        bRet &= bDdCreateSurfaceObject(pSurfaceTo, FALSE);
    }
    if (bRet)
    {
        bRet = NtGdiDdAttachSurface((HANDLE) pSurfaceFrom->hDDSurface,
                                    (HANDLE) pSurfaceTo->hDDSurface);
    }

    return(bRet);
}

/*****************************Private*Routine******************************\
* DdUnattachSurface
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DdUnattachSurface(                              // AKA 'GdiEntry12'
    LPDDRAWI_DDRAWSURFACE_LCL   pSurface,
    LPDDRAWI_DDRAWSURFACE_LCL   pSurfaceAttached
    )
{
    NtGdiDdUnattachSurface((HANDLE) pSurface->hDDSurface,
                           (HANDLE) pSurfaceAttached->hDDSurface);
}

/*****************************Private*Routine******************************\
* DdQueryDisplaySettingsUniqueness
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

ULONG
APIENTRY
DdQueryDisplaySettingsUniqueness(               // AKA 'GdiEntry13'
    VOID
    )
{
    return(pGdiSharedMemory->iDisplaySettingsUniqueness);
}

/*****************************Private*Routine******************************\
* DdGetDxHandle
*
* History:
*  18-Oct-1997 -by- smac
* Wrote it.
\**************************************************************************/

HANDLE
APIENTRY
DdGetDxHandle(                  // AKA 'GdiEntry14'
    LPDDRAWI_DIRECTDRAW_LCL pDDraw,
    LPDDRAWI_DDRAWSURFACE_LCL   pSurface,
    BOOL    bRelease
    )
{
    if( pSurface != NULL )
    {
        return( NtGdiDdGetDxHandle( NULL, (HANDLE)(pSurface->hDDSurface),
            bRelease ) );
    }
    return( NtGdiDdGetDxHandle( DD_HANDLE(pDDraw->lpGbl->hDD), NULL,
        bRelease ) );
}

/*****************************Private*Routine******************************\
* DdSetGammaRamp
*
* History:
*  18-Oct-1997 -by- smac
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
DdSetGammaRamp(                                  // AKA 'GdiEntry15'
    LPDDRAWI_DIRECTDRAW_LCL pDDraw,
    HDC         hdc,
    LPVOID      lpGammaRamp
    )
{
    return( NtGdiDdSetGammaRamp( DD_HANDLE(pDDraw->lpGbl->hDD), hdc,
        lpGammaRamp ) );
}

/*****************************Private*Routine******************************\
* DdSwapTextureHandles
*
* History:
*  17-Nov-1998 -by- anankan
* Wrote it.
\**************************************************************************/

ULONG
APIENTRY
DdSwapTextureHandles(                            // AKA 'GdiEntry16'
    LPDDRAWI_DIRECTDRAW_LCL    pDDLcl,
    LPDDRAWI_DDRAWSURFACE_LCL  pDDSLcl1,
    LPDDRAWI_DDRAWSURFACE_LCL  pDDSLcl2
    )
{
    //this entry is going away now that CreateSurfaceEx is added
    return DDHAL_DRIVER_HANDLED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\dllinit.c ===
/******************************Module*Header*******************************\
* Module Name: dllinit.c                                                   *
*                                                                          *
* Contains the GDI library initialization routines.                        *
*                                                                          *
* Created: 07-Nov-1990 13:30:31                                            *
* Author: Eric Kutter [erick]                                              *
*                                                                          *
* Copyright (c) 1990-1999 Microsoft Corporation                            *
\**************************************************************************/
#include "precomp.h"
#pragma hdrstop

#include "glsup.h"

extern PVOID pAFRTNodeList;
extern VOID vSetCheckDBCSTrailByte(DWORD dwCodePage);
NTSTATUS GdiProcessSetup();
VOID GdiProcessShutdown();

#ifdef LANGPACK
#include "winuserp.h"
#endif

HBRUSH ghbrDCBrush;
HPEN   ghbrDCPen;

BOOL  gbWOW64 = FALSE;

/******************************Public*Routine******************************\
* GdiDllInitialize                                                         *
*                                                                          *
* This is the init procedure for GDI.DLL, which is called each time a new  *
* process links to it.                                                     *
*                                                                          *
* History:                                                                 *
*  Thu 30-May-1991 18:08:00 -by- Charles Whitmer [chuckwh]                 *
* Added Local Handle Table initialization.                                 *
\**************************************************************************/

#if defined(_GDIPLUS_)

    //
    // The following are globals kept in 'gre':
    //

    extern PGDI_SHARED_MEMORY gpGdiSharedMemory;
    extern PENTRY gpentHmgr;
    extern PDEVCAPS gpGdiDevCaps;

#endif

PGDI_SHARED_MEMORY pGdiSharedMemory = NULL;
PENTRY          pGdiSharedHandleTable = NULL;
PDEVCAPS        pGdiDevCaps = NULL;
W32PID          gW32PID;
UINT            guintAcp;
UINT            guintDBCScp;

PGDIHANDLECACHE pGdiHandleCache;

BOOL gbFirst = TRUE;

#ifdef LANGPACK
BOOL gbLpk = FALSE;
FPLPKEXTEXTOUT              fpLpkExtTextOut;
FPLPKGETCHARACTERPLACEMENT  fpLpkGetCharacterPlacement;
FPLPKGETTEXTEXTENTEXPOINT   fpLpkGetTextExtentExPoint;
FPLPKUSEGDIWIDTHCACHE       fpLpkUseGDIWidthCache;

VOID GdiInitializeLanguagePack(DWORD);
#endif

NTSTATUS GdiDllInitialize(
    PVOID pvDllHandle,
    ULONG ulReason,
    PCONTEXT pcontext)
{
    NTSTATUS Status = STATUS_SUCCESS;
    INT i;
    PTEB pteb = NtCurrentTeb();

    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:

        DisableThreadLibraryCalls(pvDllHandle);

        //
        // force the kernel to initialize.  This should be done last
        // since ClientThreadSetup is going to get called before this returns.
        //

        if (NtGdiInit() != TRUE)
        {
            return(STATUS_NO_MEMORY);
        }

        Status = GdiProcessSetup();

        ghbrDCBrush = GetStockObject (DC_BRUSH);
        ghbrDCPen = GetStockObject (DC_PEN);

#ifdef BUILD_WOW6432
        gbWOW64 = TRUE;
#endif
        break;

    case DLL_PROCESS_DETACH:

        GdiProcessShutdown();
        break;
    }

    return(Status);

    pvDllHandle;
    pcontext;
}

/******************************Public*Routine******************************\
* GdiProcessSetup()
*
* This gets called from two places.  Once at dll init time and another when
* USER gets called back when the kernel initializes itself for this process.
* It is only after the kernel is initialized that the GdiSharedHandleTable
* is available but the other globals need to be setup right away.
*
* History:
*  11-Sep-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

NTSTATUS GdiProcessSetup()
{
    NTSTATUS Status = STATUS_SUCCESS;
    PTEB pteb = NtCurrentTeb();

    // who ever calls this first needs to initialize the global variables.

    if (gbFirst)
    {
        //
        // Initialize the GL metafile support semaphore
        //

        Status = (NTSTATUS)INITIALIZECRITICALSECTION(&semGlLoad);
        if (!NT_SUCCESS(Status))
        {
            WARNING("InitializeCriticalSection failed\n");
            return(Status);
        }

        //
        // Initialize the local semaphore and reserve the Local Handle Table
        // for the process.
        //

        Status = (NTSTATUS)INITIALIZECRITICALSECTION(&semLocal);
        if (!NT_SUCCESS(Status))
        {
            WARNING("InitializeCriticalSection failed\n");
            return(Status);
        }

        //
        // Initialize critical sections for ICM
        //

        Status = (NTSTATUS)INITIALIZECRITICALSECTION(&semListIcmInfo);
        if (!NT_SUCCESS(Status))
        {
            WARNING("InitializeCriticalSection failed\n");
            return(Status);
        }

        Status = (NTSTATUS)INITIALIZECRITICALSECTION(&semColorTransformCache);
        if (!NT_SUCCESS(Status))
        {
            WARNING("InitializeCriticalSection failed\n");
            return(Status);
        }

        Status = (NTSTATUS)INITIALIZECRITICALSECTION(&semColorSpaceCache);
        if (!NT_SUCCESS(Status))
        {
            WARNING("InitializeCriticalSection failed\n");
            return(Status);
        }

        //
        // Initialize critical section for UMPD
        //

        Status = (NTSTATUS)INITIALIZECRITICALSECTION(&semUMPD);
        if (!NT_SUCCESS(Status))
        {
            WARNING("InitializeCriticalSection failed\n");
            return(Status);
        }

        pAFRTNodeList = NULL;
        guintAcp = GetACP();

        if(IS_ANY_DBCS_CODEPAGE(guintAcp))
        {
        // if the default code page is a DBCS code page then set guintACP to 1252
        // since we want to compute client wide widths for SBCS fonts for code page
        // 1252 in addition to DBCS fonts for the default code page

            vSetCheckDBCSTrailByte(guintAcp);
            guintDBCScp = guintAcp;
            guintAcp = 1252;
        }
        else
        {
            guintDBCScp = 0xFFFFFFFF;  // assume this will never be a valid CP
        }

#ifdef FE_SB
        fFontAssocStatus = NtGdiQueryFontAssocInfo(NULL);
#endif

        // assign unique process ID

        gW32PID = (W32PID)((ULONG)((ULONG_PTR)pteb->ClientId.UniqueProcess & PID_BITS));

#ifdef LANGPACK
        if(((PGDI_SHARED_MEMORY) NtCurrentPebShared()->GdiSharedHandleTable)->dwLpkShapingDLLs)
        {
            GdiInitializeLanguagePack(
                ((PGDI_SHARED_MEMORY)
                 NtCurrentPebShared()->GdiSharedHandleTable)->dwLpkShapingDLLs);
        }
#endif

        gbFirst = FALSE;

        //
        // ICM has not been initialized
        //

        ghICM = NULL;

        InitializeListHead(&ListIcmInfo);
        InitializeListHead(&ListCachedColorSpace);
        InitializeListHead(&ListCachedColorTransform);
    }

    // The pshared handle table needs to be set everytime this routine gets
    // called in case the PEB doesn't have it yet for the first.

#if !defined(_GDIPLUS_)

    pGdiSharedMemory      = (PGDI_SHARED_MEMORY) NtCurrentPebShared()->GdiSharedHandleTable;
    pGdiSharedHandleTable = pGdiSharedMemory->aentryHmgr;
    pGdiDevCaps           = &pGdiSharedMemory->DevCaps;

    if (GetAppCompatFlags2(VER40) & GACF2_NOBATCHING)
    {
        GdiBatchLimit = 0;
    }
    else
    {
        GdiBatchLimit         = (NtCurrentPebShared()->GdiDCAttributeList) & 0xff;
    }

    pGdiHandleCache       = (PGDIHANDLECACHE)(&NtCurrentPebShared()->GdiHandleBuffer[0]);

#else

    pGdiSharedMemory      = gpGdiSharedMemory;
    pGdiSharedHandleTable = gpentHmgr;
    pGdiDevCaps           = gpGdiDevCaps;

    //
    // Be sure to disable batching and handle caching.
    //

    GdiBatchLimit = 0;
    pGdiHandleCache = NULL;

#endif

    // @@@ Add TrueType fonts

    #if defined(_GDIPLUS_)

    AddFontResourceW(L"arial.ttf");
    AddFontResourceW(L"cour.ttf");

    #endif // _GDIPLUS_

    return(Status);
}


/******************************Public*Routine******************************\
* GdiProcessShutdown()
*
* Historically, gdi32.dll has allowed process termination to release the
* user-mode resources.  However, some apps may use LoadLibrary/FreeLibrary
* to hook gdi32.dll, in which case the FreeLibrary will not free any of
* the resources.
*
* As a system component, we should do a good job and cleanup after ourselves
* instead of relying on process termination.
*
\**************************************************************************/

VOID GdiProcessShutdown()
{
    if (gbWOW64)
    {
        vUMPDWow64Shutdown();
    }
    DELETECRITICALSECTION(&semUMPD);
    DELETECRITICALSECTION(&semColorSpaceCache);
    DELETECRITICALSECTION(&semColorTransformCache);
    DELETECRITICALSECTION(&semListIcmInfo);
    DELETECRITICALSECTION(&semLocal);
    DELETECRITICALSECTION(&semGlLoad);
}


#ifdef LANGPACK
VOID GdiInitializeLanguagePack(DWORD dwLpkShapingDLLs)
{
    FPLPKINITIALIZE fpLpkInitialize;

    HANDLE hLpk = LoadLibraryW(L"LPK.DLL");

    if (hLpk != NULL)
    {
        FARPROC fpUser[4];

        fpLpkInitialize = (FPLPKINITIALIZE)
          GetProcAddress(hLpk,"LpkInitialize");

        fpLpkExtTextOut = (FPLPKEXTEXTOUT)
          GetProcAddress(hLpk,"LpkExtTextOut");

        fpLpkGetCharacterPlacement = (FPLPKGETCHARACTERPLACEMENT)
          GetProcAddress(hLpk,"LpkGetCharacterPlacement");


        fpLpkGetTextExtentExPoint = (FPLPKGETTEXTEXTENTEXPOINT)
          GetProcAddress(hLpk,"LpkGetTextExtentExPoint");

        fpLpkUseGDIWidthCache = (FPLPKUSEGDIWIDTHCACHE)
          GetProcAddress(hLpk,"LpkUseGDIWidthCache");

        fpUser[LPK_TABBED_TEXT_OUT] =
          GetProcAddress(hLpk,"LpkTabbedTextOut");


        fpUser[LPK_PSM_TEXT_OUT] =
          GetProcAddress(hLpk,"LpkPSMTextOut");


        fpUser[LPK_DRAW_TEXT_EX] =
          GetProcAddress(hLpk,"LpkDrawTextEx");

        fpUser[LPK_EDIT_CONTROL] =
          GetProcAddress(hLpk,"LpkEditControl");


        if(fpLpkInitialize &&
           fpLpkExtTextOut &&
           fpLpkGetCharacterPlacement &&
           fpLpkGetTextExtentExPoint &&
           fpLpkUseGDIWidthCache &&
           fpUser[LPK_TABBED_TEXT_OUT] &&
           fpUser[LPK_PSM_TEXT_OUT] &&
           fpUser[LPK_DRAW_TEXT_EX] &&
           fpUser[LPK_EDIT_CONTROL])
        {
            if((*fpLpkInitialize)(dwLpkShapingDLLs))
            {
                gbLpk = TRUE;
                InitializeLpkHooks(fpUser);
            }
            else
            {
                WARNING("gdi32: LPK initialization routine return FALSE\n");
                FreeLibrary(hLpk);
            }
        }
        else
        {
            WARNING("gdi32: one or more require LPK functions missing\n");
            FreeLibrary(hLpk);
        }
    }
    else
    {
        WARNING("gdi32: unable to load LPK\n");
    }

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\fareast.c ===
/******************************Module*Header*******************************\
* Module Name: nlsconv.c                                                   *
*                                                                          *
* DBCS specific routines                                                   *
*                                                                          *
* Created: 15-Mar-1994 15:56:30                                            *
* Author: Gerrit van Wingerden [gerritv]                                   *
*                                                                          *
* Copyright (c) 1994-1999 Microsoft Corporation                            *
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

UINT fFontAssocStatus = 0;

BYTE cLowTrailByteSet1 = 0xff;
BYTE cHighTrailByteSet1 = 0x0;
BYTE cLowTrailByteSet2 =  0xff;
BYTE cHighTrailByteSet2 = 0x0;

/******************************Public*Routine******************************\
*                                                                          *
* DBCS Trailling Byte validate check functions.                            *
*                                                                          *
\**************************************************************************/


#define IS_DBCS_TRAIL_BYTE(Char) (\
                                   ((Char >= cLowTrailByteSet1) && (Char <= cHighTrailByteSet1)) \
                                 ||((Char >= cLowTrailByteSet2) && (Char <= cHighTrailByteSet2)) \
                                 )

/**************************************************************************\
*                                                                          *
* SHIFT-JIS (Japanese) character set : CodePage 932                        *
*                                                                          *
*  Valid LeadByte Range   | Valid TailByte Range                           *
*  -----------------------+---------------------                           *
*  From  -> To            |  From  -> To                                   *
*  - - - - - - - - - - - - - - - - - - - - - - -                           *
*  0x81  -> 0x9F          |  0x40  -> 0xFC                                 *
*  0xE0  -> 0xFC          |                                                *
*                                                                          *
\**************************************************************************/

/**************************************************************************\
*                                                                          *
* WANSANG (Korean) character set : CodePage 949                            *
*                                                                          *
*  Valid LeadByte Range   | Valid TailByte Range                           *
*  -----------------------+---------------------                           *
*  From  -> To            |  From  -> To                                   *
*  - - - - - - - - - - - - - - - - - - - - - - -                           *
*  0xA1  -> 0xAC          |  0x40  -> 0xFC                                 *
*  0xB0  -> 0xC8          |                                                *
*  0xCA  -> 0xFD          |                                                *
*                                                                          *
\**************************************************************************/

/**************************************************************************\
*                                                                          *
* GB2312 (PRC Chinese) character set : CodePage 936                        *
*                                                                          *
*  Valid LeadByte Range   | Valid TailByte Range                           *
*  -----------------------+---------------------                           *
*  From  -> To            |  From  -> To                                   *
*  - - - - - - - - - - - - - - - - - - - - - - -                           *
*  0xA1  -> 0xA9          |  0xA1  -> 0xFE                                 *
*  0xB0  -> 0xF7          |                                                *
*                                                                          *
\**************************************************************************/

/**************************************************************************\
*                                                                          *
* Big 5 (Taiwan,Hong Kong Chinese) character set : CodePage 950            *
*                                                                          *
*  Valid LeadByte Range   | Valid TailByte Range                           *
*  -----------------------+---------------------                           *
*  From  -> To            |  From  -> To                                   *
*  - - - - - - - - - - - - - - - - - - - - - - -                           *
*  0x81  -> 0xFE          |  0x40  -> 0x7E                                 *
*                         |  0xA1  -> 0xFE                                 *
*                                                                          *
\**************************************************************************/

/******************************Public*Routine******************************\
* vSetCheckDBCSTrailByte()
*
* This function setup function for the DBCS trailling byte validation of
* specified character with specified Fareast codepage.
*
*  Thu-15-Feb-1996 11:59:00 -by- Gerrit van Wingerden
* Moved function pointer out of CFONT and into a global variable.
*
*  Wed 20-Dec-1994 10:00:00 -by- Hideyuki Nagase [hideyukn]
* Write it.
\**************************************************************************/

VOID vSetCheckDBCSTrailByte(DWORD dwCodePage)
{
    switch( dwCodePage )
    {
    case 932:
        cLowTrailByteSet1 = (CHAR) 0x40;
        cHighTrailByteSet1 = (CHAR) 0xfc;
        cLowTrailByteSet2 = (CHAR) 0x40;
        cHighTrailByteSet2 = (CHAR) 0xfc;
        break;

    case 949:
        cLowTrailByteSet1 = (CHAR) 0x40;
        cHighTrailByteSet1 = (CHAR) 0xfc;
        cLowTrailByteSet2 = (CHAR) 0x40;
        cHighTrailByteSet2 = (CHAR) 0xfc;
        break;

    case  936:
        cLowTrailByteSet1 = (CHAR) 0xa1;
        cHighTrailByteSet1 = (CHAR) 0xfe;
        cLowTrailByteSet2 = (CHAR) 0xa1;
        cHighTrailByteSet2 = (CHAR) 0xfe;
        break;

    case 950:
        cLowTrailByteSet1 = (CHAR) 0x40;
        cHighTrailByteSet1 = (CHAR) 0x7e;
        cLowTrailByteSet2 = (CHAR) 0xa1;
        cHighTrailByteSet2 = (CHAR) 0xfe;
        break;

    default:
        cLowTrailByteSet1 = (CHAR) 0xff;
        cHighTrailByteSet1 = (CHAR) 0x0;
        cLowTrailByteSet2 = (CHAR) 0xff;
        cHighTrailByteSet2 = (CHAR) 0x0;
        WARNING("GDI32!INVALID DBCS codepage\n");
        break;
    }
}


/******************************Public*Routine******************************\
* bComputeCharWidthsDBCS
*
* Client side version of GetCharWidth for DBCS fonts
*
*  Wed 18-Aug-1993 10:00:00 -by- Gerrit van Wingerden [gerritv]
* Stole it and converted for DBCS use.
*
*  Sat 16-Jan-1993 04:27:19 -by- Charles Whitmer [chuckwh]
* Wrote bComputeCharWidths on which this is based.
\**************************************************************************/

BOOL bComputeCharWidthsDBCS
(
    CFONT *pcf,
    UINT   iFirst,
    UINT   iLast,
    ULONG  fl,
    PVOID  pv
)
{
    USHORT *ps;
    USHORT ausWidths[256];
    UINT    ii, cc;

    if( iLast - iFirst  > 0xFF )
    {
        WARNING("bComputeCharWidthsDBCS iLast - iFirst > 0xFF" );
        return(FALSE);
    }

    if( iLast < iFirst )
    {
        WARNING("bComputeCharWidthsDBCS iLast < iFirst" );
        return(FALSE);
    }

    // We want to compute the same widths that would be computed if
    // vSetUpUnicodeStringx were called with this first and last and then
    // GetCharWidthsW was called. The logic may be wierd but I assume it is
    // there for Win 3.1J char widths compatability. To do this first fill
    // in the plain widths in ausWidths and then do all the neccesary
    // computation on them.

    if ( gpwcDBCSCharSet[(UCHAR)(iFirst>>8)] == 0xFFFF )
    {
        for( cc = 0 ; cc <= iLast - iFirst; cc++ )
        {
        // If this is a legitimate DBCS character then use
        // MaxCharInc.

            ausWidths[cc] = pcf->wd.sDBCSInc;
        }
    }
    else
    {
        for( ii = (iFirst & 0x00FF), cc = 0; ii <= (iLast & 0x00FF); cc++, ii++ )
        {
        // Just treat everything as a single byte unless we
        // encounter a DBCS lead byte which we will treat as a
        // default character.

            if( gpwcDBCSCharSet[ii] == 0xFFFF )
            {
                ausWidths[cc] = pcf->wd.sDefaultInc;
            }
            else
            {
                ausWidths[cc] = pcf->sWidth[ii];
            }
        }
    }

    switch (fl & (GCW_INT | GCW_16BIT))
    {
    case GCW_INT:               // Get LONG widths.
        {
            LONG *pl = (LONG *) pv;
            LONG fxOverhang = 0;

        // Check for Win 3.1 compatibility.

            if (fl & GCW_WIN3)
                fxOverhang = pcf->wd.sOverhang;

        // Do the trivial no-transform case.

            if (bIsOneSixteenthEFLOAT(pcf->efDtoWBaseline))
            {
                fxOverhang += 8;    // To round the final result.

            //  for (ii=iFirst; ii<=iLast; ii++)
            //      *pl++ = (pcf->sWidth[ii] + fxOverhang) >> 4;

                ps = ausWidths;
                ii = iLast - iFirst;
            unroll_1:
                switch(ii)
                {
                default:
                    pl[4] = (ps[4] + fxOverhang) >> 4;
                case 3:
                    pl[3] = (ps[3] + fxOverhang) >> 4;
                case 2:
                    pl[2] = (ps[2] + fxOverhang) >> 4;
                case 1:
                    pl[1] = (ps[1] + fxOverhang) >> 4;
                case 0:
                    pl[0] = (ps[0] + fxOverhang) >> 4;
                }
                if (ii > 4)
                {
                    ii -= 5;
                    pl += 5;
                    ps += 5;
                    goto unroll_1;
                }
                return(TRUE);
            }

        // Otherwise use the back transform.

            else
            {
                for (ii=0; ii<=iLast-iFirst; ii++)
                    *pl++ = lCvt(pcf->efDtoWBaseline,ausWidths[ii] + fxOverhang);
                return(TRUE);
            }
        }

    case GCW_INT+GCW_16BIT:     // Get SHORT widths.
        {
            USHORT *psDst = (USHORT *) pv;
            USHORT  fsOverhang = 0;

        // Check for Win 3.1 compatibility.

            if (fl & GCW_WIN3)
                fsOverhang = pcf->wd.sOverhang;

        // Do the trivial no-transform case.

            if (bIsOneSixteenthEFLOAT(pcf->efDtoWBaseline))
            {
                fsOverhang += 8;    // To round the final result.

            //  for (ii=iFirst; ii<=iLast; ii++)
            //      *psDst++ = (pcf->sWidth[ii] + fsOverhang) >> 4;

                ps = ausWidths;
                ii = iLast - iFirst;
            unroll_2:
                switch(ii)
                {
                default:
                    psDst[4] = (ps[4] + fsOverhang) >> 4;
                case 3:
                    psDst[3] = (ps[3] + fsOverhang) >> 4;
                case 2:
                    psDst[2] = (ps[2] + fsOverhang) >> 4;
                case 1:
                    psDst[1] = (ps[1] + fsOverhang) >> 4;
                case 0:
                    psDst[0] = (ps[0] + fsOverhang) >> 4;
                }
                if (ii > 4)
                {
                    ii -= 5;
                    psDst += 5;
                    ps += 5;
                    goto unroll_2;
                }
                return(TRUE);
            }

        // Otherwise use the back transform.

            else
            {
                for (ii=0; ii<=iLast-iFirst; ii++)
                {
                    *psDst++ = (USHORT)
                               lCvt
                               (
                                   pcf->efDtoWBaseline,
                                   (LONG) (ausWidths[ii] + fsOverhang)
                               );
                }
                return(TRUE);
            }
        }

    case 0:                     // Get FLOAT widths.
        {
            LONG *pe = (LONG *) pv; // Cheat to avoid expensive copies.
            EFLOAT_S efWidth,efWidthLogical;

            for (ii=0; ii<=iLast-iFirst; ii++)
            {
                vFxToEf((LONG) ausWidths[ii],efWidth);
                vMulEFLOAT(efWidthLogical,efWidth,pcf->efDtoWBaseline);
                *pe++ = lEfToF(efWidthLogical);
            }
            return(TRUE);
        }
    }
    RIP("bComputeCharWidths: Don't come here!\n");
    return(FALSE);
}

BOOL bIsDBCSString
(
    LPCSTR psz,
    int    cc
)
{
    int   ii;
    BYTE *pc;

    pc = (BYTE *) psz;

    cc--; // do not go off the edge !

    for (ii=0; ii<cc; ii++)
    {
    // if DBCS lead byte add in DBCS width

        if((gpwcDBCSCharSet[pc[ii]] == 0xFFFF)) // is this a DBCS LeadByte
        {
            return TRUE;
        }
    }

    return FALSE;
}

/******************************Public*Routine******************************\
* bComputeTextExtentDBCS (pldc,pcf,psz,cc,fl,psizl)
*
* A quick function to compute text extents on the client side for DBCS
* fonts.
*
*  Tue 17-Aug-1993 10:00:00 -by- Gerrit van Wingerden [gerritv]
* Stole it and converted for DBCS use.
*
*  Thu 14-Jan-1993 04:00:57 -by- Charles Whitmer [chuckwh]
* Wrote bComputeTextExtent from which this was stolen.
\**************************************************************************/

BOOL bComputeTextExtentDBCS
(
    PDC_ATTR    pDcAttr,
    CFONT *pcf,
    LPCSTR psz,
    int    cc,
    UINT   fl,
    SIZE  *psizl
)
{
    LONG  fxBasicExtent;
    INT   lTextExtra,lBreakExtra,cBreak;
    INT   cChars = 0;
    int   ii;
    BYTE *pc;
    FIX   fxCharExtra = 0;
    FIX   fxBreakExtra;
    FIX   fxExtra = 0;

    lTextExtra = pDcAttr->lTextExtra;
    lBreakExtra = pDcAttr->lBreakExtra;
    cBreak = pDcAttr->cBreak;

    pc = (BYTE *) psz;

// Compute the basic extent.

    fxBasicExtent = 0;
    pc = (BYTE *) psz;

    for (ii=0; ii<cc; ii++)
    {
    // if DBCS lead byte add in DBCS width

        if( /* Check the string has two bytes or more ? */
            cc - ii - 1 &&
            /* Check Is this a DBCS LeadByte ? */
            gpwcDBCSCharSet[*pc] == 0xFFFF &&
            /* Check Is this a DBCS TrailByte ? */
            IS_DBCS_TRAIL_BYTE((*(pc+sizeof(CHAR))))
          )
        {
            ii++;
            pc += 2;
            fxBasicExtent += pcf->wd.sDBCSInc;
        }
        else
        {
            fxBasicExtent += pcf->sWidth[*pc++];
        }

        cChars += 1;
    }

// Adjust for CharExtra.

    if (lTextExtra)
    {
        int cNoBackup = 0;

        fxCharExtra = lCvt(pcf->efM11,lTextExtra);

        if( fxCharExtra < 0 )
        {
        // the layout code won't backup a characters past it's origin regardless
        // of the value of iTextCharExtra so figure out for how many values
        // we will need to ignore fxCharExtra

            if( pcf->wd.sCharInc == 0 )
            {
                for( ii = 0; ii < cc; ii++ )
                {
                    if( gpwcDBCSCharSet[(BYTE)psz[ii]] == 0xFFFF )
                    {
                        if( pcf->wd.sDBCSInc + fxCharExtra <= 0 )
                        {
                            cNoBackup += 1;
                        }
                        ii++;
                    }
                    else
                    {
                        if( pcf->sWidth[(BYTE)psz[ii]] + fxCharExtra <= 0 )
                        {
                            cNoBackup += 1;
                        }
                    }
                }
            }
            else
            if( pcf->wd.sCharInc + fxCharExtra <= 0 )
            {
                cNoBackup = cChars;
            }
        }

        if ( (fl & GGTE_WIN3_EXTENT) && (pcf->hdc == 0)
            && (!(pcf->flInfo & FM_INFO_TECH_STROKE)) )
            fxExtra = fxCharExtra * ((lTextExtra > 0) ? cChars : (cChars - 1));
        else
            fxExtra = fxCharExtra * ( cChars - cNoBackup );
    }

// Adjust for lBreakExtra.

    if (lBreakExtra && cBreak)
    {
        fxBreakExtra = lCvt(pcf->efM11,lBreakExtra) / cBreak;

    // Windows won't let us back up over a break.  Set up the BreakExtra
    // to just cancel out what we've already got.

        if (fxBreakExtra + pcf->wd.sBreak + fxCharExtra < 0)
            fxBreakExtra = -(pcf->wd.sBreak + fxCharExtra);

    // Add it up for all breaks.

        pc = (BYTE *) psz;
        for (ii=0; ii<cc; ii++)
        {
            if (gpwcDBCSCharSet[*pc] == 0xFFFF)
            {
                ii++;
                pc += 2;
            }
            else if (*pc++ == pcf->wd.iBreak)
            {
                fxExtra += fxBreakExtra;
            }
        }
    }

// Add in the extra stuff.

    fxBasicExtent += fxExtra;

// Add in the overhang for font simulations.

    if (fl & GGTE_WIN3_EXTENT)
        fxBasicExtent += pcf->wd.sOverhang;

// Transform the result to logical coordinates.

    if (bIsOneSixteenthEFLOAT(pcf->efDtoWBaseline))
        psizl->cx = (fxBasicExtent + 8) >> 4;
    else
        psizl->cx = lCvt(pcf->efDtoWBaseline,fxBasicExtent);

    psizl->cy = pcf->lHeight;

    return(TRUE);
}


/******************************Public*Routine*****************************\
* QueryFontAssocStatus()                                                  *
*                                                                         *
* History:                                                                *
*  05-Jan-1994 -by- Pi-Sui Hsu [pisuih]                                   *
* Wrote it.                                                               *
\*************************************************************************/

UINT APIENTRY QueryFontAssocStatus( VOID )
{
    return(fFontAssocStatus);
}

INT APIENTRY GetFontAssocStatus( HDC hdc )
{
    if(hdc == NULL)
    {
        return(0);
    }
    else
    {
        return(NtGdiQueryFontAssocInfo(hdc));
    }
}


BOOL bToUnicodeNx(LPWSTR pwsz, LPCSTR psz, DWORD c, UINT codepage)
{

    if(fFontAssocStatus &&
       ((codepage == GetACP() || codepage == CP_ACP)) &&
       ((c == 1) || ((c == 2 && *(psz) && *((LPCSTR)(psz + 1)) == '\0'))))
    {
    //
    // If this function is called with only 1 char, and font association
    // is enabled, we should forcely convert the chars to Unicode with
    // codepage 1252.
    // This is for enabling to output Latin-1 chars ( > 0x80 in Ansi codepage )
    // Because, normally font association is enabled, we have no way to output
    // those charactres, then we provide the way, if user call TextOutA() with
    // A character and ansi font, we tempotary disable font association.
    // This might be Windows 3.1 (Korean/Taiwanese) version compatibility..
    //

        codepage = 1252;
    }

    if(MultiByteToWideChar(codepage, 0, psz, c, pwsz, c))
    {
        return(TRUE);
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }
}




/******************************Public*Routine******************************\
*
* vSetUpUnicodeStringx
*
* Effects:
*
* Warnings:
*
* History:
*  14-Mar-1993 -by- Hideyuki Nagase [hideyukn]
* Change hardcoded default character to defulat char is given as a parameter.
*
*  01-Mar-1993 -by- Takao Kitano [takaok]
* Wrote it.
\**************************************************************************/

BOOL bSetUpUnicodeStringDBCS
(
IN  UINT    iFirst,       // first ansi char
IN  UINT    iLast,        // last char
IN  PUCHAR  puchTmp,      // temporary buffer
OUT PWCHAR  pwc,          // output fuffer with a unicode string
IN  UINT    uiCodePage,   // ansi codepage
IN  CHAR    chDefaultChar // default character
)
{
    PUCHAR  puchBuf;
    BOOL bRet = FALSE;

    puchBuf = puchTmp;

    if(IsDBCSLeadByteEx(uiCodePage,(UCHAR)(iFirst >> 8)))
    {

        // This is DBCS character strings.

        for (; iFirst <= iLast; iFirst++ )
        {
            *puchBuf++ = (UCHAR)(iFirst >> 8);
            *puchBuf++ = (UCHAR)(iFirst);
        }
    }
    else
    {

    // This is SBCS character strings.
    // if Hi-byte of iFirst is not valid DBCS LeadByte , we use only
    // lo-byte of it.

        for ( ; iFirst <= iLast; iFirst++ )
        {

        // If this SBCS code in LeadByte area . It replce with default
        // character

            if ( IsDBCSLeadByteEx(uiCodePage,(UCHAR)iFirst) )
              *puchBuf++ = chDefaultChar;
            else
              *puchBuf++ = (UCHAR)iFirst;
        }
    }

    //Sundown: safe to truncate to DWORD since puchBug - puchTmp won't exceed iLast
    bRet = bToUnicodeNx(pwc, puchTmp, (DWORD)(puchBuf - puchTmp), uiCodePage);

    return(bRet);
}


BOOL IsValidDBCSRange( UINT iFirst , UINT iLast )
{
// DBCS & SBCS char parameter checking for DBCS font

    if( iFirst > 0x00ff )
    {
        // DBCS char checking for DBCS font
        if (
           // Check limit
             (iFirst > 0xffff) || (iLast > 0xffff) ||

           // DBCSLeadByte shoud be same
             (iFirst & 0xff00) != (iLast & 0xff00) ||

           // DBCSTrailByte of the First should be >= one of the Last
             (iFirst & 0x00ff) >  (iLast & 0x00ff)
           )
        {
            return(FALSE);
        }
    }

// DBCS char checking for DBCS font

    else if( (iFirst > iLast) || (iLast & 0xffffff00) )
    {
        return(FALSE);
    }

    return(TRUE);
}


/******************************Private*Routine*****************************\
* GetCurrentDefaultChar()
*
* History:
*
*  Mon 15-Mar-1993 18:14:00 -by- Hideyuki Nagase
* wrote it.
***************************************************************************/

BYTE GetCurrentDefaultChar(HDC hdc)
{

    // WINBUG 365031 4-10-2001 pravins Consider optimization in GetCurrentDeafultChar
    //
    // Old Comment:
    //   - This is slow for now.  We should cache this value locally in the dcattr
    //     but want to get other things working for now. [gerritv] 2-22-96

    TEXTMETRICA tma;

    GetTextMetricsA( hdc , &tma );

    return(tma.tmDefaultChar);
}


/***************************************************************************
 * ConvertDxArray(UINT, char*, INT*, UINT, INT*)
 *
 * Tue 27-Feb-1996 23:45:00 -by- Gerrit van Wingerden [gerritv]
 *
 ***************************************************************************/

void ConvertDxArray(UINT CodePage,
                    char *pDBCSString,
                    INT *pDxDBCS,
                    UINT Count,
                    INT *pDxUnicode,
                    BOOL bPdy
)
{
    char *pDBCSStringEnd;

    if (!bPdy)
    {

        for(pDBCSStringEnd = pDBCSString + Count;
            pDBCSString < pDBCSStringEnd;
            )
        {
            if(IsDBCSLeadByteEx(CodePage,*pDBCSString))
            {
                pDBCSString += 2;
                *pDxUnicode = *pDxDBCS++;
                *pDxUnicode += *pDxDBCS++;
            }
            else
            {
                pDBCSString += 1;
                *pDxUnicode = *pDxDBCS++;
            }

            pDxUnicode += 1;
        }
    }
    else
    {
        POINTL *pdxdyUnicode = (POINTL *)pDxUnicode;
        POINTL *pdxdyDBCS    = (POINTL *)pDxDBCS;

        for(pDBCSStringEnd = pDBCSString + Count;
            pDBCSString < pDBCSStringEnd;
            )
        {
            if(IsDBCSLeadByteEx(CodePage,*pDBCSString))
            {
                pDBCSString += 2;
                *pdxdyUnicode = *pdxdyDBCS++;
                pdxdyUnicode->x += pdxdyDBCS->x;
                pdxdyUnicode->y += pdxdyDBCS->y;
                pdxdyDBCS++;
            }
            else
            {
                pDBCSString += 1;
                *pdxdyUnicode = *pdxdyDBCS++;
            }

            pdxdyUnicode++;
        }
    }
}





ULONG APIENTRY EudcLoadLinkW
(
    LPCWSTR  pBaseFaceName,
    LPCWSTR  pEudcFontPath,
    INT      iPriority,
    INT      iFontLinkType
)
{
    return(NtGdiEudcLoadUnloadLink(pBaseFaceName,
                                   (pBaseFaceName) ? wcslen(pBaseFaceName) : 0,
                                   pEudcFontPath,
                                   wcslen(pEudcFontPath),
                                   iPriority,
                                   iFontLinkType,
                                   TRUE));
}



BOOL APIENTRY EudcUnloadLinkW
(
    LPCWSTR  pBaseFaceName,
    LPCWSTR  pEudcFontPath
)
{
    return(NtGdiEudcLoadUnloadLink(pBaseFaceName,
                                  (pBaseFaceName) ? wcslen(pBaseFaceName) : 0,
                                  pEudcFontPath,
                                  wcslen(pEudcFontPath),
                                  0,
                                  0,
                                  FALSE));

}



ULONG APIENTRY GetEUDCTimeStampExW
(
    LPCWSTR pBaseFaceName
)
{
    return(NtGdiGetEudcTimeStampEx((LPWSTR) pBaseFaceName,
                                   (pBaseFaceName) ? wcslen(pBaseFaceName) : 0,
                                   FALSE));

}


ULONG APIENTRY GetEUDCTimeStamp()
{
    return(NtGdiGetEudcTimeStampEx(NULL,0,TRUE));
}

UINT
GetStringBitmapW(
    HDC             hdc,
    LPWSTR          pwc,
    UINT            cwc,
    UINT            cbData,
    BYTE            *pSB
)
{
    if(cwc != 1)
    {
        return(0);
    }

    return(NtGdiGetStringBitmapW(hdc,pwc,1,(PBYTE) pSB,cbData));
}


UINT
GetStringBitmapA(
    HDC             hdc,
    LPSTR           pc,
    UINT            cch,
    UINT            cbData,
    BYTE            *pSB
)
{
    WCHAR Character[2];

    if(cch > 2 )
    {
        return(0);
    }


    if(MultiByteToWideChar(CP_ACP,0,pc,cch,Character,2)!=1)
    {
        return(0);
    }

    return(GetStringBitmapW(hdc,Character,1,cbData,pSB));
}


DWORD FontAssocHack(DWORD dwCodePage, CHAR *psz, UINT c)
{
// If a Text function is called with only 1 char, and font association
// is enabled, we should forcely convert the chars to Unicode with
// codepage 1252.
// This is for enabling to output Latin-1 chars ( > 0x80 in Ansi codepage )
// Because, normally font association is enabled, we have no way to output
// those charactres, then we provide the way, if user call TextOutA() with
// A character and ansi font, we tempotary disable font association.
// This might be Windows 3.1 (Korean/Taiwanese) version compatibility..


    ASSERTGDI(fFontAssocStatus,
              "FontAssocHack called with FontAssocStatus turned off\n");

    if(((dwCodePage == GetACP() || dwCodePage == CP_ACP)) &&
       ((c == 1) || ((c == 2 && *(psz) && *((LPCSTR)(psz + 1)) == '\0'))))
    {
        return(1252);
    }
    else
    {
        return(dwCodePage);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\dvpe.c ===
/******************************Module*Header*******************************\
* Module Name: ddraw.c
*
* Client side stubs for the private DirectDraw VPE system APIs.
*
* Created: 2-Oct-1996
* Author: Lingyun Wang [LingyunW]
*
* Copyright (c) 1995-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <ddrawi.h>
#include <dvpp.h>

/*****************************Private*Routine******************************\
* CanCreateVideoPort
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
WINAPI
DvpCanCreateVideoPort(
    LPDDHAL_CANCREATEVPORTDATA pCanCreateVideoPort
    )
{
    return(NtGdiDvpCanCreateVideoPort((HANDLE) pCanCreateVideoPort->lpDD->lpGbl->hDD,
                                     (PDD_CANCREATEVPORTDATA)pCanCreateVideoPort));
}

/*****************************Private*Routine******************************\
* CanCreateVideoPort
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
WINAPI
DvpColorControl (
    LPDDHAL_VPORTCOLORDATA pColorControl
    )
{
    return(NtGdiDvpColorControl((HANDLE) pColorControl->lpDD->lpGbl->hDD,
                               (PDD_VPORTCOLORDATA)pColorControl));
}

/*****************************Private*Routine******************************\
* CreateVideoPort
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
WINAPI
DvpCreateVideoPort (
    LPDDHAL_CREATEVPORTDATA pCreateVideoPort
    )
{
    return(NtGdiDvpCreateVideoPort((HANDLE) pCreateVideoPort->lpDD->lpGbl->hDD,
                                  (PDD_CREATEVPORTDATA)pCreateVideoPort));
}

/*****************************Private*Routine******************************\
* DestroyVideoPort
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpDestroyVideoPort (
    LPDDHAL_DESTROYVPORTDATA pDestroyVideoPort
)
{
    return(NtGdiDvpDestroyVideoPort((HANDLE) pDestroyVideoPort->lpDD->lpGbl->hDD,
                                  (PDD_DESTROYVPORTDATA)pDestroyVideoPort));
}

/*****************************Private*Routine******************************\
* FlipVideoPort
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpFlipVideoPort (
    LPDDHAL_FLIPVPORTDATA pFlipVideoPort
)
{
    return(NtGdiDvpFlipVideoPort((HANDLE) pFlipVideoPort->lpDD->lpGbl->hDD,
                                (HANDLE) pFlipVideoPort->lpSurfCurr->hDDSurface,
                                (HANDLE) pFlipVideoPort->lpSurfTarg->hDDSurface,
                                (PDD_FLIPVPORTDATA)pFlipVideoPort));
}

/*****************************Private*Routine******************************\
* GetCurrentAutoflipSurface
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpGetCurrentAutoflipSurface (
    LPDDHAL_GETVPORTAUTOFLIPSURFACEDATA pGetCurrentflipSurface)
{
    return(NtGdiDvpGetCurrentAutoflipSurface((HANDLE) pGetCurrentflipSurface->lpDD->lpGbl->hDD,
                                      (PDD_GETVPORTAUTOFLIPSURFACEDATA)pGetCurrentflipSurface));
}

/*****************************Private*Routine******************************\
* GetVideoPortBandwidthInfo
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpGetVideoPortBandwidthInfo (
    LPDDHAL_GETVPORTBANDWIDTHDATA pGetVPortBandwidthInfo)
{
    return(NtGdiDvpGetVideoPortBandwidthInfo((HANDLE) pGetVPortBandwidthInfo->lpDD->lpGbl->hDD,
                                      (PDD_GETVPORTBANDWIDTHDATA)pGetVPortBandwidthInfo));
}


/*****************************Private*Routine******************************\
* GetVideoPortField
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpGetVideoPortField (
    LPDDHAL_GETVPORTFIELDDATA pGetVideoPortField)
{
    return(NtGdiDvpGetVideoPortField((HANDLE) pGetVideoPortField->lpDD->lpGbl->hDD,
                                     (PDD_GETVPORTFIELDDATA)pGetVideoPortField));
}

/*****************************Private*Routine******************************\
* GetVideoPortFlipStatus
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpGetVideoPortFlipStatus (
    LPDDHAL_GETVPORTFLIPSTATUSDATA pGetVPortFlipStatus)
{
    return(NtGdiDvpGetVideoPortFlipStatus((HANDLE) pGetVPortFlipStatus->lpDD->lpGbl->hDD,
                                     (PDD_GETVPORTFLIPSTATUSDATA)pGetVPortFlipStatus));
}

/*****************************Private*Routine******************************\
* GetVideoPortInputFormats
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpGetVideoPortInputFormats (
    LPDDHAL_GETVPORTINPUTFORMATDATA pGetVPortInputFormats)
{
    return(NtGdiDvpGetVideoPortInputFormats((HANDLE) pGetVPortInputFormats->lpDD->lpGbl->hDD,
                                     (PDD_GETVPORTINPUTFORMATDATA)pGetVPortInputFormats));
}


/*****************************Private*Routine******************************\
* GetVideoPortLine
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpGetVideoPortLine (
    LPDDHAL_GETVPORTLINEDATA pGetVideoPortLine)
{
    return(NtGdiDvpGetVideoPortLine((HANDLE) pGetVideoPortLine->lpDD->lpGbl->hDD,
                                   (PDD_GETVPORTLINEDATA)pGetVideoPortLine));
}

/*****************************Private*Routine******************************\
* GetVideoPortOutputFormats
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpGetVideoPortOutputFormats (
    LPDDHAL_GETVPORTOUTPUTFORMATDATA pGetVPortOutputFormats)
{
    return(NtGdiDvpGetVideoPortOutputFormats((HANDLE) pGetVPortOutputFormats->lpDD->lpGbl->hDD,
                                   (PDD_GETVPORTOUTPUTFORMATDATA)pGetVPortOutputFormats));
}

/*****************************Private*Routine******************************\
* GetVideoPortConnectInfo
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpGetVideoPortConnectInfo (
    LPDDHAL_GETVPORTCONNECTDATA pGetVPortConnectInfo)
{
    return(NtGdiDvpGetVideoPortConnectInfo((HANDLE) pGetVPortConnectInfo->lpDD->lpGbl->hDD,
                                   (PDD_GETVPORTCONNECTDATA)pGetVPortConnectInfo));
}

/*****************************Private*Routine******************************\
* GetVideoSignalStatus
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpGetVideoSignalStatus (
    LPDDHAL_GETVPORTSIGNALDATA pGetVideoSignalStatus)
{
    return(NtGdiDvpVideoSignalStatus((HANDLE) pGetVideoSignalStatus->lpDD->lpGbl->hDD,
                                   (PDD_GETVPORTSIGNALDATA)pGetVideoSignalStatus));
}

/*****************************Private*Routine******************************\
* UpdateVideoPort
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpUpdateVideoPort (
    LPDDHAL_UPDATEVPORTDATA pUpdateVideoPort)
{
    // WINBUG #82842 2-7-2000 bhouse Code cleanup in DvpUpdateVideoPort
    // Instead of 100, we should declare (if one does not already exist) a
    // constant for the maximum number of autoflip surfaces.  This value should
    // be checked when pUpdateVideoPort->dwNumAutoflip is set.  An assertion
    // should perhaps be made here to ensure we will not walk pass the end
    // of the stack based arrary.

    HANDLE phDDSurface[100];
    DWORD  i;

    // WINBUG #82844 2-7-2000 bhouse Investigate question in old comment
    // Old Comment
    //   - seems the driver only use lplpDDSurface, why lplpBBVBSurface there?
    
    for (i=0; i< pUpdateVideoPort->dwNumAutoflip; i++)
    {
        phDDSurface[i] = (HANDLE)(pUpdateVideoPort->lplpDDSurface[i]->lpLcl->hDDSurface);
    }

    return(NtGdiDvpUpdateVideoPort((HANDLE) pUpdateVideoPort->lpDD->lpGbl->hDD,
                                  (HANDLE *)phDDSurface,
                                  (PDD_UPDATEVPORTDATA)pUpdateVideoPort));
}


/*****************************Private*Routine******************************\
* WaitForVideoPortSync
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpWaitForVideoPortSync (
    LPDDHAL_WAITFORVPORTSYNCDATA pWaitForVideoPortSync)
{
    return(NtGdiDvpWaitForVideoPortSync((HANDLE) pWaitForVideoPortSync->lpDD->lpGbl->hDD,
                                  (PDD_WAITFORVPORTSYNCDATA)pWaitForVideoPortSync));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\firewall.h ===
/***************************************************************************\
* Module Name: FIREWALL.HXX                                                 *
*                                                                           *
* Contains FIREWALL macros.  These are like assert() functions that go away *
* when FIREWALLS is not defined.                                            *
*                                                                           *
* Created: Sat 24-Sep-1988 22:45:53                                         *
* Author:  Charles Whitmer [chuckwh]                                        *
*                                                                           *
* Copyright (c) 1988-1999 Microsoft Corporation                             *
\***************************************************************************/

// Define the RIP and ASSERT macros.

#if DBG

extern  ULONG   gdi_dbgflags;
#define GDI_DBGFLAGS_VERBOSE    0x0001
#define GDI_DBGFLAGS_ERRORRIP   0x0002

#define RIP(x) {DbgPrint(x); DbgBreakPoint();}
#ifndef ASSERTGDI
#define ASSERTGDI(x,y) if(!(x)) RIP(y)
#endif
#define VERIFYGDI(x,y)                                                      \
        {if(!(x))                                                           \
         {DbgPrint(y);                                                      \
          if(gdi_dbgflags & (GDI_DBGFLAGS_VERBOSE|GDI_DBGFLAGS_ERRORRIP))   \
            DbgBreakPoint();}}
#define ERROR_ASSERT(x,y)                                                   \
        {if((gdi_dbgflags & (GDI_DBGFLAGS_VERBOSE|GDI_DBGFLAGS_ERRORRIP))   \
            && !(x))                                                        \
            RIP(y)}
#define PUTS(x) {if (gdi_dbgflags & GDI_DBGFLAGS_VERBOSE) DbgPrint(x);}
#define PUTSX(x,y) {if (gdi_dbgflags & GDI_DBGFLAGS_VERBOSE) DbgPrint(x,y);}
#define USE(x)  x = x
#define WARNING(x) DbgPrint(x)
#define WARNING1(x) DbgPrint(x)
#else
#define RIP(x)
#define ASSERTGDI(x,y)
#define VERIFYGDI(x,y)
#define ERROR_ASSERT(x,y)
#define PUTS(x)
#define PUTSX(x,y)
#define USE(x)
#define WARNING(x)
#define WARNING1(x)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\drawstream.c ===
/******************************Module*Header*******************************\
* Module Name: drawstream.c                                                *
*                                                                          *
* Client side draw stream support.  Handles metafiling if primary          *
* is a metafile.                                                           *
*                                                                          *
* Created: 03-Mar-2001                                                     *
* Author: Barton House [bhouse]                                            *
*                                                                          *
* Copyright (c) 1991-2001 Microsoft Corporation                            *
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop
/******************************Public*Routine******************************\
* GdiDrawStream
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    3/21/2001 Barton House
*
\**************************************************************************/

BOOL
GdiDrawStream(
                 HDC   hdcDst,
                 ULONG cjIn,
                 VOID *pvIn)
{
    BOOL bRet = FALSE;
    PDC_ATTR pdca;

    FIXUP_HANDLE(hdcDst);
    
    if (IS_ALTDC_TYPE(hdcDst))
    {
        HBITMAP hbmSource = NULL;
        HRGN    hrgnSaved  = NULL;
        HBITMAP hbmScratch = NULL;
        HDC     hdcScratch = NULL;
        int     iDstClip = -1;
        ULONG * pul = (ULONG *) pvIn;
    
        if(cjIn < sizeof(ULONG))
            return FALSE;
    
        if(*pul++ != 'DrwS')
            return FALSE;
    
        cjIn -= sizeof(ULONG);
    
        while(cjIn >= sizeof(ULONG))
        {
            ULONG   command = *pul;
            ULONG   commandSize;
            RECTL   rclDstClip;
    
            switch(command)
            {
            case DS_SETTARGETID: // set target
                {
                    DS_SETTARGET *  cmd = (DS_SETTARGET *) pul;
    
                    commandSize = sizeof(*cmd);
    
                    if(cjIn < commandSize)
                        goto altExit;
    
                    if((HDC) ULongToHandle(cmd->hdc) != hdcDst)
                    {
                        // NOTE: This restriction is only in place for the
                        //       initial implementation of GdiDrawStream.

                        WARNING("GdiDrawStream: target must match primary target");
                        goto altExit;
                    }
    
                    rclDstClip = cmd->rclDstClip;

                    if(hrgnSaved == NULL)
                    {
                        int iRet;

                        hrgnSaved = CreateRectRgn(0,0,0,0);
                        
                        if(hrgnSaved == NULL)
                        {
                            WARNING("GdiDrawStream: unable to create saved region");
                            goto altExit;
                        }

                        iDstClip = GetClipRgn(hdcDst, hrgnSaved);

                        if(iDstClip == -1)
                        {
                            WARNING("GdiDrawStream: failed to get DC application clip");
                            goto altExit;
                        }

                    }
                    else
                    {
                        // need to restore target clip

                        if(iDstClip)
                        {
                            SelectClipRgn(hdcDst, hrgnSaved);
                        }
                        else
                        {
                            SelectClipRgn(hdcDst, NULL);
                        }
                    }
    
                    IntersectClipRect(hdcDst, rclDstClip.left, rclDstClip.top, rclDstClip.right, rclDstClip.bottom);
                }
                break;
    
            case DS_SETSOURCEID: // set source
    
                {
                    DS_SETSOURCE *  cmd = (DS_SETSOURCE *) pul;
    
                    commandSize = sizeof(*cmd);
    
                    if(cjIn < commandSize)
                        goto altExit;
    
                    hbmSource = (HBITMAP) ULongToHandle(cmd->hbm);
    
                }
                break;
    
            case DS_NINEGRIDID:
                {
                    DS_NINEGRID * cmd = (DS_NINEGRID *) pul;
                    LONG  lSrcWidth = cmd->rclSrc.right - cmd->rclSrc.left;
                    LONG  lSrcHeight = cmd->rclSrc.bottom - cmd->rclSrc.top;
                    LONG  lDstWidth = cmd->rclDst.right - cmd->rclDst.left;
                    LONG  lDstHeight = cmd->rclDst.bottom - cmd->rclDst.top;
                    BOOL  bRenderRet;
                    RECTL rclDst = cmd->rclDst;

                    struct {
                        BITMAPINFOHEADER    bmih;
                        ULONG               masks[3];
                    } bmi;
    
                    struct {
                        DS_HEADER       hdr;
                        DS_SETTARGET    setTarget;
                        DS_SETSOURCE    setSource;
                        DS_NINEGRID     ng;
                    } scratchStream;
    
                    RECTL   rclScratch;
    
                    commandSize = sizeof(DS_NINEGRID);
    
                    // validate nine grid
    
                    #define DSDNG_MASK  0x007F      // move to wingdip.h
    
                    if(cmd->ngi.flFlags & ~DSDNG_MASK)
                    {
                        WARNING("GreDrawStream: unrecognized nine grid flags set\n");
                        goto altExit;
                    }
    
                    if(lSrcWidth < 0 || lSrcHeight < 0)
                    {
                        WARNING("GreDrawStream: nine grid rclSrc is not well ordered\n");
                        goto altExit;
                    }
    
                    if(cmd->ngi.flFlags & DSDNG_TRUESIZE)
                    {
                        if(lDstWidth > lSrcWidth) 
                        {
                            lDstWidth = lSrcWidth;
                            rclDst.right = rclDst.left + lDstWidth;
                        }

                        if(lDstHeight > lSrcHeight)
                        {
                            lDstHeight = lSrcHeight;
                            rclDst.bottom = rclDst.top + lDstHeight;
                        }
                    }
                    else
                    {
                        // NOTE: we have to check individual first then sum due to possible
                        //       numerical overflows that could occur in the sum that might
                        //       not be detected otherwise.
    
                        if(cmd->ngi.ulLeftWidth > lSrcWidth ||
                           cmd->ngi.ulRightWidth > lSrcWidth ||
                           cmd->ngi.ulTopHeight > lSrcHeight ||
                           cmd->ngi.ulBottomHeight > lSrcHeight ||
                           cmd->ngi.ulLeftWidth + cmd->ngi.ulRightWidth > lSrcWidth ||
                           cmd->ngi.ulTopHeight + cmd->ngi.ulBottomHeight > lSrcHeight)
                        {
                            WARNING("GreDrawStream: nine grid width is greater then rclSrc width\n");
                            goto altExit;
                        }
                    }
    
                    if((cmd->ngi.flFlags & (DSDNG_TRANSPARENT | DSDNG_PERPIXELALPHA)) == (DSDNG_TRANSPARENT | DSDNG_PERPIXELALPHA))
                    {
                        WARNING("GreDrawStream: nine grid attempt to set both transparency and per pixel alpha\n");
                        goto altExit;
                    }
    
                    // create temporary to render nine grid into
    
                    bmi.bmih.biSize = sizeof(bmi.bmih);
                    bmi.bmih.biWidth = lDstWidth;
                    bmi.bmih.biHeight = lDstHeight;
                    bmi.bmih.biPlanes = 1;
                    bmi.bmih.biBitCount = 32;
                    bmi.bmih.biCompression = BI_BITFIELDS;
                    bmi.bmih.biSizeImage = 0;
                    bmi.bmih.biXPelsPerMeter = 0;
                    bmi.bmih.biYPelsPerMeter = 0;
                    bmi.bmih.biClrUsed = 3;
                    bmi.bmih.biClrImportant = 0;
                    bmi.masks[0] = 0xff0000;    // red
                    bmi.masks[1] = 0x00ff00;    // green
                    bmi.masks[2] = 0x0000ff;    // blue
    
                    if(hbmScratch != NULL)
                        DeleteObject(hbmScratch);
    
                    hbmScratch = CreateDIBitmap(hdcDst, &bmi.bmih, CBM_CREATEDIB , NULL, (BITMAPINFO*)&bmi.bmih, DIB_RGB_COLORS);
                    
                    if(hbmScratch == NULL)
                    {
                        WARNING("GdiDrawStream: unable to create temporary\n");
                        goto altExit;
                    }
                    
                    if(hdcScratch == NULL)
                    {
                        hdcScratch = CreateCompatibleDC(hdcDst);

                        if(hdcScratch == NULL)
                        {
                            WARNING("GdiDrawStream: unable to create temporary dc\n");
                            goto altExit;
                        }
                    }

                    SelectObject(hdcScratch, hbmScratch);
    
                    rclScratch.left = 0;
                    rclScratch.top = 0;
                    rclScratch.right = lDstWidth;
                    rclScratch.bottom = lDstHeight;
                    
                    scratchStream.hdr.magic = DS_MAGIC;
                    scratchStream.setTarget.ulCmdID = DS_SETTARGETID;
                    scratchStream.setTarget.hdc = HandleToULong(hdcScratch);
                    scratchStream.setTarget.rclDstClip = rclScratch;
                    scratchStream.setSource.ulCmdID = DS_SETSOURCEID;
                    scratchStream.setSource.hbm = HandleToULong(hbmSource);
                    scratchStream.ng.ulCmdID = DS_NINEGRIDID;
                    scratchStream.ng.rclDst = rclScratch;
                    scratchStream.ng.rclSrc = cmd->rclSrc;
                    scratchStream.ng.ngi = cmd->ngi;
                    scratchStream.ng.ngi.flFlags &= ~(DSDNG_TRANSPARENT | DSDNG_PERPIXELALPHA);
    
                    NtGdiDrawStream(hdcScratch, sizeof(scratchStream), &scratchStream);

                    if(cmd->ngi.flFlags & DSDNG_TRANSPARENT)
                    {
                        bRenderRet = GdiTransparentBlt(hdcDst,
                                          rclDst.left, 
                                          rclDst.top,
                                          lDstWidth,
                                          lDstHeight,
                                          hdcScratch,
                                          0,
                                          0,
                                          lDstWidth,
                                          lDstHeight,
                                          cmd->ngi.crTransparent);
                    }
                    else if(cmd->ngi.flFlags & DSDNG_PERPIXELALPHA)
                    {
                        // alpha blend
                        BLENDFUNCTION   bfx;

                        bfx.AlphaFormat = AC_SRC_ALPHA;
                        bfx.BlendFlags = 0;
                        bfx.BlendOp = AC_SRC_OVER;
                        bfx.SourceConstantAlpha = 255;

                        bRenderRet = GdiAlphaBlend(hdcDst,
                                          rclDst.left, 
                                          rclDst.top,
                                          lDstWidth,
                                          lDstHeight,
                                          hdcScratch,
                                          0,
                                          0,
                                          lDstWidth,
                                          lDstHeight,
                                          bfx);
                    }
                    else
                    {
                        // bitblt

                        bRenderRet = BitBlt(hdcDst,
                                          rclDst.left, 
                                          rclDst.top,
                                          lDstWidth,
                                          lDstHeight,
                                          hdcScratch,
                                          0,
                                          0,
                                  SRCCOPY);
                    }

                    if(!bRenderRet)
                    {
                        WARNING("GdiDrawStream: failed to render temporary to destination");
                        goto altExit;
                    }
                }
                break;
    
            default:
                WARNING("GdiDrawStream: unrecognized command");
                goto altExit;
            }

            pul += commandSize  / sizeof(ULONG);
            cjIn -= commandSize;

        }

        bRet = TRUE;

    altExit:

        if(iDstClip == 1)
        {
            SelectClipRgn(hdcDst, hrgnSaved);
        }
        else if(iDstClip == 0)
        {
            SelectClipRgn(hdcDst, NULL);
        }
        
        if(hbmScratch != NULL)
            DeleteObject(hbmScratch);

        if(hdcScratch != NULL)
            DeleteDC(hdcScratch);

        if(hrgnSaved != NULL)
            DeleteObject(hrgnSaved);

        return bRet;
    }

    RESETUSERPOLLCOUNT();

    bRet = NtGdiDrawStream(
                      hdcDst,
                      cjIn,
                      pvIn);
    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\emfspool.cxx ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    emfspool.cxx

Abstract:

    EMF spooling functions

Environment:

    Windows NT GDI

Revision History:

    01/09/97 -davidx-
        Created it.

--*/

#define NO_STRICT

extern "C" {
#if defined(_GDIPLUS_)
#include    <gpprefix.h>
#endif

#include    <nt.h>
#include    <ntrtl.h>
#include    <nturtl.h>
#include    <stddef.h>
#include    <windows.h>    // GDI function declarations.
#include    <winerror.h>
#include    "firewall.h"
#define __CPLUSPLUS
#include    <winspool.h>
#include    <wingdip.h>
#include    "ntgdistr.h"
#include    "winddi.h"
#include    "hmgshare.h"
#include    "icm.h"
#include    "local.h"   // Local object support.
#include    "gdiicm.h"
#include    "metadef.h" // Metafile record type constants.

}

#include    "rectl.hxx"
#include    "mfdc.hxx"  // Metafile DC class declarations.


//
// Class for representing extra information used during EMF spooling
//

BOOL
EMFSpoolData::Init(
    HANDLE      hSpooler,
    BOOL        banding
    )

/*++

Routine Description:

    Initialize an EMFSpoolData object

Arguments:

    hSpooler - Spooler handle to the current printer
    banding - Whether GDI is doing banding on the current DC

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    TRACE_EMFSPL(("EMFSpoolData::Init - banding = %d ...\n", banding));

    //
    // initialize all fields to default values
    //

    signature = 'LPSE';
    hPrinter = hSpooler;
    bBanding = banding;
    pmdcActive = NULL;
    scratchBuf = fontBuf = NULL;

    ResetMappingState();

    //
    // Get a handle to the EMF spool file
    //

    hFile = bBanding ?
                GetTempSpoolFileHandle() :
                fpGetSpoolFileHandle(hPrinter);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        WARNING("GetSpoolFileHandle failed\n");
        return FALSE;
    }

    //
    // Map the spooler file
    //

    return MapFile();
}


VOID
EMFSpoolData::Cleanup()
{
    UnmapFile();
    FreeTempBuffers();
}


PVOID
EMFSpoolData::GetPtr(UINT32 inOffset, UINT32 inSize)
{

    PVOID ptr = emfc.ObtainPtr(currentOffset + inOffset, inSize);
    return ptr;
}

VOID
EMFSpoolData::ReleasePtr(PVOID inPtr)
{
    emfc.ReleasePtr(inPtr);
}

PVOID
EMFSpoolData::GetPtrUsingSignedOffset(INT32 inOffset, UINT32 inSize)
{
    if((inOffset + (INT32) currentOffset) < 0)
    {
        WARNING("EMFSpoolData::GetPtrUsingSignedOffset() Bad offset\n");
        return NULL;
    }

    PVOID ptr = emfc.ObtainPtr((UINT32) (currentOffset + inOffset), inSize);
    
    return ptr;
}

BOOL
EMFSpoolData::WriteData(
    PVOID   buffer,
    DWORD   size
    )

/*++

Routine Description:

    Write data to the end of mapped file

Arguments:

    buffer - Pointer to data buffer
    size - Size of data buffer

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    ASSERTGDI(size != 0, "WriteData: size is 0\n");

    if(!bMapping)
        return FALSE;

    //
    // Check if the current buffer is used for recording EMF data
    //

    if (!pmdcActive)
    {
        //
        // Make sure we have enough space left and remap if necessary
        //

        if ((size > mapSize - currentOffset) &&
            !ResizeCurrentBuffer(size))
        {
            return FALSE;
        }

        //
        // If the current buffer is NOT used for recording EMF data,
        // we simply copy the input data buffer to the end of mapped file
        //
        
        PVOID pvBuf = GetPtr(0, size);

        if(pvBuf)
        {
            CopyMemory(pvBuf, buffer, size);

            ReleasePtr(pvBuf);

            CompleteCurrentBuffer(size);
        }
        else
        {
            ReleasePtr(pvBuf);

            return FALSE;
        }
    }
    else
    {
        TRACE_EMFSPL(("WriteData called while recording EMF data: %d ...\n", size));

        //
        // If we have an actively mapped view for recording EMF data,
        // then we need to cache the input buffer into a temporary buffer.
        //

        ASSERTGDI(size % sizeof(DWORD) == 0, "WriteData: misalignment\n");

        return WriteTempData(&scratchBuf, buffer, size);
    }

    return TRUE;
}


BOOL
EMFSpoolData::ResizeCurrentBuffer(
    DWORD   newsize
    )

/*++

Routine Description:

    Resize the current buffer so that its size is at least newsize

Arguments:

    newsize - New size for the current buffer

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    UINT64  newMapStart, newFileSize;
    DWORD   newMapSize, newOffset;
    HANDLE  hNewMap;
    PVOID   pNewMap;
    BOOL    success = FALSE;

    TRACE_EMFSPL(("ResizeCurrentBuffer: %d\n", newsize));

    //
    // Don't need to do anything if we're just shrinking the current buffer
    //

    if (newsize <= mapSize - currentOffset)
        return TRUE;

    if (hFile == INVALID_HANDLE_VALUE)
        return FALSE;

    //
    // We should always start file mapping at an offset that's
    // a multiple of file mapping block size. Similarly, mapping
    // size should also be a multiple of block size.
    //
    // Make sure the content of the current page are always mapped in view.
    //

    DWORD blockSize = GetFileMappingAlignment();

    if (emfrOffset == INVALID_EMFROFFSET)
        newOffset = currentOffset % blockSize;
    else
        newOffset = currentOffset;

    newMapStart = mapStart + (currentOffset - newOffset);
    newMapSize = ((newsize + newOffset + blockSize - 1) / blockSize) * blockSize;
    newFileSize = newMapStart + newMapSize;

    // WINBUG 365006 04-10-2001 pravins Further cleanup needed in EMFSpoolData
    // We wanted to minimize the number of changes to this class to support
    // arbitrary sized EMF streams.  There is further cleanup that is needed
    // in this code (removing cruft) to help reduce support costs in the furture.

    if(bMapping)
        emfc.Term();

    bMapping = emfc.Init(hFile, newMapStart, newFileSize);

    if(bMapping)
    {
        mapStart = newMapStart;
        mapSize = newMapSize;
        currentOffset = newOffset;
        bMapping = TRUE;
        success = TRUE;
    }
    else
    {
        // try to get back the old mapping ... hope this works :-)
        bMapping = emfc.Init(hFile, mapStart, mapSize);
        WARNING("ResizeCurrentBuffer: emfc intialization failed\n");
    }

    return success;
}


BOOL
EMFSpoolData::GetEMFData(
    MDC *pmdc
    )

/*++

Routine Description:

    Return a pointer to the start the current buffer for recording EMF data.

Arguments:

    pmdc - Pointer to the MDC object used for EMF recording

Return Value:

    Pointer to beginning of EMF data buffer
    NULL if there is an error

--*/

{
    TRACE_EMFSPL(("GetEMFData: %x ...\n", pmdc));

    if (pmdcActive)
    {
        WARNING("GetEMFData: overlapping EMF data buffer\n");
        return (FALSE);
    }

    if (!ResizeCurrentBuffer(sizeof(EMFITEMHEADER) + MF_BUFSIZE_INIT))
        return (FALSE);

    //
    // If we're not banding, write out an incomplete EMFITEMHEADER
    // for an EMF_METAFILE_DATA record.
    //

    emfrOffset = mapStart + currentOffset;

    if (!IsBanding())
    {
        EMFITEMHEADER emfr = { EMRI_METAFILE_DATA, 0 };

        if (!WriteData(&emfr, sizeof(emfr)))
        {
            emfrOffset = INVALID_EMFROFFSET;
            return (FALSE);
        }
    }

    pmdcActive = pmdc;
    return(TRUE);
}


BOOL
EMFSpoolData::ResizeEMFData(
    DWORD   newsize
    )

/*++

Routine Description:

    Resize current EMF data buffer

Arguments:

    newsize - new size of EMF data buffer

Return Value:

    Pointer to the beginning of EMF data buffer
    NULL if there is an error

--*/

{
    TRACE_EMFSPL(("ResizeEMFData: 0x%x ...\n", newsize));

    ASSERTGDI(pmdcActive, "ResizeEMFData: pmdcActive is NULL\n");

    return ResizeCurrentBuffer(newsize);
}


BOOL
EMFSpoolData::CompleteEMFData(
    DWORD   size,
    HANDLE* outFile,
    UINT64* outOffset
    )

/*++

Routine Description:

    Finish recording EMF data

Arguments:

    size - size of EMF data recorded

Return Value:

    Pointer to beginning of EMF data, NULL if there is an error

--*/

{
    DWORD   emfHeaderOffset = currentOffset;

    TRACE_EMFSPL(("CompleteEMFData: 0x%x ...\n", size));

    if (!pmdcActive)
        return FALSE;

    //
    // If size parameter is 0, the caller wants us to discard
    // any data recorded in the current EMF data buffer.
    //

    if (size == 0)
    {
        //
        // If we're not banding, we need to back over the incomplete
        // EMFITEMHEADER structure.
        //

        if (!IsBanding())
            currentOffset -= sizeof(EMFITEMHEADER);

        //
        // Get rid of any data collected in the temporary buffers as well
        //

        if ((scratchBuf && scratchBuf->currentSize) ||
            (fontBuf && fontBuf->currentSize))
        {
            WARNING("CompleteEMFData: temp buffers not empty\n");
        }

        FreeTempBuffers(FALSE);
        pmdcActive = NULL;

        *outOffset = emfHeaderOffset + mapStart;
        *outFile = hFile;

        return TRUE;
    }

    //
    // If we're not banding, fill out the incomplete EMF_METAFILE_DATA
    // record that we inserted earlier during GetEMFData()
    //

    if (!IsBanding())
    {
        EMFITEMHEADER *pemfr;

        pemfr = (EMFITEMHEADER *) GetPtrUsingSignedOffset(-((INT32) sizeof(EMFITEMHEADER)), sizeof(EMFITEMHEADER));

        if(pemfr)
        {
            pemfr->cjSize = size;
            ReleasePtr(pemfr);
        }
        else
        {
            WARNING("CompleteEMFData: failed to get EMFITEMHEADER pointer\n");
            return FALSE;
        }

    }

    //
    // Mark the current EMF data buffer as complete
    //

    CompleteCurrentBuffer(size);
    pmdcActive = NULL;

    //
    // Flush and empty the content of temporary buffers
    //

    BOOL result;

    result = FlushFontExtRecords() &&
             FlushTempBuffer(scratchBuf);

    FreeTempBuffers(FALSE);

    if(result)
    {
        *outOffset = emfHeaderOffset + mapStart;
        *outFile = hFile;
    }

    return result;
}


BOOL
EMFSpoolData::AbortEMFData()

/*++

Routine Description:

    Ensure we're not actively recording EMF data

Arguments:

    NONE

Return Value:

    TRUE if successful, FALSE if there is a problem

--*/

{
//    if (pMapping == NULL)
    if(!bMapping)
        return FALSE;

    FreeTempBuffers(FALSE);

    if (pmdcActive != NULL)
    {
        WARNING("AbortEMFData: pmdcActive is not NULL\n");

        pmdcActive = NULL;
        emfrOffset = INVALID_EMFROFFSET;
        return FALSE;
    }

    return TRUE;
}


BOOL
EMFSpoolData::MapFile()

/*++

Routine Description:

    Map the EMF spool file into the current process' address space

Arguments:

    NONE

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    if (hFile == INVALID_HANDLE_VALUE)
        return FALSE;
    else
    {
        //
        // Map in 64KB to start with
        //

        ResetMappingState();

        return ResizeCurrentBuffer(GetFileMappingAlignment());
    }
}


VOID
EMFSpoolData::UnmapFile(
    BOOL    bCloseHandle
    )

/*++

Routine Description:

    Unmap the currently mapped EMF spool file

Arguments:

    bCloseHandle - Whether to close the EMF spool file handle

Return Value:

    NONE

--*/

{
    TRACE_EMFSPL(("EMFSpoolData::UnmapFile(%d) ...\n", bCloseHandle));

    if(bMapping)
    {
        emfc.Term();
        bMapping = FALSE;
    }

    if (bCloseHandle && hFile != INVALID_HANDLE_VALUE)
    {
        if (IsBanding())
        {
            //
            // Close the temporary spool file (it's be deleted automatically)
            //

            if (!CloseHandle(hFile))
            {
                WARNING("Failed to close temporary spool file\n");
            }
        }
        else
        {
            if (!fpCloseSpoolFileHandle(hPrinter, hFile))
            {
                WARNING("CloseSpoolFileHandle failed\n");
            }
        }

        hFile = INVALID_HANDLE_VALUE;
    }

    ResetMappingState();
}


BOOL
EMFSpoolData::FlushPage(
    DWORD   pageType
    )

/*++

Routine Description:

    Finish the current page and flush the content of
    EMF spool file to the spooler

Arguments:

    NONE

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
//    ASSERTGDI(pMapping && !pmdcActive, "FlushFile: inconsistent state\n");
    ASSERTGDI(bMapping && !pmdcActive, "FlushFile: inconsistent state\n");

    //
    // Output an EMRI_METAFILE_EXT or EMRI_BW_METAFILE_EXT record
    //

    EMFITEMHEADER_EXT endpage;

    endpage.emfi.ulID = (pageType == EMRI_BW_METAFILE) ?
                            EMRI_BW_METAFILE_EXT :
                            EMRI_METAFILE_EXT;

    endpage.emfi.cjSize = sizeof(endpage.offset);
    endpage.offset = mapStart + currentOffset - emfrOffset ;

    emfrOffset = INVALID_EMFROFFSET;

    if (!WriteData(&endpage, sizeof(endpage)))
    {
        WARNING("Failed to write out ENDPAGE record\n");
        return FALSE;
    }

    //
    // Commit the data for the current page to the spooler
    //

    DWORD   size;
    HANDLE  hNewFile;

    size = (DWORD) (GetTotalSize() - committedSize);

    TRACE_EMFSPL(("CommitSpoolData: %d bytes...\n", size));

    hNewFile = fpCommitSpoolData(hPrinter, hFile, size);

    if (hNewFile == INVALID_HANDLE_VALUE)
    {
        WARNING("CommitSpoolData failed\n");
    }

    if (hNewFile == hFile)
    {
        //
        // If the new handle is the same as the old handle, we
        // don't need to do any remapping. Simply proceed as usual.
        //

        committedSize += size;
        return TRUE;
    }
    else
    {
        //
        // Otherwise, we need to unmap the existing file
        // and remap the new file.
        //
        // We don't need to close existing handle here
        // because CommitSpoolData had already done so.
        //

        UnmapFile(FALSE);

        hFile = hNewFile;
        return MapFile();
    }
}


BOOL
EMFSpoolData::WriteTempData(
    PTempSpoolBuf  *ppBuf,
    PVOID           data,
    DWORD           size
    )

/*++

Routine Description:

    Write data into a temporary buffer

Arguments:

    ppBuf - Points to the temporary buffer pointer
    data - Points to data
    size - Size of data to be written

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

#define TEMPBLOCKSIZE       (4*1024)
#define ALIGNTEMPBLOCK(n)   (((n) + TEMPBLOCKSIZE - 1) / TEMPBLOCKSIZE * TEMPBLOCKSIZE)

{
    PTempSpoolBuf   buf = *ppBuf;
    DWORD           bufsize;

    //
    // Check if we need to allocate or grow the temporary buffer
    //

    if (!buf || size+buf->currentSize > buf->maxSize)
    {
        if (buf == NULL)
        {
            //
            // Allocate a new temporary buffer
            //

            bufsize = ALIGNTEMPBLOCK(size + TEMPBUF_DATAOFFSET);
            buf = (PTempSpoolBuf) LocalAlloc(LMEM_FIXED, bufsize);

            if (buf != NULL)
                buf->currentSize = 0;
        }
        else
        {
            //
            // Reallocate an existing memory buffer
            //

            WARNING("WriteTempData: reallocating temporary buffer\n");

            bufsize = ALIGNTEMPBLOCK(size + TEMPBUF_DATAOFFSET + buf->currentSize);
            buf = (PTempSpoolBuf) LocalReAlloc((HLOCAL) *ppBuf, bufsize, LMEM_MOVEABLE);
        }

        if (buf == NULL)
        {
            WARNING("WriteTempData: memory allocation failed\n");
            return FALSE;
        }

        buf->maxSize = bufsize - TEMPBUF_DATAOFFSET;
        *ppBuf = buf;
    }

    //
    // Copy the data into the temporary buffer
    //

    CopyMemory(&buf->data[buf->currentSize], data, size);
    buf->currentSize += size;
    return TRUE;
}


VOID
EMFSpoolData::FreeTempBuffers(
    BOOL    freeMem
    )

/*++

Routine Description:

    Free temporary buffers

Arguments:

    freeMem - Whether to keep or free the temporary buffer memory

Return Value:

    NONE

--*/

{
    if (freeMem)
    {
        //
        // Dispose of temparary buffers
        //

        if (scratchBuf)
        {
            LocalFree((HLOCAL) scratchBuf);
            scratchBuf = NULL;
        }

        if (fontBuf)
        {
            LocalFree((HLOCAL) fontBuf);
            fontBuf = NULL;
        }
    }
    else
    {
        //
        // Empty the temporary buffers but keep the memory
        //

        if (scratchBuf)
            scratchBuf->currentSize = 0;

        if (fontBuf)
            fontBuf->currentSize = 0;
    }
}


BOOL
EMFSpoolData::FlushTempBuffer(
    PTempSpoolBuf buf
    )

/*++

Routine Description:

    Copy the content of the temporary buffer into the spool file

Arguments:

    NONE

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    if (pmdcActive)
    {
        WARNING("FlushTempBuffer called while recording EMF data\n");
        return FALSE;
    }

    return (buf == NULL) ||
           (buf->currentSize == 0) ||
           WriteData(buf->data, buf->currentSize);
}


BOOL
EMFSpoolData::AddFontExtRecord(
    DWORD   recType,
    DWORD   offset
    )

/*++

Routine Description:

    Remember where a font related EMFITEMHEADER_EXT record is

Arguments:

    recType - Spool record type
    offset - Offset relative to the beginning of EMF data

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    EMFITEMHEADER_EXT extrec;

    if (!pmdcActive)
    {
        WARNING("AddFontExtRecord: pmdcActive is NULL\n");
        return FALSE;
    }

    //
    // Map record type to its *_EXT counterpart
    //

    switch (recType)
    {
    case EMRI_ENGINE_FONT:
        recType = EMRI_ENGINE_FONT_EXT;
        break;

    case EMRI_TYPE1_FONT:
        recType = EMRI_TYPE1_FONT_EXT;
        break;

    case EMRI_DESIGNVECTOR:
        recType = EMRI_DESIGNVECTOR_EXT;
        break;

    case EMRI_SUBSET_FONT:
        recType = EMRI_SUBSET_FONT_EXT;
        break;

    case EMRI_DELTA_FONT:
        recType = EMRI_DELTA_FONT_EXT;
        break;

    case EMRI_EMBED_FONT_EXT:
        break;

    default:
        ASSERTGDI(FALSE, "AddFontExtRecord: illegal record type\n");
        return FALSE;
    }

    extrec.emfi.ulID = recType;
    extrec.emfi.cjSize = sizeof(extrec.offset);

    //
    // Remember the absolute offset relative to the beginning of file
    //

    extrec.offset = mapStart + currentOffset + offset;

    return WriteTempData(&fontBuf, &extrec, sizeof(extrec));
}


BOOL
EMFSpoolData::FlushFontExtRecords()

/*++

Routine Description:


Arguments:

    NONE

Return Value:

    NONE

--*/

{
    EMFITEMHEADER_EXT  *pExtRec;
    DWORD               count;
    UINT64              offset;

    //
    // Don't need to do anything if the temporary font buffer is empty
    //

    if (!fontBuf || fontBuf->currentSize == 0)
        return TRUE;

    ASSERTGDI(fontBuf->currentSize % sizeof(EMFITEMHEADER_EXT) == 0,
              "FlushFontExtRecords: invalid size info\n");

    count = fontBuf->currentSize / sizeof(EMFITEMHEADER_EXT);
    pExtRec = (EMFITEMHEADER_EXT *) fontBuf->data;
    offset = mapStart + currentOffset;

    //
    // Patch the offset field in the cached EMFITEMHEADER_EXT's
    //

    while (count--)
    {
        pExtRec->offset = offset - pExtRec->offset;
        offset += sizeof(EMFITEMHEADER_EXT);
        pExtRec++;
    }

    return FlushTempBuffer(fontBuf);
}


/*++

Routine Description:

    Create a temporary EMF spool file

Arguments:

    NONE

Return Value:

    Handle to the temporary spool file
    INVALID_HANDLE_VALUE if there is an error

--*/

HANDLE
CreateTempSpoolFile()
{
    WCHAR   tempPath[MAX_PATH];
    WCHAR   tempFilename[MAX_PATH];
    HANDLE  hFile;

    //
    // Get a unique temporary filename
    //

    if (!GetTempPathW(MAX_PATH, tempPath) ||
        !GetTempFileNameW(tempPath, L"SPL", 0, tempFilename))
    {
        return INVALID_HANDLE_VALUE;
    }

    //
    // Open a Read/Write handle to the temporary file
    //

    hFile = CreateFileW(tempFilename,
                        GENERIC_READ|GENERIC_WRITE,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_SEQUENTIAL_SCAN|FILE_FLAG_DELETE_ON_CLOSE,
                        NULL);

    //
    // If we fail to open the file, make sure to delete it
    //

    if (hFile == INVALID_HANDLE_VALUE)
    {
        WARNING("Failed to create temporary spool file\n");
        DeleteFileW(tempFilename);
    }

    return hFile;
}

HANDLE
EMFSpoolData::GetTempSpoolFileHandle()

/*++

Routine Description:

    Create a temporary EMF spool file used for banding

Arguments:

    NONE

Return Value:

    Handle to the temporary spool file
    INVALID_HANDLE_VALUE if there is an error

--*/
{
    return CreateTempSpoolFile();
}


//
// C helper functions for working with EMFSpoolData object
// (stored in the hEMFSpool field in LDC).
//
// NOTE: GDI doesn't new and delete operators.
// So we allocate and deallocate object memory manually here.
//

BOOL
AllocEMFSpoolData(
    PLDC    pldc,
    BOOL    banding
    )

{
    EMFSpoolData   *pEMFSpool;

    TRACE_EMFSPL(("AllocEMFSpoolData...\n"));

    //
    // Make sure we don't have an EMFSpoolData object
    // attached to LDC already
    //

    if (pldc->hEMFSpool != NULL)
    {
        WARNING("AllocEMFSpoolData: pldc->hEMFSpool is not NULL\n");
        DeleteEMFSpoolData(pldc);
    }

    //
    // Create a new EMFSpoolData object and initialize it
    //

    pEMFSpool = (EMFSpoolData *) LOCALALLOC(sizeof(EMFSpoolData));

    if (pEMFSpool != NULL)
    {
        if (!pEMFSpool->Init(pldc->hSpooler, banding))
        {
            pEMFSpool->Cleanup();
            LOCALFREE(pEMFSpool);
            pEMFSpool = NULL;
        }
        else
            pldc->hEMFSpool = (HANDLE) pEMFSpool;
    }

    return (pEMFSpool != NULL);
}


VOID
DeleteEMFSpoolData(
    PLDC    pldc
    )

{
    EMFSpoolData *pEMFSpool = (EMFSpoolData *) pldc->hEMFSpool;

    TRACE_EMFSPL(("DeleteEMFSpoolData...\n"));

    if (pEMFSpool != NULL)
    {
        pldc->hEMFSpool = NULL;

        pEMFSpool->Cleanup();
        LOCALFREE(pEMFSpool);
    }
}


BOOL
WriteEMFSpoolData(
    PLDC    pldc,
    PVOID   buffer,
    DWORD   size
    )

{
    EMFSpoolData *pEMFSpool = (EMFSpoolData *) pldc->hEMFSpool;

    TRACE_EMFSPL(("WriteEMFSpoolData...\n"));

    if (pEMFSpool == NULL)
    {
        ASSERTGDI(FALSE, "WriteEMFSpoolData: pldc->hEMFSpool is NULL\n");
        return FALSE;
    }
    else
        return pEMFSpool->WriteData(buffer, size);
}


BOOL
FlushEMFSpoolData(
    PLDC    pldc,
    DWORD   pageType
    )

{
    EMFSpoolData *pEMFSpool = (EMFSpoolData *) pldc->hEMFSpool;

    TRACE_EMFSPL(("FlushEMFSpoolData...\n"));

    if (pEMFSpool == NULL)
    {
        WARNING("FlushEMFSpoolData: pldc->hEMFSpool is NULL\n");
        return FALSE;
    }

    //
    // Ensure sure we're not actively recording EMF data
    //

    if (!pEMFSpool->AbortEMFData())
        return FALSE;

    //
    // If GDI is doing banding on the current DC, then
    // we don't need to send data to spooler. Instead,
    // we'll simply reuse the spool file as scratch space.
    //

    if (pEMFSpool->IsBanding())
    {
        pEMFSpool->UnmapFile(FALSE);
        return TRUE;
    }

    //
    // Finish the current page and prepare to record the next page
    //

    return pEMFSpool->FlushPage(pageType);
}

//
// Debug code for emulating spool file handle interface
//

#ifdef EMULATE_SPOOLFILE_INTERFACE

HANDLE  emPrinterHandle = NULL;
HANDLE  emFileHandle = INVALID_HANDLE_VALUE;
DWORD   emAccumCommitSize = 0;
DWORD   emFileFlags = FILE_FLAG_SEQUENTIAL_SCAN;

HANDLE WINAPI
GetSpoolFileHandle(
    HANDLE  hPrinter
    )

{
    WCHAR   tempPath[MAX_PATH];
    WCHAR   tempFilename[MAX_PATH];
    HANDLE  hFile;

    ASSERTGDI(emPrinterHandle == NULL && emFileHandle == INVALID_HANDLE_VALUE,
              "GetSpoolFileHandle: overlapped calls not allowed\n");

    if (!GetTempPathW(MAX_PATH, tempPath) ||
        !GetTempFileNameW(tempPath, L"SPL", 0, tempFilename))
    {
        return INVALID_HANDLE_VALUE;
    }

    hFile = CreateFileW(tempFilename,
                        GENERIC_READ|GENERIC_WRITE,
                        FILE_SHARE_READ|FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        emFileFlags,
                        NULL);
    
    if (hFile == INVALID_HANDLE_VALUE)
    {
        WARNING("Failed to create temporary spool file\n");
        DeleteFileW(tempFilename);
    }
    else
    {
        emAccumCommitSize = 0;
        emPrinterHandle = hPrinter;
        emFileHandle = hFile;
    }

    return hFile;
}


HANDLE WINAPI
CommitSpoolData(
    HANDLE  hPrinter,
    HANDLE  hSpoolFile,
    DWORD   cbCommit
    )

{
    ASSERTGDI(hPrinter == emPrinterHandle && hSpoolFile == emFileHandle,
              "CloseSpoolFileHandle: Bad handles\n");

    emAccumCommitSize += cbCommit;
    return hSpoolFile;
}

BOOL WINAPI
CloseSpoolFileHandle(
    HANDLE  hPrinter,
    HANDLE  hSpoolFile
    )

{
    ASSERTGDI(hPrinter == emPrinterHandle && hSpoolFile == emFileHandle,
              "CloseSpoolFileHandle: Bad handles\n");

    if (SetFilePointer(hSpoolFile, emAccumCommitSize, NULL, FILE_BEGIN) == 0xffffffff ||
        !SetEndOfFile(hSpoolFile))
    {
        WARNING("Couldn't set end-of-file pointer\n");
    }

    CloseHandle(hSpoolFile);
    emPrinterHandle = NULL;
    emFileHandle = INVALID_HANDLE_VALUE;

    return TRUE;
}

#endif // EMULATE_SPOOLFILE_INTERFACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\font.c ===
/******************************Module*Header*******************************\
* Module Name: font.c
*
* Created: 28-May-1991 13:01:27
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "exehdr.h"
#include "fot16.h"
#include "winfont.h"

// Stuf for CreateScaleableFontResource

#define ALIGNMENTSHIFT  4
#define ALIGNMENTCOUNT  (1 << ALIGNMENTSHIFT)
#define CODE_OFFSET     512
#define RESOURCE_OFFSET 1024
#define PRIVRESSIZE     0x80
#define FONTDIRSIZINDEX 6
#define NE_WINDOWS      2


WCHAR * pwszAllocNtMultiplePath(
LPWSTR  pwszFileName,
FLONG  *pfl,
ULONG  *pcwc,
ULONG  *pcFiles,
BOOL    bAddFR,     // called by add or remove fr
DWORD  *pdwPidTid,   // PID/TID for embedded font
BOOL   bChkFOT
);


// Define an EXE header.  This will be hardcoded into the resource file.

#define SIZEEXEHEADER   (CJ_EXE_HDR + 25 + 39)  // should be 0x80

CONST static BYTE ajExeHeader[SIZEEXEHEADER] = {
            0x4d, 0x5a,             // unsigned short e_magic;
            0x01, 0x00,             // unsigned short e_cblp;
            0x02, 0x00,             // unsigned short e_cp;
            0x00, 0x00,             // unsigned short e_crlc;
            0x04, 0x00,             // unsigned short e_cparhdr;
            0x0f, 0x00,             // unsigned short e_minalloc;
            0xff, 0xff,             // unsigned short e_maxalloc;
            0x00, 0x00,             // unsigned short e_ss;
            0xb8, 0x00,             // unsigned short e_sp;
            0x00, 0x00,             // unsigned short e_csum;
            0x00, 0x00,             // unsigned short e_ip;
            0x00, 0x00,             // unsigned short e_cs;
            0x40, 0x00,             // unsigned short e_lfarlc;
            0x00, 0x00,             // unsigned short e_ovno;
            0x00, 0x00, 0x00, 0x00, // unsigned short e_res[ERESWDS];
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
            SIZEEXEHEADER, 0x00, 0x00, 0x00, // long  e_lfanew;


            // [gilmanw]
            // I don't know what the rest of this stuff is.  Its not
            // in the definition of EXE_HDR that we have in gdi\inc\exehdr.h.
            // The string is 39 bytes, the other stuff is 25 bytes.

            0x0e, 0x1f, 0xba, 0x0e, 0x00, 0xb4, 0x09, 0xcd,
            0x21, 0xb8, 0x01, 0x4c, 0xcd, 0x21,

            'T','h','i','s',' ',
            'i','s',' ',
            'a',' ',
            'T','r','u','e','T','y','p','e',' ',
            'f','o','n','t',',',' ',
            'n','o','t',' ',
            'a',' ',
            'p','r','o','g','r','a','m','.',

            0x0d, 0x0d, 0x0a, 0x24, 0x00, 0x4b, 0x69, 0x65,
            0x73, 0x61, 0x00
            };


// Define a resource table.  This will be hardcoded into the resource file.

#define SIZEFAKERESTBL  52

CONST static USHORT ausFakeResTable[SIZEFAKERESTBL/2] = {
            ALIGNMENTSHIFT, 0x8007, 1, 0, 0,
            (RESOURCE_OFFSET+PRIVRESSIZE) >> ALIGNMENTSHIFT,
            (0x90 >> ALIGNMENTSHIFT), 0x0c50,
            0x002c, 0, 0, 0x80cc, 1, 0, 0,
            RESOURCE_OFFSET >> ALIGNMENTSHIFT,
            (PRIVRESSIZE >> ALIGNMENTSHIFT), 0x0c50, 0x8001, 0, 0, 0,
            0x4607, 0x4e4f, 0x4454, 0x5249 // counted string 'FONTDIR'
            };


// Define a New EXE header.  This will be hardcoded into the resource file.

#define SIZENEWEXE  (CJ_NEW_EXE)

CONST static USHORT ausNewExe[SIZENEWEXE/2] = {
            NEMAGIC,                    //dw  NEMAGIC   ;magic number
            0x1005,                     //db  5, 10h    ;version #, revision #
            0xffff,                     //dw  -1        ;offset to table entry (to be filled)
            0x0002,                     //dw  2         ;# of bytes in entry table
            0x0000, 0x0000,             //dd  0         ;checksum of whole file
            0x8000, 0x0000,             //dw  8000h, 0, 0, 0
            0x0000, 0x0000,
            0x0000, 0x0000,             //dd  0, 0
            0x0000, 0x0000,
            0x0000, 0x0000,             //dw  0, 0
            0xffff,                     //dw  -1        ;size of non-resident name table
            SIZENEWEXE,                 //dw  (size NewExe)   ;offset to segment table
            SIZENEWEXE,                 //dw  (size NewExe)   ;offset to resource table
            SIZENEWEXE+SIZEFAKERESTBL,  //dw  (size NewExe)+SIZEFAKERESTBL    ;off to resident name table
            0xffff,                     //dw  -1        ;offset to module reference table
            0xffff,                     //dw  -1        ;offset to imported names table
            0xffff, 0x0000,             //dd  0ffffh    ;offset to non-resident names table
            0x0000, ALIGNMENTSHIFT,     //dw  0, ALIGNMENTSHIFT, 2
            0x0002,
            NE_WINDOWS,                 //db  NE_WINDOWS, 0
            0x0000, 0x0000,             //dw  0, 0, 0, 300h
            0x0000, 0x0300
            };


#define OFF_FONTDIRSIZINDEX  ((2*FONTDIRSIZINDEX)+SIZEEXEHEADER+SIZENEWEXE)


// Define font res string.

#define SIZEFONTRES 8

CONST static BYTE ajFontRes[SIZEFONTRES] = {
    'F','O','N','T','R','E','S',':'
    };

#define CJ_OUTOBJ  (SIZEFFH + LF_FACESIZE + LF_FULLFACESIZE + LF_FACESIZE + PRIVRESSIZE + 1024 + 16)





VOID vNewTextMetricExWToNewTextMetricExA (
NEWTEXTMETRICEXA  *pntm,
NTMW_INTERNAL     *pntmi
);

typedef struct _AFRTRACKNODE
{
    WCHAR                   *pwszPath;
    struct _AFRTRACKNODE    *pafrnNext;
    UINT                    id;
    UINT                    cLoadCount;
} AFRTRACKNODE;

extern AFRTRACKNODE *pAFRTNodeList;

AFRTRACKNODE *pAFRTNodeList;



VOID
vConvertLogicalFont(
    ENUMLOGFONTEXDVW *pelfw,
    PVOID pv
    );



ULONG cchCutOffStrLen(PSZ psz, ULONG cCutOff);

ULONG
cwcCutOffStrLen (
    PWSZ pwsz,
    ULONG cCutOff
    );


// GETS ushort at (PBYTE)pv + off. both pv and off must be even

#define  US_GET(pv,off) ( *(PUSHORT)((PBYTE)(pv) + (off)) )
#define  S_GET(pv,off)  ((SHORT)US_GET((pv),(off)))

#if TRACK_GDI_ALLOC

// Now access to these guys insn't sycnronized but they
// don't ever collide anyhow, and since it's debug stuff who cares.

ULONG bmgulNumMappedViews = 0;
ULONG bmgulTotalSizeViews = 0;

#endif

/******************************Public*Routine******************************\
* BOOL bMapFileUNICODEClideSide
*
* Similar to PosMapFile except that it takes unicode file name
*
* History:
*  Feb-05-1997 -by- Xudong Wu   [tessiew]
* Extend the function by adding an extra parameter bNtPath to handle the
* NT path name for file mapping.
*
*  21-May-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bMapFileUNICODEClideSide
(
PWSTR     pwszFileName,
CLIENT_SIDE_FILEVIEW  *pfvw,
BOOL    bNtPath
)
{
    UNICODE_STRING ObFileName;
    OBJECT_ATTRIBUTES ObjA;
    NTSTATUS rc = 0L;
    IO_STATUS_BLOCK     iosb;           // IO Status Block

    PWSTR pszFilePart = NULL;

// NOTE PERF: this is the mode I want, but appears to be broken, so I had to
// put the slower FILE_STANDARD_INFORMATION mode of query which appears to
// work correctly [bodind]
// FILE_END_OF_FILE_INFORMATION    eof;

    FILE_STANDARD_INFORMATION    eof;
    SIZE_T  cjView;

    pfvw->hf       = (HANDLE)0;            // file handle
    pfvw->hSection = (HANDLE)0;            // section handle

    ObFileName.Buffer = NULL;

// section offset must be initialized to 0 for NtMapViewOfSection to work

    if (bNtPath)
    {
        RtlInitUnicodeString(&ObFileName, pwszFileName);
    }
    else        //Dos path name converted to NtpathName
    {
        RtlDosPathNameToNtPathName_U(pwszFileName, &ObFileName, &pszFilePart, NULL);
    }

    InitializeObjectAttributes( &ObjA,
                            &ObFileName,
                            OBJ_CASE_INSENSITIVE,  // case insensitive file search
                            NULL,
                            NULL );

// NtOpenFile fails for some reason if the file is on the net unless I put this
// InpersonateClient/RevertToSelf stuff around it

// peform open call

    rc = NtOpenFile
         (
          &pfvw->hf,                            // store file handle here
          FILE_READ_DATA | SYNCHRONIZE,         // desired read access
          &ObjA,                                // filename
          &iosb,                                // io result goes here
          FILE_SHARE_READ,
          FILE_SYNCHRONOUS_IO_NONALERT
         );

    if (!bNtPath && ObFileName.Buffer)
    {
        RtlFreeHeap(RtlProcessHeap(),0,ObFileName.Buffer);
    }

// check success or fail

    if (!NT_SUCCESS(rc) || !NT_SUCCESS(iosb.Status))
    {
#ifdef DEBUG_THIS_JUNK
DbgPrint("bMapFileUNICODEClideSide(): NtOpenFile error code , rc = 0x%08lx , 0x%08lx\n", rc, iosb.Status);
#endif // DEBUG_THIS_JUNK
        return FALSE;
    }

// get the size of the file, the view should be size of the file rounded up
// to a page bdry

    rc = NtQueryInformationFile
         (
          pfvw->hf,                // IN  file handle
          &iosb,                   // OUT io status block
          (PVOID)&eof,             // OUT buffer to retrun info into
          sizeof(eof),             // IN  size of the buffer
          FileStandardInformation  // IN  query mode
         );

// dont really want the view size, but eof file

    pfvw->cjView = eof.EndOfFile.LowPart;

    if (!NT_SUCCESS(rc))
    {
#ifdef DEBUG_THIS_JUNK
DbgPrint("bMapFileUNICODEClideSide(): NtQueryInformationFile error code 0x%08lx\n", rc);
#endif // DEBUG_THIS_JUNK
        NtClose(pfvw->hf);
        return FALSE;
    }

    rc = NtCreateSection
         (
          &pfvw->hSection,          // return section handle here
          SECTION_MAP_READ,         // read access to the section
          (POBJECT_ATTRIBUTES)NULL, // default
          NULL,                     // size is set to the size of the file when hf != 0
          PAGE_READONLY,            // read access to commited pages
          SEC_COMMIT,               // all pages set to the commit state
          pfvw->hf                  // that's the file we are mapping
         );

// check success, close the file if failed

    if (!NT_SUCCESS(rc))
    {
#ifdef DEBUG_THIS_JUNK
DbgPrint("bMapFileUNICODEClideSide(): NtCreateSection error code 0x%08lx\n", rc);
#endif // DEBUG_THIS_JUNK
        NtClose(pfvw->hf);
        return FALSE;
    }

// zero out *ppv so as to force the operating system to determine
// the base address to be returned

    pfvw->pvView = (PVOID)NULL;
    cjView = 0L;

    rc = NtMapViewOfSection
         (
          pfvw->hSection,           // section we are mapping
          NtCurrentProcess(),       // process handle
          &pfvw->pvView,            // place to return the base address of view
          0L,                       // requested # of zero bits in the base address
          0L,                       // commit size, (all of them commited already)
          NULL,
          &cjView,                  // size of the view should is returned here
          ViewUnmap,                // do not map the view to child processess
          0L,                       // allocation type flags
          PAGE_READONLY             // read access to commited pages
         );

    if (!NT_SUCCESS(rc))
    {
#ifdef DEBUG_THIS_JUNK
DbgPrint("bMapFileUNICODEClideSide(): NtMapViewOfSection error code 0x%08lx\n", rc);
#endif // DEBUG_THIS_JUNK

        NtClose(pfvw->hSection);
        NtClose(pfvw->hf);
        return FALSE;
    }

    #ifdef DEBUG_THIS_JUNK
        DbgPrint("cjView = 0x%lx, eof.Low = 0x%lx, eof.High = 0x%lx\n",
                  cjView,
                  eof.EndOfFile.LowPart,
                  eof.EndOfFile.HighPart);
    #endif // DEBUG_THIS_JUNK

#define PAGE_SIZE 4096
#define PAGE_ROUNDUP(x) (((x) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1))

    if (
        (eof.EndOfFile.HighPart != 0) ||
        (PAGE_ROUNDUP(eof.EndOfFile.LowPart) > cjView)
       )
    {
#ifdef DEBUG_THIS_JUNK
DbgPrint(
    "bMapFileUNICODEClideSide(): eof.HighPart = 0x%lx, eof.LowPart = 0x%lx, cjView = 0x%lx\n",
    eof.EndOfFile.HighPart, PAGE_ROUNDUP(eof.EndOfFile.LowPart), cjView
    );
#endif // DEBUG_THIS_JUNK

        rc = STATUS_UNSUCCESSFUL;
    }

    if (!NT_SUCCESS(rc) || (pfvw->cjView == 0))
    {
        NtClose(pfvw->hSection);
        NtClose(pfvw->hf);
        return FALSE;
    }
    else if (pfvw->cjView == 0)
    {
        #if DBG
        DbgPrint("gdisrvl!bMapFileUNICODEClideSide(): WARNING--empty file %ws\n", pwszFileName);
        #endif

        vUnmapFileClideSide(pfvw);
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}




/******************************Public*Routine******************************\
* vUnmapFileClideSide
*
* Unmaps file whose view is based at pv
*
*  14-Dec-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vUnmapFileClideSide(PCLIENT_SIDE_FILEVIEW pfvw)
{

#if TRACK_GDI_ALLOC

// Now access to these guys insn't sycnronized but they (we hope)
// don't ever collide anyhow, and since it's debug stuff who cares.

      bmgulNumMappedViews -= 1;
      bmgulTotalSizeViews -= PAGE_ROUNDUP(pfvw->cjView);
      // DbgPrint("UnMapping %lu %lu\n",pfvw->cjView,PAGE_ROUNDUP(pfvw->cjView));

#endif

    NtUnmapViewOfSection(NtCurrentProcess(),pfvw->pvView);

    //
    // now close section handle
    //

    NtClose(pfvw->hSection);

    //
    // close file handle. other processes can now open this file for access
    //

    NtClose(pfvw->hf);

    //
    // prevent accidental use
    //

    pfvw->pvView   = NULL;
    pfvw->hf       = (HANDLE)0;
    pfvw->hSection = (HANDLE)0;
    pfvw->cjView   = 0;
}


/******************************Public*Routine******************************\
*
* BOOL   bVerifyFOT
*
* Effects: verify that that a file is valid fot file
*
*
* History:
*  29-Jan-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/




BOOL   bVerifyFOT
(
PCLIENT_SIDE_FILEVIEW   pfvw,
PWINRESDATA pwrd,
FLONG       *pflEmbed,
DWORD       *pdwPidTid
)
{
    PBYTE pjNewExe;     // ptr to the beginning of the new exe hdr
    PBYTE pjResType;    // ptr to the beginning of TYPEINFO struct
    ULONG iResID;       // resource type id
    PBYTE pjData;
    ULONG ulLength;
    ULONG ulNameID;
    ULONG crn;

    pwrd->pvView = pfvw->pvView;
    pwrd->cjView = pfvw->cjView;

// Initialize embed flag to FALSE (not hidden).

    *pflEmbed = 0;
    *pdwPidTid = 0;

// check the magic # at the beginning of the old header

// *.TTF FILES are eliminated on the following check

    if (US_GET(pfvw->pvView, OFF_e_magic) != EMAGIC)
    {
        return (FALSE);
    }

    pwrd->dpNewExe = (PTRDIFF)READ_DWORD((PBYTE)pfvw->pvView + OFF_e_lfanew);

// make sure that offset is consistent

    if ((ULONG)pwrd->dpNewExe > pwrd->cjView)
    {
        return FALSE;
    }

    pjNewExe = (PBYTE)pfvw->pvView + pwrd->dpNewExe;

    if (US_GET(pjNewExe, OFF_ne_magic) != NEMAGIC)
    {
        return (FALSE);
    }

    pwrd->cjResTab = (ULONG)(US_GET(pjNewExe, OFF_ne_restab) -
                             US_GET(pjNewExe, OFF_ne_rsrctab));

    if (pwrd->cjResTab == 0L)
    {
    // The following test is applied by DOS,  so I presume that it is
    // legitimate.  The assumption is that the resident name table
    // FOLLOWS the resource table directly,  and that if it points to
    // the same location as the resource table,  then there are no
    // resources. [bodind]

        WARNING("No resources in *.fot file\n");
        return(FALSE);
    }

// want offset from pvView, not from pjNewExe => must add dpNewExe

    pwrd->dpResTab = (PTRDIFF)US_GET(pjNewExe, OFF_ne_rsrctab) + pwrd->dpNewExe;

// make sure that offset is consistent

    if ((ULONG)pwrd->dpResTab > pwrd->cjView)
    {
        return FALSE;
    }

// what really lies at the offset OFF_ne_rsrctab is a NEW_RSRC.rs_align field
// that is used in computing resource data offsets and sizes as a  shift factor.
// This field occupies two bytes on the disk and the first TYPEINFO structure
// follows right after. We want pwrd->dpResTab to point to the first
// TYPEINFO structure, so we must add 2 to get there and subtract 2 from
// the length

    pwrd->ulShift = (ULONG) US_GET(pfvw->pvView, pwrd->dpResTab);
    pwrd->dpResTab += 2;
    pwrd->cjResTab -= 2;

// Now we want to determine where the resource data is located.
// The data consists of a RSRC_TYPEINFO structure, followed by
// an array of RSRC_NAMEINFO structures,  which are then followed
// by a RSRC_TYPEINFO structure,  again followed by an array of
// RSRC_NAMEINFO structures.  This continues until an RSRC_TYPEINFO
// structure which has a 0 in the rt_id field.

    pjResType = (PBYTE)pfvw->pvView + pwrd->dpResTab;
    iResID = (ULONG) US_GET(pjResType,OFF_rt_id);

    while(iResID)
    {
    // # of NAMEINFO structures that follow = resources of this type

        crn = (ULONG)US_GET(pjResType, OFF_rt_nres);

        if ((crn == 1) && ((iResID == RT_FDIR) || (iResID == RT_PSZ)))
        {
        // this is the only interesting case, we only want a single
        // font directory and a single string resource for a ttf file name

            pjData = (PBYTE)pfvw->pvView +
                     (US_GET(pjResType,CJ_TYPEINFO + OFF_rn_offset) << pwrd->ulShift);
            ulLength = (ULONG)US_GET(pjResType,CJ_TYPEINFO + OFF_rn_length) << pwrd->ulShift;
            ulNameID = (ULONG)US_GET(pjResType,CJ_TYPEINFO + OFF_rn_id);

            if (iResID == RT_FDIR)
            {
                if (ulNameID != RN_ID_FDIR)
                {
                    return (FALSE); // *.fon files get eliminated here
                }

                pwrd->pjHdr = pjData + 4;   // 4 bytes to the beginning of font device header
                pwrd->cjHdr = ulLength - 4;

                //
                // Used to check if the client thread or process is allowed to
                // load this font and get the FRW_EMB_PID and FRW_EMB_TID flags
                //
                // Any client thread or process is authorized to load a font if
                // the font isn't ebmeded ( i.e. hidden ).  If
                // FRW_EMB_PID is set then the PID written in the
                // copyright string of the must equal that of the client
                // process.  If the FRW_EMB_TID flag is set then the
                // TID written into the copyright
                // string must equal that of the client thread.
                //
                // Returns TRUE if this client process or thread is authorized
                // to load this font or FALSE if it isn't.
                //

                // Note: Win 3.1 hack.  The LSB of Type is used by Win 3.1 as an engine type
                //       and font embedding flag.  Font embedding is a form of a "hidden
                //       font file".  The MSB of Type is the same as the fsSelection from
                //       IFIMETRICS.  (Strictly speaking, the MSB of Type is equal to the
                //       LSB of IFIMETRICS.fsSelection).

                // now convert flags from the font file format to the ifi format

                *pflEmbed = ((READ_WORD(pwrd->pjHdr + OFF_Type) & 0x00ff) &
                               ( PF_TID | PF_ENCAPSULATED));

                if (*pflEmbed)
                {
                    *pflEmbed = (*pflEmbed & PF_TID) ? FRW_EMB_TID : FRW_EMB_PID;

                    WARNING("bVerifyFOT(): notification--embedded (hidden) TT font\n");

                    *pdwPidTid = READ_DWORD( pwrd->pjHdr + OFF_Copyright );
                }
            }
            else  // iResID == RT_PSZ
            {
                ASSERTGDI(iResID == RT_PSZ, "bVerifyFOT!_not RT_PSZ\n");

                if (ulNameID != RN_ID_PSZ)
                {
                    WARNING("bVerifyFOT!_RN_ID_PSZ\n");
                    return(FALSE);
                }

                pwrd->pszNameTTF = (PSZ)pjData;
                pwrd->cchNameTTF = strlen(pwrd->pszNameTTF);

                if (ulLength < (pwrd->cchNameTTF + 1))   // 1 for terminating '\0'
                {
                    WARNING("bVerifyFOT!_ pwrd->cchNameTTF\n");
                    return(FALSE);
                }
            }
        }
        else // this is something we do not recognize as an fot file
        {
            WARNING("bVerifyFOT!_fot file with crn != 1\n");
            return(FALSE);
        }

    // get ptr to the new TYPEINFO struc and the new resource id

        pjResType = pjResType + CJ_TYPEINFO + crn * CJ_NAMEINFO;
        iResID = (ULONG) US_GET(pjResType,OFF_rt_id);
    }
    return(TRUE);
}

/******************************Public*Routine******************************\
* cGetTTFFromFOT
*
* Attempts to extract the TTF pathname from a given FOT file.  If a return
* buffer is provided (pwszTTFName !NULL), then the pathname is copied into
* the buffer.  Otherwise, if the buffer is NULL, the size of the buffer
* (in WCHARs) needed is returned.
*
* Returns:
*   The number of characters copied into the return buffer.  The number
*   of WCHARs needed in the buffer if the buffer is NULL.  If an error
*   occurs, zero is returned.
*
* History:
*  22-Apr-1992 -by- Gilman Wong [gilmanw]
* Adapted from TTFD.
\**************************************************************************/

#define FOT_EXCEPTED  0
#define FOT_NOT_FOT   1
#define FOT_IS_FOT    2

ULONG
cGetTTFFromFOT (
    WCHAR *pwszFOT,       // pointer to incoming FOT name
    ULONG  cwcTTF,        // size of buffer (in WCHAR)
    WCHAR *pwszTTF,       // return TTF name in this buffer
    FLONG *pfl,           // flags, indicate the location of the .ttf
    FLONG *pflEmbed,      // flag, indicating PID or TID
    DWORD *pdwPidTid,      // PID/TID for embedded font
    BOOL  bChkFOT
    )
{
    CLIENT_SIDE_FILEVIEW   fvw;
    WINRESDATA wrd;
    UINT Result;
    WCHAR      awcPath[MAX_PATH],awcFile[MAX_PATH];
    ULONG      cNeed = 0;
    WCHAR      *pwszTmp = NULL;

    ULONG      cwcFOT = wcslen(pwszFOT);

    if (cwcFOT >= 5) // fot file has to have a form x.fot, which is at least 5 wchars long
        pwszTmp = &pwszFOT[cwcFOT - 4];

// here we are making the exception for FOT files and we require that the file has an .FOT
// extension for us to even try to recognize it as a valid FOT file.

    if
    (bChkFOT || ( pwszTmp && 
        (pwszTmp[0] == L'.')            &&
        (pwszTmp[1] == L'F' || pwszTmp[1] == L'f') &&
        (pwszTmp[2] == L'O' || pwszTmp[2] == L'o') &&
        (pwszTmp[3] == L'T' || pwszTmp[3] == L't'))
    )
    {
        // Map the file into memory.

        if (bMapFileUNICODEClideSide(pwszFOT,&fvw,FALSE))
        {
        //
        // Check the validity of this file as fot file
        // and if a valid fot file, must extract the name of an underlining ttf
        // file.  The file could be on the net so we need try excepts.
        //

            try
            {
                if(bVerifyFOT(&fvw,&wrd,pflEmbed,pdwPidTid))
                {
                 // this could except which is why we do it here
                    vToUnicodeN(awcFile, MAX_PATH, wrd.pszNameTTF, strlen(wrd.pszNameTTF)+1);
                    Result = FOT_IS_FOT;
                }
                else
                {
                    Result = FOT_NOT_FOT;
                }
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNING("bVerifyFOT exception accessing font file\n");
                Result = FOT_EXCEPTED;
            }

            if(Result == FOT_IS_FOT)
            {

                if (bMakePathNameW(awcPath,awcFile,NULL, pfl))
                {
                    //
                    // Determine pathname length
                    //

                    cNeed = wcslen(awcPath) + 1;
                    pwszFOT = awcPath;
                }

                // cGetTTFFromFOT called by font sweeper.
                // TTF file might exist over net but connection has not been established yet.

                else if (pfl)
                {
                   cNeed = wcslen(awcFile) + 1;
                   pwszFOT = awcFile;
                }
            }
            else if(Result != FOT_EXCEPTED)
            {
                //
                // We have to assume it is another type of file.
                // just copy the name in the buffer
                //

                cNeed = wcslen(pwszFOT) + 1;

                if (pfl)
                {
                    KdPrint(("cGetTTFFromFOT: Invalid FOT file: %ws\n", pwszFOT));
                    *pfl |= FONT_ISNOT_FOT;
                }
            }

            vUnmapFileClideSide(&fvw);
        }
    }
    else
    {
        cNeed = cwcFOT + 1;

        if (pfl)
        {
            KdPrint(("cGetTTFFromFOT: Invalid FOT file: %ws\n", pwszFOT));
            *pfl |= FONT_ISNOT_FOT;
        }
    }

    if (cNeed == 0)
    {
        KdPrint(("cGetTTFFromFOT failed for font file %ws\n", pwszFOT));
    }

    //
    // If return buffer exists and we succeded, copy pathname to it.
    //

    if (cNeed &&
        (pwszTTF != (PWSZ) NULL))
    {
        if (cNeed <= cwcTTF)
        {
            wcscpy(pwszTTF, pwszFOT);
        }
        else
        {
            WARNING("gdisrv!cGetTTFFromFOT(): buffer too small\n");
            cNeed = 0;
        }
    }
    else
    {
        //
        // Otherwise, caller just wants us to return the number of characters.
        //
    }

    return cNeed;

}

/******************************Public*Routine******************************\
*
* BOOL bInitSystemAndFontsDirectoriesW(WCHAR **ppwcSystemDir, WCHAR **ppwcFontsDir)
*
* Effects:
*
* Warnings:
*
* History:
*  30-Oct-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


WCHAR *gpwcSystemDir = NULL;
WCHAR *gpwcFontsDir = NULL;

#define WSTR_SYSTEM_SUBDIR   L"\\system"
#define WSTR_FONT_SUBDIR     L"\\fonts"

BOOL bInitSystemAndFontsDirectoriesW(WCHAR **ppwcSystemDir, WCHAR **ppwcFontsDir)
{
    WCHAR  awcWindowsDir[MAX_PATH];
    UINT   cwchWinPath, cwchSystem, cwchFonts;
    BOOL   bRet = TRUE;

// see if already initialized, if yes we are done.

    if (!(*ppwcSystemDir))
    {
    // Compute the windows and font directory pathname lengths (including NULL).
    // Note that cwchWinPath may have a trailing '\', in which case we will
    // have computed the path length to be one greater than it should be.

		cwchWinPath = GetSystemWindowsDirectoryW(awcWindowsDir, MAX_PATH);
		
        if( cwchWinPath ){

    	// the cwchWinPath value does not include the terminating zero

        	if (awcWindowsDir[cwchWinPath - 1] == L'\\')
        	{
            	cwchWinPath -= 1;
        	}
        	awcWindowsDir[cwchWinPath] = L'\0'; // make sure to zero terminate

        	cwchSystem = cwchWinPath + sizeof(WSTR_SYSTEM_SUBDIR)/sizeof(WCHAR);
        	cwchFonts  = cwchWinPath + sizeof(WSTR_FONT_SUBDIR)/sizeof(WCHAR);

        	if (*ppwcSystemDir = LocalAlloc(LMEM_FIXED, (cwchSystem+cwchFonts) * sizeof(WCHAR)))
        	{
            	*ppwcFontsDir = &((*ppwcSystemDir)[cwchSystem]);
            	wcscpy(*ppwcSystemDir,awcWindowsDir);
            	wcscpy(*ppwcFontsDir,awcWindowsDir);

        	// Append the system and font subdirectories

            	lstrcatW(*ppwcSystemDir, WSTR_SYSTEM_SUBDIR);
            	lstrcatW(*ppwcFontsDir, WSTR_FONT_SUBDIR);
        	}
        	else
        	{
            	bRet = FALSE;
        	}
        }
        else
        {
            bRet = FALSE;
        }
    }
    return bRet;
}



/******************************Public*Routine******************************\
* vConverLogFont                                                           *
*                                                                          *
* Converts a LOGFONTA into an equivalent ENUMLOGFONTEXDVW structure.            *
*                                                                          *
* History:                                                                 *
*  Thu 15-Aug-1991 13:01:33 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

VOID
vConvertLogFont(
    ENUMLOGFONTEXDVW *pelfexdvw,
    LOGFONTA    *plf
    )
{
    ENUMLOGFONTEXW *pelfw = &pelfexdvw->elfEnumLogfontEx;
    ULONG cchMax;

// this one does everyting but the lfFaceName;

    vConvertLogicalFont(pelfexdvw,plf);

// do lfFaceName

    cchMax = cchCutOffStrLen((PSZ) plf->lfFaceName, LF_FACESIZE);
    RtlZeroMemory(pelfw->elfLogFont.lfFaceName , LF_FACESIZE * sizeof(WCHAR) );

// translate the face name

    vToUnicodeN((LPWSTR) pelfw->elfLogFont.lfFaceName,
                cchMax,
                (LPSTR) plf->lfFaceName,
                cchMax);
    if (cchMax == LF_FACESIZE)
        pelfw->elfLogFont.lfFaceName[LF_FACESIZE - 1] = L'\0';  // truncate so NULL will fit
    else
        pelfw->elfLogFont.lfFaceName[cchMax] = L'\0';

}

/******************************Public*Routine******************************\
* vConvertLogFontW                                                         *
*                                                                          *
* Converts a LOGFONTW to an ENUMLOGFONTEXDVW                               *
*                                                                          *
* History:                                                                 *
*  Fri 16-Aug-1991 14:02:05 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

VOID
vConvertLogFontW(
     ENUMLOGFONTEXDVW *pelfw,
     LOGFONTW *plfw
    )
{
// this one does everything except for lfFaceName

    vConvertLogicalFont(pelfw,plfw);

// do lfFaceName

    RtlCopyMemory(
        pelfw->elfEnumLogfontEx.elfLogFont.lfFaceName,
        plfw->lfFaceName,
        LF_FACESIZE * sizeof(WCHAR)
        );

}

/******************************Public*Routine******************************\
* vConvertLogicalFont                                                      *
*                                                                          *
* Simply copies over all of the fields of a LOGFONTA or LOGFONTW           *
* to the fields of a target ENUMLOGFONTEXDVW. The only exception is        *
* the FaceName which must be dealt with by another routine.                *
*                                                                          *
* History:                                                                 *
*  Fri 16-Aug-1991 14:02:14 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

VOID
vConvertLogicalFont(
    ENUMLOGFONTEXDVW *pelfw,
    PVOID pv
    )
{
    pelfw->elfEnumLogfontEx.elfLogFont.lfHeight         = ((LOGFONTA*)pv)->lfHeight;
    pelfw->elfEnumLogfontEx.elfLogFont.lfWidth          = ((LOGFONTA*)pv)->lfWidth;
    pelfw->elfEnumLogfontEx.elfLogFont.lfEscapement     = ((LOGFONTA*)pv)->lfEscapement;
    pelfw->elfEnumLogfontEx.elfLogFont.lfOrientation    = ((LOGFONTA*)pv)->lfOrientation;
    pelfw->elfEnumLogfontEx.elfLogFont.lfWeight         = ((LOGFONTA*)pv)->lfWeight;
    pelfw->elfEnumLogfontEx.elfLogFont.lfItalic         = ((LOGFONTA*)pv)->lfItalic;
    pelfw->elfEnumLogfontEx.elfLogFont.lfUnderline      = ((LOGFONTA*)pv)->lfUnderline;
    pelfw->elfEnumLogfontEx.elfLogFont.lfStrikeOut      = ((LOGFONTA*)pv)->lfStrikeOut;
    pelfw->elfEnumLogfontEx.elfLogFont.lfCharSet        = ((LOGFONTA*)pv)->lfCharSet;
    pelfw->elfEnumLogfontEx.elfLogFont.lfOutPrecision   = ((LOGFONTA*)pv)->lfOutPrecision;
    pelfw->elfEnumLogfontEx.elfLogFont.lfClipPrecision  = ((LOGFONTA*)pv)->lfClipPrecision;
    pelfw->elfEnumLogfontEx.elfLogFont.lfQuality        = ((LOGFONTA*)pv)->lfQuality;
    pelfw->elfEnumLogfontEx.elfLogFont.lfPitchAndFamily = ((LOGFONTA*)pv)->lfPitchAndFamily;

    // lfFaceName is done in the calling routine

    pelfw->elfEnumLogfontEx.elfFullName[0] = 0;
    pelfw->elfEnumLogfontEx.elfStyle[0]    = 0;
    pelfw->elfEnumLogfontEx.elfScript[0]   = 0;

    pelfw->elfDesignVector.dvReserved = STAMP_DESIGNVECTOR;
    pelfw->elfDesignVector.dvNumAxes  = 0;

}



/******************************Public*Routine******************************\
*
* BOOL bConvertLogFontWToLogFontA(LOGFONTA *plfw, LOGFONTW *plfa)
*
* History:
*  10-Dec-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/




BOOL bConvertLogFontWToLogFontA(LOGFONTA *plfa, LOGFONTW *plfw)
{
    ULONG cchMax;

    plfa->lfHeight         = plfw->lfHeight         ;
    plfa->lfWidth          = plfw->lfWidth          ;
    plfa->lfEscapement     = plfw->lfEscapement     ;
    plfa->lfOrientation    = plfw->lfOrientation    ;
    plfa->lfWeight         = plfw->lfWeight         ;
    plfa->lfItalic         = plfw->lfItalic         ;
    plfa->lfUnderline      = plfw->lfUnderline      ;
    plfa->lfStrikeOut      = plfw->lfStrikeOut      ;
    plfa->lfCharSet        = plfw->lfCharSet        ;
    plfa->lfOutPrecision   = plfw->lfOutPrecision   ;
    plfa->lfClipPrecision  = plfw->lfClipPrecision  ;
    plfa->lfQuality        = plfw->lfQuality        ;
    plfa->lfPitchAndFamily = plfw->lfPitchAndFamily ;

    cchMax = cwcCutOffStrLen(plfw->lfFaceName, LF_FACESIZE);

    return (bToASCII_N(plfa->lfFaceName,  LF_FACESIZE,
                       plfw->lfFaceName, cchMax));
}


/******************************Public*Routine******************************\
* bConvertEnumLogFontExWToEnumLogFontExA                                   *
*                                                                          *
* Simply copies over all of the fields of ENUMLOGFONTEXDVW                 *
* to the fields of a target ENUMLOGFONTEXDVA.  It is all wrapped up here   *
* because the ENUMLOGFONTEXDV may move around a bit.  This makes           *
* using MOVEMEM a little tricky.                                           *
*                                                                          *
* History:                                                                 *
*  Fri 16-Aug-1991 14:02:14 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

BOOL bConvertEnumLogFontExWToEnumLogFontExA(ENUMLOGFONTEXA *pelfexa,ENUMLOGFONTEXW *pelfexw)
{
    ULONG cchMax;

    if (!bConvertLogFontWToLogFontA(&pelfexa->elfLogFont,
                                    &pelfexw->elfLogFont))
    {
    // conversion to ascii  failed, return error

        WARNING("bConvertLogFontWToLogFontA failed\n");
        return(FALSE);
    }

    cchMax = cwcCutOffStrLen(pelfexw->elfFullName, LF_FULLFACESIZE);

    if(!bToASCII_N(pelfexa->elfFullName, LF_FULLFACESIZE,
                   pelfexw->elfFullName, cchMax
                   ))
    {
    // conversion to ascii  failed, return error
        WARNING("bConvertEnumLogFontExWToEnumLogFontExA: bToASCII failed\n");
        return(FALSE);
    }
    pelfexa->elfFullName[LF_FULLFACESIZE-1]=0; // zero terminate


    cchMax = cwcCutOffStrLen(pelfexw->elfStyle, LF_FACESIZE);

    if(!bToASCII_N(pelfexa->elfStyle, LF_FACESIZE,
                   pelfexw->elfStyle, cchMax))
    {
    // conversion to ascii  failed, return error

        WARNING("bConvertEnumLogFontExWToEnumLogFontExA: bToASCII failed\n");
        return(FALSE);
    }


    cchMax = cwcCutOffStrLen(pelfexw->elfScript, LF_FACESIZE);

    if(!bToASCII_N(pelfexa->elfScript, LF_FACESIZE,
                   pelfexw->elfScript, cchMax
                   ))
    {
    // conversion to ascii  failed, return error
        WARNING("bConvertEnumLogFontExWToEnumLogFontExA: bToASCII_N failed\n");
        return(FALSE);
    }

    return (TRUE);
}

/******************************Public*Routine******************************\
* bConvertEnumLogFontExDv_AtoW                                             *
*                                                                          *
* Simply copies over all of the fields of ENUMLOGFONTEXDVW                 *
* to the fields of a target ENUMLOGFONTEXDV.  It is all wrapped up here    *
* because the fields may move around a bit.  This make                     *
* using MOVEMEM a little tricky.                                           *
*                                                                          *
* History:                                                                 *
*  Fri 16-Aug-1991 14:02:14 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/


VOID vConvertEnumLogFontExDvAtoW(
    ENUMLOGFONTEXDVW *pelfw,
    ENUMLOGFONTEXDVA *pelfa
    )
{
    ULONG cchMax;

    pelfw->elfEnumLogfontEx.elfLogFont.lfHeight         = pelfa->elfEnumLogfontEx.elfLogFont.lfHeight         ;
    pelfw->elfEnumLogfontEx.elfLogFont.lfWidth          = pelfa->elfEnumLogfontEx.elfLogFont.lfWidth          ;
    pelfw->elfEnumLogfontEx.elfLogFont.lfEscapement     = pelfa->elfEnumLogfontEx.elfLogFont.lfEscapement     ;
    pelfw->elfEnumLogfontEx.elfLogFont.lfOrientation    = pelfa->elfEnumLogfontEx.elfLogFont.lfOrientation    ;
    pelfw->elfEnumLogfontEx.elfLogFont.lfWeight         = pelfa->elfEnumLogfontEx.elfLogFont.lfWeight         ;
    pelfw->elfEnumLogfontEx.elfLogFont.lfItalic         = pelfa->elfEnumLogfontEx.elfLogFont.lfItalic         ;
    pelfw->elfEnumLogfontEx.elfLogFont.lfUnderline      = pelfa->elfEnumLogfontEx.elfLogFont.lfUnderline      ;
    pelfw->elfEnumLogfontEx.elfLogFont.lfStrikeOut      = pelfa->elfEnumLogfontEx.elfLogFont.lfStrikeOut      ;
    pelfw->elfEnumLogfontEx.elfLogFont.lfCharSet        = pelfa->elfEnumLogfontEx.elfLogFont.lfCharSet        ;
    pelfw->elfEnumLogfontEx.elfLogFont.lfOutPrecision   = pelfa->elfEnumLogfontEx.elfLogFont.lfOutPrecision   ;
    pelfw->elfEnumLogfontEx.elfLogFont.lfClipPrecision  = pelfa->elfEnumLogfontEx.elfLogFont.lfClipPrecision  ;
    pelfw->elfEnumLogfontEx.elfLogFont.lfQuality        = pelfa->elfEnumLogfontEx.elfLogFont.lfQuality        ;
    pelfw->elfEnumLogfontEx.elfLogFont.lfPitchAndFamily = pelfa->elfEnumLogfontEx.elfLogFont.lfPitchAndFamily ;


    RtlZeroMemory( pelfw->elfEnumLogfontEx.elfLogFont.lfFaceName , LF_FACESIZE * sizeof(WCHAR) );
    cchMax = cchCutOffStrLen((PSZ)pelfa->elfEnumLogfontEx.elfLogFont.lfFaceName, LF_FACESIZE);

    vToUnicodeN (
        pelfw->elfEnumLogfontEx.elfLogFont.lfFaceName, cchMax,
        pelfa->elfEnumLogfontEx.elfLogFont.lfFaceName, cchMax
        );

    if (cchMax == LF_FACESIZE)
    {
    // truncate so NULL will fit
        pelfw->elfEnumLogfontEx.elfLogFont.lfFaceName[LF_FACESIZE - 1] = L'\0';
    }
    else
    {
        pelfw->elfEnumLogfontEx.elfLogFont.lfFaceName[cchMax] = L'\0';
    }

    RtlZeroMemory( pelfw->elfEnumLogfontEx.elfFullName , LF_FACESIZE * sizeof(WCHAR) );

    cchMax = cchCutOffStrLen((PSZ)pelfa->elfEnumLogfontEx.elfFullName, LF_FULLFACESIZE);
    vToUnicodeN (
        pelfw->elfEnumLogfontEx.elfFullName, cchMax,
        pelfa->elfEnumLogfontEx.elfFullName, cchMax
        );

    if (cchMax == LF_FULLFACESIZE)
    {
        // truncate so NULL will fit
        pelfw->elfEnumLogfontEx.elfFullName[LF_FULLFACESIZE - 1] = L'\0';
    }
    else
    {
        pelfw->elfEnumLogfontEx.elfFullName[cchMax] = L'\0';
    }

    RtlZeroMemory( pelfw->elfEnumLogfontEx.elfStyle , LF_FACESIZE * sizeof(WCHAR) );
    cchMax = cchCutOffStrLen((PSZ)pelfa->elfEnumLogfontEx.elfStyle, LF_FACESIZE);
    vToUnicodeN (
        pelfw->elfEnumLogfontEx.elfStyle, cchMax,
        pelfa->elfEnumLogfontEx.elfStyle, cchMax
        );
    if (cchMax == LF_FACESIZE)
    {
        // truncate so NULL will fit
        pelfw->elfEnumLogfontEx.elfStyle[LF_FACESIZE - 1] = L'\0';
    }
    else
    {
        pelfw->elfEnumLogfontEx.elfStyle[cchMax] = L'\0';
    }

    RtlZeroMemory( pelfw->elfEnumLogfontEx.elfScript , LF_FACESIZE * sizeof(WCHAR) );
    cchMax = cchCutOffStrLen((PSZ)pelfa->elfEnumLogfontEx.elfScript, LF_FACESIZE);
    vToUnicodeN (
        pelfw->elfEnumLogfontEx.elfScript, cchMax,
        pelfa->elfEnumLogfontEx.elfScript, cchMax
        );
    if (cchMax == LF_FACESIZE)
    {
        // truncate so NULL will fit
        pelfw->elfEnumLogfontEx.elfScript[LF_FACESIZE - 1] = L'\0';
    }
    else
    {
        pelfw->elfEnumLogfontEx.elfScript[cchMax] = L'\0';
    }

// copy minimal amount of stuff from design vector

    RtlCopyMemory(&pelfw->elfDesignVector,
                  &pelfa->elfDesignVector,
                  SIZEOFDV(pelfa->elfDesignVector.dvNumAxes));
}

/******************************Public*Routine******************************\
* ulEnumFontsOpen
*
* History:
*  08-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

ULONG_PTR ulEnumFontsOpen (
    HDC     hdc,
    LPWSTR  pwszFaceName,
    ULONG   lfCharSet,
    ULONG   iEnumType,    // enumfonts, enumfontfamilies or enumfontfamiliesex
    FLONG   flWin31Compat,
    ULONG   *pulCount
    )
{


    ULONG  cwchFaceName;

    ULONG  cjData;

    cwchFaceName = (pwszFaceName != (PWSZ) NULL) ? (wcslen(pwszFaceName) + 1) : 0;

    return NtGdiEnumFontOpen(hdc,iEnumType,flWin31Compat,
             cwchFaceName,pwszFaceName, lfCharSet,pulCount);

}


/******************************Public*Routine******************************\
* vEnumFontsClose
*
* History:
*  08-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID vEnumFontsClose (ULONG_PTR ulEnumHandle)
{
    NtGdiEnumFontClose(ulEnumHandle);
}

/******************************Public*Routine******************************\
*
*    vConvertAxesListW2AxesListA
*
*
* History:
*  18-Nov-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


VOID vConvertAxesListW2AxesListA(AXESLISTA *paxlA, AXESLISTW *paxlW)
{
    ULONG iAxis = 0;

    paxlA->axlReserved = paxlW->axlReserved;
    paxlA->axlNumAxes  = paxlW->axlNumAxes;

    for (iAxis = 0; iAxis < paxlW->axlNumAxes; iAxis ++)
    {
        ULONG cch;

        paxlA->axlAxisInfo[iAxis].axMinValue = paxlW->axlAxisInfo[iAxis].axMinValue;
        paxlA->axlAxisInfo[iAxis].axMaxValue = paxlW->axlAxisInfo[iAxis].axMaxValue;

        cch = cwcCutOffStrLen(paxlW->axlAxisInfo[iAxis].axAxisName,
                              MM_MAX_AXES_NAMELEN);

        bToASCII_N(paxlA->axlAxisInfo[iAxis].axAxisName, MM_MAX_AXES_NAMELEN,
                   paxlW->axlAxisInfo[iAxis].axAxisName, cch);

    }
}




/******************************Public*Routine******************************\
*
* int  iAnsiCallback (
*
* History:
*  28-Jan-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


int  iAnsiCallback (
    ENUMFONTDATAW *pefdw,
    ULONG          iEnumType,
    FONTENUMPROCA  lpFontFunc,
    LPARAM lParam
    )
{
// full size structures with MAX_MM_AXES arrays
// on the stack, probably bigger then needed.

    ENUMLOGFONTEXDVA     elfexa ;
    ENUMTEXTMETRICA      ntma;

    NTMW_INTERNAL *pntmi = (NTMW_INTERNAL *)((BYTE*)pefdw + pefdw->dpNtmi);
    DESIGNVECTOR  *pdvSrc = &(pefdw->elfexw.elfDesignVector);

// copy out design vector

    RtlCopyMemory(&elfexa.elfDesignVector, pdvSrc, SIZEOFDV(pdvSrc->dvNumAxes));

// convert AXESLIST to ansi

    vConvertAxesListW2AxesListA(&ntma.etmAxesList, &pntmi->entmw.etmAxesList);

// Convert ENUMLOGFONTEX

    if (!bConvertEnumLogFontExWToEnumLogFontExA(&elfexa.elfEnumLogfontEx, &pefdw->elfexw.elfEnumLogfontEx))
    {
        WARNING("gdi32!EFCallbackWtoA(): ENUMLOGFONT conversion failed\n");
        return 0;
    }

// Convert NEWTEXTMETRIC.

    vNewTextMetricExWToNewTextMetricExA(&ntma.etmNewTextMetricEx, pntmi);

    return lpFontFunc(
                (LOGFONTA *)&elfexa,
                (TEXTMETRICA *)&ntma,
                pefdw->flType,
                lParam
                );

}


/******************************Public*Routine******************************\
* iScaleEnum
*
* The Win95 Universal printer driver (UNIDRV) has scalable fonts, but does
* not set the scalable capability flags in TEXTCAPS.  Instead, it enumerates
* back scalable printer fonts at several different (fixed) point sizes.
*
* We support this by detecting, on the server-side, when we are enumerating
* a scalable printer and setting the ENUMFONT_SCALE_HACK flag in the flType
* field of the ENUMFONTDATAW structure.
*
* For more details, refer to the Win95 sources found on \\tal\msdos in
* \src\win\drivers\printer\universa\unidrv\enumobj.c.  Specifically, the
* function of interest is UniEnumDFonts().
*
* Returns:
*   Value returned by callback if successful, 0 otherwise.
*
* History:
*  08-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

#define EFI_UNICODE 1

CONST int giEnumPointList[] =
    {6, 8, 10, 11, 12, 14, 18, 24, 30, 36, 48};

int iScaleEnum(
    HDC           hdc,
    FONTENUMPROCW lpFontFunc,
    ENUMFONTDATAW *pefd,
    LPARAM        lParam,
    ULONG         iEnumType,
    FLONG         fl
    )
{
    int i, cPointSizes = sizeof(giEnumPointList) / sizeof(int);
    int iHeight;
    int iXdpi, iYdpi;
    int iRet;

// make the structure on the stack is DWORD aligned

    DWORD efd[CJ_EFDW0/sizeof(DWORD)];

    ENUMFONTDATAW *pefdLocal = (ENUMFONTDATAW *)efd;

    iXdpi = GetDeviceCaps(hdc, LOGPIXELSX);
    iYdpi = GetDeviceCaps(hdc, LOGPIXELSY);

    for (i = 0; i < cPointSizes; i++)
    {
    // this has to be true because for these device fonts no
    // extra mm data will ever be needed, only logfont and ntmi

        NTMW_INTERNAL *pntmi, *pntmiDef;
        TEXTMETRICW   *ptmw,  *ptmwDef;
        LOGFONTW      *plfw,  *plfwDef;

        ASSERTGDI(pefd->cjEfdw <= sizeof(efd), "iScaleEnum size problem\n");
        RtlCopyMemory(pefdLocal, pefd, pefd->cjEfdw);

        pntmi      = (NTMW_INTERNAL *)((BYTE*)pefdLocal + pefdLocal->dpNtmi);
        pntmiDef   = (NTMW_INTERNAL *)((BYTE*)pefd + pefd->dpNtmi);
        ptmw       = (TEXTMETRICW *) &pntmi->entmw.etmNewTextMetricEx;
        ptmwDef    = (TEXTMETRICW *) &pntmiDef->entmw.etmNewTextMetricEx;
        plfw       = (LOGFONTW *) &pefdLocal->elfexw;
        plfwDef    = (LOGFONTW *) &pefd->elfexw;

    // Scale TEXTMETRIC to match enumerated height.

        iHeight = MulDiv(giEnumPointList[i], iYdpi, 72);
        ptmw->tmHeight = iHeight;
        ptmw->tmAscent = MulDiv(ptmwDef->tmAscent, iHeight, ptmwDef->tmHeight);
        ptmw->tmInternalLeading = MulDiv(ptmwDef->tmInternalLeading, iHeight,
                                         ptmwDef->tmHeight);
        ptmw->tmExternalLeading = MulDiv(ptmwDef->tmExternalLeading, iHeight,
                                         ptmwDef->tmHeight);
        ptmw->tmAveCharWidth = MulDiv(ptmwDef->tmAveCharWidth, iHeight,
                                      ptmwDef->tmHeight);
        ptmw->tmMaxCharWidth = MulDiv(ptmwDef->tmMaxCharWidth, iHeight,
                                      ptmwDef->tmHeight);

    // Scale LOGFONT to match enumerated height.

        plfw->lfHeight = MulDiv(plfwDef->lfHeight, iHeight, ptmwDef->tmHeight);
        plfw->lfWidth = MulDiv(plfwDef->lfWidth, iHeight, ptmwDef->tmHeight);

    // Invoke the callback function.

        if (fl & EFI_UNICODE)
        {
            iRet = lpFontFunc(
                       (LOGFONTW *) plfw,
                       (TEXTMETRICW *) ptmw,
                       pefd->flType,
                       lParam );
        }
        else
        {
            iRet = iAnsiCallback (pefdLocal,
                                  iEnumType,
                                  (FONTENUMPROCA)lpFontFunc,
                                  lParam);
        }

    // Break out early if callback returned error.

        if (!iRet)
            break;
    }

    return iRet;
}


/******************************Public*Routine******************************\
* EnumFontsInternalW
*
* History:
*  Mon 17-Aug-1998 -by- Bodin Dresevic [BodinD]
* update: since 1992 this function was rewritten quite a few times
*
*  08-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

int WINAPI EnumFontsInternalW (
    HDC           hdc,           // enumerate for this device
    LPCWSTR       pwszFaceName,  // use this family name (but Windows erroneously calls in face name *sigh*)
    ULONG         lfCharSet,     // only used with EnumFontFamiliesEx,
    FONTENUMPROCW lpFontFunc,    // callback
    LPARAM        lParam,        // user defined data
    ULONG         iEnumType,     // who is calling....
    FLONG         fl
    )
{
    BOOL         bMore;         // set TRUE if more data to process
    ULONG_PTR     ulEnumID;      // server side font enumeration handle
    int          iRet = 1;      // return value from callback
    ULONG        cjEfdw;        // capacity of memory data window
    ULONG        cjEfdwRet;     // size of data returned

    PENUMFONTDATAW  pefdw;      // font enumeration data buffer
    PENUMFONTDATAW  pefdwScan;  // use to parse data buffer
    PENUMFONTDATAW  pefdwEnd;   // limit of data buffer

    FLONG        flWin31Compat; // Win3.1 app hack backward compatibility flags

// Get the compatibility flags.

    flWin31Compat = (FLONG) GetAppCompatFlags(NULL);

// Open a font enumeration.  The font enumeration is uniquely identified
// by the identifier returned by ulEnumFontOpen().

    ulEnumID = ulEnumFontsOpen(
                     hdc, (LPWSTR)pwszFaceName, lfCharSet,
                     iEnumType, flWin31Compat, &cjEfdw);

    if (!ulEnumID)
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
        return 0;
    }

    if (cjEfdw == 0)
    {
        vEnumFontsClose(ulEnumID);
        return iRet;
    }

// alloc memory

    if (!(pefdw = (PENUMFONTDATAW) LOCALALLOC(cjEfdw)))
    {
        WARNING("gdi32!EnumFontsInternalW(): could not allocate memory for enumeration\n");
        GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
        vEnumFontsClose(ulEnumID);
        return 0;
    }

    if (NtGdiEnumFontChunk(hdc,ulEnumID,cjEfdw,&cjEfdwRet,pefdw))
    {

    // Scan through the data buffer.

        ASSERTGDI(cjEfdwRet <= cjEfdw, "NtGdiEnumFontChunk problem\n");

        pefdwScan = pefdw;
        pefdwEnd = (ENUMFONTDATAW *)((BYTE *)pefdw + cjEfdwRet);

        while (pefdwScan < pefdwEnd)
        {
        // GACF_ENUMTTNOTDEVICE backward compatibility hack.
        // If this flag is set, we need to mask out the DEVICE_FONTTYPE
        // if this is a TrueType font.

            if ( (flWin31Compat & GACF_ENUMTTNOTDEVICE)
                 && (pefdwScan->flType & TRUETYPE_FONTTYPE) )
                pefdwScan->flType &= ~DEVICE_FONTTYPE;

        // The Win95 UNIDRV printer driver enumerates scalable fonts at
        // several different sizes.  The server sets the ENUMFONT_SCALE_HACK
        // flag if we need to emulate that behavior.

            if ( pwszFaceName && (pefdwScan->flType & ENUMFONT_SCALE_HACK))
            {
            // Clear the hack flag before calling.  Caller doesn't need to
            // see this (internal use only) flag.

                pefdwScan->flType &= ~ENUMFONT_SCALE_HACK;

                iRet = iScaleEnum(hdc, lpFontFunc, pefdwScan, lParam,
                                  iEnumType, fl);

            }
            else
            {
            // Do the callback with data pointed to by pefdwScan.

                if (fl & EFI_UNICODE)
                {
                    NTMW_INTERNAL *pntmi =
                        (NTMW_INTERNAL *)((BYTE*)pefdwScan + pefdwScan->dpNtmi);

                    iRet = lpFontFunc(
                               (LOGFONTW *)&pefdwScan->elfexw,
                               (TEXTMETRICW *)&pntmi->entmw,
                               pefdwScan->flType,
                               lParam );

                }
                else
                {
                    iRet = iAnsiCallback (pefdwScan,
                                          iEnumType,
                                          (FONTENUMPROCA)lpFontFunc,
                                          lParam);

                }
            }

        // Break out of for-loop if callback returned 0.

            if (!iRet)
            {
                break;
            }

        // Next ENUMFONTDATAW.

            pefdwScan = (ENUMFONTDATAW *)((BYTE *)pefdwScan + pefdwScan->cjEfdw);
        }
    }

// Deallocate font enumeration data.

    LOCALFREE(pefdw);

// Remember to close the font enumeration handle.

    vEnumFontsClose(ulEnumID);

// Leave.

    return iRet;
}


/******************************Public*Routine******************************\
* EnumFontsW
*
* History:
*  08-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

int WINAPI EnumFontsW
(
    HDC           hdc,           // enumerate for this device
    LPCWSTR       pwszFaceName,  // use this family name (but Windows erroneously calls in face name *sigh*)
    FONTENUMPROCW lpFontFunc,    // callback
    LPARAM        lParam         // user defined data
)
{
    FIXUP_HANDLE(hdc);

    return EnumFontsInternalW(
               hdc,
               pwszFaceName,
               DEFAULT_CHARSET,
               lpFontFunc,
               lParam,
               TYPE_ENUMFONTS,
               EFI_UNICODE
               );
}


/******************************Public*Routine******************************\
* EnumFontFamiliesW
*
* History:
*  08-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

int WINAPI EnumFontFamiliesW
(
    HDC           hdc,           // enumerate for this device
    LPCWSTR       pwszFaceName,  // use this family name (but Windows erroneously calls in face name *sigh*)
    FONTENUMPROCW lpFontFunc,    // callback
    LPARAM        lParam         // user defined data
)
{
    FIXUP_HANDLE(hdc);

    return EnumFontsInternalW(
               hdc,
               pwszFaceName,
               DEFAULT_CHARSET,
               lpFontFunc,
               lParam,
               TYPE_ENUMFONTFAMILIES,
               EFI_UNICODE
               );

}


/******************************Public*Routine******************************\
* EnumFontFamiliesExW
*
* History:
*
*  Mon 10-Jul-1995 -by- Bodin Dresevic [BodinD]
* Wrote it:
*
\**************************************************************************/

int WINAPI EnumFontFamiliesExW
(
    HDC           hdc,
    LPLOGFONTW    plf,
    FONTENUMPROCW lpFontFunc,
    LPARAM        lParam,
    DWORD         dw
)
{
    PWSZ  pwszFaceName = NULL;

    FIXUP_HANDLE(hdc);

    if (plf && (plf->lfFaceName[0] != L'\0'))
        pwszFaceName = plf->lfFaceName;


    return EnumFontsInternalW(
               hdc,
               pwszFaceName,
               plf ? plf->lfCharSet : DEFAULT_CHARSET,
               lpFontFunc,
               lParam,
               TYPE_ENUMFONTFAMILIESEX,
               EFI_UNICODE
               );

}

/******************************Public*Routine******************************\
*
* int  EnumFontsInternalA
*
* History:
*  28-Jan-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

int  EnumFontsInternalA
(
    HDC           hdc,           // enumerate for this device
    LPCSTR        pszFaceName,   // use this family name (but Windows erroneously calls in face name *sigh*),
    ULONG         lfCharSet,
    FONTENUMPROCA lpFontFunc,    // callback
    LPARAM        lParam,        // user defined data
    ULONG         iEnumType
)
{
    PWSZ pwszFaceName;
    int iRet;
    ULONG cchFaceName;

// If a string was passed in, we need to convert it to UNICODE.

    if ( pszFaceName != (PSZ) NULL )
    {
    // Allocate memory for Unicode string.

        cchFaceName = lstrlenA(pszFaceName) + 1;

        if ( (pwszFaceName = (PWSZ) LOCALALLOC(cchFaceName * sizeof(WCHAR))) == (PWSZ) NULL )
        {
            WARNING("gdi32!EnumFontsA(): could not allocate memory for Unicode string\n");
            GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return 0;
        }

    // Convert string to Unicode.

        vToUnicodeN (
            pwszFaceName,
            cchFaceName,
            pszFaceName,
            cchFaceName
            );
    }

// Otherwise, keep it NULL.

    else
    {
        pwszFaceName = (PWSZ) NULL;
    }

// Call Unicode version.

    iRet = EnumFontsInternalW(
                hdc,
                pwszFaceName,
                lfCharSet,
                (FONTENUMPROCW)lpFontFunc,
                lParam,
                iEnumType,
                0  // not unicode
                );

// Release Unicode string buffer.

    if ( pwszFaceName != (PWSZ) NULL )
    {
        LOCALFREE(pwszFaceName);
    }

    return iRet;
}


/******************************Public*Routine******************************\
*
* int WINAPI EnumFontsA
*
*
* History:
*  28-Jan-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

int WINAPI EnumFontsA
(
    HDC           hdc,           // enumerate for this device
    LPCSTR        pszFaceName,   // use this family name (but Windows erroneously calls in face name *sigh*)
    FONTENUMPROCA lpFontFunc,    // callback
    LPARAM        lParam         // user defined data
)
{
    FIXUP_HANDLE(hdc);

    return  EnumFontsInternalA (
                hdc,
                pszFaceName,
                DEFAULT_CHARSET,
                lpFontFunc,
                lParam,
                TYPE_ENUMFONTS
                );

}


/******************************Public*Routine******************************\
* EnumFontFamiliesA
*
* History:
*  28-Jan-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

int WINAPI EnumFontFamiliesA
(
    HDC           hdc,           // enumerate for this device
    LPCSTR        pszFaceName,   // use this family name (but Windows erroneously calls in face name *sigh*)
    FONTENUMPROCA lpFontFunc,    // callback
    LPARAM        lParam         // user defined data
)
{
    return  EnumFontsInternalA (
                hdc,           // enumerate for this device
                pszFaceName,   // use this family name (but Windows erroneously calls in face name *sigh*)
                DEFAULT_CHARSET,
                lpFontFunc,    // callback
                lParam,        // user defined data
                TYPE_ENUMFONTFAMILIES
                );
}

/******************************Public*Routine******************************\
* EnumFontFamiliesExA
*
* History:
*
*  Mon 10-Jul-1995 -by- Bodin Dresevic [BodinD]
* Wrote it:
*
\**************************************************************************/

int WINAPI EnumFontFamiliesExA
(
    HDC           hdc,
    LPLOGFONTA    plf,
    FONTENUMPROCA lpFontFunc,
    LPARAM        lParam,
    DWORD         dw
)
{
    LPSTR pszFaceName = NULL;

    FIXUP_HANDLE(hdc);

    if (plf && (plf->lfFaceName[0] != '\0'))
        pszFaceName = plf->lfFaceName;

    return  EnumFontsInternalA (
                hdc,           // enumerate for this device
                pszFaceName,   // use this family name (but Windows erroneously calls in face name *sigh*)
                plf ? plf->lfCharSet : DEFAULT_CHARSET,
                lpFontFunc,    // callback
                lParam,        // user defined data
                TYPE_ENUMFONTFAMILIESEX
                );
}


/******************************Public*Routine******************************\
* GetFontResourceInfoW
*
* Client side stub.
*
* History:
*   2-Sep-1993 -by- Gerrit van Wingerden [gerritv]
* Made this a "W" function.
*  15-Jul-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/


BOOL GetFontResourceInfoW (
    LPWSTR   lpPathname,
    LPDWORD  lpBytes,
    LPVOID   lpBuffer,
    DWORD    iType)
{
    ULONG   cjBuffer = *lpBytes;
    int cRet = 0;
    FLONG flEmbed;
    DWORD dwPidTid;

    if ( (lpPathname !=  NULL) &&
         ((cjBuffer == 0) || (lpBuffer != NULL)) )
    {
        if( iType == GFRI_TTFILENAME )
        {
            WCHAR awcPathname[MAX_PATH];
            WCHAR awcTTF[MAX_PATH];

            if (bMakePathNameW(awcPathname, lpPathname, NULL, NULL))
            {
                ULONG size;

                if (size = cGetTTFFromFOT(awcPathname, MAX_PATH, awcTTF, NULL, &flEmbed, &dwPidTid, TRUE))
                {
                // For the case of GFRI_TTFILENAME, the file need not be already
                // loaded. Which means a PFF may or may not exist for this file.

                    *lpBytes = size * sizeof(WCHAR);

                    if (cjBuffer)
                    {
                    // Also return the name if it fits

                    // if awcPathnmae points to a bad FOT file, awcTTF will contain the same FOT file name
                    // passed to the cGetTTTFromFOT. In this case, we want to return FALSE.

                        if ((cjBuffer >= *lpBytes) &&
                            ((size < 5) || _wcsicmp(&awcTTF[size-5], L".FOT")))
                        {
                            RtlMoveMemory(lpBuffer, awcTTF, *lpBytes);
                        }
                        else
                        {
                        // Buffer is too small - error !
                        // or bad FOT file, no TTF file

                            *lpBytes = 0;
                        }
                    }

                    cRet = (*lpBytes != 0);
                }
            }
        }
        else
        {
        // First get a real NT path Name before calling to the kernel

            ULONG  cwc,cFiles;
            FLONG  fl = 0;         // essential initialization
            WCHAR *pwszNtPath;

            if (pwszNtPath = pwszAllocNtMultiplePath(lpPathname,
                                                     &fl,
                                                     &cwc,
                                                     &cFiles,
                                                     FALSE,
                                                     &dwPidTid,
                                                     TRUE))
            {
                cRet = NtGdiGetFontResourceInfoInternalW(
                                                    pwszNtPath,
                                                    cwc,
                                                    cFiles,
                                                    cjBuffer,
                                                    lpBytes,
                                                    lpBuffer,
                                                    iType);
                LOCALFREE(pwszNtPath);
            }
        }
    }

    return( cRet );
}



/******************************Public*Routine******************************\
* bMakePathNameW (PWSZ pwszDst, PWSZ pwszSrc, PWSZ *ppwszFilePart)
*
* Converts the filename pszSrc into a fully qualified pathname pszDst.
* The parameter pszDst must point to a WCHAR buffer at least
* MAX_PATH*sizeof(WCHAR) bytes in size.
*
* An attempt is made find the file first in the new win95 directory
* %windows%\fonts (which also is the first directory in secure font path,
* if one is defined) and then we do the old fashioned windows stuff
* where SearchPathW searches directories in usual order
*
* ppwszFilePart is set to point to the last component of the pathname (i.e.,
* the filename part) in pwszDst.  If this is null it is ignored.
*
* Returns:
*   TRUE if sucessful, FALSE if an error occurs.
*
* History:
*  Mon 02-Oct-1995 -by- Bodin Dresevic [BodinD]
* update: added font path stuff
*  30-Sep-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/



BOOL bMakePathNameW (
    WCHAR  *pwszDst,
    WCHAR  *pwszSrc,
    WCHAR **ppwszFilePart,
    FLONG  *pfl
)
{
    WCHAR * pwszD, * pwszS, * pwszF;
    BOOL    bOk;
    ULONG   ulPathLength = 0;    // essential to initialize
    ULONG   cwcSystem;
    ULONG   cwcDst;
    WCHAR  *pwcTmp;

    if (pfl)
        *pfl = 0;

    if (ppwszFilePart == NULL)
    {
        ppwszFilePart = &pwszF;
    }

// init unicode path for the fonts directory, %windir%\fonts that is:
// This is always defined in NT versions > 3.51.

    ENTERCRITICALSECTION(&semLocal);
    bOk = bInitSystemAndFontsDirectoriesW(&gpwcSystemDir, &gpwcFontsDir);
    LEAVECRITICALSECTION(&semLocal);

// bInitFontDirectoryW logs the error code and prints warning, just exit

    if (!bOk)
        return FALSE;

    ASSERTGDI(gpwcFontsDir, "gpwcFontsDir not initialized\n");

// if relative path

    if
    (
        (pwszSrc[0] != L'\\') &&
        !((pwszSrc[1] == L':') && (pwszSrc[2] == L'\\'))
    )
    {
        if (pfl)
        {
            *pfl |= FONT_RELATIVE_PATH;
        }

    // find out if the font file is in %windir%\fonts

        ulPathLength = SearchPathW (
                            gpwcFontsDir,
                            pwszSrc,
                            NULL,
                            MAX_PATH,
                            pwszDst,
                            ppwszFilePart);

#ifdef DEBUG_PATH
        DbgPrint("SPW1: pwszSrc = %ws\n", pwszSrc);
        if (ulPathLength)
            DbgPrint("SPW1: pwszDst = %ws\n", pwszDst);
#endif // DEBUG_PATH
    }

// Search for file using default windows path and return full pathname.
// We will only do so if we did not already find the font in the
// %windir%\fonts directory or if pswzSrc points to the full path
// in which case search path is ignored

    if (ulPathLength == 0)
    {
        if (ulPathLength = SearchPathW (
                            NULL,
                            pwszSrc,
                            NULL,
                            MAX_PATH,
                            pwszDst,
                            ppwszFilePart))
        {
        // let us figure it out if the font is in the
        // system directory, or somewhere else along the path:

            if (pfl)
            {
                cwcSystem = wcslen(gpwcSystemDir);
                cwcDst = wcslen(pwszDst);

                if (cwcDst > (cwcSystem + 1)) // + 1 for L'\\'
                {
                    if (!_wcsnicmp(pwszDst, gpwcSystemDir, cwcSystem))
                    {
                        pwcTmp = &pwszDst[cwcSystem];
                        if (*pwcTmp == L'\\')
                        {
                            pwcTmp++; // skip it and see if there are any more of these in pszDst
                            for (;(pwcTmp < &pwszDst[cwcDst]) && (*pwcTmp != L'\\'); pwcTmp++)
                                ;
                            if (*pwcTmp != L'\\')
                                *pfl |= FONT_IN_SYSTEM_DIR;
                        }
                    }
                }
            }

        }

#ifdef DEBUG_PATH
        DbgPrint("SPW2: pwszSrc = %ws\n", pwszSrc);
        if (ulPathLength)
            DbgPrint("SPW2: pwszDst = %ws\n", pwszDst);
#endif // DEBUG_PATH
    }
    else
    {
        if (pfl)
        {
            *pfl |= FONT_IN_FONTS_DIR;
        }
    }

    ASSERTGDI(ulPathLength <= MAX_PATH, "bMakePathNameW, ulPathLength\n");

// finally we test to see if this is one of these fonts that were moved
// by setup  during upgrade from system to fonts dir,
// but the registry entry for that font
// contained full path to system so that the code above would not have found
// this font. This code is only called by font sweeper as signified by
// pfl != NULL. More desription follows below

// This part of routine handles the upgrade situation where NT 3.51 font applet
// wrote the full path of the .fot file that lives in %windir%\system
// directory in the registry. This redundant situation happens
// when tt fonts are installed under 3.51 but ttf's are not copied
// to %windir%\system directory. Some ill behaved  apps also write the
// full path of .fot files in the system directory in the registry.
// On upgrade for 4.0 the system setup copies all .fot files from
// system to fonts directory. bMakePathNameW will therefore fail to find
// the fot file because the file was moved to fonts by setup AND full,
// no longer correct path to fot file, is passed to this routine.
// That is why we try to find out if the full path is the one
// describing system dir and if so, retry to find .fot in fonts dir.

    if (pfl && (ulPathLength == 0))
    {
    // first check if the full path to .fot file points to the
    // file which USED to be in the system directory.

        ULONG cwcFileName = wcslen(pwszSrc);
        cwcSystem   = wcslen(gpwcSystemDir);

        if ((cwcFileName + 1) > cwcSystem) // + 1 for L'\\'
        {
            if (!_wcsnicmp(gpwcSystemDir, pwszSrc, cwcSystem))
            {
                pwszSrc += cwcSystem;
                if (pwszSrc[0] == L'\\')
                {
                    pwszSrc += 1; // skip L'\\'

                // make sure there are no more directory separators L'\\' in
                // the remaining path, ie. that this is indeed a relative path

                    for (pwcTmp = pwszSrc; *pwcTmp != L'\0'; pwcTmp++)
                        if (*pwcTmp == L'\\')
                            break;

                // now check if the .fot file has been moved to fonts dir

                    if (*pwcTmp == L'\0')
                    {
                        ulPathLength = SearchPathW (
                                            gpwcFontsDir,
                                            pwszSrc,
                                            NULL,
                                            MAX_PATH,
                                            pwszDst,
                                            ppwszFilePart);

                        if (ulPathLength)
                            *pfl |= FONT_IN_FONTS_DIR;
                    }
                }
            }
        }
    }

// If search was successful return TRUE:

    return (ulPathLength != 0);
}


/******************************Private*Routine******************************\
*
* BOOL IsWinPERemoteBootDrive( PCWSTR Drive )
*
* History:
*  July 19, 2001.  acosma - Added routine. 
* 
\**************************************************************************/

static BOOL IsWinPERemoteBootDrive( PCWSTR Drive )
/*++

Routine Description:

    Finds out if we are currently running on WinPE booted remotely.

Arguments:

    None.

Return value:

    TRUE if this is a WinPE remote boot otherwise FALSE.

--*/    
{
    static BOOL Result = FALSE;
    static BOOL Initialized = FALSE;
    static WCHAR WindowsDrive = 0;
      

    if (!Initialized) {    
        HKEY hKey = NULL;
        WCHAR WindowsDir[MAX_PATH] = {0};

        Initialized = TRUE;

        if (GetWindowsDirectoryW(WindowsDir, sizeof(WindowsDir)/sizeof(TCHAR))) {
            WindowsDir[3] = 0;

            WindowsDrive = WindowsDir[0];
            
            //
            // If the drive type is DRIVE_REMOTE then we have booted from
            // network.
            //
            Result = (GetDriveTypeW(WindowsDir) == DRIVE_REMOTE);
            
            if (Result) {
                if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                                        "SYSTEM\\CurrentControlSet\\Control\\MiniNT", 
                                        0, 
                                        KEY_READ, 
                                        &hKey)) {
                    Result = TRUE;
                    CloseHandle(hKey);
                } else {
                    Result = FALSE;
                }                    
            }
        }    
    }

    //
    // Is this WinPE remote boot and is the passed in drive valid & its windows drive?
    //
    return (Result && Drive && Drive[0] && (WindowsDrive == Drive[0]));
}



/******************************Public*Routine******************************\
*
* BOOL bFileIsOnTheHardDrive(PWCHAR pwszFullPathName)
*
* History:
*  Fri 22-Jul-1994 -by- Gerrit van Wingerden [gerritv]
* Stole it from BodinD
\**************************************************************************/



BOOL bFileIsOnTheHardDrive(WCHAR *pwszFullPathName)
{
    WCHAR awcDrive[4];
    
    if (pwszFullPathName[1] != (WCHAR)':')
    {
    // the file path has the form \\foo\goo. Even though this could be
    // a share on the local hard drive, this is not very likely. It is ok
    // for the sake of simplicity to consider this a remote drive.
    // The only side effect of this is that in this unlikely case the font
    // would get unloaded at logoff and reloaded at logon time

        return FALSE;
    }


// make a zero terminated string with drive string
// to be feed into GetDriveType api. The string has to have the form: "x:\"

    awcDrive[0] = pwszFullPathName[0]; // COPY DRIVE LETTER
    awcDrive[1] = pwszFullPathName[1]; // COPY ':'
    awcDrive[2] = (CHAR)'\\';         // obvious
    awcDrive[3] = (CHAR)'\0';         // zero terminate

    if ( IsWinPERemoteBootDrive(awcDrive) )
    {
        // If we are in WinPE and this is a remote boot then always return true
        // to this so that we don't wait until logon to load fonts, since in 
        // WinPE we don't logon, and the system drive is a net drive but we 
        // already have credentials to access it since the OS is booting from
        // there
        // Doing this after checking for the \\foo\goo so that we don't accidentaly
        // try to load fonts that ARE really on some net share in the
        // Remote boot WinPE case.
        //
        return TRUE;
    }

// for this pupose, only net drives are not considered hard drives
// so that we can boot of Bernoulli removable drives

    switch (GetDriveTypeW((LPCWSTR)awcDrive))
    {
    case DRIVE_REMOVABLE:
    case DRIVE_FIXED:
    case DRIVE_CDROM:
    case DRIVE_RAMDISK:
        return 1;
    default:
        return 0;
    }

}



BOOL bFontPathOk(WCHAR * pwszPathname);


WCHAR * pwszAllocNtMultiplePath(
LPWSTR  pwszFileName,
FLONG  *pfl,
ULONG  *pcwc,
ULONG  *pcFiles,
BOOL    bAddFR,     // called by add or remove fr
DWORD   *pdwPidTid,  // PID/TID for embedded font
BOOL    bChkFOT
)
{

    BOOL  bDoIt = FALSE;
    BOOL  bReturn = TRUE;      
    ULONG cwc;
    ULONG iFile;
    ULONG cFiles = 1;  // number of paths separated by | separator
    WCHAR *pwszOneFile;
    WCHAR *pwchMem;
    WCHAR *pwcNtPaths;
    FLONG flTmp = 0; // essential initialization
    FLONG fl = (pfl ? *pfl : 0); // essential initialization
    FLONG flEmbed = 0;

// scan the string to figure out how many individual file names are
// in the input string:

    for (pwszOneFile = pwszFileName; *pwszOneFile; pwszOneFile++)
    {
        if (*pwszOneFile == PATH_SEPARATOR)
            cFiles++;
    }

// allocate memory where NtPathNames are going to be stored:

    pwchMem = (WCHAR *)LOCALALLOC(cFiles * sizeof(WCHAR) * MAX_PATH);

    if (pwchMem)
    {
    // set the pointers for the loop:

        pwcNtPaths  = pwchMem;
        pwszOneFile = pwszFileName;   // reset this from the loop above
        cwc         = 0;              // measure the whole NtPaths string
        bDoIt       = TRUE;

        for (iFile = 0; iFile < cFiles; iFile++)
        {
            WCHAR awchOneFile[MAX_PATH];
            WCHAR awcPathName[MAX_PATH];
            WCHAR awcTTF[MAX_PATH];

            WCHAR *pwcTmp = awchOneFile;

        // copy the file to the buffer on the stack and zero terminate it
        // the whole point of this is just to ensure zero termination

            while ((*pwszOneFile != L'\0') && (*pwszOneFile != PATH_SEPARATOR))
                *pwcTmp++ = *pwszOneFile++;

            pwszOneFile++; // skip the separator or terminating zero

            *pwcTmp = L'\0'; // zero terminate

            if
            (
                bMakePathNameW(awcPathName, awchOneFile,NULL,NULL) &&
                cGetTTFFromFOT(awcPathName, MAX_PATH, awcTTF, NULL, &flEmbed, pdwPidTid, bChkFOT)
            )
            {
            // we have to make sure that the font lies in the font path
            // if one is defined. This needs to be done before converting
            // to NtPathNames because the names in the registry are "dos"
            // path names, not Nt path names

                UNICODE_STRING UniStr;
                ULONG          cwcThis;

            // the next portion of code is only done for AddFontResourceCase

                if (bAddFR)
                {
                    if (bFontPathOk(awcTTF))
                    {
                        if (bFileIsOnTheHardDrive(awcTTF))
                            flTmp |= AFRW_ADD_LOCAL_FONT;
                        else
                            flTmp |= AFRW_ADD_REMOTE_FONT;

                    }
                    else
                    {
                        bDoIt = FALSE;
                        break; // out of the loop
                    }
                }

                #if defined(_GDIPLUS_)

                cwcThis = wcslen(awcTTF) + 1;

                RtlCopyMemory(pwcNtPaths, awcTTF, cwcThis*sizeof(WCHAR));

                if (iFile < cFiles - 1)
                    pwcNtPaths[cwcThis - 1] = PATH_SEPARATOR;
                else
                    pwcNtPaths[cwcThis - 1] = L'\0';

                cwc += cwcThis;
                pwcNtPaths += cwcThis;

                #else // !_GDIPLUS_

            // let us check the error return here:

                bReturn = RtlDosPathNameToNtPathName_U(awcTTF,
                                             &UniStr,
                                             NULL,
                                             NULL);

            // get the size out of the unicode string,
            // update cwc, copy out, and then free the memory

                if (bReturn && (UniStr.Buffer))
                {
                    cwcThis = (UniStr.Length/sizeof(WCHAR) + 1);
                    cwc += cwcThis;

                    RtlCopyMemory(pwcNtPaths, UniStr.Buffer, UniStr.Length);

                    if (iFile < (cFiles - 1))
                        pwcNtPaths[cwcThis - 1] = PATH_SEPARATOR;
                    else
                        pwcNtPaths[cwcThis - 1] = L'\0';


                    pwcNtPaths += cwcThis;

                // free this memory, not needed any more

                    RtlFreeHeap(RtlProcessHeap(),0,UniStr.Buffer);
                }
                else
                {
                    bDoIt = FALSE;
                    break; // out of the loop
                }

                #endif // !_GDIPLUS_
            }
            else
            {
                bDoIt = FALSE;
                break; // out of the loop
            }

        }  // end of the "for" loop

    // now check if we are going to reject the font because
    // only local or only remote fonts are requested to be loaded

        if (bDoIt && bAddFR)
        {
            switch (fl & (AFRW_ADD_REMOTE_FONT|AFRW_ADD_LOCAL_FONT))
            {
            case AFRW_ADD_REMOTE_FONT:
            // we say that the font is remote if AT LEAST ONE of the files
            // is remote.

                if (!(flTmp & AFRW_ADD_REMOTE_FONT))
                    bDoIt = FALSE;
                break;
            case AFRW_ADD_LOCAL_FONT:
            // conversely, we say that it is local when it is not remote,
            // that is when ALL files are local

                if (flTmp & AFRW_ADD_REMOTE_FONT)
                    bDoIt = FALSE;
                break;

            case (AFRW_ADD_REMOTE_FONT|AFRW_ADD_LOCAL_FONT):
                RIP("AddFontResourceW, bogus flag combination");
                bDoIt = FALSE;
                break;
            default:

            // flag if this font should be removed at the log off time

                if (flTmp & AFRW_ADD_REMOTE_FONT)
                {
                // always remove fonts on the net on the log off,
                // whether they be listed in the registry or not.
                // The point is that even if they are listed, drive letters
                // may change if a different user logs on. If this font is
                // NOT in the registry, it is a temporary remote font added
                // by an app, so we want it removed on the next log off.

                    *pfl |= AFRW_ADD_REMOTE_FONT;
                }
                else
                {
                // do not remove, even if not in the registry, i.e. even
                // if this is a temp. font added by some app. This is ok
                // since this is a local font, drive letter destinations
                // do not change even when a different user logs on. Note
                // that this is little bit different that 3.51 behavior.
                // This way every font is marked at AddFontResource time
                // for whether it should be removed or not at log off time.
                // This makes time consuming registry searches at log off
                // time unnecessary. The drawback is that the next user
                // to log on may still have local temp fonts loaded
                // from a previous user's session

                    *pfl |= AFRW_ADD_LOCAL_FONT;
                }
                break;
            }
        }
    }

    if (!bDoIt)
    {
        *pcwc    = 0;
        *pcFiles = 0;

        if (pwchMem)
        {
            LOCALFREE(pwchMem);
            pwchMem = NULL;
        }
    }
    else // success
    {
        *pcwc    = cwc;
        *pcFiles = cFiles;

    // set flag for embedded fonts

        *pfl |= flEmbed;

        ASSERTGDI((flEmbed & (FRW_EMB_PID|FRW_EMB_TID)) == flEmbed, "Embedded fonts: flEmbed\n");
        ASSERTGDI((!flEmbed) || (cFiles == 1), "Embedded fonts but cFiles != 1\n");
    }

    return pwchMem;
}


int GdiAddFontResourceW (
    LPWSTR  pwszFileName,            // ptr. to unicode filename string
    FLONG   fl,
    DESIGNVECTOR *pdv
    )
{
    int   iRet = 0;
    ULONG cFiles, cwc;
    WCHAR *pwszNtPath;
    DWORD dwPidTid;


    if (pwszNtPath = pwszAllocNtMultiplePath(pwszFileName,
                                             &fl,
                                             &cwc,
                                             &cFiles,
                                             TRUE,
                                             &dwPidTid, FALSE))
    {

        iRet = NtGdiAddFontResourceW(pwszNtPath,cwc,
                                     cFiles,fl,dwPidTid, pdv);

        LOCALFREE(pwszNtPath);

        if (!iRet)
        {
            pwszNtPath = NULL;
            cFiles = 0;
            cwc = 0;
            dwPidTid = 0;
            if (pwszNtPath = pwszAllocNtMultiplePath(pwszFileName,
                                                     &fl,
                                                     &cwc,
                                                     &cFiles,
                                                     TRUE,
                                                     &dwPidTid, TRUE))
            {

                iRet = NtGdiAddFontResourceW(pwszNtPath,cwc,
                                             cFiles,fl,dwPidTid, pdv);
    
                LOCALFREE(pwszNtPath);

            }
        }
    }

    
    return iRet;
}


/******************************Public*Routine******************************\
*
* int WINAPI AddFontResource(LPSTR psz)
*
* History:
*  13-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


int WINAPI AddFontResourceA(LPCSTR psz)
{
    return AddFontResourceExA(psz,0, NULL);
}


/******************************Public*Routine******************************\
*
* int WINAPI AddFontResourceExA(LPSTR psz, DWORD dwFlag, PVOID NULL)
*
* History:
*  29-Aug-1996 -by- Xudong Wu [TessieW]
* Wrote it.
\**************************************************************************/


int WINAPI AddFontResourceExA(LPCSTR psz, DWORD fl, PVOID pvResrved)
{
    int     iRet = 0;
    WCHAR   awcPathName[MAX_PATH];
    ULONG   cch, cwc;
    WCHAR  *pwcPathName = NULL;
    DESIGNVECTOR * pdv = NULL;

// check invalid flag

    if ( fl & ~(FR_PRIVATE | FR_NOT_ENUM) )
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

// protect ourselves from bogus pointers, win95 does it

    try
    {
        cch = lstrlenA(psz) + 1;
        if (cch <= MAX_PATH)
        {
            pwcPathName = awcPathName;
            cwc = MAX_PATH;
        }
        else
        {
            pwcPathName = (WCHAR *)LOCALALLOC(cch * sizeof(WCHAR));
            cwc = cch;
        }

        if (pwcPathName)
        {
            vToUnicodeN(pwcPathName, cwc, psz, cch);
            iRet = 1;
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        iRet = 0;
    }

    if (iRet)
        iRet = GdiAddFontResourceW(pwcPathName,(FLONG)fl, pdv);

    if (pwcPathName && (pwcPathName != awcPathName))
        LOCALFREE(pwcPathName);

    return iRet;
}


/**************************Public*Routine************************\
* int WINAPI AddFontMemResourceEx()
*
* Font image pointed by pFileView is loaded as private font
* (FR_PRIVATE | FR_NOT_ENUM) to the system private font tale.
*
* If succeeds, it returns an index to the global memory font
* link list, otherwise it returns zero.
*
* History:
*  20-May-1997 -by- Xudong Wu [TessieW]
* Wrote it.
\****************************************************************/

HANDLE WINAPI AddFontMemResourceEx
(
    PVOID pFileView,
    DWORD cjSize,
    PVOID pvResrved,
    DWORD* pNumFonts)
{
    DWORD   cjDV = 0;
    DESIGNVECTOR * pdv = NULL;

    // check size and pointer

    if ((cjSize == 0) || (pFileView == NULL) || (pNumFonts == NULL))
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    if (pdv)
    {
        cjDV = SIZEOFDV(pdv->dvNumAxes);
    }

    return (NtGdiAddFontMemResourceEx(pFileView, cjSize, pdv, cjDV, pNumFonts));
}


/******************************Public*Routine******************************\
*
* int WINAPI AddFontResourceTracking(LPSTR psz)
*
* This routine calls AddFontResource and, if succesful, keeps track of the
* call along with an unique id identifying the apps.  Later when the app
* goes away, WOW will call RemoveNetFonts to remove all of these added fonts
* if there are on a net share.
*
* History:
*  Fri 22-Jul-1994 -by- Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/

int AddFontResourceTracking(LPCSTR psz, UINT id)
{
    INT iRet;
    AFRTRACKNODE *afrtnNext;
    WCHAR awcPathBuffer[MAX_PATH],*pTmp;
    WCHAR   awcPathName[MAX_PATH];
    BOOL bResult;

    vToUnicodeN(awcPathName, MAX_PATH, psz, lstrlenA(psz) + 1);

    iRet = GdiAddFontResourceW(awcPathName, 0 , NULL);

    if( iRet == 0 )
    {
    // we failed so just return

        return(iRet);
    }

// now get the full pathname of the font

    if (!bMakePathNameW(awcPathBuffer,awcPathName, &pTmp, NULL))
    {
        WARNING("AddFontResourceTracking unable to create path\n");
        return(iRet);
    }

// if this isn't a network font just return

    if( bFileIsOnTheHardDrive( awcPathBuffer ) )
    {
        return(iRet);
    }

// now search the list

    for( afrtnNext = pAFRTNodeList;
         afrtnNext != NULL;
         afrtnNext = afrtnNext->pafrnNext
       )
    {
        if( ( !_wcsicmp( awcPathBuffer, afrtnNext->pwszPath ) ) &&
            ( id == afrtnNext->id ))
        {
        // we've found an entry so update the count and get out of here

            afrtnNext->cLoadCount += 1;
            return(iRet);
        }
    }

// if we got here this font isn't yet in the list so we need to add it

    afrtnNext = (AFRTRACKNODE *) LOCALALLOC( sizeof(AFRTRACKNODE) +
                ( sizeof(WCHAR) * ( wcslen( awcPathBuffer ) + 1)) );

    if( afrtnNext == NULL )
    {
        WARNING("AddFontResourceTracking unable to allocate memory\n");
        return(iRet);
    }

// link it in

    afrtnNext->pafrnNext = pAFRTNodeList;
    pAFRTNodeList = afrtnNext;

// the path string starts just past afrtnNext in our recently allocated buffer

    afrtnNext->pwszPath = (WCHAR*) (&afrtnNext[1]);
    lstrcpyW( afrtnNext->pwszPath, awcPathBuffer );

    afrtnNext->id = id;
    afrtnNext->cLoadCount = 1;

    return(iRet);

}


/******************************Public*Routine******************************\
*
* int RemoveFontResourceEntry( UINT id, CHAR *pszFaceName )
*
* Either search for an entry for a particlur task id and font file or and
* decrement the load count for it or, if pszPathName is NULL unload all
* fonts loaded by the task.
*
* History:
*  Fri 22-Jul-1994 -by- Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/


void RemoveFontResourceEntry( UINT id, WCHAR *pwszPathName )
{
    AFRTRACKNODE *afrtnNext,**ppafrtnPrev;
    BOOL bMore = TRUE;

    while( bMore )
    {

        for( afrtnNext = pAFRTNodeList, ppafrtnPrev = &pAFRTNodeList;
            afrtnNext != NULL;
            afrtnNext = afrtnNext->pafrnNext )
        {
            if( (( pwszPathName == NULL ) ||
                 ( !_wcsicmp( pwszPathName, afrtnNext->pwszPath ))) &&
                 ( id == afrtnNext->id ))
            {
            // we've found an entry so break
                break;
            }

            ppafrtnPrev = &(afrtnNext->pafrnNext);

        }

        if( afrtnNext == NULL )
        {
            bMore = FALSE;
        }
        else
        {
            if( pwszPathName == NULL )
            {
            // we need to call RemoveFontResource LoadCount times to remove this font

                while( afrtnNext->cLoadCount )
                {
                    RemoveFontResourceW( afrtnNext->pwszPath );
                    afrtnNext->cLoadCount -= 1;
                }
            }
            else
            {
                afrtnNext->cLoadCount -= 1;

            // we're only decrementing the ref count so we are done

                bMore = FALSE;
            }

            // now unlink it and a free the memory if the ref count is zero

            if( afrtnNext->cLoadCount == 0 )
            {
                *ppafrtnPrev = afrtnNext->pafrnNext;
                LOCALFREE(afrtnNext);
            }

        }

    }

}




/******************************Public*Routine******************************\
*
* int RemoveFontResourceTracking(LPSTR psz)
*
* History:
*  Fri 22-Jul-1994 -by- Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/

int RemoveFontResourceTracking(LPCSTR psz, UINT id)
{
    INT iRet;
    WCHAR awcPathBuffer[MAX_PATH],*pTmp;
    WCHAR   awcPathName[MAX_PATH];
    BOOL bResult;

    vToUnicodeN(awcPathName, MAX_PATH, psz, lstrlenA(psz) + 1);

#if DBG
    DbgPrint("We made it to RemoveFontsResourceTracking %s\n", psz);
#endif
    iRet = RemoveFontResourceW( awcPathName );

    if( iRet == 0 )
    {
    // we failed so just return

        return(iRet);
    }

// now get the full pathname of the font

    if (!bMakePathNameW(awcPathBuffer, awcPathName, &pTmp, NULL))
    {
        WARNING("RemoveFontResourceTracking unable to create path\n");
        return(iRet);
    }

#if DBG
    DbgPrint("Path is %ws\n", awcPathBuffer);
#endif

// if this isn't a network font just return

    if( bFileIsOnTheHardDrive( awcPathBuffer ) )
    {
        return(iRet);
    }

// now search the list decrement the reference count

    RemoveFontResourceEntry( id, awcPathBuffer );

    return(iRet);
}


void UnloadNetworkFonts( UINT id )
{
    RemoveFontResourceEntry( id, NULL );
}



/******************************Public*Routine******************************\
*
* int WINAPI AddFontResourceW(LPWSTR pwsz)
*
* History:
*  13-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

int WINAPI AddFontResourceW(LPCWSTR pwsz)
{
    return GdiAddFontResourceW((LPWSTR) pwsz, 0 , NULL);
}


/******************************Public*Routine******************************\
*
* int WINAPI AddFontResourceExW
*
* History:
*  29-Aug-1996 -by- Xudong Wu [TessieW]
* Wrote it.
\**************************************************************************/

int WINAPI AddFontResourceExW(LPCWSTR pwsz, DWORD fl, PVOID pvResrved)
{
    DESIGNVECTOR * pdv = NULL;
    
// check invalid flag

    if (fl & ~(FR_PRIVATE | FR_NOT_ENUM))
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    return GdiAddFontResourceW((LPWSTR) pwsz, (FLONG)fl , pdv);
}


/******************************Public*Routine******************************\
*
* BOOL WINAPI RemoveFontResource(LPSTR psz)
*
*
* History:
*  13-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


BOOL WINAPI RemoveFontResourceA(LPCSTR psz)
{
    return RemoveFontResourceExA(psz,0, NULL);
}

/******************************Public*Routine******************************\
*
* BOOL WINAPI RemoveFontResourceExA
*
* Note: Process should use the same flag with the one for AddFontResourceExA
*       to remove the font resource
*
* History:
*  27-Sept-1996 -by- Xudong Wu [TessieW]
* Wrote it.
\**************************************************************************/

BOOL WINAPI RemoveFontResourceExA(LPCSTR psz, DWORD fl, PVOID pvResrved)
{
    BOOL bRet = FALSE;
    WCHAR awcPathName[MAX_PATH];
    ULONG cch, cwc;
    WCHAR *pwcPathName = NULL;
    DESIGNVECTOR * pdv = NULL;
    
// check invalid flag

    if (fl & ~(FR_PRIVATE | FR_NOT_ENUM))
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

// protect ourselves from bogus pointers, win95 does it

    try
    {
        cch = lstrlenA(psz) + 1;
        if (cch <= MAX_PATH)
        {
            pwcPathName = awcPathName;
            cwc = MAX_PATH;
        }
        else
        {
            pwcPathName = (WCHAR *)LOCALALLOC(cch * sizeof(WCHAR));
            cwc = cch;
        }

        if (pwcPathName)
        {
            vToUnicodeN(pwcPathName, cwc, psz, lstrlenA(psz) + 1);
            bRet = 1;
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        bRet = 0;
    }

    if (bRet)
        bRet = RemoveFontResourceExW(pwcPathName,fl, NULL);

    if (pwcPathName && (pwcPathName != awcPathName))
        LOCALFREE(pwcPathName);

    return bRet;
}




/******************************Public*Routine******************************\
*
* BOOL WINAPI RemoveFontResourceW(LPWSTR pwsz)
*
* History:
*  13-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


BOOL WINAPI RemoveFontResourceW(LPCWSTR pwsz)
{
    return RemoveFontResourceExW(pwsz,0, NULL);
}


/******************************Public*Routine******************************\
*
* BOOL WINAPI RemoveFontResourceExW
*
* Note:  needs to pass fl and dwPidTid for Embedded fonts
* History:
*  27-Sept-1996 -by- Xudong Wu [TessieW]
* Wrote it.
\**************************************************************************/


BOOL WINAPI RemoveFontResourceExW(LPCWSTR pwsz, DWORD dwfl, PVOID pvResrved)
{

    BOOL bRet = FALSE;
    ULONG cFiles, cwc;
    FLONG fl = dwfl;
    WCHAR *pwszNtPath;
    DWORD dwPidTid;
    DESIGNVECTOR * pdv = NULL;
    
// check invalid flag

    if (fl & ~(FR_PRIVATE | FR_NOT_ENUM))
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    if (pwsz)
    {
        if (pwszNtPath = pwszAllocNtMultiplePath((LPWSTR)pwsz,
                                                 &fl,
                                                 &cwc,
                                                 &cFiles,
                                                 FALSE,
                                                 &dwPidTid, TRUE))
        {
            bRet = NtGdiRemoveFontResourceW(pwszNtPath, cwc,
                                            cFiles, fl, dwPidTid,
                                            pdv);
            LOCALFREE(pwszNtPath);
        }
    }
    return bRet;

}


/**************************Public*Routine************************\
*
* BOOL WINAPI RemoveFontMemResourceEx()
*
* Note: current process can only remove the memory fonts loaded
* by itself.
*
* History:
*  20-May-1997 -by- Xudong Wu [TessieW]
* Wrote it.
\****************************************************************/

BOOL WINAPI RemoveFontMemResourceEx(HANDLE hMMFont)
{
    if (hMMFont == 0)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    return (NtGdiRemoveFontMemResourceEx(hMMFont));
}

/******************************Public*Routine******************************\
* CreateScalableFontResourceA
*
* Client side stub (ANSI version) to GreCreateScalableFontResourceW.
*
* History:
*  16-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY CreateScalableFontResourceA(
DWORD    flHidden,              // mark file as embedded font
LPCSTR   lpszResourceFile,      // name of file to create
LPCSTR   lpszFontFile,          // name of font file to use
LPCSTR    lpszCurrentPath)       // path to font file
{
// Allocate stack space for UNICODE version of input strings.

    WCHAR   awchResourceFile[MAX_PATH];
    WCHAR   awchFontFile[MAX_PATH];
    WCHAR   awchCurrentPath[MAX_PATH];

// Parameter checking.

    if ( (lpszFontFile == (LPSTR) NULL) ||
         (lpszResourceFile == (LPSTR) NULL)
       )
    {
        WARNING("gdi!CreateScalableFontResourceA(): bad parameter\n");
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

// Convert input strings to UNICODE.

    vToUnicodeN(awchResourceFile, MAX_PATH, lpszResourceFile, lstrlenA(lpszResourceFile)+1);
    vToUnicodeN(awchFontFile, MAX_PATH, lpszFontFile, lstrlenA(lpszFontFile)+1);

    // Note: Whereas the other parameters may be not NULL, lpszCurrentPath
    //       may be NULL.  Therefore, we need to treat it a little
    //       differently.

    if ( lpszCurrentPath != (LPSTR) NULL )
    {
        vToUnicodeN(awchCurrentPath, MAX_PATH, lpszCurrentPath, lstrlenA(lpszCurrentPath)+1);
    }
    else
    {
        awchCurrentPath[0] = L'\0';     // equivalent to NULL pointer for this call
    }

// Call to UNICODE version of call.

    return (CreateScalableFontResourceW (
                flHidden,
                awchResourceFile,
                awchFontFile,
                awchCurrentPath
                )
           );
}

/******************************Public*Routine******************************\
* CreateScalableFontResourceInternalW
*
* Creates a font resource file that contains the font directory and the name
* of the name of the scalable font file.
*
* The flEmbed flag marks the created file as hidden (or embedded).  When an
* embedded font file is added to the system, it is hidden from enumeration
* and may be mapped to only if the bit is set in the LOGFONT.
*
* With regard to pwszCurrentPath and pwszFontFile, two cases are valid:
*
* 1.  pwszCurrentPath is a path (relative, full, etc.)
*     pwszFontFile is only FILENAME.EXT
*
*     In this case, pwszFontFile is stored in the resource file.  The caller
*     is responsible for copying the .TTF file to the \windows\system
*     directory.
*
* 2.  pwszCurrentPath is NULL or a pointer to NULL
*     pwszFontFile is a FULL pathname
*
*     In this case, pwszFontFile is stored in the resource file.  The
*     file must always exist at this pathname.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  12-Apr-1995 Gerrit van Wingerden [gerritv]
*   Moved it to client side for kernel mode.
*  10-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

#define vToASCIIN( pszDst, cch, pwszSrc, cwch)                                \
    {                                                                         \
        RtlUnicodeToMultiByteN((PCH)(pszDst), (ULONG)(cch), (PULONG)NULL,     \
              (PWSZ)(pwszSrc), (ULONG)((cwch)*sizeof(WCHAR)));                \
        (pszDst)[(cch)-1] = 0;                                                \
    }

BOOL CreateScalableFontResourceInternalW (
    FLONG    flEmbed,            // fl
    LPCWSTR   lpwszResourceFile,
    LPCWSTR   lpwszFontFile,
    LPCWSTR   lpwszCurrentPath
)
{
    BOOL    bFullPath = TRUE;           //!localW  nIsNotFullPath
    ULONG   cwchFileName = 0;           // localW  nFileNameLength
    ULONG   cwchFullPath = 0;           // localW  nFullPathLength
    ULONG   cwchModuleName = 0;         // localW  nModuleNameLength
    PWSZ    pwszModuleName;             // localD  lpModuleName
    PTRDIFF dpwszFullPath;              // lovalW  wFullPath
    ULONG   cjFontDir;                  // localW  nSizeFontDir
    ULONG   cchFaceName;                // localW  nFaceNameLength
    PSZ     pszFaceName;                // localD  lpFaceName
    PBYTE   pjOutObj;                   // localD  <lpFontDir, lpOutObj>
    HANDLE  hResFile;                   // localW  hResFile
    WCHAR   awchFullPath[MAX_PATH];  // localV  pFullPath, PATH_LENGTH
    PWSZ    pwszFullPath;
    PWSZ    pwszTmp;
    ULONG   cwch;
    BYTE    ajFontDir[CJ_FONTDIR];
    PSZ     pszTmp;
    BYTE    ajOutObj[CJ_OUTOBJ];
    USHORT  usTmp;

// Parameter check.

    if ( (lpwszFontFile == (LPWSTR) NULL) ||
         (lpwszResourceFile == (LPWSTR) NULL)
       )
    {
        WARNING("CreateScalableFontResourceInternalW(): bad parameter\n");
        return (FALSE);
    }

// If not a NULL ptr, put current path in the full path.

    pwszFullPath = awchFullPath;

    if ( lpwszCurrentPath != (LPWSTR) NULL )
    {
    // Copy current path including the NULL.

        pwszTmp = (PWSZ) lpwszCurrentPath;

        while ( *pwszFullPath++ = *pwszTmp++ );
        cwchFullPath = (ULONG) (pwszTmp - lpwszCurrentPath);   // number of characters copied

    // Back up pointer to the terminating NULL (we have to append here).

        pwszFullPath--;
        cwchFullPath--;

    // If any non-NULL characters were copied, then check to make sure path ends with '\'.

        if (cwchFullPath != 0)
        {
            if (awchFullPath[cwchFullPath - 1] != L'\\')
            {
            // Put in the '\' and NULL and update character count.

                *pwszFullPath++ = L'\\';
                *pwszFullPath = 0x0000;
                cwchFullPath++;

            }

        // Path info was copied, so we didn't have a full path.

            bFullPath = FALSE;
        }

    }

// Append the file name

    pwszTmp = (PWSZ) lpwszFontFile;

    while ( *pwszFullPath++ = *pwszTmp++ );

    // Note: lengths include the NULL.
    cwchFullPath += (ULONG) (pwszTmp - lpwszFontFile);  // add on number of characters copied
    cwchFileName = (ULONG) (pwszTmp - lpwszFontFile);   // number of characters copied

// [Win 3.1 compatibility]
//     Win 3.1 is paranoid.  They parse the full pathname backward to look for
//     filename (without path), just in case both lpwszCurrentPath and
//     pwszFileName (with a path) is passed in.

// Adjust pointer to terminating NULL.

    pwszFullPath--;

// Move pointer to beginning of filename alone.  Figure out the length
// of just the filename.

    pwszTmp = pwszFullPath;

    // Note: loop terminates when beginning of string is reached or
    // the first '\' is encountered.

    for (cwch = cwchFullPath;
         (cwch != 0) && (*pwszTmp != L'\\');
         cwch--, pwszTmp--
        );

    pwszTmp++;                          // backed up one too far

    cwchFileName = cwchFullPath - cwch; // cwch is length of just path

// The filename is the module name, so set the pointer at current position.

    pwszModuleName = pwszTmp;

// Figure out the length of module name (filename with no extention).
// NULL is not counted (nor does it exist!).

    // Note: loop terminates when end of string is reached or
    // '.' is encountered.

    for (cwch = 0;
         (cwch < cwchFileName) && (*pwszTmp != L'.');
         cwch++, pwszTmp++
        );

    // Truncate length to 8 because Win 3.1 does (probably an EXE format
    // requirement).

    cwchModuleName = min(cwch, 8);

// If a full path was passed in via pwszFileName, then set offset to it.

    if ( bFullPath )
    {
        dpwszFullPath = 0;
    }

// Otherwise, set offset to filename alone.

    else
    {
        dpwszFullPath = (PTRDIFF)(pwszModuleName - awchFullPath); // this is win64 safe cast!
        cwchFullPath = cwchFileName;
    }

// Allocate memory on the stack for the Font Directory resource structure.

    RtlZeroMemory((PVOID) ajFontDir, (UINT) CJ_FONTDIR);

// Call GreMakeFontDir to create a Font Directory resource.

    {
        UNICODE_STRING unicodeString;
        PWSZ pwsz;

        RtlDosPathNameToNtPathName_U(awchFullPath,
                                     &unicodeString,
                                     NULL,
                                     NULL);

        cjFontDir = NtGdiMakeFontDir(flEmbed,
                                    ajFontDir,
                                    sizeof(ajFontDir),
                                    unicodeString.Buffer,
                                    (unicodeString.Length + 1) * sizeof(*(unicodeString.Buffer))
                                    );

        if (unicodeString.Buffer)
        {
            RtlFreeHeap(RtlProcessHeap(),0,unicodeString.Buffer);
        }
    }

    if ( cjFontDir == (ULONG ) 0 )
    {
        WARNING("CreateScalableFontResourceInternalW(): fontdir creation failed\n");
        return (FALSE);
    }

// Find the facename and facename length in the font directory.

    pszTmp = (PSZ) (ajFontDir + SIZEFFH + 4 + 1);

    while (*pszTmp++);              // skip the family name.

    pszFaceName = pszTmp;

    // Note: count does not include NULL in this case.

    for (cchFaceName = 0; *pszTmp; pszTmp++, cchFaceName++);

// Allocate memory on the stack for the font resource file memory image.

    RtlZeroMemory((PVOID) ajOutObj, (UINT) CJ_OUTOBJ);

    pjOutObj = ajOutObj;

// Copy generic EXE header into output image.

    RtlCopyMemory(pjOutObj, ajExeHeader, SIZEEXEHEADER);

// Copy generic New EXE header into output image.

    RtlCopyMemory(pjOutObj + SIZEEXEHEADER, ausNewExe, SIZENEWEXE);

// Copy the fake resource table into output image.

    RtlCopyMemory(pjOutObj + SIZEEXEHEADER + SIZENEWEXE, ausFakeResTable, SIZEFAKERESTBL);

// Patch up field, Font Directory Size Index (as a count of aligned pages).

    WRITE_WORD(pjOutObj + OFF_FONTDIRSIZINDEX, (cjFontDir + ALIGNMENTCOUNT - 1) >> ALIGNMENTSHIFT);

// Patch offsets to imported names table and module reference table.

    usTmp = (USHORT) (cwchModuleName +
            READ_WORD(pjOutObj + SIZEEXEHEADER + OFF_ne_restab) +
            6);

    WRITE_WORD((pjOutObj + SIZEEXEHEADER + OFF_ne_imptab), usTmp);
    WRITE_WORD((pjOutObj + SIZEEXEHEADER + OFF_ne_modtab), usTmp);

// Patch offset to entry table.

    usTmp += (USHORT) cwchFileName + 1;
    WRITE_WORD((pjOutObj + SIZEEXEHEADER + OFF_ne_enttab), usTmp);

// Patch offset to and size of non-resident name table.

    usTmp += SIZEEXEHEADER + 4;
    WRITE_DWORD((pjOutObj + SIZEEXEHEADER + OFF_ne_nrestab), (DWORD) usTmp);

    WRITE_WORD((pjOutObj + SIZEEXEHEADER + OFF_ne_cbnrestab), SIZEFONTRES + 4 + cchFaceName);

// Now write some data after the exe headers and fake resource table.

    pjOutObj += SIZEEXEHEADER + SIZENEWEXE + SIZEFAKERESTBL;

// Write out module name length and module name.

    *pjOutObj++ = (BYTE) cwchModuleName;    // win 3.1 assumes < 256, so will we

    // Note: Writing cwchModuleName+1 characters because cwchModuleName
    //       does not include space for a NULL character.

    vToASCIIN((PSZ) pjOutObj, (UINT) cwchModuleName + 1, pwszModuleName, (UINT) cwchModuleName + 1);

    pjOutObj += cwchModuleName & 0x00ff;    // enforce < 256 assumption

// Pad with 5 bytes of zeroes.

    *pjOutObj++ = 0;
    *pjOutObj++ = 0;
    *pjOutObj++ = 0;
    *pjOutObj++ = 0;
    *pjOutObj++ = 0;

// Write out file name length and file name.

    *pjOutObj++ = (BYTE) cwchFileName;      // win 3.1 assumes < 256, so will we

    vToASCIIN((PSZ) pjOutObj, (UINT) cwchFileName, pwszModuleName, (UINT) cwchFileName);

    pjOutObj += cwchFileName & 0x00ff;      // enforce < 256 assumption

// Pad with 4 bytes of zeroes.

    *pjOutObj++ = 0;
    *pjOutObj++ = 0;
    *pjOutObj++ = 0;
    *pjOutObj++ = 0;

// Write out size of non-resident name table and the table itself.

    *pjOutObj++ = (BYTE) (SIZEFONTRES + 4 + cchFaceName);

    RtlCopyMemory(pjOutObj, ajFontRes, SIZEFONTRES);
    pjOutObj += SIZEFONTRES;

    RtlCopyMemory(pjOutObj, pszFaceName, (UINT) cchFaceName);
    pjOutObj += cchFaceName;

// Pad with 8 bytes of zeroes.

    RtlZeroMemory(pjOutObj, 8);
    pjOutObj += 8;

// Store some bogus code.  (Just an x86 RET instruction).

    pjOutObj = ajOutObj + CODE_OFFSET;
    *pjOutObj++ = 0xc3;                 // RET OpCode.
    *pjOutObj++ = 0x00;

// Copy the "full path name" into the resource position.

    pjOutObj = ajOutObj + RESOURCE_OFFSET;

    vToASCIIN((PSZ) pjOutObj, (UINT) cwchFullPath, awchFullPath + dpwszFullPath, (UINT) cwchFullPath);

    pjOutObj += cwchFullPath;

// Pad to paragraph boundary with zeroes.

    RtlZeroMemory(pjOutObj, PRIVRESSIZE - cwchFullPath);

    pjOutObj += PRIVRESSIZE - cwchFullPath;

// Finally, copy the font directory.

    RtlCopyMemory(pjOutObj, ajFontDir, cjFontDir);
    pjOutObj += cjFontDir;

// Add add a one paragraph padding of zeroes.

    RtlZeroMemory(pjOutObj, 16);

// Create the file.

    if ( (hResFile = CreateFileW(lpwszResourceFile,
                                 GENERIC_WRITE | GENERIC_READ,
                                 FILE_SHARE_READ,
                                 NULL,
                                 CREATE_NEW,
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL)) != (HANDLE) -1 )
    {
        //
        // Write memory image to the file.
        //

        ULONG  cjWasWritten;

        if (WriteFile(hResFile,
                      ajOutObj,
                      CJ_OUTOBJ,
                      (LPDWORD) &cjWasWritten,
                      NULL) )
        {
            if (CloseHandle(hResFile) != 0)
            {
                return (TRUE);
            }
            else
            {
                WARNING("CreateScalableFontResourceInternalW(): error closing file\n");
            }
        }
        else
        {
            WARNING("CreateScalableFontResourceInternalW(): error writing to file\n");
        }

        //
        // Close the file on error
        //

        CloseHandle(hResFile);
    }

    return (FALSE);

}



/******************************Public*Routine******************************\
* CreateScalableFontResourceW
*
* Client side stub to GreCreateScalableFontResourceW.
*
* History:
*  16-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY CreateScalableFontResourceW (
DWORD    flHidden,              // mark file as embedded font
LPCWSTR  lpwszResourceFile,     // name of file to create
LPCWSTR  lpwszFontFile,         // name of font file to use
LPCWSTR  lpwszCurrentPath)      // path to font file
{
    BOOL    bRet = FALSE;
    ULONG   cjData;

    ULONG   cwchResourceFile;
    ULONG   cwchFontFile;
    ULONG   cwchCurrentPath;

    WCHAR   awchResourcePathName[MAX_PATH];
    WCHAR   awcPathName[MAX_PATH];
    WCHAR   awcFileName[MAX_PATH];
    PWSZ    pwszFilePart;
    BOOL    bMadePath;

// Parameter checking.

    if ( (lpwszFontFile == (LPWSTR) NULL) ||
         (lpwszResourceFile == (LPWSTR) NULL)
       )
    {
        WARNING("gdi!CreateScalableFontResourceW(): bad parameter\n");
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

// To simplify the client server parameter validation, if lpwszCurrentPath
// is NULL, make it instead point to NULL.

    if ( lpwszCurrentPath == (LPWSTR) NULL )
        lpwszCurrentPath = L"";

// Need to convert paths and pathnames to full qualified paths and pathnames
// here on the client side because the "current directory" is not the same
// on the server side.

// Case 1: lpwszCurrentPath is NULL, so we want to transform lpwszFontFile
//         into a fully qualified path name and keep lpwszCurrentPath NULL.

    if ( *lpwszCurrentPath == L'\0' )
    {
    // Construct a fully qualified path name.

        if (!bMakePathNameW(awcPathName, (LPWSTR) lpwszFontFile, &pwszFilePart, NULL))
        {
            WARNING("gdi!CreateScalableFontResourceW(): could not construct src full pathname (1)\n");
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            return (FALSE);
        }

        lpwszFontFile = awcPathName;
    }

// Case 2: lpwszCurrentPath points to path of font file, so we want to make
//         lpwszCurrentPath into a fully qualified path (not pathnmame) and
//         lpwszFontFile into the file part of the fully qualified path NAME.

    else
    {
    // Concatenate lpwszCurrentPath and lpwszFontFile to make a partial (maybe
    // even full) path.  Keep it temporarily in awcFileName.

        lstrcpyW(awcFileName, lpwszCurrentPath);
        if ( lpwszCurrentPath[wcslen(lpwszCurrentPath) - 1] != L'\\' )
            lstrcatW(awcFileName, L"\\");   // append '\' to path if needed
        lstrcatW(awcFileName, lpwszFontFile);

    // Construct a fully qualified path name.

        if (!bMakePathNameW(awcPathName, awcFileName, &pwszFilePart,NULL))
        {
            WARNING("gdi!CreateScalableFontResourceW(): could not construct src full pathname (2)\n");
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            return (FALSE);
        }

    // Copy out the filename part.

        lstrcpyW(awcFileName, pwszFilePart);

    // Remove the filename part from the path name (so that it is now just
    // a fully qualified PATH).  We do this by turning the first character
    // of the filename part into a NULL, effectively cutting this part off.

        *pwszFilePart = L'\0';

    // Change the pointers to point at our buffers.

        lpwszCurrentPath = awcPathName;
        lpwszFontFile = awcFileName;
    }

// Convert the resource filename to a fully qualified path name.

    if ( !GetFullPathNameW(lpwszResourceFile, MAX_PATH, awchResourcePathName, &pwszFilePart) )
    {
        WARNING("gdi!CreateScalableFontResourceW(): could not construct dest full pathname\n");
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }
    else
    {
        lpwszResourceFile = awchResourcePathName;
    }

    return(CreateScalableFontResourceInternalW( flHidden,
                                                lpwszResourceFile,
                                                lpwszFontFile,
                                                lpwszCurrentPath ));
}


/******************************Public*Routine******************************\
* GetRasterizerCaps
*
* Client side stub to GreGetRasterizerCaps.
*
* History:
*  17-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL  APIENTRY GetRasterizerCaps (
    OUT LPRASTERIZER_STATUS lpraststat, // pointer to struct
    IN UINT                 cjBytes     // copy this many bytes into struct
    )
{
    return(NtGdiGetRasterizerCaps(lpraststat,cjBytes));
}



/******************************Public*Routine******************************\
* SetFontEnumeration                                                       *
*                                                                          *
* Client side stub to GreSetFontEnumeration.                               *
*                                                                          *
* History:                                                                 *
*  09-Mar-1992 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

ULONG SetFontEnumeration(ULONG ulType)
{
    return(NtGdiSetFontEnumeration(ulType));
}

/******************************Public*Routine******************************\
* vNewTextMetricWToNewTextMetric
*
* History:
*  20-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vNewTextMetricExWToNewTextMetricExA (
NEWTEXTMETRICEXA    *pntmexa,
NTMW_INTERNAL       *pntmi
)
{
    NEWTEXTMETRICW  *pntmw = &pntmi->entmw.etmNewTextMetricEx.ntmTm;
    NEWTEXTMETRICA  *pntma = &pntmexa->ntmTm;

    pntma->tmHeight           = pntmw->tmHeight             ; // DWORD
    pntma->tmAscent           = pntmw->tmAscent             ; // DWORD
    pntma->tmDescent          = pntmw->tmDescent            ; // DWORD
    pntma->tmInternalLeading  = pntmw->tmInternalLeading    ; // DWORD
    pntma->tmExternalLeading  = pntmw->tmExternalLeading    ; // DWORD
    pntma->tmAveCharWidth     = pntmw->tmAveCharWidth       ; // DWORD
    pntma->tmMaxCharWidth     = pntmw->tmMaxCharWidth       ; // DWORD
    pntma->tmWeight           = pntmw->tmWeight             ; // DWORD
    pntma->tmOverhang         = pntmw->tmOverhang           ; // DWORD
    pntma->tmDigitizedAspectX = pntmw->tmDigitizedAspectX   ; // DWORD
    pntma->tmDigitizedAspectY = pntmw->tmDigitizedAspectY   ; // DWORD
    pntma->tmItalic           = pntmw->tmItalic             ; // BYTE
    pntma->tmUnderlined       = pntmw->tmUnderlined         ; // BYTE
    pntma->tmStruckOut        = pntmw->tmStruckOut          ; // BYTE
    pntma->ntmFlags           = pntmw->ntmFlags             ;
    pntma->ntmSizeEM          = pntmw->ntmSizeEM            ;
    pntma->ntmCellHeight      = pntmw->ntmCellHeight        ;
    pntma->ntmAvgWidth        = pntmw->ntmAvgWidth          ;
    pntma->tmPitchAndFamily   = pntmw->tmPitchAndFamily     ; //        BYTE
    pntma->tmCharSet          = pntmw->tmCharSet            ; //               BYTE

    pntma->tmFirstChar   = pntmi->tmdNtmw.chFirst;
    pntma->tmLastChar    = pntmi->tmdNtmw.chLast ;
    pntma->tmDefaultChar = pntmi->tmdNtmw.chDefault;
    pntma->tmBreakChar   = pntmi->tmdNtmw.chBreak;

// finally copy font signature, required by EnumFontFamiliesEx

    pntmexa->ntmFontSig = pntmi->entmw.etmNewTextMetricEx.ntmFontSig;
}




/******************************Public*Routine******************************\
*
* BOOL bInitFontPath
*
* History:
*  15-Nov-1994 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL gbFontPathInitialized = FALSE;
PWSZ gpwszFontPath = NULL;



#define FONTPATHKEY L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\FontPath"


BOOL bInitFontPath()
{
    gbFontPathInitialized = TRUE;
    return TRUE;
}



/******************************Public*Routine******************************\
* bFontPathOk()
*
* This is a sleazy hack to make sure that fonts are loaded from a secure
* directory.  If the registry key is defined, then we only load fonts from
* the directories listed in that key.  If the key is not defined, then we
* will load any fonts at all.
*
* Returns:
*
*   returns TRUE if it is ok to load the font file.
*
* History:
*
*  Thu 05-Oct-1995 -by- Bodin Dresevic [BodinD]
* update: Rewrote it
*  03-24-93 -by- Paul Butzi
* Wrote it.
\**************************************************************************/



BOOL bFontPathOk(PWSZ pwszPathname)
{
    WCHAR awszPath[MAX_PATH+sizeof(L"\\WINSRV.DLL")+1];
    PWSZ  pwsz, pwszPath, pwszEnd;
    int   iLen;
    BOOL  bOk;

    ENTERCRITICALSECTION(&semLocal);
    bOk = bInitFontPath();
    LEAVECRITICALSECTION(&semLocal);

// bInitFontPath logs errors, prints warnings etc.

    if (!bOk)
        return FALSE;

    ASSERTGDI(gbFontPathInitialized,
        "gdi32: Secure FontPath has not been initialized\n");

    if (!gpwszFontPath) // font path not defined or empty
    {
        return TRUE;
    }

    // For each element in the path value.

    pwszPath = (PWSZ)gpwszFontPath;
    while ( *pwszPath != UNICODE_NULL )
    {
        for (pwszEnd = pwszPath;
            (*pwszEnd != ';') && (*pwszEnd != UNICODE_NULL);
            pwszEnd += 1)
            ;

        iLen = (int) (pwszEnd - pwszPath);
        if ( iLen == 0 )
        {
            break;
        }

        if ( _wcsnicmp(pwszPathname, pwszPath, iLen) == 0 )
        {

            // strings match, make sure that path is entire prefix of pathname

            for (pwsz = pwszPathname + iLen + 1;
                ;
                pwsz += 1 )
            {
                if ((*pwsz == '\\') || (*pwsz == '/'))
                    break;

                if (*pwsz == UNICODE_NULL)
                    return TRUE;
            }
        }

    // get the next subpath in the font path

        pwszPath = pwszEnd;
        if (*pwszPath != UNICODE_NULL)
        {
            pwszPath += 1;
        }
    }

// Always allow the built in fonts in winsrv.dll to be loaded since winsrv.dll
// better be secure and we want to avoid a bluescreen if the user accidentally
// put a bogus entry in the FontPath key preventing all fonts from being loaded.

    GetSystemDirectoryW( awszPath, MAX_PATH );

    wcscat( awszPath, L"\\WINSRV.DLL" );

    if( _wcsicmp( awszPath, pwszPathname ) == 0 )
    {
        return(TRUE);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\gdiicm.h ===
/******************************Module*Header*******************************\
* Module Name: gdiicm                                                      *
*                                                                          *
* Definitions needed for client side objects.                              *
*                                                                          *
* Copyright (c) 1993-1999 Microsoft Corporation                            *
\**************************************************************************/

//
// ICM
//
#if DBG
#define DBG_ICM 1
#else
#define DBG_ICM 0
#endif

#if DBG_ICM

#define DBG_ICM_API          0x00000001
#define DBG_ICM_WRN          0x00000002
#define DBG_ICM_MSG          0x00000004
#define DBG_ICM_COMPATIBLEDC 0x00000008
#define DBG_ICM_METAFILE     0x00000010

extern ULONG DbgIcm;

//
// trace APIs
//

#define ICMAPI(s)                \
    if (DbgIcm & DBG_ICM_API)    \
    {                            \
        DbgPrint ## s;           \
    }

#define ICMMSG(s)                \
    if (DbgIcm & DBG_ICM_MSG)    \
    {                            \
        DbgPrint ## s;           \
    }

#define ICMWRN(s)                \
    if (DbgIcm & DBG_ICM_WRN)    \
    {                            \
        DbgPrint ## s;           \
    }

#else

#define ICMAPI(s)
#define ICMMSG(s)
#define ICMWRN(s)

#endif

#define LOAD_ICMDLL(errCode) if ((ghICM == NULL) && (!IcmInitialize())) {   \
                                  WARNING("gdi32: Can't load mscms.dll\n"); \
                                  return((errCode));                        \
                             }

//
// The direction of color transform
//
#define ICM_FORWARD   0x0001
#define ICM_BACKWARD  0x0002

//
// Default intents
//
#define LCS_DEFAULT_INTENT LCS_GM_IMAGES
#define DM_DEFAULT_INTENT  DMICM_CONTRAST

typedef struct _PROFILECALLBACK_DATA
{
    PWSTR pwszFileName;
    BOOL  bFound;
} PROFILECALLBACK_DATA, *PPROFILECALLBACK_DATA;

//
// The flags for DIB_TRANSLATE_INFO.TranslateType
//
#define TRANSLATE_BITMAP               0x0001
#define TRANSLATE_HEADER               0x0002

typedef struct _DIB_TRANSLATE_INFO
{
    ULONG        TranslateType;
    BMFORMAT     SourceColorType;
    BMFORMAT     TranslateColorType;
    ULONG        SourceWidth;
    ULONG        SourceHeight;
    ULONG        SourceBitCount;
    LPBITMAPINFO TranslateBitmapInfo;
    ULONG        TranslateBitmapInfoSize;
    PVOID        pvSourceBits;
    ULONG        cjSourceBits;
    PVOID        pvTranslateBits;
    ULONG        cjTranslateBits;
} DIB_TRANSLATE_INFO, *PDIB_TRANSLATE_INFO;

//
// Cached Color Space Structure
//
typedef struct _CACHED_COLORSPACE
{
    LIST_ENTRY     ListEntry;
    HGDIOBJ        hObj;
    FLONG          flInfo;
    ULONG          cRef;
    HPROFILE       hProfile;
    DWORD          ColorIntent;
    BMFORMAT       ColorFormat;
    PROFILE        ColorProfile;
    LOGCOLORSPACEW LogColorSpace;
} CACHED_COLORSPACE, *PCACHED_COLORSPACE;

//
// CACHED_COLORSPACE.flInfo
//
#define HGDIOBJ_SPECIFIC_COLORSPACE    0x010000
#define NOT_CACHEABLE_COLORSPACE       0x020000
#define NEED_TO_FREE_PROFILE           0x040000 // ColorProfile.pProfileData must be GlobalFree()
#define NEED_TO_DEL_PROFILE            0x080000
#define NEED_TO_DEL_PROFILE_WITH_HOBJ  0x100000
#define ON_MEMORY_PROFILE              0x200000

#define DEVICE_CALIBRATE_COLORSPACE    0x000001 // Enable "DeviceColorCalibration" during halftoning
#define METAFILE_COLORSPACE           (0x000002 | HGDIOBJ_SPECIFIC_COLORSPACE) // DC (metafile)
#define DRIVER_COLORSPACE             (0x000004 | HGDIOBJ_SPECIFIC_COLORSPACE) // DC (source)
#define DIBSECTION_COLORSPACE         (0x000010 | HGDIOBJ_SPECIFIC_COLORSPACE) // DIBSection

#define GET_COLORSPACE_TYPE(x)  ((x) & 0x000FFF)

//
// Cached Color Transform Structure
//
typedef struct _CACHED_COLORTRANSFORM
{
    LIST_ENTRY         ListEntry;
    FLONG              flInfo;
    HDC                hdc;
    ULONG              cRef;
    HANDLE             ColorTransform;
    PCACHED_COLORSPACE SourceColorSpace;
    PCACHED_COLORSPACE DestinationColorSpace;
    PCACHED_COLORSPACE TargetColorSpace;
} CACHED_COLORTRANSFORM, *PCACHED_COLORTRANSFORM;

//
// CACHED_COLORTRANSFORM.flInfo
//
#define DEVICE_COLORTRANSFORM      0x0004
#define CACHEABLE_COLORTRANSFORM   0x0010

//
// Matafiled ICC profile
//
typedef struct _MATAFILE_COLORPROFILE
{
    LIST_ENTRY    ListEntry;
    WCHAR         ColorProfile[MAX_PATH];
} METAFILE_COLORPROFILE, *PMETAFILE_COLORPROFILE;

#define IDENT_COLORTRANSFORM  ((PCACHED_COLORTRANSFORM)-1)

//
// Saved ICMINFO for SaveDC and RestoreDC API.
//
typedef struct _SAVED_ICMINFO
{
    LIST_ENTRY             ListEntry;
    DWORD                  dwSavedDepth;      // Saved depth
    PCACHED_COLORSPACE     pSourceColorSpace; // Pointer to source profile data
    PCACHED_COLORSPACE     pDestColorSpace;   // Pointer to destination profile data
    PCACHED_COLORSPACE     pTargetColorSpace; // Pointer to target profile data
    PCACHED_COLORTRANSFORM pCXform;      // Pointer to color transform
    PCACHED_COLORTRANSFORM pBackCXform;  // Pointer to Backward color transform for GetXXX API
    PCACHED_COLORTRANSFORM pProofCXform; // Pointer to Proofing color transform for ColorMatchToTarget()
} SAVED_ICMINFO, *PSAVED_ICMINFO;

//
// ICM related info associated to DC.
//
typedef struct _GDI_ICMINFO
{
    LIST_ENTRY             ListEntry;
    HDC                    hdc;               // hdc who owns this ICM info.
    PVOID                  pvdcattr;          // pointer to dcattr
    FLONG                  flInfo;            // Flags
    PCACHED_COLORSPACE     pSourceColorSpace; // Pointer to source profile data
    PCACHED_COLORSPACE     pDestColorSpace;   // Pointer to destination profile data
    PCACHED_COLORSPACE     pTargetColorSpace; // Pointer to target profile data
    PCACHED_COLORTRANSFORM pCXform;           // Pointer to color transform
    PCACHED_COLORTRANSFORM pBackCXform;       // Pointer to Backward color transform for GetXXX API
    PCACHED_COLORTRANSFORM pProofCXform;      // Pointer to Proofing color transform for ColorMatchToTarget()
    HCOLORSPACE            hDefaultSrcColorSpace; // Handle (kernel-mode) to default source color space
    DWORD                  dwDefaultIntent;   // default intent in LOGCOLORSPACE
    LIST_ENTRY             SavedIcmInfo;      // Saved ICMINFO for SaveDC and RestoreDC API
    WCHAR                  DefaultDstProfile[MAX_PATH]; // DC's default source color profile
} GDI_ICMINFO, *PGDI_ICMINFO;

//
// GDI_ICMINFO.flInfo
//
#define ICM_VALID_DEFAULT_PROFILE    0x0001
#define ICM_VALID_CURRENT_PROFILE    0x0002
#define ICM_DELETE_SOURCE_COLORSPACE 0x0004
#define ICM_ON_ICMINFO_LIST          0x0008
#define ICM_UNDER_INITIALIZING       0x0010
#define ICM_UNDER_CHANGING           0x0020
#define ICM_IN_USE                   (ICM_UNDER_INITIALIZING|ICM_UNDER_CHANGING)

//
// PGDI_ICMINFO INIT_ICMINFO(hdc,pdcattr)
//
#define INIT_ICMINFO(hdc,pdcattr) (IcmInitIcmInfo((hdc),(pdcattr)))

//
// PGDI_ICMINFO GET_ICMINFO(PDC_ATTR)
//
#define GET_ICMINFO(pdcattr)      ((PGDI_ICMINFO)((pdcattr)->pvICM))

//
// BOOL BEXIST_ICMINFO(PDC_ATTR)
//
#define BEXIST_ICMINFO(pdcattr)   (((pdcattr)->pvICM != NULL) ? TRUE : FALSE)

//
// BOOL bNeedTranslateColor(PDC_ATTR)
//
#define bNeedTranslateColor(pdcattr)                     \
        (IS_ICM_HOST(pdcattr->lIcmMode) &&               \
         (!IS_ICM_LAZY_CORRECTION(pdcattr->lIcmMode)) && \
         (pdcattr->hcmXform != NULL))

//
// VOID IcmMarkInUseIcmInfo(PGDI_ICMINFO,BOOL)
//
#define IcmMarkInUseIcmInfo(pIcmInfo,bInUse)           \
        ENTERCRITICALSECTION(&semListIcmInfo);         \
        if ((bInUse))                                  \
            (pIcmInfo)->flInfo |= ICM_UNDER_CHANGING;  \
        else                                           \
            (pIcmInfo)->flInfo &= ~ICM_UNDER_CHANGING; \
        LEAVECRITICALSECTION(&semListIcmInfo);

//
// Functions exports from MSCMS.DLL
//

//
// HPROFILE
// OpenColorProfile(
//    PROFILE pProfile,
//    DWORD   dwDesiredAccess,
//    DWORD   dwShareMode,
//    DWORD   dwCreationMode
//    );  
//
typedef HPROFILE (FAR WINAPI * FPOPENCOLORPROFILEA)(PPROFILE, DWORD, DWORD, DWORD);
typedef HPROFILE (FAR WINAPI * FPOPENCOLORPROFILEW)(PPROFILE, DWORD, DWORD, DWORD);

//
// BOOL
// CloseColorProfile(
//     HPROFILE hProfile
//     );
//
typedef BOOL (FAR WINAPI * FPCLOSECOLORPROFILE)(HPROFILE);

//
// BOOL
// IsColorProfileValid(
//     HPROFILE hProfile
//     );
//
typedef BOOL (FAR WINAPI * FPISCOLORPROFILEVALID)(HPROFILE);

//
// BOOL
// CreateDeviceLinkProfile(
//     PHPROFILE  pahProfile,
//     DWORD      nProfiles,
//     PBYTE     *nProfileData,
//     DWORD      indexPreferredCMM
//     );
//     
typedef BOOL (FAR WINAPI * FPCREATEDEVICELINKPROFILE)(PHPROFILE, DWORD, PBYTE *, DWORD);

//
// HTRANSFORM
// CreateColorTransform(
//     LPLOGCOLORSPACE[A|W] pLogColorSpace,
//     HPROFILE             hDestProfile,
//     HPROFILE             hTargetProfile,
//     DWORD                dwFlags
//     );
//
typedef HTRANSFORM (FAR WINAPI * FPCREATECOLORTRANSFORMA)(LPLOGCOLORSPACEA, HPROFILE, HPROFILE, DWORD);
typedef HTRANSFORM (FAR WINAPI * FPCREATECOLORTRANSFORMW)(LPLOGCOLORSPACEW, HPROFILE, HPROFILE, DWORD);

//
// HTRANSFORM
// CreateMultiProfileTransform(
//     PHPROFILE phProfile,
//     DWORD     nProfiles,
//     PDWORD    padwIntent,
//     DWORD     nIntents,
//     DWORD     dwFlags,
//     DWORD     indexPreferredCMM
//     );
//
typedef HTRANSFORM (FAR WINAPI * FPCREATEMULTIPROFILETRANSFORM)(PHPROFILE, DWORD, PDWORD, DWORD, DWORD, DWORD);

//
// BOOL
// DeleteColorTransform(
//     HTRANSFORM hxform
//     );
//
typedef BOOL (FAR WINAPI * FPDELETECOLORTRANSFORM)(HTRANSFORM);

//
// BOOL
// TranslateBitmapBits(
//     HTRANSFORM    hxform,
//     PVOID         pSrcBits,
//     BMFORMAT      bmInput,
//     DWORD         dwWidth,
//     DWORD         dwHeight,
//     DWORD         dwInputStride,
//     PVOID         pDestBits,
//     BMFORMAT      bmOutput,
//     DWORD         dwOutputStride,
//     PBMCALLBACKFN pfnCallback,
//     ULONG         ulCallbackData
//     );
//
typedef BOOL (FAR WINAPI * FPTRANSLATEBITMAPBITS)(HTRANSFORM, PVOID, BMFORMAT, DWORD, DWORD, DWORD, PVOID, BMFORMAT, DWORD, PBMCALLBACKFN, ULONG);

//
// BOOL
// TranslateColors(
//     HTRANSFORM  hxform,        
//     PCOLOR      paInputColors, 
//     DWORD       nColors,       
//     COLORTYPE   ctInput,       
//     PCOLOR      paOutputColors,
//     COLORTYPE   ctOutput
//     );
//
typedef BOOL (FAR WINAPI * FPTRANSLATECOLORS)(HTRANSFORM, PCOLOR, DWORD, COLORTYPE, PCOLOR, COLORTYPE);

//
// BOOL
// CheckBitmapBits(
//     HTRANSFORM     hxform,
//     PVOID          pSrcBits,
//     BMFORMAT       bmInput,
//     DWORD          dwWidth,
//     DWORD          dwHeight,
//     DWORD          dwStride,
//     PBYTE          paResult,
//     PBMCALLBACKFN  pfnCallback,
//     ULONG          ulCallbackData
//     );
//
typedef BOOL (FAR WINAPI * FPCHECKBITMAPBITS)(HTRANSFORM , PVOID, BMFORMAT, DWORD, DWORD, DWORD, PBYTE, PBMCALLBACKFN, ULONG);

//
// BOOL
// TranslateColors(
//     HTRANSFORM  hxform,
//     PCOLOR      paInputColors,
//     DWORD       nColors,
//     COLORTYPE   ctInput,
//     PCOLOR      paOutputColors,
//     COLORTYPE   ctOutput
//     );
//
typedef BOOL (FAR WINAPI * FPTRANSLATECOLORS)(HTRANSFORM, PCOLOR, DWORD, COLORTYPE, PCOLOR, COLORTYPE);

//
// BOOL
// CheckColors(
//     HTRANSFORM      hxform,
//     PCOLOR          paInputColors,
//     DWORD           nColors,
//     COLORTYPE       ctInput,
//     PBYTE           paResult
//     );
//
typedef BOOL (FAR WINAPI * FPCHECKCOLORS)(HTRANSFORM, PCOLOR, DWORD, COLORTYPE, PBYTE);

//
// DWORD
// GetCMMInfo(
//     HTRANSFORM      hxform,
//     DWORD           dwInfo
//     );
//
typedef DWORD (FAR WINAPI * FPGETCMMINFO)(HTRANSFORM, DWORD);

//
// BOOL
// RegisterCMM(
//     PCTSTR      pMachineName,
//     DWORD       cmmID,
//     PCTSTR       pCMMdll
//     );
//
typedef BOOL (FAR WINAPI * FPREGISTERCMMA)(PCSTR, DWORD, PCSTR);
typedef BOOL (FAR WINAPI * FPREGISTERCMMW)(PCWSTR, DWORD, PCWSTR);

//
// BOOL
// UnregisterCMM(
//    PCTSTR  pMachineName,
//    DWORD   cmmID
//    );
//
typedef BOOL (FAR WINAPI * FPUNREGISTERCMMA)(PCSTR, DWORD);
typedef BOOL (FAR WINAPI * FPUNREGISTERCMMW)(PCWSTR, DWORD);

//
// BOOL
// SelectCMM(
//    DWORD   dwCMMType
//    );
//
typedef BOOL (FAR WINAPI * FPSELECTCMM)(DWORD);

//
// BOOL
// InstallColorProfile(
//    PCTSTR   pMachineName,
//    PCTSTR   pProfileName
//    );
//
typedef BOOL (FAR WINAPI * FPINSTALLCOLORPROFILEA)(PCSTR, PCSTR);
typedef BOOL (FAR WINAPI * FPINSTALLCOLORPROFILEW)(PCWSTR, PCWSTR);

//
// BOOL
// UninstallColorProfile(
//    PCTSTR  pMachineName,
//    PCTSTR  pProfileName,
//    BOOL    bDelete
//    );
//
typedef BOOL (FAR WINAPI * FPUNINSTALLCOLORPROFILEA)(PCSTR, PCSTR, BOOL);
typedef BOOL (FAR WINAPI * FPUNINSTALLCOLORPROFILEW)(PCWSTR, PCWSTR, BOOL);

//
// BOOL
// EnumColorProfiles(
//    PCTSTR          pMachineName,
//    PENUMTYPE[A|W]  pEnumRecord,
//    PBYTE           pBuffer,
//    PDWORD          pdwSize,
//    PDWORD          pnProfiles
//    );
//
typedef BOOL (FAR WINAPI * FPENUMCOLORPROFILESA)(PCSTR, PENUMTYPEA, PBYTE, PDWORD, PDWORD);
typedef BOOL (FAR WINAPI * FPENUMCOLORPROFILESW)(PCWSTR, PENUMTYPEW, PBYTE, PDWORD, PDWORD);

//
// BOOL
// GetStandardColorSpaceProfile(
//    PCTSTR          pMachineName,
//    DWORD           dwSCS,
//    PSTR            pBuffer,
//    PDWORD          pdwSize
//    );
//
typedef BOOL (FAR WINAPI * FPGETSTANDARDCOLORSPACEPROFILEA)(PCSTR, DWORD, PSTR, PDWORD);
typedef BOOL (FAR WINAPI * FPGETSTANDARDCOLORSPACEPROFILEW)(PCWSTR, DWORD, PWSTR, PDWORD);

//
// BOOL
// GetColorProfileHeader(
//    HPROFILE        hProfile,
//    PPROFILEHEADER  pProfileHeader
//    );
//
typedef BOOL (FAR WINAPI * FPGETCOLORPROFILEHEADER)(HPROFILE, PPROFILEHEADER);

//
// BOOL
// GetColorDirectory(
//    PCTSTR          pMachineName,
//    PTSTR           pBuffer,
//    PDWORD          pdwSize
//    );
typedef BOOL (FAR WINAPI * FPGETCOLORDIRECTORYA)(PCSTR, PSTR, PDWORD);
typedef BOOL (FAR WINAPI * FPGETCOLORDIRECTORYW)(PCWSTR, PWSTR, PDWORD);

//
// BOOL WINAPI CreateProfileFromLogColorSpaceA(
//    LPLOGCOLORSPACEA pLogColorSpace,
//    PBYTE            *pBuffer
//    );
//
typedef BOOL (FAR WINAPI * FPCREATEPROFILEFROMLOGCOLORSPACEA)(LPLOGCOLORSPACEA,PBYTE *);
typedef BOOL (FAR WINAPI * FPCREATEPROFILEFROMLOGCOLORSPACEW)(LPLOGCOLORSPACEW,PBYTE *);

//
// BOOL InternalGetDeviceConfig(
//    LPCTSTR pDeviceName,
//    DWORD   dwDeviceClass
//    DWORD   dwConfigType,
//    PVOID   pConfig,
//    PDWORD  pdwSize
//    );
//
typedef BOOL (FAR * FPINTERNALGETDEVICECONFIG)(LPCWSTR,DWORD,DWORD,PVOID,PDWORD);

extern HINSTANCE  ghICM;
extern BOOL       gbICMEnabledOnceBefore;

extern RTL_CRITICAL_SECTION semListIcmInfo;
extern RTL_CRITICAL_SECTION semColorTransformCache;
extern RTL_CRITICAL_SECTION semColorSpaceCache;

extern LIST_ENTRY ListIcmInfo;
extern LIST_ENTRY ListCachedColorSpace;
extern LIST_ENTRY ListCachedColorTransform;

//
// ANSI version function in MSCMS.DLL will not called.
//
// extern FPOPENCOLORPROFILEA           fpOpenColorProfileA;
// extern FPCREATECOLORTRANSFORMA       fpCreateColorTransformA;
// extern FPREGISTERCMMA                fpRegisterCMMA;
// extern FPUNREGISTERCMMA              fpUnregisterCMMA;
// extern FPINSTALLCOLORPROFILEA        fpInstallColorProfileA;
// extern FPUNINSTALLCOLORPROFILEA      fpUninstallColorProfileA;
// extern FPGETSTANDARDCOLORSPACEPROFILEA fpGetStandardColorSpaceProfileA;
// extern FPENUMCOLORPROFILESA          fpEnumColorProfilesA;
// extern FPGETCOLORDIRECTORYA          fpGetColorDirectoryA;
//
// And Following function does not used from gdi32.dll
//
// extern FPISCOLORPROFILEVALID         fpIsColorProfileValid;
// extern FPCREATEDEVICELINKPROFILE     fpCreateDeviceLinkProfile;
// extern FPTRANSLATECOLORS             fpTranslateColors;
// extern FPCHECKCOLORS                 fpCheckColors;
// extern FPGETCMMINFO                  fpGetCMMInfo;
// extern FPSELECTCMM                   fpSelectCMM;
//

extern FPOPENCOLORPROFILEW           fpOpenColorProfileW;
extern FPCLOSECOLORPROFILE           fpCloseColorProfile;
extern FPCREATECOLORTRANSFORMW       fpCreateColorTransformW;
extern FPDELETECOLORTRANSFORM        fpDeleteColorTransform;
extern FPTRANSLATECOLORS             fpTranslateColors;
extern FPTRANSLATEBITMAPBITS         fpTranslateBitmapBits;
extern FPCHECKBITMAPBITS             fpCheckBitmapBits;
extern FPREGISTERCMMW                fpRegisterCMMW;
extern FPUNREGISTERCMMW              fpUnregisterCMMW;
extern FPINSTALLCOLORPROFILEW        fpInstallColorProfileW;
extern FPUNINSTALLCOLORPROFILEW      fpUninstallColorProfileW;
extern FPENUMCOLORPROFILESW            fpEnumColorProfilesW;
extern FPGETSTANDARDCOLORSPACEPROFILEW fpGetStandardColorSpaceProfileW;
extern FPGETCOLORPROFILEHEADER       fpGetColorProfileHeader;
extern FPGETCOLORDIRECTORYW          fpGetColorDirectoryW;
extern FPCREATEPROFILEFROMLOGCOLORSPACEW fpCreateProfileFromLogColorSpaceW;
extern FPCREATEMULTIPROFILETRANSFORM fpCreateMultiProfileTransform;
extern FPINTERNALGETDEVICECONFIG     fpInternalGetDeviceConfig;

//
// Functions GDI internal use (defined in icm.c)
//

//
// Color Translation Functions
//

BOOL
IcmTranslateDIB(
    HDC          hdc,
    PDC_ATTR     pdcattr,
    ULONG        nColors,
    PVOID        pBitsIn,
    PVOID       *ppBitsOut,
    PBITMAPINFO  pbmi,
    PBITMAPINFO *pbmiNew,
    DWORD       *pcjbmiNew,
    DWORD        dwNumScan,
    UINT         iUsage,
    DWORD        dwFlags,
    PCACHED_COLORSPACE *ppBitmapColorSpace,
    PCACHED_COLORTRANSFORM *ppCXform
    );

BOOL
IcmTranslateCOLORREF(
    HDC      hdc,
    PDC_ATTR pdcattr,
    COLORREF ColorIn,
    COLORREF *ColorOut,
    DWORD    Flags
    );

BOOL
IcmTranslateBrushColor(
    HDC      hdc,
    PDC_ATTR pdcattr,
    HBRUSH   hbrush
    );

BOOL
IcmTranslatePenColor(
    HDC      hdc,
    PDC_ATTR pdcattr,
    HPEN     hpen
    );

BOOL
IcmTranslateExtPenColor(
    HDC      hdc,
    PDC_ATTR pdcattr,
    HPEN     hpen
    );

BOOL
IcmTranslateColorObjects(
    HDC      hdc,
    PDC_ATTR pdcattr,
    BOOL     bICMEnable
    );

BOOL
IcmTranslateTRIVERTEX(
    HDC         hdc,
    PDC_ATTR    pdcattr,
    PTRIVERTEX  pVertex,
    ULONG       nVertex
    );

BOOL
IcmTranslatePaletteEntry(
    HDC           hdc,
    PDC_ATTR      pdcattr,
    PALETTEENTRY *pColorIn,
    PALETTEENTRY *pColorOut,
    UINT          NumberOfEntries
    );

//
// DC related functions
//

PGDI_ICMINFO
IcmInitIcmInfo(
    HDC      hdc,
    PDC_ATTR pdcattr
    );

BOOL
IcmCleanupIcmInfo(
    PDC_ATTR     pdcattr,
    PGDI_ICMINFO pIcmInfo
    );

PGDI_ICMINFO
IcmGetUnusedIcmInfo(
    HDC hdc
    );

BOOL
IcmInitLocalDC(
    HDC             hdc,
    HANDLE          hPrinter,
    CONST DEVMODEW *pdm,
    BOOL            bReset
    );

BOOL
IcmDeleteLocalDC(
    HDC          hdc,
    PDC_ATTR     pdcattr,
    PGDI_ICMINFO pIcmInfo
    );

BOOL
IcmUpdateLocalDCColorSpace(
    HDC      hdc,
    PDC_ATTR pdcattr
    );

VOID 
IcmReleaseDCColorSpace(
    PGDI_ICMINFO pIcmInfo,
    BOOL         bReleaseDC
    );

BOOL
IcmUpdateDCColorInfo(
    HDC      hdc,
    PDC_ATTR pdcattr
    );

BOOL
IcmEnableForCompatibleDC(
    HDC      hdcCompatible,
    HDC      hdcDevice,
    PDC_ATTR pdcaDevice
    );

BOOL
IcmSaveDC(
    HDC hdc,
    PDC_ATTR pdcattr,
    PGDI_ICMINFO pIcmInfo
    );

VOID
IcmRestoreDC(
    PDC_ATTR pdcattr,
    int iLevel,
    PGDI_ICMINFO pIcmInfo
    );

//
// SelectObject functions
//

BOOL
IcmSelectColorTransform (
    HDC                    hdc,
    PDC_ATTR               pdcattr,
    PCACHED_COLORTRANSFORM pCXform,
    BOOL                   bDeviceCalibrate
    );

HBRUSH
IcmSelectBrush (
    HDC      hdc,
    PDC_ATTR pdcattr,
    HBRUSH   hbrushNew
    );

HPEN
IcmSelectPen(
    HDC      hdc,
    PDC_ATTR pdcattr,
    HPEN     hpenNew
    );

HPEN
IcmSelectExtPen(
    HDC      hdc,
    PDC_ATTR pdcattr,
    HPEN     hpenNew
    );

//
// Profile Enumuration related
//

int
IcmEnumColorProfile(
    HDC       hdc,
    PVOID     pvCallBack,
    LPARAM    lParam,
    BOOL      bAnsiCallBack,
    PDEVMODEW pDevModeW,
    DWORD    *pdwColorSpaceFlag
    );

int CALLBACK
IcmQueryProfileCallBack(
    LPWSTR lpFileName,
    LPARAM lAppData
    );

int CALLBACK
IcmFindProfileCallBack(
    LPWSTR lpFileName,
    LPARAM lAppData
    );

BOOL
IcmCreateTemporaryColorProfile(
    LPWSTR TemporaryColorProfile,
    LPBYTE ProfileData,
    DWORD  ProfileDataSize
    );

//
// Filename/Path related.
//

PWSTR
GetFileNameFromPath(
    PWSTR pwszFileName
    );

PWSZ
BuildIcmProfilePath(
    PWSZ  FileName,
    PWSZ  FullPathFileName,
    ULONG BufferSize
    );

//
// Color Transform management
//

PCACHED_COLORTRANSFORM
IcmGetFirstNonUsedColorTransform(
    VOID
);

PCACHED_COLORTRANSFORM
IcmGetColorTransform(
    HDC                hdc,
    PCACHED_COLORSPACE pSourceColorSpace,
    PCACHED_COLORSPACE pDestColorSpace,
    PCACHED_COLORSPACE pTargetColorSpace,
    BOOL               bNeedDeviceXform
    );

PCACHED_COLORTRANSFORM
IcmCreateColorTransform(
    HDC                hdc,
    PDC_ATTR           pdcattr,
    PCACHED_COLORSPACE lpOptionalColorSpace,
    DWORD              dwFlags
    );

BOOL
IcmDeleteColorTransform(
    HANDLE   hcmXformToBeDeleted,
    BOOL     bForceDelete
    );

BOOL
IcmDeleteDCColorTransforms(
    PGDI_ICMINFO pIcmInfo
    );

BOOL
IcmDeleteCachedColorTransforms(
    HDC          hdc
    );

BOOL 
IcmIsCacheable(
    PCACHED_COLORSPACE pColorSpace
);

//
// Color Space/Profile management
//

HCOLORSPACE WINAPI
CreateColorSpaceInternalW(
    LPLOGCOLORSPACEW lpLogColorSpace,
    DWORD            dwCreateFlags
    );

BOOL
SetICMProfileInternalA(
    HDC                hdc,
    LPSTR              pszFileName,
    PCACHED_COLORSPACE pColorSpace,
    DWORD              dwFlags
    );

BOOL
SetICMProfileInternalW(
    HDC                hdc,
    LPWSTR             pwszFileName,
    PCACHED_COLORSPACE pColorSpace,
    DWORD              dwFlags
    );

BOOL WINAPI
ColorMatchToTargetInternal(
    HDC                hdc,
    PCACHED_COLORSPACE pTargetColorSpace,
    DWORD              uiAction
    );

HCOLORSPACE
IcmSetSourceColorSpace(
    HDC hdc,
    HCOLORSPACE        hColorSpace,
    PCACHED_COLORSPACE pColorSpace,
    DWORD              dwFlags
    );

BOOL
IcmSetDestinationColorSpace(
    HDC                hdc,
    LPWSTR             pwszFileName,
    PCACHED_COLORSPACE pColorSpace,
    DWORD              dwFlags
    );

BOOL 
IcmSetTargetColorSpace(
    HDC                hdc,
    PCACHED_COLORSPACE pColorSpace,
    DWORD              uiAction
    );

BMFORMAT
IcmGetProfileColorFormat(
    HPROFILE hProfile
    );

BOOL
IcmCreateProfileFromLCS(
    LPLOGCOLORSPACEW  lpLogColorSpaceW,
    PVOID            *ppvProfileData,
    PULONG            pulProfileSize
    );

PCACHED_COLORSPACE
IcmCreateColorSpaceByColorSpace(
    HGDIOBJ          hObj,
    LPLOGCOLORSPACEW lpLogColorSpace,
    PPROFILE         pProfileData,
    DWORD            dwFlags
    );

PCACHED_COLORSPACE
IcmCreateColorSpaceByName(
    HGDIOBJ hObj,
    PWSZ    ColorProfileName,
    DWORD   dwIntent,
    DWORD   dwFlags
    );

PCACHED_COLORSPACE
IcmGetColorSpaceByHandle(
    HGDIOBJ          hObj,
    HCOLORSPACE      hColorSpace,
    LPLOGCOLORSPACEW lpLogColorSpace,
    DWORD            dwFlags
    );

PCACHED_COLORSPACE
IcmGetColorSpaceByColorSpace(
    HGDIOBJ          hObj,
    LPLOGCOLORSPACEW lpLogColorSpace,
    PPROFILE         pProfileData,
    DWORD            dwFlags
    );

PCACHED_COLORSPACE
IcmGetColorSpaceByName(
    HGDIOBJ hObj,
    PWSZ    ColorProfileName,
    DWORD   dwIntent,
    DWORD   dwFlags
    );

BOOL
IcmSameColorSpace(
    PCACHED_COLORSPACE pColorSpaceA,
    PCACHED_COLORSPACE pColorSapceB
    );

VOID
IcmReleaseColorSpace(
    HGDIOBJ            hObj,
    PCACHED_COLORSPACE pColorSpace,
    BOOL               bReleaseDC
    );

BOOL
IcmReleaseCachedColorSpace(
    HGDIOBJ hObj
    );

int
IcmAskDriverForColorProfile(
    PLDC       pldc,
    ULONG      ulQueryMode,
    PDEVMODEW  pDevMode,
    PWSTR      pProfileName,
    DWORD     *pdwColorSpaceFlag
);

BOOL
IcmRealizeColorProfile(
    PCACHED_COLORSPACE pColorSpace,
    BOOL               bCheckColorFormat
);

VOID
IcmUnrealizeColorProfile(
    PCACHED_COLORSPACE pColorSpace
);

//
// Metafile related
//
VOID
IcmInsertMetafileList(
    PLIST_ENTRY pAttachedColorProfile,
    PWSZ        ProfileName
    );

BOOL
IcmCheckMetafileList(
    PLIST_ENTRY pAttachedColorProfile,
    PWSZ        ProfileName
    );

VOID
IcmFreeMetafileList(
    PLIST_ENTRY pAttachedColorProfile
    );

//
// Bitmap color space
//
BOOL
IcmGetBitmapColorSpace(
    LPBITMAPINFO     pbmi,
    LPLOGCOLORSPACEW plcspw,
    PPROFILE         pProfileData,
    PDWORD           pdwFlags
    );

PCACHED_COLORSPACE
IcmGetColorSpaceforBitmap(
    HBITMAP hbm
    );

//
// Icm Blting
//
BOOL
IcmStretchBlt(HDC hdc, int x, int y, int cx, int cy,
              HDC hdcSrc, int x1, int y1, int cx1, int cy1, DWORD rop,
              PDC_ATTR pdcattr, PDC_ATTR pdcattrSrc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\glsup.h ===
/******************************Header*File*********************************\
*
* glsup.h
*
* Header file for GL metafiling and printing support
*
* History:
*  Wed Mar 15 15:20:49 1995	-by-	Drew Bliss [drewb]
*   Created
* Copyright (c) 1995-1999 Microsoft Corporation                            
*
\**************************************************************************/

#ifndef __GLSUP_H__
#define __GLSUP_H__

// Critical section for GL support
extern RTL_CRITICAL_SECTION semGlLoad;

BOOL LoadOpenGL(void);
void UnloadOpenGL(void);

// Track the current banded rendering session
typedef struct
{
    HDC hdcDest;
    HDC hdcDib;
    HBITMAP hbmDib;
    HGLRC hrc;
    int iBandWidth;
    int iBandHeight;
    int iReducedBandWidth;
    int iReducedBandHeight;
    int xSource;
    int ySource;
    int iSourceWidth;
    int iSourceHeight;
    int iReduceFactor;
    int iReducedWidth;
    int iReducedHeight;
    int iStretchMode;
    POINT ptBrushOrg;
    BOOL bBrushOrgSet;
} GLPRINTSTATE;

BOOL InitGlPrinting(HENHMETAFILE hemf, HDC hdcDest, RECT *rc,
                    DEVMODEW *pdm, GLPRINTSTATE *pgps);
void EndGlPrinting(GLPRINTSTATE *pgps);
BOOL PrintMfWithGl(HENHMETAFILE hemf, GLPRINTSTATE *pgps,
                   POINTL *pptlBand, SIZE *pszBand);
BOOL IsMetafileWithGl(HENHMETAFILE hemf);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\font.h ===
/*******************************************************************************
 * font.h
 *
 * Structures for client side caching of char widths.
 *
 * Copyright (c) 1994-1999 Microsoft Corporation
 *
 *******************************************************************************/


/**************************************************************************\
*
*   CFONT's are a client side cache of font metric information.  This includes
*   character widths for the first 256 glyphs as well as textmetric's and
*   average character width used by USER's GetCharDimensions.  There are two
*   flavors of this cache, public and private.
*
*   private:
*       for private fonts, the pUser field in the handle table points to a
*       LOCALFONT.  The LOCALFONT has a chain of CFONT's hanging off it for
*       accumulating information per transform.
*
*   public:
*       For public fonts which include both stock fonts and fonts USER makes
*       public, the CFONT structures live in a shared memory area in the
*       GDI_SHARED_MEMORY structure which is mapped into all processes with
*       the handle manager table.  For these fonts, we only cache data for
*       the primary display and a 1-to-1 mapping (MM_TEXT).  This way, there
*       is only CFONT per public font.
*
\**************************************************************************/


// Flags for LOCALFONT.fl:

#define LF_HARDWAY        0x0001    // Font not worth mapping client side.

typedef struct _LOCALFONT
{
    FLONG              fl;
    CFONT             *pcf;
} LOCALFONT;



LOCALFONT *plfCreateLOCALFONT(FLONG fl);
VOID       vDeleteLOCALFONT(LOCALFONT *plf);

CFONT     *pcfLocateCFONT(HDC hdc,PDC_ATTR pDcAttr,UINT iFirst,PVOID pch,UINT c,BOOL bType);
BOOL       bGetTextExtentA(HDC hdc,LPCSTR psz,int c,LPSIZE psizl,UINT fl);
BOOL       bGetTextExtentW(HDC hdc,LPCWSTR pwsz,int cwc,LPSIZE psizl,UINT fl);
BOOL       bComputeTextExtent(PDC_ATTR pDcAttr,CFONT *pcf,PVOID psz,int cc,UINT fl,SIZE *psizl, BOOL bType);
BOOL       bComputeCharWidths(CFONT *pcf,UINT iFirst, UINT iLast,ULONG fl,PVOID pv);
BOOL       bGetTextMetricsWInternal(HDC hdc,TMW_INTERNAL * ptmw,int cjTM,CFONT *pcf);

VOID FASTCALL vTextMetricWToTextMetric(LPTEXTMETRICA,TMW_INTERNAL *);
VOID FASTCALL vTextMetricWToTextMetricStrict(LPTEXTMETRICA,LPTEXTMETRICW);

VOID vConvertEnumLogFontExDvAtoW(ENUMLOGFONTEXDVW *pelfw, ENUMLOGFONTEXDVA *pelfa);
VOID vConvertLogFontW(ENUMLOGFONTEXDVW *pelfw, LOGFONTW *plfw);
VOID vConvertLogFont(ENUMLOGFONTEXDVW *pelfw, LOGFONTA *plf);
BOOL bConvertEnumLogFontExWToEnumLogFontExA(ENUMLOGFONTEXA *,ENUMLOGFONTEXW *);
BOOL bConvertLogFontWToLogFontA(LOGFONTA *, LOGFONTW *);

typedef struct _CLIENT_SIDE_FILEVIEW    // fvw
{
    HANDLE hf;       // file handle
    HANDLE hSection; // section handle
    PVOID  pvView;           // pointer to the view of the memory mapped file
    ULONG  cjView;           // size, really end of the file information
} CLIENT_SIDE_FILEVIEW, *PCLIENT_SIDE_FILEVIEW;

BOOL bMapFileUNICODEClideSide(PWSTR pwszFileName, CLIENT_SIDE_FILEVIEW *pfvw, BOOL bNtPath);
VOID vUnmapFileClideSide(PCLIENT_SIDE_FILEVIEW pfvw);

#define WVT_PERF_EVAL
VOID vGetWvtPerf(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\glsup.c ===
/******************************Header*File*********************************\
*
* glsup.c
*
* GL metafiling and printing support
*
* History:
*  Wed Mar 15 15:20:49 1995 -by-    Drew Bliss [drewb]
*   Created
*
* Copyright (c) 1995-1999 Microsoft Corporation                            
*
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "glsup.h"


// GL metafile callbacks in opengl32
typedef struct _GLMFCALLBACKS
{
    BOOL  (APIENTRY *GlmfInitPlayback)(HDC, ENHMETAHEADER *, LPRECTL);
    BOOL  (APIENTRY *GlmfBeginGlsBlock)(HDC);
    BOOL  (APIENTRY *GlmfPlayGlsRecord)(HDC, DWORD, BYTE *, LPRECTL);
    BOOL  (APIENTRY *GlmfEndGlsBlock)(HDC);
    BOOL  (APIENTRY *GlmfEndPlayback)(HDC);
    BOOL  (APIENTRY *GlmfCloseMetaFile)(HDC);
    HGLRC (APIENTRY *wglCreateContext)(HDC);
    BOOL  (APIENTRY *wglDeleteContext)(HGLRC);
    BOOL  (APIENTRY *wglMakeCurrent)(HDC, HGLRC);
    HGLRC (APIENTRY *wglGetCurrentContext)(void);
} GLMFCALLBACKS;
#define GL_MF_CALLBACKS (sizeof(GLMFCALLBACKS)/sizeof(PROC))

static char *pszGlmfEntryPoints[] =
{
    "GlmfInitPlayback",
    "GlmfBeginGlsBlock",
    "GlmfPlayGlsRecord",
    "GlmfEndGlsBlock",
    "GlmfEndPlayback",
    "GlmfCloseMetaFile",
    "wglCreateContext",
    "wglDeleteContext",
    "wglMakeCurrent",
    "wglGetCurrentContext"
};
#define GL_MF_ENTRYPOINTS (sizeof(pszGlmfEntryPoints)/sizeof(char *))

RTL_CRITICAL_SECTION semGlLoad;

static GLMFCALLBACKS gmcGlFuncs = {NULL};
static HMODULE hOpenGL = NULL;
static LONG lLoadCount = 0;

/*****************************Private*Routine******************************\
*
* LoadOpenGL
*
* Loads opengl32.dll if necessary
*
* History:
*  Wed Mar 01 10:41:59 1995 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL LoadOpenGL(void)
{
    HMODULE hdll;
    BOOL fRet;
    PROC *ppfn;
    int i;
    GLMFCALLBACKS gmc;

    ASSERTGDI(GL_MF_CALLBACKS == GL_MF_ENTRYPOINTS,
              "Glmf callback/entry points mismatch\n");
    
    ENTERCRITICALSECTION(&semGlLoad);

    if (hOpenGL != NULL)
    {
        goto Success;
    }
    
    fRet = FALSE;

    hdll = LoadLibrary("opengl32.dll");
    if (hdll == NULL)
    {
        WARNING("Unable to load opengl32.dll\n");
        goto Exit;
    }

    ppfn = (PROC *)&gmc;
    for (i = 0; i < GL_MF_CALLBACKS; i++)
    {
        if (!(*ppfn = (PROC)GetProcAddress(hdll,
                                           pszGlmfEntryPoints[i])))
        {
            WARNING("opengl32 missing '");
            WARNING(pszGlmfEntryPoints[i]);
            WARNING("'\n");
            FreeLibrary(hdll);
            goto Exit;
        }

        ppfn++;
    }

    gmcGlFuncs = gmc;
    hOpenGL = hdll;
    
 Success:
    fRet = TRUE;
    lLoadCount++;

 Exit:
    LEAVECRITICALSECTION(&semGlLoad);
    return fRet;
}

/*****************************Private*Routine******************************\
*
* UnloadOpenGL
*
* Unloads opengl32.dll if necessary
*
* History:
*  Wed Mar 01 11:02:06 1995 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void UnloadOpenGL(void)
{
    ENTERCRITICALSECTION(&semGlLoad);

    ASSERTGDI(lLoadCount > 0, "UnloadOpenGL called without Load\n");
    
    if (--lLoadCount == 0)
    {
        HMODULE hdll;

        ASSERTGDI(hOpenGL != NULL, "Positive load count with no DLL\n");
        
        hdll = hOpenGL;
        hOpenGL = NULL;
        memset(&gmcGlFuncs, 0, sizeof(gmcGlFuncs));
        FreeLibrary(hdll);
    }

    LEAVECRITICALSECTION(&semGlLoad);
}

/*****************************Private*Routine******************************\
*
* GlmfInitPlayback
*
* Stub to forward call to opengl
*
* History:
*  Wed Mar 01 11:02:31 1995 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL APIENTRY GlmfInitPlayback(HDC hdc, ENHMETAHEADER *pemh, LPRECTL prclDest)
{
    ASSERTGDI(gmcGlFuncs.GlmfInitPlayback != NULL,
              "GlmfInitPlayback not set\n");
    return gmcGlFuncs.GlmfInitPlayback(hdc, pemh, prclDest);
}

/*****************************Private*Routine******************************\
*
* GlmfBeginGlsBlock
*
* Stub to forward call to opengl
*
* History:
*  Mon Apr 10 11:38:13 1995 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL APIENTRY GlmfBeginGlsBlock(HDC hdc)
{
    ASSERTGDI(gmcGlFuncs.GlmfBeginGlsBlock != NULL,
              "GlmfBeginGlsBlock not set\n");
    return gmcGlFuncs.GlmfBeginGlsBlock(hdc);
}

/*****************************Private*Routine******************************\
*
* GlmfPlayGlsRecord
*
* Stub to forward call to opengl
*
* History:
*  Wed Mar 01 11:02:49 1995 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL APIENTRY GlmfPlayGlsRecord(HDC hdc, DWORD cb, BYTE *pb,
                                LPRECTL prclBounds)
{
    ASSERTGDI(gmcGlFuncs.GlmfPlayGlsRecord != NULL,
              "GlmfPlayGlsRecord not set\n");
    return gmcGlFuncs.GlmfPlayGlsRecord(hdc, cb, pb, prclBounds);
}

/*****************************Private*Routine******************************\
*
* GlmfEndGlsBlock
*
* Stub to forward call to opengl
*
* History:
*  Mon Apr 10 11:38:13 1995 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL APIENTRY GlmfEndGlsBlock(HDC hdc)
{
    ASSERTGDI(gmcGlFuncs.GlmfEndGlsBlock != NULL,
              "GlmfEndGlsBlock not set\n");
    return gmcGlFuncs.GlmfEndGlsBlock(hdc);
}

/*****************************Private*Routine******************************\
*
* GlmfEndPlayback
*
* Stub to forward call to opengl
*
* History:
*  Wed Mar 01 11:03:02 1995 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL APIENTRY GlmfEndPlayback(HDC hdc)
{
    BOOL fRet;

    ASSERTGDI(gmcGlFuncs.GlmfEndPlayback != NULL,
              "GlmfEndPlayback not set\n");
    fRet = gmcGlFuncs.GlmfEndPlayback(hdc);

    // WINBUG #82850 2-7-2000 bhouse We might was to unload opengl32.dll
    // This is not really a problem . This WINBUG is actually asking about
    // if we should unload("opengl32.dll"). The opengl32.dll is loaded as
    // a side effect of calling InitGlPrinting() call. This will only cause
    // a ref count leak. Also as this is user mode code on the client side.
    
    return fRet;
}

/*****************************Private*Routine******************************\
*
* GlmfCloseMetaFile
*
* Stub to forward call to opengl
*
* History:
*  Fri Mar 03 17:50:57 1995 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL APIENTRY GlmfCloseMetaFile(HDC hdc)
{
    if (!LoadOpenGL())
    {
        return FALSE;
    }
    
    ASSERTGDI(gmcGlFuncs.GlmfCloseMetaFile != NULL,
              "GlmfCloseMetaFile not set\n");

    // WINBUG #82850 2-7-2000 bhouse Investigate need to unload
    // Old Comment:
    //    - Unload?
    // This is not really a problem . The WINBUG is actually asking about
    // if we should unload("opengl32.dll"). The opengl32.dll is loaded as
    // a side effect of calling InitGlPrinting() call. This will only cause
    // a ref count leak. Also as this is user mode code on the client side.
    return gmcGlFuncs.GlmfCloseMetaFile(hdc);
}

// WINBUG #82854 2-7-2000 bhouse Investigate magic value used for band memory limit
static DWORD cbBandMemoryLimit = 0x400000;

#define RECT_CB(w, h, cbp) ((cbp)*(w)*(h))

// GL has hardcoded limits on maximum rendering size
#define GL_WIDTH_LIMIT 16384
#define GL_HEIGHT_LIMIT 16384

/******************************Public*Routine******************************\
*
* EndGlPrinting
*
* Cleans up resources used while printing OpenGL metafiles
*
* History:
*  Wed Apr 12 17:51:24 1995 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void EndGlPrinting(GLPRINTSTATE *pgps)
{
    ASSERTGDI(hOpenGL != NULL, "EndGlPrinting: No opengl\n");

    if (pgps->iReduceFactor > 1)
    {
        if (pgps->bBrushOrgSet)
        {
            SetBrushOrgEx(pgps->hdcDest,
                          pgps->ptBrushOrg.x, pgps->ptBrushOrg.y,
                          NULL);
        }
        if (pgps->iStretchMode != 0)
        {
            SetStretchBltMode(pgps->hdcDest, pgps->iStretchMode);
        }
    }
    
    if (gmcGlFuncs.wglGetCurrentContext() != NULL)
    {
        gmcGlFuncs.wglMakeCurrent(pgps->hdcDib, NULL);
    }
    if (pgps->hrc != NULL)
    {
        gmcGlFuncs.wglDeleteContext(pgps->hrc);
    }
    if (pgps->hdcDib != NULL)
    {
        DeleteDC(pgps->hdcDib);
    }
    if (pgps->hbmDib != NULL)
    {
        DeleteObject(pgps->hbmDib);
    }

    // WINBUG #82850 2-7-2000 bhouse Investigate need to unload
    // Old Comment:
    //    - Unload?
    // This is not really a problem . The WINBUG is actually asking about
    // if we should unload("opengl32.dll"). The opengl32.dll is loaded as
    // a side effect of calling InitGlPrinting() call. This will only cause
    // a ref count leak. Also as this is user mode code on the client side.
}

/******************************Public*Routine******************************\
*
* InitGlPrinting
*
* Performs all setup necessary for OpenGL printing
*
* History:
*  Wed Apr 12 17:51:46 1995 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL InitGlPrinting(HENHMETAFILE hemf, HDC hdcDest, RECT *rc,
                    DEVMODEW *pdm, GLPRINTSTATE *pgps)
{
    PIXELFORMATDESCRIPTOR pfd;
    int iFmt;
    BITMAPINFO *pbmi;
    BITMAPINFOHEADER *pbmih;
    int iWidth, iHeight;
    DWORD cbMeta;
    POINT pt;
    UINT cbPixelFormat;
    UINT cbPixel;
    UINT nColors;
    PVOID pvBits;

    // Zero out in case we need to do cleanup
    memset(pgps, 0, sizeof(*pgps));
    pgps->hdcDest = hdcDest;

    if (!LoadOpenGL())
    {
        return FALSE;
    }
    
    pbmi = NULL;

    // Set the reduction factor according to the dithering setting
    // for the DC
    switch(pdm->dmDitherType)
    {
    case DMDITHER_NONE:
    case DMDITHER_LINEART:
        pgps->iReduceFactor = 1;
        break;
    case DMDITHER_COARSE:
        pgps->iReduceFactor = 2;
        break;
    default:
        pgps->iReduceFactor = 4;
        break;
    }
    
    // Put the destination DC into the mode we need for rendering
    if (pgps->iReduceFactor > 1)
    {
        pgps->iStretchMode = SetStretchBltMode(hdcDest, HALFTONE);
        if (pgps->iStretchMode == 0)
        {
            goto EH_Cleanup;
        }

        // Need to reset the brush origin after changing the stretch mode
        if (!SetBrushOrgEx(hdcDest, 0, 0, &pgps->ptBrushOrg))
        {
            goto EH_Cleanup;
        }
        pgps->bBrushOrgSet = TRUE;
    }
    
    // Get the pixel format in the metafile if one exists
    cbPixelFormat = GetEnhMetaFilePixelFormat(hemf, sizeof(pfd), &pfd);
    if (cbPixelFormat == GDI_ERROR ||
        (cbPixelFormat != 0 && cbPixelFormat != sizeof(pfd)))
    {
        goto EH_Cleanup;
    }

    // No pixel format in the header, so use a default
    if (cbPixelFormat == 0)
    {
        pfd.nSize = sizeof(pfd);
        pfd.nVersion = 1;
        pfd.dwFlags = PFD_DRAW_TO_BITMAP | PFD_SUPPORT_OPENGL;
        pfd.iPixelType = PFD_TYPE_RGBA;
        pfd.cColorBits = 16;
        pfd.cRedBits = 5;
        pfd.cRedShift = 0;
        pfd.cGreenBits = 5;
        pfd.cGreenShift = 5;
        pfd.cBlueBits = 5;
        pfd.cBlueShift = 10;
        pfd.cAlphaBits = 0;
        pfd.cAccumBits = 0;
        pfd.cDepthBits = 16;
        pfd.cStencilBits = 0;
        pfd.cAuxBuffers = 0;
        pfd.iLayerType = PFD_MAIN_PLANE;
    }
    else
    {
        // Force draw-to-bitmap and single buffered
        // Turn off flags not supported
        pfd.dwFlags = (pfd.dwFlags &
                       ~(PFD_DRAW_TO_WINDOW | PFD_DOUBLEBUFFER |
                         PFD_STEREO | PFD_SUPPORT_GDI)) |
                         PFD_DRAW_TO_BITMAP | PFD_SUPPORT_OPENGL;

        // What happens in color index mode?
        if (pfd.iPixelType == PFD_TYPE_RGBA)
        {
            pfd.cColorBits = 16;
            pfd.cRedBits = 5;
            pfd.cRedShift = 0;
            pfd.cGreenBits = 5;
            pfd.cGreenShift = 5;
            pfd.cBlueBits = 5;
            pfd.cBlueShift = 10;
        }

        pfd.iLayerType = PFD_MAIN_PLANE;
    }
    
    // Determine the amount of memory used per pixel
    // This rounds 4bpp to one byte per pixel but that's close
    // enough
    cbPixel =
        (pfd.cColorBits+7)/8+
        (pfd.cAlphaBits+7)/8+
        (pfd.cAccumBits+7)/8+
        (pfd.cDepthBits+7)/8+
        (pfd.cStencilBits+7)/8;
    
    // Determine the size of the band based on smaller of:
    //   The biggest DIB that can fit in cbBandMemoryLimit
    //   The size of the metafile

    // The given rectangle is the size the metafile is supposed to
    // be rendered into so base our computations on it
    pgps->xSource = rc->left;
    pgps->ySource = rc->top;
    iWidth = rc->right-rc->left;
    iHeight = rc->bottom-rc->top;

    if (iWidth == 0 || iHeight == 0)
    {
        WARNING("InitGlPrinting: Metafile has no size\n");
        return FALSE;
    }

    pgps->iSourceWidth = iWidth;
    pgps->iSourceHeight = iHeight;
    
    // Reduce the resolution somewhat to allow halftoning space to work
    iWidth = iWidth/pgps->iReduceFactor;
    iHeight = iHeight/pgps->iReduceFactor;

    pgps->iReducedWidth = iWidth;
    pgps->iReducedHeight = iHeight;

    if (iWidth > GL_WIDTH_LIMIT)
    {
        iWidth = GL_WIDTH_LIMIT;
    }
    if (iHeight > GL_HEIGHT_LIMIT)
    {
        iHeight = GL_HEIGHT_LIMIT;
    }
    
    cbMeta = RECT_CB(iWidth, iHeight, cbPixel);

    // Shrink the rectangle until it fits in our memory limit
    if (cbMeta > cbBandMemoryLimit)
    {
        // How many scanlines will fit
        iHeight = cbBandMemoryLimit/RECT_CB(iWidth, 1, cbPixel);
        if (iHeight == 0)
        {
            // Can't fit a full scanline, so figure out how much
            // of a scanline will fit
            iWidth = cbBandMemoryLimit/cbPixel;
            iHeight = 1;
        }
    }
    
    if (iWidth < 1 || iHeight < 1)
    {
        WARNING("InitGlPrinting: "
                "Not enough memory to render anything\n");
        return FALSE;
    }

    // Create a DIB for the band
    switch(pfd.cColorBits)
    {
    case 4:
        nColors = 16;
        break;
    case 8:
        nColors = 256;
        break;
    case 16:
    case 32:
        nColors = 3;
        break;
    case 24:
        // Use one since it's already included in the BITMAPINFO definition
        nColors = 1;
        break;
    }
    pbmi = (BITMAPINFO *)LocalAlloc(LMEM_FIXED,
                                    sizeof(BITMAPINFO)+(nColors-1)*
                                    sizeof(RGBQUAD));
    if (pbmi == NULL)
    {
        goto EH_Cleanup;
    }
    
    pbmih = &pbmi->bmiHeader;
    pbmih->biSize = sizeof(BITMAPINFOHEADER);
    pbmih->biWidth = iWidth;
    pbmih->biHeight = iHeight;
    pbmih->biPlanes = 1;
    pbmih->biBitCount = pfd.cColorBits;
    if (pfd.cColorBits == 16 || pfd.cColorBits == 32)
    {
        pbmih->biCompression = BI_BITFIELDS;
        *((DWORD *)pbmi->bmiColors+0) =
            ((1 << pfd.cRedBits)-1) << pfd.cRedShift;
        *((DWORD *)pbmi->bmiColors+1) = 
            ((1 << pfd.cGreenBits)-1) << pfd.cGreenShift;
        *((DWORD *)pbmi->bmiColors+2) = 
            ((1 << pfd.cBlueBits)-1) << pfd.cBlueShift;
    }
    else if (pfd.cColorBits == 24)
    {
        pbmih->biCompression = BI_RGB;
    }
    else
    {
        UINT nEnt, i;
        
        pbmih->biCompression = BI_RGB;
        nEnt = GetEnhMetaFilePaletteEntries(hemf, nColors,
                                            (PALETTEENTRY *)pbmi->bmiColors);
        if (nEnt == GDI_ERROR)
        {
            goto EH_Cleanup;
        }

        // Force the flags byte to zero just to make sure
        for (i = 0; i < nEnt; i++)
        {
            pbmi->bmiColors[i].rgbReserved = 0;
        }
    }
    pbmih->biSizeImage= 0;
    pbmih->biXPelsPerMeter = 0;
    pbmih->biYPelsPerMeter = 0;
    pbmih->biClrUsed = 0;
    pbmih->biClrImportant = 0;

    // It doesn't matter what this DC is compatible with because that
    // will be overridden when we select the DIB into it
    pgps->hdcDib = CreateCompatibleDC(NULL);
    if (pgps->hdcDib == NULL)
    {
        WARNING("InitGlPrinting: CreateCompatibleDC failed\n");
        goto EH_Cleanup;
    }

    pgps->hbmDib = CreateDIBSection(pgps->hdcDib, pbmi, DIB_RGB_COLORS,
                                    &pvBits, NULL, 0);
    if (pgps->hbmDib == NULL)
    {
        WARNING("InitGlPrinting: CreateDibSection failed\n");
        goto EH_Cleanup;
    }

    if (SelectObject(pgps->hdcDib, pgps->hbmDib) == NULL)
    {
        WARNING("InitGlPrinting: SelectObject failed\n");
        goto EH_Cleanup;
    }
    
    // Set the pixel format for the DC
    
    iFmt = ChoosePixelFormat(pgps->hdcDib, &pfd);
    if (iFmt == 0)
    {
        WARNING("InitGlPrinting: ChoosePixelFormat failed\n");
        goto EH_Cleanup;
    }

    if (!SetPixelFormat(pgps->hdcDib, iFmt, &pfd))
    {
        WARNING("InitGlPrinting: SetPixelFormat failed\n");
        goto EH_Cleanup;
    }

    pgps->hrc = gmcGlFuncs.wglCreateContext(pgps->hdcDib);
    if (pgps->hrc == NULL)
    {
        WARNING("InitGlPrinting: wglCreateContext failed\n");
        goto EH_Cleanup;
    }

    if (!gmcGlFuncs.wglMakeCurrent(pgps->hdcDib, pgps->hrc))
    {
        WARNING("InitGlPrinting: wglMakeCurrent failed\n");
        goto EH_Cleanup;
    }

    pgps->iReducedBandWidth = iWidth;
    pgps->iBandWidth = iWidth*pgps->iReduceFactor;
    pgps->iReducedBandHeight = iHeight;
    pgps->iBandHeight = iHeight*pgps->iReduceFactor;
    
    return TRUE;

 EH_Cleanup:
    if (pbmi != NULL)
    {
        LocalFree(pbmi);
    }
    EndGlPrinting(pgps);
    return FALSE;
}

/*****************************Private*Routine******************************\
*
* RenderGlBand
*
* Plays the metafile and stretches the resulting band into the
* appropriate location in the destination
*
* Uses PlayEnhMetaFile-style error reporting, where we remember errors
* but continue to complete processing.  This avoids complete failure
* in cases where metafiles contain minor errors
*
* History:
*  Wed Apr 12 18:22:08 1995 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

static BOOL RenderGlBand(HENHMETAFILE hemf, GLPRINTSTATE *pgps, int x, int y)
{
    RECT rcBand;
    int iWidth, iHeight;
    int iReducedWidth, iReducedHeight;
    int ySrc;
    BOOL fSuccess = TRUE;

    // We want to render a band-size rectangle of the source metafile
    // at (x,y), so we need to do a negative translation by (x,y)
    // Size remains constant since we don't want any scaling
    //
    // The caller of this routine may have already shifted the
    // viewport with SetViewport so we don't attempt to use it
    // to do our translation

    // WINBUG #82858 2-7-2000 bhouse Investigate propoer metafile handling
    // Old Comment:
    //     - Proper handling of metafile left,top?

    // x and y are guaranteed to be even multiples of pgps->iReduceFactor
    rcBand.left = -x/pgps->iReduceFactor;
    rcBand.right = rcBand.left+pgps->iReducedWidth;
    rcBand.top = -y/pgps->iReduceFactor;
    rcBand.bottom = rcBand.top+pgps->iReducedHeight;

    if (!PlayEnhMetaFile(pgps->hdcDib, hemf, &rcBand))
    {
        WARNING("RenderBand: PlayEnhMetaFile failed\n");
        fSuccess = FALSE;
    }

    // Copy the DIB bits to the destination
    // Compute minimal width and height to avoid clipping problems

    iWidth = pgps->iBandWidth;
    iReducedWidth = pgps->iReducedBandWidth;
    iHeight = pgps->iBandHeight;
    iReducedHeight = pgps->iReducedBandHeight;
    ySrc = 0;

    // Check for X overflow
    if (x+iWidth > pgps->iSourceWidth)
    {
        iWidth = pgps->iSourceWidth-x;
        // If iWidth is not an even multiple of pgps->iReduceFactor then
        // this can result in a different stretch factor
        // I think this is more or less unavoidable
        iReducedWidth = (iWidth+pgps->iReduceFactor-1)/pgps->iReduceFactor;
    }

    // Invert destination Y
    y = pgps->iSourceHeight-pgps->iBandHeight-y;
    
    // Check for Y underflow
    if (y < 0)
    {
        iHeight += y;
        iReducedHeight = (iHeight+pgps->iReduceFactor-1)/pgps->iReduceFactor;
        // This can cause registration problems when y is not a
        // multiple of pgps->iReduceFactor.  Again, I'm not sure that
        // anything can be done
        ySrc -= (y+pgps->iReduceFactor-1)/pgps->iReduceFactor;
        y = 0;
    }

#if 0
    DbgPrint("GL band (%d,%d - %d,%d)\n", x, y, iWidth, iHeight);
#endif
    
    if (!StretchBlt(pgps->hdcDest,
                    x+pgps->xSource, y+pgps->ySource, iWidth, iHeight,
                    pgps->hdcDib,
                    0, ySrc, iReducedWidth, iReducedHeight,
                    SRCCOPY))
    {
        WARNING("RenderBand: StretchBlt failed\n");
        fSuccess = FALSE;
    }

    return fSuccess;
}

/******************************Public*Routine******************************\
*
* PrintMfWithGl
*
* Prints a metafile that contains OpenGL records by rendering bands
* in a DIB and then stretching them to the printer DC
*
* Uses PlayEnhMetaFile-style error reporting, where we remember errors
* but continue to complete processing.  This avoids complete failure
* in cases where metafiles contain minor errors
*
* History:
*  Wed Apr 12 18:22:41 1995 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL PrintMfWithGl(HENHMETAFILE hemf, GLPRINTSTATE *pgps,
                   POINTL *pptlBand, SIZE *pszBand)
{
    int iHorzBands, iVertBands;
    int iH, iV;
    int x, y;
    BOOL fSuccess = TRUE;
    int iStretchMode;
    POINT ptBrushOrg;

    ASSERTGDI(hOpenGL != NULL, "PrintMfWithGl: No opengl\n");
    
    // To render banded to a destination we create a 24-bit DIB and
    // play the metafile into that, then blt the DIB to
    // the destination DC
    //
    // The DIB and Z buffer take a large amount of memory
    // so the playback is banded into bands whose size is
    // determined by the amount of memory we want to consume

    iHorzBands = (pgps->iSourceWidth+pgps->iBandWidth-1)/pgps->iBandWidth;
    iVertBands = (pgps->iSourceHeight+pgps->iBandHeight-1)/pgps->iBandHeight;

    // Render high to low because the Y axis is positive up and
    // we want to go down the page
    y = (iVertBands-1)*pgps->iBandHeight;
    for (iV = 0; iV < iVertBands; iV++)
    {
        x = 0;
        for (iH = 0; iH < iHorzBands; iH++)
        {
            // If the current OpenGL band doesn't overlap any of the
            // current printer band, there's no point in drawing anything
            if (pptlBand != NULL &&
                pszBand != NULL &&
                (x+pgps->iBandWidth <= pptlBand->x ||
                 x >= pptlBand->x+pszBand->cx ||
                 y+pgps->iBandHeight <= pptlBand->y ||
                 y >= pptlBand->y+pszBand->cy))
            {
                // No band overlap
            }
            else if (!RenderGlBand(hemf, pgps, x, y))
            {
                fSuccess = FALSE;
            }

            x += pgps->iBandWidth;
        }
        
        y -= pgps->iBandHeight;
    }

    return fSuccess;
}

/******************************Public*Routine******************************\
*
* IsMetafileWithGl()
*
* IsMetafileWithGl will determines the matafile contains
* OpenGL records or not.
*
* History:
*  Wed Jan 29 00:00:00 1997 -by- Hideyuki Nagase [hideyukn]
* Created.
*
\**************************************************************************/

BOOL IsMetafileWithGl(HENHMETAFILE hmeta)
{
    ENHMETAHEADER emh;
    UINT cbEmh;

    cbEmh = GetEnhMetaFileHeader(hmeta, sizeof(emh), &emh);
    if (cbEmh == 0)
    {
        WARNING("IsMetafileWithGl(): GetEnhMetaFileHeader failed\n");
        return FALSE;
    }

    if (cbEmh >= META_HDR_SIZE_VERSION_2)
    {
        return emh.bOpenGL;
    }
    else
    {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\ldc.c ===
/******************************Module*Header*******************************\
* Module Name: ldc.c
*
* GDI functions that are handled on the client side.
*
* Created: 05-Jun-1991 01:45:21
* Author: Charles Whitmer [chuckwh]
*
* Copyright (c) 1991-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "wowgdip.h"
#define MIRRORED_DC(pDcAttr)     (pDcAttr->dwLayout & LAYOUT_RTL)

BOOL MF16_RecordParms2( HDC hdc, int parm2, WORD Func);

/******************************Public*Routine******************************
 * GetAndSetDCDWord( HDC, UINT, UINT, UINT, UINT, UINT )
 *
 * Gerrit van Wingerden [gerritv]
 *  11-9-94     Wrote It.
 *
 **************************************************************************/

DWORD GetAndSetDCDWord(
 HDC hdc,
 UINT uIndex,
 UINT uValue,
 UINT uEmr,
 WORD wEmr16,
 UINT uError )
{
    DWORD uRet=0;

    DWORD retData;

    // Metafile the call.

    if( IS_ALTDC_TYPE(hdc) && ( uEmr != EMR_MAX+1 ) )
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParmsD(hdc,uValue,wEmr16));

        DC_PLDC(hdc,pldc,uError)

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SetD(hdc,(DWORD)uValue,uEmr))
                return(uRet);
        }
    }

    uRet = NtGdiGetAndSetDCDword(hdc,
                                 uIndex,
                                 uValue,
                                 &retData);

    return (( uRet ) ? retData : uError);

}
/******************************Public*Routine******************************\
* SetBkMode
*
* Arguments:
*
*   hdc   - DC handle
*   iMode - new mode
*
* Return Value:
*
*   Old mode value or 0 for failure
*
\**************************************************************************/

int
META
APIENTRY
SetBkMode(
    HDC hdc,
    int iMode
    )
{
    int iModeOld = 0;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    if( IS_ALTDC_TYPE(hdc) )
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParmsD(hdc,iMode,META_SETBKMODE));

        DC_PLDC(hdc,pldc,iModeOld)

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SetD(hdc,(DWORD)iMode,EMR_SETBKMODE))
                return(iModeOld);
        }
    }

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        iModeOld = pDcAttr->lBkMode;
        pDcAttr->jBkMode = (iMode == OPAQUE) ? OPAQUE : TRANSPARENT;
        pDcAttr->lBkMode = iMode;
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(iModeOld);
}

/******************************Public*Routine******************************\
* SetPolyFillMode
*
* Arguments:
*
*   hdc   - DC handle
*   iMode - new mode
*
* Return Value:
*
*   Old mode value or 0 for failure
*
\**************************************************************************/

int META APIENTRY SetPolyFillMode(HDC hdc,int iMode)
{
    int iModeOld = 0;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    if( IS_ALTDC_TYPE(hdc) )
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParmsD(hdc,iMode,META_SETPOLYFILLMODE));

        DC_PLDC(hdc,pldc,iModeOld)

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SetD(hdc,(DWORD)iMode,EMR_SETPOLYFILLMODE))
                return(iModeOld);
        }
    }

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        CHECK_AND_FLUSH(hdc, pDcAttr);

        iModeOld = pDcAttr->lFillMode;
        pDcAttr->jFillMode = (iMode == WINDING) ? WINDING : ALTERNATE;
        pDcAttr->lFillMode = iMode;

    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(iModeOld);
}

/******************************Public*Routine******************************\
* SetROP2
*
* Arguments:
*
*   hdc   - DC handle
*   iMode - new mode
*
* Return Value:
*
*   Old mode value or 0 for failure
*
\**************************************************************************/

int META APIENTRY SetROP2(HDC hdc,int iMode)
{
    int iOldROP2 = 0;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    if( IS_ALTDC_TYPE(hdc) )
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParmsD(hdc,iMode,META_SETROP2));

        DC_PLDC(hdc,pldc,iOldROP2)

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SetD(hdc,(DWORD)iMode,EMR_SETROP2))
                return(iOldROP2);
        }
    }

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        CHECK_AND_FLUSH(hdc, pDcAttr);

        iOldROP2 = pDcAttr->jROP2;
        pDcAttr->jROP2 = (BYTE)iMode;
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(iOldROP2);
}

/******************************Public*Routine******************************\
* SetStretchBltMode
*
* Arguments:
*
*   hdc   - DC handle
*   iMode - new mode
*
* Return Value:
*
*   Old mode value or 0 for failure
*
\**************************************************************************/

int META APIENTRY SetStretchBltMode(HDC hdc,int iMode)
{
    int iModeOld = 0;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    if( IS_ALTDC_TYPE(hdc) )
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParmsD(hdc,iMode,META_SETSTRETCHBLTMODE));

        DC_PLDC(hdc,pldc,iModeOld)

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SetD(hdc,(DWORD)iMode,EMR_SETSTRETCHBLTMODE))
                return(iModeOld);
        }
    }

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        iModeOld = pDcAttr->lStretchBltMode;
        pDcAttr->lStretchBltMode = iMode;

        if ((iMode <= 0) || (iMode > MAXSTRETCHBLTMODE))
        {
            iMode = (DWORD) WHITEONBLACK;
        }

        pDcAttr->jStretchBltMode = (BYTE)iMode;
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(iModeOld);
}

/******************************Public*Routine******************************\
* SetTextAlign
*
* Arguments:
*
*   hdc   - DC handle
*   iMode - new mode
*
* Return Value:
*
*   Old mode value or 0 for failure
*
\**************************************************************************/

UINT META APIENTRY SetTextAlign(HDC hdc,UINT iMode)
{
    int iModeOld = GDI_ERROR;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    if( IS_ALTDC_TYPE(hdc) )
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParmsD(hdc,iMode,META_SETTEXTALIGN));

        DC_PLDC(hdc,pldc,iModeOld)

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SetD(hdc,(DWORD)iMode,EMR_SETTEXTALIGN))
                return(iModeOld);
        }
    }

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        iModeOld = pDcAttr->lTextAlign;
        pDcAttr->lTextAlign = iMode;
        if (MIRRORED_DC(pDcAttr) && (iMode & TA_CENTER) != TA_CENTER) {
            iMode = iMode ^ TA_RIGHT;
        }
        pDcAttr->flTextAlign = iMode & (TA_UPDATECP | TA_CENTER | TA_BASELINE);
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(iModeOld);
}

/******************************Public*Routine******************************\
* SetRelAbs (hdc,iMode)
*
* Client side attribute setting routine.
*
* History:
*  5-11-94 -by- Lingyun Wang [lingyunw]
* Moved client side attr to server side
*
*  09-Jun-1992 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int APIENTRY SetRelAbs(HDC hdc,int iMode)
{
    FIXUP_HANDLE(hdc);

    return((int) GetAndSetDCDWord( hdc,
                                   GASDDW_RELABS,
                                   iMode,
                                   EMR_MAX+1,
                                   EMR_MAX+1,
                                   0 ));
}

/******************************Public*Routine******************************\
* SetTextCharacterExtra (hdc,dx)
*
* Client side attribute setting routine.
*
*  5-11-94 -by- Lingyun Wang [lingyunw]
* Moved client side attr to server side
*
*  Sat 08-Jun-1991 00:53:45 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

int META APIENTRY SetTextCharacterExtra(HDC hdc,int dx)
{
    int  iRet = 0x80000000L;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

// Validate the spacing.

    if (dx == 0x80000000)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(iRet);
    }

    // Metafile the call for 16-bit only.
    // For enhanced metafiles, the extras are included in the textout records.

    if (IS_METADC16_TYPE(hdc))
        return(MF16_RecordParms2(hdc,dx,META_SETTEXTCHAREXTRA));

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        CHECK_AND_FLUSH_TEXT(hdc, pDcAttr);

        iRet = pDcAttr->lTextExtra;
        pDcAttr->lTextExtra = dx;
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return (iRet);
}

/******************************Public*Routine******************************\
* SetTextColor
*
* Arguments:
*
*   hdc   - DC handle
*   color - new color
*
* Return Value:
*
*   Old mode value or 0 for failure
*
\**************************************************************************/

COLORREF META APIENTRY SetTextColor(HDC hdc,COLORREF color)
{
    COLORREF crRet = CLR_INVALID;
    PDC_ATTR pdcattr;

    FIXUP_HANDLE(hdc);

    if( IS_ALTDC_TYPE(hdc) )
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParmsD(hdc,color,META_SETTEXTCOLOR));

        DC_PLDC(hdc,pldc,crRet)

        if (pldc->iType == LO_METADC)
        {
            CHECK_COLOR_PAGE(pldc,color);
            if (!MF_SetD(hdc,(DWORD)color,EMR_SETTEXTCOLOR))
                return(crRet);
        }
    }

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        crRet = pdcattr->ulForegroundClr;
        pdcattr->ulForegroundClr = color;

        color &= 0x13ffffff;

        if (!(color & 0x01000000) && bNeedTranslateColor(pdcattr))
        {
            COLORREF NewColor;

            BOOL bStatus = IcmTranslateCOLORREF(hdc,
                                                pdcattr,
                                                color,
                                                &NewColor,
                                                ICM_FORWARD);
            if (bStatus)
            {
                color = NewColor;
            }
        }

        if (pdcattr->crForegroundClr != color)
        {
            pdcattr->crForegroundClr = color;
            pdcattr->ulDirty_ |= (DIRTY_FILL|DIRTY_LINE|DIRTY_TEXT);
        }
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(crRet);
}
/******************************Public*Routine******************************\
* SetBkColor
*
* Arguments:
*
*   hdc   - DC handle
*   color - new color
*
* Return Value:
*
*   Old mode value or 0 for failure
*
\**************************************************************************/


COLORREF META APIENTRY SetBkColor(HDC hdc,COLORREF color)
{
    COLORREF crRet = CLR_INVALID;
    PDC_ATTR pdcattr;

    FIXUP_HANDLE(hdc);

    if( IS_ALTDC_TYPE(hdc) )
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParmsD(hdc,color,META_SETBKCOLOR));

        DC_PLDC(hdc,pldc,crRet)

        if (pldc->iType == LO_METADC)
        {
            CHECK_COLOR_PAGE(pldc,color);
            if (!MF_SetD(hdc,(DWORD)color,EMR_SETBKCOLOR))
                return(crRet);
        }
    }

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        //
        // set app specified color
        //

        crRet = pdcattr->ulBackgroundClr;
        pdcattr->ulBackgroundClr = color;

        color &= 0x13ffffff;

        //
        // check icm if not PALINDEX
        //

        if (!(color & 0x01000000) && bNeedTranslateColor(pdcattr))
        {
            COLORREF NewColor;

            BOOL bStatus = IcmTranslateCOLORREF(hdc,
                                                pdcattr,
                                                color,
                                                &NewColor,
                                                ICM_FORWARD);
            if (bStatus)
            {
                color = NewColor;
            }
        }

        if (color != pdcattr->crBackgroundClr)
        {
            pdcattr->crBackgroundClr = color;
            pdcattr->ulDirty_ |= (DIRTY_FILL|DIRTY_LINE|DIRTY_BACKGROUND);
        }
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(crRet);
}

/******************************Public*Routine******************************\
* SetDCBrushColor
*
* Arguments:
*
*   hdc   - DC handle
*   color - new color
*
* Return Value:
*
*   Old mode value or 0 for failure
*
* History :
*
*  Feb.16.1997 -by- Hideyuki Nagase [hideyukn]
* ICM-aware version.
\**************************************************************************/

COLORREF META APIENTRY SetDCBrushColor(HDC hdc,COLORREF color)
{
    COLORREF crRet = CLR_INVALID;
    PDC_ATTR pdcattr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        if (IS_ALTDC_TYPE(hdc))
        {
            if (!IS_METADC16_TYPE(hdc))
            {
                PLDC pldc;

                DC_PLDC(hdc,pldc,crRet);

                if (pldc->iType == LO_METADC)
                {
                    CHECK_COLOR_PAGE(pldc,color);

                    if (pdcattr->hbrush == ghbrDCBrush)
                    {
                         BOOL   bRet = FALSE;
                         HBRUSH hbr  = CreateSolidBrush (color);

                         if (hbr != NULL)
                         {
                             // If there is an old DCbrush, delete it now
                             if (pldc->oldSetDCBrushColorBrush)
                                 DeleteObject (pldc->oldSetDCBrushColorBrush);

                             bRet = MF_SelectAnyObject (hdc, hbr, EMR_SELECTOBJECT);
                             // Store the new tmp DC brush in the LDC.
                             pldc->oldSetDCBrushColorBrush = hbr;
                         }

                         if (!bRet)
                             return (CLR_INVALID);
                    }
                 }

              }
        }

        //
        // set app specified color
        //

        crRet = pdcattr->ulDCBrushClr;
        pdcattr->ulDCBrushClr = color;

        color &= 0x13ffffff;

        //
        // check icm if not PALINDEX
        //

        if (!(color & 0x01000000) && bNeedTranslateColor(pdcattr))
        {
            COLORREF NewColor;

            BOOL bStatus = IcmTranslateCOLORREF(hdc,
                                                pdcattr,
                                                color,
                                                &NewColor,
                                                ICM_FORWARD);
            if (bStatus)
            {
                color = NewColor;
            }
        }

        if (color != pdcattr->crDCBrushClr)
        {
            pdcattr->crDCBrushClr = color;
            pdcattr->ulDirty_ |= DIRTY_FILL;
        }
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(crRet);
}

/******************************Public*Routine******************************\
* GetDCBrushColor
*
* Arguments:
*
*   hdc   - DC handle
*
* Return Value:
*
*   Old mode value or 0 for failure
*
\**************************************************************************/

COLORREF META APIENTRY GetDCBrushColor(HDC hdc)
{
    COLORREF crRet = CLR_INVALID;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        crRet = pDcAttr->ulDCBrushClr;
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(crRet);
}


/******************************Public*Routine******************************\
* SetDCPenColor
*
* Arguments:
*
*   hdc   - DC handle
*   color - new color
*
* Return Value:
*
*   Old mode value or 0 for failure
*
* History :
*
*  Feb.16.1997 -by- Hideyuki Nagase [hideyukn]
* ICM-aware version.
\**************************************************************************/

COLORREF META APIENTRY SetDCPenColor(HDC hdc,COLORREF color)
{
    COLORREF crRet = CLR_INVALID;
    PDC_ATTR pdcattr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        if(IS_ALTDC_TYPE(hdc))
        {
            if (!IS_METADC16_TYPE(hdc))
            {
                PLDC pldc;

                DC_PLDC(hdc,pldc,crRet);

                if (pldc->iType == LO_METADC)
                {
                    CHECK_COLOR_PAGE(pldc,color);

                    if (pdcattr->hpen == ghbrDCPen)
                    {
                         BOOL bRet = FALSE;
                         HPEN hpen = CreatePen (PS_SOLID,0,color);

                         if (hpen != NULL)
                         {
                             // If there is a old temp DC pen, delete it.
                             if (pldc->oldSetDCPenColorPen)
                                 DeleteObject(pldc->oldSetDCPenColorPen);

                             bRet = MF_SelectAnyObject (hdc, hpen, EMR_SELECTOBJECT);
                             // Store the new tmp pen in the LDC.
                             pldc->oldSetDCPenColorPen = hpen;
                         }

                         if (!bRet)
                             return (CLR_INVALID);
                    }
                }
            }
        }

        //
        // set app specified color
        //

        crRet = pdcattr->ulDCPenClr;
        pdcattr->ulDCPenClr = color;

        color &= 0x13ffffff;

        //
        // check icm if not PALINDEX
        //

        if (!(color & 0x01000000) && bNeedTranslateColor(pdcattr))
        {
            COLORREF NewColor;

            BOOL bStatus = IcmTranslateCOLORREF(hdc,
                                                pdcattr,
                                                color,
                                                &NewColor,
                                                ICM_FORWARD);
            if (bStatus)
            {
                color = NewColor;
            }
        }

        if (color != pdcattr->crDCPenClr)
        {
            pdcattr->crDCPenClr = color;
            pdcattr->ulDirty_ |= DIRTY_LINE;
        }
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(crRet);
}

/******************************Public*Routine******************************\
* GetDCPenColor
*
* Arguments:
*
*   hdc   - DC handle
*
* Return Value:
*
*   Old mode value or 0 for failure
*
\**************************************************************************/

COLORREF META APIENTRY GetDCPenColor(HDC hdc)
{
    COLORREF crRet = CLR_INVALID;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        crRet = pDcAttr->ulDCPenClr;
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(crRet);
}

/******************************Public*Routine******************************
 * GetDCDWord( HDC hdc, UINT index, UINT error )
 *
 * This routine can be used to return a DWORD of information about a DC
 * from the server side.  The parameter index is used to specify which
 * one.  The values for indext are define in "ntgdi.h"
 *
 * Gerrit van Wingerden [gerritv]
 *  11-9-94     Wrote It.
 *
 **************************************************************************/

DWORD GetDCDWord( HDC hdc, UINT index, INT error )
{
    DWORD uRet=0;

    DWORD retData;

    uRet = NtGdiGetDCDword(hdc,
                           index,
                           &retData);

    return (uRet ? retData : error);

}

/******************************Public*Routine******************************\
* GetGraphicsMode(hdc)
* GetROP2(hdc)
* GetBkMode(hdc)
* GetPolyFillMode(hdc)
* GetStretchBltMode(hdc)
* GetTextAlign(hdc)
* GetTextCharacterExtra(hdc)
* GetTextColor(hdc)
* GetBkColor(hdc)
* GetRelAbs(hdc)
* GetFontLanguageInfo(hdc)
*
* added by Lingyunw:
* GetBreakExtra   (hdc)
* GetcBreak       (hdc)
*
* Simple client side handlers that just retrieve data from the LDC.
*
*  Mon 19-Oct-1992 -by- Bodin Dresevic [BodinD]
* update: GetGraphicsMode
*
*  Sat 08-Jun-1991 00:47:52 -by- Charles Whitmer [chuckwh]
* Wrote them.
\**************************************************************************/


#define BIDI_MASK (GCP_DIACRITIC|GCP_GLYPHSHAPE|GCP_KASHIDA|GCP_LIGATE|GCP_REORDER)


DWORD APIENTRY GetFontLanguageInfo(HDC hdc)
{
    DWORD dwRet = 0;
    DWORD dwRet1;

    FIXUP_HANDLE(hdc);

#ifdef LANGPACK
    if (gbLpk)
    {
        int iCharSet = NtGdiGetTextCharsetInfo(hdc, NULL, 0);
        if ((iCharSet == ARABIC_CHARSET) || (iCharSet == HEBREW_CHARSET))
            dwRet |= BIDI_MASK;
    }
#endif

    dwRet1 = GetDCDWord(hdc, DDW_FONTLANGUAGEINFO, (DWORD)GCP_ERROR);

    if (dwRet1 != GCP_ERROR)
    {
        dwRet |= dwRet1;
    }
    else
    {
        dwRet = dwRet1;
    }

    return dwRet;
}

int APIENTRY GetGraphicsMode(HDC hdc)
{
    int mode = 0;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        mode = pDcAttr->iGraphicsMode;
    }
    return(mode);
}

int APIENTRY GetROP2(HDC hdc)
{
    int rop = 0;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        rop = pDcAttr->jROP2;
    }

    return(rop);
}

int APIENTRY GetBkMode(HDC hdc)
{
    int mode = 0;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        mode = pDcAttr->lBkMode;
    }
    return(mode);
}

int APIENTRY GetPolyFillMode(HDC hdc)
{
    int mode = 0;

    PDC_ATTR pDcAttr;
    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        mode = pDcAttr->lFillMode;
    }
    return(mode);
}

int APIENTRY GetStretchBltMode(HDC hdc)
{
    int mode = 0;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        mode = pDcAttr->lStretchBltMode;
    }
    return(mode);
}

UINT APIENTRY GetTextAlign(HDC hdc)
{
    UINT al = GDI_ERROR;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        al = pDcAttr->lTextAlign;
    }
    return(al);
}

int APIENTRY GetTextCharacterExtra(HDC hdc)
{
    int iExtra = 0x80000000;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        iExtra = pDcAttr->lTextExtra;
    }

    return(iExtra);
}

COLORREF APIENTRY GetTextColor(HDC hdc)
{
    COLORREF co = CLR_INVALID;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        co = pDcAttr->ulForegroundClr;
    }
    return(co);
}

COLORREF APIENTRY GetBkColor(HDC hdc)
{
    COLORREF co = CLR_INVALID;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        co = pDcAttr->ulBackgroundClr;
    }

    return(co);
}

int APIENTRY GetRelAbs(HDC hdc,int iMode)
{
    iMode;

    FIXUP_HANDLE(hdc);

    return( (int) GetDCDWord( hdc, DDW_RELABS,(DWORD) 0 ));
}

//added for retrieve lBreakExtra from server side
int GetBreakExtra (HDC hdc)
{
    return( (int) GetDCDWord( hdc, DDW_BREAKEXTRA,(DWORD) 0 ));
}

//added for retrieve cBreak from server side
int GetcBreak (HDC hdc)
{
    return( (int) GetDCDWord( hdc, DDW_CBREAK,(DWORD) 0 ));
}

//added to retrieve hlfntNew for USER
HFONT APIENTRY GetHFONT (HDC hdc)
{
    HFONT hfnt = NULL;

    PDC_ATTR pDcAttr;
    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        hfnt = (HFONT)pDcAttr->hlfntNew;
    }

    return(hfnt);
}

/******************************Public*Routine******************************\
* GdiIsPlayMetafileDC
*
* Arguments:
*
*   hdc   - DC handle
*
* Return Value:
*
*   True if we are playing a metafile on DC, FALSE otherwise
*
* History :
*  Aug-31-97 -by- Samer Arafeh [SamerA]
\**************************************************************************/
BOOL APIENTRY GdiIsPlayMetafileDC(HDC hdc)
{
    PDC_ATTR pDcAttr;
    BOOL     bRet=FALSE;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        bRet = (pDcAttr->ulDirty_&DC_PLAYMETAFILE) ? TRUE : FALSE;
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\icm.c ===
/******************************Module*Header*******************************\
* Module Name: icm.c
*
* Created: 4-Jun-1996
* Author: Mark Enstrom [marke]
*
* Copyright (c) 1996-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop
#include "winuserk.h"

#if DBG_ICM

ULONG DbgIcm = 0x0;

#endif

//
// Instance of MSCMS.DLL
//
HINSTANCE ghICM;

//
// Color Profile Directory
//
WCHAR ColorDirectory[MAX_PATH];
DWORD ColorDirectorySize;

//
// Primary display DC color profile filename.
//
WCHAR PrimaryDisplayProfile[MAX_PATH];

//
// List of ICMINFO
//
LIST_ENTRY ListIcmInfo;

//
// Semaphore to protect ICMINFO list
//
RTL_CRITICAL_SECTION semListIcmInfo;

//
// Per process color space and color transform cache list
//
LIST_ENTRY ListCachedColorSpace;
LIST_ENTRY ListCachedColorTransform;

ULONG      cCachedColorSpace = 0;
ULONG      cCachedColorTransform = 0;

//
// Semaphore to protect Cache list
//
RTL_CRITICAL_SECTION semColorTransformCache;
RTL_CRITICAL_SECTION semColorSpaceCache;

BOOL gbICMEnabledOnceBefore = FALSE;

//
// ANSI version function in MSCMS.DLL will not called.
//
// FPOPENCOLORPROFILEA           fpOpenColorProfileA;
// FPCREATECOLORTRANSFORMA       fpCreateColorTransformA;
// FPREGISTERCMMA                fpRegisterCMMA;
// FPUNREGISTERCMMA              fpUnregisterCMMA;
// FPINSTALLCOLORPROFILEA        fpInstallColorProfileA;
// FPUNINSTALLCOLORPROFILEA      fpUninstallColorProfileA;
// FPGETSTANDARDCOLORSPACEPROFILEA fpGetStandardColorSpaceProfileA;
// FPENUMCOLORPROFILESA          fpEnumColorProfilesA;
// FPGETCOLORDIRECTORYA          fpGetColorDirectoryA;
//
// And Following function does not used from gdi32.dll
//
// FPISCOLORPROFILEVALID         fpIsColorProfileValid;
// FPCREATEDEVICELINKPROFILE     fpCreateDeviceLinkProfile;
// FPTRANSLATECOLORS             fpTranslateColors;
// FPCHECKCOLORS                 fpCheckColors;
// FPGETCMMINFO                  fpGetCMMInfo;
// FPSELECTCMM                   fpSelectCMM;
//

FPOPENCOLORPROFILEW           fpOpenColorProfileW;
FPCLOSECOLORPROFILE           fpCloseColorProfile;
FPCREATECOLORTRANSFORMW       fpCreateColorTransformW;
FPDELETECOLORTRANSFORM        fpDeleteColorTransform;
FPTRANSLATEBITMAPBITS         fpTranslateBitmapBits;
FPTRANSLATECOLORS             fpTranslateColors;
FPCHECKBITMAPBITS             fpCheckBitmapBits;
FPREGISTERCMMW                fpRegisterCMMW;
FPUNREGISTERCMMW              fpUnregisterCMMW;
FPINSTALLCOLORPROFILEW        fpInstallColorProfileW;
FPUNINSTALLCOLORPROFILEW      fpUninstallColorProfileW;
FPENUMCOLORPROFILESW          fpEnumColorProfilesW;
FPGETSTANDARDCOLORSPACEPROFILEW fpGetStandardColorSpaceProfileW;
FPGETCOLORPROFILEHEADER         fpGetColorProfileHeader;
FPGETCOLORDIRECTORYW            fpGetColorDirectoryW;
FPCREATEPROFILEFROMLOGCOLORSPACEW fpCreateProfileFromLogColorSpaceW;
FPCREATEMULTIPROFILETRANSFORM fpCreateMultiProfileTransform;
FPINTERNALGETDEVICECONFIG     fpInternalGetDeviceConfig;

//
// MS COLOR MATCH DLL name
//
#define MSCMS_DLL_NAME        L"mscms.dll"

//
// Misc. macros
//
#define ALIGN_DWORD(nBytes)   (((nBytes) + 3) & ~3)

//
// sRGB color profile name
//
#define sRGB_PROFILENAME      L"sRGB Color Space Profile.icm"

//
// DWORD 0x12345678 ---> 0x78563412
//
#define IcmSwapBytes(x) ((((x) & 0xFF000000) >> 24) | (((x) & 0x00FF0000) >>  8) | \
                         (((x) & 0x0000FF00) <<  8) | (((x) & 0x000000FF) << 24))

//
// Macro to check color DC or not.
//
// LATER: We can improve performance by caching this in client, since
//        GetDeviceCaps() goes to kernel in most cases.
//
#define IsColorDeviceContext(hdcThis) \
                        (2 < (unsigned) GetDeviceCaps((hdcThis), NUMCOLORS))

//
// Macro to check the color space is GDI object dependent.
//
#define IsColorSpaceOwnedByGDIObject(pColorSpace,hGDIObj)         \
            ((pColorSpace) ?                                      \
              (((pColorSpace)->hObj == (hGDIObj)) ? TRUE : FALSE) \
               : FALSE)

//
// Macro to get current color tranform in DC.
//
#define GetColorTransformInDC(pdcattr) ((pdcattr)->hcmXform)

//
// if the color space has DEVICE_CALIBRATE_COLORSPACE flag, returns TRUE, otherwise FALSE.
//
#define bDeviceCalibrate(pColorSpace)                                                \
            ((pColorSpace) ?                                                         \
              (((pColorSpace)->flInfo & DEVICE_CALIBRATE_COLORSPACE) ? TRUE : FALSE) \
                : FALSE)

//
// Increment reference count of colorpsace/colortransform.
//

#define IcmReferenceColorSpace(pColorSpace)                 \
            if ((pColorSpace))                              \
            {                                               \
                ENTERCRITICALSECTION(&semColorSpaceCache);  \
                (pColorSpace)->cRef++;                      \
                LEAVECRITICALSECTION(&semColorSpaceCache);  \
            }

#define IcmReferenceColorTransform(pCXfrom)                     \
            if ((pCXform))                                      \
            {                                                   \
                ENTERCRITICALSECTION(&semColorTransformCache);  \
                (pCXform)->cRef++;                              \
                LEAVECRITICALSECTION(&semColorTransformCache);  \
            }

//
// Invalid color space handle
//
#define INVALID_COLORSPACE                 ((HCOLORSPACE)-1)

//
// Maximum number of cached color transform in list.
//
#define MAX_COLORTRANSFORM_CACHE           10

//
// Maximum size of "on memory profile" which be able to cache.
//
#define MAX_SIZE_OF_COLORPROFILE_TO_CACHE  (1024*3)

/******************************Public*Routine******************************\
* GDI initialization routine called from dll init
*
* Arguments:
*
*   None
*
* Return Value:
*
*   Status
*
* History:
*
*    3-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
IcmInitialize()
{
    BOOL bStatus = TRUE;

    ICMAPI(("gdi32: IcmInitialize\n"));

    ENTERCRITICALSECTION(&semLocal);

    //
    // load MCSCM.DLL and get function addresses
    //
    if (ghICM == NULL)
    {
        HANDLE hmscms = LoadLibraryW(MSCMS_DLL_NAME);

        if (hmscms != NULL)
        {
            fpOpenColorProfileW =
                (FPOPENCOLORPROFILEW)GetProcAddress(hmscms,"OpenColorProfileW");
            fpCloseColorProfile =
                (FPCLOSECOLORPROFILE)GetProcAddress(hmscms,"CloseColorProfile");
            fpCreateColorTransformW =
                (FPCREATECOLORTRANSFORMW)GetProcAddress(hmscms,"CreateColorTransformW");
            fpDeleteColorTransform =
                (FPDELETECOLORTRANSFORM)GetProcAddress(hmscms,"DeleteColorTransform");
            fpTranslateBitmapBits =
                (FPTRANSLATEBITMAPBITS)GetProcAddress(hmscms,"TranslateBitmapBits");
            fpTranslateColors =
                (FPTRANSLATECOLORS)GetProcAddress(hmscms,"TranslateColors");
            fpCheckBitmapBits =
                (FPCHECKBITMAPBITS)GetProcAddress(hmscms,"CheckBitmapBits");
            fpRegisterCMMW =
                (FPREGISTERCMMW)GetProcAddress(hmscms,"RegisterCMMW");
            fpUnregisterCMMW =
                (FPUNREGISTERCMMW)GetProcAddress(hmscms,"UnregisterCMMW");
            fpInstallColorProfileW =
                (FPINSTALLCOLORPROFILEW)GetProcAddress(hmscms,"InstallColorProfileW");
            fpUninstallColorProfileW =
                (FPUNINSTALLCOLORPROFILEW)GetProcAddress(hmscms,"UninstallColorProfileW");
            fpEnumColorProfilesW =
                (FPENUMCOLORPROFILESW)GetProcAddress(hmscms,"EnumColorProfilesW");
            fpGetStandardColorSpaceProfileW =
                (FPGETSTANDARDCOLORSPACEPROFILEW)GetProcAddress(hmscms,"GetStandardColorSpaceProfileW");
            fpGetColorProfileHeader =
                (FPGETCOLORPROFILEHEADER)GetProcAddress(hmscms,"GetColorProfileHeader");
            fpGetColorDirectoryW =
                (FPGETCOLORDIRECTORYW)GetProcAddress(hmscms,"GetColorDirectoryW");
            fpCreateProfileFromLogColorSpaceW =
                (FPCREATEPROFILEFROMLOGCOLORSPACEW)GetProcAddress(hmscms,"CreateProfileFromLogColorSpaceW");
            fpCreateMultiProfileTransform =
                (FPCREATEMULTIPROFILETRANSFORM)GetProcAddress(hmscms,"CreateMultiProfileTransform");
            fpInternalGetDeviceConfig =
                (FPINTERNALGETDEVICECONFIG)GetProcAddress(hmscms,"InternalGetDeviceConfig");

            if ((fpOpenColorProfileW           == NULL) ||
                (fpCloseColorProfile           == NULL) ||
                (fpCreateColorTransformW       == NULL) ||
                (fpDeleteColorTransform        == NULL) ||
                (fpTranslateBitmapBits         == NULL) ||
                (fpTranslateColors             == NULL) ||
                (fpCheckBitmapBits             == NULL) ||
                (fpRegisterCMMW                == NULL) ||
                (fpUnregisterCMMW              == NULL) ||
                (fpInstallColorProfileW        == NULL) ||
                (fpUninstallColorProfileW      == NULL) ||
                (fpEnumColorProfilesW          == NULL) ||
                (fpGetStandardColorSpaceProfileW == NULL) ||
                (fpGetColorProfileHeader       == NULL) ||
                (fpGetColorDirectoryW          == NULL) ||
                (fpCreateProfileFromLogColorSpaceW == NULL) ||
                (fpCreateMultiProfileTransform == NULL) ||
                (fpInternalGetDeviceConfig     == NULL)
               )
            {
                WARNING("LoadLibrary of mscms.dll failed to associate all proc addresses\n");
                FreeLibrary(hmscms);
                hmscms = NULL;
            }
            else
            {
                //
                // Initialize Color Directory
                //
                ColorDirectorySize = sizeof(ColorDirectory) / sizeof(WCHAR);

                bStatus = (*fpGetColorDirectoryW)(NULL,ColorDirectory,&ColorDirectorySize);

                if (bStatus)
                {
                    ColorDirectorySize = wcslen(ColorDirectory);
                }

                if (bStatus && ColorDirectorySize)
                {
                    ICMMSG(("IcmInitialize():ColorDirectory = %ws\n",ColorDirectory));

                    //
                    // Counts null-terminated char.
                    //
                    ColorDirectorySize += 1;

                    //
                    // Initialize Primary display color profile.
                    //
                    PrimaryDisplayProfile[0] = UNICODE_NULL;
                }
                else
                {
                    WARNING("LoadLibrary of mscms.dll failed to obtain color directory\n");
                    FreeLibrary(hmscms);
                    hmscms = NULL;
                }
            }

            //
            // Keep the handle to global veriable.
            //
            ghICM = hmscms;
        }
    }

    LEAVECRITICALSECTION(&semLocal);

    if (ghICM == NULL)
    {
        GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
        bStatus = FALSE;
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
*
* SetIcmMode - turn ICM on or off in a DC
*
* Arguments:
*
*   hdc - device context
*   mode - ICM_ON,ICM_OFF,ICM_QUERY
*
* Return Value:
*
*   status
*
* History:
*
* Rewrite it:
*   20-Jan-1997 -by- Hideyuki Nagase [hideyukn]
* Write it:
*    4-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

int META WINAPI
SetICMMode(
    HDC       hdc,
    int       mode
    )
{
    int      iRet = (int)FALSE;
    PDC_ATTR pdcattr;

    ICMAPI(("gdi32: SetICMMode\n"));

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    //
    // metafile (only for ICM_ON and ICM_OFF)
    //
    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        //
        // No ICM with Windows MetaFile.
        //
        if (IS_METADC16_TYPE(hdc))
            return(iRet);

        DC_PLDC(hdc,pldc,iRet)

        #if DBG_ICM
            ICMMSG(("SetICMMode():%s ICM for %s\n", \
                    ((mode == ICM_ON) ? "Enable" : \
                     ((mode == ICM_OFF) ? "Disable" : "Query")), \
                    ((pldc->iType == LO_METADC) ? "Enhanced Metafile" :   \
                     (!IsColorDeviceContext(hdc) ? "Monochrome Printer" : "Color Printer")) \
                  ));
        #endif

        //
        // If this is Enhanced Metafile, OR non-color printer device, don't enable ICM "really".
        //
        if (pldc->iType == LO_METADC || (!IsColorDeviceContext(hdc)))
        {
            switch (mode)
            {
            case ICM_ON:
            case ICM_OFF:
            case ICM_DONE_OUTSIDEDC:

                //
                // Record ICM ON/OFF only to metafile.
                //
                if (pldc->iType == LO_METADC)
                {
                    if (!MF_SetD(hdc,(DWORD)mode,EMR_SETICMMODE))
                    {
                        return((int)FALSE);
                    }
                }

                //
                // We don't "really" turn-on ICM for metafile, metafile
                // should be device-independent, thus, non-ICMed color/images
                // will be metafiled. But still need to keep its status for ICM_QUERY.
                // And "real" image correction happen at play-back time.
                //
                if(pdcattr)
                {
                    if (mode == ICM_ON)
                    {
                        pdcattr->lIcmMode |= DC_ICM_METAFILING_ON;
                    }
                    else if (mode == ICM_DONE_OUTSIDEDC)
                    {
                        pdcattr->lIcmMode |= (DC_ICM_METAFILING_ON |
                                              CTX_ICM_METAFILING_OUTSIDEDC);
                    }
                    else // if ((mode == ICM_OFF)
                    {
                        pdcattr->lIcmMode &= ~(DC_ICM_METAFILING_ON |
                                               CTX_ICM_METAFILING_OUTSIDEDC);
                    }
                    iRet = (int)TRUE;
                }
                break;

            case ICM_QUERY:

                if (pdcattr)
                {
                    if (IS_ICM_METAFILING_ON(pdcattr->lIcmMode))
                    {
                        iRet = ((pdcattr->lIcmMode & CTX_ICM_METAFILING_OUTSIDEDC) ? \
                                ICM_DONE_OUTSIDEDC : ICM_ON);
                    }
                    else
                    {
                        iRet = ICM_OFF;
                    }
                }
                break;

            default:
                iRet = (int)FALSE;
                break;
            }

            return (iRet);
        }
    }

    if (pdcattr)
    {
        ULONG        iPrevMode;

        //
        // Before change ICM mode, we need to flush batched gdi functions.
        //
        CHECK_AND_FLUSH(hdc,pdcattr);

        //
        // Get current mode.
        //
        iPrevMode = pdcattr->lIcmMode;

        //
        // validate input parameter
        //
        switch (ICM_MODE(mode))
        {
        case ICM_QUERY:

            //
            // return current mode
            //
            if (IS_ICM_INSIDEDC(iPrevMode))
            {
                iRet = ICM_ON;
            }
            else if (IS_ICM_OUTSIDEDC(iPrevMode))
            {
                iRet = ICM_DONE_OUTSIDEDC;
            }
            else
            {
                iRet = ICM_OFF;
            }

            break;

        case ICM_ON:

            if (!IS_ICM_INSIDEDC(iPrevMode))
            {
                //
                // As default, ICM will be done on HOST.
                //
                ULONG lReqMode = REQ_ICM_HOST;

                PGDI_ICMINFO pIcmInfo = INIT_ICMINFO(hdc,pdcattr);

                //
                // Initialize ICMINFO
                //
                if (pIcmInfo == NULL)
                {
                    WARNING("gdi32: SetICMMode: Can't init icm info\n");
                    return((int)FALSE);
                }

                //
                // Load external ICM dlls.
                //
                LOAD_ICMDLL((int)FALSE);

                //
                // ICM is not enabled,yet. Let's enable ICM.
                //
                ASSERTGDI(GetColorTransformInDC(pdcattr) == NULL,"SetIcmMode: hcmXform is not NULL\n");

                if (IS_DEVICE_ICM_DEVMODE(iPrevMode))
                {
                    ICMMSG(("SetIcmMode: Device ICM is requested\n"));

                    //
                    // if ICM on Device was requested by CreateDC(), let force do
                    // ICM on device, if possible.
                    //
                    lReqMode = REQ_ICM_DEVICE;
                }
                else
                {
                    ICMMSG(("SetIcmMode: Host ICM is requested\n"));
                }

                //
                // Turn ICM on for this DC.
                //
                if (!NtGdiSetIcmMode(hdc,ICM_SET_MODE,lReqMode))
                {
                    //
                    // something wrong... we are fail to enable ICM.
                    //
                    iRet = (int)FALSE;
                    break;
                }

                //
                // If we have cached transform and it is not dirty, we can use that.
                //
                if ((pIcmInfo->pCXform == NULL) || (pdcattr->ulDirty_ & DIRTY_COLORTRANSFORM))
                {
                    if (IcmUpdateDCColorInfo(hdc,pdcattr))
                    {
                        //
                        // Mark this process has experience about ICM ON.
                        //
                        gbICMEnabledOnceBefore = TRUE;
                        iRet = (int)TRUE;
                    }
                    else
                    {
                        WARNING("SetIcmMode():IcmUpdateDCInfo failed\n");

                        //
                        // Fail to create new transform
                        //
                        NtGdiSetIcmMode(hdc,ICM_SET_MODE,REQ_ICM_OFF);
                        iRet = (int)FALSE;
                    }
                }
                else
                {
                    ICMMSG(("SetIcmMode: Use cached Color Transform\n"));

                    //
                    // Use cached transform, because since last time when we disabled ICM,
                    // NO profile(s) and logical color space has been changed.
                    //
                    if (IcmSelectColorTransform(
                            hdc,pdcattr,pIcmInfo->pCXform,
                            bDeviceCalibrate(pIcmInfo->pCXform->DestinationColorSpace)))
                    {
                        //
                        // Translate all DC objects to ICM colors. Must
                        // force brush/pens to be re-realized when used next
                        //
                        IcmTranslateColorObjects(hdc,pdcattr,TRUE);
                        iRet = (int)TRUE;
                    }
                    else
                    {
                        //
                        // Fail to select cached transform to the DC.
                        //
                        NtGdiSetIcmMode(hdc,ICM_SET_MODE,REQ_ICM_OFF);
                        iRet = (int)FALSE;
                    }
                }
            }
            else
            {
                ICMMSG(("SetIcmMode: ICM has been enabled already\n"));
                iRet = (int)TRUE;
            }

            break;

        case ICM_DONE_OUTSIDEDC:

            if (!IS_ICM_OUTSIDEDC(iPrevMode))
            {
                //
                // if inside-DC ICM is enabled, turned off it.
                //
                if (IS_ICM_INSIDEDC(iPrevMode))
                {
                    //
                    // Invalidate current color tansform (but the cache in ICMINFO is still valid).
                    //
                    IcmSelectColorTransform(hdc,pdcattr,NULL,FALSE);

                    //
                    // Restore color data for ICM disable.
                    //
                    IcmTranslateColorObjects(hdc,pdcattr,FALSE);
                }

                //
                // Tell the kernel to disable color adjustment during halftone.
                //
                NtGdiSetIcmMode(hdc,ICM_SET_MODE,REQ_ICM_OUTSIDEDC);
            }
            else
            {
                ICMMSG(("SetIcmMode: OutsideDC ICM has been enabled already\n"));
            }

            iRet = (int)TRUE;
            break;

        case ICM_OFF:

            //
            // Is there any kind of ICM is enabled ?
            //
            if (IS_ICM_ON(iPrevMode))
            {
                if (IS_ICM_INSIDEDC(iPrevMode))
                {
                    //
                    // Invalidate current color tansform (but the cache in ICMINFO is still valid).
                    //
                    IcmSelectColorTransform(hdc,pdcattr,NULL,TRUE);

                    //
                    // Restore color data for ICM disable.
                    //
                    IcmTranslateColorObjects(hdc,pdcattr,FALSE);
                }

                //
                // Tell the kernel to disable ICM.
                //
                NtGdiSetIcmMode(hdc,ICM_SET_MODE,REQ_ICM_OFF);
            }
            else
            {
                ICMMSG(("SetIcmMode: ICM has been disabled already\n"));
            }

            iRet = (int)TRUE;
            break;

        default:

            GdiSetLastError(ERROR_INVALID_PARAMETER);
            iRet = (int)FALSE;
            break;
        }
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        iRet = (int)FALSE;
    }

    return((int)iRet);
}

/******************************Public*Routine******************************\
* CreateColorSpaceA
*
* Arguments:
*
*   lpLogColorSpace - apps log color space
*
* Return Value:
*
*   handle of color space or NULL
*
* History:
*
*    4-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

HCOLORSPACE WINAPI
CreateColorSpaceA(
    LPLOGCOLORSPACEA lpLogColorSpace
    )
{
    HCOLORSPACE    hRet;
    LOGCOLORSPACEW LogColorSpaceW;

    ICMAPI(("gdi32: CreateColorSpaceA\n"));

    if (lpLogColorSpace == NULL)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    //
    // convert ascii to long character version
    //
    if ((lpLogColorSpace->lcsSignature != LCS_SIGNATURE)    ||
        (lpLogColorSpace->lcsVersion   != 0x400)            ||
        (lpLogColorSpace->lcsSize      != sizeof(LOGCOLORSPACEA)))
    {
        ICMWRN(("CreateColorSpaceA: Incorrect signature,version or size \n"));
        GdiSetLastError(ERROR_INVALID_COLORSPACE);
        return(NULL);
    }

    RtlZeroMemory(&LogColorSpaceW,sizeof(LOGCOLORSPACEW));

    LogColorSpaceW.lcsSignature   = lpLogColorSpace->lcsSignature;
    LogColorSpaceW.lcsVersion     = lpLogColorSpace->lcsVersion;
    LogColorSpaceW.lcsCSType      = lpLogColorSpace->lcsCSType;
    LogColorSpaceW.lcsIntent      = lpLogColorSpace->lcsIntent;
    LogColorSpaceW.lcsEndpoints   = lpLogColorSpace->lcsEndpoints;
    LogColorSpaceW.lcsGammaRed    = lpLogColorSpace->lcsGammaRed;
    LogColorSpaceW.lcsGammaGreen  = lpLogColorSpace->lcsGammaGreen;
    LogColorSpaceW.lcsGammaBlue   = lpLogColorSpace->lcsGammaBlue;

    LogColorSpaceW.lcsSize        = sizeof(LOGCOLORSPACEW);

    vToUnicodeN(
                LogColorSpaceW.lcsFilename,MAX_PATH,
                lpLogColorSpace->lcsFilename,strlen(lpLogColorSpace->lcsFilename)+1
               );

    hRet = CreateColorSpaceInternalW(&LogColorSpaceW,LCSEX_ANSICREATED);

    return(hRet);
}

/******************************Public*Routine******************************\
* CreateColorSpaceW
*
*   ColorSpace is a KERNEL mode object
*
* Arguments:
*
*   lpLogColorSpace - apps log color space
*
* Return Value:
*
*   Handle of color space or NULL
*
* History:
*
*   18-Apr-1997 -by- Hideyuki Nagase [hideyukn]
*
\**************************************************************************/

HCOLORSPACE WINAPI
CreateColorSpaceW(
    LPLOGCOLORSPACEW lpLogColorSpace
    )
{
    return (CreateColorSpaceInternalW(lpLogColorSpace,0));
}

HCOLORSPACE WINAPI
CreateColorSpaceInternalW(
    LPLOGCOLORSPACEW lpLogColorSpace,
    DWORD            dwCreateFlags
    )
{
    HCOLORSPACE      hRet = NULL;
    LOGCOLORSPACEEXW LogColorSpaceExOnStack;

    ICMAPI(("gdi32: CreateColorSpaceW\n"));

    if (lpLogColorSpace == NULL)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    //
    // validate color space
    //
    if ((lpLogColorSpace->lcsSignature != LCS_SIGNATURE) ||
        (lpLogColorSpace->lcsVersion   != 0x400)         ||
        (lpLogColorSpace->lcsSize      != sizeof(LOGCOLORSPACEW)))
    {
        goto InvalidColorSpaceW;
    }

    //
    // validate lcsIntent
    //
    if ((lpLogColorSpace->lcsIntent != LCS_GM_BUSINESS) &&
        (lpLogColorSpace->lcsIntent != LCS_GM_GRAPHICS) &&
        (lpLogColorSpace->lcsIntent != LCS_GM_IMAGES)   &&
        (lpLogColorSpace->lcsIntent != LCS_GM_ABS_COLORIMETRIC))
    {
        goto InvalidColorSpaceW;
    }

    //
    // We can not modify apps LOGCOLORSPACEW, so that make a copy on stack.
    //
    LogColorSpaceExOnStack.lcsColorSpace = *lpLogColorSpace;
    LogColorSpaceExOnStack.dwFlags       = dwCreateFlags;

    //
    // validate lcsCSTYPE
    //
    if ((lpLogColorSpace->lcsCSType == LCS_CALIBRATED_RGB) ||
        (lpLogColorSpace->lcsCSType == PROFILE_LINKED))
    {
        //
        // Replace CSType in case PROFILE_LINKED.
        //
        LogColorSpaceExOnStack.lcsColorSpace.lcsCSType = LCS_CALIBRATED_RGB;

        if (lpLogColorSpace->lcsFilename[0] != L'\0')
        {
            HANDLE hFile;

            //
            // Normalize profile filename. but we will not over-write app's
            // path with our normalized path.
            //
            BuildIcmProfilePath(lpLogColorSpace->lcsFilename,
                                LogColorSpaceExOnStack.lcsColorSpace.lcsFilename,
                                MAX_PATH);

            //
            // profile name given, verify it exists
            //
            hFile = CreateFileW(
                        LogColorSpaceExOnStack.lcsColorSpace.lcsFilename,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

            if (hFile != INVALID_HANDLE_VALUE)
            {
                //
                // Yes, file is really exits.
                //
                CloseHandle(hFile);
            }
            else
            {
                ICMWRN(("CreateColorSpaceW: Couldn't open file specified by lcsFilename\n"));
                GdiSetLastError(ERROR_PROFILE_NOT_FOUND);
                return(NULL);
            }
        }
    }
    else // any other CSType
    {
        ULONG ulSize = MAX_PATH;

        //
        // Load external ICM dlls.
        //
        LOAD_ICMDLL(NULL);

        //
        // if CSType is not LCS_CALIBRATED_RGB, we should go to MSCMS.DLL to get color profile
        // for corresponding LCSType, then any given profile name from application is IGNORED.
        //
        if (!(*fpGetStandardColorSpaceProfileW)(
                   NULL, lpLogColorSpace->lcsCSType,
                   LogColorSpaceExOnStack.lcsColorSpace.lcsFilename, &ulSize))
        {
            ICMWRN(("CreateColorSpaceW:Error CSType = %x\n",lpLogColorSpace->lcsCSType));
            goto InvalidColorSpaceW;
        }
    }

    //
    // Call kernel to create this colorspace.
    //
    hRet = NtGdiCreateColorSpace(&LogColorSpaceExOnStack);

    return(hRet);

InvalidColorSpaceW:

    ICMWRN(("CreateColorSpaceW: Incorrect ColorSpace parameter\n"));
    GdiSetLastError(ERROR_INVALID_COLORSPACE);
    return(NULL);
}

/******************************Public*Routine******************************\
* DeleteColorSpace - delete user object
*
* Arguments:
*
*   hColorSpace - color space handle
*
* Return Value:
*
*   status
*
* History:
*
*    5-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL WINAPI
DeleteColorSpace(
    HCOLORSPACE hColorSpace
    )
{
    ICMAPI(("gdi32: DeleteColorSpace\n"));

    FIXUP_HANDLE(hColorSpace);

    //
    // validate handle, delete
    //
    return (NtGdiDeleteColorSpace(hColorSpace));
}

/******************************Public*Routine******************************\
* SetColorSpace - set logical color space into DC, force new xform to be
* created and all objects re-realized
*
* Arguments:
*
*   hdc         - dc handle
*   hColorSpace - logical color space  handle
*
* Return Value:
*
*   Status
*
* History:
*
*    5-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

HCOLORSPACE META WINAPI
SetColorSpace(
    HDC             hdc,
    HCOLORSPACE     hColorSpace
    )
{
    HANDLE   hRet = NULL;

    ICMAPI(("gdi32: SetColorSpace\n"));

    FIXUP_HANDLE(hdc);
    FIXUP_HANDLE(hColorSpace);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(hRet);

        DC_PLDC(hdc,pldc,hRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SelectAnyObject(hdc,(HANDLE)hColorSpace,EMR_SETCOLORSPACE))
                return(hRet);
        }
    }

    //
    // Update source color space
    //
    hRet = IcmSetSourceColorSpace(hdc,hColorSpace,NULL,0);

    return(hRet);
}

/******************************Public*Routine******************************\
* GetColorSpace - return color space from DC
*
* Arguments:
*
*   hdc
*
* Return Value:
*
*   hColorSpace or NULL
*
* History:
*
*    5-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

HCOLORSPACE WINAPI
GetColorSpace(
    HDC hdc
    )
{
    HANDLE      hRet = NULL;
    PDC_ATTR    pdcattr;

    ICMAPI(("gdi32: GetColorSpace\n"));

    FIXUP_HANDLE(hdc);

    //
    // validate and access hdc
    //
    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        //
        // get hColorSpace
        //
        hRet = (HANDLE)pdcattr->hColorSpace;
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(hRet);
}

/******************************Public*Routine******************************\
*   GetLogColorSpaceA - get colorspace and convert to ASCII
*
*   typedef struct tagLOGCOLORSPACEW {
*       DWORD lcsSignature;
*       DWORD lcsVersion;
*       DWORD lcsSize;
*       LCSCSTYPE lcsCSType;
*       LCSGAMUTMATCH lcsIntent;
*       CIEXYZTRIPLE lcsEndpoints;
*       DWORD lcsGammaRed;
*       DWORD lcsGammaGreen;
*       DWORD lcsGammaBlue;
*       WCHAR  lcsFilename[MAX_PATH];
*   } LOGCOLORSPACEW, *LPLOGCOLORSPACEW;
*
* Arguments:
*
*   hColorSpace - handle to color space
*   lpBuffer    - buffer to hold logcolorspace
*   nSize       - buffer size
*
* Return Value:
*
*   status
*
* History:
*
*    5-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL WINAPI
GetLogColorSpaceA(
    HCOLORSPACE         hColorSpace,
    LPLOGCOLORSPACEA    lpBuffer,
    DWORD               nSize
    )
{
    BOOL            bRet = FALSE;
    LOGCOLORSPACEW  LogColorSpaceW;

    ICMAPI(("gdi32: GetLogColorSpaceA\n"));

    if ((lpBuffer != NULL) && (nSize >= sizeof(LOGCOLORSPACEA)))
    {
        //
        // get info using W version
        //
        bRet = GetLogColorSpaceW(hColorSpace,&LogColorSpaceW,sizeof(LOGCOLORSPACEW));

        if (bRet)
        {
            //
            // copy to user buffer
            //
            lpBuffer->lcsSignature  = LogColorSpaceW.lcsSignature;
            lpBuffer->lcsVersion    = LogColorSpaceW.lcsVersion;
            lpBuffer->lcsSize       = sizeof(LOGCOLORSPACEA);
            lpBuffer->lcsCSType     = LogColorSpaceW.lcsCSType;
            lpBuffer->lcsIntent     = LogColorSpaceW.lcsIntent;
            lpBuffer->lcsEndpoints  = LogColorSpaceW.lcsEndpoints;
            lpBuffer->lcsGammaRed   = LogColorSpaceW.lcsGammaRed;
            lpBuffer->lcsGammaGreen = LogColorSpaceW.lcsGammaGreen;
            lpBuffer->lcsGammaBlue  = LogColorSpaceW.lcsGammaBlue;

            //
            // convert W to A
            //
            bRet = bToASCII_N(lpBuffer->lcsFilename,
                              MAX_PATH,
                              LogColorSpaceW.lcsFilename,
                              wcslen(LogColorSpaceW.lcsFilename)+1);
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
        }
    }
    else
    {
        GdiSetLastError(ERROR_INSUFFICIENT_BUFFER);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* GetLogColorSpaceW - return logical color space info.
*
* Arguments:
*
*   hColorSpace - handle to color space
*   lpBuffer    - buffer to hold logcolorspace
*   nSize       - buffer size
*
* Return Value:
*
*   status
*
* History:
*
*    5-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL WINAPI
GetLogColorSpaceW(
    HCOLORSPACE         hColorSpace,
    LPLOGCOLORSPACEW    lpBuffer,
    DWORD               nSize
    )
{
    BOOL bRet = FALSE;

    ICMAPI(("gdi32: GetLogColorSpaceW\n"));

    if ((lpBuffer != NULL) && (nSize >= sizeof(LOGCOLORSPACEW)))
    {
        FIXUP_HANDLE(hColorSpace);

        //
        // Call kernel to get contents
        //
        if (NtGdiExtGetObjectW(hColorSpace,sizeof(LOGCOLORSPACEW),lpBuffer)
                                                    == sizeof(LOGCOLORSPACEW))
        {
            //
            // Only for stock color space object.
            //
            if ((hColorSpace == GetStockObject(PRIV_STOCK_COLORSPACE)) &&
                (lpBuffer->lcsCSType != LCS_CALIBRATED_RGB))
            {
                ULONG ulSize = MAX_PATH;

                //
                // Load ICM DLL.
                //
                LOAD_ICMDLL(FALSE);

                //
                // Get corresponding profile name from CSType.
                //
                if (!(*fpGetStandardColorSpaceProfileW)(
                         NULL,
                         lpBuffer->lcsCSType,
                         lpBuffer->lcsFilename,
                         &ulSize))
                {
                    ICMMSG(("GetLogColorSpaceW():Fail to SCS(%x), leave it as is\n",
                                                                lpBuffer->lcsCSType));
                }
            }

            bRet = TRUE;
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
        }
    }
    else
    {
        GdiSetLastError(ERROR_INSUFFICIENT_BUFFER);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* CheckColorsInGamut
*
* Arguments:
*
*  hdc        - DC
*  lpRGBQuad  - Buffer of colors to check
*  dlpBuffer  - result buffer
*  nCount     - number of colors
*
* Return Value:
*
*   status
*
* History:
*
* Rewrite it:
*   26-Jan-1997 -by- Hideyuki Nagase [hideyukn]
* Write it:
*    5-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL WINAPI
CheckColorsInGamut(
    HDC             hdc,
    LPVOID          lpRGBTriple,
    LPVOID          dlpBuffer,
    DWORD           nCount
    )
{
    BOOL     bRet = FALSE;
    PDC_ATTR pdcattr;

    ICMAPI(("gdi32: CheckColorsInGamut\n"));

    FIXUP_HANDLE(hdc);

    //
    // Check parameter
    //
    if ((lpRGBTriple == NULL) || (dlpBuffer == NULL) || (nCount == 0))
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    // validate and access hdc
    //
    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        if (IS_ICM_HOST(pdcattr->lIcmMode) ||
            IS_ICM_DEVICE(pdcattr->lIcmMode))
        {
            ASSERTGDI(ghICM,"CheckColorsInGamut(): mscms.dll is not loaded\n");

            if (GetColorTransformInDC(pdcattr))
            {
                //
                // The input buffer may not be DWORD-aligned, And it buffer size
                // might be exactly nCount * sizeof(RGBTRIPLE).
                // So that, allocate DWORD-aligned buffer here.
                //
                PVOID pvBuf = LOCALALLOC(ALIGN_DWORD(nCount*sizeof(RGBTRIPLE)));

                if (!pvBuf)
                {
                    GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    return (FALSE);
                }

                //
                // Make a copy, here
                //
                RtlZeroMemory(pvBuf,ALIGN_DWORD(nCount*sizeof(RGBTRIPLE)));
                RtlCopyMemory(pvBuf,lpRGBTriple,nCount*sizeof(RGBTRIPLE));

                if (IS_ICM_HOST(pdcattr->lIcmMode))
                {
                    //
                    // we handle RGBTRIPLE array as nCount x 1 pixel bitmap.
                    //
                    bRet = (*fpCheckBitmapBits)(
                               (HANDLE)GetColorTransformInDC(pdcattr),
                               pvBuf,
                               BM_RGBTRIPLETS,
                               nCount,1,
                               ALIGN_DWORD(nCount*sizeof(RGBTRIPLE)),
                               dlpBuffer,
                               NULL,0);
                }
                else // if (IS_ICM_DEVICE(pdcattr->lIcmMode))
                {
                    //
                    // Call device driver via kernel.
                    //
                    bRet = NtGdiCheckBitmapBits(
                               hdc,
                               (HANDLE)GetColorTransformInDC(pdcattr),
                               (PVOID)lpRGBTriple,
                               (ULONG)BM_RGBTRIPLETS,
                               nCount,1,
                               ALIGN_DWORD(nCount*sizeof(RGBTRIPLE)),
                               dlpBuffer);
                }

                LOCALFREE(pvBuf);
            }
            else
            {
                //
                // There is no valid color transform,
                // so it is assume ident. color transform,
                // then that every color in the gamut.
                //
                RtlZeroMemory(dlpBuffer,nCount);
                bRet = TRUE;
            }
        }
        else
        {
            WARNING("CheckColorsInGamut():ICM mode is invalid\n");
            GdiSetLastError(ERROR_ICM_NOT_ENABLED);
        }
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* ColorMatchToTarget
*
* Arguments:
*
*   hdc,
*   hdcTarget
*   uiAction
*
* Return Value:
*
*   status
*
* History:
*
* Rewrite it:
*   26-Jan-1997 -by- Hideyuki Nagase [hideyukn]
* Write it:
*    5-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL META WINAPI
ColorMatchToTarget(
    HDC   hdc,
    HDC   hdcTarget,
    DWORD uiAction
    )
{
    BOOL     bRet = FALSE;
    PDC_ATTR pdcattrTarget;

    ICMAPI(("gdi32: ColorMatchToTarget\n"));

    FIXUP_HANDLE(hdcTarget);

    //
    // Verify Target DC. No ICM with Windows MetaFile.
    //
    if (IS_METADC16_TYPE(hdcTarget))
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(bRet);
    }

    PSHARED_GET_VALIDATE(pdcattrTarget,hdcTarget,DC_TYPE);

    if (pdcattrTarget != NULL)
    {
        PCACHED_COLORSPACE pTargetColorSpace = NULL;

        PLDC pldcTarget = (PLDC)(pdcattrTarget->pvLDC);

        if (!IS_ICM_INSIDEDC(pdcattrTarget->lIcmMode))
        {
            GdiSetLastError(ERROR_ICM_NOT_ENABLED);
            return (FALSE);
        }

        //
        // No Enhanced metafile DC as target DC.
        //
        if (pldcTarget && pldcTarget->iType == LO_METADC)
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            return(bRet);
        }

        //
        // ICMINFO should be exist.
        //
        if (!BEXIST_ICMINFO(pdcattrTarget))
        {
            GdiSetLastError(ERROR_ICM_NOT_ENABLED);
            return(bRet);
        }

        if (uiAction == CS_ENABLE)
        {
            //
            // Hold critical section for color space to make sure pTargetColorSpace won't be deleted
            //
            ENTERCRITICALSECTION(&semColorSpaceCache);

            //
            // Target DC has LDC and ICMINFO, pick up colorspace data from there.
            //
            pTargetColorSpace = ((PGDI_ICMINFO)(pdcattrTarget->pvICM))->pDestColorSpace;

            //
            // Select it to target. the ref count of pTargetColorSpace will be incremented
            // if we suceed to select.
            //
            bRet = ColorMatchToTargetInternal(hdc,pTargetColorSpace,uiAction);

            LEAVECRITICALSECTION(&semColorSpaceCache);
        }
        else
        {
            bRet = ColorMatchToTargetInternal(hdc,NULL,uiAction);
        }
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return (bRet);
}

BOOL WINAPI
ColorMatchToTargetInternal(
    HDC                hdc,
    PCACHED_COLORSPACE pTargetColorSpace,
    DWORD              uiAction
    )
{
    BOOL     bRet = FALSE;
    BOOL     bEhnMetafile = FALSE;
    PDC_ATTR pdcattr;

    FIXUP_HANDLE(hdc);

    //
    // Verify destination DC. No ICM with Windows MetaFile.
    //
    if (IS_METADC16_TYPE(hdc))
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if (pdcattr != NULL)
    {
        PLDC pldc = (PLDC)(pdcattr->pvLDC);

        //
        // Check ICM is enabled on hdc properly.
        //
        if (pldc && (pldc->iType == LO_METADC))
        {
            //
            // ICM should be turned on "fakely" on metafile hdc
            //
            if (!IS_ICM_METAFILING_ON(pdcattr->lIcmMode))
            {
                GdiSetLastError(ERROR_ICM_NOT_ENABLED);
                return (FALSE);
            }

            //
            // Mark we are recording into Enhanced metafile.
            //
            bEhnMetafile = TRUE;
        }
        else
        {
            if (!IS_ICM_INSIDEDC(pdcattr->lIcmMode))
            {
                GdiSetLastError(ERROR_ICM_NOT_ENABLED);
                return (FALSE);
            }
        }

        switch (uiAction)
        {
        case CS_ENABLE:

            //
            // Fail, if we are in proofing mode, already.
            //
            if (!IS_ICM_PROOFING(pdcattr->lIcmMode))
            {
                if (pTargetColorSpace)
                {
                    if (bEhnMetafile)
                    {
                        //
                        // Set the data to metafile.
                        //
                        bRet = MF_ColorMatchToTarget(
                                    hdc, uiAction,
                                    (PVOID) pTargetColorSpace,
                                    EMR_COLORMATCHTOTARGETW);
                    }
                    else
                    {
                        //
                        // Set Target color space.
                        //
                        // (this increments ref count of pTargetColorSpace)
                        //
                        bRet = IcmSetTargetColorSpace(hdc,pTargetColorSpace,uiAction);
                    }
                }
            }
            else
            {
                WARNING("ColorMatchToTargetInternal(): DC is proofing mode already\n");
                GdiSetLastError(ERROR_INVALID_PARAMETER);
            }

            break;

        case CS_DISABLE:
        case CS_DELETE_TRANSFORM:

            if (IS_ICM_PROOFING(pdcattr->lIcmMode))
            {
                if (bEhnMetafile)
                {
                    //
                    // Set the data to metafile.
                    //
                    bRet = MF_ColorMatchToTarget(
                                   hdc, uiAction, NULL,
                                   EMR_COLORMATCHTOTARGETW);
                }
                else
                {
                    //
                    // Reset Target color space
                    //
                    bRet = IcmSetTargetColorSpace(hdc,NULL,uiAction);
                }
            }
            else
            {
                //
                // we are not in proofing mode, never called with CS_ENABLE before.
                //
                WARNING("ColorMatchToTarget: DC is not proofing mode\n");
                GdiSetLastError(ERROR_INVALID_PARAMETER);
            }

            break;

        default:

            WARNING("ColorMatchToTarget: uiAction is invalid\n");
            GdiSetLastError(ERROR_INVALID_PARAMETER);
        }
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        WARNING("ColorMatchToTarget: invalid DC\n");
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* GetICMProfileA - get current profile from DC
*
* Arguments:
*
*   hdc       - DC
*   szBuffer  - size of buffer
*   pBuffer   - user buffer
*
* Return Value:
*
*   status
*
* History:
*
* Rewrite it:
*   05-Feb-1996 -by- Hideyuki Nagase [hideyukn]
* Write it:
*    5-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL WINAPI
GetICMProfileA(
    HDC     hdc,
    LPDWORD pBufSize,
    LPSTR   pszFilename
    )
{
    BOOL      bRet = FALSE;
    WCHAR     wchProfile[MAX_PATH];
    DWORD     BufSizeW = MAX_PATH;

    ICMAPI(("gdi32: GetICMProfileA\n"));

    if (pBufSize == NULL)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    // Call W version.
    //
    if (GetICMProfileW(hdc,&BufSizeW,wchProfile))
    {
        CHAR  chProfile[MAX_PATH];
        DWORD BufSizeA = MAX_PATH;

        if (BufSizeW)
        {
            //
            // Unicode to Ansi convertion
            //
            BufSizeA = WideCharToMultiByte(CP_ACP,0,
                                           wchProfile,BufSizeW,
                                           chProfile,BufSizeA,
                                           NULL,NULL);

            if ((pszFilename == NULL) || (*pBufSize < BufSizeA))
            {
                //
                // if the buffer is not given or not enough, return nessesary buffer size and error.
                //
                *pBufSize = BufSizeA;
                GdiSetLastError(ERROR_INSUFFICIENT_BUFFER);
            }
            else
            {
                //
                // copy converted string to buffer.
                //
                lstrcpyA(pszFilename,chProfile);
                *pBufSize = BufSizeA;
                bRet = TRUE;
            }
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* GetICMProfileW - read icm profile from DC
*
* Arguments:
*
*   hdc      - DC
*   szBuffer - size of user buffer
*   pszFilename  - user W buffer
*
* Return Value:
*
*   Boolean
*
* History:
*
*    5-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL WINAPI
GetICMProfileW(
    HDC     hdc,
    LPDWORD pBufSize,
    LPWSTR  pszFilename
    )
{
    PDC_ATTR  pdcattr;

    ICMAPI(("gdi32: GetICMProfileW\n"));

    FIXUP_HANDLE(hdc);

    if (pBufSize == NULL)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        PGDI_ICMINFO pIcmInfo;
        PWSZ         pwszProfile = NULL;
        ULONG        ulSize = 0;

        //
        // Initialize ICMINFO
        //
        if ((pIcmInfo = INIT_ICMINFO(hdc,pdcattr)) == NULL)
        {
            WARNING("gdi32: GetICMProfileW: Can't init icm info\n");
            return(FALSE);
        }

        if (IsColorDeviceContext(hdc))
        {
            //
            // Load external ICM dll
            //
            LOAD_ICMDLL(FALSE);

            //
            // if there is no destination profile for the DC, then load
            // the defualt
            //
            IcmUpdateLocalDCColorSpace(hdc,pdcattr);

            if (pIcmInfo->pDestColorSpace)
            {
                //
                // Get profile name in destination colorspace.
                //
                pwszProfile = pIcmInfo->pDestColorSpace->LogColorSpace.lcsFilename;
            }
        }
        else
        {
            ICMMSG(("GetICMProfile(): for Mono-device\n"));

            //
            // There is no destination profile AS default,
            // *BUT* if Apps set it by calling SetICMProfile(), return it.
            //
            if (pIcmInfo->flInfo & ICM_VALID_CURRENT_PROFILE)
            {
                pwszProfile = pIcmInfo->DefaultDstProfile;
            }
        }

        if (pwszProfile)
        {
            ulSize = lstrlenW(pwszProfile) + 1; // + 1 for null-terminated
        }

        if (ulSize <= 1)
        {
            //
            // No profile, Or only NULL character.
            //
            GdiSetLastError(ERROR_PROFILE_NOT_FOUND);
            return(FALSE);
        }
        else if (*pBufSize >= ulSize)
        {
            //
            // There is enough buffer, copy filename.
            //
            lstrcpyW(pszFilename,pwszProfile);
            *pBufSize = ulSize;
            return (TRUE);
        }
        else
        {
            //
            // if buffer is not presented or it's too small,
            // returns the nessesary buffer size.
            //
            GdiSetLastError(ERROR_INSUFFICIENT_BUFFER);
            *pBufSize = ulSize;
            return (FALSE);
        }
    }

    //
    // something error.
    //
    GdiSetLastError(ERROR_INVALID_PARAMETER);
    return(FALSE);
}

/******************************Public*Routine******************************\
* SetICMProfileA - convert the profile string to WCHAR and save in DC
*
* Arguments:
*
*   hdc         - DC
*   pszFileName - Profile name
*
* Return Value:
*
*   status
*
* History:
*
* Rewrite it:
*   23-Jan-1996 -by- Hideyuki Nagase [hideyukn]
* Write it:
*    5-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL META WINAPI
SetICMProfileA(
    HDC   hdc,
    LPSTR pszFileName
    )
{
    ICMAPI(("gdi32: SetICMProfileA\n"));

    return (SetICMProfileInternalA(hdc,pszFileName,NULL,0));
}

BOOL
SetICMProfileInternalA(
    HDC                hdc,
    LPSTR              pszFileName,
    PCACHED_COLORSPACE pColorSpace,
    DWORD              dwFlags
    )
{
    BOOL bRet = FALSE;

    //
    // Check parameter either pColorSpace or pszFilename should be given.
    //
    if (pColorSpace)
    {
        ICMAPI(("gdi32: SetICMProfileA by ColorSpace (%ws):dwFlags - %d\n",
                           pColorSpace->LogColorSpace.lcsFilename,dwFlags));
    }
    else if (pszFileName)
    {
        ICMAPI(("gdi32: SetICMProfileA by profile name (%s):dwFlags - %x\n",
                                                      pszFileName,dwFlags));
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(bRet);

        DC_PLDC(hdc,pldc,bRet)

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SetICMProfile(hdc,
                                  (LPBYTE)pszFileName,
                                  (PVOID)pColorSpace,
                                  EMR_SETICMPROFILEA))
            {
                return((int)FALSE);
            }
        }
    }

    if (pColorSpace)
    {
        //
        // Select the given profile into DC.
        //
        // (this increments ref count of pColorSpace)
        //
        bRet = IcmSetDestinationColorSpace(hdc,NULL,pColorSpace,dwFlags);
    }
    else if (pszFileName)
    {
        ULONG ulSize = lstrlenA(pszFileName);

        if (ulSize && (ulSize < MAX_PATH))
        {
            WCHAR pwszCapt[MAX_PATH];

            //
            // let me count null-terminate char.
            //
            ulSize += 1;

            //
            // Convert to Unicode.
            //
            vToUnicodeN(pwszCapt,MAX_PATH,pszFileName,ulSize);

            //
            // Select the given profile into DC.
            //
            bRet = IcmSetDestinationColorSpace(hdc,pwszCapt,NULL,dwFlags);
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* SetICMProfileW - set profile name into DC
*
* Arguments:
*
* Return Value:
*
* History:
*
*    5-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL META WINAPI
SetICMProfileW(
    HDC hdc,
    LPWSTR pwszFileName
    )
{
    ICMAPI(("gdi32: SetICMProfileW\n"));

    return (SetICMProfileInternalW(hdc,pwszFileName,NULL,0));
}

BOOL
SetICMProfileInternalW(
    HDC                hdc,
    LPWSTR             pwszFileName,
    PCACHED_COLORSPACE pColorSpace,
    DWORD              dwFlags
    )
{
    BOOL      bRet = FALSE;

    //
    // Check parameter either pColorSpace or pszFilename should be given.
    //
    if (pColorSpace)
    {
        ICMAPI(("gdi32: SetICMProfileW by ColorSpace (%ws):dwFlags - %x\n",
                           pColorSpace->LogColorSpace.lcsFilename,dwFlags));
    }
    else if (pwszFileName)
    {
        ICMAPI(("gdi32: SetICMProfileW by profile name (%ws):dwFlags - %d\n",
                                                      pwszFileName,dwFlags));
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(bRet);

        DC_PLDC(hdc,pldc,bRet)

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SetICMProfile(hdc,
                                  (LPBYTE)pwszFileName,
                                  (PVOID)pColorSpace,
                                  EMR_SETICMPROFILEW))
            {
                return((int)FALSE);
            }
        }
    }

    //
    // Select the given profile into DC.
    //
    // (this increments ref count of pColorSpace)
    //
    bRet = IcmSetDestinationColorSpace(hdc,pwszFileName,pColorSpace,dwFlags);

    return (bRet);
}

/******************************Public*Routine******************************\
* EnumICMProfilesA
*
* Arguments:
*
*   hdc
*   lpEnumGamutMatchProc
*   lParam
*
* Return Value:
*
* History:
*
* Write it:
*  13-Feb-1997 -by- Hideyuki Nagase [hideyukn]
*
\**************************************************************************/

int WINAPI
EnumICMProfilesA(
    HDC                hdc,
    ICMENUMPROCA       lpEnumGamutMatchProc,
    LPARAM             lParam
    )
{
    int  iRet = -1;
    BOOL bRet;

    ICMAPI(("gdi32: EnumICMProfileA\n"));

    FIXUP_HANDLE(hdc);

    VALIDATE_HANDLE(bRet,hdc,DC_TYPE);

    if (bRet && (lpEnumGamutMatchProc != NULL))
    {
        iRet = IcmEnumColorProfile(hdc,lpEnumGamutMatchProc,lParam,TRUE,NULL,NULL);
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* EnumICMProfilesW
*
* Arguments:
*
*   hdc
*   lpEnumGamutMatchProc
*   lParam
*
* Return Value:
*
* History:
*
* Write it:
*  13-Feb-1997 -by- Hideyuki Nagase [hideyukn]
*
\**************************************************************************/

int WINAPI
EnumICMProfilesW(
    HDC                hdc,
    ICMENUMPROCW       lpEnumGamutMatchProc,
    LPARAM             lParam
    )
{
    int  iRet = -1;
    BOOL bRet;

    ICMAPI(("gdi32: EnumICMProfileW\n"));

    FIXUP_HANDLE(hdc);

    VALIDATE_HANDLE(bRet,hdc,DC_TYPE);

    if (bRet && (lpEnumGamutMatchProc != NULL))
    {
        iRet = IcmEnumColorProfile(hdc,lpEnumGamutMatchProc,lParam,FALSE,NULL,NULL);
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* UpdateICMRegKeyW()
*
* History:
*    8-Jan-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL WINAPI
UpdateICMRegKeyW(
    DWORD  Reserved,
    PWSTR  pwszICMMatcher,
    PWSTR  pwszFileName,
    UINT   Command
    )
{
    BOOL bRet = FALSE;

    int iRet;

    ICMAPI(("gdi32: UpdateICMRegKeyW\n"));

    if (Reserved != 0)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    // Load external ICM dlls
    //
    LOAD_ICMDLL(FALSE);

    switch (Command)
    {
    case ICM_ADDPROFILE:

        if (pwszFileName)
        {
            //
            // Call InstallColorProfileA() in mscms.dll
            //
            bRet = (*fpInstallColorProfileW)(NULL, pwszFileName);
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
        }
        break;

    case ICM_DELETEPROFILE:

        if (pwszFileName)
        {
            //
            // Call UninstallColorProfileW() in mscms.dll
            //
            bRet = (*fpUninstallColorProfileW)(NULL, pwszFileName, FALSE);
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
        }
        break;

    case ICM_QUERYPROFILE:

        if (pwszFileName)
        {
            PROFILECALLBACK_DATA QueryProfile;

            QueryProfile.pwszFileName = GetFileNameFromPath(pwszFileName);
            QueryProfile.bFound       = FALSE;

            if (QueryProfile.pwszFileName != NULL)
            {
                //
                // Enumrate all registered profile to find this profile.
                //
                IcmEnumColorProfile(NULL,IcmQueryProfileCallBack,(LPARAM)(&QueryProfile),FALSE,NULL,NULL);

                //
                // Is that found ?
                //
                bRet = QueryProfile.bFound;
            }
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
        }
        break;

    case ICM_SETDEFAULTPROFILE:

        //
        // Not supported.
        //
        GdiSetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        break;

    case ICM_REGISTERICMATCHER:

        if (pwszICMMatcher && pwszFileName)
        {
            DWORD dwCMM = *((DWORD *)pwszICMMatcher);

            //
            // Call RegisterCMMW() in mscms.dll
            //
            bRet = (*fpRegisterCMMW)(NULL, IcmSwapBytes(dwCMM), pwszFileName);
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
        }
        break;

    case ICM_UNREGISTERICMATCHER:

        if (pwszICMMatcher)
        {
            DWORD dwCMM = *((DWORD *)pwszICMMatcher);

            //
            // Call UnregisterCMMW() in mscms.dll
            //
            bRet = (*fpUnregisterCMMW)(NULL, IcmSwapBytes(dwCMM));
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
        }
        break;

    case ICM_QUERYMATCH:

        if (pwszFileName)
        {
            //
            // Find match profile.
            //
            iRet = IcmEnumColorProfile(NULL,NULL,0,FALSE,(PDEVMODEW)pwszFileName,NULL);

            //
            // Adjust return value, because IcmEnumColorProfile returns -1 if not found.
            // and 0 for error (since no callback function)
            //
            if (iRet > 0)
            {
                bRet = TRUE;
            }
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
        }
        break;

    default:

        WARNING("gdi32!UpdateICMRegKeyW():Invalid Command\n");
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        break;
    }

    return bRet;
}

/******************************Public*Routine******************************\
* UpdateICMRegKeyA
*
* Arguments:
*
*   Reserved
*   szICMMatcher
*   szFileName
*   Command
*
* Return Value:
*
*   Status
*
* History:
*
*    8-Jan-1997 -by- Hideyuki Nagase [hideyukn]
*
\**************************************************************************/

BOOL WINAPI
UpdateICMRegKeyA(
    DWORD Reserved,
    PSTR  szICMMatcher,
    PSTR  szFileName,
    UINT  Command
    )
{
    BOOL bRet = FALSE;
    BOOL bError = FALSE;

    PWSTR pwszFileName = NULL;

    //
    // szICMMatcher points to 4 bytes CMM ID, actually it is not "string".
    // Ansi to Unicode conversion is not needed.
    //
    PWSTR pwszICMMatcher = (PWSTR) szICMMatcher;

    ULONG cjSize;

    ICMAPI(("gdi32: UpdateICMRegKeyA\n"));

    if (Reserved != 0)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    switch (Command)
    {
    case ICM_ADDPROFILE:
    case ICM_DELETEPROFILE:
    case ICM_QUERYPROFILE:
    case ICM_REGISTERICMATCHER:

        //
        // szFileName should be presented.
        //
        if (szFileName)
        {
            //
            // szFileName points to ansi string, just convert to Unicode.
            //
            cjSize = lstrlenA(szFileName)+1;

            pwszFileName = LOCALALLOC((cjSize)*sizeof(WCHAR));
            if (pwszFileName == NULL)
            {
                GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return (bRet);
            }

            vToUnicodeN(pwszFileName,cjSize,szFileName,cjSize);
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            bError = TRUE;
        }
        break;

    case ICM_QUERYMATCH:

        //
        // szFileName should be presented.
        //
        if (szFileName)
        {
            //
            // szFileName points to DEVMODEA structure, convert it to DEVMODEW
            //
            pwszFileName = (PWSTR) GdiConvertToDevmodeW((DEVMODEA *)szFileName);
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            bError = TRUE;
        }
        break;

    case ICM_SETDEFAULTPROFILE:

        GdiSetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        bError = TRUE;
        break;

    case ICM_UNREGISTERICMATCHER:

        //
        // Nothing to convert to Unicode.
        //
        ASSERTGDI(szFileName==NULL,"UpdateICMRegKeyA():szFileName is not null\n");
        break;

    default:

        WARNING("GDI:UpdateICMRegKeyA():Command is invalid\n");
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        bError = TRUE;
        break;
    }

    if (!bError)
    {
        //
        // Call W version.
        //
        bRet = UpdateICMRegKeyW(Reserved,pwszICMMatcher,pwszFileName,Command);
    }

    if (pwszFileName)
    {
        LOCALFREE(pwszFileName);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* GetDeviceGammaRamp
*
* Arguments:
*
*   hdc
*   lpGammaRamp
*
* Return Value:
*
*   Status
*
* History:
*
*    5-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL WINAPI
GetDeviceGammaRamp(
    HDC             hdc,
    LPVOID          lpGammaRamp
    )
{
    BOOL    bRet = FALSE;

    ICMAPI(("gdi32: GetDeviceGammaRamp\n"));

    if (lpGammaRamp == NULL)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }
    else
    {
        //
        // Call kernel to get current Gamma ramp array for this DC.
        //
        bRet = NtGdiGetDeviceGammaRamp(hdc,lpGammaRamp);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* SetDeviceGammaRamp
*
* Arguments:
*
*   hdc
*   lpGammaRamp
*
* Return Value:
*
*   Status
*
* History:
*
*    5-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL WINAPI
SetDeviceGammaRamp(
    HDC             hdc,
    LPVOID          lpGammaRamp
    )
{
    BOOL    bRet = FALSE;

    ICMAPI(("gdi32: SetDeviceGammaRamp\n"));

    if (lpGammaRamp == NULL)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }
    else
    {
        //
        // Call kernel to set new Gamma ramp array for this DC.
        //
        bRet = NtGdiSetDeviceGammaRamp(hdc,lpGammaRamp);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* ColorCorrectPalette
*
*   If this is not the default palette and ICM is turned on in the DC
*   then translate the specified palette entries according to the color
*   transform in the DC
*
* Arguments:
*
*   hdc             -  DC handle
*   hpal            -  PALETTE handle
*   FirsrEntry      -  first entry in palette to translate
*   NumberOfEntries -  number of entries to translate
*
* Return Value:
*
*   Status
*
* History:
*
* Write it:
*  13-Feb-1997 -by- Hideyuki Nagase [hideyukn]
*
\**************************************************************************/

BOOL META WINAPI
ColorCorrectPalette(
    HDC      hdc,
    HPALETTE hpal,
    ULONG    FirstEntry,
    ULONG    NumberOfEntries
    )
{
    BOOL bStatus = FALSE;
    PDC_ATTR pdcattr = NULL;

    ICMAPI(("gdi32: ColorCorrectPalette\n"));

    //
    // Parameter check (max entry of log palette is 0x65536)
    //
    if ((hdc == NULL) || (hpal == NULL) ||
        (NumberOfEntries == 0) || (NumberOfEntries > 65536) ||
        (FirstEntry >= 65536) || (65536 - NumberOfEntries < FirstEntry))
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    // default palette could not be changed...
    //
    if (hpal != (HPALETTE)GetStockObject(DEFAULT_PALETTE))
    {
        //
        // metafile call
        //
        if (IS_ALTDC_TYPE(hdc))
        {
            PLDC pldc;

            if (IS_METADC16_TYPE(hdc))
                return(bStatus);

            DC_PLDC(hdc,pldc,bStatus);

            if (pldc->iType == LO_METADC)
            {
                if (!MF_ColorCorrectPalette(hdc,hpal,FirstEntry,NumberOfEntries))
                {
                    return(FALSE);
                }
            }
        }

        PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

        if (pdcattr)
        {
            //
            // Load external ICM dlls
            //
            LOAD_ICMDLL(FALSE);

            if (IS_ICM_HOST(pdcattr->lIcmMode))
            {
                if (bNeedTranslateColor(pdcattr))
                {
                    PPALETTEENTRY ppalEntrySrc = NULL;
                    PPALETTEENTRY ppalEntryDst = NULL;
                    ULONG         NumEntriesRetrieved = 0;

                    //
                    // Make sure palette can be color corrected, get requested entries
                    //
                    ULONG Index;

                    ppalEntrySrc = LOCALALLOC((NumberOfEntries * sizeof(PALETTEENTRY)) * 2);

                    if (ppalEntrySrc == NULL)
                    {
                        WARNING("ColorCorrectPalette: ppalEntry = NULL\n");
                        GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
                        return(bStatus);
                    }

                    NumEntriesRetrieved = NtGdiColorCorrectPalette(hdc,
                                                                   hpal,
                                                                   FirstEntry,
                                                                   NumberOfEntries,
                                                                   ppalEntrySrc,
                                                                   ColorPaletteQuery);

                    if (NumEntriesRetrieved > 0)
                    {
                        ppalEntryDst = ppalEntrySrc + NumberOfEntries;

                        //
                        // Translate palette entry colors
                        //
                        IcmTranslatePaletteEntry(hdc,pdcattr,ppalEntrySrc,ppalEntryDst,NumEntriesRetrieved);

                        //
                        // set new palette entries
                        //
                        NumEntriesRetrieved = NtGdiColorCorrectPalette(hdc,
                                                                       hpal,
                                                                       FirstEntry,
                                                                       NumEntriesRetrieved,
                                                                       ppalEntryDst,
                                                                       ColorPaletteSet);

                        if (NumEntriesRetrieved > 0)
                        {
                            bStatus = TRUE;
                        }
                    }
                    else
                    {
                        GdiSetLastError(ERROR_INVALID_PARAMETER);
                    }

                    LOCALFREE(ppalEntrySrc);
                }
                else
                {
                    //
                    // Don't need to translate color.
                    //
                    bStatus = TRUE;
                }
            }
            else if (IS_ICM_DEVICE(pdcattr->lIcmMode))
            {
                //
                // for device ICM, don't need to do anything.
                //
                bStatus = TRUE;
            }
            else
            {
                WARNING("ColorCorrectPalette():ICM mode is not enabled\n");
                GdiSetLastError(ERROR_ICM_NOT_ENABLED);
            }
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
        }
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return bStatus;
}

/******************************Public*Routine******************************\
* IcmTranslateColorObjects - called when there is a change in ICM color transfrom
*                  state
*
* Arguments:
*
*   hdc     - input DC
*   pdcattr - DC's attrs
*
* Return Value:
*
*   status
*
* History:
*
* Rewrite it:
*   13-Feb-1997 -by- Hideyuki Nagase [hideyukn]
* Write it:
*    9-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
IcmTranslateColorObjects(
    HDC      hdc,
    PDC_ATTR pdcattr,
    BOOL     bICMEnable
    )
{
    BOOL bStatus = TRUE;

    COLORREF OldColor;
    COLORREF NewColor;

    ICMAPI(("gdi32: IcmTranslateColorObjects\n"));

    //
    // Invalidate IcmPenColor/IcmBrushColor
    //
    pdcattr->ulDirty_ &= ~(ICM_PEN_TRANSLATED | ICM_BRUSH_TRANSLATED);

    if (bICMEnable)
    {
        if(bNeedTranslateColor(pdcattr))
        {
            if (GetColorTransformInDC(pdcattr) == NULL)
            {
                WARNING("Error in IcmTranslateColorObjects: called when hcmXform == NULL");
                return FALSE;
            }

            //
            // translate Foreground to new icm mode if not paletteindex
            //
            if (!(pdcattr->ulForegroundClr & 0x01000000))
            {
                OldColor = pdcattr->ulForegroundClr;

                bStatus = IcmTranslateCOLORREF(hdc,
                                               pdcattr,
                                               OldColor,
                                               &NewColor,
                                               ICM_FORWARD);

                if (bStatus)
                {
                    pdcattr->crForegroundClr = NewColor;
                }
                else
                {
                    pdcattr->crForegroundClr = OldColor;
                }
            }

            //
            // translate Background to new icm mode if not paletteindex
            //
            if (!(pdcattr->ulBackgroundClr & 0x01000000))
            {
                OldColor = pdcattr->ulBackgroundClr;

                bStatus = IcmTranslateCOLORREF(hdc,
                                               pdcattr,
                                               OldColor,
                                               &NewColor,
                                               ICM_FORWARD);

                if (bStatus)
                {
                    pdcattr->crBackgroundClr = NewColor;
                }
                else
                {
                    pdcattr->crBackgroundClr = OldColor;
                }
            }

            //
            // translate DCBrush to new icm mode if not paletteindex
            //
            if (!(pdcattr->ulDCBrushClr & 0x01000000))
            {
                OldColor = pdcattr->ulDCBrushClr;

                bStatus = IcmTranslateCOLORREF(hdc,
                                               pdcattr,
                                               OldColor,
                                               &NewColor,
                                               ICM_FORWARD);

                if (bStatus)
                {
                    pdcattr->crDCBrushClr = NewColor;
                }
                else
                {
                    pdcattr->crDCBrushClr = OldColor;
                }
            }

            //
            // translate DCPen to new icm mode if not paletteindex
            //
            if (!(pdcattr->ulDCPenClr & 0x01000000))
            {
                OldColor = pdcattr->ulDCPenClr;

                bStatus = IcmTranslateCOLORREF(hdc,
                                               pdcattr,
                                               OldColor,
                                               &NewColor,
                                               ICM_FORWARD);

                if (bStatus)
                {
                    pdcattr->crDCPenClr = NewColor;
                }
                else
                {
                    pdcattr->crDCPenClr = OldColor;
                }
            }

            //
            // set icm color of selected logical brush
            //
            IcmTranslateBrushColor(hdc,pdcattr,(HANDLE)pdcattr->hbrush);

            //
            // set icm color of selected logical pen/extpen
            //
            if (LO_TYPE(pdcattr->hpen) == LO_EXTPEN_TYPE)
            {
                IcmTranslateExtPenColor(hdc,pdcattr,(HANDLE)pdcattr->hpen);
            }
            else
            {
                IcmTranslatePenColor(hdc,pdcattr,(HANDLE)pdcattr->hpen);
            }
        }
    }
    else
    {
        PBRUSHATTR pbrushattr;

        //
        // ICM is off, restore colors (non device icm only)
        //
        pdcattr->crForegroundClr = pdcattr->ulForegroundClr & 0x13ffffff;
        pdcattr->crBackgroundClr = pdcattr->ulBackgroundClr & 0x13ffffff;
        pdcattr->crDCBrushClr    = pdcattr->ulDCBrushClr    & 0x13ffffff;
        pdcattr->crDCPenClr      = pdcattr->ulDCPenClr      & 0x13ffffff;

        //
        // set icm color of selected logical brush
        //
        PSHARED_GET_VALIDATE(pbrushattr,pdcattr->hbrush,BRUSH_TYPE);

        if (pbrushattr)
        {
            pdcattr->IcmBrushColor = pbrushattr->lbColor;
        }

        //
        // set icm color of selected logical pen
        //
        PSHARED_GET_VALIDATE(pbrushattr,pdcattr->hpen,BRUSH_TYPE);

        if (pbrushattr)
        {
            pdcattr->IcmPenColor = pbrushattr->lbColor;
        }
    }

    //
    // set DC dirty flags to force re-realization of color objects
    //
    pdcattr->ulDirty_ |= (DIRTY_BRUSHES|DC_BRUSH_DIRTY|DC_PEN_DIRTY);

    return(bStatus);
}

/******************************Public*Routine******************************\
* IcmCreateTemporaryColorProfile()
*
* History:
*
* Wrote it:
*     7.May.1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
IcmCreateTemporaryColorProfile(
    LPWSTR TemporaryColorProfile,
    LPBYTE ProfileData,
    DWORD  ProfileDataSize
    )
{
    BOOL  bRet = FALSE;

    WCHAR TempPath[MAX_PATH];
    WCHAR TempFile[MAX_PATH];

    //
    // make temp file for profile, include name in lcspw
    //
    if (GetTempPathW(MAX_PATH,(LPWSTR)TempPath))
    {
        BOOL bPathOK = TRUE;

        if (TemporaryColorProfile[0] != UNICODE_NULL)
        {
            wcscpy(TempFile,TempPath);
            wcscat(TempFile,TemporaryColorProfile);
        }
        else
        {
            bPathOK = GetTempFileNameW((LPWSTR)TempPath,L"ICM",0,(LPWSTR)TempFile);
        }

        if (bPathOK)
        {
            if (ProfileDataSize == 0)
            {
                //
                // Nothing needs to save, just return with created filename
                //
                lstrcpyW(TemporaryColorProfile,TempFile);

                bRet = TRUE;
            }
            else
            {
                HANDLE hFile = CreateFileW((LPWSTR)TempFile,
                                    GENERIC_READ | GENERIC_WRITE,
                                    0,
                                    NULL,
                                    CREATE_ALWAYS,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL);

                if (hFile != INVALID_HANDLE_VALUE)
                {
                    ULONG ulWritten;

                    if (WriteFile(hFile,ProfileData,ProfileDataSize,&ulWritten,NULL))
                    {
                        //
                        // Put the created file name into LOGCOLORSPACE
                        //
                        lstrcpyW(TemporaryColorProfile,TempFile);

                        //
                        // Close file handle
                        //
                        CloseHandle(hFile);

                        //
                        // Everything O.K.
                        //
                        bRet = TRUE;
                    }
                    else
                    {
                        ICMWRN(("IcmCreateTemporaryColorProfile(): Failed WriteFile\n"));

                        //
                        // Failed, close handle and delete it.
                        //
                        CloseHandle(hFile);
                        DeleteFileW(TempFile);
                    }
                }
                else
                {
                    ICMWRN(("IcmCreateTemporaryColorProfile(): Failed CreateFile\n"));
                }
            }
        }
        else
        {
            ICMWRN(("IcmCreateTemporaryColorProfile(): Failed CreateTempFileName\n"));
        }
    }
    else
    {
        ICMWRN(("IcmCreateTemporayColorProfile(): Failed GetTempPath\n"));
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* IcmGetBitmapColorSpace()
*
* History:
*
* Wrote it:
*     13.March.1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
IcmGetBitmapColorSpace(
    LPBITMAPINFO     pbmi,
    LPLOGCOLORSPACEW plcspw,
    PPROFILE         pColorProfile,
    PDWORD           pdwFlags
)
{
    BOOL bBitmapColorSpace = FALSE;

    ICMAPI(("gdi32: IcmGetBitmapColorSpace\n"));

    //
    // Init output buffers with zero.
    //
    *pdwFlags = 0;
    ZeroMemory(plcspw,sizeof(LOGCOLORSPACE));
    ZeroMemory(pColorProfile,sizeof(PROFILE));

    //
    // check for BITMAPV4 OR BITMAPV5
    //
    if (pbmi->bmiHeader.biSize == sizeof(BITMAPV4HEADER))
    {
        PBITMAPV4HEADER pbmih4 = (PBITMAPV4HEADER)&pbmi->bmiHeader;

        ICMMSG(("IcmGetBitmapColorSpace: BITMAPV4HEADER\n"));

        //
        // if CIEXYZ endpoints are given, create a new color transform
        // to use.
        //
        plcspw->lcsSignature = LCS_SIGNATURE;
        plcspw->lcsVersion   = 0x400;
        plcspw->lcsSize      = sizeof(LOGCOLORSPACEW);
        plcspw->lcsCSType    = pbmih4->bV4CSType;
        plcspw->lcsIntent    = LCS_GM_IMAGES;
        plcspw->lcsEndpoints = pbmih4->bV4Endpoints;
        plcspw->lcsGammaRed   = pbmih4->bV4GammaRed;
        plcspw->lcsGammaGreen = pbmih4->bV4GammaGreen;
        plcspw->lcsGammaBlue  = pbmih4->bV4GammaBlue;

        if (pbmih4->bV4CSType == LCS_CALIBRATED_RGB)
        {
            ICMMSG(("IcmGetBitmapColorSpace: BITMAPv4 CALIBRATED RGB\n"));
            ICMMSG(("  lcspw.lcsCSType     = %x\n",pbmih4->bV4CSType));
            ICMMSG(("  lcspw.lcsIntent     = %d\n",LCS_GM_IMAGES));
            ICMMSG(("  lcspw.lcsGammaRed   = %d\n",pbmih4->bV4GammaRed));
            ICMMSG(("  lcspw.lcsGammaGreen = %d\n",pbmih4->bV4GammaGreen));

            //
            // There is no profile specified.
            //
            plcspw->lcsFilename[0] = UNICODE_NULL;

            bBitmapColorSpace = TRUE;
        }
        else // any other CSType
        {
            DWORD dwSize = MAX_PATH;

            ICMMSG(("IcmGetBitmapColorSpace: BITMAPv4 lcsType = %x\n",pbmih4->bV4CSType));

            //
            // Load external ICM dlls.
            //
            LOAD_ICMDLL((int)FALSE);

            //
            // Get corresponding colorspace profile.
            //
            bBitmapColorSpace =
                (*fpGetStandardColorSpaceProfileW)(NULL,
                                                   pbmih4->bV4CSType,
                                                   plcspw->lcsFilename,
                                                   &dwSize);
        }
    }
    else if (pbmi->bmiHeader.biSize == sizeof(BITMAPV5HEADER))
    {
        PBITMAPV5HEADER pbmih5 = (PBITMAPV5HEADER)&pbmi->bmiHeader;

        ICMMSG(("IcmGetBitmapColorSpace: BITMAPV5HEADER\n"));
        ICMMSG(("  lcspw.lcsCSType  = %x\n",pbmih5->bV5CSType));
        ICMMSG(("  lcspw.lcsIntent  = %d\n",pbmih5->bV5Intent));

        //
        // fill in common logcolorspace info
        //
        plcspw->lcsSignature = LCS_SIGNATURE;
        plcspw->lcsVersion   = 0x400;
        plcspw->lcsSize      = sizeof(LOGCOLORSPACEW);
        plcspw->lcsCSType    = pbmih5->bV5CSType;
        plcspw->lcsIntent    = pbmih5->bV5Intent;
        plcspw->lcsEndpoints = pbmih5->bV5Endpoints;
        plcspw->lcsGammaRed   = pbmih5->bV5GammaRed;
        plcspw->lcsGammaGreen = pbmih5->bV5GammaGreen;
        plcspw->lcsGammaBlue  = pbmih5->bV5GammaBlue;

        //
        // validate Intent
        //
        if ((plcspw->lcsIntent != LCS_GM_BUSINESS) &&
            (plcspw->lcsIntent != LCS_GM_GRAPHICS) &&
            (plcspw->lcsIntent != LCS_GM_IMAGES)   &&
            (plcspw->lcsIntent != LCS_GM_ABS_COLORIMETRIC))
        {
            //
            // Intent is invalid, just use LCS_GM_IMAGES
            //
            plcspw->lcsIntent = LCS_GM_IMAGES;
        }

        //
        // If a profile is linked or embedded then use it.
        // otherwise:
        // If CIEXYZ endpoints are given, create a new color transform
        // to use.
        //
        if (pbmih5->bV5CSType == PROFILE_EMBEDDED)
        {
            PVOID pProfileEmbedded = NULL;

            ICMMSG(("IcmGetBitmapColorSpace: Embedded profile\n"));

            //
            // Update CSType to Calibrated_RGB from Profile_Embedded
            //
            plcspw->lcsCSType = LCS_CALIBRATED_RGB;

            //
            // Get pointer to embeded profile.
            //
            pProfileEmbedded = (PVOID)((PBYTE)pbmi + pbmih5->bV5ProfileData);

            if (pProfileEmbedded)
            {
                //
                // Fill up PROFILE structure for "on memory" profile.
                //
                pColorProfile->dwType = PROFILE_MEMBUFFER;
                pColorProfile->pProfileData = pProfileEmbedded;
                pColorProfile->cbDataSize = pbmih5->bV5ProfileSize;

                //
                // Mark as on memory profile.
                //
                *pdwFlags |= ON_MEMORY_PROFILE;
            }
            else
            {
                //
                // This bitmap marked as "Embedded", but no profile there, just go with LOGCOLORSPACE.
                //
                ICMWRN(("IcmGetBitmapColorSpace(): Embedded profile, but no profile embedded\n"));
            }

            bBitmapColorSpace = TRUE;
        }
        else if (pbmih5->bV5CSType == PROFILE_LINKED)
        {
            WCHAR LinkedProfile[MAX_PATH];

            ICMMSG(("IcmGetBitmapColorSpace(): linked profile\n"));

            //
            // Update CSType to Calibrated_RGB from Profile_Linked
            //
            plcspw->lcsCSType = LCS_CALIBRATED_RGB;

            //
            // Convert profile name to Unicode.
            //
            vToUnicodeN(
                        LinkedProfile, MAX_PATH,
                        (CONST CHAR *)((PBYTE)pbmih5 + pbmih5->bV5ProfileData),
                        strlen((CONST CHAR *)((PBYTE)pbmih5 + pbmih5->bV5ProfileData))+1
                       );

            //
            // Normalize profile path.
            //
            BuildIcmProfilePath(LinkedProfile,plcspw->lcsFilename,MAX_PATH);

            ICMMSG(("lcspw.lcsFilename = %ws\n",plcspw->lcsFilename));

            bBitmapColorSpace = TRUE;
        }
        else if (pbmih5->bV5CSType == LCS_CALIBRATED_RGB)
        {
            ICMMSG(("IcmGetBitmapColorSpace(): calibrated RGB\n"));
            ICMMSG(("  lcspw.lcsGammaRed   = %d\n",pbmih5->bV5GammaRed));
            ICMMSG(("  lcspw.lcsGammaGreen = %d\n",pbmih5->bV5GammaGreen));
            ICMMSG(("  lcspw.lcsGammaBlue  = %d\n",pbmih5->bV5GammaBlue));

            //
            // There is profile specified.
            //
            plcspw->lcsFilename[0] = UNICODE_NULL;

            bBitmapColorSpace = TRUE;
        }
        else // any other CSType
        {
            DWORD dwSize = MAX_PATH;

            ICMMSG(("IcmGetBitmapColorSpace: BITMAPv5 lcsType = %x\n",pbmih5->bV5CSType));

            //
            // Load external ICM dlls.
            //
            LOAD_ICMDLL((int)FALSE);

            //
            // Get corresponding colorspace profile.
            //
            bBitmapColorSpace =
                (*fpGetStandardColorSpaceProfileW)(NULL,
                                                   pbmih5->bV5CSType,
                                                   plcspw->lcsFilename,
                                                   &dwSize);
        }
    }
    else
    {
        ICMMSG(("IcmGetBitmapColorSpace(): no color space specified\n"));
    }

    return (bBitmapColorSpace);
}

/******************************Public*Routine******************************\
* IcmGetTranslateInfo()
*
* History:
*
* Wrote it:
*     13.March.1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
IcmGetTranslateInfo(
    PDC_ATTR            pdcattr,
    LPBITMAPINFO        pbmi,
    PVOID               pvBits,
    ULONG               cjBits,
    DWORD               dwNumScan,
    PDIB_TRANSLATE_INFO pdti,
    DWORD               dwFlags
)
{
    BMFORMAT    ColorType;
    PVOID       pOutput;
    ULONG       nColors;
    ULONG       cjTranslateBits;

    PBITMAPINFO pbmiNew    = NULL;
    BOOL        bCMYKColor = IS_CMYK_COLOR(pdcattr->lIcmMode);

    ICMAPI(("gdi32: IcmGetTranslateInfo\n"));
    ICMAPI(("-----: CMYK Color = %s\n",(bCMYKColor ? "Yes" : "No")));
    ICMAPI(("-----: Backward   = %s\n",((dwFlags & ICM_BACKWARD) ? "Yes" : "No")));

    UNREFERENCED_PARAMETER(dwFlags);

    if (dwNumScan == (DWORD)-1)
    {
        dwNumScan = ABS(pbmi->bmiHeader.biHeight);
    }

    //
    // determine whether this is a palettized DIB
    //
    if (pbmi->bmiHeader.biCompression == BI_RGB)
    {
        if (pbmi->bmiHeader.biBitCount > 8)
        {
            //
            // we will translate bitmap, pvBits should be presented.
            //
            if (pvBits == NULL)
            {
                return (FALSE);
            }

            //
            // must translate DIB, standard 16,24,32 format
            //
            if (pbmi->bmiHeader.biBitCount == 16)
            {
                ICMMSG(("IcmGetTranslateInfo():BI_RGB 16 bpp\n"));

                ColorType = BM_x555RGB;
            }
            else if (pbmi->bmiHeader.biBitCount == 24)
            {
                ICMMSG(("IcmGetTranslateInfo():BI_RGB 24 bpp\n"));

                ColorType = BM_RGBTRIPLETS;
            }
            else if (pbmi->bmiHeader.biBitCount == 32)
            {
                ICMMSG(("IcmGetTranslateInfo():BI_RGB 32 bpp\n"));

                ColorType = BM_xRGBQUADS;
            }
            else
            {
                ICMMSG(("IcmGetTranslateInfo():BI_RGB Invalid bpp\n"));

                return (FALSE);
            }

            //
            // Fill up source bitmap information.
            //
            pdti->SourceWidth     = pbmi->bmiHeader.biWidth;
            pdti->SourceHeight    = dwNumScan;
            pdti->SourceBitCount  = pbmi->bmiHeader.biBitCount;
            pdti->SourceColorType = ColorType;
            pdti->pvSourceBits    = pvBits;
            pdti->cjSourceBits    = cjBits;

            //
            // CMYK Color ?
            //
            if (bCMYKColor)
            {
                pdti->TranslateType = (TRANSLATE_BITMAP|TRANSLATE_HEADER);

                //
                // CMYK bitmap color bitmap is 32 BPP (4 bytes per pixel).
                //
                cjTranslateBits = (pdti->SourceWidth * 4) * pdti->SourceHeight;

                //
                // We need new bitmap info header for CMYK.
                //
                pbmiNew = LOCALALLOC(pbmi->bmiHeader.biSize);

                if (!pbmiNew)
                {
                    WARNING("IcmGetTranslateInfo():LOCALALLOC() failed\n");
                    return (FALSE);
                }

                //
                // Make a copy of source, first.
                //
                RtlCopyMemory(pbmiNew,pbmi,pbmi->bmiHeader.biSize);

                //
                // Update header for CMYK color.
                //
                pbmiNew->bmiHeader.biBitCount = 32;
                pbmiNew->bmiHeader.biCompression = BI_CMYK;
                pbmiNew->bmiHeader.biSizeImage = cjTranslateBits;
                pbmiNew->bmiHeader.biClrUsed = 0;
                pbmiNew->bmiHeader.biClrImportant = 0;

                //
                // We have new BITMAPINFO header
                //
                pdti->TranslateBitmapInfo     = pbmiNew;
                pdti->TranslateBitmapInfoSize = pbmi->bmiHeader.biSize;

                //
                // Translate bitmap color type is CMYK.
                //
                pdti->TranslateColorType = BM_KYMCQUADS;
            }
            else
            {
                pdti->TranslateType = TRANSLATE_BITMAP;

                //
                // Translate bitmap size is same as source.
                //
                cjTranslateBits = cjBits;

                //
                // Translate bitmap color type is same source.
                //
                pdti->TranslateColorType = ColorType;

                pdti->TranslateBitmapInfo     = NULL;
                pdti->TranslateBitmapInfoSize = 0;
            }

            //
            // Allocate translate buffer
            //
            pOutput = LOCALALLOC(cjTranslateBits);

            if (!pOutput)
            {
                if (pbmiNew)
                {
                    LOCALFREE(pbmiNew);
                }
                WARNING("IcmGetTranslateInfo():LOCALALLOC() failed\n");
                return (FALSE);
            }

            //
            // Setup translation buffer.
            //
            pdti->pvTranslateBits = pOutput;
            pdti->cjTranslateBits = cjTranslateBits;
        }
        else if (
                 ((pbmi->bmiHeader.biBitCount == 8) ||
                  (pbmi->bmiHeader.biBitCount == 4) ||
                  (pbmi->bmiHeader.biBitCount == 1))
                )
        {
            ULONG nMaxColors = (1 << pbmi->bmiHeader.biBitCount);

            ICMMSG(("IcmGetTranslateInfo():BI_RGB 8/4/1 bpp\n"));

            //
            // validate number of colors
            //
            nColors = pbmi->bmiHeader.biClrUsed;

            if ((nColors == 0) || (nColors > nMaxColors))
            {
                nColors = nMaxColors;
            }

            //
            // Allocate new bitmap info header and color table.
            //
            pbmiNew = LOCALALLOC(pbmi->bmiHeader.biSize + (nColors * sizeof(RGBQUAD)));

            if (!pbmiNew)
            {
                WARNING("IcmGetTranslateInfo():LOCALALLOC() failed\n");
                return (FALSE);
            }

            //
            // Copy source BITMAPINFO to new
            //
            RtlCopyMemory(pbmiNew,pbmi,pbmi->bmiHeader.biSize);

            pdti->TranslateType           = TRANSLATE_HEADER;
            pdti->SourceColorType         = BM_xRGBQUADS;
            pdti->SourceWidth             = nColors;
            pdti->SourceHeight            = 1;
            pdti->SourceBitCount          = sizeof(RGBQUAD);
            pdti->TranslateBitmapInfo     = pbmiNew;
            pdti->TranslateBitmapInfoSize = 0; // size will not change from original
            pdti->pvSourceBits            = (PBYTE)pbmi + pbmi->bmiHeader.biSize;
            pdti->cjSourceBits            = nColors;
            pdti->pvTranslateBits         = (PBYTE)pbmiNew + pbmiNew->bmiHeader.biSize;
            pdti->cjTranslateBits         = nColors * sizeof(RGBQUAD);

            if (bCMYKColor)
            {
                pdti->TranslateColorType = BM_KYMCQUADS;

                //
                // Update header for CMYK color.
                //
                pbmiNew->bmiHeader.biCompression = BI_CMYK;
            }
            else
            {
                pdti->TranslateColorType = BM_xRGBQUADS;
            }
        }
        else
        {
            ICMWRN(("IcmGetTranslateInfo: Illegal biBitCount\n"));
            return (FALSE);
        }
    }
    else if (
             (pbmi->bmiHeader.biCompression == BI_BITFIELDS) &&
              (
                (pbmi->bmiHeader.biBitCount == 16) ||
                (pbmi->bmiHeader.biBitCount == 32)
              )
            )
    {
        PULONG pulColors = (PULONG)pbmi->bmiColors;

        ICMMSG(("IcmGetTranslateInfo():BI_BITFIELDS 16/32 bpp\n"));

        //
        // we will translate bitmap, pvBits should be presented.
        //
        if (pvBits == NULL)
        {
            return (FALSE);
        }

        if (pbmi->bmiHeader.biBitCount == 32)
        {
            if ((pulColors[0] == 0x0000ff) &&  /* Red */
                (pulColors[1] == 0x00ff00) &&  /* Green */
                (pulColors[2] == 0xff0000))    /* Blue */
            {
                ColorType = BM_xBGRQUADS;
            }
            else if ((pulColors[0] == 0xff0000) &&  /* Red */
                     (pulColors[1] == 0x00ff00) &&  /* Green */
                     (pulColors[2] == 0x0000ff))    /* Blue */
            {
                ColorType = BM_xRGBQUADS;
            }
            else
            {
                ICMWRN(("IcmGetTranslateInfo: Illegal Bitfields fields for 32 bpp\n"));
                return (FALSE);
            }
        }
        else
        {
            if ((pulColors[0] == 0x007c00) &&
                (pulColors[1] == 0x0003e0) &&
                (pulColors[2] == 0x00001f))
            {
                ColorType = BM_x555RGB;
            }
            else if ((pulColors[0] == 0x00f800) &&
                     (pulColors[1] == 0x0007e0) &&
                     (pulColors[2] == 0x00001f))
            {
                ColorType = BM_565RGB;
            }
            else
            {
                ICMWRN(("IcmGetTranslateInfo: Illegal Bitfields fields for 16 bpp\n"));
                return (FALSE);
            }
        }

        //
        // Fill up source bitmap information.
        //
        pdti->SourceWidth     = pbmi->bmiHeader.biWidth;
        pdti->SourceHeight    = dwNumScan;
        pdti->SourceBitCount  = pbmi->bmiHeader.biBitCount;
        pdti->SourceColorType = ColorType;
        pdti->pvSourceBits    = pvBits;
        pdti->cjSourceBits    = cjBits;

        //
        // CMYK Color ?
        //
        if (bCMYKColor)
        {
            pdti->TranslateType = (TRANSLATE_BITMAP|TRANSLATE_HEADER);

            //
            // CMYK bitmap color bitmap is 32 BPP (4 bytes per pixel).
            //
            cjTranslateBits = (pdti->SourceWidth * 4) * pdti->SourceHeight;

            //
            // We need new bitmap info header for CMYK.
            //
            pbmiNew = LOCALALLOC(pbmi->bmiHeader.biSize);

            if (!pbmiNew)
            {
                WARNING("IcmGetTranslateInfo():LOCALALLOC() failed\n");
                return (FALSE);
            }

            //
            // Make a copy of source, first.
            //
            RtlCopyMemory(pbmiNew,pbmi,pbmi->bmiHeader.biSize);

            //
            // Update header for CMYK color.
            //
            pbmiNew->bmiHeader.biBitCount = 32;
            pbmiNew->bmiHeader.biCompression = BI_CMYK;
            pbmiNew->bmiHeader.biSizeImage = cjTranslateBits;
            pbmiNew->bmiHeader.biClrUsed = 0;
            pbmiNew->bmiHeader.biClrImportant = 0;

            //
            // We have new BITMAPINFO header
            //
            pdti->TranslateBitmapInfo     = pbmiNew;
            pdti->TranslateBitmapInfoSize = pbmi->bmiHeader.biSize;

            //
            // Translate bitmap color type is CMYK.
            //
            pdti->TranslateColorType = BM_KYMCQUADS;
        }
        else
        {
            pdti->TranslateType = TRANSLATE_BITMAP;

            //
            // Translate bitmap size is same as source.
            //
            cjTranslateBits = cjBits;

            //
            // Translate bitmap color type is same source.
            //
            pdti->TranslateColorType = ColorType;

            pdti->TranslateBitmapInfo     = NULL;
            pdti->TranslateBitmapInfoSize = 0;
        }

        //
        // Allocate translate buffer
        //
        pOutput = LOCALALLOC(cjTranslateBits);

        if (!pOutput)
        {
            if (pbmiNew)
            {
                LOCALFREE(pbmiNew);
            }
            WARNING("IcmGetTranslateInfo():LOCALALLOC() failed\n");
            return (FALSE);
        }

        //
        // Setup translation buffer.
        //
        pdti->pvTranslateBits = pOutput;
        pdti->cjTranslateBits = cjTranslateBits;
    }
    else if (
             (pbmi->bmiHeader.biCompression == BI_RLE8) ||
             (pbmi->bmiHeader.biCompression == BI_RLE4)
            )
    {
        //
        // translate 256 for RLE8, 16 for RLE4 entry color palette
        //
        ULONG nMaxColors;

        if (pbmi->bmiHeader.biCompression == BI_RLE8)
        {
            ICMMSG(("IcmGetTranslateInfo():BI_RLE 8\n"));

            nMaxColors = 256;
        }
        else
        {
            ICMMSG(("IcmGetTranslateInfo():BI_RLE 4\n"));

            nMaxColors = 16;
        }

        //
        // validate number of colors
        //
        nColors = pbmi->bmiHeader.biClrUsed;

        if ((nColors == 0) || (nColors > nMaxColors))
        {
            nColors = nMaxColors;
        }

        //
        // Allocate new bitmap info header and color table.
        //
        pbmiNew = LOCALALLOC(pbmi->bmiHeader.biSize + (nColors * sizeof(RGBQUAD)));

        if (!pbmiNew)
        {
            WARNING("IcmGetTranslateInfo():LOCALALLOC() failed\n");
            return (FALSE);
        }

        //
        // Copy source BITMAPINFO to new
        //
        RtlCopyMemory(pbmiNew,pbmi,pbmi->bmiHeader.biSize);

        pdti->TranslateType           = TRANSLATE_HEADER;
        pdti->SourceColorType         = BM_xRGBQUADS;
        pdti->SourceWidth             = nColors;
        pdti->SourceHeight            = 1;
        pdti->SourceBitCount          = sizeof(RGBQUAD);
        pdti->TranslateBitmapInfo     = pbmiNew;
        pdti->TranslateBitmapInfoSize = 0; // size will not change from original
        pdti->pvSourceBits            = (PBYTE)pbmi + pbmi->bmiHeader.biSize;
        pdti->cjSourceBits            = nColors;
        pdti->pvTranslateBits         = (PBYTE)pbmiNew + pbmiNew->bmiHeader.biSize;
        pdti->cjTranslateBits         = nColors * sizeof(RGBQUAD);

        if (bCMYKColor)
        {
            pdti->TranslateColorType = BM_KYMCQUADS;

            //
            // Update header for CMYK color.
            //
            if (pbmi->bmiHeader.biCompression == BI_RLE8)
            {
                ICMMSG(("IcmGetTranslateInfo():BI_CMYKRLE 8\n"));

                pbmiNew->bmiHeader.biCompression = BI_CMYKRLE8;
            }
            else
            {
                ICMMSG(("IcmGetTranslateInfo():BI_CMYKRLE 4\n"));

                pbmiNew->bmiHeader.biCompression = BI_CMYKRLE4;
            }
        }
        else
        {
            pdti->TranslateColorType = BM_xRGBQUADS;
        }
    }
    else
    {
        WARNING("IcmGetTranslateInfo():Illegal bitmap format\n");
        return (FALSE);
    }

    return (TRUE);
}

/******************************Public*Routine******************************\
* IcmTranslateDIB
*
* History:
*
* Rewrote it for CMYK color support:
*   13-Mar-1997 -by- Hideyuki Nagase [hideyukn]
* Wrote it:
*    3-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
IcmTranslateDIB(
    HDC          hdc,
    PDC_ATTR     pdcattr,
    ULONG        cjBits,
    PVOID        pBitsIn,
    PVOID       *ppBitsOut,
    PBITMAPINFO  pbmi,
    PBITMAPINFO *ppbmiNew,
    DWORD       *pcjbmiNew,
    DWORD        dwNumScan,
    UINT         iUsage,
    DWORD        dwFlags,
    PCACHED_COLORSPACE *ppColorSpace, // used only for device ICM case.
    PCACHED_COLORTRANSFORM *ppCXform  // used only for device ICM case.
    )
{
    //
    // translate DIB or color table
    //
    BOOL   bStatus = TRUE;
    DWORD  dwColorSpaceFlags = 0;
    PCACHED_COLORSPACE pBitmapColorSpace = NULL;

    LOGCOLORSPACEW     LogColorSpace;
    PROFILE            ColorProfile;

    DIB_TRANSLATE_INFO TranslateInfo;

    PCACHED_COLORTRANSFORM pCXform;

    PGDI_ICMINFO pIcmInfo;

    UNREFERENCED_PARAMETER(iUsage);

    ICMAPI(("gdi32: IcmTranslateDIB\n"));

    //
    // Parameter check
    //
    if (pbmi == NULL)
    {
        WARNING("gdi32: IcmTranslateDIB(): pbmi is NULL\n");
        return FALSE;
    }

    //
    // Load external ICM dlls.
    //
    LOAD_ICMDLL(FALSE);

    //
    // Initialize ICMINFO
    //
    if ((pIcmInfo = GET_ICMINFO(pdcattr)) == NULL)
    {
        WARNING("gdi32: IcmTranslateDIB: Can't init icm info\n");
        return FALSE;
    }

    //
    // Initialized returned info.
    //
    if (ppColorSpace)
        *ppColorSpace = NULL;
    if (ppCXform)
        *ppCXform = NULL;

    //
    // Get LOGCOLORSPACE from bitmap if specified.
    //
    if (IcmGetBitmapColorSpace(pbmi,&LogColorSpace,&ColorProfile,&dwColorSpaceFlags))
    {
        //
        // Find ColorSpace from cache.
        //
        pBitmapColorSpace = IcmGetColorSpaceByColorSpace(
                                (HGDIOBJ)hdc,
                                &LogColorSpace,
                                &ColorProfile,
                                dwColorSpaceFlags);

        if (pBitmapColorSpace == NULL)
        {
            //
            // Create new cache.
            //
            pBitmapColorSpace = IcmCreateColorSpaceByColorSpace(
                                    (HGDIOBJ)hdc,
                                    &LogColorSpace,
                                    &ColorProfile,
                                    dwColorSpaceFlags);
        }
    }

    //
    // Create Color Transform, if nessesary.
    //
    if (IS_ICM_DEVICE(pdcattr->lIcmMode))
    {
        //
        // just create a new hcmXform for use with BITMAPV4 AND BITMAPV5s.
        //
        if (pBitmapColorSpace)
        {
            ICMMSG(("IcmTranslateDIB():Bitmap color space used for DEVICE ICM\n"));

            if ((ppCXform != NULL) && (ppColorSpace != NULL))
            {
                //
                // for DEVICE managed ICM, call device driver to create a temp xform
                //
                pCXform = IcmCreateColorTransform(hdc,pdcattr,pBitmapColorSpace,dwFlags);

                if (pCXform == NULL)
                {
                    WARNING("IcmTranslateDIB():Fail to create temporay Xfrom with V4V5 Bitmap\n");

                    //
                    // Failed to create color transfrom, release bitmap color space,
                    // and null-color transform.
                    //
                    IcmReleaseColorSpace(NULL,pBitmapColorSpace,FALSE);
                    bStatus = FALSE;
                }
                else
                {
                    if (pCXform == IDENT_COLORTRANSFORM)
                    {
                        //
                        // Source and destination color space are same, so no color transform is
                        // required, and of course we don't need to keep bitmap color space.
                        //
                        IcmReleaseColorSpace(NULL,pBitmapColorSpace,FALSE);
                    }
                    else
                    {
                        //
                        // Return to the color transform to callee...
                        // (these should be deleted by callee)
                        //
                        *ppCXform = pCXform;
                        *ppColorSpace = pBitmapColorSpace;
                    }

                    bStatus = TRUE;
                }
            }
            else
            {
                WARNING("IcmTranslateDIB():No device ICM will happen for this V4V5 Bitmap\n");

                IcmReleaseColorSpace(NULL,pBitmapColorSpace,FALSE);
                bStatus = TRUE;
            }

            return (bStatus);
        }
        else
        {
            ICMMSG(("IcmTranslateDIB():DC color space used for DEVICE ICM\n"));

            //
            // We don't need to create new transform, just use the transform in DC.
            //
            return (TRUE);
        }
    }
    else if (IS_ICM_HOST(pdcattr->lIcmMode))
    {
        HANDLE hcmXform = NULL;

        if (pBitmapColorSpace)
        {
            ICMMSG(("IcmTranslateDIB():Bitmap color space used for HOST ICM\n"));

            pCXform = IcmCreateColorTransform(hdc,pdcattr,pBitmapColorSpace,dwFlags);

            if ((pCXform == IDENT_COLORTRANSFORM) || (pCXform == NULL))
            {
                //
                // unable or not nessesary to translate DIB
                //
                ICMWRN(("Bitmap V4 or V5: CreateColorTransform failed or ident.\n"));
                goto TranslateDIB_Cleanup;
            }
            else
            {
                hcmXform = pCXform->ColorTransform;
            }
        }
        else
        {
            ICMMSG(("IcmTranslateDIB():DC color space used for HOST ICM\n"));

            if (dwFlags & ICM_BACKWARD)
            {
                ICMMSG(("IcmTranslateDIB():Backward Color transform\n"));

                //
                // If there is cached handle, use that.
                //
                if (pIcmInfo->pBackCXform)
                {
                    ICMMSG(("IcmTranslateDIB():Use cached transform for Backward Color transform\n"));

                    hcmXform = pIcmInfo->pBackCXform->ColorTransform;
                }
                else
                {
                    PCACHED_COLORTRANSFORM pCXform;

                    ICMMSG(("IcmTranslateDIB():Create cached transform for Backward Color transform\n"));

                    //
                    // Create backward color transform.
                    //
                    pCXform = IcmCreateColorTransform(hdc,
                                                      pdcattr,
                                                      NULL,
                                                      ICM_BACKWARD);

                    if ((pCXform == NULL) || (pCXform == IDENT_COLORTRANSFORM))
                    {
                        ICMWRN(("IcmTranslateDIB():ColorTransform is NULL or ident.\n"));
                        goto TranslateDIB_Cleanup;
                    }

                    //
                    // Cache created color transform.
                    //
                    pIcmInfo->pBackCXform = pCXform;

                    //
                    // We will delete this cached transform, when we don't need this anymore.
                    //
                    hcmXform = pCXform->ColorTransform;
                }
            }
            else
            {
                //
                // Use DC's colortransform
                //
                hcmXform = pdcattr->hcmXform;
            }
        }

        if (hcmXform == NULL)
        {
            //
            // if we don't have any colortransform, we will not translate anything.
            // just fail and let use original image.
            //
            ICMWRN(("IcmTranslateDIB():No colortransform, might be ident.\n"));
            goto TranslateDIB_Cleanup;
        }

        //
        // Get bitmap translate information.
        //
        bStatus = IcmGetTranslateInfo(pdcattr,pbmi,pBitsIn,cjBits,dwNumScan,&TranslateInfo,dwFlags);

        if (bStatus)
        {
            LONG nLineBytes = ((TranslateInfo.SourceWidth *
                                TranslateInfo.SourceBitCount) + 7) / 8;

            bStatus = (*fpTranslateBitmapBits)(
                            hcmXform,
                            TranslateInfo.pvSourceBits,
                            TranslateInfo.SourceColorType,
                            TranslateInfo.SourceWidth,
                            TranslateInfo.SourceHeight,
                            ALIGN_DWORD(nLineBytes),
                            TranslateInfo.pvTranslateBits,
                            TranslateInfo.TranslateColorType,
                               //
                            0, // We need pass 0 here, to let Kodak CMM works
                               //
                            NULL,0);

            if (bStatus)
            {
                //
                // Pass new bitmap and/or header to caller.
                //
                if (TranslateInfo.TranslateType & TRANSLATE_BITMAP)
                {
                    if (ppBitsOut)
                    {
                        *ppBitsOut = TranslateInfo.pvTranslateBits;
                    }
                    else
                    {
                        //
                        // Overwrite original (when input color and output color type is same)
                        //
                        if (TranslateInfo.SourceColorType == TranslateInfo.TranslateColorType)
                        {
                            RtlCopyMemory(TranslateInfo.pvSourceBits,
                                          TranslateInfo.pvTranslateBits,
                                          TranslateInfo.cjTranslateBits);
                        }
                        else
                        {
                            WARNING("IcmTranslateDIB():Input color != Output color\n");
                        }

                        LOCALFREE(TranslateInfo.pvTranslateBits);
                    }
                }

                if (TranslateInfo.TranslateType & TRANSLATE_HEADER)
                {
                    if (ppbmiNew)
                    {
                        *ppbmiNew  = TranslateInfo.TranslateBitmapInfo;
                    }
                    else
                    {
                        //
                        // Overwrite original (when input color and output color type is same)
                        //
                        if (TranslateInfo.SourceColorType == TranslateInfo.TranslateColorType)
                        {
                            RtlCopyMemory(TranslateInfo.pvSourceBits,
                                          TranslateInfo.pvTranslateBits,
                                          TranslateInfo.cjTranslateBits);
                        }
                        else
                        {
                            WARNING("IcmTranslateDIB():Input color != Output color\n");
                        }

                        LOCALFREE(TranslateInfo.TranslateBitmapInfo);
                    }

                    if (pcjbmiNew)
                    {
                        *pcjbmiNew = TranslateInfo.TranslateBitmapInfoSize;
                    }
                }
            }
            else
            {
                WARNING("IcmTranslateDIB():Fail TranslateBitmapBits\n");

                //
                // Free memory which allocated inside IcmGetTranslateInfo().
                //
                if (TranslateInfo.TranslateType & TRANSLATE_BITMAP)
                {
                    LOCALFREE(TranslateInfo.pvTranslateBits);
                }

                if (TranslateInfo.TranslateType & TRANSLATE_HEADER)
                {
                    LOCALFREE(TranslateInfo.TranslateBitmapInfo);
                }
            }
        }

TranslateDIB_Cleanup:

        //
        // Free temp transform and temp file
        //
        // Only delete hcmXform when it based on bitmap colorspace.
        //
        if (pBitmapColorSpace)
        {
            if (hcmXform)
            {
                IcmDeleteColorTransform(pCXform,FALSE);
            }

            IcmReleaseColorSpace(NULL,pBitmapColorSpace,FALSE);
        }
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* IcmGetFirstNonUsedColorTransform()
*
* History:
*
* Write it:
*   12-Mar-1998 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

PCACHED_COLORTRANSFORM
IcmGetFirstNonUsedColorTransform(
    VOID
)
{
    PCACHED_COLORTRANSFORM pCXform = NULL;
    PLIST_ENTRY p;

    ICMAPI(("gdi32: IcmGetFirstNonUsedColorTransform\n"));

    ENTERCRITICALSECTION(&semColorTransformCache);

    p = ListCachedColorTransform.Flink;

    while(p != &ListCachedColorTransform)
    {
        pCXform = CONTAINING_RECORD(p,CACHED_COLORTRANSFORM,ListEntry);

        if (pCXform->cRef == 0)
        {
            ICMMSG(("IcmGetFirstNonUsedColorTransform():Find non-used color transform in cache !\n"));

            //
            // No one use this color transform at this moment.
            //
            break;
        }

        p = p->Flink;
        pCXform = NULL;
    }

    LEAVECRITICALSECTION(&semColorTransformCache);

    return (pCXform);
}

/******************************Public*Routine******************************\
* IcmGetColorTransform()
*
* History:
*
* Write it:
*   21-Apr-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

PCACHED_COLORTRANSFORM
IcmGetColorTransform(
    HDC                hdcRequest,
    PCACHED_COLORSPACE pSource,
    PCACHED_COLORSPACE pDestination,
    PCACHED_COLORSPACE pTarget,
    BOOL               bNeedDeviceXform
)
{
    PCACHED_COLORTRANSFORM pCXform = NULL;
    PLIST_ENTRY p;

    ICMAPI(("gdi32: IcmGetColorTransform\n"));

    ENTERCRITICALSECTION(&semColorTransformCache);

    p = ListCachedColorTransform.Flink;

    while(p != &ListCachedColorTransform)
    {
        pCXform = CONTAINING_RECORD(p,CACHED_COLORTRANSFORM,ListEntry);

        if (IcmSameColorSpace(pSource,pCXform->SourceColorSpace) &&
            IcmSameColorSpace(pDestination,pCXform->DestinationColorSpace) &&
            IcmSameColorSpace(pTarget,pCXform->TargetColorSpace))
        {
            //
            // If callee needs device color tansform,
            // of course, we should return device color transform.
            //
            if ((bNeedDeviceXform ? 1 : 0) ==
                ((pCXform->flInfo & DEVICE_COLORTRANSFORM) ? 1 : 0))
            {
                //
                // if Cached color transform depends on specific DC, check it.
                //
                if ((pCXform->hdc == NULL) || (pCXform->hdc == hdcRequest))
                {
                    ICMMSG(("IcmGetColorTransform():Find in cache !\n"));

                    //
                    // Match !, use this color transform, increment ref. count
                    //
                    pCXform->cRef++;

                    break;
                }
            }
        }

        p = p->Flink;
        pCXform = NULL;
    }

    LEAVECRITICALSECTION(&semColorTransformCache);

    return (pCXform);
}

/******************************Public*Routine******************************\
* IcmCreateColorTransform
*
*   Decide whether to call the device driver or mscms.dll to delete a
*   color transform.
*
* Arguments:
*
*   hdc
*   pdcattr
*   pLogColorSpaceW
*
* Return Value:
*
*   handle of new transform
*
* History:
*
* Write it:
*   24-Jan-1996 -by- Hideyuki Nagase [hideyukn]
*
\**************************************************************************/

PCACHED_COLORTRANSFORM
IcmCreateColorTransform(
    HDC                hdc,
    PDC_ATTR           pdcattr,
    PCACHED_COLORSPACE pInputColorSpace,
    DWORD              dwFlags
    )
{
    PCACHED_COLORTRANSFORM pCXform = NULL;
    PCACHED_COLORSPACE pSourceColorSpace = NULL;

    BOOL   bDCSourceColorSpace = (pInputColorSpace == NULL ? TRUE : FALSE);

    BOOL   bAnyNewColorSpace = FALSE;

    PGDI_ICMINFO pIcmInfo;

    ICMAPI(("gdi32: IcmCreateColorTransform\n"));

    ASSERTGDI(pdcattr != NULL,"IcmCreateColorTransform: pdcattr == NULL\n");

    //
    // If this is Lazy color correction case, the destination surface
    // will have image in source color space, so the color transform
    // is identical.
    //
    if (IS_ICM_LAZY_CORRECTION(pdcattr->lIcmMode))
    {
        return (IDENT_COLORTRANSFORM);
    }

    //
    // Load external ICM dlls.
    //
    LOAD_ICMDLL(NULL);

    //
    // Initialize ICMINFO
    //
    if ((pIcmInfo = GET_ICMINFO(pdcattr)) == NULL)
    {
        WARNING("gdi32: IcmCreateColorTransform: Can't init icm info\n");
        return(NULL);
    }

    if (bDCSourceColorSpace && (pIcmInfo->pSourceColorSpace == NULL))
    {
        //
        // If we haven't gotton DC source color space, get it there.
        //
        LOGCOLORSPACEW LogColorSpaceW;

        ICMMSG(("IcmCreateColorTransform(): Call getobject to get source color space in DC\n"));

        //
        // Filled with zero.
        //
        RtlZeroMemory(&LogColorSpaceW,sizeof(LOGCOLORSPACEW));

        //
        // Find ColorSpace from cache.
        //
        pSourceColorSpace = IcmGetColorSpaceByHandle(
                                (HGDIOBJ)hdc,
                                (HANDLE)pdcattr->hColorSpace,
                                &LogColorSpaceW,0);

        //
        // If we can not find from cache, but succeeded to obtain
        // valid logcolorspace from handle, create new one.
        //
        if ((pSourceColorSpace == NULL) &&
            (LogColorSpaceW.lcsSignature == LCS_SIGNATURE))
        {
            //
            // Create new cache.
            //
            pSourceColorSpace = IcmCreateColorSpaceByColorSpace(
                                    (HGDIOBJ)hdc,
                                    &LogColorSpaceW,
                                    NULL, 0);

            //
            // we are using new color space
            //
            bAnyNewColorSpace = TRUE;
        }

        //
        // And this is DC's color space, keep it for cache.
        //
        pIcmInfo->pSourceColorSpace = pSourceColorSpace;
    }
    else if (bDCSourceColorSpace)
    {
        ICMMSG(("IcmCreateColorTransform(): Use cached source color space in DC\n"));

        //
        // Get this from client cache !
        //
        pSourceColorSpace = pIcmInfo->pSourceColorSpace;
    }
    else
    {
        ICMMSG(("IcmCreateColorTransform(): Use given source color space\n"));

        //
        // Just use given color space.
        //
        pSourceColorSpace = pInputColorSpace;
    }

    if (pSourceColorSpace)
    {
        HANDLE hColorTransform = NULL;

        PCACHED_COLORSPACE pDestColorSpace   = pIcmInfo->pDestColorSpace;
        PCACHED_COLORSPACE pTargetColorSpace = NULL;

        //
        // if we are in proofing mode, consider target profile.
        //
        if (IS_ICM_PROOFING(pdcattr->lIcmMode))
        {
            pTargetColorSpace = pIcmInfo->pTargetColorSpace;
        }

        #if DBG_ICM
        //
        // Dump current color space for the DC.
        //
        if ((pSourceColorSpace->LogColorSpace.lcsFilename[0]) != UNICODE_NULL)
        {
            ICMMSG(("IcmCreateColorTransform(): Source Profile = %ws\n",
                     pSourceColorSpace->LogColorSpace.lcsFilename));
        }

        if ((pDestColorSpace) &&
            ((pDestColorSpace->LogColorSpace.lcsFilename[0]) != UNICODE_NULL))
        {
            ICMMSG(("IcmCreateColorTransform(): Destination Profile = %ws\n",
                     pDestColorSpace->LogColorSpace.lcsFilename));
        }

        if ((pTargetColorSpace) &&
            ((pTargetColorSpace->LogColorSpace.lcsFilename[0]) != UNICODE_NULL))
        {
            ICMMSG(("IcmCreateColorTransform(): Target Profile = %ws\n",
                     pTargetColorSpace->LogColorSpace.lcsFilename));
        }

        ICMMSG(("IcmCreateColorTransform(): Intent = %d\n",
                 pSourceColorSpace->ColorIntent));
        #endif // DBG

        //
        // At this moment, we have any source colorspace.
        //
        if (IcmSameColorSpace(pSourceColorSpace,pDestColorSpace))
        {
            if (pTargetColorSpace)
            {
                if (IcmSameColorSpace(pSourceColorSpace,pTargetColorSpace))
                {
                    ICMMSG(("IcmCreateColorTransform(): Src == Dest == Trg colorspace\n"));

                    //
                    // Source ColorSpace == Destination ColorSpace == Target ColorSpace
                    // No color transform needed.
                    //
                    return (IDENT_COLORTRANSFORM);
                }
            }
            else
            {
                ICMMSG(("IcmCreateColorTransform(): Src == Dest colorspace\n"));

                //
                // Source ColorSpace == Destination ColorSpace,
                // and there is no target profile.
                // That means we don't need translate color
                //
                return (IDENT_COLORTRANSFORM);
            }
        }

        //
        // We need to have proper colortransform to adjust color between each colorspace.
        //
        if (dwFlags & ICM_BACKWARD)
        {
            //
            // This is backward transform. (swap source and destination)
            //
            PCACHED_COLORSPACE pSwapColorSpace;
            pSwapColorSpace = pSourceColorSpace;
            pSourceColorSpace = pDestColorSpace;
            pDestColorSpace = pSwapColorSpace;
        }

        //
        // At this moment, at least, we should have Source and Destination color space.
        // And target color space is optional.
        //
        if (pDestColorSpace)
        {
            if (!bAnyNewColorSpace)
            {
                //
                // Find colortransform from cache
                //
                // if this is device ICM, hdc also should matched.
                //
                pCXform = IcmGetColorTransform(
                              hdc,
                              pSourceColorSpace,
                              pDestColorSpace,
                              pTargetColorSpace,
                              (IS_ICM_DEVICE(pdcattr->lIcmMode)));

                if (pCXform)
                {
                    return (pCXform);
                }
            }

            //
            // Allocate CACHED_COLORTRANSFORM
            //
            pCXform = LOCALALLOC(sizeof(CACHED_COLORTRANSFORM));

            if (pCXform)
            {
                ENTERCRITICALSECTION(&semColorSpaceCache);

                //
                // Make sure all color space has been realized
                //
                if (IcmRealizeColorProfile(pSourceColorSpace,TRUE) &&
                    IcmRealizeColorProfile(pDestColorSpace,TRUE) &&
                    IcmRealizeColorProfile(pTargetColorSpace,TRUE))
                {
                    //
                    // call ICM dll or device driver to create a color transform
                    //
                    if (IS_ICM_HOST(pdcattr->lIcmMode))
                    {
                        DWORD    ahIntents[3];
                        HPROFILE ahProfiles[3];
                        DWORD    chProfiles = 0;

                        ICMMSG(("Creating Host ICM Transform...\n"));

                        //
                        // Put source profile in first entry.
                        //
                        ahIntents[chProfiles]  = INTENT_RELATIVE_COLORIMETRIC;
                        ahProfiles[chProfiles] = pSourceColorSpace->hProfile;
                        chProfiles++;

                        ahIntents[chProfiles]  = pSourceColorSpace->ColorIntent;

                        //
                        // If target profile (proofing) is used, insert it
                        // between source and destination.
                        //
                        if (pTargetColorSpace)
                        {
                            ahProfiles[chProfiles] = pTargetColorSpace->hProfile;
                            chProfiles++;

                            ahIntents[chProfiles]  = INTENT_ABSOLUTE_COLORIMETRIC;
                        }

                        //
                        // Finally, set destination profile.
                        //
                        ahProfiles[chProfiles] = pDestColorSpace->hProfile;
                        chProfiles++;

                        //
                        // Call MSCMS to create color transform.
                        //
                        hColorTransform = (*fpCreateMultiProfileTransform)(
                                              ahProfiles, chProfiles,
                                              ahIntents, chProfiles,
                                              NORMAL_MODE | ENABLE_GAMUT_CHECKING,
                                              INDEX_DONT_CARE);
                    }
                    else if (IS_ICM_DEVICE(pdcattr->lIcmMode))
                    {
                        CLIENT_SIDE_FILEVIEW fvwSrcProfile;
                        CLIENT_SIDE_FILEVIEW fvwDstProfile;
                        CLIENT_SIDE_FILEVIEW fvwTrgProfile;

                        ICMMSG(("Creating Device ICM Transform...\n"));

                        //
                        // Invalidate FILEVIEW.
                        //
                        RtlZeroMemory(&fvwSrcProfile,sizeof(CLIENT_SIDE_FILEVIEW));
                        RtlZeroMemory(&fvwDstProfile,sizeof(CLIENT_SIDE_FILEVIEW));
                        RtlZeroMemory(&fvwTrgProfile,sizeof(CLIENT_SIDE_FILEVIEW));

                        //
                        // Map color profile(s) into memory.
                        //
                        if (pSourceColorSpace->ColorProfile.dwType == PROFILE_FILENAME)
                        {
                            if (!bMapFileUNICODEClideSide(
                                     (PWSTR)(pSourceColorSpace->ColorProfile.pProfileData),
                                     &fvwSrcProfile,FALSE))
                            {
                                WARNING("IcmCreateColorTransform(): Fail to map source profile\n");
                                goto IcmCreateColorTransform_Cleanup;
                            }
                        }
                        else if (pSourceColorSpace->ColorProfile.dwType == PROFILE_MEMBUFFER)
                        {
                            ICMMSG(("Source Profile is memory buffer\n"));

                            fvwSrcProfile.pvView = pSourceColorSpace->ColorProfile.pProfileData;
                            fvwSrcProfile.cjView = pSourceColorSpace->ColorProfile.cbDataSize;
                        }
                        else
                        {
                            WARNING("IcmCreateColorTransform():src profile type is not supported\n");
                            goto IcmCreateColorTransform_Cleanup;
                        }

                        if (pDestColorSpace->ColorProfile.dwType == PROFILE_FILENAME)
                        {
                            if (!bMapFileUNICODEClideSide(
                                     (PWSTR)(pDestColorSpace->ColorProfile.pProfileData),
                                     &fvwDstProfile,FALSE))
                            {
                                WARNING("IcmCreateColorTransform(): Fail to map destination profile\n");
                                goto IcmCreateColorTransform_Cleanup;
                            }
                        }
                        else if (pDestColorSpace->ColorProfile.dwType == PROFILE_MEMBUFFER)
                        {
                            ICMMSG(("Destination Profile is memory buffer\n"));

                            fvwDstProfile.pvView = pDestColorSpace->ColorProfile.pProfileData;
                            fvwDstProfile.cjView = pDestColorSpace->ColorProfile.cbDataSize;
                        }
                        else
                        {
                            WARNING("IcmCreateColorTransform():dst profile type is not supported\n");
                            goto IcmCreateColorTransform_Cleanup;
                        }

                        //
                        // Target color space is optional
                        //
                        if (pTargetColorSpace)
                        {
                            if (pTargetColorSpace->ColorProfile.dwType == PROFILE_FILENAME)
                            {
                                if (!bMapFileUNICODEClideSide(
                                         (PWSTR)(pTargetColorSpace->ColorProfile.pProfileData),
                                         &fvwTrgProfile,FALSE))
                                {
                                    WARNING("IcmCreateColorTransform(): Fail to map target profile\n");
                                    goto IcmCreateColorTransform_Cleanup;
                                }
                            }
                            else if (pTargetColorSpace->ColorProfile.dwType == PROFILE_MEMBUFFER)
                            {
                                ICMMSG(("Target Profile is memory buffer\n"));

                                fvwTrgProfile.pvView = pTargetColorSpace->ColorProfile.pProfileData;
                                fvwTrgProfile.cjView = pTargetColorSpace->ColorProfile.cbDataSize;
                            }
                            else
                            {
                                WARNING("IcmCreateColorTransform():trg profile type is not supported\n");
                                goto IcmCreateColorTransform_Cleanup;
                            }
                        }

                        //
                        // Call kernel.
                        //
                        hColorTransform = NtGdiCreateColorTransform(hdc,
                                                 &(pSourceColorSpace->LogColorSpace),
                                                 fvwSrcProfile.pvView, // Source Profile memory mapped file.
                                                 fvwSrcProfile.cjView,
                                                 fvwDstProfile.pvView, // Destination Profile memory mapped file.
                                                 fvwDstProfile.cjView,
                                                 fvwTrgProfile.pvView, // Target Profile memory mapped file.
                                                 fvwTrgProfile.cjView);

IcmCreateColorTransform_Cleanup:

                        //
                        // if we mapped file, unmap here.
                        //
                        if (fvwSrcProfile.hSection)
                        {
                            vUnmapFileClideSide(&fvwSrcProfile);
                        }

                        if (fvwDstProfile.hSection)
                        {
                            vUnmapFileClideSide(&fvwDstProfile);
                        }

                        if (fvwTrgProfile.hSection)
                        {
                            vUnmapFileClideSide(&fvwTrgProfile);
                        }
                    }
                }

                //
                // Once after create tranform, we don't need realized color space,
                // so just unrealize it.
                //
                IcmUnrealizeColorProfile(pSourceColorSpace);
                IcmUnrealizeColorProfile(pDestColorSpace);
                IcmUnrealizeColorProfile(pTargetColorSpace);

                LEAVECRITICALSECTION(&semColorSpaceCache);

                if (hColorTransform)
                {
                    BOOL bCacheable = TRUE;

                    //
                    // Initialize CACHED_COLORTRANSFORM with zero
                    //
                    RtlZeroMemory(pCXform,sizeof(CACHED_COLORTRANSFORM));

                    //
                    // Fill up CACHED_COLORTRANSFORM
                    //
                    pCXform->ColorTransform   = hColorTransform;
                    pCXform->SourceColorSpace = pSourceColorSpace;
                    pCXform->DestinationColorSpace = pDestColorSpace;
                    pCXform->TargetColorSpace = pTargetColorSpace;

                    if (IS_ICM_DEVICE(pdcattr->lIcmMode))
                    {
                        //
                        // if this is device colortransform, mark it and
                        // put DC in CACHED_COLORTRANSFORM strcuture
                        //
                        pCXform->flInfo |= DEVICE_COLORTRANSFORM;

                        //
                        // And device color transform is not cacheable.
                        //
                        bCacheable = FALSE;
                    }

                    ENTERCRITICALSECTION(&semColorSpaceCache);

                    //
                    // Increment transform ref. count in each color space.
                    //
                    if (pSourceColorSpace)
                    {
                        pSourceColorSpace->cRef++;

                        if (bCacheable)
                        {
                            //
                            // Check this color space is cacheable.
                            //
                            bCacheable &= IcmIsCacheable(pSourceColorSpace);
                        }
                    }

                    if (pDestColorSpace)
                    {
                        pDestColorSpace->cRef++;

                        if (bCacheable)
                        {
                            //
                            // Check this color space is cacheable.
                            //
                            bCacheable &= IcmIsCacheable(pDestColorSpace);
                        }
                    }

                    if (pTargetColorSpace)
                    {
                        pTargetColorSpace->cRef++;

                        if (bCacheable)
                        {
                            //
                            // Check this color space is cacheable.
                            //
                            bCacheable &= IcmIsCacheable(pTargetColorSpace);
                        }
                    }

                    LEAVECRITICALSECTION(&semColorSpaceCache);

                    //
                    // Initialize ref. counter.
                    //
                    pCXform->cRef = 1;

                    //
                    // Set cache-able bit, if possible.
                    //
                    if (bCacheable)
                    {
                        ICMMSG(("IcmCreateColorTransform(): ColorTransform is cacheable\n"));

                        pCXform->flInfo |= CACHEABLE_COLORTRANSFORM;
                    }
                    else
                    {
                        ICMMSG(("IcmCreateColorTransform(): ColorTransform is *NOT* cacheable\n"));

                        //
                        // If this is not cacheable, make sure this get deleted when DC gone.
                        //
                        pCXform->hdc = hdc;
                    }

                    //
                    // Insert new CACHED_COLORTRANSFORM to list
                    //
                    ENTERCRITICALSECTION(&semColorTransformCache);

                    InsertTailList(&ListCachedColorTransform,&(pCXform->ListEntry));
                    cCachedColorTransform++;

                    LEAVECRITICALSECTION(&semColorTransformCache);
                }
                else
                {
                    ICMWRN(("IcmCreateColorTransform(): Fail to create color transform\n"));

                    //
                    // Fail to get transform handle
                    //
                    LOCALFREE(pCXform);
                    pCXform = NULL;
                }
            }
            else
            {
                WARNING("IcmCreateColorTransform(): LOCALALLOC() failed\n");
            }
        }
        else
        {
            WARNING("IcmCreateColorTransform(): Dest color space is required\n");
        }
    }
    else
    {
        WARNING("IcmCreateColorTransform(): Fail to get source colorspace\n");
    }

    return(pCXform);
}

/******************************Public*Routine******************************\
* IcmTranslateCOLORREF
*
* Arguments:
*
*   hdc
*   pdcattr
*   ColorIn
*   *ColorOut
*
* Return Value:
*
*   Status
*
* History:
*
* Write it:
*   13-Feb-1997 -by- Hideyuki Nagase [hideyukn]
*
\**************************************************************************/

BOOL
IcmTranslateCOLORREF(
    HDC      hdc,
    PDC_ATTR pdcattr,
    COLORREF ColorIn,
    COLORREF *ColorOut,
    DWORD    Flags
    )
{
    COLORREF OldColor = ColorIn;
    COLORREF NewColor;
    BOOL     bStatus = TRUE;

    ICMAPI(("gdi32: IcmTranslateCOLORREF\n"));

    ASSERTGDI(ColorOut != NULL,"IcmTranslateCOLORREF(): ColorOut == NULL\n");

    if (bNeedTranslateColor(pdcattr))
    {
        PGDI_ICMINFO pIcmInfo;

        LOAD_ICMDLL(FALSE);

        if ((pIcmInfo = GET_ICMINFO(pdcattr)) == NULL)
        {
            WARNING("gdi32: IcmTranslateCOLORREF: Can't init icm info\n");
            return((int)FALSE);
        }
        else
        {
            ULONG  SrcColorFormat;
            ULONG  DstColorFormat;
            HANDLE hcmXform = NULL;

            if (Flags & ICM_BACKWARD)
            {
                ICMMSG(("IcmTranslateCOLORREF():Backward Color transform\n"));

                //
                // AnyColorFormat ----> COLORREF (0x00bbggrr)
                //
                // Setup src & dest color type.
                //
                SrcColorFormat = pIcmInfo->pDestColorSpace->ColorFormat;
                DstColorFormat = BM_xBGRQUADS;

                //
                // If there is cached handle, use that.
                //
                if (pIcmInfo->pBackCXform)
                {
                    ICMMSG(("IcmTranslateCOLORREF():Use cached transform for Backward Color transform\n"));

                    hcmXform = pIcmInfo->pBackCXform->ColorTransform;
                }
                else
                {
                    PCACHED_COLORTRANSFORM pCXform;

                    ICMMSG(("IcmTranslateCOLORREF():Create cached transform for Backward Color transform\n"));

                    //
                    // Create backward color transform.
                    //
                    pCXform = IcmCreateColorTransform(hdc,
                                                      pdcattr,
                                                      NULL,
                                                      ICM_BACKWARD);

                    if ((pCXform == NULL) || (pCXform == IDENT_COLORTRANSFORM))
                    {
                        return (FALSE);
                    }

                    //
                    // Cache created color transform.
                    //
                    pIcmInfo->pBackCXform = pCXform;

                    //
                    // We will delete this cached transform, when we don't need this anymore.
                    //
                    hcmXform = pCXform->ColorTransform;
                }
            }
            else
            {
                //
                // COLORREF (0x00bbggrr) ----> AnyColorFormat
                //
                // Setup src & dest color type.
                //
                SrcColorFormat = BM_xBGRQUADS;
                DstColorFormat = pIcmInfo->pDestColorSpace->ColorFormat;

                //
                // Use foaward color transform.
                //
                hcmXform = GetColorTransformInDC(pdcattr);

                //
                // Source is COLORREF. then, Mask off gdi internal infomation.
                //
                // COLORREF = 0x00bbggrr;
                //
                OldColor &= 0x00ffffff;
            }

            if (hcmXform)
            {
                //
                // We handle COLORREF as 1x1 pixel bitmap data.
                //
                bStatus = (*fpTranslateBitmapBits)(hcmXform,
                                                   (PVOID)&OldColor,
                                                   SrcColorFormat,
                                                   1,1,
                                                   ALIGN_DWORD(sizeof(COLORREF)),
                                                   (PVOID)&NewColor,
                                                   DstColorFormat,
                                                      //
                                                   0, // We need pass 0 here, to let Kodak CMM works
                                                      //
                                                   NULL,0);
            }
            else
            {
                //
                // It seems hcmXform is invalid
                //
                ICMWRN(("IcmTranslateCOLORREF():hcmXform is invalid\n"));
                bStatus = FALSE;
            }

            if (bStatus)
            {
                if (Flags & ICM_BACKWARD)
                {
                    //
                    // OldColor: AnyColorFormat
                    // NewColor: COLORREF (0x00bbggrr)
                    //
                    // [NOTE:]
                    //  We could not restore flags.
                    //
                    *ColorOut = NewColor;
                }
                else
                {
                    //
                    // OldColor: COLORREF (0x00bbggrr)
                    // NewColor: AnyColorFormat
                    //
                    if (!(IS_32BITS_COLOR(pdcattr->lIcmMode)))
                    {
                        //
                        // The distination is not 32Bits Color, Restore assign and preserve flags.
                        //
                        *ColorOut = (NewColor & 0x00ffffff) | (ColorIn & 0xff000000);
                    }
                    else
                    {
                        //
                        // The distination is 32bits color.
                        //
                        // [NOTE:]
                        //  We will lost flags here.
                        //
                        *ColorOut = NewColor;

                        ICMMSG(("IcmTranslateCOLORREF(): 32 bits color !\n"));
                    }
                }
            }
            else
            {
                WARNING("IcmTranslateCOLORREF():Fail TranslateBitmapBits()\n");
            }
        }
    }
    else
    {
        //
        // Just return original color
        //
        *ColorOut = ColorIn;
        bStatus = TRUE;
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* IcmTranslateTRIVERTEX
*
*   Translate TRIVERTEX in place. No need for a general routine with
*   separate input and output pointers
*
* Arguments:
*
*   hdc        - hdc
*   pdcattr    - verified dcattr
*   pVertex    - input and output pointer
*
* Return Value:
*
*   Status
*
* History:
*
* Write it:
*   13-Feb-1997 -by- Hideyuki Nagase [hideyukn]
*
\**************************************************************************/

BOOL
IcmTranslateTRIVERTEX(
    HDC         hdc,
    PDC_ATTR    pdcattr,
    PTRIVERTEX  pVertex,
    ULONG       nVertex
    )
{
    BOOL     bStatus = TRUE;

    ICMAPI(("gdi32: IcmTranslateTRIVERTEX\n"));

    ASSERTGDI(pVertex != NULL,"IcmTranslateTrivertex(): pVertex == NULL\n");

    if (bNeedTranslateColor(pdcattr))
    {
        PGDI_ICMINFO pIcmInfo;

        LOAD_ICMDLL(FALSE);

        if ((pIcmInfo = GET_ICMINFO(pdcattr)) == NULL)
        {
            WARNING("gdi32: IcmTranslateTRIVERTEX: Can't init icm info\n");
            return((int)FALSE);
        }
        else
        {
            //
            // Use foaward color transform.
            //
            if (GetColorTransformInDC(pdcattr))
            {
                //
                // use 16 bit per channel COLOR_RGB to translate trivertex
                //

                while (nVertex--)
                {
                    COLOR Color;

                    Color.rgb.red   = pVertex->Red;
                    Color.rgb.green = pVertex->Green;
                    Color.rgb.blue  = pVertex->Blue;

                    bStatus = (*fpTranslateColors)(
                                  (HANDLE)GetColorTransformInDC(pdcattr),
                                  &Color,
                                  1,
                                  COLOR_RGB,
                                  &Color,
                                  COLOR_RGB);

                    if (bStatus)
                    {
                        //
                        // assign output
                        //
                        pVertex->Red   = Color.rgb.red;
                        pVertex->Green = Color.rgb.green;
                        pVertex->Blue  = Color.rgb.blue;
                    }
                    else
                    {
                        WARNING("IcmTranslateTRIVERTEX():Fail TranslateColors()\n");
                        break;
                    }

                    pVertex++;
                }

            }
            else
            {
                //
                // It seems hcmXform is invalid
                //
                ICMWRN(("IcmTranslateTRIVERTEX():hcmXform is invalid\n"));
                bStatus = FALSE;
            }
        }
    }
    else
    {
        bStatus = TRUE;
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* IcmTranslatePaletteEntry
*
* Arguments:
*
*   hdc
*   pdcattr
*   ColorIn
*   pColorOut
*
* Return Value:
*
*   Status
*
* History:
*
* Rewrite it:
*   21-Jan-1997 -by- Hideyuki Nagase [hideyukn]
* Write it:
*    5-Aug-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
IcmTranslatePaletteEntry(
    HDC           hdc,
    PDC_ATTR      pdcattr,
    PALETTEENTRY *pColorIn,
    PALETTEENTRY *pColorOut,
    UINT          NumberOfEntries
    )
{
    BOOL bStatus = FALSE;

    ICMAPI(("gdi32: IcmTranslatePaletteEntry\n"));

    if (bNeedTranslateColor(pdcattr))
    {
        PGDI_ICMINFO pIcmInfo = GET_ICMINFO(pdcattr);

        if (pIcmInfo)
        {
            LOAD_ICMDLL(FALSE);

            //
            // We handle PALETTEENTRYs as NumberOfEntries x 1 pixels bitmap data.
            //
            bStatus = (*fpTranslateBitmapBits)((HANDLE)GetColorTransformInDC(pdcattr),
                                               (PVOID)pColorIn,
                                                             //
                                               BM_xBGRQUADS, // PALETTEENTRY is 0x00bbggrr format
                                                             //
                                               NumberOfEntries,1,
                                               ALIGN_DWORD(NumberOfEntries*sizeof(COLORREF)),
                                               (PVOID)pColorOut,
                                                                                       //
                                               pIcmInfo->pDestColorSpace->ColorFormat, // BM_xBGRQUADS or BM_KYMCQUADS
                                                                                       //
                                                  //
                                               0, // We need pass 0 here, to let Kodak CMM works
                                                  //
                                               NULL,0);

            if (!bStatus)
            {
                WARNING("IcmTranslatePaletteEntry():Fail TranslateBitmapBits()\n");
            }
        }
    }
    else
    {
        //
        // Just return original color.
        //
        RtlCopyMemory(pColorIn,pColorOut,sizeof(PALETTEENTRY) * NumberOfEntries);
        bStatus = TRUE;
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* IcmDeleteColorTransform
*
*   Decide whether to call the device driver or mscms.dll to delete a
*   color transform.
*
* Arguments:
*
* Return Value:
*
* History:
*
*     Mar.12.1998 -by- Hideyuki Nagase [hideyukn]
*
\**************************************************************************/

BOOL
IcmDeleteColorTransform(
    PCACHED_COLORTRANSFORM pCXform,
    BOOL                   bForceDelete
    )
{
    BOOL bStatus = TRUE;

    ICMAPI(("gdi32: IcmDeleteColorTransform\n"));

    if (pCXform)
    {
        ENTERCRITICALSECTION(&semColorTransformCache);

        //
        // Decrement ref. counter.
        //
        pCXform->cRef--;

        if ((pCXform->cRef == 0) || bForceDelete)
        {
            PCACHED_COLORTRANSFORM pCXformVictim = NULL;

            if ((pCXform->flInfo & CACHEABLE_COLORTRANSFORM) && !bForceDelete)
            {
                if (cCachedColorTransform < MAX_COLORTRANSFORM_CACHE)
                {
                    ICMMSG(("IcmDeleteColorTransform(): colortransform can be cached !\n"));

                    //
                    // The color transform can be cached. so just keep it in list.
                    // And don't need to delete anything here.
                    //
                    pCXformVictim = NULL;
                }
                else
                {
                    //
                    // Find any cache can delete from list.
                    //
                    if ((pCXformVictim = IcmGetFirstNonUsedColorTransform()) == NULL)
                    {
                        ICMMSG(("IcmDeleteColorTransform(): colortransform cache is full, delete myself\n"));

                        //
                        // Nothing can be deleted from list, so delete myself.
                        //
                        pCXformVictim = pCXform;
                    }
                    else
                    {
                        ICMMSG(("IcmDeleteColorTransform(): colortransform cache is full, delete victim\n"));
                    }
                }
            }
            else
            {
                //
                // The colortransform can not be kept, or force delete, so just delete this.
                //
                pCXformVictim = pCXform;
            }

            if (pCXformVictim)
            {
                //
                // Unref color space count.
                //
                if (pCXformVictim->SourceColorSpace)
                {
                    IcmReleaseColorSpace(NULL,pCXformVictim->SourceColorSpace,FALSE);
                }

                if (pCXformVictim->DestinationColorSpace)
                {
                    IcmReleaseColorSpace(NULL,pCXformVictim->DestinationColorSpace,FALSE);
                }

                if (pCXformVictim->TargetColorSpace)
                {
                    IcmReleaseColorSpace(NULL,pCXformVictim->TargetColorSpace,FALSE);
                }

                //
                // Delete color transform
                //
                if (pCXformVictim->flInfo & DEVICE_COLORTRANSFORM)
                {
                    //
                    // call device driver to delete transform.
                    //
                    bStatus = NtGdiDeleteColorTransform(pCXformVictim->hdc,pCXformVictim->ColorTransform);
                }
                else
                {
                    //
                    // call color match dll to delete transform.
                    //
                    bStatus = (*fpDeleteColorTransform)(pCXformVictim->ColorTransform);
                }

                //
                // Remove from list
                //

                RemoveEntryList(&(pCXformVictim->ListEntry));
                cCachedColorTransform--;

                //
                // free CACHED_COLORTRANSFORM
                //
                LOCALFREE(pCXformVictim);
            }
        }

        LEAVECRITICALSECTION(&semColorTransformCache);
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* IcmDeleteDCColorTransforms
*
* Arguments:
*
* Return Value:
*
* History:
*
*    Feb.17.1997 Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL IcmDeleteDCColorTransforms(
    PGDI_ICMINFO pIcmInfo
    )
{
    ICMAPI(("gdi32: IcmDeleteDCColorTransforms\n"));

    ASSERTGDI(pIcmInfo != NULL,"IcmDeleteDCColorTransform():pIcmInfo == NULL\n");

    //
    // Delete transform selected in DC.
    //
    if (pIcmInfo->pCXform)
    {
        IcmDeleteColorTransform(pIcmInfo->pCXform,FALSE);
    }

    if (pIcmInfo->pBackCXform)
    {
        IcmDeleteColorTransform(pIcmInfo->pBackCXform,FALSE);
    }

    if (pIcmInfo->pProofCXform)
    {
        IcmDeleteColorTransform(pIcmInfo->pProofCXform,FALSE);
    }

    //
    // Invalidate colortransforms
    //
    pIcmInfo->pCXform = pIcmInfo->pBackCXform = pIcmInfo->pProofCXform = NULL;

    return (TRUE);
}

/******************************Public*Routine******************************\
* IcmDeleteCachedColorTransforms
*
* Arguments:
*
* Return Value:
*
* History:
*
*    May.06.1997 Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
IcmDeleteCachedColorTransforms(
    HDC          hdc
    )
{
    PCACHED_COLORTRANSFORM pCXform = NULL;
    PLIST_ENTRY p;

    ICMAPI(("gdi32: IcmDeleteCachedColorTransforms\n"));

    ENTERCRITICALSECTION(&semColorTransformCache);

    p = ListCachedColorTransform.Flink;

    while(p != &ListCachedColorTransform)
    {
        //
        // Get cached color transform
        //
        pCXform = CONTAINING_RECORD(p,CACHED_COLORTRANSFORM,ListEntry);

        //
        // Let 'p' points next cell. (this prefer to be done BEFORE un-chain this cell)
        //
        p = p->Flink;

        //
        // Is this color transform is specific to this DC ?
        //
        if (pCXform->hdc == hdc)
        {
            ICMMSG(("IcmDeleteCachedColorTransform():Delete colortransform in cache !\n"));

            //
            // Delete color transform (this call will un-chain this cell)
            //
            IcmDeleteColorTransform(pCXform,TRUE);
        }
    }

    LEAVECRITICALSECTION(&semColorTransformCache);

    return (TRUE);
}

/******************************Public*Routine******************************\
* IcmIsCacheable
*
* Arguments:
*
* Return Value:
*
* History:
*
*    Mar.12.1998 Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
IcmIsCacheable(
    PCACHED_COLORSPACE pColorSpace
)
{
    //
    // If this color space can not be cached, don't cache it.
    //
    if (pColorSpace->flInfo & NOT_CACHEABLE_COLORSPACE)
    {
        return (FALSE);
    }

    //
    // If this is any GDI object specific color space, also can not cache.
    //
    if (pColorSpace->hObj)
    {
        return (FALSE);
    }

    return (TRUE);
}

/******************************Public*Routine******************************\
* IcmReleaseCachedColorSpace
*
* Arguments:
*
* Return Value:
*
* History:
*
*    May.06.1997 Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
IcmReleaseCachedColorSpace(
    HGDIOBJ  hObj
    )
{
    PCACHED_COLORSPACE pColorSpace = NULL;
    PLIST_ENTRY p;

    ICMAPI(("gdi32: IcmReleaseCachedColorSpace\n"));

    ENTERCRITICALSECTION(&semColorSpaceCache);

    p = ListCachedColorSpace.Flink;

    while(p != &ListCachedColorSpace)
    {
        //
        // Get cached color space
        //
        pColorSpace = CONTAINING_RECORD(p,CACHED_COLORSPACE,ListEntry);

        //
        // Let 'p' points next cell. (this prefer to be done BEFORE un-chain this cell)
        //
        p = p->Flink;

        //
        // Is this color transform is related to this DC ?
        //
        if (pColorSpace->hObj == hObj)
        {
            ICMMSG(("IcmReleaseCachedColorSpace():Delete colorspace in cache !\n"));

            //
            // Delete color space (this call will un-chain this cell)
            //
            IcmReleaseColorSpace(hObj,pColorSpace,TRUE);
        }
    }

    LEAVECRITICALSECTION(&semColorSpaceCache);

    return (TRUE);
}

/******************************Public*Routine******************************\
* IcmReleaseColorSpace
*
* Arguments:
*
* Return Value:
*
* History:
*
*    Feb.17.1997 -by- Hideyuki Nagase [hideyukn]
*
\**************************************************************************/

VOID IcmReleaseColorSpace(
    HGDIOBJ            hObj,        /* Must be given if bForceDelete is TRUE */
    PCACHED_COLORSPACE pColorSpace,
    BOOL               bForceDelete
    )
{
    ICMAPI(("gdi32: IcmReleaseColorSpace\n"));

    if (pColorSpace)
    {
        ENTERCRITICALSECTION(&semColorSpaceCache);

        //
        // Decrement ref. counter.
        //
        pColorSpace->cRef--;

        //
        // If this profile associated with other GDI objects (driver, metafile or bitmap)
        // we won't delete until the object is deleted 
        //
        if (
            (pColorSpace->flInfo & HGDIOBJ_SPECIFIC_COLORSPACE)
                    &&
            (bForceDelete == FALSE)
           )
        {
            ICMWRN(("IcmReleaseColorSpace: Delay Delete for Metafile/Driver/Bitmap profile - %ws\n",\
                (pColorSpace->LogColorSpace.lcsFilename[0] ? \
                                   pColorSpace->LogColorSpace.lcsFilename : L"no profile")));
        }
        else
        {
            if ((pColorSpace->cRef == 0)      // No one uses this profile.
                         ||                   //     OR
                (bForceDelete && IsColorSpaceOwnedByGDIObject(pColorSpace,hObj))
                                              // DC or Owner GDI object is going to delete and
                                              // colorspace is designed for this GDI object.
               )
            {
                ICMMSG(("IcmReleaseColorSpace: Delete - %ws\n",    \
                      (pColorSpace->LogColorSpace.lcsFilename[0] ? \
                                       pColorSpace->LogColorSpace.lcsFilename : L"no profile")));

                if (pColorSpace->hProfile)
                {
                    IcmUnrealizeColorProfile(pColorSpace);
                }

                if (pColorSpace->flInfo & NEED_TO_FREE_PROFILE)
                {
                    ICMMSG(("IcmReleaseColorSpace: Free on memory profile\n"));

                    GlobalFree(pColorSpace->ColorProfile.pProfileData);
                }

                if (pColorSpace->flInfo & NEED_TO_DEL_PROFILE)
                {
                    ICMMSG(("IcmReleaseColorSpace: Delete TempFile - %ws\n",
                                    pColorSpace->LogColorSpace.lcsFilename));

                    DeleteFileW(pColorSpace->LogColorSpace.lcsFilename);
                }

                //
                // Remove from list
                //
                RemoveEntryList(&(pColorSpace->ListEntry));
                cCachedColorSpace--;

                //
                // Free colorspace.
                //
                LOCALFREE(pColorSpace);
            }
            else
            {
                ICMWRN(("IcmReleaseColorSpace: Still in USE - %ws\n",    \
                    (pColorSpace->LogColorSpace.lcsFilename[0] ? \
                                       pColorSpace->LogColorSpace.lcsFilename : L"no profile")));
            }
        }

        LEAVECRITICALSECTION(&semColorSpaceCache);
    }
}

/******************************Public*Routine******************************\
* IcmReleaseDCColorSpace
*
* Arguments:
*
* Return Value:
*
* History:
*
*    Feb.17.1997 -by- Hideyuki Nagase [hideyukn]
*
\**************************************************************************/

VOID IcmReleaseDCColorSpace(
    PGDI_ICMINFO pIcmInfo,
    BOOL         bReleaseDC
    )
{
    INT i   = 0;
    HDC hdc = pIcmInfo->hdc;
    PCACHED_COLORSPACE DeleteColorSpaces[4];

    ICMAPI(("gdi32: IcmReleaseDCColorSpace\n"));

    ASSERTGDI(pIcmInfo != NULL,"IcmReleaseDCColorSpace pIcmInfo == NULL\n");

    //
    // Fill up the table to delete color color spaces.
    //
    DeleteColorSpaces[i++] = pIcmInfo->pSourceColorSpace;

    if (bReleaseDC)
    {
        ICMMSG(("IcmReleaseDCColorSpace: Force Delete\n"));

        //
        // If we are in "force deletion" mode, don't delete twice.
        // since if the color space owned by this HDC, and this DC is going to be
        // deleted, we will delete the color space forcely.
        //
        if (IsColorSpaceOwnedByGDIObject(pIcmInfo->pDestColorSpace,hdc) &&
            IcmSameColorSpace(pIcmInfo->pSourceColorSpace,pIcmInfo->pDestColorSpace))

        {
            ICMMSG(("IcmReleaseDCColorSpace: Force Delete - skip destination (same as source)\n"));
        }
        else
        {
            DeleteColorSpaces[i++] = pIcmInfo->pDestColorSpace;
        }

        if (IsColorSpaceOwnedByGDIObject(pIcmInfo->pTargetColorSpace,hdc) &&
            (IcmSameColorSpace(pIcmInfo->pSourceColorSpace,pIcmInfo->pTargetColorSpace) ||
             IcmSameColorSpace(pIcmInfo->pDestColorSpace,pIcmInfo->pTargetColorSpace)))
        {
            ICMMSG(("IcmReleaseDCColorSpace: Force Delete - skip target (same as source/dest)\n"));
        }
        else
        {
            DeleteColorSpaces[i++] = pIcmInfo->pTargetColorSpace;
        }
    }
    else
    {
        DeleteColorSpaces[i++] = pIcmInfo->pDestColorSpace;
        DeleteColorSpaces[i++] = pIcmInfo->pTargetColorSpace;
    }

    DeleteColorSpaces[i] = NULL;

    for (i = 0; DeleteColorSpaces[i] != NULL; i++)
    {
        IcmReleaseColorSpace((HGDIOBJ)hdc,DeleteColorSpaces[i],bReleaseDC);
    }

    pIcmInfo->pSourceColorSpace = NULL;
    pIcmInfo->pDestColorSpace   = NULL;
    pIcmInfo->pTargetColorSpace = NULL;
}

/******************************Public*Routine******************************\
* IcmInitIcmInfo()
*
* Arguments:
*
* Return Value:
*
* History:
*
*    Jan.31,1997 -by- Hideyuki Nagase [hideyukn]
*
\**************************************************************************/

PGDI_ICMINFO
IcmInitIcmInfo(
    HDC      hdc,
    PDC_ATTR pdcattr
    )
{
    ICMAPI(("gdi32: IcmInitIcmInfo\n"));

    if (pdcattr == NULL)
    {
        WARNING("IcmInitIcmInfo():pdcattr is NULL\n");
        return (NULL);
    }

    if (pdcattr->pvICM == NULL)
    {
        PGDI_ICMINFO pIcmInfo = NULL;
        PLDC         pldc = (PLDC) pdcattr->pvLDC;
        BOOL         bDisplay = ((pldc && pldc->hSpooler) ? FALSE : TRUE);
        BOOL         bInsertList = bDisplay;

        ENTERCRITICALSECTION(&semListIcmInfo);

        //
        // First try to get ICMINFO from list. if not nothing can be re-used,
        // allocate new one.
        //
        if (bDisplay)
        {
            if ((pIcmInfo = IcmGetUnusedIcmInfo(hdc)) != NULL)
            {
                LIST_ENTRY ListEntry;

                //
                // Save ListEntry.
                //
                ListEntry = pIcmInfo->ListEntry;

                //
                // Init with zero.
                //
                RtlZeroMemory(pIcmInfo,sizeof(GDI_ICMINFO));

                //
                // Restore ListEntry
                //
                pIcmInfo->ListEntry = ListEntry;

                //
                // This ICMInfo already on list, don't need to insert.
                //
                bInsertList = FALSE;

                //
                // Mark this cell in on ListIcmInfo.
                //
                pIcmInfo->flInfo = ICM_ON_ICMINFO_LIST;

                ICMMSG(("IcmInitIcmInfo():Get unused ICMINFO structure = %p\n",pIcmInfo));
            }
        }

        if (pIcmInfo == NULL)
        {
            //
            // ICMINFO is not allocated, yet. then allocate it.
            //
            pIcmInfo = (PGDI_ICMINFO) LOCALALLOC(sizeof(GDI_ICMINFO));

            //
            // Init with zero.
            //
        if (pIcmInfo != NULL) {
        RtlZeroMemory(pIcmInfo,sizeof(GDI_ICMINFO));
        }

            ICMMSG(("IcmInitIcmInfo():Allocate new ICMINFO structure = %p\n",pIcmInfo));
        }

        if (pIcmInfo)
        {
            PDEVMODEW pDevModeW = NULL;

            //
            // Set owner information (hdc and pdcattr).
            //
            pIcmInfo->hdc      = hdc;
            pIcmInfo->pvdcattr = (PVOID) pdcattr;

            //
            // initialize LIST_ENTRY for saved icm info.
            //
            InitializeListHead(&(pIcmInfo->SavedIcmInfo));

            //
            // Default is LCS_DEFAULT_INTENT (aka LCS_GM_IMAGES)
            //
            pIcmInfo->dwDefaultIntent = LCS_DEFAULT_INTENT;

            //
            // If this is printer, set default Intent from devmode.
            //
            if (pldc && pldc->hSpooler)
            {
                PVOID pvFree = NULL;

                if (pldc->pDevMode)
                {
                    pDevModeW = pldc->pDevMode;
                }
                else
                {
                    pDevModeW = pdmwGetDefaultDevMode(pldc->hSpooler,NULL,&pvFree);
                }

                if (pDevModeW && (pDevModeW->dmFields & DM_ICMINTENT))
                {
                    DWORD dwIntent = pDevModeW->dmICMIntent;

                    ICMMSG(("IcmInitIcmInfo():Intent in devmode = %d\n",dwIntent));

                    //
                    // Convert intent for devmode to intent for LOGCOLORSPACE.
                    //
                    switch (dwIntent)
                    {
                    case DMICM_SATURATE:
                        pIcmInfo->dwDefaultIntent = LCS_GM_BUSINESS;
                        break;

                    case DMICM_COLORIMETRIC:
                        pIcmInfo->dwDefaultIntent = LCS_GM_GRAPHICS;
                        break;

                    case DMICM_ABS_COLORIMETRIC:
                        pIcmInfo->dwDefaultIntent = LCS_GM_ABS_COLORIMETRIC;
                        break;

                    case DMICM_CONTRAST:
                    default:
                        pIcmInfo->dwDefaultIntent = LCS_DEFAULT_INTENT;
                        break;
                    }
                }

                ICMMSG(("IcmInitIcmInfo():Default Intent = %d\n",pIcmInfo->dwDefaultIntent));

                //
                // Free devmode buffer.
                //
                if (pvFree)
                {
                    LOCALFREE(pvFree);
                }
            }

            //
            // Only ICMINFO for Display ICM put on to the list.
            //
            if (bInsertList)
            {
                //
                // This ICMINFO is newly allocated, so put this on list.
                //
                InsertTailList(&ListIcmInfo,&(pIcmInfo->ListEntry));

                //
                // Mark this cell in on ListIcmInfo.
                //
                pIcmInfo->flInfo |= ICM_ON_ICMINFO_LIST;
            }
        }

        //
        // Store pointer to ICMINFO to DC_ATTR.
        //
        pdcattr->pvICM = (PVOID) pIcmInfo;

        LEAVECRITICALSECTION(&semListIcmInfo);
    }

    return ((PGDI_ICMINFO)(pdcattr->pvICM));
}

/******************************Public*Routine******************************\
* IcmGetUnusedIcmInfo()
*
* ATTENTION: semListIcmInfo should be held by caller
*
* History:
*    17-Feb-1999 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

PGDI_ICMINFO
IcmGetUnusedIcmInfo(
    HDC hdcNew
    )
{
    PLIST_ENTRY  p;

    PGDI_ICMINFO pInvalidIcmInfo = NULL;

    ICMAPI(("gdi32: IcmGetUnusedIcmInfo\n"));

    p = ListIcmInfo.Flink;

    //
    // First Loop - Find ICMINFO which has same hdc.
    //
    while(p != &ListIcmInfo)
    {
        pInvalidIcmInfo = CONTAINING_RECORD(p,GDI_ICMINFO,ListEntry);

        if (pInvalidIcmInfo->flInfo & ICM_IN_USE)
        {
            //
            // Skip this one, since it's under initializing.
            //
        }
        else
        {
            //
            // If this is same hdc, break.
            //
            if (pInvalidIcmInfo->hdc == hdcNew)
            {
                ICMMSG(("IcmGetUnusedIcmInfo(): ICMINFO at %p is invalid (same hdc)\n",
                         pInvalidIcmInfo));

                //
                // break loop.
                //
                break;
            }
        }

        //
        // Move on next.
        //
        p = p->Flink;
        pInvalidIcmInfo = NULL;
    }

    //
    // If not find in first loop, go to second loop.
    //
    if (pInvalidIcmInfo == NULL)
    {
        p = ListIcmInfo.Flink;

        //
        // Second Loop - Find unused ICMINFO.
        //
        while(p != &ListIcmInfo)
        {
            pInvalidIcmInfo = CONTAINING_RECORD(p,GDI_ICMINFO,ListEntry);

            if (pInvalidIcmInfo->flInfo & ICM_IN_USE)
            {
                //
                // Skip this one, since it's under initializing.
                //
            }
            else
            {
                PDC_ATTR pdcattr;

                //
                // Make sure this ICMINFO and hdc is stil effective.
                //

                //
                // Check below by calling PSHARED_GET_VALIDATE.
                //
                // 1) Is this DC handle ?
                // 2) Is this DC handle belonging to this process ?
                // 3) Does this DC has valid user mode DC_ATTR ?
                //
                PSHARED_GET_VALIDATE(pdcattr,pInvalidIcmInfo->hdc,DC_TYPE);

                if (pdcattr == NULL)
                {
                    ICMMSG(("IcmGetUnusedIcmInfo(): ICMINFO at %p is invalid (no pdcattr)\n",
                            pInvalidIcmInfo));

                    //
                    // break loop.
                    //
                    break;
                }
                else
                {
                    //
                    // Make sure the pointer points each other.
                    //
                    if ((pdcattr->pvICM != pInvalidIcmInfo          ) ||
                        (pdcattr        != pInvalidIcmInfo->pvdcattr))
                    {
                        ICMMSG(("IcmGetUnusedIcmInfo(): ICMINFO at %p is invalid (pointer mismatch)\n",
                                pInvalidIcmInfo));

                        //
                        // break loop.
                        //
                        break;
                    }
                }
            }

            //
            // Move on next.
            //
            p = p->Flink;
            pInvalidIcmInfo = NULL;
        }
    }

    if (pInvalidIcmInfo)
    {
        //
        // This ICMINFO is invalid, clean up this ICMINFO.
        //
        IcmCleanupIcmInfo(NULL,pInvalidIcmInfo);
    }
    else
    {
        ICMMSG(("IcmGetUnusedIcmInfo(): Unused ICMINFO is not in list\n"));
    }

    return (pInvalidIcmInfo);
}

/******************************Public*Routine******************************\
* IcmInitDC()
*
* Arguments:
*
* Return Value:
*
* History:
*
*    Jan.31.1997 -by- Hideyuki Nagase [hideyukn]
*
\**************************************************************************/

BOOL
IcmInitLocalDC(
    HDC             hdc,
    HANDLE          hPrinter,
    CONST DEVMODEW *pdm,
    BOOL            bReset
    )
{
    BOOL         bRet = TRUE;
    PDC_ATTR     pdcattr;
    PLDC         pldc;

    ICMAPI(("gdi32: IcmInitLocalDC\n"));

    //
    // all these stuff is for only Printer.
    //

    if (hPrinter == NULL)
    {
        return (TRUE);
    }

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if (!pdcattr)
    {
        WARNING("IcmInitDC(): pdcattr is NULL\n");
        return (FALSE);
    }

    if (bReset)
    {
        //
        // Release existing ICMINFO
        //
        if (ghICM || BEXIST_ICMINFO(pdcattr))
        {
            //
            // Delete ICM stuff in this DC.
            //
            IcmDeleteLocalDC(hdc,pdcattr,NULL);
        }
    }

    if (!pdm)
    {
        //
        // DEVMODE are not presented.
        //
        ICMMSG(("IcmInitLocalDC():DEVMODE is not presented\n"));
        return (TRUE);
    }

    //
    // Check pointer to DEVMODE is valid or not. Check validation until
    // DEVMODE.dmSize first, then check whole devmode size specified in dmSize.
    //
    if (IsBadReadPtr((CONST VOID *)pdm, offsetof(DEVMODEW,dmDriverExtra)) ||
        IsBadReadPtr((CONST VOID *)pdm, pdm->dmSize))
    {
        WARNING("IcmInitLocalDC(): Invalid pointer given as PDEVMODEW\n");
        return (FALSE);
    }

    //
    // Check color or mono mode.
    //
    if ((pdm->dmFields & DM_COLOR) && (pdm->dmColor == DMCOLOR_MONOCHROME))
    {
        //
        // This is monochrome mode, don't enable ICM as default.
        // And NEVER enable ICM.
        //
        ICMMSG(("IcmInitLocalDC():DEVMODE says MONOCHROME mode\n"));
        return (TRUE);
    }

    //                                                                           
    // ATTENTION: AFTER HERE, WE HAVE A DEVMODE WHICH POSSIBLE TO ENABLE ICM LATER OR NOW.
    //                                                                          

    //
    // Check DM fields
    //
    if (!(pdm->dmFields & DM_ICMMETHOD))
    {
        //
        // DEVMODE does not have ICMMETHOD.
        //
        ICMMSG(("IcmInitLocalDC():DEVMODE does not have ICMMETHOD\n"));
        return (TRUE);
    }

    //
    // NOTE:
    //
    // DEVMODEW structure.
    //
    // ... [omitted]
    // DWORD  dmDisplayFrequency;
    // #if(WINVER >= 0x0400)
    // DWORD  dmICMMethod;         // Windows 95 only / Windows NT 5.0
    // DWORD  dmICMIntent;         // Windows 95 only / Windows NT 5.0
    // DWORD  dmMediaType;         // Windows 95 only / Windows NT 5.0
    // ....
    //
    // Then DEVMODE structure should be larger than offset of dmMediaType
    // to access ICM stuff.
    //
    if (pdm->dmSize < offsetof(DEVMODEW,dmMediaType))
    {
        //
        // DEVMODE version might not matched.
        //
        WARNING("IcmInitLocalDC():DEVMODE is small\n");
        return (TRUE);
    }

    //
    // Check requested ICM mode.
    //
    switch (pdm->dmICMMethod)
    {
        case DMICMMETHOD_NONE:

            ICMMSG(("IcmInitDC(): ICM is disabled by default\n"));
            //
            // ICM is not enabled at this time.
            //
            // no more process is needed, just return here...
            //
            return (TRUE);

        case DMICMMETHOD_SYSTEM:

            ICMMSG(("IcmInitDC(): HOST ICM is requested\n"));
            //
            // ICM on Host, is requested.
            //
            SET_HOST_ICM_DEVMODE(pdcattr->lIcmMode);
            break;

        case DMICMMETHOD_DRIVER:
        case DMICMMETHOD_DEVICE:

            ICMMSG(("IcmInitDC(): DEVICE ICM is requested\n"));
            //
            // ICM on device, is requested.
            //
            SET_DEVICE_ICM_DEVMODE(pdcattr->lIcmMode);
            break;

        default:

            //
            // And we treat as Device ICM greater DMICMMETHOD_USER also.
            //
            if (pdm->dmICMMethod >= DMICMMETHOD_USER)
            {
                ICMMSG(("IcmInitDC(): DEVICE ICM (USER) is requested\n"));
                //
                // ICM on device (user defined), is requested.
                //
                SET_DEVICE_ICM_DEVMODE(pdcattr->lIcmMode);
            }
            else
            {
                ICMMSG(("IcmInitDC(): Unknown ICM mode\n"));
                //
                // return with error.
                //
                return (FALSE);
            }
            break;
    }

    //
    // Finally, enabled ICM.
    //
    bRet = SetICMMode(hdc,ICM_ON);

    if (!bRet)
    {
        ICMWRN(("InitLocalDC():FAILED to turn on ICM\n"));
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* IcmUpdateDCColorInfo()
*
* Arguments:
*
* Return Value:
*
* History:
*
*    May.28.1997 -by- Hideyuki Nagase [hideyukn]
*
\**************************************************************************/

BOOL
IcmUpdateDCColorInfo(
    HDC      hdc,
    PDC_ATTR pdcattr
    )
{
    BOOL bRet = TRUE;
    PGDI_ICMINFO pIcmInfo;

    ICMAPI(("gdi32: IcmUpdateDCColorInfo\n"));

    pIcmInfo = GET_ICMINFO(pdcattr);

    ASSERTGDI(pIcmInfo != NULL,"IcmUpdateDCColorInfo(): pIcmInfo == NULL\n");

    //
    // Get the ColorSpace for this DC.
    //
    if (!IcmUpdateLocalDCColorSpace(hdc,pdcattr))
    {
        return (FALSE);
    }

    if ((pIcmInfo->pCXform == NULL) || (pdcattr->ulDirty_ & DIRTY_COLORTRANSFORM))
    {
        //
        // if TRUE in above, new color space (or no) has been selected,
        // then updates color transforms.
        //
        PCACHED_COLORTRANSFORM pCXform;

        //
        // At this momernt, we should have destination color space.
        // if this is null, we may fail to update color space in
        // IcmUpdateLocalDCColorSpace()
        //
        if (pIcmInfo->pDestColorSpace)
        {
            //
            // Create the color transform.
            //
            pCXform = IcmCreateColorTransform(hdc,pdcattr,NULL,ICM_FORWARD);

            if (pCXform)
            {
                if (pCXform == IDENT_COLORTRANSFORM)
                {
                    ICMMSG(("IcmUpdateDCInfo():Input & Output colorspace is same\n"));

                    //
                    // Input and Output colorspace is same, could be optimize.
                    //

                    //
                    // Set new color transform to DC.
                    //
                    IcmSelectColorTransform(hdc,pdcattr,NULL,
                                            bDeviceCalibrate(pIcmInfo->pDestColorSpace));

                    //
                    // Delete cached dirty color transform, if we have.
                    //
                    IcmDeleteDCColorTransforms(pIcmInfo);

                    //
                    // Set new color transform to ICMINFO.
                    //
                    pIcmInfo->pCXform = NULL;
                }
                else
                {
                    //
                    // Select the color transform to DC.
                    //
                    IcmSelectColorTransform(hdc,pdcattr,pCXform,
                                            bDeviceCalibrate(pCXform->DestinationColorSpace));

                    //
                    // Delete cached dirty color transform, if we have.
                    //
                    IcmDeleteDCColorTransforms(pIcmInfo);

                    //
                    // Set new color transform to ICMINFO.
                    //
                    pIcmInfo->pCXform = pCXform;

                    //
                    // Translate all DC objects to ICM colors. Must
                    // force brush/pens to be re-realized when used next
                    //
                    IcmTranslateColorObjects(hdc,pdcattr,TRUE);
                }
            }
            else
            {
                WARNING("IcmUpdateDCInfo():CreateColorTransform failed\n");

                //
                // Fail to create new transform, keep as is.
                //
                bRet = FALSE;
            }
        }
        else
        {
            WARNING("IcmUpdateDCInfo():No destination color space\n");
            bRet = FALSE;
        }
    }
    else
    {
        ICMMSG(("IcmUpdateDCColorInfo(): Color space does not change or not found\n"));
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* IcmUpdateLocalDCColorSpace
*
* Arguments:
*
* Return Value:
*
* History:
*
*    26.Feb.1997 -by- Hideyuki Nagase [hideyukn]
*
\**************************************************************************/

BOOL
IcmUpdateLocalDCColorSpace(
    HDC      hdc,
    PDC_ATTR pdcattr
    )
{
    BOOL bRet = FALSE;
    BOOL bDirtyXform = FALSE;

    PLDC         pldc;
    PGDI_ICMINFO pIcmInfo;

    WCHAR ProfileName[MAX_PATH];
    DWORD dwColorSpaceFlag;

    PCACHED_COLORSPACE pNewColorSpace = NULL;

    ICMAPI(("gdi32: IcmUpdateLocalDCColorSpace\n"));

    ASSERTGDI(pdcattr != NULL,"IcmUpdateLocalDCColorSpace(): pdcattr == NULL\n");

    pldc = pdcattr->pvLDC;
    pIcmInfo = GET_ICMINFO(pdcattr);

    ASSERTGDI(pIcmInfo != NULL,"IcmUpdateLocalDCColorSpace(): pIcmInfo == NULL\n");

    //
    // if the DC already has a destination colorspace, then return TRUE
    //
    if ((pIcmInfo->pDestColorSpace == NULL) || (pdcattr->ulDirty_ & DIRTY_COLORSPACE))
    {
        HCOLORSPACE hDIBColorSpace;

        //
        // Invalidate profilename.
        //
        ProfileName[0]   = UNICODE_NULL;
        dwColorSpaceFlag = 0;
        hDIBColorSpace   = NULL;

        //
        // if the target DC has DIBSection. it will be DIBsection's color space
        // OR sRGB color space.
        //
        if (bDIBSectionSelected(pdcattr))
        {
            ENTERCRITICALSECTION(&semColorSpaceCache);

            if (pdcattr->dwDIBColorSpace)
            {
                ICMMSG(("IcmUpdateLocalDCColorSpace(): DIB section in DC (V4/V5)\n"));

                //
                // The DIB currently selected, has thier own color space.
                // This case happens when CreateDIBSection called with
                // BITMAPV4/V5 header.
                //
                pNewColorSpace = (PCACHED_COLORSPACE) pdcattr->dwDIBColorSpace;

                //
                // Inc. ref. count.
                //
                pNewColorSpace->cRef++;
            }
            else
            {
                ICMMSG(("IcmUpdateLocalDCColorSpace(): DIB section in DC (no color space)\n"));

                // [This is Win98 compatible behave]
                //
                // If the DIBitmap does not have any specific color space,
                // keep same color space as current DC.
                //
            }

            LEAVECRITICALSECTION(&semColorSpaceCache);
        }
        else if ((pdcattr->ulDirty_ & DC_PRIMARY_DISPLAY) &&
                 (PrimaryDisplayProfile[0] != UNICODE_NULL))
        {
            //
            // Use cached color profile.
            //
            lstrcpyW(ProfileName,PrimaryDisplayProfile);
        }
        else if (pIcmInfo->flInfo & ICM_VALID_DEFAULT_PROFILE)
        {
            //
            // Use cached color profile.
            //
            lstrcpyW(ProfileName,pIcmInfo->DefaultDstProfile);
        }
        else
        {
            int iRet;

            //
            // Still couldn't find yet ??. Ask MSCMS to find out profile. (go slow way)
            //
            iRet = IcmEnumColorProfile(hdc,IcmFindProfileCallBack,
                                       (LPARAM)ProfileName,FALSE,NULL,&dwColorSpaceFlag);

            //
            // if you could not find any profile for this DC, just use sRGB.
            //
            if ((iRet == -1) || (ProfileName[0] == UNICODE_NULL))
            {
                ULONG ulSize = MAX_PATH;

                if (!(*fpGetStandardColorSpaceProfileW)(NULL,LCS_sRGB,ProfileName,&ulSize))
                {
                    ICMMSG(("IcmUpdateLocalDCColorSpace():Fail to SCS(sRGB), use hardcode\n"));

                    //
                    // If error, use hardcoded profile name.
                    //
                    wcscpy(ProfileName,sRGB_PROFILENAME);
                }
            }

            //
            // Create cache for next usage
            //
            if ((pdcattr->ulDirty_ & DC_PRIMARY_DISPLAY) &&
                (PrimaryDisplayProfile[0] == UNICODE_NULL))
            {
                lstrcpyW(PrimaryDisplayProfile,ProfileName);
            }
            else // otherwise put it into default profile.
            {
                lstrcpyW(pIcmInfo->DefaultDstProfile,ProfileName);
                pIcmInfo->flInfo |= (ICM_VALID_DEFAULT_PROFILE|
                                     ICM_VALID_CURRENT_PROFILE);
            }
        }

        //
        // If default device profile could be found, associate it into this DC.
        //
        if ((ProfileName[0] != UNICODE_NULL) || (pNewColorSpace != NULL))
        {
        #if DBG
            if (ProfileName[0] != UNICODE_NULL)
            {
                ICMMSG(("IcmUpdateLocalDCColorSpace():Default Device Profile = %ws\n",ProfileName));
            }
        #endif

            //
            // try to find desired color space from cache.
            //
            if (pNewColorSpace == NULL)
            {
                pNewColorSpace = IcmGetColorSpaceByName(
                                     (HGDIOBJ)hdc,
                                     ProfileName,
                                     pIcmInfo->dwDefaultIntent,
                                     dwColorSpaceFlag);

                if (pNewColorSpace == NULL)
                {
                    //
                    // create new one.
                    //
                    pNewColorSpace = IcmCreateColorSpaceByName(
                                         (HGDIOBJ)hdc,
                                         ProfileName,
                                         pIcmInfo->dwDefaultIntent,
                                         dwColorSpaceFlag);
                }
            }

            if (pNewColorSpace)
            {
                //
                // Is this same destination color space as currently selected in DC ?
                //
                if (IcmSameColorSpace(pNewColorSpace,pIcmInfo->pDestColorSpace))
                {
                    ICMMSG(("IcmUpdateLocalDCColorSpace():Same color space is selected already\n"));

                    //
                    // Color space does NOT changed.
                    //
                    IcmReleaseColorSpace(NULL,pNewColorSpace,FALSE);

                    bRet = TRUE;
                }
                else
                {
                    //
                    // Notify new color format to kernel.
                    //
                    if (NtGdiSetIcmMode(hdc,ICM_CHECK_COLOR_MODE,pNewColorSpace->ColorFormat))
                    {
                        //
                        // if we have some color space currently selected, delete it.
                        //
                        if (pIcmInfo->pDestColorSpace)
                        {
                            IcmReleaseColorSpace(NULL,pIcmInfo->pDestColorSpace,FALSE);
                        }

                        //
                        // DC can accept this color space, Set new colorspace to destination.
                        //
                        pIcmInfo->pDestColorSpace = pNewColorSpace;

                        //
                        // Color space is changed. so color transform should be updated.
                        //
                        bDirtyXform = TRUE;

                        bRet = TRUE;
                    }
                    else
                    {
                        WARNING("ICM:Detected colorspace was not accepted by target DC\n");

                        //
                        // This color space does not match to this DC.
                        //
                        IcmReleaseColorSpace(NULL,pNewColorSpace,FALSE);
                    }
                }
            }
            else
            {
                WARNING("Failed IcmUpdateLocalDCColorSpace(), Failed to create new color space.\n");
            }
        }
        else
        {
            WARNING("Failed IcmUpdateLocalDCColorSpace(), no device profile is detected.\n");
        }
    }
    else
    {
        ICMMSG(("IcmUpdateLocalDCColoSpace(): Destination Color Space cache is valid\n"));

        bRet = TRUE;
    }

    //
    // [Only for Printer]
    //
    // If we haven't asked default source color profile for this Printer DC,
    // Now is the time to ask it. Only do this when apps does NOT specified
    // thier own color space.
    //
    if (bRet && pldc && pldc->hSpooler)
    {
        if ((pdcattr->hColorSpace == GetStockObject(PRIV_STOCK_COLORSPACE)) &&
            (pIcmInfo->hDefaultSrcColorSpace == NULL))
        {
            PDEVMODEW pDevModeW = NULL;
            PVOID     pvFree = NULL;
            BOOL      bRetSource = FALSE;

            //
            // Default is no DC specific source color space (= INVALID_COLORSPACE),
            // this also make sure we will not come here again.
            //
            pIcmInfo->hDefaultSrcColorSpace = INVALID_COLORSPACE;

            //
            // Invalidate profilename.
            //
            ProfileName[0]   = UNICODE_NULL;
            dwColorSpaceFlag = 0;

            if (pldc->pDevMode)
            {
                ICMMSG(("IcmUpdateLocalDCColorSpace():Cached DEVMODE used\n"));

                pDevModeW = pldc->pDevMode;
            }
            else
            {
                ICMMSG(("IcmUpdateLocalDCColorSpace():Get default DEVMODE\n"));

                pDevModeW = pdmwGetDefaultDevMode(pldc->hSpooler,NULL,&pvFree);
            }

            if (pDevModeW)
            {
                //
                // Get source color proflie from driver.
                //
                if (IcmAskDriverForColorProfile(pldc,QCP_SOURCEPROFILE,
                                                pDevModeW,ProfileName,&dwColorSpaceFlag) <= 0)
                {
                    //
                    // No source profile specified.
                    //
                    ProfileName[0] = UNICODE_NULL;
                }
            }

            //
            // Free devmode buffer.
            //
            if (pvFree)
            {
                LOCALFREE(pvFree);
            }

            //
            // 1) If default source profile could be found, or
            // 2) the default intent in devmode is different from LCS_DEFAULT_INTENT,
            //
            // we need to create new source color space, then associate it into this DC.
            //
            if ((ProfileName[0] != UNICODE_NULL) ||
                (pIcmInfo->dwDefaultIntent != LCS_DEFAULT_INTENT))
            {
                HCOLORSPACE hColorSpace = NULL;

                ICMMSG(("IcmUpdateLocalDCColorSpace():Default devmode Intent = %d\n",
                                                      pIcmInfo->dwDefaultIntent));

                //
                // If no color profile specified, use sRGB.
                //
                if (ProfileName[0] == UNICODE_NULL)
                {
                    ULONG ulSize = MAX_PATH;

                    if (!(*fpGetStandardColorSpaceProfileW)(NULL,LCS_sRGB,ProfileName,&ulSize))
                    {
                        ICMMSG(("IcmUpdateLocalDCColorSpace():Fail to SCS(sRGB), use hardcode\n"));

                        //
                        // If error, use hardcoded profile name.
                        //
                        wcscpy(ProfileName,sRGB_PROFILENAME);
                    }
                }

                ICMMSG(("IcmUpdateLocalDCColorSpace():Default Source Profile = %ws\n",ProfileName));

                //
                // Find from cache first.
                //
                pNewColorSpace = IcmGetColorSpaceByName(
                                     (HGDIOBJ)hdc,
                                     ProfileName,
                                     pIcmInfo->dwDefaultIntent,
                                     dwColorSpaceFlag);

                if (pNewColorSpace == NULL)
                {
                    //
                    // create new one.
                    //
                    pNewColorSpace = IcmCreateColorSpaceByName(
                                         (HGDIOBJ)hdc,
                                         ProfileName,
                                         pIcmInfo->dwDefaultIntent,
                                         dwColorSpaceFlag);
                }

                if (pNewColorSpace)
                {
                    //
                    // Create kernel-mode handle.
                    //
                    hColorSpace = CreateColorSpaceW(&(pNewColorSpace->LogColorSpace));

                    if (hColorSpace)
                    {
                        //
                        // Select this into DC.
                        //
                        if (IcmSetSourceColorSpace(hdc,hColorSpace,pNewColorSpace,0))
                        {
                            //
                            // IcmSetSourceColorSpace increments ref. count of colorspace.
                            // but we have done it by Icm[Get|Create]ColorSpaceByName, so
                            // decrement ref count of color space here.
                            //
                            IcmReleaseColorSpace(NULL,pNewColorSpace,FALSE);

                            //
                            // Keep these into ICMINFO.
                            //
                            pIcmInfo->hDefaultSrcColorSpace = hColorSpace;

                            //
                            // This color space should be deleted later.
                            //
                            pIcmInfo->flInfo |= ICM_DELETE_SOURCE_COLORSPACE;

                            //
                            // Source color space has been changed.
                            // (color transform is updated inside IcmSetSourceColorSpace().
                            //  so not nessesary to set bDirtyXfrom to TRUE)
                            //
                            bRetSource = TRUE;
                        }
                        else
                        {
                            WARNING("Failed IcmUpdateLocalDCColorSpace(), Failed to select new source color space.\n");
                        }
                    }
                    else
                    {
                        WARNING("Failed IcmUpdateLocalDCColorSpace(), Failed to create new source color space.\n");
                    }
                }
                else
                {
                    WARNING("Failed IcmUpdateLocalDCColorSpace(), Failed to create new source color space cache.\n");
                }

                if (!bRetSource)
                {
                    if (hColorSpace)
                    {
                        DeleteColorSpace(hColorSpace);
                    }

                    if (pNewColorSpace)
                    {
                        IcmReleaseColorSpace(NULL,pNewColorSpace,FALSE);
                    }
                }
            }
            else
            {
                ICMMSG(("IcmUpdateLocalDCColoSpace(): No default source color Space cache specified\n"));
            }
        }
    }

    //
    // Now color space is valid.
    //
    if (bRet)
    {
        pdcattr->ulDirty_ &= ~DIRTY_COLORSPACE;
    }

    if (bDirtyXform)
    {
        pdcattr->ulDirty_ |= DIRTY_COLORTRANSFORM;
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* IcmCleanupIcmInfo()
*
* ATTENTION: semListIcmInfo must be hold by caller
*
* History:
*   16-Feb-1999 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
IcmCleanupIcmInfo(
    PDC_ATTR     pdcattr, // This can be NULL for clean up case.
    PGDI_ICMINFO pIcmInfo // This can *NOT* be NULL at any rate.
    )
{
    if (ghICM)
    {
        //
        // Delete Saved ICMINFO data (if present)
        //
        IcmRestoreDC(pdcattr,1,pIcmInfo);
    }

    //
    // If there is any default source profile (kernel-side), do something here.
    //
    if ((pIcmInfo->hDefaultSrcColorSpace != NULL) &&
        (pIcmInfo->hDefaultSrcColorSpace != INVALID_COLORSPACE))
    {
        ICMMSG(("IcmCleanupIcmInfo():Delete/Unselect default source color space\n"));

        if (pdcattr)
        {
            //
            // If it is currently selected into this DC, un-select it.
            //
            if (pIcmInfo->hDefaultSrcColorSpace == pdcattr->hColorSpace)
            {
                NtGdiSetColorSpace(pIcmInfo->hdc,GetStockObject(PRIV_STOCK_COLORSPACE));
            }
        }

        //
        // And it should be delete it.
        //
        if (pIcmInfo->flInfo & ICM_DELETE_SOURCE_COLORSPACE)
        {
            DeleteColorSpace(pIcmInfo->hDefaultSrcColorSpace);
        }

        pIcmInfo->hDefaultSrcColorSpace = NULL;
    }

    if (ghICM)
    {
        //
        // Delete Color transforms
        //
        IcmDeleteDCColorTransforms(pIcmInfo);

        //
        // Delete Cached color transform related to this DC.
        // (like device color transform)
        //
        IcmDeleteCachedColorTransforms(pIcmInfo->hdc);

        //
        // Free ICM colorspace datas.
        //
        IcmReleaseDCColorSpace(pIcmInfo,TRUE);

        //
        // Delete Cached color space which related to this DC.
        // (like color space in metafile)
        //
        IcmReleaseCachedColorSpace((HGDIOBJ)(pIcmInfo->hdc));
    }

    pIcmInfo->hdc      = NULL;
    pIcmInfo->pvdcattr = NULL;
    pIcmInfo->flInfo   = 0;

    return(TRUE);
}

/******************************Public*Routine******************************\
* IcmDeleteLocalDC()
*
* Arguments:
*
* Return Value:
*
* History:
*
*    Jan.31.1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
IcmDeleteLocalDC(
    HDC          hdc,
    PDC_ATTR     pdcattr,
    PGDI_ICMINFO pIcmInfo
    )
{
    ICMAPI(("gdi32: IcmDeleteLocalDC\n"));

    ASSERTGDI(pdcattr != NULL,"IcmDeleteLocalDC():pdcattr == NULL\n");

    //
    // If callee does not provide ICMINFO, get it from pdcattr.
    //
    if (pIcmInfo == NULL)
    {
        pIcmInfo = GET_ICMINFO(pdcattr);
    }

    //
    // Invalidate current color tansform.
    //
    // (but the cache in ICMINFO is still valid, and will be delete
    //  inside IcmDeleteDCColorTransforms() called from IcmCleanupIcmInfo().)
    //
    IcmSelectColorTransform(hdc,pdcattr,NULL,TRUE);

    if (IS_ICM_INSIDEDC(pdcattr->lIcmMode))
    {
        //
        // Tell the kernel to disable ICM before delete client side data.
        //
        NtGdiSetIcmMode(hdc,ICM_SET_MODE,REQ_ICM_OFF);
    }

    //
    // Clean up ICMINFO.
    //
    if (pIcmInfo != NULL)
    {
        ENTERCRITICALSECTION(&semListIcmInfo);

        if (pIcmInfo->flInfo & ICM_ON_ICMINFO_LIST)
        {
            //
            // Remove this ICMINFO from list. (since this will be deleted).
            //
            RemoveEntryList(&(pIcmInfo->ListEntry));
        }

        //
        // Clean up ICMINFO.
        //
        IcmCleanupIcmInfo(pdcattr,pIcmInfo);

        //
        // Invalidate ICM info in DC_ATTR.
        //
        pdcattr->pvICM = NULL;

        LEAVECRITICALSECTION(&semListIcmInfo);

        //
        // Free ICM structure.
        //
        LOCALFREE(pIcmInfo);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL IcmSelectColorTransform (HDC, PDC_ATTR, PCACHED_COLORTRANSFORM)
*
* History:
*  23-Sep-1997 -by-  Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

BOOL
IcmSelectColorTransform(
    HDC                    hdc,
    PDC_ATTR               pdcattr,
    PCACHED_COLORTRANSFORM pCXform,
    BOOL                   bDeviceCalibrate)
{
    if (pCXform)
    {
        BMFORMAT ColorFormat = pCXform->DestinationColorSpace->ColorFormat;

        // LATER :
        //
        // if (GET_COLORTYPE(pdcattr->lIcmMode) != IcmConvertColorFormat(ColorFormat))
        //
        if (TRUE)
        {
            if (!NtGdiSetIcmMode(hdc,ICM_SET_COLOR_MODE,ColorFormat))
            {
                //
                // The transform color format is not accepted by DC.
                //
                return (FALSE);
            }
        }

        //
        // Select into the color transform to DC_ATTR.
        //
        pdcattr->hcmXform = pCXform->ColorTransform;
    }
    else
    {
        //
        // If curent color type is not RGB, call kernel to reset.
        //
        if (GET_COLORTYPE(pdcattr->lIcmMode) != DC_ICM_RGB_COLOR)
        {
            //
            // Reset current color mode to RGB (default).
            //
            NtGdiSetIcmMode(hdc,ICM_SET_COLOR_MODE,BM_xBGRQUADS);
        }

        //
        // Select null-color transfrom into the DC_ATTR.
        //
        pdcattr->hcmXform = NULL;
    }

    //
    // If device calibration mode need to updated, call kernel to update it.
    //

    if ((bDeviceCalibrate ? 1 : 0) !=
        (IS_ICM_DEVICE_CALIBRATE(pdcattr->lIcmMode) ? 1 : 0))
    {
        NtGdiSetIcmMode(hdc,ICM_SET_CALIBRATE_MODE,bDeviceCalibrate);
    }

    //
    // Remove dirty transform flag.
    //
    pdcattr->ulDirty_ &= ~DIRTY_COLORTRANSFORM;

    return(TRUE);
}

/******************************Public*Routine******************************\
* HBRUSH IcmSelectBrush (HDC hdc, HBRUSH hbrush)
*
* History:
*  04-June-1995 -by-  Lingyun Wang [lingyunW]
* Wrote it.
\**************************************************************************/

HBRUSH
IcmSelectBrush (
    HDC      hdc,
    PDC_ATTR pdcattr,
    HBRUSH   hbrushNew)
{
    HBRUSH hbrushOld = pdcattr->hbrush;

    ICMAPI(("gdi32: IcmSelectBrush\n"));

    //
    // Mark brush as dirty, select new brush in dcattr.
    // Color translation may fail, but still select brush
    //
    pdcattr->ulDirty_ |= DC_BRUSH_DIRTY;
    pdcattr->hbrush = hbrushNew;

    if (bNeedTranslateColor(pdcattr))
    {
        IcmTranslateBrushColor(hdc,pdcattr,hbrushNew);
    }

    return (hbrushOld);
}

/******************************Public*Routine******************************\
* HBRUSH IcmTranslateBrushColor(HDC hdc, PDC_ATTR pdcattr, HBRUSH hbrush)
*
* History:
*  10-Apr-1997 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

BOOL
IcmTranslateBrushColor(
    HDC      hdc,
    PDC_ATTR pdcattr,
    HBRUSH   hbrush)
{
    BOOL       bStatus = FALSE;
    COLORREF   OldColor;
    COLORREF   NewColor;
    PBRUSHATTR pbra;

    //
    // Invalidate BRUSH_TRANSLATED
    //
    pdcattr->ulDirty_ &= ~ICM_BRUSH_TRANSLATED;

    PSHARED_GET_VALIDATE(pbra,hbrush,BRUSH_TYPE);

    if (pbra)
    {
        //
        // translate to new icm mode if not paletteindex
        //
        OldColor = pbra->lbColor;

        if (!(OldColor & 0x01000000))
        {
            bStatus = IcmTranslateCOLORREF(hdc,
                                           pdcattr,
                                           OldColor,
                                           &NewColor,
                                           ICM_FORWARD);
            if (bStatus)
            {
                pdcattr->IcmBrushColor = NewColor;
            }
            else
            {
                pdcattr->IcmBrushColor = OldColor;
            }
        }
        else
        {
            pdcattr->IcmBrushColor = OldColor;
        }

        //
        // Somehow, IcmBrushColor is initialized.
        //
        pdcattr->ulDirty_ |= ICM_BRUSH_TRANSLATED;
    }
    else
    {
        LOGBRUSH lbrush;

        //
        // stock brush or bitmap/hatch/dib brush
        //
        if(GetObjectW(hbrush,sizeof(LOGBRUSH),&lbrush))
        {
            if ((lbrush.lbStyle == BS_SOLID) || (lbrush.lbStyle == BS_HATCHED))
            {
                //
                // try to translate color
                //
                OldColor = lbrush.lbColor;

                if (!(OldColor & 0x01000000))
                {
                    bStatus = IcmTranslateCOLORREF(hdc,
                                                   pdcattr,
                                                   OldColor,
                                                   &NewColor,
                                                   ICM_FORWARD);

                    if (bStatus)
                    {
                        pdcattr->IcmBrushColor = NewColor;
                    }
                    else
                    {
                        pdcattr->IcmBrushColor = OldColor;
                    }
                }
                else
                {
                    pdcattr->IcmBrushColor = OldColor;
                }

                //
                // IcmBrushColor is initialized.
                //
                pdcattr->ulDirty_ |= ICM_BRUSH_TRANSLATED;
            }
            else if (lbrush.lbStyle == BS_DIBPATTERN)
            {
                PBITMAPINFO pbmiDIB;

                //
                // Allocate temorary bitmap info header to get brush bitmap
                //
                pbmiDIB = (PBITMAPINFO)LOCALALLOC(sizeof(BITMAPINFO)+((256-1)*sizeof(RGBQUAD)));

                if (pbmiDIB)
                {
                    ULONG iColorUsage;
                    BOOL  bAlreadyTran;
                    BOOL  bStatus;

                    PVOID pvBits = NULL;
                    ULONG cjBits = 0;

                    //
                    // Get brush bitmap information, colortype, size, etc.
                    //
                    bStatus = NtGdiIcmBrushInfo(hdc,
                                                hbrush,
                                                pbmiDIB,
                                                pvBits,
                                                &cjBits,
                                                &iColorUsage,
                                                &bAlreadyTran,
                                                IcmQueryBrush);

                    if (bStatus)
                    {
                        if ((iColorUsage == DIB_RGB_COLORS) &&
                            (!bAlreadyTran) && (cjBits))
                        {
                            pvBits = (PVOID) LOCALALLOC(cjBits);

                            if (pvBits)
                            {
                                //
                                // Get brush bitmap bits.
                                //
                                bStatus = NtGdiIcmBrushInfo(hdc,
                                                            hbrush,
                                                            pbmiDIB,
                                                            pvBits,
                                                            &cjBits,
                                                            NULL,
                                                            NULL,
                                                            IcmQueryBrush);

                                if (bStatus)
                                {
                                    //
                                    // IcmTranslateDIB may create new copy of bitmap bits and/or
                                    // bitmap info header, if nessesary.
                                    //
                                    PVOID       pvBitsNew = NULL;
                                    PBITMAPINFO pbmiDIBNew = NULL;

                                    bStatus = IcmTranslateDIB(hdc,
                                                              pdcattr,
                                                              cjBits,
                                                              pvBits,
                                                              &pvBitsNew,
                                                              pbmiDIB,
                                                              &pbmiDIBNew,
                                                              NULL,
                                                              (DWORD)-1,
                                                              iColorUsage,
                                                              ICM_FORWARD,
                                                              NULL,NULL);

                                    if (bStatus)
                                    {
                                        if (pvBitsNew != NULL)
                                        {
                                            //
                                            // IcmTranslateDIB creates new bitmap buffer, then
                                            // free original buffer and set new one.
                                            //
                                            LOCALFREE(pvBits);
                                            pvBits = pvBitsNew;
                                        }

                                        if (pbmiDIBNew != NULL)
                                        {
                                            //
                                            // If bitmapInfo header is updated, use new one.
                                            // And, need to compute bitmap bits size based
                                            // on new bitmap header.
                                            //
                                            LOCALFREE(pbmiDIB);
                                            pbmiDIB = pbmiDIBNew;

                                            //
                                            // Calculate bitmap bits size based on BITMAPINFO and nNumScans
                                            //
                                            cjBits = cjBitmapBitsSize(pbmiDIB);
                                        }

                                        //
                                        // Set ICM-translated DIB into brush
                                        //
                                        bStatus = NtGdiIcmBrushInfo(hdc,
                                                                    hbrush,
                                                                    pbmiDIB,
                                                                    pvBits,
                                                                    &cjBits,
                                                                    NULL,
                                                                    NULL,
                                                                    IcmSetBrush);

                                        if (bStatus)
                                        {
                                            //
                                            // The color is translated.
                                            //
                                            bAlreadyTran = TRUE;
                                        }
                                        else
                                        {
                                            WARNING("IcmSelectBrush():NtGdiIcmBrushInfo(SET) Failed\n");
                                        }
                                    }
                                    else
                                    {
                                        WARNING("IcmSelectBrush():IcmTranslateDIB() Failed\n");
                                    }
                                }
                                else
                                {
                                    WARNING("IcmSelectBrush():NtGdiIcmBrushInfo(GET) Failed\n");
                                }

                                LOCALFREE(pvBits);
                            }
                            else
                            {
                                WARNING("IcmSelectBrush(): LOCALALLOC(pvBits) failed\n");
                            }
                        }

                        if (bAlreadyTran)
                        {
                            //
                            // Eventually, IcmBrushColor is initialized.
                            //
                            pdcattr->ulDirty_ |= ICM_BRUSH_TRANSLATED;
                        }
                    }
                    else
                    {
                        ICMWRN(("IcmSelectBrush(): Fail to get brush bitmap size or bitmap is DIB_PAL_COLORS\n"));
                    }

                    LOCALFREE(pbmiDIB);
                }
                else
                {
                    WARNING("IcmSelectBrush(): LOCALALLOC(pbmi) failed\n");
                }
            }
            else
            {
                ICMMSG(("IcmSelectBrush(): ICM will not done for this style - %d\n",lbrush.lbStyle));
            }
        }
        else
        {
            WARNING("IcmSelectBrush(): GetObject failed on hbrush\n");
            pdcattr->IcmBrushColor = CLR_INVALID;
        }
    }

    return (bStatus);
}

/******************************Public*Routine******************************\
* IcmSelectPen()
*
* History:
*
* Wrote it:
*  31-Jul-1996 -by- Mark Enstrom [marke]
\**************************************************************************/

HPEN
IcmSelectPen(
    HDC      hdc,
    PDC_ATTR pdcattr,
    HPEN     hpenNew
    )
{
    HPEN     hpenOld = pdcattr->hpen;

    ICMAPI(("gdi32: IcmSelectPen\n"));

    pdcattr->ulDirty_ |= DC_PEN_DIRTY;
    pdcattr->hpen = hpenNew;

    if (bNeedTranslateColor(pdcattr))
    {
        IcmTranslatePenColor(hdc,pdcattr,hpenNew);
    }

    return (hpenOld);
}

/******************************Public*Routine******************************\
* BOOL IcmTranslatePenColor(HDC hdc, PDC_ATTR pdcattr, HBRUSH hbrush)
*
* History:
*  10-Apr-1997 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

BOOL
IcmTranslatePenColor(
    HDC      hdc,
    PDC_ATTR pdcattr,
    HPEN     hpen
    )
{
    BOOL     bStatus = FALSE;
    COLORREF OldColor;
    COLORREF NewColor;
    PBRUSHATTR pbra;

    //
    // Invalidate PEN_TRANSLATED
    //
    pdcattr->ulDirty_ &= ~ICM_PEN_TRANSLATED;

    PSHARED_GET_VALIDATE(pbra,hpen,BRUSH_TYPE);

    if (pbra)
    {
        OldColor = pbra->lbColor;

        //
        // translate to new icm mode if not paletteindex
        //
        if (!(OldColor & 0x01000000))
        {
            bStatus = IcmTranslateCOLORREF(hdc,
                                           pdcattr,
                                           OldColor,
                                           &NewColor,
                                           ICM_FORWARD);

            if (bStatus)
            {
                pdcattr->IcmPenColor = NewColor;
            }
            else
            {
                pdcattr->IcmPenColor = OldColor;
            }
        }
        else
        {
            pdcattr->IcmPenColor = OldColor;
        }

        //
        // IcmPenColor is initialized.
        //
        pdcattr->ulDirty_ |= ICM_PEN_TRANSLATED;
    }
    else
    {
        LOGPEN logpen;

        //
        // stock brush or bitmap/hatch/dib brush
        //
        if(GetObjectW(hpen,sizeof(LOGPEN),&logpen))
        {
            if (logpen.lopnStyle != PS_NULL)
            {
                //
                // try to translate color
                //
                OldColor = logpen.lopnColor;

                if (!(OldColor & 0x01000000))
                {
                    bStatus = IcmTranslateCOLORREF(hdc,
                                                   pdcattr,
                                                   OldColor,
                                                   &NewColor,
                                                   ICM_FORWARD);

                    if (bStatus)
                    {
                        pdcattr->IcmPenColor = NewColor;
                    }
                    else
                    {
                        pdcattr->IcmPenColor = OldColor;
                    }
                }
                else
                {
                    pdcattr->IcmPenColor = OldColor;
                }

                //
                // IcmPenColor is initialized.
                //
                pdcattr->ulDirty_ |= ICM_PEN_TRANSLATED;
            }
            else
            {
                ICMMSG(("IcmSelectPen():Pen style is PS_NULL\n"));
                pdcattr->IcmPenColor = CLR_INVALID;
            }
        }
        else
        {
            WARNING("GetObject failed on hbrush\n");
            pdcattr->IcmPenColor = CLR_INVALID;
        }
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* IcmSelectExtPen()
*
* History:
*
* Wrote it:
*  11-Mar-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

HPEN
IcmSelectExtPen(
    HDC      hdc,
    PDC_ATTR pdcattr,
    HPEN     hpenNew
    )
{
    HPEN     hpenOld;

    ICMAPI(("gdi32: IcmSelectExtPen\n"));

    //
    // Invalidate PEN_TRANSLATED
    //
    pdcattr->ulDirty_ &= ~ICM_PEN_TRANSLATED;

    //
    // Call kernel to select this object.
    //
    hpenOld = NtGdiSelectPen(hdc,hpenNew);

    if (hpenOld && bNeedTranslateColor(pdcattr))
    {
        IcmTranslateExtPenColor(hdc,pdcattr,hpenNew);
    }

    return (hpenOld);
}

/******************************Public*Routine******************************\
* BOOL IcmTranslateExtPenColor(HDC hdc, PDC_ATTR pdcattr, HBRUSH hbrush)
*
* History:
*  10-Apr-1997 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

BOOL
IcmTranslateExtPenColor(
    HDC      hdc,
    PDC_ATTR pdcattr,
    HPEN     hpen
    )
{
    BOOL     bStatus = FALSE;
    COLORREF OldColor;
    COLORREF NewColor;

    EXTLOGPEN logpenLocal;
    EXTLOGPEN *plogpen = &logpenLocal;

    if (!GetObjectW(hpen,sizeof(EXTLOGPEN),plogpen))
    {
        ULONG cbNeeded;

        //
        // It might be PS_USERSTYLE (go slow way...)
        //
        cbNeeded = GetObjectW(hpen,0,NULL);

        if (cbNeeded)
        {
            plogpen = LOCALALLOC(cbNeeded);

            if (plogpen)
            {
                if (!GetObjectW(hpen,cbNeeded,plogpen))
                {
                    LOCALFREE(plogpen);
                    plogpen = NULL;
                }
            }
        }
        else
        {
            plogpen = NULL;
        }
    }

    if (plogpen)
    {
        if ((plogpen->elpBrushStyle == BS_SOLID) || (plogpen->elpBrushStyle == BS_HATCHED))
        {
            ICMMSG(("IcmSelectExtPen:BS_SOLID or BS_HATCHED\n"));

            //
            // try to translate color
            //
            OldColor = plogpen->elpColor;

            if (!(OldColor & 0x01000000))
            {
                bStatus = IcmTranslateCOLORREF(hdc,
                                               pdcattr,
                                               OldColor,
                                               &NewColor,
                                               ICM_FORWARD);

                if (bStatus)
                {
                    pdcattr->IcmPenColor = NewColor;
                }
                else
                {
                    pdcattr->IcmPenColor = OldColor;
                }
            }
            else
            {
                pdcattr->IcmPenColor = OldColor;
            }

            //
            // Somehow, IcmPenColor is initialized.
            //
            pdcattr->ulDirty_ |= ICM_PEN_TRANSLATED;
        }
        else if ((plogpen->elpBrushStyle == BS_DIBPATTERN) || (plogpen->elpBrushStyle == BS_DIBPATTERNPT))
        {
            PBITMAPINFO pbmiDIB;

            ICMMSG(("IcmSelectExtPen:BS_DIBPATTERN or BS_DIBPATTERNPT\n"));

            //
            // Allocate temorary bitmap info header to get brush bitmap
            //
            pbmiDIB = (PBITMAPINFO)LOCALALLOC(sizeof(BITMAPINFO)+((256-1)*sizeof(RGBQUAD)));

            if (pbmiDIB)
            {
                ULONG iColorUsage;
                BOOL  bAlreadyTran;

                PVOID pvBits = NULL;
                ULONG cjBits = 0;

                //
                // Get brush bitmap information, colortype, size, etc.
                //
                bStatus = NtGdiIcmBrushInfo(hdc,
                                            (HBRUSH)hpen,
                                            pbmiDIB,
                                            pvBits,
                                            &cjBits,
                                            &iColorUsage,
                                            &bAlreadyTran,
                                            IcmQueryBrush);

                if (bStatus)
                {
                    if ((iColorUsage == DIB_RGB_COLORS) &&
                        (!bAlreadyTran) &&
                        (cjBits))
                    {
                        pvBits = (PVOID) LOCALALLOC(cjBits);

                        if (pvBits)
                        {
                            //
                            // Get brush bitmap bits.
                            //
                            bStatus = NtGdiIcmBrushInfo(hdc,
                                                        (HBRUSH)hpen,
                                                        pbmiDIB,
                                                        pvBits,
                                                        &cjBits,
                                                        NULL,
                                                        NULL,
                                                        IcmQueryBrush);

                            if (bStatus)
                            {
                                //
                                // must make a copy of the DIB data
                                //
                                DWORD dwNumScan = ABS(pbmiDIB->bmiHeader.biHeight);
                                ULONG nColors   = pbmiDIB->bmiHeader.biWidth *
                                                  dwNumScan * (pbmiDIB->bmiHeader.biBitCount/8);

                                //
                                // IcmTranslateDIB may create new copy of bitmap bits and/or
                                // bitmap info header, if nessesary.
                                //
                                PVOID       pvBitsNew = NULL;
                                PBITMAPINFO pbmiDIBNew = NULL;

                                bStatus = IcmTranslateDIB(hdc,
                                                          pdcattr,
                                                          nColors,
                                                          pvBits,
                                                          &pvBitsNew,
                                                          pbmiDIB,
                                                          &pbmiDIBNew,
                                                          NULL,
                                                          dwNumScan,
                                                          iColorUsage,
                                                          ICM_FORWARD,
                                                          NULL,NULL);

                                if (bStatus)
                                {
                                    if (pvBitsNew != NULL)
                                    {
                                        //
                                        // IcmTranslateDIB creates new bitmap buffer, then
                                        // free original buffer and set new one.
                                        //
                                        LOCALFREE(pvBits);
                                        pvBits = pvBitsNew;
                                    }

                                    if (pbmiDIBNew != NULL)
                                    {
                                        //
                                        // If bitmapInfo header is updated, use new one.
                                        // And, need to compute bitmap bits size based
                                        // on new bitmap header.
                                        //
                                        LOCALFREE(pbmiDIB);
                                        pbmiDIB = pbmiDIBNew;

                                        //
                                        // Calculate bitmap bits size based on BITMAPINFO and nNumScans
                                        //
                                        cjBits = cjBitmapBitsSize(pbmiDIB);
                                    }

                                    //
                                    // Set ICM-translated DIB into brush
                                    //
                                    bStatus = NtGdiIcmBrushInfo(hdc,
                                                                (HBRUSH)hpen,
                                                                pbmiDIB,
                                                                pvBits,
                                                                &cjBits,
                                                                NULL,
                                                                NULL,
                                                                IcmSetBrush);

                                    if (bStatus)
                                    {
                                        //
                                        // Translated.
                                        //
                                        bAlreadyTran = TRUE;
                                    }
                                    else
                                    {
                                        WARNING("IcmSelectExtPen():NtGdiIcmBrushInfo(SET) Failed\n");
                                    }
                                }
                                else
                                {
                                    WARNING("IcmSelectBrush():IcmTranslateDIB() Failed\n");
                                }
                            }
                            else
                            {
                                WARNING("IcmSelectExtPen():NtGdiIcmBrushInfo(GET) Failed\n");
                            }

                            LOCALFREE(pvBits);
                        }
                        else
                        {
                            WARNING("IcmSelectExtPen(): LOCALALLOC(pvBits) failed\n");
                        }
                    }

                    if (bAlreadyTran)
                    {
                        //
                        // Eventually, IcmPenColor is initialized.
                        //
                        pdcattr->ulDirty_ |= ICM_PEN_TRANSLATED;
                    }
                }
                else
                {
                    ICMWRN(("IcmSelectBrush(): Fail to get brush bitmap size or bitmap is DIB_PAL_COLORS\n"));
                }

                LOCALFREE(pbmiDIB);
            }
            else
            {
                WARNING("IcmSelectExtPen(): LOCALALLOC(pbmi) failed\n");
            }
        }
        else
        {
        #if DBG_ICM
            DbgPrint("IcmSelectExtPen:ICM does not support this style (%d), yet\n",plogpen->elpBrushStyle);
        #endif
        }

        if (plogpen != &logpenLocal)
        {
            LOCALFREE(plogpen);
        }
    }
    else
    {
        WARNING("IcmSelectExtPen():GetObjectW() failed on hextpen\n");
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* IcmGetProfileColorFormat()
*
* History:
*
* Write it:
*   12-Feb-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BMFORMAT
IcmGetProfileColorFormat(
    HPROFILE   hProfile
    )
{
    //
    // defaut is RGB
    //
    ULONG ColorFormat = BM_xBGRQUADS;

    PROFILEHEADER ProfileHeader;

    ICMAPI(("gdi32: IcmGetProfileColorFormat\n"));

    //
    // Get profile header information.
    //
    if (((*fpGetColorProfileHeader)(hProfile,&ProfileHeader)))
    {
        DWORD ColorSpace;

        //
        // Yes, we succeed to get profile header.
        //
        ColorSpace = ProfileHeader.phDataColorSpace;

        //
        // Figure out color format from color space.
        //
        switch (ColorSpace)
        {
        case SPACE_CMYK:

            ICMMSG(("IcmGetProfileColorFormat(): CMYK Color Space\n"));

            //
            // Output format is CMYK color.
            //
            ColorFormat = BM_KYMCQUADS;
            break;

        case SPACE_RGB:

            ICMMSG(("IcmGetProfileColorFormat(): RGB Color Space\n"));

            //
            // Output format is same as COLORREF (0x00bbggrr)
            //
            ColorFormat = BM_xBGRQUADS;
            break;

        default:

            WARNING("IcmGetProfileColorFormat(): Unknown color space\n");

            ColorFormat = 0xFFFFFFFF;
            break;
        }
    }

    return (ColorFormat);
}

/******************************Public*Routine******************************\
* IcmEnumColorProfile()
*
* History:
*
* Write it:
*   12-Feb-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

int
IcmEnumColorProfile(
    HDC       hdc,
    PVOID     pvCallBack,
    LPARAM    lParam,
    BOOL      bAnsiCallBack,
    PDEVMODEW pDevModeW,
    DWORD    *pdwColorSpaceFlag
    )
{
    int       iRet        = -1; // -1 means fail.
    int       iRetFromCMS = -1;

    BYTE      StackDeviceData[MAX_PATH*2*sizeof(WCHAR)];
    WCHAR     StackProfileData[MAX_PATH];
    WCHAR     StackTempBuffer[MAX_PATH];
    CHAR      StackTempBufferA[MAX_PATH];

    PVOID     pvFree = NULL;

    PWSTR     ProfileNames = StackProfileData;
    DWORD     cjAllocate = 0;

    LPWSTR    pDeviceName = NULL;
    DWORD     dwDeviceClass = 0L;

    PLDC      pldc = NULL;

    DWORD     bDontAskDriver = FALSE;
    DWORD     dwSize;

    ICMAPI(("gdi32: IcmEnumColorProfile\n"));

    //
    // Load external ICM dlls
    //
    LOAD_ICMDLL(iRet);

    //
    // Try to identify device name, class and devmode (if hdc is given)
    //
    if (hdc)
    {
        pldc = GET_PLDC(hdc);

        if (pldc && pldc->hSpooler)
        {
            DWORD cbFilled;

            //
            // This is printer.
            //
            dwDeviceClass = CLASS_PRINTER;

            //
            // Get current DEVMODE for printer (if devmode is not given)
            //
            if (!pDevModeW)
            {
                if (pldc->pDevMode)
                {
                    ICMMSG(("IcmEnumColorProfile():Cached DEVMODE used\n"));

                    pDevModeW = pldc->pDevMode;
                }
                else
                {
                    ICMMSG(("IcmEnumColorProfile():Get default DEVMODE\n"));

                    //
                    // UNDER_CONSTRUCTION: NEED TO USE CURRENT DEVMODE, NOT DEFAULT DEVMODE.
                    //
                    pDevModeW = pdmwGetDefaultDevMode(pldc->hSpooler,NULL,&pvFree);
                }
            }

            //
            // Get printer device name, Try level 1 information.
            //
            if ((*fpGetPrinterW)(pldc->hSpooler,1,
                                 (BYTE *) &StackDeviceData,sizeof(StackDeviceData),
                                 &cbFilled))
            {
                PRINTER_INFO_1W *pPrinterInfo1 = (PRINTER_INFO_1W *) &StackDeviceData;

                //
                // Device name is in there.
                //
                pDeviceName = pPrinterInfo1->pName;
            }
            else
            {
                ICMMSG(("IcmEnumColorProfile():FAILED on GetPrinterW(INFO_1) - %d\n",GetLastError()));

                //
                // Failed on GetPrinter, So get device name from DEVMODE
                // (this will be limited to 32 character, but better than nothing.)
                //
                if (pDevModeW)
                {
                    pDeviceName = pDevModeW->dmDeviceName;
                }
            }

            //
            // Get configuration about we need to ask driver for profile or not.
            //
            dwSize = sizeof(DWORD);

            if ((*fpInternalGetDeviceConfig)(pDeviceName, CLASS_PRINTER, MSCMS_PROFILE_ENUM_MODE,
                                             &bDontAskDriver, &dwSize))
            {
                ICMMSG(("IcmEnumColorProfile():EnumMode = %d\n",bDontAskDriver));
            }
            else
            {
                bDontAskDriver = FALSE; // if error, set back as default.
            }
        }
        else if (GetDeviceCaps(hdc,TECHNOLOGY) == DT_RASDISPLAY)
        {
            //
            // This is display.
            //
            dwDeviceClass = CLASS_MONITOR;

            //
            // Get monitor name for this DC.
            //
            if (NtGdiGetMonitorID(hdc,sizeof(StackDeviceData), (LPWSTR) StackDeviceData))
            {
                pDeviceName = (LPWSTR) StackDeviceData;
            }
            else
            {
                WARNING("NtGdiGetMonitorID failed, use hardcoded data\n");

                //
                // If failed, use "DISPLAY"
                //
                pDeviceName = L"DISPLAY";
            }
        }
    }
    else if (pDevModeW)
    {
        pDeviceName = pDevModeW->dmDeviceName;
    }

    if (pDeviceName)
    {
        ICMMSG(("IcmEnumColorProfile() DeviceName = %ws\n",pDeviceName));
    }

    //
    // If we have devmode, call printer driver UI first to obtain color profile.
    //
    if (pDevModeW &&               /* devmode should be given      */
        pdwColorSpaceFlag &&       /* no query context             */
        pldc && pldc->hSpooler &&  /* only for printer driver      */
        !bDontAskDriver)           /* only when we need ask driver */
    {
        //
        // Ask (Printer UI) driver for default device color profile
        //
        iRetFromCMS = IcmAskDriverForColorProfile(pldc,QCP_DEVICEPROFILE,
                                                  pDevModeW,ProfileNames,pdwColorSpaceFlag);

        //
        // if iRet is greater then 0, driver have paticular color profile to use.
        //
        if (iRetFromCMS > 0)
        {
            if (pvCallBack)
            {
                //
                // Build ICM profile file path.
                //
                BuildIcmProfilePath(ProfileNames,StackTempBuffer,MAX_PATH);

                if (bAnsiCallBack)
                {
                    bToASCII_N(StackTempBufferA,MAX_PATH,
                               StackTempBuffer, wcslen(StackTempBuffer)+1);

                    //
                    // Callback application.
                    //
                    iRet = (*(ICMENUMPROCA)pvCallBack)(StackTempBufferA,lParam);
                }
                else
                {
                    iRet = (*(ICMENUMPROCW)pvCallBack)(StackTempBuffer,lParam);
                }

                if (iRet > 0)
                {
                    //
                    // If iRet is positive value, continue to enumeration.
                    //
                    iRetFromCMS = -1;
                }
            }
            else
            {
                //
                // There is no call back function, just use return value from CMS.
                //
                iRet = iRetFromCMS;
            }
        }
        else
        {
            iRetFromCMS = -1;
        }
    }

    if (iRetFromCMS == -1)
    {
        ENUMTYPEW EnumType;

        //
        // Initialize with zero.
        //
        RtlZeroMemory(&EnumType,sizeof(ENUMTYPEW));

        //
        // Fill up EnumType structure
        //
        EnumType.dwSize = sizeof(ENUMTYPEW);
        EnumType.dwVersion = ENUM_TYPE_VERSION;

        //
        // If device name is given use it, otherwise get it from DEVMODE.
        //
        if (pDeviceName)
        {
            EnumType.dwFields |= ET_DEVICENAME;
            EnumType.pDeviceName = pDeviceName;
        }

        //
        // Set DeviceClass (if hdc is given)
        //
        if (dwDeviceClass)
        {
            EnumType.dwFields |= ET_DEVICECLASS;
            EnumType.dwDeviceClass = dwDeviceClass;
        }

        //
        // Pick up any additional info from devmode (if we have)
        //
        if (pDevModeW)
        {
            //
            // Set MediaType is presented.
            //
            if (pDevModeW->dmFields & DM_MEDIATYPE)
            {
                EnumType.dwFields |= ET_MEDIATYPE;
                EnumType.dwMediaType = pDevModeW->dmMediaType;
            }

            if (pDevModeW->dmFields & DM_DITHERTYPE)
            {
                EnumType.dwFields |= ET_DITHERMODE;
                EnumType.dwDitheringMode = pDevModeW->dmDitherType;
            }

            if ((pDevModeW->dmFields & DM_PRINTQUALITY) &&
                (pDevModeW->dmPrintQuality >= 0))
            {
                EnumType.dwFields |= ET_RESOLUTION;
                EnumType.dwResolution[0] = pDevModeW->dmPrintQuality;

                if (pDevModeW->dmFields & DM_YRESOLUTION)
                {
                    EnumType.dwResolution[1] = pDevModeW->dmYResolution;
                }
                else
                {
                    EnumType.dwResolution[1] = pDevModeW->dmPrintQuality;
                }

                ICMMSG(("Resolution in devmode (%d,%d)\n",
                         EnumType.dwResolution[0],EnumType.dwResolution[1]));
            }
        }

        //
        // Figure out how much memory we need.
        //
        iRetFromCMS = (*fpEnumColorProfilesW)(NULL,&EnumType,NULL,&cjAllocate,NULL);

        //
        // Buffer should be requested ,at least, more then 2 unicode-null.
        //
        if (cjAllocate > (sizeof(UNICODE_NULL) * 2))
        {
            //
            // If the buffer on stack is not enough, allocate it.
            //
            if (cjAllocate > sizeof(StackProfileData))
            {
                //
                // Allocate buffer to recieve data.
                //
                ProfileNames = LOCALALLOC(cjAllocate);

                if (ProfileNames == NULL)
                {
                    GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    goto IcmEnumColorProfile_Cleanup;
                }
            }

            //
            // Enumurate profiles
            //
            iRetFromCMS = (*fpEnumColorProfilesW)(NULL,&EnumType,(PBYTE)ProfileNames,&cjAllocate,NULL);

            if (iRetFromCMS == 0)
            {
                //
                // There is no profile enumulated.
                //
                goto IcmEnumColorProfile_Cleanup;
            }

            if (pvCallBack)
            {
                PWSTR pwstr;

                //
                // Callback for each file.
                //
                pwstr = ProfileNames;

                while(*pwstr)
                {
                    //
                    // Build ICM profile file path.
                    //
                    BuildIcmProfilePath(pwstr,StackTempBuffer,MAX_PATH);

                    if (bAnsiCallBack)
                    {
                        bToASCII_N(StackTempBufferA,MAX_PATH,
                                   StackTempBuffer, wcslen(StackTempBuffer)+1);

                        //
                        // Callback application.
                        //
                        iRet = (*(ICMENUMPROCA)pvCallBack)(StackTempBufferA,lParam);
                    }
                    else
                    {
                        iRet = (*(ICMENUMPROCW)pvCallBack)(StackTempBuffer,lParam);
                    }

                    if (iRet == 0)
                    {
                        //
                        // Stop enumlation.
                        //
                        break;
                    }

                    //
                    // Move pointer to next.
                    //
                    pwstr += (wcslen(pwstr)+1);
                }
            }
            else
            {
                //
                // There is no call back function, just use return value from CMS.
                //
                iRet = iRetFromCMS;
            }
        }

IcmEnumColorProfile_Cleanup:

        if (ProfileNames && (ProfileNames != StackProfileData))
        {
            LOCALFREE(ProfileNames);
        }
    }

    //
    // Free devmode buffer.
    //
    if (pvFree)
    {
        LOCALFREE(pvFree);
    }

    return (iRet);
}

/******************************Public*Routine******************************\
* IcmQueryProfileCallBack()
*
* History:
*
* Write it:
*   19-Feb-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

int CALLBACK
IcmQueryProfileCallBack(
    LPWSTR lpFileName,
    LPARAM lAppData
)
{
    PROFILECALLBACK_DATA *ProfileCallBack = (PROFILECALLBACK_DATA *)lAppData;

    if (lpFileName)
    {
        PWSZ FileNameOnly = GetFileNameFromPath(lpFileName);

        if (_wcsicmp(ProfileCallBack->pwszFileName,FileNameOnly) == 0)
        {
            //
            // Yes, found it.
            //
            ProfileCallBack->bFound = TRUE;

            //
            // stop enumuration.
            //
            return (0);
        }
    }

    //
    // Continue to enumuration.
    //
    return (1);
}

/******************************Public*Routine******************************\
* IcmFindProfileCallBack()
*
* History:
*
* Write it:
*   19-Feb-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

int CALLBACK
IcmFindProfileCallBack(
    LPWSTR lpFileName,
    LPARAM lAppData
)
{
    //
    // OK, just pick up first enumuration.
    //
    lstrcpyW((PWSZ)lAppData,lpFileName);

    //
    // And then stop enumuration.
    //
    return (0);
}

/******************************Public*Routine******************************\
* GetFileNameFromPath()
*
* History:
*
* Write it:
*   19-Feb-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

PWSTR
GetFileNameFromPath(
    PWSTR pwszFileName
)
{
    PWSTR FileNameOnly = NULL;

    //
    // Check for: C:\PathName\Profile.icm
    //
    FileNameOnly = wcsrchr(pwszFileName,L'\\');

    if (FileNameOnly != NULL)
    {
        FileNameOnly++;  // Skip '\\'
    }
    else
    {
        //
        // For: C:Profile.icm
        //
        FileNameOnly = wcschr(pwszFileName,L':');

        if (FileNameOnly != NULL)
        {
            FileNameOnly++;  // Skip ':'
        }
        else
        {
            //
            // Otherwise Profile.icm
            //
            FileNameOnly = pwszFileName;
        }
    }

    return (FileNameOnly);
}

/******************************Public*Routine******************************\
* IcmCreateProfileFromLCS()
*
* History:
*
* Write it:
*   19-Feb-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
IcmCreateProfileFromLCS(
    LPLOGCOLORSPACEW  lpLogColorSpaceW,
    PVOID            *ppvProfileData,
    PULONG            pulProfileSize
)
{
    BOOL bRet;

    ICMAPI(("gdi32: IcmCreateProfileFromLCS\n"));

    //
    // Call MSCMS.DLL to create Profile from LOGCOLORSPACE
    //
    bRet = (*fpCreateProfileFromLogColorSpaceW)(lpLogColorSpaceW,
                                                (PBYTE *)ppvProfileData);

    if (bRet && *ppvProfileData)
    {
        *pulProfileSize = (ULONG)GlobalSize(*ppvProfileData);
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* BuildIcmProfilePath()
*
* History:
*
* Write it:
*   07-Apr-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

PWSZ
BuildIcmProfilePath(
    PWSZ  FileName,         // IN
    PWSZ  FullPathFileName, // OUT
    ULONG BufferSize
)
{
    PWSZ FileNameOnly;

    //
    // BufferSize - need to be used for overrap check sometime later...
    //

    FileNameOnly = GetFileNameFromPath(FileName);

    if (FileName == FileNameOnly)
    {
        // It seems we don't have any specified path, just use color directory.
        
        const UINT c_cBufChars = MAX_PATH;
        
        // Use a temporary because FileName and FullPathFileName can be the same
        // and wcsncpy doesn't like that.
        
        WCHAR awchTemp[MAX_PATH];
        
        int count = c_cBufChars;
        
        // Copy color directory first, then filename
        
        // wcsncpy does not append a NULL if the count is smaller than the
        // string. Do it manually so that wcsncat and wcslen work.
        
        wcsncpy(awchTemp, ColorDirectory, count);
        awchTemp[c_cBufChars-1] = 0;
        
        // Leave space for the NULL terminator. Note, because we append a
        // NULL terminator above, wcslen cannot return a number bigger than
        // BufferSize-1. Therefore the resulting count cannot be negative.
        
        count = c_cBufChars-wcslen(awchTemp)-1;
        ASSERT(count>=0);
        
        wcsncat(awchTemp,L"\\",count);
        
        // leave space for the NULL
        
        count = c_cBufChars-wcslen(awchTemp)-1;
        ASSERT(count>=0);
        
        wcsncat(awchTemp, FileNameOnly, count);
        
        // copy to the final destination and force NULL termination.
        
        wcsncpy(FullPathFileName, awchTemp, BufferSize);
        FullPathFileName[BufferSize-1] = 0;
    }
    else
    {
        //
        // Input path contains path, just use that.
        //
        if (FileName != FullPathFileName)
        {
            //
            // Source and destination buffer is different, need to copy.
            //
            wcsncpy(FullPathFileName,FileName,BufferSize);
            FullPathFileName[BufferSize-1] = 0;
        }
    }

    return (FileNameOnly);
}

/******************************Public*Routine******************************\
* IcmSameColorSpace()
*
* History:
*
* Write it:
*   21-Apr-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
IcmSameColorSpace(
    PCACHED_COLORSPACE pColorSpaceA,
    PCACHED_COLORSPACE pColorSpaceB
)
{
    ICMAPI(("gdi32: IcmSameColorSpace\n"));

    if (pColorSpaceA == pColorSpaceB)
    {
        ICMMSG(("IcmSameColorSpace - Yes\n"));
        return (TRUE);
    }
    else
    {
        ICMMSG(("IcmSameColorSpace - No\n"));
        return (FALSE);
    }
}

/******************************Public*Routine******************************\
* IcmGetColorSpaceByColorSpace()
*
* History:
*
* Write it:
*   21-Apr-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

PCACHED_COLORSPACE
IcmGetColorSpaceByColorSpace(
    HGDIOBJ          hObjRequest,
    LPLOGCOLORSPACEW lpLogColorSpace,
    PPROFILE         pColorProfile,
    DWORD            dwColorSpaceFlags
)
{
    PCACHED_COLORSPACE pCandidateColorSpace = NULL;
    PWSZ pProfileName;
    BOOL bNeedMatchHdc = FALSE;

    PLIST_ENTRY p;

    ICMAPI(("gdi32: IcmGetColorSpaceByColorSpace\n"));

    //
    // If this is "on memory" profile which size is larger than
    // maximum size of cachable profile withOUT filename,
    // don't search cache, since we never be able to find from cache.
    //
    if (pColorProfile &&
        (pColorProfile->dwType == PROFILE_MEMBUFFER) &&
        (pColorProfile->cbDataSize > MAX_SIZE_OF_COLORPROFILE_TO_CACHE) &&
        (lpLogColorSpace->lcsFilename[0] == UNICODE_NULL))
    {
        return (NULL);
    }

    //
    // If this is metafile color space, must match hdc.
    //
    if (GET_COLORSPACE_TYPE(dwColorSpaceFlags) == GET_COLORSPACE_TYPE(METAFILE_COLORSPACE))
    {
        bNeedMatchHdc = TRUE;
    }

    pProfileName = lpLogColorSpace->lcsFilename;

    //
    // Search from cache.
    //
    ENTERCRITICALSECTION(&semColorSpaceCache);

    p = ListCachedColorSpace.Flink;

    while(p != &ListCachedColorSpace)
    {
        pCandidateColorSpace = CONTAINING_RECORD(p,CACHED_COLORSPACE,ListEntry);

        //
        // If this colorspace depends on specific gdi object, check it.
        //
        if (/* hdc is match */
            (pCandidateColorSpace->hObj == hObjRequest) ||
            /* candidate is not specific to hdc, and does not need to match hdc */
            ((bNeedMatchHdc == FALSE) && (pCandidateColorSpace->hObj == NULL)))
        {
            LOGCOLORSPACEW *pCandidateLogColorSpace;
            PWSZ            pCandidateProfileName;

            //
            // Get pointer to profile
            //
            pCandidateLogColorSpace = &(pCandidateColorSpace->LogColorSpace);
            pCandidateProfileName = pCandidateColorSpace->LogColorSpace.lcsFilename;

            //
            // Check lcsIntent.
            //
            if (pCandidateLogColorSpace->lcsIntent == lpLogColorSpace->lcsIntent)
            {
                //
                // Check profile name if given
                //
                if (*pProfileName && *pCandidateProfileName)
                {
                    if (_wcsicmp(pProfileName,pCandidateProfileName) == 0)
                    {
                        ICMMSG(("IcmGetColorSpaceByColorSpace():Find in cache (by profile name)\n"));

                        //
                        // Find it ! then Increment ref. counter
                        //
                        pCandidateColorSpace->cRef++;

                        break;
                    }
                }
                else if ((*pProfileName == UNICODE_NULL) && (*pCandidateProfileName == UNICODE_NULL))
                {
                    if (pColorProfile == NULL)
                    {
                        //
                        // Both of color space does not have color profile, check inside LOGCOLORSPACE.
                        //
                        if ((pCandidateLogColorSpace->lcsCSType == lpLogColorSpace->lcsCSType) &&
                            (pCandidateLogColorSpace->lcsGammaRed == lpLogColorSpace->lcsGammaRed) &&
                            (pCandidateLogColorSpace->lcsGammaGreen == lpLogColorSpace->lcsGammaGreen) &&
                            (pCandidateLogColorSpace->lcsGammaBlue == lpLogColorSpace->lcsGammaBlue) &&
                            (RtlCompareMemory(&(pCandidateLogColorSpace->lcsEndpoints),
                                          &(lpLogColorSpace->lcsEndpoints),sizeof(CIEXYZTRIPLE))
                                                                        == sizeof(CIEXYZTRIPLE)))
                        {
                            ICMMSG(("IcmGetColorSpaceByColorSpace():Find in cache (by metrics)\n"));

                            //
                            // Find it ! then Increment ref. counter
                            //
                            pCandidateColorSpace->cRef++;

                            break;
                        }
                    }
                    else if ((pColorProfile->dwType == PROFILE_MEMBUFFER) &&
                             (pCandidateColorSpace->ColorProfile.dwType == PROFILE_MEMBUFFER))
                    {
                        if (pCandidateColorSpace->ColorProfile.cbDataSize == pColorProfile->cbDataSize)
                        {
                            if (RtlCompareMemory(pCandidateColorSpace->ColorProfile.pProfileData,
                                                 pColorProfile->pProfileData,
                                                 pColorProfile->cbDataSize)
                                              == pColorProfile->cbDataSize)
                            {
                                ICMMSG(("IcmGetColorSpaceByColorSpace():Find in cache (by on memory profile)\n"));

                                //
                                // Find it ! then Increment ref. counter
                                //
                                pCandidateColorSpace->cRef++;

                                break;
                            }
                        }
                    }
                }
            }
        }

        p = p->Flink;
        pCandidateColorSpace = NULL;
    }

    LEAVECRITICALSECTION(&semColorSpaceCache);

    return (pCandidateColorSpace);
}

/******************************Public*Routine******************************\
* IcmGetColorSpaceByHandle()
*
* History:
*
* Write it:
*   21-Apr-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

PCACHED_COLORSPACE
IcmGetColorSpaceByHandle(
    HGDIOBJ          hObj,
    HCOLORSPACE      hColorSpace,
    LPLOGCOLORSPACEW lpLogColorSpace,
    DWORD            dwFlags
)
{
    ULONG cRet;

    ICMAPI(("gdi32: IcmGetColorSpaceByHandle\n"));

    //
    // Get LOGCOLORSPACE from handle
    //
    cRet = NtGdiExtGetObjectW(hColorSpace,sizeof(LOGCOLORSPACEW),lpLogColorSpace);

    if (cRet >= sizeof(LOGCOLORSPACEW))
    {
        if (lpLogColorSpace->lcsFilename[0] != UNICODE_NULL)
        {
            //
            // Normalize filename
            //
            BuildIcmProfilePath(lpLogColorSpace->lcsFilename,lpLogColorSpace->lcsFilename,MAX_PATH);
        }
        else
        {
            if (lpLogColorSpace->lcsCSType != LCS_CALIBRATED_RGB)
            {
                ULONG ulSize = MAX_PATH;

                //
                // if CSType is not LCS_CALIBRATED_RGB, we should go to MSCMS.DLL
                // to get color profile for corresponding LCSType, then any given
                // profile name from application is IGNORED.
                //
                if ((*fpGetStandardColorSpaceProfileW)(
                       NULL,
                       lpLogColorSpace->lcsCSType,
                       lpLogColorSpace->lcsFilename,
                       &ulSize))
                {
                    ICMMSG(("IcmGetColorSpaceByHandle():CSType %x = %ws\n",
                                          lpLogColorSpace->lcsCSType,
                                          lpLogColorSpace->lcsFilename));
                }
                else
                {
                    ICMWRN(("IcmGetColorSpaceByHandle():Error CSType = %x\n",
                                          lpLogColorSpace->lcsCSType));
                    return (NULL);
                }
            }
        }

        //
        // Find it !
        //
        return (IcmGetColorSpaceByColorSpace(hObj,lpLogColorSpace,NULL,dwFlags));
    }
    else
    {
        ICMWRN(("IcmGetColorSpaceByHandle():Failed on GetObject\n"));
        return (NULL);
    }
}

/******************************Public*Routine******************************\
* IcmGetColorSpaceByName()
*
* History:
*
* Write it:
*   21-Apr-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

PCACHED_COLORSPACE
IcmGetColorSpaceByName(
    HGDIOBJ hObj,
    PWSZ    ColorProfileName,
    DWORD   dwIntent,
    DWORD   dwFlags
)
{
    ICMAPI(("gdi32: IcmGetColorSpaceByName (%ws)\n",(ColorProfileName ? ColorProfileName : L"null")));

    if (ColorProfileName)
    {
        LOGCOLORSPACEW LogColorSpace;

        RtlZeroMemory(&LogColorSpace,sizeof(LOGCOLORSPACEW));

        //
        // Put intent in LOGCOLORSPACE
        //
        LogColorSpace.lcsIntent = (LCSGAMUTMATCH) dwIntent;

        //
        // Normalize path name
        //
        BuildIcmProfilePath(ColorProfileName,LogColorSpace.lcsFilename,MAX_PATH);

        //
        // Find it !
        //
        return (IcmGetColorSpaceByColorSpace(hObj,&LogColorSpace,NULL,dwFlags));
    }
    else
    {
        return (NULL);
    }
}

/******************************Public*Routine******************************\
* IcmCreateColorSpaceByName()
*
* History:
*
* Write it:
*   21-Apr-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

PCACHED_COLORSPACE
IcmCreateColorSpaceByName(
    HGDIOBJ hObj,
    PWSZ    ColorProfileName,
    DWORD   dwIntent,
    DWORD   dwFlags
)
{
    LOGCOLORSPACEW LogColorSpace;

    ICMAPI(("gdi32: IcmCreateColorSpaceByName\n"));

    RtlZeroMemory(&LogColorSpace,sizeof(LOGCOLORSPACEW));

    //
    // Fill up LOGCOLORSPACE fields.
    //
    LogColorSpace.lcsSignature = LCS_SIGNATURE;
    LogColorSpace.lcsVersion   = 0x400;
    LogColorSpace.lcsSize      = sizeof(LOGCOLORSPACEW);
    LogColorSpace.lcsCSType    = LCS_CALIBRATED_RGB;
    LogColorSpace.lcsIntent    = (LCSGAMUTMATCH) dwIntent;

    //
    // Put profile file name in lcsFilename[]
    //
    lstrcpyW(LogColorSpace.lcsFilename,ColorProfileName);

    //
    // Create colorspace with LOGCOLORSPACE
    //
    return (IcmCreateColorSpaceByColorSpace(hObj,&LogColorSpace,NULL,dwFlags));
}

/******************************Public*Routine******************************\
* IcmCreateColorSpaceByColorSpace()
*
* History:
*
* Write it:
*   21-Apr-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

PCACHED_COLORSPACE
IcmCreateColorSpaceByColorSpace(
    HGDIOBJ          hObj,
    LPLOGCOLORSPACEW lpLogColorSpace,
    PPROFILE         pProfileData,
    DWORD            dwFlags
)
{
    PCACHED_COLORSPACE pColorSpace = NULL;

    ICMAPI(("gdi32: IcmCreateColorSpaceByColorSpace\n"));

    if (lpLogColorSpace)
    {
        //
        // If ICMDLL is not loaded, yet, Just Load ICMDLL regardless current ICM mode,
        // since we need it for handle this color profile. And apps can enable ICM
        // later at that time, the opened color profile mighted be used.
        //
        if ((ghICM == NULL) && (!IcmInitialize()))
        {
            ICMWRN(("IcmCreateColorSpace():Fail to load ICM dlls\n"));
            return (NULL);
        }

        //
        // Allocate CACHED_COLORSPACE
        //
        pColorSpace = LOCALALLOC(sizeof(CACHED_COLORSPACE));

        if (pColorSpace)
        {
            //
            // Zero init CACHED_COLORSPACE
            //
            RtlZeroMemory(pColorSpace,sizeof(CACHED_COLORSPACE));

            //
            // Copy LOGCOLORSPACE into CACHED_COLORSPACE
            //
            RtlCopyMemory(&(pColorSpace->LogColorSpace),lpLogColorSpace,sizeof(LOGCOLORSPACEW));

            //
            // Default colorspace is RGB (BGR = 0x00bbggrr same as COLORREF format)
            //
            pColorSpace->ColorFormat = BM_xBGRQUADS;

            //
            // Map intent value for MSCMS from LOGCOLORSPACE.
            //
            switch (lpLogColorSpace->lcsIntent)
            {
            case LCS_GM_BUSINESS:
                pColorSpace->ColorIntent = INTENT_SATURATION;
                break;

            case LCS_GM_GRAPHICS:
                pColorSpace->ColorIntent = INTENT_RELATIVE_COLORIMETRIC;
                break;

            case LCS_GM_IMAGES:
                pColorSpace->ColorIntent = INTENT_PERCEPTUAL;
                break;

            case LCS_GM_ABS_COLORIMETRIC:
                pColorSpace->ColorIntent = INTENT_ABSOLUTE_COLORIMETRIC;
                break;

            default:
                ICMWRN(("IcmCreateColorSpace():Invalid intent value\n"));
                LOCALFREE(pColorSpace);
                return (NULL);
            }

            //
            // Keep flags
            //
            pColorSpace->flInfo = dwFlags;

            //
            // if the color space is specific to some GDI object, keep its handle.
            //
            // for DIBSECTION_COLORSPACE, CreateDIBSection calls us this hdc in hObj,
            // then later overwrite hObj with thier bitmap handle. this prevent from
            // this color space is shared with others.
            //
            if (dwFlags & HGDIOBJ_SPECIFIC_COLORSPACE)
            {
                pColorSpace->hObj = hObj;
            }

            //
            // If this is not LCS_CALIBRATED_RGB, get color profile name.
            //
            if (lpLogColorSpace->lcsCSType != LCS_CALIBRATED_RGB)
            {
                ULONG ulSize = MAX_PATH;

                //
                // if CSType is not LCS_CALIBRATED_RGB, we should go to MSCMS.DLL
                // to get color profile for corresponding LCSType, then any given
                // profile name from application is IGNORED.
                //
                if ((*fpGetStandardColorSpaceProfileW)(
                       NULL, lpLogColorSpace->lcsCSType,
                       pColorSpace->LogColorSpace.lcsFilename, &ulSize))
                {
                    ICMMSG(("IcmCreateColorSpace():CSType %x = %ws\n",
                                          lpLogColorSpace->lcsCSType,
                                          pColorSpace->LogColorSpace.lcsFilename));
                }
                else
                {
                    ICMWRN(("IcmCreateColorSpace():Error CSType = %x\n",
                                          lpLogColorSpace->lcsCSType));

                    LOCALFREE(pColorSpace);
                    return (NULL);
                }
            }

            //
            // Use PROFILE if profile is given
            //
            if ((pProfileData != NULL) &&
                (pProfileData->dwType == PROFILE_MEMBUFFER) &&
                (pProfileData->pProfileData != NULL) &&
                (pProfileData->cbDataSize != 0))
            {
                ICMMSG(("IcmCreateColorSpace():Create ColorSpace cache by memory profile\n"));

                ASSERTGDI(dwFlags & ON_MEMORY_PROFILE,
                          "IcmCreateColorSpace():dwFlags does not have ON_MEMORY_PROFILE");

                if (!(dwFlags & NOT_CACHEABLE_COLORSPACE))
                {
                    //
                    // Try to make a copy, if profile size is small enough,
                    // so that we can cache this profile.
                    //
                    if (pProfileData->cbDataSize <= MAX_SIZE_OF_COLORPROFILE_TO_CACHE)
                    {
                        pColorSpace->ColorProfile.pProfileData = GlobalAlloc(GMEM_FIXED,pProfileData->cbDataSize);

                        if (pColorSpace->ColorProfile.pProfileData)
                        {
                            ICMMSG(("IcmCreateColorSpace():Profile data can be cacheable\n"));

                            pColorSpace->ColorProfile.dwType = PROFILE_MEMBUFFER;
                            pColorSpace->ColorProfile.cbDataSize = pProfileData->cbDataSize;
                            RtlCopyMemory(pColorSpace->ColorProfile.pProfileData,
                                          pProfileData->pProfileData,
                                          pProfileData->cbDataSize);

                            //
                            // Make sure it is cachable...
                            //
                            ASSERTGDI((pColorSpace->flInfo & NOT_CACHEABLE_COLORSPACE) == 0,
                                      "IcmCreateColorSpace():flInfo has NOT_CACHEABLE_COLORSPACE");

                            //
                            // Profile memory need to be freed at deletion.
                            //
                            pColorSpace->flInfo |= NEED_TO_FREE_PROFILE;
                        }
                    }
                }

                //
                // If not able to cache, it the profile data in application.
                //
                if (pColorSpace->ColorProfile.pProfileData == NULL)
                {
                    //
                    // Use PROFILE data if it's given in parameter.
                    //
                    pColorSpace->ColorProfile = *pProfileData;

                    //
                    // We don't make a copy of profile data, so profile data possible to be
                    // free by application, so this color space can not be cached
                    //
                    pColorSpace->flInfo |= NOT_CACHEABLE_COLORSPACE;
                }
            }
            else if (lpLogColorSpace->lcsFilename[0] != UNICODE_NULL)
            {
                PWSZ pszFileNameOnly;

                ICMMSG(("IcmCreateColorSpace():Create ColorSpace cache by file - %ws\n",
                                                                 lpLogColorSpace->lcsFilename));

                //
                // Normalize filename
                //
                pszFileNameOnly = BuildIcmProfilePath(pColorSpace->LogColorSpace.lcsFilename,
                                                      pColorSpace->LogColorSpace.lcsFilename,MAX_PATH);

                //
                // If this is sRGB (= sRGB Color Space Profile.icm) color profile, ...
                //
                if (_wcsicmp(pszFileNameOnly,sRGB_PROFILENAME) == 0)
                {
                    //
                    // Mark device_calibrate_colorspace flag.
                    //
                    pColorSpace->flInfo |= DEVICE_CALIBRATE_COLORSPACE;
                }

                //
                // Fill up PROFILE structure and open it.
                //
                pColorSpace->ColorProfile.dwType = PROFILE_FILENAME;
                pColorSpace->ColorProfile.pProfileData = pColorSpace->LogColorSpace.lcsFilename;
                pColorSpace->ColorProfile.cbDataSize = MAX_PATH * sizeof(WCHAR);
            }
            else // if we only have parameter in LOGCOLORSPACE but not lcsFileName.
            {
                BOOL bRet;

                //
                // Convert LOGCOLORSPACE to ICC Profile.
                //
                ICMMSG(("IcmCreateColorSpace():Create ColorSpace cache by LOGCOLRSPACE\n"));

                //
                // Fill up PROFILE structure.
                //
                pColorSpace->ColorProfile.dwType = PROFILE_MEMBUFFER;
                pColorSpace->ColorProfile.pProfileData = NULL;

                //
                // Call convert function. (LOGCOLORSPACE -> ICC PROFILE)
                //
                bRet = IcmCreateProfileFromLCS(
                               &(pColorSpace->LogColorSpace),             // source logColorSpace
                               &(pColorSpace->ColorProfile.pProfileData), // receive pointer to profile image
                               &(pColorSpace->ColorProfile.cbDataSize));  // receive size of profile image

                if ((bRet == FALSE) ||
                    (pColorSpace->ColorProfile.pProfileData == NULL) ||
                    (pColorSpace->ColorProfile.cbDataSize == 0))
                {
                    ICMWRN(("IcmCreateColorSpaceByColorSpace():IcmCreateProfileFromLCS() failed\n"));

                    LOCALFREE(pColorSpace);
                    return (NULL);
                }

                //
                // Mark pProfileData must be freed at deletion.
                //
                pColorSpace->flInfo |= NEED_TO_FREE_PROFILE;
            }

            //
            // At this point, we don't have color format yet,
            // so call IcmRealizeColorProfile with no color format checking.
            //
            if (IcmRealizeColorProfile(pColorSpace,FALSE))
            {
                //
                // Get profile color format
                //
                pColorSpace->ColorFormat = IcmGetProfileColorFormat(pColorSpace->hProfile);

                //
                // Until create color transform, we don't need realized color space.
                //
                IcmUnrealizeColorProfile(pColorSpace);
            }
            else
            {
                ICMWRN(("IcmCreateColorSpace():Fail to realize color profile\n"));

                if (pColorSpace->flInfo & NEED_TO_FREE_PROFILE)
                {
                    GlobalFree(pColorSpace->ColorProfile.pProfileData);
                }

                LOCALFREE(pColorSpace);
                return (NULL);
            }

            //
            // Initialize ref. counter
            //
            pColorSpace->cRef = 1;

            //
            // Put the created color space into the list
            //
            ENTERCRITICALSECTION(&semColorSpaceCache);

            InsertTailList(&ListCachedColorSpace,&(pColorSpace->ListEntry));
            cCachedColorSpace++;

            LEAVECRITICALSECTION(&semColorSpaceCache);
        }
        else
        {
            WARNING("gdi32:IcmCreateColorSpace():LOCALALLOC failed\n");
        }
    }

    return (pColorSpace);
}

/******************************Public*Routine******************************\
* ColorProfile on demand loading/unloading support functions
*
* History:
*
* Write it:
*   29-Nov-1998 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
IcmRealizeColorProfile(
    PCACHED_COLORSPACE pColorSpace,
    BOOL               bCheckColorFormat
)
{
    ICMAPI(("gdi32: IcmRealizeColorProfile\n"));

    if (pColorSpace)
    {
        if ((pColorSpace->hProfile == NULL) &&
            (pColorSpace->ColorProfile.pProfileData != NULL))
        {
            HPROFILE hProfile = (*fpOpenColorProfileW)(
                                     &(pColorSpace->ColorProfile),
                                     PROFILE_READ,
                                     FILE_SHARE_READ | FILE_SHARE_WRITE,
                                     OPEN_EXISTING);

            if (hProfile)
            {
                //
                // Make sure color format of color profile has not been changed.
                //
                if ((bCheckColorFormat == FALSE) ||
                    (pColorSpace->ColorFormat == IcmGetProfileColorFormat(hProfile)))
                {
                    pColorSpace->hProfile = hProfile;
                }
                else
                {
                    (*fpCloseColorProfile)(hProfile);
                }
            }
        }

        return ((BOOL)!!pColorSpace->hProfile);
    }
    else
    {
        return (TRUE);
    }
}

VOID
IcmUnrealizeColorProfile(
    PCACHED_COLORSPACE pColorSpace
)
{
    ICMAPI(("gdi32: IcmUnrealizeColorProfile\n"));

    if (pColorSpace && pColorSpace->hProfile)
    {
        (*fpCloseColorProfile)(pColorSpace->hProfile);
        pColorSpace->hProfile = NULL;
    }
}

/******************************Public*Routine******************************\
* Metafiling support functions
*
* History:
*
* Write it:
*   23-May-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

VOID
IcmInsertMetafileList(
    PLIST_ENTRY pListHead,
    PWSZ        pName
    )
{
    PMETAFILE_COLORPROFILE pData;

    pData = LOCALALLOC(sizeof(METAFILE_COLORPROFILE));

    if (pData)
    {
        wcscpy(pData->ColorProfile,pName);
        InsertTailList(pListHead,&(pData->ListEntry));
    }
}

BOOL
IcmCheckMetafileList(
    PLIST_ENTRY pListHead,
    PWSZ        pName
    )
{
    PLIST_ENTRY p;
    PMETAFILE_COLORPROFILE pData;

    p = pListHead->Flink;

    while (p != pListHead)
    {
        pData = (PVOID) CONTAINING_RECORD(p,METAFILE_COLORPROFILE,ListEntry);

        if (_wcsicmp(pData->ColorProfile,pName) == 0)
        {
            return TRUE;
        }

        p = p->Flink;
    }

    return FALSE;
}

VOID
IcmFreeMetafileList(
    PLIST_ENTRY pListHead
    )
{
    PLIST_ENTRY p;
    PVOID       pData;

    p = pListHead->Flink;

    while(p != pListHead)
    {
        pData = (PVOID) CONTAINING_RECORD(p,METAFILE_COLORPROFILE,ListEntry);
        //
        // Need to get pointer to next before free memory.
        //
        p = p->Flink;
        //
        // then free memory.
        //
        LOCALFREE(pData);
    }

    InitializeListHead(pListHead);
}

/******************************Public*Routine******************************\
* IcmStretchBlt()
*
* History:
*
* Write it:
*   29-May-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
IcmStretchBlt(HDC hdc, int x, int y, int cx, int cy,
              HDC hdcSrc, int x1, int y1, int cx1, int cy1, DWORD rop,
              PDC_ATTR pdcattr, PDC_ATTR pdcattrSrc)
{
    int     iRet = 0;

    PGDI_ICMINFO pIcmInfo;

    HBITMAP      hbm;
    PVOID        pvBits;
    PBITMAPINFO  pbmi;
    ULONG        cjBits;

    HCOLORSPACE        hSourceColorSpace = NULL,
                       hOldColorSpace = NULL;
    PCACHED_COLORSPACE pSourceColorSpace = NULL;

    POINT ptDevice[2];
    UINT  nNumScan, nNumWidth;
    UINT  nStartScan, nStartWidth;
    BOOL  bNoScaling;

    BYTE dibData[(sizeof(DIBSECTION)+256*sizeof(RGBQUAD))];

    ICMAPI(("gdi32: IcmStretchBlt\n"));

    //
    // Convert Logical coord to Physical coord on source.
    //
    ptDevice[0].x = x1;
    ptDevice[0].y = y1;
    ptDevice[1].x = x1 + cx1;
    ptDevice[1].y = y1 + cy1;

    if (LPtoDP(hdcSrc,ptDevice,2) == FALSE)
    {
        //
        // can't handle, let callee handle this.
        //
        return (FALSE);
    }

    //
    // Compute new origin.
    //
    nStartWidth = ptDevice[0].x; 
    nStartScan  = ptDevice[0].y;
    nNumWidth   = ptDevice[1].x - ptDevice[0].x; 
    nNumScan    = ptDevice[1].y - ptDevice[0].y;

    //
    // Check source bounds.
    //
    if (((INT)nStartWidth < 0) || ((INT)nStartScan < 0) || ((INT)nNumWidth < 0) || ((INT)nNumScan < 0))
    {
        ICMWRN(("IcmStretchBlt: (x1,y1) is out of surface\n"));

        //
        // We can't handle this, let callee handle this.
        //
        return (FALSE);
    }

    //
    // Is there any scaling ?
    //
    bNoScaling = ((cx == (int)nNumWidth) && (cy == (int)nNumScan));

    //
    // Get bitmap handle.
    //
    hbm = (HBITMAP) GetDCObject(hdcSrc, LO_BITMAP_TYPE);

    if (bDIBSectionSelected(pdcattrSrc))
    {
        //
        // Get DIBSECTION currently selected in source DC.
        //
        if (GetObject(hbm, sizeof(DIBSECTION), &dibData) != (int)sizeof(DIBSECTION))
        {
            WARNING("IcmStretchBlt: GetObject(DIBSECTION) failed\n");
            return(FALSE);
        }

        //
        // Load color table and overwrite DIBSECTION structure from right after BITMAPINFOHEADER
        //
        if (((DIBSECTION *)&dibData)->dsBm.bmBitsPixel <= 8)
        {
            GetDIBColorTable(hdcSrc, 0, 256, (RGBQUAD *)&((DIBSECTION *)&dibData)->dsBitfields[0]);
        }

        pbmi = (PBITMAPINFO)&(((DIBSECTION *)&dibData)->dsBmih);

        // if ((nStartScan + nNumScan) > (((DIBSECTION *)&dibData)->dsBm.bmHeight))
        // {
        //    nNumScan = (((DIBSECTION *)&dibData)->dsBm.bmHeight - nStartScan);
        // }

        //
        // Setup color source/destination colorspaces
        //
        if (IS_ICM_INSIDEDC(pdcattrSrc->lIcmMode))
        {
            //
            // if ICM is turned on source DC. we will use source DC's
            // destination color space as destination DC's source
            // color space.
            //
            pIcmInfo = GET_ICMINFO(pdcattrSrc);

            if (pIcmInfo && pIcmInfo->pDestColorSpace)
            {
                hSourceColorSpace = CreateColorSpaceW(&(pIcmInfo->pDestColorSpace->LogColorSpace));
                pSourceColorSpace = pIcmInfo->pDestColorSpace;
            }
        }

        if (hSourceColorSpace == NULL)
        {
            //
            // if no colorspace, use sRGB.
            //
            hSourceColorSpace = GetStockObject(PRIV_STOCK_COLORSPACE);
            pSourceColorSpace = NULL;
        }
    }
    else if (IS_ICM_LAZY_CORRECTION(pdcattrSrc->lIcmMode))
    {
        //
        // Get BITMAP currently selected in source DC.
        //
        if (GetObject(hbm, sizeof(BITMAP), &dibData) != (int)sizeof(BITMAP))
        {
            WARNING("IcmStretchBlt: GetObject(BITMAP) failed\n");
            return(FALSE);
        }

        //
        // Create bitmap info header
        //
        pbmi = (PBITMAPINFO) ((PBYTE)dibData+sizeof(BITMAP));

        pbmi->bmiHeader.biSize        = sizeof(BITMAPINFO);
        pbmi->bmiHeader.biHeight      = ((BITMAP *)&dibData)->bmHeight;
        pbmi->bmiHeader.biWidth       = ((BITMAP *)&dibData)->bmWidth;
        pbmi->bmiHeader.biPlanes      = 1;
        pbmi->bmiHeader.biBitCount    = 24; // 24bpp
        pbmi->bmiHeader.biCompression = BI_RGB;
        pbmi->bmiHeader.biSizeImage     = 0;
        pbmi->bmiHeader.biXPelsPerMeter = 0;
        pbmi->bmiHeader.biYPelsPerMeter = 0;
        pbmi->bmiHeader.biClrUsed       = 0;
        pbmi->bmiHeader.biClrImportant  = 0;

        // if ((nStartScan + nNumScan) > pbmi->bmiHeader.biHeight)
        // {
        //     nNumScan = pbmi->bmiHeader.biHeight - nStartScan;
        // }

        ASSERTGDI(IS_ICM_INSIDEDC(pdcattrSrc->lIcmMode),
                  "IcmStretchBlt():Lazy color correction, but ICM is not enabled\n");

        pIcmInfo = GET_ICMINFO(pdcattrSrc);

        if (pIcmInfo && pIcmInfo->pSourceColorSpace)
        {
            hSourceColorSpace = CreateColorSpaceW(&(pIcmInfo->pSourceColorSpace->LogColorSpace));
            pSourceColorSpace = pIcmInfo->pSourceColorSpace;
        }
        else
        {
            //
            // Otherwise, just use Stcok color space (= sRGB)
            //
            hSourceColorSpace = GetStockObject(PRIV_STOCK_COLORSPACE);
            pSourceColorSpace = NULL;
        }
    }
    else
    {
        //
        // Can't handle here, let callee handle it.
        //
        return (FALSE);
    }

    //
    // Get bitmap size
    //
    cjBits = cjBitmapScanSize(pbmi,nNumScan);

    pvBits = LOCALALLOC(cjBits);

    if (pvBits)
    {
        //
        // Fix up the start scan (bottom-left).
        //
        nStartScan = (pbmi->bmiHeader.biHeight - nStartScan - nNumScan);

        //
        // Call NtGdiGetDIBitsInternal directly, because
        // we don't want to backward color correction to
        // source color space in hdcSrc.
        //
        if (NtGdiGetDIBitsInternal(
                      hdcSrc,hbm,
                      nStartScan,nNumScan,
                      pvBits,pbmi,
                      DIB_RGB_COLORS,
                      cjBits,0) == 0)
        {
            WARNING("IcmStretchBlt(): Failed on GetDIBits()\n");

            LOCALFREE(pvBits);
            pvBits = NULL;
        }

        //
        // Fix up the bitmap height, since pvBits only has nNumScan image.
        //
        pbmi->bmiHeader.biHeight = nNumScan;
    }

    if (pvBits)
    {

        if (hSourceColorSpace)
        {
            hOldColorSpace = IcmSetSourceColorSpace(hdc,hSourceColorSpace,pSourceColorSpace,0);
        }

        //
        // Draw the bitmap.
        //
        //  Target - x,y (upper left).
        //  Source - nStartWidth,0 (upper left).
        //
        if (bNoScaling && (rop == SRCCOPY))
        {
            iRet = SetDIBitsToDevice(hdc,x,y,cx,cy,nStartWidth,0,0,nNumScan,
                                     pvBits,pbmi,DIB_RGB_COLORS);
        }
        else
        {
            iRet = StretchDIBits(hdc,x,y,cx,cy,nStartWidth,0,nNumWidth,nNumScan,
                                 pvBits,pbmi,DIB_RGB_COLORS,rop);
        }

        //
        // Back to original color space, if created
        //
        if (hOldColorSpace)
        {
            IcmSetSourceColorSpace(hdc,hOldColorSpace,NULL,0);
        }

        LOCALFREE(pvBits);
    }

    if (hSourceColorSpace)
    {
        DeleteColorSpace(hSourceColorSpace);
    }

    return (BOOL) !!iRet;
}

/******************************Public*Routine******************************\
* IcmGetColorSpaceforBitmap()
*
* History:
*
* Write it:
*   29-May-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

PCACHED_COLORSPACE
IcmGetColorSpaceforBitmap(HBITMAP hbm)
{
    ICMAPI(("gdi32: IcmGetColorSpaceforBitmap\n"));

    FIXUP_HANDLE(hbm);

    return ((PCACHED_COLORSPACE)NtGdiGetColorSpaceforBitmap(hbm));
}

/******************************Public*Routine******************************\
* IcmEnableForCompatibleDC()
*
* History:
*
* Write it:
*   13-Jun-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
IcmEnableForCompatibleDC(
    HDC      hdcCompatible,
    HDC      hdcDevice,
    PDC_ATTR pdcaDevice
    )
{
    PDC_ATTR pdcaCompatible;

    ICMAPI(("gdi32: IcmEnableForCompatibleDC\n"));

    PSHARED_GET_VALIDATE(pdcaCompatible,hdcCompatible,DC_TYPE);

    if (pdcaCompatible)
    {
        PGDI_ICMINFO pIcmInfoCompatible;
        PGDI_ICMINFO pIcmInfoDevice;

        // Initialize ICMINFO
        //
        // for device DC, ICMINFO should be presented.
        //
        if ((pIcmInfoDevice = GET_ICMINFO(pdcaDevice)) == NULL)
        {
            WARNING("gdi32: IcmEnableForCompatibleDC: Can't init icm info\n");
            return (FALSE);
        }

        //
        // for compatible DC, it was just created, ICMINFO is not exist, then create here.
        //
        if ((pIcmInfoCompatible = INIT_ICMINFO(hdcCompatible,pdcaCompatible)) == NULL)
        {
            WARNING("gdi32: IcmEnableForCompatibleDC: Can't init icm info\n");
            return (FALSE);
        }

        //
        // Set Source color space as same as original DC
        //
        // Kernel side...
        //
        if (pdcaDevice->hColorSpace)
        {
            if (pdcaDevice->hColorSpace != GetStockObject(PRIV_STOCK_COLORSPACE))
            {
                //
                // Call directly kernel to set the color space to DC. (don't need client stuff)
                //
                NtGdiSetColorSpace(hdcCompatible,(HCOLORSPACE)pdcaDevice->hColorSpace);
            }

            //
            // Keep it in ICMINFO, so that we can un-select it later.
            //
            pIcmInfoCompatible->hDefaultSrcColorSpace = pdcaDevice->hColorSpace;
        }

        // And client side...
        //
        ENTERCRITICALSECTION(&semColorSpaceCache);

        if (pIcmInfoDevice->pSourceColorSpace)
        {
            pIcmInfoCompatible->pSourceColorSpace = pIcmInfoDevice->pSourceColorSpace;
            pIcmInfoCompatible->pSourceColorSpace->cRef++;
        }

        //
        // Set destination color space as same as original DC
        //
        if (pIcmInfoDevice->pDestColorSpace)
        {
            pIcmInfoCompatible->pDestColorSpace = pIcmInfoDevice->pDestColorSpace;
            pIcmInfoCompatible->pDestColorSpace->cRef++;
        }

        LEAVECRITICALSECTION(&semColorSpaceCache);

        //
        // copy default profile name (if they has)
        //
        if (pIcmInfoDevice->DefaultDstProfile[0] != UNICODE_NULL)
        {
            wcscpy(pIcmInfoCompatible->DefaultDstProfile,pIcmInfoDevice->DefaultDstProfile);
            pIcmInfoCompatible->flInfo |= (ICM_VALID_DEFAULT_PROFILE|
                                           ICM_VALID_CURRENT_PROFILE);
        }

        //
        // Make sure we have valid color space.
        //
        pdcaCompatible->ulDirty_ &= ~DIRTY_COLORSPACE;

        //
        // And we don't have valid color transform.
        //
        pdcaCompatible->ulDirty_ |= DIRTY_COLORTRANSFORM;

        if (IS_ICM_INSIDEDC(pdcaDevice->lIcmMode))
        {
            //
            // For compatible DC, use host ICM anytime...
            //
            ULONG ReqIcmMode = REQ_ICM_HOST;

            //
            // Turn ICM on for this compatible DC.
            //
            if (!NtGdiSetIcmMode(hdcCompatible,ICM_SET_MODE,ReqIcmMode))
            {
                //
                // something wrong... we are fail to enable ICM.
                //
                return (FALSE);
            }

            //
            // Update color transform.
            //
            if (!IcmUpdateDCColorInfo(hdcCompatible,pdcaCompatible))
            {
                //
                // Fail to create new transform
                //
                NtGdiSetIcmMode(hdcCompatible,ICM_SET_MODE,REQ_ICM_OFF);
                return (FALSE);
            }
        }
    }

    return (TRUE);
}

/******************************Public*Routine******************************\
* IcmAskDriverForColorProfile
*
* History:
*   08-Oct-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

int
IcmAskDriverForColorProfile(
    PLDC       pldc,
    ULONG      ulQueryMode,
    PDEVMODEW  pDevMode,
    PWSTR      pProfileName,
    DWORD     *pdwColorSpaceFlag
)
{
    INT   iRet;

    BYTE  TempProfileData[MAX_PATH];

    PVOID pvProfileData = (PVOID) TempProfileData;
    ULONG cjProfileSize = sizeof(TempProfileData);
    FLONG flProfileFlag = 0;

    ICMAPI(("gdi32: IcmAskDriverForColorProfile\n"));

    //
    // Call driver to get device profile data.
    //
    iRet = QueryColorProfileEx(pldc,
                                  pDevMode,
                                  ulQueryMode,
                                  pvProfileData,
                                  &cjProfileSize,
                                  &flProfileFlag);

    if (iRet == -1)
    {
        ICMMSG(("gdi32: IcmAskDriverForColorProfile():Driver does not hook color profile\n"));

        //
        // Driver does not support profile hook.
        //
        return iRet;
    }
    else if ((iRet == 0) &&
             (cjProfileSize > sizeof(TempProfileData)) &&
             (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
    {
        ICMMSG(("gdi32: IcmAskDriverForColorProfile():Allocate larger memory\n"));

        //
        // Buffer is not enough, so allocate it.
        //
        pvProfileData = LOCALALLOC(cjProfileSize);

        if (pvProfileData)
        {
            iRet = QueryColorProfileEx(pldc,
                                          pDevMode,
                                          ulQueryMode,
                                          pvProfileData,
                                          &cjProfileSize,
                                          &flProfileFlag);
        }
    }

    if ((iRet > 0) && (pvProfileData != NULL) && (cjProfileSize != 0))
    {
        if (flProfileFlag == QCP_PROFILEDISK)
        {
            ICMMSG(("gdi32: IcmAskDriverForColorProfile():Profiles - %ws\n",pvProfileData));

            //
            // pvProfileData contains filename in Unicode.
            //
            wcsncpy(pProfileName,(PWSTR)pvProfileData,MAX_PATH);
        }
        else if (flProfileFlag == QCP_PROFILEMEMORY)
        {
            //
            // pvProfileData contains color profile itself.
            //

            //
            // No desired name.
            //
            *pProfileName = UNICODE_NULL;

            //
            // Create temporary color profile.
            //
            if (IcmCreateTemporaryColorProfile(pProfileName,pvProfileData,cjProfileSize))
            {
                ICMMSG(("gdi32: IcmAskDriverForColorProfile():Profiles - %ws\n",pProfileName));

                //
                // Mark this as temporary file, so that when this is not used
                // the file will be deleted.
                //
                *pdwColorSpaceFlag = (DRIVER_COLORSPACE | NEED_TO_DEL_PROFILE);
            }
            else
            {
                ICMMSG(("gdi32: IcmAskDriverForColorProfile():Failed to create temp file\n"));

                //
                // failed to create temporary color profile.
                //
                iRet = 0;
            }
        }
        else
        {
            //
            // Unknown data type.
            //
            iRet = 0;
        }
    }
    else
    {
        iRet = 0;
    }

    if (pvProfileData && (pvProfileData != TempProfileData))
    {
        LOCALFREE(pvProfileData);
    }

    return (iRet);
}

/******************************Public*Routine******************************\
* GdiConvertBitmapV5
*
*  pbBitmapData - pointer to BITMAPV4/V5 data
*  iSizeOfBitmapData - size of buffer
*  uConvertFormat - either of CF_DIB or CF_BITMAP
*
* History:
*   12-Dec-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

HANDLE GdiConvertBitmapV5(
    LPBYTE   pbBitmapData,
    int      iSizeOfBitmapData,
    HPALETTE hPalette,
    UINT     uConvertFormat
)
{
    HANDLE hRet = NULL;

    UNREFERENCED_PARAMETER(hPalette);

    ICMAPI(("gdi32: GdiConvertBitmapV5\n"));

    if (pbBitmapData && iSizeOfBitmapData)
    {
        BITMAPINFO       *pbmi        = (BITMAPINFO *)pbBitmapData;
        BITMAPINFOHEADER *pbmih       = &(pbmi->bmiHeader);
        PVOID            pvBits       = NULL;

        ULONG            ulColorTableSize = (ULONG)-1;
        BOOL             bTransColorTable = FALSE;
        BOOL             bMoveColorMasks  = FALSE;

        //
        // Load external ICM dlls.
        //
        LOAD_ICMDLL(NULL);

        //
        // Find the bitmap bits pointer.
        //
        try
        {
            //
            // Calculate color table size.
            //
            if (pbmih->biCompression == BI_BITFIELDS)
            {
                //
                // Bitfields are a part of BITMAPV4/V5 header.
                //
                ulColorTableSize = 0;
                bMoveColorMasks  = TRUE;
            }
            else if (pbmih->biCompression == BI_RGB)
            {
                if (pbmih->biClrUsed)
                {
                    ulColorTableSize = (pbmih->biClrUsed * sizeof(RGBQUAD));

                    if (pbmih->biBitCount <= 8)
                    {
                        bTransColorTable = TRUE;
                    }
                }
                else if (pbmih->biBitCount <= 8)
                {
                    ulColorTableSize = ((1 << pbmih->biBitCount) * sizeof(RGBQUAD));
                    bTransColorTable = TRUE;
                }
                else
                {
                    ulColorTableSize = 0;
                }
            }
            else if (pbmih->biCompression == BI_RLE4)
            {
                ulColorTableSize = 16 * sizeof(RGBQUAD);
                bTransColorTable = TRUE;
            }
            else if (pbmih->biCompression == BI_RLE8)
            {
                ulColorTableSize = 256 * sizeof(RGBQUAD);
                bTransColorTable = TRUE;
            }
            else
            {
                //
                // BI_JPEG, BI_PNG, and others can not convert
                //
                ICMWRN(("GdiConvertBitmapV5: "
                        "given data is BI_JPEG, BI_PNG, or unkown\n"));
            }

            if (ulColorTableSize != (ULONG)-1)
            {
                //
                // Make sure given data is either BITMAPV4 or V5 header.
                //
                if (pbmih->biSize == sizeof(BITMAPV5HEADER))
                {
                    pvBits = (BYTE *)pbmi
                           + sizeof(BITMAPV5HEADER)
                           + ulColorTableSize
                           + ((LPBITMAPV5HEADER)pbmi)->bV5ProfileSize;
                }
                else if (pbmih->biSize != sizeof(BITMAPV4HEADER))
                {
                    pvBits = (BYTE *)pbmi
                           + sizeof(BITMAPV4HEADER)
                           + ulColorTableSize;
                }
                else
                {
                    ICMWRN(("GdiConvertBitmapV5: given data is not bitmapV4/V5\n"));
                }
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            pvBits = NULL;
        }

        if (pvBits)
        {
            if (uConvertFormat == CF_DIB)
            {
                ULONG cjBitmapBits;

                ICMMSG(("GdiConvertBitmapV5(): CF_DIBV5 -----> CF_DIB\n"));

                //
                // Calculate size of bitmap bits
                //
                try
                {
                    cjBitmapBits = cjBitmapBitsSize(pbmi);
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    cjBitmapBits = 0;
                }

                if (cjBitmapBits)
                {
                    //
                    // Allocate buffer for color translation
                    //
                    hRet = GlobalAlloc(GHND,sizeof(BITMAPINFOHEADER)
                                          + (bMoveColorMasks ? (3 * sizeof(DWORD)) : \
                                                               (ulColorTableSize))
                                          + cjBitmapBits);

                    if (hRet)
                    {
                        PBYTE pjSrc  = (PBYTE)pbmi;
                        PBYTE pjDest = GlobalLock(hRet);
                        BOOL  bTransformError = FALSE;

                        if (pjDest)
                        {
                            PROFILE            sRGBColorProfileData;
                            LOGCOLORSPACEW     LogColorSpaceW;
                            PROFILE            ColorProfile;

                            DWORD              dwFlags = 0;
                            HANDLE             hColorTransform = NULL;
                            HANDLE             hsRGBColorProfile = NULL;
                            HANDLE             hBitmapColorProfile = NULL;
                            PCACHED_COLORSPACE pColorSpace = NULL;

                            try
                            {
                                //
                                // Extract color space from BITMAPV4/V5 header.
                                //
                                bTransformError = !(IcmGetBitmapColorSpace(
                                                        pbmi,
                                                        &LogColorSpaceW,
                                                        &ColorProfile,
                                                        &dwFlags));
                            }
                            except(EXCEPTION_EXECUTE_HANDLER)
                            {
                                bTransformError = TRUE;
                            }

                            if (!bTransformError)
                            {
                                //
                                // Create color space and color transform
                                //
                                if ((LogColorSpaceW.lcsCSType == LCS_sRGB) ||
                                    (LogColorSpaceW.lcsCSType == LCS_WINDOWS_COLOR_SPACE))
                                {
                                    ICMMSG(("GdiConvertBitmapV5(): Original bitmap is sRGB\n"));

                                    //
                                    // No color translarion required.
                                    //
                                    hColorTransform = NULL;
                                }
                                else
                                {
                                    //
                                    // Get source color space (if bitmap has color space)
                                    //

                                    //
                                    // First, find ColorSpace from cache.
                                    //
                                    pColorSpace = IcmGetColorSpaceByColorSpace(
                                                      (HGDIOBJ)NULL,
                                                      &LogColorSpaceW,
                                                      &ColorProfile,
                                                      dwFlags);

                                    if (pColorSpace == NULL)
                                    {
                                        pColorSpace = IcmCreateColorSpaceByColorSpace(
                                                          (HGDIOBJ)NULL,
                                                          &LogColorSpaceW,
                                                          &ColorProfile,
                                                          dwFlags);
                                    }

                                    if (pColorSpace && IcmRealizeColorProfile(pColorSpace,TRUE))
                                    {
                                        hBitmapColorProfile = pColorSpace->hProfile;
                                    }

                                    //
                                    // Open sRGB color space profile as destination color space.
                                    //
                                    sRGBColorProfileData.dwType = PROFILE_FILENAME;
                                    sRGBColorProfileData.pProfileData = (PVOID)sRGB_PROFILENAME;
                                    sRGBColorProfileData.cbDataSize = MAX_PATH * sizeof(WCHAR);

                                    hsRGBColorProfile = (*fpOpenColorProfileW)(
                                                            &sRGBColorProfileData,
                                                            PROFILE_READ,
                                                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                                                            OPEN_EXISTING);

                                    if (hBitmapColorProfile && hsRGBColorProfile)
                                    {
                                        DWORD    ahIntents[2];
                                        HPROFILE ahProfiles[2];

                                        ahIntents[0]  = INTENT_RELATIVE_COLORIMETRIC;
                                        ahIntents[1]  = pColorSpace->ColorIntent;
                                        ahProfiles[0] = hBitmapColorProfile;
                                        ahProfiles[1] = hsRGBColorProfile;

                                        hColorTransform = (*fpCreateMultiProfileTransform)(
                                                              ahProfiles, 2,
                                                              ahIntents, 2,
                                                              NORMAL_MODE | ENABLE_GAMUT_CHECKING,
                                                              INDEX_DONT_CARE);
                                    }

                                    if (!hColorTransform)
                                    {
                                        bTransformError = TRUE;
                                    }
                                }

                                if (!bTransformError)
                                {
                                    //
                                    // Copy the bitmap to target with proper color space conversion.
                                    //
                                    try
                                    {
                                        BITMAPV5HEADER *pbm5h = (BITMAPV5HEADER *)pbmi;

                                        //
                                        // Copy bitmap header to target.
                                        //
                                        RtlCopyMemory(pjDest,pjSrc,sizeof(BITMAPINFOHEADER));

                                        //
                                        // Adjust bmHeader.biSize
                                        //
                                        ((BITMAPINFOHEADER *)pjDest)->biSize = sizeof(BITMAPINFOHEADER);

                                        //
                                        // Move src and dest pointers
                                        //
                                        pjSrc  += pbmih->biSize;
                                        pjDest += sizeof(BITMAPINFOHEADER);

                                        //
                                        // Copy bit mask or color table.
                                        //
                                        if (bMoveColorMasks)
                                        {
                                            //
                                            // Move color masks. cast it to pointer to BITMAPV5HEADER
                                            // since same offset on BITMAPV4HEADER too.
                                            //

                                            *(DWORD *)pjDest = pbm5h->bV5RedMask;
                                            pjDest += sizeof(DWORD);
                                            *(DWORD *)pjDest = pbm5h->bV5GreenMask;
                                            pjDest += sizeof(DWORD);
                                            *(DWORD *)pjDest = pbm5h->bV5BlueMask;
                                            pjDest += sizeof(DWORD);
                                        }
                                        else
                                        {
                                            if (ulColorTableSize)
                                            {
                                                if (bTransColorTable && hColorTransform)
                                                {
                                                    bTransformError = !(*fpTranslateBitmapBits)(
                                                                           hColorTransform,
                                                                           pjSrc, BM_xRGBQUADS,
                                                                           ulColorTableSize/sizeof(RGBQUAD), 1,
                                                                           0,
                                                                           pjDest, BM_xRGBQUADS,
                                                                           0,NULL,0);
                                                }
                                                else
                                                {
                                                    RtlCopyMemory(pjDest,pjSrc,ulColorTableSize);
                                                }

                                                pjSrc  += ulColorTableSize;
                                                pjDest += ulColorTableSize;
                                            }
                                        }

                                        if (bTransColorTable || (hColorTransform == NULL))
                                        {
                                            //
                                            // All the color information is in the color table. and
                                            // it has been translated, so just copy bitmap bits.
                                            //
                                            RtlCopyMemory(pjDest,pvBits,cjBitmapBits);
                                        }
                                        else
                                        {
                                            //
                                            // Translate bitmap bits.
                                            //
                                            BMFORMAT bmColorType;

                                            //
                                            // Get BMFORMAT based on bitmap format.
                                            //
                                            if (pbmih->biBitCount == 16)
                                            {
                                                if (pbmih->biCompression == BI_RGB)
                                                {
                                                    bmColorType = BM_x555RGB;
                                                }
                                                else if (pbmih->biCompression == BI_BITFIELDS)
                                                {
                                                    if ((pbm5h->bV5RedMask   == 0x007c00) &&
                                                        (pbm5h->bV5GreenMask == 0x0003e0) &&
                                                        (pbm5h->bV5BlueMask  == 0x00001f))
                                                    {
                                                        bmColorType = BM_x555RGB;
                                                    }
                                                    else if ((pbm5h->bV5RedMask   == 0x00f800) &&
                                                             (pbm5h->bV5GreenMask == 0x0007e0) &&
                                                             (pbm5h->bV5BlueMask  == 0x00001f))
                                                    {
                                                        bmColorType = BM_565RGB;
                                                    }
                                                    else
                                                    {
                                                        ICMWRN(("GdiConvertBitmapV5: Bad Bitfields Mask for 16 bpp\n"));
                                                        bTransformError = TRUE;
                                                    }
                                                }
                                                else
                                                {
                                                    ICMWRN(("GdiConvertBitmapV5: Bad biCompression for 16 bpp\n"));
                                                    bTransformError = TRUE;
                                                }
                                            }
                                            else if (pbmih->biBitCount == 24)
                                            {
                                                bmColorType = BM_RGBTRIPLETS;
                                            }
                                            else if (pbmih->biBitCount == 32)
                                            {
                                                if (pbmih->biCompression == BI_RGB)
                                                {
                                                    bmColorType = BM_xRGBQUADS;
                                                }
                                                else if (pbmih->biCompression == BI_BITFIELDS)
                                                {
                                                    if ((pbm5h->bV5RedMask   == 0x0000ff) &&  /* Red */
                                                        (pbm5h->bV5GreenMask == 0x00ff00) &&  /* Green */
                                                        (pbm5h->bV5BlueMask  == 0xff0000))    /* Blue */
                                                    {
                                                        bmColorType = BM_xBGRQUADS;
                                                    }
                                                    else if ((pbm5h->bV5RedMask   == 0xff0000) &&  /* Red */
                                                             (pbm5h->bV5GreenMask == 0x00ff00) &&  /* Green */
                                                             (pbm5h->bV5BlueMask  == 0x0000ff))    /* Blue */
                                                    {
                                                        bmColorType = BM_xRGBQUADS;
                                                    }
                                                    else
                                                    {
                                                        ICMWRN(("GdiConvertBitmapV5: Bad Bitfields Mask for 32 bpp\n"));
                                                        bTransformError = TRUE;
                                                    }
                                                }
                                                else
                                                {
                                                    ICMWRN(("GdiConvertBitmapV5: Bad biCompression for 32 bpp\n"));
                                                    bTransformError = TRUE;
                                                }
                                            }
                                            else
                                            {
                                                ICMWRN(("GdiConvertBitmapV5: Bad biBitCount\n"));
                                                bTransformError = TRUE;
                                            }

                                            if (!bTransformError)
                                            {
                                                bTransformError = !(*fpTranslateBitmapBits)(
                                                                       hColorTransform,
                                                                       pvBits, bmColorType,
                                                                       pbmih->biWidth,
                                                                       ABS(pbmih->biHeight),
                                                                       0,
                                                                       pjDest, bmColorType,
                                                                       0,NULL,0);
                                            }
                                        }
                                    }
                                    except(EXCEPTION_EXECUTE_HANDLER)
                                    {
                                        bTransformError = TRUE;
                                    }
                                }

                                //
                                // Clean up used color transform and color profile handles
                                //
                                if (hColorTransform)
                                {
                                    (*fpDeleteColorTransform)(hColorTransform);
                                }

                                if (hsRGBColorProfile)
                                {
                                    (*fpCloseColorProfile)(hsRGBColorProfile);
                                }

                                if (pColorSpace)
                                {
                                    IcmReleaseColorSpace(NULL,pColorSpace,FALSE);
                                }
                            }
                        }

                        GlobalUnlock(hRet);

                        if (bTransformError)
                        {
                            GlobalFree(hRet);
                            hRet = NULL;
                        }
                    }
                    else
                    {
                        ICMWRN(("GdiConvertBitmapV5: Fail on GlobalAlloc()\n"));
                    }
                }
                else
                {
                    ICMWRN(("GdiConvertBitmapV5: cjBitmapBits is 0\n"));
                }

                return (hRet);
            }
            else if (uConvertFormat == CF_BITMAP)
            {
                HDC     hDC = GetDC(NULL);
                HBITMAP hBitmap = NULL;

                if (hDC)
                {
                    ICMMSG(("GdiConvertBitmapV5(): CF_DIBV5 -----> CF_BITMAP\n"));

                    //
                    // Set destination color space as sRGB, and enable ICM.
                    //
                    if (IcmSetDestinationColorSpace(hDC,sRGB_PROFILENAME,NULL,0) &&
                        SetICMMode(hDC,ICM_ON))
                    {
                        try
                        {
                            //
                            // Create bitmap handle with given bitmap V5 data.
                            //
                            hBitmap = CreateDIBitmap(hDC,
                                                     pbmih,
                                                     CBM_INIT,
                                                     pvBits,
                                                     pbmi,
                                                     DIB_RGB_COLORS);
                        }
                        except(EXCEPTION_EXECUTE_HANDLER)
                        {
                            hBitmap = NULL;
                        }

                        if (!hBitmap)
                        {
                            ICMWRN(("GdiConvertBitmapV5: Fail on CreateDIBitmap()\n"));
                        }
                    }

                    //
                    // Clean up DC
                    //
                    SetICMMode(hDC,ICM_OFF);
                    ReleaseDC(NULL,hDC);
                }

                return ((HANDLE)hBitmap);
            }
            else
            {
                ICMWRN(("GdiConvertBitmapV5(): CF_DIBV5 -----> Unknown\n"));
            }
        }
    }

    return (hRet);
}

/******************************Public*Routine******************************\
* IcmSetTargetColorSpace()
*
* History:
*    8-Jun-1998 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
IcmSetTargetColorSpace(
    HDC                hdc,
    PCACHED_COLORSPACE pTargetColorSpace,
    DWORD              uiAction
    )
{
    BOOL     bRet = FALSE;
    PDC_ATTR pdcattr;
    PGDI_ICMINFO pIcmInfo;

    ICMAPI(("gdi32: IcmSetTargetColorSpace\n"));

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if (pdcattr == NULL)
    {
        return (FALSE);
    }

    if ((pIcmInfo = GET_ICMINFO(pdcattr)) == NULL)
    {
        return (FALSE);
    }

    switch (uiAction)
    {
        case CS_ENABLE:
        {
            //
            // Check validation of given Target color space.
            //
            if (pTargetColorSpace != NULL)
            {
                PCACHED_COLORTRANSFORM pCXform;
                BOOL bDeleteOldCXform = FALSE;

                //
                // Mark we are in proofing mode.
                //
                SET_ICM_PROOFING(pdcattr->lIcmMode);

                if ((pIcmInfo->pProofCXform != NULL) &&
                    IcmSameColorSpace(pTargetColorSpace,pIcmInfo->pTargetColorSpace))
                {
                    ICMMSG(("IcmSetTargetColorSpace():Use Cached Proof Transform\n"));

                    ENTERCRITICALSECTION(&semColorTransformCache);

                    //
                    // the cached proofing transform is still valid.
                    //
                    pCXform = pIcmInfo->pProofCXform;

                    if (pCXform)
                    {
                        //
                        // Increment ref count of it.
                        //
                        pCXform->cRef++;
                    }

                    LEAVECRITICALSECTION(&semColorTransformCache);
                }
                else
                {
                    ICMMSG(("IcmSetTargetColorSpace():Create New Proof Transform\n"));

                    //
                    // We don't have cached color space or it is no longer valid.
                    //

                    //
                    // Check we still have cached color space and it's still valid ?
                    //
                    if (pIcmInfo->pTargetColorSpace &&
                        IcmSameColorSpace(pTargetColorSpace,pIcmInfo->pTargetColorSpace))
                    {
                        //
                        // Cached target color space are still valid, keep as is.
                        //
                    }
                    else
                    {
                        //
                        // Release old target color space.
                        //
                        IcmReleaseColorSpace(NULL,pIcmInfo->pTargetColorSpace,FALSE);

                        //
                        // Increment ref count of it.
                        //
                        IcmReferenceColorSpace(pTargetColorSpace);

                        //
                        // set target destination profile into current DC as target profile
                        //
                        pIcmInfo->pTargetColorSpace = pTargetColorSpace;
                    }

                    //
                    // create new transform
                    //
                    pCXform = IcmCreateColorTransform(hdc,pdcattr,NULL,ICM_FORWARD);

                    //
                    // Marks as need to delete old color transform if we have.
                    //
                    bDeleteOldCXform = pIcmInfo->pProofCXform ? TRUE : FALSE;
                }

                if ((pCXform == IDENT_COLORTRANSFORM) || (pCXform == NULL))
                {
                    //
                    // Invalidate color transform
                    //
                    IcmSelectColorTransform(hdc,pdcattr,NULL,
                                            bDeviceCalibrate(pIcmInfo->pDestColorSpace));

                    //
                    // Delete old color transform.
                    //
                    if (bDeleteOldCXform)
                    {
                        //
                        // Delete cached proofing color transform
                        //
                        IcmDeleteColorTransform(pIcmInfo->pProofCXform,FALSE);
                    }

                    //
                    // Set null color transform to ICMINFO
                    //
                    pIcmInfo->pProofCXform = NULL;

                    if (pCXform == IDENT_COLORTRANSFORM)
                    {
                        ICMMSG(("IcmSetTargetColorSpace():Input & Output colorspace is same\n"));

                        //
                        // Input & Destination & Target color space is same, there is
                        // no color translation needed.
                        //
                        bRet = TRUE;
                    }
                    else
                    {
                        ICMWRN(("IcmSetTargetColorSpace():Fail to create color transform\n"));
                    }

                    //
                    // Translate back to DC color object to original
                    //
                    IcmTranslateColorObjects(hdc,pdcattr,FALSE);
                }
                else
                {
                    //
                    // Select the color transform to DC.
                    //
                    IcmSelectColorTransform(hdc,pdcattr,pCXform,
                                            bDeviceCalibrate(pCXform->DestinationColorSpace));

                    //
                    // Delete old color transform.
                    //
                    if (bDeleteOldCXform)
                    {
                        //
                        // Delete cached proofing color transform
                        //
                        IcmDeleteColorTransform(pIcmInfo->pProofCXform,FALSE);
                    }

                    //
                    // Set new color transform to ICMINFO.
                    //
                    pIcmInfo->pProofCXform = pCXform;

                    //
                    // Initialize color attributes in this DC.
                    //
                    IcmTranslateColorObjects(hdc,pdcattr,TRUE);

                    bRet = TRUE;
                }
            }
            else
            {
                GdiSetLastError(ERROR_INVALID_PARAMETER);
                WARNING("IcmSetTargetColorSpace: target color space is NULL\n");

                //
                // Anyway, just re-initialize without target profile.
                //
                IcmTranslateColorObjects(hdc,pdcattr,TRUE);
            }

            if (!bRet)
            {
                //
                // if failed, mask off as we are not in proofing mode
                //
                CLEAR_ICM_PROOFING(pdcattr->lIcmMode);

                if (pIcmInfo->pTargetColorSpace)
                {
                    //
                    // Release target color space.
                    //
                    IcmReleaseColorSpace(NULL,pIcmInfo->pTargetColorSpace,FALSE);

                    //
                    // Disable target profile.
                    //
                    pIcmInfo->pTargetColorSpace = NULL;
                }
            }

            break;
        }

        case CS_DISABLE:
        case CS_DELETE_TRANSFORM:
        {
            //
            // We are going to be out of proofing mode.
            //
            CLEAR_ICM_PROOFING(pdcattr->lIcmMode);

            if (pdcattr->ulDirty_ & DIRTY_COLORTRANSFORM)
            {
                if (uiAction == CS_DELETE_TRANSFORM)
                {
                    if (pIcmInfo->pTargetColorSpace)
                    {
                        //
                        // Release target color space.
                        //
                        IcmReleaseColorSpace(NULL,pIcmInfo->pTargetColorSpace,FALSE);

                        //
                        // Disable target profile.
                        //
                        pIcmInfo->pTargetColorSpace = NULL;
                    }
                }

                //
                // While DC is in proofing mode, the source or
                // destination color space has been changed by
                // SetColorSpace() or SetICMProfile(). So,
                // we will reset all color transform in this
                // DC.
                //
                if (IcmUpdateDCColorInfo(hdc,pdcattr))
                {
                    bRet = TRUE;
                }
                else
                {
                    GdiSetLastError(ERROR_DELETING_ICM_XFORM);
                }
            }
            else
            {
                //
                // We are leaving proofing mode, Select back the normal colortransform into DC.
                //
                IcmSelectColorTransform(hdc,pdcattr,pIcmInfo->pCXform,
                                        bDeviceCalibrate(pIcmInfo->pDestColorSpace));

                //
                // The color transform cache will effective...
                //
                if (uiAction == CS_DELETE_TRANSFORM)
                {
                    if (pIcmInfo->pTargetColorSpace)
                    {
                        //
                        // Release target color space.
                        //
                        IcmReleaseColorSpace(NULL,pIcmInfo->pTargetColorSpace,FALSE);

                        //
                        // Disable target profile.
                        //
                        pIcmInfo->pTargetColorSpace = NULL;
                    }

                    //
                    // Delete ONLY proofing color transform (if it is)
                    //
                    if (pIcmInfo->pProofCXform)
                    {
                        if (!IcmDeleteColorTransform(pIcmInfo->pProofCXform,FALSE))
                        {
                            GdiSetLastError(ERROR_DELETING_ICM_XFORM);
                            return (FALSE);
                        }

                        //
                        // There is no proofing transform in this ICMINFO.
                        //
                        pIcmInfo->pProofCXform = NULL;
                    }
                }

                bRet = TRUE;
            }

            if (bRet)
            {
                //
                // Initialize color attributes in this DC.
                //
                IcmTranslateColorObjects(hdc,pdcattr,TRUE);
            }

            break;
        }

        default:
        {
            WARNING("IcmSetTargetColorSpace: uiAction is invalid\n");
            GdiSetLastError(ERROR_INVALID_PARAMETER);
        }
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* IcmSetDestinationColorSpace()
*
* History:
*   17-Jul-1998 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
IcmSetDestinationColorSpace(
    HDC                hdc,
    LPWSTR             pwszFileName,
    PCACHED_COLORSPACE pColorSpace,
    DWORD              dwFlags
    )
{
    BOOL      bRet = FALSE;
    PDC_ATTR  pdcattr;

    ULONG     FileNameSize;

    if (pColorSpace)
    {
        ICMAPI(("gdi32: IcmSetDestinationColorSpace by ColorSpace (%ws):dwFlags - %d\n",
                           pColorSpace->LogColorSpace.lcsFilename,dwFlags));
    }
    else if (pwszFileName)
    {
        ICMAPI(("gdi32: IcmSetDestinationColorSpace by profile name (%ws):dwFlags - %x\n",
                                                     pwszFileName,dwFlags));

        //
        // Check filename
        //
        if (pwszFileName)
        {
            FileNameSize = lstrlenW(pwszFileName);
        }

        if ((FileNameSize == 0) || (FileNameSize > MAX_PATH))
        {
            ICMWRN(("IcmSetDestinatonColorSpace - no or too long profile name\n"));
            return FALSE;
        }
    }
    else
    {
        ICMAPI(("gdi32: IcmSetDestinationColorSpace - invalid parameter\n"));
        return FALSE;
    }

    FIXUP_HANDLE(hdc);

    //
    // We are going to try to select this color space into thisDC,
    // default is false.
    //
    bRet = FALSE;

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    //
    // Profile filename or pColorSpace should be presented.
    //
    if (pdcattr)
    {
        PGDI_ICMINFO pIcmInfo;

        //
        // Initialize ICMINFO
        //
        if ((pIcmInfo = INIT_ICMINFO(hdc,pdcattr)) == NULL)
        {
            WARNING("gdi32: IcmSetDestinationColorSpace: Can't init icm info\n");
            return(FALSE);
        }

        if (IsColorDeviceContext(hdc))
        {
            PCACHED_COLORSPACE pNewColorSpace = NULL;

            //
            // Load external ICM dlls.
            //
            LOAD_ICMDLL(FALSE);

            if (pColorSpace == NULL)
            {
                //
                // Find colorspace from cache
                //
                pNewColorSpace = IcmGetColorSpaceByName(
                                     (HGDIOBJ)hdc,
                                     pwszFileName,
                                     pIcmInfo->dwDefaultIntent,
                                     dwFlags);

                if (pNewColorSpace == NULL)
                {
                    ICMMSG(("IcmSetDestinationColorSpace():This is new color space, create it\n"));

                    //
                    // Can not find, Create new one
                    //
                    pNewColorSpace = IcmCreateColorSpaceByName(
                                         (HGDIOBJ)hdc,
                                         pwszFileName,
                                         pIcmInfo->dwDefaultIntent,
                                         dwFlags);
                }
            }
            else
            {
                //
                // Increment ref count of given color space
                //
                IcmReferenceColorSpace(pColorSpace);

                //
                // Use pColorSpace from parameter.
                //
                pNewColorSpace = pColorSpace;
            }

            //
            // We are going to select this colorspace onto DC. and free previous profile.
            //
            if (pNewColorSpace)
            {
                PCACHED_COLORSPACE pOldColorSpace = pIcmInfo->pDestColorSpace;

                //
                // Is this same destination color space currently selected in DC ?
                //
                if (IcmSameColorSpace(pNewColorSpace,pIcmInfo->pDestColorSpace))
                {
                    //
                    // Yes, early-out. We don't need new color space.
                    //
                    IcmReleaseColorSpace(NULL,pNewColorSpace,FALSE);
                    return (TRUE);
                }

                //
                // Before change destination color space, we need to flush batched gdi functions.
                //
                CHECK_AND_FLUSH(hdc,pdcattr);

                //
                // Check new color format is accepted by this DC or not.
                //
                if (!NtGdiSetIcmMode(hdc,ICM_CHECK_COLOR_MODE,pNewColorSpace->ColorFormat))
                {
                    ICMWRN(("IcmSetDestinationColorSpace(): DC does not accept this color format\n"));
                    GdiSetLastError(ERROR_INVALID_PROFILE);
                }
                else
                {
                    //
                    // Set new color space into DC.
                    //
                    pIcmInfo->pDestColorSpace = pNewColorSpace;

                    //
                    // Remove dirty transform flag.
                    //
                    pdcattr->ulDirty_ &= ~DIRTY_COLORSPACE;

                    if (IS_ICM_INSIDEDC(pdcattr->lIcmMode) && !IS_ICM_PROOFING(pdcattr->lIcmMode))
                    {
                        PCACHED_COLORTRANSFORM pCXform;

                        //
                        // create new color transform base on new colorspace
                        //
                        pCXform = IcmCreateColorTransform(hdc,pdcattr,NULL,ICM_FORWARD);

                        if (pCXform == IDENT_COLORTRANSFORM)
                        {
                            //
                            // Select null color transform to DC.
                            //
                            IcmSelectColorTransform(hdc,pdcattr,NULL,
                                                    bDeviceCalibrate(pIcmInfo->pDestColorSpace));

                            //
                            // delete old color transform in DC.
                            //
                            IcmDeleteDCColorTransforms(pIcmInfo);

                            //
                            // Select null color transform to ICMINFO.
                            //
                            pIcmInfo->pCXform = NULL;

                            //
                            // back it to original color (non-ICMed color).
                            //
                            IcmTranslateColorObjects(hdc,pdcattr,FALSE);

                            //
                            // And, everything O.K.
                            //
                            bRet = TRUE;
                        }
                        else if (pCXform)
                        {
                            //
                            // Select the colortransform into DC.
                            //
                            if (IcmSelectColorTransform(
                                    hdc,pdcattr,pCXform,
                                    bDeviceCalibrate(pCXform->DestinationColorSpace)))
                            {
                                //
                                // delete old color transform in DC.
                                //
                                IcmDeleteDCColorTransforms(pIcmInfo);

                                //
                                // Select it to ICMINFO.
                                //
                                pIcmInfo->pCXform = pCXform;

                                //
                                // Adjust to new color transform.
                                //
                                IcmTranslateColorObjects(hdc,pdcattr,TRUE);

                                //
                                // And, everything O.K.
                                //
                                bRet = TRUE;
                            }
                            else
                            {
                                //
                                // Failed to select it to the DC in client side.
                                // so delete it and invalidate pCXform.
                                //
                                IcmDeleteColorTransform(pCXform,FALSE);
                                pCXform = NULL;
                            }
                        }

                        if (pCXform == NULL)
                        {
                            //
                            // Failed to create/select color stransform,
                            // so put back previous color space.
                            //
                            pIcmInfo->pDestColorSpace = pOldColorSpace;
                        }
                    }
                    else
                    {
                        //
                        // if ICM is not turned on currently, we just mark
                        // cached color transform is no longer valid.
                        //
                        pdcattr->ulDirty_ |= DIRTY_COLORTRANSFORM;

                        // For ColorMatchToTarget()
                        //
                        // While color matching to the target is enabled by setting
                        // uiAction to CS_ENABLE, application changes to the color
                        // space or gamut matching method are ignored.
                        // Those changes then take effect when color matching to
                        // the target is disabled.
                        //
                        if (IS_ICM_PROOFING(pdcattr->lIcmMode))
                        {
                            ICMMSG(("IcmSetDestinationColorSpace():In Proofing mode, lazy setting...\n"));
                        }

                        bRet = TRUE;
                    }
                }

                if (bRet)
                {
                    //
                    // We are succeeded to select new color space, then
                    // close and free references to old color space.
                    //
                    IcmReleaseColorSpace(NULL,pOldColorSpace,FALSE);
                }
                else
                {
                    //
                    // We will not use this color space as destination color space,
                    // because 1) DC does not accept this color space, 2) Fail to
                    // create color transform based on this color space.
                    //
                    IcmReleaseColorSpace(NULL,pNewColorSpace,FALSE);
                }
            }
            else
            {
                GdiSetLastError(ERROR_PROFILE_NOT_FOUND);
            }
        }
        else
        {
            ICMMSG(("IcmSetDestinationColorSpace(): for Mono-device\n"));

            //
            // Just copy Apps specifyed profile to internal buffer, which will
            // be return to app by GetICMProfile(), but it is NEVER used for
            // non-color device other than that case, since there is no ICM
            // happen.
            //
            wcsncpy(pIcmInfo->DefaultDstProfile,pwszFileName,MAX_PATH);

            //
            // This is not default profile, but current profile.
            //
            pIcmInfo->flInfo &= ~ICM_VALID_DEFAULT_PROFILE;
            pIcmInfo->flInfo |= ICM_VALID_CURRENT_PROFILE;
        }
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* IcmSetSourceColorSpace()
*
* History:
*   17-Jul-1998 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

HCOLORSPACE
IcmSetSourceColorSpace(
    HDC                hdc,
    HCOLORSPACE        hColorSpace,
    PCACHED_COLORSPACE pColorSpace,
    DWORD              dwFlags)
{
    HANDLE hRet = NULL;
    PDC_ATTR pdcattr;

    ICMAPI(("gdi32: IcmSetSourceColorSpace\n"));

    FIXUP_HANDLE(hdc);
    FIXUP_HANDLE(hColorSpace);

    //
    // validate and access hdc
    //
    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        PGDI_ICMINFO pIcmInfo;

        //
        // Initialize ICMINFO
        //
        if ((pIcmInfo = INIT_ICMINFO(hdc,pdcattr)) == NULL)
        {
            WARNING("gdi32: IcmSetSourceColorSpace: Can't init icm info\n");
            return(NULL);
        }

        if (pdcattr->hColorSpace != hColorSpace)
        {
            //
            // Before change source color space, we need to flush batched gdi functions.
            //
            CHECK_AND_FLUSH(hdc,pdcattr);

            //
            // Return Old (currently selected) color space handle.
            //
            hRet = pdcattr->hColorSpace;

            //
            // set new color space, call kernel to keep reference count tracking
            // of colospace object
            //
            if (NtGdiSetColorSpace(hdc,hColorSpace))
            {
                if (IsColorDeviceContext(hdc))
                {
                    PCACHED_COLORSPACE pNewColorSpace;
                    LOGCOLORSPACEW     LogColorSpaceW;

                    RtlZeroMemory(&LogColorSpaceW,sizeof(LOGCOLORSPACEW));

                    //
                    // Load external ICM dlls.
                    //
                    LOAD_ICMDLL(NULL);

                    if (pColorSpace == NULL)
                    {
                        //
                        // Check if there is client-cached colorspace for this or not.
                        //
                        pNewColorSpace = IcmGetColorSpaceByHandle(
                                             (HGDIOBJ)hdc,
                                             hColorSpace,
                                             &LogColorSpaceW,dwFlags);

                        //
                        // If we can not find from cache, but succeeded to obtain
                        // valid logcolorspace from handle, create new one.
                        //
                        if ((pNewColorSpace == NULL) &&
                            (LogColorSpaceW.lcsSignature == LCS_SIGNATURE))
                        {
                            //
                            // Create new one.
                            //
                            pNewColorSpace = IcmCreateColorSpaceByColorSpace(
                                                 (HGDIOBJ)hdc,
                                                 &LogColorSpaceW,
                                                 NULL,
                                                 dwFlags);
                        }
                    }
                    else
                    {
                        //
                        // Increment ref count of given color space
                        //
                        IcmReferenceColorSpace(pColorSpace);

                        //
                        // Use pColorSpace from parameter.
                        //
                        pNewColorSpace = pColorSpace;
                    }

                    //
                    // Update current source color space to new one.
                    //
                    if (pNewColorSpace)
                    {
                        PCACHED_COLORSPACE pOldColorSpace = pIcmInfo->pSourceColorSpace;

                        //
                        // Check the colorspace is same one as currently selected ?
                        //
                        if (IcmSameColorSpace(pNewColorSpace,pIcmInfo->pSourceColorSpace))
                        {
                            //
                            // This is the "actually" same color space, but differrent handle,
                            // don't need to update
                            //
                            IcmReleaseColorSpace(NULL,pNewColorSpace,FALSE);
                            return (hRet);
                        }

                        //
                        // Source color space should be RGB color space.
                        //
                        if (pNewColorSpace->ColorFormat != BM_xBGRQUADS)
                        {
                            ICMWRN(("IcmSetSourceColorSpace():Source color space is not RGB\n"));

                            //
                            // Set back previous color space. (can't fail these calls)
                            //
                            IcmReleaseColorSpace(NULL,pNewColorSpace,FALSE);
                            NtGdiSetColorSpace(hdc,hRet);
                            GdiSetLastError(ERROR_INVALID_COLORSPACE);
                            return (NULL);
                        }

                        //
                        // And set new color space.
                        //
                        pIcmInfo->pSourceColorSpace = pNewColorSpace;

                        //
                        // if ICM is enabled, needs update color transform, right now.
                        //
                        if (IS_ICM_INSIDEDC(pdcattr->lIcmMode) && !IS_ICM_PROOFING(pdcattr->lIcmMode))
                        {
                            PCACHED_COLORTRANSFORM pCXform;

                            //
                            // create new color transform
                            //
                            pCXform = IcmCreateColorTransform(hdc,pdcattr,NULL,ICM_FORWARD);

                            if (pCXform == IDENT_COLORTRANSFORM)
                            {
                                ICMMSG(("IcmSetSourceColorSpace():Input & Output colorspace is same\n"));

                                //
                                // select NULL transform into DC.
                                //
                                IcmSelectColorTransform(hdc,pdcattr,NULL,
                                                        bDeviceCalibrate(pIcmInfo->pDestColorSpace));

                                //
                                // delete old colorspace/transform from ICMINFO.
                                //
                                IcmDeleteDCColorTransforms(pIcmInfo);

                                //
                                // select NULL tranform to ICMINFO.
                                //
                                pIcmInfo->pCXform = NULL;

                                //
                                // Set DC objects color to non-ICMed color.
                                //
                                IcmTranslateColorObjects(hdc,pdcattr,FALSE);
                            }
                            else if (pCXform)
                            {
                                //
                                // Select the color transform to DC.
                                //
                                if (IcmSelectColorTransform(
                                        hdc,pdcattr,pCXform,
                                        bDeviceCalibrate(pCXform->DestinationColorSpace)))
                                {
                                    //
                                    // delete old colorspace/transform from ICMINFO.
                                    //
                                    IcmDeleteDCColorTransforms(pIcmInfo);

                                    //
                                    // select new color transform to ICMINFO.
                                    //
                                    pIcmInfo->pCXform = pCXform;

                                    //
                                    // Succeed to select into DC, Validate DC color objects
                                    //
                                    IcmTranslateColorObjects(hdc,pdcattr,TRUE);
                                }
                                else
                                {
                                    //
                                    // Failed to select it to the DC in client side.
                                    // so delete it and invalidate pCXform.
                                    //
                                    IcmDeleteColorTransform(pCXform,FALSE);
                                    pCXform = NULL;
                                }
                            }

                            if (pCXform == NULL)
                            {
                                ICMMSG(("IcmSetSourceColorSpace():Fail to create/select color transform\n"));

                                //
                                // Set back previous color space. (can't fail these calls)
                                //
                                pIcmInfo->pSourceColorSpace = pOldColorSpace;
                                NtGdiSetColorSpace(hdc,hRet);
                                hRet = NULL;
                            }
                        }
                        else
                        {
                            //
                            // Otherwise, we just mark color transform might be dirty.
                            // Because new color space was selected.
                            //
                            pdcattr->ulDirty_ |= DIRTY_COLORTRANSFORM;

                            // For ColorMatchToTarget()
                            //
                            // While color matching to the target is enabled by setting
                            // uiAction to CS_ENABLE, application changes to the color
                            // space or gamut matching method are ignored.
                            // Those changes then take effect when color matching to
                            // the target is disabled.
                            //
                            if (IS_ICM_PROOFING(pdcattr->lIcmMode))
                            {
                                ICMMSG(("IcmSetSourceColorSpace():In Proofing mode, lazy setting...\n"));
                            }
                        }

                        if (hRet)
                        {
                            //
                            // Succeed to select new color space, then delete old one.
                            //
                            IcmReleaseColorSpace(NULL,pOldColorSpace,FALSE);
                        }
                        else
                        {
                            IcmReleaseColorSpace(NULL,pNewColorSpace,FALSE);
                        }
                    }
                }
                else
                {
                    ICMMSG(("IcmSetSourceColorSpace(): for Mono-device\n"));

                    //
                    // For monochrome device case, just return kernel color space
                    // handle, then just don't create client-side representitive,
                    // since there is no ICM for monochrome device.
                    //
                }
            }
            else
            {
                WARNING("Error: hdc and hColorSpace check out but NtGdi call failed\n");
                hRet = NULL;
            }
        }
        else
        {
            //
            // Same color space was selected, just return current.
            //
            hRet = hColorSpace;
        }
    }

    if (hRet == NULL)
    {
        GdiSetLastError(ERROR_INVALID_COLORSPACE);
    }

    return (hRet);
}

/******************************Public*Routine******************************\
* IcmSaveDC()
*
* History:
*    7-Dec-1998 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
IcmSaveDC(
    HDC hdc,
    PDC_ATTR pdcattr,
    PGDI_ICMINFO pIcmInfo)
{
    BOOL bRet = TRUE;

    ICMAPI(("gdi32: IcmSaveDC\n"));

    if (pdcattr && pIcmInfo)
    {
        //
        // Get currect saved level.
        //
        DWORD dwCurrentSavedDepth;

        if (NtGdiGetDCDword(hdc,DDW_SAVEDEPTH,&dwCurrentSavedDepth))
        {
            PSAVED_ICMINFO pSavedIcmInfo = LOCALALLOC(sizeof(SAVED_ICMINFO));

            if (pSavedIcmInfo)
            {
                PCACHED_COLORSPACE pSourceColorSpace = pIcmInfo->pSourceColorSpace;
                PCACHED_COLORSPACE pDestColorSpace   = pIcmInfo->pDestColorSpace;
                PCACHED_COLORSPACE pTargetColorSpace = pIcmInfo->pTargetColorSpace;
                PCACHED_COLORTRANSFORM pCXform       = pIcmInfo->pCXform;
                PCACHED_COLORTRANSFORM pBackCXform   = pIcmInfo->pBackCXform;
                PCACHED_COLORTRANSFORM pProofCXform  = pIcmInfo->pProofCXform;

                //
                // Increment reference count of color spaces in DC.
                //
                IcmReferenceColorSpace(pSourceColorSpace);
                IcmReferenceColorSpace(pDestColorSpace);
                IcmReferenceColorSpace(pTargetColorSpace);

                //
                // Increment reference count of color transform in DC.
                //
                IcmReferenceColorTransform(pCXform);
                IcmReferenceColorTransform(pBackCXform);
                IcmReferenceColorTransform(pProofCXform);

                //
                // Save color spaces.
                //
                pSavedIcmInfo->pSourceColorSpace = pSourceColorSpace;
                pSavedIcmInfo->pDestColorSpace   = pDestColorSpace;
                pSavedIcmInfo->pTargetColorSpace = pTargetColorSpace;

                //
                // Save color transforms.
                //
                pSavedIcmInfo->pCXform           = pCXform;
                pSavedIcmInfo->pBackCXform       = pBackCXform;
                pSavedIcmInfo->pProofCXform      = pProofCXform;

                //
                // Put current saved level in DC.
                //
                pSavedIcmInfo->dwSavedDepth      = dwCurrentSavedDepth;

                //
                // Insert saved data to list.
                //
                InsertHeadList(&(pIcmInfo->SavedIcmInfo),&(pSavedIcmInfo->ListEntry));

                ICMMSG(("gdi32: IcmSaveDC() - Saved Depth = %d\n",dwCurrentSavedDepth));
            }
            else
            {
                WARNING("IcmSaveDC():Failed on LOCALALLOC()\n");
                bRet = FALSE;
            }
        }
        else
        {
            WARNING("IcmSaveDC():Failed on NtGdiGetDCDword(DDW_SAVEDEPTH)\n");
            bRet = FALSE;
        }
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* IcmRestoreDC()
*
* History:
*    7-Dec-1998 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

VOID
IcmRestoreDC(
    PDC_ATTR pdcattr,
    int iLevel,
    PGDI_ICMINFO pIcmInfo)
{
    ICMAPI(("gdi32: IcmRestoreDC - iLevel = %d\n",iLevel));

    if (pIcmInfo)
    {
        //
        // Still have same ICMINFO.
        //
        PLIST_ENTRY p = pIcmInfo->SavedIcmInfo.Flink;
        BOOL        bContinue = TRUE;

        while (bContinue     &&
               (iLevel != 0) &&
               (p != &(pIcmInfo->SavedIcmInfo)))
        {
            PSAVED_ICMINFO pSavedIcmInfo = CONTAINING_RECORD(p,SAVED_ICMINFO,ListEntry);

            if (iLevel > 0)
            {
                //
                // iLevel is absolute saved depth to restore
                //
                if (iLevel == (int) pSavedIcmInfo->dwSavedDepth)
                {
                    bContinue = FALSE;
                }
            }
            else
            {
                //
                // iLevel is relative saved depth to restore
                //
                if (++iLevel == 0)
                {
                    bContinue = FALSE;
                }
            }

            if (bContinue == FALSE)
            {
                PCACHED_COLORSPACE pSourceColorSpace = pIcmInfo->pSourceColorSpace;
                PCACHED_COLORSPACE pDestColorSpace   = pIcmInfo->pDestColorSpace;
                PCACHED_COLORSPACE pTargetColorSpace = pIcmInfo->pTargetColorSpace;
                PCACHED_COLORTRANSFORM pCXform       = pIcmInfo->pCXform;
                PCACHED_COLORTRANSFORM pBackCXform   = pIcmInfo->pBackCXform;
                PCACHED_COLORTRANSFORM pProofCXform  = pIcmInfo->pProofCXform;

                //
                // Restore this saved data to DC.
                //
                pIcmInfo->pSourceColorSpace = pSavedIcmInfo->pSourceColorSpace;
                pIcmInfo->pDestColorSpace   = pSavedIcmInfo->pDestColorSpace;
                pIcmInfo->pTargetColorSpace = pSavedIcmInfo->pTargetColorSpace;
                pIcmInfo->pCXform           = pSavedIcmInfo->pCXform;
                pIcmInfo->pBackCXform       = pSavedIcmInfo->pBackCXform;
                pIcmInfo->pProofCXform      = pSavedIcmInfo->pProofCXform;

                //
                // Release color space which *WAS* selected in DC.
                //
                IcmReleaseColorSpace(NULL,pSourceColorSpace,FALSE);
                IcmReleaseColorSpace(NULL,pDestColorSpace,FALSE);
                IcmReleaseColorSpace(NULL,pTargetColorSpace,FALSE);

                //
                // Delete color transform which *WAS* selected in DC.
                //
                IcmDeleteColorTransform(pCXform,FALSE);
                IcmDeleteColorTransform(pBackCXform,FALSE);
                IcmDeleteColorTransform(pProofCXform,FALSE);

                if (pdcattr)
                {
                    //
                    // Validate flags.
                    //
                    pdcattr->ulDirty_ &= ~(DIRTY_COLORSPACE | DIRTY_COLORTRANSFORM);
                }
            }
            else
            {
                //
                // Decrement ref count of color space.
                //
                IcmReleaseColorSpace(NULL,pSavedIcmInfo->pSourceColorSpace,FALSE);
                IcmReleaseColorSpace(NULL,pSavedIcmInfo->pDestColorSpace,FALSE);
                IcmReleaseColorSpace(NULL,pSavedIcmInfo->pTargetColorSpace,FALSE);

                //
                // Decrement ref count of color transform.
                //
                IcmDeleteColorTransform(pSavedIcmInfo->pCXform,FALSE);
                IcmDeleteColorTransform(pSavedIcmInfo->pBackCXform,FALSE);
                IcmDeleteColorTransform(pSavedIcmInfo->pProofCXform,FALSE);
            }

            //
            // Get pointer to next.
            //
            p = p->Flink;

            //
            // Remove from list.
            //
            RemoveEntryList(&(pSavedIcmInfo->ListEntry));

            //
            // Free SAVED_ICMINFO.
            //
            LOCALFREE(pSavedIcmInfo);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\image.c ===
/******************************Module*Header*******************************\
* Module Name: image .c                                                    *
*                                                                          *
* Client side stubs for Alpha, Transparent and GradientFill                *
*                                                                          *
* Created: 05-Jun-1997                                                     *
* Author: Mark Enstrom [marke]                                             *
*                                                                          *
* Copyright (c) 1991-1999 Microsoft Corporation                            *
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

/******************************Public*Routine******************************\
* GdiAlphaBlend
*
*   DC to DC alpha blt
*
* Arguments:
*
*   hdcDst        - dst dc
*   DstX          - dst x origin
*   DstY          - dst y origin
*   DstCx         - dst width
*   DstCy         - dst height
*   hdcSrc        - src dc
*   SrcX          - src x origin
*   SrcY          - src y origin
*   SrcCx         - src width
*   SrcCy         - src height
*   BlendFunction - blend function
*
* Return Value:
*
*   Status
*
* History:
*
*    12/3/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
GdiAlphaBlend(
    HDC           hdcDest,
    int           DstX,
    int           DstY,
    int           DstCx,
    int           DstCy,
    HDC           hdcSrc,
    int           SrcX,
    int           SrcY,
    int           SrcCx,
    int           SrcCy,
    BLENDFUNCTION BlendFunction
    )
{
    BOOL bRet = FALSE;
    BLENDULONG Blend;
    FIXUP_HANDLE(hdcDest);
    FIXUP_HANDLE(hdcSrc);

    Blend.Blend = BlendFunction;

    //
    // check for metafile
    //

    if (!hdcSrc || IS_METADC16_TYPE(hdcSrc))
        return(bRet);

    if (IS_ALTDC_TYPE(hdcDest))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdcDest))
            return(bRet);

        DC_PLDC(hdcDest,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_AnyBitBlt(hdcDest,
                              DstX,
                              DstY,
                              DstCx,
                              DstCy,
                              (LPPOINT)NULL,
                              hdcSrc,
                              SrcX,
                              SrcY,
                              SrcCx,
                              SrcCy,
                              (HBITMAP)NULL,
                              0,
                              0,
                              Blend.ul,
                              EMR_ALPHABLEND))
            {
                return(bRet);
            }
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
        {
            vSAPCallback(pldc);
        }

        if (pldc->fl & LDC_DOC_CANCELLED)
        {
            return(bRet);
        }

        if (pldc->fl & LDC_CALL_STARTPAGE)
        {
            StartPage(hdcDest);
        }
    }

    RESETUSERPOLLCOUNT();

    //
    // call kernel to draw
    //

    bRet = NtGdiAlphaBlend(
                      hdcDest,
                      DstX,
                      DstY,
                      DstCx,
                      DstCy,
                      (HDC)hdcSrc,
                      SrcX,
                      SrcY,
                      SrcCx,
                      SrcCy,
                      BlendFunction,
                      NULL
                      );
    return(bRet);
}

/******************************Public*Routine******************************\
* GdiGradientFill
*
*   metafile or call kernel
*
* Arguments:
*
*   hdc      - hdc
*   pVertex  - pointer to vertex array
*   nVertex  - number of elements in vertex array
*   pMesh    - pointer to mesh array
*   nCount   - number of elements in mesh array
*   ulMode   - drawing mode
*
* Return Value:
*
*   status
*
* History:
*
*    12/3/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
GdiGradientFill(
    HDC         hdc,
    PTRIVERTEX  pVertex,
    ULONG       nVertex,
    PVOID       pMesh,
    ULONG       nCount,
    ULONG       ulMode
    )
{
    BOOL bRet = TRUE;
    PTRIVERTEX pTempVertex = pVertex;
    PDC_ATTR pdcattr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        //
        // NT metafile
        //

        if (IS_ALTDC_TYPE(hdc))
        {
            PLDC pldc;

            if (IS_METADC16_TYPE(hdc))
                return(bRet);

            DC_PLDC(hdc,pldc,bRet);

            if (pldc->iType == LO_METADC)
            {
                bRet = MF_GradientFill(hdc,pVertex,nVertex,pMesh,nCount,ulMode);
                if (!bRet)
                {
                    return(bRet);
                }
            }

            if (pldc->fl & LDC_SAP_CALLBACK)
            {
                vSAPCallback(pldc);
            }

            if (pldc->fl & LDC_DOC_CANCELLED)
            {
                return(bRet);
            }

            if (pldc->fl & LDC_CALL_STARTPAGE)
            {
                StartPage(hdc);
            }
        }

        RESETUSERPOLLCOUNT();

        //
        // if icm is on, tanslate vertex array
        //

        if (
             (IS_ICM_INSIDEDC(pdcattr->lIcmMode)) &&
             (pVertex != NULL)              &&
             (nVertex > 0)                  &&
             (nVertex <  0x80000000)
           )
        {
            pTempVertex = (PTRIVERTEX)LOCALALLOC(nVertex * sizeof(TRIVERTEX));

            if (pTempVertex != NULL)
            {
                //
                // copy to new vertex array
                //

                memcpy(pTempVertex,pVertex,nVertex * sizeof(TRIVERTEX));

                bRet = IcmTranslateTRIVERTEX(hdc,pdcattr,pTempVertex,nVertex);
            }
            else
            {
                bRet = FALSE;
                GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
            }
        }

        if (bRet)
        {
            //
            // call kernel to draw
            //

            bRet = NtGdiGradientFill(hdc,
                                     pTempVertex,
                                     nVertex,
                                     pMesh,
                                     nCount,
                                     ulMode
                                     );
        }

        //
        // free temp buffer
        //

        if (pTempVertex != pVertex)
        {
            LOCALFREE(pTempVertex);
        }
    }
    else
    {
        bRet = FALSE;
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* GdiTransparentBlt
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    12/3/1996 Lingyun Wang
*
\**************************************************************************/

BOOL
GdiTransparentBlt(
                 HDC   hdcDest,
                 int   DstX,
                 int   DstY,
                 int   DstCx,
                 int   DstCy,
                 HDC   hSrc,
                 int   SrcX,
                 int   SrcY,
                 int   SrcCx,
                 int   SrcCy,
                 UINT  Color
                 )
{
    BOOL bRet = FALSE;
    PDC_ATTR pdca;

    if ((DstCx <= 0) || (DstCy <= 0) || (SrcCx <= 0) || (SrcCy <= 0))
    {
        return (FALSE);
    }

    FIXUP_HANDLE(hdcDest);
    FIXUP_HANDLE(hSrc);

    if (!hSrc || IS_METADC16_TYPE(hSrc))
        return(bRet);

    if (IS_ALTDC_TYPE(hdcDest))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdcDest))
            return(bRet);

        DC_PLDC(hdcDest,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_AnyBitBlt(hdcDest,
                              DstX,
                              DstY,
                              DstCx,
                              DstCy,
                              (LPPOINT)NULL,
                              hSrc,
                              SrcX,
                              SrcY,
                              SrcCx,
                              SrcCy,
                              (HBITMAP)NULL,
                              0,
                              0,
                              Color,
                              EMR_TRANSPARENTBLT))
            {
                return(bRet);
            }
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
        {
            vSAPCallback(pldc);
        }

        if (pldc->fl & LDC_DOC_CANCELLED)
        {
            return(bRet);
        }

        if (pldc->fl & LDC_CALL_STARTPAGE)
        {
            StartPage(hdcDest);
        }
    }


    RESETUSERPOLLCOUNT();

    bRet = NtGdiTransparentBlt(
                      hdcDest,
                      DstX,
                      DstY,
                      DstCx,
                      DstCy,
                      hSrc,
                      SrcX,
                      SrcY,
                      SrcCx,
                      SrcCy,
                      Color);
    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\makefile.inc ===
$(DYNLINK_LIB) : $(DYNLINK_LIBP)

$(DYNLINK_LIBP) $(DYNLINK_LIBP:.lib=.exp): $(O)\$(TARGETNAMEP).def $(LIBRARY_OBJS)
   -$(LIB_NAME) -out:$(DYNLINK_LIBP) @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\$(TARGETNAMEP).def
$(LIBRARY_OBJS)
<<NOKEEP

C_DEFINES=$(C_DEFINES) -DPRIVATE= -D_$(ALT_PROJECT)_
$(O)\$(TARGETNAMEP).def: ..\$(TARGETNAME).def
    $(C_PREPROCESSOR) ..\$(TARGETNAME).def > $@


$(UMPDDDILIB) $(UMPDDDILIB:.lib=.exp): $(O)\umpdddip.def $(LIBRARY_OBJS)
   -$(LIB_NAME) -out:$(UMPDDDILIB) @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\umpdddip.def
$(LIBRARY_OBJS)
<<NOKEEP

C_DEFINES=$(C_DEFINES) -DPRIVATE= -D_$(ALT_PROJECT)_
$(O)\umpdddip.def: ..\umpdddi.def
    $(C_PREPROCESSOR) ..\umpdddi.def > $@

$(WINPPILIB) $(WINPPILIB:.lib=.exp): $(O)\winppi.def $(LIBRARY_OBJS)
   -$(LIB_NAME) -out:$(WINPPILIB) @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\winppi.def
$(LIBRARY_OBJS)
<<NOKEEP

C_DEFINES=$(C_DEFINES) -DPRIVATE= -D_$(ALT_PROJECT)_
$(O)\winppi.def: ..\winppi.def
    $(C_PREPROCESSOR) ..\winppi.def > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\mem.c ===
/******************************Module*Header*******************************\
* Module Name: mem.c							   
*									   
* Support routines for client side memory management.	                   
*									   
* Created: 30-May-1991 21:55:57 					   
* Author: Charles Whitmer [chuckwh]					   
*									   
* Copyright (c) 1991-1999 Microsoft Corporation                            
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop


PVOID __nw(unsigned int ui)
{
    USE(ui);
    RIP("Bogus __nw call");
    return(NULL);
}

VOID __dl(PVOID pv)
{
    USE(pv);
    RIP("Bogus __dl call");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\linedda.c ===
/******************************Module*Header*******************************\
* Module Name: linedda.c
*
* (Brief description)
*
* Created: 04-Jan-1991 09:23:30
* Author: Eric Kutter [erick]
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
* (General description of its use)
*
* Dependencies:
*
*   (#defines)
*
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

/******************************Public*Routine******************************\
* BOOL WINAPI InnerLineDDA(x1,y1,x2,y2,pfn,pvUserData)
*
*   This routine is basic version of Bressenhams Algorithm for drawing lines.
*   For each point, pfn is called with that point and the user passed in
*   data pointer, pvUserData.  This call is device independant and does no
*   scaling or rotating.  This wouldn't be possible since there is no
*   DC passed in.  It is probably an old artifact of Windows 1.0.  It is
*   strictly a client side function.
*
*   return value is TRUE unless pfn is NULL.
*
* History:
*  07-Jan-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL WINAPI LineDDA(
    int    x1,
    int    y1,
    int    x2,
    int    y2,
    LINEDDAPROC   pfn,
    LPARAM UserData)
{
    int dx;
    int xinc;
    int dy;
    int yinc;
    int iError;
    int cx;

    if (pfn == (LINEDDAPROC)NULL)
        return(FALSE);

    dx   = x2 - x1;
    xinc = 1;

    if (dx <= 0)
    {
        xinc = -xinc;
        dx = -dx;
    }

// prepare for ascending y

    dy   = y2 - y1;
    yinc = 1;
    iError = 0;

// if decending

    if (dy <= 0)
    {
        yinc = -yinc;
        dy = -dy;
        //iError = 0; // in the win3.0 version, this is a 1 but it seems
    }                 // to give wierd results.

// y Major

    if (dy >= dx)
    {
        iError = (iError + dy) / 2;
        cx = dy;

        while (cx--)
        {
            (*pfn)(x1,y1,UserData);
            y1 += yinc;
            iError -= dx;
            if (iError < 0)
            {
                iError += dy;
                x1 += xinc;
            }
        }
    }
    else
    {
// x Major

        iError = (iError + dx) / 2;
        cx = dx;

        while (cx--)
        {
            (*pfn)(x1,y1,UserData);

            x1 += xinc;
            iError -= dy;

            if (iError < 0)
            {
                iError += dx;
                y1 += yinc;
            }
        }
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\local.h ===
/******************************Module*Header*******************************\
* Module Name: local.h                                                     *
*                                                                          *
* Definitions needed for client side objects.                              *
*                                                                          *
* Copyright (c) 1993-1999 Microsoft Corporation                            *
\**************************************************************************/

#include "gdispool.h"
#include "umpd.h"
#include "cliumpd.h"


#define MIRRORED_HDC(hdc)                 (GetLayout(hdc) & LAYOUT_RTL)

//
// Semaphore utilities
//

#define INITIALIZECRITICALSECTION(psem) RtlInitializeCriticalSection(psem)
#define ENTERCRITICALSECTION(hsem)      RtlEnterCriticalSection(hsem)
#define LEAVECRITICALSECTION(hsem)      RtlLeaveCriticalSection(hsem)
#define DELETECRITICALSECTION(psem)     RtlDeleteCriticalSection(psem)

//
// Memory allocation
//

#define LOCALALLOC(size)            RtlAllocateHeap(RtlProcessHeap(),0,size)
#define LOCALFREE(pv)               (void)RtlFreeHeap(RtlProcessHeap(),0,pv)


extern DWORD GdiBatchLimit;

typedef LPWSTR PWSZ;

extern HBRUSH ghbrDCBrush;
extern HPEN   ghbrDCPen;
extern BOOL   gbWOW64;

#define     WOW64PRINTING(pUMPD)    ((gbWOW64) && (pUMPD) && ((pUMPD)->pp))

void vUMPDWow64Shutdown();

/**************************************************************************\
 *
 * Local handle macros
 *
\**************************************************************************/

// macros to validate the handles passed in and setup some local variables
// for accessing the handle information.

#define DC_PLDC(hdc,pldc,Ret)                                      \
    pldc = GET_PLDC(hdc);                                          \
    if (!pldc || (LO_TYPE(hdc) == LO_METADC16_TYPE))               \
    {                                                              \
        GdiSetLastError(ERROR_INVALID_HANDLE);                     \
        return(Ret);                                               \
    }                                                              \
    ASSERTGDI((pldc->iType == LO_DC) || (pldc->iType == LO_METADC),"DC_PLDC error\n");

#define GET_PLDC(hdc)           pldcGet(hdc)
#define GET_PMDC(hdc)           pmdcGetFromHdc(hdc)

#define GET_PMFRECORDER16(pmf,hdc)          \
{                                           \
    pmf = (PMFRECORDER16)plinkGet(hdc);     \
    if (pmf)                                \
        pmf = ((PLINK)pmf)->pv;             \
}

#define hdcFromIhdc(i)          GdiFixUpHandle((HANDLE)i)
#define pmdcGetFromIhdc(i)      pmdcGetFromHdc(GdiFixUpHandle((HANDLE)i))

// ALTDC_TYPE is not LO_ALTDC_TYPE || LO_METADC16_TYPE

#define IS_ALTDC_TYPE(h)    (LO_TYPE(h) != LO_DC_TYPE)
#define IS_METADC16_TYPE(h) (LO_TYPE(h) == LO_METADC16_TYPE)

// these macros are defined to aid in determining color vs monochrome pages

#define CLEAR_COLOR_PAGE(pldc) pldc->fl &= ~LDC_COLOR_PAGE
#define IS_COLOR_GREY(color) ((BYTE)color == (BYTE)(color >> 8) && (BYTE)color == (BYTE)(color >> 16))
#define IS_GREY_MONO(color) ((BYTE)color == (BYTE)0x0 || (BYTE)color == (BYTE)0xff)
#define IS_COLOR_MONO(color) ((color & 0x00ffffff) == 0 || (color & 0x00ffffff) == 0x00ffffff)

#if 1        // disable debug messages

#define DESIGNATE_COLOR_PAGE(pldc) CLEAR_COLOR_PAGE(pldc);
#define SET_COLOR_PAGE(pldc) pldc->fl |= LDC_COLOR_PAGE;
#define CHECK_COLOR_PAGE(pldc,color)            \
{                                               \
    if (!IS_COLOR_MONO(color))                  \
        pldc->fl |= LDC_COLOR_PAGE;             \
}

#else

#define DESIGNATE_COLOR_PAGE(pldc)              \
{                                               \
    if (pldc->fl & LDC_COLOR_PAGE)              \
    {                                           \
        DbgPrint ("gdi32:Color Page\n");        \
    }                                           \
    else                                        \
    {                                           \
        DbgPrint ("gdi32:Monochrome Page\n");   \
    }                                           \
    CLEAR_COLOR_PAGE(pldc);                     \
}
#define CHECK_COLOR_PAGE(pldc,color)            \
{                                               \
    if (!IS_COLOR_MONO(color))                  \
    {                                           \
        pldc->fl |= LDC_COLOR_PAGE;             \
        DbgPrint ("Set Color Page: %08x %s %d\n",color,__FILE__,__LINE__); \
    }                                           \
}
#define SET_COLOR_PAGE(pldc)            \
{                                       \
    pldc->fl |= LDC_COLOR_PAGE;         \
    DbgPrint ("Set color page %s %d\n",__FILE__,__LINE__); \
}
#endif

/**************************************************************************\
 *
 * LINK stuff
 *
\**************************************************************************/

#define INVALID_INDEX      0xffffffff
#define LINK_HASH_SIZE     128
#define H_INDEX(h)            ((USHORT)(h))
#define LINK_HASH_INDEX(h) (H_INDEX(h) & (LINK_HASH_SIZE-1))

typedef struct tagLINK
{
    DWORD           metalink;
    struct tagLINK *plinkNext;
    HANDLE          hobj;
    PVOID           pv;
} LINK, *PLINK;

extern PLINK aplHash[LINK_HASH_SIZE];

PLINK   plinkGet(HANDLE h);
PLINK   plinkCreate(HANDLE h,ULONG ulSize);
BOOL    bDeleteLink(HANDLE h);

HANDLE  hCreateClientObjLink(PVOID pv,ULONG ulType);
PVOID   pvClientObjGet(HANDLE h, DWORD dwLoType);
BOOL    bDeleteClientObjLink(HANDLE h);

int     iGetServerType(HANDLE hobj);

/****************************************************************************
 *
 * UFI Hash stuff
 *
 ***************************************************************************/

typedef struct _MERGEDVIEW
{
    BYTE *pjMem; // pointer to the merged font's memory image
    ULONG cjMem; // its size
} MERGEDVIEW;

// info needed for subsetting first and subsequent pages

typedef struct _SSINFO
{
    BYTE *pjBits;       // glyph index bitfield, one bit set for every glyph
                        // used on pages up to and including this one
    ULONG cjBits;       // cj of the bitfield above
    ULONG cGlyphsSoFar; // number of bits set in the bitfield above

    ULONG cDeltaGlyphs; // number of glyphs in the delta for this page
    BYTE *pjDelta;      // bitfield for glyphs in the delta for this page
} SSINFO;

typedef union _SSMERGE
{
    MERGEDVIEW mvw;  // only used on the server
    SSINFO     ssi;  // only used on the client
} SSMERGE;

#define UFI_HASH_SIZE   32  // this should be plenty

typedef struct tagUFIHASH
{
    UNIVERSAL_FONT_ID  ufi;
    struct tagUFIHASH *pNext;
    FSHORT             fs1;
    FSHORT             fs2;

// client of server side union

    SSMERGE            u;

} UFIHASH, *PUFIHASH;


#if 0

typedef struct tagUFIHASH
{
    UNIVERSAL_FONT_ID  ufi;
    struct tagUFIHASH *pNext;
    FSHORT             fs1; // server or client, if client delta or not
    FSHORT             fs2; // private or public, dv or not

// this part of the structure is only optionally allocated, only needed
// for subsetting code.

    PBYTE   pjMemory;
    ULONG   ulMemBytes;

// these fields are only used on the client side to do book keeping about
// which glyphs from this font are used in the document

    ULONG   ulDistGlyph;
    ULONG   ulDistDelta;
    PBYTE   pjDelta;
} UFIHASH, *PUFIHASH;

#endif

#define FLUFI_SERVER 1
#define FLUFI_DELTA  2

// Define the local DC object.

#define PRINT_TIMER 0

#if PRINT_TIMER
extern BOOL bPrintTimer;
#endif

/****************************************************************************
 *
 * PostScript Data
 *
 ***************************************************************************/

typedef struct _EMFITEMPSINJECTIONDATA
{
    DWORD      cjSize;
    int        nEscape;
    int        cjInput;
    BYTE       EscapeData[1];
} EMFITEMPSINJECTIONDATA, *PEMFITEMPSINJECTIONDATA;

typedef struct _PS_INJECTION_DATA
{
    LIST_ENTRY              ListEntry;
    EMFITEMPSINJECTIONDATA  EmfData;
} PS_INJECTION_DATA, *PPS_INJECTION_DATA;

/****************************************************************************
 *
 * Local DC
 *
 ***************************************************************************/

typedef struct _LDC
{
    HDC                 hdc;
    ULONG               fl;
    ULONG               iType;

// Metafile information.

    PVOID               pvPMDC; // can't have a PMDC here since it is a class

// Printing information.
// We need to cache the port name from createDC in case it is not specified at StartDoc

    LPWSTR              pwszPort;
    ABORTPROC           pfnAbort;       // Address of application's abort proc.
    ULONG               ulLastCallBack; // Last time we call back to abort proc.
    HANDLE              hSpooler;       // handle to the spooler.
    PUMPD               pUMPD;          // pointer to user-mode printer driver info
    KERNEL_PUMDHPDEV    pUMdhpdev;      // pointer to user-mode pdev info
    PUFIHASH            *ppUFIHash;     // used to keep track of fonts used in doc
    PUFIHASH            *ppDVUFIHash;   // used to keep track of mm instance fonts used in a doc
    PUFIHASH            *ppSubUFIHash;  // used to keep track of subsetted fonts in the doc
    DEVMODEW            *pDevMode;      // used to keep trak of ResetDC's
    UNIVERSAL_FONT_ID   ufi;            // current UFI used for forced mapping
    HANDLE              hEMFSpool;      // information used for recording EMF data
#if PRINT_TIMER
    DWORD               msStartDoc;     // Time of StartDoc in miliseconds.
    DWORD               msStartPage;    // Time of StartPage in miliseconds.
#endif
    DWORD               dwSizeOfPSDataToRecord; // Total size of PostScript Injection data to record EMF
    LIST_ENTRY          PSDataList;     // List to PostScript Injection data
    DEVCAPS             DevCaps;
    HBRUSH              oldSetDCBrushColorBrush; // Holds latest temp DC brush
    HPEN                oldSetDCPenColorPen;     // Holds latest temp DC pen
} LDC,*PLDC;

// Flags for ldc.fl.

#define LDC_SAP_CALLBACK            0x00000020L
#define LDC_DOC_STARTED             0x00000040L
#define LDC_PAGE_STARTED            0x00000080L
#define LDC_CALL_STARTPAGE          0x00000100L
#define LDC_NEXTBAND                0x00000200L
#define LDC_EMPTYBAND               0x00000400L
#define LDC_EMBED_FONTS             0x00001000L
#define LDC_META_ARCDIR_CLOCKWISE   0x00002000L
#define LDC_FONT_SUBSET             0x00004000L
#define LDC_FONT_CHANGE             0x00008000L
#define LDC_DOC_CANCELLED           0x00010000L
#define LDC_META_PRINT              0x00020000L
#define LDC_PRINT_DIRECT            0x00040000L
#define LDC_BANDING                 0x00080000L
#define LDC_DOWNLOAD_FONTS          0x00100000L
#define LDC_RESETDC_CALLED          0x00200000L
#define LDC_FORCE_MAPPING           0x00400000L
#define LDC_LINKED_FONTS            0x00800000L
#define LDC_INFO                    0x01000000L
#define LDC_CACHED_DEVCAPS          0x02000000L
#define LDC_ICM_INFO                0x04000000L
#define LDC_DOWNLOAD_PROFILES       0x08000000L
#define LDC_CALLED_ENDPAGE          0x10000000L
#define LDC_COLOR_PAGE              0x20000000L

// Values for lMsgSAP.

#define MSG_FLUSH       1L  // Created thread should flush its message queue.
#define MSG_CALL_USER   2L  // Created thread should call user.
#define MSG_EXIT        3L  // Created thread should exit.

// TYPE of DC

#define LO_DC           0x01
#define LO_METADC       0x02

extern RTL_CRITICAL_SECTION  semLocal;  // Semaphore for handle management
extern RTL_CRITICAL_SECTION  semBrush;  // semphore for client brush


// ahStockObjects will contain both the stock objects visible to an
// application, and internal ones such as the private stock bitmap.

extern ULONG_PTR ahStockObjects[];

// Declare support functions.

HANDLE GdiFixUpHandle(HANDLE h);

PLDC    pldcGet(HDC hdc);
VOID    vSetPldc(HDC hdc,PLDC pldc);
VOID    GdiSetLastError(ULONG iError);
HBITMAP GdiConvertBitmap(HBITMAP hbm);
HRGN    GdiConvertRegion(HRGN hrgn);
HDC     GdiConvertDC(HDC hdc);
HBRUSH  GdiConvertBrush(HBRUSH hbrush);
VOID    vSAPCallback(PLDC);
BOOL    InternalDeleteDC(HDC hdc,ULONG iType);
int     GetBrushBits(HDC hdc,HBITMAP hbmRemote,UINT iUsage,DWORD cbBmi,
            LPVOID pBits,LPBITMAPINFO pBmi);
VOID    CopyCoreToInfoHeader(LPBITMAPINFOHEADER pbmih,LPBITMAPCOREHEADER pbmch);
HBITMAP GetObjectBitmapHandle(HBRUSH hbr, UINT *piUsage);
BOOL    MonoBitmap(HBITMAP hSrvBitmap);

int     APIENTRY SetBkModeWOW(HDC hdc,int iMode);
int     APIENTRY SetPolyFillModeWOW(HDC hdc,int iMode);
int     APIENTRY SetROP2WOW(HDC hdc,int iMode);
int     APIENTRY SetStretchBltModeWOW(HDC hdc,int iMode);
UINT    APIENTRY SetTextAlignWOW(HDC hdc,UINT iMode);

HMETAFILE    WINAPI   SetMetaFileBitsAlt(HLOCAL);
HENHMETAFILE APIENTRY SetEnhMetaFileBitsAlt(HLOCAL, HANDLE, HANDLE, UINT64);
BOOL    InternalDeleteEnhMetaFile(HENHMETAFILE hemf, BOOL bAllocBuffer);
BOOL    SetFontXform(HDC hdc,FLOAT exScale,FLOAT eyScale);
BOOL    DeleteObjectInternal(HANDLE h);
DWORD   GetServerObjectType(HGDIOBJ h);
BOOL    MakeInfoDC(HDC hdc,BOOL bSet);
BOOL    GetDCPoint(HDC hdc,DWORD i,PPOINT pptOut);

HANDLE  CreateClientObj(ULONG ulType);
BOOL    DeleteClientObj(HANDLE h);
PLDC    pldcCreate(HDC hdc,ULONG ulType);
BOOL    bDeleteLDC(PLDC pldc);

BOOL    bGetANSISetMap();

HANDLE  CreateTempSpoolFile();

// Some convenient defines.

typedef BITMAPINFO   BMI;
typedef PBITMAPINFO  PBMI;
typedef LPBITMAPINFO LPBMI;

typedef BITMAPINFOHEADER   BMIH;
typedef PBITMAPINFOHEADER  PBMIH;
typedef LPBITMAPINFOHEADER LPBMIH;

typedef BITMAPCOREINFO   BMC;
typedef PBITMAPCOREINFO  PBMC;
typedef LPBITMAPCOREINFO LPBMC;

typedef BITMAPCOREHEADER   BMCH;
typedef PBITMAPCOREHEADER  PBMCH;
typedef LPBITMAPCOREHEADER LPBMCH;

#define NEG_INFINITY   0x80000000
#define POS_INFINITY   0x7fffffff

// Check if a source is needed in a 3-way bitblt operation.
// This works on both rop and rop3.  We assume that a rop contains zero
// in the high byte.
//
// This is tested by comparing the rop result bits with source (column A
// below) vs. those without source (column B).  If the two cases are
// identical, then the effect of the rop does not depend on the source
// and we don't need a source device.  Recall the rop construction from
// input (pattern, source, target --> result):
//
//      P S T | R   A B         mask for A = 0CCh
//      ------+--------         mask for B =  33h
//      0 0 0 | x   0 x
//      0 0 1 | x   0 x
//      0 1 0 | x   x 0
//      0 1 1 | x   x 0
//      1 0 0 | x   0 x
//      1 0 1 | x   0 x
//      1 1 0 | x   x 0
//      1 1 1 | x   x 0

#define ISSOURCEINROP3(rop3)    \
        (((rop3) & 0xCCCC0000) != (((rop3) << 2) & 0xCCCC0000))

#define MIN(A,B)    ((A) < (B) ?  (A) : (B))
#define MAX(A,B)    ((A) > (B) ?  (A) : (B))
#define MAX4(a, b, c, d)    max(max(max(a,b),c),d)
#define MIN4(a, b, c, d)    min(min(min(a,b),c),d)

//
// Win31 compatibility stuff.
// see user\client
//

DWORD GetAppCompatFlags(KERNEL_PVOID);
DWORD GetAppCompatFlags2(WORD); // defined in w32\w32inc\usergdi.h

#define ABS(X) (((X) < 0 ) ? -(X) : (X))

#define META

int GetBreakExtra (HDC hdc);
int GetcBreak (HDC hdc);
HANDLE GetDCObject (HDC, int);
DWORD GetDCDWord(HDC hdc,UINT index,INT error );


#if DBG
extern int gerritv;


#define MFD1(X) { if(gerritv) DbgPrint(X); }
#define MFD2(X,Y) { if(gerritv) DbgPrint(X,Y); }
#define MFD3(X,Y,Z) { if(gerritv) DbgPrint(X,Y,Z); }

#else

#define MFD1(X)
#define MFD2(X,Y)
#define MFD3(X,Y,Z)

#endif

BOOL    AssociateEnhMetaFile(HDC);
HENHMETAFILE UnassociateEnhMetaFile(HDC, BOOL);
ULONG   ulToASCII_N(LPSTR psz, DWORD cbAnsi, LPWSTR pwsz, DWORD c);
DWORD   GetAndSetDCDWord( HDC, UINT, UINT, UINT, WORD, UINT );

#ifdef DBCS
#define gbDBCSCodeOn  TRUE
#endif

/**************************************************************************\
 *
 * SPOOLER Linking routines.  We don't want to staticly link to the spooler
 * so that it doesn't need to be brought in until necesary.
 *
 *  09-Aug-1994 -by-  Eric Kutter [erick]
 *
\**************************************************************************/


BOOL bLoadSpooler();

#define BLOADSPOOLER    ((ghSpooler != NULL) || bLoadSpooler())

typedef LPWSTR (FAR WINAPI * FPSTARTDOCDLGW)(HANDLE,CONST DOCINFOW *);
typedef BOOL   (FAR WINAPI * FPOPENPRINTERW)(LPWSTR,LPHANDLE,LPPRINTER_DEFAULTSW);
typedef BOOL   (FAR WINAPI * FPRESETPRINTERW)(HANDLE,LPPRINTER_DEFAULTSW);
typedef BOOL   (FAR WINAPI * FPCLOSEPRINTER)(HANDLE);
typedef BOOL   (FAR WINAPI * FPGETPRINTERW)(HANDLE,DWORD,LPBYTE,DWORD,LPDWORD);
typedef BOOL   (FAR WINAPI * FPGETPRINTERDRIVERW)(HANDLE,LPWSTR,DWORD,LPBYTE,DWORD,LPDWORD);

typedef BOOL   (FAR WINAPI * FPENDDOCPRINTER)(HANDLE);
typedef BOOL   (FAR WINAPI * FPENDPAGEPRINTER)(HANDLE);
typedef BOOL   (FAR WINAPI * FPREADPRINTER)(HANDLE,LPVOID,DWORD,LPDWORD);
typedef BOOL   (FAR WINAPI * FPSPLREADPRINTER)(HANDLE,LPBYTE *,DWORD);
typedef DWORD  (FAR WINAPI * FPSTARTDOCPRINTERW)(HANDLE,DWORD,LPBYTE);
typedef BOOL   (FAR WINAPI * FPSTARTPAGEPRINTER)(HANDLE);
typedef BOOL   (FAR WINAPI * FPWRITERPRINTER)(HANDLE,LPVOID,DWORD,LPDWORD);
typedef BOOL   (FAR WINAPI * FPABORTPRINTER)(HANDLE);
typedef BOOL   (FAR WINAPI * FPQUERYSPOOLMODE)(HANDLE,FLONG*,ULONG*);
typedef INT    (FAR WINAPI * FPQUERYREMOTEFONTS)(HANDLE,PUNIVERSAL_FONT_ID,ULONG);
typedef BOOL   (FAR WINAPI * FPSEEKPRINTER)(HANDLE,LARGE_INTEGER,PLARGE_INTEGER,DWORD,BOOL);
typedef BOOL   (FAR WINAPI * FPQUERYCOLORPROFILE)(HANDLE,PDEVMODEW,ULONG,PVOID,ULONG*,FLONG*);
typedef VOID   (FAR WINAPI * FPSPLDRIVERUNLOADCOMPLETE)(LPWSTR);
typedef HANDLE (FAR WINAPI * FPGETSPOOLFILEHANDLE)(HANDLE);
typedef HANDLE (FAR WINAPI * FPCOMMITSPOOLDATA)(HANDLE, HANDLE, DWORD);
typedef BOOL   (FAR WINAPI * FPCLOSESPOOLFILEHANDLE)(HANDLE, HANDLE);
typedef LONG   (FAR WINAPI * FPDOCUMENTPROPERTIESW)(HWND,HANDLE,LPWSTR,PDEVMODEW,PDEVMODEW,DWORD);
typedef DWORD  (FAR WINAPI * FPLOADSPLWOW64)(HANDLE *hProcess);

extern HINSTANCE           ghSpooler;
extern FPSTARTDOCDLGW      fpStartDocDlgW;
extern FPOPENPRINTERW      fpOpenPrinterW;
extern FPRESETPRINTERW     fpResetPrinterW;
extern FPCLOSEPRINTER      fpClosePrinter;
extern FPGETPRINTERW       fpGetPrinterW;
extern FPGETPRINTERDRIVERW fpGetPrinterDriverW;
extern PFNDOCUMENTEVENT    fpDocumentEvent;
extern FPQUERYCOLORPROFILE fpQueryColorProfile;

extern FPSPLDRIVERUNLOADCOMPLETE fpSplDriverUnloadComplete;

extern FPENDDOCPRINTER     fpEndDocPrinter;
extern FPENDPAGEPRINTER    fpEndPagePrinter;
extern FPSPLREADPRINTER    fpSplReadPrinter;
extern FPREADPRINTER       fpReadPrinter;
extern FPSTARTDOCPRINTERW  fpStartDocPrinterW;
extern FPSTARTPAGEPRINTER  fpStartPagePrinter;
extern FPABORTPRINTER      fpAbortPrinter;
extern FPQUERYSPOOLMODE    fpQuerySpoolMode;
extern FPQUERYREMOTEFONTS  fpQueryRemoteFonts;
extern FPSEEKPRINTER       fpSeekPrinter;

extern FPGETSPOOLFILEHANDLE     fpGetSpoolFileHandle;
extern FPCOMMITSPOOLDATA        fpCommitSpoolData;
extern FPCLOSESPOOLFILEHANDLE   fpCloseSpoolFileHandle;

extern FPDOCUMENTPROPERTIESW    fpDocumentPropertiesW;
extern FPLOADSPLWOW64           fpLoadSplWow64;


int DocumentEventEx(PUMPD, HANDLE, HDC, INT, ULONG, PVOID, ULONG, PVOID);
DWORD StartDocPrinterWEx(PUMPD, HANDLE, DWORD, LPBYTE);
BOOL  EndDocPrinterEx(PUMPD, HANDLE);
BOOL  StartPagePrinterEx(PUMPD, HANDLE);
BOOL  EndPagePrinterEx(PUMPD, HANDLE);
BOOL  AbortPrinterEx(PLDC, BOOL);
BOOL  ResetPrinterWEx(PLDC, PRINTER_DEFAULTSW *);
BOOL  QueryColorProfileEx(PLDC, PDEVMODEW, ULONG, PVOID, ULONG *, FLONG *);

extern BOOL MFP_StartDocA(HDC hdc, CONST DOCINFOA * pDocInfo, BOOL bBanding );
extern BOOL MFP_StartDocW(HDC hdc, CONST DOCINFOW * pDocInfo, BOOL bBanding );
extern int  MFP_StartPage(HDC hdc );
extern int  MFP_EndPage(HDC hdc );
extern int  MFP_EndFormPage(HDC hdc );
extern int  MFP_EndDoc(HDC hdc);
extern BOOL MFP_ResetBanding( HDC hdc, BOOL bBanding );
extern BOOL MFP_ResetDCW( HDC hdc, DEVMODEW *pdmw );
extern int  DetachPrintMetafile( HDC hdc );
extern HDC  ResetDCWInternal(HDC hdc, CONST DEVMODEW *pdm, BOOL *pbBanding);
extern BOOL PutDCStateInMetafile( HDC hdcMeta );


//font subsetting routines
typedef void *(WINAPIV *CFP_ALLOCPROC) (size_t);
typedef void *(WINAPIV *CFP_REALLOCPROC) (void *, size_t);
typedef void (WINAPIV *CFP_FREEPROC) (void *);

typedef SHORT  (FAR WINAPIV * FPCREATEFONTPACKAGE)(const PUCHAR, const ULONG,
                                                   PUCHAR*, ULONG*, ULONG*, const USHORT,
                                                   const USHORT, const USHORT, const USHORT,
                                                   const USHORT, const USHORT,
                                                   const PUSHORT, const USHORT,
                                                   CFP_ALLOCPROC, CFP_REALLOCPROC, CFP_FREEPROC,
                                                   void*);

typedef SHORT  (FAR WINAPIV * FPMERGEFONTPACKAGE)(const PUCHAR, const ULONG, const PUCHAR, const ULONG, PUCHAR*,
                                                 ULONG*, ULONG*, const USHORT,
                                                 CFP_ALLOCPROC, CFP_REALLOCPROC, CFP_FREEPROC,
                                                 void*);
extern FPCREATEFONTPACKAGE  gfpCreateFontPackage;
extern FPMERGEFONTPACKAGE   gfpMergeFontPackage;

// gulMaxCig is used to decide whether font subset should be used for remote printing
extern ULONG    gulMaxCig;

#if DBG
#define DBGSUBSET 1
#endif

#ifdef  DBGSUBSET
extern FLONG    gflSubset;

#define FL_SS_KEEPLIST      1
#define FL_SS_BUFFSIZE      2
#define FL_SS_SPOOLTIME     4
#define FL_SS_PAGETIME      8
#define FL_SS_SUBSETTIME    16
#endif //  DBGSUBSET

/**************************************************************************\
 *
 * EMF structures.
 *
 *  EMFSPOOLHEADER - first thing in a spool file
 *
 *  EMFITEMHEADER  - defines items (blocks) of a metafile.  This includes
 *                   fonts, pages, new devmode, list of things to do before
 *                   first start page.
 *
 *                   cjSize is the size of the data following the header
 *
 *
\**************************************************************************/

//
// Round up n to the nearest multiple of sizeof(DWORD) = 4
//

#define ROUNDUP_DWORDALIGN(n) (((n) + 3) & ~3)

typedef struct tagEMFSPOOLHEADER {
    DWORD dwVersion;    // version of this EMF spoolfile
    DWORD cjSize;       // size of this structure
    DWORD dpszDocName;  // offset to lpszDocname value of DOCINFO struct
    DWORD dpszOutput;   // offset to lpszOutput value of DOCINFO struct
} EMFSPOOLHEADER;


#define EMRI_METAFILE          0x00000001
#define EMRI_ENGINE_FONT       0x00000002
#define EMRI_DEVMODE           0x00000003
#define EMRI_TYPE1_FONT        0x00000004
#define EMRI_PRESTARTPAGE      0x00000005
#define EMRI_DESIGNVECTOR      0x00000006
#define EMRI_SUBSET_FONT       0x00000007
#define EMRI_DELTA_FONT        0x00000008
#define EMRI_FORM_METAFILE     0x00000009
#define EMRI_BW_METAFILE       0x0000000A
#define EMRI_BW_FORM_METAFILE  0x0000000B
#define EMRI_METAFILE_DATA     0x0000000C
#define EMRI_METAFILE_EXT      0x0000000D
#define EMRI_BW_METAFILE_EXT   0x0000000E
#define EMRI_ENGINE_FONT_EXT   0x0000000F
#define EMRI_TYPE1_FONT_EXT    0x00000010
#define EMRI_DESIGNVECTOR_EXT  0x00000011
#define EMRI_SUBSET_FONT_EXT   0x00000012
#define EMRI_DELTA_FONT_EXT    0x00000013
#define EMRI_PS_JOB_DATA       0x00000014
#define EMRI_EMBED_FONT_EXT    0x00000015

#define EMF_PLAY_COLOR            0x00000001 // Current DC has DMCOLOR_COLOR
#define EMF_PLAY_MONOCHROME       0x00000002 // Changed by Optimization code to MONOCHROME
#define EMF_PLAY_FORCE_MONOCHROME 0x00000003 // Changed to MONOCHROME in the spool file

#define NORMAL_PAGE 1
#define FORM_PAGE   2

typedef struct tagEMFITEMHEADER
{
    DWORD ulID;     // either EMRI_METAFILE or EMRI_FONT
    DWORD cjSize;   // size of item in bytes
} EMFITEMHEADER;

//
// EMF spool file record structure for the following record types:
//  EMRI_METAFILE_EXT
//  EMRI_BW_METAFILE_EXT
//  EMRI_ENGINE_FONT_EXT
//  EMRI_TYPE1_FONT_EXT
//  EMRI_DESIGNVECTOR_EXT
//  EMRI_SUBSET_FONT_EXT
//  EMRI_DELTA_FONT_EXT
//

typedef struct tagEMFITEMHEADER_EXT
{
    EMFITEMHEADER   emfi;
    INT64           offset;
} EMFITEMHEADER_EXT;

typedef struct tagEMFITEMPRESTARTPAGE
{
    ULONG         ulUnused; // originally ulCopyCount
    BOOL          bEPS;
}EMFITEMPRESTARTPAGE, *PEMFITEMPRESTARTPAGE;

typedef struct tagRECORD_INFO_STRUCT
{
    struct tagRECORD_INFO_STRUCT *pNext;
    LONGLONG      RecordOffset;
    ULONG         RecordSize;
    DWORD         RecordID;
} RECORD_INFO_STRUCT, *PRECORD_INFO_STRUCT;

typedef struct tagPAGE_INFO_STRUCT
{
    LONGLONG             EMFOffset;
    LONGLONG             SeekOffset;
    LPDEVMODEW           pDevmode;
    ULONG                EMFSize;
    ULONG                ulID;
    PRECORD_INFO_STRUCT  pRecordInfo;
} PAGE_INFO_STRUCT;

typedef struct tagPAGE_LAYOUT_STRUCT
{
    HENHMETAFILE     hemf;
    DWORD            dwPageNumber;
    XFORM            XFormDC;
    RECT             rectClip;
    RECT             rectDocument;
    RECT             rectBorder;
    BOOL             bAllocBuffer;
} PAGE_LAYOUT_STRUCT;

typedef struct tagEMF_HANDLE
{
    DWORD              tag;
    DWORD              dwPageNumber;
    HENHMETAFILE       hemf;
    BOOL               bAllocBuffer;
    struct tagEMF_HANDLE *pNext;
} EMF_HANDLE, *PEMF_HANDLE;

typedef struct tagEMF_LIST
{
    HENHMETAFILE       hemf;
    BOOL               bAllocBuffer;
    struct tagEMF_LIST *pNext;
} EMF_LIST, *PEMF_LIST;

typedef struct tagSPOOL_FILE_HANDLE
{
    DWORD              tag;
    HDC                hdc;
    HANDLE             hSpooler;
    LPDEVMODEW         pOriginalDevmode;
    LPDEVMODEW         pLastDevmode;
    ULONG              MaxPageProcessed;
    PAGE_INFO_STRUCT   *pPageInfo;
    ULONG              PageInfoBufferSize;
    DWORD              dwNumberOfPagesInCurrSide;
    BOOL               bBanding;
    PAGE_LAYOUT_STRUCT *pPageLayout;
    DWORD              dwNumberOfPagesAllocated;
    PEMF_HANDLE        pEMFHandle;
    DWORD              dwPlayBackStatus;
    BOOL               bUseMemMap;
} SPOOL_FILE_HANDLE;

#define SPOOL_FILE_HANDLE_TAG                   'SPHT'
#define SPOOL_FILE_MAX_NUMBER_OF_PAGES_PER_SIDE 32
#define EMF_HANDLE_TAG                          'EFHT'

/**************************************************************************\
 *
 * stuff from csgdi.h
 *
\**************************************************************************/

//
// Win32ClientInfo[WIN32_CLIENT_INFO_SPIN_COUNT] corresponds to the
// cSpins field of the CLIENTINFO structure.  See ntuser\inc\user.h.
//
#define RESETUSERPOLLCOUNT() ((DWORD)NtCurrentTebShared()->Win32ClientInfo[WIN32_CLIENT_INFO_SPIN_COUNT] = 0)

ULONG cjBitmapSize(CONST BITMAPINFO *pbmi,ULONG iUsage);
ULONG cjBitmapBitsSize(CONST BITMAPINFO *pbmi);
ULONG cjBitmapScanSize(CONST BITMAPINFO *pbmi, int nScans);

BITMAPINFOHEADER * pbmihConvertHeader (BITMAPINFOHEADER *pbmih);

LPBITMAPINFO pbmiConvertInfo(CONST BITMAPINFO *, ULONG, ULONG * ,BOOL);

//
// object.c
//

HANDLE hGetPEBHandle(HANDLECACHETYPE,ULONG);
BOOL bDIBSectionSelected(PDC_ATTR);
PDEVMODEW pdmwGetDefaultDevMode(
    HANDLE          hSpooler,
    PUNICODE_STRING pustrDevice,    // device name
    PVOID          *ppvFree         // *ppvFree must be freed by the caller
    );

/**************************************************************************\
 *  DIB flags.  These flags are merged with the usage field when calling
 *  cjBitmapSize to specify what the size should include.  Any routine that
 *  uses these flags should first use the macro, CHECKDIBFLAGS(iUsage) to
 *  return an error if one of these bits is set.  If the definition of
 *  iUsage changes and one of these flags becomes a valid flag, the interface
 *  will need to be changed slightly.
 *
 *  04-June-1991 -by- Eric Kutter [erick]
\**************************************************************************/

#define DIB_MAXCOLORS   0x80000000
#define DIB_NOCOLORS    0x40000000
#define DIB_LOCALFLAGS  (DIB_MAXCOLORS | DIB_NOCOLORS)

#define CHECKDIBFLAGS(i)  {if (i & DIB_LOCALFLAGS)                    \
                           {RIP("INVALID iUsage"); goto MSGERROR;}}


#define HANDLE_TO_INDEX(h) (DWORD)((ULONG_PTR)h & 0x0000ffff)

/******************************Public*Macro********************************\
*
*  PSHARED_GET_VALIDATE
*
*  Validate all handle information, return user pointer if the handle
*  is valid or NULL otherwise.
*
* Arguments:
*
*   p       - pointer to assign to pUser is successful
*   h       - handle to object
*   iType   - handle type
*
\**************************************************************************/

#pragma warning(4:4821)     // Disable all ptr64->ptr32 truncation warnings for now

#define PSHARED_GET_VALIDATE(p,h,iType)                                 \
{                                                                       \
    UINT uiIndex = HANDLE_TO_INDEX(h);                                  \
    p = NULL;                                                           \
                                                                        \
    if (uiIndex < MAX_HANDLE_COUNT)                                     \
    {                                                                   \
        PENTRY pentry = &pGdiSharedHandleTable[uiIndex];                \
                                                                        \
        if (                                                            \
             (pentry->Objt == iType) &&                                 \
             (pentry->FullUnique == (USHORT)((ULONG_PTR)h >> 16)) &&    \
             (OBJECTOWNER_PID(pentry->ObjectOwner) == gW32PID)          \
           )                                                            \
        {                                                               \
            p = (PVOID)(ULONG_PTR)pentry->pUser;                        \
        }                                                               \
    }                                                                   \
}

#define VALIDATE_HANDLE(bRet, h,iType)                                  \
{                                                                       \
    UINT uiIndex = HANDLE_TO_INDEX(h);                                  \
    bRet = FALSE;                                                       \
                                                                        \
    if (uiIndex < MAX_HANDLE_COUNT)                                     \
    {                                                                   \
        PENTRY pentry = &pGdiSharedHandleTable[uiIndex];                \
                                                                        \
        if (                                                            \
             (pentry->Objt == iType) &&                                 \
             ((pentry->FullUnique&~FULLUNIQUE_STOCK_MASK) ==            \
             (((USHORT)((ULONG_PTR)h >> 16))&~FULLUNIQUE_STOCK_MASK)) &&\
             ((OBJECTOWNER_PID(pentry->ObjectOwner) == gW32PID) ||      \
              (OBJECTOWNER_PID(pentry->ObjectOwner) == 0))              \
           )                                                            \
        {                                                               \
           bRet = TRUE;                                                 \
        }                                                               \
    }                                                                   \
}


#define VALIDATE_HANDLE_AND_STOCK(bRet, h, iType, bStock)               \
{                                                                       \
    UINT uiIndex = HANDLE_TO_INDEX(h);                                  \
    bRet = FALSE;                                                       \
    bStock = FALSE;                                                     \
                                                                        \
    if (uiIndex < MAX_HANDLE_COUNT)                                     \
    {                                                                   \
        PENTRY pentry = &pGdiSharedHandleTable[uiIndex];                \
                                                                        \
        if (                                                            \
             (pentry->Objt == iType) &&                                 \
             ((pentry->FullUnique&~FULLUNIQUE_STOCK_MASK) ==            \
             (((USHORT)((ULONG_PTR)h >> 16))&~FULLUNIQUE_STOCK_MASK)) &&\
             ((OBJECTOWNER_PID(pentry->ObjectOwner) == gW32PID) ||      \
              (OBJECTOWNER_PID(pentry->ObjectOwner) == 0))              \
           )                                                            \
        {                                                               \
           bRet = TRUE;                                                 \
           bStock = (pentry->FullUnique & FULLUNIQUE_STOCK_MASK);       \
        }                                                               \
    }                                                                   \
}
//
//
// DC_ATTR support
//
//
//

extern PGDI_SHARED_MEMORY pGdiSharedMemory;
extern PDEVCAPS           pGdiDevCaps;
extern PENTRY             pGdiSharedHandleTable;
extern W32PID             gW32PID;

#define SHARECOUNT(hbrush)       (pGdiSharedHandleTable[HANDLE_TO_INDEX(h)].ObjectOwner.Share.Count)


/******************************Public*Routine******************************\
*
* FSHARED_DCVALID_RAO - check Valid RAO flag in the handle table entry for
*                       the hdc
*
* Arguments:
*
*   hdc
*
* Return Value:
*
*    BOOL flag value
*
\**************************************************************************/


#define FSHARED_DCVALID_RAO(hdc)                            \
    (pGdiSharedHandleTable[HDC_TO_INDEX(hdc)].Flags &       \
            HMGR_ENTRY_VALID_RAO)

BOOL
DeleteRegion(HRGN);


/******************************Public*Macro********************************\
* ORDER_PRECT makes the rect well ordered
*
* Arguments:
*
*    PRECTL prcl
*
\**************************************************************************/

#define ORDER_PRECTL(prcl)              \
{                                       \
    LONG lt;                            \
                                        \
    if (prcl->left > prcl->right)       \
    {                                   \
        lt          = prcl->left;       \
        prcl->left  = prcl->right;      \
        prcl->right = lt;               \
    }                                   \
                                        \
    if (prcl->top > prcl->bottom)       \
    {                                   \
        lt           = prcl->top;       \
        prcl->top    = prcl->bottom;    \
        prcl->bottom = lt;              \
    }                                   \
}

//
// client region defines and structures
//

#define CONTAINED 1
#define CONTAINS  2
#define DISJOINT  3


#define VALID_SCR(X)    (!((X) & 0xF8000000) || (((X) & 0xF8000000) == 0xF8000000))
#define VALID_SCRPT(P)  ((VALID_SCR((P).x)) && (VALID_SCR((P).y)))
#define VALID_SCRPPT(P) ((VALID_SCR((P)->x)) && (VALID_SCR((P)->y)))
#define VALID_SCRRC(R)  ((VALID_SCR((R).left)) && (VALID_SCR((R).bottom)) && \
                         (VALID_SCR((R).right)) && (VALID_SCR((R).top)))
#define VALID_SCRPRC(R) ((VALID_SCR((R)->left)) && (VALID_SCR((R)->bottom)) && \
                         (VALID_SCR((R)->right)) && (VALID_SCR((R)->top)))

int iRectRelation(PRECTL prcl1, PRECTL prcl2);

int APIENTRY GetRandomRgn(HDC hdc,HRGN hrgn,int iNum);

#define vReferenceCFONTCrit(pcf)   {(pcf)->cRef++;}

DWORD   GetCodePage(HDC hdc);


#define FLOATARG(f)     (*(PULONG)(PFLOAT)&(f))
#define FLOATPTRARG(pf) ((PULONG)(pf))

/******************************Public*Macros******************************\
* FIXUP_HANDLE(h) and FIXUP_HANDLEZ(h)
*
* check to see if the handle has been truncated.
* FIXUP_HANDLEZ() adds an extra check to allow NULL.
*
* Arguments:
*   h - handle to be checked and fix
*
* Return Value:
*
* History:
*
*    25-Jan-1996 -by- Lingyun Wang [lingyunw]
*
\**************************************************************************/

#define HANDLE_FIXUP 0

#if DBG
extern INT gbCheckHandleLevel;
#endif

#define NEEDS_FIXING(h)    (!((ULONG_PTR)h & 0xffff0000))

#if DBG
#define HANDLE_WARNING()                                                 \
{                                                                        \
        if (gbCheckHandleLevel == 1)                                     \
        {                                                                \
            WARNING ("truncated handle\n");                              \
        }                                                                \
        ASSERTGDI (gbCheckHandleLevel != 2, "truncated handle\n");       \
}
#else
#define HANDLE_WARNING()
#endif

#if DBG
#define CHECK_HANDLE_WARNING(h, bZ)                                      \
{                                                                        \
    BOOL bFIX = NEEDS_FIXING(h);                                         \
                                                                         \
    if (bZ) bFIX = h && bFIX;                                            \
                                                                         \
    if (bFIX)                                                            \
    {                                                                    \
        if (gbCheckHandleLevel == 1)                                     \
        {                                                                \
            WARNING ("truncated handle\n");                              \
        }                                                                \
        ASSERTGDI (gbCheckHandleLevel != 2, "truncated handle\n");       \
    }                                                                    \
}
#else
#define CHECK_HANDLE_WARNING(h,bZ)
#endif


#if HANDLE_FIXUP
#define FIXUP_HANDLE(h)                                 \
{                                                       \
    if (NEEDS_FIXING(h))                                \
    {                                                   \
        HANDLE_WARNING();                               \
        h = GdiFixUpHandle(h);                          \
    }                                                   \
}
#else
#define FIXUP_HANDLE(h)                                 \
{                                                       \
    CHECK_HANDLE_WARNING(h,FALSE);                      \
}
#endif

#if HANDLE_FIXUP
#define FIXUP_HANDLEZ(h)                                \
{                                                       \
    if (h && NEEDS_FIXING(h))                           \
    {                                                   \
        HANDLE_WARNING();                               \
        h = GdiFixUpHandle(h);                          \
    }                                                   \
}
#else
#define FIXUP_HANDLEZ(h)                                \
{                                                       \
    CHECK_HANDLE_WARNING(h,TRUE);                       \
}
#endif

#define FIXUP_HANDLE_NOW(h)                             \
{                                                       \
    if (NEEDS_FIXING(h))                                \
    {                                                   \
        HANDLE_WARNING();                               \
        h = GdiFixUpHandle(h);                          \
    }                                                   \
}

/******************************MACRO***************************************\
*  CHECK_AND_FLUSH
*
*   Check if commands in the batch need to be flushed based on matching
*   hdc
*
* Arguments:
*
*   hdc
*
* History:
*
*    14-Feb-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

#define CHECK_AND_FLUSH(hdc, pdca)                                       \
{                                                                        \
    if ((NtCurrentTebShared()->GdiTebBatch.HDC == (ULONG_PTR)hdc)        \
         && (pdca->ulDirty_ & BATCHED_DRAWING)                           \
       )                                                                 \
    {                                                                    \
        NtGdiFlush();                                                    \
        pdca->ulDirty_ &= ~BATCHED_DRAWING;                              \
    }                                                                    \
}

#define CHECK_AND_FLUSH_TEXT(hdc, pdca)                                  \
{                                                                        \
    if ((NtCurrentTebShared()->GdiTebBatch.HDC == (ULONG_PTR)hdc)        \
          &&  (pdca->ulDirty_ & BATCHED_TEXT)                            \
       )                                                                 \
    {                                                                    \
        NtGdiFlush();                                                    \
        pdca->ulDirty_ &= ~BATCHED_TEXT;                                 \
        pdca->ulDirty_ &= ~BATCHED_DRAWING;                              \
    }                                                                    \
}

#if defined(_WIN64) || defined(BUILD_WOW6432)

#define KHANDLE_ALIGN(size) ((size + sizeof(KHANDLE) - 1) & ~(sizeof(KHANDLE) - 1))

#else

// no alignment issues on regular 32-bit
#define KHANDLE_ALIGN(size) (size)

#endif

/*********************************MACRO************************************\
* BEGIN_BATCH_HDC
*
*   Attemp to place the command in the TEB batch. This macro is for use
*   with commands requiring an HDC
*
* Arguments:
*
*   hdc     - hdc of command
*   pdca    - PDC_ATTR from hdc
*   cType   - enum bathc command type
*   StrType - specific BATCH structure
*
* Return Value:
*
*   none: will jump to UNBATHCED_COMMAND if command can't be batched
*
* History:
*
*    22-Feb-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

#define BEGIN_BATCH_HDC(hdc,pdca,cType,StrType)                               \
{                                                                             \
    PTEBSHARED ptebShared = NtCurrentTebShared();                             \
    StrType *pBatch;                                                          \
    HDC      hdcBatch = hdc;                                                  \
                                                                              \
    if (!(                                                                    \
         (                                                                    \
           (ptebShared->GdiTebBatch.HDC == 0)          ||                     \
           (ptebShared->GdiTebBatch.HDC == (ULONG_PTR)hdc)                    \
         ) &&                                                                 \
         ((ptebShared->GdiTebBatch.Offset + KHANDLE_ALIGN(sizeof(StrType))) <= GDI_BATCH_SIZE) &&  \
         (pdca != NULL) &&                                                    \
         (!(pdca->ulDirty_ & DC_DIBSECTION))                                  \
       ))                                                                     \
    {                                                                         \
        goto UNBATCHED_COMMAND;                                               \
    }                                                                         \
                                                                              \
    pBatch = (StrType *)(                                                     \
                          ((PBYTE)(&ptebShared->GdiTebBatch.Buffer[0])) +     \
                          ptebShared->GdiTebBatch.Offset                      \
                        );                                                    \
                                                                              \
    pBatch->Type              = cType;                                        \
    pBatch->Length            = KHANDLE_ALIGN(sizeof(StrType));               \
                                                                              \
    if (cType < BatchTypeSetBrushOrg)                                         \
    {                                                                         \
        pdca->ulDirty_ |= BATCHED_DRAWING;                                    \
    }                                                                         \
                                                                              \
    if (cType == BatchTypeTextOut)                                            \
    {                                                                         \
        pdca->ulDirty_ |= BATCHED_TEXT;                                       \
    }


/*********************************MACRO************************************\
* BEGIN_BATCH_HDC
*
*   Attemp to place the command in the TEB batch. This macro is for use
*   with commands requiring an HDC
*
* Arguments:
*
*   hdc     - hdc of command
*   pdca    - PDC_ATTR from hdc
*   cType   - enum bathc command type
*   StrType - specific BATCH structure
*
* Return Value:
*
*   none: will jump to UNBATHCED_COMMAND if command can't be batched
*
* History:
*
*    22-Feb-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

#define BEGIN_BATCH_HDC_SIZE(hdc,pdca,cType,StrType,Size)                 \
{                                                                         \
    PTEBSHARED ptebShared = NtCurrentTebShared();                         \
    StrType *pBatch;                                                      \
    HDC      hdcBatch = hdc;                                              \
                                                                          \
    if (!(                                                                \
         (                                                                \
           (ptebShared->GdiTebBatch.HDC == 0)          ||                 \
           (ptebShared->GdiTebBatch.HDC == (ULONG_PTR)hdc)                \
         ) &&                                                             \
         ((ptebShared->GdiTebBatch.Offset + KHANDLE_ALIGN(Size)) <= GDI_BATCH_SIZE) &&   \
         (pdca != NULL) &&                                                \
         (!(pdca->ulDirty_ & DC_DIBSECTION))                              \
       ))                                                                 \
    {                                                                     \
        goto UNBATCHED_COMMAND;                                           \
    }                                                                     \
                                                                          \
    pBatch = (StrType *)(                                                 \
                          ((PBYTE)(&ptebShared->GdiTebBatch.Buffer[0])) + \
                          ptebShared->GdiTebBatch.Offset                  \
                        );                                                \
                                                                          \
    pBatch->Type              = cType;                                    \
    pBatch->Length            = KHANDLE_ALIGN(Size);                      \
    pBatch->Length            = Size;                                     \
                                                                          \
    if (cType < BatchTypeSetBrushOrg)                                     \
    {                                                                     \
        pdca->ulDirty_ |= BATCHED_DRAWING;                                \
    }                                                                     \
                                                                          \
    if (cType == BatchTypeTextOut)                                        \
    {                                                                     \
        pdca->ulDirty_ |= BATCHED_TEXT;                                   \
    }


/*********************************MACRO************************************\
* BEGIN_BATCH
*
*   Attemp to place the command in the TEB batch. This macro is for use
*   with commands that don't require an HDC
*
* Arguments:
*
*   cType   - enum bathc command type
*   StrType - specific BATCH structure
*
* Return Value:
*
*   none: will jump to UNBATHCED_COMMAND if command can't be batched
*
* Notes:
*
*   The "Win32ThreadInfo==NULL" check fixes "issue 2" of bug #338052.
*
*   If the thread is not a GUI thread, we can't batch non-HDC operations, 
*   because we can't guarantee that the batch will be flushed before the 
*   thread exits. (GdiThreadCallout isn't called unless the thread is a GUI
*   thread.)
*
* History:
*
*    22-Feb-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

#define BEGIN_BATCH(cType,StrType)                                            \
{                                                                             \
    PTEBSHARED ptebShared = NtCurrentTebShared();                             \
    StrType *pBatch;                                                          \
    HDC      hdcBatch = NULL;                                                 \
                                                                              \
    if (ptebShared->Win32ThreadInfo == NULL)                                  \
    {                                                                         \
        goto UNBATCHED_COMMAND;                                               \
    }                                                                         \
                                                                              \
    if (!                                                                     \
         ((ptebShared->GdiTebBatch.Offset + KHANDLE_ALIGN(sizeof(StrType))) <= GDI_BATCH_SIZE) \
       )                                                                      \
    {                                                                         \
        goto UNBATCHED_COMMAND;                                               \
    }                                                                         \
                                                                              \
    pBatch = (StrType *)(                                                     \
                          ((PBYTE)(&ptebShared->GdiTebBatch.Buffer[0])) +     \
                          ptebShared->GdiTebBatch.Offset                      \
                        );                                                    \
                                                                              \
    pBatch->Type              = cType;                                        \
    pBatch->Length            = KHANDLE_ALIGN(sizeof(StrType));               \

/*********************************MACRO************************************\
*  COMPLETE_BATCH_COMMAND
*
*   Complete batched command started with BEGIN_BATCH or BEGIN_BATCH_HDC.
*   The command is not actually batched unless this macro is executed.
*
* Arguments:
*
*   None
*
* Return Value:
*
*   None
*
* History:
*
*    22-Feb-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

#define COMPLETE_BATCH_COMMAND()                                           \
    if (hdcBatch)                                                          \
    {                                                                      \
        ptebShared->GdiTebBatch.HDC     = (ULONG_PTR)hdcBatch;             \
    }                                                                      \
    ptebShared->GdiTebBatch.Offset +=                                      \
        (pBatch->Length + sizeof(KHANDLE) - 1) & ~(sizeof(KHANDLE)-1);     \
                                                                           \
    ptebShared->GdiBatchCount++;                                           \
    if (ptebShared->GdiBatchCount >= GdiBatchLimit)                        \
    {                                                                      \
        NtGdiFlush();                                                      \
    }                                                                      \
}


/******************************Public*Routine******************************\
* HBRUSH CacheSelectBrush (HDC hdc, HBRUSH hbrush)
*
*   Client side brush caching
*
* History:
*  04-June-1995 -by-  Lingyun Wang [lingyunW]
* Wrote it.
\**************************************************************************/

#define CACHE_SELECT_BRUSH(pDcAttr,hbrushNew,hbrushOld)                    \
{                                                                          \
    hbrushOld = 0;                                                         \
                                                                           \
    if (pDcAttr)                                                           \
    {                                                                      \
        pDcAttr->ulDirty_ |= DC_BRUSH_DIRTY;                               \
        hbrushOld = pDcAttr->hbrush;                                       \
        pDcAttr->hbrush = hbrushNew;                                       \
    }                                                                      \
}


/******************************Public*Routine******************************\
* CacheSelectPen
*
*   Select a pen into DC_ATTR field of DC and set pen flag
*
* Arguments:
*
*   hdc     - user hdc
*   hpenNew - New Pen to select
*
* Return Value:
*
*   Old Pen or NULL
*
* History:
*
*    25-Jan-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

#define CACHE_SELECT_PEN(pdcattr,hpenNew, hpenOld)                         \
{                                                                          \
    hpenOld = 0;                                                           \
                                                                           \
    if (pdcattr)                                                           \
    {                                                                      \
        pdcattr->ulDirty_ |= DC_PEN_DIRTY;                                 \
        hpenOld = pdcattr->hpen;                                           \
        pdcattr->hpen = hpenNew;                                           \
    }                                                                      \
}





/**************************************************************************\
 *
 * far east
 *
\**************************************************************************/

extern UINT   guintAcp;
extern UINT   guintDBCScp;
extern UINT   fFontAssocStatus;
extern WCHAR *gpwcANSICharSet;
extern WCHAR *gpwcDBCSCharSet;
extern BOOL   gbDBCSCodePage;

UINT WINAPI QueryFontAssocStatus( VOID );
DWORD FontAssocHack(DWORD,CHAR*,UINT);

BOOL bComputeTextExtentDBCS(PDC_ATTR,CFONT*,LPCSTR,int,UINT,SIZE*);
BOOL bComputeCharWidthsDBCS(CFONT*, UINT, UINT, ULONG, PVOID);
extern BOOL IsValidDBCSRange( UINT iFirst , UINT iLast );
extern BYTE GetCurrentDefaultChar(HDC hdc);
extern BOOL bSetUpUnicodeStringDBCS(UINT iFirst,UINT iLast,PUCHAR puchTmp,
                                    PWCHAR pwc, UINT uiCodePage,CHAR chDefaultChar);

extern WINAPI NamedEscape(HDC,LPWSTR,int,int,LPCSTR,int,LPSTR);
extern BOOL RemoteRasterizerCompatible(HANDLE hSpooler);

void ConvertDxArray(UINT CP,char *pszDBCS,INT *pDxDBCS,UINT c,INT *pDxU, BOOL bPdy);


#ifdef LANGPACK

/**************************************************************************\
 *
 * language packs
 *
\**************************************************************************/

extern gbLpk;
extern void InitializeLanguagePack();

typedef BOOL   (* FPLPKINITIALIZE)(DWORD);
typedef UINT   (* FPLPKGETCHARACTERPLACEMENT)
                  (HDC,LPCWSTR,int,int,LPGCP_RESULTSW,DWORD,INT);
typedef BOOL   (* FPLPKEXTEXTOUT)
                  (HDC,INT,INT,UINT,CONST RECT*,LPCWSTR,UINT,CONST INT*,INT);

typedef BOOL   (* FPLPKGETTEXTEXTENTEXPOINT)
                  (HDC, LPCWSTR, INT, INT, LPINT, LPINT, LPSIZE, FLONG, INT);
typedef BOOL   (* FPLPKUSEGDIWIDTHCACHE)(HDC,LPCSTR,int,LONG,BOOL);


extern FPLPKGETCHARACTERPLACEMENT fpLpkGetCharacterPlacement;
extern FPLPKEXTEXTOUT fpLpkExtTextOut;
extern FPLPKGETCHARACTERPLACEMENT fpLpkGetCharacterPlacement;
extern FPLPKGETTEXTEXTENTEXPOINT fpLpkGetTextExtentExPoint;
extern FPLPKUSEGDIWIDTHCACHE fpLpkUseGDIWidthCache;

#endif

typedef union _BLENDULONG
{
    BLENDFUNCTION Blend;
    ULONG         ul;
}BLENDULONG,*PBLENDULONG;

BOOL bMergeSubsetFont(HDC, PVOID, ULONG, PVOID*, ULONG*, BOOL, UNIVERSAL_FONT_ID*);
PUFIHASH pufihAddUFIEntry(PUFIHASH*, PUNIVERSAL_FONT_ID, ULONG, FLONG, FLONG);
#define FL_UFI_SUBSET  1


BOOL bDoFontSubset(PUFIHASH, PUCHAR*, ULONG*, ULONG*);
BOOL WriteFontToSpoolFile(PLDC, PUNIVERSAL_FONT_ID, FLONG);
BOOL WriteSubFontToSpoolFile(PLDC, PUCHAR, ULONG, UNIVERSAL_FONT_ID*, BOOL);
BOOL bAddUFIandWriteSpool(HDC,PUNIVERSAL_FONT_ID,BOOL, FLONG);
VOID vFreeUFIHashTable( PUFIHASH *pUFIHashBase, FLONG fl);
BOOL WriteFontDataAsEMFComment(PLDC, DWORD, PVOID, DWORD, PVOID, DWORD);

//
// C helper functions for working with EMFSpoolData object
// (stored in the hEMFSpool field in LDC).
//

BOOL AllocEMFSpoolData(PLDC pldc, BOOL banding);
VOID DeleteEMFSpoolData(PLDC pldc);
BOOL WriteEMFSpoolData(PLDC pldc, PVOID buffer, ULONG size);
BOOL FlushEMFSpoolData(PLDC pldc, DWORD pageType);

#define MMAPCOPY_THRESHOLD  0x100000   // 1MB

VOID CopyMemoryToMemoryMappedFile(PVOID Destination, CONST VOID *Source, DWORD Length);
DWORD GetFileMappingAlignment();
DWORD GetSystemPageSize();

BOOL MirrorRgnDC(HDC hdc, HRGN hrgn, HRGN *phrgn);

#define HORZSIZEP 1
#define VERTSIZEP 2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\metadef.h ===
/*************************************************************************\
* Module Name: metadef.h
*
* This file contains the definitions and constants for metafile.
*
* Created: 12-June-1991 13:46:00
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1991-1999 Microsoft Corporation
\*************************************************************************/

// Metafile header sizes for existing valid versions

// Minimum header size
#define META_HDR_SIZE_MIN               META_HDR_SIZE_VERSION_1
// Original header
#define META_HDR_SIZE_VERSION_1         88


// Header with OpenGL extensions
#define META_HDR_SIZE_VERSION_2         100

// Header with sizlMicrometer extensions
#define META_HDR_SIZE_VERSION_3         108


// Maximum header size
#define META_HDR_SIZE_MAX               sizeof(ENHMETAHEADER)

// Metafile version constants

#define META_FORMAT_ENHANCED     0x10000         // Windows NT format
#define META_FORMAT_WINDOWS      0x300           // Windows 3.x format

// Metafile record structure.

typedef struct tagENHMETABOUNDRECORD
{
    DWORD   iType;              // Record type EMR_
    DWORD   nSize;              // Record size in bytes
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   dParm[1];           // Parameters
} ENHMETABOUNDRECORD, *PENHMETABOUNDRECORD;

// Flags for iType field in ENHMETARECORD.
// They are to be used in future to support backward systems only.
// See PlayEnhMetaFileRecord for details.

#define EMR_NOEMBED      0x80000000  // do not include record in embedding
#define EMR_ACCUMBOUNDS  0x40000000  // record has bounds

typedef struct tagMETALINK16
{
    DWORD       metalink;
    struct tagMETALINK16 *pmetalink16Next;
    HANDLE      hobj;
    PVOID       pv;

// WARNING: fields before this must match the LINK structure.

    DWORD       cMetaDC16;
    HDC         ahMetaDC16[1];
} METALINK16, *PMETALINK16;

// Public GdiComment.

typedef struct tagEMRGDICOMMENT_PUBLIC
{
    EMR     emr;
    DWORD   cbData;             // Size of following fields and data
    DWORD   ident;              // GDICOMMENT_IDENTIFIER
    DWORD   iComment;           // Comment type e.g. GDICOMMENT_WINDOWS_METAFILE
} EMRGDICOMMENT_PUBLIC, *PEMRGDICOMMENT_PUBLIC;

// Public GdiComment for embedded Windows metafile.

typedef struct tagEMRGDICOMMENT_WINDOWS_METAFILE
{
    EMR     emr;
    DWORD   cbData;             // Size of following fields and windows metafile
    DWORD   ident;              // GDICOMMENT_IDENTIFIER
    DWORD   iComment;           // GDICOMMENT_WINDOWS_METAFILE
    DWORD   nVersion;           // 0x300 or 0x100
    DWORD   nChecksum;          // Checksum
    DWORD   fFlags;             // Compression etc.  This is currently zero.
    DWORD   cbWinMetaFile;      // Size of windows metafile data in bytes
                                // The windows metafile data follows here
} EMRGDICOMMENT_WINDOWS_METAFILE, *PEMRGDICOMMENT_WINDOWS_METAFILE;

// Public GdiComment for begin group.

typedef struct tagEMRGDICOMMENT_BEGINGROUP
{
    EMR     emr;
    DWORD   cbData;             // Size of following fields and all data
    DWORD   ident;              // GDICOMMENT_IDENTIFIER
    DWORD   iComment;           // GDICOMMENT_BEGINGROUP
    RECTL   rclOutput;          // Output rectangle in logical coords.
    DWORD   nDescription;       // Number of chars in the unicode description
                                // string that follows this field.  This is 0
                                // if there is no description string.
} EMRGDICOMMENT_BEGINGROUP, *PEMRGDICOMMENT_BEGINGROUP;

// Public GdiComment for end group.

typedef EMRGDICOMMENT_PUBLIC  EMRGDICOMMENT_ENDGROUP;
typedef PEMRGDICOMMENT_PUBLIC PEMRGDICOMMENT_ENDGROUP;

// Public GdiComment for multiple formats.

typedef struct tagEMRGDICOMMENT_MULTIFORMATS
{
    EMR     emr;
    DWORD   cbData;             // Size of following fields and all data
    DWORD   ident;              // GDICOMMENT_IDENTIFIER
    DWORD   iComment;           // GDICOMMENT_MULTIFORMATS
    RECTL   rclOutput;          // Output rectangle in logical coords.
    DWORD   nFormats;           // Number of formats contained in the record
    EMRFORMAT aemrformat[1];    // Array of EMRFORMAT structures in order of
                                // preference.  This is followed by the data
                                // for each format.
} EMRGDICOMMENT_MULTIFORMATS, *PEMRGDICOMMENT_MULTIFORMATS;

// iComment flags

#define GDICOMMENT_NOEMBED      0x80000000  // do not include comment in
                                            //   embedding
#define GDICOMMENT_ACCUMBOUNDS  0x40000000  // has logical rectangle bounds
                                            //   that follows the iComment field

// ExtEscape to output encapsulated PostScript file.

typedef struct tagEPSDATA
{
    DWORD    cbData;        // Size of the structure and EPS data in bytes.
    DWORD    nVersion;      // Language level, e.g. 1 for level 1 PostScript.
    POINT    aptl[3];       // Output parallelogram in 28.4 FIX device coords.
                            // This is followed by the EPS data.
} EPSDATA, *PEPSDATA;


/**************************************************************************\
 *
 *                <----------------------------------------------\
 *       hash                                                     \
 *                                                                 \
 *       +-----+                                                   |
 *      0| I16 |       metalink16                                  |
 *      1|     |                                                   |
 *      2|     |       +--------+        +--------+                |
 *      3|     |------>|idc/iobj|     /->|metalink|                |
 *      4|     |       |hobj    |    /   |hobj    |                |
 *      5|     |       |pmlNext |---/    |pmlNext |--/             |
 *       |     |       |16bit mf|        |16bit mf|                |
 *      .|     |       +--------+        +--------+                |
 *      .|     |         |                                         |
 *      .|     |         |                                         |
 *       |     |      /--/                                         |
 *    n-1|     |     /                                             |
 *       +-----+     |                                             |
 *                   |  LDC(idc)          MDC                      |
 *                   |                                             |
 *                   \->+--------+       +--------+    MHE[iobj]   |
 *                      |        |       |        |                |
 *                      |        |    /->|        |   +--------+   |
 *                      |        |   /   |        |   |hobj    |---/
 *                      |pmdc    |--/    |pmhe    |-->|idc/iobj|
 *                      +--------+       |        |   +--------+
 *                                       +--------+
 *
 *
 *
\**************************************************************************/

PMETALINK16 pmetalink16Resize(HANDLE h,int cObj);

#define pmetalink16Get(h)    ((PMETALINK16) plinkGet(h))
#define pmetalink16Create(h) ((PMETALINK16)plinkCreate(h,sizeof(METALINK16)))
#define bDeleteMetalink16(h) bDeleteLink(h)

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\local.c ===
/*****************************Module*Header*******************************\
* Module Name: local.c                                                     *
*                                                                          *
* Support routines for client side objects and attribute caching.          *
*                                                                          *
* Created: 30-May-1991 21:55:57                                            *
* Author: Charles Whitmer [chuckwh]                                        *
*                                                                          *
* Copyright (c) 1991-1999 Microsoft Corporation                            *
\**************************************************************************/
#include "precomp.h"
#pragma hdrstop

#include "stdarg.h"

#include "wowgdip.h"

extern CFONT *pcfDeleteList;

VOID vFreeCFONTCrit(CFONT *pcf);

RTL_CRITICAL_SECTION semLocal;             // Semaphore for handle allocation.

//
// ahStockObjects will contain both the stock objects visible to an
// application, and internal ones such as the private stock bitmap.
//

ULONG_PTR ahStockObjects[PRIV_STOCK_LAST+1];

#if DBG
ULONG   gdi_dbgflags;               // Debug flags - FIREWALL.H.
#endif

#if DBG
INT gbCheckHandleLevel=0;
#endif


/******************************Public*Routine******************************\
* GdiQueryTable()
*
*   private entry point for wow to get the gdi handle table.  This allows
*   WOW to do fix up's on handles since they throw away the high word.
*
* History:
*  24-Jul-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

PVOID GdiQueryTable()
{
    return((PVOID)pGdiSharedHandleTable);
}

/******************************Public*Routine******************************\
*
* History:
*  02-Aug-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

PLDC pldcGet(HDC hdc)
{
   PLDC pldc = NULL;
   PDC_ATTR pdca;
   PSHARED_GET_VALIDATE(pdca,hdc,DC_TYPE);

   if (pdca)
        pldc = (PLDC)pdca->pvLDC;

   return(pldc);
}

/******************************Public*Routine******************************\
* pldcCreate()
*
* History:
*  25-Jan-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

PLDC pldcCreate(
    HDC hdc,
    ULONG ulType)
{
    PLDC pldc;

    pldc = (PLDC)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,sizeof(LDC));

    if (!pldc)
    {
        WARNING("pldcCreate - failed to allocate plinkCreate\n");
    }
    else
    {
        PDC_ATTR pdca;

        pldc->iType = ulType;
        pldc->hdc   = hdc;

    // make sure that all three of these pointer need to be set to zero
    // on print server's dc. ppSubUFIHash certainly has to (tessiew).

        pldc->ppUFIHash = pldc->ppDVUFIHash = pldc->ppSubUFIHash = NULL;

    // initalize postscript data list.

        InitializeListHead(&(pldc->PSDataList));

    // Put pointer to DC_ATTR in LDC.

        PSHARED_GET_VALIDATE(pdca,hdc,DC_TYPE);

        if (pdca)
        {
            pdca->pvLDC = pldc;
        }
    }

    ASSERTGDI((offsetof(LINK,metalink ) == offsetof(METALINK16,metalink ))       &&
              (offsetof(LINK,plinkNext) == offsetof(METALINK16,pmetalink16Next)) &&
              (offsetof(LINK,hobj     ) == offsetof(METALINK16,hobj     ))       &&
              (offsetof(LINK,pv       ) == offsetof(METALINK16,pv       )),
              "pldcCreate - invalid structures\n");

    return(pldc);
}

/******************************Public*Routine******************************\
* VOID vSetPldc()
*
*   This is used if a we already have a pldc and want to set it in this DC.
*   The purpose is ResetDC since we don't know if we still have the same dcattr.
*
* History:
*  03-Aug-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID vSetPldc(
    HDC hdc,
    PLDC pldc)
{
    PDC_ATTR pdca;

    PSHARED_GET_VALIDATE(pdca,hdc,DC_TYPE);

    if (pdca)
    {
        pdca->pvLDC = pldc;
    }

    if (pldc)
    {
        pldc->hdc = hdc;
    }
}

/******************************Public*Routine******************************\
* bDeleteLDC()
*
* History:
*  25-Jan-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL bDeleteLDC(
    PLDC pldc
    )
{
    if (pldc->pDevMode)
    {
        LOCALFREE(pldc->pDevMode);
    }

    if (pldc->hEMFSpool)
    {
        DeleteEMFSpoolData(pldc);
    }

    if (pldc->dwSizeOfPSDataToRecord)
    {
        PPS_INJECTION_DATA pPSData;
        PLIST_ENTRY        p = pldc->PSDataList.Flink;

        while(p != &(pldc->PSDataList))
        {
            // get pointer to this cell.

            pPSData = CONTAINING_RECORD(p,PS_INJECTION_DATA,ListEntry);

            // get pointer to next cell.

            p = p->Flink;

            // free this cell.

            LOCALFREE(pPSData);
        }
    }

    LocalFree(pldc);
    return(TRUE);
}

/******************************Public*Routine******************************\
* GdiCleanCacheDC (hdcLocal)                                               *
*                                                                          *
* Resets the state of a cached DC, but has no effect on an OWNDC.          *
* Should be called by WOW when the app calls ReleaseDC.                    *
*                                                                          *
* History:                                                                 *
*  Sat 30-Jan-1993 11:49:12 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL GdiCleanCacheDC(HDC hdc)
{
// Validate the call.  It must be a direct display DC.

    if (IS_ALTDC_TYPE(hdc))
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

// any other dc doesn't really matter.

    return(TRUE);
}

/******************************Public*Routine******************************\
* GdiConvertAndCheckDC
*
*  Private entry point for USER's drawing routine.  This function differs
*  from GdiConvertDC in that it also does printing specific things for the
*  given dc.  This is for APIs that apps can use for printing.
*
* History:
*  14-Apr-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

HDC GdiConvertAndCheckDC(HDC hdc)
{
    if (IS_ALTDC_TYPE(hdc) && !IS_METADC16_TYPE(hdc))
    {
        PLDC pldc;

        DC_PLDC(hdc,pldc,(HDC)0);

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(FALSE);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    return(hdc);
}

/******************************Public*Routine******************************\
* GdiIsMetaFileDC
*
* History:
* 02-12-92 mikeke  Created
\**************************************************************************/

BOOL GdiIsMetaFileDC(HDC hdc)
{
    BOOL b = FALSE;

    if (IS_ALTDC_TYPE(hdc))
    {
        if (IS_METADC16_TYPE(hdc))
        {
            b = TRUE;
        }
        else
        {
            PLDC pldc;

            DC_PLDC(hdc,pldc,FALSE);

            if (pldc->iType == LO_METADC)
                b = TRUE;
        }
    }
    return(b);
}

/******************************Public*Routine******************************\
*
* GdiIsMetaPrintDC
*
* Tests whether the given DC is a metafile-spooled printer DC
*
* History:
*  Fri Jun 16 12:00:11 1995     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL APIENTRY GdiIsMetaPrintDC(HDC hdc)
{
    if (IS_ALTDC_TYPE(hdc) && !IS_METADC16_TYPE(hdc))
    {
        PLDC pldc;

        DC_PLDC(hdc, pldc, FALSE);

        return (pldc->fl & LDC_META_PRINT) != 0;
    }

    return FALSE;
}

/**************************************************************************\
 *
 * WINBUG #82862 2-7-2000 bhouse Possible cleanup of stubs
 *
 * Old Comment:
 *   Client stubs for USER that do things with handles and caching.  They are
 *   now NOP's and should be removed from USER as soon as this stuff is part
 *   of the main build.
 *
\**************************************************************************/

HDC GdiConvertDC(HDC hdc)
{
    FIXUP_HANDLEZ(hdc);
    return(hdc);
}

HFONT GdiConvertFont(HFONT hfnt)
{
    FIXUP_HANDLEZ(hfnt);
    return(hfnt);
}

BOOL GdiValidateHandle(HANDLE hObj)
{
    UINT uiIndex;

    if (hObj == NULL)
        return(TRUE);

    uiIndex = HANDLE_TO_INDEX(hObj);

    if (uiIndex < MAX_HANDLE_COUNT)
    {
        PENTRY pentry = &pGdiSharedHandleTable[uiIndex];

        if ((pentry->FullUnique == (USHORT)((ULONG_PTR)hObj >> 16)) &&
            ((OBJECTOWNER_PID(pentry->ObjectOwner) == gW32PID) ||
             (OBJECTOWNER_PID(pentry->ObjectOwner) == 0))
           )
        {
           return(TRUE);
        }
    }

    WARNING1("GdiValidateHandle: Bad handle\n");

    return(FALSE);
}

HFONT GdiGetLocalFont(HFONT hfntRemote)
{
    return(hfntRemote);
}

HBRUSH GdiGetLocalBrush(HBRUSH hbrushRemote)
{
    return(hbrushRemote);
}

HANDLE META WINAPI SelectBrushLocal(HDC hdc,HANDLE h)
{
    return(h);
}

HANDLE META WINAPI SelectFontLocal(HDC hdc,HANDLE h)
{
    return(h);
}

BOOL GdiSetAttrs(HDC hdc)
{
    hdc;
    return(TRUE);
}

HBITMAP GdiConvertBitmap(HBITMAP hbm)
{
    FIXUP_HANDLEZ(hbm);
    return(hbm);
}

HBRUSH GdiConvertBrush(HBRUSH hbrush)
{
    FIXUP_HANDLEZ(hbrush);
    return (hbrush);
}

HPALETTE GdiConvertPalette(HPALETTE hpal)
{
    FIXUP_HANDLEZ(hpal);
    return(hpal);
}

HRGN GdiConvertRegion(HRGN hrgn)
{
    FIXUP_HANDLEZ(hrgn);
    return(hrgn);
}

void APIENTRY GdiSetServerAttr(HDC hdc, PVOID pattr)
{
    hdc;
    pattr;
}

/******************************Public*Routine******************************\
* plfCreateLOCALFONT (fl)
*
* Allocates a LOCALFONT.  Actually pulls one from a preallocated pool.
* Does simple initialization.
*
* WARNING: This routines assume that the caller has grabbed semLocal
*
*  Sun 10-Jan-1993 01:46:12 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

#define LF_ALLOCCOUNT   10

LOCALFONT *plfFreeListLOCALFONT = (LOCALFONT *) NULL;

LOCALFONT *plfCreateLOCALFONT(FLONG fl)
{
    LOCALFONT *plf;

    // Try to get one off the free list.

    plf = plfFreeListLOCALFONT;
    if (plf != (LOCALFONT *) NULL)
    {
        plfFreeListLOCALFONT = *((LOCALFONT **) plf);
    }

    // Otherwise expand the free list.

    else
    {
        plf = (LOCALFONT *) LOCALALLOC(LF_ALLOCCOUNT * sizeof(LOCALFONT));
        if (plf != (LOCALFONT *) NULL)
        {
            int ii;

            // Link all the new ones into the free list.

            *((LOCALFONT **) plf) = (LOCALFONT *) NULL;
            plf++;

            for (ii=0; ii<LF_ALLOCCOUNT-2; ii++,plf++)
              *((LOCALFONT **) plf) = plf-1;

            plfFreeListLOCALFONT = plf-1;

            // Keep the last one for us!
        }
        else
        {
            GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    if (plf != (LOCALFONT *) NULL)
    {
        plf->fl = fl;
        plf->pcf = (CFONT *) NULL;
    }

     return(plf);
}

/******************************Public*Routine******************************\
* vDeleteLOCALFONT (plf)                                                   *
*                                                                          *
* Frees a LOCALFONT after unreferencing any CFONTs it points to.           *
*                                                                          *
*  Sun 10-Jan-1993 02:27:50 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

VOID vDeleteLOCALFONT(LOCALFONT *plf)
{
    ASSERTGDI(plf != (LOCALFONT *) NULL,"Trying to free NULL LOCALFONT.\n");

    ENTERCRITICALSECTION(&semLocal);
    {
        CFONT *pcf;

        pcf = plf->pcf;

        // Walk the CFONT list and delallocate those CFONTs not in use.
        // put those which are in use back on the global CFONT delete list.

        while( pcf != (CFONT*) NULL )
        {
            ASSERTGDI(!(pcf->fl & CFONT_PUBLIC),"vDeleteLocalFont - public font error\n");

            if( pcf->cRef )
            {
                // this CFONT is in use so we'll put it on the global
                // delete list and free it later.

                CFONT *pcfTmp = pcf->pcfNext;
#if DBG
                DbgPrint("\n\nvDeleteLOCALFONT: CFONT in use putting on delete list, cRef = %ld, hf = %lx.\n",pcf->cRef, pcf->hf);
#endif

                pcf->pcfNext = pcfDeleteList;
                pcfDeleteList = pcf;
                pcf = pcfTmp;
            }
            else
            {
                CFONT *pcfTmp;

                pcfTmp = pcf->pcfNext;
                vFreeCFONTCrit(pcf);
                pcf = pcfTmp;
            }
        }

        *((LOCALFONT **) plf) = plfFreeListLOCALFONT;
        plfFreeListLOCALFONT = plf;
    }
    LEAVECRITICALSECTION(&semLocal);
}


/******************************Public*Routine******************************\
* bLoadSpooler()
*
*   This function loads the spooler and gets the address's of all routines
*   GDI calls in the spooler.  This should be called the first time the
*   spooler is needed.
*
* History:
*  09-Aug-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HINSTANCE           ghSpooler = NULL;
FPSTARTDOCDLGW      fpStartDocDlgW;
FPOPENPRINTERW      fpOpenPrinterW;
FPRESETPRINTERW     fpResetPrinterW;
FPCLOSEPRINTER      fpClosePrinter;
FPGETPRINTERW       fpGetPrinterW;
FPGETPRINTERDRIVERW fpGetPrinterDriverW;
FPENDDOCPRINTER     fpEndDocPrinter;
FPENDPAGEPRINTER    fpEndPagePrinter;
FPREADPRINTER       fpReadPrinter;
FPSPLREADPRINTER    fpSplReadPrinter;
FPSTARTDOCPRINTERW  fpStartDocPrinterW;
FPSTARTPAGEPRINTER  fpStartPagePrinter;
FPABORTPRINTER      fpAbortPrinter;
PFNDOCUMENTEVENT    fpDocumentEvent;
FPQUERYSPOOLMODE    fpQuerySpoolMode;
FPQUERYREMOTEFONTS  fpQueryRemoteFonts;
FPSEEKPRINTER       fpSeekPrinter;
FPQUERYCOLORPROFILE fpQueryColorProfile;
FPSPLDRIVERUNLOADCOMPLETE   fpSplDriverUnloadComplete;
FPGETSPOOLFILEHANDLE        fpGetSpoolFileHandle;
FPCOMMITSPOOLDATA           fpCommitSpoolData;
FPCLOSESPOOLFILEHANDLE      fpCloseSpoolFileHandle;
FPDOCUMENTPROPERTIESW       fpDocumentPropertiesW;
FPLOADSPLWOW64              fpLoadSplWow64;

BOOL bLoadSpooler()
{
    if (ghSpooler != NULL)
        WARNING("spooler already loaded\n");

    ENTERCRITICALSECTION(&semLocal);

// make sure someone else didn't sneak in under us and load it.

    if (ghSpooler == NULL)
    {
        HANDLE hSpooler = LoadLibraryW(L"winspool.drv");

        if (hSpooler != NULL)
        {
            #define GETSPOOLERPROC_(type, procname) \
                    fp##procname = (type) GetProcAddress(hSpooler, #procname)

            GETSPOOLERPROC_(FPSTARTDOCDLGW, StartDocDlgW);
            GETSPOOLERPROC_(FPOPENPRINTERW, OpenPrinterW);
            GETSPOOLERPROC_(FPRESETPRINTERW, ResetPrinterW);
            GETSPOOLERPROC_(FPCLOSEPRINTER, ClosePrinter);
            GETSPOOLERPROC_(FPGETPRINTERW, GetPrinterW);
            GETSPOOLERPROC_(FPGETPRINTERDRIVERW, GetPrinterDriverW);
            GETSPOOLERPROC_(FPENDDOCPRINTER, EndDocPrinter);
            GETSPOOLERPROC_(FPENDPAGEPRINTER, EndPagePrinter);
            GETSPOOLERPROC_(FPREADPRINTER, ReadPrinter);
            GETSPOOLERPROC_(FPSTARTDOCPRINTERW, StartDocPrinterW);
            GETSPOOLERPROC_(FPSTARTPAGEPRINTER, StartPagePrinter);
            GETSPOOLERPROC_(FPABORTPRINTER, AbortPrinter);
            GETSPOOLERPROC_(PFNDOCUMENTEVENT, DocumentEvent);
            GETSPOOLERPROC_(FPQUERYSPOOLMODE, QuerySpoolMode);
            GETSPOOLERPROC_(FPQUERYREMOTEFONTS, QueryRemoteFonts);
            GETSPOOLERPROC_(FPSEEKPRINTER, SeekPrinter);
            GETSPOOLERPROC_(FPQUERYCOLORPROFILE, QueryColorProfile);
            GETSPOOLERPROC_(FPSPLDRIVERUNLOADCOMPLETE, SplDriverUnloadComplete);
            GETSPOOLERPROC_(FPDOCUMENTPROPERTIESW, DocumentPropertiesW);
            
            fpLoadSplWow64 = (FPLOADSPLWOW64) GetProcAddress(hSpooler, (LPCSTR) MAKELPARAM(224, 0));

            #ifdef EMULATE_SPOOLFILE_INTERFACE

            fpGetSpoolFileHandle = GetSpoolFileHandle;
            fpCommitSpoolData = CommitSpoolData;
            fpCloseSpoolFileHandle = CloseSpoolFileHandle;

            #else

            GETSPOOLERPROC_(FPGETSPOOLFILEHANDLE, GetSpoolFileHandle);
            GETSPOOLERPROC_(FPCOMMITSPOOLDATA, CommitSpoolData);
            GETSPOOLERPROC_(FPCLOSESPOOLFILEHANDLE, CloseSpoolFileHandle);

            #endif

            fpSplReadPrinter   = (FPSPLREADPRINTER)GetProcAddress(hSpooler, (LPCSTR) MAKELPARAM(205, 0));

            if (! fpStartDocDlgW            ||
                ! fpOpenPrinterW            ||
                ! fpResetPrinterW           ||
                ! fpClosePrinter            ||
                ! fpGetPrinterW             ||
                ! fpGetPrinterDriverW       ||
                ! fpEndDocPrinter           ||
                ! fpEndPagePrinter          ||
                ! fpReadPrinter             ||
                ! fpSplReadPrinter          ||
                ! fpStartDocPrinterW        ||
                ! fpStartPagePrinter        ||
                ! fpAbortPrinter            ||
                ! fpDocumentEvent           ||
                ! fpQuerySpoolMode          ||
                ! fpQueryRemoteFonts        ||
                ! fpSeekPrinter             ||
                ! fpQueryColorProfile       ||
                ! fpSplDriverUnloadComplete ||
                ! fpGetSpoolFileHandle      ||
                ! fpCommitSpoolData         ||
                ! fpCloseSpoolFileHandle    ||
                ! fpDocumentPropertiesW     ||
                ! fpLoadSplWow64)
            {
                FreeLibrary(hSpooler);
                hSpooler = NULL;
            }

            ghSpooler = hSpooler;
        }
    }

    LEAVECRITICALSECTION(&semLocal);

    if (ghSpooler == NULL)
        GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);

    return(ghSpooler != NULL);
}

/******************************Public*Routine******************************\
* GdiGetLocalDC
*
* Arguments:
*
*   hdc - handle to dc
*
* Return Value:
*
*   same DC or NULL for failure
*
\**************************************************************************/

HDC
GdiGetLocalDC(HDC hdc)
{

    return(hdc);
}
/******************************Public*Routine******************************\
* GdiDeleteLocalDC
*
*   Free client DC_ATTR regardless of reference count
*
* Arguments:
*
*   hdc
*
* Return Value:
*
*   Status
*
* History:
*
*   04-May-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL GdiDeleteLocalDC(HDC hdc)
{
    return(TRUE);
}

/******************************Public*Routine******************************\
* GdiReleaseLocalDC
*
* Routine Description:
*
*   When the reference count of DC_ATTR drops to zero, free it
*
* Arguments:
*
*   hdc - DC handle
*
* Return Value:
*
*   BOOL status
*
* History:
*
*   02-May-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL GdiReleaseLocalDC(HDC hdc)
{

#if DBG
    DbgPrint("Error, call to GdiReleaseLocalDC\n");
    DbgBreakPoint();
#endif

    return(TRUE);
}

/******************************Public*Routine******************************\
* GdiFixUpHandle()
*
*   given a handle with the high word 0'd, return the actual handle
*
* History:
*  16-Feb-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HANDLE GdiFixUpHandle(
    HANDLE h)
{
    HANDLE hNew = NULL;

    if ((((ULONG_PTR)h & FULLUNIQUE_MASK) == 0) && ((ULONG_PTR)h < MAX_HANDLE_COUNT))
    {
        hNew = (HANDLE)MAKE_HMGR_HANDLE((ULONG)(ULONG_PTR)h,pGdiSharedHandleTable[(ULONG_PTR)h].FullUnique);
    }

    return(hNew);
}

/******************************Public*Routine******************************\
* DoRip()
*
*  go to the user mode debugger in checked builds
*
* Effects:
*
* Warnings:
*  Leave this enabled in case efloat.lib needs it.
*  efloat.lib uses gre\engine.h's ASSERTGDI macro.
*
* History:
*  09-Aug-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID DoRip(PSZ psz)
{
    DbgPrint("GDI Assertion Failure: ");
    DbgPrint(psz);
    DbgPrint("\n");
    DbgBreakPoint();
}

/******************************Public*Routine******************************\
* DoIDRip()
*
*  go to the user mode debugger in checked builds
*
* Effects:
*
* Warnings:
*  Leave this enabled in case efloat.lib needs it.
*  efloat.lib uses gre\engine.h's ASSERTGDI macro.
*
* History:
*  31-Aug-2000 -by-  Jason Hartman [jasonha]
* Wrote it.
\**************************************************************************/

VOID DoIDRip(PCSTR ID, PSZ psz)
{
    DbgPrint("GDI Assertion Failure: ");
    if (ID)
    {
        DbgPrint((PCH)ID);
        DbgPrint(": ");
    }
    DbgPrint(psz);
    DbgPrint("\n");
    DbgBreakPoint();
}


DWORD
GetFileMappingAlignment()

/*++

Routine Description:

    Alignment for file mapping starting offset

Arguments:

    NONE

Return Value:

    see above

--*/

{
    static DWORD alignment = 0;

    if (alignment == 0)
    {
        SYSTEM_INFO sysinfo;

        //
        // Set file mapping alignment for EMF spool file to
        // the system memory allocation granularity
        //

        GetSystemInfo(&sysinfo);
        alignment = sysinfo.dwAllocationGranularity;
    }

    return alignment;
}

DWORD
GetSystemPageSize()

/*++

Routine Description:

    Returns the page size for the current system

Arguments:

    NONE

Return Value:

    see above

--*/

{
    static DWORD pagesize = 0;

    if (pagesize == 0)
    {
        SYSTEM_INFO sysinfo;

        GetSystemInfo(&sysinfo);
        pagesize = sysinfo.dwPageSize;
    }

    return pagesize;
}

VOID
CopyMemoryToMemoryMappedFile(
    PVOID Destination,
    CONST VOID *Source,
    DWORD Length
    )

/*++

Routine Description:

    Copy data into memory-mapped file (assuming mostly sequential access pattern)

Arguments:

    Destination - Points to destination buffer
    Source - Points to source buffer
    Length - Number of bytes to be copied

Return Value:

    NONE

--*/

{
    PBYTE dst = (PBYTE) Destination;
    PBYTE src = (PBYTE) Source;
    DWORD alignment = GetFileMappingAlignment();
    DWORD count;

    //
    // Copy the initial portion so that the destination buffer
    // pointer is properly aligned
    //

    count = (DWORD) ((ULONG_PTR) dst % alignment);

    if (count != 0)
    {
        count = min(alignment-count, Length);
        RtlCopyMemory(dst, src, count);

        Length -= count;
        dst += count;
        src += count;
    }

    //
    // Copy the middle portion in 64KB chunks
    //

    count = Length / alignment;
    Length -= count * alignment;

    while (count--)
    {
        RtlCopyMemory(dst, src, alignment);
        VirtualUnlock(dst, alignment);
        dst += alignment;
        src += alignment;
    }

    //
    // Finish up the remaining portion
    //

    if (Length > 0)
        RtlCopyMemory(dst, src, Length);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\metafile.cxx ===
/******************************Module*Header*******************************\
* Module Name: metafile.cxx
*
* Includes enhanced metafile API functions.
*
* Created: 17-July-1991 10:10:36
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1991-1999 Microsoft Corporation
\**************************************************************************/

#define NO_STRICT

extern "C" {
#if defined(_GDIPLUS_)
#include <gpprefix.h>
#endif

#include <string.h>
#include <stdio.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <windows.h>    // GDI function declarations.
#include <winspool.h>
#include "nlsconv.h"    // UNICODE helpers
#include "firewall.h"
#define __CPLUSPLUS
#include <winspool.h>
#include <w32gdip.h>
#include "ntgdistr.h"
#include "winddi.h"
#include "hmgshare.h"
#include "icm.h"
#include "local.h"      // Local object support.
#include "gdiicm.h"
#include "metadef.h"    // Metafile record type constants.
#include "metarec.h"
#include "mf16.h"
#include "ntgdi.h"
#include "glsup.h"
}

#include "rectl.hxx"
#include "mfdc.hxx"     // Metafile DC declarations.
#include "mfrec.hxx"    // Metafile record class declarations.

WORD   GetWordCheckSum(UINT cbData, PWORD pwData);
DWORD  GetDWordCheckSum(UINT cbData, PDWORD pdwData);
UINT   InternalGetEnhMetaFileDescription(HENHMETAFILE hemf, UINT cchBuffer, LPSTR lpDescription, BOOL bUnicode);

RECTL rclNull = { 0, 0, -1, -1 };
RECTL rclInfinity = {NEG_INFINITY,NEG_INFINITY,POS_INFINITY,POS_INFINITY};
extern XFORM xformIdentity;

typedef UINT (*LPFNCONVERT) (PBYTE, UINT, PBYTE, INT, HDC, UINT) ;

extern "C" BOOL SetSizeDevice(HDC hdc, int cxVirtualDevice, int cyVirtualDevice);


/******************************Public*Routine******************************\
* HDC APIENTRY CreateEnhMetaFileA(
*         HDC hDCRef OPTIONAL,
*         LPSTR pszFilename OPTIONAL,
*         LPRECT lpRect OPTIONAL,
*         LPSTR lpDescription OPTIONAL);
*
* The CreateEnhMetaFile function creates an enhanced metafile device context.
*
* Client side stub.  Allocates a client side LDC as well.
*
* Note that it calls the server only after all client side stuff has
* succeeded, we don't want to ask the server to clean up.
*
* The LDC is actually a reference info DC for the metafile.  The pmdc
* in the handle table is a pointer to the metafile DC object.
*
* Parameter   Description
* lpFilename  Points to the filename for the metafile. If NULL, the metafile
*             will be memory based with no backing store.
*
* Return Value
* The return value identifies an enhanced metafile device context if the
* function is successful. Otherwise, it is zero.
*
* Note that it returns a HDC, not a HENHMETAFILE!
*
* History:
*  Wed Jul 17 10:10:36 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

extern "C" HDC APIENTRY CreateEnhMetaFileA
(
HDC    hDCRef,
LPCSTR pszFilename,
CONST RECT *lpRect,
LPCSTR lpDescription
)
{
    UINT  cch;
    HDC   hdcRet;
    WCHAR awchFilename[MAX_PATH];
    PWCH  pwchFilename    = (PWCH) NULL;
    PWCH  pwchDescription = (PWCH) NULL;

    if (pszFilename != (LPSTR) NULL)
    {
        cch = strlen(pszFilename) + 1;

        if (cch > MAX_PATH)
        {
            ERROR_ASSERT(FALSE, "CreateEnhMetaFileA filename too long");
            GdiSetLastError(ERROR_FILENAME_EXCED_RANGE);
            return((HDC) 0);
        }
        vToUnicodeN(pwchFilename = awchFilename, MAX_PATH, pszFilename, cch);
    }

    if (lpDescription != (LPSTR) NULL)
    {
        // Compute the length of the description string including the NULL
        // characters.

        for (cch = 0;
             lpDescription[cch] != (CHAR) 0 || lpDescription[cch+1] != (CHAR) 0;
             cch++)
            ;                   // NULL expression
        cch += 2;

        pwchDescription = (PWCH) LocalAlloc(LMEM_FIXED, cch*sizeof(WCHAR));
        if (pwchDescription == (PWCH) NULL)
        {
            VERIFYGDI(FALSE, "CreateEnhMetaFileA out of memory\n");
            return((HDC) 0);
        }
        vToUnicodeN(pwchDescription, cch, lpDescription, cch);
    }

    hdcRet = CreateEnhMetaFileW(hDCRef, pwchFilename, lpRect, pwchDescription);

    if (pwchDescription)
    {
        if (LocalFree((HANDLE) pwchDescription))
        {
            ASSERTGDI(FALSE, "LocalFree failed");
        }
    }

    return(hdcRet);
}

extern "C" HDC APIENTRY CreateEnhMetaFileW
(
HDC      hDCRef,
LPCWSTR  pwszFilename,
CONST RECT *lpRect,
LPCWSTR  lpDescription
)
{
    HDC   hdcNew = NULL;
    PLDC  pldc   = NULL;
    PMDC  pmdc;

    PUTS("CreateEnhMetaFileW\n");

    // Get the server to create a DC.
    // If hDCRef is supplied then clone it for the reference DC.
    // Otherwise, use the display as the reference info DC for the metafile.

    hdcNew = NtGdiCreateMetafileDC(hDCRef);

    // now create the client version

    if (hdcNew)
    {
        // if this fails, it deletes hdcNew

        pldc = pldcCreate(hdcNew,LO_METADC);
    }

    // Handle errors.

    if (!pldc)
    {
        ERROR_ASSERT(FALSE, "CreateEnhMetaFileW failed");
        return((HDC) 0);
    }

    ASSERTGDI(LO_TYPE(hdcNew) == LO_ALTDC_TYPE,"CreateEnhMetafile - invalid type\n");

// Create the metafile DC object.

    if (!(pmdc = pmdcAllocMDC(hdcNew, pwszFilename, lpDescription, NULL)))
        goto CreateEnhMetaFileW_error;

    pldc->pvPMDC = (PVOID)pmdc;

// Add the Frame Rect if one was specified; if not it will be fixed up
// by CloseEnhMetaFile.

    if (lpRect)
    {
        if (((PERECTL) lpRect)->bEmpty())
        {
            ERROR_ASSERT(FALSE, "CreateEnhMetaFileW invalid frame rect");
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            goto CreateEnhMetaFileW_error;
        }
        else
            pmdc->mrmf.rclFrame = *(PRECTL) lpRect;
    }

// Enable bounds accumlation in the reference DC.

    (void) SetBoundsRectAlt(hdcNew, (LPRECT) NULL,
        (UINT) (DCB_WINDOWMGR | DCB_RESET | DCB_ENABLE));
// Return the result.

    ASSERTGDI(hdcNew != (HDC) NULL, "CreateEnhMetaFileW: bad HDC value");
    return(hdcNew);

// Cleanup for errors.

CreateEnhMetaFileW_error:

    if (pmdc)
    {
        pmdc->fl |= MDC_FATALERROR;
        vFreeMDC(pmdc);
        pldc->pvPMDC = NULL;
    }

    if (!InternalDeleteDC(hdcNew, LO_METADC))
    {
        ASSERTGDI(FALSE, "InternalDeleteDC failed");
    }

    ERROR_ASSERT(FALSE, "CreateEnhMetaFileW failed");
    return((HDC) 0);
}

/******************************Public*Routine******************************\
* AssociateEnhMetaFile()
*
*   Associate an EnhMetaFile with this DC.  This is similar to CreateEnhMetaFile
*   but in this case it just converts the dc.  UnassociateEnhMetaFile must be
*   used on this DC before it can be deleted.  CloseMetaFile can not be use.
*   This is currently only for use by spooled printing using enhanced metafiles.
*
*   This is called at start doc and after each EndPage to set up the next page.
*
* History:
*  19-Jan-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

extern "C" BOOL APIENTRY AssociateEnhMetaFile(
    HDC hdc)
{
    ULONG ulSrvDC;
    PMDC  pmdc;
    BOOL  bIcmOn = FALSE;

    PUTS("CreateEnhMetaFileW\n");

// Get the server to create a DC.
// If hDCRef is supplied then clone it for the reference DC.
// Otherwise, use the display as the reference info DC for the metafile.

    PLDC pldc;

    DC_PLDC(hdc,pldc,FALSE);

// Handle errors.

    EMFSpoolData *pEMFSpool = (EMFSpoolData *) pldc->hEMFSpool;

    if (pldc->iType == LO_METADC || pEMFSpool == NULL)
    {
        ERROR_ASSERT(FALSE, "CreateEnhMetaFileW failed");
        return(FALSE);
    }

// Create the metafile DC object.

    if (!(pmdc = pmdcAllocMDC(hdc, NULL, L"Print test\0", (HANDLE) pEMFSpool)))
    {
        ERROR_ASSERT(FALSE, "CreateEnhMetaFileW failed");
        return(FALSE);
    }

// Before, we switch this DC to Metafile DC, turn-off ICM.

    if (SetICMMode(hdc,ICM_QUERY) == ICM_ON)
    {
        SetICMMode(hdc,ICM_OFF);
        bIcmOn = TRUE;
    }

    MakeInfoDC(hdc,TRUE);

    ASSERTGDI(pldc->iType == LO_DC,"AssociateEnhMetaFile not LO_DC\n");

    pldc->pvPMDC  = (PVOID)pmdc;
    pldc->iType = LO_METADC;

    pmdc->mrmf.rclFrame.left   = 0;
    pmdc->mrmf.rclFrame.top    = 0;
    pmdc->mrmf.rclFrame.right  = GetDeviceCaps( hdc, HORZSIZE ) * 100;
    pmdc->mrmf.rclFrame.bottom = GetDeviceCaps( hdc, VERTSIZE ) * 100;

// Enable bounds accumlation in the reference DC.

    SetBoundsRectAlt(hdc, NULL,(UINT) (DCB_WINDOWMGR | DCB_RESET | DCB_ENABLE));

// if ICM is originally turned on, turn on it for LO_METADC.

    if (bIcmOn)
    {
        SetICMMode(hdc,ICM_ON);
    }

// Save state of the DC in the EnhMetaFile

    return (PutDCStateInMetafile( hdc ));
}


/******************************Public*Routine******************************\
* HENHMETAFILE CloseEnhMetaFile(hDC)
* HDC hDC;
*
* The CloseEnhMetaFile function closes the enhanced metafile device context
* and creates an enhanced metafile handle that can be used with other
* enhanced metafile calls.
*
* Parameter  Description
* hDC        Identifies the enhanced metafile device context to be closed.
*
* Return Value
* The return value identifies the enhanced metafile if the function is
* successful.  Otherwise, it is 0.
*
* History:
*  Wed Jul 17 10:10:36 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

extern "C" HENHMETAFILE APIENTRY CloseEnhMetaFile(HDC hdc)
{
    PMDC            pmdc;
    HENHMETAFILE    hemf = NULL;
    PUTS("CloseEnhMetaFile\n");

// Validate the metafile DC handle.

    PLDC pldc;

    DC_PLDC(hdc,pldc,hemf);

// Handle errors.

    if (pldc->iType != LO_METADC)
        return(hemf);

// Cleanup temp brush or pen created for SetDCBrushColor and SetDCPenColor
    if (pldc->oldSetDCBrushColorBrush)
    {
        DeleteObject(pldc->oldSetDCBrushColorBrush);
        pldc->oldSetDCBrushColorBrush = 0;
    }
    if (pldc->oldSetDCPenColorPen)
    {
        DeleteObject(pldc->oldSetDCPenColorPen);
        pldc->oldSetDCPenColorPen = 0;
    }

    pmdc = (PMDC)pldc->pvPMDC;

    // If the metafile contains GL records, tell OpenGL that things are done
    if (pmdc->mrmf.bOpenGL)
    {
        if (!GlmfCloseMetaFile(hdc))
        {
            WARNING("GlmfCloseMetaFile failed\n");
        }
    }

// Check for fatal errors.

    if (pmdc->bFatalError())
        goto CloseEnhMetaFile_cleanup;

// Make sure that save and restore DCs are balanced.  Always restore back to 1.
// Don't need to check if it fails since not much we can do anyways.  Also,
// we would need to make an extra server call to see if it is already at 1.

    RestoreDC(hdc,1);

// Write out the EOF metafile record.  This would force the previous
// bounds record to be commited.  The EOF metafile record includes the
// metafile palette if logical palettes are used.

    pmdc->mrmf.nPalEntries = pmdc->iPalEntries;

    if (!MF_EOF(hdc,pmdc->iPalEntries,pmdc->pPalEntries))
        goto CloseEnhMetaFile_cleanup;

// Finally flush the bounds to the metafile header.  We cannot flush the
// bounds if we have not committed the previous bounds record yet.
// Therefore, we do this after the last EMREOF record.

    pmdc->vFlushBounds();

// If there was no initial metafile Frame defined in CreateEnhMetaFile then
// the Bounds converted to 0.01 mm will be the Frame.

    if (((PERECTL) &pmdc->mrmf.rclFrame)->bEmpty())
    {
        pmdc->mrmf.rclFrame.left   = MulDiv((int) (100 * pmdc->mrmf.rclBounds.left),
                                            (int) pmdc->mrmf.szlMillimeters.cx,
                                            (int) pmdc->mrmf.szlDevice.cx);
        pmdc->mrmf.rclFrame.right  = MulDiv((int) (100 * pmdc->mrmf.rclBounds.right),
                                            (int) pmdc->mrmf.szlMillimeters.cx,
                                            (int) pmdc->mrmf.szlDevice.cx);
        pmdc->mrmf.rclFrame.top    = MulDiv((int) (100 * pmdc->mrmf.rclBounds.top),
                                            (int) pmdc->mrmf.szlMillimeters.cy,
                                            (int) pmdc->mrmf.szlDevice.cy);
        pmdc->mrmf.rclFrame.bottom = MulDiv((int) (100 * pmdc->mrmf.rclBounds.bottom),
                                            (int) pmdc->mrmf.szlMillimeters.cy,
                                            (int) pmdc->mrmf.szlDevice.cy);
    }

// Flush the buffer and write out the latest header record.

    ASSERTGDI((ULONG) pmdc->mrmf.nHandles <= pmdc->cmhe,
        "CloseEnhMetaFile: Bad nHandles");

    if (pmdc->bIsDiskFile())
    {
        ULONG   nWritten ;

        // Flush the memory buffer.

        if (!pmdc->bFlush())
            goto CloseEnhMetaFile_cleanup;

        // Flush the header record.

        if (SetFilePointer(pmdc->hFile, 0L, (PLONG) NULL, FILE_BEGIN) != 0L)
            goto CloseEnhMetaFile_cleanup;

        if (!WriteFile(pmdc->hFile, &pmdc->mrmf, sizeof(ENHMETAHEADER),
                &nWritten, (LPOVERLAPPED) NULL)
         || nWritten != sizeof(ENHMETAHEADER))
            goto CloseEnhMetaFile_cleanup;

        // Close the file.

        if (!CloseHandle(pmdc->hFile))
        {
            ASSERTGDI(FALSE, "CloseHandle failed");
        }

        pmdc->hFile = INVALID_HANDLE_VALUE;
    }
    else
    {
        // Flush the header record.

        PENHMETAHEADER pmrmf = (PENHMETAHEADER) pmdc->GetPtr(0, sizeof(ENHMETAHEADER));

        if(pmrmf)
        {
            *pmrmf = pmdc->mrmf;

            pmdc->ReleasePtr(pmrmf);
        }
        else
        {
            WARNING("CloseEnhMetaFile() Failed to get ENHMETAHEADER pointer\n");
            goto CloseEnhMetaFile_cleanup;
        }

        // Realloc memory metafile to exact size

        if (!pmdc->ReallocMem(pmdc->iMem))
        {
            ASSERTGDI(FALSE, "ReallocMem failed");
        }
    }

// Fixup the checksum if we are embedding a Windows metafile.
// This is called by SetWinMetaFileBits only.

    if (pmdc->fl & MDC_CHECKSUM)
    {
        DWORD    nChecksum;
        PEMRGDICOMMENT_WINDOWS_METAFILE pemrWinMF;

        ASSERTGDI(!pmdc->bIsDiskFile(),
            "CloseEnhMetaFile: Expects only mem files for Checksum");

        PENHMETAHEADER pmrmf = (PENHMETAHEADER) pmdc->GetPtr(0, pmdc->iMem);

        if(pmrmf)
        {
            nChecksum = GetDWordCheckSum((UINT) pmdc->iMem, (PDWORD) pmrmf);

            pemrWinMF = (PEMRGDICOMMENT_WINDOWS_METAFILE) ((PBYTE) pmrmf + pmrmf->nSize);

            ASSERTGDI(((PMRGDICOMMENT) pemrWinMF)->bIsWindowsMetaFile(),
                "CloseEnhMetaFile: record should be comment");

            pemrWinMF->nChecksum = (DWORD) 0 - nChecksum;

            ASSERTGDI(!GetDWordCheckSum((UINT)pmdc->iMem, (PDWORD) pmrmf),
                "CloseEnhMetaFile Checksum failed");

            pmdc->ReleasePtr(pmrmf);
        }
        else
        {
            WARNING("CloseEnhMetaFile() Failed to get metafile data pointer\n");
            goto CloseEnhMetaFile_cleanup;
        }
    }

// Allocate and initialize a MF.

    if (pmdc->bIsDiskFile())
    {
        hemf = GetEnhMetaFileW(pmdc->wszPathname);
    }
    else
    {
        if (pmdc->bIsEMFSpool())
        {
            // Just in case - we should never get here during EMF spooling

            WARNING("CloseEnhMetaFile: called during EMF spooling\n");

            hemf = pmdc->CompleteEMFData(TRUE);
        }
        else
        {
            PENHMETAHEADER pmrmf = (PENHMETAHEADER) pmdc->GetPtr(0, pmdc->iMem);
            
            if(pmrmf)
            {
                hemf = SetEnhMetaFileBitsAlt((HLOCAL) pmrmf, NULL, NULL, 0);

                pmdc->ReleasePtr(pmrmf);
            }
            else
            {
                WARNING("CloseEnhMetaFile: failed to get emf data\n");
                goto CloseEnhMetaFile_cleanup;
            }
        }

        if (hemf)
            pmdc->hData = NULL; // don't free it below because it has been transfered
    }

CloseEnhMetaFile_cleanup:

// Delete the disk metafile if we had an error.

    if (hemf == (HENHMETAFILE) 0)
        pmdc->fl |= MDC_FATALERROR;

// Delete the MDC and free objects and resources.

    vFreeMDC(pmdc);

// Delete the reference info DC last because we need the local handle in
// vFreeMDC.

    if (!InternalDeleteDC(hdc, LO_METADC))
    {
        ASSERTGDI(FALSE, "InternalDeleteDC failed");
    }

    ERROR_ASSERT(hemf != (HENHMETAFILE) 0, "CloseEnhMetaFile failed");
    return(hemf);
}

/******************************Public*Routine******************************\
* UnassociateEnhMetaFile()
*
*   This should only be called if AssociateEnhMetaFile() is first called on
* this DC.  This is similar to CloseEnhMetaFile in that it returns an
* enhanced metafile, but it does not delete the DC, it just converts it back
* to a direct DC.  This is currently intended only for use with enhanced
* metafile spooling.
*
* History:
*  20-Jan-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

extern "C" HENHMETAFILE UnassociateEnhMetaFile(HDC hdc, BOOL bKeepEMF)
{
    PMDC            pmdc;
    HENHMETAFILE    hemf = NULL;
    BOOL            bIcmOn = FALSE;
    PENHMETAHEADER  pmrmf = NULL;

    PUTS("UnassociateEnhMetaFile\n");

// Validate the metafile DC handle.

    PLDC pldc;

    DC_PLDC(hdc,pldc,hemf);

// Handle errors.

    if (pldc->iType != LO_METADC)
    {
    // We need to exit cleanly in this case because we could hit it, if at
    // end page time we suceed in unasociating a metafile but then fail before
    // we can reassociate a new metafile.

        WARNING("UnassociateEnhMetaFileW - not a metafile\n");
        return((HENHMETAFILE)0);
    }

// Cleanup temp brush or pen created for SetDCBrushColor and SetDCPenColor
    if (pldc->oldSetDCBrushColorBrush)
    {
        DeleteObject(pldc->oldSetDCBrushColorBrush);
        pldc->oldSetDCBrushColorBrush = 0;
    }
    if (pldc->oldSetDCPenColorPen)
    {
        DeleteObject(pldc->oldSetDCPenColorPen);
        pldc->oldSetDCPenColorPen = 0;
    }
    pmdc = (PMDC)pldc->pvPMDC;

    // if there is no pmdc, there was a failure during the recording.  Still
    // need to unassociate the meta file but don't want to do any of the other
    // cleanup.
    //

    if (pmdc == NULL || !pmdc->bIsEMFSpool())
    {
        WARNING("UnassociateEnhMetaFile: pmdc is NULL or no EMFSpoolData\n");

        MakeInfoDC(hdc,FALSE);
        return((HENHMETAFILE)0);
    }

    // If the metafile contains GL records, tell OpenGL that things are done
    if (pmdc->mrmf.bOpenGL)
    {
        if (!GlmfCloseMetaFile(hdc))
        {
            WARNING("GlmfCloseMetaFile failed\n");
        }
    }

// Before, we switch this back to original state, turn-off ICM.

    if (SetICMMode(hdc,ICM_QUERY) == ICM_ON)
    {
        SetICMMode(hdc,ICM_OFF);
        bIcmOn = TRUE;
    }

    MakeInfoDC(hdc,FALSE);

// Check for fatal errors.

    if (pmdc->bFatalError())
        goto UnassociateEnhMetaFile_cleanup;

// Write out the EOF metafile record.  This would force the previous
// bounds record to be commited.  The EOF metafile record includes the
// metafile palette if logical palettes are used.

    pmdc->mrmf.nPalEntries = pmdc->iPalEntries;

    if (!MF_EOF(hdc,pmdc->iPalEntries,pmdc->pPalEntries))
        goto UnassociateEnhMetaFile_cleanup;

// Finally flush the bounds to the metafile header.  We cannot flush the
// bounds if we have not committed the previous bounds record yet.
// Therefore, we do this after the last EMREOF record.

    pmdc->vFlushBounds();

// If there was no initial metafile Frame defined in CreateEnhMetaFile then
// the Bounds converted to 0.01 mm will be the Frame.

    if (((PERECTL) &pmdc->mrmf.rclFrame)->bEmpty())
    {
        pmdc->mrmf.rclFrame.left   = MulDiv((int) (100 * pmdc->mrmf.rclBounds.left),
                                            (int) pmdc->mrmf.szlMillimeters.cx,
                                            (int) pmdc->mrmf.szlDevice.cx);
        pmdc->mrmf.rclFrame.right  = MulDiv((int) (100 * pmdc->mrmf.rclBounds.right),
                                            (int) pmdc->mrmf.szlMillimeters.cx,
                                            (int) pmdc->mrmf.szlDevice.cx);
        pmdc->mrmf.rclFrame.top    = MulDiv((int) (100 * pmdc->mrmf.rclBounds.top),
                                            (int) pmdc->mrmf.szlMillimeters.cy,
                                            (int) pmdc->mrmf.szlDevice.cy);
        pmdc->mrmf.rclFrame.bottom = MulDiv((int) (100 * pmdc->mrmf.rclBounds.bottom),
                                            (int) pmdc->mrmf.szlMillimeters.cy,
                                            (int) pmdc->mrmf.szlDevice.cy);
    }

// Flush the buffer and write out the latest header record.

    ASSERTGDI((ULONG) pmdc->mrmf.nHandles <= pmdc->cmhe,
        "UnassociateEnhMetaFile: Bad nHandles");

    // Flush the header record.

    {
        pmrmf = (PENHMETAHEADER) pmdc->GetPtr(0, sizeof(ENHMETAHEADER));
    
        if(pmrmf)
        {
            *pmrmf = pmdc->mrmf;
    
            pmdc->ReleasePtr(pmrmf);
        }
        else
        {
            WARNING("UnassociateEnhMetaFile() failed to get ENHMETAHEADER\n");
            goto UnassociateEnhMetaFile_cleanup;
        }
    }


    // Realloc memory metafile to exact size

    if (!pmdc->ReallocMem(pmdc->iMem))
    {
        ASSERTGDI(FALSE, "ReallocMem failed");
    }

// Fixup the checksum if we are embedding a Windows metafile.
// This is called by SetWinMetaFileBits only.

    if (pmdc->fl & MDC_CHECKSUM)
    {
        DWORD    nChecksum;
        PEMRGDICOMMENT_WINDOWS_METAFILE pemrWinMF;

        ASSERTGDI(!pmdc->bIsDiskFile(),
            "UnassociateMetaFile: Expects only mem files for Checksum");

        pmrmf = (PENHMETAHEADER) pmdc->GetPtr(0, pmdc->iMem);

        if(pmrmf)
        {
            nChecksum = GetDWordCheckSum((UINT) pmdc->iMem, (PDWORD) pmrmf);

            pemrWinMF = (PEMRGDICOMMENT_WINDOWS_METAFILE) ((PBYTE) pmrmf + pmrmf->nSize);

            ASSERTGDI(((PMRGDICOMMENT) pemrWinMF)->bIsWindowsMetaFile(),
                "UnassociatePrintMetaFile: record should be comment");

            pemrWinMF->nChecksum = (DWORD) 0 - nChecksum;

            ASSERTGDI(!GetDWordCheckSum((UINT)pmdc->iMem, (PDWORD) pmrmf),
                "UnassociatePrintMetaFile Checksum failed");

            pmdc->ReleasePtr(pmrmf);
        }
        else
        {
            WARNING("UnassociateMetaFile() failed to get metafile data\n");
            goto UnassociateEnhMetaFile_cleanup;
        }
    }

// Allocate and initialize a MF.

    if (hemf = pmdc->CompleteEMFData(bKeepEMF))
        pmdc->hData = NULL; // don't free it below because it has been transfered

    ASSERTGDI(pldc->iType == LO_METADC,"UnassociateEnhMetaFile not LO_METADC\n");

UnassociateEnhMetaFile_cleanup:

    pldc->iType = LO_DC;

// Delete the disk metafile if we had an error.

    if (hemf == (HENHMETAFILE) 0)
        pmdc->fl |= MDC_FATALERROR;

// Delete the MDC and free objects and resources.

    vFreeMDC(pmdc);

    pldc->pvPMDC = NULL;

// if ICM is originally turned on, turn on it for LO_METADC.

    if (bIcmOn)
    {
        SetICMMode(hdc,ICM_ON);
    }

    return(hemf);
}

/******************************Public*Routine******************************\
* HENHMETAFILE CopyEnhMetaFile(hSrcMetaFile, lpFilename)
* HENHMETAFILE hSrcMetaFile;
* LPSTR lpFilename;
*
* The CopyEnhMetaFile function copies the source metafile. If lpFilename is a
* valid filename, the source is copies to a disk metafile. If lpFilename is
* NULL, the source is copied to a memory metafile.
*
* Parameter     Description
* hSrcMetaFile  Identifies the source metafile.
* lpFilename    Points to a filename of the file that is to receive the
*               metafile. If NULL the source is copied to a memory metafile.
*
* Return Value
* The return value identifies the new enhanced metafile. Zero is returned if
* an error occurred.
*
* History:
*  Tue Sep 03 11:21:14 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

extern "C" HENHMETAFILE APIENTRY CopyEnhMetaFileA(HENHMETAFILE hemf, LPCSTR psz)
{
    UINT  cch;
    WCHAR awch[MAX_PATH];

    if (psz != (LPSTR) NULL)
    {
        cch = strlen(psz) + 1;

        if (cch > MAX_PATH)
        {
            ERROR_ASSERT(FALSE, "CopyEnhMetaFileA filename too long");
            GdiSetLastError(ERROR_FILENAME_EXCED_RANGE);
            return((HENHMETAFILE)0);
        }
        vToUnicodeN(awch, MAX_PATH, psz, cch);

        return(CopyEnhMetaFileW(hemf, awch));
    }
    else
        return(CopyEnhMetaFileW(hemf, (LPWSTR) NULL));
}

extern "C" HENHMETAFILE APIENTRY CopyEnhMetaFileW(HENHMETAFILE hemf, LPCWSTR pwsz)
{
    PMF             pmf;
    HENHMETAFILE    hmf = NULL;

    PUTS("CopyEnhMetaFileW\n");

// Validate the metafile handle.

    if (!(pmf = GET_PMF(hemf)))
        return(hmf);

    PENHMETAHEADER pmrmf = pmf->emfc.GetEMFHeader();

    if(!pmrmf)
    {
        WARNING("CopyEnhMetaFile: unable to get header info\n");
        return(hmf);
    }

    PBYTE pb = (PBYTE) pmf->emfc.ObtainPtr(0, pmrmf->nBytes);

    if(!pb)
    {
        WARNING("CopyEnhMetaFile: unable to get header info\n");
        return(hmf);
    }

    if (pwsz)
    {
        HANDLE hFile    = INVALID_HANDLE_VALUE;
        HANDLE hFileMap = NULL;
        HANDLE hMem     = NULL;

        // It's a disk metafile.
        // Create the disk file.

        if ((hFile = CreateFileW(pwsz,                  // Filename
                                GENERIC_WRITE|GENERIC_READ,   // Write access
                                0L,                     // Non-shared
                                (LPSECURITY_ATTRIBUTES) NULL, // No security
                                CREATE_ALWAYS,          // Always create
                                FILE_ATTRIBUTE_NORMAL,  // normal attributes
                                (HANDLE) 0))            // no template file
            == INVALID_HANDLE_VALUE)
        {
            ERROR_ASSERT(FALSE, "CopyEnhMetaFile: CreateFile failed");
            goto CopyEnhMetaFile_file_cleanup;
        }

        // Map the disk file.

        if (!(hFileMap = CreateFileMappingW(hFile,
                                           (LPSECURITY_ATTRIBUTES) NULL,
                                           PAGE_READWRITE,
                                           0L,
                                           pmrmf->nBytes,
                                           (LPWSTR) NULL)))
        {
            ERROR_ASSERT(FALSE, "CopyEnhMetaFile: CreateFileMapping failed");
            goto CopyEnhMetaFile_file_cleanup;
        }

        if (!(hMem = MapViewOfFile(hFileMap, FILE_MAP_WRITE, 0, 0, 0)))
        {
            ERROR_ASSERT(FALSE, "CopyEnhMetaFile: MapViewOfFile failed");
            goto CopyEnhMetaFile_file_cleanup;
        }

        // Copy the bits.

        RtlCopyMemory((PBYTE) hMem, pb, pmrmf->nBytes);

CopyEnhMetaFile_file_cleanup:

        if (hMem)
        {
            if (!UnmapViewOfFile(hMem))
            {
                ASSERTGDI(FALSE, "UmmapViewOfFile failed");
            }
        }

        if (hFileMap)
        {
            if (!CloseHandle(hFileMap))
            {
                ASSERTGDI(FALSE, "CloseHandle failed");
            }
        }

        if (hFile != INVALID_HANDLE_VALUE)
        {
            if (!CloseHandle(hFile))
            {
                ASSERTGDI(FALSE, "CloseHandle failed");
            }
        }

// Return a hemf if success.

        hmf = (hMem ? GetEnhMetaFileW(pwsz) : (HENHMETAFILE) 0);
    }
    else
    {
        // It's a memory metafile.
        // This is identical to SetEnhMetaFileBits.

        hmf = SetEnhMetaFileBits((UINT)pmrmf->nBytes, pb);
    }

    if(pb)
        pmf->emfc.ReleasePtr(pb);

    return(hmf);
}

/******************************Public*Routine******************************\
* BOOL DeleteEnhMetaFile(hEMF)
* HENHMETAFILE hEMF;
*
* The DeleteEnhMetaFile function invalidates the given metafile handle. If hemf
* refered to a memory metafile, the metafile contents are lost. If hemf refered
* to a disk-based metafile, the metafile contents are retained and access to
* the metafile can be reestablished by retrieving a new handle using the
* GetEnhMetaFile function.
*
* Parameter  Description
* hemf        Identifies the enhanced metafile.
*
* Return Value
* The return value is TRUE if the handle has been invalidated. Otherwise it is
* FALSE.
*
* History:
*  Tue Sep 03 11:21:14 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

extern "C" BOOL APIENTRY DeleteEnhMetaFile(HENHMETAFILE hemf)
{
    PMF    pmf;

    PUTS("DeleteEnhMetaFile\n");

// Validate the metafile handle.

    if (!(pmf = GET_PMF(hemf)))
        return(FALSE);

// Free the metafile and its handle.

    vFreeMF(pmf);
    return(bDeleteHmf(hemf));
}

BOOL InternalDeleteEnhMetaFile(HENHMETAFILE hemf, BOOL bAllocBuffer)
/*++
Function Description: This is an internal definition of DeleteEnhMetaFile which is
                      used in the printing playback code (object.c). The flag bAllocBuffer
                      if used to indicate if the buffer associated with hemf needs to be
                      freed. This is used while passing read only memory mapped buffers to
                      SetEnhMetaFileBitsAlt.

Parameters:    hemf         --   emf handle to be deleted
               bAllocBuffer --   flag to releasing hemf buffers.

Return Values:  TRUE if successful;
                FALSE otherwise
--*/
{
   PMF    pmf;

   PUTS("DeleteEnhMetaFile\n");

// Validate the metafile handle.

   if (!(pmf = GET_PMF(hemf)))
       return(FALSE);

// Free the metafile and its handle.

   vFreeMFAlt(pmf, bAllocBuffer);
   return(bDeleteHmf(hemf));

}

/******************************Public*Routine******************************\
* HENHMETAFILE GetEnhMetaFile(lpFilename)
* LPSTR lpFilename;
*
* The GetEnhMetaFile function creates a handle for the enhanced metafile
* named by the lpFilename parameter.
*
* Parameter   Description
* lpFilename  Points to the null-terminated character filename that specifies
*             the enhanced metafile. The metafile must already exist.
*
* Return Value
* The return value identifies an enhanced metafile if the function is
* successful.  Otherwise, it is 0.
*
* History:
*  Tue Sep 03 11:21:14 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

extern "C" HENHMETAFILE  APIENTRY GetEnhMetaFileA(LPCSTR psz)
{
    UINT  cch;
    WCHAR awch[MAX_PATH];

    cch = strlen(psz) + 1;

    if (cch > MAX_PATH)
    {
        ERROR_ASSERT(FALSE, "GetEnhMetaFileA filename too long");
        GdiSetLastError(ERROR_FILENAME_EXCED_RANGE);
        return ((HENHMETAFILE)0);
    }

    vToUnicodeN(awch, MAX_PATH, psz, cch);

    return(GetEnhMetaFileW(awch));
}

extern "C" HENHMETAFILE  APIENTRY GetEnhMetaFileW(LPCWSTR pwsz)
{
    PMF     pmf;
    HENHMETAFILE hmf;

    PUTS("GetEnhMetaFileW\n");

// Allocate and initialize a MF.

    if (!(pmf = pmfAllocMF(0, (PDWORD) NULL, pwsz, NULL, 0, 0)))
        return((HENHMETAFILE) 0);

// Allocate a local handle.

    hmf = hmfCreate(pmf);
    if (hmf == NULL)
    {
        vFreeMF(pmf);
    }

// Return the metafile handle.

    return(hmf);
}

/******************************Public*Routine******************************\
* BOOL PlayEnhMetaFile(hDC, hEMF, lpRect)
* HDC hDC;
* HENHMETAFILE hEMF;
* LPRECT lpRect;
*
* The PlayEnhMetaFile function plays the contents of the specified metafile to
* the given device context. The metafile can be played any number of times.
*
* Parameter  Description
* hDC        Identifies the device context of the output device.
* hEMF       Identifies the metafile.
*
* Return Value
* The return value is TRUE if the function is successful. Otherwise, it is
* FALSE.
*
* History:
*  Tue Sep 03 11:21:14 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

extern "C" BOOL APIENTRY PlayEnhMetaFile(HDC hdc, HENHMETAFILE hemf, CONST RECT *lpRect)
{
    PUTS("PlayEnhMetaFile\n");

// Make sure that hdc is given.  bInternalPlayEMF expects it to be given
// in PlayEnhMetaFile.

    if (hdc == (HDC) 0)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }


    return(bInternalPlayEMF(hdc, hemf, (ENHMFENUMPROC) NULL, (LPVOID) NULL, (PRECTL) lpRect));
}

/******************************Public*Routine******************************\
* BOOL EnumEnhMetaFile(hDC, hemf, lpMetaFunc, lpData, lpRect)
* HDC hDC;
* HENHMETAFILE hemf;
* ENHMFENUMPROC lpMetaFunc;
* LPVOID lpData;
* LPRECT lpRect;
*
* The EnumEnhMetaFile function enumerates the GDI calls within the metafile
* identified by the hemf parameter. The EnumEnhMetaFile function retrieves each
* GDI call within the metafile and passes it to the function pointed to by the
* lpMetaFunc parameter. This callback function, an application-supplied
* function, can process each GDI call as desired. Enumeration continues until
* there are no more GDI calls or the callback function returns FALSE.
*
* Parameter   Description
* hDC         Identifies the device context to be passed to MetaFunc.
* hemf        Identifies the metafile.
* lpMetaFunc  Is the address of the callback function. See the following
*             Comments section for details.
* lpData      Points to the callback-function data.
* lpRect      Points to a %RECT% structure the contains the coordinates of the
*             upper-left and lower-right corners of the bounding rectangle for
*             the output area in logical units.  Points on the edges are
*             included in the output area.  If <hdc> is 0, this is ignored.
*
* Return Value
* The return value is TRUE if the callback function enumerates all the GDI
* calls in a metafile. Otherwise, it returns FALSE.
*
* Comments
* The callback function must be declared as an APIENTRY, so that the correct
* calling conventions will be used.
*
* Callback Function
* BOOL APIENTRY MetaFunc(hDC, lpHTable, lpMFR, nObj, lpData)
* HDC hDC;
* LPHANDLETABLE lpHTable;
* LPENHMETARECORD lpMFR;
* LONG nObj;
* LPVOID lpData;
*
* This function may have any name, MetaFunc is just an example.
*
* Parameter  Description
* hDC        Identifies the device context that was passed to EnumEnhMetaFile.
* lpHTable   Points to a table of handles associated with the objects (pens,
*            brushes, and so on) in the metafile.
* lpMFR      Points to a metafile record contained in the metafile.
* nObj       Specifies the number of objects with associated handles in the
*            handle table.
* lpData     Points to the application-supplied data.
*
* Return Value
* The function can carry out any desired task. It must return TRUE to continue
* enumeration, or FALSE to stop it.
*
* History:
*  Tue Sep 03 11:21:14 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

extern "C" BOOL APIENTRY EnumEnhMetaFile(HDC hdc, HENHMETAFILE hemf, ENHMFENUMPROC pfn, LPVOID pv, CONST RECT *lpRect)
{
    PUTS("EnumEnhMetaFile\n");

// Make sure that the callback function is given.  bInternalPlayEMF expects
// it to be given in EnumEnhMetaFile.

    if (pfn == (ENHMFENUMPROC) NULL)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    return(bInternalPlayEMF(hdc, hemf, pfn, pv, (PRECTL) lpRect));
}


BOOL bInternalPlayEMF(HDC hdc, HENHMETAFILE hemf, ENHMFENUMPROC pfn, LPVOID pv, CONST RECTL *prcl)
{
    BOOL            bRet = FALSE;
    BOOL            bBailout = TRUE;
    PMF             pmf;
    ULONG           ii, iPos;
    PDC_ATTR        pDcAttr;
    FLONG           flPlayMetaFile;
    PLDC            pldc = (PLDC) NULL;
    PVOID           pvUser;
    DWORD           dwLayout = GDI_ERROR;
    PENHMETARECORD  pemr = NULL;

    //
    // validate hdc, get user mode dc attr pointer
    //

    PSHARED_GET_VALIDATE(pvUser,hdc,DC_TYPE);
    pDcAttr = (PDC_ATTR)pvUser;

    BOOL   bGlmf = FALSE;
    BOOL   bInGlsBlock = FALSE;

    PUTS("bInternalPlayEMF\n");

// Validate the metafile handle.

    if (!(pmf = GET_PMF(hemf)))
        return(bRet);

    PENHMETAHEADER pmrmf = pmf->emfc.GetEMFHeader();

    if(!pmrmf)
    {
        WARNING("bInternalPlayEMF: unable to get header info\n");
        return(FALSE);
    }

// Store hemf in the handle table.

    pmf->pht->objectHandle[0] = hemf;

// Initialize metafile save level to 1.

    pmf->cLevel = 1;

// Initialize the public comment indicator to FALSE.
// This is set by MRMETAFILE::bPlay and cleared by MREOF::bPlay when embedding.

    pmf->bBeginGroup = FALSE;

// Initialize default clipping.

    pmf->erclClipBox = rclInfinity;

    // Load OpenGL if the metafile contains GL records

    if (pmrmf->nSize >= META_HDR_SIZE_VERSION_2 &&
        pmrmf->bOpenGL &&
        !LoadOpenGL())
    {
        return FALSE;
    }

// If DC is not given in EnumEnhMetaFile, we will only enumerate the records.

    if (hdc != (HDC) 0)
    {
        // Make sure that the output rectangle is given.

        if (prcl == (PRECTL) NULL)
        {
            ERROR_ASSERT(FALSE, "bInternalPlayEMF: no output rectangle is given\n");

            GdiSetLastError(ERROR_INVALID_PARAMETER);
            return(bRet);
        }

        // Save DC states before we play.

        if (!SaveDC(hdc))
            return(bRet);

        // find the LDC if we have one

        if (pDcAttr != NULL)
        {
            flPlayMetaFile = pDcAttr->ulDirty_ & DC_PLAYMETAFILE;
            if (flPlayMetaFile)
            {
                PUTS("CommonEnumMetaFile: DC_PLAYMETAFILE bit is set!\n");
            }
            pDcAttr->ulDirty_ |= DC_PLAYMETAFILE;
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            return(FALSE);
        }

        //
        // Turn of mirroring if any.
        //
        dwLayout = SetLayout(hdc, 0);

        // The metafile is to be played in the advanced graphics mode only.

        if (!SetGraphicsMode(hdc, GM_ADVANCED))
            goto bInternalPlayEMF_cleanup;

        // Combine the initial destination clipping region into the meta region
        // (hrgnMeta) and reset the destination clipping region before we play.
        // The meta region defines the clipping areas for the metafile picture
        // and is different from those defined in the metafile.
        // The clip region is reset to default in SetMetaRgn.

        if (SetMetaRgn(hdc) == RGN_ERROR)
            goto bInternalPlayEMF_cleanup;

        // Reset DC (without Restore).

        if (!bMetaResetDC(hdc))
            goto bInternalPlayEMF_cleanup;
        // if it use to be mirrored then change the Arc direction default.
        if ((dwLayout != GDI_ERROR) && (dwLayout & LAYOUT_RTL))
            SetArcDirection(hdc, AD_CLOCKWISE);

        // Transform setup.
        //
        // To display the metafile picture in the given output rectangle, we need
        // to scale the picture frame of the metafile to the output rectangle.
        //
        //        picture frame              output rectangle
        //
        //   (a,b)                        (e,f)
        //        +-------+                    +--------------+
        //        | ***** |                    |              |
        //        |   *   |                    |  **********  |
        //        |   *   |                    |      *       |
        //        |   *   |                    |      *       |
        //        +-------+                    |      *       |
        //                (c,d)                |      *       |
        //                                     |      *       |
        //                                     |      *       |
        //                                     |              |
        //                                     +--------------+
        //                                                     (g,h)
        //
        // The base playback transform (M) can be computed as follows:
        //
        //    M = S     . T       .S     . T     . W .P
        //         (m,n)   (-a,-b)  (u,v)   (e,f)   p  p
        //
        //    where
        //
        //      S        scales the metafile picture from source device units to
        //       (m,n)   the picture frame units (.01 mm).
        //
        //      T        translates the picture frame to the origin.
        //       (-a,-b)
        //
        //      S        scales the metafile picture extents to that of the logical
        //       (u,v)   output rectangle where
        //                   u = (g - e) / (c - a), and
        //                   v = (h - f) / (d - b).
        //
        //      T        translates the scaled picture to the logical output
        //       (e,f)   rectangle origin.
        //
        //      W .P     is the world and page transforms of the destination DC that
        //       p  p    determine the final placement and shape of the picture in
        //               in device space.  We assume the combined world and page
        //               transform is given by the XFORM {w x y z s t}.
        //
        // M can be reduced as follows:
        //
        //          [m  0  0]  [ 1  0  0]  [u  0  0]  [1  0  0]  [w  x  0]
        //      M = [0  n  0]. [ 0  1  0]. [0  v  0]. [0  1  0]. [y  z  0]
        //          [0  0  1]  [-a -b  1]  [0  0  1]  [e  f  1]  [s  t  1]
        //
        //          [muw                   mux                   0]
        //        = [nvy                   nvz                   0]
        //          [(-au+e)w+(-bv+f)y+s   (-au+e)x+(-bv+f)z+t   1]
        //

        FLOAT u, v, mu, nv, aue, bvf;
        XFORM xform;
        POINT ptOrg;

        // Verify that the picture frame is valid.

        if (pmrmf->rclFrame.right  < pmrmf->rclFrame.left
         || pmrmf->rclFrame.bottom < pmrmf->rclFrame.top)
        {
            ERROR_ASSERT(FALSE, "bInternalPlayEMF: Picture frame is null\n");
            GdiSetLastError(ERROR_INVALID_DATA);
            goto bInternalPlayEMF_cleanup;
        }

        if (pmrmf->nSize >= META_HDR_SIZE_VERSION_2 &&
            pmrmf->bOpenGL)
        {
            PBYTE pb = (PBYTE) pmf->emfc.ObtainPtr(0, pmrmf->nBytes);

            if(pb)
            {
                // WINBUG 365038 4-10-2001 pravins Investigate GlmfInitPlayback usage
                // Do we have to send the whole metafile to opengl init?
                bGlmf = GlmfInitPlayback(hdc, (PENHMETAHEADER) pb, (LPRECTL)prcl);

                pmf->emfc.ReleasePtr(pb);

            }

            if(!bGlmf) goto bInternalPlayEMF_cleanup;

        }

        // prcl is incl-incl.

        if (pmrmf->rclFrame.right == pmrmf->rclFrame.left)
            u = (FLOAT) (prcl->right - prcl->left + 1);  // handle special case
        else
            u = (FLOAT) (prcl->right - prcl->left) /
                (FLOAT) (pmrmf->rclFrame.right - pmrmf->rclFrame.left);

        if (pmrmf->rclFrame.bottom == pmrmf->rclFrame.top)
            v = (FLOAT) (prcl->bottom - prcl->top + 1);  // handle special case
        else
            v = (FLOAT) (prcl->bottom - prcl->top) /
                (FLOAT) (pmrmf->rclFrame.bottom - pmrmf->rclFrame.top);

        mu  = (FLOAT) 100.0f * (FLOAT) pmrmf->szlMillimeters.cx /
              (FLOAT) pmrmf->szlDevice.cx * u;
        nv  = (FLOAT) 100.0f * (FLOAT) pmrmf->szlMillimeters.cy /
              (FLOAT) pmrmf->szlDevice.cy * v;

        aue = (FLOAT) prcl->left - (FLOAT) pmrmf->rclFrame.left * u;
        bvf = (FLOAT) prcl->top  - (FLOAT) pmrmf->rclFrame.top  * v;

        if (!GetTransform(hdc, XFORM_WORLD_TO_DEVICE, &xform))
            goto bInternalPlayEMF_cleanup;

        pmf->xformBase.eM11  = mu * xform.eM11;
        pmf->xformBase.eM12  = mu * xform.eM12;
        pmf->xformBase.eM21  = nv * xform.eM21;
        pmf->xformBase.eM22  = nv * xform.eM22;
        pmf->xformBase.eDx   = aue * xform.eM11 + bvf * xform.eM21 + xform.eDx;
        pmf->xformBase.eDy   = aue * xform.eM12 + bvf * xform.eM22 + xform.eDy;

        // Reset mapmode to MM_TEXT.

        if (GetMapMode(hdc) != MM_TEXT)
            if (!SetMapMode(hdc, MM_TEXT))
                goto bInternalPlayEMF_cleanup;

        // Reset window origin.

        if (!GetWindowOrgEx(hdc, &ptOrg))
            goto bInternalPlayEMF_cleanup;

        if (ptOrg.x != 0 || ptOrg.y != 0)
            if (!SetWindowOrgEx(hdc, 0, 0, (LPPOINT) NULL))
                goto bInternalPlayEMF_cleanup;

        // Reset viewport origin.

        if (!GetViewportOrgEx(hdc, &ptOrg))
            goto bInternalPlayEMF_cleanup;
        if (ptOrg.x != 0 || ptOrg.y != 0)
            if (!SetViewportOrgEx(hdc, 0, 0, (LPPOINT) NULL))
                goto bInternalPlayEMF_cleanup;

        // Finally, set the world transform.  Before we set it, check for
        // identity transform since rounding errors can distort the result.

        if (xform.eM12 == 0.0f && xform.eM21 == 0.0f
         && pmf->xformBase.eM12 == 0.0f   && pmf->xformBase.eM21 == 0.0f
         && pmf->xformBase.eM11 >= 0.999f && pmf->xformBase.eM11 <= 1.001f
         && pmf->xformBase.eM22 >= 0.999f && pmf->xformBase.eM22 <= 1.001f
           )
        {
            PUTS("bInternalPlayEMF: Base xform is identity\n");

            pmf->xformBase.eM11 = 1.0f;
            pmf->xformBase.eM22 = 1.0f;
        }

        if (!SetWorldTransform(hdc, &pmf->xformBase))
            goto bInternalPlayEMF_cleanup;

        // Now get the clip box for bound test in the source device units.
        // If the clip region is empty, we can skip playing the metafile.
        // Otherwise, we need to compensate for the tranform errors by
        // expanding the clip box.  We will perform clip test only if the
        // DC is a real DC and not a meta DC.

        if (!pldc || (LO_TYPE(hdc) == LO_DC_TYPE))
        {
            int complexity = GetClipBox(hdc, (LPRECT) &pmf->erclClipBox);

            pmf->erclClipBox.vOrder();

            switch (complexity)
            {
            case NULLREGION:
                bRet = TRUE;            // fall through.

            case RGN_ERROR:
                goto bInternalPlayEMF_cleanup;

            default:
                LONG ldx;               // delta to expand x
                LONG ldy;               // delta to expand y
                FLOAT eppmmDstX, eppmmDstY, eppmmSrcX, eppmmSrcY;
                                    // pixels per millimeter for src and dst devices

                // Initialize the clip box for bound test.

                eppmmDstX = (FLOAT) GetDeviceCaps(hdc, DESKTOPHORZRES) /
                            (FLOAT) GetDeviceCaps(hdc, HORZSIZE);
                eppmmDstY = (FLOAT) GetDeviceCaps(hdc, DESKTOPVERTRES) /
                            (FLOAT) GetDeviceCaps(hdc, VERTSIZE);
                eppmmSrcX = (FLOAT) pmrmf->szlDevice.cx /
                            (FLOAT) pmrmf->szlMillimeters.cx;
                eppmmSrcY = (FLOAT) pmrmf->szlDevice.cy /
                            (FLOAT) pmrmf->szlMillimeters.cy;

                ldx = eppmmDstX >= eppmmSrcX
                        ? 1
                        : (LONG) (eppmmSrcX / eppmmDstX) + 1;

                ldy = eppmmDstY >= eppmmSrcY
                        ? 1
                        : (LONG) (eppmmSrcY / eppmmDstY) + 1;

                pmf->erclClipBox.left   -= ldx;
                pmf->erclClipBox.right  += ldx;
                pmf->erclClipBox.top    -= ldy;
                pmf->erclClipBox.bottom += ldy;
                break;
            }
        }

        // Setup source resolution in the transform DC.

        if (!SetVirtualResolution(pmf->hdcXform,
                                  (int) pmrmf->szlDevice.cx,
                                  (int) pmrmf->szlDevice.cy,
                                  (int) pmrmf->szlMillimeters.cx,
                                  (int) pmrmf->szlMillimeters.cy))
            goto bInternalPlayEMF_cleanup;

        if (pmrmf->nSize >=
           META_HDR_SIZE_VERSION_3 + pmrmf->nDescription * sizeof(WCHAR))
        {
           if (pmrmf->szlMicrometers.cx && pmrmf->szlMicrometers.cy)
           {
              if (!SetSizeDevice(pmf->hdcXform,
                            (DWORD) pmrmf->szlMicrometers.cx,
                            (DWORD) pmrmf->szlMicrometers.cy))
              goto bInternalPlayEMF_cleanup;
           }
        }

        // Initialize the transform in the transform DC.
        // If we use ResetDC for initialization, we need to make sure that the
        // source resolution is not changed!

        if (!SetMapMode(pmf->hdcXform, MM_TEXT)
         || !ModifyWorldTransform(pmf->hdcXform, (LPXFORM) NULL, MWT_IDENTITY)
         || !SetWindowOrgEx(pmf->hdcXform, 0, 0, (LPPOINT) NULL)
         || !SetViewportOrgEx(pmf->hdcXform, 0, 0, (LPPOINT) NULL))
            goto bInternalPlayEMF_cleanup;

        //
        // Restore the layout back.
        //
        if (dwLayout != GDI_ERROR) {
            SetLayout(hdc, dwLayout);
            dwLayout = GDI_ERROR;
        }
    } // if (hdc != (HDC) 0)

// Assume success.

    bRet = TRUE;
    bBailout = FALSE;

    pldc = pldcGet(hdc);

    #if 0
    // EngQueryEMFInfo support junk ... we are dropping support for this entry point

    if (pldc && pldc->pUMPD && (pldc->pUMPD->dwFlags & UMPDFLAG_METAFILE_DRIVER))
    {
        if (pldc->pUMdhpdev)
        {
            ((UMDHPDEV *)(pldc->pUMdhpdev))->pvEMF = (PBYTE)pmf;
        }
    }
    #endif

// Play the records until we encounter the EMR_EOF record.
// We will do the EMR_EOF record after restoring unbalanced DC states.

    iPos = 0;
     
    while(1)
    {
        pemr = pmf->emfc.ObtainRecordPtr(iPos);

        if(!pemr)
        {
            WARNING("bInternalPlayEMF: unable to get emf record\n");
            bRet = FALSE;
            bBailout = TRUE;
            goto bInternalPlayEMF_cleanup;
        }

        if(pemr->iType == EMR_EOF)
            break;

        if( (hdc != 0) && !(pDcAttr->ulDirty_ & DC_PLAYMETAFILE) )
        {
            WARNING("bInternalPlayEMF: CancelDC called\n");
            bRet = FALSE;
            bBailout = TRUE;
            goto bInternalPlayEMF_cleanup;
        }

        // If we're beginning or ending a block of GLS records then we
        // need to notify the OpenGL metafile support
        if (pemr->iType == EMR_GLSRECORD ||
            pemr->iType == EMR_GLSBOUNDEDRECORD)
        {
            if (!bInGlsBlock)
            {
                if (!GlmfBeginGlsBlock(hdc))
                {
                    WARNING("GlmfBeginGlsBlock failed\n");
                    bRet = FALSE;
                }

                bInGlsBlock = TRUE;
            }
        }
        else
        {
            if (bInGlsBlock)
            {
                if (!GlmfEndGlsBlock(hdc))
                {
                    WARNING("GlmfEndGlsBlock failed\n");
                    bRet = FALSE;
                }

                bInGlsBlock = FALSE;
            }
        }

        if (pfn == (ENHMFENUMPROC) NULL)
        {
            // PlayEnhMetaFile
            // If we encountered an error, we will continue playing but
            // return an error.

#if 0
// EngQueryEMFInfo junk
            if (pldc && pldc->pUMPD && (pldc->pUMPD->dwFlags & UMPDFLAG_METAFILE_DRIVER))
            {
                if (pldc->pUMdhpdev)
                {
                    ((UMDHPDEV *)(pldc->pUMdhpdev))->pvCurrentRecord = (PBYTE)pemr;
                }
            }
#endif

            if (!PlayEnhMetaFileRecord
                (
                    hdc,
                    (LPHANDLETABLE) pmf->pht,
                    pemr,
                    (UINT) pmrmf->nHandles
                )
               )
            {
                PUTSX("PlayEnhMetaFileRecord failed: pRecord: 0x%lX\n",
                    (PBYTE) pemr);
                ERROR_ASSERT(FALSE, "\n");
                bRet = FALSE;
            }
        }
        else
        {
            // EnumEnhMetaFile

            if (!(*pfn)
                (
                    hdc,
                    (LPHANDLETABLE) pmf->pht,
                    pemr,
                    (int) pmrmf->nHandles,
                    (LPARAM)pv
                )
               )
            {
                ERROR_ASSERT(FALSE, "EnumProc failed");
                bRet = FALSE;
                bBailout = TRUE;
                goto bInternalPlayEMF_cleanup;
            }
        }

        // If the metafile is corrupt with a record of size 0, we would loop forever
        // negitive or zero size will be treated as an error

        if (pemr->nSize > 0)
        {
            iPos += pemr->nSize;
        }
        else
        {
            WARNING("bInternalPlayEMF failed on a record with zero/negitive size\n");
            bRet = FALSE;
            bBailout = TRUE;
            goto bInternalPlayEMF_cleanup;
        }

        if (iPos >= pmrmf->nBytes)
        {
            VERIFYGDI(FALSE, "bInternalPlayEMF: No EOF found\n");
            bRet = FALSE;
            bBailout = TRUE;
            goto bInternalPlayEMF_cleanup;
        }

        pmf->emfc.ReleaseRecordPtr(pemr);

    }

    // Cleanup and return.

bInternalPlayEMF_cleanup:

    //
    // Restore the layout back.
    //
    if (dwLayout != GDI_ERROR) {
        SetLayout(hdc, dwLayout);
    }

    // Restore any remaining metafile saved states if necessary.

    if (pmf->cLevel > 1)
    {
        EMRRESTOREDC emrrdc;

        WARNING("bInternalPlayEMF: fixing up unbalanced Save/Restore DCs\n");

        emrrdc.emr.iType = EMR_RESTOREDC;
        emrrdc.emr.nSize = sizeof(EMRRESTOREDC);
        emrrdc.iRelative = 1 - pmf->cLevel;

        // If the app bails out, we still need to restore our states.

            if (pfn == (ENHMFENUMPROC) NULL || bBailout)
        {
                if (!PlayEnhMetaFileRecord(hdc, (LPHANDLETABLE) pmf->pht,
            (CONST ENHMETARECORD *) &emrrdc, (UINT) pmrmf->nHandles))
            bRet = FALSE;
        }
            else
        {
                if (!(*pfn)(hdc, (LPHANDLETABLE) pmf->pht,
            (CONST ENHMETARECORD *) &emrrdc, (int) pmrmf->nHandles,
            (LPARAM)pv))
            bRet = FALSE;
        }
    }

    // Play the EMR_EOF record if the app did not bail out.
    // We play it here to better identify the end of the picture.

    if (!bBailout)
    {
        ASSERTGDI(pemr->iType == EMR_EOF, "bInternalPlayEMF: Bad EMR_EOF record");

        if (pfn != (ENHMFENUMPROC) NULL)
        {
            if (!(*pfn)(hdc, (LPHANDLETABLE) pmf->pht,
                (CONST ENHMETARECORD *) pemr,
                (int) pmrmf->nHandles, (LPARAM)pv))
            {
                bRet = FALSE;
            }
        }

        if (pfn == (ENHMFENUMPROC) NULL || pmf->bBeginGroup)
        {
            // If the enum callback function did not call us on EMR_EOF but
            // called us on EMR_HEADER, we will emit the comment record anyway.

            VERIFYGDI(pfn == (ENHMFENUMPROC) NULL,
            "bInternalPlayEMF: fixing up public group comments\n");

            if (!PlayEnhMetaFileRecord(hdc, (LPHANDLETABLE) pmf->pht,
                (CONST ENHMETARECORD *) pemr, (UINT) pmrmf->nHandles))
            {
                bRet = FALSE;
            }
        }
    }

    // Clean up GL state
    if (bGlmf &&
        !GlmfEndPlayback(hdc))
    {
        ASSERTGDI(FALSE, "GlmfEndPlayback failed");
    }

    // Restore DC states.

    if (hdc != (HDC) 0)
    {
        if (!RestoreDC(hdc, -1))
        {
            ERROR_ASSERT(FALSE, "RestoreDC failed");
        }

        // If PlayEnhMetaFile is called as a result of playback of the multi formats
        // public comment, we have to preserve the DC_PLAYMETAFILE bit.
        // If we hit a CancelDC, then we want to let the caller know.

        ASSERTGDI(!(flPlayMetaFile & ~DC_PLAYMETAFILE),
                  "bInternalPlayEMF: bad flPlayMetaFile\n");

        pDcAttr->ulDirty_ &= ~DC_PLAYMETAFILE;
        pDcAttr->ulDirty_ |= flPlayMetaFile;

    }


    // Delete the objects created by play.  The previous restore would have
    // deselected these objects.  The first entry contain the hemf handle.

    for (ii = 1; ii < (ULONG) pmrmf->nHandles; ii++)
        if (pmf->pht->objectHandle[ii])
        {
            PUTS("Deleting an object in bInternalPlayEMF\n");

            if (!DeleteObject(pmf->pht->objectHandle[ii]))
            {
                VERIFYGDI(FALSE, "bInternalPlayEMF: DeleteObject failed\n");
            }

            pmf->pht->objectHandle[ii] = 0;
        }

    if(pemr)
        pmf->emfc.ReleaseRecordPtr(pemr);

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL PlayEnhMetaFileRecord(hDC, lpHandletable, lpEnhMetaRecord, nHandles)
* HDC hDC;
* LPHANDLETABLE lpHandletable;
* CONST ENHMETARECORD *lpMetaRecord;
* UINT nHandles;
*
* The PlayEnhMetaFileRecord function plays a metafile record by executing the GDI
* function call contained within the metafile record.
*
* Parameter      Description
* hDC            Identifies the device context.
* lpHandletable  Points to the object handle table to be used for the metafile
*                playback.
* lpMetaRecord   Points to the metafile record to be played.
* nHandles       Not used
*
* Return Value
* TRUE is returned for success, FALSE for failure.
*
* Comments
* An application typically uses this function in conjunction with the
* EnumEnhMetaFile function to modify and then play a metafile.
*
* The lpHandleTable, nHandles, and lpMetaRecord parameters must be exactly
* those passed to the MetaFunc procedure by EnumEnhMetaFile.
*
* History:
*  Tue Sep 03 11:21:14 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

extern "C" BOOL APIENTRY PlayEnhMetaFileRecord
(
    HDC hdc,
    LPHANDLETABLE pht,
    CONST ENHMETARECORD *pmr,
    UINT cht
)
{
    PUTS("PlayEnhMetaFileRecord\n");

    if (pmr->iType >= EMR_MIN && pmr->iType <= EMR_MAX)
    {
        return
        (
            (((PMR) pmr)->*afnbMRPlay[((PENHMETARECORD)pmr)->iType - 1])
            (
                hdc,
                (PHANDLETABLE) pht,
                cht
            )
        );
    }

// Allow future metafile records to be embedded.
// Since it is impossible to know in advance the requirements for all new
// records, we will make the assumption that most records can be simply
// embedded with little or no modifications.  If a new record cannot be
// embedded by the following code, it should include a special bit in its
// record type and we will ignore it during embedding.  In this case,
// we assume that the record does not have side effects that distort the
// picture in a major way.  If an embeddable record contains a bounds,
// we need to transform the bounds to the new device coords.
// I estimate the following code to embed 80% of the new records correctly.
//
// NOTE: The future designer should take into account the compatibility
// issue when adding new record types.
//
// Note that although the code is here, it is not a requirement for
// the future metafiles if you think it is insane.  Just add EMR_NOEMBED
// to the metafile types and it will ignore the new records.
// For true compatibility support, see GdiComment for multiple formats.

    ERROR_ASSERT(FALSE, "PlayEnhMetaFileRecord: unknown record");

    if (pmr->iType & EMR_NOEMBED)
        return(TRUE);

// If we are not embedding, we are done with this record.

    PLDC pldc;

    DC_PLDC(hdc,pldc,FALSE);

    if (pldc->iType != LO_METADC)
        return(TRUE);

// Embed this new record.

    PMDC  pmdc = (PMDC)pldc->pvPMDC;
    PMR   pmrNew;

    PUTS("PlayEnhMetaFileRecord: embedding new record\n");

    if (!(pmrNew = (PMR) pmdc->pvNewRecord((pmr->nSize + 3) & ~3)))
        return(FALSE);

    // Init the record header.

    pmrNew->vInit(pmr->iType);

    // Copy the body.

    RtlCopyMemory
        (
        (PBYTE) ((PENHMETARECORD) pmrNew)->dParm,
        (PBYTE) pmr->dParm,
        pmr->nSize - sizeof(EMR)
        );

    // Update record with bounds.

    if (pmr->iType & EMR_ACCUMBOUNDS)
    {
        if (!((PERECTL) &((PENHMETABOUNDRECORD) pmrNew)->rclBounds)->bEmpty())
        {
            PMF    pmf;
            XFORM  xform;
            POINTL aptlOld[4], aptlNew[4];

            // Get metafile.

            if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
                return(FALSE);

            // Convert from old device coords to new device coords.

            xform = pmf->xformBase;

            aptlOld[0].x = ((PENHMETABOUNDRECORD) pmrNew)->rclBounds.left;
            aptlOld[0].y = ((PENHMETABOUNDRECORD) pmrNew)->rclBounds.top;
            aptlOld[1].x = ((PENHMETABOUNDRECORD) pmrNew)->rclBounds.right;
            aptlOld[1].y = ((PENHMETABOUNDRECORD) pmrNew)->rclBounds.top;
            aptlOld[2].x = ((PENHMETABOUNDRECORD) pmrNew)->rclBounds.right;
            aptlOld[2].y = ((PENHMETABOUNDRECORD) pmrNew)->rclBounds.bottom;
            aptlOld[3].x = ((PENHMETABOUNDRECORD) pmrNew)->rclBounds.left;
            aptlOld[3].y = ((PENHMETABOUNDRECORD) pmrNew)->rclBounds.bottom;

            for (int i = 0; i < 4; i++)
            {
            aptlNew[i].x = (LONG) ((FLOAT) aptlOld[i].x * xform.eM11
                         + (FLOAT) aptlOld[i].y * xform.eM21
                         + xform.eDx + 0.5f);
            aptlNew[i].y = (LONG) ((FLOAT) aptlOld[i].x * xform.eM12
                         + (FLOAT) aptlOld[i].y * xform.eM22
                         + xform.eDy + 0.5f);
            }

            // Update the device bounds.

            ((PENHMETABOUNDRECORD) pmrNew)->rclBounds.left
            = MIN4(aptlNew[0].x,aptlNew[1].x,aptlNew[2].x,aptlNew[3].x);
            ((PENHMETABOUNDRECORD) pmrNew)->rclBounds.right
            = MAX4(aptlNew[0].x,aptlNew[1].x,aptlNew[2].x,aptlNew[3].x);
            ((PENHMETABOUNDRECORD) pmrNew)->rclBounds.top
            = MIN4(aptlNew[0].y,aptlNew[1].y,aptlNew[2].y,aptlNew[3].y);
            ((PENHMETABOUNDRECORD) pmrNew)->rclBounds.bottom
            = MAX4(aptlNew[0].y,aptlNew[1].y,aptlNew[2].y,aptlNew[3].y);

            // Accumulate the new bounds.

            (void) SetBoundsRectAlt(hdc,
            (LPRECT) &((PENHMETABOUNDRECORD) pmrNew)->rclBounds,
            (UINT) (DCB_WINDOWMGR | DCB_ACCUMULATE));
        }
    }

    pmrNew->vCommit(pmdc);      // commit the record
    return(TRUE);
}

/******************************Public*Routine******************************\
* UINT APIENTRY GetEnhMetaFileBits(
*          HENHMETAFILE hemf,
*          UINT nSize,
*         LPBYTE lpData )
*
* The GetEnhMetaFileBits function returns the specified metafile as a block of
* data. The retrieved data must not be modified and is only usable by
* SetEnhMetaFileBits.
*
* Parameter  Description
* hemf       Identifies the metafile.
* nSize      Specifies the size of the buffer reserved for the data. Only this
*            many bytes will be written.
* lpData     Points to the buffer to receive the metafile data. If this
*            pointer is NULL, the function returns the size necessary to hold
*            the data.
*
* Return Value
* The return value is the size of the metafile data in bytes. If an error
* occurs, 0 is returned.
*
* Comments
* The handle used as the hemf parameter does NOT become invalid when the
* GetEnhMetaFileBits function returns.
*
* History:
*  Tue Sep 03 11:21:14 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

extern "C" UINT APIENTRY GetEnhMetaFileBits(
         HENHMETAFILE hEMF,
         UINT nSize,
        LPBYTE lpData )
{
    PMF    pmf;

    PUTS("GetEnhMetaFileBits\n");

// Validate the metafile handle.

    if (!(pmf = GET_PMF(hEMF)))
        return(0);

    PENHMETAHEADER pmrmf = pmf->emfc.GetEMFHeader();

    if(!pmrmf)
        return(0);

// If lpData is NULL, return the size necessary to hold the data.

    if (!lpData)
        return(pmrmf->nBytes);

// Make sure the input buffer is large enough.

    if (nSize < pmrmf->nBytes)
    {
    GdiSetLastError(ERROR_INSUFFICIENT_BUFFER);
        return(0);
    }

// Copy the bits.

    PBYTE pb = (PBYTE) pmf->emfc.ObtainPtr(0, pmrmf->nBytes);

    if(!pb)
        return(0);

    RtlCopyMemory(lpData, pb, pmrmf->nBytes);

    pmf->emfc.ReleasePtr(pb);

// Return the number of bytes copied.

    return(pmrmf->nBytes);
}


/******************************Public*Routine******************************\
* UINT APIENTRY GetWinMetaFileBits(
*          HENHMETAFILE hemf,
*          UINT nSize,
*         LPBYTE lpData
*         INT iMapMode,
*         HDC hdcRef)
*
* The GetWinMetaFileBits function returns the metafile records of the
* specified enhanced metafile  in the Windows 3.0 format and copies
* them into the buffer specified.
*
* Parameter  Description
* hemf       Identifies the metafile.
* nSize      Specifies the size of the buffer reserved for the data. Only this
*            many bytes will be written.
* lpData     Points to the buffer to receive the metafile data. If this
*            pointer is NULL, the function returns the size necessary to hold
*            the data.
* iMapMode   the desired mapping mode of the metafile contents to be returned
* hdcRef     defines the units of the metafile to be returned
*
* Return Value
* The return value is the size of the metafile data in bytes. If an error
* occurs, 0 is returned.
*
* Comments
* The handle used as the hemf parameter does NOT become invalid when the
* GetWinMetaFileBits function returns.
*
* History:
*  Thu Apr  8 14:22:23 1993     -by-    Hock San Lee    [hockl]
* Rewrote it.
*  02-Jan-1992     -by-    John Colleran    [johnc]
* Wrote it.
\**************************************************************************/

extern "C" UINT APIENTRY GetWinMetaFileBits
(
HENHMETAFILE hemf,
UINT         cbData16,
LPBYTE       pData16,
INT          iMapMode,
HDC          hdcRef
)
{
    static LPFNCONVERT lpConvertEmfToWmf = (LPFNCONVERT) NULL;
    PENHMETAHEADER pmrmf = NULL;

    PMF   pmf;
    UINT  fConverter = MF3216_INCLUDE_WIN32MF;
    PEMRGDICOMMENT_WINDOWS_METAFILE pemrWinMF;
    UINT  result = 0;

    PUTS("GetWinMetaFileBits\n");

// Validate mapmode.

    if ((iMapMode < MM_MIN) ||
        (iMapMode > MM_MAX) ||
        (LO_TYPE(hemf) != LO_METAFILE_TYPE))
    {
        ERROR_ASSERT(FALSE, "GetWinMetaFileBits: Bad mapmode");
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(0);
    }

// Validate the metafile handle.

    if (!(pmf = GET_PMF(hemf)))
        goto getWinMetaFileBits_exit;

    pmrmf = pmf->emfc.GetEMFHeader();

    if(!pmrmf)
        goto getWinMetaFileBits_exit;

    pmrmf = (PENHMETAHEADER) pmf->emfc.ObtainPtr(0, pmrmf->nBytes);

    if(!pmrmf)
        goto getWinMetaFileBits_exit;

    ASSERTGDI(pmrmf->iType == EMR_HEADER, "GetWinMetaFileBits: invalid data");

#ifndef DO_NOT_USE_EMBEDDED_WINDOWS_METAFILE
// See if the this was originally an old style metafile and if it has
// an encapsulated original

    pemrWinMF = (PEMRGDICOMMENT_WINDOWS_METAFILE)
            ((PBYTE) pmrmf + ((PENHMETAHEADER) pmrmf)->nSize);

    if (((PMRGDICOMMENT) pemrWinMF)->bIsWindowsMetaFile())
    {
    // Make sure that this is what we want and verify checksum

    if (iMapMode != MM_ANISOTROPIC)
    {
        PUTS("GetWinMetaFileBits: Requested and embedded metafile mapmodes mismatch\n");
    }
    else if ((pemrWinMF->nVersion != METAVERSION300 &&
              pemrWinMF->nVersion != METAVERSION100)
          || pemrWinMF->fFlags != 0)
    {
        // In this release, we can only handle the given metafile
        // versions.  If we return a version that we don't recognize,
        // the app will not be able to play that metafile later on!

        VERIFYGDI(FALSE, "GetWinMetaFileBits: Unrecognized Windows metafile\n");
    }
    else if (GetDWordCheckSum((UINT) pmrmf->nBytes, (PDWORD) pmrmf))
    {
        PUTS("GetWinMetaFileBits: Metafile has been modified\n");
    }
    else
    {
        PUTS("GetWinMetaFileBits: Returning embedded Windows metafile\n");

        if (pData16)
        {
            if (cbData16 < pemrWinMF->cbWinMetaFile)
            {
                ERROR_ASSERT(FALSE, "GetWinMetaFileBits: insufficient buffer");
                GdiSetLastError(ERROR_INSUFFICIENT_BUFFER);
                goto getWinMetaFileBits_exit;
            }

            RtlCopyMemory(pData16,
                      (PBYTE) &pemrWinMF[1],
                      pemrWinMF->cbWinMetaFile);
        }

        result = pemrWinMF->cbWinMetaFile;
        goto getWinMetaFileBits_exit;

    }

    // Either the enhanced metafile containing an embedded Windows
    // metafile has been modified or the embedded Windows metafile
    // is not what we want.  Since the original format is Windows
    // format, we will not embed the enhanced metafile in the
    // returned Windows metafile.

    PUTS("GetWinMetaFileBits: Skipping embedded windows metafile\n");

    fConverter &= ~MF3216_INCLUDE_WIN32MF;
    }
#endif // DO_NOT_USE_EMBEDDED_WINDOWS_METAFILE

// Load the MF3216 metafile converter if it has not been loaded for this
// process.  NOTE: the converter is unloaded when the process goes away.

    if (!lpConvertEmfToWmf)
    {
        HANDLE hModule = LoadLibraryW(L"mf3216") ;

        lpConvertEmfToWmf = (LPFNCONVERT) GetProcAddress(hModule, "ConvertEmfToWmf");
        if (!lpConvertEmfToWmf)
        {
            VERIFYGDI(FALSE, "GetWinMetaFileBits: Failed to load mf3216.dll\n");
            goto getWinMetaFileBits_exit;
        }
    }

// Tell the converter to emit the Enhanced metafile as a comment only if
// this metafile is not previously a Windows metafile

    if (fConverter & MF3216_INCLUDE_WIN32MF)
    {
        PUTS("GetWinMetaFileBits: Embedding enhanced metafile\n");
    }
    else
    {
        PUTS("GetWinMetaFileBits: No embedding of enhanced metafile\n");
    }

    result = lpConvertEmfToWmf((PBYTE) pmrmf, cbData16, pData16,
           iMapMode, hdcRef, fConverter);

getWinMetaFileBits_exit:

    if(pmrmf)
        pmf->emfc.ReleasePtr(pmrmf);

    return(result);
}

/******************************Public*Routine******************************\
* HENHMETAFILE APIENTRY SetWinMetaFileBits(
*         UINT nSize,
*         LPBYTE lpData,
*         HDC hdcRef,
*         LPMETAFILEPICT lpMFP
*
* The SetWinMetaFileBits function creates a memory-based enhanced metafile
* from Windows 3.X metafile data.
*
* hEMF       Identifies the metafile.
* nSize      Specifies the size of the buffer
* lpData     Points to the buffer of the Win 3.x metafile data.
* hdcRef     defines the units of the metafile to be returned
* lpMFP      suggested size of metafile
*
* Return Value
* The return value is a handle to the new enhanced metafile if successful.
*
* History:
*  Thu Apr  8 14:22:23 1993     -by-    Hock San Lee    [hockl]
* Rewrote it.
*  02-Jan-1992     -by-    John Colleran    [johnc]
* Wrote it.
\**************************************************************************/

extern "C" HENHMETAFILE APIENTRY SetWinMetaFileBits
(
UINT           nSize,
CONST BYTE    *lpMeta16Data,
HDC            hdcRef,
CONST METAFILEPICT *lpMFP
)
{
    HENHMETAFILE  hemf32 = (HENHMETAFILE) 0;
    HMETAFILE     hmf16  = (HMETAFILE) 0;
    HDC           hdcT   = (HDC) 0;
    RECT          rcFrame;
    LPRECT        lprcFrame = (LPRECT)NULL;
    HDC           hdcEMF;
    INT           iMapMode;
    INT           xExtPels;
    INT           yExtPels;
    PMETA_ESCAPE_ENHANCED_METAFILE pmfeEnhMF;
    BOOL          bEmbedEmf = TRUE;
    PMDC          pmdcEMF;

    PUTS("SetWinMetaFileBits\n");

    if (lpMFP)
    {
        PUTSX("SetWinMetaFileBits: xExt:%lX  ", lpMFP->xExt);
        PUTSX("yExt:%lX\n", lpMFP->yExt);
    }
    else
        PUTS("SetWinMetaFileBits: lpMFP is NULL\n");

// Verify the input data.

    if (nSize < sizeof(METAHEADER)
     || !IsValidMetaHeader16((PMETAHEADER) lpMeta16Data))
    {
        ERROR_ASSERT(FALSE, "SetWinMetaFileBits: Bad input data\n");
        GdiSetLastError(ERROR_INVALID_DATA);
        return((HENHMETAFILE) 0);
    }

#ifndef DO_NOT_USE_EMBEDDED_ENHANCED_METAFILE
// Check if the windows metafile contains an embedded version of the
// original enhanced metafile.

    pmfeEnhMF = (PMETA_ESCAPE_ENHANCED_METAFILE) &lpMeta16Data[sizeof(METAHEADER)];
    if (IS_META_ESCAPE_ENHANCED_METAFILE(pmfeEnhMF))
    {
        PBYTE   pMetaData32 = (PBYTE) NULL;
        UINT    i;
        UINT    cbMetaData32;

        // We will not do metafile version check here.  It is verified in
        // pmfAllocMF eventually.

        if (pmfeEnhMF->fFlags != 0)
        {
            VERIFYGDI(FALSE, "SetWinMetaFileBits: Unrecognized Windows metafile\n");
            goto SWMFB_UseConverter;
        }

        // Validate checksum

        if (GetWordCheckSum(nSize, (PWORD) lpMeta16Data))
        {
            PUTS("SetWinMetaFileBits: Metafile has been modified\n");
            goto SWMFB_UseConverter;
        }

        // Unpack the data from the small chunks of metafile comment records
        // Windows 3.0 chokes on Comment Record > 8K?
        // We probably could probably just error out if out of memory but
        // lets try to convert just because the embedded comment might be bad.

        PUTS("SetWinMetaFileBits: Using embedded enhanced metafile\n");

        cbMetaData32 = (UINT) pmfeEnhMF->cbEnhMetaFile;
        if (!(pMetaData32 = (PBYTE) LocalAlloc(LMEM_FIXED, cbMetaData32)))
        {
            VERIFYGDI(FALSE, "SetWinMetaFileBits: LocalAlloc Failed");
            goto SWMFB_UseConverter;
        }

        i = 0;
        do
        {
            if (i + pmfeEnhMF->cbCurrent > cbMetaData32)
            {
                VERIFYGDI(FALSE, "SetWinMetaFileBits: Bad metafile comment");
                goto SWMFB_UseConverter;
            }

            RtlCopyMemory(&pMetaData32[i], (PBYTE) &pmfeEnhMF[1], pmfeEnhMF->cbCurrent);
            i += (UINT) pmfeEnhMF->cbCurrent;
            pmfeEnhMF = (PMETA_ESCAPE_ENHANCED_METAFILE)
                ((PWORD) pmfeEnhMF + pmfeEnhMF->rdSize);
        } while (IS_META_ESCAPE_ENHANCED_METAFILE(pmfeEnhMF));

        if (i != cbMetaData32)
        {
            VERIFYGDI(FALSE, "SetWinMetaFileBits: Insufficient metafile data");
            goto SWMFB_UseConverter;
        }

        // Set the memory directly into the enhanced metafile and return the
        // metafile.

        if (hemf32 = SetEnhMetaFileBitsAlt((HLOCAL) pMetaData32, NULL, NULL, 0))
            goto SWMFB_exit;

        VERIFYGDI(FALSE, "SetWinMetaFileBits: SetEnhMetaFileBitsAlt failed\n");

SWMFB_UseConverter:
        if (pMetaData32)
        {
            if (LocalFree((HANDLE) pMetaData32))
            {
                ASSERTGDI(FALSE, "SetWinMetaFileBits: LocalFree Failed");
            }
        }

        // The Windows metafile containing an embedded enhanced metafile has
        // been modified.  Since the original format is enhanced format, we
        // will not embed the Windows metafile in the returned enhanced
        // metafile.

        bEmbedEmf = FALSE;
    }
#endif // DO_NOT_USE_EMBEDDED_ENHANCED_METAFILE

// Create the 16 bit metafile

    if (!(hmf16 = SetMetaFileBitsEx(nSize, lpMeta16Data)))
    {
        ERROR_ASSERT(FALSE, "SetWinMetaFileBits: SetMetaFileBitsEx Failed");
        goto SWMFB_exit;
    }

// If no hdcRef is given, use the default display as reference.

    if (!hdcRef)
    {
        if (!(hdcRef = hdcT = CreateICA((LPCSTR) "DISPLAY", (LPCSTR) NULL,
                        (LPCSTR) NULL, (LPDEVMODEA) NULL)))
        {
            ERROR_ASSERT(FALSE, "SetWinMetaFileBits: CreateICA Failed");
            goto SWMFB_exit;
        }
    }

// Get the frame rect in .01mm units and extents in pel units.
// For fixed mapmodes, the extents are unnecessary.

    if (lpMFP)
    {
        iMapMode = lpMFP->mm ? (INT) lpMFP->mm : MM_ANISOTROPIC;  // zero used
        switch (iMapMode)
        {
        case MM_ISOTROPIC:
        case MM_ANISOTROPIC:
            // If the extents are negative, use the default device extents.

            if (lpMFP->xExt > 0 && lpMFP->yExt > 0)
            {
                // Convert the MetaFilePict suggested size HI-Metric into PELs

                xExtPels = MulDiv((int) lpMFP->xExt,
                          GetDeviceCaps(hdcRef, DESKTOPHORZRES),
                          GetDeviceCaps(hdcRef, HORZSIZE) * 100);
                yExtPels = MulDiv((int) lpMFP->yExt,
                          GetDeviceCaps(hdcRef, DESKTOPVERTRES),
                          GetDeviceCaps(hdcRef, VERTSIZE) * 100);
                rcFrame.left   = 0;
                rcFrame.top    = 0;
                rcFrame.right  = lpMFP->xExt;
                rcFrame.bottom = lpMFP->yExt;
                lprcFrame      = &rcFrame;
                break;
            }

            PUTS("SetWinMetaFileBits: negative extents in lpMFP\n");

            // fall through

        case MM_TEXT:
        case MM_LOMETRIC:
        case MM_HIMETRIC:
        case MM_LOENGLISH:
        case MM_HIENGLISH:
        case MM_TWIPS:
            xExtPels = GetDeviceCaps(hdcRef, DESKTOPHORZRES);
            yExtPels = GetDeviceCaps(hdcRef, DESKTOPVERTRES);
            break;

        default:
            VERIFYGDI(FALSE, "SetWinMetaFileBits: Bad mapmode in METAFILEPICT\n");
            goto SWMFB_exit;
        }
    }
    else
    {
    // If the METAFILEPICT is not given, use the MM_ANISOTROPIC mapmode
    // and the default device extents.

        iMapMode = MM_ANISOTROPIC;

        xExtPels = GetDeviceCaps(hdcRef, DESKTOPHORZRES);
        yExtPels = GetDeviceCaps(hdcRef, DESKTOPVERTRES);
    }

    PUTSX("SetWinMetaFileBits: xExtPels:%lX  ", xExtPels);
    PUTSX("yExtPels:%lX\n", yExtPels);

    // Create the new 32 bit metafile DC

    if (!(hdcEMF = CreateEnhMetaFileW(hdcRef, (LPWSTR) NULL, lprcFrame,
            (LPWSTR) NULL)))
        goto SWMFB_exit;

    // We want to preserve the original Metafile as a comment only if this
    // metafile wasn't originally an enhanced metafile as indicated by bEmbedEmf.

    PLDC pldc;
    DC_PLDC(hdcEMF,pldc,0);
    pmdcEMF = (PMDC)pldc->pvPMDC;

#ifndef DO_NOT_EMBED_WINDOWS_METAFILE
    // Embed it only if the mapmode is MM_ANISOTROPIC.

    if (bEmbedEmf && iMapMode == MM_ANISOTROPIC)
    {
        if (!MF_GdiCommentWindowsMetaFile(hdcEMF, nSize, lpMeta16Data))
        {
            HENHMETAFILE  hemfTmp;

            ERROR_ASSERT(FALSE, "SetWinMetaFileBits: GdiComment Failed!");
            if (hemfTmp = CloseEnhMetaFile(hdcEMF))
                DeleteEnhMetaFile(hemfTmp);

            goto SWMFB_exit;
        }

        pmdcEMF->fl |= MDC_CHECKSUM; // tell CloseEnhMetaFile we need a checksum
    }
#endif // DO_NOT_EMBED_WINDOWS_METAFILE

    // Play the 16 bit metafile into the new metafile DC

    if (!SetMapMode(hdcEMF, iMapMode)
     || !SetViewportExtEx(hdcEMF, (int)xExtPels, (int)yExtPels, (LPSIZE) NULL)
     || !SetWindowExtEx  (hdcEMF, (int)xExtPels, (int)yExtPels, (LPSIZE) NULL))
    {
        HENHMETAFILE  hemfTmp;

        ERROR_ASSERT(FALSE, "SetWinMetaFileBits: unable to PlayMetaFile");
        if (hemfTmp = CloseEnhMetaFile(hdcEMF))
            DeleteEnhMetaFile(hemfTmp);

        goto SWMFB_exit;
    }

    // Ignore the return value from PlayMetaFile because some existing metafiles
    // contains errors (e.g. DeleteObject for a handle that is selected) although
    // they are not fatal.

    (void) PlayMetaFile(hdcEMF, hmf16);

    // Get the 32 bit metafile by closing the 32 bit metafile DC.

    hemf32 = CloseEnhMetaFile(hdcEMF);
    VERIFYGDI(hemf32, "SetWinMetaFileBits: CloseEnhMetaFile failed\n");

SWMFB_exit:

    if (hdcT)
    {
        if (!DeleteDC(hdcT))
        {
            ASSERTGDI(FALSE, "SetWinMetaFileBits: DeleteDC Failed");
        }
    }

    if (hmf16)
    {
        if (!DeleteMetaFile(hmf16))
        {
            ASSERTGDI(FALSE, "SetWinMetaFileBits: DeleteMetaFile failed");
        }
    }

    ERROR_ASSERT(hemf32, "SetWinMetaFileBits failed");
    return(hemf32);
}

/******************************Public*Routine******************************\
* GetWordCheckSum(UINT cbData, PWORD pwData)
*
* Adds cbData/2 number of words pointed to by pwData to provide an
* additive checksum.  If the checksum is valid the sum of all the WORDs
* should be zero.
*
\**************************************************************************/

WORD GetWordCheckSum(UINT cbData, PWORD pwData)
{
    WORD   wCheckSum = 0;
    UINT   cwData = cbData / sizeof(WORD);

    ASSERTGDI(!(cbData%sizeof(WORD)), "GetWordCheckSum data not WORD multiple");
    ASSERTGDI(!((ULONG_PTR)pwData%sizeof(WORD)), "GetWordCheckSum data not WORD aligned");

    while (cwData--)
        wCheckSum += *pwData++;

    return(wCheckSum);
}

DWORD GetDWordCheckSum(UINT cbData, PDWORD pdwData)
{
    DWORD   dwCheckSum = 0;
    UINT    cdwData = cbData / sizeof(DWORD);

    ASSERTGDI(!(cbData%sizeof(DWORD)), "GetDWordCheckSum data not DWORD multiple");
    ASSERTGDI(!((ULONG_PTR)pdwData%sizeof(DWORD)), "GetDWordCheckSum data not DWORD aligned");

    while (cdwData--)
        dwCheckSum += *pdwData++;

    return(dwCheckSum);
}

/******************************Public*Routine******************************\
* HENHMETAFILE APIENTRY SetEnhMetaFileBits
* (
* UINT nSize,
* LPBYTE pb
* )
*
* The SetEnhMetaFileBits function creates a memory metafile from the data
* provided.
*
* Parameter  Description
* nSize      Specifies the size, in bytes, of the data provided.
* lpData     Points to a buffer that contains the metafile data. It is assumed
*            that the data was previously created using the GetEnhMetaFileBits
*            function.
*
* Return Value
* The return value identifies a memory metafile if the function is successful.
* Otherwise, the return value is 0.
*
* History:
*  Tue Sep 03 11:21:14 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

extern "C" HENHMETAFILE APIENTRY SetEnhMetaFileBits
(
UINT nSize,
CONST BYTE * pb
)
{
    PMF     pmf;
    HENHMETAFILE hmf;

    PUTS("SetEnhMetaFileBits\n");

// Verify nSize is valid.

    if (nSize < sizeof(META_HDR_SIZE_MIN) ||
        nSize < ((PENHMETAHEADER) pb)->nBytes)
    {
        GdiSetLastError(ERROR_INVALID_DATA);
        return((HENHMETAFILE) 0);
    }

// Allocate and initialize a MF.

    if (!(pmf = pmfAllocMF(0, (PDWORD)pb, (LPWSTR) NULL, NULL, 0, 0)))
        return((HENHMETAFILE) 0);

// Allocate a local handle.

    hmf = hmfCreate(pmf);
    if (hmf == NULL)
    {
        vFreeMF(pmf);
    }

// Return the metafile handle.

    return(hmf);
}

// Similar to SetEnhMetaFileBits except that hMem is set into the metafile
// directly.  It is assumed that hMem is allocated with the LMEM_FIXED option.
// For internal use only.

extern "C" HENHMETAFILE APIENTRY SetEnhMetaFileBitsAlt(HLOCAL hMem, HANDLE hExtra, HANDLE hFile, UINT64 qwFileOffset)
{
    PMF          pmf;
    HENHMETAFILE hmf;

    PUTS("SetEnhMetaFileBitsAlt\n");

// Allocate and initialize a MF.

    if (!(pmf = pmfAllocMF(ALLOCMF_TRANSFER_BUFFER, (PDWORD) hMem, (LPWSTR) NULL, hFile, qwFileOffset, hExtra)))
        return((HENHMETAFILE) 0);

// Allocate a local handle.

    hmf = hmfCreate(pmf);
    if (hmf == NULL)
    {
        // If memory got transferred reset it to not transferred state.
        if(pmf->pvLocalCopy)
        {
            pmf->pvLocalCopy = 0;
        }
        vFreeMF(pmf);
    }

 // Return the metafile handle.

    return(hmf);
}

/******************************Public*Routine******************************\
* UINT GetEnhMetaFilePaletteEntries(hEMF, nNumEntries, lpPaletteEntries)
* HENHMETAFILE hEMF;
* UINT nNumEntries;
* LPPALETTEENTRY lpPaletteEntries;
*
* The GetEnhMetaFilePaletteEntries function retrieves the palette entries
* used in a metafile.  They include non-duplicate colors defined in
* CreatePalette and SetPaletteEntries records in a metafile.  The
* palette entries do not contain any peFlags.
*
* Parameter         Description
* hEMF              Identifies the metafile.
* nNumEntries       Specifies the number of entries in the metafile palette
*                   to be retrieved.
* lpPaletteEntries  Points to an array of PALETTEENTRY structures to receive
*                   the palette entries. The array must contain at least as
*                   many data structures as specified by the nNumEntries
*                   parameter. If this parameter is NULL, the function will
*                   return the number of entries in the metafile palette.
*
* Return Value
* The return value is the number of entries retrieved from the palette.
* If no palette is created in the metafile, 0 is returned.  If an error
* occurs, -1 is returned.
*
* History:
*  Mon Sep 23 17:41:07 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

extern "C" UINT APIENTRY GetEnhMetaFilePaletteEntries
(
    HENHMETAFILE   hemf,
    UINT           nNumEntries,
    LPPALETTEENTRY lpPaletteEntries
)
{
    PMF     pmf = NULL;
    UINT    cEntries = GDI_ERROR;
    PEMREOF pmreof = NULL;
    PENHMETAHEADER pmrmf = NULL;

    PUTS("GetEnhMetaFilePaletteEntries\n");

// Validate the metafile handle.

    if (!(pmf = GET_PMF(hemf)))
        goto GetEnhMetaFilePaletteEntries_exit;

    pmrmf = pmf->emfc.GetEMFHeader();

    if(!pmrmf)
        goto GetEnhMetaFilePaletteEntries_exit;

    pmreof = pmf->emfc.ObtainEOFRecordPtr();

    if(!pmreof)
    {
        cEntries = 0; // We do not have a palette ih the metafile
        goto GetEnhMetaFilePaletteEntries_exit;
    }

// If lpPaletteEntries is NULL, return the number of entries in the metafile
// palette.

    if (!lpPaletteEntries)
    {
        cEntries = pmrmf->nPalEntries;
        goto GetEnhMetaFilePaletteEntries_exit;
    }

// Get the number of entries to copy.

    cEntries = min(nNumEntries,(UINT) pmrmf->nPalEntries);

    ASSERTGDI
    (
        pmrmf->nPalEntries == pmreof->nPalEntries,
        "GetEnhMetaFilePaletteEntries: Bad nPalEntries"
    );

// Copy the palette.

    RtlCopyMemory
    (
        (PBYTE) lpPaletteEntries,
        (PBYTE) pmreof + pmreof->offPalEntries,
        cEntries * sizeof(PALETTEENTRY)
    );

// Return the number of entries copied.

GetEnhMetaFilePaletteEntries_exit:

    if(pmreof)
        pmf->emfc.ReleaseEOFRecordPtr(pmreof);
    
    return(cEntries);
}

/******************************Public*Routine******************************\
* UINT APIENTRY GetEnhMetaFileHeader(
*         HENHMETAFILE hemf,
*         UINT nSize,
*         LPENHMETAHEADER lpEnhMetaHeader );
*
* Returns the metafile header information for hemf.
* If lpEnhMetaHeader is NULL then the size of the header is returned.
*
* This routine supports multiple versions of the metafile header by
* returning the largest version that fits in the buffer
*
* History:
*  16-Oct-1991 1991     -by-    John Colleran    [johnc]
* Wrote it.
\**************************************************************************/

extern "C" UINT APIENTRY GetEnhMetaFileHeader
(
    HENHMETAFILE hemf,
    UINT nSize,
    LPENHMETAHEADER lpEnhMetaHeader
)
{
    PMF    pmf;
    UINT   nCopySize = 0;
    PENHMETAHEADER pmrmf = NULL;

    PUTS("GetEnhMetaFileHeader\n");

// Validate the metafile handle.

    if (!(pmf = GET_PMF(hemf)))
    {
        ERROR_ASSERT(FALSE, "GetEnhMetaFileHeader invalid metafile handle");
        goto GetEnhMetaFileHeader_exit;
    }

    pmrmf = pmf->emfc.GetEMFHeader();

    if(!pmrmf)
        goto GetEnhMetaFileHeader_exit;

// Is this just a size query

    if (lpEnhMetaHeader == (LPENHMETAHEADER) NULL)
    {
        nCopySize = pmrmf->nSize;
        goto GetEnhMetaFileHeader_exit;
    }

// Header request.  The size must be large enough to include some version
// of the header

    if (nSize < META_HDR_SIZE_MIN)
    {
        ERROR_ASSERT(FALSE, "GetEnhMetaFileHeader buffer size too small");
        GdiSetLastError(ERROR_INSUFFICIENT_BUFFER);
        goto GetEnhMetaFileHeader_exit;
    }

    // Figure out which version of the header to copy
    if (nSize < META_HDR_SIZE_VERSION_2 ||
        pmrmf->nSize == META_HDR_SIZE_VERSION_1)
    {
        nCopySize = META_HDR_SIZE_VERSION_1;
    }
    else if (nSize < META_HDR_SIZE_VERSION_3 ||
        pmrmf->nSize == META_HDR_SIZE_VERSION_2)
    {
        nCopySize = META_HDR_SIZE_VERSION_2;
    }
    else
    {
        nCopySize = META_HDR_SIZE_VERSION_3;
    }

// Copy the ENHMETAHEADER and return its size

    RtlCopyMemory(lpEnhMetaHeader, pmrmf, nCopySize);

    // If an application asks for a version two or three header
    // but the metafile only has a version one header,
    // we can still come up with a valid version two or three header
    // by NULLing out the version two or three data
    // This makes it easier to write an application that just
    // does GetEnhMetaFileHeader with sizeof(ENHMETAHEADER)
    // because it will work on both v1 and v2 and v3 metafiles
    // Same applies to app asking for version three header on a metafile
    // with a version two header
    //
    if (nCopySize == META_HDR_SIZE_VERSION_1 &&
         ((nSize == META_HDR_SIZE_VERSION_2) ||
         (nSize == META_HDR_SIZE_VERSION_3)))
    {
        nCopySize = META_HDR_SIZE_VERSION_2;
        lpEnhMetaHeader->cbPixelFormat = 0;
        lpEnhMetaHeader->offPixelFormat = 0;
        lpEnhMetaHeader->bOpenGL = FALSE;
    }

    if (nCopySize == META_HDR_SIZE_VERSION_2 &&
        nSize == META_HDR_SIZE_VERSION_3)
    {
        nCopySize = META_HDR_SIZE_VERSION_3;
        lpEnhMetaHeader->szlMicrometers.cx = 0;
        lpEnhMetaHeader->szlMicrometers.cy = 0;
    }

    lpEnhMetaHeader->nSize = nCopySize;

GetEnhMetaFileHeader_exit:

    return nCopySize;
}

/******************************Public*Routine******************************\
* UINT APIENTRY GetEnhMetaFileDescription(
*        HENHMETAFILE hemf,
*        UINT cchBuffer,
*        LPWSTR lpDescription );
*
*
* Returns: size of buffer in char count if successful
*          0 if no description
*          GDI_ERROR if an error occurs
*
* History:
*  16-Oct-1991 1991     -by-    John Colleran    [johnc]
* Wrote it.
\**************************************************************************/

extern "C" UINT APIENTRY GetEnhMetaFileDescriptionA(
        HENHMETAFILE hemf,
        UINT cchBuffer,
        LPSTR lpDescription )
{
    return(InternalGetEnhMetaFileDescription(hemf, cchBuffer, lpDescription, FALSE));
}

extern "C" UINT APIENTRY GetEnhMetaFileDescriptionW
(
    HENHMETAFILE hemf,
    UINT cchBuffer,
    LPWSTR lpDescription
)
{
    return(InternalGetEnhMetaFileDescription(hemf, cchBuffer, (LPSTR) lpDescription, TRUE));
}

UINT InternalGetEnhMetaFileDescription
(
    HENHMETAFILE  hemf,
    UINT  cchBuffer,
    LPSTR lpDescription,
    BOOL  bUnicode
)
{
    PMF             pmf;
    UINT            cchRet = GDI_ERROR;
    PENHMETAHEADER  pmrmf = NULL;
    LPWSTR          pwstr = NULL;

    PUTS("InternalGetEnhMetaFileDescription\n");

    // Validate the metafile handle.

    if (!(pmf = GET_PMF(hemf)))
    {
        ERROR_ASSERT(FALSE, "InternalGetEnhMetaFileDescription: invalid hemf");
        goto InternalGetEnhMetaFileDescription_exit;
    }

    pmrmf = pmf->emfc.GetEMFHeader();

    if(!pmrmf)
        goto InternalGetEnhMetaFileDescription_exit;

    pwstr = (LPWSTR) pmf->emfc.ObtainPtr(pmrmf->offDescription,
                                pmrmf->nDescription * sizeof(WCHAR));

    if(!pwstr)
        goto InternalGetEnhMetaFileDescription_exit;

    if (lpDescription == (LPSTR) NULL)
    {
        // Return the size if that's all they want.

        if( bUnicode )
        {
            cchRet = pmrmf->nDescription;
        }
        else
        {
            cchRet = 0;

            RtlUnicodeToMultiByteSize((ULONG*)&cchRet, pwstr, 
                                      (UINT)(pmrmf->nDescription)*sizeof(WCHAR));
        }
    }
    else
    {
        // Copy the data
        
        if (bUnicode)
        {
            cchRet = min(cchBuffer, (UINT) pmrmf->nDescription);
    
            RtlCopyMemory
            (
                (PBYTE) lpDescription,
                (PBYTE) pwstr,
                cchRet * sizeof(WCHAR)
            );
        }
        else
        {
            if (pmrmf->nDescription)
            {
                cchRet = WideCharToMultiByte(CP_ACP,
                                             0,
                                             pwstr,
                                             (UINT) pmrmf->nDescription,
                                             lpDescription,
                                             cchBuffer,
                                             NULL,
                                             NULL);
    
                if (cchRet == 0)
                {
                // Unicode to Ansi translation is failed.
    
                    cchRet = (UINT) GDI_ERROR;
                }
            }
            else
            {
            // There is no description.
    
                cchRet = 0;
            }
        }
    }

InternalGetEnhMetaFileDescription_exit:

    if(pwstr)
        pmf->emfc.ReleasePtr(pwstr);

    return(cchRet);
}

/******************************Public*Routine******************************\
*
* GetEnhMetaFilePixelFormat
*
* Retrieves the last pixel format set in the given enhanced metafile
*
* History:
*  Thu Apr 06 15:07:34 1995     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

extern "C" UINT APIENTRY GetEnhMetaFilePixelFormat(HENHMETAFILE hemf,
                                                   UINT cbBuffer,
                                                   PIXELFORMATDESCRIPTOR *ppfd)
{
    PMF             pmf;
    UINT            cbRet = GDI_ERROR;
    PENHMETAHEADER  pmrmf = NULL;
    PBYTE           pb = NULL;

    PUTS("GetEnhMetaFilePixelFormat\n");

    // Validate the metafile handle.
    if (!(pmf = GET_PMF(hemf)))
    {
        ERROR_ASSERT(FALSE, "GetEnhMetaFilePixelFormat: invalid hemf");
        GdiSetLastError(ERROR_INVALID_HANDLE);
        goto GetEnhMetaFilePixelFormat_exit;
    }

    pmrmf = pmf->emfc.GetEMFHeader();

    if(!pmrmf)
        goto GetEnhMetaFilePixelFormat_exit;

    // Ensure that this metafile is a version which supports the
    // pixel format information
    if (pmrmf->nSize < META_HDR_SIZE_VERSION_2)
    {
        ERROR_ASSERT(FALSE, "GetEnhMetaFilePixelFormat: invalid hdr version");
        GdiSetLastError(ERROR_INVALID_HANDLE);
        goto GetEnhMetaFilePixelFormat_exit;
    }

    pb = (PBYTE) pmf->emfc.ObtainPtr(pmrmf->offPixelFormat, pmrmf->cbPixelFormat);

    if(!pb)
    {
        goto GetEnhMetaFilePixelFormat_exit;
    }

    cbRet = pmrmf->cbPixelFormat;

    // Copy the data if a buffer is provided and is large enough and
    // there is data to copy
    if (cbRet > 0 && ppfd != NULL && cbBuffer >= cbRet)
    {
        ASSERTGDI(pmrmf->offPixelFormat != 0,
                  "cbPixelFormat set but not offPixelFormat\n");

        RtlCopyMemory((PBYTE)ppfd, pb, cbRet);
    }

GetEnhMetaFilePixelFormat_exit:
    
    if(pb)
        pmf->emfc.ReleasePtr(pb);

    return cbRet;
}

/******************************Public*Routine******************************\
* BOOL APIENTRY GdiComment( HDC hDC, UINT nSize, LPBYTE lpData )
*
* Records a Comment record in a metafile if hDC is a metafile DC otherwise
* it is a no-op
*
*
* Returns: TRUE if succesful otherwise false
*
* History:
*  16-Oct-1991 1991     -by-    John Colleran    [johnc]
* Wrote it.
\**************************************************************************/

extern "C" BOOL APIENTRY GdiComment( HDC hdc, UINT nSize, CONST BYTE *lpData )
{
    BOOL bRet = TRUE;

    PUTS("GdiComment\n");

    if (LO_TYPE(hdc) == LO_ALTDC_TYPE)
    {
        PLDC pldc;
        DC_PLDC(hdc,pldc,FALSE);

        if (pldc->iType == LO_METADC)
            bRet = MF_GdiComment(hdc, nSize, lpData);
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\mf16.h ===
/******************************Module*Header*******************************\
* Module Name: mf16.h                                                      *
*									   
* Definitions needed for 3.x Metafile functions                            *
*									   
* Created: 01-Jul-1991                                                     *
* Author: John Colleran (johnc)                                            *
*									   
* Copyright (c) 1991-1999 Microsoft Corporation				   
\**************************************************************************/

// Windows 3.x structures

#pragma pack(2)

#define SIZEOF_METARECORDHEADER (sizeof(DWORD)+sizeof(WORD))

typedef struct _RECT16 {
    SHORT   left;
    SHORT   top;
    SHORT   right;
    SHORT   bottom;
} RECT16;
typedef RECT16 UNALIGNED *PRECT16;

typedef struct _BITMAP16 {
    SHORT   bmType;
    SHORT   bmWidth;
    SHORT   bmHeight;
    SHORT   bmWidthBytes;
    BYTE    bmPlanes;
    BYTE    bmBitsPixel;
    LPBYTE  bmBits;
} BITMAP16;
typedef BITMAP16 UNALIGNED *PBITMAP16;

typedef struct _LOGBRUSH16 {
    WORD     lbStyle;
    COLORREF lbColor;
    SHORT    lbHatch;
} LOGBRUSH16;
typedef LOGBRUSH16 UNALIGNED *PLOGBRUSH16;

typedef struct tagLOGFONT16
{
    SHORT     lfHeight;
    SHORT     lfWidth;
    SHORT     lfEscapement;
    SHORT     lfOrientation;
    SHORT     lfWeight;
    BYTE      lfItalic;
    BYTE      lfUnderline;
    BYTE      lfStrikeOut;
    BYTE      lfCharSet;
    BYTE      lfOutPrecision;
    BYTE      lfClipPrecision;
    BYTE      lfQuality;
    BYTE      lfPitchAndFamily;
    BYTE      lfFaceName[LF_FACESIZE];
} LOGFONT16;
typedef LOGFONT16 UNALIGNED *PLOGFONT16;

typedef struct _LOGPEN16 {
    WORD     lopnStyle;
    POINTS   lopnWidth;
    COLORREF lopnColor;
} LOGPEN16;
typedef LOGPEN16 UNALIGNED *PLOGPEN16;

#pragma pack()


// Macros for converting 32 bit objects to 16 bit equivalents

#define INT32FROMINT16(lp32, lp16, c)                           \
{                                                               \
    UINT    ii;                                                 \
                                                                \
    for(ii=0; ii<(c); ii++)                                     \
        ((LPINT)(lp32))[ii] = ((PSHORT)(lp16))[ii];             \
}

#define BITMAP32FROMBITMAP16(lpBitmap, lpBitmap16)              \
{                                                               \
    (lpBitmap)->bmType       = (LONG)(lpBitmap16)->bmType;      \
    (lpBitmap)->bmWidth      = (LONG)(lpBitmap16)->bmWidth;     \
    (lpBitmap)->bmHeight     = (LONG)(lpBitmap16)->bmHeight;    \
    (lpBitmap)->bmWidthBytes = (LONG)(lpBitmap16)->bmWidthBytes;\
    (lpBitmap)->bmPlanes     = (WORD)(lpBitmap16)->bmPlanes;    \
    (lpBitmap)->bmBitsPixel  = (WORD)(lpBitmap16)->bmBitsPixel; \
    (lpBitmap)->bmBits       = (lpBitmap16)->bmBits;            \
}

#define LOGBRUSH32FROMLOGBRUSH16(lpLogBrush, lpLogBrush16)      \
{                                                               \
    (lpLogBrush)->lbStyle = (UINT) (lpLogBrush16)->lbStyle;     \
    (lpLogBrush)->lbColor = (lpLogBrush16)->lbColor;            \
    (lpLogBrush)->lbHatch = (LONG)  (lpLogBrush16)->lbHatch;    \
}

#define LOGFONT32FROMLOGFONT16(lpLogFont, lpLogFont16)          \
{                                                               \
    ASSERTGDI((sizeof(LOGFONTA) == (sizeof(LOGFONT16)+sizeof(WORD)*5)), \
            "MF16.h: LOGFONT(32) and LOGFONT(16) changed!");            \
    (lpLogFont)->lfHeight      = (LONG) (lpLogFont16)->lfHeight;           \
    (lpLogFont)->lfWidth       = (LONG) (lpLogFont16)->lfWidth;            \
    (lpLogFont)->lfEscapement  = (LONG) (lpLogFont16)->lfEscapement;       \
    (lpLogFont)->lfOrientation = (LONG) (lpLogFont16)->lfOrientation;      \
    (lpLogFont)->lfWeight      = (LONG) (lpLogFont16)->lfWeight;           \
    /* [ntbug #129231 - Access97 occurs an application error.]             \
       Access 97 does not padded rest of facename arrary if the length of  \
       face name is less than LF_FACESIZE. Win9x only access until null,   \
       so that they are safe, we also did same.                         */ \
    (lpLogFont)->lfItalic      =        (lpLogFont16)->lfItalic;           \
    (lpLogFont)->lfUnderline   =        (lpLogFont16)->lfUnderline;        \
    (lpLogFont)->lfStrikeOut   =        (lpLogFont16)->lfStrikeOut;        \
    (lpLogFont)->lfCharSet     =        (lpLogFont16)->lfCharSet;          \
    (lpLogFont)->lfOutPrecision =       (lpLogFont16)->lfOutPrecision;     \
    (lpLogFont)->lfClipPrecision =      (lpLogFont16)->lfClipPrecision;    \
    (lpLogFont)->lfQuality     =        (lpLogFont16)->lfQuality;          \
    (lpLogFont)->lfPitchAndFamily =     (lpLogFont16)->lfPitchAndFamily;   \
    strncpy((lpLogFont)->lfFaceName,(lpLogFont16)->lfFaceName,LF_FACESIZE);\
}

#define LOGPEN32FROMLOGPEN16(pLogPen, pLogPen16)                \
{                                                               \
    (pLogPen)->lopnStyle   = (pLogPen16)->lopnStyle;            \
    (pLogPen)->lopnWidth.x = (pLogPen16)->lopnWidth.x;          \
    (pLogPen)->lopnWidth.y = (pLogPen16)->lopnWidth.y;          \
    (pLogPen)->lopnColor   = (pLogPen16)->lopnColor;            \
}


// Macros for convert 16 bit objects to 32 bit equivalents

#define BITMAP16FROMBITMAP32(pBitmap16,pBitmap)                 \
{                                                               \
    (pBitmap16)->bmType      = (SHORT)(pBitmap)->bmType;        \
    (pBitmap16)->bmWidth     = (SHORT)(pBitmap)->bmWidth;       \
    (pBitmap16)->bmHeight    = (SHORT)(pBitmap)->bmHeight;      \
    (pBitmap16)->bmWidthBytes= (SHORT)(pBitmap)->bmWidthBytes;  \
    (pBitmap16)->bmPlanes    = (BYTE)(pBitmap)->bmPlanes;       \
    (pBitmap16)->bmBitsPixel = (BYTE)(pBitmap)->bmBitsPixel;    \
    (pBitmap16)->bmBits      = (pBitmap)->bmBits;               \
}

#define LOGBRUSH16FROMLOGBRUSH32(pLogBrush16,pLogBrush)         \
{                                                               \
    (pLogBrush16)->lbStyle = (WORD)(pLogBrush)->lbStyle;        \
    ASSERTGDI((pLogBrush16)->lbStyle == BS_SOLID		\
	   || (pLogBrush16)->lbStyle == BS_HATCHED		\
	   || (pLogBrush16)->lbStyle == BS_HOLLOW,		\
	"LOGBRUSH16FROMLOGBRUSH32: unexpected lbStyle");	\
    (pLogBrush16)->lbColor = (pLogBrush)->lbColor;              \
    (pLogBrush16)->lbHatch = (SHORT)(pLogBrush)->lbHatch;       \
}

#define LOGPEN16FROMLOGPEN32(pLogPen16,pLogPen)                 \
{                                                               \
    (pLogPen16)->lopnStyle   = (WORD)(pLogPen)->lopnStyle;      \
    (pLogPen16)->lopnWidth.x = (SHORT)(pLogPen)->lopnWidth.x;   \
    (pLogPen16)->lopnWidth.y = (SHORT)(pLogPen)->lopnWidth.y;   \
    (pLogPen16)->lopnColor   = (pLogPen)->lopnColor;            \
}

#define LOGFONT16FROMLOGFONT32(pLogFont16,pLogFont)             \
{                                                               \
    ASSERTGDI((sizeof(LOGFONTA) == (sizeof(LOGFONT16)+sizeof(WORD)*5)),  \
            "MF16.h: LOGFONT(32) and LOGFONT(16) changed!");            \
    (pLogFont16)->lfHeight      = (SHORT)(pLogFont)->lfHeight;  \
    (pLogFont16)->lfWidth       = (SHORT)(pLogFont)->lfWidth;   \
    (pLogFont16)->lfEscapement  = (SHORT)(pLogFont)->lfEscapement;   \
    (pLogFont16)->lfOrientation = (SHORT)(pLogFont)->lfOrientation;  \
    (pLogFont16)->lfWeight      = (SHORT)(pLogFont)->lfWeight;       \
    RtlCopyMemory((PVOID)&(pLogFont16)->lfItalic,                  \
                  (CONST VOID *)&(pLogFont)->lfItalic,             \
                  sizeof(LOGFONTA)-sizeof(LONG)*5); \
}


/*** MetaFile Internal Constants and Macros ***/

#define METAVERSION300      0x0300
#define METAVERSION100      0x0100

// Metafile constants not in Windows.h

#define MEMORYMETAFILE      1
#define DISKMETAFILE        2

#define METAFILEFAILURE     1               // Flags denoting metafile is aborted

#define MF16_BUFSIZE_INIT   (16*1024)       // Metafile memory buffer size
#define MF16_BUFSIZE_INC    (16*1024)       // Metafile buffer increment size

#define ID_METADC16         0x444D          // "MD"
#define MF16_IDENTIFIER     0x3631464D      // "MF16"

#define MF3216_INCLUDE_WIN32MF     0x0001

// Constants for MFCOMMENT Escape

#define MFCOMMENT_IDENTIFIER           0x43464D57
#define MFCOMMENT_ENHANCED_METAFILE    1

// pmf16AllocMF16 flags

#define ALLOCMF16_TRANSFER_BUFFER	0x1

// METAFILE16 flags

#define MF16_DISKFILE		0x0001	// Disk or memory metafile.

// *** MetaFile Internal TypeDefs ***

typedef struct _METAFILE16 {
    DWORD       ident;
    METAHEADER  metaHeader;
    HANDLE      hFile;
    HANDLE      hFileMap;
    HANDLE      hMem;
    DWORD       iMem;
    HANDLE      hMetaFileRecord;
    DWORD       fl;
    WCHAR       wszFullPathName[MAX_PATH+1];
} METAFILE16,* PMETAFILE16;

#define MIN_OBJ_TYPE    OBJ_PEN
#define MAX_OBJ_TYPE    OBJ_ENHMETAFILE

typedef struct _MFRECORDER16 {

    HANDLE      hMem;                       // handle to the data (or buffer)
    HANDLE      hFile;                      // handle to the disk file
    DWORD       cbBuffer;                   // current size of hMem
    DWORD       ibBuffer;                   // current position in buffer
    METAHEADER  metaHeader;
    WORD        recFlags;
    HANDLE      hObjectTable;
    HANDLE      recCurObjects[MAX_OBJ_TYPE];// Current Selected Object
    UINT        iPalVer;                    // index of palette metafile synced to
    WCHAR       wszFullPathName[MAX_PATH+1];
} MFRECORDER16, * PMFRECORDER16;

typedef struct _OBJECTTABLE {
    HANDLE      CurHandle;
    BOOL        fPreDeleted;
} OBJECTTABLE, * POBJECTTABLE;

#pragma pack(2)
typedef struct _SCAN  {
    WORD        scnPntCnt;                  // Scan point count
    WORD        scnPntTop;                  // Top of scan
    WORD        scnPntBottom;               // Bottom of scan
    WORD        scnPntsX[2];                // Start of points in scan
    WORD        scnPtCntToo;                // Point count-- to allow UP travel
} SCAN;
typedef SCAN UNALIGNED *PSCAN;

typedef struct _WIN3REGION {
    WORD        nextInChain;                // Not used should be zero
    WORD        ObjType;                    // Must always be 6 (Windows OBJ_RGN)
    DWORD       ObjCount;                   // Not used
    WORD        cbRegion;                   // size of following region struct
    WORD        cScans;
    WORD        maxScan;
    RECT16      rcBounding;
    SCAN        aScans[1];
} WIN3REGION;
typedef WIN3REGION UNALIGNED *PWIN3REGION;

typedef struct _META_ESCAPE_ENHANCED_METAFILE {
    DWORD       rdSize;             // Size of the record in words
    WORD        rdFunction;         // META_ESCAPE
    WORD        wEscape;            // MFCOMMENT
    WORD        wCount;             // Size of the following data + emf in bytes
    DWORD       ident;              // MFCOMMENT_IDENTIFIER
    DWORD       iComment;           // MFCOMMENT_ENHANCED_METAFILE
    DWORD       nVersion;           // Enhanced metafile version 0x10000
    WORD        wChecksum;          // Checksum - used by 1st record only
    DWORD       fFlags;             // Compression etc - used by 1st record only
    DWORD       nCommentRecords;    // Number of records making up the emf
    DWORD       cbCurrent;          // Size of emf data in this record in bytes
    DWORD       cbRemainder;        // Size of remainder in following records
    DWORD       cbEnhMetaFile;      // Size of enhanced metafile in bytes
				    // The enhanced metafile data follows here
} META_ESCAPE_ENHANCED_METAFILE;
typedef META_ESCAPE_ENHANCED_METAFILE UNALIGNED *PMETA_ESCAPE_ENHANCED_METAFILE;
#pragma pack()

// Macro to check that it is a meta_escape embedded enhanced metafile record.

#define IS_META_ESCAPE_ENHANCED_METAFILE(pmfeEnhMF)			      \
	((pmfeEnhMF)->rdFunction == META_ESCAPE				      \
      && (pmfeEnhMF)->rdSize     >  sizeof(META_ESCAPE_ENHANCED_METAFILE) / 2 \
      && (pmfeEnhMF)->wEscape    == MFCOMMENT				      \
      && (pmfeEnhMF)->ident      == MFCOMMENT_IDENTIFIER		      \
      && (pmfeEnhMF)->iComment   == MFCOMMENT_ENHANCED_METAFILE)

// Internal Function Declarations

PMETARECORD   GetEvent(PMETAFILE16 pmf,PMETARECORD pmr);
DWORD         GetObject16AndType(HANDLE hObj, LPVOID lpObjectBuf);
BOOL          IsValidMetaHeader16(PMETAHEADER pMetaHeader);
WORD          RecordObject(HDC hdc, HANDLE hObject);
BOOL          RecordParms(HDC hDC, DWORD magic, DWORD cw, CONST WORD *lpParm);
UINT          ConvertEmfToWmf(PBYTE pMeta32, UINT cbMeta16, PBYTE pMeta16, INT mm, HDC hdc, UINT f);
PMETAFILE16   pmf16AllocMF16(DWORD fl, DWORD cb, CONST UNALIGNED DWORD *pb, LPCWSTR pwszFilename);
VOID          vFreeMF16(PMETAFILE16 pmf16);
BOOL	      bMetaGetDIBInfo(HDC hdc, HBITMAP hbm,
                    PBITMAPINFOHEADER pBmih, PDWORD pcbBmi, PDWORD pcbBits,
                    DWORD iUsage, LONG cScans, BOOL bMeta16);




#define hmf16Create(pmf16)   hCreateClientObjLink((PVOID)pmf16,LO_METAFILE16_TYPE)
#define bDeleteHmf16(hmf)    bDeleteClientObjLink((HANDLE)hmf)
#define GET_PMF16(hmf)       ((PMETAFILE16)pvClientObjGet((HANDLE)hmf,LO_METAFILE16_TYPE))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\metasup.cxx ===
/******************************Module*Header*******************************\
* Module Name: metasup.cxx
*
* Includes metafile support functions.
*
* Created: 17-July-1991 10:10:36
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1991-1999 Microsoft Corporation
\**************************************************************************/

#define NO_STRICT

extern "C" {
#if defined(_GDIPLUS_)
#include    <gpprefix.h>
#endif

#include    <nt.h>
#include    <ntrtl.h>
#include    <nturtl.h>
#include    <stddef.h>
#include    <windows.h>    // GDI function declarations.
#include    <winerror.h>
#include    "firewall.h"
#define __CPLUSPLUS
#include    <winspool.h>
#include    <w32gdip.h>
#include    "ntgdistr.h"
#include    "winddi.h"
#include    "hmgshare.h"
#include    "icm.h"
#include    "local.h"      // Local object support.
#include    "gdiicm.h"
#include    "metadef.h"    // Metafile record type constants.
#include    "mf16.h"
#include    "ntgdi.h"
}

#include    "rectl.hxx"
#include    "mfdc.hxx"  // Metafile DC class declarations.
#include    "mfrec.hxx" // Metafile record class declarations.

extern "C" {
HANDLE InternalCreateLocalMetaFile(HANDLE hSrv, DWORD iTypeReq);
DWORD SetMapperFlagsInternal(HDC hdc,DWORD fl);
}


PLINK aplHash[LINK_HASH_SIZE] = {0};


/******************************Public*Routine******************************\
* pmdcAllocMDC(hdcRef, pszFilename, pwszDescription)
*
* This routine allocates memory for an MDC and initializes it.  It creates
* a disk file if necessary.  Returns a pointer to the new MDC.  On error
* returns NULL.
*
* This routine is called by API level DC allocation routines CreateEnhMetaFile.
*
* History:
*  Tue Jul 02 13:43:18 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

PMDC pmdcAllocMDC(HDC hdcRef, LPCWSTR pwszFilename, LPCWSTR pwszDescription, HANDLE hEMFSpool)
{
    PMDC  pmdc, pmdcRc = (PMDC) NULL;
    ULONG       ii;

    PUTS("pmdcAllocMDC\n");

// Allocate a new MDC.

    if (!(pmdc = (PMDC) LocalAlloc(LMEM_FIXED, sizeof(MDC))))
        goto pmdcAllocMDC_cleanup;

// Initialize it.

    pmdc->ident     = MDC_IDENTIFIER;
    pmdc->hFile     = INVALID_HANDLE_VALUE;
    pmdc->hData     = NULL;
    pmdc->nMem      = MF_BUFSIZE_INIT;
    pmdc->iMem      = 0L;
    pmdc->fl        = 0L;
    pmdc->pmhe      = (PMHE) NULL;
    pmdc->cPalEntries = 0L;
    pmdc->iPalEntries = 0L;
    pmdc->pPalEntries = (PPALETTEENTRY) NULL;   // allocate as needed
    pmdc->erclMetaBounds = rclInfinity;     // default clipping bounds
    pmdc->erclClipBounds = rclInfinity;
    pmdc->hdcRef      = hdcRef;
    pmdc->exFontScale(0.0f);
    pmdc->eyFontScale(0.0f);
    pmdc->vInitColorProfileList();

// Create a disk file if given.  The filename is given in unicode.

    if (pwszFilename)
    {
        LPWSTR  pwszFilePart;           // not used

        // Convert the filename to a fully qualified pathname.

        DWORD cPathname = GetFullPathNameW(pwszFilename,
                                          MAX_PATH,
                                          pmdc->wszPathname,
                                          &pwszFilePart);

        if (!cPathname || cPathname > MAX_PATH)
        {
            ERROR_ASSERT(FALSE, "GetFullPathName failed");
            if (cPathname > MAX_PATH)
                GdiSetLastError(ERROR_FILENAME_EXCED_RANGE);
            goto pmdcAllocMDC_cleanup;
        }
        pmdc->wszPathname[cPathname] = 0;

        // Create the file.

        if ((pmdc->hFile = CreateFileW(pmdc->wszPathname,       // Filename
                                    GENERIC_WRITE,              // Write access
                                    0L,                         // Non-shared
                    (LPSECURITY_ATTRIBUTES) NULL, // No security
                                    CREATE_ALWAYS,              // Always create
                                    FILE_ATTRIBUTE_NORMAL,      // normal attributes
                                    (HANDLE) 0))                // no template file
            == INVALID_HANDLE_VALUE)
        {
            ERROR_ASSERT(FALSE, "CreateFile failed");
            goto pmdcAllocMDC_cleanup;
        }
        pmdc->fl |= MDC_DISKFILE;       // this must be last!  See vFreeMDC.

    }

// Allocate memory for metafile.
//   For disk metafile, it is used as a buffer.
//   For memory metafile, it is the storage for the metafile.

    if (hEMFSpool != NULL)
    {
        // Recording EMF data during EMF spooling

        pmdc->fl |= MDC_EMFSPOOL;
        pmdc->hData = hEMFSpool;

        if(!((EMFSpoolData *) hEMFSpool)->GetEMFData(pmdc))
            goto pmdcAllocMDC_cleanup;

    }
    else
    {
        if (!(pmdc->hData = LocalAlloc(LMEM_FIXED, MF_BUFSIZE_INIT)))
            goto pmdcAllocMDC_cleanup;

    }

// Allocate memory for metafile handle table.

    if (!(pmdc->pmhe = (PMHE) LocalAlloc(LMEM_FIXED, MHT_HANDLE_SIZE * sizeof(MHE))))
        goto pmdcAllocMDC_cleanup;

// Initialize the new handles.
// The first entry is reserved and unused.

    pmdc->pmhe[0].lhObject   = (HANDLE) 0;
    pmdc->pmhe[0].metalink.vInit(INVALID_INDEX);

    ii = pmdc->imheFree = 1L;
    pmdc->cmhe = MHT_HANDLE_SIZE;
    for ( ; ii < MHT_HANDLE_SIZE; ii++)
    {
        pmdc->pmhe[ii].lhObject = (HANDLE) 0;
        pmdc->pmhe[ii].metalink.vInit(ii+1);
    }
    pmdc->pmhe[ii-1].metalink.vInit(INVALID_INDEX);

// Create the first metafile record.
// The description string is part of the header record.

    // Get the length of the description string including the NULLs.

    PMRMETAFILE pmrmf;
    UINT cwszDescription;

    if (pwszDescription != (LPWSTR) NULL)
    {
       for
       (
           cwszDescription = 0;
           pwszDescription[cwszDescription] != (WCHAR) 0
           || pwszDescription[cwszDescription + 1] != (WCHAR) 0;
           cwszDescription++
       )
           ;               // NULL expression
       cwszDescription += 2;       // add terminating nulls
       if (cwszDescription > 512)
       {
           WARNING("pmdcAllocMDC: Description string is > 512 chars\n");
       }
    }
    else
    cwszDescription = 0;

    // Allocate dword aligned structure.

    if (!(pmrmf = (PMRMETAFILE) pmdc->pvNewRecord
            (SIZEOF_MRMETAFILE(cwszDescription))))
        goto pmdcAllocMDC_cleanup;

    pmrmf->vInit(hdcRef, pwszDescription, cwszDescription);

// Save a copy of it in the metafile DC.

    pmdc->mrmf = *(PENHMETAHEADER) pmrmf;

// Commit it.

    pmrmf->vCommit(pmdc);


    // If the reference DC has a pixel format selected, record
    // it in the metafile
    int iPixelFormat;

    if ((iPixelFormat = GetPixelFormat(hdcRef)) != 0)
    {
        PMRPIXELFORMAT pmrpf;
        PIXELFORMATDESCRIPTOR pfd;

        if (!DescribePixelFormat(hdcRef, iPixelFormat, sizeof(pfd), &pfd))
        {
            goto pmdcAllocMDC_cleanup;
        }

        pmrpf = (PMRPIXELFORMAT)pmdc->pvNewRecord(SIZEOF_MRPIXELFORMAT);
        if (pmrpf == NULL)
        {
            goto pmdcAllocMDC_cleanup;
        }

        pmrpf->vInit(&pfd);
        pmrpf->vCommit(pmdc);
    }

    pmdcRc = pmdc;

// Cleanup and go home.

pmdcAllocMDC_cleanup:

    if (!pmdcRc)
        if (pmdc)
        {
            pmdc->fl |= MDC_FATALERROR; // set to delete the disk metafile
            vFreeMDC(pmdc);
        }

    ERROR_ASSERT(pmdcRc, "pmdcAllocMDC failed");
    return(pmdcRc);
}

/******************************Public*Routine******************************\
* vFreeMDC (pmdc)
*
* This is a low level routine which frees the resouces in the MDC.
*
* This function is intended to be called from the routine CloseEnhMetaFile.
*
* Arguments:
*   pmdc    - The MDC to be freed.
*
* History:
*  Tue Jul 02 13:43:18 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID vFreeMDC(PMDC pmdc)
{
    ULONG   ii;

    PUTS("vFreeMDC\n");

    ASSERTGDI(pmdc->ident == MDC_IDENTIFIER, "Bad MDC");

// Free the resources.

    if (pmdc->pPalEntries)
    {
        if (LocalFree(pmdc->pPalEntries))
        {
            ASSERTGDI(FALSE, "LocalFree failed");
        }
    }

    // Cleanup objects and metalinks.

    pmdc->vFreeColorProfileList();

    if (pmdc->pmhe)
    {
        // The first entry is reserved and unused.

        for (ii = 1 ; ii < pmdc->cmhe; ii++)
        {
            if (pmdc->pmhe[ii].lhObject != (HANDLE) 0)
                vFreeMHE(pmdc->hdcRef, ii);
        }
        if (LocalFree(pmdc->pmhe))
        {
            ASSERTGDI(FALSE, "LocalFree failed");
        }
    }
    if (pmdc->hData)
    {
        if (pmdc->bIsEMFSpool())
        {
            pmdc->CompleteEMFData(FALSE);
        }
        else
        {
            if (LocalFree(pmdc->hData))
            {
                ASSERTGDI(FALSE, "LocalFree failed");
            }
        }
    }

    if (pmdc->hFile != INVALID_HANDLE_VALUE)
    {
        if (!CloseHandle(pmdc->hFile))
        {
            ASSERTGDI(FALSE, "CloseHandle failed");
        }
    }

// Delete the disk metafile we created if we encountered any fatal error.

    if (pmdc->bIsDiskFile() && pmdc->bFatalError())
    {

        #if DBG
        SetLastError(0);
        #endif

        if (!DeleteFileW(pmdc->wszPathname))
        {
            #if DBG
            DbgPrint("vFreeMDC: DeleteFile failed with error code %ld\n",
                     GetLastError());
            #endif

            //
            // There are certain conditions causing fatal errors accessing
            // files that equally prevent the deletion of the file
            // (such as out of quota or pool)
            // If we can't delete the file, we can't do anything about it
            // anyway - let's not force an ASSERT even on checked builds unless
            // we set the debug flags. We will make do with an error message
            // and appropriate error code above.
            //

            ERROR_ASSERT(FALSE, "vFreeMDC: DeleteFile failed");
        }
    }

// Smash the identifier.

    pmdc->ident = 0;

// Free the memory.

    if (LocalFree(pmdc))
    {
        ASSERTGDI(FALSE, "LocalFree failed");
    }
}

/******************************Public*Routine******************************\
* pmfAllocMF(fl, pb, pwszFilename)
*
* This routine allocates memory for an MF and initializes it.
* Returns a pointer to the new MF.  On error returns NULL.
* It accepts only enhanced metafiles.
*
* This routine is called by API level MF allocation routines CloseEnhMetaFile,
* GetEnhMetaFile, SetEnhMetaFileBits and CopyEnhMetaFile.
*
* Arguments:
*   fl           - ALLOCMF_TRANSFER_BUFFER is set if storage for memory metafile
*                  is to be set directly into MF.  Otherwise, a copy of the
*                  memory metafile is duplicated.
*   pb           - Pointer to a memory metafile if non-null.
*   pwszFilename - Filename of a disk metafile if non-null.
*
* History:
*  Tue Jul 02 13:43:18 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

PMF pmfAllocMF(ULONG fl, CONST UNALIGNED DWORD *pb, LPCWSTR pwszFilename, HANDLE hFile, UINT64 fileOffset, HANDLE hExtra)
{
    PMF             pmf = NULL;
    PMF             pmfRc = (PMF) NULL;
    PENHMETAHEADER  pmrmf = NULL;

    PUTS("pmfAllocMF\n");

    ASSERTGDI(!(fl & ~ALLOCMF_TRANSFER_BUFFER), "pmfAllocMF: Invalid fl");

// Allocate a new MF.

    if (!(pmf = (PMF) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(MF))))
        goto pmfAllocMF_cleanup;

// Initialize it.

    pmf->ident      = MF_IDENTIFIER;
    pmf->hFile      = INVALID_HANDLE_VALUE;
    pmf->hFileMap   = NULL;
    pmf->pvFileMapping = NULL;
    pmf->pvLocalCopy = NULL;
    pmf->pEMFSpool  = hExtra ? (EMFSpoolData*) hExtra : NULL;
    pmf->iMem       = 0L;
    pmf->pht        = (PHANDLETABLE) NULL;
    pmf->fl         = 0L;
    pmf->hdcXform   = 0;


// Memory mapped the disk file if given.

    if (pwszFilename)
    {
        pmf->fl |= MF_DISKFILE;         // this must be first!  See vFreeMF.

        LPWSTR          pwszFilePart;           // not used
        UINT64          fileSize;

        // Convert the filename to a fully qualified pathname.

        DWORD cPathname = GetFullPathNameW(pwszFilename,
                                          MAX_PATH,
                                          pmf->wszPathname,
                                          &pwszFilePart);

        if (!cPathname || cPathname > MAX_PATH)
        {
            ERROR_ASSERT(FALSE, "GetFullPathName failed");
            if (cPathname > MAX_PATH)
                GdiSetLastError(ERROR_FILENAME_EXCED_RANGE);
            goto pmfAllocMF_cleanup;
        }
        pmf->wszPathname[cPathname] = 0;

        if ((pmf->hFile = CreateFileW(pmf->wszPathname,         // Filename
                                     GENERIC_READ,              // Read access
                                     FILE_SHARE_READ,           // Share read
                                     (LPSECURITY_ATTRIBUTES) 0L,// No security
                                     OPEN_EXISTING,             // Re-open
                                     0,                         // file attributes ignored
                                     (HANDLE) 0))               // no template file
            == INVALID_HANDLE_VALUE)
        {
            ERROR_ASSERT(FALSE, "CreateFile failed");
            goto pmfAllocMF_cleanup;
        }

        if(!GetFileSizeEx(pmf->hFile, (PLARGE_INTEGER) &fileSize))
        {
            ERROR_ASSERT(FALSE, "GetFileSizeEx failed");
            goto pmfAllocMF_cleanup;
        }

        if(fileSize > (UINT64) 0xFFFFFFFF)
        {
            ERROR_ASSERT(FALSE, "EMF File too large\n");
            goto pmfAllocMF_cleanup;
        }

        if (!(pmf->hFileMap = CreateFileMappingW(pmf->hFile,
                                                (LPSECURITY_ATTRIBUTES) 0L,
                                                PAGE_READONLY,
                                                0L,
                                                0L,
                                                (LPWSTR) NULL)))
        {
            ERROR_ASSERT(FALSE, "CreateFileMapping failed");
            goto pmfAllocMF_cleanup;
        }

        if (!(pmf->pvFileMapping = (PENHMETAHEADER) MapViewOfFile(pmf->hFileMap, FILE_MAP_READ, 0, 0, 0)))
        {
            ERROR_ASSERT(FALSE, "MapViewOfFile failed");
            goto pmfAllocMF_cleanup;
        }

        pmf->emfc.Init((PENHMETAHEADER) pmf->pvFileMapping, (UINT32) fileSize);

    }
    else if (fl & ALLOCMF_TRANSFER_BUFFER)
    {
// If this is our memory metafile from MDC, transfer it to MF.

        if(pb)
        {
            pmf->emfc.Init((PENHMETAHEADER) pb, ((PENHMETAHEADER) pb)->nBytes);

            // We now own the reference which we must free

            pmf->pvLocalCopy = (PVOID) pb;
        }
        else if(hFile)
        {
            pmf->emfc.Init(hFile, fileOffset, 0);

            // We now own the reference which we must now Close

            pmf->hFile = hFile;
        }
        else
        {
            ERROR_ASSERT(hFile != NULL, "pmfAllocMF: exepect hHandle or pb to be non-null\n");
            goto pmfAllocMF_cleanup;
        }

    }
    else
    {
// Otherwise, make a copy of memory metafile.

        if (!(pmf->pvLocalCopy = (PENHMETAHEADER) LocalAlloc(LMEM_FIXED, (UINT) ((PENHMETAHEADER) pb)->nBytes)))
            goto pmfAllocMF_cleanup;

        RtlCopyMemory((PBYTE) pmf->pvLocalCopy, pb, ((PENHMETAHEADER) pb)->nBytes);

        pmf->emfc.Init((PENHMETAHEADER) pmf->pvLocalCopy, ((PENHMETAHEADER) pb)->nBytes);

    }

// Verify metafile header

    pmrmf = pmf->emfc.GetEMFHeader();

    if(!pmrmf)
    {
        WARNING("pmfAllocMF: failed to get emf header\n");
        goto pmfAllocMF_cleanup;
    }

    if (!((PMRMETAFILE) pmrmf)->bValid())
    {
        ERROR_ASSERT(FALSE,
                "pmfAllocMF: Metafile has an invalid header; Failing\n");
        goto pmfAllocMF_cleanup;
    }

// Allocate and initialize the playback object handle table.
// The first entry of pht is initialized to hemf in PlayEnhMetaFile
// and EnumEnhMetaFile.

    if (!(pmf->pht
          = (PHANDLETABLE) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                      pmrmf->nHandles * sizeof(HANDLE))))
        goto pmfAllocMF_cleanup;

// Allocate a virtual device for transform computation.

    if (!(pmf->hdcXform = CreateICA((LPCSTR) "DISPLAY",
                                   (LPCSTR) NULL,
                                   (LPCSTR) NULL,
                                   (LPDEVMODEA) NULL)))
    {
        ERROR_ASSERT(FALSE, "CreateICA failed");
        goto pmfAllocMF_cleanup;
    }

// The transform DC must be in the advanced graphics mode.
// The world transform can only be set in the advanced graphics mode.

    if (!SetGraphicsMode(pmf->hdcXform, GM_ADVANCED))
        goto pmfAllocMF_cleanup;

// Everything is golden.

    pmfRc = pmf;

// Cleanup and go home.

pmfAllocMF_cleanup:

    if (!pmfRc)
        if (pmf)
        {
            if (fl & ALLOCMF_TRANSFER_BUFFER)
                pmf->pvLocalCopy = 0;    // let caller free the buffer.
            vFreeMF(pmf);
        }

    ERROR_ASSERT(pmfRc, "pmfAllocMF failed");
    return(pmfRc);
}

/******************************Public*Routine******************************\
* vFreeMF (pmf)
*
* This is a low level routine which frees the resouces in the MF.
*
* This function is intended to be called from the routines CloseEnhMetaFile
* and DeleteEnhMetaFile.
*
* Arguments:
*   pmf    - The MF to be freed.
*
* History:
*  Tue Jul 02 13:43:18 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID vFreeMF(PMF pmf)
{
    PUTS("vFreeMF\n");

    ASSERTGDI(pmf->ident == MF_IDENTIFIER, "Bad MF");

// Free the resources.

    if (pmf->hdcXform)
        DeleteDC(pmf->hdcXform);

    pmf->emfc.Term();

    if (pmf->pht)
    {
        // Objects created during play are freed in PlayEnhMetaFile and
        // EnumEnhMetaFile.

        PENHMETAHEADER pmrmf = pmf->emfc.GetEMFHeader();

        if (pmrmf)
        {
            for (WORD ii = 1; ii < pmrmf->nHandles; ii++)
            {
                ASSERTGDI(!pmf->pht->objectHandle[ii],
                "vFreeMF: Handle table not empty");
            }
        }

        if (LocalFree(pmf->pht))
        {
            ASSERTGDI(FALSE, "LocalFree failed");
        }
    }

    if (!pmf->bIsDiskFile())
    {
// Free memory metafile.

        if (pmf->pvLocalCopy && LocalFree(pmf->pvLocalCopy))
        {
            ASSERTGDI(FALSE, "LocalFree failed");
        }

        // If we are spooling, then the spooler needs to deal
        // with closing the file handle, otherwise we own it
        // and need to close it.

        if(!pmf->bIsEMFSpool())
        {
            if (pmf->hFile != INVALID_HANDLE_VALUE)
            {
                if (!CloseHandle(pmf->hFile))
                {
                    ASSERTGDI(FALSE, "CloseHandle failed");
                }
                else
                {
                    pmf->hFile = NULL;
                }
            }
        }
    }
    else
    {
// Unmap disk file.

        if (pmf->pvFileMapping && !UnmapViewOfFile(pmf->pvFileMapping))
        {
            ASSERTGDI(FALSE, "UmmapViewOfFile failed");
        }

        if (pmf->hFileMap)
        {
            if (!CloseHandle(pmf->hFileMap))
            {
                ASSERTGDI(FALSE, "CloseHandle failed");
            }
            else
            {
                pmf->hFileMap = NULL;
            }
        }

        if (pmf->hFile != INVALID_HANDLE_VALUE)
        {
            if (!CloseHandle(pmf->hFile))
            {
                ASSERTGDI(FALSE, "CloseHandle failed");
            }
            else
            {
                pmf->hFile = NULL;
            }
        }

    }

// Smash the identifier.

    pmf->ident = 0;

// Free the memory.

    if (LocalFree(pmf))
    {
        ASSERTGDI(FALSE, "LocalFree failed");
    }
}

/******************************Public*Routine******************************\
* vFreeMFAlt (pmf, bAllocBuffer)
*
* This is a low level routine which frees the resouces in the MF.
*
* This function is intended to be called from the routines InternalDeleteEnhMetaFile
*
* Arguments:
*   pmf    - The MF to be freed.
*   bAllocBuffer -  flag to free buffer
*
\**************************************************************************/

VOID vFreeMFAlt(PMF pmf, BOOL bAllocBuffer)
{
    PUTS("vFreeMF\n");

    ASSERTGDI(pmf->ident == MF_IDENTIFIER, "Bad MF");

    // Free the resources.

    if (pmf->hdcXform)
        DeleteDC(pmf->hdcXform);

    pmf->emfc.Term();

    if (pmf->pht)
    {
        // Objects created during play are freed in PlayEnhMetaFile and
        // EnumEnhMetaFile.

        PENHMETAHEADER pmrmf = pmf->emfc.GetEMFHeader();

        if (pmrmf)
        {
           for (WORD ii = 1; ii < pmrmf->nHandles; ii++)
           {
               ASSERTGDI(!pmf->pht->objectHandle[ii],
               "vFreeMF: Handle table not empty");
           }
        }

        if (LocalFree(pmf->pht))
        {
            ASSERTGDI(FALSE, "LocalFree failed");
        }
    }

    if (bAllocBuffer)
    {
       if (!pmf->bIsDiskFile())
       {
           // Free memory metafile.

           if (pmf->pvLocalCopy && LocalFree(pmf->pvLocalCopy))
           {
               ASSERTGDI(FALSE, "LocalFree failed");
           }

           if(!pmf->bIsEMFSpool())
           {
               // If we are spooling, then the spooler needs to deal
               // with closing the file handle, otherwise we own it
               // and need to close it.

               if (pmf->hFile != INVALID_HANDLE_VALUE)
               {
                   if (!CloseHandle(pmf->hFile))
                   {
                       ASSERTGDI(FALSE, "CloseHandle failed");
                   }
                   else
                   {
                       pmf->hFile = NULL;
                   }
               }
           }
       }
       else
       {
           // Unmap disk file.

           if (pmf->pvFileMapping && !UnmapViewOfFile(pmf->pvFileMapping))
           {
               ASSERTGDI(FALSE, "UmmapViewOfFile failed");
           }

           if (pmf->hFileMap)
           {
               if (!CloseHandle(pmf->hFileMap))
               {
                   ASSERTGDI(FALSE, "CloseHandle failed");
               }
               else
               {
                   pmf->hFileMap = NULL;
               }
           }
           
           if (pmf->hFile != INVALID_HANDLE_VALUE)
           {
               if (!CloseHandle(pmf->hFile))
               {
                   ASSERTGDI(FALSE, "CloseHandle failed");
               }
               else
               {
                   pmf->hFile = NULL;
               }
           }
       }

    }
    // Smash the identifier.

    pmf->ident = 0;

    // Free the memory.

    if (LocalFree(pmf))
    {
        ASSERTGDI(FALSE, "LocalFree failed");
    }
}

/******************************Public*Routine******************************\
* bMetaResetDC (hdc)
*
* Initialize the destination DC before playing a metafile to that DC.
*
* History:
*  Fri Nov 01 15:02:58 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL bMetaResetDC(HDC hdc)
{
// Make sure we do everything
// If the destination is a metafile DC, we want to embed
// the calls made in this function.

    POINT ptOrg;
    FLOAT eMiterLimit;

// Reset to default objects.

    SelectObject(hdc, GetStockObject(WHITE_BRUSH));
    SelectObject(hdc, GetStockObject(BLACK_PEN));
    SelectObject(hdc, GetStockObject(DEVICE_DEFAULT_FONT));
    SelectPalette(hdc,GetStockObject(DEFAULT_PALETTE),TRUE);

// Attributes cache.

    SetBkColor(hdc, 0xffffff);
    SetTextColor(hdc, 0);
    SetTextCharacterExtra(hdc, 0);
    SetBkMode(hdc, OPAQUE);

    SetPolyFillMode(hdc, ALTERNATE);
    SetROP2(hdc, R2_COPYPEN);
    SetStretchBltMode(hdc, BLACKONWHITE);
    SetTextAlign(hdc, 0);

// Reset server attributes.

    // Mapper flags.
    // Metafile it only if the previous mapper flags is not default.
    if (SetMapperFlagsInternal(hdc, 0) != 0)      // if the previous flags is
    {
        if (SetMapperFlags(hdc, 0) == GDI_ERROR)  // not default, set to default
        {
            ASSERTGDI(FALSE, "SetMapperFlags failed");
        }
    }

    SetBrushOrgEx(hdc, 0, 0, (LPPOINT) NULL);
    SetMiterLimit(hdc, 10.0f, (PFLOAT) NULL);
    SetTextJustification(hdc, 0, 0);
    SetArcDirection(hdc, AD_COUNTERCLOCKWISE);
    MoveToEx(hdc, 0, 0, (LPPOINT) NULL);

    return(TRUE);
}

/******************************Public*Routine******************************\
* bIsPoly16(pptl, cptl)
*
* Return TRUE if all the points in the poly array are 16-bit signed integers.
* Otherwise, it is FALSE.
*
* History:
*  Sat Mar 07 17:07:33 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL bIsPoly16(PPOINTL pptl, DWORD cptl)
{
    while (cptl--)
    {
    if
    (
        pptl->x < (LONG) (SHORT) MINSHORT
     || pptl->x > (LONG) (SHORT) MAXSHORT
     || pptl->y < (LONG) (SHORT) MINSHORT
     || pptl->y > (LONG) (SHORT) MAXSHORT
    )
        return(FALSE);
    pptl++;
    }
    return(TRUE);
}

/******************************Public*Routine******************************\
* imheAllocMHE(hdc, lhObject)
*
* Allocates a MHE from the Metafile Handle Table in the metafile DC,
* initializes fields in the MHE, and updates the object's metalink.
* Returns the MHE index or INVALID_INDEX on error.
*
* Since the first entry is reserved, index zero is never returned.
*
* When a object's metalink is first created, a 16-bit metafile object-link
* should be added to the begining of the metafile link as necessary.  The
* 16-bit metafile object-link should be removed as necessary when the last
* metalink is deleted.
*
* History:
*  Tue Aug 06 15:41:52 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

ULONG imheAllocMHE(HDC hdc, HANDLE lhObject)
{
    PMDC    pmdc = GET_PMDC(hdc);
    ULONG   imhe = INVALID_INDEX;
    ULONG   ii;
    PMHE    pmhe;

// Get critical for handle allocation.

    ENTERCRITICALSECTION(&semLocal);

// Make sure a handle is available.

    if (pmdc->imheFree == INVALID_INDEX)
    {
        // Allocate more handles up to the max size.

        PMHE    pmhe1;
        UINT    cmhe1;

        if (pmdc->cmhe == MHT_MAX_HANDLE_SIZE)
        {
            ERROR_ASSERT(FALSE, "imheAllocMHE: max handle table size reached");
            goto imheAllocMHE_exit;
        }

        cmhe1 = min((UINT) pmdc->cmhe + MHT_HANDLE_SIZE,
            (UINT) MHT_MAX_HANDLE_SIZE);

        if (!(pmhe1 = (PMHE) LocalReAlloc
                                (
                                pmdc->pmhe,
                                cmhe1 * sizeof(MHE),
                                LMEM_MOVEABLE
                                )
             )
           )
        {
            ERROR_ASSERT(FALSE, "LocalReAlloc failed");
            goto imheAllocMHE_exit;
        }

        pmdc->pmhe = pmhe1;

        // Initialize the new handles.

        ii = pmdc->imheFree = pmdc->cmhe;
        pmdc->cmhe = cmhe1;
        for ( ; ii < pmdc->cmhe; ii++)
        {
            pmdc->pmhe[ii].lhObject = (HANDLE) 0;
            pmdc->pmhe[ii].metalink.vInit(ii+1);
        }
        pmdc->pmhe[ii-1].metalink.vInit(INVALID_INDEX);
    }


    // First, make sure the object has a 16-bit metafile object-link.
    // we have this in brackets to reduce scope of pmetalink16
    {
        METALINK16 *pmetalink16 = pmetalink16Get(lhObject);

        if (pmetalink16 == NULL)
        {
            pmetalink16 = pmetalink16Create(lhObject);

            if (pmetalink16 == NULL)
            {
                ERROR_ASSERT(FALSE, "LocalAlloc failed");
                goto imheAllocMHE_exit;
            }

            ASSERTGDI
            (
                pmetalink16->metalink == 0
                 && pmetalink16->cMetaDC16 == 0
                 && pmetalink16->ahMetaDC16[0] == (HDC) 0,
                "imheAllocMHE: METALINK16 not initialized properly"
            );
        }

        imhe = pmdc->imheFree;
        pmhe = pmdc->pmhe + imhe;
        pmdc->imheFree = (ULONG) pmhe->metalink;

        ASSERTGDI(imhe != 0, "imheAllocMHE: index zero is reserved");
        ASSERTGDI(pmhe->lhObject == (HANDLE) 0, "imheAllocMHE: imheFree in use");

    // Update and add the metalink to the link list.

        pmhe->lhObject = lhObject;
        pmhe->metalink.vInit(pmetalink16->metalink);
        ((PMETALINK) &pmetalink16->metalink)->vInit((USHORT) imhe, H_INDEX(hdc));
    }

imheAllocMHE_exit:

// Leave the critical section.

    LEAVECRITICALSECTION(&semLocal);
    return(imhe);
}

/******************************Public*Routine******************************\
* vFreeMHE(hdc, imhe)
*
* Free up a MHE and insert it into the Metafile Handle Table free list.
* It also updates the object's metalink.
*
* When the last metalink is removed, the 16-bit metafile object-link should
* also be removed if it is not used.
*
* History:
*  Tue Aug 06 15:41:52 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID vFreeMHE(HDC hdc, ULONG imhe)
{
    PMETALINK16 pmetalink16;
    PMDC    pmdc = GET_PMDC(hdc);
    HANDLE  hobj;

    ASSERTGDI(imhe != 0, "vFreeMHE: index zero is reserved");

// Get critical for handle deallocation.

    ENTERCRITICALSECTION(&semLocal);

// Remove it from the object metalink friend list.

    hobj = pmdc->pmhe[imhe].lhObject;
    pmetalink16 = pmetalink16Get(hobj);

    ASSERTGDI(pmetalink16, "vFreeMHE: pmetalink16 Invalid");

    METALINK metalink(pmetalink16);

    ASSERTGDI(metalink.bValid(), "vFreeMHE: Invalid imhe");

    if (metalink.bEqual((USHORT) imhe, H_INDEX(hdc)))
    {
        pmetalink16->metalink = (ULONG) pmdc->pmhe[imhe].metalink;
    }
    else
    {
        while (!(metalink.pmetalinkNext())->bEqual((USHORT) imhe, H_INDEX(hdc)))
        {
            metalink.vNext();
            ASSERTGDI(metalink.bValid(), "vFreeMHE: Invalid imhe");
        }

        *(metalink.pmetalinkNext()) = pmdc->pmhe[imhe].metalink;
    }

// Add the handle to the free list.

    pmdc->pmhe[imhe].lhObject = (HANDLE) 0;
    pmdc->pmhe[imhe].metalink.vInit(pmdc->imheFree);
    pmdc->imheFree = imhe;

// If there is no more metalink, remove the 16-bit metafile object-link
// if it's not used.

    if (!pmetalink16->metalink
     && !pmetalink16->cMetaDC16)
    {
        if (!bDeleteMetalink16(hobj))
        {
            ASSERTGDI(FALSE, "LocalFree failed");
        }
    }

// Leave the critical section.

    LEAVECRITICALSECTION(&semLocal);
}

/******************************Public*Routine******************************\
* GdiConvertMetaFilePict
* GdiConvertEnhMetaFile
*
* A server handle is created that is an exact copy of the client
* MetaFilePict or EnhMetaFile data.  The caller (clipbrd) is responsible
* for deleting both the client and server copies when they are no longer
* needed.
*
* A MetaFilePict is a structure containing a metafile size and a handle
* to a metafile.  Both MetaFilePict and EnhMetaFile are used primarily by
* the clipboard interface.  When an app puts a MetaFilePict or an
* EnhMetaFile in the clipboard we have to create a server copy because
* the app can terminate and another application can still query the
* clipboard data.
*
* The format for the client-server data is as follows:
*
*   DWORD iType     MFEN_IDENTIFIER or MFPICT_IDENTIFIER
*   DWORD mm        used by MetaFilePict only
*   DWORD xExt      used by MetaFilePict only
*   DWORD yExt      used by MetaFilePict only
*   DWORD nBytes    number of bytes in pClientData
*   PBYTE pClientData   contains the metafile bits
*
* Returns a server handle that is a copy of the metafile data.
* Returns zero if an error occurs.
*
* History:
*  Wed Sep 16 09:42:22 1992     -by-    Hock San Lee    [hockl]
* Rewrote it.
*  28-Oct-1991   -by-    John Colleran    [johnc]
* Wrote it.
\**************************************************************************/

HANDLE GdiConvertMetaFilePict(HANDLE hmem)
{
    HANDLE      hRet = (HANDLE) 0;
    PMETAFILE16 pmf16;
    LPMETAFILEPICT lpmfp;

    PUTS("GdiConvertMetaFilePict\n");

// Get the METAFILEPICT

    lpmfp = (LPMETAFILEPICT) GlobalLock(hmem);
    if (!lpmfp)
    {
        WARNING("GdiConvertMetaFilePict GlobalLock(hmem) Failed\n");
        return((HANDLE) 0);
    }

    pmf16 = GET_PMF16(lpmfp->hMF);

// Validate the hmf field of the METAFILEPICT

    if (pmf16 == NULL)
    {
        WARNING("GdiConvertMetaFilePict invalid handle\n");
        GdiSetLastError(ERROR_INVALID_HANDLE);
        goto GCMFP_Exit;
    }

// Get the size of the metafile.

    ASSERTGDI(IsValidMetaHeader16(&pmf16->metaHeader),
    "GdiConvertMetaFilePict: Bad metafile");

    hRet = NtGdiCreateServerMetaFile(MFPICT_IDENTIFIER,
        pmf16->metaHeader.mtSize * sizeof(WORD), (PBYTE) pmf16->hMem,
        lpmfp->mm, lpmfp->xExt, lpmfp->yExt);

GCMFP_Exit:
    GlobalUnlock(hmem);
    ERROR_ASSERT(hRet, "GdiConvertMetaFilePict failed\n");
    return(hRet);
}


HANDLE GdiConvertEnhMetaFile(HENHMETAFILE hemf)
{
    HANDLE hRet;
    PMF    pmf;

    PUTS("GdiConvertEnhMetaFile\n");

    if (!(pmf = GET_PMF(hemf)))
    {
        WARNING("GdiConvertEnhMetaFile: bad hemf\n");
        return((HMETAFILE) 0);
    }

    PENHMETAHEADER pmrmf = pmf->emfc.GetEMFHeader();

    if(!pmrmf)
    {
        WARNING("GdiConvertEnhMetaFile: failed getting header\n");
        return((HMETAFILE) 0);
    }

    PBYTE pb = (PBYTE) pmf->emfc.ObtainPtr(0, pmrmf->nBytes);

    if(!pb)
    {
        WARNING("GdiConvertEnhMetaFile: failed getting data\n");
        return((HMETAFILE) 0);
    }

    hRet = NtGdiCreateServerMetaFile(MFEN_IDENTIFIER, pmrmf->nBytes,
            pb, 0, 0, 0);

    pmf->emfc.ReleasePtr(pb);

    ERROR_ASSERT(hRet, "GdiConvertEnhMetaFile failed");
    return((HMETAFILE) hRet);
}


/******************************Public*Routine******************************\
* GdiCreateLocalMetaFilePict
* GdiCreateLocalEnhMetaFile
*
* Creates a local MetaFilePict or EnhMetaFile handle that is a copy of
* the server handle.  The server handle can be either a standard metafile
* or an enhanced metafile.  The functions will perform metafile conversion
* to the requested format (MetaFilePict or EnhMetaFile) if necessary.
*
* The caller is responsible for deleting the local handle when it is no
* longer needed.  By Windows convention the app that recieves the
* MetaFilePict will delete it by first deleting the metafile and then
* freeing the global handle
*
* The format for the client-server data is as follows:
*
*   HANDLE hSrv         server handle (can be standard or enhanced metafile)
*   DWORD  iType        return MFPICT_IDENTIFIER or MFEN_IDENTIFIER
*   DWORD  mm           return by MetaFilePict only
*   DWORD  xExt         return by MetaFilePict only
*   DWORD  yExt         return by MetaFilePict only
*   DWORD  nBytes       zero to query size of metafile bits in pClientData.
*           otherwise it is the size of pClientData that is to
*           receive the metafile bits.
*   PBYTE  pClientData  to receive the metafile bits
*
* Returns a client MetaFilePict or EnhMetaFile handle that is a copy of
* the server metafile.  Returns zero if an error occurs
*
* History:
*  Wed Sep 16 09:42:22 1992     -by-    Hock San Lee    [hockl]
* Rewrote it.
*  28-Oct-1991   -by-    John Colleran    [johnc]
* Wrote it.
\**************************************************************************/


HANDLE GdiCreateLocalMetaFilePict(HANDLE hSrv)
{
    return(InternalCreateLocalMetaFile(hSrv, MFPICT_IDENTIFIER));
}


HENHMETAFILE GdiCreateLocalEnhMetaFile(HANDLE hSrv)
{
    return((HENHMETAFILE) InternalCreateLocalMetaFile((HANDLE) hSrv, MFEN_IDENTIFIER));
}


ULONG GetServerMetaFileBits(HANDLE hSrv, DWORD nBytes, PBYTE pMFBits,
    PDWORD piType, PDWORD pmm, PDWORD pxExt, PDWORD pyExt)
{
    ULONG cRet = 0;

    PUTS("GetServerMetaFileBits\n");

    cRet = NtGdiGetServerMetaFileBits(
                                      hSrv,
                                      (ULONG)nBytes,
                                      (LPBYTE)pMFBits,
                                      piType,
                                      pmm,
                                      pxExt,
                                      pyExt);

    return(cRet);
}


HANDLE InternalCreateLocalMetaFile(HANDLE hSrv, DWORD iTypeReq)
{
    DWORD  iTypeSrv;
    DWORD  mm;
    DWORD  xExt;
    DWORD  yExt;
    ULONG  cbData;
    PBYTE          pData = (PBYTE) NULL;
    LPMETAFILEPICT lpmfp = (LPMETAFILEPICT) NULL;
    HANDLE     hRet  = (HANDLE) 0;

    ASSERTGDI(iTypeReq == MFEN_IDENTIFIER || iTypeReq == MFPICT_IDENTIFIER,
    "InternalCreateLocalMetaFile: bad metafile type\n");

    if (!hSrv)
    {
        VERIFYGDI(FALSE, "InternalCreateLocalMetaFile: hSrv is 0");
        return((HANDLE) 0);
    }

// Get the size of the server metafile bits.

    cbData = GetServerMetaFileBits(hSrv, 0, (PBYTE) NULL, (PDWORD) NULL,
                                   (PDWORD) NULL, (PDWORD) NULL, (PDWORD) NULL);
    if (!cbData)
    {
        ASSERTGDI(FALSE, "InternalCreateLocalMetaFile: size query failed");
        return((HANDLE) 0);
    }

// Allocate a buffer to retrieve the metafile bits.

    pData = (PBYTE) LocalAlloc(LMEM_FIXED, (UINT) cbData);
    if (!pData)
        return((HANDLE) 0);

// Retrieve the server metafile bits.

    if (GetServerMetaFileBits(hSrv, cbData, pData, &iTypeSrv, &mm, &xExt, &yExt)
    != cbData)
    {
        ASSERTGDI(FALSE, "InternalCreateLocalMetaFile: not all data returned");
        goto ICLMF_exit;
    }

// Allocate the MetaFilePict structure if necessary.

    if (iTypeReq == MFPICT_IDENTIFIER)
    {
    lpmfp = (LPMETAFILEPICT) GlobalAlloc(GMEM_FIXED, sizeof(METAFILEPICT));
    if (!lpmfp)
    {
        VERIFYGDI(FALSE, "InternalCreateLocalMetaFile: GlobalAlloc failed\n");
        goto ICLMF_exit;
    }
    }

// Create the same type of metafile as requested.

    switch (iTypeSrv)
    {
    case MFEN_IDENTIFIER:
        if (iTypeReq == MFPICT_IDENTIFIER)
        {
            UINT   cbMeta16;
            LPBYTE lpMeta16;
            HDC    hdcICScreen;
            HENHMETAFILE   hemf;
            PENHMETAHEADER pEMH = (PENHMETAHEADER) pData;

            PUTS("InternalCreateLocalMetaFile: EMF -> MFPICT\n");

            lpmfp->mm   = MM_ANISOTROPIC;
            lpmfp->xExt = (DWORD) (pEMH->rclFrame.right  - pEMH->rclFrame.left);
            lpmfp->yExt = (DWORD) (pEMH->rclFrame.bottom - pEMH->rclFrame.top );

            if (hemf = SetEnhMetaFileBitsAlt((HLOCAL) pData, NULL, NULL, 0))
                pData = (PBYTE) NULL;   // pData has been moved to the metafile
            else
                VERIFYGDI(hemf, "InternalCreateLocalMetaFile: SetEnhMetaFileBitsAlt failed");

            hdcICScreen = CreateICA((LPCSTR)"DISPLAY", (LPCSTR)NULL,
                                    (LPCSTR)NULL, (LPDEVMODEA)NULL);
            VERIFYGDI(hdcICScreen, "InternalCreateLocalMetaFile: CreateICA failed");

            cbMeta16 = GetWinMetaFileBits(hemf, 0, (LPBYTE) NULL,
            MM_ANISOTROPIC, hdcICScreen);
            if (cbMeta16)
            {
                lpMeta16 = (PBYTE) LocalAlloc(LMEM_FIXED, cbMeta16);

                if (lpMeta16)
                {
                    if ((GetWinMetaFileBits(hemf, cbMeta16, lpMeta16, MM_ANISOTROPIC, hdcICScreen)
                        != cbMeta16)
                        // use the memory handle for the metafile!
                        || !(lpmfp->hMF = SetMetaFileBitsAlt((HLOCAL) lpMeta16)))
                    {
                        VERIFYGDI(FALSE, "InternalCreateLocalMetaFile: SetMetaFileBitsAlt failed");
                        LocalFree((HANDLE) lpMeta16);
                    }
                    else
                        hRet = (HANDLE) lpmfp;
                }
            }

            DeleteEnhMetaFile(hemf);
                DeleteDC(hdcICScreen);
        }
        else
        {
            PUTS("InternalCreateLocalMetaFile: EMF -> EMF\n");

            if (hRet = (HANDLE) SetEnhMetaFileBitsAlt((HLOCAL) pData, NULL, NULL, 0))
                pData = (PBYTE) NULL;   // pData has been moved to the metafile
            else
            {
                VERIFYGDI(FALSE, "InternalCreateLocalMetaFile: SetEnhMetaFileBitsAlt failed");
            }
        }
        break;

    case MFPICT_IDENTIFIER:
        if (iTypeReq == MFPICT_IDENTIFIER)
        {
            PUTS("InternalCreateLocalMetaFile: MFPICT -> MFPICT\n");

            lpmfp->mm   = mm;
            lpmfp->xExt = xExt;
            lpmfp->yExt = yExt;

            if (lpmfp->hMF = SetMetaFileBitsAlt((HLOCAL) pData))
            {
                pData = (PBYTE) NULL;   // pData has been moved to the metafile
                hRet  = (HANDLE) lpmfp;
            }
            else
                VERIFYGDI(FALSE, "InternalCreateLocalMetaFile: SetMetaFileBitsAlt failed");
        }
        else
        {
            METAFILEPICT mfp;

            PUTS("InternalCreateLocalMetaFile: MFPICT -> EMF\n");

            mfp.mm   = mm;
            mfp.xExt = xExt;
            mfp.yExt = yExt;
            mfp.hMF  = (HMETAFILE) 0;

            hRet = (HANDLE) SetWinMetaFileBits((UINT) cbData, pData, (HDC) 0, &mfp);
            VERIFYGDI(hRet, "InternalCreateLocalMetaFile: SetWinMetaFileBits failed");
        }
        break;

    default:
        ASSERTGDI(FALSE, "InternalCreateLocalMetaFile unknown metafile type\n");
        break;
    }

// Cleanup if we failed

ICLMF_exit:
    if (!hRet && lpmfp)
    {
        if (GlobalFree((HANDLE) lpmfp))
        {
            ASSERTGDI(FALSE, "InternalCreateLocalMetaFile: GlobalFree failed");
        }
    }

    if (pData)
    {
        LocalFree((HANDLE) pData);
    }

    ERROR_ASSERT(hRet, "InternalCreateLocalMetaFile failed");
    return(hRet);
}

/******************************Public*Routine******************************\
* GetRandomRgnBounds
*
* Wrote it.
*  Fri Jul 24 09:35:24 1992     -by-    Hock San Lee    [hockl]
\**************************************************************************/

BOOL APIENTRY GetRandomRgnBounds(HDC hdc,PRECTL prcl,INT iType)
{
    BOOL  bRet = FALSE;
    HRGN  hrgnTmp;

// We should be able to get the region handle without creating a copy!
// Make a copy of the specified clip region.

    if (!(hrgnTmp = CreateRectRgn(0, 0, 0, 0)))
        return(bRet);

    switch (GetRandomRgn(hdc, hrgnTmp, (int) iType))
    {
    case -1:    // error
        WARNING("GetRandomRgn failed");
        break;

    case 0: // no initial clip region
        *prcl = rclInfinity;
        bRet = TRUE;
        break;

    case 1: // has initial clip region
        bRet = (GetRgnBox(hrgnTmp, (LPRECT) prcl) != RGN_ERROR);
        break;
    }

    if (!DeleteObject(hrgnTmp))
    {
        ASSERTGDI(FALSE, "DeleteObject failed");
    }

    return(bRet);
}

/**************************************************************************\
 *
 * misc statistics
 *
\**************************************************************************/

#if DBG

    ULONG gcMetalinks    = 0;
    ULONG gcQueries      = 0;
    ULONG gcQueriesExtra = 0;
    ULONG gcHits         = 0;

    #define INC_QUERIES  (++gcQueries)
    #define INC_QUERIESX (++gcQueries)
    #define INC_HITS     (++gcHits)
    #define INC_LINKS    (++gcMetalinks)
    #define DEC_LINKS    (--gcMetalinks,++gcHits)

    BOOL  gbdbgml = 0;
#else
    #define gbdbgml FALSE

    #define INC_QUERIES
    #define INC_QUERIESX
    #define INC_HITS
    #define INC_LINKS
    #define DEC_LINKS
#endif

/******************************Public*Routine******************************\
* PLINK plinkGet()
*
*   This routine locks semLocal critical section while traversing the table.
*
* History:
*  14-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

PLINK plinkGet(
    HANDLE h
    )
{
    PLINK plink = NULL;

// see if we need to search.  We do a quick test before entering the critical
// section to see if the cache entry is empty.  For cases where the entry is
// not in the cache, the entry will usualy be empty.  We need to recheck the
// value once we are in the critical section to make sure it hasn't gone away

    if (h && aplHash[LINK_HASH_INDEX(h)])
    {
        INC_QUERIES;

        ENTERCRITICALSECTION(&semLocal);

        plink = aplHash[LINK_HASH_INDEX(h)];

        while (plink && DIFFHANDLE(plink->hobj,h))
        {
            INC_QUERIESX;

            plink = plink->plinkNext;
        }

        LEAVECRITICALSECTION(&semLocal);

        if (plink)
        {
            INC_HITS;
        }
    }

#if DBG
    if (gbdbgml)
        DbgPrint("plinkGet(%p) = %p, ihash = %ld\n",
             h,plink,
             LINK_HASH_INDEX(h));
#endif
    return(plink);
}

/******************************Public*Routine******************************\
* PLINK plinkCreate()
*
*   Note that this does not need to grab semLocal.  All callers must already
*   have done that.
*
* History:
*  14-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

PLINK plinkCreate(
    HANDLE h,
    ULONG  ulSize
    )
{
    PLINK plink = (PLINK)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,ulSize);

    if (plink)
    {
        INC_LINKS;

        plink->plinkNext = aplHash[LINK_HASH_INDEX(h)];
        plink->hobj      = h;

        aplHash[LINK_HASH_INDEX(h)] = plink;
    }

#if DBG
    if (gbdbgml)
        DbgPrint("plinkCreate(%p) = %p, ihash = %ld\n",
             h,plink,
             LINK_HASH_INDEX(h));
#endif

    return(plink);
}

/******************************Public*Routine******************************\
* BOOL bDeletelink()
*
*   This routine locks semLocal critical section while traversing the table.
*
* History:
*  14-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL bDeleteLink(
    HANDLE h
    )
{
    BOOL  bSuccess = FALSE;
    PLINK plink    = NULL;

    if (h)
    {
        ENTERCRITICALSECTION(&semLocal);

        plink = aplHash[LINK_HASH_INDEX(h)];

        if (plink)
        {
            INC_QUERIES;

        // see if it is the first on the list.

            if (SAMEHANDLE(plink->hobj,h))
            {
                aplHash[LINK_HASH_INDEX(h)] = plink->plinkNext;
                bSuccess = TRUE;
                DEC_LINKS;
            }
            else
            {
            // it isn't the first so lets run the list.  We know pmetalink16 is
            // valid and that it is not the element

                while (plink->plinkNext)
                {
                    INC_QUERIESX;

                    if (SAMEHANDLE(plink->plinkNext->hobj,h))
                    {
                        PLINK plinkDel   = plink->plinkNext;
                        plink->plinkNext = plinkDel->plinkNext;

                        plink = plinkDel;  // so we can delete it.
                        bSuccess = TRUE;

                        DEC_LINKS;
                        break;
                    }

                    plink = plink->plinkNext;
                }
            }

        }

        LEAVECRITICALSECTION(&semLocal);

        if (bSuccess)
            LocalFree(plink);
    }
#if DBG
    if (gbdbgml)
        DbgPrint("bDeleteLink(%p) = %p, ihash = %ld\n",
             h,plink,
             LINK_HASH_INDEX(h));
#endif
    return(bSuccess);
}


/******************************Public*Routine******************************\
* PMETALINK16 pmetalink16Resize()
*
*   This routine locks semLocal critical section while traversing the table.
*
* History:
*  14-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

PMETALINK16 pmetalink16Resize(
    HANDLE h,
    int    cObj
    )
{
    PMETALINK16 pmetalink16 = NULL;
    int cj = sizeof(METALINK16) + sizeof(HDC) * (cObj-1);

    if (h)
    {
        ENTERCRITICALSECTION(&semLocal);

        pmetalink16 = (PMETALINK16)aplHash[LINK_HASH_INDEX(h)];

        if (pmetalink16)
        {
            INC_QUERIES;

        // see if it is the first on the list.

            if (SAMEHANDLE(pmetalink16->hobj,h))
            {
                pmetalink16 = (PMETALINK16)LocalReAlloc(pmetalink16,cj,LMEM_MOVEABLE);
                if (pmetalink16)
                    aplHash[LINK_HASH_INDEX(h)] = (PLINK)pmetalink16;
            }
            else
            {
            // it isn't the first so lets run the list.  We know pmetalink16 is
            // valid and that it is not the element

                while (pmetalink16->pmetalink16Next)
                {
                    INC_QUERIESX;

                    if (SAMEHANDLE(pmetalink16->pmetalink16Next->hobj,h))
                    {
                        PMETALINK16 ptmpmetalink16;

                        ptmpmetalink16 = (PMETALINK16)LocalReAlloc(
                                    pmetalink16->pmetalink16Next,cj,LMEM_MOVEABLE);

                        if (ptmpmetalink16)
                        {
                            pmetalink16->pmetalink16Next = ptmpmetalink16;
                            pmetalink16 = pmetalink16->pmetalink16Next;
                        }
                        else
                        {
                            pmetalink16 = ptmpmetalink16;
                        }
                        break;
                    }

                    pmetalink16 = pmetalink16->pmetalink16Next;
                }
            }
        }

        LEAVECRITICALSECTION(&semLocal);
    }

#if DBG
    if (gbdbgml)
        DbgPrint("pmetalink16Resize(%p) = %p, ihash = %ld\n",
             h,pmetalink16,
             aplHash[LINK_HASH_INDEX(h)]);
#endif
    return(pmetalink16);
}

/******************************Public*Routine******************************\
*
* History:
*  03-Aug-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

PMDC pmdcGetFromHdc(
    HDC hdc)
{
    PLDC pldc = pldcGet(hdc);

    return((PMDC)(pldc ? pldc->pvPMDC : NULL));
}

/******************************Public*Routine******************************\
* HANDLE hCreateClientObjLink()
*
*   ClientObjLinks are just associations of a server handle with a client pointer.
*
* History:
*  17-Jan-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HANDLE hCreateClientObjLink(
    PVOID pv,
    ULONG ulType)
{
    HANDLE h = CreateClientObj(ulType);

    if (h)
    {
        PLINK plink;

        ENTERCRITICALSECTION(&semLocal);

        plink = plinkCreate(h,sizeof(LINK));

        LEAVECRITICALSECTION(&semLocal);

        if (plink)
        {
            plink->pv = pv;
        }
        else
        {
            DeleteClientObj(h);
            h = NULL;
        }
    }

#if DBG
    if (gbdbgml)
        DbgPrint("hCreateClientObjLink = %p\n",h);
#endif
    return(h);
}

/******************************Public*Routine******************************\
* PVOID pvClientObjGet()
*
*   Given a handle, find the client pv field of the client object.  The GRE
*   type of the handle will be CLIENTOBJ_TYPE.
*
* History:
*  18-Jan-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

PVOID pvClientObjGet(
    HANDLE h,
    DWORD  dwLoType)
{
    if (LO_TYPE(h) == dwLoType)
    {
        PLINK plink = plinkGet(h);

    #if DBG
        if (gbdbgml)
            DbgPrint("pvClientObjGet(%p) = %p\n",h,plink ? plink->pv : NULL);
    #endif

        if (plink)
        {
            return(plink->pv);
        }
    }
    else
    {
        WARNING1("pvClientObjGet (metafile stuff) - invalid handle\n");
    }

    GdiSetLastError(ERROR_INVALID_HANDLE);
    return(NULL);
}

/******************************Public*Routine******************************\
* BOOL bDeleteClientObjLink()
*
*
* History:
*  18-Jan-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL bDeleteClientObjLink(
    HANDLE h)
{
#if DBG
    if (gbdbgml)
        DbgPrint("bDeleteClientObjLink = %p\n",h);
#endif

    if (bDeleteLink(h))
    {
        DeleteClientObj(h);
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\metarec.cxx ===
/******************************Module*Header*******************************\
* Module Name: metarec.cxx
*
* Metafile recording functions.
*
* Created: 12-June-1991 13:46:00
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1991-1999 Microsoft Corporation
\**************************************************************************/
#define NO_STRICT

extern "C" {
#if defined(_GDIPLUS_)
#include    <gpprefix.h>
#endif

#include    <nt.h>
#include    <ntrtl.h>
#include    <nturtl.h>
#include    <stddef.h>
#include    <windows.h>    // GDI function declarations.
#include    <winerror.h>
#include    "firewall.h"
#define __CPLUSPLUS
#include    <winspool.h>
#include    <w32gdip.h>
#include    "ntgdistr.h"
#include    "winddi.h"
#include    "icm.h"
#include    "hmgshare.h"
#include    "local.h"      // Local object support.
#include    "gdiicm.h"
#include    "font.h"
#include    "metadef.h"    // Metafile record type constants.
#include    "metarec.h"    // Metafile recording functions.
#include    "mf16.h"
#include    "nlsconv.h"
#include    "ntgdi.h"
#include    "xfflags.h"
#include "..\inc\mapfile.h"
}

#include    "rectl.hxx"
#include    "mfdc.hxx"  // Metafile DC class declarations.
#include    "mfrec.hxx" // Metafile record class declarations.
extern "C" {
#include    "mfrec16.h" // 3.x Metafile recording functions
}

extern "C" BOOL bDoFontChange(HDC hdc, WCHAR *pwsz, int c, UINT fl);
extern "C" BOOL bRecordEmbedFonts(HDC hdc);

XFORM xformIdentity = { 1.00000000f, 0.00000000f, 0.00000000f, 1.00000000f,
                        0.00000000f, 0.00000000f };

#ifdef LANGPACK
extern LONG gdwDisableMetafileRec ;
#endif

// SaveDC
// BeginPath
// EndPath
// CloseFigure
// FlattenPath
// WidenPath
// AbortPath
// SetMetaRgn
// RealizePalette

extern "C" BOOL MF_Record(HDC hdc,DWORD mrType)
{
    PMR     pmr;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_Record\n");

    if (!(pmr = (PMR) pmdc->pvNewRecord(SIZEOF_MR)))
        return(FALSE);

    pmr->vInit(mrType);
    pmr->vCommit(pmdc);
    return(TRUE);
}

// FillPath
// StrokeAndFillPath
// StrokePath

extern "C" BOOL MF_BoundRecord(HDC hdc,DWORD mrType)
{
    PMRB    pmrb;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");


    PUTS("MF_BoundRecord\n");

    if (!(pmrb = (PMRB) pmdc->pvNewRecord(SIZEOF_MRB)))
        return(FALSE);

    pmrb->vInit(mrType, pmdc);
    pmrb->vCommit(pmdc);
    return(TRUE);
}

// SetMapperFlags
// SetMapMode
// SetBkMode
// SetPolyFillMode
// SetROP2
// SetStretchBltMode
// SetTextAlign
// SetTextColor
// SetBkColor
// RestoreDC
// SetArcDirection
// SetMiterLimit
// SelectClipPath
// SetLayout

extern "C" BOOL MF_SetD(HDC hdc,DWORD d1,DWORD mrType)
{
    PMRD    pmrd;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_SetD\n");

    if( ( mrType == EMR_SETMAPMODE ) ||
        ( mrType == EMR_SETMAPPERFLAGS ) ||
        ( mrType == EMR_SETLAYOUT ) ||
        ( mrType == EMR_RESTOREDC  ) )
    {
        pldc->fl |= LDC_FONT_CHANGE;
    }

    if (!(pmrd = (PMRD) pmdc->pvNewRecord(SIZEOF_MRD)))
        return(FALSE);

    pmrd->vInit(mrType, d1);
    pmrd->vCommit(pmdc);
    return(TRUE);
}

// OffsetWindowOrgEx
// OffsetViewportOrgEx
// SetWindowExtEx
// SetWindowOrgEx
// SetViewportExtEx
// SetViewportOrgEx
// SetBrushOrgEx
// OffsetClipRgn
// MoveToEx
// LineTo
// SetTextJustification

extern "C" BOOL MF_SetDD(HDC hdc,DWORD d1,DWORD d2,DWORD mrType)
{
    PMRDD   pmrdd;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_SetDD\n");

    if( ( mrType == EMR_SETVIEWPORTEXTEX ) || ( mrType == EMR_SETWINDOWEXTEX ) )
    {
        pldc->fl |= LDC_FONT_CHANGE;
    }

    if (!(pmrdd = (PMRDD) pmdc->pvNewRecord(SIZEOF_MRDD)))
        return(FALSE);

    pmrdd->vInit(mrType, d1, d2);
    pmrdd->vCommit(pmdc);
    return(TRUE);
}

// ExcludeClipRect
// IntersectClipRect
// ScaleViewportExtEx
// ScaleWindowExtEx

extern "C" BOOL MF_SetDDDD(HDC hdc,DWORD d1,DWORD d2,DWORD d3,DWORD d4,DWORD mrType)
{
    PMRDDDD pmrdddd;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_SetDDDD\n");

    if( ( mrType == EMR_SCALEVIEWPORTEXTEX ) || ( mrType == EMR_SCALEWINDOWEXTEX ) )
    {
        pldc->fl |= LDC_FONT_CHANGE;
    }

    if (!(pmrdddd = (PMRDDDD) pmdc->pvNewRecord(SIZEOF_MRDDDD)))
        return(FALSE);

    pmrdddd->vInit(mrType, d1, d2, d3, d4);
    pmrdddd->vCommit(pmdc);
    return(TRUE);
}

// SetMetaRgn

extern "C" BOOL MF_SetMetaRgn(HDC hdc)
{
    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_SetMetaRgn\n");

// Record it first.

    if (!MF_Record(hdc,EMR_SETMETARGN))
        return(FALSE);

// We have to flush the bounds before we change the clipping region
// because the bounds are clipped to the current clipping region bounds.

    pmdc->vFlushBounds();

// Now update the clipping bounds to prepare for the next flush.

    pmdc->vSetMetaBounds();

    return(TRUE);
}

// SelectClipPath

extern "C" BOOL MF_SelectClipPath(HDC hdc,int iMode)
{
    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_SelectClipPath\n");

// Record it first.

    if (!MF_SetD(hdc, (DWORD) iMode, EMR_SELECTCLIPPATH))
        return(FALSE);

// We have to flush the bounds before we change the clipping region
// because the bounds are clipped to the current clipping region bounds.

    pmdc->vFlushBounds();

// Now mark the clipping bounds dirty.  The clipping bounds is updated
// when it is needed.

    pmdc->vMarkClipBoundsDirty();

    return(TRUE);
}

// OffsetClipRgn

extern "C" BOOL MF_OffsetClipRgn(HDC hdc,int x1,int y1)
{
    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_OffsetClipRgn\n");

// Record it first.

    if (!MF_SetDD(hdc, (DWORD) x1, (DWORD) y1, EMR_OFFSETCLIPRGN))
        return(FALSE);

// We have to flush the bounds before we change the clipping region
// because the bounds are clipped to the current clipping region bounds.

    pmdc->vFlushBounds();

// Now mark the clipping bounds dirty.  The clipping bounds is updated
// when it is needed.

    pmdc->vMarkClipBoundsDirty();

    return(TRUE);
}

// ExcludeClipRect
// IntersectClipRect

extern "C" BOOL MF_AnyClipRect(HDC hdc,int x1,int y1,int x2,int y2,DWORD mrType)
{
    BOOL    bRet = FALSE;
    HRGN    hrgnTmp;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_AnyClipRect\n");

// Record it first.

    if (!MF_SetDDDD(hdc, (DWORD) x1, (DWORD) y1, (DWORD) x2, (DWORD) y2, mrType))
        return(bRet);

// We have to flush the bounds before we change the clipping region
// because the bounds are clipped to the current clipping region bounds.

    pmdc->vFlushBounds();

// Now mark the clipping bounds dirty.  The clipping bounds is updated
// when it is needed.

    pmdc->vMarkClipBoundsDirty();

// For ExcludeClipRect and InteresectClipRect, this is a little tricky.
// If there is no initial clip region, we have to create a default clipping
// region.  Otherwise, GDI will create some random default clipping region
// for us!

// Find out if we have a clip region.

    if (!(hrgnTmp = CreateRectRgn(0, 0, 0, 0)))
        return(bRet);

    switch (GetClipRgn(hdc, hrgnTmp))
    {
    case -1:    // error
        ASSERTGDI(FALSE, "GetClipRgn failed");
        break;

    case 0:     // no initial clip region
        // We need to select in our default clipping region.
        // First, make our default clipping region.

        if (!SetRectRgn(hrgnTmp,
                        (int) (SHORT) MINSHORT,
                        (int) (SHORT) MINSHORT,
                        (int) (SHORT) MAXSHORT,
                        (int) (SHORT) MAXSHORT))
        {
            ASSERTGDI(FALSE, "SetRectRgn failed");
            break;
        }

        // Now select our default region but don't metafile the call.

        {
            INT iRet;

            iRet = NtGdiExtSelectClipRgn(hdc, hrgnTmp, RGN_COPY);

            bRet = (iRet != RGN_ERROR);

        }
        break;

    case 1:     // has initial clip region
        bRet = TRUE;
        break;
    }

    if (!DeleteObject(hrgnTmp))
    {
        ASSERTGDI(FALSE, "DeleteObject failed");
    }

    return(bRet);
}

// Always store the relative level.

extern "C" BOOL MF_RestoreDC(HDC hdc,int iLevel)
{
    int cLevel = (int) GetDCDWord(hdc,DDW_SAVEDEPTH,0);

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

// Compute the relative level.

    if (iLevel > 0)
    {
        iLevel = iLevel - cLevel;
    }

// Check bad levels.

    if ((iLevel >= 0) || (iLevel + cLevel <= 0))
        return(FALSE);

    if (!MF_SetD(hdc,(DWORD)iLevel,EMR_RESTOREDC))
        return(FALSE);

// We have to flush the bounds before we change the clipping region
// because the bounds are clipped to the current clipping region bounds.

    pmdc->vFlushBounds();

// Now mark the clipping bounds dirty.  The clipping bounds is updated
// when it is needed.

    pmdc->vMarkClipBoundsDirty();
    pmdc->vMarkMetaBoundsDirty();

    return(TRUE);
}

extern "C" BOOL MF_SetViewportExtEx(HDC hdc,int x,int y)
{
    return(MF_SetDD(hdc,(DWORD)x,(DWORD)y,EMR_SETVIEWPORTEXTEX));
}

extern "C" BOOL MF_SetViewportOrgEx(HDC hdc,int x,int y)
{
    return(MF_SetDD(hdc,(DWORD)x,(DWORD)y,EMR_SETVIEWPORTORGEX));
}

extern "C" BOOL MF_SetWindowExtEx(HDC hdc,int x,int y)
{
    return(MF_SetDD(hdc,(DWORD)x,(DWORD)y,EMR_SETWINDOWEXTEX));
}

extern "C" BOOL MF_SetWindowOrgEx(HDC hdc,int x,int y)
{
    return(MF_SetDD(hdc,(DWORD)x,(DWORD)y,EMR_SETWINDOWORGEX));
}

// Map it to SetViewportOrgEx record.

extern "C" BOOL MF_OffsetViewportOrgEx(HDC hdc,int x,int y)
{
    POINTL ptl;

    if (!GetViewportOrgEx(hdc, (LPPOINT) &ptl))
        return(FALSE);
    return
        (
        MF_SetDD
            (
            hdc,
            (DWORD)(ptl.x + (LONG) x),
            (DWORD)(ptl.y + (LONG) y),
            EMR_SETVIEWPORTORGEX
            )
        );
}

// Map it to SetWindowOrgEx record.

extern "C" BOOL MF_OffsetWindowOrgEx(HDC hdc,int x,int y)
{
    POINTL ptl;

    if (!GetWindowOrgEx(hdc, (LPPOINT) &ptl))
        return(FALSE);
    return
        (
        MF_SetDD
            (
            hdc,
            (DWORD) (ptl.x + (LONG) x),
            (DWORD) (ptl.y + (LONG) y),
            EMR_SETWINDOWORGEX
            )
        );
}

extern "C" BOOL MF_SetBrushOrgEx(HDC hdc,int x,int y)
{
    return(MF_SetDD(hdc,(DWORD)x,(DWORD)y,EMR_SETBRUSHORGEX));
}

// PolyBezier
// Polygon
// Polyline
// PolyBezierTo
// PolylineTo

extern "C" BOOL MF_Poly(HDC hdc, CONST POINT *pptl,DWORD cptl,DWORD mrType)
{
    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_Poly\n");

// Check input assumptions.

    ASSERTGDI
    (
        mrType == EMR_POLYBEZIER
     || mrType == EMR_POLYGON
     || mrType == EMR_POLYLINE
     || mrType == EMR_POLYBEZIERTO
     || mrType == EMR_POLYLINETO,
        "MF_Poly: Bad record type"
    );

    ASSERTGDI
    (
        EMR_POLYGON - EMR_POLYBEZIER == EMR_POLYGON16 - EMR_POLYBEZIER16
     && EMR_POLYLINE - EMR_POLYBEZIER == EMR_POLYLINE16 - EMR_POLYBEZIER16
     && EMR_POLYBEZIERTO - EMR_POLYBEZIER == EMR_POLYBEZIERTO16 - EMR_POLYBEZIER16
     && EMR_POLYLINETO - EMR_POLYBEZIER == EMR_POLYLINETO16 - EMR_POLYBEZIER16,
        "MF_Poly: Bad record type"
    );

// Store 16-bit record if possible.

    if (bIsPoly16((PPOINTL) pptl, cptl))
    {
        PMRBP16 pmrbp16;

        if (!(pmrbp16 = (PMRBP16) pmdc->pvNewRecord(SIZEOF_MRBP16(cptl))))
            return(FALSE);

        pmrbp16->vInit
        (
            mrType - EMR_POLYBEZIER + EMR_POLYBEZIER16,
            cptl,
            (PPOINTL) pptl,
            pmdc
        );
        pmrbp16->vCommit(pmdc);
    }
    else
    {
        PMRBP   pmrbp;

        if (!(pmrbp = (PMRBP) pmdc->pvNewRecord(SIZEOF_MRBP(cptl))))
            return(FALSE);

        pmrbp->vInit(mrType, cptl, (PPOINTL) pptl, pmdc);
        pmrbp->vCommit(pmdc);
    }
    return(TRUE);
}

// PolyPolygon
// PolyPolyline

extern "C" BOOL MF_PolyPoly(HDC hdc, CONST POINT *pptl, CONST DWORD *pc,DWORD cPoly,DWORD mrType)
{
    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_PolyPoly\n");

// Check input assumptions.

    ASSERTGDI
    (
        mrType == EMR_POLYPOLYGON
     || mrType == EMR_POLYPOLYLINE,
        "MF_PolyPoly: Bad record type"
    );

    ASSERTGDI
    (
        EMR_POLYPOLYLINE - EMR_POLYPOLYGON == EMR_POLYPOLYLINE16 - EMR_POLYPOLYGON16,
        "MF_Poly: Bad record type"
    );

// Compute the size of the PolyPoly record.

    DWORD cptl = 0;
    for (DWORD i = 0; i < cPoly; i++)
        cptl += pc[i];

// Store 16-bit record if possible.

    if (bIsPoly16((PPOINTL) pptl, cptl))
    {
        PMRBPP16 pmrbpp16;

        if (!(pmrbpp16 = (PMRBPP16) pmdc->pvNewRecord(SIZEOF_MRBPP16(cptl,cPoly))))
            return(FALSE);

        pmrbpp16->vInit
        (
            mrType - EMR_POLYPOLYGON + EMR_POLYPOLYGON16,
            cPoly,
            cptl,
            (LPDWORD) pc,
            (PPOINTL) pptl,
            pmdc
        );
        pmrbpp16->vCommit(pmdc);
    }
    else
    {
        PMRBPP   pmrbpp;

        if (!(pmrbpp = (PMRBPP) pmdc->pvNewRecord(SIZEOF_MRBPP(cptl,cPoly))))
            return(FALSE);

        pmrbpp->vInit(mrType, cPoly, cptl, (LPDWORD) pc, (PPOINTL) pptl, pmdc);
        pmrbpp->vCommit(pmdc);
    }
    return(TRUE);
}


/******************************Public*Routine******************************\
* MF_TriangleMesh
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    12/3/1996 Mark Enstrom [marke]
*
\**************************************************************************/

extern "C" BOOL
MF_GradientFill(
            HDC               hdc,
            CONST PTRIVERTEX  pVertex,
            ULONG             nVertex,
            CONST PVOID       pMesh,
            ULONG             nMesh,
            ULONG             ulMode
            )
{
    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);
    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_TriangleMesh\n");

    PMRGRADIENTFILL pmrtr;

    if (!(pmrtr = (PMRGRADIENTFILL) pmdc->pvNewRecord(SIZEOF_MRGRADIENTFILL(nVertex,nMesh))))
    {
        return(FALSE);
    }

    pmrtr->vInit(nVertex,pVertex,nMesh,pMesh,ulMode,pmdc);
    pmrtr->vCommit(pmdc);

    SET_COLOR_PAGE(pldc);

    return(TRUE);
}

// PolyDraw

extern "C" BOOL MF_PolyDraw(HDC hdc, CONST POINT *pptl, CONST BYTE *pb, DWORD cptl)
{
    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_PolyDraw\n");

// Store 16-bit record if possible.

    if (bIsPoly16((PPOINTL) pptl, cptl))
    {
        PMRPOLYDRAW16   pmrpd16;

        if (!(pmrpd16 = (PMRPOLYDRAW16) pmdc->pvNewRecord(SIZEOF_MRPOLYDRAW16(cptl))))
            return(FALSE);

        pmrpd16->vInit(pmdc, (PPOINTL) pptl, pb, cptl);
        pmrpd16->vCommit(pmdc);
    }
    else
    {
        PMRPOLYDRAW     pmrpd;

        if (!(pmrpd = (PMRPOLYDRAW) pmdc->pvNewRecord(SIZEOF_MRPOLYDRAW(cptl))))
            return(FALSE);

        pmrpd->vInit(pmdc, (PPOINTL) pptl, pb, cptl);
        pmrpd->vCommit(pmdc);
    }
    return(TRUE);
}

// InvertRgn
// PaintRgn

extern "C" BOOL MF_InvertPaintRgn(HDC hdc,HRGN hrgn,DWORD mrType)
{
    PMRBR   pmrbr;
    DWORD   cRgnData;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_InvertPaintRgn\n");

// Get the size of the region data.

    if (!(cRgnData = GetRegionData(hrgn, 0, (LPRGNDATA) NULL)))
        return(FALSE);

// Allocate dword aligned structure.

    if (!(pmrbr = (PMRBR) pmdc->pvNewRecord(SIZEOF_MRBR(cRgnData))))
        return(FALSE);

    if (!pmrbr->bInit(mrType, pmdc, hrgn, cRgnData, sizeof(MRBR)))
        return(FALSE);

    pmrbr->vCommit(pmdc);
    return(TRUE);
}

// FillRgn

extern "C" BOOL MF_FillRgn(HDC hdc,HRGN hrgn,HBRUSH hbrush)
{
    PMRFILLRGN  pmrfr;
    DWORD       cRgnData;
    DWORD       imheBrush;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_FillRgn\n");

// Create the brush first.

    if (!(imheBrush = MF_InternalCreateObject(hdc, hbrush)))
        return(FALSE);

// Get the size of the region data.

    if (!(cRgnData = GetRegionData(hrgn, 0, (LPRGNDATA) NULL)))
        return(FALSE);

// Allocate dword aligned structure.

    if (!(pmrfr = (PMRFILLRGN) pmdc->pvNewRecord(SIZEOF_MRFILLRGN(cRgnData))))
        return(FALSE);

    if (!pmrfr->bInit(pmdc, hrgn, cRgnData, imheBrush))
        return(FALSE);

    pmrfr->vCommit(pmdc);
    return(TRUE);
}

// FrameRgn

extern "C" BOOL MF_FrameRgn(HDC hdc,HRGN hrgn,HBRUSH hbrush,int cx,int cy)
{
    PMRFRAMERGN pmrfr;
    DWORD       cRgnData;
    DWORD       imheBrush;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_FrameRgn\n");

// Create the brush first.

    if (!(imheBrush = MF_InternalCreateObject(hdc, hbrush)))
        return(FALSE);

// Get the size of the region data.

    if (!(cRgnData = GetRegionData(hrgn, 0, (LPRGNDATA) NULL)))
        return(FALSE);

// Allocate dword aligned structure.

    if (!(pmrfr = (PMRFRAMERGN) pmdc->pvNewRecord(SIZEOF_MRFRAMERGN(cRgnData))))
        return(FALSE);

    if (!pmrfr->bInit(pmdc, hrgn, cRgnData, imheBrush, (LONG) cx, (LONG) cy))
        return(FALSE);

    pmrfr->vCommit(pmdc);
    return(TRUE);
}

// SelectClipRgn
// ExtSelectClipRgn
// SelectObject(hdc,hrgn)

extern "C" BOOL MF_ExtSelectClipRgn(HDC hdc,HRGN hrgn,int iMode)
{
    PMREXTSELECTCLIPRGN pmrescr;
    DWORD       cRgnData;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_ExtSelectClipRgn\n");

// Get the size of the region data.

    if (iMode == RGN_COPY && hrgn == (HRGN) 0)
        cRgnData = 0;
    else if (!(cRgnData = GetRegionData(hrgn, 0, (LPRGNDATA) NULL)))
        return(FALSE);

// Allocate dword aligned structure.

    if (!(pmrescr = (PMREXTSELECTCLIPRGN) pmdc->pvNewRecord
                        (SIZEOF_MREXTSELECTCLIPRGN(cRgnData))))
        return(FALSE);

    if (!pmrescr->bInit(hrgn, cRgnData, (DWORD) iMode))
        return(FALSE);

    pmrescr->vCommit(pmdc);

// We have to flush the bounds before we change the clipping region
// because the bounds are clipped to the current clipping region bounds.

    pmdc->vFlushBounds();

// Now mark the clipping bounds dirty.  The clipping bounds is updated
// when it is needed.

    pmdc->vMarkClipBoundsDirty();

    return(TRUE);
}

// SetPixel
// SetPixelV

extern "C" BOOL MF_SetPixelV(HDC hdc,int x,int y,COLORREF color)
{
    PMRSETPIXELV pmrspv;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_SetPixelV\n");

    if (!(pmrspv = (PMRSETPIXELV) pmdc->pvNewRecord(SIZEOF_MRSETPIXELV)))
        return(FALSE);

    pmrspv->vInit(x, y, color);
    pmrspv->vCommit(pmdc);

    CHECK_COLOR_PAGE(pldc,color);

    return(TRUE);
}

// AngleArc

extern "C" BOOL MF_AngleArc(HDC hdc,int x,int y,DWORD r,FLOAT eA,FLOAT eB)
{
    PMRANGLEARC pmraa;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_AngleArc\n");

    if (!(pmraa = (PMRANGLEARC) pmdc->pvNewRecord(SIZEOF_MRANGLEARC)))
        return(FALSE);

    pmraa->vInit(x, y, r, eA, eB);
    pmraa->vCommit(pmdc);
    return(TRUE);
}

// SetArcDirection - This is recorded only when used.


extern "C" BOOL MF_ValidateArcDirection(HDC hdc)
{
    PLDC pldc;
    BOOL bClockwiseMeta, bClockwiseAdvanced;

    DC_PLDC(hdc,pldc,FALSE);

    PUTS("MF_ValidateArcDirection\n");

// Get the current arc direction recorded in the metafile.
// The metafile is recorded in the advanced graphics mode only.

    bClockwiseMeta = (pldc->fl & LDC_META_ARCDIR_CLOCKWISE) ? TRUE : FALSE;

// Get the current arc direction in the advanced graphics mode.

    bClockwiseAdvanced = (GetArcDirection(hdc) == AD_CLOCKWISE);

    if (GetGraphicsMode(hdc) == GM_COMPATIBLE)
    {
        switch (GetMapMode(hdc))
        {
        case MM_LOMETRIC:
        case MM_HIMETRIC:
        case MM_LOENGLISH:
        case MM_HIENGLISH:
        case MM_TWIPS:
            bClockwiseAdvanced = !bClockwiseAdvanced;
            break;

        //
        // If it is MM_ANISOTROPIC and MM_ISOTROPIC
        // and negative transform, we flip the arc direction.
        // related bugs - 3026, 74010 [lingyunw]
        //
        case MM_ANISOTROPIC:
        case MM_ISOTROPIC:
            {
               PDC_ATTR pDcAttr;
               PVOID  pvUser;

               PSHARED_GET_VALIDATE(pvUser,hdc,DC_TYPE);

               if (pvUser)
               {
                  pDcAttr = (PDC_ATTR)pvUser;

                  //
                  // if the xform has changed, we call to the kernel
                  // to update it
                  //
                  if(pDcAttr->flXform &
                     (PAGE_XLATE_CHANGED | PAGE_EXTENTS_CHANGED | WORLD_XFORM_CHANGED))
                  {
                      if (!NtGdiUpdateTransform(hdc))
                          return(FALSE);
                  };

                  if (((pDcAttr->flXform & PTOD_EFM11_NEGATIVE) != 0) ^
                       ((pDcAttr->flXform & PTOD_EFM22_NEGATIVE) != 0))
                  {
                      bClockwiseAdvanced = !bClockwiseAdvanced;
                  }
               }
            }
            break;
        }
    }

// Record it only if the new arc direction differs from the recorded one.

    if (bClockwiseMeta == bClockwiseAdvanced)
        return(TRUE);

    pldc->fl ^= LDC_META_ARCDIR_CLOCKWISE;

    return
    (
        MF_SetD
        (
            hdc,
            (DWORD) (bClockwiseAdvanced ? AD_CLOCKWISE : AD_COUNTERCLOCKWISE),
            EMR_SETARCDIRECTION
        )
    );
}


// Ellipse
// Rectangle

extern "C" BOOL MF_EllipseRect(HDC hdc,int x1,int y1,int x2,int y2,DWORD mrType)
{
    PMRE  pmre;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_EllipseRect\n");

// Validate the arc direction in the metafile first.

    if (!MF_ValidateArcDirection(hdc))
        return(FALSE);

    if (!(pmre = (PMRE) pmdc->pvNewRecord(SIZEOF_MRE)))
        return(FALSE);

// If the box is empty, don't record it and return success.

    switch (pmre->iInit(mrType, hdc, x1, y1, x2, y2))
    {
    case MRI_ERROR:     return(FALSE);
    case MRI_NULLBOX:   return(TRUE);
    case MRI_OK:        break;
    default:            ASSERTGDI(FALSE, "MRE::iInit returned bad value");
                        break;
    }

    pmre->vCommit(pmdc);
    return(TRUE);
}

// RoundRect

extern "C" BOOL MF_RoundRect(HDC hdc,int x1,int y1,int x2,int y2,int x3,int y3)
{
    PMRROUNDRECT pmrrr;

    PUTS("MF_RoundRect\n");

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

// Validate the arc direction in the metafile first.

    if (!MF_ValidateArcDirection(hdc))
        return(FALSE);

    if (!(pmrrr = (PMRROUNDRECT) pmdc->pvNewRecord(SIZEOF_MRROUNDRECT)))
        return(FALSE);

// If the box is empty, don't record it and return success.

    switch (pmrrr->iInit(hdc, x1, y1, x2, y2, x3, y3))
    {
    case MRI_ERROR:     return(FALSE);
    case MRI_NULLBOX:   return(TRUE);
    case MRI_OK:        break;
    default:            ASSERTGDI(FALSE, "MRROUNDRECT::iInit returned bad value");
                        break;
    }

    pmrrr->vCommit(pmdc);
    return(TRUE);
}

// Arc
// ArcTo
// Chord
// Pie

extern "C" BOOL MF_ArcChordPie(HDC hdc,int x1,int y1,int x2,int y2,int x3,int y3,int x4,int y4,DWORD mrType)
{
    PMREPP  pmrepp;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_ArcChordPie\n");

// Validate the arc direction in the metafile first.

    if (!MF_ValidateArcDirection(hdc))
        return(FALSE);


    if (!(pmrepp = (PMREPP) pmdc->pvNewRecord(SIZEOF_MREPP)))
        return(FALSE);

// If the box is empty, don't record it and return success.

    switch (pmrepp->iInit(mrType, hdc, x1, y1, x2, y2, x3, y3, x4, y4))
    {
    case MRI_ERROR:     return(FALSE);
    case MRI_NULLBOX:   return(TRUE);
    case MRI_OK:        break;
    default:            ASSERTGDI(FALSE, "MREPP::iInit returned bad value");
                        break;
    }

    pmrepp->vCommit(pmdc);
    return(TRUE);
}

// SetWorldTransform

extern "C" BOOL MF_SetWorldTransform(HDC hdc, CONST XFORM *pxform)
{
    PMRX    pmrx;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_SetWorldTransform\n");

    pldc->fl |= LDC_FONT_CHANGE;

    if (!(pmrx = (PMRX) pmdc->pvNewRecord(SIZEOF_MRX)))
        return(FALSE);

    pmrx->vInit(EMR_SETWORLDTRANSFORM, *pxform);
    pmrx->vCommit(pmdc);
    return(TRUE);
}

// ModifyWorldTransform

extern "C" BOOL MF_ModifyWorldTransform(HDC hdc, CONST XFORM *pxform, DWORD iMode)
{
    PMRXD   pmrxd;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_ModifyWorldTransform\n");

    pldc->fl |= LDC_FONT_CHANGE;

    if (!(pmrxd = (PMRXD) pmdc->pvNewRecord(SIZEOF_MRXD)))
        return(FALSE);

// If the mode is set to identity transform, use our identity transform
// since there may not be an input transform.

    pmrxd->vInit
        (
        EMR_MODIFYWORLDTRANSFORM,
        (iMode == MWT_IDENTITY) ? xformIdentity : *pxform,
        iMode
        );
    pmrxd->vCommit(pmdc);
    return(TRUE);
}

// SelectObject
// SelectPalette

extern "C" BOOL MF_SelectAnyObject(HDC hdc,HANDLE h,DWORD mrType)
{
    DWORD   imhe;

#ifdef LANGPACK
    if(gbLpk && gdwDisableMetafileRec)   // if there is alangpack, then don't record this (since we are in the middle of an exttextout call)
    {
        ASSERTGDI(LO_TYPE(h) == LO_FONT_TYPE, "gdwDisableMetafileRec\n");

        return TRUE ;
    }
#endif

// Do not do regions.  Region call goes to ExtSelectClipRgn.
// Do not do bitmap.  Metafile DC is not a memory device.
// MF_InternalCreateObject will return an error if given a bitmap handle.

    PUTS("MF_SelectAnyObject\n");

    // we need to set the DCBrush and DCPen here if they are selected

    if ((h == ghbrDCBrush) || (h == ghbrDCPen))
    {
        PVOID p;
        PDC_ATTR pDcAttr;

        PSHARED_GET_VALIDATE(p,hdc,DC_TYPE);

        pDcAttr = (PDC_ATTR)p;

        if (pDcAttr)
        {
            if (h == ghbrDCBrush)
            {
                if (pDcAttr->ulDCBrushClr != CLR_INVALID)
                {
                // Dont know why they were creating a new brush. ghbrDCBrush is a stock object and can be used as such.
                //    h = (HANDLE) CreateSolidBrush (pDcAttr->ulDCBrushClr);
                }
                else
                {
                    return (FALSE);
                }
            }

            if (h == ghbrDCPen)
            {
                if (pDcAttr->ulDCPenClr != CLR_INVALID)
                {
                // Dont know why they were creating a new brush. ghbrDCPen is a stock object and can be used as such. 
                //    h = (HANDLE) CreatePen (PS_SOLID, 0, pDcAttr->ulDCPenClr);
                }
                else
                {
                    return (FALSE);
                }
            }

            if (h == NULL)
            {
                return (FALSE);
            }
        }
    }

    if (!(imhe = MF_InternalCreateObject(hdc, h)))
        return(FALSE);

    return(MF_SetD(hdc, imhe, mrType));
}

// CreatePen
// CreatePenIndirect
// ExtCreatePen
// CreateBrushIndirect
// CreateDIBPatternBrush
// CreateDIBPatternBrushPt
// CreateHatchBrush
// CreatePatternBrush
// CreateSolidBrush
// CreatePalette
// CreateFont
// CreateFontIndirect
// CreateColorSpace

// Create an object if it does not exist.  The object must not be a region.
// It also does not create bitmap objects since we keep them in the drawing
// records.
// Return the metafile handle index of the object.  For stock objects,
// return the special object index.
// Return 0 on error.

DWORD MF_InternalCreateObject(HDC hdc,HANDLE hobj)
{
    DWORD   imhe;
    UINT    ii;
    int     iType;
    int     iRet;
    LOGBRUSH lb;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_InternalCreateObject\n");

    if (hobj == NULL)
    {
        return(0);
    }

// Do not do bitmaps.  We don't keep bitmap handles in metafiles.

    iType = LO_TYPE(hobj);

    if ((iType == LO_BITMAP_TYPE) || (iType == LO_DIBSECTION_TYPE))
    {
        ERROR_ASSERT(FALSE,
            "MF_InternalCreateObject: Cannot select bitmap into an enhanced metafile DC");
        return(0);
    }

// Do not do regions.  Regions are stored in the drawing records.

    ASSERTGDI(iType != LO_REGION_TYPE,
        "MF_InternalCreateObject: Bad object type");

// If this is a stock object, just return a special object index.

    if (IS_STOCKOBJ(hobj))
    {
        for (ii = 0; ii <= STOCK_LAST; ii++)
        {
            if (GetStockObject(ii) == hobj)
            {
                if (iType == LO_FONT_TYPE)
                {
                    pldc->fl |= LDC_FONT_CHANGE;
                }
                break;
            }
        }
        return((DWORD) ENHMETA_STOCK_OBJECT + ii);
    }

// Check if the metafile DC knows this object.

    METALINK metalink(pmetalink16Get(hobj));

    while (metalink.bValid() && (metalink.ihdc != H_INDEX(hdc)))
        metalink.vNext();

// If the metafile DC knows this object, just return the metafile handle index.

    if (metalink.bValid())
    {
        if( iType == LO_FONT_TYPE )
        {
            pldc->fl |= LDC_FONT_CHANGE;
        }
        return((DWORD) metalink.imhe);
    }

// Create the object.

    DWORD ulRet = 0;            // Assume failure

// Allocate a metafile handle entry and update the metalink.

    if ((imhe = imheAllocMHE(hdc, hobj)) == INVALID_INDEX)
        return(ulRet);

    switch (iType)
    {
// Do brush.

    case LO_BRUSH_TYPE:

        iRet = GetObject(hobj,sizeof(lb),&lb);

        // Stock objects is handled above.

        ASSERTGDI(iRet,"MF_InternalCreateObject: Brush error");

        switch (lb.lbStyle)
        {
        case BS_HATCHED:
        case BS_SOLID:
            CHECK_COLOR_PAGE (pldc,lb.lbColor);
        case BS_HOLLOW:

            PMRCREATEBRUSHINDIRECT  pmrcbi;

            if (!(pmrcbi = (PMRCREATEBRUSHINDIRECT) pmdc->pvNewRecord
                                (SIZEOF_MRCREATEBRUSHINDIRECT)))
                break;

            pmrcbi->vInit(imhe, lb);
            pmrcbi->vCommit(pmdc);
            ulRet = imhe;
        break;

        case BS_PATTERN:
        case BS_DIBPATTERN:
        case BS_DIBPATTERNPT:

            {
                UINT    iUsage;
                HBITMAP hbmRemote;
                BMIH    bmih;
                DWORD   cbBitsInfo;
                DWORD   cbBits;
                BOOL    bMonoBrush = FALSE;

                if (!(hbmRemote = GetObjectBitmapHandle((HBRUSH)hobj, &iUsage)))
                {
                    ASSERTGDI(FALSE,
                        "MF_InternalCreateObject: GetObjectBitmapHandle failed");
                    break;
                }

            // For a pattern brush, the usage should be set to DIB_PAL_INDICES
            // if it is monochrome.  If it is color, it becomes a dib pattern
            // brush with DIB_RGB_COLORS usage.

                if (lb.lbStyle == BS_PATTERN)
                {
                    bMonoBrush = MonoBitmap(hbmRemote);

                    if (bMonoBrush)
                        iUsage = DIB_PAL_INDICES;
                    else
                        iUsage = DIB_RGB_COLORS;
                }

            // Get the bitmap info header and sizes.

                if (!bMetaGetDIBInfo(hdc, hbmRemote, &bmih,
                        &cbBitsInfo, &cbBits, iUsage, 0, FALSE))
                    break;

            // Finally create the record and get the bits.

                PMRBRUSH    pmrbr;

                if (!(pmrbr = (PMRBRUSH) pmdc->pvNewRecord
                            (SIZEOF_MRBRUSH(cbBitsInfo,cbBits))))
                    break;

                if (!pmrbr->bInit
                    (
                        bMonoBrush
                            ? EMR_CREATEMONOBRUSH
                            : EMR_CREATEDIBPATTERNBRUSHPT,
                        hdc,
                        imhe,
                        hbmRemote,
                        bmih,
                        iUsage,
                        cbBitsInfo,             // size of bitmap info
                        cbBits          // size of bits buffer
                    )
                   )
                    break;

            // Check whether this is a color brush

                if (pmrbr->fColor)
                {
                    SET_COLOR_PAGE(pldc);
                }
                pmrbr->vCommit(pmdc);

                ulRet = imhe;
            }
            break;

        default:
            ASSERTGDI(FALSE, "MF_InternalCreateObject: Brush error");
        }
        break;

// Do pen.

    case LO_PEN_TYPE:

        PMRCREATEPEN    pmrcpn;

        // Allocate dword aligned structure.

        if (!(pmrcpn = (PMRCREATEPEN) pmdc->pvNewRecord(SIZEOF_MRCREATEPEN)))
            break;

        if (!pmrcpn->bInit(hobj, imhe))
            break;

        CHECK_COLOR_PAGE (pldc,pmrcpn->GetPenColor());

        pmrcpn->vCommit(pmdc);
        ulRet = imhe;
        break;

// Do extended pen.

    case LO_EXTPEN_TYPE:

        EXTLOGPEN       elp;
        PEXTLOGPEN      pelp;
        int             cbelp,tcbelp;

        // Get the size of the ExtPen.

        if (!(cbelp = GetObjectA(hobj, 0, (LPVOID) NULL)))
            break;

        ASSERTGDI(cbelp % 4 == 0, "MF_InternalCreateObject: Bad ext pen size");

        if (cbelp <= sizeof(EXTLOGPEN))
            pelp = &elp;
        else if (!(pelp = (PEXTLOGPEN) LocalAlloc(LMEM_FIXED, (UINT) cbelp)))
            break;

        // Get the ExtPen.

        if (GetObjectA(hobj, cbelp, (LPVOID) pelp) == cbelp)
        {
            UINT        iUsage;
            HBITMAP     hbmRemote  = (HBITMAP) 0;
            BMIH        bmih;
            DWORD       cbBitsInfo = 0;
            DWORD       cbBits     = 0;
            BOOL        bMonoBrush = FALSE;


            // Use switch statement so we can use the break statement on error.
            // The following code is similiar to the brush creation code.

            switch (pelp->elpBrushStyle)
            {
            case BS_DIBPATTERN:
                pelp->elpBrushStyle = BS_DIBPATTERNPT;  // fall through
            case BS_PATTERN:
            case BS_DIBPATTERNPT:

                if (!(hbmRemote = GetObjectBitmapHandle((HBRUSH)hobj, &iUsage)))
                {
                    ASSERTGDI(FALSE,
                        "MF_InternalCreateObject: GetObjectBitmapHandle failed");
                    break;
                }

                // For a pattern brush, the usage should be set to
                // DIB_PAL_INDICES if it is monochrome.  If it is color,
                // it becomes a dib pattern brush with DIB_RGB_COLORS usage.

                if (pelp->elpBrushStyle == BS_PATTERN)
                {
                    bMonoBrush = MonoBitmap(hbmRemote);

                    if (bMonoBrush)
                        iUsage = DIB_PAL_INDICES;
                    else
                        iUsage = DIB_RGB_COLORS;
                }

                // Get the bitmap info header and sizes.

                if (!bMetaGetDIBInfo(hdc, hbmRemote, &bmih,
                        &cbBitsInfo, &cbBits, (DWORD) iUsage, 0, FALSE))
                    break;

                // Record DIB bitmap if possible.

                pelp->elpBrushStyle = bMonoBrush
                                        ? BS_PATTERN
                                        : BS_DIBPATTERNPT;
                *(PDWORD) &pelp->elpColor = (DWORD) iUsage;
                pelp->elpHatch      = 0;

                // fall through

            default:

                tcbelp = cbelp;
#if !defined(_X86_)
                // Adjust the elp to be EXTLOGPEN32 for IA64
                // We do this by shifting all DWORDS from
                // &(pelp->elpNumEntries) up by 4 bytes.
                // This is to make sure the disk format is the same
                // as the X86 compatible EXTLOGPEN32 bassed format.
                MoveMemory((PBYTE)(&pelp->elpNumEntries)-4,
                           (PBYTE)(&pelp->elpNumEntries),
                           tcbelp-FIELD_OFFSET(EXTLOGPEN,elpNumEntries));
                tcbelp -= 4;
#endif

                // Finally create the record (and get the bits).

                PMREXTCREATEPEN pmrecp;

                // Allocate dword aligned structure.

                if (!(pmrecp = (PMREXTCREATEPEN) pmdc->pvNewRecord
                            (SIZEOF_MREXTCREATEPEN(tcbelp,cbBitsInfo,cbBits))))
                    break;

                if (!pmrecp->bInit
                    (
                        hdc,
                        imhe,
                        tcbelp,
                        (PEXTLOGPEN32)pelp,
                        hbmRemote,
                        bmih,
                        cbBitsInfo,     // size of bitmap info
                        cbBits          // size of bits buffer
                    )
                   )
                    break;

                // Check for color page info

                if (pelp->elpBrushStyle == BS_SOLID || pelp->elpBrushStyle == BS_HATCHED)
                {
                    CHECK_COLOR_PAGE (pldc,pelp->elpColor);
                }
                else if (hbmRemote && pmrecp->fColor)
                {
                    SET_COLOR_PAGE(pldc);
                }
                pmrecp->vCommit(pmdc);
                ulRet = imhe;
                break;
            }
        }

        if (cbelp > sizeof(EXTLOGPEN))
        {
            if (LocalFree(pelp))
            {
                ASSERTGDI(FALSE, "MF_InternalCreateObject: LocalFree failed");
            }
        }

        break;

// Do palette.

    case LO_PALETTE_TYPE:

        PMRCREATEPALETTE  pmrcp;
        USHORT            cEntries;

        if (GetObjectA(hobj, sizeof(USHORT), (LPVOID) &cEntries) != 2)
        {
            ASSERTGDI(FALSE, "MF_InternalCreateObject: GetObjectA failed");
            break;
        }

        if (!(pmrcp = (PMRCREATEPALETTE) pmdc->pvNewRecord
                            (SIZEOF_MRCREATEPALETTE(cEntries))))
            break;

        // Also clear peFlags.

        if (!pmrcp->bInit((HPALETTE) hobj, imhe, cEntries))
            break;

        // Also update the metafile palette.

        if (!pmrcp->bCommit(pmdc))
            break;

        ulRet = imhe;
        break;

// Do font.

    case LO_FONT_TYPE:

        PMREXTCREATEFONTINDIRECTW pmecfiw;
        PLDC pldc;
        int iSize;
        ENUMLOGFONTEXDVW elfw;

        pldc = GET_PLDC(hdc);

        iSize = GetObjectW(hobj, (int)sizeof(ENUMLOGFONTEXDVW), (LPVOID)&elfw);

        if (!iSize)
            break;

        ASSERTGDI(
            ((DWORD)iSize) == (offsetof(ENUMLOGFONTEXDVW,elfDesignVector) + SIZEOFDV(elfw.elfDesignVector.dvNumAxes)),
            "sizeof enumlogfontexdvw is broken\n"
            );

        ASSERTGDI(
           sizeof(EXTLOGFONTW) < (offsetof(ENUMLOGFONTEXDVW,elfDesignVector) + SIZEOFDV(0)),
           "sizeof(EXTLOGFONTW) problem\n");

        pldc->fl |= LDC_FONT_CHANGE;

        if (!(pmecfiw = (PMREXTCREATEFONTINDIRECTW) pmdc->pvNewRecord
                            (SIZEOF_MRCREATEFONTINDIRECTEXW(iSize))))
            break;

        pmecfiw->vInit((HFONT) hobj, imhe, &elfw);

        pmecfiw->vCommit(pmdc);
        ulRet = imhe;
        break;

// Do color space.

    case LO_ICMLCS_TYPE:

        if (!MF_InternalCreateColorSpace(hdc,hobj,imhe))
        {
            break;
        }
        ulRet = imhe;
        break;

    case LO_BITMAP_TYPE:
    case LO_DIBSECTION_TYPE:
    default:

        ASSERTGDI(FALSE, "MF_InternalCreateObject: Bad object type\n");
        break;
    }

// Check for error.

    if (ulRet == 0)
    {
        ERROR_ASSERT(FALSE,
            "MF_InternalCreateObject: unable to record the object");
        vFreeMHE(hdc, imhe);
        return(ulRet);
    }

    ASSERTGDI(ulRet == imhe, "MF_InternalCreateObject: Bad return value");

// Update number of handles in the metafile header record.

    pmdc->vUpdateNHandles(imhe);

// Return the metafile handle index of the object.

    return(imhe);
}

// DeleteObject

extern "C" BOOL MF_DeleteObject(HANDLE h)
{
// We don't get called if it is a stock object.

    HDC      hdc;
    METALINK metalink;

    PUTS("MF_DeleteObject\n");

    ASSERTGDI(pmetalink16Get(h) != NULL,
        "MF_DeleteObject: No object to delete");

// Delete the object from each metafile DC which references it.

    while (TRUE)
    {
        metalink.vInit(pmetalink16Get(h));
        if (!metalink.bValid())
            break;

        hdc = hdcFromIhdc(metalink.ihdc);

    #if DBG
        ASSERTGDI(GET_PMDC(hdc)->pmhe[metalink.imhe].lhObject == h,
          "MF_DeleteObject: Bad metalink");
        ASSERTGDI(metalink.imhe != 0,           // Index zero is reserved.
          "MF_DeleteObject: Bad metalink");
    #endif

    // Send a delete object record.

        (VOID) MF_SetD(hdc, (DWORD) metalink.imhe, EMR_DELETEOBJECT);
        vFreeMHE(hdc, (ULONG) metalink.imhe);
    }
    return(TRUE);
}

// SetPaletteEntries

extern "C" BOOL MF_SetPaletteEntries
(
    HPALETTE        hpal,
    UINT            iStart,
    UINT            cEntries,
    CONST PALETTEENTRY  *pPalEntries
)
{
// We don't get called if it is a stock object.

    PUTS("MF_SetPaletteEntries\n");

// Create a record in each metafile DC which references it.
// Note that if an object has been previously selected in a metafile DC
// and currently deselected, it is still referenced by the metafile DC.

    for
    (
        METALINK metalink(pmetalink16Get(hpal));
        metalink.bValid();
        metalink.vNext()
    )
    {
        // Get a metafile DC.

        PMDC pmdc = GET_PMDC(hdcFromIhdc(metalink.ihdc));
        PMRSETPALETTEENTRIES pmrspe;

        ASSERTGDI(pmdc->pmhe[metalink.imhe].lhObject == hpal,
          "MF_SetPaletteEntries: Bad metalink");
        ASSERTGDI(metalink.imhe != 0,           // Index zero is reserved.
          "MF_SetPaletteEntries: Bad metalink");

        // Send a SetPaletteEntries record.

        if (!(pmrspe = (PMRSETPALETTEENTRIES) pmdc->pvNewRecord
                            (SIZEOF_MRSETPALETTEENTRIES(cEntries))))
            return(FALSE);

        // Also clear peFlags.

        pmrspe->vInit(metalink.imhe, iStart, cEntries, pPalEntries);

        // Also update the metafile palette.

        if (!pmrspe->bCommit(pmdc))
            return(FALSE);
    }
    return(TRUE);
}

/******************************Public*Routine******************************\
* MF_ColorCorrectPalette
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    9/23/1996 Mark Enstrom [marke]
*
\**************************************************************************/

extern "C"
BOOL
MF_ColorCorrectPalette(
    HDC      hdc,
    HPALETTE hpal,
    ULONG    FirstEntry,
    ULONG    NumberOfEntries)
{
    PMRDDDD pmrdddd;
    DWORD   imhePal;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_SetDDDD : ColorCorrectPalette\n");

    //
    // get palette
    //

    if (!(imhePal = MF_InternalCreateObject(hdc, hpal)))
    {
        return(FALSE);
    }

    if (!(pmrdddd = (PMRDDDD) pmdc->pvNewRecord(SIZEOF_MRDDDD)))
    {
        return(FALSE);
    }

    pmrdddd->vInit(EMR_COLORCORRECTPALETTE,imhePal,FirstEntry,NumberOfEntries,0);
    pmrdddd->vCommit(pmdc);
    return(TRUE);
}

// ResizePalette

extern "C" BOOL MF_ResizePalette(HPALETTE hpal,UINT c)
{
// We don't get called if it is a stock object.

    PUTS("MF_ResizePalette\n");

// Create a record in each metafile DC which references it.
// Note that if an object has been previously selected in a metafile DC
// and currently deselected, it is still referenced by the metafile DC.

    for
    (
        METALINK metalink(pmetalink16Get(hpal));
        metalink.bValid();
        metalink.vNext()
    )
    {
        HDC hdc = hdcFromIhdc(metalink.ihdc);

        ASSERTGDI(GET_PMDC(hdc)->pmhe[metalink.imhe].lhObject == hpal,
          "MF_ResizePalette: Bad metalink");
        ASSERTGDI(metalink.imhe != 0,           // Index zero is reserved.
          "MF_ResizePalette: Bad metalink");

        // Send a ResizePalette record.

        if
        (
            !MF_SetDD
            (
                hdc,
                (DWORD)metalink.imhe,
                (DWORD)c,
                EMR_RESIZEPALETTE
            )
        )
            return(FALSE);
    }
    return(TRUE);
}

// RealizePalette
//
// This function takes a hpal, not a hdc!  We want to metafile RealizePalette
// calls in other DC which affect the metafile DCs as well.  For example,
// if a palette is selected into a display DC and a metafile DC, a
// RealizePalette on the display DC will cause a record to be generated in
// the metafile DC.  The reason is applications may expect this behavior
// in Windows although we do not completely agree with this.  In any case,
// we do the right thing when they realize a palette on metafile DCs.
//
// Note that no record is generated if the stock palette is realized.  This
// is compatible with the current design for palette management in metafiles.

extern "C" BOOL MF_RealizePalette(HPALETTE hpal)
{
// We don't get called if it is a stock object.

    PUTS("MF_RealizePalette\n");

// Create a record in each metafile DC which selects it (NOT references it!).
// Note that if an object has been previously selected in a metafile DC
// and currently deselected, it is still referenced by the metafile DC.

    for
    (
        METALINK metalink(pmetalink16Get(hpal));
        metalink.bValid();
        metalink.vNext()
    )
    {
        HDC hdc = hdcFromIhdc(metalink.ihdc);

        ASSERTGDI(GET_PMDC(hdc)->pmhe[metalink.imhe].lhObject == hpal,
          "MF_RealizePalette: Bad metalink");
        ASSERTGDI(metalink.imhe != 0,           // Index zero is reserved.
          "MF_RealizePalette: Bad metalink");

        // Send a RealizePalette record.

        if (GetDCObject(hdc,LO_PALETTE_TYPE) == hpal)
            if (!MF_Record(hdc,EMR_REALIZEPALETTE))
                return(FALSE);
    }
    return(TRUE);
}

// EOF - emit an EOF metafile record.
// This function is called by CloseEnhMetaFile to emit the last metafile record.
// The EOF record includes the metafile palette if any logical palette is
// used in the metafile.

extern "C" BOOL MF_EOF(HDC hdc, ULONG cEntries, PPALETTEENTRY pPalEntries)
{
    PMREOF pmreof;
    DWORD  cbEOF;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_EOF\n");

    cbEOF = SIZEOF_MREOF(cEntries);

    if (!(pmreof = (PMREOF) pmdc->pvNewRecord(cbEOF)))
        return(FALSE);

    pmreof->vInit(cEntries, pPalEntries, cbEOF);
    pmreof->vCommit(pmdc);
    return(TRUE);
}

// GdiComment - emit a metafile comment record.

extern "C" BOOL MF_GdiComment(HDC hdc, UINT nSize, CONST BYTE *lpData)
{
    PMRGDICOMMENT  pmrc;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_GdiComment\n");

// Ignore GDICOMMENT_WINDOWS_METAFILE and other non-embeddable public comments.
// These comments are now extra baggage.

    if (nSize >= 2 * sizeof(DWORD)
     && ((PDWORD) lpData)[0] == GDICOMMENT_IDENTIFIER
     && ((PDWORD) lpData)[1] & GDICOMMENT_NOEMBED)
        return(TRUE);

    if (!(pmrc = (PMRGDICOMMENT) pmdc->pvNewRecord(SIZEOF_MRGDICOMMENT(nSize))))
        return(FALSE);

// If it is a GDICOMMENT_MULTIFORMATS or other public comments containing
// logical bounds, we need to accumulate the bounds.
// We assume that applications set up metafile palette properly before
// embedding so we do not have to accumulate the metafile palette here.
// We do the bounds after pvNewRecord so that the previous bounds is
// accounted for properly.

    if (nSize >= 2 * sizeof(DWORD)
     && ((PDWORD) lpData)[0] == GDICOMMENT_IDENTIFIER
     && ((PDWORD) lpData)[1] & GDICOMMENT_ACCUMBOUNDS)
    {
        POINT  aptBounds[4];
        RECT   rcBounds;

// The logical output rectangle follows the ident and iComment fields.

        CONST RECTL *prclOutput = (PRECTL) &lpData[2 * sizeof(DWORD)];

        aptBounds[0].x = prclOutput->left;
        aptBounds[0].y = prclOutput->top;
        aptBounds[1].x = prclOutput->right;
        aptBounds[1].y = prclOutput->top;
        aptBounds[2].x = prclOutput->right;
        aptBounds[2].y = prclOutput->bottom;
        aptBounds[3].x = prclOutput->left;
        aptBounds[3].y = prclOutput->bottom;

        if (!LPtoDP(hdc, aptBounds, 4))
            return(FALSE);

        rcBounds.left   = MIN4(aptBounds[0].x,aptBounds[1].x,aptBounds[2].x,aptBounds[3].x);
        rcBounds.right  = MAX4(aptBounds[0].x,aptBounds[1].x,aptBounds[2].x,aptBounds[3].x);
        rcBounds.top    = MIN4(aptBounds[0].y,aptBounds[1].y,aptBounds[2].y,aptBounds[3].y);
        rcBounds.bottom = MAX4(aptBounds[0].y,aptBounds[1].y,aptBounds[2].y,aptBounds[3].y);

        (void) SetBoundsRectAlt(hdc, &rcBounds, (UINT) (DCB_WINDOWMGR | DCB_ACCUMULATE));
    }

    pmrc->vInit(nSize, lpData);
    pmrc->vCommit(pmdc);
    return(TRUE);
}

//
// Emit a EMF comment record which contains embedded font information
//

BOOL
WriteFontDataAsEMFComment(
    PLDC    pldc,
    DWORD   ulID,
    PVOID   buf1,
    DWORD   size1,
    PVOID   buf2,
    DWORD   size2
    )

{
    static struct {
        DWORD   reserved;
        DWORD   signature;
    } FontCommentHeader = { 0, 'TONF' };

    EMFITEMHEADER emfi = { ulID, size1+size2 };

    COMMENTDATABUF databuf[4] = {
        { sizeof(FontCommentHeader), &FontCommentHeader },
        { sizeof(emfi), &emfi },
        { size1, buf1 },
        { size2, buf2 }
    };

    PMRGDICOMMENT pmrc;
    UINT n;
    PMDC pmdc = (PMDC) pldc->pvPMDC;
    BOOL result;

    if (!pmdc || !pmdc->bIsEMFSpool())
    {
        ASSERTGDI(FALSE, "WriteFontDataAsEMFComment: pmdc is NULL\n");
        return FALSE;
    }

    //
    // Record the font data as EMF comment and remember
    // its location in the EMF spool file.
    //

    n = sizeof(FontCommentHeader) + sizeof(emfi) + size1 + size2;

    if (!(pmrc = (PMRGDICOMMENT) pmdc->pvNewRecord(SIZEOF_MRGDICOMMENT(n))))
        return FALSE;

    n = SIZEOF_MRGDICOMMENT(0) + sizeof(FontCommentHeader);
    result = pmdc->SaveFontCommentOffset(ulID, n);

    pmrc->vInit(4, databuf);
    pmrc->vCommit(pmdc);
    return result;
}

// Emit a metafile comment record for embedded windows metafile.

extern "C" BOOL MF_GdiCommentWindowsMetaFile(HDC hdc, UINT nSize, CONST BYTE *lpData)
{
    PMRGDICOMMENT  pmrc;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_GdiCommentWindowsMetaFile\n");

    if (!(pmrc = (PMRGDICOMMENT) pmdc->pvNewRecord(SIZEOF_MRGDICOMMENT_WINDOWS_METAFILE(nSize))))
        return(FALSE);

    pmrc->vInitWindowsMetaFile(nSize, lpData);
    pmrc->vCommit(pmdc);
    return(TRUE);
}

// Emit a metafile comment record for begin group.  This is used to identify
// the beginning of an embedded enhanced metafile.

extern "C" BOOL MF_GdiCommentBeginGroupEMF(HDC hdc, PENHMETAHEADER pemfHeader)
{
    PMRGDICOMMENT  pmrc;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_GdiCommentBeginGroupEMF\n");

    if (!(pmrc = (PMRGDICOMMENT) pmdc->pvNewRecord(SIZEOF_MRGDICOMMENT_BEGINGROUP(pemfHeader->nDescription))))
        return(FALSE);

    pmrc->vInitBeginGroupEMF(pemfHeader);
    pmrc->vCommit(pmdc);
    return(TRUE);
}

// Emit a metafile comment record for end group.  This is used to identify
// the end of an embedded enhanced metafile.

extern "C" BOOL MF_GdiCommentEndGroupEMF(HDC hdc)
{
    DWORD  ad[2];

    PUTS("MF_GdiCommentEndGroupEMF\n");

    ad[0] = GDICOMMENT_IDENTIFIER;      // ident
    ad[1] = GDICOMMENT_ENDGROUP;        // iComment

    return(MF_GdiComment(hdc, (UINT) sizeof(ad), (LPBYTE) &ad));
}

// MF_AnyBitBlt helper.

extern "C" BOOL MF_DoBitBlt
(
    PMDC     pmdcDst,
    int      xDst,
    int      yDst,
    int      cxDst,
    int      cyDst,
    DWORD    rop,
    int      xSrc          = 0,
    int      ySrc          = 0,
    PXFORM   pxformSrc = &xformIdentity,
    COLORREF clrBkSrc      = 0,
    PBMIH    pbmihSrc      = (PBMIH) NULL,
    HBITMAP  hbmSrc        = (HBITMAP) 0,
    DWORD    cbBitsInfoSrc = 0,
    DWORD    cbBitsSrc     = 0
)
{
    PMRBB pmrbb;

    if (!(pmrbb = (PMRBB) pmdcDst->pvNewRecord
                    (SIZEOF_MRBB(cbBitsInfoSrc,cbBitsSrc))))
        return(FALSE);

    // Use compression option

    if (!pmrbb->bInit
        (
            EMR_BITBLT,
            pmdcDst,                    // pmdcDst
            xDst,                       // xDst
            yDst,                       // yDst
            cxDst,                      // cxDst
            cyDst,                      // cyDst
            rop,                        // rop
            xSrc,                       // xSrc
            ySrc,                       // ySrc
            pxformSrc,                  // source DC transform
            clrBkSrc,                   // source DC BkColor
            pbmihSrc,                   // source bitmap info header
            hbmSrc,                     // source bitmap to save
            hbmSrc ? sizeof(MRBB) : 0,  // offset to bitmap info
            cbBitsInfoSrc,              // size of bitmap info
            hbmSrc ? sizeof(MRBB) + cbBitsInfoSrc : 0,// offset to bits
            cbBitsSrc                   // size of bits buffer
        )
       )
        return(FALSE);

    pmrbb->vCommit(pmdcDst);
    return(TRUE);
}

/******************************Public*Routine******************************\
* MF_DoAlphaBlend
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    12/3/1996 Mark Enstrom [marke]
*
\**************************************************************************/

extern "C" BOOL MF_DoAlphaBlend
(
    PMDC     pmdcDst,
    int      xDst,
    int      yDst,
    int      cxDst,
    int      cyDst,
    DWORD    Blend,
    int      xSrc,
    int      ySrc,
    int      cxSrc,
    int      cySrc,
    PXFORM   pxformSrc,
    COLORREF clrBkSrc,
    PBMIH    pbmihSrc,
    HBITMAP  hbmSrc,
    DWORD    cbBitsInfoSrc,
    DWORD    cbBitsSrc
)
{
    PMRALPHABLEND pmrai;

// We always have a source bitmap here.  AlphaImage without a source is not valid

    ASSERTGDI(hbmSrc != (HBITMAP) 0, "MF_DoAlphaBlend: Bad hbmSrc");

    if (!(pmrai = (PMRALPHABLEND) pmdcDst->pvNewRecord
                    (SIZEOF_MRALPHABLEND(cbBitsInfoSrc,cbBitsSrc))))
        return(FALSE);

    // Use compression option

    if (!pmrai->bInit
        (
            pmdcDst,            // pmdcDst
            xDst,               // xDst
            yDst,               // yDst
            cxDst,              // cxDst
            cyDst,              // cyDst
            Blend,              // replaves rop
            xSrc,               // xSrc
            ySrc,               // ySrc
            cxSrc,              // cxSrc
            cySrc,              // cySrc
            pxformSrc,          // source DC transform
            clrBkSrc,           // source DC BkColor
            pbmihSrc,           // source bitmap info header
            hbmSrc,             // source bitmap to save
            sizeof(MRALPHABLEND),// offset to bitmap info
            cbBitsInfoSrc,      // size of bitmap info
            sizeof(MRALPHABLEND) + cbBitsInfoSrc,// offset to bits
            cbBitsSrc           // size of bits buffer
        )
       )
        return(FALSE);

    pmrai->vCommit(pmdcDst);
    return(TRUE);
}

/******************************Public*Routine******************************\
* MF_DoTransparentBlt
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    12/3/1996 Mark Enstrom [marke]
*
\**************************************************************************/

extern "C" BOOL MF_DoTransparentBlt
(
    PMDC     pmdcDst,
    int      xDst,
    int      yDst,
    int      cxDst,
    int      cyDst,
    DWORD    Blend,
    int      xSrc,
    int      ySrc,
    int      cxSrc,
    int      cySrc,
    PXFORM   pxformSrc,
    COLORREF clrBkSrc,
    PBMIH    pbmihSrc,
    HBITMAP  hbmSrc,
    DWORD    cbBitsInfoSrc,
    DWORD    cbBitsSrc
)
{
    PMRTRANSPARENTBLT pmrai;

// We always have a source bitmap here.  TransparentImage without a source is not valid

    ASSERTGDI(hbmSrc != (HBITMAP) 0, "MF_DoTransparentImage: Bad hbmSrc");

    if (!(pmrai = (PMRTRANSPARENTBLT) pmdcDst->pvNewRecord
                    (SIZEOF_MRTRANSPARENTBLT(cbBitsInfoSrc,cbBitsSrc))))
        return(FALSE);

    // Use compression option

    if (!pmrai->bInit
        (
            pmdcDst,            // pmdcDst
            xDst,               // xDst
            yDst,               // yDst
            cxDst,              // cxDst
            cyDst,              // cyDst
            Blend,              // color
            xSrc,               // xSrc
            ySrc,               // ySrc
            cxSrc,
            cySrc,
            pxformSrc,          // source DC transform
            clrBkSrc,           // source DC BkColor
            pbmihSrc,           // source bitmap info header
            hbmSrc,             // source bitmap to save
            sizeof(MRTRANSPARENTBLT),// offset to bitmap info
            cbBitsInfoSrc,      // size of bitmap info
            sizeof(MRTRANSPARENTBLT) + cbBitsInfoSrc,// offset to bits
            cbBitsSrc           // size of bits buffer
        )
       )
        return(FALSE);

    pmrai->vCommit(pmdcDst);
    return(TRUE);
}


// MF_AnyBitBlt helper.

extern "C" BOOL MF_DoStretchBlt
(
    PMDC     pmdcDst,
    int      xDst,
    int      yDst,
    int      cxDst,
    int      cyDst,
    DWORD    rop,
    int      xSrc,
    int      ySrc,
    int      cxSrc,
    int      cySrc,
    PXFORM   pxformSrc,
    COLORREF clrBkSrc,
    PBMIH    pbmihSrc,
    HBITMAP  hbmSrc,
    DWORD    cbBitsInfoSrc,
    DWORD    cbBitsSrc
)
{
    PMRSTRETCHBLT pmrsb;

// We always have a source bitmap here.  StretchBlt without a source is
// recorded as BitBlt.

    ASSERTGDI(hbmSrc != (HBITMAP) 0, "MF_DoStretchBlt: Bad hbmSrc");

    if (!(pmrsb = (PMRSTRETCHBLT) pmdcDst->pvNewRecord
                    (SIZEOF_MRSTRETCHBLT(cbBitsInfoSrc,cbBitsSrc))))
        return(FALSE);

    // Use compression option

    if (!pmrsb->bInit
        (
            pmdcDst,            // pmdcDst
            xDst,               // xDst
            yDst,               // yDst
            cxDst,              // cxDst
            cyDst,              // cyDst
            rop,                // rop
            xSrc,               // xSrc
            ySrc,               // ySrc
            cxSrc,              // cxSrc
            cySrc,              // cySrc
            pxformSrc,          // source DC transform
            clrBkSrc,           // source DC BkColor
            pbmihSrc,           // source bitmap info header
            hbmSrc,             // source bitmap to save
            sizeof(MRSTRETCHBLT),// offset to bitmap info
            cbBitsInfoSrc,      // size of bitmap info
            sizeof(MRSTRETCHBLT) + cbBitsInfoSrc,// offset to bits
            cbBitsSrc           // size of bits buffer
        )
       )
        return(FALSE);

    pmrsb->vCommit(pmdcDst);
    return(TRUE);
}

// MF_AnyBitBlt helper.

extern "C" BOOL MF_DoMaskBlt
(
    PMDC     pmdcDst,
    int      xDst,
    int      yDst,
    int      cxDst,
    int      cyDst,
    DWORD    rop3,
    PBMIH    pbmihMask,
    HBITMAP  hbmMask,
    DWORD    cbBitsInfoMask,
    DWORD    cbBitsMask,
    int      xMask,
    int      yMask,
    int      xSrc,
    int      ySrc,
    PXFORM   pxformSrc,
    COLORREF clrBkSrc      = 0,
    PBMIH    pbmihSrc      = (PBMIH) NULL,
    HBITMAP  hbmSrc        = (HBITMAP) 0,
    DWORD    cbBitsInfoSrc = 0,
    DWORD    cbBitsSrc     = 0
)
{
    PMRMASKBLT pmrmb;
    DWORD      offBase          = sizeof(MRMASKBLT);
    DWORD      offBitsInfoSrc   = 0;
    DWORD      offBitsSrc       = 0;
    DWORD      offBitsInfoMask  = 0;
    DWORD      offBitsMask      = 0;

    if (hbmSrc)
    {
        offBitsInfoSrc = offBase;
        offBitsSrc     = offBitsInfoSrc + cbBitsInfoSrc;
        offBase        = offBitsSrc + cbBitsSrc;
    }

    if (hbmMask)
    {
        offBitsInfoMask = offBase;
        offBitsMask     = offBitsInfoMask + cbBitsInfoMask;
    }

    // Now create the record.

    if (!(pmrmb = (PMRMASKBLT) pmdcDst->pvNewRecord
                    (SIZEOF_MRMASKBLT(cbBitsInfoSrc,cbBitsSrc,cbBitsInfoMask,cbBitsMask))))
        return(FALSE);

    // Use compression option

    if (!pmrmb->bInit
        (
            pmdcDst,                    // pmdcDst
            xDst,                       // xDst
            yDst,                       // yDst
            cxDst,                      // cxDst
            cyDst,                      // cyDst
            rop3,                       // rop3
            xSrc,                       // xSrc
            ySrc,                       // ySrc
            pxformSrc,                  // source DC transform
            clrBkSrc,                   // source DC BkColor
            pbmihSrc,                   // source bitmap info header
            hbmSrc,                     // source bitmap to save
            offBitsInfoSrc,             // offset to bitmap info
            cbBitsInfoSrc,              // size of bitmap info
            offBitsSrc,                 // offset to bits
            cbBitsSrc,                  // size of bits buffer
            xMask,                      // xMask
            yMask,                      // yMask
            pbmihMask,                  // mask bitmap info header
            hbmMask,                    // mask bitmap
            offBitsInfoMask,            // offset to mask bitmap info
            cbBitsInfoMask,             // size of mask bitmap info
            offBitsMask,                // offset to mask bits
            cbBitsMask                  // size of mask bits buffer
        )
       )
        return(FALSE);

    pmrmb->vCommit(pmdcDst);
    return(TRUE);
}

// MF_AnyBitBlt helper.

extern "C" BOOL MF_DoPlgBlt
(
    PMDC     pmdcDst,
    CONST POINT *pptDst,
    PBMIH    pbmihMask,
    HBITMAP  hbmMask,
    DWORD    cbBitsInfoMask,
    DWORD    cbBitsMask,
    int      xMask,
    int      yMask,
    int      xSrc,
    int      ySrc,
    int      cxSrc,
    int      cySrc,
    PXFORM   pxformSrc,
    COLORREF clrBkSrc,
    PBMIH    pbmihSrc,
    HBITMAP  hbmSrc,
    DWORD    cbBitsInfoSrc,
    DWORD    cbBitsSrc
)
{
    PMRPLGBLT  pmrpb;

// We always have a source bitmap here.  Destination to destination PlgBlt
// is not allowed.

    ASSERTGDI(hbmSrc != (HBITMAP) 0, "MF_DoPlgBlt: Bad hbmSrc");

    // Now create the record.

    if (!(pmrpb = (PMRPLGBLT) pmdcDst->pvNewRecord
                    (SIZEOF_MRPLGBLT(cbBitsInfoSrc,cbBitsSrc,cbBitsInfoMask,cbBitsMask))))
        return(FALSE);

    // Use compression option

    if (!pmrpb->bInit
        (
            pmdcDst,                    // pmdcDst
            pptDst,                     // pptDst
            xSrc,                       // xSrc
            ySrc,                       // ySrc
            cxSrc,                      // cxSrc
            cySrc,                      // cySrc
            pxformSrc,                  // source DC transform
            clrBkSrc,                   // source DC BkColor
            pbmihSrc,                   // source bitmap info header
            hbmSrc,                     // source bitmap to save
            sizeof(MRPLGBLT),           // offset to bitmap info
            cbBitsInfoSrc,              // size of bitmap info
            sizeof(MRPLGBLT) + cbBitsInfoSrc,// offset to bits
            cbBitsSrc,                  // size of bits buffer
            xMask,                      // xMask
            yMask,                      // yMask
            pbmihMask,                  // mask bitmap info header
            hbmMask,                    // mask bitmap
            hbmMask                     // offset to mask bitmap info
                ? sizeof(MRPLGBLT) + cbBitsInfoSrc + cbBitsSrc
                : 0,
            cbBitsInfoMask,             // size of mask bitmap info
            hbmMask                     // offset to mask bits
                ? sizeof(MRPLGBLT) + cbBitsInfoSrc + cbBitsSrc + cbBitsInfoMask
                : 0,
            cbBitsMask                  // size of mask bits buffer
        )
       )
        return(FALSE);

    pmrpb->vCommit(pmdcDst);
    return(TRUE);
}

// bMetaGetDIBInfo
//
// Gets the bitmap info header and sizes.
//
// If hbm or hbmRemote is given, it queries the bitmap info header and
// fills in the BITMAPINFOHERADER structure at pBmih.  A hdc is required
// if iUsage is DIB_PAL_COLORS.
//
// If no hbm or hbmRemote is given, it assumes that it is called by
// SetDIBitsToDevice or StretchDIBits and pBmih already points to a
// bitmap info header (BITMAPINFOHEADER) or core header (BITMAPCOREHEADER).
//
// In any case, the size for bitmap info (BITMAPINFO) with color table
// and the size for the bitmap bits is returned in pcbBmi and pcbBits
// respectively.  We do not store BITMAPCOREINFO structure in the metafiles.
//
// If cScans is non zero, only the size for the bitmap bits of this many
// scans is given.  The callers in this case are SetDIBitsToDevice or
// StretchDIBits.
//
// This function is called in many places and any modifications have to
// be verified carefully!  It should be kept current with the
// cjBitmapSize and cjBitmapBitsSize functions.
//
// Returns TRUE if successful, FALSE otherwise.

BOOL bMetaGetDIBInfo
(
    HDC     hdc,
    HBITMAP hbm,
    PBMIH   pBmih,
    PDWORD  pcbBmi,
    PDWORD  pcbBits,
    DWORD   iUsage,
    LONG    cScans,
    BOOL    bMeta16
)
{
    DWORD   cjClr;
    DWORD   cbBmi;
    DWORD   cbBits;

    PUTS("bMetaGetDIBInfo\n");

    if (pBmih == NULL)
        return(FALSE);

// If hbm is given, we need to get the bitmap info header.
// Otherwise, pBmih already has the bitmap info header.

    if (hbm)
    {
        pBmih->biSize = sizeof(BMIH);
        pBmih->biBitCount = 0;          // don't fill in color table
        pBmih->biCompression = BI_RGB;
        if (!GetDIBits(hdc, hbm, 0, 0, (LPBYTE) NULL,
                   (LPBITMAPINFO) pBmih, (UINT) iUsage))
        {
            ASSERTGDI(FALSE, "bMetaGetDIBInfo: InternalGetDIBits failed");
            return(FALSE);
        }

// Windows always zeros the clrUsed and clrImportant fields.
// 16-bit metafiles also do not support 16/32bpp bitmaps.

        if (bMeta16)
        {
            pBmih->biClrUsed      = 0;
            pBmih->biClrImportant = 0;
            if (pBmih->biPlanes != 1
             || pBmih->biBitCount == 16 || pBmih->biBitCount == 32)
            {
                pBmih->biPlanes      = 1;
                pBmih->biBitCount    = 24;
                pBmih->biCompression = BI_RGB;
                pBmih->biSizeImage   = 0;
                iUsage = DIB_RGB_COLORS;
            }

        }
    }

// Compute size of a color entry.

    switch (iUsage)
    {
    case DIB_RGB_COLORS:
        cjClr = sizeof(RGBQUAD);
        break;
    case DIB_PAL_COLORS:
        cjClr = sizeof(WORD);
        ASSERTGDI(sizeof(WORD) == 2, "bMetaGetDIBInfo: Bad size");
        break;
    case DIB_PAL_INDICES:
        cjClr = 0;
        break;
    default:
        ASSERTGDI(FALSE, "bMetaGetDIBInfo: Bad iUsage");
        return(FALSE);
    }

// Compute size of the bitmap info (with color table) and bitmap bits buffer.
// We will store only BITMAPINFO in the record only.  The BITMAPCOREINFO
// structure will be stored as BITMAPINFO in the metafile.

    if (pBmih->biSize > sizeof(BMIH))
    {
        cbBmi = pBmih->biSize;
    }
    else
    {
        cbBmi = sizeof(BMIH);
    }

    if (pBmih->biSize == sizeof(BMCH))
    {
        if (((LPBMCH) pBmih)->bcBitCount == 16 || ((LPBMCH) pBmih)->bcBitCount == 32)
        {
            ASSERTGDI(FALSE, "bMetaGetDIBInfo: 16/32bpp bitmap not allowed in core bitmap info");
            return(FALSE);
        }

        if (((LPBMCH) pBmih)->bcBitCount < 16)
            cbBmi += (1 << ((LPBMCH) pBmih)->bcBitCount) * cjClr;

        cbBits = CJSCAN(((LPBMCH) pBmih)->bcWidth,
                        ((LPBMCH) pBmih)->bcPlanes,
                        ((LPBMCH) pBmih)->bcBitCount)
               * (cScans ? cScans : (DWORD) ((LPBMCH) pBmih)->bcHeight);
    }
    else
    {
        if (pBmih->biBitCount == 16 || pBmih->biBitCount == 32)
        {
            if (pBmih->biCompression == BI_BITFIELDS)
                cbBmi += 3 * sizeof(DWORD);
        }
        else if (pBmih->biBitCount == 24)
        {
            // BI_BITFIELDS not allowed
        }
        else if ((pBmih->biCompression == BI_JPEG) ||
                 (pBmih->biCompression == BI_PNG))
        {
            // No color table for JPEG and PNG images
        }
        else if (pBmih->biClrUsed)
            cbBmi += pBmih->biClrUsed * cjClr;
        else if (pBmih->biBitCount < 16)
            cbBmi += (1 << pBmih->biBitCount) * cjClr;

    // compute cbBits.  We first do the computation and then use biSizeImage
    // if it is smaller than cbBits.

        cbBits = CJSCAN(pBmih->biWidth, pBmih->biPlanes, pBmih->biBitCount)
                 * (cScans ? cScans : ABS(pBmih->biHeight));

        if (((pBmih->biSizeImage > 0) &&
             (pBmih->biSizeImage < cbBits ||
              pBmih->biCompression == BI_RLE8 ||
              pBmih->biCompression == BI_RLE4))  ||
            (pBmih->biCompression == BI_PNG) ||
            (pBmih->biCompression == BI_JPEG))
            cbBits = pBmih->biSizeImage;
    }

    *pcbBmi  = cbBmi;
    *pcbBits = cbBits;
    return(TRUE);
}

// BitBlt
// PatBlt
// StretchBlt
// MaskBlt
// PlgBlt

extern "C" BOOL MF_AnyBitBlt
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    int     cxDst,
    int     cyDst,
    CONST POINT *pptDst,
    HDC     hdcSrc,
    int     xSrc,
    int     ySrc,
    int     cxSrc,
    int     cySrc,
    HBITMAP hbmMask,
    int     xMask,
    int     yMask,
    DWORD   rop,                        // For MaskBlt, this is rop3!
                                        // For PlgBlt, this must be 0xCCAA0000!
    DWORD   mrType
)
{
    DWORD   cbBitsInfoMask = 0;
    DWORD   cbBitsMask     = 0;
    BMIH    bmihMask;
    PBMIH   pbmihMask      = (PBMIH) NULL;
    XFORM   xformSrc;

    PLDC pldc;
    DC_PLDC(hdcDst,pldc,FALSE);

    PMDC pmdcDst = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdcDst,"no pmdc\n");

    PUTS("MF_AnyBitBlt\n");

    ASSERTGDI(mrType == EMR_BITBLT
           || mrType == EMR_STRETCHBLT
           || mrType == EMR_MASKBLT
           || mrType == EMR_PLGBLT
           || mrType == EMR_ALPHABLEND
           || mrType == EMR_TRANSPARENTBLT,
        "MF_AnyBitBlt: Bad mrType");

// Do mask first.

    if (hbmMask)
    {
        // Get the mask's bitmap info header and sizes.

        pbmihMask = &bmihMask;
        if (!bMetaGetDIBInfo(hdcDst, hbmMask, &bmihMask,
                &cbBitsInfoMask, &cbBitsMask, DIB_PAL_INDICES, 0, FALSE))
            return(FALSE);

        // Make sure that it is monochrome.

        if (bmihMask.biPlanes != 1 && bmihMask.biBitCount != 1)
            return(FALSE);
    }

// These two checks are needed to make sure that the following rop test works.

    if ((mrType == EMR_BITBLT || mrType == EMR_STRETCHBLT)
     && (rop & (0xff000000 & ~NOMIRRORBITMAP)) != 0)
    {
        WARNING("MF_AnyBitBlt: Bad BitBlt/StretchBlt rop");
        return(FALSE);
    }

    ASSERTGDI(mrType != EMR_PLGBLT || rop == 0xCCAA0000,
        "MF_AnyBitBlt: Bad PlgBlt rop");

// Get the source transform if a source is required by the rop.
// For MaskBlt, we always need the source transform.

    if (
         ISSOURCEINROP3(rop)                ||
         (mrType == EMR_MASKBLT)            ||
         (mrType == EMR_ALPHABLEND)         ||
         (mrType == EMR_TRANSPARENTBLT)
       )
    {
    // Get source transform.

        if (!GetTransform(hdcSrc, XFORM_WORLD_TO_DEVICE, &xformSrc))
            return(FALSE);

    // Make sure that it is a scale.

        if (xformSrc.eM12 != 0.0f || xformSrc.eM21 != 0.0f)
            return(FALSE);

    // Set color page flag
        SET_COLOR_PAGE(pldc);
    }

// Do blts with a source.  The source must allow bit query operation.

    if (
         ISSOURCEINROP3(rop) ||
         (mrType == EMR_TRANSPARENTBLT) ||
         (mrType == EMR_ALPHABLEND)
       )
    {
        COLORREF clrBkSrc;
        BOOL     bRet = FALSE;          // assume failure

    // We need to record the source bitmap.  The source DC must be a memory
    // DC or a direct DC that allows bits to be retrieved.  As a result, the
    // source DC cannot be an enhanced metafile DC.  That is, destination
    // to destination blts are not allowed in an enhanced metafile!

        if (IS_ALTDC_TYPE(hdcSrc))
        {
            PLDC pldcSrc;
            DC_PLDC(hdcSrc,pldcSrc,FALSE);

            if (pldcSrc->iType == LO_METADC)
                return(FALSE);
        }

    // Get source bk color.

        if ((clrBkSrc = GetNearestColor(hdcSrc, GetBkColor(hdcSrc)))
            == CLR_INVALID)
        {
            return(FALSE);
        }

    // Compute the area of the source bitmap to save in the metafile.
    // First we find the coordinates of the source rectange in the
    // device/bitmap units.  Then we expand the rectangle by one pixel
    // unit to account for possible rounding errors.  Finally we map
    // the rectangle to the playback bitmap origin by modifying the
    // translation elements in the source transform.
    // Verify pdev

        LONG    lWidthSrc, lHeightSrc;
        RECTL   rclSrc;
        RECTL   rclBitmap;
        DWORD   cbBitsInfoCompat;
        DWORD   cbBitsCompat;
        HBITMAP hbmTmp     = 0;
        HBITMAP hbmCompat  = 0;
        HDC     hdcCompat  = 0;
        int     iSaveState = 0;
        BMIH    bmihCompat;

        // Get source rectangle in device/bitmap coordinates.  Since the
        // source transform is a scale, we can simply convert the endpoints
        // of the source rectangle.

        ASSERTGDI((mrType != EMR_BITBLT && mrType != EMR_MASKBLT)
               || (cxDst == cxSrc && cyDst == cySrc),
            "MF_AnyBitBlt: Bad width and height in BitBlt/MaskBlt");
        ASSERTGDI(sizeof(RECTL) == sizeof(POINT)*2, "MF_AnyBitBlt: Bad size");

        ((PERECTL) &rclSrc)->vInit(xSrc, ySrc, xSrc + cxSrc, ySrc + cySrc);
        if (!LPtoDP(hdcSrc, (LPPOINT) &rclSrc, 2))
            return(FALSE);

        // Order the result.  We assume it to be inclusive-inclusive.

        ((PERECTL) &rclSrc)->vOrder();

        // Expand it by one pixel.

        rclSrc.left--;
        rclSrc.top--;
        rclSrc.right++;
        rclSrc.bottom++;

        // Map it to the playback bitmap origin.

        xformSrc.eDx -= (FLOAT) rclSrc.left;
        xformSrc.eDy -= (FLOAT) rclSrc.top;

        // We now have the rectangle which defines the size of the playback
        // bitmap.  But we still need to clip it to the source device/bitmap
        // limits.  This is done by reducing the size of the rectangle and
        // translating its origin.

        ((PERECTL) &rclBitmap)->vInit
            (0, 0, rclSrc.right - rclSrc.left, rclSrc.bottom - rclSrc.top);

        // Get source width and height
        // WINBUG #82866 2-7-2000 bhouse Investigate possible bug in MfAnyBitBlt
        // Old Comment:
        //   - if it is a direct DC, we really want to fall through to the
        //     second case.  Will either the GetDCObject or GetObject fail?

        HBITMAP hbm = (HBITMAP)GetDCObject(hdcSrc, LO_BITMAP_TYPE);
        BITMAP bmSrc;

        if (hbm && GetObjectA((HANDLE)hbm,sizeof(BITMAP),(LPVOID) &bmSrc))
        {
            lWidthSrc  = bmSrc.bmWidth;
            lHeightSrc = bmSrc.bmHeight;
        }
        else
        {
            lWidthSrc  = GetDeviceCaps(hdcDst, DESKTOPHORZRES);
            lHeightSrc = GetDeviceCaps(hdcDst, DESKTOPVERTRES);
        }

        // Clip the source rectangle to the source device/bitmap limits.
        // Adjust the playback bitmap size and source transform at the
        // same time.

        if (rclSrc.left < 0)                // Shift and clip the left edge.
        {
            rclBitmap.right += rclSrc.left;
            xformSrc.eDx    += (FLOAT) rclSrc.left;
            rclSrc.left      = 0;
        }
        if (rclSrc.right >= lWidthSrc)      // Clip the right edge.
        {
            rclBitmap.right -= (rclSrc.right - lWidthSrc + 1);
            rclSrc.right    -= (rclSrc.right - lWidthSrc + 1);
        }
        if (rclSrc.top < 0)                 // Shift and clip the top edge.
        {
            rclBitmap.bottom += rclSrc.top;
            xformSrc.eDy     += (FLOAT) rclSrc.top;
            rclSrc.top        = 0;
        }
        if (rclSrc.bottom >= lHeightSrc)   // Clip the bottom edge.
        {
            rclBitmap.bottom -= (rclSrc.bottom - lHeightSrc + 1);
            rclSrc.bottom    -= (rclSrc.bottom - lHeightSrc + 1);
        }

        // If the rectangle is completely clipped, there is no playback
        // bitmap and nothing to blt.

        if (rclBitmap.right < 0 || rclBitmap.bottom < 0)
            return(TRUE);

    // We now have the size of the playback bitmap.  We will create a bitmap
    // compatible to the source, copy the bits to the compatible bitmap
    // and finally retrieve and store the bits in the metafile record.

        // Create a compatible DC.

        if (!(hdcCompat = CreateCompatibleDC(hdcSrc)))
            goto mfbb_src_exit;

        // Create a compatible bitmap.

        if (!(hbmCompat = CreateCompatibleBitmap
                            (
                                hdcSrc,
                                (int) rclBitmap.right  + 1,
                                (int) rclBitmap.bottom + 1
                            )
              )
            )
            goto mfbb_src_exit;

        // Select the bitmap.

        if (!(hbmTmp = (HBITMAP)SelectObject(hdcCompat, (HANDLE)hbmCompat)))
            goto mfbb_src_exit;

        // Set up the source DC to have the same identity transform as the
        // compatible DC so that the following bitblt call will not scale.

        if (!(iSaveState = SaveDC(hdcSrc)))
            goto mfbb_src_exit;

        // Must be in the advanced graphics mode to modify the world transform.

        SetGraphicsMode(hdcSrc, GM_ADVANCED);

        if (!SetMapMode(hdcSrc, MM_TEXT)
         || !ModifyWorldTransform(hdcSrc, (LPXFORM) NULL, MWT_IDENTITY)
         || !SetWindowOrgEx(hdcSrc, 0, 0, (LPPOINT) NULL)
         || !SetViewportOrgEx(hdcSrc, 0, 0, (LPPOINT) NULL))
            goto mfbb_src_exit;

        // Copy the source bits into the compatible bitmap.

        if (!BitBlt(hdcCompat,                  // Dest dc
                    0,                          // Dest x
                    0,                          // Dest y
                    (int) rclBitmap.right  + 1, // Width
                    (int) rclBitmap.bottom + 1, // Height
                    hdcSrc,                     // Src dc
                    (int) rclSrc.left,          // Src x
                    (int) rclSrc.top,           // Src y
                    SRCCOPY))                   // Rop
            goto mfbb_src_exit;

        // Retrieve the bitmap info header.

        SelectObject(hdcCompat, hbmTmp);
        hbmTmp = 0;                     // don't deselect it again later.

        // Get the bitmap info header and sizes.

        if (!bMetaGetDIBInfo(hdcCompat, hbmCompat, &bmihCompat,
                &cbBitsInfoCompat, &cbBitsCompat, DIB_RGB_COLORS, 0, FALSE))
            goto mfbb_src_exit;

        // Finally create the record and get the bits.

        pmdcDst->hdcSrc = hdcSrc;

        switch (mrType)
        {
        case EMR_BITBLT:
            bRet = MF_DoBitBlt
                    (
                        pmdcDst,                // pmdcDst
                        xDst,                   // xDst
                        yDst,                   // yDst
                        cxDst,                  // cxDst
                        cyDst,                  // cyDst
                        rop,                    // rop
                        xSrc,                   // xSrc
                        ySrc,                   // ySrc
                        &xformSrc,              // source DC transform
                        clrBkSrc,               // source DC BkColor
                        &bmihCompat,            // source bitmap info header
                        hbmCompat,              // source bitmap to save
                        cbBitsInfoCompat,       // size of bitmap info
                        cbBitsCompat            // size of bits buffer
                    );
            break;

        case EMR_STRETCHBLT:
            bRet = MF_DoStretchBlt
                    (
                        pmdcDst,                // pmdcDst
                        xDst,                   // xDst
                        yDst,                   // yDst
                        cxDst,                  // cxDst
                        cyDst,                  // cyDst
                        rop,                    // rop
                        xSrc,                   // xSrc
                        ySrc,                   // ySrc
                        cxSrc,                  // cxSrc
                        cySrc,                  // cySrc
                        &xformSrc,              // source DC transform
                        clrBkSrc,               // source DC BkColor
                        &bmihCompat,            // source bitmap info header
                        hbmCompat,              // source bitmap to save
                        cbBitsInfoCompat,       // size of bitmap info
                        cbBitsCompat            // size of bits buffer
                    );
            break;

        case EMR_MASKBLT:
            bRet = MF_DoMaskBlt
                    (
                        pmdcDst,                // pmdcDst
                        xDst,                   // xDst
                        yDst,                   // yDst
                        cxDst,                  // cxDst
                        cyDst,                  // cyDst
                        rop,                    // rop
                        pbmihMask,              // mask bitmap info header
                        hbmMask,                // hbmMask
                        cbBitsInfoMask,         // size of mask bitmap info
                        cbBitsMask,             // size of mask bits buffer
                        xMask,                  // xMask
                        yMask,                  // yMask
                        xSrc,                   // xSrc
                        ySrc,                   // ySrc
                        &xformSrc,              // source DC transform
                        clrBkSrc,               // source DC BkColor
                        &bmihCompat,            // source bitmap info header
                        hbmCompat,              // source bitmap to save
                        cbBitsInfoCompat,       // size of bitmap info
                        cbBitsCompat            // size of bits buffer
                    );
            break;

        case EMR_PLGBLT:
            bRet = MF_DoPlgBlt
                    (
                        pmdcDst,                // pmdcDst
                        pptDst,                 // pptDst
                        pbmihMask,              // mask bitmap info header
                        hbmMask,                // hbmMask
                        cbBitsInfoMask,         // size of mask bitmap info
                        cbBitsMask,             // size of mask bits buffer
                        xMask,                  // xMask
                        yMask,                  // yMask
                        xSrc,                   // xSrc
                        ySrc,                   // ySrc
                        cxSrc,                  // cxSrc
                        cySrc,                  // cySrc
                        &xformSrc,              // source DC transform
                        clrBkSrc,               // source DC BkColor
                        &bmihCompat,            // source bitmap info header
                        hbmCompat,              // source bitmap to save
                        cbBitsInfoCompat,       // size of bitmap info
                        cbBitsCompat            // size of bits buffer
                    );
            break;
        case EMR_ALPHABLEND:
            bRet = MF_DoAlphaBlend(
                                   pmdcDst,                // pmdcDst
                                   xDst,                   // xDst
                                   yDst,                   // yDst
                                   cxDst,                  // cxDst
                                   cyDst,                  // cyDst
                                   rop,                    // rop
                                   xSrc,                   // xSrc
                                   ySrc,                   // ySrc
                                   cxSrc,                  // cxSrc
                                   cySrc,                  // cySrc
                                   &xformSrc,              // source DC transform
                                   clrBkSrc,               // source DC BkColor
                                   &bmihCompat,            // source bitmap info header
                                   hbmCompat,              // source bitmap to save
                                   cbBitsInfoCompat,       // size of bitmap info
                                   cbBitsCompat            // size of bits buffer
                       );
            break;
        case EMR_TRANSPARENTBLT:
            bRet = MF_DoTransparentBlt(
                                         pmdcDst,                // pmdcDst
                                         xDst,                   // xDst
                                         yDst,                   // yDst
                                         cxDst,                  // cxDst
                                         cyDst,                  // cyDst
                                         rop,                    // rop
                                         xSrc,                   // xSrc
                                         ySrc,                   // ySrc
                                         cxSrc,
                                         cySrc,
                                         &xformSrc,              // source DC transform
                                         clrBkSrc,               // source DC BkColor
                                         &bmihCompat,            // source bitmap info header
                                         hbmCompat,              // source bitmap to save
                                         cbBitsInfoCompat,       // size of bitmap info
                                         cbBitsCompat            // size of bits buffer
                       );
            break;
        }

    mfbb_src_exit:

        // Clean up and go home.

        if (iSaveState)
        {
            if (!RestoreDC(hdcSrc, -1))
            {
                ASSERTGDI(FALSE, "MF_AnyBitBlt: RestoreDC failed");
            }
        }

        if (hbmTmp)
        {
            if (!SelectObject(hdcCompat, hbmTmp))
            {
                ASSERTGDI(FALSE, "MF_AnyBitBlt: SelectObject failed");
            }
        }

        if (hbmCompat)
        {
            if (!DeleteObject(hbmCompat))
            {
                ASSERTGDI(FALSE, "MF_AnyBitBlt: DeleteObject failed");
            }
        }

        if (hdcCompat)
        {
            if (!DeleteDC(hdcCompat))
            {
                ASSERTGDI(FALSE, "MF_AnyBitBlt: DeleteDC failed");
            }
        }

        return(bRet);
    }

// It requires no source DC.

    switch (mrType)
    {
// StretchBlt is just a BitBlt here.

    case EMR_BITBLT:
    case EMR_STRETCHBLT:
        return
        (
            MF_DoBitBlt
            (
                pmdcDst,
                xDst,
                yDst,
                cxDst,
                cyDst,
                rop
            )
        );

    case EMR_MASKBLT:

        return
        (
            MF_DoMaskBlt
            (
                pmdcDst,
                xDst,
                yDst,
                cxDst,
                cyDst,
                rop,
                pbmihMask,
                hbmMask,
                cbBitsInfoMask,
                cbBitsMask,
                xMask,
                yMask,
                xSrc,
                ySrc,
                &xformSrc
            )
        );

// PlgBlt requires a source.

    case EMR_PLGBLT:
        ASSERTGDI(FALSE, "MF_AnyBitBlt: Source needed in PlgBlt");
        return(FALSE);
    }
    return FALSE;
}

// SetDIBitsToDevice (for both 16- and 32-bit metafiles)
// StretchDIBits (for both 16- and 32-bit metafiles)

extern "C" BOOL MF_AnyDIBits
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    int     cxDst,
    int     cyDst,
    int     xDib,
    int     yDib,
    int     cxDib,
    int     cyDib,
    DWORD   iStartScan,
    DWORD   cScans,
    CONST VOID * pBitsDib,
    CONST BITMAPINFO *pBitsInfoDib,
    DWORD   iUsageDib,
    DWORD   rop,
    DWORD   mrType
)
{
    DWORD       cbBitsInfoDib = 0;
    DWORD       cbBitsDib     = 0;
    DWORD       cbProfData    = 0;
    VOID       *pProfData     = NULL;

    PUTS("MF_AnyDIBits\n");

    ASSERTGDI(mrType == EMR_SETDIBITSTODEVICE || mrType == EMR_STRETCHDIBITS
           || mrType == META_SETDIBTODEV || mrType == META_STRETCHDIB,
        "MF_AnyDIBits: Bad mrType");


    ASSERTGDI(mrType == EMR_STRETCHDIBITS || mrType == META_STRETCHDIB
           || rop == SRCCOPY,
        "MF_AnyDIBits: Bad rop");

    if (ISSOURCEINROP3(rop))
    {
        // Get the bitmap sizes.
        // We will store only BITMAPINFO in the record only.  The
        // BITMAPCOREINFO structure will be converted and stored as
        // BITMAPINFO in the metafile.

        // If it is a SetDIBitsToDevice, cScans cannot be zero.
        // If it is a StretchDIBits, cScans must be zero.
        if (mrType == EMR_SETDIBITSTODEVICE || mrType == META_SETDIBTODEV)
            if (!cScans)
                return(FALSE);

        if (!bMetaGetDIBInfo(hdcDst, (HBITMAP) 0, (PBMIH) pBitsInfoDib,
                &cbBitsInfoDib, &cbBitsDib, iUsageDib, cScans, FALSE))
            return(FALSE);

        // If there is any attached color space data, get pointer to that.
        // (only for BITMAPV5 headers.

        if (pBitsInfoDib->bmiHeader.biSize == sizeof(BITMAPV5HEADER))
        {
            PBITMAPV5HEADER pBmih5 = (PBITMAPV5HEADER)pBitsInfoDib;

            // if there is any attached profile data, count it on.

            if (((pBmih5->bV5CSType == PROFILE_EMBEDDED) ||
                 (pBmih5->bV5CSType == PROFILE_LINKED))
                  &&
                (pBmih5->bV5ProfileData != 0))
            {
                ICMMSG(("MF_AnyDIBits(): Metafiling attached color profile data\n"));

                pProfData  = (BYTE *)pBmih5 + pBmih5->bV5ProfileData;
                cbProfData = pBmih5->bV5ProfileSize;
            }
        }
    }

    switch (mrType)
    {
    case EMR_SETDIBITSTODEVICE:
        {
            PMRSETDIBITSTODEVICE pmrsdb;

            PLDC pldc;
            DC_PLDC(hdcDst,pldc,FALSE);

            PMDC pmdcDst = (PMDC)pldc->pvPMDC;
            ASSERTGDI(pmdcDst,"no pmdc\n");

            if (!(pmrsdb = (PMRSETDIBITSTODEVICE) pmdcDst->pvNewRecord
                        (SIZEOF_MRSETDIBITSTODEVICE(cbBitsInfoDib,cbBitsDib,cbProfData))))
                return(FALSE);

            pmrsdb->vInit
            (
                pmdcDst,        // pmdcDst
                (LONG) xDst,    // xDst
                (LONG) yDst,    // yDst
                (LONG) xDib,    // xDib
                (LONG) yDib,    // yDib
                (DWORD) cxDib,  // cxDib
                (DWORD) cyDib,  // cyDib
                iStartScan,     // iStartScan
                cScans,         // cScans
                cbBitsDib,      // size of bits buffer
                pBitsDib,       // dib bits
                cbBitsInfoDib,  // size of bitmap info
                pBitsInfoDib,   // dib info
                cbProfData,     // size of color profile data (if BITMAPV5)
                pProfData,      // color profile data
                iUsageDib       // dib info usage
            );
            pmrsdb->vCommit(pmdcDst);
            SET_COLOR_PAGE(pldc);
        }
        break;

    case EMR_STRETCHDIBITS:
        {
            PMRSTRETCHDIBITS pmrstrdb;

            PLDC pldc;
            DC_PLDC(hdcDst,pldc,FALSE);

            PMDC pmdcDst = (PMDC)pldc->pvPMDC;
            ASSERTGDI(pmdcDst,"no pmdc\n");

            if (!(pmrstrdb = (PMRSTRETCHDIBITS) pmdcDst->pvNewRecord
                        (SIZEOF_MRSTRETCHDIBITS(cbBitsInfoDib,cbBitsDib))))
                return(FALSE);

            pmrstrdb->vInit
            (
                pmdcDst,        // pmdcDst
                (LONG) xDst,    // xDst
                (LONG) yDst,    // yDst
                (LONG) cxDst,   // cxDst
                (LONG) cyDst,   // cyDst
                (LONG) xDib,    // xDib
                (LONG) yDib - iStartScan,    // yDib
                (LONG) cxDib,   // cxDib
                (LONG) cyDib,   // cyDib
                cScans,         // cScans
                cbBitsDib,      // size of bits buffer
                cScans ? ((PBYTE)pBitsDib) +
                         CJSCAN(pBitsInfoDib->bmiHeader.biWidth,pBitsInfoDib->bmiHeader.biPlanes,
                         pBitsInfoDib->bmiHeader.biBitCount)* iStartScan
                         : pBitsDib,    // dib bits
                cbBitsInfoDib,  // size of bitmap info
                pBitsInfoDib,   // dib info
                iUsageDib,      // dib info usage
                cbProfData,     // size of color profile data (if BITMAPV5)
                pProfData,      // color profile data
                rop             // rop
            );
            pmrstrdb->vCommit(pmdcDst);
            SET_COLOR_PAGE(pldc);
        }
        break;

    case META_SETDIBTODEV:
    case META_STRETCHDIB:
        {
            // Do not handle DIB_PAL_INDICES because there is no palette
            // information available.

            if (cbBitsInfoDib != 0 && iUsageDib == DIB_PAL_INDICES)
                return(FALSE);

            // Convert new bitmap formats to win3 bitmap formats

            if (cbBitsInfoDib != 0
             && (pBitsInfoDib->bmiHeader.biSize == sizeof(BMIH))
             && (pBitsInfoDib->bmiHeader.biPlanes != 1
               ||pBitsInfoDib->bmiHeader.biBitCount == 16
               ||pBitsInfoDib->bmiHeader.biBitCount == 32))
            {
                BOOL    b       = FALSE;
                HDC     hdc     = (HDC) 0;
                HBITMAP hbm     = (HBITMAP) 0;
                PBYTE   pBits24 = (PBYTE) NULL;
                DWORD   cbBits24;
                BMIH    bmih;

                if (iUsageDib == DIB_PAL_COLORS)
                    return(FALSE);      // illegal usage

                hdc = CreateCompatibleDC((HDC) 0);

                if (!(hbm = CreateDIBitmap(hdc,
                                (LPBITMAPINFOHEADER) pBitsInfoDib,
                                CBM_CREATEDIB, (LPBYTE) NULL, pBitsInfoDib, DIB_RGB_COLORS)))
                    goto error_exit;

                if (!SetDIBits(hdc, hbm,
                    cScans ? (UINT) iStartScan : 0,
                    cScans ? (UINT) cScans : (UINT) pBitsInfoDib->bmiHeader.biHeight,
                    (CONST VOID *) pBitsDib, pBitsInfoDib, (UINT) iUsageDib))
                    goto error_exit;

                bmih = *(PBITMAPINFOHEADER) pBitsInfoDib;
                bmih.biPlanes       = 1;
                bmih.biBitCount     = 24;
                bmih.biCompression  = BI_RGB;
                bmih.biSizeImage    = 0;
                bmih.biClrUsed      = 0;
                bmih.biClrImportant = 0;

                cbBits24 = CJSCAN(bmih.biWidth,bmih.biPlanes,bmih.biBitCount)
                            * (cScans ? cScans : ABS(bmih.biHeight));

                pBits24 = (LPBYTE) LocalAlloc(LMEM_FIXED, (UINT) cbBits24);
                if (pBits24 == (LPBYTE) NULL)
                    goto error_exit;

                // Get bitmap info and bits in 24bpp.

                if (!GetDIBits(hdc,
                       hbm,
                       cScans ? (UINT) iStartScan : 0,
                       cScans ? (UINT) cScans : (UINT) bmih.biHeight,
                       (LPVOID) pBits24,
                       (LPBITMAPINFO) &bmih,
                       DIB_RGB_COLORS))
                    goto error_exit;

                b = MF16_RecordDIBits
                    (
                        hdcDst,
                        xDst,
                        yDst,
                        cxDst,
                        cyDst,
                        xDib,
                        yDib,
                        cxDib,
                        cyDib,
                        iStartScan,
                        cScans,
                        cbBits24,
                        pBits24,
                        sizeof(bmih),
                        (LPBMI) &bmih,
                        DIB_RGB_COLORS,
                        rop,
                        mrType
                    );

            error_exit:
                if (hdc)
                    DeleteDC(hdc);
                if (hbm)
                    DeleteObject(hbm);
                if (pBits24)
                    LocalFree((HANDLE) pBits24);
                return(b);
            }
            else
            {
                return
                (
                    MF16_RecordDIBits
                    (
                        hdcDst,
                        xDst,
                        yDst,
                        cxDst,
                        cyDst,
                        xDib,
                        yDib,
                        cxDib,
                        cyDib,
                        iStartScan,
                        cScans,
                        cbBitsDib,
                        pBitsDib,
                        cbBitsInfoDib,
                        pBitsInfoDib,
                        iUsageDib,
                        rop,
                        mrType
                    )
                );
            }
        }
    }

    return(TRUE);
}

// SetFontXform
// This function is called only by the metafile playback code.
// If hdc is an enhanced metafile DC, we need to remember the scales
// so that we can metafile it in the compatible ExtTextOut or PolyTextOut
// record that follows.

extern "C" BOOL MF_SetFontXform(HDC hdc,FLOAT exScale,FLOAT eyScale)
{
    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    pmdc->exFontScale(exScale);
    pmdc->eyFontScale(eyScale);

    return(TRUE);
}

// TextOutA
// TextOutW
// ExtTextOutA
// ExtTextOutW

extern "C" BOOL MF_ExtTextOut(
    HDC hdc
  , int x
  , int y
  , UINT fl
  , CONST RECT *prcl
  , LPCSTR psz
  , int c
  , CONST INT *pdx
  , DWORD mrType
  )
{
#define BUFCOUNT 256
    WCHAR         awc[BUFCOUNT];
    WCHAR        *pwsz;
    PLDC          pldc;
    int           bAlloc = 0;
    BOOL          bRet = TRUE;
    DWORD         dwCP;
    INT           pDxCaptureBuffer[BUFCOUNT * 2]; // just in case there is pdy
    INT           cSave;
    PVOID	      pDCAttr;

    switch (mrType)
    {
    case EMR_EXTTEXTOUTW:

        pwsz = (WCHAR*) psz;
        break;

    case EMR_EXTTEXTOUTA:

        if (c < BUFCOUNT)
        {
            // if the multi byte string is small enough then use
            // the buffer on the frame

            pwsz = awc;
        }
        else
        {
            if (!(pwsz = (WCHAR*) LOCALALLOC((c+1) * (sizeof(WCHAR)+
            ((fl & ETO_PDY) ? (sizeof(INT) * 2) : sizeof(INT))))))
            {
                WARNING("MF_ExtTextOut: failed memory allocation\n");
                return(FALSE);
            }
            bAlloc = 1;
        }

        dwCP = GetCodePage(hdc);

        if(fFontAssocStatus)
        {
            dwCP = FontAssocHack(dwCP,(char*)psz,c);
        }

        cSave = c;

        c = MultiByteToWideChar(dwCP, 0, psz, c, pwsz, c*sizeof(WCHAR));
        break;

    default:

        WARNING("MF_ExtTextOut: Bad record type");
        return(FALSE);

    }

    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_ExtTextOut\n");

    pldc = GET_PLDC( hdc );

    if (pldc == NULL)
    {
    WARNING("MF_ExtTextOut: unable to retrieve pldc\n");
    if (bAlloc)
    {
        LOCALFREE((void*) pwsz);
    }

    return(FALSE);
    }

    if( (pldc->fl & (LDC_FONT_CHANGE | LDC_FONT_SUBSET | LDC_LINKED_FONTS)) &&
        (pldc->fl & (LDC_DOWNLOAD_FONTS | LDC_FORCE_MAPPING )) )
    {
        bDoFontChange(hdc, pwsz, c, fl);
        pldc->fl &= ~LDC_FONT_CHANGE;
    }
    else if (!(pldc->fl & (LDC_DOWNLOAD_FONTS | LDC_FORCE_MAPPING)) &&            // local printing
             (pldc->fl & LDC_EMBED_FONTS))                                      // current process has embedded fonts
    {
        bRecordEmbedFonts(hdc);
    }

    PSHARED_GET_VALIDATE(pDCAttr,hdc,DC_TYPE);

    // optimization for printing.  If there is no pdx array, lTextExtra, lBreakExtra and cBreak, don't record pdx

    if((pldc->fl & LDC_META_PRINT) && (pdx == NULL) && ( ((PDC_ATTR)pDCAttr)->lTextExtra == 0 ) && 
    	( ((PDC_ATTR)pDCAttr)->lBreakExtra == 0 ) && ( ((PDC_ATTR)pDCAttr)->cBreak == 0) )
    {
        PMRSMALLTEXTOUT pmrsto;
        BOOL bSmallGlyphs = TRUE;
        int cGlyphs;
        UINT cSize;

        for( cGlyphs = 0; cGlyphs < c; cGlyphs++ )
        {
            if( pwsz[cGlyphs] & 0xFF00 )
            {
                bSmallGlyphs = FALSE;
                break;
            }
        }

        cSize = sizeof(MRSMALLTEXTOUT);
        cSize += c * ( ( bSmallGlyphs ) ? sizeof(char) : sizeof(WCHAR) );
        cSize += ( prcl == NULL ) ? 0 : sizeof(RECT);
        cSize = ( cSize + 3 ) & ~3;

        if( !(pmrsto = (PMRSMALLTEXTOUT) pmdc->pvNewRecord(cSize)) )
        {
            bRet = FALSE;
        }
        else
        {
            pmrsto->vInit(hdc,
                          pmdc,
                          EMR_SMALLTEXTOUT,
                          x,
                          y,
                          fl,
                          (RECT*) prcl,
                          c,
                          pwsz,
                          bSmallGlyphs );

            pmrsto->vCommit(pmdc);
        }
    }
    else
    {
        PMREXTTEXTOUT pmreto;
        UINT cjCh = sizeof(WCHAR);

        INT *pDxCapt = (INT *)pdx;

        if((mrType == EMR_EXTTEXTOUTA) && (pdx != NULL))
        {
            if (IS_ANY_DBCS_CODEPAGE(dwCP))
            {
                pDxCapt = (bAlloc) ? (INT*) &pwsz[(cSave+1)&~1] : pDxCaptureBuffer;

                ConvertDxArray(dwCP,
                               (char*) psz,
                               (int*) pdx,
                               cSave,
                               pDxCapt,
                               (BOOL)(fl & ETO_PDY)
                               );
            }
            else
            {
                pDxCapt = (INT *)pdx;
            }
        }

        if(!(pmreto=(PMREXTTEXTOUT)pmdc->pvNewRecord(SIZEOF_MREXTTEXTOUT(c,cjCh,(fl & ETO_PDY)))) ||
           !pmreto->bInit(EMR_EXTTEXTOUTW,pmdc,hdc,x,y,fl,prcl,(LPCSTR)pwsz,
                          c,(CONST INT *)pDxCapt,cjCh))
        {
            bRet = FALSE;
        }
        else
        {
            pmreto->vCommit(pmdc);
        }
    }

    if (bAlloc)
        LOCALFREE((void*) pwsz);

    return(bRet);
#undef BUFCOUNT
}

// PolyTextOutA
// PolyTextOutW

extern "C" BOOL MF_PolyTextOut(HDC hdc, CONST POLYTEXTA *ppta, int c, DWORD mrType)
{
    DWORD mrTypeT;
    BOOL b;
    CONST POLYTEXTA *pptaT;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_PolyTextOut\n");

    // [kirko] 19-Apr-94
    //
    // I have changed this routine to call off to MF_ExtTextOut for each member
    // of the POLYTEXT? array. This is a little sleazy in that we are recording
    // a different function than what was sent down by the application. On the
    // other hand, it works and it is not incompatible with Chicago since they
    // don't support a PolyTextOut function. You may be concerned that we are losing
    // speed since we no longer call off to the spiffy fase PolyTextOut routine.
    // But, if you look in GDI you will find that that PolyTextOut just calls off
    // to ExtTextOut in a loop. We have just moved the loop to the Metafile recording.
    // If PolyTextOut is ever made fast again, the Metafile code should then be
    // modified to record those calls directly.

    switch (mrType)
    {
    case EMR_POLYTEXTOUTA:
        mrTypeT = EMR_EXTTEXTOUTA;
        break;
    case EMR_POLYTEXTOUTW:
        mrTypeT = EMR_EXTTEXTOUTW;
        break;
    default:
        WARNING("MF_PolyTextOut -- bad mrType");
        return(FALSE);
    }

    for (b = TRUE, pptaT = ppta + c; ppta < pptaT && b; ppta++)
    {
        b = MF_ExtTextOut(hdc, ppta->x, ppta->y, ppta->uiFlags, &(ppta->rcl)
                                      , ppta->lpstr, ppta->n, ppta->pdx, mrTypeT);
    }
    return(b);
}

extern "C" BOOL MF_ExtFloodFill(HDC hdc,int x,int y,COLORREF color,DWORD iMode)
{
    PMREXTFLOODFILL pmreff;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_ExtFloodFill\n");

    if (!(pmreff = (PMREXTFLOODFILL) pmdc->pvNewRecord(SIZEOF_MREXTFLOODFILL)))
        return(FALSE);

    pmreff->vInit(x, y, color, iMode);
    pmreff->vCommit(pmdc);
    return(TRUE);
}

// SetColorAdjustment

extern "C" BOOL MF_SetColorAdjustment(HDC hdc, CONST COLORADJUSTMENT *pca)
{
    PMRSETCOLORADJUSTMENT pmrsca;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    PUTS("MF_SetColorAdjustment\n");

    if (!(pmrsca = (PMRSETCOLORADJUSTMENT) pmdc->pvNewRecord(SIZEOF_MRSETCOLORADJUSTMENT(pca))))
        return(FALSE);

    pmrsca->vInit(pca);
    pmrsca->vCommit(pmdc);
    return(TRUE);
}



extern "C" BOOL MF_WriteEscape(HDC hdc, int nEscape, int nCount, LPCSTR lpInData, int type )
{
    PMRESCAPE   pmre;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    MFD2("Recording escape %d\n", nEscape );

    // just in case some one (pagemaker) passes in NULL with non 0 count!

    if (lpInData == NULL)
        nCount = 0;

    if (!(pmre = (PMRESCAPE) pmdc->pvNewRecord((sizeof(MRESCAPE)+nCount+3)&~3)))
    {
        WARNING("MF_WriteEscape: failed memory allocation\n");
        return(FALSE);
    }

    pmre->vInit(type, nEscape, nCount, lpInData);
    pmre->vCommit(pmdc);

    if (type == EMR_DRAWESCAPE ||
        nEscape == PASSTHROUGH ||
        nEscape == POSTSCRIPT_DATA ||
        nEscape == POSTSCRIPT_PASSTHROUGH ||
        nEscape == ENCAPSULATED_POSTSCRIPT)
    {
        SET_COLOR_PAGE (pldc);
    }

    return(TRUE);
}


extern "C" BOOL MF_WriteNamedEscape(
    HDC hdc,
    LPWSTR pwszDriver,
    int nEscape,
    int nCount,
    LPCSTR lpInData)
{
    PMRNAMEDESCAPE   pmre;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    MFD2("Recording named escape %d\n", nEscape );

    INT cjSizeOfRecord = (sizeof(MRNAMEDESCAPE) + nCount +
      ((wcslen(pwszDriver)+1) * sizeof(WCHAR)) +3)&~3;

    if(!(pmre = (PMRNAMEDESCAPE) pmdc->pvNewRecord(cjSizeOfRecord)))
    {
        WARNING("MF_WriteEscape: failed memory allocation\n");
        return(FALSE);
    }

    pmre->vInit(EMR_NAMEDESCAPE, nEscape, pwszDriver, lpInData, nCount);
    pmre->vCommit(pmdc);

    return(TRUE);
}


extern "C" BOOL MF_StartDoc(HDC hdc, CONST DOCINFOW *pDocInfo )
{
    PMRSTARTDOC pmrs;
    DWORD       cj;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    MFD1( "Recording MF_StartDocW\n" );

    cj = sizeof(MRSTARTDOC);

    if( pDocInfo->lpszDocName != NULL )
    {
        cj += (lstrlenW( pDocInfo->lpszDocName ) + 1) * sizeof(WCHAR);
        cj = (cj+3) & ~(0x3);
    }

    if( pDocInfo->lpszOutput != NULL )
    {
        cj += (lstrlenW( pDocInfo->lpszOutput ) + 1) * sizeof(WCHAR);
    }

    cj = (cj+3) & ~(0x3); // make things DWORD alligned


    if (!(pmrs = (PMRSTARTDOC) pmdc->pvNewRecord( cj+40 )))
    {
        WARNING("MF_StartDoc: failed memory allocation\n");
        return(FALSE);
    }

    pmrs->vInit(EMR_STARTDOC, pDocInfo);
    pmrs->vCommit(pmdc);

    return(TRUE);
}


extern "C" BOOL MF_ForceUFIMapping(HDC hdc, PUNIVERSAL_FONT_ID pufi )
{
    PMRFORCEUFIMAPPING   pmre;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    MFD1("Recording forced mapping\n");

    if (!(pmre = (PMRFORCEUFIMAPPING) pmdc->pvNewRecord(sizeof(MRFORCEUFIMAPPING))))
    {
        WARNING("MF_ForceUFIMapping: failed memory allocation\n");
        return(FALSE);
    }

    pmre->vInit(EMR_FORCEUFIMAPPING, pufi);
    pmre->vCommit(pmdc);

    return(TRUE);
}

extern "C" BOOL MF_SetLinkedUFIs(HDC hdc, PUNIVERSAL_FONT_ID pufi,UINT uNumLinkedUFIs )
{
    PMRSETLINKEDUFIS pmre;
    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc,"no pmdc\n");

    MFD1("Recording SetLinkedUFIs\n");

    UINT AllocationSize = sizeof(MRSETLINKEDUFIS) + sizeof(UNIVERSAL_FONT_ID) *
      uNumLinkedUFIs;

    if(!(pmre = (PMRSETLINKEDUFIS) pmdc->pvNewRecord(AllocationSize)))
    {
        WARNING("MF_orceUFIMapping: failed memory allocation\n");
        return(FALSE);
    }

    pmre->vInit(uNumLinkedUFIs, pufi);
    pmre->vCommit(pmdc);

    return(TRUE);
}

// OpenGL metafile records


BOOL APIENTRY GdiAddGlsRecord(HDC hdc, DWORD cb, BYTE *pb, LPRECTL prclBounds)
{
    PMRGLSRECORD pmrgr;
    PMRGLSBOUNDEDRECORD pmrgbr;

    PLDC pldc;
    DC_PLDC(hdc, pldc, FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc, "no pmdc\n");

    if (prclBounds == NULL)
    {
        pmrgr = (PMRGLSRECORD)pmdc->pvNewRecord(SIZEOF_MRGLSRECORD(cb));
        if (pmrgr == NULL)
        {
            return FALSE;
        }

        pmrgr->vInit(cb, pb);
        pmrgr->vCommit(pmdc);
    }
    else
    {
        pmrgbr = (PMRGLSBOUNDEDRECORD)
            pmdc->pvNewRecord(SIZEOF_MRGLSBOUNDEDRECORD(cb));
        if (pmrgbr == NULL)
        {
            return FALSE;
        }

        pmrgbr->vInit(cb, pb, prclBounds);
        pmrgbr->vCommit(pmdc);
    }

    // Mark the metafile as containing OpenGL records
    pmdc->mrmf.bOpenGL = TRUE;

    // NTFIXED #34919(old RaidDB 423900) 02-07-2000 pravins OPENGL PRINT: Prints
    // to many color printers in black an white only.
    // This page can be a color.
    SET_COLOR_PAGE(pldc);

    return TRUE;
}



extern "C" BOOL APIENTRY GdiAddGlsBounds(HDC hdc, LPRECTL prclBounds)
{
    // Bounds are given as a well-ordered rectangle in
    // device coordinates
    return SetBoundsRectAlt(hdc, (RECT *)prclBounds,
                            (UINT)(DCB_WINDOWMGR | DCB_ACCUMULATE)) != 0;
}



extern "C" BOOL APIENTRY MF_SetPixelFormat(HDC hdc,
                                           int iPixelFormat,
                                           CONST PIXELFORMATDESCRIPTOR *ppfd)
{
    PMRPIXELFORMAT pmrpf;

    PLDC pldc;
    DC_PLDC(hdc, pldc, FALSE);

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc, "no pmdc\n");

    pmrpf = (PMRPIXELFORMAT)pmdc->pvNewRecord(SIZEOF_MRPIXELFORMAT);
    if (pmrpf == NULL)
    {
        return FALSE;
    }

    pmrpf->vInit(ppfd);
    pmrpf->vCommit(pmdc);

    // Fix up the pixel format offset in the header
    // This only allows one pixel format to be
    // described in the header.  This doesn't seem too bad
    // but we don't really need the pixel format offset in the
    // header since there should always be a pixel format record
    // in the metafile (as long as a pixel format is set)
    pmdc->mrmf.cbPixelFormat = sizeof(PIXELFORMATDESCRIPTOR);
    pmdc->mrmf.offPixelFormat = pmdc->iMem-sizeof(MRPIXELFORMAT)+
        FIELD_OFFSET(MRPIXELFORMAT, pfd);

    return TRUE;
}



extern "C" BOOL APIENTRY MF_SetICMProfile(HDC hdc, LPBYTE lpFile, PVOID pvColorSpace, DWORD dwRecordType)
{
    BOOL bRet = TRUE;

    PMRSETICMPROFILE pmsip;
    WCHAR UnicFileName[MAX_PATH];
    WCHAR PathFileName[MAX_PATH+1];

    PCACHED_COLORSPACE pColorSpace = (PCACHED_COLORSPACE) pvColorSpace;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PUTS("MF_SetICMProfile\n");

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc, "no pmdc\n");

    ASSERTGDI((dwRecordType == EMR_SETICMPROFILEA) ||
              (dwRecordType == EMR_SETICMPROFILEW), "Invalid Record Type\n");

    CLIENT_SIDE_FILEVIEW MappedProfile;

    DWORD  dwFlags = 0;

    DWORD  dwNameLength = 0;
    DWORD  dwDataLength = 0;
    LPBYTE lpName = NULL;
    LPBYTE lpData = NULL;

#if DBG
    BOOL   bDownload = ((pldc->fl & LDC_DOWNLOAD_PROFILES) || (DbgIcm & DBG_ICM_METAFILE));
#else
    BOOL   bDownload = (pldc->fl & LDC_DOWNLOAD_PROFILES);
#endif

    if (pColorSpace)
    {
        ICMMSG(("MF_SetICMProfile[A|W]():Metafiling by color space\n"));

        //
        // Get profile name from CACHED_COLORSPACE.
        //
        lpName = (PBYTE)&(pColorSpace->LogColorSpace.lcsFilename[0]);

        //
        // Unicode record.
        //
        dwRecordType = EMR_SETICMPROFILEW;
    }
    else if (lpFile)
    {
        ICMMSG(("MF_SetICMProfile[A|W]():Metafiling by file name\n"));

        //
        // If ansi API, the lpName is ansi based string, Convert the string to Unicode.
        //
        if (bDownload && (dwRecordType == EMR_SETICMPROFILEA))
        {
            //
            // Convert ANSI to Unicode.
            //
            vToUnicodeN(UnicFileName,MAX_PATH,(char *)lpFile,strlen((char *)lpFile)+1);
            lpName = (LPBYTE) UnicFileName;

            //
            // And this is download, which means only EMF-spooling case comes here.
            // so this record is only play back on NT. thus we are safe to convert
            // record this as Unicode.
            //
            dwRecordType = EMR_SETICMPROFILEW;
        }
        else
        {
            lpName = lpFile;
        }
    }
    else
    {
        return FALSE;
    }

    //
    // We must have color profile (since this is destination color space).
    //
    if (dwRecordType == EMR_SETICMPROFILEW)
    {
        ICMMSG(("MF_SetICMProfileW():Metafiling - %ws\n",lpName));

        if (*(WCHAR *)lpName == UNICODE_NULL)
        {
            ICMMSG(("MF_SetICMProfile() ANSI: no profile name is given\n"));
            return FALSE;
        }
    }
    else
    {
        ICMMSG(("MF_SetICMProfileA():Metafiling - %s\n",lpName));

        if (*(char *)lpName == NULL)
        {
            ICMMSG(("MF_SetICMProfile() UNICODE: no profile name is given\n"));
            return FALSE;
        }
    }

    RtlZeroMemory(&MappedProfile,sizeof(CLIENT_SIDE_FILEVIEW));

    if (bDownload)
    {
        //
        // We are in profile attached mode.
        //
        dwFlags = SETICMPROFILE_EMBEDED;

        //
        // Normalize ICC profile path
        //
        BuildIcmProfilePath((WCHAR *)lpName, PathFileName, MAX_PATH);

        //
        // Check we already attached this or not.
        //
        if (pmdc->bExistColorProfile(PathFileName))
        {
            ICMMSG(("MF_SetICMProfile():Exist in metafile FileImage - %ws\n",PathFileName));
        }
        else
        {
            ICMMSG(("MF_SetICMProfile():Attaching in metafile FileImage - %ws\n",PathFileName));

            if (pColorSpace && (pColorSpace->ColorProfile.dwType == PROFILE_MEMBUFFER))
            {
                lpData = (PBYTE)(pColorSpace->ColorProfile.pProfileData);
                dwDataLength = pColorSpace->ColorProfile.cbDataSize;
            }
            else
            {
                if (!bMapFileUNICODEClideSide(PathFileName,&MappedProfile,FALSE))
                {
                    return FALSE;
                }

                lpData = (PBYTE) MappedProfile.pvView;
                dwDataLength = MappedProfile.cjView;
            }

            // Mark we attach this profile into metafile
            //
            pmdc->vInsertColorProfile((WCHAR *)PathFileName);
        }

        // WINBUG 365045 4-10-2001 pravins Possible work item in MF_SetICMProfile
        //
        // Old Comment:
        //     [THIS PART NEED TO BE RE-CONSIDERRED]
        //
        //     Only record filename, not full path. (when we attach profile)
        //
        lpName = (LPBYTE) GetFileNameFromPath((WCHAR *)PathFileName);
    }

    if (dwRecordType == EMR_SETICMPROFILEA)
    {
        //
        // Compute the data length (string is ansi)
        //
        dwNameLength = strlen((CHAR *)lpName) + 1;
    }
    else
    {
        //
        // Compute the data length (string is unicode)
        //
        dwNameLength = (wcslen((WCHAR *)lpName) + 1) * sizeof(WCHAR);
    }

    pmsip = (PMRSETICMPROFILE)pmdc->pvNewRecord(SIZEOF_MRSETICMPROFILE(dwNameLength+dwDataLength));

    if (pmsip == NULL)
    {
        bRet = FALSE;
    }
    else
    {
        pmsip->vInit(dwRecordType,dwFlags,dwNameLength,lpName,dwDataLength,lpData);
        pmsip->vCommit(pmdc);
    }

    if (MappedProfile.hSection)
    {
        vUnmapFileClideSide(&MappedProfile);
    }

    return bRet;
}



extern "C" BOOL APIENTRY MF_ColorMatchToTarget(HDC hdc, DWORD dwAction, PVOID pvColorSpace, DWORD dwRecordType)
{
    BOOL bRet = TRUE;

    PMRCOLORMATCHTOTARGET pmcmt;
    WCHAR PathFileName[MAX_PATH+1];

    PCACHED_COLORSPACE pColorSpace = (PCACHED_COLORSPACE) pvColorSpace;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PUTS("MF_ColorMatchToTarget\n");

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc, "no pmdc\n");

    ASSERTGDI(dwRecordType == EMR_COLORMATCHTOTARGETW, "Invalid Record Type\n");

    DWORD  dwFlags = 0;

    DWORD  dwNameLength = 0;
    DWORD  dwDataLength = 0;
    LPBYTE lpName = NULL;
    LPBYTE lpData = NULL;

    CLIENT_SIDE_FILEVIEW MappedProfile;

    RtlZeroMemory(&MappedProfile,sizeof(CLIENT_SIDE_FILEVIEW));

    if (dwAction == CS_ENABLE)
    {
        //
        // Get profile name from CACHED_COLORSPACE.
        //
        lpName = (PBYTE)&(pColorSpace->LogColorSpace.lcsFilename[0]);

        //
        // We must have color profile (since this is target color space).
        //
        if (*(WCHAR *)lpName == UNICODE_NULL)
        {
            ICMMSG(("MF_ColorMatchToTarget():no profile name in LOGCOLORSPACE\n"));
            return FALSE;
        }

        ICMMSG(("MF_ColorMatchToTarget():Metafiling - %ws\n",lpName));

    #if DBG
        if ((pldc->fl & LDC_DOWNLOAD_PROFILES) || (DbgIcm & DBG_ICM_METAFILE))
    #else
        if (pldc->fl & LDC_DOWNLOAD_PROFILES)
    #endif
        {
            //
            // We are in profile attached mode.
            //
            dwFlags = COLORMATCHTOTARGET_EMBEDED;

            //
            // Normalize ICC profile path
            //
            BuildIcmProfilePath((WCHAR *)lpName, PathFileName, MAX_PATH);

            //
            // Check we already attached this or not.
            //
            if (pmdc->bExistColorProfile((WCHAR *)PathFileName))
            {
                ICMMSG(("MF_ColorMatchToTarget():Exist in metafile FileImage - %ws\n",PathFileName));
            }
            else
            {
                ICMMSG(("MF_ColorMatchToTarget():Attaching in metafile FileImage - %ws\n",PathFileName));

                if (pColorSpace->ColorProfile.dwType == PROFILE_MEMBUFFER)
                {
                    lpData = (PBYTE)(pColorSpace->ColorProfile.pProfileData);
                    dwDataLength = pColorSpace->ColorProfile.cbDataSize;
                }
                else
                {
                    if (!bMapFileUNICODEClideSide(PathFileName,&MappedProfile,FALSE))
                    {
                        return FALSE;
                    }

                    lpData = (PBYTE) MappedProfile.pvView;
                    dwDataLength = MappedProfile.cjView;
                }

                // Mark we attach this profile into metafile
                //
                pmdc->vInsertColorProfile((WCHAR *)PathFileName);
            }

            // WINBUG 365045 4-10-2001 pravins Possible work item in MF_SetICMProfile
            //
            // Old Comment:
            //     [THIS PART NEED TO BE RE-CONSIDERRED]
            //
            //     Only record filename, not full path. (when we attach profile)
            //
            lpName = (LPBYTE) GetFileNameFromPath((WCHAR *)PathFileName);
        }

        //
        // Compute the data length (string is unicode)
        //
        dwNameLength = (wcslen((WCHAR *)lpName) + 1) * sizeof(WCHAR);
    }
    else
    {
        ICMMSG(("MF_ColorMatchToTarget():Metafiling - %d",dwAction));
    }

    pmcmt = (PMRCOLORMATCHTOTARGET)pmdc->pvNewRecord(SIZEOF_MRCOLORMATCHTOTARGET(dwNameLength+dwDataLength));

    if (pmcmt == NULL)
    {
        bRet = FALSE;
    }
    else
    {
        pmcmt->vInit(dwRecordType,dwAction,dwFlags,dwNameLength,lpName,dwDataLength,lpData);
        pmcmt->vCommit(pmdc);
    }

    if (MappedProfile.hSection)
    {
        vUnmapFileClideSide(&MappedProfile);
    }

    return bRet;
}


extern "C" BOOL APIENTRY MF_CreateColorSpaceA(PMDC pmdc, HGDIOBJ hobj, DWORD imhe)
{
    BOOL bRet = TRUE;

    PMRCREATECOLORSPACE pmColorSpaceA;

    PUTS("MF_CreateColorSpaceA\n");

    LOGCOLORSPACEA LogColorSpaceA;

    if (!GetLogColorSpaceA((HCOLORSPACE)hobj,&LogColorSpaceA,sizeof(LOGCOLORSPACEA)))
    {
        ICMMSG(("MF_CreateColorSpaceA():Failed on GetLogColorSpaceW()\n"));
        return FALSE;
    }

#if DBG
    if (LogColorSpaceA.lcsFilename[0] != NULL)
    {
        ICMMSG(("MF_CreateColorSpaceA():Metafiling - %s\n",LogColorSpaceA.lcsFilename));
    }
#endif

    pmColorSpaceA = (PMRCREATECOLORSPACE) pmdc->pvNewRecord(SIZEOF_MRCREATECOLORSPACE);

    if (pmColorSpaceA == NULL)
    {
        bRet = FALSE;
    }
    else
    {
        pmColorSpaceA->vInit((ULONG)imhe,LogColorSpaceA);
        pmColorSpaceA->vCommit(pmdc);
    }

    return bRet;
}

extern "C" BOOL APIENTRY MF_CreateColorSpaceW(
    PMDC pmdc, PLOGCOLORSPACEEXW pLogColorSpaceExW, DWORD imhe, BOOL bDownload)
{
    BOOL bRet = TRUE;

    PMRCREATECOLORSPACEW pmColorSpaceW;
    WCHAR PathFileName[MAX_PATH];

    PUTS("MF_CreateColorSpaceW\n");

    DWORD  dwFlags = 0;

    DWORD  dwDataLength = 0;
    LPBYTE lpData = NULL;

    CLIENT_SIDE_FILEVIEW MappedProfile;

    RtlZeroMemory(&MappedProfile,sizeof(CLIENT_SIDE_FILEVIEW));

    //
    // Check LOGCOLORSPACE has color profile.
    //
    if (pLogColorSpaceExW->lcsColorSpace.lcsFilename[0] != NULL)
    {
        ICMMSG(("MF_CreateColorSpaceW():Metafiling - %ws\n",
                 pLogColorSpaceExW->lcsColorSpace.lcsFilename));
    }

    pmColorSpaceW = (PMRCREATECOLORSPACEW)pmdc->pvNewRecord(SIZEOF_MRCREATECOLORSPACEW(dwDataLength));

    if (pmColorSpaceW == NULL)
    {
        bRet = FALSE;
    }
    else
    {
        pmColorSpaceW->vInit((ULONG)imhe,pLogColorSpaceExW->lcsColorSpace,dwFlags,dwDataLength,lpData);
        pmColorSpaceW->vCommit(pmdc);
    }

    return bRet;
}

extern "C" BOOL APIENTRY MF_InternalCreateColorSpace(HDC hdc,HGDIOBJ hobj,DWORD imhe)
{
    BOOL bRet = TRUE;

    PLDC pldc;
    DC_PLDC(hdc,pldc,FALSE);

    PUTS("MF_InternalCreateColorSpace\n");

    PMDC pmdc = (PMDC)pldc->pvPMDC;
    ASSERTGDI(pmdc, "no pmdc\n");

    LOGCOLORSPACEEXW LogColorSpaceExW;

    //
    // Obtain LOGCOLORSPACEEX from handle.
    //
    if (!NtGdiExtGetObjectW((HCOLORSPACE)hobj,sizeof(LOGCOLORSPACEEXW),&LogColorSpaceExW))
    {
        ICMMSG(("MF_InternalCreateColorSpace():Failed on NtGdiExtGetObject()\n"));
        return (FALSE);
    }

#if DBG
    BOOL bDownload = ((pldc->fl & LDC_DOWNLOAD_PROFILES) || (DbgIcm & DBG_ICM_METAFILE));
#else
    BOOL bDownload = (pldc->fl & LDC_DOWNLOAD_PROFILES);
#endif

    ICMMSG(("MF_InternalCreateColorSpace():dwFlags = %x, bDownload = %d\n",
             LogColorSpaceExW.dwFlags,bDownload));

    //
    // If we are EMF spooling (profile attach case), or color space is created by CreateColorSpaceW(),
    // use Unicode version of record to keep in metafile.
    //

    if ((LogColorSpaceExW.dwFlags & LCSEX_ANSICREATED) && (!bDownload))
    {
        //
        // Create Win9x compatible ANSI record.
        //
        bRet = MF_CreateColorSpaceA(pmdc,hobj,imhe);
    }
    else
    {
        //
        // Create Unicode record.
        //
        bRet = MF_CreateColorSpaceW(pmdc,&LogColorSpaceExW,imhe,bDownload);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\mfrec16.c ===
/****************************** Module Header ******************************\
* Module Name: MfRec16.c
*
* Copyright (c) 1991-1999 Microsoft Corporation
*
* DESCRIPTIVE NAME:   Metafile Recorder
*
* FUNCTION:   Records GDI functions in memory and disk metafiles.
*
* PUBLIC ENTRY POINTS:
*   CloseMetaFile
*   CopyMetaFile
*   CreateMetaFile
*   GetMetaFileBitsEx
*   SetMetaFileBitsEx
* PRIVATE ENTRY POINTS:
*   RecordParms
*   AttemptWrite
*   MarkMetaFile
*   RecordObject
*   ProbeSize
*   AddObjectToDCTable
*
* History:
*  02-Jul-1991 -by-  John Colleran [johnc]
* Combined From Win 3.1 and WLO 1.0 sources
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "mf16.h"



UINT    AddObjectToDCTable(HDC hdc, HANDLE hObject, PUINT piPosition, BOOL bRealAdd);
BOOL    AddDCToObjectMetaList16(HDC hMeta16DC, HANDLE hObject);
BOOL    AttemptWrite(PMFRECORDER16 pMFRec, DWORD dwBytes, LPBYTE lpData);
VOID    MarkMetaFile(PMFRECORDER16 pMFRec);
BOOL    MakeLogPalette(HDC hdc, HANDLE hPal, WORD magic);
HANDLE  ProbeSize(PMFRECORDER16 pMF, DWORD dwLength);
BOOL    RecordCommonBitBlt(HDC hdcDest, INT x, INT y, INT nWidth, INT nHeight,
                HDC hdcSrc, INT xSrc, INT ySrc, INT nSrcWidth, INT nSrcHeight,
                DWORD rop, WORD wFunc);
BOOL    UnlistObjects(HDC hMetaDC);
BOOL    MF16_DeleteRgn(HDC hdc, HANDLE hrgn);


// Metafile Logging stubs for 3.x Metafiles

/******************************Public*Routine******************************\
* XXX_RecordParms
*
* These routines package up the parameters of an NT GDI call and send
* them to a general purpose recording routine that validates the metafile
* DC and records the parameters.
*
* Returns
*    TRUE iff successful
*
* Warnings
*    Windows 3.x metafile behavior is that when a function is being metafiled
*    the routine itself is not called; eg SetPixel does not call GreSetPixel
*    but (GDI) SetPixel intercepts the calls and records the parameters and
*    returns without taking further action
*
* History:
*   24-Nov-1991  -by-    John Colleran  [johnc]
* Wrote it.
\**************************************************************************/

BOOL MF16_RecordParms1(HDC hdc, WORD Func)
{
    return RecordParms(hdc, Func, 0, (LPWORD)NULL);
}

BOOL MF16_RecordParms2(HDC hdc, INT parm2, WORD Func)
{
    return RecordParms(hdc, Func, 1, (LPWORD)&parm2);
}

BOOL MF16_RecordParms3(HDC hdc, INT parm2, INT parm3, WORD Func)
{
    WORD    aw[2];

    aw[0] = (WORD)parm3;
    aw[1] = (WORD)parm2;
    return RecordParms(hdc, Func, 2, aw);
}

BOOL MF16_RecordParms5(HDC hdc, INT parm2, INT parm3, INT parm4, INT parm5, WORD Func)
{
    WORD    aw[4];

    aw[0] = (WORD)parm5;
    aw[1] = (WORD)parm4;
    aw[2] = (WORD)parm3;
    aw[3] = (WORD)parm2;
    return RecordParms(hdc, Func, 4, aw);
}

BOOL MF16_RecordParms7(HDC hdc, INT parm2, INT parm3, INT parm4, INT parm5, INT parm6, INT parm7, WORD Func)
{
    WORD    aw[6];

    aw[0] = (WORD)parm7;
    aw[1] = (WORD)parm6;
    aw[2] = (WORD)parm5;
    aw[3] = (WORD)parm4;
    aw[4] = (WORD)parm3;
    aw[5] = (WORD)parm2;
    return RecordParms(hdc, Func, 6, aw);
}

BOOL MF16_RecordParms9(HDC hdc, INT parm2, INT parm3, INT parm4, INT parm5,
        INT parm6, INT parm7, INT parm8, INT parm9, WORD Func)
{
    WORD    aw[8];

    aw[0] = (WORD)parm9;
    aw[1] = (WORD)parm8;
    aw[2] = (WORD)parm7;
    aw[3] = (WORD)parm6;
    aw[4] = (WORD)parm5;
    aw[5] = (WORD)parm4;
    aw[6] = (WORD)parm3;
    aw[7] = (WORD)parm2;
    return RecordParms(hdc, Func, 8, aw);
}

BOOL MF16_RecordParmsD(HDC hdc, DWORD d1, WORD Func)
{
    return RecordParms(hdc, Func, 2, (LPWORD) &d1);
}

BOOL MF16_RecordParmsWWD(HDC hdc, WORD w1, WORD w2, DWORD d3, WORD Func)
{
    WORD    aw[4];

    aw[0] = LOWORD(d3);
    aw[1] = HIWORD(d3);
    aw[2] = w2;
    aw[3] = w1;
    return RecordParms(hdc, Func, 4, aw);
}

BOOL MF16_RecordParmsWWDW(HDC hdc, WORD w1, WORD w2, DWORD d3, WORD w4, WORD Func)
{
    WORD    aw[5];

    aw[0] = w4;
    aw[1] = LOWORD(d3);
    aw[2] = HIWORD(d3);
    aw[3] = w2;
    aw[4] = w1;
    return RecordParms(hdc, Func, 5, aw);
}

BOOL MF16_RecordParmsWWWWD(HDC hdc, WORD w1, WORD w2, WORD w3, WORD w4, DWORD d5, WORD Func)
{
    WORD    aw[6];

    aw[0] = LOWORD(d5);
    aw[1] = HIWORD(d5);
    aw[2] = w4;
    aw[3] = w3;
    aw[4] = w2;
    aw[5] = w1;
    return RecordParms(hdc, Func, 6, aw);
}

BOOL MF16_RecordParmsPoly(HDC hdc, LPPOINT lpPoint, INT nCount, WORD Func)
{
    BOOL        fRet;
    LPWORD      lpW,lpT;
    DWORD       cw;
    INT         ii;

    cw = (nCount*sizeof(POINTS)/sizeof(WORD))+1;
    lpT = lpW = (LPWORD)LocalAlloc(LMEM_FIXED, cw*sizeof(WORD));
    if (!lpW)
        return(FALSE);

    *lpW++ = (WORD)nCount;

    for(ii=0; ii<nCount; ii++)
    {
        *lpW++ = (WORD)lpPoint[ii].x;
        *lpW++ = (WORD)lpPoint[ii].y;
    }

    fRet = RecordParms(hdc, Func, cw, lpT);

    if (LocalFree((HANDLE)lpT))
        ASSERTGDI(FALSE, "MF16_RecordParmsPoly: LocalFree Failed\n");

    return (fRet);
}

// SetDIBitsToDevice
// StretchDIBits

BOOL MF16_RecordDIBits
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    int     cxDst,
    int     cyDst,
    int     xDib,
    int     yDib,
    int     cxDib,
    int     cyDib,
    DWORD   iStartScan,
    DWORD   cScans,
    DWORD   cbBitsDib,
    CONST VOID * pBitsDib,
    DWORD   cbBitsInfoDib,
    CONST BITMAPINFO *pBitsInfoDib,
    DWORD   iUsageDib,
    DWORD   rop,
    DWORD   mrType
)
{
    BOOL        fRet;
    LPWORD      lpW;
    LPWORD      lpWStart;
    WORD        cwParms;
    PBMIH       lpDIBInfoHeader;

    PUTS("MF16_RecrodDIBits\n");

    ASSERTGDI(mrType == META_SETDIBTODEV || mrType == META_STRETCHDIB,
        "MF16_RecrodDIBits: Bad mrType");

// Get the number of parameters to save.

    cwParms = (WORD) ((mrType == META_SETDIBTODEV) ? 9 : 11);   // in words

// Allocate space for DIB plus parameters.

    lpWStart = lpW = (LPWORD) LocalAlloc(LMEM_FIXED,
                cbBitsInfoDib + (cbBitsDib + 1) / 2 * 2 + cwParms*sizeof(WORD));
    if (!lpW)
    {
        ERROR_ASSERT(FALSE, "MF16_RecordDIBits: out of memory\n");
        return(FALSE);
    }

// Copy the parameters.

    if (mrType == META_SETDIBTODEV)
    {
        *lpW++ = (WORD) iUsageDib;
        *lpW++ = (WORD) cScans;
        *lpW++ = (WORD) iStartScan;
        *lpW++ = (WORD) yDib;
        *lpW++ = (WORD) xDib;
        *lpW++ = (WORD) cyDib;
        *lpW++ = (WORD) cxDib;
        *lpW++ = (WORD) yDst;
        *lpW++ = (WORD) xDst;
    }
    else
    {
        *lpW++ = (WORD) LOWORD(rop);
        *lpW++ = (WORD) HIWORD(rop);
        *lpW++ = (WORD) iUsageDib;
        *lpW++ = (WORD) cyDib;
        *lpW++ = (WORD) cxDib;
        *lpW++ = (WORD) yDib;
        *lpW++ = (WORD) xDib;
        *lpW++ = (WORD) cyDst;
        *lpW++ = (WORD) cxDst;
        *lpW++ = (WORD) yDst;
        *lpW++ = (WORD) xDst;
    }

// Save the start of the bitmap info header field.

    lpDIBInfoHeader = (LPBITMAPINFOHEADER) lpW;

// cbBitsInfoDib must be word sized

    ASSERTGDI(cbBitsInfoDib % 2 == 0,
        "MF16_RecordDIBits: cbBitsInfoDib is not word aligned");

// Copy dib info if given.

    if (cbBitsInfoDib)
    {
        if (pBitsInfoDib->bmiHeader.biSize == sizeof(BMCH))
        {
            CopyCoreToInfoHeader
            (
                lpDIBInfoHeader,
                (LPBITMAPCOREHEADER) pBitsInfoDib
            );

            if (iUsageDib == DIB_RGB_COLORS)
            {
                RGBQUAD   *prgbq;
                RGBTRIPLE *prgbt;
                UINT      ui;

                prgbq = ((PBMI) lpDIBInfoHeader)->bmiColors;
                prgbt = ((PBMC) pBitsInfoDib)->bmciColors;

                ASSERTGDI(cbBitsInfoDib >= sizeof(BMIH),
                    "MF16_RecordDIBits: Bad cbBitsInfoDib size");

                for
                (
                    ui = (UINT) (cbBitsInfoDib - sizeof(BMIH))
                                / sizeof(RGBQUAD);
                    ui;
                    ui--
                )
                {
                    prgbq->rgbBlue     = prgbt->rgbtBlue;
                    prgbq->rgbGreen    = prgbt->rgbtGreen;
                    prgbq->rgbRed      = prgbt->rgbtRed;
                    prgbq->rgbReserved = 0;
                    prgbq++; prgbt++;
                }
            }
            else
            {
                RtlCopyMemory
                (
                    (PBYTE) lpDIBInfoHeader + sizeof(BMIH),
                    (PBYTE) pBitsInfoDib + sizeof(BMCH),
                    cbBitsInfoDib - sizeof(BMIH)
                );
            }
        }
        else
        {
            RtlCopyMemory
            (
                (PBYTE) lpDIBInfoHeader,
                (PBYTE) pBitsInfoDib,
                cbBitsInfoDib
            );

            if (pBitsInfoDib->bmiHeader.biBitCount >= 16)
            {
                DWORD UNALIGNED *pClrUsed = (DWORD UNALIGNED *)&lpDIBInfoHeader->biClrUsed;
                *pClrUsed = 0;
            }

        }
    }

// Copy dib bits.

    RtlCopyMemory((PBYTE) lpDIBInfoHeader + cbBitsInfoDib, pBitsDib, cbBitsDib);

// Finally record the parameters into the file.

    fRet = RecordParms(hdcDst, mrType,
                   cwParms + (cbBitsInfoDib + cbBitsDib + 1) / sizeof(WORD),
                   lpWStart);

    if (lpWStart)
        if (LocalFree((HANDLE) lpWStart))
            ASSERTGDI(FALSE, "MF16_RecordDIBits: LocalFree Failed\n");

    return(fRet);
}

BOOL MF16_BitBlt(HDC hdcDest, INT x, INT y, INT nWidth, INT nHeight,
        HDC hdcSrc, INT xSrc, INT ySrc, DWORD rop)
{
    WORD        aw[9];

// This is how windows works but really it should look at the ROP
    if (hdcDest == hdcSrc || hdcSrc == NULL)
    {
        aw[0] = (WORD)LOWORD(rop);
        aw[1] = (WORD)HIWORD(rop);
        aw[2] = (WORD)ySrc;
        aw[3] = (WORD)xSrc;
        aw[4] = (WORD)0;            // No DC necessary
        aw[5] = (WORD)nHeight;
        aw[6] = (WORD)nWidth;
        aw[7] = (WORD)y;
        aw[8] = (WORD)x;

        return(RecordParms(hdcDest, META_DIBBITBLT, 9, aw));
    }
    else
        return(RecordCommonBitBlt(hdcDest,x,y,nWidth,nHeight,hdcSrc,
                xSrc,ySrc,nWidth,nHeight,rop,META_DIBBITBLT));
}

BOOL MF16_StretchBlt(HDC hdcDest, INT x, INT y, INT nWidth, INT nHeight,
        HDC hdcSrc, INT xSrc, INT ySrc, INT nSrcWidth, INT nSrcHeight, DWORD rop)
{
    WORD    aw[11];

// This is how windows works but really it should look at the ROP
    if (hdcDest == hdcSrc || hdcSrc == NULL)
    {
        aw[0]  = (WORD)LOWORD(rop);
        aw[1]  = (WORD)HIWORD(rop);
        aw[2]  = (WORD)nSrcHeight;
        aw[3]  = (WORD)nSrcWidth;
        aw[4]  = (WORD)ySrc;
        aw[5]  = (WORD)xSrc;
        aw[6]  = (WORD)0;            // No DC necessary
        aw[7]  = (WORD)nHeight;
        aw[8]  = (WORD)nWidth;
        aw[9]  = (WORD)y;
        aw[10] = (WORD)x;

        return(RecordParms(hdcDest, META_DIBSTRETCHBLT, 11, aw));
    }
    else
        return(RecordCommonBitBlt(hdcDest,x,y,nWidth,nHeight,hdcSrc,
                xSrc,ySrc,nSrcWidth,nSrcHeight,rop,META_DIBSTRETCHBLT));
}

BOOL RecordCommonBitBlt(HDC hdcDest, INT x, INT y, INT nWidth, INT nHeight,
       HDC hdcSrc, INT xSrc, INT ySrc, INT nSrcWidth, INT nSrcHeight, DWORD rop,
       WORD wFunc)
{
    BOOL        fRet = FALSE;
    HBITMAP     hBitmap;
    LPWORD      lpW;
    LPWORD      lpWStart = (LPWORD) NULL;
    WORD        cwParms;
    BMIH        bmih;
    DWORD       cbBitsInfo;
    DWORD       cbBits;
    PBMIH       lpDIBInfoHeader;

// hdcSrc must be a memory DC.

    if (GetObjectType((HANDLE)hdcSrc) != OBJ_MEMDC)
    {
        ERROR_ASSERT(FALSE, "RecordCommonBitblt hdcSrc must be MEMDC\n");
        GdiSetLastError(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

// Retrieve the source bitmap.

    hBitmap = SelectObject(hdcSrc, GetStockObject(PRIV_STOCK_BITMAP));
    ERROR_ASSERT(hBitmap, "RecordCommonBitblt: SelectObject1 failed\n");

// Get the bitmap info header and sizes.

    if (!bMetaGetDIBInfo(hdcSrc, hBitmap, &bmih,
            &cbBitsInfo, &cbBits, DIB_RGB_COLORS, 0, TRUE))
        goto RecordCommonBitBlt_exit;

// Get the number of parameters to save.

    cwParms = (WORD) ((wFunc == META_DIBSTRETCHBLT) ? 10 : 8);  // in words

// Allocate space for DIB plus parameters.

    lpWStart = lpW = (LPWORD) LocalAlloc(LMEM_FIXED,
                        cbBitsInfo + cbBits + cwParms*sizeof(WORD));
    if (!lpW)
    {
        ERROR_ASSERT(FALSE, "RecordCommonBitblt: out of memory\n");
        goto RecordCommonBitBlt_exit;
    }

// Copy the parameters.

    *lpW++ = (WORD)LOWORD(rop);
    *lpW++ = (WORD)HIWORD(rop);

    if (wFunc == META_DIBSTRETCHBLT)
    {
        *lpW++ = (WORD)nSrcHeight;
        *lpW++ = (WORD)nSrcWidth;
    }

    *lpW++ = (WORD)ySrc;
    *lpW++ = (WORD)xSrc;
    *lpW++ = (WORD)nHeight;
    *lpW++ = (WORD)nWidth;
    *lpW++ = (WORD)y;
    *lpW++ = (WORD)x;

// Save the start of the bitmap info header field.

    lpDIBInfoHeader = (LPBITMAPINFOHEADER) lpW;

// Copy the bitmap info header.

    *lpDIBInfoHeader = bmih;

// Get bitmap info and bits.

    if (!GetDIBits(hdcSrc,
                   hBitmap,
                   0,
                   (UINT) bmih.biHeight,
                   (LPBYTE) ((PBYTE) lpW + cbBitsInfo),
                   (LPBITMAPINFO) lpDIBInfoHeader,
                   DIB_RGB_COLORS))
    {
        ERROR_ASSERT(FALSE, "RecordCommonBitBlt: GetDIBits2 failed\n");
        goto RecordCommonBitBlt_exit;
    }

// Finally record the parameters into the file.

    fRet = RecordParms(hdcDest, wFunc,
                   cwParms + (cbBitsInfo + cbBits) / sizeof(WORD),
                   lpWStart);

RecordCommonBitBlt_exit:

    if (lpWStart)
        if (LocalFree((HANDLE)lpWStart))
            ASSERTGDI(FALSE, "RecordCommonBitBlt: LocalFree Failed\n");

    if (!SelectObject(hdcSrc, hBitmap))
        ASSERTGDI(FALSE, "RecordCommonBitblt: SelectObject2 failed\n");

    return(fRet);
}

BOOL MF16_DeleteRgn(HDC hdc, HANDLE hrgn)
{
    UINT    pos;

    if (AddObjectToDCTable(hdc, hrgn, &pos, FALSE) != 1)
        ASSERTGDI(FALSE, "MF16_DeleteRgn: AddObjectToDCTable failed");

    return(RecordParms(hdc, META_DELETEOBJECT, 1, (LPWORD)&pos));
}

BOOL MF16_DeleteObject(HANDLE hObject)
{
    INT     iCurDC;
    UINT    pos;
    UINT    iObjType;
    PMFRECORDER16   pMFRec;
    PMETALINK16     pml16;

    pml16 = pmetalink16Get(hObject);
    ASSERTGDI(pml16, "MF16_DeleteObject: Metalink is NULL\n");

    iObjType = GetObjectType(hObject);
    ASSERTGDI(iObjType != OBJ_REGION, "MF16_DeleteObject: region unexpected");

// Delete the object from each metafile DC which references it.

    for(iCurDC = pml16->cMetaDC16 - 1; iCurDC >= 0; iCurDC--)
    {
        // Send a DeleteObject record to each metafile

        HDC hdc16 = pml16->ahMetaDC16[iCurDC];

        if (!IS_METADC16_TYPE(hdc16))
        {
            RIP("MF16_DELETEOBJECT: invalid metaDC16\n");
            continue;
        }

        // If the object is not selected then delete it, if it is then mark as predeleted

        GET_PMFRECORDER16(pMFRec,hdc16);

        if (pMFRec->recCurObjects[iObjType - MIN_OBJ_TYPE] != hObject)
        {
            if (AddObjectToDCTable(hdc16, hObject, &pos, FALSE) == 1)
                RecordParms(hdc16, META_DELETEOBJECT, 1, (LPWORD)&pos);
            else
                RIP("MF16_DeleteObject Metalink16 and metadc table not in sync\n");
        }
        else
        {
            if (pMFRec->metaHeader.mtNoObjects)
            {
                UINT    ii;
                POBJECTTABLE   pobjt;

                pobjt = (POBJECTTABLE) pMFRec->hObjectTable;

                for (ii=0; ii < (UINT) pMFRec->metaHeader.mtNoObjects; ii++)
                {
                    if (pobjt[ii].CurHandle == hObject)
                    {
                        pobjt[ii].fPreDeleted = TRUE;
                        break;
                    }
                }
            }
        }
    }

// This Object has been freed from all 3.x metafiles so free its MetaList16
// if the metalink field is in use resize METALINK16

    if (pml16->metalink)
    {
        if (pml16->cMetaDC16 > 1)
            pml16 = pmetalink16Resize(hObject,1);

        if (pml16 == NULL)
        {
            ASSERTGDI(FALSE, "MF16_DeleteObject LocalReAlloc failed\n");
            return (FALSE);
        }

        pml16->cMetaDC16     = 0;
        pml16->ahMetaDC16[0] = (HDC) 0;
    }
    else
    {
        if (!bDeleteMetalink16(hObject))
            ASSERTGDI(FALSE, "MF16_DeleteObject LocalFree failed\n");
    }

    return(TRUE);
}

BOOL MF16_RealizePalette(HDC hdc)
{
    HPALETTE        hpal;
    PMFRECORDER16   pMFRec;
    PMETALINK16     pml16;

    ASSERTGDI(IS_METADC16_TYPE(hdc),"MF16_RealizePalette - invalid handle\n");

    GET_PMFRECORDER16(pMFRec,hdc);

    hpal = pMFRec->recCurObjects[OBJ_PAL - MIN_OBJ_TYPE];
    ASSERTGDI(hpal, "MF16_RealizePalette: bad hpal\n");

// emit the palette again only if the palette is dirty.

    pml16 = pmetalink16Get(hpal);

    ASSERTGDI(IS_STOCKOBJ(hpal) || pml16,"MF16_RealizePalette - pml16 == NULL\n");

    if (pml16)
    {
        if (PtrToUlong(pml16->pv) != pMFRec->iPalVer)
            if (!MakeLogPalette(hdc, hpal, META_SETPALENTRIES))
                return(FALSE);

    // record which version of the palette the metafile is synced to.

        pMFRec->iPalVer = PtrToUlong(pml16->pv);
    }

    return(RecordParms(hdc, META_REALIZEPALETTE, 0, (LPWORD)NULL));
}

BOOL MF16_AnimatePalette
(
    HPALETTE hpal,
    UINT iStart,
    UINT cEntries,
    CONST PALETTEENTRY *pPalEntries
)
{
    INT           iCurDC;
    PMETALINK16   pml16;
    LPWORD        lpW,lpT;
    DWORD         cw;
    UINT          ii;
    PMFRECORDER16 pMFRec;

    if (!(pml16 = pmetalink16Get(hpal)))
        return(FALSE);

    cw  = (cEntries * sizeof(PALETTEENTRY) / sizeof(WORD)) + 2;
    lpT = lpW = (LPWORD) LocalAlloc(LMEM_FIXED, cw * sizeof(WORD));

    if (!lpW)
        return(FALSE);

    *lpW++ = (WORD) iStart;
    *lpW++ = (WORD) cEntries;

    for (ii = 0; ii < cEntries; ii++)
        ((PPALETTEENTRY) lpW)[ii] = pPalEntries[ii];

// Send a AnimatePalette record to each associated metafile that has the
// palette selected.

    for (iCurDC = pml16->cMetaDC16 - 1; iCurDC >= 0; iCurDC--)
    {
        HDC hdc16 = pml16->ahMetaDC16[iCurDC];

        if (!IS_METADC16_TYPE(hdc16))
        {
            ASSERTGDI(FALSE, "MF16_AnimatePalette: invalid metaDC16\n");
            continue;
        }

        GET_PMFRECORDER16(pMFRec,hdc16);
        if (pMFRec->recCurObjects[OBJ_PAL - MIN_OBJ_TYPE] == hpal)
            if (!RecordParms(pml16->ahMetaDC16[iCurDC], META_ANIMATEPALETTE, cw, lpT))
                ASSERTGDI(FALSE, "MF16_AnimatePalette: RecordParms Failed\n");
    }

    if (LocalFree((HANDLE) lpT))
        ASSERTGDI(FALSE, "MF16_AnimatePalette: LocalFree Failed\n");

    return(TRUE);
}

BOOL MF16_ResizePalette(HPALETTE hpal, UINT nCount)
{
    INT           iCurDC;
    PMETALINK16   pml16;
    PMFRECORDER16 pMFRec;

    if (!(pml16 = pmetalink16Get(hpal)))
        return(FALSE);

// Send a ResizePalette record to each associated metafile that has the
// palette selected.

    for (iCurDC = pml16->cMetaDC16 - 1; iCurDC >= 0; iCurDC--)
    {
        HDC hdc16 = pml16->ahMetaDC16[iCurDC];

        if (!IS_METADC16_TYPE(hdc16))
        {
            ASSERTGDI(FALSE, "MF16_ResizePalette: invalid metaDC16\n");
            continue;
        }

        GET_PMFRECORDER16(pMFRec,hdc16);

        if (pMFRec->recCurObjects[OBJ_PAL - MIN_OBJ_TYPE] == hpal)
            if (!RecordParms(pml16->ahMetaDC16[iCurDC], META_RESIZEPALETTE, 1, (LPWORD) &nCount))
                ASSERTGDI(FALSE, "MF16_ResizePalette: RecordParms Failed\n");
    }
    return(TRUE);
}

BOOL MF16_DrawRgn(HDC hdc, HRGN hrgn, HBRUSH hBrush, INT cx, INT cy, WORD Func)
{
    WORD    aw[4];
    BOOL    bRet;

    // Each region function has at least a region to record
    aw[0] = (WORD)RecordObject(hdc, hrgn);

    switch(Func)
    {
    case META_PAINTREGION:
    case META_INVERTREGION:
        bRet = RecordParms(hdc, Func, 1, aw);
        break;

    case META_FILLREGION:
        aw[1] = (WORD)RecordObject(hdc, hBrush);
        bRet = RecordParms(hdc, Func, 2, aw);
        break;

    case META_FRAMEREGION:
        aw[1] = (WORD)RecordObject(hdc, hBrush);
        aw[2] = (WORD)cy;
        aw[3] = (WORD)cx;
        bRet = RecordParms(hdc, Func, 4, aw);
        break;

    default:
        ASSERTGDI(FALSE, "MF16_DrawRgn: Bad Func\n");
        bRet = FALSE;
        break;
    }

// Delete the metafile region handle in the metafile after use!
// The reason is that a region can be modified (e.g. SetRectRgn)
// between each use and we have to re-record it each time it is used
// unless we use a dirty flag.

    if (!MF16_DeleteRgn(hdc, hrgn))
        ASSERTGDI(FALSE, "MF16_DrawRgn: MF16_DeleteRgn failed\n");

    return(bRet);
}

BOOL MF16_PolyPolygon(HDC hdc, CONST POINT *lpPoint, CONST INT *lpPolyCount, INT nCount)
{
    BOOL        fRet;
    LPWORD      lpW,lpT;
    DWORD       cw;
    INT         cPt = 0;
    INT         ii;

    for(ii=0; ii<nCount; ii++)
        cPt += lpPolyCount[ii];

    cw = 1+nCount+(cPt*sizeof(POINTS)/sizeof(WORD));
    lpT = lpW = (LPWORD)LocalAlloc(LMEM_FIXED, cw*sizeof(WORD));
    if (!lpW)
        return(FALSE);

    // first is the count
    *lpW++ = (WORD)nCount;

    // second is the list of poly counts
    for(ii=0; ii<nCount; ii++)
        *lpW++ = (WORD)lpPolyCount[ii];

    // third is the list of points
    for(ii=0; ii<cPt; ii++)
    {
        *lpW++ = (WORD)lpPoint[ii].x;
        *lpW++ = (WORD)lpPoint[ii].y;
    }

    fRet = RecordParms(hdc, META_POLYPOLYGON, cw, lpT);

    if(LocalFree((HANDLE)lpT))
        ASSERTGDI(FALSE, "MF16_PolyPolygon: LocalFree Failed\n");

    return (fRet);
}

BOOL MF16_SelectClipRgn(HDC hdc, HRGN hrgn, int iMode)
{
    PMFRECORDER16 pMFRec;

    if (!IS_METADC16_TYPE(hdc))
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

    PUTS("MF16_SelectClipRgn\n");

    GET_PMFRECORDER16(pMFRec,hdc);

    if (iMode != RGN_COPY)
        return(FALSE);

// We will emit SelectObject record for clip region just like Windows.
// However, a null region cannot be recorded in the SelectObject call since
// the handle does not identify the object type.  This is a bug in Win 3.1!
//
// BUG 8419 winproj 4 has a bug where it counts on this bug.  Chicago
// also has this bug so we will have this bug.

    if (hrgn == (HRGN) 0)
    {
#ifdef RECORD_SELECTCLIPRGN_NULL
        BOOL    fRet;

        fRet = MF16_RecordParms2(hdc, 0, META_SELECTCLIPREGION);

        // maintain the new selection in the CurObject table

        pMFRec->recCurObjects[OBJ_REGION - MIN_OBJ_TYPE] = 0;

        return(fRet);
#else
        return TRUE;
#endif
    }
    else
        return(MF16_SelectObject(hdc, hrgn) ? TRUE : FALSE);
}

// SelectObject returns previous object! - new in win3.1

HANDLE MF16_SelectObject(HDC hdc, HANDLE h)
{
    HANDLE        hOldObject;
    WORD          position;
    PMFRECORDER16 pMFRec;
    UINT          iType;


    PUTS("MF16_SelectObject\n");

    GET_PMFRECORDER16(pMFRec,hdc);

    if (!IS_METADC16_TYPE(hdc) || !pMFRec)
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
        return(0);
    }

    iType = GetObjectType(h);

    if ((iType == 0) || !h || (position = (WORD) RecordObject(hdc, h)) == (WORD) -1)
        return((HANDLE) 0);
    else
    {
        if (!RecordParms(hdc, META_SELECTOBJECT, 1, &position))
            return((HANDLE) 0);

        // maintain the new selection in the CurObject table

        ASSERTGDI(iType <= MAX_OBJ_TYPE && iType >= MIN_OBJ_TYPE,
            "MF16_SelectObject type > max\n");

        hOldObject = pMFRec->recCurObjects[iType - MIN_OBJ_TYPE];
        pMFRec->recCurObjects[iType - MIN_OBJ_TYPE] = h;

        // return the previously selected object or 1 if it is a region
        // (for compatibility) - new in win3.1

        if (iType == OBJ_REGION)
        {
            // We also delete the region handle here!
            // The reason is that a region can be modified (e.g. SetRectRgn)
            // between each use and we have to re-record it each time it is used
            // unless we use a dirty flag.  This is a bug in win3.1

            return(MF16_DeleteRgn(hdc, h) ? (HANDLE) 1 : (HANDLE) 0);
        }
        else
        {
            return(hOldObject);
        }
    }
}

BOOL MF16_SelectPalette(HDC hdc, HPALETTE hpal)
{
    WORD          position;
    PMFRECORDER16 pMFRec;

    GET_PMFRECORDER16(pMFRec,hdc);

    if (!IS_METADC16_TYPE(hdc) || !pMFRec)
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
        return(0);
    }

    if (!hpal || (position = (WORD) RecordObject(hdc, (HANDLE) hpal)) == (WORD) -1)
        return(FALSE);
    else
    {
        PMETALINK16 pml16;

        if (!RecordParms(hdc, META_SELECTPALETTE, 1, &position))
            return(FALSE);

        // maintain the new selection in the CurObject table
        pMFRec->recCurObjects[OBJ_PAL - MIN_OBJ_TYPE] = hpal;

        // Also record which version of the palette we are synced with
        // so we know whether to emit a new palette when RealizePalette
        // is called

        pml16 = pmetalink16Get(hpal);
        ASSERTGDI(IS_STOCKOBJ(hpal) || pml16,"MF16_RealizePalette - pml16 == NULL\n");

        if (pml16)
           pMFRec->iPalVer = PtrToUlong(pml16->pv);

        return(TRUE);
    }
}

BOOL MF16_TextOut(HDC hdc, INT x, INT y, LPCSTR lpString, INT nCount, BOOL bUnicode)
{
    BOOL    fRet;
    LPWORD  lpw, lpT;
    DWORD   cw;

    cw  = (nCount + 1)/sizeof(WORD) + 3;     // word-aligned character string
    lpT = lpw = (LPWORD) LocalAlloc(LMEM_FIXED, cw*sizeof(WORD));

    if (!lpw)
        return(FALSE);

    *lpw++ = (WORD)nCount;

    // Copy the string

    if (!bUnicode)
    {
        RtlCopyMemory(lpw, lpString, nCount);
    }
    else
    {
        (void) bToASCII_N((LPSTR) lpw, nCount, (LPWSTR) lpString, nCount);
    }

    lpw += (nCount+1)/sizeof(WORD);   // keep word aligned

    *lpw++ = (WORD)y;
    *lpw++ = (WORD)x;

    fRet = RecordParms(hdc, META_TEXTOUT, cw, lpT);

    if(LocalFree((HANDLE)lpT))
        ASSERTGDI(FALSE, "MF16_TextOut: LocalFree Failed\n");
    return (fRet);
}

BOOL MF16_PolyTextOut(HDC hdc, CONST POLYTEXTA *ppta, int cpta, BOOL bUnicode)
{
    int     i;

    for (i = 0; i < cpta; i++)
    {
        if (!MF16_ExtTextOut(hdc, ppta[i].x, ppta[i].y, ppta[i].uiFlags,
                        &ppta[i].rcl, (LPCSTR) ppta[i].lpstr, (INT) ppta[i].n,
                        (LPINT) ppta[i].pdx, bUnicode))
            return(FALSE);
    }

    return(TRUE);
}

BOOL MF16_ExtTextOut(HDC hdc, INT x, INT y, UINT flOptions, CONST RECT *lpRect,
    LPCSTR lpString, INT nCount, CONST INT *lpDX, BOOL bUnicode)
{
    BOOL    fRet;
    LPWORD  lpw, lpT;
    DWORD cw = 0;
    INT nUnicodeCount = nCount;
    char *pjAnsiString = NULL;

    if(bUnicode)
    {
    // compute the real count of characters in the string

        RtlUnicodeToMultiByteSize((PULONG) &nCount, (PWCH) lpString,
                                  nCount * sizeof(WCHAR));
    }

    // Compute buffer space needed
    //   room for the char string
    //   room for the 4 words that are the fixed parms
    //   if there is a dx array, we need room for it
    //   if the rectangle is being used, we need room for it
    //   and we need extra byte for eventual word roundoff
    //

    if (flOptions & ETO_PDY)
        return FALSE;

    cw += (lpDX) ? nCount : 0;       // DX array
    cw += (flOptions & (ETO_OPAQUE | ETO_CLIPPED)) ? 4 : 0;  // sizeof RECTS
    cw += 4;  // x,y,options and count
    cw += (nCount + 1)/sizeof(WORD);

    lpT = lpw = (LPWORD) LocalAlloc(LMEM_FIXED, cw*sizeof(WORD));
    if (!lpw)
        return(FALSE);

    *lpw++ = (WORD)y;
    *lpw++ = (WORD)x;
    *lpw++ = (WORD)nCount;
    *lpw++ = (WORD)flOptions;

    // Copy the rect if present
    if (flOptions & (ETO_OPAQUE | ETO_CLIPPED))
    {
        ERROR_ASSERT(lpRect, "MF16_ExtTextOut: expect valid lpRect\n");
        *lpw++ = (WORD)lpRect->left;
        *lpw++ = (WORD)lpRect->top;
        *lpw++ = (WORD)lpRect->right;
        *lpw++ = (WORD)lpRect->bottom;
    }

    // Copy the string
    if (!bUnicode)
    {
        RtlCopyMemory(lpw, lpString, nCount);
    }
    else
    {
        (void) bToASCII_N((LPSTR) lpw, nCount, (LPWSTR) lpString, nUnicodeCount);
        pjAnsiString = (char*) lpw;
    }

    lpw += (nCount+1)/sizeof(WORD);   // keep word aligned

    if (lpDX)
    {
        INT ii;

        if(nCount != nUnicodeCount)
        {
            INT jj;

            for(ii=0,jj=0; ii < nCount; ii++,jj++)
            {
                *lpw++ = (WORD)lpDX[jj];

                if(IsDBCSLeadByte(pjAnsiString[ii]))
                {
                    *lpw++ = 0;
                    ii++;
                }
            }
        }
        else
        {
            for(ii=0; ii<nCount; ii++)
              *lpw++ = (WORD)lpDX[ii];
        }

    }

    fRet = RecordParms(hdc, META_EXTTEXTOUT, cw, lpT);

    if (LocalFree((HANDLE)lpT))
        ASSERTGDI(FALSE, "MF16_ExtTextOut: LocalFree Failed\n");

    return (fRet);
}

BOOL MF16_Escape(HDC hdc, int nEscape, int nCount, LPCSTR lpInData, LPVOID lpOutData)
{
    BOOL        fRet;
    LPWORD      lpW,lpT;
    DWORD       cw;

// If a metafile is retrieved from GetWinMetaFileBits, it may contain
// an embedded enhanced metafile.  Do not include the enhanced metafile
// if we are playing the metafile to another metafile.

    if (nEscape == MFCOMMENT
     && nCount > sizeof(META_ESCAPE_ENHANCED_METAFILE) - sizeof(DWORD) - 3 * sizeof(WORD)
     && ((DWORD UNALIGNED *) lpInData)[0] == MFCOMMENT_IDENTIFIER
     && ((DWORD UNALIGNED *) lpInData)[1] == MFCOMMENT_ENHANCED_METAFILE)
    {
        return(TRUE);
    }

// Some wow apps (e.g. amipro) use metafiles for printing.  As a result,
// we need to record these printing escapes.

    cw = 2 + ((nCount + 1) / sizeof(WORD));
    lpT = lpW = (LPWORD) LocalAlloc(LMEM_FIXED, cw * sizeof(WORD));
    if (!lpW)
        return(FALSE);

    *lpW++ = (WORD) nEscape;    // escape number
    *lpW++ = (WORD) nCount;     // count of input data buffer

    RtlCopyMemory(lpW, lpInData, nCount);

    fRet = RecordParms(hdc, META_ESCAPE, cw, lpT);

    if (LocalFree((HANDLE) lpT))
        ASSERTGDI(FALSE, "MF16_Escape: LocalFree Failed\n");

    return(fRet);
}

/****************************************************************************
*                                                                           *
* RecordParms                                                               *
*                                                                           *
* Parameters: 1.hMF handle to a metafile header.                            *
*             2.The magic number of the function being recorded.            *
*             3.The number of parmmeter of the function (size of lpParm     *
*                 in words)                                                 *
*             4.A long pointer to parameters stored in reverse order        *
*                                                                           *
* Warning call only once per function because max record is updated.        *
*                                                                           *
****************************************************************************/

BOOL RecordParms(HDC hdc, DWORD magic, DWORD cw, CONST WORD *lpParm)
{
    PMFRECORDER16 pMFRec;
    METARECORD    MFRecord;

    PUTSX("RecordParms %lX\n", (ULONG)magic);
    ASSERTGDI(HIWORD(magic) == 0, "RecordParms: bad magic\n");

    GET_PMFRECORDER16(pMFRec,hdc);

    if (!IS_METADC16_TYPE(hdc) || !pMFRec)
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

// Make sure the Metafile hasn't died before we continue

    if (!(pMFRec->recFlags & METAFILEFAILURE))
    {
        MFRecord.rdSize     = SIZEOF_METARECORDHEADER/sizeof(WORD) + cw;
        MFRecord.rdFunction = (WORD)magic;

        // Write the header

        if (!AttemptWrite(pMFRec, SIZEOF_METARECORDHEADER, (LPBYTE)&MFRecord))
            return(FALSE);

        // Write the data

        if (!AttemptWrite(pMFRec, cw*sizeof(WORD), (LPBYTE)lpParm))
            return(FALSE);

        // Update max record size

        if (MFRecord.rdSize > pMFRec->metaHeader.mtMaxRecord)
            pMFRec->metaHeader.mtMaxRecord = MFRecord.rdSize;
    }
    return (TRUE);      // Win 3.1 returns true even if METAFAILEFAILURE is on!
}

/***************************** Internal Function ***************************\
* AttemptWrite
*
* Tries to write data to a metafile disk file
*
* dwBytes is the byte count of lpData.
*
* Returns TRUE iff the write was sucessful
*
*
\***************************************************************************/

BOOL AttemptWrite(PMFRECORDER16 pMFRec, DWORD dwBytes, LPBYTE lpData)
{
    DWORD cbWritten;
    BOOL  fRet;

    PUTS("AttemptWrite\n");

    ASSERTGDI(dwBytes % 2 == 0, "AttemptWrite: bad dwBytes\n"); // must be even
    ASSERTGDI(!(pMFRec->recFlags & METAFILEFAILURE),
        "AttemptWrite: Bad recording\n");

// Handle disk file.

    if (pMFRec->metaHeader.mtType == DISKMETAFILE)
    {
        // Flush the buffer if it's not large enough.

        if (dwBytes + pMFRec->ibBuffer > pMFRec->cbBuffer)
        {
            fRet = WriteFile(pMFRec->hFile, (LPBYTE)pMFRec->hMem,
                    pMFRec->ibBuffer, &cbWritten, (LPOVERLAPPED)NULL);
            if (!fRet || (cbWritten != pMFRec->ibBuffer))
            {
                ERROR_ASSERT(FALSE, "AttemptWrite: Write1 failed\n");
                goto AttemptWrite_Error;
            }
            pMFRec->ibBuffer = 0;       // reset buffer info
        }

        // If the data is still too large, write it out to disk directly.

        if (dwBytes + pMFRec->ibBuffer > pMFRec->cbBuffer)
        {
            fRet = WriteFile(pMFRec->hFile, lpData,
                    dwBytes, &cbWritten, (LPOVERLAPPED)NULL);
            if (!fRet || (cbWritten != dwBytes))
            {
                ERROR_ASSERT(FALSE, "AttemptWrite: Write2 failed\n");
                goto AttemptWrite_Error;
            }
        }
        else
        {
            // Store data in the buffer.

            RtlCopyMemory((LPBYTE)pMFRec->hMem + pMFRec->ibBuffer, lpData, dwBytes);
            pMFRec->ibBuffer += dwBytes;
        }
    }
    else
    {
    // Handle memory file.

        // Grow the buffer if necessary.

        if (dwBytes + pMFRec->ibBuffer > pMFRec->cbBuffer)
        {
            DWORD   cbNewSize;
            HANDLE  hMem;

            cbNewSize = pMFRec->cbBuffer + MF16_BUFSIZE_INC
                            + dwBytes / MF16_BUFSIZE_INC * MF16_BUFSIZE_INC;

            hMem = LocalReAlloc(pMFRec->hMem, cbNewSize, LMEM_MOVEABLE);
            if (hMem == NULL)
            {
                ERROR_ASSERT(FALSE, "AttemptWrite: out of memory\n");
                goto AttemptWrite_Error;
            }
            pMFRec->hMem = hMem;
            pMFRec->cbBuffer = cbNewSize;
        }

        // Record the data.

        RtlCopyMemory((LPBYTE)pMFRec->hMem + pMFRec->ibBuffer, lpData, dwBytes);
        pMFRec->ibBuffer += dwBytes;
    }

    // Update the header size.

    pMFRec->metaHeader.mtSize += dwBytes/sizeof(WORD);

    return(TRUE);

AttemptWrite_Error:

    MarkMetaFile(pMFRec);
    return(FALSE);
}


/***************************** Internal Function ***************************\
* VOID MarkMetaFile
*
* Marks a metafile as failed
*
* Effects:
*   Frees the metafile resources
*
\***************************************************************************/

VOID MarkMetaFile(PMFRECORDER16 pMFRec)
{
// Clean up is done in CloseMetaFile.

    PUTS("MarkMetaFile\n");

    pMFRec->recFlags |= METAFILEFAILURE;
}

/***************************** Internal Function **************************\
* MakeLogPalette
*
* Records either CreatePalette or SetPaletteEntries
*
* Returns TRUE iff sucessful
*
*
\***************************************************************************/

BOOL MakeLogPalette(HDC hdc, HANDLE hPal, WORD magic)
{
    WORD        cPalEntries;
    BOOL        fStatus = FALSE;
    DWORD       cbPalette;
    LPLOGPALETTE lpPalette;

    PUTS("MakeLogPalette\n");

    if (!GetObject(hPal, sizeof(WORD), &cPalEntries))
    {
        ERROR_ASSERT(FALSE, "MakeLogPalette: GetObject Failed\n");
        return(fStatus);
    }

// alloc memory and get the palette entries

    if (lpPalette = (LPLOGPALETTE)LocalAlloc(LMEM_FIXED,
            cbPalette = sizeof(LOGPALETTE)-sizeof(PALETTEENTRY)+sizeof(PALETTEENTRY)*cPalEntries))
    {
        lpPalette->palNumEntries = cPalEntries;

        GetPaletteEntries(hPal, 0, cPalEntries, lpPalette->palPalEntry);

        if (magic == (META_CREATEPALETTE & 255))
        {
            lpPalette->palVersion = 0x300;
            magic = META_CREATEPALETTE;
        }
        else if (magic == (META_SETPALENTRIES & 255))
        {
            lpPalette->palVersion = 0;   /* really "starting index" */
            magic = META_SETPALENTRIES;
        }

        fStatus = RecordParms(hdc, magic, (DWORD)cbPalette >> 1, (LPWORD)lpPalette);

        if (LocalFree((HANDLE)lpPalette))
            ASSERTGDI(FALSE, "MakeLogPalette: LocalFree Failed\n");
    }

    return(fStatus);
}


/***************************** Internal Function ***************************\
* RecordObject
*
* Records the use of an object by creating the object
*
* Returns: index of object in table
*          -1 if error
*
\***************************************************************************/

WIN3REGION w3rgnEmpty =
{
    0,              // nextInChain
    6,              // ObjType
    0x2F6,          // ObjCount
    sizeof(WIN3REGION) - sizeof(SCAN) + 2,
                    // cbRegion
    0,              // cScans
    0,              // maxScan
    {0,0,0,0},      // rcBounding
    {0,0,0,{0,0},0} // aScans[]
};

WORD RecordObject(HDC hdc, HANDLE hObject)
{
    UINT        status;
    UINT        iPosition;
    HDC         hdcScreen = (HDC) 0;
    int         iType;
    UINT    iUsage;

    PUTS("RecordObject\n");

// Validate the object.

    iType = LO_TYPE(hObject);

    if (iType != LO_PEN_TYPE &&
        iType != LO_BRUSH_TYPE &&
        iType != LO_FONT_TYPE &&
        iType != LO_REGION_TYPE &&
        iType != LO_PALETTE_TYPE
        )
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
        return((WORD) -1);
    }

// Add the object to the metafiles list.

    status = AddObjectToDCTable(hdc, hObject, &iPosition, TRUE);

// An error occurred.

    if (status == (UINT) -1)
        return((WORD) -1);

// Object already exists.

    if (status == 1)
        return((WORD) iPosition);

    ASSERTGDI(!status, "RecordObject: Bad return code from AddObjectToDCTable\n");

// Object does not exist, record it.

    if (iType != LO_REGION_TYPE)       // don't add regions to the metalist!
        if (!AddDCToObjectMetaList16(hdc,hObject))
            return((WORD) -1);

    switch (iType)
    {
    case LO_PEN_TYPE:
    {
        LOGPEN16 logpen16;

        GetObject16AndType(hObject, (LPVOID)&logpen16);
        status = (UINT) RecordParms(hdc, (WORD)META_CREATEPENINDIRECT,
                          (DWORD)((sizeof(LOGPEN16) + 1) >> 1),
                          (LPWORD)&logpen16);
        break;
    }

    case LO_FONT_TYPE:
    {
        LOGFONT16 logfont16;

        GetObject16AndType(hObject, (LPVOID)&logfont16);

        /* size of LOGFONT adjusted based on the length of the facename */
        status = (UINT) RecordParms(hdc, META_CREATEFONTINDIRECT,
                          (DWORD)((sizeof(LOGFONT16) + 1) >> 1),
                          (LPWORD) &logfont16);
        break;
    }

    /*
     * in win2, METACREATEREGION records contained an entire region object,
     * including the full header.  this header changed in win3.
     *
     * to remain compatible, the region records will be saved with the
     * win2 header.  here we save our region with a win2 header.
     */
    case LO_REGION_TYPE:
    {
        PWIN3REGION lpw3rgn;
        DWORD       cbNTRgnData;
        DWORD       curRectl;
        WORD        cScans;
        WORD        maxScanEntry;
        WORD        curScanEntry;
        DWORD       cbw3data;
        PRGNDATA    lprgn;
        LPRECT      lprc;
        PSCAN       lpScan;

        ASSERTGDI(!status, "RecordObject: bad status\n");

        // Get the NT Region Data
        cbNTRgnData = GetRegionData(hObject, 0, NULL);
        if (cbNTRgnData == 0)
            break;

        lprgn = (PRGNDATA) LocalAlloc(LMEM_FIXED, cbNTRgnData);
        if (!lprgn)
            break;

        cbNTRgnData = GetRegionData(hObject, cbNTRgnData, lprgn);
        if (cbNTRgnData == 0)
        {
            LocalFree((HANDLE) lprgn);
            break;
        }

        // Handle the empty region.

        if (!lprgn->rdh.nCount)
        {
            status = (UINT) RecordParms(hdc, META_CREATEREGION,
                        (sizeof(WIN3REGION) - sizeof(SCAN)) >> 1,  // Convert to count of words
                        (LPWORD) &w3rgnEmpty);

            LocalFree((HANDLE)lprgn);
            break;
        }

        lprc = (LPRECT)lprgn->Buffer;

        // Create the Windows 3.x equivalent

        // worst case is one scan for each rect
        cbw3data = 2*sizeof(WIN3REGION) + (WORD)lprgn->rdh.nCount*sizeof(SCAN);

        lpw3rgn = (PWIN3REGION)LocalAlloc(LMEM_FIXED, cbw3data);
        if (!lpw3rgn)
        {
            LocalFree((HANDLE) lprgn);
            break;
        }

        // Grab the bounding rect.
        lpw3rgn->rcBounding.left   = (SHORT)lprgn->rdh.rcBound.left;
        lpw3rgn->rcBounding.right  = (SHORT)lprgn->rdh.rcBound.right;
        lpw3rgn->rcBounding.top    = (SHORT)lprgn->rdh.rcBound.top;
        lpw3rgn->rcBounding.bottom = (SHORT)lprgn->rdh.rcBound.bottom;

        cbw3data = sizeof(WIN3REGION) - sizeof(SCAN) + 2;

        // visit all the rects
        curRectl     = 0;
        cScans       = 0;
        maxScanEntry = 0;
        lpScan       = lpw3rgn->aScans;

        while(curRectl < lprgn->rdh.nCount)
        {
            LPWORD  lpXEntry;
            DWORD   cbScan;

            curScanEntry = 0;       // Current X pair in this scan

            lpScan->scnPntTop    = (WORD)lprc[curRectl].top;
            lpScan->scnPntBottom = (WORD)lprc[curRectl].bottom;

            lpXEntry = (LPWORD) lpScan->scnPntsX;

            // handle rects on this scan
            do
            {
                lpXEntry[curScanEntry + 0] = (WORD)lprc[curRectl].left;
                lpXEntry[curScanEntry + 1] = (WORD)lprc[curRectl].right;
                curScanEntry += 2;
                curRectl++;
            } while ((curRectl < lprgn->rdh.nCount)
                    && (lprc[curRectl-1].top    == lprc[curRectl].top)
                    && (lprc[curRectl-1].bottom == lprc[curRectl].bottom)
                   );

            lpScan->scnPntCnt      = curScanEntry;
            lpXEntry[curScanEntry] = curScanEntry;  // Count also follows Xs
            cScans++;

            if (curScanEntry > maxScanEntry)
                maxScanEntry = curScanEntry;

            // account for each new scan + each X1 X2 Entry but the first
            cbScan = sizeof(SCAN)-(sizeof(WORD)*2) + (curScanEntry*sizeof(WORD));
            cbw3data += cbScan;
            lpScan = (PSCAN)(((LPBYTE)lpScan) + cbScan);
        }

        // Initialize the header
        lpw3rgn->nextInChain = 0;
        lpw3rgn->ObjType = 6;           // old Windows OBJ_RGN identifier
        lpw3rgn->ObjCount= 0x2F6;       // any non-zero number
        lpw3rgn->cbRegion = (WORD)cbw3data;   // don't count type and next
        lpw3rgn->cScans = cScans;
        lpw3rgn->maxScan = maxScanEntry;

        status = (UINT) RecordParms(hdc, META_CREATEREGION,
                (cbw3data-2) >> 1,  // Convert to count of words
                (LPWORD) lpw3rgn);

        if (LocalFree((HANDLE)lprgn))
            ASSERTGDI(FALSE, "RecordObject: LocalFree(lprgn) Failed\n");
        if (LocalFree((HANDLE)lpw3rgn))
            ASSERTGDI(FALSE, "RecordObject: LocalFree(lpw3rgn) Failed\n");

        break;
    }

    case LO_BRUSH_TYPE:
    {
        LOGBRUSH  lb;

        if (!GetObjectA(hObject, sizeof(LOGBRUSH), &lb))
            break;

        switch (lb.lbStyle)
        {
        case BS_HATCHED:
        case BS_HOLLOW:
        case BS_SOLID:
            {
            LOGBRUSH16 lb16;

            LOGBRUSH16FROMLOGBRUSH32(&lb16, &lb);

            // non-pattern brush
            status = (UINT) RecordParms(hdc, META_CREATEBRUSHINDIRECT,
                              (DWORD) ((sizeof(LOGBRUSH16) + 1) >> 1),
                              (LPWORD) &lb16);
            break;
            }

        case BS_PATTERN:
        case BS_DIBPATTERN:
        case BS_DIBPATTERNPT:
            {
            HBITMAP hbmRemote;
            BMIH    bmih;
            DWORD   cbBitsInfo;
            DWORD   cbBits;
            LPWORD  lpWStart, lpW;
            DWORD   lbStyle = BS_DIBPATTERN;
            PBMIH   lpDIBInfoHeader;

            if (!(hbmRemote = GetObjectBitmapHandle((HBRUSH) hObject, &iUsage)))
            {
                ASSERTGDI(FALSE, "RecordObject: GetObjectBitmapHandle failed");
                break;
            }

            // For a pattern brush, if it is color, it is recorded as a
            // DIB pattern brush with BS_DIBPATTERN style.  If it is
            // monochrome, it is recorded as a DIB pattern brush with
            // BS_PATTERN style.  The playback code has a special
            // case to deal with monochrome brushes.

            if (lb.lbStyle == BS_PATTERN)
            {
                iUsage     = DIB_RGB_COLORS;
                if (MonoBitmap(hbmRemote))
                    lbStyle = BS_PATTERN;
            }

            hdcScreen = CreateCompatibleDC((HDC) 0);        // freed below

            // Get the bitmap info header and sizes.

            if (!bMetaGetDIBInfo(hdcScreen, hbmRemote, &bmih,
                    &cbBitsInfo, &cbBits, iUsage, 0, TRUE))
                break;

            // Make sure that cbBitsInfo is dword aligned

            // If we have converted the bitmap format in bMetaGetDIBInfo,
            // modify the iUsage to match the new format.

            if (bmih.biBitCount == 24)
                iUsage = DIB_RGB_COLORS;

            // Allocate space for DIB plus parameters.

            lpWStart = lpW = (LPWORD) LocalAlloc(LMEM_FIXED,
                                cbBitsInfo + cbBits + 2*sizeof(WORD));
            if (!lpW)
            {
                ERROR_ASSERT(FALSE, "RecordObject: out of memory\n");
                break;
            }

            *lpW++ = (WORD) lbStyle;        // BS_PATTERN or BS_DIBPATTERN
            *lpW++ = (WORD) iUsage;         // usage word

            // Save the start of the bitmap info header field.

            lpDIBInfoHeader = (LPBITMAPINFOHEADER) lpW;

            // Copy the bitmap info header.

            *lpDIBInfoHeader = bmih;

            // Get bitmap info and bits.

            if (GetBrushBits(hdcScreen,
                        hbmRemote,
                        (UINT) iUsage,
                        cbBitsInfo,
                        (LPVOID) ((PBYTE) lpW + cbBitsInfo),
                        (LPBITMAPINFO) lpDIBInfoHeader))
            {
            // Finally record the parameters into the file.

                status = (UINT) RecordParms(hdc, META_DIBCREATEPATTERNBRUSH,
                               2 + (cbBitsInfo + cbBits) / sizeof(WORD),
                               (LPWORD) lpWStart);
            }

            if (LocalFree((HANDLE) lpWStart))
                ASSERTGDI(FALSE, "RecordObject: LocalFree Failed\n");

            break;
            }

        default:
            {
            ASSERTGDI(FALSE, "RecordObject: Bad brush style");
            break;
            }
        }   // switch(lb.lbStyle)
        break;
    }   // case LO_BRUSH

    case LO_PALETTE_TYPE:
        status = (UINT) MakeLogPalette(hdc, hObject, META_CREATEPALETTE);
        break;

    default:
        ERROR_ASSERT(FALSE, "unknown case RecordObject");
        break;
    }

// Free the DC created in the brush case.

    if (hdcScreen)
        if (!DeleteDC(hdcScreen))
            ASSERTGDI(FALSE, "RecordObject: DeleteDC Failed\n");

    ASSERTGDI(status == TRUE, "RecordObject: Failing\n");
    return ((WORD) (status == TRUE ? iPosition : -1));
} /* RecordObject */


BOOL AddDCToObjectMetaList16(HDC hMetaDC16, HANDLE hObject)
{
    ULONG   cMetaDC16New;
    PMETALINK16 pml16;

    ASSERTGDI(LO_TYPE(hObject) != LO_REGION_TYPE,
        "AddDCToObjectMetaList16: unexpected region object");

// If the object is a stock object there is no work to do

    if (IS_STOCKOBJ(hObject))
        return(TRUE);

// If the Object's MetaList16 is NULL create allocate one

    pml16 = pmetalink16Get(hObject);

    if (!pml16)
    {
        ENTERCRITICALSECTION(&semLocal);
        pml16 = pmetalink16Create(hObject);
        LEAVECRITICALSECTION(&semLocal);

        if (pml16)
        {
            pml16->metalink = 0;
            pml16->cMetaDC16 = 1;
            pml16->ahMetaDC16[0] = hMetaDC16;
        }
        else
        {
            ASSERTGDI(FALSE, "AddDCToObjectMetaList16: Out of Memory 1");
            return(FALSE);
        }
    }
    else
    {
        int cj;

        cMetaDC16New = pml16->cMetaDC16 + 1;

        if (pml16 = pmetalink16Resize(hObject,cMetaDC16New))
        {
            pml16->ahMetaDC16[pml16->cMetaDC16++] = hMetaDC16;
        }
        else
        {
            ASSERTGDI(FALSE, "AddDCToObjectMetaList16: Out of Memory 2");
            return(FALSE);
        }
    }

    return(TRUE);
}

/***************************** Internal Function ***************************\
* AddObjectToDCTable
*
* Add an object (brush, pen...) to a list of objects associated with the
* metafile.
*
*
*
* Returns: 1 if object is already in table
*          0 if object was just added to table
*          -1 if failure
*
* Remarks
*   bAdd is TRUE iff the object is being added otherwise it is being deleted
*
\***************************************************************************/

UINT AddObjectToDCTable(HDC hdc, HANDLE hObject, PUINT pPosition, BOOL bAdd)
{
    UINT            iEmptySpace = (UINT) -1;
    UINT            i;
    UINT            status = (UINT) -1;
    POBJECTTABLE    pHandleTable;
    PMFRECORDER16   pMFRec;

    PUTS("AddObjectToDCTable\n");

    GET_PMFRECORDER16(pMFRec,hdc);

    if (!IS_METADC16_TYPE(hdc) || !pMFRec)
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
        return((UINT)-1);
    }

// if the Object table already exists search it for the object

    if (pHandleTable = (POBJECTTABLE)pMFRec->hObjectTable)
    {
        for (i=0; i < (UINT) pMFRec->metaHeader.mtNoObjects; ++i)
        {
            if (hObject == pHandleTable[i].CurHandle)
            {
                *pPosition = i;
                status = 1;             // the object exists in the table

                // if we are doing a METADELETEOBJECT.
                //  delete object from table

                if (!bAdd)
                {
                    pHandleTable[i].fPreDeleted = FALSE;
                    pHandleTable[i].CurHandle = (HANDLE)NULL;
                }
                goto AddObjectToTable10;
            }
            else if ((pHandleTable[i].CurHandle == 0) && (iEmptySpace == (UINT) -1))
            {
                // if the entry has been deleted, we want to add a new object
                // in its place.  iEmptySpace will tell us where that place is.

                iEmptySpace = i;
            }
        } // for
    }

    if (bAdd)
    {
        // If there is no object table for this MetaFile then Allocate one.

        if (pHandleTable == (POBJECTTABLE)NULL)
        {
            pHandleTable = (POBJECTTABLE) LocalAlloc(LMEM_FIXED, sizeof(OBJECTTABLE));
            pMFRec->hObjectTable = (HANDLE) pHandleTable;
        }
        else if (iEmptySpace == (UINT) -1)
        {
            pHandleTable = (POBJECTTABLE) LocalReAlloc(pMFRec->hObjectTable,
                    (pMFRec->metaHeader.mtNoObjects + 1) * sizeof(OBJECTTABLE),
                    LMEM_MOVEABLE);
            if (pHandleTable)
                pMFRec->hObjectTable = (HANDLE) pHandleTable;
        }

        if (pHandleTable)
        {
            if (iEmptySpace == (UINT) -1)
                *pPosition = pMFRec->metaHeader.mtNoObjects++;
            else
                *pPosition = iEmptySpace;

            pHandleTable[*pPosition].fPreDeleted = FALSE;
            pHandleTable[*pPosition].CurHandle = hObject;

            status = 0;                 // the object is added to the table
        }
    }
AddObjectToTable10:

    ERROR_ASSERT(status != (UINT) -1, "AddObjectToTable: Failing\n");
    return(status);
}

/***************************** Internal Function **************************\
* HDC WINAPI CreateMetaFileW
*
* Creates a MetaFile DC
*
* The internal format for a MetaFileRecorder has two formats one
* for a memory MetaFile and one for a disk based MetaFile
*
\***************************************************************************/

HDC WINAPI CreateMetaFileA(LPCSTR pszFileName)
{
    UINT  cch;
    WCHAR awch[MAX_PATH];

    if (pszFileName)
    {
        cch = strlen(pszFileName)+1;

        if (cch > MAX_PATH)
        {
            ERROR_ASSERT(FALSE, "CreateMetaFileA filename too long");
            GdiSetLastError(ERROR_FILENAME_EXCED_RANGE);
            return((HDC) 0);
        }
        vToUnicodeN(awch, MAX_PATH, pszFileName, cch);

        return (CreateMetaFileW(awch));
    }
    else
        return (CreateMetaFileW((LPWSTR)NULL));
}


HDC WINAPI CreateMetaFileW(LPCWSTR pwszFileName)
{
    PMFRECORDER16   pMFRec;
    HDC             hdc;

    PUTS("CreateMetaFileW\n");

    if (!(pMFRec = (PMFRECORDER16) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                              sizeof(MFRECORDER16))))
        goto CreateMetaFileW_error;

//  pMFRec->ident           = ID_METADC16;
//  pMFRec->hMem            = 0;
    pMFRec->hFile           = INVALID_HANDLE_VALUE;
    pMFRec->cbBuffer        = MF16_BUFSIZE_INIT;
//  pMFRec->ibBuffer        = 0;
    pMFRec->metaHeader.mtHeaderSize   = sizeof(METAHEADER)/sizeof(WORD);
    pMFRec->metaHeader.mtVersion      = METAVERSION300;
//  pMFRec->metaHeader.mtSize         = 0;
//  pMFRec->metaHeader.mtNoObjects    = 0;
//  pMFRec->metaHeader.mtMaxRecord    = 0;
//  pMFRec->metaHeader.mtNoParameters = 0;
//  pMFRec->recFlags        = 0;
//  pMFRec->recCurObjects[] = 0;
    pMFRec->recCurObjects[OBJ_PEN - MIN_OBJ_TYPE]
                                        = GetStockObject(BLACK_PEN);
    pMFRec->recCurObjects[OBJ_BRUSH - MIN_OBJ_TYPE]
                                        = GetStockObject(WHITE_BRUSH);
    pMFRec->recCurObjects[OBJ_FONT - MIN_OBJ_TYPE]
                                        = GetStockObject(DEVICE_DEFAULT_FONT);
    pMFRec->recCurObjects[OBJ_BITMAP - MIN_OBJ_TYPE]
                                        = GetStockObject(PRIV_STOCK_BITMAP);
    pMFRec->recCurObjects[OBJ_REGION - MIN_OBJ_TYPE]
                                        = (HANDLE) NULL;
    pMFRec->recCurObjects[OBJ_PAL - MIN_OBJ_TYPE]
                                        = GetStockObject(DEFAULT_PALETTE);
//  pMFRec->iPalVer         = 0;

// Create a disk file if given.  The filename is given in unicode.

    if (pwszFileName)
    {
        LPWSTR  pwszFilePart;           // not used
        DWORD   cPathname;

        // Convert the filename to a fully qualified pathname.

        cPathname = GetFullPathNameW(pwszFileName,
                                     MAX_PATH,
                                     pMFRec->wszFullPathName,
                                     &pwszFilePart);

        if (!cPathname || cPathname > MAX_PATH)
        {
            ERROR_ASSERT(FALSE, "GetFullPathName failed");
            if (cPathname > MAX_PATH)
                GdiSetLastError(ERROR_FILENAME_EXCED_RANGE);
            goto CreateMetaFileW_error;
        }
        pMFRec->wszFullPathName[cPathname] = 0;

        // Create the file.

        if ((pMFRec->hFile = CreateFileW(pMFRec->wszFullPathName,// Filename
                                    GENERIC_WRITE,              // Write access
                                    0L,                         // Non-shared
                                    (LPSECURITY_ATTRIBUTES) NULL, // No security
                                    CREATE_ALWAYS,              // Always create
                                    FILE_ATTRIBUTE_NORMAL,      // normal attributes
                                    (HANDLE) 0))                // no template file
            == INVALID_HANDLE_VALUE)
        {
            // Milestones, Etc. 3.1 creates the file for read/write access when
            // it calls CreateMetaFile.  This causes the above CreateFile to
            // fail.  However, we do not want to modify the above call since
            // it provides serialization and access to the metafile.  Instead,
            // we add in this hack for Milestones.  The only difference is
            // that the metafile is shared for read/write access.

            if ((pMFRec->hFile = CreateFileW(pMFRec->wszFullPathName,
                        GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        (LPSECURITY_ATTRIBUTES) NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        (HANDLE) 0))
                == INVALID_HANDLE_VALUE)
            {
                ERROR_ASSERT(FALSE, "CreateFile failed");
                goto CreateMetaFileW_error;
            }

            WARNING("CreateMetaFileW: Creating metafile with read/write share\n");
        }
        pMFRec->metaHeader.mtType = DISKMETAFILE;
    }
    else
    {
        pMFRec->metaHeader.mtType = MEMORYMETAFILE;
    }

// Allocate memory for metafile.
//   For disk metafile, it is used as a buffer.
//   For memory metafile, it is the storage for the metafile.

    if (!(pMFRec->hMem = LocalAlloc(LMEM_FIXED, MF16_BUFSIZE_INIT)))
        goto CreateMetaFileW_error;

// Write the header.

    if (!AttemptWrite(pMFRec, sizeof(METAHEADER), (LPBYTE)&pMFRec->metaHeader))
        goto CreateMetaFileW_error;

// Finally, allocate a local handle for the metafile DC.  It references
// the metafile recorder info.

    hdc = hCreateClientObjLink(pMFRec,LO_METADC16_TYPE);

    if (!hdc)
    {
        ERROR_ASSERT(FALSE, "CreateMetaFileW: iAllocHandle failed\n");
        goto CreateMetaFileW_error;
    }

    return(hdc);

CreateMetaFileW_error:

    if (pMFRec)
    {
        if (pMFRec->hFile != INVALID_HANDLE_VALUE)
        {
            if (!CloseHandle(pMFRec->hFile))
                ASSERTGDI(FALSE, "CloseHandle failed\n");

            if (!DeleteFileW(pMFRec->wszFullPathName))
                WARNING("CreateMetaFileW: DeleteFile failed\n");
        }

        if (pMFRec->hMem)
            if (LocalFree(pMFRec->hMem))
                ASSERTGDI(FALSE, "LocalFree failed");

        if (LocalFree((HANDLE) pMFRec))
            ASSERTGDI(FALSE, "CreateMetaFileW: LocalFree failed\n");
    }

    ERROR_ASSERT(FALSE, "CreateMetaFileW failed\n");
    return((HDC) 0);
}

/***************************** Internal Function **************************\
* HMETAFILE WINAPI CloseMetaFile
*
* The CloseMetaFile function closes the metafile device context and creates a
* metafile handle that can be used to play the metafile by using the
* PlayMetaFile function.
*
* The internal format for a MetaFile has two formats one
* for a memory MetaFile and one for a disk based MetaFile
*
* Effects:
*
\***************************************************************************/

HMETAFILE WINAPI CloseMetaFile(HDC hdc)
{
    PMFRECORDER16   pmfRec;
    HMETAFILE       hmf = (HMETAFILE) 0;

    PUTS("CloseMetaFile\n");

    GET_PMFRECORDER16(pmfRec,hdc);

    ASSERTGDI(pmfRec, "CloseMetaFile: pmfRec is NULL!");

    if (!IS_METADC16_TYPE(hdc) || !pmfRec)
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
        return(hmf);
    }

// If the metafile was aborted then free the MetaDC handle memory and go home.

    if (pmfRec->recFlags & METAFILEFAILURE)
        goto CLM_Cleanup;

// Write the terminate Record

    if (!RecordParms(hdc, 0, 0, (LPWORD)NULL))
        goto CLM_Cleanup;

// Flush the buffer and update the header record.

    if (pmfRec->metaHeader.mtType == DISKMETAFILE)
    {
        BOOL  fRet;
        DWORD dwT;

        ASSERTGDI(pmfRec->metaHeader.mtType == DISKMETAFILE,
            "CloseMetaFile: unknown metafile type");

        // Flush the memory buffer

        fRet = WriteFile(pmfRec->hFile, (LPBYTE)pmfRec->hMem,
                pmfRec->ibBuffer, &dwT, (LPOVERLAPPED)NULL);
        if (!fRet || (dwT != pmfRec->ibBuffer))
        {
            ERROR_ASSERT(FALSE, "CloseMetaFile: Write1 failed\n");
            goto CLM_Cleanup;
        }

        // Rewind the file and write the header out

        if (SetFilePointer(pmfRec->hFile, 0, (LPLONG)NULL, FILE_BEGIN) != 0)
        {
            ERROR_ASSERT(FALSE, "CloseMetaFile: SetFilePointer failed\n");
            goto CLM_Cleanup;
        }

        // Fix up data written to disk as a memory metafile

        pmfRec->metaHeader.mtType = MEMORYMETAFILE;
        fRet = WriteFile(pmfRec->hFile, (LPBYTE)& pmfRec->metaHeader,
                sizeof(METAHEADER), &dwT, (LPOVERLAPPED)NULL);
        pmfRec->metaHeader.mtType = DISKMETAFILE;       // restore it

        if (!fRet || (dwT != sizeof(METAHEADER)))
        {
            ERROR_ASSERT(FALSE, "CloseMetaFile: Write2 failed\n");
            goto CLM_Cleanup;
        }

        // Close the file.

        if (!CloseHandle(pmfRec->hFile))
            ASSERTGDI(FALSE, "CloseMetaFile: FileError\n");

        pmfRec->hFile = INVALID_HANDLE_VALUE;   // don't close it again below
    }
    else
    {
        HANDLE hMemNew;

        // Flush the header record.

        *(PMETAHEADER) pmfRec->hMem = pmfRec->metaHeader;

        // Realloc memory metafile to exact size

        hMemNew = LocalReAlloc(pmfRec->hMem, pmfRec->metaHeader.mtSize * sizeof(WORD), LMEM_MOVEABLE);

        if (!hMemNew)
        {
            ASSERTGDI(FALSE, "LocalReAlloc failed");
            goto CLM_Cleanup;
        }

        pmfRec->hMem = hMemNew;
    }

// Allocate and initialize a metafile.

    if (pmfRec->metaHeader.mtType == DISKMETAFILE)
    {
        hmf = GetMetaFileW(pmfRec->wszFullPathName);
    }
    else
    {
        hmf = SetMetaFileBitsAlt((HLOCAL) pmfRec->hMem);
        if (hmf)
            pmfRec->hMem = 0; // don't free it below because it has been transfered
    }

CLM_Cleanup:

// Remove the MetaFile from the list of active metafiles

    if (pmfRec->hObjectTable)
    {
        UnlistObjects(hdc);
        if (LocalFree((HANDLE) pmfRec->hObjectTable))
            ASSERTGDI( FALSE, "CloseMetaFile: LocalFree object table failed\n");
    }

// If the file handle exists at this time, we have an error.

    if (pmfRec->hFile != INVALID_HANDLE_VALUE)
    {
        if (!CloseHandle(pmfRec->hFile))
            ASSERTGDI(FALSE, "CloseHandle failed\n");

        if (!DeleteFileW(pmfRec->wszFullPathName))
            WARNING("CloseMetaFile: DeleteFile failed\n");
    }

// Free the cache buffer.

    if (pmfRec->hMem)
        if (LocalFree(pmfRec->hMem))
            ASSERTGDI(FALSE, "LocalFree failed");

// Free the memory for the metafile DC.

    if (LocalFree((HANDLE) pmfRec))
        ASSERTGDI(FALSE, "CloseMetaFile: LocalFree failed\n");

// Free the handle for the metafile DC.

    if (!bDeleteClientObjLink(hdc))
        RIP("CloseMetaFile - failed bDeleteClientObjLink\n");

    ERROR_ASSERT(hmf != (HMETAFILE) 0, "CloseMetaFile failed\n");
    return(hmf);
}

/***************************** Internal Function **************************\
* CopyMetaFile(hSrcMF, lpFileName)
*
*    Copies the metafile (hSrcMF) to a new metafile with name lpFileName. The
*    function then returns a handle to this new metafile if the function was
*    successful.
*
* Retuns      a handle to a new metafile, 0 iff failure
*
* IMPLEMENTATION:
*     The source and target metafiles are checked to see if they are both memory
*     metafile and if so a piece of Local memory is allocated and the metafile
*     is simply copied.
*     If this is not the case CreateMetaFile is called with lpFileName and then
*     records are pulled out of the source metafile (using GetEvent) and written
*     into the destination metafile one at a time (using RecordParms).
*
*     Lock the source
*     if source is a memory metafile and the destination is a memory metafile
*         alloc the same size Local memory as the source
*         copy the bits directly
*     else
*         get a metafile handle by calling CreateMetaFile
*         while GetEvent returns records form the source
*             record the record in the new metafile
*
*         close the metafile
*
*     return the new metafile handle
*
\***************************************************************************/

HMETAFILE WINAPI CopyMetaFileA(HMETAFILE hmf, LPCSTR psz)
{
    UINT  cch;
    WCHAR awch[MAX_PATH];

    if (psz != (LPSTR)NULL)
    {
        cch = strlen(psz)+1;

        if (cch > MAX_PATH)
        {
            ERROR_ASSERT(FALSE, "CopyMetaFileA filename too long");
            GdiSetLastError(ERROR_FILENAME_EXCED_RANGE);
            return((HMETAFILE)0);
        }

        vToUnicodeN(awch, MAX_PATH, psz, cch);

        return (CopyMetaFileW(hmf, awch));
    }
    else
        return (CopyMetaFileW(hmf, (LPWSTR)NULL));
}

HMETAFILE WINAPI CopyMetaFileW(HMETAFILE hSrcMF, LPCWSTR pwszFileName)
{
    PMETAFILE16     pMFSource;
    HMETAFILE       hMFDest = (HMETAFILE) 0;
    HDC             hMDCDest;
    UINT            state;

    PUTS("CopyMetaFile\n");

    pMFSource = GET_PMF16(hSrcMF);
    if (pMFSource == NULL)
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
        return(hMFDest);
    }

    state = (pMFSource->fl & MF16_DISKFILE) ? 2 : 0;
    state |= (pwszFileName) ? 1 : 0;

    switch (state)
    {
    case 0: /* memory -> memory */
        hMFDest = SetMetaFileBitsEx
                  (
                    pMFSource->metaHeader.mtSize * sizeof(WORD),
                    (LPBYTE) pMFSource->hMem
                  );
        break;

    case 3: /* disk -> disk */
        hMFDest = CopyFileW(pMFSource->wszFullPathName,
                         pwszFileName, FALSE)
                    ? GetMetaFileW(pwszFileName) : 0;

        ERROR_ASSERT(hMFDest, "CopyMetaFileW: GetMetaFile Failed\n");
        break;

    case 1:
    case 2:
        if (hMDCDest = CreateMetaFileW(pwszFileName))
        {
            PMFRECORDER16   pMFRecDest;
            PMETARECORD     lpMR = NULL;

            GET_PMFRECORDER16(pMFRecDest,hMDCDest);

            while (lpMR = GetEvent(pMFSource, lpMR))
                if ((lpMR == (PMETARECORD) -1)
                 || !RecordParms(hMDCDest, (DWORD)lpMR->rdFunction,
                              (DWORD)lpMR->rdSize - 3,
                              (LPWORD) lpMR->rdParm))
                {
                    HMETAFILE     hmfT;

                    MarkMetaFile(pMFRecDest);

                    if (hmfT = CloseMetaFile(hMDCDest))
                        DeleteMetaFile(hmfT);
                    return((HMETAFILE) 0);
                }

            // touch up the destination metafile header before we close
            // the metafile!

            pMFRecDest->metaHeader.mtNoObjects
                = pMFSource->metaHeader.mtNoObjects;
            ASSERTGDI(sizeof(METAHEADER) == 18, "CopyMetaFile: METAHEADER has changed!");

            hMFDest = CloseMetaFile(hMDCDest);
        }
        break;
    }

    ERROR_ASSERT(hMFDest, "CopyMetaFileW Failing\n");
    return(hMFDest);
}

/***************************** Internal Function ***************************\
* HANDLE WINAPI GetMetaFileBitsEx
*
* The GetMetaFileBits function returns a handle to a Windows metafile that
* contains the specified data describing the metafile.
*
* It does not invalidate the metafile handle like Windows!
*
* Effects:
*
\***************************************************************************/

UINT WINAPI GetMetaFileBitsEx(HMETAFILE hMF, UINT cbBuffer, LPVOID lpData)
{
    DWORD       cbHave;
    PMETAFILE16 pmf16;

    PUTS("GetMetaFileBitsEx\n");

    pmf16 = GET_PMF16(hMF);
    if (pmf16 == NULL)
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
        return(0);
    }

    cbHave = pmf16->metaHeader.mtSize * sizeof(WORD);

// If lpData is NULL, return the size necessary to hold the data.

    if (!lpData)
        return(cbHave);

// Make sure the input buffer is large enough.

    if (cbBuffer < cbHave)
        return(0);

// Copy the bits.  Win3.1 returns the bits for memory metafile only!
// We will do the right thing here.

    RtlCopyMemory(lpData, (PBYTE) pmf16->hMem, cbHave);

// Return the number of bytes copied.

    return(cbHave);
}

/***************************** Internal Function **************************\
* HMETAFILE WINAPI SetMetaFileBitsEx
*
* Creates a memory based Windows 3.X metafile from the data provided
*
* Returns:  HMETAFILE iff succesful.
*
* Effects:
*
\***************************************************************************/

HMETAFILE WINAPI SetMetaFileBitsEx(UINT cbBuffer, CONST BYTE *lpData)
{
    PMETAFILE16 pmf16;
    HMETAFILE   hmf;

    PUTS("SetMetaFileBitsEx\n");

// Verify the input data.

    if (cbBuffer < sizeof(METAHEADER)
     || !IsValidMetaHeader16((PMETAHEADER) lpData))
    {
        ERROR_ASSERT(FALSE, "SetMetaFileBitsEx: Bad input data\n");
        GdiSetLastError(ERROR_INVALID_DATA);
        return((HMETAFILE) 0);
    }

    ERROR_ASSERT(((PMETAHEADER) lpData)->mtType == MEMORYMETAFILE,
        "SetMetaFileBitsEx: Bad mtType\n");

// Allocate and initialize a metafile.
// Some Windows metafiles contain bad values in mtSize.  As a result,
// we have to verify and fix the mtSize if neccessary.  This is fixed
// in the following call.

    if (!(pmf16 = pmf16AllocMF16(0, (DWORD) cbBuffer, (PDWORD)lpData, (LPWSTR) NULL)))
        return((HMETAFILE) 0);

    ASSERTGDI(pmf16->metaHeader.mtType == MEMORYMETAFILE,
        "SetMetaFileBitsEx: Bad mtType\n");
    ((PMETAHEADER) pmf16->hMem)->mtType = MEMORYMETAFILE;  // just in case

// Allocate a local handle.


    hmf = hmf16Create(pmf16);
    if (hmf == NULL)
    {
        vFreeMF16(pmf16);
    }

// Return the metafile handle.

    return(hmf);
}

// Similar to Win3.x SetMetaFileBits.
// It is assumed that hMem is allocated with the LMEM_FIXED option.
// For internal use only.

HMETAFILE WINAPI SetMetaFileBitsAlt(HLOCAL hMem)
{
    PMETAFILE16 pmf16;
    HMETAFILE   hmf;

    PUTS("SetMetaFileBitsAlt\n");

// Allocate and initialize a metafile.

    if (!(pmf16 = pmf16AllocMF16(ALLOCMF16_TRANSFER_BUFFER, 0, (PDWORD) hMem, (LPWSTR) NULL)))
        return((HMETAFILE) 0);

    ASSERTGDI(pmf16->metaHeader.mtType == MEMORYMETAFILE,
        "SetMetaFileBitsAlt: Bad mtType\n");
    ((PMETAHEADER) pmf16->hMem)->mtType = MEMORYMETAFILE;  // just in case

// Allocate a local handle.

    hmf = hmf16Create(pmf16);

    if (hmf == NULL)
    {
        pmf16->hMem = NULL;       // let caller free the buffer!
        vFreeMF16(pmf16);
    }

// Return the metafile handle.

    return(hmf);
}

/***************************** Internal Function **************************\
* GetObject16AndType
*
* Returns the object type, eg OBJ_FONT, as well as a the LogObject
* in Windows 3.x Format
*
\***************************************************************************/

#define MAXOBJECTSIZE sizeof(LOGFONT)

DWORD GetObject16AndType(HANDLE hObj, LPVOID lpObjBuf16)
{
    BYTE    objBuf32[MAXOBJECTSIZE];
    int     iObj;

    PUTS("GetObjectAndType\n");

    ASSERTGDI(MAXOBJECTSIZE >= sizeof(LOGPEN),
        "GetObject16AndType MAXOBJECTSIZE wrong\n");

    if (!GetObject(hObj, MAXOBJECTSIZE, &objBuf32))
    {
        ERROR_ASSERT(FALSE, "GetObject16AndType GetObject Failed\n");
        return(0);
    }

    switch(iObj = GetObjectType(hObj))
    {
    case OBJ_PEN:
        LOGPEN16FROMLOGPEN32((PLOGPEN16)lpObjBuf16,(LPLOGPEN)objBuf32);
        break;

    case OBJ_FONT:
        LOGFONT16FROMLOGFONT32((PLOGFONT16)lpObjBuf16,(LPLOGFONT)objBuf32);
        break;

    default:
        ASSERTGDI(FALSE, "GetObject16AndType unknown object type\n");
        return(0);
        break;
    }

    return((DWORD) iObj);
}

/***************************** Internal Function **************************\
* BOOL  UnlistObjects(hMetaDC)
*
* Each object has a list of metafiles the object is associated with.
* UnlistObjects removes hMetaDC from all of its object's metafile lists
*
* Effects:
*
\***************************************************************************/

BOOL UnlistObjects(HDC hMetaDC)
{
    PMETALINK16     pml16;
    UINT            iCurObject;
    UINT            iCurMetaListEntry;
    POBJECTTABLE    pht;
    PMFRECORDER16   pMFRec;

    PUTS("UnlistObjects\n");

    GET_PMFRECORDER16(pMFRec,hMetaDC);

    if (!IS_METADC16_TYPE(hMetaDC) || !pMFRec)
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
        return((UINT)-1);
    }

    if (pMFRec->metaHeader.mtNoObjects)
    {
        pht = (POBJECTTABLE) pMFRec->hObjectTable;
        ASSERTGDI(pht, "UnlistObject: called even with no handle table");

    // Loop through the objects and unlink this metafile

        for (iCurObject=0; iCurObject < (UINT) pMFRec->metaHeader.mtNoObjects; iCurObject++)
        {
            HANDLE hObj;

            if( (hObj = pht[iCurObject].CurHandle)
                && (!pht[iCurObject].fPreDeleted))
            {
                if (IS_STOCKOBJ(hObj))
                    continue;

                ASSERTGDI(LO_TYPE(hObj) != LO_REGION_TYPE,
                    "UnlistObjects: unexpected region object");

                pml16 = pmetalink16Get(hObj);

                // It cannot be a empty list.

                ASSERTGDI(pml16, "UnlistObject: pml16 is NULL");

                if (!pml16 || pml16->cMetaDC16 == 0)
                    continue;

            // Find the metafile in the objects MetaLink16 list

                for (iCurMetaListEntry=0;
                     iCurMetaListEntry<pml16->cMetaDC16;
                     iCurMetaListEntry++)
                {
                    if(pml16->ahMetaDC16[iCurMetaListEntry] == hMetaDC)
                        break;
                }

                ASSERTGDI(iCurMetaListEntry < pml16->cMetaDC16,
                    "UnlistObject: Metafile not found");

            // Slide the rest of the metafiles in the list "up"

                for(; iCurMetaListEntry < (pml16->cMetaDC16-1); iCurMetaListEntry++)
                    pml16->ahMetaDC16[iCurMetaListEntry] = pml16->ahMetaDC16[iCurMetaListEntry+1];

                pml16->cMetaDC16--;             // just got rid of one

                if (pml16->cMetaDC16 == 0)
                {
                // We can only free the METALINK16 if the metalink field is not being used

                    if (pml16->metalink)
                    {
                        pml16->cMetaDC16 = 0;
                        pml16->ahMetaDC16[0] = (HDC)NULL;
                    }
                    else
                    {
                        if (!bDeleteMetalink16(hObj))
                            ASSERTGDI(FALSE,"UnlistObjects: LocalFree Failed\n");
                    }
                }
                else
                {
                    pml16 = pmetalink16Resize(hObj,pml16->cMetaDC16);

                    if (pml16 == NULL)
                    {
                        ASSERTGDI(FALSE,"UnlistObjects: LocalReAlloc Failed\n");
                        return (FALSE);
                    }
                }
            }
        } // for
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* pmf16AllocMF16(fl, cb, pb, pwszFilename)
*
* This routine allocates memory for an METAFILE16 and initializes it.
* Returns a pointer to the new METAFILE16.  On error returns NULL.
* It accepts only windows metafiles.
*
* This routine is called by API level METAFILE16 allocation routines
* CloseMetaFile, GetMetaFile, SetMetaFileBitsEx.
*
* Arguments:
*   fl           - ALLOCMF16_TRANSFER_BUFFER is set if storage for memory
*                  metafile is to be set directly into METAFILE16.  Otherwise,
*                  a copy of the memory metafile is duplicated.
*   cb           - Size of pb in bytes if given.  This parameter is given
*                  by SetMetaFileBitsEx only.  It is used to compare and
*                  fixup bad mtSize if necessary.
*   pb           - Pointer to a memory metafile if non-null.
*   pwszFilename - Filename of a disk metafile if non-null.
*
* History:
*  Fri May 15 14:11:22 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

PMETAFILE16 pmf16AllocMF16(DWORD fl, DWORD cb, CONST UNALIGNED DWORD *pb, LPCWSTR pwszFilename)
{
    PMETAFILE16  pmf16, pmf16Rc = (PMETAFILE16) NULL;

    PUTS("pmf16AllocMF16\n");

    ASSERTGDI(!(fl & ~ALLOCMF16_TRANSFER_BUFFER), "pmf16AllocMF16: Invalid fl");

// Allocate a new METAFILE16.

    if (!(pmf16 = (PMETAFILE16) LocalAlloc(LMEM_FIXED, sizeof(METAFILE16))))
        goto pmf16AllocMF16_cleanup;

// Initialize it.

    pmf16->ident           = MF16_IDENTIFIER;
    pmf16->hFile           = INVALID_HANDLE_VALUE;
    pmf16->hFileMap        = (HANDLE) 0;
    pmf16->hMem            = (HANDLE) 0;
    pmf16->iMem            = 0;
    pmf16->hMetaFileRecord = (HANDLE) 0;
    pmf16->fl              = 0L;

// Memory mapped the disk file if given.

    if (pwszFilename)
    {
        LPWSTR  pwszFilePart;           // not used
        DWORD   cPathname;

        pmf16->fl |= MF16_DISKFILE;     // this must be first!  See vFreeMF16.

        // Convert the filename to a fully qualified pathname.

        cPathname = GetFullPathNameW(pwszFilename,
                                     MAX_PATH,
                                     pmf16->wszFullPathName,
                                     &pwszFilePart);

        if (!cPathname || cPathname > MAX_PATH)
        {
            ERROR_ASSERT(FALSE, "GetFullPathName failed");
            if (cPathname > MAX_PATH)
                GdiSetLastError(ERROR_FILENAME_EXCED_RANGE);
            goto pmf16AllocMF16_cleanup;
        }
        pmf16->wszFullPathName[cPathname] = 0;

        if ((pmf16->hFile = CreateFileW(pmf16->wszFullPathName, // Filename
                                     GENERIC_READ,              // Read access
                                     FILE_SHARE_READ,           // Share read
                                     (LPSECURITY_ATTRIBUTES) 0L,// No security
                                     OPEN_EXISTING,             // Re-open
                                     0,                         // file attributes ignored
                                     (HANDLE) 0))               // no template file
            == INVALID_HANDLE_VALUE)
        {
        // See the comment for Milestones in CreateMetaFileW.

        if ((pmf16->hFile = CreateFileW(pmf16->wszFullPathName,
                     GENERIC_READ,
                     FILE_SHARE_READ | FILE_SHARE_WRITE,
                     (LPSECURITY_ATTRIBUTES) 0L,
                     OPEN_EXISTING,
                     0,
                     (HANDLE) 0))
        == INVALID_HANDLE_VALUE)
        {
        ERROR_ASSERT(FALSE, "CreateFile failed");
        goto pmf16AllocMF16_cleanup;
        }
        WARNING("pmf16AllocMF16: Opening metafile with read/write share\n");
        }

        if (!(pmf16->hFileMap = CreateFileMappingW(pmf16->hFile,
                                                (LPSECURITY_ATTRIBUTES) 0L,
                                                PAGE_READONLY,
                                                0L,
                                                0L,
                                                (LPWSTR) NULL)))
        {
            ERROR_ASSERT(FALSE, "CreateFileMapping failed");
            goto pmf16AllocMF16_cleanup;
        }

        if (!(pmf16->hMem = MapViewOfFile(pmf16->hFileMap, FILE_MAP_READ, 0, 0, 0)))
        {
            ERROR_ASSERT(FALSE, "MapViewOfFile failed");
            goto pmf16AllocMF16_cleanup;
        }
    }
    else if (fl & ALLOCMF16_TRANSFER_BUFFER)
    {
// If this is our memory metafile from MDC, transfer it to METAFILE16.

        pmf16->hMem = (BYTE *) pb;
    }
    else
    {
// Otherwise, make a copy of memory metafile.
// We get here only if the caller is SetMetaFileBitsEx.  Since some metafiles
// may contain a bad mtSize that is different than the actual file size, we
// need to fix it up if necessary!

        DWORD mtSize = ((PMETAHEADER) pb)->mtSize;

        if ((mtSize * 2 > cb)                   // mtSize greater than filesize
         || (((PWORD) pb)[mtSize - 3] != 3)     // EOF record should be 3,0,0
         || (((PWORD) pb)[mtSize - 2] != 0)
         || (((PWORD) pb)[mtSize - 1] != 0))
        {
            // Compute the correct mtSize!

            PMETARECORD pMR;
            DWORD       mtSizeMax;

            PUTS("pmf16AllocMF16: verifying mtSize\n");

            mtSize = ((PMETAHEADER) pb)->mtHeaderSize;
            pMR    = (PMETARECORD) ((PWORD) pb + ((PMETAHEADER) pb)->mtHeaderSize);
            mtSizeMax = cb / 2 - 3;     // max mtSize not counting EOF record

            while (mtSize <= mtSizeMax && pMR->rdFunction != 0)
            {
                mtSize += pMR->rdSize;
                pMR = (PMETARECORD) ((PWORD) pMR + pMR->rdSize);
            }

            if (mtSize > mtSizeMax)
            {
                ERROR_ASSERT(FALSE, "pmf16AllocMF16: incomplete metafile\n");
                goto pmf16AllocMF16_cleanup;
            }

// Powerpnt uses 0,0,0 for the EOF record!  We will change it to 3,0,0 below.

            mtSize += 3;    // include EOF record (pMR->rdSize may not be valid)

            if (((PMETAHEADER) pb)->mtSize != mtSize)
            {
                ERROR_ASSERT(FALSE, "pmf16AllocMF16: fixing up bad mtSize\n");
            }
        }

        if (!(pmf16->hMem = LocalAlloc(LMEM_FIXED, mtSize * sizeof(WORD))))
            goto pmf16AllocMF16_cleanup;
        RtlCopyMemory((PBYTE) pmf16->hMem, (PBYTE)pb, mtSize * sizeof(WORD));
        ((PMETAHEADER) pmf16->hMem)->mtSize = mtSize;   // update mtSize

    VERIFYGDI(((PWORD) pmf16->hMem)[mtSize - 3] == 3
           && ((PWORD) pmf16->hMem)[mtSize - 2] == 0
           && ((PWORD) pmf16->hMem)[mtSize - 1] == 0,
        "pmf16AllocMF16: fixing up bad EOF metafile record\n");

        ((PWORD) pmf16->hMem)[mtSize - 3] = 3;      // update EOF record
        ((PWORD) pmf16->hMem)[mtSize - 2] = 0;
        ((PWORD) pmf16->hMem)[mtSize - 1] = 0;
    }

// Make a copy of the metafile header.

    pmf16->metaHeader = *(PMETAHEADER) pmf16->hMem;
    pmf16->metaHeader.mtType = (pmf16->fl & MF16_DISKFILE)
                                ? DISKMETAFILE
                                : MEMORYMETAFILE;

// Verify metafile header

    if (!IsValidMetaHeader16(&pmf16->metaHeader))
    {
        ERROR_ASSERT(FALSE,
                "pmf16AllocMF16: Metafile has an invalid header; Failing\n");
        goto pmf16AllocMF16_cleanup;
    }

// Everything is golden.

    pmf16Rc = pmf16;

// Cleanup and go home.

pmf16AllocMF16_cleanup:

    if (!pmf16Rc)
        if (pmf16)
        {
            if (fl & ALLOCMF16_TRANSFER_BUFFER)
                pmf16->hMem = NULL;       // let caller free the buffer!
            vFreeMF16(pmf16);
        }

    ERROR_ASSERT(pmf16Rc, "pmf16AllocMF16 failed");
    return(pmf16Rc);
}

/******************************Public*Routine******************************\
* vFreeMF16 (pmf16)
*
* This is a low level routine which frees the resouces in the METAFILE16.
*
* This function is intended to be called from the routines CloseMetaFile
* and DeleteMetaFile.
*
* Arguments:
*   pmf16    - The METAFILE16 to be freed.
*
* History:
*  Fri May 15 14:11:22 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID vFreeMF16(PMETAFILE16 pmf16)
{
    PUTS("vFreeMF16\n");

    ASSERTGDI(pmf16->ident == MF16_IDENTIFIER, "Bad METAFILE16");

// Free the resources.

    if (!(pmf16->fl & MF16_DISKFILE))
    {
    // Free memory metafile.

        if (pmf16->hMem)
            if (LocalFree(pmf16->hMem))
                ASSERTGDI(FALSE, "LocalFree failed");
    }
    else
    {
    // Unmap disk file.

        if (pmf16->hMem)
            if (!UnmapViewOfFile((LPVOID) pmf16->hMem))
                ASSERTGDI(FALSE, "UmmapViewOfFile failed");

        if (pmf16->hFileMap)
            if (!CloseHandle(pmf16->hFileMap))
                ASSERTGDI(FALSE, "CloseHandle failed");

        if (pmf16->hFile != INVALID_HANDLE_VALUE)
            if (!CloseHandle(pmf16->hFile))
                ASSERTGDI(FALSE, "CloseHandle failed");
    }

// Smash the identifier.

    pmf16->ident = 0;

// Free the memory.

    if (LocalFree(pmf16))
        ASSERTGDI(FALSE, "LocalFree failed");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\metarec.h ===
/******************************Module*Header*******************************\
* Module Name: metarec.h
*
* Metafile recording functions.
*
* Copyright (c) 1991-1999 Microsoft Corporation
\**************************************************************************/

BOOL MF_GdiComment(HDC hdc, UINT nSize, CONST BYTE *lpData);
BOOL MF_GdiCommentWindowsMetaFile(HDC hdc, UINT nSize, CONST BYTE *lpData);
BOOL MF_GdiCommentBeginGroupEMF(HDC hdc, PENHMETAHEADER pemfHeader);
BOOL MF_GdiCommentEndGroupEMF(HDC hdc);

// SaveDC
// BeginPath
// EndPath
// CloseFigure
// FlattenPath
// WidenPath
// AbortPath

BOOL MF_Record(HDC hdc,DWORD mrType);

// FillPath
// StrokeAndFillPath
// StrokePath

BOOL MF_BoundRecord(HDC hdc,DWORD mrType);

// PolyBezier
// Polygon
// Polyline
// PolyBezierTo
// PolylineTo

BOOL MF_Poly(HDC hdc, CONST POINT *pptl, DWORD cptl, DWORD mrType);

// PolyPolygon
// PolyPolyline

BOOL MF_PolyPoly(HDC hdc, CONST POINT *pptl, CONST DWORD *pc, DWORD cPoly, DWORD mrType);

BOOL MF_PolyDraw(HDC hdc, CONST POINT *pptl, CONST BYTE *pb, DWORD cptl);

// SetMapperFlags
// SetMapMode
// SetBkMode
// SetPolyFillMode
// SetROP2
// SetStretchBltMode
// SetTextAlign
// SetTextColor
// SetBkColor
// RestoreDC
// SetArcDirection
// SetMiterLimit

BOOL MF_SetD(HDC hdc,DWORD d1,DWORD mrType);

// OffsetWindowOrgEx
// OffsetViewportOrgEx
// SetWindowExtEx
// SetWindowOrgEx
// SetViewportExtEx
// SetViewportOrgEx
// SetBrushOrgEx
// MoveToEx
// LineTo

BOOL MF_SetDD(HDC hdc,DWORD d1,DWORD d2,DWORD mrType);

// ScaleViewportExtEx
// ScaleWindowExtEx

BOOL MF_SetDDDD(HDC hdc,DWORD d1,DWORD d2,DWORD d3,DWORD d4,DWORD mrType);

BOOL MF_RestoreDC(HDC hdc,int iLevel);
BOOL MF_SetViewportExtEx(HDC hdc,int x,int y);
BOOL MF_SetViewportOrgEx(HDC hdc,int x,int y);
BOOL MF_SetWindowExtEx(HDC hdc,int x,int y);
BOOL MF_SetWindowOrgEx(HDC hdc,int x,int y);
BOOL MF_OffsetViewportOrgEx(HDC hdc,int x,int y);
BOOL MF_OffsetWindowOrgEx(HDC hdc,int x,int y);
BOOL MF_SetBrushOrgEx(HDC hdc,int x,int y);

// ExcludeClipRect
// IntersectClipRect

BOOL MF_AnyClipRect(HDC hdc,int x1,int y1,int x2,int y2,DWORD mrType);

// SetMetaRgn

BOOL MF_SetMetaRgn(HDC hdc);

// SelectClipPath

BOOL MF_SelectClipPath(HDC hdc,int iMode);

// OffsetClipRgn

BOOL MF_OffsetClipRgn(HDC hdc,int x1,int y1);

// SetPixel
// SetPixelV

BOOL MF_SetPixelV(HDC hdc,int x,int y,COLORREF color);

// CloseEnhMetaFile

BOOL MF_EOF(HDC hdc, ULONG cEntries, PPALETTEENTRY pPalEntries);

BOOL MF_SetWorldTransform(HDC hdc, CONST XFORM *pxform);
BOOL MF_ModifyWorldTransform(HDC hdc, CONST XFORM *pxform, DWORD iMode);

// SelectObject
// SelectPalette

BOOL MF_SelectAnyObject(HDC hdc,HANDLE h,DWORD mrType);

BOOL MF_DeleteObject(HANDLE h);

DWORD MF_InternalCreateObject(HDC hdc,HANDLE h);

BOOL MF_AngleArc(HDC hdc,int x,int y,DWORD r,FLOAT eA,FLOAT eB);

// SetArcDirection

BOOL MF_ValidateArcDirection(HDC hdc);

// Ellipse
// Rectangle

BOOL MF_EllipseRect(HDC hdc,int x1,int y1,int x2,int y2,DWORD mrType);

BOOL MF_RoundRect(HDC hdc,int x1,int y1,int x2,int y2,int x3,int y3);

// Arc
// ArcTo
// Chord
// Pie

BOOL MF_ArcChordPie(HDC hdc,int x1,int y1,int x2,int y2,int x3,int y3,int x4,int y4,DWORD mrType);

BOOL MF_ResizePalette(HPALETTE hpal,UINT c);
BOOL MF_RealizePalette(HPALETTE hpal);
BOOL MF_SetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, CONST PALETTEENTRY *pPalEntries);
BOOL MF_ColorCorrectPalette(HDC hdc,HPALETTE hpal,ULONG FirstEntry,ULONG NumberOfEntries);

// InvertRgn
// PaintRgn

BOOL MF_InvertPaintRgn(HDC hdc,HRGN hrgn,DWORD mrType);

BOOL MF_FillRgn(HDC hdc,HRGN hrgn,HBRUSH hbrush);
BOOL MF_FrameRgn(HDC hdc,HRGN hrgn,HBRUSH hbrush,int cx,int cy);

// SelectClipRgn
// ExtSelectClipRgn
// SelectObject(hdc,hrgn)

BOOL MF_ExtSelectClipRgn(HDC hdc,HRGN hrgn,int iMode);

// BitBlt
// PatBlt
// StretchBlt
// MaskBlt
// PlgBlt

BOOL MF_AnyBitBlt(HDC hdcDst,int xDst,int yDst,int cxDst,int cyDst,
    CONST POINT *pptDst, HDC hdcSrc,int xSrc,int ySrc,int cxSrc,int cySrc,
    HBITMAP hbmMask,int xMask,int yMask,DWORD rop,DWORD mrType);

// SetDIBitsToDevice
// StretchDIBits

BOOL MF_AnyDIBits(HDC hdcDst,int xDst,int yDst,int cxDst,int cyDst,
    int xDib,int yDib,int cxDib,int cyDib,DWORD iStartScan,DWORD cScans,
    CONST VOID * pBitsDib, CONST BITMAPINFO *pBitsInfoDib,DWORD iUsageDib,DWORD rop,DWORD mrType);

// TextOutA
// TextOutW
// ExtTextOutA
// ExtTextOutW

BOOL MF_ExtTextOut(HDC hdc,int x,int y,UINT fl,CONST RECT *prcl,LPCSTR psz,int c, CONST INT *pdx,DWORD mrType);

// PolyTextOutA
// PolyTextOutW

BOOL MF_PolyTextOut(HDC hdc,CONST POLYTEXTA *ppta,int c,DWORD mrType);

// ExtFloodFill
// FloodFill

BOOL MF_ExtFloodFill(HDC hdc,int x,int y,COLORREF color,DWORD iMode);

// SetColorAdjustment

BOOL MF_SetColorAdjustment(HDC hdc, CONST COLORADJUSTMENT *pca);

// SetFontXform

BOOL MF_SetFontXform(HDC hdc,FLOAT exScale,FLOAT eyScale);


// EMF Spooling Stuff
BOOL MF_StartDoc(HDC hdc, CONST DOCINFOW *pDocInfo );
BOOL MF_EndPage(HDC hdc);
BOOL MF_StartPage(HDC hdc);
BOOL MF_WriteEscape(HDC hdc, int nEscape, int nCount, LPCSTR lpInData, int type );
BOOL MF_ForceUFIMapping(HDC hdc, PUNIVERSAL_FONT_ID pufi );
BOOL MF_SetLinkedUFIs(HDC hdc, PUNIVERSAL_FONT_ID pufi, UINT uNumLinkedUFIs );


// SetPixelFormat
BOOL MF_SetPixelFormat(HDC hdc,
                       int iPixelFormat,
                       CONST PIXELFORMATDESCRIPTOR *ppfd);

BOOL MF_WriteNamedEscape(HDC hdc, LPWSTR pwszDriver, int nEscape, int nCount,
                         LPCSTR lpInData);

// SetICMProfile
BOOL MF_SetICMProfile(HDC hdc,LPBYTE lpData,PVOID pColorSpace,DWORD dwRecord);

// ColorMatchToTarget
BOOL MF_ColorMatchToTarget(HDC hdc, DWORD uiAction, PVOID pColorSpace, DWORD dwRecord);

// CreateColorSpace
BOOL MF_InternalCreateColorSpace(HDC hdc,HGDIOBJ h,DWORD imhe);

// Image APIs
BOOL MF_AlphaBlend(HDC,LONG,LONG,LONG,LONG,HDC,LONG,LONG,LONG,LONG,BLENDFUNCTION);
BOOL MF_GradientFill(HDC,CONST PTRIVERTEX,ULONG, CONST PVOID,ULONG,ULONG);
BOOL MF_TransparentImage(HDC,LONG,LONG,LONG,LONG,HDC,LONG,LONG,LONG,LONG,ULONG,ULONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\mfdc.cxx ===
/*************************************************************************\
* Module Name: mfdc.cxx
*
* This file contains the member functions for metafile DC class defined
* in mfdc.hxx.
*
* Created: 12-June-1991 13:46:00
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1991-1999 Microsoft Corporation
\*************************************************************************/

#define NO_STRICT

extern "C" {
#if defined(_GDIPLUS_)
#include    <gpprefix.h>
#endif

#include    <nt.h>
#include    <ntrtl.h>
#include    <nturtl.h>
#include    <stddef.h>
#include    <windows.h>    // GDI function declarations.
#include    <winerror.h>
#include    "firewall.h"
#define __CPLUSPLUS
#include    <winspool.h>
#include    <wingdip.h>
#include    "ntgdistr.h"
#include    "winddi.h"
#include    "hmgshare.h"
#include    "icm.h"
#include    "local.h"   // Local object support.
#include    "gdiicm.h"
#include    "metadef.h" // Metafile record type constants.

}

#include    "rectl.hxx"
#include    "mfdc.hxx"  // Metafile DC class declarations.

extern RECTL rclNull;   // METAFILE.CXX

#define MF_CHECK_RECORDMEMORY_LIMIT 0x00010000


VOID METALINK::vInit(ULONG metalink)
{
    imhe = ((METALINK *) &metalink)->imhe;
    ihdc = ((METALINK *) &metalink)->ihdc;
}


/******************************Public*Routine******************************\
* void * MDC::pvNewRecord(nSize)
*
* Allocate a metafile record from memory buffer.
* Also set the size field in the metafile record.  If a fatal error
* has occurred, do not allocate new record.
*
* History:
*  Thu Jul 18 11:19:20 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

void * MDC::pvNewRecord(DWORD nSize)
{
#if DBG
    static DWORD cRcd = 0;

    PUTSX("MDC::pvNewRecord %ld \n", cRcd++);
#endif

// If a fatal error has occurred, do not allocate any more.

    if (fl & MDC_FATALERROR)
        return((void *) 0);

// Before we allocate a new record, commit the previous bounds record
// if necessary.

    if (fl & MDC_DELAYCOMMIT)
    {
        // Clear the flag.

        fl &= ~MDC_DELAYCOMMIT;

        PENHMETABOUNDRECORD pmrb = (PENHMETABOUNDRECORD) GetNextRecordPtr(sizeof(ENHMETABOUNDRECORD));

        if(pmrb)
        {
            // Get and reset bounds.
            // See also MDC::vFlushBounds.

            if (GetBoundsRectAlt(hdcRef, (LPRECT) &pmrb->rclBounds, (UINT) (DCB_RESET | DCB_WINDOWMGR))
                == DCB_SET)
            {
                // Need to intersect bounds with current clipping region first

                *((PERECTL) &pmrb->rclBounds) *= *perclMetaBoundsGet();
                *((PERECTL) &pmrb->rclBounds) *= *perclClipBoundsGet();

                // Make it inclusive-inclusive.

                pmrb->rclBounds.right--;
                pmrb->rclBounds.bottom--;

                // Accumulate bounds to the metafile header.

                if (!((PERECTL) &pmrb->rclBounds)->bEmpty())
                    *((PERECTL) &mrmf.rclBounds) += pmrb->rclBounds;
                else
                    pmrb->rclBounds = rclNull;
            }
            else
            {
                pmrb->rclBounds = rclNull;
            }

            vCommit(*(PENHMETARECORD) pmrb);

            ASSERTGDI(!(fl & MDC_FATALERROR),
                "MDC::pvNewRecord: Fatal error has occurred");

            ReleasePtr(pmrb);
        }
        else
        {
            WARNING("MDC::pvNewRecord() failed to get new record\n");
            return(NULL);
        }
    }

// If there is enough free buffer space, use it.

    if (iMem + nSize > nMem)
    {
    // Not enough free buffer space.  Flush the filled buffer if it is
    // a disk metafile.

        if (bIsDiskFile())
            if (!bFlush())
                return((void *) 0);

    // Realloc memory buffer if the free buffer is still too small.

        if (iMem + nSize > nMem)
        {
            ULONG nMemNew, sizeNeeded, sizeExtra;

            sizeNeeded = (nSize + MF_BUFSIZE_INC - 1) / MF_BUFSIZE_INC * MF_BUFSIZE_INC;

            if (!bIsEMFSpool())
            {
                //
                // When not EMF spooling, use the following heuristics:
                //  If current size <= 64K, enlarge the buffer by extra 16K 
                //  Else, enlarge the buffer by extra 25%
                //

                sizeExtra = (nMem > 0x10000) ? (nMem >> 2) : MF_BUFSIZE_INC;

                nMemNew = nMem + sizeExtra + sizeNeeded;
            }
            else
            {
                //
                // When EMF spooling, use the more aggressive heuristics:
                //  If current size <= 1MB, double the buffer
                //  Else, enlarge the buffer by 50% with a cap of 4MB

                if (nMem > 0x100000)
                {
                    sizeExtra = nMem >> 1;

                    if (sizeExtra > 0x400000)
                        sizeExtra = 0x400000;
                }
                else
                    sizeExtra = nMem;
                    
                nMemNew = nMem + max(sizeNeeded, sizeExtra);
            }

            if (!ReallocMem(nMemNew))
            {
                ERROR_ASSERT(FALSE, "ReallocMem failed\n");
                return NULL;
            }
        }
    }

// Zero the last dword.  If the record does not use up all bytes in the
// last dword, the unused bytes will be zeros.

    PVOID pvRecord = GetNextRecordPtr(nSize);

    if(pvRecord)
    {
        ((PDWORD) pvRecord)[nSize / 4 - 1] = 0;

    // Set the size field and return the pointer to the new record.

        ((PENHMETARECORD) pvRecord)->nSize = nSize;

        // WINBUG 365051 4-10-2001 pravins Need to modify usage of pvNewRecord() to release ptr
        // We should not be doing the release here.  We should have users of pvNewRecord()
        // call ReleasePtr when they are done.  This requires a bunch of edits in metarec.cxx
        // and mestsup.cxx.

        ReleasePtr(pvRecord);
    }
    else
    {
        WARNING("MDC::pvNewRecord() failed to get next record ptr\n");
    }

    return pvRecord;
}


BOOL
MDC::ReallocMem(
    ULONG newsize
    )

/*++

Routine Description:

    Resize the memory buffer used to hold EMF data

Arguments:

    newsize - new size of EMF memory buffer

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    if (bIsEMFSpool())
    {
        ENHMETAHEADER  *pNewHeader;

        if(!((EMFSpoolData *) hData)->ResizeEMFData(newsize))
            return FALSE;

    }
    else
    {
        HANDLE hMemNew;

        if ((hMemNew = LocalReAlloc(hData, newsize, LMEM_MOVEABLE)) == NULL)
        {
            ERROR_ASSERT(FALSE, "LocalReAlloc failed");
            return FALSE;
        }

        hData = hMemNew;
    }

    nMem = newsize;
    return TRUE;
}


/******************************Public*Routine******************************\
* BOOL MDC::bFlush()
*
* Flush the filled memory buffer to disk.
*
* History:
*  Thu Jul 18 11:19:20 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MDC::bFlush()
{
    ULONG   nWritten ;

    PUTS("MDC::bFlush\n");
    PUTSX("\tnFlushSize  = %ld\n", (ULONG)iMem);
    PUTSX("\tnBufferSize = %ld\n", (ULONG)nMem);

    ASSERTGDI(bIsDiskFile(), "MDC::bFlush: Not a disk metafile");
    ASSERTGDI(!(fl & MDC_FATALERROR), "MDC::bFlush: Fatal error has occurred");

// WriteFile handles a null write correctly.

    if (!WriteFile(hFile, hData, iMem, &nWritten, (LPOVERLAPPED) NULL)
     || nWritten != iMem)
    {
// The write error here is fatal since we are doing record buffering and
// have no way of recovering to a previous state.

        ERROR_ASSERT(FALSE, "MDC::bFlush failed");
        fl |= MDC_FATALERROR;
        return(FALSE);
    }
    iMem = 0L;
    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID MDC::vAddToMetaFilePalette(cEntries, pPalEntriesNew)
*
* Add new palette entries to the metafile palette.
*
* When new palette entries are added to a metafile in CreatePalette or
* SetPaletteEntries, they are also accumulated to the metafile palette.
* The palette is later returned in GetEnhMetaFilePaletteEntries when an
* application queries it.  It assumes that the peFlags of the palette entries
* are zeroes.
*
* A palette color is added to the metafile palette only if it is not a
* duplicate.  It uses a simple linear search algorithm to determine if
* a duplicate palette exists.
*
* History:
*  Mon Sep 23 14:27:25 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID MDC::vAddToMetaFilePalette(UINT cEntries, PPALETTEENTRY pPalEntriesNew)
{
    UINT  ii;

    PUTS("vAddToMetaFilePalette\n");

    while (cEntries--)
    {
        ASSERTGDI(pPalEntriesNew->peFlags == 0,
            "MDC::vAddToMetaFilePalette: peFlags not zero");

        // Look for duplicate.

        for (ii = 0; ii < iPalEntries; ii++)
        {
            ASSERTGDI(sizeof(PALETTEENTRY) == sizeof(DWORD),
                "MDC::vAddToMetaFilePalette: Bad size");

            if (*(PDWORD) &pPalEntries[ii] == *(PDWORD) pPalEntriesNew)
                break;
        }

        // Add to the metafile palette if not a duplicate.

        if (ii >= iPalEntries)
        {
            pPalEntries[iPalEntries] = *pPalEntriesNew;
            iPalEntries++;              // Advance iPalEntries for next loop!
        }

        pPalEntriesNew++;
    }
}

/******************************Public*Routine******************************\
* VOID METALINK::vNext()
*
* Update *this to the next metalink.
*
* History:
*  Wed Aug 07 09:28:54 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID METALINK::vNext()
{
    PUTS("METALINK::vNext\n");
    ASSERTGDI(bValid(), "METALINK::vNext: Invalid metalink");

    PMDC pmdc = pmdcGetFromIhdc(ihdc);
    ASSERTGDI(pmdc,"METALINK::vNext - invalid pmdc\n");

    if (pmdc == NULL)
        ZeroMemory(this,sizeof(*this)); // Make it invalid so bValid will fail.
    else
        *this = pmdc->pmhe[imhe].metalink;
}

/******************************Public*Routine******************************\
* METALINK * METALINK::pmetalinkNext()
*
* Return the pointer to the next metalink.
*
* History:
*  Wed Aug 07 09:28:54 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

METALINK * METALINK::pmetalinkNext()
{
    PUTS("METALINK::pmetalinkNext\n");
    ASSERTGDI(bValid(), "METALINK::pmetalinkNext: Invalid metalink");

    PMDC pmdc = pmdcGetFromIhdc(ihdc);
    ASSERTGDI(pmdc,"METALINK::vNext - invalid pmdc\n");

    return(&pmdc->pmhe[imhe].metalink);
}

VOID EMFContainer::Init(ENHMETAHEADER * inHdr, UINT32 dataSize)
{
    dwRefCount = 0;

    pemfhdr = inHdr;
    dwHdrSize = dataSize;

    pvWindow = NULL;
    dwWindowOffset = 0;
    dwWindowSize = 0;

    hFile = NULL;
}

BOOL EMFContainer::Init(HANDLE inFile, UINT64 inHdrOffset, UINT64 inFileSize)
{
    BOOL bResult = FALSE;

    dwRefCount = 0;

    pemfhdr = NULL;
    dwHdrSize = 0;

    pvWindow = NULL;
    dwWindowOffset = 0;
    dwWindowSize = 0;

    hFile = inFile;
    hFileMapping = NULL;
    pvHdr = NULL;

    qwHdrOffset = inHdrOffset;
    qwFileSize = inFileSize;

    if(qwFileSize != 0 || GetFileSizeEx(hFile, (LARGE_INTEGER *)  &qwFileSize))
    {
        hFileMapping = CreateFileMappingW(hFile,
                                     NULL,
                                     PAGE_READWRITE,
                                     HIDWORD(qwFileSize),
                                     LODWORD(qwFileSize),
                                     NULL);

        if(hFileMapping != NULL)
        {
            UINT64  qwOffset = qwHdrOffset;
            UINT32   dwSize = sizeof(ENHMETAHEADER);

            pvHdr = pvMapView(&qwOffset, &dwSize);

            if(pvHdr)
            {
                UINT32 dwViewOffset = (UINT32) (qwHdrOffset - qwOffset);

                pemfhdr = (PENHMETAHEADER) ((PBYTE) pvHdr + dwViewOffset);
                dwHdrSize = dwSize - dwViewOffset;

                bResult = TRUE;
            }
        }

    }

    if(!bResult)
        Term();

    return bResult;

}

VOID EMFContainer::Term()
{
    // Free any locally allocated resources

    if(hFile)
    {
        // We were using mapped views of the file

        if(hFileMapping)
        {
            if(!CloseHandle(hFileMapping))
            {
                WARNING("EMFContainer::Term() failed to close file mapping\n");
            }
            hFileMapping = NULL;
        }

        if(pvHdr != NULL)
        {
            if(!UnmapViewOfFile(pvHdr))
            {
                WARNING("EMFContainer::Term() Failed to unmap header view\n");
            }
            pvHdr = NULL;
        }

        if(pvWindow != NULL)
        {
            if(!UnmapViewOfFile(pvWindow))
            {
                WARNING("EMFContainer::Term() Failed to unmap window view\n");
            }
            pvWindow = NULL;
        }

        hFile = NULL;

    }

    pemfhdr = NULL;
    dwHdrSize = 0;

}

PVOID EMFContainer::ObtainPtr(UINT inOffset, UINT inSize)
{
    if(dwRefCount > 1)
    {
        WARNING("Obtaining record with non-zero ref count\n");
        return NULL;
    }

    dwRefCount++;

    if(inOffset < dwHdrSize && inSize <= (dwHdrSize - inOffset))
        return (PVOID) ((PBYTE) pemfhdr + inOffset);

    if(!hFile)
    {
        WARNING("EMFContainer::ObtainPtr() Attempt to obtain ptr past end of memory EMF\n");
        dwRefCount--;
        return NULL;
    }

    if(inOffset < dwWindowOffset ||
       (inOffset + inSize) > (dwWindowOffset + dwWindowSize))
    {

        if(pvWindow && !UnmapViewOfFile(pvWindow))
        {
            WARNING("EMFContainer::ObtainPtr() failed to unmap window view\n");
        }

        UINT64 qwOffset = qwHdrOffset + inOffset;

        dwWindowSize = inSize;

        pvWindow = pvMapView(&qwOffset, &dwWindowSize);

        if(!pvWindow)
        {
            WARNING("EMFContainer::ObtainPtr() failed to map window view\n");
            dwRefCount--;
            return NULL;
        }

        if(qwOffset < qwHdrOffset)
        {
            dwWindowUnusable = (UINT32) (qwHdrOffset -  qwOffset);

            ASSERTGDI(dwWindowUnusable < dwWindowSize, "EMFContainer::ObtainPtr() Unexpected dwUnusable value\n");

            dwWindowSize -= dwWindowUnusable;
            dwWindowOffset = 0;

        }
        else
        {
            dwWindowUnusable = 0;
            dwWindowOffset = (UINT32) (qwOffset - qwHdrOffset);
        }

        if(inOffset < dwWindowOffset ||
           (inOffset + inSize) > (dwWindowOffset + dwWindowSize))
        {
            WARNING("EMFContainer::ObtainPtr() something went really wrong\n");
            dwRefCount--;
            return NULL;
        }

    }

    return (PVOID) ((PBYTE) pvWindow + inOffset - dwWindowOffset + dwWindowUnusable);

}

PENHMETARECORD EMFContainer::ObtainRecordPtr(UINT inOffset)
{
    ENHMETARECORD *pemr = NULL;
    
    __try 
    {
        ENHMETARECORD *pemrTemp = (ENHMETARECORD *) ObtainPtr(inOffset, sizeof(ENHMETARECORD));

        if (pemrTemp != NULL)
        {
            UINT size = pemrTemp->nSize;

            ReleasePtr(pemrTemp);

            pemrTemp = (ENHMETARECORD *) ObtainPtr(inOffset, size);

            if (pemrTemp != NULL)
            {
                //
                // WinBug #296646 andarsov 3-22-2001
                // Touch all the memory pages that belong to the record,
                // the idea is to bring them in the system cache, so the Play
                // functions will not cause PAGE_ERROR. This is not 100% certain
                // since the thread could be pre-emptied and have its memory 
                // cleared, but would not hurt much, since the faults will appear
                // later on anyway.
                //


                DWORD dwPagesize = GetSystemPageSize( );
                BYTE bData;
                BYTE *pbLoc = (BYTE *)pemrTemp;
                BYTE *pbEnd = pbLoc + ( (size < MF_CHECK_RECORDMEMORY_LIMIT) ? size : MF_CHECK_RECORDMEMORY_LIMIT );

                while (pbLoc < pbEnd)
                {
                    bData = *pbLoc;
                    pbLoc += dwPagesize;
                }

                //
                // Now finish off by touching the last byte of the record, which could happen
                // to fall in different page.
                //

                pbEnd--;
                bData = *pbEnd;

                //
                // If everything is OK here, then set the return pointer.
                //
                pemr = pemrTemp;
            }
        }
    }
    __except( GetExceptionCode() == STATUS_IN_PAGE_ERROR ) 
    {
        //
        // Here we try to catch in page errors caused when portions of the mapped file
        // cannot be moved to memory, we will return NULL in such cases
        //
    }

    return pemr;
}

PEMREOF EMFContainer::ObtainEOFRecordPtr()
{
    PEMREOF         pmreof = NULL;
    ENHMETAHEADER * pmrmf = GetEMFHeader();

    if(pmrmf)
    {
        PDWORD pdw = (PDWORD) ObtainPtr(pmrmf->nBytes - sizeof(DWORD),
                                        sizeof(DWORD));

        if(pdw)
        {
            DWORD  dwOffset = pmrmf->nBytes - *pdw;

            ReleasePtr(pdw);

            pmreof = (PEMREOF) ObtainRecordPtr(dwOffset);
        }

    }

    return pmreof;


}

PVOID  EMFContainer::pvMapView(UINT64 * ioOffset, UINT32 * ioSize)
{
    UINT64   qwMappingAlignment = GetFileMappingAlignment();
    UINT64   qwMappingMask = ~(qwMappingAlignment - 1);
    UINT64   qwRecordStart = *ioOffset;
    UINT64   qwRecordEnd = qwRecordStart + *ioSize;
    UINT64   qwViewStart;
    UINT64   qwViewEnd;
    PVOID    pvView;

    qwViewStart = qwRecordStart & qwMappingMask;

    qwViewEnd = qwViewStart + qwMappingAlignment;

    if(qwViewEnd < qwRecordEnd)
    {
        qwViewEnd = qwRecordEnd;
    }

    qwViewEnd = (qwViewEnd + (qwMappingAlignment - 1)) & qwMappingMask;

    if(qwViewEnd > qwFileSize)
    {
        qwViewEnd = qwFileSize;
    }

    DWORD dwViewSize = (DWORD) (qwViewEnd - qwViewStart);

    pvView = MapViewOfFile(hFileMapping,
                            FILE_MAP_WRITE,
                            HIDWORD(qwViewStart),
                            LODWORD(qwViewStart),
                            dwViewSize);

    if(pvView)
    {
        *ioOffset = qwViewStart;
        *ioSize = dwViewSize;
    }
    else
    {
        ioOffset = 0;
        ioSize = 0;
    }

    return pvView;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\mfrec.cxx ===
/*************************************************************************\
* Module Name: mfrec.cxx
*
* This file contains the member functions for the metafile record
* classes defined in mfrec.hxx.
*
* Created: 12-June-1991 13:46:00
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1991-1999 Microsoft Corporation
\*************************************************************************/

#define NO_STRICT

extern "C" {
#if defined(_GDIPLUS_)
#include    <gpprefix.h>
#endif

#include    <nt.h>
#include    <ntrtl.h>
#include    <nturtl.h>
#include    <stddef.h>
#include    <windows.h> // GDI function declarations.
#include    <winerror.h>
#include    "firewall.h"
#define __CPLUSPLUS
#include    <winspool.h>
#include    <w32gdip.h>
#include    "ntgdistr.h"
#include    "winddi.h"
#include    "hmgshare.h"
#include    "icm.h"
#include    "local.h"   // Local object support.
#include    "gdiicm.h"
#include    "metadef.h" // Metafile record type constants.
#include    "metarec.h" // Metafile recording functions.
#include    "mf16.h"
#include    "ntgdi.h"
#include    "nlsconv.h" // Ansi - Unicode conversions.
}

#include    "rectl.hxx"
#include    "mfdc.hxx"  // Metafile DC class declarations.
#include    "mfrec.hxx" // Metafile record class declarations.

#ifdef LANGPACK
LONG gdwDisableMetafileRec=0 ;
#endif


// Max number of pointl's allowed on stack before explicit memory allocation.

#define MAX_STACK_POINTL        128

#define STOCK_IMHE(imhe)                                             \
        (                                                            \
            ((imhe) & ENHMETA_STOCK_OBJECT) &&                       \
            (((imhe) & ~ENHMETA_STOCK_OBJECT) <= PRIV_STOCK_LAST)    \
        )

#define VALID_IMHE(imhe,cht)                                    \
        (                                                       \
            (((UINT) (imhe)) < ((UINT) (cht))) &&               \
            ((imhe) != 0)                                       \
        )

// FNBMRPLAY afnbMRPlay[EMR_MAX-EMR_MIN+1]
typedef BOOL (MR::*MRPFN)(HDC, PHANDLETABLE, UINT);
//BOOL (MR::*afnbMRPlay[EMR_MAX-EMR_MIN+1])(HDC, PHANDLETABLE, UINT) = {
MRPFN afnbMRPlay[EMR_MAX-EMR_MIN+1] = {
    (MRPFN)&MRMETAFILE::bPlay,
    (MRPFN)&MRPOLYBEZIER::bPlay,
    (MRPFN)&MRPOLYGON::bPlay,
    (MRPFN)&MRPOLYLINE::bPlay,
    (MRPFN)&MRPOLYBEZIERTO::bPlay,
    (MRPFN)&MRPOLYLINETO::bPlay,
    (MRPFN)&MRPOLYPOLYLINE::bPlay,
    (MRPFN)&MRPOLYPOLYGON::bPlay,
    (MRPFN)&MRSETWINDOWEXTEX::bPlay,
    (MRPFN)&MRSETWINDOWORGEX::bPlay,    // EMR_SETWINDOWORGEX    10
    (MRPFN)&MRSETVIEWPORTEXTEX::bPlay,
    (MRPFN)&MRSETVIEWPORTORGEX::bPlay,
    (MRPFN)&MRSETBRUSHORGEX::bPlay,
    (MRPFN)&MREOF::bPlay,
    (MRPFN)&MRSETPIXELV::bPlay,
    (MRPFN)&MRSETMAPPERFLAGS::bPlay,
    (MRPFN)&MRSETMAPMODE::bPlay,
    (MRPFN)&MRSETBKMODE::bPlay,
    (MRPFN)&MRSETPOLYFILLMODE::bPlay,
    (MRPFN)&MRSETROP2::bPlay,           // EMR_SETROP2           20
    (MRPFN)&MRSETSTRETCHBLTMODE::bPlay,
    (MRPFN)&MRSETTEXTALIGN::bPlay,
    (MRPFN)&MRSETCOLORADJUSTMENT::bPlay,
    (MRPFN)&MRSETTEXTCOLOR::bPlay,
    (MRPFN)&MRSETBKCOLOR::bPlay,
    (MRPFN)&MROFFSETCLIPRGN::bPlay,
    (MRPFN)&MRMOVETOEX::bPlay,
    (MRPFN)&MRSETMETARGN::bPlay,
    (MRPFN)&MREXCLUDECLIPRECT::bPlay,
    (MRPFN)&MRINTERSECTCLIPRECT::bPlay, // EMR_INTERSECTCLIPRECT 30
    (MRPFN)&MRSCALEVIEWPORTEXTEX::bPlay,
    (MRPFN)&MRSCALEWINDOWEXTEX::bPlay,
    (MRPFN)&MRSAVEDC::bPlay,
    (MRPFN)&MRRESTOREDC::bPlay,
    (MRPFN)&MRSETWORLDTRANSFORM::bPlay,
    (MRPFN)&MRMODIFYWORLDTRANSFORM::bPlay,
    (MRPFN)&MRSELECTOBJECT::bPlay,
    (MRPFN)&MRCREATEPEN::bPlay,
    (MRPFN)&MRCREATEBRUSHINDIRECT::bPlay,
    (MRPFN)&MRDELETEOBJECT::bPlay,      // EMR_DELETEOBJECT      40
    (MRPFN)&MRANGLEARC::bPlay,
    (MRPFN)&MRELLIPSE::bPlay,
    (MRPFN)&MRRECTANGLE::bPlay,
    (MRPFN)&MRROUNDRECT::bPlay,
    (MRPFN)&MRARC::bPlay,
    (MRPFN)&MRCHORD::bPlay,
    (MRPFN)&MRPIE::bPlay,
    (MRPFN)&MRSELECTPALETTE::bPlay,
    (MRPFN)&MRCREATEPALETTE::bPlay,
    (MRPFN)&MRSETPALETTEENTRIES::bPlay, // EMR_SETPALETTEENTRIES 50
    (MRPFN)&MRRESIZEPALETTE::bPlay,
    (MRPFN)&MRREALIZEPALETTE::bPlay,
    (MRPFN)&MREXTFLOODFILL::bPlay,
    (MRPFN)&MRLINETO::bPlay,
    (MRPFN)&MRARCTO::bPlay,
    (MRPFN)&MRPOLYDRAW::bPlay,
    (MRPFN)&MRSETARCDIRECTION::bPlay,
    (MRPFN)&MRSETMITERLIMIT::bPlay,
    (MRPFN)&MRBEGINPATH::bPlay,
    (MRPFN)&MRENDPATH::bPlay,          // EMR_ENDPATH            60
    (MRPFN)&MRCLOSEFIGURE::bPlay,
    (MRPFN)&MRFILLPATH::bPlay,
    (MRPFN)&MRSTROKEANDFILLPATH::bPlay,
    (MRPFN)&MRSTROKEPATH::bPlay,
    (MRPFN)&MRFLATTENPATH::bPlay,
    (MRPFN)&MRWIDENPATH::bPlay,
    (MRPFN)&MRSELECTCLIPPATH::bPlay,
    (MRPFN)&MRABORTPATH::bPlay,
    (MRPFN)&MR::bPlay,                 // not used
    (MRPFN)&MRGDICOMMENT::bPlay,       // EMR_GDICOMMENT         70
    (MRPFN)&MRFILLRGN::bPlay,
    (MRPFN)&MRFRAMERGN::bPlay,
    (MRPFN)&MRINVERTRGN::bPlay,
    (MRPFN)&MRPAINTRGN::bPlay,
    (MRPFN)&MREXTSELECTCLIPRGN::bPlay,
    (MRPFN)&MRBITBLT::bPlay,
    (MRPFN)&MRSTRETCHBLT::bPlay,
    (MRPFN)&MRMASKBLT::bPlay,
    (MRPFN)&MRPLGBLT::bPlay,
    (MRPFN)&MRSETDIBITSTODEVICE::bPlay, // EMR_SETDIBITSTODEVICE 80
    (MRPFN)&MRSTRETCHDIBITS::bPlay,
    (MRPFN)&MREXTCREATEFONTINDIRECTW::bPlay,
    (MRPFN)&MREXTTEXTOUT::bPlay,        // EMR_EXTTEXTOUTA
    (MRPFN)&MREXTTEXTOUT::bPlay,        // EMR_EXTTEXTOUTW
    (MRPFN)&MRBP16::bPlay,              // EMR_POLYBEZIER16
    (MRPFN)&MRBP16::bPlay,              // EMR_POLYGON16
    (MRPFN)&MRBP16::bPlay,              // EMR_POLYLINE16
    (MRPFN)&MRBP16::bPlay,              // EMR_POLYBEZIERTO16
    (MRPFN)&MRBP16::bPlay,              // EMR_POLYLINETO16
    (MRPFN)&MRBPP16::bPlay,             // EMR_POLYPOLYLINE16    90
    (MRPFN)&MRBPP16::bPlay,             // EMR_POLYPOLYGON16
    (MRPFN)&MRPOLYDRAW16::bPlay,
    (MRPFN)&MRCREATEMONOBRUSH::bPlay,
    (MRPFN)&MRCREATEDIBPATTERNBRUSHPT::bPlay,
    (MRPFN)&MREXTCREATEPEN::bPlay,
    (MRPFN)&MRPOLYTEXTOUT::bPlay,       // EMR_POLYTEXTOUTA
    (MRPFN)&MRPOLYTEXTOUT::bPlay,       // EMR_POLYTEXTOUTW

    (MRPFN)&MRSETICMMODE::bPlay,
    (MRPFN)&MRCREATECOLORSPACE::bPlay,  // EMR_CREATECOLORSPACE (ansi)
    (MRPFN)&MRSETCOLORSPACE::bPlay,     // EMR_SETCOLORSPACE    100
    (MRPFN)&MRDELETECOLORSPACE::bPlay,

    (MRPFN)&MRGLSRECORD::bPlay,         // EMR_GLSRECORD
    (MRPFN)&MRGLSBOUNDEDRECORD::bPlay,  // EMR_GLSBOUNDEDRECORD
    (MRPFN)&MRPIXELFORMAT::bPlay,       // EMR_PIXELFORMAT


    (MRPFN)&MRESCAPE::bPlay,            // EMR_DRAWESCAPE
    (MRPFN)&MRESCAPE::bPlay,            // EMR_EXTESCAPE
    (MRPFN)&MRSTARTDOC::bPlay,
    (MRPFN)&MRSMALLTEXTOUT::bPlay,
    (MRPFN)&MRFORCEUFIMAPPING::bPlay,
    (MRPFN)&MRNAMEDESCAPE::bPlay,       // EMR_NAMEDESCAPE      110

    (MRPFN)&MRCOLORCORRECTPALETTE::bPlay,
    (MRPFN)&MRSETICMPROFILE::bPlay,     // EMR_SETICMPROFILEA
    (MRPFN)&MRSETICMPROFILE::bPlay,     // EMR_SETICMPROFILEW

    (MRPFN)&MRALPHABLEND::bPlay,
    (MRPFN)&MRSETLAYOUT::bPlay,         // EMR_SETLAYOUT
    (MRPFN)&MRTRANSPARENTBLT::bPlay,
    (MRPFN)&MR::bPlay,                  // not used
    (MRPFN)&MRGRADIENTFILL::bPlay,
    (MRPFN)&MRSETLINKEDUFIS::bPlay,
    (MRPFN)&MRSETTEXTJUSTIFICATION::bPlay, //                   120
    (MRPFN)&MRCOLORMATCHTOTARGET::bPlay,   // EMF_COLORMATCHTOTARGET
    (MRPFN)&MRCREATECOLORSPACEW::bPlay,    // EMR_CREATECOLORSPACEW (unicode)
};

/******************************Public*Routine******************************\
* CreateMonoDib
*
* This is the same as CreateBitmap except that the bits are assumed
* to be DWORD aligned and that the scans start from the bottom of the bitmap.
*
* This routine is temporary until CreateDIBitmap supports monochrome bitmaps!
*
* History:
*  Sun Jun 14 12:22:11 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

extern "C" HBITMAP CreateMonoDib
(
    LPBITMAPINFO pbmi,
    CONST BYTE * pjBits,
    UINT         iUsage
)
{
    HBITMAP hbm;

    ASSERTGDI(pbmi->bmiHeader.biPlanes == 1, "CreateMonoDib: bad biPlanes value");
    ASSERTGDI(pbmi->bmiHeader.biBitCount == 1, "CreateMonoDib: bad biBitCount value");

    hbm = CreateBitmap((int)  pbmi->bmiHeader.biWidth,
                       (int)  pbmi->bmiHeader.biHeight,
                       (UINT) 1,
                       (UINT) 1,
                       (CONST VOID *) NULL);
    if (!hbm)
        return(hbm);

    SetDIBits((HDC) 0, hbm, 0, (UINT) pbmi->bmiHeader.biHeight,
              (CONST VOID *) pjBits, pbmi, iUsage);

    return(hbm);
}

/******************************Public*Routine******************************\
* CreateCompatibleDCAdvanced
*
* Create a compatible DC in the advanced graphics mode.  The advanced
* graphics mode is required to modify the world transform.
*
* History:
*  Wed Nov 4 14:21:00 1992      -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

extern "C" HDC CreateCompatibleDCAdvanced(HDC hdc)
{
    HDC hdcRet;

    hdcRet = CreateCompatibleDC(hdc);

    SetGraphicsMode(hdcRet, GM_ADVANCED);

    return(hdcRet);
}

/******************************Public*Routine******************************\
* GetBrushBits
*
* This function is really a hack.  In the current implementation,
* gdisrv keeps the original brush color table for both DIB_PAL_COLORS
* and DIB_RGB_COLORS usages.  The size of the table is
* sizeof(RGBQUAD) * nEntries in both cases.  In order to get the
* bits and bitmap info using GetDIBits, it requires that the usage
* be DIB_RGB_COLORS in the case of DIB_PAL_COLORS to prevent
* color translation.  But it actually returns the original palette
* indices stored in the brush color table.
*
* History:
*  Mon Feb 1 10:22:23 1993      -by-    Hock San Lee    [hockl]
* Wrote it.
\******************************Public*Routine******************************/

extern "C" int GetBrushBits
(
    HDC      hdc,
    HBITMAP  hbm,
    UINT     iUsage,
    DWORD    cbBmi,
    LPVOID   pBits,
    LPBITMAPINFO pBmi
)
{
    if (iUsage == DIB_PAL_COLORS)
    {
        LPBITMAPINFO pBmiTmp;
        int          iRet;
        DWORD        cEntries;

        ASSERTGDI((cbBmi - sizeof(BMIH)) % 2 == 0, "GetBrushBits: Bad cbBmi\n");
        cEntries = (cbBmi - sizeof(BMIH)) / sizeof(WORD);

        // Allocate bitmap info to accommodate RGBQUADs.
        if (!(pBmiTmp = (PBMI) LocalAlloc(LMEM_FIXED,
                (UINT) (cEntries * sizeof(RGBQUAD) + sizeof(BMIH)))))
            return(0);

        *(PBMIH) pBmiTmp = *(PBMIH) pBmi;

        // Get bitmap info and bits.
        iRet = GetDIBits(hdc, hbm,
                   0, (UINT) pBmi->bmiHeader.biHeight,
                   pBits, pBmiTmp, DIB_RGB_COLORS);

        // Get the bitmap info header and palette indexes.
        RtlCopyMemory((PBYTE) pBmi, (PBYTE) pBmiTmp, cbBmi);

        // Free the temporary bitmap info.
        if (LocalFree(pBmiTmp))
        {
            ASSERTGDI(FALSE, "GetBrushBits: LocalFree failed\n");
        }

        return(iRet);
    }
    else
    {
        // Get bitmap info and bits.

        return(GetDIBits(hdc, hbm,
                   0, (UINT) pBmi->bmiHeader.biHeight,
                   pBits, pBmi, iUsage));
    }
}

/******************************Public*Routine******************************\
* VOID MRBP::vInit(iType1, cptl1, aptl1, pmdc)
*
* Initializers -- Initialize the metafile Poly(To) record.
*
* History:
*  Thu Jul 18 11:19:20 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID MRBP::vInit(DWORD iType1, DWORD cptl1, CONST POINTL *aptl1, PMDC pmdc)
{
    PUTS("MRBP::vInit\n");

    MRB::vInit(iType1, pmdc);

    cptl = cptl1;
    RtlCopyMemory((PBYTE) aptl, (PBYTE) aptl1, cptl1 * sizeof(POINTL));
}

/******************************Public*Routine******************************\
* VOID MRBP16::vInit(iType1, cptl1, aptl1, pmdc)
*
* Initializers -- Initialize the metafile Poly(To)16 record.
*
* History:
*  Sat Mar 07 15:06:16 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID MRBP16::vInit(DWORD iType1, DWORD cptl1, CONST POINTL *aptl1, PMDC pmdc)
{
    PUTS("MRBP16::vInit\n");

    MRB::vInit(iType1, pmdc);

    cpts = cptl1;
    POINTL_TO_POINTS(apts, aptl1, cptl1);
}

/******************************Public*Routine******************************\
* VOID MRBPP::vInit(iType1, cPoly1, cptl1, ac1, aptl1, pmdc)
*
* Initializers -- Initialize the metafile PolyPoly record.
*
* History:
*  Thu Jul 18 11:19:20 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID MRBPP::vInit
(
    DWORD       iType1,
    DWORD       cPoly1,
    DWORD       cptl1,
    CONST DWORD *ac1,
    CONST POINTL *aptl1,
    PMDC        pmdc
)
{
    PUTS("MRBPP::vInit\n");

    MRB::vInit(iType1, pmdc);

    cPoly = cPoly1;
    cptl  = cptl1;
    RtlCopyMemory((PBYTE) &ac, (PBYTE) ac1, cPoly1 * sizeof(DWORD));
    RtlCopyMemory((PBYTE) &ac[cPoly1], (PBYTE) aptl1, cptl1 * sizeof(POINTL));
}

/******************************Public*Routine******************************\
* VOID MRBPP16::vInit(iType1, cPoly1, cptl, ac1, aptl1, pmdc)
*
* Initializers -- Initialize the metafile PolyPoly16 record.
*
* History:
*  Sat Mar 07 15:06:16 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID MRBPP16::vInit
(
    DWORD       iType1,
    DWORD       cPoly1,
    DWORD       cptl1,
    CONST DWORD *ac1,
    CONST POINTL *aptl1,
    PMDC        pmdc
)
{
    PUTS("MRBPP16::vInit\n");

    MRB::vInit(iType1, pmdc);

    cPoly = cPoly1;
    cpts  = cptl1;
    RtlCopyMemory((PBYTE) &ac, (PBYTE) ac1, cPoly1 * sizeof(DWORD));
    POINTL_TO_POINTS((PPOINTS) &ac[cPoly1], aptl1, cptl1);
}

/******************************Public*Routine******************************\
* VOID MRPOLYDRAW::vInit(pmdc, aptl1, ab1, cptl1)
*
* Initializers -- Initialize the metafile MRPOLYDRAW record.
*
* History:
*  Thu Oct 17 14:11:36 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID MRPOLYDRAW::vInit(PMDC pmdc, CONST POINTL *aptl1, CONST BYTE *ab1, DWORD cptl1)
{
    PUTS("MRPOLYDRAW::vInit\n");

    MRB::vInit(EMR_POLYDRAW, pmdc);

    cptl = cptl1;
    RtlCopyMemory((PBYTE) aptl, (PBYTE) aptl1, cptl1 * sizeof(POINTL));
    RtlCopyMemory((PBYTE) &aptl[cptl1], ab1, cptl1 * sizeof(BYTE));
}

/******************************Public*Routine******************************\
* VOID MRPOLYDRAW16::vInit(pmdc, aptl1, ab1, cptl1)
*
* Initializers -- Initialize the metafile MRPOLYDRAW16 record.
*
* History:
*  Sat Mar 07 15:06:16 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID MRPOLYDRAW16::vInit(PMDC pmdc, CONST POINTL *aptl1, CONST BYTE *ab1, DWORD cptl1)
{
    PUTS("MRPOLYDRAW16::vInit\n");

    MRB::vInit(EMR_POLYDRAW16, pmdc);

    cpts = cptl1;
    POINTL_TO_POINTS(apts, aptl1, cptl1);
    RtlCopyMemory((PBYTE) &apts[cptl1], ab1, cptl1 * sizeof(BYTE));
}

/******************************Public*Routine******************************\
* VOID MRTRIANGLEMESH::bInit
*
* Initializers -- Initialize the metafile MRTRIANGLEMESH
*
* History:
*
*    12/3/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID MRGRADIENTFILL::vInit(DWORD nVer1, CONST TRIVERTEX *pVer1, DWORD nTri1,CONST PVOID pTri1,ULONG ulMode1,PMDC pmdc)
{
    PUTS("MRGRADIENTFILL::vInit\n");

    MRB::vInit(EMR_GRADIENTFILL, pmdc);

    nVer   = nVer1;
    nTri   = nTri1;
    ulMode = ulMode1;

    RtlCopyMemory((PBYTE) &Ver[0],pVer1,nVer * sizeof(TRIVERTEX));

    if (ulMode & GRADIENT_FILL_TRIANGLE)
    {
         RtlCopyMemory((PBYTE) &Ver[nVer],pTri1,nTri * sizeof(GRADIENT_TRIANGLE));
    }
    else
    {
         RtlCopyMemory((PBYTE) &Ver[nVer],pTri1,nTri * sizeof(GRADIENT_RECT));
    }
}

/******************************Public*Routine******************************\
* BOOL MRMETAFILE::bValid()
*
* bValid -- Is this a valid record?
*
* History:
*  Tue Aug 20 18:19:38 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRMETAFILE::bValid()
{
    PUTS("MRMETAFILE::bValid\n");

// We do not check the version.  We will try to play a future version of
// enhanced metafile.

    if (dSignature != ENHMETA_SIGNATURE // check signature
     || iType != EMR_HEADER             // check record type
     || nHandles == 0                   // must have at least a reserved handle
     || nBytes % 4)                     // nBytes must be dword multiples
        return (FALSE);

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL MRCREATEPALETTE::bInit(hpal_, imhe_, cEntries_)
*
* Initializers -- Initialize the metafile MRCREATEPALETTE record.
* It sets the peFlags in the palette entries to zeroes.
*
* History:
*  Sun Sep 22 16:34:36 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRCREATEPALETTE::bInit(HPALETTE hpal_, ULONG imhe_, USHORT cEntries_)
{
    PUTS("MRCREATEPALETTE::bInit\n");

    MR::vInit(EMR_CREATEPALETTE);
    imhe = imhe_;
    logpal.palVersion = 0x300;
    logpal.palNumEntries = cEntries_;

    if (GetPaletteEntries(hpal_, 0, (UINT) cEntries_, logpal.palPalEntry)
        != (UINT) cEntries_)
        return(FALSE);

    for (USHORT ii = 0; ii < cEntries_; ii++)
    {
        // Since we don't support PC_EXPLICIT, we set it to black.  This will
        // prevent us from adding meaningless colors to the metafile palette.

        ASSERTGDI(sizeof(PALETTEENTRY) == sizeof(DWORD), "Bad size");

        if (logpal.palPalEntry[ii].peFlags & PC_EXPLICIT)
            *((PDWORD) &logpal.palPalEntry[ii]) = RGB(0,0,0);
        else
            logpal.palPalEntry[ii].peFlags = 0;
    }
    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID MRSETPALETTEENTRIES::vInit(imhe_, iStart_, cEntries_, pPalEntries_)
*
* Initializers -- Initialize the metafile MRSETPALETTEENTRIES record.
* It sets the peFlags in the palette entries to zeroes.
*
* History:
*  Sun Sep 22 16:34:36 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

VOID MRSETPALETTEENTRIES::vInit
(
    ULONG imhe_,
    UINT  iStart_,
    UINT  cEntries_,
    CONST PALETTEENTRY *pPalEntries_
)
{
    PUTS("MRSETPALETTEENTRIES::bInit\n");

    MR::vInit(EMR_SETPALETTEENTRIES);
    imhe     = imhe_;
    iStart   = iStart_;
    cEntries = cEntries_;

    for (UINT ii = 0; ii < cEntries_; ii++)
    {
        aPalEntry[ii] = pPalEntries_[ii];

        // Since we don't support PC_EXPLICIT, we set it to black.  This will
        // prevent us from adding meaningless colors to the metafile palette.

        ASSERTGDI(sizeof(PALETTEENTRY) == sizeof(DWORD), "Bad size");

        if (aPalEntry[ii].peFlags & PC_EXPLICIT)
            *((PDWORD) &aPalEntry[ii]) = RGB(0,0,0);
        else
            aPalEntry[ii].peFlags = 0;
    }
}

/******************************Public*Routine******************************\
* BOOL MTEXT::bInit(hdc1, x1, y1, fl1, prc1, pString1, cchString1, pdx1,
*                   pMR1, offString1, cjCh1)
*
* Initializers -- Initialize the base record for all textout metafile records.
*
* History:
*  Thu Aug 24 15:20:33 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MTEXT::bInit
(
    HDC    hdc1,
    int    x1,
    int    y1,
    UINT   fl1,
    CONST RECT *prc1,
    LPCSTR pString1,
    int    cchString1,
    CONST INT *pdx1,
    PMR    pMR1,
    DWORD  offString1,          // dword-aligned aDx follows the string
    int    cjCh1                // size of a character in bytes
)
{
    int    i;
    SIZEL  szl;

    PUTS("MTEXT::bInit\n");

    ASSERTGDI(cjCh1 == sizeof(CHAR) || cjCh1 == sizeof(WCHAR),
        "MTEXT::bInit: bad char size");

    eptlRef.vInit((LONG) x1, (LONG) y1);

    fOptions  = (DWORD) fl1;

    if (fl1 & (ETO_CLIPPED | ETO_OPAQUE))
        ercl.vInit(*(PRECTL) prc1);
    else
        ercl.vInit(rclNull);

    // Copy the string.

    cchString = cchString1;
    offString = offString1;
    RtlCopyMemory((PBYTE) pMR1 + offString1, (PBYTE) pString1, cchString1 * cjCh1);

    // Initialize the Dx array.  If it is not given, we will make one up
    // since we always need one by design!

    offaDx = offString1 + (cchString1 * cjCh1 + 3) / 4 * 4;  // make it dword-aligned
    PLONG aDx = (PLONG) ((PBYTE) pMR1 + offaDx);

    if (pdx1 != (CONST INT *)NULL)
    {
        RtlCopyMemory((PBYTE) aDx, (PBYTE) pdx1,
            cchString1 * (sizeof(LONG) * ((fOptions & ETO_PDY) ? 2 : 1)));
    }
    else if (cchString1 != 0)
    {
        if (cjCh1 == sizeof(CHAR))
        {
            // szl and nMaxExtent are needed by the function!

            if (!GetTextExtentExPointA
                 (
                    hdc1,
                    pString1,
                    cchString1,
                    MAXLONG,
                    (LPINT) NULL,
                    (LPINT) aDx,
                    (LPSIZE) &szl
                 )
               )
            return(FALSE);
        }
        else
        {
            // szl and nMaxExtent are needed by the function!

#ifdef LANGPACK
        // [bodind], I think this is non optimal solution
        //           this should be done more elegantly

            if (gbLpk)     // check if there is an LPK
            {
              BOOL bTmp;
              InterlockedIncrement( &gdwDisableMetafileRec ) ;
              bTmp = GetTextExtentExPointW
                     (
                      hdc1,
                      (LPWSTR) pString1,
                      cchString1,
                      (ULONG)0xffffffff,
                      NULL,
                      (PINT) aDx,
                      (LPSIZE) &szl
                     );
              InterlockedDecrement( &gdwDisableMetafileRec ) ;

              if (!bTmp)
              {
                return FALSE ;
              }
            }
            else
#endif
            {
                if (!NtGdiGetTextExtentExW
                     (
                        hdc1,
                        (LPWSTR) pString1,
                        cchString1,
                        (ULONG)0xffffffff,
                        NULL,
                        (PULONG) aDx,
                        (LPSIZE) &szl, 0
                     )
                   )
                return(FALSE);
            }
        }

        // Convert partial widths to individual widths.

        for (i = cchString1 - 1; i > 0; i--)
            aDx[i] -= aDx[i - 1];
    }
    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL MRMETAFILE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRMETAFILE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRMETAFILE::bPlay\n");
    ASSERTGDI(iType == EMR_HEADER, "Bad record type");

    USE(cht);

// If we are embedding the metafile, emit the public begin group comment.

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;
        DC_PLDC(hdc,pldc,FALSE);

        if (pldc->iType == LO_METADC)
        {
            PMF   pmf;

            // Get metafile.

            if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
                return(FALSE);

            // Indicate we have emitted the begin group public comment for embedding this
            // enhanced metafile.

            pmf->bBeginGroup = TRUE;
            return(MF_GdiCommentBeginGroupEMF(hdc, (PENHMETAHEADER) this));
        }
    }
    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL MRPOLYBEZIER::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRPOLYBEZIER::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRPOLYBEZIER::bPlay\n");
    ASSERTGDI(iType == EMR_POLYBEZIER, "Bad record type");

    USE(pht);
    USE(cht);
    return(PolyBezier(hdc, (LPPOINT) aptl, cptl));
}

/******************************Public*Routine******************************\
* BOOL MRPOLYGON::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRPOLYGON::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRPOLYGON::bPlay\n");
    ASSERTGDI(iType == EMR_POLYGON, "Bad record type");

    USE(pht);
    USE(cht);
    return(Polygon(hdc, (LPPOINT) aptl, (int) cptl));
}

/******************************Public*Routine******************************\
* BOOL MRPOLYLINE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRPOLYLINE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRPOLYLINE::bPlay\n");
    ASSERTGDI(iType == EMR_POLYLINE, "Bad record type");

    USE(pht);
    USE(cht);
    return(Polyline(hdc, (LPPOINT) aptl, (int) cptl));
}

/******************************Public*Routine******************************\
* BOOL MRGRADIENTFILL::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*
*    12/3/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL MRGRADIENTFILL::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRGRADIENTFILL::bPlay\n");
    ASSERTGDI(iType == EMR_GRADIENTFILL, "Bad record type");

    USE(pht);
    USE(cht);
    return(GdiGradientFill(hdc,&Ver[0],nVer,(PUSHORT)(&Ver[nVer]),nTri,ulMode));
}

/******************************Public*Routine******************************\
* BOOL MRPOLYBEZIERTO::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRPOLYBEZIERTO::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRPOLYBEZIERTO::bPlay\n");
    ASSERTGDI(iType == EMR_POLYBEZIERTO, "Bad record type");

    USE(pht);
    USE(cht);
    return(PolyBezierTo(hdc, (LPPOINT) aptl, cptl));
}

/******************************Public*Routine******************************\
* BOOL MRPOLYLINETO::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRPOLYLINETO::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRPOLYLINETO::bPlay\n");
    ASSERTGDI(iType == EMR_POLYLINETO, "Bad record type");

    USE(pht);
    USE(cht);
    return(PolylineTo(hdc, (LPPOINT) aptl, cptl));
}

/******************************Public*Routine******************************\
* BOOL MRBP16::bPlay(hdc, pht, cht)
*
* Play the 16-bit metafile records PolyBezier, Polygon, Polyline, PolyBezierTo
* and PolylineTo.
*
* History:
*  Sat Mar 07 15:06:16 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRBP16::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    BOOL    bRet = FALSE;
    POINTL  aptl[MAX_STACK_POINTL];
    PPOINTL pptl;

    PUTS("MRBP16::bPlay\n");

    USE(pht);
    USE(cht);

    if (cpts <= MAX_STACK_POINTL)
        pptl = aptl;
    else if (!(pptl = (PPOINTL) LocalAlloc(LMEM_FIXED, (UINT) cpts * sizeof(POINTL))))
        return(bRet);

    POINTS_TO_POINTL(pptl, apts, cpts);

    switch (iType)
    {
    case EMR_POLYBEZIER16:
        bRet = PolyBezier(hdc, (LPPOINT) pptl, cpts);
        break;
    case EMR_POLYGON16:
        bRet = Polygon(hdc, (LPPOINT) pptl, (int) cpts);
        break;
    case EMR_POLYLINE16:
        bRet = Polyline(hdc, (LPPOINT) pptl, (int) cpts);
        break;
    case EMR_POLYBEZIERTO16:
        bRet = PolyBezierTo(hdc, (LPPOINT) pptl, cpts);
        break;
    case EMR_POLYLINETO16:
        bRet = PolylineTo(hdc, (LPPOINT) pptl, cpts);
        break;
    default:
        ASSERTGDI(FALSE, "Bad record type");
        break;
    }

    if (cpts > MAX_STACK_POINTL)
    {
        if (LocalFree(pptl))
        {
            ASSERTGDI(FALSE, "MRBP16::bPlay: LocalFree failed");
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MRPOLYPOLYLINE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRPOLYPOLYLINE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRPOLYPOLYLINE::bPlay\n");
    ASSERTGDI(iType == EMR_POLYPOLYLINE, "Bad record type");

    USE(pht);
    USE(cht);
    return(PolyPolyline(hdc, (LPPOINT) &ac[cPoly], ac, cPoly));
}

/******************************Public*Routine******************************\
* BOOL MRPOLYPOLYGON::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRPOLYPOLYGON::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRPOLYPOLYGON::bPlay\n");
    ASSERTGDI(iType == EMR_POLYPOLYGON, "Bad record type");

    USE(pht);
    USE(cht);
    return(PolyPolygon(hdc, (LPPOINT) &ac[cPoly], (LPINT) ac, (int) cPoly));
}

/******************************Public*Routine******************************\
* BOOL MRBPP16::bPlay(hdc, pht, cht)
*
* Play the 16-bit metafile records PolyPolyline, PolyPolygon.
*
* History:
*  Sat Mar 07 15:06:16 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRBPP16::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    BOOL    bRet = FALSE;
    PPOINTL pptl;
    POINTL  aptl[MAX_STACK_POINTL];

    PUTS("MRBPP16::bPlay\n");

    USE(pht);
    USE(cht);

    if (cpts <= MAX_STACK_POINTL)
        pptl = aptl;
    else if (!(pptl = (PPOINTL) LocalAlloc(LMEM_FIXED, (UINT) cpts * sizeof(POINTL))))
        return(bRet);

    POINTS_TO_POINTL(pptl, (PPOINTS) &ac[cPoly], cpts);

    switch (iType)
    {
    case EMR_POLYPOLYLINE16:
        bRet = PolyPolyline(hdc, (LPPOINT) pptl, ac, cPoly);
        break;
    case EMR_POLYPOLYGON16:
        bRet = PolyPolygon(hdc, (LPPOINT) pptl, (LPINT) ac, (int) cPoly);
        break;
    default:
        ASSERTGDI(FALSE, "Bad record type");
        break;
    }

    if (cpts > MAX_STACK_POINTL)
    {
        if (LocalFree(pptl))
        {
            ASSERTGDI(FALSE, "MRBPP16::bPlay: LocalFree failed");
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MRPOLYDRAW::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Oct 17 14:06:04 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRPOLYDRAW::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRPOLYDRAW::bPlay\n");
    ASSERTGDI(iType == EMR_POLYDRAW, "Bad record type");

    USE(pht);
    USE(cht);
    return(PolyDraw(hdc, (LPPOINT) aptl, (LPBYTE) &aptl[cptl], (int) cptl));
}

/******************************Public*Routine******************************\
* BOOL MRPOLYDRAW16::bPlay(hdc, pht, cht)
*
* Play the 16-bit metafile record.
*
* History:
*  Sat Mar 07 15:06:16 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRPOLYDRAW16::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    BOOL    bRet = FALSE;
    POINTL  aptl[MAX_STACK_POINTL];
    PPOINTL pptl;

    PUTS("MRPOLYDRAW16::bPlay\n");
    ASSERTGDI(iType == EMR_POLYDRAW16, "Bad record type");

    USE(pht);
    USE(cht);

    if (cpts <= MAX_STACK_POINTL)
        pptl = aptl;
    else if (!(pptl = (PPOINTL) LocalAlloc(LMEM_FIXED, (UINT) cpts * sizeof(POINTL))))
        return(bRet);

    POINTS_TO_POINTL(pptl, apts, cpts);

    bRet = PolyDraw(hdc, (LPPOINT) pptl, (LPBYTE) &apts[cpts], (int) cpts);

    if (cpts > MAX_STACK_POINTL)
    {
        if (LocalFree(pptl))
        {
            ASSERTGDI(FALSE, "MRPOLYDRAW16::bPlay: LocalFree failed");
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MRSETWINDOWEXTEX::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETWINDOWEXTEX::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;

    PUTS("MRSETWINDOWEXTEX::bPlay\n");
    ASSERTGDI(iType == EMR_SETWINDOWEXTEX, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

// Cannot change extent in fixed scale mapping mode.

    if (GetMapMode(pmf->hdcXform) <= MM_MAX_FIXEDSCALE)
        return(TRUE);

// Play it to the virtual DC.

    if (!SetWindowExtEx(pmf->hdcXform, (int) d1, (int) d2, (LPSIZE) NULL))
        return(FALSE);

// Set up new transform in the target DC.

    return(pmf->bSetTransform(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRSETWINDOWORGEX::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETWINDOWORGEX::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;

    PUTS("MRSETWINDOWORGEX::bPlay\n");
    ASSERTGDI(iType == EMR_SETWINDOWORGEX, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

// Play it to the virtual DC.

    if (!SetWindowOrgEx(pmf->hdcXform, (int) d1, (int) d2, (LPPOINT) NULL))
        return(FALSE);

// Set up new transform in the target DC.

    return(pmf->bSetTransform(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRSETVIEWPORTEXTEX::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETVIEWPORTEXTEX::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;

    PUTS("MRSETVIEWPORTEXTEX::bPlay\n");
    ASSERTGDI(iType == EMR_SETVIEWPORTEXTEX, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

// Cannot change extent in fixed scale mapping mode.

    if (GetMapMode(pmf->hdcXform) <= MM_MAX_FIXEDSCALE)
        return(TRUE);

// Play it to the virtual DC.

    if (!SetViewportExtEx(pmf->hdcXform, (int) d1, (int) d2, (LPSIZE) NULL))
        return(FALSE);

// Set up new transform in the target DC.

    return(pmf->bSetTransform(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRSETVIEWPORTORGEX::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETVIEWPORTORGEX::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;

    PUTS("MRSETVIEWPORTORGEX::bPlay\n");
    ASSERTGDI(iType == EMR_SETVIEWPORTORGEX, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

// Play it to the virtual DC.

    if (!SetViewportOrgEx(pmf->hdcXform, (int) d1, (int) d2, (LPPOINT) NULL))
        return(FALSE);

// Set up new transform in the target DC.

    return(pmf->bSetTransform(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRSETBRUSHORGEX::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETBRUSHORGEX::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;

    PUTS("MRSETBRUSHORGEX::bPlay\n");
    ASSERTGDI(iType == EMR_SETBRUSHORGEX, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

// Since we do not scale brush patterns, we set the brush origin is in
// the original device units.

   return(SetBrushOrgEx(hdc, (int) d1, (int) d2, (LPPOINT) NULL));
}

/******************************Public*Routine******************************\
* BOOL MREOF::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MREOF::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MREOF::bPlay\n");
    ASSERTGDI(iType == EMR_EOF, "Bad record type");

    USE(cht);

// If we emitted the begin group public comment earlier, emit the corresponding
// end group comment now.

// If we are embedding the metafile, emit the public end group comment.

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        DC_PLDC(hdc,pldc,FALSE);

        if (pldc->iType == LO_METADC)
        {
            PMF   pmf;

            // Get metafile.

            if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
                return(FALSE);

            if (pmf->bBeginGroup)
            {
                pmf->bBeginGroup = FALSE;
                return(MF_GdiCommentEndGroupEMF(hdc));
            }
        }
    }
    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL MRGDICOMMENT::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Wed Apr 28 10:43:12 1993     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRGDICOMMENT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRGDICOMMENT::bPlay\n");
    ASSERTGDI(iType == EMR_GDICOMMENT, "Bad record type");

    USE(pht);
    USE(cht);

// Handle private comments first.

    if (!bIsPublicComment())
        return(GdiComment(hdc, (UINT) cb, abComment));

// Handle public comments.

    switch (((PEMRGDICOMMENT_PUBLIC) this)->iComment)
    {
    case GDICOMMENT_UNICODE_STRING:
    case GDICOMMENT_UNICODE_END:
       return (TRUE);

    case GDICOMMENT_WINDOWS_METAFILE:
    case GDICOMMENT_BEGINGROUP:
    case GDICOMMENT_ENDGROUP:
    default:
        return(GdiComment(hdc, (UINT) cb, abComment));

    case GDICOMMENT_MULTIFORMATS:
        {
            HENHMETAFILE hemf;
            BOOL         bRet;
            int          nEscape;
            PEMRGDICOMMENT_MULTIFORMATS pemrcmf;

        // Do embedding.

            if (IS_ALTDC_TYPE(hdc))
            {
                PLDC pldc;

                DC_PLDC(hdc,pldc,FALSE);

                if (pldc->iType == LO_METADC)
                    return(GdiComment(hdc, (UINT) cb, abComment));
            }

        // Playback the first recognizable format.

            pemrcmf = (PEMRGDICOMMENT_MULTIFORMATS) this;
            for (DWORD i = 0; i < pemrcmf->nFormats; i++)
            {
                switch (pemrcmf->aemrformat[i].dSignature)
                {
                case ENHMETA_SIGNATURE:
                    if (pemrcmf->aemrformat[i].nVersion <= META_FORMAT_ENHANCED)
                    {
                        hemf = SetEnhMetaFileBits(
                                (UINT) pemrcmf->aemrformat[i].cbData,
                                &abComment[pemrcmf->aemrformat[i].offData]);
                        bRet = PlayEnhMetaFile(hdc, hemf,
                                (LPRECT) &pemrcmf->rclOutput);
                        DeleteEnhMetaFile(hemf);
                        return(bRet);
                    }
                    break;

                case EPS_SIGNATURE:
                    nEscape = ENCAPSULATED_POSTSCRIPT;
                    if (DrawEscape(hdc, QUERYESCSUPPORT,
                        sizeof(nEscape), (LPCSTR) &nEscape) > 0)
                    {
                        int        iRet;
                        DWORD      cbEpsData;
                        PEPSDATA   pEpsData;
                        POINT      aptl3[3];

                        cbEpsData = sizeof(EPSDATA)
                                     + pemrcmf->aemrformat[i].cbData;
                        pEpsData = (PEPSDATA) LocalAlloc(LMEM_FIXED,
                                       (UINT) cbEpsData);
                        if (!pEpsData)
                            break;      // try the next format

                        aptl3[0].x = pemrcmf->rclOutput.left;
                        aptl3[0].y = pemrcmf->rclOutput.top;
                        aptl3[1].x = pemrcmf->rclOutput.right;
                        aptl3[1].y = pemrcmf->rclOutput.top;
                        aptl3[2].x = pemrcmf->rclOutput.left;
                        aptl3[2].y = pemrcmf->rclOutput.bottom;
                        if (!NtGdiTransformPoints(hdc,aptl3,pEpsData->aptl,3,XFP_LPTODPFX))
                        {
                            LocalFree((HLOCAL) pEpsData);
                            return(FALSE);
                        }

                        pEpsData->cbData   = cbEpsData;
                        pEpsData->nVersion = pemrcmf->aemrformat[i].nVersion;
                        RtlCopyMemory
                        (
                            (PBYTE) &pEpsData[1],
                            &abComment[pemrcmf->aemrformat[i].offData],
                            pemrcmf->aemrformat[i].cbData
                        );

                        iRet = DrawEscape(hdc, nEscape, (int) cbEpsData,
                                (LPCSTR) pEpsData);

                        if (LocalFree((HLOCAL) pEpsData))
                        {
                            ASSERTGDI(FALSE, "LocalFree failed");
                        }

                        // DrawEscape returns ERROR_NOT_SUPPORTED if it cannot
                        // draw this EPS data.  For example, the EPS data
                        // may be level 2 but the driver supports only level 1.

                        if (iRet <= 0 && GetLastError() == ERROR_NOT_SUPPORTED)
                            break;      // try the next format

                        return(iRet > 0);
                    }
                    break;
                }
            }

            VERIFYGDI(FALSE, "MRGDICOMMENT::bPlay: No recognized format in GDICOMMENT_MULTIFORMATS public comments\n");
            return(FALSE);       // no format found!
        }
        break;
    } // switch (((PEMRGDICOMMENT_PUBLIC) this)->iComment)

// Should not get here!

    ASSERTGDI(FALSE, "MRGDICOMMENT::bPlay: unexpected error");
    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL MRSETPIXELV::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETPIXELV::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSETPIXELV::bPlay\n");
    ASSERTGDI(iType == EMR_SETPIXELV, "Bad record type");

    USE(pht);
    USE(cht);
    return(SetPixelV(hdc, (int) eptl.x, (int) eptl.y, crColor));
}

/******************************Public*Routine******************************\
* BOOL MRSETMAPPERFLAGS::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETMAPPERFLAGS::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSETMAPPERFLAGS::bPlay\n");
    ASSERTGDI(iType == EMR_SETMAPPERFLAGS, "Bad record type");

    USE(pht);
    USE(cht);
    return(SetMapperFlags(hdc, d1) != GDI_ERROR);
}

/******************************Public*Routine******************************\
* BOOL MRSETMAPMODE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETMAPMODE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;
    int   iMapModeOld;

    PUTS("MRSETMAPMODE::bPlay\n");
    ASSERTGDI(iType == EMR_SETMAPMODE, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

// Play it to the virtual DC.

    if (!(iMapModeOld = SetMapMode(pmf->hdcXform, (int) d1)))
        return(FALSE);

// No need to recompute transform if there is no change in mapping mode
// AND it is not MM_ISOTROPIC.

    if (iMapModeOld == (int) d1 && iMapModeOld != MM_ISOTROPIC)
        return(TRUE);

// Set up new transform in the target DC.

    return(pmf->bSetTransform(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRSETLAYOUT::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETLAYOUT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;
    DWORD dwOrientationOld;

    PUTS("MRSETLAYOUT::bPlay\n");
    ASSERTGDI(iType == EMR_SETLAYOUT, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

// Play it to the virtual DC.

    if ((dwOrientationOld = SetLayout(pmf->hdcXform, (DWORD) d1)) == GDI_ERROR)
        return(FALSE);

// Set up new transform in the target DC.

    return(pmf->bSetTransform(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRSETBKMODE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETBKMODE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSETBKMODE::bPlay\n");
    ASSERTGDI(iType == EMR_SETBKMODE, "Bad record type");

    USE(pht);
    USE(cht);
    return(SetBkMode(hdc, (int) d1) != 0);
}

/******************************Public*Routine******************************\
* BOOL MRSETPOLYFILLMODE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETPOLYFILLMODE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSETPOLYFILLMODE::bPlay\n");
    ASSERTGDI(iType == EMR_SETPOLYFILLMODE, "Bad record type");

    USE(pht);
    USE(cht);
    return(SetPolyFillMode(hdc, (int) d1) != 0);
}

/******************************Public*Routine******************************\
* BOOL MRSETROP2::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETROP2::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSETROP2::bPlay\n");
    ASSERTGDI(iType == EMR_SETROP2, "Bad record type");

    USE(pht);
    USE(cht);
    return(SetROP2(hdc, (int) d1) != 0);
}

/******************************Public*Routine******************************\
* BOOL MRSETSTRETCHBLTMODE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETSTRETCHBLTMODE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSETSTRETCHBLTMODE::bPlay\n");
    ASSERTGDI(iType == EMR_SETSTRETCHBLTMODE, "Bad record type");

    USE(pht);
    USE(cht);
    return(SetStretchBltMode(hdc, (int) d1) != 0);
}

/******************************Public*Routine******************************\
* BOOL MRSETTEXTALIGN::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETTEXTALIGN::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSETTEXTALIGN::bPlay\n");
    ASSERTGDI(iType == EMR_SETTEXTALIGN, "Bad record type");

    USE(pht);
    USE(cht);
    return(SetTextAlign(hdc, (UINT) d1) != GDI_ERROR);
}

/******************************Public*Routine******************************\
* BOOL MRSETTEXTCOLOR::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETTEXTCOLOR::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSETTEXTCOLOR::bPlay\n");
    ASSERTGDI(iType == EMR_SETTEXTCOLOR, "Bad record type");

    USE(pht);
    USE(cht);
    return(SetTextColor(hdc, (COLORREF) d1) != CLR_INVALID);
}

/******************************Public*Routine******************************\
* BOOL MRSETBKCOLOR::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETBKCOLOR::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSETBKCOLOR::bPlay\n");
    ASSERTGDI(iType == EMR_SETBKCOLOR, "Bad record type");

    USE(pht);
    USE(cht);
    return(SetBkColor(hdc, (COLORREF) d1) != CLR_INVALID);
}

/******************************Public*Routine******************************\
* BOOL MRSETICMMODE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*
*    9/19/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL MRSETICMMODE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSETICMMODE::bPlay\n");
    ASSERTGDI(iType == EMR_SETICMMODE, "Bad record type");

    USE(pht);
    USE(cht);
    return((SetICMMode(hdc, (int) d1) != 0));
}

/******************************Public*Routine******************************\
* BOOL MRSETCOLORSPACE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*
*    9/19/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL MRSETCOLORSPACE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    HCOLORSPACE hColorSpace;
    PUTS("MRSETCOLORSPACE::bPlay\n");
    ASSERTGDI(iType == EMR_SETCOLORSPACE, "Bad record type");

    USE(cht);

    if(STOCK_IMHE(d1))
    {
        hColorSpace = (HCOLORSPACE) GetStockObject(d1 & ~ENHMETA_STOCK_OBJECT);
    }
    else
    {
        hColorSpace = (HCOLORSPACE) pht->objectHandle[d1];
    }

    return((SetColorSpace(hdc, hColorSpace) != 0));
}

/******************************Public*Routine******************************\
* BOOL MRCREATECOLORSPACE::bPlay(hdc, pht, cht)
*
* Play the metafile record (Windows 98 compatible record)
*
* History:
*
*    7/15/1998 Hideyuki Nagase [hideyukn]
*
\**************************************************************************/

BOOL MRCREATECOLORSPACE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRCREATECOLORSPACE::bPlay\n");
    ASSERTGDI(iType == EMR_CREATECOLORSPACE, "Bad record type");

    USE(hdc);

// Make sure the handle is in the table.

    if (!VALID_IMHE(imhe, cht))
        return(FALSE);

    pht->objectHandle[imhe] = CreateColorSpaceA(&lcsp);
    return(pht->objectHandle[imhe] != 0);
}

/******************************Public*Routine******************************\
* BOOL MRDELETECOLORSPACE::bPlay(hdc, pht, cht)
*
* Play the metafile record - stub for deletecolorspace
*
* History:
*
*    9/19/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL MRDELETECOLORSPACE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRDELETECOLORSPACE::bPlay\n");
    ASSERTGDI(iType == EMR_DELETECOLORSPACE, "Bad record type");

    USE(hdc);
    USE(pht);
    USE(cht);

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL MRSETARCDIRECTION::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Oct 17 16:46:33 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETARCDIRECTION::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSETARCDIRECTION::bPlay\n");
    ASSERTGDI(iType == EMR_SETARCDIRECTION, "Bad record type");

    USE(pht);
    USE(cht);

// Arc direction is recorded in the advanced graphics mode.  Make sure we have
// set the advanced graphics mode.

    ASSERTGDI
    (
        GetGraphicsMode(hdc) == GM_ADVANCED,
        "MR::bPlay: Not in advanced graphics mode"
    );

    return(SetArcDirection(hdc, (int) d1) != 0);
}

/******************************Public*Routine******************************\
* BOOL MRSETMITERLIMIT::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Oct 17 16:46:33 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETMITERLIMIT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSETMITERLIMIT::bPlay\n");
    ASSERTGDI(iType == EMR_SETMITERLIMIT, "Bad record type");

    USE(pht);
    USE(cht);
    return(SetMiterLimit(hdc, (FLOAT) d1, (PFLOAT) NULL) != GDI_ERROR);
}

/******************************Public*Routine******************************\
* BOOL MRMOVETOEX::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRMOVETOEX::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRMOVETOEX::bPlay\n");
    ASSERTGDI(iType == EMR_MOVETOEX, "Bad record type");

    USE(pht);
    USE(cht);
    return(MoveToEx(hdc, (int) d1, (int) d2, (LPPOINT) NULL));
}

/******************************Public*Routine******************************\
* BOOL MRLINETO::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Wed Oct 02 10:30:36 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRLINETO::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRLINETO::bPlay\n");
    ASSERTGDI(iType == EMR_LINETO, "Bad record type");

    USE(pht);
    USE(cht);
    return(LineTo(hdc, (int) d1, (int) d2));
}

/******************************Public*Routine******************************\
* BOOL MREXCLUDECLIPRECT::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MREXCLUDECLIPRECT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MREXCLUDECLIPRECT::bPlay\n");
    ASSERTGDI(iType == EMR_EXCLUDECLIPRECT, "Bad record type");

    USE(pht);
    USE(cht);

    return
    (
        ExcludeClipRect
        (
            hdc,
            (int) d1,
            (int) d2,
            (int) d3,
            (int) d4
        )
        != RGN_ERROR
    );
}

/******************************Public*Routine******************************\
* BOOL MRINTERSECTCLIPRECT::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRINTERSECTCLIPRECT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRINTERSECTCLIPRECT::bPlay\n");
    ASSERTGDI(iType == EMR_INTERSECTCLIPRECT, "Bad record type");

    USE(pht);
    USE(cht);

    return
    (
        IntersectClipRect
        (
            hdc,
            (int) d1,
            (int) d2,
            (int) d3,
            (int) d4
        )
        != RGN_ERROR
    );
}

/******************************Public*Routine******************************\
* BOOL MRINVERTRGN::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Tue Oct 29 13:44:38 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRINVERTRGN::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;
    BOOL  bRet;
    HRGN  hrgn;

    PUTS("MRINVERTRGN::bPlay\n");
    ASSERTGDI(iType == EMR_INVERTRGN, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

// Check bounds.

    if (pmf->bClipped(erclBounds))
        return(TRUE);

// Create the region.

    if (!(hrgn = ExtCreateRegion((LPXFORM) NULL, cRgnData, (LPRGNDATA) &this[1])))
        return(FALSE);

    bRet = InvertRgn(hdc, hrgn);

    if (!DeleteObject(hrgn))
    {
        ASSERTGDI(FALSE, "DeleteObject failed");
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MRPAINTRGN::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Tue Oct 29 13:44:38 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRPAINTRGN::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;
    BOOL  bRet;
    HRGN  hrgn;

    PUTS("MRPAINTRGN::bPlay\n");
    ASSERTGDI(iType == EMR_PAINTRGN, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

// Check bounds.

    if (pmf->bClipped(erclBounds))
        return(TRUE);

// Create the region.

    if (!(hrgn = ExtCreateRegion((LPXFORM) NULL, cRgnData, (LPRGNDATA) &this[1])))
        return(FALSE);

    bRet = PaintRgn(hdc, hrgn);

    if (!DeleteObject(hrgn))
    {
        ASSERTGDI(FALSE, "DeleteObject failed");
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MRFILLRGN::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Tue Oct 29 13:44:38 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRFILLRGN::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF    pmf;
    BOOL   bRet;
    HRGN   hrgn;
    HBRUSH hbr;

    PUTS("MRFILLRGN::bPlay\n");
    ASSERTGDI(iType == EMR_FILLRGN, "Bad record type");

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

// Check bounds.

    if (pmf->bClipped(erclBounds))
        return(TRUE);

// Get the brush handle.

    if (STOCK_IMHE(imheBrush))
    {
        // Stock brush.

        hbr = (HBRUSH) GetStockObject(imheBrush & ~ENHMETA_STOCK_OBJECT);
    }
    else
    {
        // Make sure the handle is in the table.

        if (!VALID_IMHE(imheBrush, cht))
            return(FALSE);

        // If brush creation failed earlier, hbr is 0 and FillRgn will
        // just return an error.

        hbr = (HBRUSH) pht->objectHandle[imheBrush];
    }

// Create the region.

    if (!(hrgn = ExtCreateRegion((LPXFORM) NULL, cRgnData, (LPRGNDATA) &this[1])))
        return(FALSE);

    bRet = FillRgn(hdc, hrgn, hbr);

    if (!DeleteObject(hrgn))
    {
        ASSERTGDI(FALSE, "DeleteObject failed");
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MRFRAMERGN::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Tue Oct 29 13:44:38 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRFRAMERGN::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF    pmf;
    BOOL   bRet;
    HRGN   hrgn;
    HBRUSH hbr;

    PUTS("MRFRAMERGN::bPlay\n");
    ASSERTGDI(iType == EMR_FRAMERGN, "Bad record type");

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

// Check bounds.

    if (pmf->bClipped(erclBounds))
        return(TRUE);

// Get the brush handle.

    if (STOCK_IMHE(imheBrush))
    {
        // Stock brush.

        hbr = (HBRUSH) GetStockObject(imheBrush & ~ENHMETA_STOCK_OBJECT);
    }
    else
    {
        // Make sure the handle is in the table.

        if (!VALID_IMHE(imheBrush, cht))
            return(FALSE);

        // If brush creation failed earlier, hbr is 0 and FrameRgn will
        // just return an error.

        hbr = (HBRUSH) pht->objectHandle[imheBrush];
    }

// Create the region.

    if (!(hrgn = ExtCreateRegion((LPXFORM) NULL, cRgnData, (LPRGNDATA) &this[1])))
        return(FALSE);

    bRet = FrameRgn(hdc, hrgn, hbr, (int) nWidth, (int) nHeight);

    if (!DeleteObject(hrgn))
    {
        ASSERTGDI(FALSE, "DeleteObject failed");
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MROFFSETCLIPRGN::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Tue Oct 29 13:44:38 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MROFFSETCLIPRGN::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MROFFSETCLIPRGN::bPlay\n");
    ASSERTGDI(iType == EMR_OFFSETCLIPRGN, "Bad record type");

    USE(pht);
    USE(cht);

// Since we have moved the initial destination clip region into the meta
// region (hrgnMeta), the offset will not affect the initial clip region.

    return(OffsetClipRgn(hdc, (int) d1, (int) d2) != RGN_ERROR);
}

/******************************Public*Routine******************************\
* BOOL MREXTSELECTCLIPRGN::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Tue Oct 29 13:44:38 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MREXTSELECTCLIPRGN::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;
    BOOL  bRet;
    HRGN  hrgn;

    PUTS("MREXTSELECTCLIPRGN::bPlay\n");
    ASSERTGDI(iType == EMR_EXTSELECTCLIPRGN, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

// Create the region if necessary.
// The region will be created in the destination units.

    if (cRgnData == 0)          // default region
    {
        ASSERTGDI(iMode == RGN_COPY,
            "MREXTSELECTCLIPRGN::bPlay: No region data");
        hrgn = (HRGN) 0;
    }
    else if (!(hrgn = ExtCreateRegion(&pmf->xformBase,
                                                // this happens to be xformBase
                                      cRgnData,
                                      (LPRGNDATA) &this[1])))
        return(FALSE);

// Since we have moved the initial destination clip region into the meta
// region (hrgnMeta), the select will not affect the initial clip region.

    bRet = ExtSelectClipRgn(hdc, hrgn, (int) iMode) != RGN_ERROR;

    if (hrgn)
    {
        if (!DeleteObject(hrgn))
        {
            ASSERTGDI(FALSE, "DeleteObject failed");
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MRSETMETARGN::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Tue Apr 07 17:59:25 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETMETARGN::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSETMETARGN::bPlay\n");
    ASSERTGDI(iType == EMR_SETMETARGN, "Bad record type");

    USE(pht);
    USE(cht);

    return(SetMetaRgn(hdc) != RGN_ERROR);
}

/******************************Public*Routine******************************\
* BOOL MRSCALEVIEWPORTEXTEX::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSCALEVIEWPORTEXTEX::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;

    PUTS("MRSCALEVIEWPORTEXTEX::bPlay\n");
    ASSERTGDI(iType == EMR_SCALEVIEWPORTEXTEX, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

// Cannot change extent in fixed scale mapping mode.

    if (GetMapMode(pmf->hdcXform) <= MM_MAX_FIXEDSCALE)
        return(TRUE);

// Play it to the virtual DC.

    if (!ScaleViewportExtEx(pmf->hdcXform,
                          (int) d1,
                          (int) d2,
                          (int) d3,
                          (int) d4,
                          (LPSIZE) NULL))
        return(FALSE);

// Set up new transform in the target DC.

    return(pmf->bSetTransform(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRSCALEWINDOWEXTEX::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSCALEWINDOWEXTEX::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;

    PUTS("MRSCALEWINDOWEXTEX::bPlay\n");
    ASSERTGDI(iType == EMR_SCALEWINDOWEXTEX, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

// Cannot change extent in fixed scale mapping mode.

    if (GetMapMode(pmf->hdcXform) <= MM_MAX_FIXEDSCALE)
        return(TRUE);

// Play it to the virtual DC.

    if (!ScaleWindowExtEx(pmf->hdcXform,
                        (int) d1,
                        (int) d2,
                        (int) d3,
                        (int) d4,
                        (LPSIZE) NULL))
        return(FALSE);

// Set up new transform in the target DC.

    return(pmf->bSetTransform(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRSAVEDC::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSAVEDC::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;

    PUTS("MRSAVEDC::bPlay\n");
    ASSERTGDI(iType == EMR_SAVEDC, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

// Save the virtual DC used for transform computation.

    if (!SaveDC(pmf->hdcXform))
        return(FALSE);

// We may need to save the MF data structure here.  Luckily there is no
// other data in the MF structure that requires us to do this.
// Save the target DC.

    if (SaveDC(hdc) == 0)
    {
        RestoreDC(pmf->hdcXform, -1);
        return(FALSE);
    }

    pmf->cLevel++;
    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL MRRESTOREDC::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRRESTOREDC::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;

    PUTS("MRRESTOREDC::bPlay\n");
    ASSERTGDI(iType == EMR_RESTOREDC, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

// No absolute level restore is allowed.

    if ((int) d1 > 0)
        return(FALSE);

// Restore the virtual DC used for transform computation.
// If we can restore the virtual DC, we know that it is a balanced restore.
// Otherwise, we return an error.

    if (!RestoreDC(pmf->hdcXform, (int) d1))
        return(FALSE);

// Restore the target DC.

    pmf->cLevel += d1;
    return(RestoreDC(hdc, (int) d1));
}

/******************************Public*Routine******************************\
* BOOL MRSETWORLDTRANSFORM::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETWORLDTRANSFORM::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;

    PUTS("MRSETWORLDTRANSFORM::bPlay\n");
    ASSERTGDI(iType == EMR_SETWORLDTRANSFORM, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

// Play it to the virtual DC.

    if (!SetWorldTransform(pmf->hdcXform, &xform))
        return(FALSE);

// Set up new transform in the target DC.

    return(pmf->bSetTransform(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRMODIFYWORLDTRANSFORM::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRMODIFYWORLDTRANSFORM::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;

    PUTS("MRMODIFYWORLDTRANSFORM::bPlay\n");
    ASSERTGDI(iType == EMR_MODIFYWORLDTRANSFORM, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

// Play it to the virtual DC.

    if (!ModifyWorldTransform(pmf->hdcXform, &xform, d1))
        return(FALSE);

// Do the easy case of left multiply.

    if (d1 == MWT_LEFTMULTIPLY)
        return(ModifyWorldTransform(hdc, &xform, d1));

// Recompute transform in the other two cases.
// Set up new transform in the target DC.

    return(pmf->bSetTransform(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRSELECTOBJECT::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSELECTOBJECT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSELECTOBJECT::bPlay\n");
    ASSERTGDI(iType == EMR_SELECTOBJECT, "Bad record type");

// Do stock objects first.

    if (STOCK_IMHE(d1))
        return
        (
            SelectObject(hdc, GetStockObject(d1 & ~ENHMETA_STOCK_OBJECT))
            != 0
        );

// Make sure the handle is in the table.

    if (!VALID_IMHE(d1, cht))
        return(FALSE);

// If object creation failed earlier, object handle is 0 and SelectObject
// will just return an error.

    return(SelectObject(hdc, pht->objectHandle[d1]) != 0);
}

/******************************Public*Routine******************************\
* BOOL MRSELECTPALETTE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
* The palette is always selected as a background palette.
*
* History:
*  Sun Sep 22 16:53:24 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSELECTPALETTE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSELECTPALETTE::bPlay\n");
    ASSERTGDI(iType == EMR_SELECTPALETTE, "Bad record type");

// Do stock palette first.

    if (d1 == (ENHMETA_STOCK_OBJECT | DEFAULT_PALETTE))
        return
        (
            SelectPalette(hdc, (HPALETTE) GetStockObject(DEFAULT_PALETTE), TRUE)
            != 0
        );

// Make sure the handle is in the table.

    if (!VALID_IMHE(d1, cht))
        return(FALSE);

// If palette creation failed earlier, hpal is 0 and SelectPalette will
// just return an error.

    return(SelectPalette(hdc, (HPALETTE) pht->objectHandle[d1], TRUE) != 0);
}

/******************************Public*Routine******************************\
* BOOL MRCOLORCORRECTPALETTE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
\**************************************************************************/

BOOL MRCOLORCORRECTPALETTE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRCOLORCORRECTPALETTE::bPlay\n");
    ASSERTGDI(iType == EMR_COLORCORRECTPALETTE, "Bad record type");

// Make sure the handle is in the table.

    if (!VALID_IMHE(d1, cht))
        return(FALSE);

    return(ColorCorrectPalette(hdc, (HPALETTE) pht->objectHandle[d1], d2, d3) != 0);
}

/******************************Public*Routine******************************\
* BOOL MRCREATEPEN::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRCREATEPEN::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRCREATEPEN::bPlay\n");
    ASSERTGDI(iType == EMR_CREATEPEN, "Bad record type");

    USE(hdc);

// Make sure the handle is in the table.

    if (!VALID_IMHE(imhe, cht))
        return(FALSE);

// Create the pen and store it in the table.

    pht->objectHandle[imhe] = CreatePenIndirect(&logpen);
    return(pht->objectHandle[imhe] != 0);
}

/******************************Public*Routine******************************\
* BOOL MREXTCREATEPEN::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Mon Mar 16 18:20:11 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MREXTCREATEPEN::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    LOGBRUSH lb;
    HBITMAP  hbm = (HBITMAP) 0;

    PUTS("MREXTCREATEPEN::bPlay\n");
    ASSERTGDI(iType == EMR_EXTCREATEPEN, "Bad record type");

    USE(hdc);

// Make sure the handle is in the table.

    if (!VALID_IMHE(imhe, cht))
        return(FALSE);

// Create the brush if any.

    lb.lbStyle = elp.elpBrushStyle;
    lb.lbColor = elp.elpColor;
    lb.lbHatch = (ULONG_PTR)(elp.elpHatch);

    if (elp.elpBrushStyle == BS_PATTERN)
    {
        // a small check of the validity of the record.
        // WinFix #359131 (andarsov) malformed such records are skipped.
        if ( offBitsInfo >= nSize || offBits >= nSize )
            goto mecp_exit;

        // Mono bitmap.
        if (!(hbm = CreateMonoDib
                    (
                        (PBMI) ((PBYTE) this + offBitsInfo),
                        (CONST BYTE *) ((PBYTE) this + offBits),
                        *(PUINT) &elp.elpColor
                    )
             )
           )
            goto mecp_exit;

        lb.lbHatch = (ULONG_PTR)hbm;
    }
    else if (elp.elpBrushStyle == BS_DIBPATTERNPT
          || elp.elpBrushStyle == BS_DIBPATTERN)
    {
        // DIB bitmap.

        lb.lbStyle = BS_DIBPATTERNPT;
        lb.lbHatch = (ULONG_PTR)((PBYTE) this + offBitsInfo);
    }

// Create the pen and store it in the table.

    pht->objectHandle[imhe] = ExtCreatePen
                              (
                                (DWORD) elp.elpPenStyle,
                                (DWORD) elp.elpWidth,
                                &lb,
                                elp.elpNumEntries,
                                elp.elpNumEntries
                                    ? elp.elpStyleEntry
                                    : (LPDWORD) NULL
                              );
mecp_exit:

    if (hbm)
    {
        if (!DeleteObject(hbm))
        {
            ASSERTGDI(FALSE, "MREXTCREATEPEN::bPlay: DeleteObject failed");
        }
    }

    return(pht->objectHandle[imhe] != 0);
}

/******************************Public*Routine******************************\
* BOOL MRCREATEPALETTE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Sun Sep 22 15:07:56 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRCREATEPALETTE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRCREATEPALETTE::bPlay\n");
    ASSERTGDI(iType == EMR_CREATEPALETTE, "Bad record type");

    USE(hdc);

// Make sure the handle is in the table.

    if (!VALID_IMHE(imhe, cht))
        return(FALSE);

// Create the palette and store it in the table.

    pht->objectHandle[imhe] = CreatePalette(&logpal);
    return(pht->objectHandle[imhe] != 0);
}

/******************************Public*Routine******************************\
* BOOL MRCREATEBRUSHINDIRECT::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRCREATEBRUSHINDIRECT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    LOGBRUSH lbNew;

    PUTS("MRCREATEBRUSHINDIRECT::bPlay\n");
    ASSERTGDI(iType == EMR_CREATEBRUSHINDIRECT, "Bad record type");

    USE(hdc);

// Make sure the handle is in the table.

    if (!VALID_IMHE(imhe, cht))
        return(FALSE);

// Create the brush and store it in the table.

    if (lb.lbStyle != BS_SOLID
     && lb.lbStyle != BS_HATCHED
     && lb.lbStyle != BS_HOLLOW)
        return(FALSE);

    lbNew.lbStyle = lb.lbStyle;
    lbNew.lbColor = lb.lbColor;
    lbNew.lbHatch = (UINT_PTR)lb.lbHatch;

    pht->objectHandle[imhe] = CreateBrushIndirect(&lbNew);
    return(pht->objectHandle[imhe] != 0);
}

/******************************Public*Routine******************************\
* BOOL MRCREATEMONOBRUSH::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Mar 12 17:13:53 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRCREATEMONOBRUSH::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    HBITMAP hbm;

    PUTS("MRCREATEMONOBRUSH::bPlay\n");
    ASSERTGDI(iType == EMR_CREATEMONOBRUSH, "Bad record type");

    USE(hdc);

// Make sure the handle is in the table.

    if (!VALID_IMHE(imhe, cht))
        return(FALSE);

// Create the brush and store it in the table.

    if (!(hbm = CreateMonoDib
                (
                    (PBMI) ((PBYTE) this + offBitsInfo),
                    (CONST BYTE *) ((PBYTE) this + offBits),
                    (UINT) iUsage
                )
         )
       )
        return(FALSE);

    pht->objectHandle[imhe] = CreatePatternBrush(hbm);

    if (!DeleteObject(hbm))
    {
        ASSERTGDI(FALSE, "MRCREATEMONOBRUSH::bPlay: DeleteObject failed");
    }

    return(pht->objectHandle[imhe] != 0);
}

/******************************Public*Routine******************************\
* BOOL MRCREATEDIBPATTERNBRUSHPT::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Mar 12 17:13:53 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRCREATEDIBPATTERNBRUSHPT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRCREATEDIBPATTERNBRUSHPT::bPlay\n");
    ASSERTGDI(iType == EMR_CREATEDIBPATTERNBRUSHPT, "Bad record type");

    USE(hdc);

// Make sure the handle is in the table.

    if (!VALID_IMHE(imhe, cht))
        return(FALSE);

// Create the brush and store it in the table.

    pht->objectHandle[imhe] = CreateDIBPatternBrushPt
                              (
                                (LPBITMAPINFO) ((PBYTE) this + offBitsInfo),
                                (UINT) iUsage
                              );
    return(pht->objectHandle[imhe] != 0);
}


/******************************Public*Routine******************************\
* BOOL MREXTCREATEFONTINDIRECTW::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Tue Jan 14 14:10:43 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MREXTCREATEFONTINDIRECTW::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MREXTCREATEFONTINDIRECTW::bPlay\n");
    ASSERTGDI(iType == EMR_EXTCREATEFONTINDIRECTW, "Bad record type");

    USE(hdc);

// Make sure the handle is in the table.

    if (!VALID_IMHE(imhe, cht))
        return(FALSE);

// As of NT 5.0 we only record records that contain ENUMLOGFONTEXDVW,
// but we still need to be able to play records that contain EXTLOGFONT
// that may have been recorded on win9x or pre NT 5.0 system

    if (nSize <= sizeof(MREXTCREATEFONTINDIRECTW))
    {
    // the old type structure, contains only EXTLOGFONT or even only LOGFONTW

        pht->objectHandle[imhe] = CreateFontIndirectW((CONST LOGFONTW *) &elfw);
    }
    else
    {
    // this record contains ENUMLOGFONTEXDVW structure

        pht->objectHandle[imhe] = CreateFontIndirectExW((CONST ENUMLOGFONTEXDVW*) &elfw);
    }
    return(pht->objectHandle[imhe] != 0);
}



/******************************Public*Routine******************************\
* BOOL MRDELETEOBJECT::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 22 16:44:09 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRDELETEOBJECT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    BOOL  bRet;

    PUTS("MRDELETEOBJECT::bPlay\n");
    ASSERTGDI(iType == EMR_DELETEOBJECT, "Bad record type");

    USE(hdc);

// Our metafile driver never emits delete stock object records.
// Handle it anyway.

    if (STOCK_IMHE(d1))
    {
        ERROR_ASSERT(FALSE, "MRDELETEOBJECT::bPlay: Deleting a stock object");
        return(TRUE);                   // see DeleteObject
    }

// Make sure the handle is in the table.

    if (!VALID_IMHE(d1, cht))
        return(FALSE);

// Delete the object and remove it from the table.

    bRet = DeleteObject(pht->objectHandle[d1]);
    pht->objectHandle[d1] = 0;
    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MRANGLEARC::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Fri Sep 13 17:54:00 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRANGLEARC::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRANGLEARC::bPlay\n");
    ASSERTGDI(iType == EMR_ANGLEARC, "Bad record type");

    USE(pht);
    USE(cht);

    return(AngleArc(hdc, (int) eptl.x, (int) eptl.y, nRadius, eStartAngle, eSweepAngle));
}

/******************************Public*Routine******************************\
* BOOL MRELLIPSE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Fri Sep 13 17:54:00 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRELLIPSE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRELLIPSE::bPlay\n");
    ASSERTGDI(iType == EMR_ELLIPSE, "Bad record type");

    USE(pht);
    USE(cht);

// erclBox is inclusive-inclusive.  Make sure we have set the advanced
// graphics mode.

    ASSERTGDI
    (
        GetGraphicsMode(hdc) == GM_ADVANCED,
        "MR::bPlay: Not in advanced graphics mode"
    );

    return
    (
        Ellipse
        (
            hdc,
            (int) erclBox.left,
            (int) erclBox.top,
            (int) erclBox.right,
            (int) erclBox.bottom
        )
    );
}

/******************************Public*Routine******************************\
* BOOL MRRECTANGLE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Fri Sep 13 17:54:00 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRRECTANGLE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRRECTANGLE::bPlay\n");
    ASSERTGDI(iType == EMR_RECTANGLE, "Bad record type");

    USE(pht);
    USE(cht);

// erclBox is inclusive-inclusive.  Make sure we have set the advanced
// graphics mode.

    ASSERTGDI
    (
        GetGraphicsMode(hdc) == GM_ADVANCED,
        "MR::bPlay: Not in advanced graphics mode"
    );

    return
    (
        Rectangle
        (
            hdc,
            (int) erclBox.left,
            (int) erclBox.top,
            (int) erclBox.right,
            (int) erclBox.bottom
        )
    );
}

/******************************Public*Routine******************************\
* BOOL MRROUNDRECT::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Fri Sep 13 17:54:00 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRROUNDRECT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRROUNDRECT::bPlay\n");
    ASSERTGDI(iType == EMR_ROUNDRECT, "Bad record type");

    USE(pht);
    USE(cht);

// erclBox is inclusive-inclusive.  Make sure we have set the advanced
// graphics mode.

    ASSERTGDI
    (
        GetGraphicsMode(hdc) == GM_ADVANCED,
        "MR::bPlay: Not in advanced graphics mode"
    );

    return
    (
        RoundRect
        (
            hdc,
            (int) erclBox.left,
            (int) erclBox.top,
            (int) erclBox.right,
            (int) erclBox.bottom,
            (int) szlEllipse.cx,
            (int) szlEllipse.cy
        )
    );
}

/******************************Public*Routine******************************\
* BOOL MRARC::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Fri Sep 13 17:54:00 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRARC::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRARC::bPlay\n");
    ASSERTGDI(iType == EMR_ARC, "Bad record type");

    USE(pht);
    USE(cht);

// erclBox is inclusive-inclusive.  Make sure we have set the advanced
// graphics mode.

    ASSERTGDI
    (
        GetGraphicsMode(hdc) == GM_ADVANCED,
        "MR::bPlay: Not in advanced graphics mode"
    );

    return
    (
        Arc
        (
            hdc,
            (int) erclBox.left,
            (int) erclBox.top,
            (int) erclBox.right,
            (int) erclBox.bottom,
            (int) eptlStart.x,
            (int) eptlStart.y,
            (int) eptlEnd.x,
            (int) eptlEnd.y
        )
    );
}

/******************************Public*Routine******************************\
* BOOL MRARCTO::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Wed Oct 02 10:44:31 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRARCTO::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRARCTO::bPlay\n");
    ASSERTGDI(iType == EMR_ARCTO, "Bad record type");

    USE(pht);
    USE(cht);

// erclBox is inclusive-inclusive.  Make sure we have set the advanced
// graphics mode.

    ASSERTGDI
    (
        GetGraphicsMode(hdc) == GM_ADVANCED,
        "MR::bPlay: Not in advanced graphics mode"
    );

    return
    (
        ArcTo
        (
            hdc,
            (int) erclBox.left,
            (int) erclBox.top,
            (int) erclBox.right,
            (int) erclBox.bottom,
            (int) eptlStart.x,
            (int) eptlStart.y,
            (int) eptlEnd.x,
            (int) eptlEnd.y
        )
    );
}

/******************************Public*Routine******************************\
* BOOL MRCHORD::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Fri Sep 13 17:54:00 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRCHORD::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRCHORD::bPlay\n");
    ASSERTGDI(iType == EMR_CHORD, "Bad record type");

    USE(pht);
    USE(cht);

// erclBox is inclusive-inclusive.  Make sure we have set the advanced
// graphics mode.

    ASSERTGDI
    (
        GetGraphicsMode(hdc) == GM_ADVANCED,
        "MR::bPlay: Not in advanced graphics mode"
    );

    return
    (
        Chord
        (
            hdc,
            (int) erclBox.left,
            (int) erclBox.top,
            (int) erclBox.right,
            (int) erclBox.bottom,
            (int) eptlStart.x,
            (int) eptlStart.y,
            (int) eptlEnd.x,
            (int) eptlEnd.y
        )
    );
}

/******************************Public*Routine******************************\
* BOOL MRPIE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Fri Sep 13 17:54:00 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRPIE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRPIE::bPlay\n");
    ASSERTGDI(iType == EMR_PIE, "Bad record type");

    USE(pht);
    USE(cht);

// erclBox is inclusive-inclusive.  Make sure we have set the advanced
// graphics mode.

    ASSERTGDI
    (
        GetGraphicsMode(hdc) == GM_ADVANCED,
        "MR::bPlay: Not in advanced graphics mode"
    );

    return
    (
        Pie
        (
            hdc,
            (int) erclBox.left,
            (int) erclBox.top,
            (int) erclBox.right,
            (int) erclBox.bottom,
            (int) eptlStart.x,
            (int) eptlStart.y,
            (int) eptlEnd.x,
            (int) eptlEnd.y
        )
    );
}

/******************************Public*Routine******************************\
* BOOL MRSETPALETTEENTRIES::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Sun Sep 22 16:34:36 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETPALETTEENTRIES::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSETPALETTEENTRIES::bPlay\n");
    ASSERTGDI(iType == EMR_SETPALETTEENTRIES, "Bad record type");

    USE(hdc);

// Make sure the handle is in the table.

    if (!VALID_IMHE(imhe, cht))
        return(FALSE);

// If palette creation failed earlier, hpal is 0 and SetPaletteEntries
// will just return an error.

    return
    (
        SetPaletteEntries
        (
            (HPALETTE) pht->objectHandle[imhe],
            (UINT) iStart,
            (UINT) cEntries,
            aPalEntry
        )
        != 0
    );
}

/******************************Public*Routine******************************\
* BOOL MRRESIZEPALETTE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Sun Sep 22 16:34:36 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRRESIZEPALETTE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRRESIZEPALETTE::bPlay\n");
    ASSERTGDI(iType == EMR_RESIZEPALETTE, "Bad record type");

    USE(hdc);

// Make sure the handle is in the table.

    if (!VALID_IMHE(d1, cht))
        return(FALSE);

// If palette creation failed earlier, hpal is 0 and ResizePalette will
// just return an error.

    return(ResizePalette((HPALETTE) pht->objectHandle[d1], (UINT) d2));
}

/******************************Public*Routine******************************\
* BOOL MRREALIZEPALETTE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Mon Sep 23 17:41:46 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRREALIZEPALETTE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRREALIZEPALETTE::bPlay\n");
    ASSERTGDI(iType == EMR_REALIZEPALETTE, "Bad record type");

    USE(pht);
    USE(cht);

    return(RealizePalette(hdc) != -1);
}

/******************************Public*Routine******************************\
* BOOL MREXTFLOODFILL::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Fri Sep 13 17:54:00 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MREXTFLOODFILL::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    BOOL            bRet = FALSE;
    PMF             pmf;
    HRGN            hrgn = (HRGN) 0;
    POINTL          ptlRef;
    PENHMETAHEADER  pmrmf = NULL;

    PUTS("MREXTFLOODFILL::bPlay\n");
    ASSERTGDI(iType == EMR_EXTFLOODFILL, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

// Save the DC.

    if (!SaveDC(hdc))
        return(FALSE);

// We are going to use the picture frame to set up the clipping before
// flood fill.  This is to make sure that the fill will not flood beyond
// the picture.  We first convert the picture frame to the source device
// coordinates and set up the transform such that the source world to
// device transform is identity.  Then we intersect the picture
// frame using the IntersecClipRect function.  Note that the reference
// point is also converted to source device coordinates.

// Convert the reference point to the device units on the source device.

    ptlRef.x = eptl.x;
    ptlRef.y = eptl.y;
    if (!LPtoDP(pmf->hdcXform, (LPPOINT) &ptlRef, 1))
        goto mreff_exit;

// Reset source transform to identity.
// We simply set the total transform to the xformBase.

    if (!SetWorldTransform(hdc, &pmf->xformBase))
        goto mreff_exit;

// Compute the picture frame in the source device coordinates.

    RECTL   rclSrc;

    pmrmf = pmf->emfc.GetEMFHeader();

    rclSrc.left   = MulDiv((int) pmrmf->rclFrame.left,
                           (int) pmrmf->szlDevice.cx,
                           (int) (100 * pmrmf->szlMillimeters.cx));
    rclSrc.right  = MulDiv((int) pmrmf->rclFrame.right,
                           (int) pmrmf->szlDevice.cx,
                           (int) (100 * pmrmf->szlMillimeters.cx));
    rclSrc.top    = MulDiv((int) pmrmf->rclFrame.top,
                           (int) pmrmf->szlDevice.cy,
                           (int) (100 * pmrmf->szlMillimeters.cy));
    rclSrc.bottom = MulDiv((int) pmrmf->rclFrame.bottom,
                           (int) pmrmf->szlDevice.cy,
                           (int) (100 * pmrmf->szlMillimeters.cy));

// Intersect the clip region with the size of the picture bounds.

    if (IntersectClipRect(hdc,
                          (int) rclSrc.left,
                          (int) rclSrc.top,
                          (int) rclSrc.right + 1,
                          (int) rclSrc.bottom + 1)
        == ERROR)
        goto mreff_exit;

// Finally, do the flood fill.

    bRet = ExtFloodFill(hdc, (int) ptlRef.x, (int) ptlRef.y, clrRef, (UINT) iMode);

// Clean up.

mreff_exit:

    if (!RestoreDC(hdc, -1))
    {
        ASSERTGDI(FALSE, "MREXTFLOODFILL::bPlay: RestoreDC failed");
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MRBEGINPATH::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Oct 17 17:10:02 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRBEGINPATH::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRBEGINPATH::bPlay\n");
    ASSERTGDI(iType == EMR_BEGINPATH, "Bad record type");

    USE(pht);
    USE(cht);

    return(BeginPath(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRENDPATH::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Oct 17 17:10:02 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRENDPATH::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRENDPATH::bPlay\n");
    ASSERTGDI(iType == EMR_ENDPATH, "Bad record type");

    USE(pht);
    USE(cht);

    return(EndPath(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRCLOSEFIGURE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Oct 17 17:10:02 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRCLOSEFIGURE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRCLOSEFIGURE::bPlay\n");
    ASSERTGDI(iType == EMR_CLOSEFIGURE, "Bad record type");

    USE(pht);
    USE(cht);

    return(CloseFigure(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRFLATTENPATH::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Oct 17 17:10:02 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRFLATTENPATH::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRFLATTENPATH::bPlay\n");
    ASSERTGDI(iType == EMR_FLATTENPATH, "Bad record type");

    USE(pht);
    USE(cht);

    return(FlattenPath(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRWIDENPATH::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Oct 17 17:10:02 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRWIDENPATH::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRWIDENPATH::bPlay\n");
    ASSERTGDI(iType == EMR_WIDENPATH, "Bad record type");

    USE(pht);
    USE(cht);

    return(WidenPath(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRFILLPATH::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Oct 17 17:10:02 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRFILLPATH::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;

    PUTS("MRFILLPATH::bPlay\n");
    ASSERTGDI(iType == EMR_FILLPATH, "Bad record type");

    USE(pht);
    USE(cht);

    return(FillPath(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRSTROKEANDFILLPATH::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Oct 17 17:10:02 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSTROKEANDFILLPATH::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;

    PUTS("MRSTROKEANDFILLPATH::bPlay\n");
    ASSERTGDI(iType == EMR_STROKEANDFILLPATH, "Bad record type");

    USE(pht);
    USE(cht);

    return(StrokeAndFillPath(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRSTROKEPATH::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Oct 17 17:10:02 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSTROKEPATH::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;

    PUTS("MRSTROKEPATH::bPlay\n");
    ASSERTGDI(iType == EMR_STROKEPATH, "Bad record type");

    USE(pht);
    USE(cht);

    return(StrokePath(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRSELECTCLIPPATH::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Fri Oct 18 11:33:05 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSELECTCLIPPATH::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSELECTCLIPPATH::bPlay\n");
    ASSERTGDI(iType == EMR_SELECTCLIPPATH, "Bad record type");

    USE(pht);
    USE(cht);

// Since we have moved the initial destination clip region into the meta
// region (hrgnMeta), this function should not affect the initial clip region.

    return(SelectClipPath(hdc, (int) d1));
}

/******************************Public*Routine******************************\
* BOOL MRABORTPATH::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Oct 17 17:10:02 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRABORTPATH::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRABORTPATH::bPlay\n");
    ASSERTGDI(iType == EMR_ABORTPATH, "Bad record type");

    USE(pht);
    USE(cht);

// This call is recorded in place of PathToRegion in metafiles.
// See comments in PathToRegion for more information.

    return(AbortPath(hdc));
}

/******************************Public*Routine******************************\
* BOOL MRBITBLT::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Fri Nov 22 18:30:27 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRBITBLT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF     pmf;
    BOOL    bRet   = FALSE;
    HBITMAP hbmSrc = (HBITMAP) 0;
    HBITMAP hbmTmp = (HBITMAP) 0;
    HDC     hdcSrc = (HDC) 0;

    PUTS("MRBITBLT::bPlay\n");
    ASSERTGDI(iType == EMR_BITBLT, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

// Check bounds.

    if (pmf->bClipped(erclBounds))
        return(TRUE);

// Handle bitblt with no source DC.

    if (!ISSOURCEINROP3(rop))
        return
        (
            BitBlt
            (
                hdc,
                (int) xDst,
                (int) yDst,
                (int) cxDst,
                (int) cyDst,
                (HDC) 0,
                (int) xSrc,
                (int) ySrc,
                rop
            )
        );

// Handle bitblt with a source bitmap.
// Create a compatible source DC.

    if (!(hdcSrc = CreateCompatibleDCAdvanced(hdc)))
        goto mrbb_exit;

// Create the source bitmap.

    if (!(hbmSrc = CreateDIBitmap
                    (
                        hdcSrc,
                        (LPBITMAPINFOHEADER) ((PBYTE) this + offBitsInfoSrc),
                        CBM_INIT | CBM_CREATEDIB,
                        (LPBYTE) ((PBYTE) this + offBitsSrc),
                        (LPBITMAPINFO) ((PBYTE) this + offBitsInfoSrc),
                        (UINT) iUsageSrc
                    )
          )
       )
        goto mrbb_exit;

// Select the bitmap.

    if (!(hbmTmp = (HBITMAP)SelectObject(hdcSrc, hbmSrc)))
        goto mrbb_exit;

// Set up source DC transform and background color.

    if (!SetWorldTransform(hdcSrc, &xformSrc))
        goto mrbb_exit;

    if (SetBkColor(hdcSrc, clrBkSrc) == CLR_INVALID)
        goto mrbb_exit;

// Do the blt.

    bRet = BitBlt
           (
               hdc,
               (int) xDst,
               (int) yDst,
               (int) cxDst,
               (int) cyDst,
               hdcSrc,
               (int) xSrc,
               (int) ySrc,
               rop
           );

mrbb_exit:
    if (hbmTmp)
    {
        if (!SelectObject(hdcSrc, hbmTmp))
        {
            ASSERTGDI(FALSE, "MRBITBLT::bPlay: SelectObject failed");
        }
    }

    if (hbmSrc)
    {
        if (!DeleteObject(hbmSrc))
        {
            ASSERTGDI(FALSE, "MRBITBLT::bPlay: DeleteObject failed");
        }
    }

    if (hdcSrc)
    {
        if (!DeleteDC(hdcSrc))
        {
            ASSERTGDI(FALSE, "MRBITBLT::bPlay: DeleteDC failed");
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MRSTRETCHBLT::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Fri Nov 22 18:30:27 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSTRETCHBLT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF     pmf;
    BOOL    bRet   = FALSE;
    HBITMAP hbmSrc = (HBITMAP) 0;
    HBITMAP hbmTmp = (HBITMAP) 0;
    HDC     hdcSrc = (HDC) 0;

    PUTS("MRSTRETCHBLT::bPlay\n");
    ASSERTGDI(iType == EMR_STRETCHBLT, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

// Check bounds.

    if (pmf->bClipped(erclBounds))
        return(TRUE);

// Handle stretchblt with no source DC.

    if (!ISSOURCEINROP3(rop))
        return
        (
            StretchBlt
            (
                hdc,
                (int) xDst,
                (int) yDst,
                (int) cxDst,
                (int) cyDst,
                (HDC) 0,
                (int) xSrc,
                (int) ySrc,
                (int) cxSrc,
                (int) cySrc,
                rop
            )
        );

// Handle stretchblt with a source bitmap.
// Create a compatible source DC.

    if (!(hdcSrc = CreateCompatibleDCAdvanced(hdc)))
        goto mrsb_exit;

// Create the source bitmap.

    if (!(hbmSrc = CreateDIBitmap
                    (
                        hdcSrc,
                        (LPBITMAPINFOHEADER) ((PBYTE) this + offBitsInfoSrc),
                        CBM_INIT | CBM_CREATEDIB,
                        (LPBYTE) ((PBYTE) this + offBitsSrc),
                        (LPBITMAPINFO) ((PBYTE) this + offBitsInfoSrc),
                        (UINT) iUsageSrc
                    )
          )
       )
        goto mrsb_exit;

// Select the bitmap.

    if (!(hbmTmp = (HBITMAP)SelectObject(hdcSrc, hbmSrc)))
        goto mrsb_exit;

// Set up source DC transform and background color.

    if (!SetWorldTransform(hdcSrc, &xformSrc))
        goto mrsb_exit;

    if (SetBkColor(hdcSrc, clrBkSrc) == CLR_INVALID)
        goto mrsb_exit;

// Do the blt.

    bRet = StretchBlt
           (
               hdc,
               (int) xDst,
               (int) yDst,
               (int) cxDst,
               (int) cyDst,
               hdcSrc,
               (int) xSrc,
               (int) ySrc,
               (int) cxSrc,
               (int) cySrc,
               rop
           );

mrsb_exit:
    if (hbmTmp)
    {
        if (!SelectObject(hdcSrc, hbmTmp))
        {
            ASSERTGDI(FALSE, "MRSTRETCHBLT::bPlay: SelectObject failed");
        }
    }

    if (hbmSrc)
    {
        if (!DeleteObject(hbmSrc))
        {
            ASSERTGDI(FALSE, "MRSTRETCHBLT::bPlay: DeleteObject failed");
        }
    }

    if (hdcSrc)
    {
        if (!DeleteDC(hdcSrc))
        {
            ASSERTGDI(FALSE, "MRSTRETCHBLT::bPlay: DeleteDC failed");
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MRALPHABLEND::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*
*    12/3/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL MRALPHABLEND::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF     pmf;
    BOOL    bRet   = FALSE;
    HBITMAP hbmSrc = (HBITMAP) 0;
    HBITMAP hbmTmp = (HBITMAP) 0;
    HDC     hdcSrc = (HDC) 0;

    PUTS("MRALPHABLEND::bPlay\n");
    ASSERTGDI(iType == EMR_ALPHABLEND, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

// Check bounds.

    if (pmf->bClipped(erclBounds))
        return(TRUE);

// Create a compatible source DC.

    if (!(hdcSrc = CreateCompatibleDCAdvanced(hdc)))
        goto mrai_exit;

// Create the source bitmap.

    if (!(hbmSrc = CreateDIBitmap
                    (
                        hdcSrc,
                        (LPBITMAPINFOHEADER) ((PBYTE) this + offBitsInfoSrc),
                        CBM_INIT | CBM_CREATEDIB,
                        (LPBYTE) ((PBYTE) this + offBitsSrc),
                        (LPBITMAPINFO) ((PBYTE) this + offBitsInfoSrc),
                        (UINT) iUsageSrc
                    )
          )
       )
        goto mrai_exit;

// Select the bitmap.

    if (!(hbmTmp = (HBITMAP)SelectObject(hdcSrc, hbmSrc)))
        goto mrai_exit;

// Set up source DC transform and background color.

    if (!SetWorldTransform(hdcSrc, &xformSrc))
        goto mrai_exit;

    if (SetBkColor(hdcSrc, clrBkSrc) == CLR_INVALID)
        goto mrai_exit;

// Do the blt.

    BLENDULONG Blend;

    Blend.ul = rop;

    bRet = GdiAlphaBlend
           (
               hdc,
               (int) xDst,
               (int) yDst,
               (int) cxDst,
               (int) cyDst,
               hdcSrc,
               (int) xSrc,
               (int) ySrc,
               (int) cxSrc,
               (int) cySrc,
               Blend.Blend
           );

mrai_exit:
    if (hbmTmp)
    {
        if (!SelectObject(hdcSrc, hbmTmp))
        {
            ASSERTGDI(FALSE, "MRALPHABLEND::bPlay: SelectObject failed");
        }
    }

    if (hbmSrc)
    {
        if (!DeleteObject(hbmSrc))
        {
            ASSERTGDI(FALSE, "MRALPHABLEND::bPlay: DeleteObject failed");
        }
    }

    if (hdcSrc)
    {
        if (!DeleteDC(hdcSrc))
        {
            ASSERTGDI(FALSE, "MRALPHABLEND::bPlay: DeleteDC failed");
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MRTRANSPARENTIMAGE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*
*    12/3/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL MRTRANSPARENTBLT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF     pmf;
    BOOL    bRet   = FALSE;
    HBITMAP hbmSrc = (HBITMAP) 0;
    HBITMAP hbmTmp = (HBITMAP) 0;
    HDC     hdcSrc = (HDC) 0;

    PUTS("MRTRANSPARENTBLT::bPlay\n");
    ASSERTGDI(iType == EMR_TRANSPARENTBLT, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

// Check bounds.

    if (pmf->bClipped(erclBounds))
        return(TRUE);

// Create a compatible source DC.

    if (!(hdcSrc = CreateCompatibleDCAdvanced(hdc)))
        goto mrti_exit;

// Create the source bitmap.

    if (!(hbmSrc = CreateDIBitmap
                    (
                        hdcSrc,
                        (LPBITMAPINFOHEADER) ((PBYTE) this + offBitsInfoSrc),
                        CBM_INIT | CBM_CREATEDIB,
                        (LPBYTE) ((PBYTE) this + offBitsSrc),
                        (LPBITMAPINFO) ((PBYTE) this + offBitsInfoSrc),
                        (UINT) iUsageSrc
                    )
          )
       )
        goto mrti_exit;

// Select the bitmap.

    if (!(hbmTmp = (HBITMAP)SelectObject(hdcSrc, hbmSrc)))
        goto mrti_exit;

// Set up source DC transform and background color.

    if (!SetWorldTransform(hdcSrc, &xformSrc))
        goto mrti_exit;

    if (SetBkColor(hdcSrc, clrBkSrc) == CLR_INVALID)
        goto mrti_exit;

// Do the blt.

    bRet = GdiTransparentBlt
           (
               hdc,
               (int) xDst,
               (int) yDst,
               (int) cxDst,
               (int) cyDst,
               hdcSrc,
               (int) xSrc,
               (int) ySrc,
               (int) cxSrc,
               (int) cySrc,
               rop  //color
           );

mrti_exit:
    if (hbmTmp)
    {
        if (!SelectObject(hdcSrc, hbmTmp))
        {
            ASSERTGDI(FALSE, "MRSTRETCHBLT::bPlay: SelectObject failed");
        }
    }

    if (hbmSrc)
    {
        if (!DeleteObject(hbmSrc))
        {
            ASSERTGDI(FALSE, "MRSTRETCHBLT::bPlay: DeleteObject failed");
        }
    }

    if (hdcSrc)
    {
        if (!DeleteDC(hdcSrc))
        {
            ASSERTGDI(FALSE, "MRSTRETCHBLT::bPlay: DeleteDC failed");
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MRMASKBLT::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Fri Nov 22 18:30:27 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRMASKBLT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF     pmf;
    BOOL    bRet    = FALSE;
    HBITMAP hbmSrc  = (HBITMAP) 0;
    HBITMAP hbmTmp  = (HBITMAP) 0;
    HBITMAP hbmMask = (HBITMAP) 0;
    HDC     hdcSrc  = (HDC) 0;

    PUTS("MRMASKBLT::bPlay\n");
    ASSERTGDI(iType == EMR_MASKBLT, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

// Check bounds.

    if (pmf->bClipped(erclBounds))
        return(TRUE);

// Create the mask bitmap if it exists.

    if (cbBitsInfoMask)
        if (!(hbmMask = CreateMonoDib
                        (
                            (LPBITMAPINFO) ((PBYTE) this + offBitsInfoMask),
                            (CONST BYTE *) ((PBYTE) this + offBitsMask),
                            (UINT) iUsageMask
                        )
             )
           )
            return(FALSE);

// Create a compatible source DC.  This is needed even if the rop does not
// require a source.

    if (!(hdcSrc = CreateCompatibleDCAdvanced(hdc)))
        goto mrmb_exit;

// Set up source DC transform.

    if (!SetWorldTransform(hdcSrc, &xformSrc))
        goto mrmb_exit;

// Handle maskblt with no source bitmap.

    if (!ISSOURCEINROP3(rop))
    {
        bRet = MaskBlt
                (
                    hdc,
                    (int) xDst,
                    (int) yDst,
                    (int) cxDst,
                    (int) cyDst,
                    (HDC) hdcSrc,
                    (int) xSrc,
                    (int) ySrc,
                    hbmMask,
                    (int) xMask,
                    (int) yMask,
                    rop
                );
        goto mrmb_exit;
    }

// Handle maskblt with a source bitmap.
// Create the source bitmap.

    if (!(hbmSrc = CreateDIBitmap
                    (
                        hdcSrc,
                        (LPBITMAPINFOHEADER) ((PBYTE) this + offBitsInfoSrc),
                        CBM_INIT | CBM_CREATEDIB,
                        (LPBYTE) ((PBYTE) this + offBitsSrc),
                        (LPBITMAPINFO) ((PBYTE) this + offBitsInfoSrc),
                        (UINT) iUsageSrc
                    )
          )
       )
        goto mrmb_exit;

// Select the bitmap.

    if (!(hbmTmp = (HBITMAP)SelectObject(hdcSrc, hbmSrc)))
        goto mrmb_exit;

// Set up source DC background color.

    if (SetBkColor(hdcSrc, clrBkSrc) == CLR_INVALID)
        goto mrmb_exit;

// Do the blt.

    bRet = MaskBlt
           (
               hdc,
               (int) xDst,
               (int) yDst,
               (int) cxDst,
               (int) cyDst,
               hdcSrc,
               (int) xSrc,
               (int) ySrc,
               hbmMask,
               (int) xMask,
               (int) yMask,
               rop
           );

mrmb_exit:
    if (hbmTmp)
    {
        if (!SelectObject(hdcSrc, hbmTmp))
        {
            ASSERTGDI(FALSE, "MRMASKBLT::bPlay: SelectObject failed");
        }
    }

    if (hbmSrc)
    {
        if (!DeleteObject(hbmSrc))
        {
            ASSERTGDI(FALSE, "MRMASKBLT::bPlay: DeleteObject failed");
        }
    }

    if (hdcSrc)
    {
        if (!DeleteDC(hdcSrc))
        {
            ASSERTGDI(FALSE, "MRMASKBLT::bPlay: DeleteDC failed");
        }
    }

    if (hbmMask)
    {
        if (!DeleteObject(hbmMask))
        {
            ASSERTGDI(FALSE, "MRMASKBLT::bPlay: DeleteObject failed");
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MRPLGBLT::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Fri Nov 22 18:30:27 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRPLGBLT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF     pmf;
    BOOL    bRet    = FALSE;
    HBITMAP hbmSrc  = (HBITMAP) 0;
    HBITMAP hbmTmp  = (HBITMAP) 0;
    HBITMAP hbmMask = (HBITMAP) 0;
    HDC     hdcSrc  = (HDC) 0;

    PUTS("MRPLGBLT::bPlay\n");
    ASSERTGDI(iType == EMR_PLGBLT, "Bad record type");

    USE(cht);

// There must be a source DC in this call

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

// Check bounds.

    if (pmf->bClipped(erclBounds))
        return(TRUE);

// Create the mask bitmap if it exists.

    if (cbBitsInfoMask)
        if (!(hbmMask = CreateMonoDib
                        (
                            (LPBITMAPINFO) ((PBYTE) this + offBitsInfoMask),
                            (CONST BYTE *) ((PBYTE) this + offBitsMask),
                            (UINT) iUsageMask
                        )
             )
           )
            return(FALSE);

// Handle plgblt with a source bitmap.
// Create a compatible source DC.

    if (!(hdcSrc = CreateCompatibleDCAdvanced(hdc)))
        goto mrpb_exit;

// Create the source bitmap.

    if (!(hbmSrc = CreateDIBitmap
                    (
                        hdcSrc,
                        (LPBITMAPINFOHEADER) ((PBYTE) this + offBitsInfoSrc),
                        CBM_INIT | CBM_CREATEDIB,
                        (LPBYTE) ((PBYTE) this + offBitsSrc),
                        (LPBITMAPINFO) ((PBYTE) this + offBitsInfoSrc),
                        (UINT) iUsageSrc
                    )
          )
       )
        goto mrpb_exit;

// Select the bitmap.

    if (!(hbmTmp = (HBITMAP)SelectObject(hdcSrc, hbmSrc)))
        goto mrpb_exit;

// Set up source DC transform and background color.

    if (!SetWorldTransform(hdcSrc, &xformSrc))
        goto mrpb_exit;

    if (SetBkColor(hdcSrc, clrBkSrc) == CLR_INVALID)
        goto mrpb_exit;

// Do the blt.

    bRet = PlgBlt
           (
               hdc,
               (LPPOINT) aptlDst,
               hdcSrc,
               (int) xSrc,
               (int) ySrc,
               (int) cxSrc,
               (int) cySrc,
               hbmMask,
               (int) xMask,
               (int) yMask
           );

mrpb_exit:
    if (hbmTmp)
    {
        if (!SelectObject(hdcSrc, hbmTmp))
        {
            ASSERTGDI(FALSE, "MRPLGBLT::bPlay: SelectObject failed");
        }
    }

    if (hbmSrc)
    {
        if (!DeleteObject(hbmSrc))
        {
            ASSERTGDI(FALSE, "MRPLGBLT::bPlay: DeleteObject failed");
        }
    }

    if (hdcSrc)
    {
        if (!DeleteDC(hdcSrc))
        {
            ASSERTGDI(FALSE, "MRPLGBLT::bPlay: DeleteDC failed");
        }
    }

    if (hbmMask)
    {
        if (!DeleteObject(hbmMask))
        {
            ASSERTGDI(FALSE, "MRPLGBLT::bPlay: DeleteObject failed");
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MRSETDIBITSTODEVICE::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Fri Nov 22 18:30:27 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETDIBITSTODEVICE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF   pmf;
    BOOL  bRet = FALSE;
    POINT ptDst;
    PBMI  pBitsInfoDib;

    PUTS("MRSETDIBITSTODEVICE::bPlay\n");
    ASSERTGDI(iType == EMR_SETDIBITSTODEVICE, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

// Check bounds.

    if (pmf->bClipped(erclBounds))
        return(TRUE);

// Do the simple case where xformBase is identity
// Since there may be a non identity xformBase, we cannot simply
// call SetDIBitsToDevice directly.  Instead, we will convert it to a
// StretchDIBits call.  There is one catch here: in SetDIBitsToDevice,
// the destination width and height are in device units but in StretchDIBits,
// they are in world units.  We have to replace the original transform
// in the metafile with a identity transform before calling StretchDIBits.

// Convert the destination origin to the device units on the original device.

    ptDst.x = (long) xDst;
    ptDst.y = (long) yDst;
    if (!LPtoDP(pmf->hdcXform, &ptDst, 1))
        return(FALSE);

// Reset original destination transform to identity.
// We simply set the total transform to the xformBase.

    if (!SetWorldTransform(hdc, &pmf->xformBase))
        return(FALSE);

// Since StretchDIBits takes a full dib, we have to adjust the source dib info.

    if (!(pBitsInfoDib = (PBMI) LocalAlloc(LMEM_FIXED, (UINT) cbBitsInfoDib)))
        goto mrsdb_exit;

    RtlCopyMemory((PBYTE) pBitsInfoDib, (PBYTE) this + offBitsInfoDib, cbBitsInfoDib);

    if (pBitsInfoDib->bmiHeader.biHeight > 0)
    {
        pBitsInfoDib->bmiHeader.biHeight    = cScans;
    }
    else
    {
        // top-down
        pBitsInfoDib->bmiHeader.biHeight    = cScans;
        pBitsInfoDib->bmiHeader.biHeight = -pBitsInfoDib->bmiHeader.biHeight;

    }
    pBitsInfoDib->bmiHeader.biSizeImage = cbBitsDib;

// Do the blt.

    bRet = StretchDIBits
           (
               hdc,
               (int) ptDst.x,
               (int) ptDst.y,
               (int) cxDib,
               (int) cyDib,
               (int) xDib,
               (int) yDib - (int) iStartScan,
               (int) cxDib,
               (int) cyDib,
               cbBitsDib
                   ? (LPBYTE) ((PBYTE) this + offBitsDib)
                   : (LPBYTE) NULL,
               pBitsInfoDib,
               (UINT) iUsageDib,
               SRCCOPY
           ) != 0;

    if (LocalFree(pBitsInfoDib))
    {
        ASSERTGDI(FALSE, "MRSETDIBITSTODEVICE::bPlay: LocalFree failed");
    }

mrsdb_exit:
// Restore current transform.

    if (!pmf->bSetTransform(hdc))
    {
        WARNING("MRSETDIBITSTODEVICE::bPlay: Restore xform failed");
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MRSTRETCHDIBITS::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Fri Nov 22 18:30:27 1991     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSTRETCHDIBITS::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PMF     pmf;

    PUTS("MRSTRETCHDIBITS::bPlay\n");
    ASSERTGDI(iType == EMR_STRETCHDIBITS, "Bad record type");

    USE(cht);

// Get metafile.

    if (!(pmf = GET_PMF((HENHMETAFILE)pht->objectHandle[0])))
        return(FALSE);

// Check bounds.

    if (pmf->bClipped(erclBounds))
        return(TRUE);

// Do the blt.

    return
    (
        StretchDIBits
        (
            hdc,
            (int) xDst,
            (int) yDst,
            (int) cxDst,
            (int) cyDst,
            (int) xDib,
            (int) yDib,
            (int) cxDib,
            (int) cyDib,
            cbBitsDib
                ? (LPBYTE) ((PBYTE) this + offBitsDib)
                : (LPBYTE) NULL,
            cbBitsInfoDib
                ? (LPBITMAPINFO) ((PBYTE) this + offBitsInfoDib)
                : (LPBITMAPINFO) NULL,
            (UINT) iUsageDib,
            rop
        ) != 0
    );
}

/******************************Public*Routine******************************\
* BOOL MREXTTEXTOUT::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 24 15:20:33 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MREXTTEXTOUT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    BOOL  bRet;

    PUTS("MREXTTEXTOUT::bPlay\n");
    ASSERTGDI(iType == EMR_EXTTEXTOUTA || iType == EMR_EXTTEXTOUTW,
        "Bad record type");

    USE(pht);
    USE(cht);

// Set the graphics mode if necessary.
// The metafile playback is always in the advanced graphics mode.

    if (iGraphicsMode != GM_ADVANCED)
    {
        if (!SetGraphicsMode(hdc, iGraphicsMode))
            return(FALSE);
        if (!SetFontXform(hdc, exScale, eyScale))
            return(FALSE);
    }

    if (iType == EMR_EXTTEXTOUTA)
        bRet = ExtTextOutA
                (
                    hdc,
                    (int) mtext.eptlRef.x,
                    (int) mtext.eptlRef.y,
                    (UINT) mtext.fOptions,
                    (LPRECT) &mtext.ercl,
                    (LPSTR) ((PBYTE) this + mtext.offString),
                    (int) mtext.cchString,
                    (LPINT) (mtext.offaDx ? ((PBYTE) this + mtext.offaDx) : 0)
                );
    else
        bRet = ExtTextOutW
                (
                    hdc,
                    (int) mtext.eptlRef.x,
                    (int) mtext.eptlRef.y,
                    (UINT) mtext.fOptions,
                    (LPRECT) &mtext.ercl,
                    (LPWSTR) ((PBYTE) this + mtext.offString),
                    (int) mtext.cchString,
                    (LPINT) (mtext.offaDx ? ((PBYTE) this + mtext.offaDx) : 0)
                );

// Restore the graphics mode.

    if (iGraphicsMode != GM_ADVANCED)
    {
        if (!SetGraphicsMode(hdc, GM_ADVANCED))
            return(FALSE);
        if (!SetFontXform(hdc, 0.0f, 0.0f))
            return(FALSE);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MRPOLYTEXTOUT::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Thu Aug 24 15:20:33 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRPOLYTEXTOUT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    POLYTEXTA * ppta;
    BOOL        bRet = FALSE;
    LONG        i;

    PUTS("MRPOLYTEXTOUT::bPlay\n");
    ASSERTGDI(iType == EMR_POLYTEXTOUTA || iType == EMR_POLYTEXTOUTW,
        "Bad record type");

    USE(pht);
    USE(cht);

// Set the graphics mode if necessary.
// The metafile playback is always in the advanced graphics mode.

    if (iGraphicsMode != GM_ADVANCED)
    {
        if (!SetGraphicsMode(hdc, (int) iGraphicsMode))
            return(FALSE);
        if (!SetFontXform(hdc, exScale, eyScale))
            return(FALSE);
    }

// Allocate a POLYTEXTA array.

    if (!(ppta = (POLYTEXTA *) LocalAlloc(LMEM_FIXED, (UINT) cmtext * sizeof(POLYTEXTA))))
        goto mpto_exit;

// Copy the POLYTEXTA array.

    ASSERTGDI(sizeof(MTEXT) == sizeof(POLYTEXTA)
           && offsetof(MTEXT,eptlRef.x) == offsetof(POLYTEXTA,x)
           && offsetof(MTEXT,eptlRef.y) == offsetof(POLYTEXTA,y)
           && offsetof(MTEXT,cchString) == offsetof(POLYTEXTA,n)
           && offsetof(MTEXT,offString) == offsetof(POLYTEXTA,lpstr)
           && offsetof(MTEXT,fOptions)  == offsetof(POLYTEXTA,uiFlags)
           && offsetof(MTEXT,ercl)      == offsetof(POLYTEXTA,rcl)
           && offsetof(MTEXT,offaDx)    == offsetof(POLYTEXTA,pdx),
        "MRPOLYTEXTOUT::bPlay: structures different");

    RtlCopyMemory((PBYTE) ppta, (PBYTE) &amtext[0], cmtext * sizeof(POLYTEXTA));

// Update the pointers.

    for (i = 0; i < cmtext; i++)
    {
        ppta[i].lpstr = (PCSTR) ((PBYTE) this + amtext[i].offString);
        ppta[i].pdx   = (int *) ((PBYTE) this + amtext[i].offaDx);
    }

// Make the call.

    if (iType == EMR_POLYTEXTOUTA)
        bRet = PolyTextOutA(hdc, ppta, (int) cmtext);
    else
        bRet = PolyTextOutW(hdc, (POLYTEXTW *) ppta, (int) cmtext);

    if (LocalFree((HANDLE) ppta))
    {
        ASSERTGDI(FALSE, "MRPOLYTEXTOUT::bPlay: LocalFree failed");
    }

mpto_exit:

// Restore the graphics mode.

    if (iGraphicsMode != GM_ADVANCED)
    {
        if (!SetGraphicsMode(hdc, GM_ADVANCED))
            return(FALSE);
        if (!SetFontXform(hdc, 0.0f, 0.0f))
            return(FALSE);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MRSETCOLORADJUSTMENT::bPlay(hdc, pht, cht)
*
* Play the metafile record.
*
* History:
*  Tue Oct 27 09:59:28 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL MRSETCOLORADJUSTMENT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSETCOLORADJUSTMENT::bPlay\n");
    ASSERTGDI(iType == EMR_SETCOLORADJUSTMENT, "Bad record type");

    USE(pht);
    USE(cht);
    return(SetColorAdjustment(hdc, &ColorAdjustment));
}


BOOL MRESCAPE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    switch( iType )
    {
    case EMR_DRAWESCAPE:
//        MFD2("Playing Meta DrawEscape %d\n", iEscape);
        DrawEscape( hdc, iEscape, cjIn, (const char*) ((PBYTE) this + sizeof(MRESCAPE)) );
        break;
    case EMR_EXTESCAPE:
//        MFD2("Playing Meta ExtEscape %d\n", iEscape);

        ExtEscape( hdc, iEscape, cjIn,
                   (const char*) ((PBYTE) this + sizeof(MRESCAPE)), 0,
                   (LPSTR) NULL );
        break;
    default:
        ASSERTGDI((FALSE), "MRESCAPE::bPlay invalid type\n");
        break;
    }

    USE(pht);
    USE(cht);
    return(TRUE);
}


BOOL MRNAMEDESCAPE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{

    NamedEscape(hdc,
                (LPWSTR) ((PBYTE) this + sizeof(MRNAMEDESCAPE)),
                iEscape,
                 cjIn,
                (const char*) (PBYTE) this + sizeof(MRNAMEDESCAPE) + cjDriver,
                0,
                NULL);

    USE(pht);
    USE(cht);
    return(TRUE);
}


BOOL MRSTARTDOC::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PBYTE pj = (PBYTE) this+sizeof(MRSTARTDOC);
    ASSERTGDI(iType == EMR_STARTDOC, "Bad record type");
    DOCINFOW doi1;

// nothing for now


    USE(pht);
    USE(cht);

    *(&doi1) = *(&doi);

    if( doi1.lpszDocName != NULL )
    {
        doi1.lpszDocName = (LPWSTR) pj;
        pj += ((lstrlenW( (LPWSTR) pj )+1) * sizeof(WCHAR) + 4) & ~(0x3);
    }

    if( doi1.lpszOutput != NULL )
    {
        doi1.lpszOutput = (LPWSTR) pj;
    }

    MFD3("Playing StartDocA %s %s\n", doi1.lpszDocName, doi1.lpszOutput);

    return( StartDocW( hdc, &doi1 ) );
}


#define QUICK_BUF_SIZE  120

BOOL MRSMALLTEXTOUT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    RECT *pRect = NULL;
    BYTE *pjThis = (PBYTE) this + sizeof(MRSMALLTEXTOUT);
    WCHAR wcQuickBuf[QUICK_BUF_SIZE],*pwc;
    BOOL bRet;

    if (iGraphicsMode != GM_ADVANCED)
    {
        if (!SetGraphicsMode(hdc, iGraphicsMode))
          return(FALSE);
         if (!SetFontXform(hdc, exScale, eyScale))
           return(FALSE);
    }

    if( !(fuOptions & ETO_NO_RECT) )
    {
        pRect = (RECT*) pjThis;
        pjThis += sizeof(RECT);
    }

    if( fuOptions & ETO_SMALL_CHARS )
    {
        INT c;
        WCHAR *pwc1;


        if( cChars > QUICK_BUF_SIZE )
        {
            pwc = (WCHAR*) LocalAlloc( LMEM_FIXED, sizeof(WCHAR) * cChars );

            if( pwc == NULL )
            {
                WARNING("MRSMALLTEXTOUT::bPlay -- out of memory\n" );
                return(FALSE);
            }
        }
        else
        {
            pwc = wcQuickBuf;
        }

        for( pwc1 = pwc, c = cChars; c > 0 ; c-- )
        {
            *pwc1++ = (WCHAR) *pjThis++;
        }
    }
    else
    {
        pwc = (WCHAR*) pjThis;
    }

    bRet = ExtTextOutW( hdc,
                        x,
                        y,
                        fuOptions & ~(ETO_NO_RECT|ETO_SMALL_CHARS),
                        pRect,
                        pwc,
                        cChars,
                        NULL );

    if( (pwc != wcQuickBuf ) && ( pwc != (WCHAR*) pjThis ) )
    {
        LocalFree( pwc );
    }

    if(iGraphicsMode != GM_ADVANCED)
    {

        if (!SetGraphicsMode(hdc, GM_ADVANCED))
          return(FALSE);

        if (!SetFontXform(hdc, 0.0f, 0.0f))
          return(FALSE);
    }

    return(bRet);

}


BOOL MRFORCEUFIMAPPING::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    ASSERTGDI(iType == EMR_FORCEUFIMAPPING, "Bad record type");

// nothing for now

    USE(pht);
    USE(cht);

    MFD1("Playing ForceUFIMapping\n");

    return NtGdiForceUFIMapping(hdc, &ufi);
}


BOOL MRSETLINKEDUFIS::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    ASSERTGDI(iType == EMR_SETLINKEDUFIS, "Bad record type");

// nothing for now

    USE(pht);
    USE(cht);

    MFD1("Playing SetLinkedUFIs\n");

    return(NtGdiSetLinkedUFIs(hdc, pufiList, uNumLinkedUFIs));
}

/******************************Public*Routine******************************\
*
* MRGLSRECORD::bPlay(hdc, pht, cht)
*
* Play the metafile record
*
* History:
*  Thu Feb 23 14:41:41 1995     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/


BOOL MRGLSRECORD::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRGLSRECORD::bPlay\n");
    ASSERTGDI(iType == EMR_GLSRECORD, "Bad record type");

    USE(pht);
    USE(cht);

    return GlmfPlayGlsRecord(hdc, cb, abRecord, NULL);
}

/******************************Public*Routine******************************\
*
* MRGLSBOUNDEDRECORD::bPlay(hdc, pht, cht)
*
* Play the metafile record
*
* History:
*  Thu Feb 23 14:41:41 1995     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/


BOOL MRGLSBOUNDEDRECORD::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRGLSBOUNDEDRECORD::bPlay\n");
    ASSERTGDI(iType == EMR_GLSBOUNDEDRECORD, "Bad record type");

    USE(pht);
    USE(cht);

    return GlmfPlayGlsRecord(hdc, cb, abRecord, &rclBounds);
}


/******************************Public*Routine******************************\
*
* MRPIXELFORMAT::bPlay(hdc, pht, cht)
*
* Play the metafile record
*
* History:
*  Mon Mar 27 14:41:41 1995     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/


BOOL MRPIXELFORMAT::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    int iPixelFormat;

    PUTS("MRPIXELFORMAT::bPlay\n");
    ASSERTGDI(iType == EMR_PIXELFORMAT, "Bad record type");

    USE(pht);
    USE(cht);

    iPixelFormat = ChoosePixelFormat(hdc, &pfd);
    if (iPixelFormat == 0)
    {
        return FALSE;
    }
    else
    {
        // Ignore errors from this call because the metafile player
        // may have already set up a pixel format and it can't
        // be set twice
        //
        // The check alone isn't sufficient because of race conditions,
        // it just cuts down on debug messages from OpenGL warning
        // about duplicate sets
        if (GetPixelFormat(hdc) == 0)
        {
            SetPixelFormat(hdc, iPixelFormat, &pfd);
        }

        return TRUE;
    }
}


/******************************Public*Routine******************************\
*
* MRSETICMPROFILE::bPlay(hdc, pht, cht)
*
* Play the metafile record
*
* History:
*  Wed May 07 17:38:00 1997     -by-    Hideyuki Nagase [hideyukn]
*   Created
*
\**************************************************************************/

BOOL MRSETICMPROFILE::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSETICMPROFILE::bPlay\n");

    ASSERTGDI((iType == EMR_SETICMPROFILEA) || (iType == EMR_SETICMPROFILEW),
              "Bad record type");

    USE(pht);
    USE(cht);

    BOOL bRet = FALSE;

    PCACHED_COLORSPACE pCachedColorSpace;

    if (dwFlags & SETICMPROFILE_EMBEDED)
    {
        LOGCOLORSPACEW LogColorSpaceW;
        PROFILE        Profile;

        //
        // ICC Profile is attched into Metafile,
        //
        RtlZeroMemory(&LogColorSpaceW,sizeof(LOGCOLORSPACEW));

        //
        // Build fake LOGCOLORSPACEW for this color space.
        //
        LogColorSpaceW.lcsSignature = LCS_SIGNATURE;
        LogColorSpaceW.lcsVersion   = 0x400;
        LogColorSpaceW.lcsSize      = sizeof(LOGCOLORSPACEW);
        LogColorSpaceW.lcsCSType    = LCS_CALIBRATED_RGB;
        LogColorSpaceW.lcsIntent    = LCS_DEFAULT_INTENT;

        if (iType == EMR_SETICMPROFILEW)
        {
            //
            // Copy desired filename in Unicode.
            //
            BuildIcmProfilePath((WCHAR *)Data,LogColorSpaceW.lcsFilename,MAX_PATH);
        }
        else
        {
            WCHAR TempFile[MAX_PATH];

            //
            // Data is ansi based string, Convert the string to Unicode.
            //
            vToUnicodeN(TempFile,MAX_PATH,(char *)Data,strlen((char *)Data)+1);

            //
            // Copy desired filename in Unicode.
            //
            BuildIcmProfilePath(TempFile,LogColorSpaceW.lcsFilename,MAX_PATH);
        }

        //
        // Make PROFILE structure pointing color profile in metafile.
        //
        Profile.dwType = PROFILE_MEMBUFFER;
        Profile.pProfileData = Data+cbName;
        Profile.cbDataSize = cbData;

        //
        // Search this color space from cache.
        //
        pCachedColorSpace = IcmGetColorSpaceByColorSpace(
                                hdc, &LogColorSpaceW, &Profile,
                                (METAFILE_COLORSPACE | ON_MEMORY_PROFILE));

        if (pCachedColorSpace == NULL)
        {
            pCachedColorSpace = IcmCreateColorSpaceByColorSpace(
                                    hdc, &LogColorSpaceW, &Profile,
                                    (METAFILE_COLORSPACE | ON_MEMORY_PROFILE));
        }

        if (pCachedColorSpace)
        {
            bRet = SetICMProfileInternalW(hdc,NULL,pCachedColorSpace,0);

            // - if bRet is TRUE.
            //
            // SetICMProfileInternal increments ref. count of colorspace.
            // but we have done it by Icm[Get|Create]ColorSpaceByName, so
            // decrement ref count of color space here.
            //
            // - if bRet is FALSE.
            //
            // we failed to select to this color space to target, so we should
            // decrement ref count which done by Icm[Get|Create]ColorSpace
            //
            IcmReleaseColorSpace(NULL,pCachedColorSpace,FALSE);
        }
    }
    else
    {
        //
        // The record only has profile filename in Data.
        //
        if (iType == EMR_SETICMPROFILEA)
        {
            bRet = SetICMProfileInternalA(hdc,(LPSTR)Data,NULL,METAFILE_COLORSPACE);
        }
        else
        {
            bRet = SetICMProfileInternalW(hdc,(LPWSTR)Data,NULL,METAFILE_COLORSPACE);
        }
    }

    return bRet;
}


/******************************Public*Routine******************************\
*
* MRCOLORMATCHTOTARGET::bPlay(hdc, pht, cht)
*
* Play the metafile record
*
* History:
*  Wed Jun 23 12:00:00 1998     -by-    Hideyuki Nagase [hideyukn]
*   Created
*
\**************************************************************************/

BOOL MRCOLORMATCHTOTARGET::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRCOLORMATCHTOTARGET::bPlay\n");

    ASSERTGDI(iType == EMR_COLORMATCHTOTARGETW,"Bad record type");

    USE(pht);
    USE(cht);

    BOOL bRet = TRUE;

    if (dwAction == CS_ENABLE)
    {
        PCACHED_COLORSPACE pCachedColorSpace;

        if (dwFlags & COLORMATCHTOTARGET_EMBEDED)
        {
            LOGCOLORSPACEW LogColorSpaceW;
            PROFILE        Profile;

            //
            // ICC Profile is attched into Metafile,
            //
            RtlZeroMemory(&LogColorSpaceW,sizeof(LOGCOLORSPACEW));

            //
            // Build fake LOGCOLORSPACEW for this color space.
            //
            LogColorSpaceW.lcsSignature = LCS_SIGNATURE;
            LogColorSpaceW.lcsVersion   = 0x400;
            LogColorSpaceW.lcsSize      = sizeof(LOGCOLORSPACEW);
            LogColorSpaceW.lcsCSType    = LCS_CALIBRATED_RGB;
            LogColorSpaceW.lcsIntent    = LCS_DEFAULT_INTENT;

            //
            // Copy desired filename in Unicode.
            //
            BuildIcmProfilePath((WCHAR *)Data,LogColorSpaceW.lcsFilename,MAX_PATH);

            //
            // Make PROFILE structure pointing color profile in metafile.
            //
            Profile.dwType = PROFILE_MEMBUFFER;
            Profile.pProfileData = Data+cbName;
            Profile.cbDataSize = cbData;

            //
            // Search this color space from cache.
            //
            pCachedColorSpace = IcmGetColorSpaceByColorSpace(
                                    hdc, &LogColorSpaceW, &Profile,
                                    (METAFILE_COLORSPACE | ON_MEMORY_PROFILE));

            if (pCachedColorSpace == NULL)
            {
                pCachedColorSpace = IcmCreateColorSpaceByColorSpace(
                                        hdc, &LogColorSpaceW, &Profile,
                                        (METAFILE_COLORSPACE | ON_MEMORY_PROFILE));
            }
        }
        else
        {
            //
            // The record only has profile filename in Data.
            //
            pCachedColorSpace = IcmGetColorSpaceByName(
                                    hdc,(LPWSTR)Data,
                                    LCS_DEFAULT_INTENT,
                                    METAFILE_COLORSPACE);

            if (pCachedColorSpace == NULL)
            {
                pCachedColorSpace = IcmCreateColorSpaceByName(
                                        hdc,(LPWSTR)Data,
                                        LCS_DEFAULT_INTENT,
                                        METAFILE_COLORSPACE);
            }
        }

        if (pCachedColorSpace)
        {
            bRet = ColorMatchToTargetInternal(hdc,pCachedColorSpace,dwAction);

            // - if bRet is TRUE.
            //
            // ColorMatchToTargetInternal increments ref. count of colorspace.
            // but we have done it by Icm[Get|Create]ColorSpaceByName, so
            // decrement ref count of color space here.
            //
            // - if bRet is FALSE.
            //
            // we failed to select to this color space to target, so we should
            // decrement ref count which done by Icm[Get|Create]ColorSpace
            //
            IcmReleaseColorSpace(NULL,pCachedColorSpace,FALSE);
        }
    }
    else
    {
        //
        // Reset Target color space
        //
        bRet = ColorMatchToTargetInternal(hdc,NULL,dwAction);
    }

    return bRet;
}

/******************************Public*Routine******************************\
*
* MRCREATECOLORSPACEW::bPlay(hdc, pht, cht)
*
* Play the metafile record
*
* History:
*  Wed Jun 23 12:00:00 1998     -by-    Hideyuki Nagase [hideyukn]
*   Created
*
\**************************************************************************/

BOOL MRCREATECOLORSPACEW::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRCREATECOLORSPACEW::bPlay\n");

    ASSERTGDI(iType == EMR_CREATECOLORSPACEW, "Bad record type");

    USE(hdc);

// Make sure the handle is in the table.

    if (!VALID_IMHE(imhe, cht))
        return(FALSE);

    pht->objectHandle[imhe] = CreateColorSpaceW(&lcsp);
    return(pht->objectHandle[imhe] != 0);
}

/****************************Public*Routine**************************\
*
* MRSETTEXTJUSTIFICATION::bPlay(hdc, pht, cht)
*
* Play the metafile record of SetTextJustification
*
* History:
*  07-May-1997  -by-    Xudong Wu [Tessiew]
* Wrote it.
\*********************************************************************/

BOOL MRSETTEXTJUSTIFICATION::bPlay(HDC hdc, PHANDLETABLE pht, UINT cht)
{
    PUTS("MRSETTEXTJUSTIFICATION::bPlay\n");
    ASSERTGDI(iType == EMR_SETTEXTJUSTIFICATION, "MRSETTEXTJUSTIFICATION Bad record type\n");

    USE(pht);
    USE(cht);

    return (SetTextJustification(hdc, (int)d1, (int)d2));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\mfplay16.c ===
/****************************** Module Header ******************************\
* Module Name: MfPlay16.c
*
* This file contains the routines for playing the GDI metafile.  Most of these
* routines are adopted from windows gdi code. Most of the code is from
* win3.0 except for the GetEvent code which is taken from win2.1
*
* Created: 11-Oct-1989
*
* Copyright (c) 1985-1999  Microsoft Corporation
*
*
* Public Functions:
*   PlayMetaFile
*   PlayMetaFileRecord
*   GetMetaFile
*   DeleteMetaFile
* Private Functions:
*   GetEvent
*   IsDIBBlackAndWhite
*
* History:
*  02-Jul-1991 -by-  John Colleran [johnc]
* Combined From Win 3.1 and WLO 1.0 sources
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "mf16.h"


BOOL    AddToHandleTable(LPHANDLETABLE lpHandleTable, HANDLE hObject, UINT noObjs);
BOOL    CommonEnumMetaFile(HDC hdc, HMETAFILE hmf, MFENUMPROC proc, LPARAM lpData);
HANDLE  CreateBitmapForDC (HDC hMemDC, LPBITMAPINFOHEADER lpDIBInfo);
WORD    GetSizeOfColorTable (LPBITMAPINFOHEADER lpDIBInfo);
BOOL    IsDIBBlackAndWhite(LPBITMAPINFOHEADER lpDIBInfo);
BOOL    PlayIntoAMetafile(LPMETARECORD lpMR, HDC hdcDest);

 #if DBG
UINT    curRecord;      // debuging helpers
UINT    iBreakRecord = 0xFFFFFFFF;
#endif

/***************************** Public Function ****************************\
* BOOL  APIENTRY PlayMetaFile(hdc, hmf)
* HDC           hDC;
* HMETAFILE     hMF;
*
* Play a windows metafile.
*
* History:
*   02-Jul-1991 -by-  John Colleran [johnc]
* Ported from Windows and WLO
\***************************************************************************/

BOOL APIENTRY PlayMetaFile(HDC hdc, HMETAFILE hmf)
{
    return (CommonEnumMetaFile(hdc, hmf, (MFENUMPROC)NULL, (LPARAM)0));
}

/******************************** Public Function **************************\
* BOOL EnumMetaFile(hmf)
*
* The EnumMetaFile function enumerates the GDI calls within the metafile
* identified by the hMF parameter. The EnumMetaFile function retrieves each
* GDI call within the metafile and passes it to the function pointed to by the
* pCallbackFunc parameter. This callback function, an application-supplied
* function, can process each GDI call as desired. Enumeration continues until
* there are no more GDI calls or the callback function returns zero.
*
*
* Effects:
*
\***************************************************************************/

BOOL EnumMetaFile(HDC hdc, HMETAFILE hmf, MFENUMPROC pCallBackFunction, LPARAM pClientData)
{
// Make sure that the callback function is given.  CommonEnumMetaFile expects
// it to be given in EnumMetaFile.

    if (!pCallBackFunction)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER );
        return(FALSE);
    }

    return (CommonEnumMetaFile(hdc, hmf, pCallBackFunction, pClientData));
}

BOOL CommonEnumMetaFile(HDC hdc, HMETAFILE hmf, MFENUMPROC pCallBack, LPARAM pClientData)
{
    BOOL            fStatus    = FALSE;        // assume it fails
    UINT            ii;
    UINT            noObjs;
    PMETAFILE16     pMF;
    INT             oldMapMode = -1;
    PMETARECORD     pMR        = (PMETARECORD) NULL;
    LPHANDLETABLE   pht        = (LPHANDLETABLE) NULL;
    HFONT           hLFont;
    HBRUSH          hLBrush;
    HPALETTE        hLPal;
    HPEN            hLPen;
    HRGN            hClipRgn   = (HRGN)NULL;
    SIZE            sizeOldWndExt;
    SIZE            sizeOldVprtExt;
    PDC_ATTR        pDcAttr;
    PLDC            pldc;
    int             iGraphicsModeOld;
    BOOL            bMetaDC16 = FALSE;
    FLONG           flPlayMetaFile = (FLONG) 0;

// First validate the DC type and note whether or not we
// are playing into a 16bit metafile.Null hdc is allowed
// in win3.0 but disallowed in win3.1.


    if(LO_TYPE(hdc) == LO_METADC16_TYPE)
    {
        bMetaDC16 = TRUE;
    }
    else if ((hdc == NULL) && pCallBack)
    {
       // Actually win9x can take NULL hdc.  There are some image filter
       // that actually pass in us NULL hdc.  Only let NULL hdc thru if there is a
       // callback routine. [bug 102767]

       bMetaDC16 = TRUE;
    }
    else
    if((LO_TYPE(hdc) != LO_DC_TYPE ) &&
       (LO_TYPE(hdc) != LO_ALTDC_TYPE))
    {
        WARNING("CommonEnumMetaFile: bogus DC\n");
        return(FALSE);
    }

// need a pointer to pDcAttr for DC_PLAYMETAFILE flag

    PSHARED_GET_VALIDATE((PVOID)pDcAttr,hdc,DC_TYPE);

    if(!bMetaDC16 && !pDcAttr) {
        WARNING("CommonEnumMetaFile: Couldn't Validate DC\n");
        return(FALSE);
    }

// we still need to PLDC in the case that we are printing and there is
// an abort proc

    pldc = GET_PLDC(hdc);

    PUTS("CommonEnumMetaFile\n");

#if DBG
    curRecord = 0;
#endif

// Validate the 16 bit MetaFile

    pMF = GET_PMF16(hmf);
    if (pMF == NULL)
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

// Allocate memory for the handle table.

    if ((noObjs = pMF->metaHeader.mtNoObjects) > 0)
        if (!(pht = (LPHANDLETABLE) LocalAlloc(
                                LMEM_FIXED | LMEM_ZEROINIT,
                                sizeof(HANDLE) * pMF->metaHeader.mtNoObjects
                                     + sizeof(WORD))))  // need extra word?
            return(FALSE);

// Save the old objects so we can put them back if this is not a metafile.
// Only do object save/reselect for real DC's.

    if( !bMetaDC16 )
    {
        hLBrush  = (HBRUSH)   GetDCObject(hdc, LO_BRUSH_TYPE);
        hLFont   = (HFONT)    GetDCObject(hdc, LO_FONT_TYPE);
        hLPal    = (HPALETTE) GetDCObject(hdc, LO_PALETTE_TYPE);
        hLPen    = (HPEN)     GetDCObject(hdc, LO_PEN_TYPE);

    // Set a bit in the DC to indicate that we are playing the metafile.
    // This bit is cleared by CancelDC() to stop playing the metafile.
    // At the same time, remember the previous DC_PLAYMETAFILE bit.

        try
        {
            flPlayMetaFile = pDcAttr->ulDirty_ & DC_PLAYMETAFILE;
            if (flPlayMetaFile)
            {
                PUTS("CommonEnumMetaFile: DC_PLAYMETAFILE bit is set!\n");
            }
            pDcAttr->ulDirty_ |= DC_PLAYMETAFILE;
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("except in SetBkMode\n");
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            return(FALSE);
        }

    // Create a region in case there is a clip region to receive from GetClipRgn

        if (!(hClipRgn = CreateRectRgn(0,0,0,0)))
            goto pmf_cleanup;

        switch (GetClipRgn(hdc, hClipRgn))
        {
        case -1:        // error
            ASSERTGDI(FALSE, "GetClipRgn failed");
            goto pmf_cleanup;
        case 0:         // no initial clip region
            if (!DeleteObject(hClipRgn))
                ASSERTGDI(FALSE, "CommonEnumMetaFile: Detele region failed\n");
            hClipRgn = (HRGN) 0;
            break;
        case 1:         // has initial clip region
            break;
        }

// The metafile is to be played in the compatible graphics mode only.

        iGraphicsModeOld = GetGraphicsMode(hdc);
        if (iGraphicsModeOld != GM_COMPATIBLE)
            SetGraphicsMode(hdc, GM_COMPATIBLE);
    }

// Are we doing an EnumMetaFile or PlayMetaFile

    if (pCallBack)
    {
        fStatus = TRUE;         // assume success

// EnumMetaFile

        while (pMR = (PMETARECORD) GetEvent(pMF, pMR))
        {
            if (pMR == (PMETARECORD) -1)
            {
                fStatus = FALSE;
                break;
            }

            if (!bMetaDC16 && !( pDcAttr->ulDirty_ & DC_PLAYMETAFILE))
            {
                WARNING("CommonEnumMetaFile: CancelDC called\n");
                fStatus = FALSE;
                break;
            }

            if (!(fStatus = (*pCallBack)(hdc, pht, (METARECORD FAR *) pMR,
                                (int) noObjs, pClientData)))
                break;

        #if DBG
            curRecord++;
            if (curRecord == iBreakRecord)
                ASSERTGDI(FALSE, "CommonEnumMetaFile: iBreakRecord reached\n");
        #endif
        }
    }
    else
    {
// PlayMetaFile

        fStatus = TRUE;         // assume success

        while (pMR = (PMETARECORD) GetEvent(pMF, pMR))
        {
            if (pMR == (PMETARECORD) -1)
            {
                fStatus = FALSE;
                break;
            }

            if (!bMetaDC16 && !( pDcAttr->ulDirty_ & DC_PLAYMETAFILE))
            {
                WARNING("CommonEnumMetaFile: CancelDC called\n");
                fStatus = FALSE;
                break;
            }

            if (pldc && pldc->pfnAbort != NULL)
            {
                if (!(*pldc->pfnAbort)(hdc, 0))
                {
                    fStatus = FALSE;
                        break;
                }
            }

        // For win3.1 compatability, ignore the return value from PlayMetaFileRecord

            PlayMetaFileRecord(hdc, pht, pMR, noObjs);

        #if DBG
            curRecord++;
            if (curRecord == iBreakRecord)
                ASSERTGDI(FALSE, "CommonEnumMetaFile: iBreakRecord reached\n");
        #endif
        }
    }

    // if we fail restoring an object, we need to select some
    // default object so that we can DeleteObject any Metafile-
    // selected objects

    if( !bMetaDC16 )
    {
        if (iGraphicsModeOld != GM_COMPATIBLE)
            SetGraphicsMode(hdc, iGraphicsModeOld);

        if (!SelectObject(hdc,hLPen))
            SelectObject(hdc,GetStockObject(BLACK_PEN));

        if (!SelectObject(hdc,hLBrush))
            SelectObject(hdc,GetStockObject(BLACK_BRUSH));

        if (!SelectPalette(hdc, hLPal, FALSE))
            SelectPalette(hdc, GetStockObject(DEFAULT_PALETTE), FALSE);

        if (hLFont != (HFONT) GetDCObject(hdc, LO_FONT_TYPE))
        {
            if (!SelectObject(hdc,hLFont))
            {
                // if we cannot select the original font back in, we
                // select the system font.  this will allow us to delete
                // the metafile font selected.  to insure that the system
                // font gets selected, we reset the DC's transform to
                // default.  after the selection, we restore this stuff
                //

                GetWindowExtEx(hdc, &sizeOldWndExt);
                GetViewportExtEx(hdc, &sizeOldVprtExt);
                oldMapMode = SetMapMode(hdc, MM_TEXT);

                SelectObject(hdc,GetStockObject(SYSTEM_FONT));

                SetMapMode(hdc,oldMapMode);
                SetWindowExtEx( hdc, sizeOldWndExt.cx,  sizeOldWndExt.cy,  NULL);
                SetViewportExtEx(hdc, sizeOldVprtExt.cx, sizeOldVprtExt.cy, NULL);
            }
        }

        if (SelectClipRgn(hdc, hClipRgn) == RGN_ERROR)
            SelectClipRgn(hdc, (HRGN) 0);
    }

    // Cleanup all created objects

    for (ii = 0; ii < noObjs; ii++)
    {
        if (pht->objectHandle[ii])
            if (!DeleteObject(pht->objectHandle[ii]))
                ERROR_ASSERT(FALSE,
                    "CommonEnumMetaFile: DeleteObject(objectHandle) failed\n");
    }

    // if we fiddled with the map mode because we could not
    // restore the original font, then maybe we can restore the
    // font now

    if (oldMapMode > 0)
        SelectObject(hdc,hLFont);

pmf_cleanup:

    if (pldc)
    {
        // Preserve the DC_PLAYMETAFILE bit.
        // If we hit a CancelDC, then we will leave the bit clear.

        ASSERTGDI(!(flPlayMetaFile & ~DC_PLAYMETAFILE),
            "CommonEnumMetaFile: bad flPlayMetaFile\n");

        if (!bMetaDC16 && !( pDcAttr->ulDirty_ & DC_PLAYMETAFILE) )
        {
            pDcAttr->ulDirty_ &= ~DC_PLAYMETAFILE;
            pDcAttr->ulDirty_ |= flPlayMetaFile; // restore the original flag
        }
    }

    if (hClipRgn)
        if (!DeleteObject(hClipRgn))
            ASSERTGDI(FALSE, "CommonEnumMetaFile: Delete region 2 failed\n");

    if (pht)
        if (LocalFree((HANDLE) pht))
            ASSERTGDI(FALSE, "CommonEnumMetaFile: LocalFree failed\n");

    return(fStatus);
}

/***************************** Internal Function **************************\
* BOOL NEAR PASCAL IsDIBBlackAndWhite
*
* Check to see if this DIB is a black and white DIB (and should be
* converted into a mono bitmap as opposed to a color bitmap).
*
* Returns: TRUE         it is a B&W bitmap
*          FALSE        this is for color
*
* Effects: ?
*
* Warnings: ?
*
* History:
\***************************************************************************/

BOOL IsDIBBlackAndWhite(LPBITMAPINFOHEADER lpDIBInfo)
{
    LPDWORD lpRGB;

    PUTS("IsDIBBlackAndWhite\n");

    ASSERTGDI(!((ULONG_PTR) lpDIBInfo & 0x3), "IsDIBBlackAndWhite: dword alignment error\n");

    /* pointer color table */
    lpRGB = (LPDWORD)((LPBITMAPINFO)lpDIBInfo)->bmiColors;

    return (lpDIBInfo->biBitCount == 1
         && lpDIBInfo->biPlanes == 1
         && lpRGB[0] == (DWORD) 0
         && lpRGB[1] == (DWORD) 0xFFFFFF);
}

/***************************** Internal Function **************************\
* UseStretchDIBits
*
* set this directly to the device using StretchDIBits.
* if DIB is black&white, don't do this.
*
* Returns:
*               TRUE --- operation successful
*               FALSE -- decided not to use StretchDIBits
*
* History:
\***************************************************************************/

BOOL UseStretchDIB(HDC hDC, WORD magic, LPMETARECORD lpMR)
{
    LPBITMAPINFOHEADER lpDIBInfo;
    INT sExtX, sExtY;
    INT sSrcX, sSrcY;
    INT DstX, DstY, DstXE, DstYE;

    if (magic == META_DIBBITBLT)
    {
        lpDIBInfo = (LPBITMAPINFOHEADER)&lpMR->rdParm[8];

        DstX  = (INT) (SHORT) lpMR->rdParm[7];
        DstY  = (INT) (SHORT) lpMR->rdParm[6];
        sSrcX = (INT) (SHORT) lpMR->rdParm[3];
        sSrcY = (INT) (SHORT) lpMR->rdParm[2];
        DstXE = sExtX = (INT) (SHORT) lpMR->rdParm[5];
        DstYE = sExtY = (INT) (SHORT) lpMR->rdParm[4];
    }
    else
    {
        lpDIBInfo = (LPBITMAPINFOHEADER)&lpMR->rdParm[10];

        DstX  = (INT) (SHORT) lpMR->rdParm[9];
        DstY  = (INT) (SHORT) lpMR->rdParm[8];
        DstXE = (INT) (SHORT) lpMR->rdParm[7];
        DstYE = (INT) (SHORT) lpMR->rdParm[6];
        sSrcX = (INT) (SHORT) lpMR->rdParm[5];
        sSrcY = (INT) (SHORT) lpMR->rdParm[4];
        sExtX = (INT) (SHORT) lpMR->rdParm[3];
        sExtY = (INT) (SHORT) lpMR->rdParm[2];
    }

    ASSERTGDI(!((ULONG_PTR) lpDIBInfo & 0x3), "UseStretchDIB: dword alignment error\n");

    /* if DIB is black&white, we don't really want to do this */
    if (IsDIBBlackAndWhite(lpDIBInfo))
        return(FALSE);

// Need to flip the source y coordinates to call StretchDIBits.

    sSrcY = ABS(lpDIBInfo->biHeight) - sSrcY - sExtY;

    StretchDIBits(hDC, DstX, DstY, DstXE, DstYE,
                        sSrcX, sSrcY, sExtX, sExtY,
                        (LPBYTE)((LPSTR)lpDIBInfo + lpDIBInfo->biSize
                                + GetSizeOfColorTable(lpDIBInfo)),
                        (LPBITMAPINFO)lpDIBInfo, DIB_RGB_COLORS,
                        (MAKELONG(lpMR->rdParm[0], lpMR->rdParm[1])));
    return(TRUE);
}

/***************************** Internal Function **************************\
* GetEvent
*
* This routine will now open a disk metafile in READ_ONLY mode. This will
* allow us to play read-only metafiles or to share such file.
*
* To start the enumeration, the first lpMR must be NULL.
* It does not enumerate the first (header) and last (terminator) records.
*
* Returns:  Next MetaFile Record to be played
*           NULL if the next metafile record is the EOF record
*           -1   if an error occurs.
*
\***************************************************************************/

PMETARECORD GetEvent(PMETAFILE16 pmf16, PMETARECORD lpMR)
{
    PMETARECORD lpMRNext;

    PUTS("GetEvent\n");

    if (lpMR == (PMETARECORD) NULL)
        pmf16->iMem = sizeof(METAHEADER);
    else
        pmf16->iMem += (lpMR->rdSize * sizeof(WORD));

// Make sure that we don't read past the EOF.  A minimal record includes
// rdSize (DWORD) and rdFunction (WORD).

    if (pmf16->iMem > pmf16->metaHeader.mtSize * sizeof(WORD) - sizeof(DWORD) - sizeof(WORD))
    {
        VERIFYGDI(FALSE, "GetEvent: Metafile contains bad data\n");
        return((PMETARECORD) -1);
    }

    lpMRNext = (PMETARECORD) ((LPBYTE) pmf16->hMem + pmf16->iMem);

// If we are at the end of the metafile then return NULL.

    if (lpMRNext->rdFunction == 0)
        return((PMETARECORD) NULL);

    return(lpMRNext);
}

/***************************** Internal Function **************************\
* BOOL GDIENTRY PlayMetaFileRecord
*
* Plays a metafile record by executing the GDI function call contained
* withing the metafile record
*
* Effects:
*
\***************************************************************************/

//LPSTR lpZapfDingbats = "ZAPFDINGBATS";
//LPSTR lpZapf_Dingbats = "ZAPF DINGBATS";
//LPSTR lpSymbol = "SYMBOL";
//LPSTR lpTmsRmn = "TMS RMN";
//LPSTR lpHelv = "HELV";

#define PITCH_MASK  ( FIXED_PITCH | VARIABLE_PITCH )

BOOL
APIENTRY PlayMetaFileRecord(
    HDC             hdc,
    LPHANDLETABLE   lpHandleTable,
    LPMETARECORD    lpMR,
    UINT            noObjs
   )
{
    BOOL         fStatus = FALSE;
    LPMETARECORD lpMRdup = (LPMETARECORD) NULL;
    WORD    magic;
    HANDLE  hObject;
    HANDLE  hOldObject;
    HBRUSH  hBrush;
    HRGN    hRgn;
    HANDLE  hPal;

    PUTSX("PlayMetaFileRecord 0x%p\n", lpMR);

    magic = lpMR->rdFunction;

    switch (magic & 255)
    {
        case (META_BITBLT & 255):
        case (META_STRETCHBLT & 255):
        {
            HDC         hSDC;
            HANDLE      hBitmap;
            PBITMAP16   lpBitmap16;
            INT         delta = 0;
            DWORD       rop;

            WARNING("PlayMetaFileRecord: obsolete META_BITBLT/META_STRETCHBLT record\n");

            /* if playing into another Metafile, do direct copy */
            if (PlayIntoAMetafile(lpMR, hdc))
            {
                fStatus = TRUE;
                break;
            }

            if ((lpMR->rdSize - 3) == ((DWORD) magic >> 8))
            {
                hSDC = hdc;
                delta = 1;
            }
            else
            {
                LPMETARECORD lpMRtmp;

                // Make the bitmap bits dword aligned.  To do this,
                // lpMR has to fall on a dword aligned even address so that
                // the bitmap bits (&lpMR->rdParm[8+5] or &lpMR->rdParm[10+5])
                // will fall on the dword aligned addresses.

                if (!(lpMRdup = (LPMETARECORD) LocalAlloc(LMEM_FIXED,
                        (UINT) lpMR->rdSize * sizeof(WORD))))
                    break;
                lpMRtmp = lpMRdup;
                RtlCopyMemory((PBYTE) lpMRtmp,
                              (PBYTE) lpMR,
                              (UINT)  lpMR->rdSize * sizeof(WORD));

                if (hSDC = CreateCompatibleDC(hdc))
                {
                    if (magic == META_BITBLT)
                        lpBitmap16 = (PBITMAP16) &lpMRtmp->rdParm[8];
                    else
                        lpBitmap16 = (PBITMAP16) &lpMRtmp->rdParm[10];

                    if (hBitmap  = CreateBitmap(lpBitmap16->bmWidth,
                                                lpBitmap16->bmHeight,
                                                lpBitmap16->bmPlanes,
                                                lpBitmap16->bmBitsPixel,
                                                (LPBYTE)&lpBitmap16->bmBits))
                        hOldObject = SelectObject(hSDC, hBitmap);
                    else
                        goto PMFR_BitBlt_cleanup;
                }
                else
                    break;
            }

            rop = MAKELONG(lpMR->rdParm[0], lpMR->rdParm[1]);

            if (magic == META_BITBLT)
                fStatus = BitBlt(hdc,
                                (int) (SHORT) lpMR->rdParm[7 + delta],
                                (int) (SHORT) lpMR->rdParm[6 + delta],
                                (int) (SHORT) lpMR->rdParm[5 + delta],
                                (int) (SHORT) lpMR->rdParm[4 + delta],
                                (delta && !ISSOURCEINROP3(rop)) ? 0 : hSDC,
                                (int) (SHORT) lpMR->rdParm[3],
                                (int) (SHORT) lpMR->rdParm[2],
                                rop);
            else
                fStatus = StretchBlt(hdc,
                                (int) (SHORT) lpMR->rdParm[9 + delta],
                                (int) (SHORT) lpMR->rdParm[8 + delta],
                                (int) (SHORT) lpMR->rdParm[7 + delta],
                                (int) (SHORT) lpMR->rdParm[6 + delta],
                                (delta && !ISSOURCEINROP3(rop)) ? 0 : hSDC,
                                (int) (SHORT) lpMR->rdParm[5],
                                (int) (SHORT) lpMR->rdParm[4],
                                (int) (SHORT) lpMR->rdParm[3],
                                (int) (SHORT) lpMR->rdParm[2],
                                rop);

            if (hSDC != hdc)
            {
                if (!SelectObject(hSDC, hOldObject))
                    ASSERTGDI(FALSE, "PlayMetaFileRecord: SelectObject Bitblt Failed\n");
                if (!DeleteObject(hBitmap))
                    ASSERTGDI(FALSE, "PlayMetaFileRecord: DeleteObject Bitblt Failed\n");
PMFR_BitBlt_cleanup:
                if (!DeleteDC(hSDC))
                    ASSERTGDI(FALSE, "PlayMetaFileRecord: DeleteDC BitBlt Failed\n");
            }
        }
        break;

        case (META_DIBBITBLT & 255):
        case (META_DIBSTRETCHBLT & 255):
        {
            HDC         hSDC;
            HANDLE      hBitmap;
            LPBITMAPINFOHEADER lpDIBInfo ;
            INT         delta = 0;
            HANDLE      hOldPal;

            /* if playing into another metafile, do direct copy */
            if (PlayIntoAMetafile(lpMR, hdc))
            {
                fStatus = TRUE;
                break;
            }

            if ((lpMR->rdSize - 3) == ((DWORD) magic >> 8))
            {
                hSDC = hdc;
                delta = 1;
            }
            else
            {
                LPMETARECORD lpMRtmp;

                // Make the bitmap info and bits dword aligned.  To do this,
                // lpMR has to fall on a non dword aligned even address so that
                // the bitmap info (&lpMR->rdParm[8] or &lpMR->rdParm[10]) and
                // the bitmap bits will fall on the dword aligned addresses.
                // Note that the size of the bitmap info is always a multiple
                // of 4.

                if (!(lpMRdup = (LPMETARECORD) LocalAlloc(LMEM_FIXED,
                        (UINT) lpMR->rdSize * sizeof(WORD) + sizeof(WORD))))
                    break;
                lpMRtmp = (LPMETARECORD) &((PWORD) lpMRdup)[1];
                RtlCopyMemory((PBYTE) lpMRtmp,
                              (PBYTE) lpMR,
                              (UINT)  lpMR->rdSize * sizeof(WORD));

                if (UseStretchDIB(hdc, magic, lpMRtmp))
                {
                    fStatus = TRUE;
                    break;
                }

                if (hSDC = CreateCompatibleDC(hdc))
                {
                    /* set up the memDC to have the same palette */
                    hOldPal = SelectPalette(hSDC, GetCurrentObject(hdc,OBJ_PAL), TRUE);

                    if (magic == META_DIBBITBLT)
                        lpDIBInfo = (LPBITMAPINFOHEADER)&lpMRtmp->rdParm[8];
                    else
                        lpDIBInfo = (LPBITMAPINFOHEADER)&lpMRtmp->rdParm[10];

                    /* now create the bitmap for the MemDC and fill in the bits */
                    /* the processing for old and new format of metafiles is
                            different here (till hBitmap is obtained) */

                    /* new metafile version */
                    hBitmap = CreateBitmapForDC (hdc,lpDIBInfo);

                    if (hBitmap)
                        hOldObject = SelectObject (hSDC, hBitmap) ;
                    else
                        goto PMFR_DIBBITBLT_cleanup;
                }
                else
                    break;
            }

            if (magic == META_DIBBITBLT)
                fStatus = BitBlt(hdc,
                            (int) (SHORT) lpMR->rdParm[7 + delta],
                            (int) (SHORT) lpMR->rdParm[6 + delta],
                            (int) (SHORT) lpMR->rdParm[5 + delta],
                            (int) (SHORT) lpMR->rdParm[4 + delta],
                            delta ? 0 : hSDC,
                            (int) (SHORT) lpMR->rdParm[3],
                            (int) (SHORT) lpMR->rdParm[2],
                            MAKELONG(lpMR->rdParm[0], lpMR->rdParm[1]));
            else
                fStatus = StretchBlt(hdc,
                            (int) (SHORT) lpMR->rdParm[9 + delta],
                            (int) (SHORT) lpMR->rdParm[8 + delta],
                            (int) (SHORT) lpMR->rdParm[7 + delta],
                            (int) (SHORT) lpMR->rdParm[6 + delta],
                            delta ? 0 : hSDC,
                            (int) (SHORT) lpMR->rdParm[5],
                            (int) (SHORT) lpMR->rdParm[4],
                            (int) (SHORT) lpMR->rdParm[3],
                            (int) (SHORT) lpMR->rdParm[2],
                            MAKELONG(lpMR->rdParm[0], lpMR->rdParm[1]));

            if (hSDC != hdc)
            {
                /* Deselect hDC's palette from memDC */
                SelectPalette(hSDC, hOldPal, TRUE);
                if (!SelectObject(hSDC, hOldObject))
                    ASSERTGDI(FALSE, "PlayMetaFileRecord: SelectObject DIBBitBlt Failed\n");
                if (!DeleteObject(hBitmap))
                    ASSERTGDI(FALSE, "PlayMetaFileRecord: DeleteObject(hBitmap) DIBBitBlt Failed\n");
PMFR_DIBBITBLT_cleanup:
                if (!DeleteDC(hSDC))
                    ASSERTGDI(FALSE, "PlayMetaFileRecord DeleteDC DIBBitblt failed\n");
            }
        }
        break;

        case (META_SELECTOBJECT & 255):
        {
            if (hObject = lpHandleTable->objectHandle[lpMR->rdParm[0]])
            {
                fStatus = SelectObject(hdc, hObject) != (HANDLE)0;

                // new in win3.1
                if (!fStatus)
                {
                    switch (GetObjectType(hObject))
                    {
                    case OBJ_PAL:
                        SelectObject(hdc, (HGDIOBJ) GetStockObject(DEFAULT_PALETTE));
                        break;
                    case OBJ_BRUSH:
                        SelectObject(hdc, (HGDIOBJ) GetStockObject(WHITE_BRUSH));
                        break;
                    case OBJ_PEN:
                        SelectObject(hdc, (HGDIOBJ) GetStockObject(BLACK_PEN));
                        break;
                    case OBJ_FONT:
                        SelectObject(hdc, (HGDIOBJ) GetStockObject(DEVICE_DEFAULT_FONT));
                        break;
                    case OBJ_REGION:
                        SelectClipRgn(hdc, 0);
                        break;
                    default:
                        ASSERTGDI(FALSE,
                            "PlayMetaFileRecord:SELECTOBJECT unknown object\n");
                        break;
                    }
                }
            }
        }
        break;

        case (META_CREATEPENINDIRECT & 255):
        {
            LOGPEN lp;

            LOGPEN32FROMLOGPEN16(&lp, (PLOGPEN16) &lpMR->rdParm[0]);
            if (hObject = CreatePenIndirect(&lp))
                fStatus = AddToHandleTable(lpHandleTable, hObject, noObjs);
        }
        break;

        case (META_CREATEFONTINDIRECT & 255):
        {
            LOGFONTA     lf;
            PLOGFONT16  plf16 = (PLOGFONT16) &lpMR->rdParm[0];
            CHAR        achCapString[LF_FACESIZE];

            LOGFONT32FROMLOGFONT16(&lf, (PLOGFONT16) &lpMR->rdParm[0]);

        // Capitalize the string for faster compares.

            lstrcpynA(achCapString, lf.lfFaceName, LF_FACESIZE);
            CharUpperBuffA(achCapString, LF_FACESIZE);

        // Here we are going to implement a bunch of Win 3.1 hacks rather
        // than contaminate the 32-bit engine.  These same hacks can be found
        // in WOW (in the CreateFont/CreateFontIndirect code).
        //
        // These hacks are keyed off the facename in the LOGFONTA.  String
        // comparisons have been unrolled for maximal performance.

        // Win 3.1 facename-based hack.  Some apps, like
        // Publisher, create a "Helv" font but have the lfPitchAndFamily
        // set to specify FIXED_PITCH.  To work around this, we will patch
        // the pitch field for a "Helv" font to be variable.

            // if ( !lstrcmp(achCapString, lpHelv) )

            if ( ((achCapString[0]  == 'H') &&
                  (achCapString[1]  == 'E') &&
                  (achCapString[2]  == 'L') &&
                  (achCapString[3]  == 'V') &&
                  (achCapString[4]  == '\0')) )
            {
                lf.lfPitchAndFamily |= ( (lf.lfPitchAndFamily & ~PITCH_MASK) | VARIABLE_PITCH );
            }
            else
            {
            // Win 3.1 hack for Legacy 2.0.  When a printer does not enumerate
            // a "Tms Rmn" font, the app enumerates and gets the LOGFONTA for
            // "Script" and then create a font with the name "Tms Rmn" but with
            // the lfCharSet and lfPitchAndFamily taken from the LOGFONTA for
            // "Script".  Here we will over the lfCharSet to be ANSI_CHARSET.

                // if ( !lstrcmp(achCapString, lpTmsRmn) )

                if ( ((achCapString[0]  == 'T') &&
                      (achCapString[1]  == 'M') &&
                      (achCapString[2]  == 'S') &&
                      (achCapString[3]  == ' ') &&
                      (achCapString[4]  == 'R') &&
                      (achCapString[5]  == 'M') &&
                      (achCapString[6]  == 'N') &&
                      (achCapString[7]  == '\0')) )
                {
                    lf.lfCharSet = ANSI_CHARSET;
                }
                else
                {
                // If the lfFaceName is "Symbol", "Zapf Dingbats", or "ZapfDingbats",
                // enforce lfCharSet to be SYMBOL_CHARSET.  Some apps (like Excel) ask
                // for a "Symbol" font but have the char set set to ANSI.  PowerPoint
                // has the same problem with "Zapf Dingbats".

                    //if ( !lstrcmp(achCapString, lpSymbol) ||
                    //     !lstrcmp(achCapString, lpZapfDingbats) ||
                    //     !lstrcmp(achCapString, lpZapf_Dingbats) )

                    if ( ((achCapString[0]  == 'S') &&
                          (achCapString[1]  == 'Y') &&
                          (achCapString[2]  == 'M') &&
                          (achCapString[3]  == 'B') &&
                          (achCapString[4]  == 'O') &&
                          (achCapString[5]  == 'L') &&
                          (achCapString[6]  == '\0')) ||

                         ((achCapString[0]  == 'Z') &&
                          (achCapString[1]  == 'A') &&
                          (achCapString[2]  == 'P') &&
                          (achCapString[3]  == 'F') &&
                          (achCapString[4]  == 'D') &&
                          (achCapString[5]  == 'I') &&
                          (achCapString[6]  == 'N') &&
                          (achCapString[7]  == 'G') &&
                          (achCapString[8]  == 'B') &&
                          (achCapString[9]  == 'A') &&
                          (achCapString[10] == 'T') &&
                          (achCapString[11] == 'S') &&
                          (achCapString[12] == '\0')) ||

                         ((achCapString[0]  == 'Z') &&
                          (achCapString[1]  == 'A') &&
                          (achCapString[2]  == 'P') &&
                          (achCapString[3]  == 'F') &&
                          (achCapString[4]  == ' ') &&
                          (achCapString[5]  == 'D') &&
                          (achCapString[6]  == 'I') &&
                          (achCapString[7]  == 'N') &&
                          (achCapString[8]  == 'G') &&
                          (achCapString[9]  == 'B') &&
                          (achCapString[10] == 'A') &&
                          (achCapString[11] == 'T') &&
                          (achCapString[12] == 'S') &&
                          (achCapString[13] == '\0')) )
                    {
                        lf.lfCharSet = SYMBOL_CHARSET;
                    }
                }
            }

            if (hObject = CreateFontIndirectA(&lf))
            {
                fStatus = AddToHandleTable(lpHandleTable, hObject, noObjs);
            }
        }
        break;

        case (META_CREATEPATTERNBRUSH & 255):
        {
            HANDLE       hBitmap;
            BITMAP       Bitmap;
            LPMETARECORD lpMRtmp;

            WARNING("PlayMetaFileRecord: obsolete META_CREATEPATTERNBRUSH record\n");

            // Make the bitmap bits dword aligned.  To do this,
            // lpMR has to fall on a non dword aligned even address so that
            // the bitmap bits (bmBits) will fall on the dword aligned address.

            if (!(lpMRdup = (LPMETARECORD) LocalAlloc(LMEM_FIXED,
                        (UINT) lpMR->rdSize * sizeof(WORD) + sizeof(WORD))))
                break;
            lpMRtmp = (LPMETARECORD) &((PWORD) lpMRdup)[1];
            RtlCopyMemory((PBYTE) lpMRtmp,
                          (PBYTE) lpMR,
                          (UINT)  lpMR->rdSize * sizeof(WORD));

            BITMAP32FROMBITMAP16(&Bitmap, (PBITMAP16) &lpMRtmp->rdParm[0]);
            // The magic number 18 is based on the IPBITMAP structure in win3.1
            Bitmap.bmBits = (PBYTE) &lpMRtmp->rdParm + sizeof(BITMAP16) + 18;

            if (hBitmap = CreateBitmapIndirect(&Bitmap))
            {
                if (hObject = CreatePatternBrush(hBitmap))
                    fStatus = AddToHandleTable(lpHandleTable, hObject, noObjs);

                if (!DeleteObject(hBitmap))
                    ASSERTGDI(FALSE, "PlayMetaFileRecord: DeleteObject(hBitmap) CreatePatternBrush Failed\n");
            }
        }
        break;

        case (META_DIBCREATEPATTERNBRUSH & 255):
        {
            HDC         hMemDC ;
            HANDLE      hBitmap;
            LPBITMAPINFOHEADER lpDIBInfo ;
            LPMETARECORD lpMRtmp;

            // Make the bitmap info and bits dword aligned.  To do this,
            // lpMR has to fall on a non dword aligned even address so that
            // the bitmap info (&lpMR->rdParm[2]) and
            // the bitmap bits will fall on the dword aligned addresses.
            // Note that the size of the bitmap info is always a multiple
            // of 4.

            if (!(lpMRdup = (LPMETARECORD) LocalAlloc(LMEM_FIXED,
                        (UINT) lpMR->rdSize * sizeof(WORD) + sizeof(WORD))))
                break;
            lpMRtmp = (LPMETARECORD) &((PWORD) lpMRdup)[1];
            RtlCopyMemory((PBYTE) lpMRtmp,
                          (PBYTE) lpMR,
                          (UINT)  lpMR->rdSize * sizeof(WORD));


            if (lpMRtmp->rdParm[0] == BS_PATTERN)
            {
                /* the address of the second paramter is the address of the DIB
                   header, extract it */
                lpDIBInfo = (LPBITMAPINFOHEADER) &lpMRtmp->rdParm[2];

                /* now create a device dependend bitmap compatible to the default
                   screen DC - hScreenDC and extract the bits from the DIB into it.
                    The following function does all these, and returns a HANDLE
                    to the device dependent BItmap. */

                /* we will use a dummy memory DC compatible to the screen DC */
                hMemDC = CreateCompatibleDC((HDC)NULL);

                if (!hMemDC)
                {
                    ERROR_ASSERT(FALSE, "PlayMetaRecord: CreateCompDC Failed\n");
                    break;
                }

                hBitmap = CreateBitmapForDC(hMemDC,lpDIBInfo);

                if (hBitmap)
                {
                    if (hObject = CreatePatternBrush(hBitmap))
                        fStatus = AddToHandleTable(lpHandleTable, hObject, noObjs);

                    if (!DeleteObject(hBitmap))
                        ASSERTGDI(FALSE, "PlayMetaFileRecord: DeleteObject(hBitmap) DIBCreatePatternBrush Failed\n");
                }

                /* delete the dummy memory DC for new version Metafiles*/
                if (!DeleteDC (hMemDC))
                    ASSERTGDI(FALSE, "PlayMetaRecord: DeleteDC DIBCreatePatternBrush Failed\n");
            }

            /* this is a DIBPattern brush */
            else
            {
                if (hObject = CreateDIBPatternBrushPt((LPVOID)&lpMRtmp->rdParm[2],
                                                      (DWORD) lpMRtmp->rdParm[1]))
                    fStatus = AddToHandleTable(lpHandleTable, hObject, noObjs);

            }
        }
        break;

        case (META_CREATEBRUSHINDIRECT & 255):
        {
            LOGBRUSH lb;

            LOGBRUSH32FROMLOGBRUSH16(&lb, (PLOGBRUSH16) &lpMR->rdParm[0]);
            if (hObject = CreateBrushIndirect(&lb))
                fStatus = AddToHandleTable(lpHandleTable, hObject, noObjs);
        }
        break;

        case (META_POLYLINE & 255):
        case (META_POLYGON & 255):
        {
            PPOINTL pptl;
            UINT    cpts = lpMR->rdParm[0];

            if (!(pptl = (PPOINTL) LocalAlloc
                                (LMEM_FIXED, (UINT) cpts * sizeof(POINTL))))
                break;

            INT32FROMINT16(pptl, &lpMR->rdParm[1], cpts * 2);

            switch (magic)
            {
            case META_POLYGON:
                fStatus = Polygon(hdc, (LPPOINT) pptl, (int) cpts);
                break;
            case META_POLYLINE:
                fStatus = Polyline(hdc, (LPPOINT) pptl, (int) cpts);
                break;
            default:
                ASSERTGDI(FALSE, "Bad record type");
                break;
            }

            if (LocalFree(pptl))
                ASSERTGDI(FALSE, "PlayMetaRecord: LocalFree failed\n");
        }
        break;

        case (META_POLYPOLYGON & 255):
        {
            PPOINTL pptl;
            LPINT   lpPolyCount;
            PBYTE   pb;
            UINT    ii;
            UINT    cpts  = 0;
            UINT    cPoly = lpMR->rdParm[0];

            for (ii = 0; ii < cPoly; ii++)
                cpts += ((LPWORD)&lpMR->rdParm[1])[ii];

            if (!(pb = (PBYTE) LocalAlloc
                        (
                            LMEM_FIXED,
                            cPoly * sizeof(INT) + cpts * sizeof(POINTL)
                        )
                 )
               )
                break;

            lpPolyCount = (LPINT) pb;
            pptl        = (PPOINTL) (pb + cPoly * sizeof(INT));

            for (ii = 0; ii < cPoly; ii++)
                lpPolyCount[ii] = (INT) (UINT) ((LPWORD)&lpMR->rdParm[1])[ii];

            INT32FROMINT16(pptl, &lpMR->rdParm[1] + cPoly, cpts * 2);

            fStatus = PolyPolygon(hdc, (LPPOINT) pptl, lpPolyCount, (int) cPoly);

            if (LocalFree((HANDLE) pb))
                ASSERTGDI(FALSE, "PlayMetaRecord: LocalFree failed\n");
        }
        break;

        case (META_EXTTEXTOUT & 255):
        {
            PSHORT      lpdx16;
            LPINT       lpdx;
            LPSTR       lpch;
            RECT        rc;
            LPRECT      lprc;

            lprc = (lpMR->rdParm[3] & (ETO_OPAQUE|ETO_CLIPPED))
                   ? (LPRECT) &lpMR->rdParm[4]
                   : (LPRECT) NULL;

            if (lprc)
            {
                rc.left   = ((PRECT16)lprc)->left;
                rc.right  = ((PRECT16)lprc)->right;
                rc.top    = ((PRECT16)lprc)->top;
                rc.bottom = ((PRECT16)lprc)->bottom;
                lprc = &rc;
            }

            lpch = (LPSTR)&lpMR->rdParm[4] + ((lprc) ?  sizeof(RECT16) : 0);

            /* dx array starts at next word boundary after char string */
            lpdx16 = (PSHORT) (lpch + ((lpMR->rdParm[2] + 1) / 2 * 2));

            /* check to see if there is a Dx array by seeing if
               structure ends after the string itself
            */
            if (((DWORD)((LPWORD)lpdx16 - (LPWORD)(lpMR))) >= lpMR->rdSize)
                lpdx = NULL;
            else
            {
                lpdx = (LPINT)LocalAlloc(LMEM_FIXED, lpMR->rdParm[2]*sizeof(INT));
                if (!lpdx)
                {
                    ERROR_ASSERT(FALSE, "PlayMetaFileRecord: out of memory exttextout");
                    break;
                }
                INT32FROMINT16(lpdx, lpdx16, (UINT) lpMR->rdParm[2]);
            }

            // Mask off bit 0x80 that an old Excel used to add to its
            // Metafiles and the GDI errors on.
            fStatus = ExtTextOutA(hdc,
                                  (int) (SHORT) lpMR->rdParm[1],
                                  (int) (SHORT) lpMR->rdParm[0],
                                  gbLpk ?
                                  ((UINT) lpMR->rdParm[3]) :
                                  ((UINT) lpMR->rdParm[3] & ~ETO_RTLREADING),
                                  lprc,
                                  lpch,
                                  (UINT) lpMR->rdParm[2],
                                  lpdx);

            if (lpdx)
                if (LocalFree((HANDLE)lpdx))
                    ASSERTGDI(FALSE, "PlayMetaRecord: LocalFree failed\n");
            break;
        }

        case (META_TEXTOUT & 255):
            fStatus = TextOutA(hdc,
                               (int) (SHORT) lpMR->rdParm[lpMR->rdSize-4],
                               (int) (SHORT) lpMR->rdParm[lpMR->rdSize-5],
                               (LPSTR) &lpMR->rdParm[1],
                               (int) (UINT) lpMR->rdParm[0]);
            break;

        case (META_ESCAPE & 255):
            if (!(fStatus = PlayIntoAMetafile(lpMR, hdc)))
            {
                if ((int)(UINT)lpMR->rdParm[0] != MFCOMMENT)
                {
                    fStatus = Escape(hdc,
                        (int) (UINT) lpMR->rdParm[0],
                            (int) (UINT) lpMR->rdParm[1],
                        (LPCSTR) &lpMR->rdParm[2],
                        (LPVOID) NULL) != 0;
                }
                else
                {
                    fStatus = TRUE;
                }
        }
            break;

        case (META_FRAMEREGION & 255):
            if ((hRgn = lpHandleTable->objectHandle[lpMR->rdParm[0]])
            && (hBrush = lpHandleTable->objectHandle[lpMR->rdParm[1]]))
                fStatus = FrameRgn(hdc,
                                   hRgn,
                                   hBrush,
                                   (int) (SHORT) lpMR->rdParm[3],
                                   (int) (SHORT) lpMR->rdParm[2]);
            break;

        case (META_PAINTREGION & 255):
            if (hRgn = lpHandleTable->objectHandle[lpMR->rdParm[0]])
                fStatus = PaintRgn(hdc, hRgn);
            break;

        case (META_INVERTREGION & 255):
            if (hRgn = lpHandleTable->objectHandle[lpMR->rdParm[0]])
                fStatus = InvertRgn(hdc, hRgn);
            break;

        case (META_FILLREGION & 255):
            if ((hRgn = lpHandleTable->objectHandle[lpMR->rdParm[0]])
            && (hBrush = lpHandleTable->objectHandle[lpMR->rdParm[1]]))
                fStatus = FillRgn(hdc, hRgn, hBrush);
            break;

/*
*** in win2, METACREATEREGION records contained an entire region object,
*** including the full header.  this header changed in win3.
***
*** to remain compatible, the region records will be saved with the
*** win2 header.  here we read a win2 header with region, and actually
*** create a win3 header with same region internals
*/

        case (META_CREATEREGION & 255):
        {
            HRGN        hrgn;
            PSHORT      pXs;
            PWIN3REGION pW3Rgn = (PWIN3REGION) lpMR->rdParm;
            UINT        ii, jj;
            UINT        cscn;
            PSCAN       pscn;
            DWORD       nrcl;
            PRECTL      prcl;
            UINT        cRgnData;
            PRGNDATA    pRgnData;

            cscn = (UINT) pW3Rgn->cScans;

            // Handle the empty region.

            if (!cscn)
            {
                hrgn = CreateRectRgn(0, 0, 0, 0);
                fStatus = AddToHandleTable(lpHandleTable, hrgn, noObjs);
                break;
            }

            // Count the number of rectangles in the region.

            nrcl = 0;
            pscn = pW3Rgn->aScans;
            for (ii = 0; ii < cscn; ii++)
            {
                nrcl += pscn->scnPntCnt / 2;
                pscn = (PSCAN) ((PBYTE) pscn
                                + sizeof(SCAN)
                                - 2 * sizeof(WORD)
                                + (int) (UINT) pscn->scnPntCnt * sizeof(WORD));
            }

            cRgnData = sizeof(RGNDATAHEADER) + nrcl * sizeof(RECTL);
            if (!(pRgnData = (PRGNDATA) LocalAlloc(LMEM_FIXED, cRgnData)))
                break;

            pRgnData->rdh.dwSize = sizeof(RGNDATAHEADER);
            pRgnData->rdh.iType  = RDH_RECTANGLES;
            pRgnData->rdh.nCount = nrcl;
            pRgnData->rdh.nRgnSize = 0;
            pRgnData->rdh.rcBound.left   = (LONG) pW3Rgn->rcBounding.left   ;
            pRgnData->rdh.rcBound.top    = (LONG) pW3Rgn->rcBounding.top    ;
            pRgnData->rdh.rcBound.right  = (LONG) pW3Rgn->rcBounding.right  ;
            pRgnData->rdh.rcBound.bottom = (LONG) pW3Rgn->rcBounding.bottom ;

            prcl = (PRECTL) pRgnData->Buffer;
            pscn = pW3Rgn->aScans;
            for (ii = 0; ii < cscn; ii++)
            {
                pXs = (PSHORT) pscn->scnPntsX;
                for (jj = pscn->scnPntCnt / 2; jj; jj--)
                {
                    prcl->left   = (LONG) (*pXs++);
                    prcl->top    = (LONG) (SHORT) pscn->scnPntTop;
                    prcl->right  = (LONG) (*pXs++);
                    prcl->bottom = (LONG) (SHORT) pscn->scnPntBottom;
                    prcl++;
                }
                pscn = (PSCAN) ((PBYTE) pscn
                                + sizeof(SCAN)
                                - 2 * sizeof(WORD)
                                + (int) (UINT) pscn->scnPntCnt * sizeof(WORD));
            }

            hrgn = ExtCreateRegion((LPXFORM) NULL, cRgnData, pRgnData);
            fStatus = AddToHandleTable(lpHandleTable, hrgn, noObjs);

            if (LocalFree((HANDLE) pRgnData))
                ASSERTGDI(FALSE, "PlayMetaRecord: LocalFree failed\n");
        }
        break;

        case (META_DELETEOBJECT & 255):
        {
            HANDLE h;

            if (h = lpHandleTable->objectHandle[lpMR->rdParm[0]])
            {
                if (!(fStatus = DeleteObject(h)))
                    ERROR_ASSERT(FALSE, "PlayMetaFileRecord: DeleteObject(h) Failed\n");
                lpHandleTable->objectHandle[lpMR->rdParm[0]] = NULL;
            }
        }
        break;

        case (META_CREATEPALETTE & 255):
        {
            LPMETARECORD lpMRtmp;

            // Make the logical palette dword aligned.  To do this,
            // lpMR has to fall on a non dword aligned even address so that
            // the logical palette (&lpMR->rdParm[0]) will fall on the
            // dword aligned address.

            if (!(lpMRdup = (LPMETARECORD) LocalAlloc(LMEM_FIXED,
                        (UINT) lpMR->rdSize * sizeof(WORD) + sizeof(WORD))))
                break;
            lpMRtmp = (LPMETARECORD) &((PWORD) lpMRdup)[1];
            RtlCopyMemory((PBYTE) lpMRtmp,
                          (PBYTE) lpMR,
                          (UINT)  lpMR->rdSize * sizeof(WORD));

            if (hObject = CreatePalette((LPLOGPALETTE)&lpMRtmp->rdParm[0]))
                fStatus = AddToHandleTable(lpHandleTable, hObject, noObjs);
        }
        break;

        case (META_SELECTPALETTE & 255):
            if (hPal = lpHandleTable->objectHandle[lpMR->rdParm[0]])
                fStatus = SelectPalette(hdc, hPal, 0) != 0;
            break;

        case (META_REALIZEPALETTE & 255):
            fStatus = RealizePalette(hdc) != -1;
            break;

        case (META_SETPALENTRIES & 255):
        case (META_ANIMATEPALETTE & 255):
        {
            LPMETARECORD lpMRtmp;

            // Make the palette entry array dword aligned.  To do this,
            // lpMR has to fall on a non dword aligned even address so that
            // the palette entry array (&lpMR->rdParm[2]) will fall on the
            // dword aligned address.

            if (!(lpMRdup = (LPMETARECORD) LocalAlloc(LMEM_FIXED,
                        (UINT) lpMR->rdSize * sizeof(WORD) + sizeof(WORD))))
                break;
            lpMRtmp = (LPMETARECORD) &((PWORD) lpMRdup)[1];
            RtlCopyMemory((PBYTE) lpMRtmp,
                          (PBYTE) lpMR,
                          (UINT)  lpMR->rdSize * sizeof(WORD));

            // we know the palette being set is the current palette
            if (magic == META_SETPALENTRIES)
                fStatus = SetPaletteEntries(GetCurrentObject(hdc,OBJ_PAL),
                                            (UINT) lpMRtmp->rdParm[0],
                                            (UINT) lpMRtmp->rdParm[1],
                                            (LPPALETTEENTRY)&lpMRtmp->rdParm[2]
                                           ) != 0;
            else
                fStatus = AnimatePalette(GetCurrentObject(hdc,OBJ_PAL),
                                         (UINT) lpMR->rdParm[0],
                                         (UINT) lpMR->rdParm[1],
                                         (LPPALETTEENTRY)&lpMR->rdParm[2]);
        }
        break;

        case (META_RESIZEPALETTE & 255):
            fStatus = ResizePalette(GetCurrentObject(hdc,OBJ_PAL),
                                    (UINT) lpMR->rdParm[0]);
            break;

        case (META_SETDIBTODEV & 255):
        {
            LPBITMAPINFOHEADER lpBitmapInfo;
            DWORD              ColorSize;
            LPMETARECORD       lpMRtmp;

            /* if playing into another metafile, do direct copy */
            if (PlayIntoAMetafile(lpMR, hdc))
            {
                fStatus = TRUE;
                break;
            }

            // Make the bitmap info and bits dword aligned.  To do this,
            // lpMR has to fall on a dword aligned address so that
            // the bitmap info (&lpMR->rdParm[9]) and
            // the bitmap bits will fall on the dword aligned addresses.
            // Note that the size of the bitmap info is always a multiple
            // of 4.

            if (!(lpMRdup = (LPMETARECORD) LocalAlloc(LMEM_FIXED,
                        (UINT) lpMR->rdSize * sizeof(WORD))))
                break;
            lpMRtmp = lpMRdup;
            RtlCopyMemory((PBYTE) lpMRtmp,
                          (PBYTE) lpMR,
                          (UINT)  lpMR->rdSize * sizeof(WORD));

            lpBitmapInfo = (LPBITMAPINFOHEADER)&(lpMRtmp->rdParm[9]);

            if (lpBitmapInfo->biBitCount == 16 || lpBitmapInfo->biBitCount == 32)
                ColorSize = 3 * sizeof(DWORD);
            else if (lpBitmapInfo->biClrUsed)
                ColorSize = lpBitmapInfo->biClrUsed *
                             (DWORD)(lpMRtmp->rdParm[0] == DIB_RGB_COLORS ?
                                    sizeof(RGBQUAD) :
                                    sizeof(WORD));
            else if (lpBitmapInfo->biBitCount == 24)
                ColorSize = 0;
            else
                ColorSize = (DWORD)(1 << lpBitmapInfo->biBitCount) *
                             (DWORD)(lpMRtmp->rdParm[0] == DIB_RGB_COLORS ?
                                    sizeof(RGBQUAD) :
                                    sizeof(WORD));
            ColorSize = (ColorSize + 3) / 4 * 4;  // make sure it is aligned

            ColorSize += lpBitmapInfo->biSize;

            fStatus = SetDIBitsToDevice(hdc,
                                        (int) (SHORT) lpMRtmp->rdParm[8],
                                        (int) (SHORT) lpMRtmp->rdParm[7],
                                        (DWORD) (int) (SHORT)lpMRtmp->rdParm[6],
                                        (DWORD) (int) (SHORT)lpMRtmp->rdParm[5],
                                        (int) (SHORT) lpMRtmp->rdParm[4],
                                        (int) (SHORT) lpMRtmp->rdParm[3],
                                        (UINT) lpMRtmp->rdParm[2],
                                        (UINT) lpMRtmp->rdParm[1],
                                        (PBYTE)(((PBYTE)lpBitmapInfo) + ColorSize),
                                        (LPBITMAPINFO) lpBitmapInfo,
                                        (DWORD) lpMRtmp->rdParm[0]
                                       ) != 0;
        }
        break;

        case (META_STRETCHDIB & 255):
        {
            LPBITMAPINFOHEADER lpBitmapInfo;
            DWORD              ColorSize;
            LPMETARECORD       lpMRtmp;

            /* if playing into another metafile, do direct copy */
            if (PlayIntoAMetafile(lpMR, hdc))
            {
                fStatus = TRUE;
                break;
            }

            // Make the bitmap info and bits dword aligned.  To do this,
            // lpMR has to fall on a dword aligned address so that
            // the bitmap info (&lpMR->rdParm[11]) and
            // the bitmap bits will fall on the dword aligned addresses.
            // Note that the size of the bitmap info is always a multiple
            // of 4.

            if (!(lpMRdup = (LPMETARECORD) LocalAlloc(LMEM_FIXED,
                        (UINT) lpMR->rdSize * sizeof(WORD))))
                break;
            lpMRtmp = lpMRdup;
            RtlCopyMemory((PBYTE) lpMRtmp,
                          (PBYTE) lpMR,
                          (UINT)  lpMR->rdSize * sizeof(WORD));

            //
            // rdsize is SIZEOF_METARECORDHEADER/sizeof(WORD) + cw;
            // where cw is from MF16_RecordDIBits (11)
            //
            if (lpMR->rdSize > SIZEOF_METARECORDHEADER/sizeof(WORD) + 11)
            {
               lpBitmapInfo = (LPBITMAPINFOHEADER)&(lpMRtmp->rdParm[11]);

               if (lpBitmapInfo->biBitCount == 16 || lpBitmapInfo->biBitCount == 32)
                   ColorSize = 3 * sizeof(DWORD);
               else if (lpBitmapInfo->biClrUsed)
                   ColorSize = lpBitmapInfo->biClrUsed *
                                (DWORD)(lpMRtmp->rdParm[2] == DIB_RGB_COLORS ?
                                       sizeof(RGBQUAD) :
                                       sizeof(WORD));
               else if (lpBitmapInfo->biBitCount == 24)
                   ColorSize = 0;
               else
                   ColorSize = (DWORD)(1 << lpBitmapInfo->biBitCount) *
                                (DWORD)(lpMRtmp->rdParm[2] == DIB_RGB_COLORS ?
                                       sizeof(RGBQUAD) :
                                       sizeof(WORD));
               ColorSize = (ColorSize + 3) / 4 * 4;  // make sure it is aligned

               ColorSize += lpBitmapInfo->biSize;

            }
            else
            {
               lpBitmapInfo = NULL;
            }

            fStatus = StretchDIBits(hdc,
                                    (int) (SHORT) lpMRtmp->rdParm[10],
                                    (int) (SHORT) lpMRtmp->rdParm[9],
                                    (int) (SHORT) lpMRtmp->rdParm[8],
                                    (int) (SHORT) lpMRtmp->rdParm[7],
                                    (int) (SHORT) lpMRtmp->rdParm[6],
                                    (int) (SHORT) lpMRtmp->rdParm[5],
                                    (int) (SHORT) lpMRtmp->rdParm[4],
                                    (int) (SHORT) lpMRtmp->rdParm[3],
                                    lpBitmapInfo ? (LPBYTE)(((PBYTE)lpBitmapInfo) + ColorSize) : NULL,
                                    (LPBITMAPINFO) lpBitmapInfo,
                                    (DWORD) lpMRtmp->rdParm[2],
                                    MAKELONG(lpMRtmp->rdParm[0], lpMRtmp->rdParm[1])
                                   ) != ERROR;
        }
        break;

// Function that have new parameters on WIN32
// Or have DWORDs that stayed DWORDs; all other INTs to DWORDs

        case (META_PATBLT & 255):
            fStatus = PatBlt(hdc,
                             (int) (SHORT) lpMR->rdParm[5],
                             (int) (SHORT) lpMR->rdParm[4],
                             (int) (SHORT) lpMR->rdParm[3],
                             (int) (SHORT) lpMR->rdParm[2],
                             MAKELONG(lpMR->rdParm[0], lpMR->rdParm[1]));
            break;

        case (META_MOVETO & 255):
            fStatus = MoveToEx(hdc, (int)(SHORT)lpMR->rdParm[1], (int)(SHORT)lpMR->rdParm[0], NULL);
            break;

        case (META_RESTOREDC & 255):
            fStatus = RestoreDC(hdc, (int)(SHORT)lpMR->rdParm[0]);
            break;

        case (META_SETBKCOLOR & 255):
            fStatus = SetBkColor(hdc, *(COLORREF UNALIGNED *)lpMR->rdParm) != CLR_INVALID;
            break;

        case (META_SETTEXTCOLOR & 255):
            fStatus = SetTextColor(hdc, *(COLORREF UNALIGNED *)lpMR->rdParm) != CLR_INVALID;
            break;

        case (META_SETPIXEL & 255):
            fStatus = SetPixel(hdc,
                               (int) (SHORT) lpMR->rdParm[3],
                               (int) (SHORT) lpMR->rdParm[2],
                               *(COLORREF UNALIGNED *) lpMR->rdParm
                              ) != CLR_INVALID;
            break;

        case (META_SETMAPPERFLAGS & 255):
            fStatus = SetMapperFlags(hdc, *(DWORD UNALIGNED *)lpMR->rdParm) != GDI_ERROR;
            break;

        case (META_FLOODFILL & 255):
            fStatus = FloodFill(hdc,
                                (int) (SHORT) lpMR->rdParm[3],
                                (int) (SHORT) lpMR->rdParm[2],
                                *(COLORREF UNALIGNED *) lpMR->rdParm);
            break;

        case (META_EXTFLOODFILL & 255):
            fStatus = ExtFloodFill(hdc,
                                   (int) (SHORT) lpMR->rdParm[4],
                                   (int) (SHORT) lpMR->rdParm[3],
                                   *(COLORREF UNALIGNED *) &lpMR->rdParm[1],
                                   (UINT) lpMR->rdParm[0]);
            break;

        case (META_SCALEWINDOWEXT & 255):
            fStatus = ScaleWindowExtEx(hdc,
                                       (int)(SHORT)lpMR->rdParm[3],
                                       (int)(SHORT)lpMR->rdParm[2],
                                       (int)(SHORT)lpMR->rdParm[1],
                                       (int)(SHORT)lpMR->rdParm[0],
                                       NULL);
            break;

        case (META_SCALEVIEWPORTEXT & 255):
            fStatus = ScaleViewportExtEx(hdc,
                                         (int)(SHORT)lpMR->rdParm[3],
                                         (int)(SHORT)lpMR->rdParm[2],
                                         (int)(SHORT)lpMR->rdParm[1],
                                         (int)(SHORT)lpMR->rdParm[0],
                                         NULL);
            break;

        case (META_SETWINDOWORG & 255):
            fStatus = SetWindowOrgEx(hdc,
                                     (int)(SHORT)lpMR->rdParm[1],
                                     (int)(SHORT)lpMR->rdParm[0],
                                     (LPPOINT) NULL);
            break;

        case (META_SETWINDOWEXT & 255):
            fStatus = SetWindowExtEx(hdc,
                                     (int)(SHORT)lpMR->rdParm[1],
                                     (int)(SHORT)lpMR->rdParm[0],
                                     (LPSIZE) NULL);
            break;

        case (META_SETVIEWPORTORG & 255):
            fStatus = SetViewportOrgEx(hdc,
                                       (int)(SHORT)lpMR->rdParm[1],
                                       (int)(SHORT)lpMR->rdParm[0],
                                       (LPPOINT) NULL);
            break;

        case (META_SETVIEWPORTEXT & 255):
            fStatus = SetViewportExtEx(hdc,
                                       (int)(SHORT)lpMR->rdParm[1],
                                       (int)(SHORT)lpMR->rdParm[0],
                                       (LPSIZE) NULL);
            break;

        case (META_OFFSETWINDOWORG & 255):
            fStatus = OffsetWindowOrgEx(hdc,
                                        (int)(SHORT)lpMR->rdParm[1],
                                        (int)(SHORT)lpMR->rdParm[0],
                                        (LPPOINT) NULL);
            break;

        case (META_OFFSETVIEWPORTORG & 255):
            fStatus = OffsetViewportOrgEx(hdc,
                                          (int)(SHORT)lpMR->rdParm[1],
                                          (int)(SHORT)lpMR->rdParm[0],
                                          (LPPOINT) NULL);
            break;

        case (META_SETTEXTCHAREXTRA & 255):
            fStatus = SetTextCharacterExtra(hdc, (int)(SHORT)lpMR->rdParm[0]) != 0x80000000;
            break;

        case (META_SETTEXTALIGN & 255):
            fStatus = SetTextAlign(hdc, (UINT)lpMR->rdParm[0]) != GDI_ERROR;
            break;

        case (META_SAVEDC & 255):
            fStatus = (SaveDC(hdc) != 0);
            break;

        case (META_SELECTCLIPREGION & 255):
            // Win3.1 has never got this right except when the handle is 0.
            hObject =  (lpMR->rdParm[0] == 0)
                        ? 0
                        : lpHandleTable->objectHandle[lpMR->rdParm[0]];
            fStatus = (SelectClipRgn(hdc, hObject) != RGN_ERROR);
            break;

        case (META_SETBKMODE & 255):
            fStatus = (SetBkMode(hdc, (int)(SHORT)lpMR->rdParm[0]) != 0);
            break;

        case (META_SETMAPMODE & 255):
            fStatus = (SetMapMode(hdc, (int)(SHORT)lpMR->rdParm[0]) != 0);
            break;

        case (META_SETLAYOUT & 255):
            fStatus = (SetLayout(hdc, (DWORD)lpMR->rdParm[0]) != GDI_ERROR);
            break;

        case (META_SETPOLYFILLMODE & 255):
            fStatus = (SetPolyFillMode(hdc, (int)(SHORT)lpMR->rdParm[0]) != 0);
            break;

        case (META_SETROP2 & 255):
            fStatus = (SetROP2(hdc, (int)(SHORT)lpMR->rdParm[0]) != 0);
            break;

        case (META_SETSTRETCHBLTMODE & 255):
            fStatus = (SetStretchBltMode(hdc, (int)(SHORT)lpMR->rdParm[0]) != 0);
            break;

        case (META_LINETO & 255):
            fStatus = LineTo(hdc,
                             (int)(SHORT)lpMR->rdParm[1],
                             (int)(SHORT)lpMR->rdParm[0]);
            break;

        case (META_OFFSETCLIPRGN & 255):
            fStatus = OffsetClipRgn(hdc,
                                    (int)(SHORT)lpMR->rdParm[1],
                                    (int)(SHORT)lpMR->rdParm[0]
                                   ) != RGN_ERROR;
            break;

        case (META_SETTEXTJUSTIFICATION & 255):
            fStatus = SetTextJustification(hdc,
                                           (int)(SHORT)lpMR->rdParm[1],
                                           (int)(SHORT)lpMR->rdParm[0]);
            break;

        case (META_ELLIPSE & 255):
            fStatus = Ellipse(hdc,
                              (int)(SHORT)lpMR->rdParm[3],
                              (int)(SHORT)lpMR->rdParm[2],
                              (int)(SHORT)lpMR->rdParm[1],
                              (int)(SHORT)lpMR->rdParm[0]);
            break;

        case (META_RECTANGLE & 255):
            fStatus = Rectangle(hdc,
                                (int)(SHORT)lpMR->rdParm[3],
                                (int)(SHORT)lpMR->rdParm[2],
                                (int)(SHORT)lpMR->rdParm[1],
                                (int)(SHORT)lpMR->rdParm[0]);
            break;

        case (META_EXCLUDECLIPRECT & 255):
            fStatus = ExcludeClipRect(hdc,
                                      (int)(SHORT)lpMR->rdParm[3],
                                      (int)(SHORT)lpMR->rdParm[2],
                                      (int)(SHORT)lpMR->rdParm[1],
                                      (int)(SHORT)lpMR->rdParm[0]
                                     ) != RGN_ERROR;
            break;

        case (META_INTERSECTCLIPRECT & 255):
            fStatus = IntersectClipRect(hdc,
                                        (int)(SHORT)lpMR->rdParm[3],
                                        (int)(SHORT)lpMR->rdParm[2],
                                        (int)(SHORT)lpMR->rdParm[1],
                                        (int)(SHORT)lpMR->rdParm[0]
                                       ) != RGN_ERROR;
            break;

        case (META_ROUNDRECT & 255):
            fStatus = RoundRect(hdc,
                                (int)(SHORT)lpMR->rdParm[5],
                                (int)(SHORT)lpMR->rdParm[4],
                                (int)(SHORT)lpMR->rdParm[3],
                                (int)(SHORT)lpMR->rdParm[2],
                                (int)(SHORT)lpMR->rdParm[1],
                                (int)(SHORT)lpMR->rdParm[0]
                               );
            break;

        case (META_ARC & 255):
            fStatus = Arc(hdc,
                          (int)(SHORT)lpMR->rdParm[7],
                          (int)(SHORT)lpMR->rdParm[6],
                          (int)(SHORT)lpMR->rdParm[5],
                          (int)(SHORT)lpMR->rdParm[4],
                          (int)(SHORT)lpMR->rdParm[3],
                          (int)(SHORT)lpMR->rdParm[2],
                          (int)(SHORT)lpMR->rdParm[1],
                          (int)(SHORT)lpMR->rdParm[0]
                         );
            break;

        case (META_CHORD & 255):
            fStatus = Chord(hdc,
                            (int)(SHORT)lpMR->rdParm[7],
                            (int)(SHORT)lpMR->rdParm[6],
                            (int)(SHORT)lpMR->rdParm[5],
                            (int)(SHORT)lpMR->rdParm[4],
                            (int)(SHORT)lpMR->rdParm[3],
                            (int)(SHORT)lpMR->rdParm[2],
                            (int)(SHORT)lpMR->rdParm[1],
                            (int)(SHORT)lpMR->rdParm[0]
                           );
            break;

        case (META_PIE & 255):
            fStatus = Pie(hdc,
                          (int)(SHORT)lpMR->rdParm[7],
                          (int)(SHORT)lpMR->rdParm[6],
                          (int)(SHORT)lpMR->rdParm[5],
                          (int)(SHORT)lpMR->rdParm[4],
                          (int)(SHORT)lpMR->rdParm[3],
                          (int)(SHORT)lpMR->rdParm[2],
                          (int)(SHORT)lpMR->rdParm[1],
                          (int)(SHORT)lpMR->rdParm[0]
                         );
            break;

        case (META_SETRELABS & 255):
            ERROR_ASSERT(FALSE, "PlayMetaFileRecord: unsupported META_SETRELABS record\n");
            fStatus = TRUE;
            break;

#if 0
        case (META_CREATEBITMAP & 255):
        case (META_CREATEBITMAPINDIRECT & 255):
        case (META_CREATEBRUSH & 255):
        case (META_ABORTDOC & 255):
        case (META_ENDPAGE & 255):
        case (META_ENDDOC & 255):
        case (META_RESETDC & 255):
        case (META_STARTDOC & 255):
        case (META_STARTPAGE & 255):
            // not created or playbacked on Win3.1!
            ASSERTGDI(FALSE, "PlayMetaFileRecord: unsupported record\n");
            fStatus = TRUE;
            break;
#endif // 0

    case 0:         // End of metafile record
        fStatus = TRUE;
            break;

        default:
            VERIFYGDI(FALSE, "PlayMetaFileRecord: unknown record\n");
 #if DBG
        DbgPrint("Record %lx pMFRecord %p magic %X\n", curRecord, lpMR, magic);
#endif
            fStatus = TRUE;
            break;

    } // switch (magic & 255)

    if (lpMRdup)
        if (LocalFree((HANDLE) lpMRdup))
            ASSERTGDI(FALSE, "LocalFree failed");

#if DBG
    if (!fStatus)
    {
        DbgPrint("PlayMetaFileRecord Record %lx pMFRecord %p magic %X\n", curRecord, lpMR, magic);
        ERROR_ASSERT(FALSE, "PlayMetaFileRecord Failing\n");
    }
#endif

    return(fStatus);
}

/****************************** Internal Function **************************\
* AddToHandleTable
*
* Adds an object to the metafile table of objects
*
*
\***************************************************************************/

BOOL AddToHandleTable(LPHANDLETABLE lpHandleTable, HANDLE hObject, UINT noObjs)
{
    UINT    ii;

    PUTS("AddToHandleTable\n");

    if (lpHandleTable == (LPHANDLETABLE) NULL)
    {
        ASSERTGDI(FALSE, "AddToHandleTable: lpHT is NULL\n");
        return(FALSE);
    }

    /* linear search through table for first open slot */
    for (ii = 0; ((lpHandleTable->objectHandle[ii] != NULL) && (ii < noObjs));
            ++ii);

    if (ii < noObjs)                     /* ok index */
    {
        lpHandleTable->objectHandle[ii] = hObject;
        return (TRUE);
    }
    else
    {
        ASSERTGDI(FALSE, "AddToHandleTable: Too many objects in table\n");
        return(FALSE);
    }
}

BOOL IsValidMetaHeader16(PMETAHEADER pMetaHeader)
{
    BOOL            status;

    PUTS("IsValidMetaHeader16\n");

    status = (
               (pMetaHeader->mtType == MEMORYMETAFILE ||
                pMetaHeader->mtType == DISKMETAFILE) &&
               (pMetaHeader->mtHeaderSize == (sizeof(METAHEADER)/sizeof(WORD))) &&
               ((pMetaHeader->mtVersion == METAVERSION300) ||
                   (pMetaHeader->mtVersion ==METAVERSION100))
             );

    ERROR_ASSERT(status, "IsValidMetaHeader16 is failing\n");

    return status;
}

/****************************** Internal Function **************************\
* CreateBitmapForDC (HDC hMemDC, LPBITMAPINFOHEADER lpDIBInfo)
*
* This routine takes a memory device context and a DIB bitmap, creates a
* compatible bitmap for the DC and fills it with the bits from the DIB
* converting to the device dependent format). The pointer to the DIB bits
* start immediately after the color table in the INFO header.
*
* The routine returns the handle to the bitmap with the bits filled in if
* everything goes well else it returns NULL.
\***************************************************************************/

HANDLE CreateBitmapForDC (HDC hMemDC, LPBITMAPINFOHEADER lpDIBInfo)
{
    HBITMAP hBitmap ;
    LPBYTE  lpDIBits ;

    PUTS("CreateBitmapForDC\n");

    ASSERTGDI(!((ULONG_PTR) lpDIBInfo & 0x3), "CreateBitmapForDC: dword alignment error\n");

    /* preserve monochrome if it started out as monochrome
    ** and check for REAL Black&white monochrome as opposed
    ** to a 2-color DIB
    */
    if (IsDIBBlackAndWhite(lpDIBInfo))
        hBitmap = CreateBitmap ((WORD)lpDIBInfo->biWidth,
                        (WORD)lpDIBInfo->biHeight,
                        1, 1, (LPBYTE) NULL);
    else
    /* otherwise, make a compatible bitmap */
        hBitmap = CreateCompatibleBitmap (hMemDC,
                    (WORD)lpDIBInfo->biWidth,
                    (WORD)lpDIBInfo->biHeight);

    if (!hBitmap)
        goto CreateBitmapForDCErr ;

    /* take a pointer past the header of the DIB, to the start of the color
       table */
    lpDIBits = (LPBYTE) lpDIBInfo + lpDIBInfo->biSize;

    /* take the pointer past the color table */
    lpDIBits += GetSizeOfColorTable (lpDIBInfo) ;

    /* get the bits from the DIB into the Bitmap */
    if (!SetDIBits (hMemDC, hBitmap, 0, (WORD)lpDIBInfo->biHeight,
                    lpDIBits, (LPBITMAPINFO)lpDIBInfo, DIB_RGB_COLORS))
    {
        if (!DeleteObject(hBitmap))
            ASSERTGDI(FALSE, "CreateBitmapForDC: DeleteObject(hBitmap) Failed\n");
        goto CreateBitmapForDCErr ;
    }

   /* return success */
   return (hBitmap) ;

CreateBitmapForDCErr:

   /* returm failure for function */
   return (NULL);
}


/****************************** Internal Function **************************\
* GetSizeOfColorTable (LPBITMAPINFOHEADER lpDIBInfo)
*
* Returns the number of bytes in the color table for the giving info header
*
\***************************************************************************/

WORD GetSizeOfColorTable (LPBITMAPINFOHEADER lpDIBInfo)
{
    PUTS("GetSizeOfColorTable\n");

    ASSERTGDI(!((ULONG_PTR) lpDIBInfo & 0x3), "GetSizeOfColorTable: dword alignment error\n");

    if (lpDIBInfo->biBitCount == 16 || lpDIBInfo->biBitCount == 32)
        return(3 * sizeof(DWORD));

    if (lpDIBInfo->biClrUsed)
        return((WORD)lpDIBInfo->biClrUsed * (WORD)sizeof(RGBQUAD));

    if (lpDIBInfo->biBitCount < 16)
        return((1 << lpDIBInfo->biBitCount) * sizeof(RGBQUAD));
    else
        return(0);
}

/***************************** Public Function ****************************\
* BOOL APIENTRY DeleteMetaFile(hmf)
*
* Frees a metafile handle.
*
* Effects:
*
\***************************************************************************/

BOOL APIENTRY DeleteMetaFile(HMETAFILE hmf)
{
    PMETAFILE16 pmf16;

    PUTS("DeleteMetaFile\n");

    pmf16 = GET_PMF16(hmf);
    if (pmf16 == NULL)
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

// Free the metafile and its handle.

    vFreeMF16(pmf16);
    bDeleteHmf16(hmf);
    return(TRUE);
}

/***************************** Public Function ****************************\
* HMETAFILE APIENTRY GetMetaFileW(pszwFilename)
*
* Returns a metafile handle for a disk based metafile.
*
* Effects:
*
* History:
*  Fri May 15 14:11:22 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\***************************************************************************/

HMETAFILE GetMetaFileA(LPCSTR pszFileName)
{
    UINT  cch;
    WCHAR awch[MAX_PATH];

    cch = strlen(pszFileName)+1;

    if (cch > MAX_PATH)
    {
        ERROR_ASSERT(FALSE, "GetMetaFileA filename too long");
        GdiSetLastError(ERROR_FILENAME_EXCED_RANGE);
        return ((HMETAFILE)0);
    }
    vToUnicodeN(awch, MAX_PATH, pszFileName, cch);

    return (GetMetaFileW(awch));
}

HMETAFILE APIENTRY GetMetaFileW(LPCWSTR pwszFileName)
{
    PMETAFILE16 pmf16;
    HMETAFILE   hmf;

    PUTS("GetMetaFileW\n");

// Allocate and initialize a metafile.

    if (!(pmf16 = pmf16AllocMF16(0, 0, (PDWORD) NULL, (LPWSTR) pwszFileName)))
        return((HMETAFILE) 0);

    ASSERTGDI(pmf16->metaHeader.mtType == DISKMETAFILE,
        "GetMetaFileW: Bad mtType\n");

// Allocate a local handle.

    hmf = hmf16Create(pmf16);
    if (!hmf)
    {
        vFreeMF16(pmf16);
    }

// Return the metafile handle.

    return(hmf);
}

/***************************** Internal Function **************************\
* BOOL FAR PASCAL PlayIntoAMetafile
*
* if this record is being played into another metafile, simply record
* it into that metafile, without hassling with a real playing.
*
* Returns: TRUE if record was played (copied) into another metafile
*          FALSE if destination DC was a real (non-meta) DC
*
* Effects: ?
*
* Warnings: ?
*
\***************************************************************************/

BOOL PlayIntoAMetafile(LPMETARECORD lpMR, HDC hdcDest)
{
    PUTS("PlayIntoAMetafile\n");

    if (LO_TYPE(hdcDest) != LO_METADC16_TYPE)
        return(FALSE);

// If a metafile is retrieved with GetWinMetaFileBits, it may contain
// an embedded enhanced metafile.  Do not include the enhanced metafile
// if we are playing the metafile to another metafile.

    if (IS_META_ESCAPE_ENHANCED_METAFILE((PMETA_ESCAPE_ENHANCED_METAFILE) lpMR))
        return(TRUE);

    // the size is the same minus 3 words for the record header
    return(RecordParms(hdcDest, (DWORD)lpMR->rdFunction, (DWORD)lpMR->rdSize - 3,
            (LPWORD)&(lpMR->rdParm[0])));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\nlsconv.h ===
/******************************Module*Header*******************************\
* Module Name: nlsconv.h
*
* Created: 08-Sep-1991 14:01:23
* Author: Bodin Dresevic [BodinD]
* 02-Feb-1993 00:32:35
* Copyright (c) 1991-1999 Microsoft Corporation.
*
* (General description of its use)
*
\**************************************************************************/


#include "winuserp.h"   // nls conversion routines
#include <crt\stdlib.h>      // c rtl library include file off of nt\public\sdk\inc

/******************************Public*Macro******************************\
* bToASCIIN(pszDst, cch, pwszSrc, cwch)
*
* Calls the Rtl function that convert multi-byte ANSI to Unicode via
* the current codepage.  Note that this macro does not guarantee a
* terminating NULL for the destination.
*
* Returns:
*   TRUE if converted successfully, FALSE otherwise.
*
\**************************************************************************/

#define bToASCII_N(pszDst, cch, pwszSrc, cwch)                          \
    (                                                                   \
        NT_SUCCESS(RtlUnicodeToMultiByteN((PCH)(pszDst), (ULONG)(cch),  \
              (PULONG)NULL,(PWSZ)(pwszSrc), (ULONG)((cwch)*sizeof(WCHAR))))     \
    )


/******************************Public*Macro******************************\
* vToUnicodeN(awchDst, cwchDst, achSrc, cchSrc)
*
* Calls the Rtl function that convert Unicode to multi-byte ANSI via
* the current codepage.  Note that this macro does not guarantee a
* terminating NULL for the destination.
*
* Returns:
*   Nothing.  Should not be able to fail.
*
\**************************************************************************/

#if DBG
#define vToUnicodeN( awchDst, cwchDst, achSrc, cchSrc )                 \
    {                                                                   \
        NTSTATUS st =                                                   \
        RtlMultiByteToUnicodeN(                                         \
            (PWSZ)(awchDst),(ULONG)((cwchDst)*sizeof(WCHAR)),           \
            (PULONG)NULL,(PSZ)(achSrc),(ULONG)(cchSrc));                        \
                                                                        \
        ASSERTGDI(NT_SUCCESS(st),                                       \
            "gdi32!vToUnicodeN(MACRO): Rtl func. failed\n");            \
    }
#else
#define vToUnicodeN( awchDst, cwchDst, achSrc, cchSrc )                 \
    {                                                                   \
        RtlMultiByteToUnicodeN(                                         \
            (PWSZ)(awchDst),(ULONG)((cwchDst)*sizeof(WCHAR)),           \
            (PULONG)NULL,(PSZ)(achSrc),(ULONG)(cchSrc));                        \
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\nlsconv.c ===
/******************************Module*Header*******************************\
* Module Name: nlsconv.c                                                   *
*                                                                          *
* NLS conversion routines.                                                 *
*                                                                          *
* Created: 08-Sep-1991 15:56:30                                            *
* Author: Bodin Dresevic [BodinD]                                          *
*                                                                          *
* Copyright (c) 1991-1999 Microsoft Corporation                            *
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

/******************************Public*Routine******************************\
* bGetANSISetMap                                                           *
*                                                                          *
* Tries to get a simple translation table from ANSI to UNICODE.  Returns   *
* TRUE on success.  Sets the gbDBCSCodePage flag if it thinks the char set *
* MIGHT be DBCS.                                                           *
*                                                                          *
*                                                                          *
*  Mon 11-Jan-1993 14:13:34 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.  I'm clearly assuming that by the time this is called, the     *
* char set is well defined, and will not change.                           *
\**************************************************************************/

WCHAR *gpwcANSICharSet = NULL;
WCHAR *gpwcDBCSCharSet = NULL;

BOOL bGetANSISetMap()
{
    CHAR     ch[256];
    ULONG    *pul;
    ULONG    ii,jj;
    NTSTATUS st;
    ULONG    cjResult;
    WCHAR   *pwc;
    WCHAR    *pwcSBC;

// See if we know the answers already.  (The client should not have called!)

    if (gpwcANSICharSet != (WCHAR *) NULL)
        return(TRUE);

// Create a mapping.

// Make an ANSI source char set.  This funny way of initialization takes
// about 180 instructions to execute rather than over 1000.

    pul = (ULONG *) ch;

    for (ii=0x03020100L,jj=0; jj<64; jj+=4)
    {
        pul[jj+0] = ii;
        ii += 0x04040404L;
        pul[jj+1] = ii;
        ii += 0x04040404L;
        pul[jj+2] = ii;
        ii += 0x04040404L;
        pul[jj+3] = ii;
        ii += 0x04040404L;
    }

// Allocate the UNICODE buffer but don't write the pointer in until the
// table is valid, in case we're racing another thread.

    pwc = LOCALALLOC(512 * sizeof(WCHAR));
    pwcSBC = &pwc[256];
    
    if (pwc == (WCHAR *) NULL)
        return(FALSE);

// Convert the characters.

    pwc[0] = 0;
    st = RtlMultiByteToUnicodeN
         (
            &pwc[1],                // OUT PWCH UnicodeString
            255 * sizeof(WCHAR),    // IN ULONG MaxBytesInUnicodeString
            &cjResult,              // OUT PULONG BytesInUnicodeString
            &ch[1],                 // IN PCH MultiByteString
            255                     // IN ULONG BytesInMultiByteString
         );

    if( !NT_SUCCESS(st) )
    {
    // Clean up and forget about accelerations.

        WARNING("GDI32: RtlMultiByteToUnicodeN error.");
        LOCALFREE(pwc);
        return(FALSE);
    }

    if( cjResult != 255 * sizeof(WCHAR) )
    {
    // There must be a DBCS code page so gpwcANSIMap takes on new meaning.
    // It is used for fonts with ANSI,OEM, and SYMBOL charsets.  Also,
    // another table, gpwcDBCS is constructed that is used to map the SBCS
    // of SHIFT-JIS fonts.

        WARNING("GDI32:Assuming DBCS code page.\n");

        st = MultiByteToWideChar
             (
                1252,       // code page to use
                0,          // flags
                &ch[1],     // characters to translate
                255,        // number of multibyte characters
                &pwc[1],    // unicode values of characters
                255         // number of wide characters
             );

        if( !NT_SUCCESS(st) )
        {
        // Clean up and forget about accelerations.

            WARNING("GDI32: MultiByteToWideChar error.");
            LOCALFREE(pwc);
            return(FALSE);
        }

    // Okay now make a table for SBC bytes.  Mark DBCS lead bytes
    // with 0xFFFF.

        for( jj = 0; jj < 256; jj++ )
        {
            if( IsDBCSLeadByte( (UCHAR)jj ))
            {
                pwcSBC[jj] = (WCHAR) 0xFFFF;
            }
            else
            {
                st = RtlMultiByteToUnicodeN
                     (
                        &pwcSBC[jj],
                        sizeof(WCHAR),
                        &cjResult,
                        &ch[jj],
                        1
                     );

                if( !NT_SUCCESS(st) )
                {
                    WARNING("GDI32: RtlMultByteToUnicodeN error.");
                    LOCALFREE(pwc);
                    return(FALSE);
                }

            }
        }

    }

// The table is good, jam it in.  Watch out for another thread running this
// routine simultaneously.

    ENTERCRITICALSECTION(&semLocal);
    {
        if (gpwcANSICharSet == (WCHAR *) NULL)
        {
            gpwcANSICharSet = pwc;
            gpwcDBCSCharSet = pwcSBC;
            pwc = (WCHAR *) NULL;
        }
    }
    LEAVECRITICALSECTION(&semLocal);

// If we collided with another thread, clean up our extra space.

    if (pwc != (WCHAR *) NULL)
        LOCALFREE(pwc);

// At this point we have a valid mapping.

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\mfrec16.h ===
/******************************Module*Header*******************************\
* Module Name: MfRec16.h                                                   *
*									   *
* Definitions needed for client side recording of 16 bit metafiles.        *
*									   *
* Created: 14-Nov-1991                                                     *
* Author: John Colleran [johnc]                                            *
*									   *
* Copyright (c) 1991-1999 Microsoft Corporation				   *
\**************************************************************************/

BOOL MF16_RecordParms1(HDC hdc, WORD Func);
BOOL MF16_RecordParms2(HDC hdc, int parm2, WORD Func);
BOOL MF16_RecordParms3(HDC hdc, int parm2, int parm3, WORD Func);
BOOL MF16_RecordParms5(HDC hdc, int parm2, int parm3, int parm4, int parm5, WORD Func);
BOOL MF16_RecordParms7(HDC hdc, int parm2, int parm3, int parm4, int parm5, int parm6, int parm7, WORD Func);
BOOL MF16_RecordParms9(HDC hdc, int parm2, int parm3, int parm4, int parm5,
        int parm6, int parm7, int parm8, int parm9, WORD Func);

BOOL MF16_RecordParmsD(HDC hdc, DWORD d1, WORD Func);
BOOL MF16_RecordParmsWWD(HDC hdc, WORD w1, WORD w2, DWORD d3, WORD Func);
BOOL MF16_RecordParmsWWDW(HDC hdc, WORD w1, WORD w2, DWORD d3, WORD w4, WORD Func);
BOOL MF16_RecordParmsWWWWD(HDC hdc, WORD w1, WORD w2, WORD w3, WORD w4, DWORD d5, WORD Func);
BOOL MF16_RecordParmsPoly(HDC hdc, LPPOINT lpPoint, INT nCount, WORD Func);
BOOL MF16_DrawRgn(HDC hdc, HRGN hrgn, HBRUSH hBrush, INT cx, INT cy, WORD Func);

BOOL MF16_BitBlt(HDC hdcDest, int x, int y, int nWidth, int nHeight,
        HDC hdcSrc, int xSrc, int ySrc, DWORD rop);
BOOL MF16_DeleteObject(HANDLE h);
BOOL MF16_ExtTextOut(HDC hdc, INT x, INT y, UINT flOptions, CONST RECT *lpRect,
        LPCSTR lpString, INT nCount, CONST INT *lpDX, BOOL bUnicode);
BOOL MF16_PolyTextOut(HDC hdc, CONST POLYTEXTA *ppta, int cpta, BOOL bUnicode);
BOOL MF16_PolyPolygon(HDC hdc, CONST POINT *lpPoint, CONST INT *lpPolyCount, int nCount);
BOOL MF16_RealizePalette(HDC hdc);
BOOL MF16_ResizePalette(HPALETTE hPal, UINT nCount);
BOOL MF16_AnimatePalette(HPALETTE hpal, UINT iStart, UINT cEntries, CONST PALETTEENTRY *pPalEntries);
HANDLE MF16_SelectObject(HDC hdc, HANDLE h);
BOOL MF16_SelectClipRgn(HDC hdc, HRGN hrgn, int iMode);
BOOL MF16_SelectPalette(HDC hdc, HPALETTE hpal);
BOOL MF16_StretchBlt(HDC hdcDest, int x, int y, int nWidth, int nHeight,
        HDC hdcSrc, int xSrc, int ySrc, int nSrcWidth, int nSrcHeight, DWORD rop);
BOOL MF16_TextOut(HDC hdc, INT x, INT y, LPCSTR lpString, int nCount, BOOL bUnicode);
BOOL MF16_RecordDIBits(HDC hdcDst, int xDst, int yDst, int cxDst, int cyDst,
    int xDib, int yDib, int cxDib, int cyDib, DWORD iStartScan, DWORD cScans,
    DWORD cbBitsDib, CONST VOID * pBitsDib, DWORD cbBitsInfoDib, CONST BITMAPINFO *pBitsInfoDib, 
    DWORD iUsageDib, DWORD rop, DWORD mrType);
BOOL MF16_Escape(HDC hdc, int nEscape, int nCount, LPCSTR lpInData, LPVOID lpOutData);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\object.c ===
/******************************Module*Header*******************************\
* Module Name: object.c                                                    *
*                                                                          *
* GDI client side stubs which deal with object creation and deletion.      *
*                                                                          *
* Created: 30-May-1991 21:56:51                                            *
* Author: Charles Whitmer [chuckwh]                                        *
*                                                                          *
* Copyright (c) 1991-1999 Microsoft Corporation                            *
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

extern PGDIHANDLECACHE pGdiHandleCache;

ULONG gLoHandleType[GDI_CACHED_HADNLE_TYPES] = {
                LO_BRUSH_TYPE  ,
                LO_PEN_TYPE    ,
                LO_REGION_TYPE ,
                LO_FONT_TYPE
                };

ULONG gHandleCacheSize[GDI_CACHED_HADNLE_TYPES] = {
                CACHE_BRUSH_ENTRIES ,
                CACHE_PEN_ENTRIES   ,
                CACHE_REGION_ENTRIES,
                CACHE_LFONT_ENTRIES
                };

ULONG gCacheHandleOffsets[GDI_CACHED_HADNLE_TYPES] = {
                                                        0,
                                                        CACHE_BRUSH_ENTRIES,
                                                        (
                                                            CACHE_BRUSH_ENTRIES +
                                                            CACHE_PEN_ENTRIES
                                                        ),
                                                        (
                                                            CACHE_BRUSH_ENTRIES +
                                                            CACHE_PEN_ENTRIES   +
                                                            CACHE_PEN_ENTRIES
                                                        )
                                                      };

/******************************Public*Routine******************************\
* hGetPEBHandle
*
*   Try to allocate a handle from the PEB handle cache
*
* Aruguments:
*
*   HandleType - type of cached handle to allocate
*
* Return Value:
*
*   handle or NULL if none available
*
* History:
*
*    31-Jan-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

HANDLE
hGetPEBHandle(
   HANDLECACHETYPE HandleType,
   ULONG           lbColor
   )
{
    HANDLE     hret = NULL;
    BOOL       bStatus;
    PBRUSHATTR pBrushattr;
    OBJTYPE    ObjType = BRUSH_TYPE;

#if !defined(_GDIPLUS_)

    ASSERTGDI(
               (
                (HandleType == BrushHandle) ||
                (HandleType == PenHandle) ||
                (HandleType == RegionHandle) ||
                (HandleType == LFontHandle)
               ),
               "hGetPEBHandle: illegal handle type");


    if (HandleType == RegionHandle)
    {
        ObjType = RGN_TYPE;
    }

    LOCK_HANDLE_CACHE(pGdiHandleCache,NtCurrentTeb(),bStatus);

    if (bStatus)
    {
        //
        // is a handle of the requested type available
        //

        if (pGdiHandleCache->ulNumHandles[HandleType] > 0)
        {
            ULONG   Index = gCacheHandleOffsets[HandleType];
            KHANDLE *pHandle,*pMaxHandle;

            //
            // calc starting index of handle type in PEB,
            // convert to address for faster linear search
            //

            pHandle = &(pGdiHandleCache->Handle[Index]);
            pMaxHandle = pHandle + gHandleCacheSize[HandleType];

            //
            // search PEB for non-NULL handle of th correct type
            //

            while (pHandle != pMaxHandle)
            {
                if (*pHandle != NULL)
                {
                    hret = *pHandle;

                    ASSERTGDI((gLoHandleType[HandleType] == LO_TYPE((ULONG_PTR)hret)),
                               "hGetPEBHandle: handle LO_TYPE mismatch");

                    *pHandle = NULL;
                    pGdiHandleCache->ulNumHandles[HandleType]--;

                    PSHARED_GET_VALIDATE(pBrushattr,hret,ObjType);

                    //
                    // setup the fields
                    //

                    if (
                        (pBrushattr) &&
                        ((pBrushattr->AttrFlags & (ATTR_CACHED | ATTR_TO_BE_DELETED | ATTR_CANT_SELECT))
                         == ATTR_CACHED)
                       )
                    {
                        //
                        // set brush flag which indicates this brush
                        // has never been selected into a dc. if this flag
                        // is still set in deleteobject then it is ok to
                        // put the brush on the teb.
                        //

                        pBrushattr->AttrFlags &= ~ATTR_CACHED;

                        if ((HandleType == BrushHandle) && (pBrushattr->lbColor != lbColor))
                        {
                            pBrushattr->AttrFlags |= ATTR_NEW_COLOR;
                            pBrushattr->lbColor = lbColor;
                        }
                    }
                    else
                    {
                        //
                        // Bad brush on PEB
                        //

                        WARNING ("pBrushattr == NULL, bad handle on TEB/PEB! \n");

                        //DeleteObject(hbr);

                        hret = NULL;
                    }

                    break;
                }

                pHandle++;
            }
        }

        UNLOCK_HANDLE_CACHE(pGdiHandleCache);
    }

#endif

    return(hret);
}

/******************************Public*Routine******************************\
* GdiPlayJournal
*
* Plays a journal file to an hdc.
*
* History:
*  31-Mar-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL WINAPI GdiPlayJournal
(
HDC hDC,
LPWSTR pwszName,
DWORD iStart,
DWORD iEnd,
int   iDeltaPriority
)
{
    WARNING("GdiPlayJournalCalled but no longer implemented\n");
    return(FALSE);
}


/******************************Public*Routine******************************\
* gdiPlaySpoolStream
*
* Stub of Chicago version of GdiPlayJournal
*
* History:
*  4-29-95 Gerrit van Wingerden
* Wrote it.
\**************************************************************************/


HDC gdiPlaySpoolStream(
   LPSTR lpszDevice,
   LPSTR lpszOutput,
   LPSTR lpszSpoolFile,
   DWORD JobId,
   LPDWORD lpcbBuf,
   HDC hDC )
{
    USE(lpszDevice);
    USE(lpszOutput);
    USE(lpszSpoolFile);
    USE(JobId);
    USE(lpcbBuf);
    USE(hDC);

    GdiSetLastError(ERROR_CALL_NOT_IMPLEMENTED);

    return(hDC);

}

/******************************Public*Routine******************************\
*
* History:
*  08-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

NTSTATUS
PrinterQueryRoutine
(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
)
{
    //
    // If the context value is NULL, then store the length of the value.
    // Otherwise, copy the value to the specified memory.
    //

    if (Context == NULL)
    {
        *(PULONG)EntryContext = ValueLength;
    }
    else
    {
        RtlCopyMemory(Context, ValueData, (int)ValueLength);
    }

    return(STATUS_SUCCESS);
}


/******************************Public*Routine******************************\
* pdmwGetDefaultDevMode()
*
* History:
*  08-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

PDEVMODEW pdmwGetDefaultDevMode(
    HANDLE          hSpooler,
    PUNICODE_STRING pustrDevice,    // device name
    PVOID          *ppvFree         // *ppvFree must be freed by the caller
    )
{
    PDEVMODEW pdmw = NULL;
    int       cj;
    PWSZ      pwszDevice = pustrDevice ? pustrDevice->Buffer : NULL;

// see if we found it in the registry.  If not, we need to get the default from
// the spooler.

    cj = 0;

    (*fpGetPrinterW)(hSpooler,2,NULL,0,&cj);

    if (cj && (*ppvFree = LOCALALLOC(cj)))
    {
    // we've loaded the spooler, gotten a spooler handle, gotten the size,
    // and allocated the buffer.  Now lets get the data.

        if ((*fpGetPrinterW)(hSpooler,2,*ppvFree,cj,&cj))
        {
            pdmw = ((PRINTER_INFO_2W *)*ppvFree)->pDevMode;
        }
        else
        {
            LOCALFREE(*ppvFree);
            *ppvFree = NULL;
        }
    }

    return(pdmw);
}


/******************************Public*Routine******************************\
* hdcCreateDCW                                                             *
*                                                                          *
* Client side stub.  Allocates a client side LDC as well.                  *
*                                                                          *
* Note that it calls the server only after all client side stuff has       *
* succeeded, we don't want to ask the server to clean up.                  *
*                                                                          *
* History:                                                                 *
*  Sat 01-Jun-1991 16:13:22 -by- Charles Whitmer [chuckwh]                 *
*  8-18-92 Unicode enabled and combined with CreateIC                      *
* Wrote it.                                                                *
\**************************************************************************/

HDC hdcCreateDCW(
    PUNICODE_STRING pustrDevice,
    PUNICODE_STRING pustrPort,
    CONST DEVMODEW *pdm,
    BOOL            bDisplay,
    BOOL            bIC
)
{
    HDC       hdc      = NULL;
    PLDC      pldc     = NULL;
    PVOID     pvFree   = NULL;
    PWSZ      pwszPort = NULL;
    HANDLE    hSpooler = NULL;
    PUMPD     pUMPD    = NULL;
    PDEVMODEW pdmAlt   = NULL;
    PRINTER_DEFAULTSW defaults;
    KERNEL_PUMDHPDEV pUMdhpdev = NULL;
    BOOL      bDocEvent = FALSE;

    //
    // if it is not the display...
    //

    if (!bDisplay)
    {
        //
        // quick out if pustrDevice is NULL
        //

        if (pustrDevice == (PUNICODE_STRING)NULL)
        {
            return((HDC)NULL);
        }

        // Load the spooler and get a spool handle

        if (BLOADSPOOLER)
        {

            // Open the printer with the default data type.  When we do
            // a StartDoc we will then try to to a StartDocPrinter with data type
            // EMF if that suceeds will will mark the DC as an EMF dc.  Othewise
            // we will try again, this time doing a StartDocPrinter with data type
            // raw

            defaults.pDevMode = (LPDEVMODEW) pdm;
            defaults.DesiredAccess = PRINTER_ACCESS_USE;
            defaults.pDatatype = L"RAW";

            // open the spooler and note if it is spooled or not

            (*fpOpenPrinterW)((LPWSTR)pustrDevice->Buffer,&hSpooler,&defaults);

            if (hSpooler)
            {
                // Load user-mode printer driver, if applicable

                if (! LoadUserModePrinterDriver(hSpooler,  (LPWSTR) pustrDevice->Buffer, &pUMPD, &defaults))
                    goto MSGERROR;

                // and we don't have a devmode yet, try to get one.

                if (pdm == NULL)
                {
                    pdm = pdmwGetDefaultDevMode(hSpooler,pustrDevice,&pvFree);
                }


                // now see if we need to call DocumentEvent

                if (fpDocumentEvent)
                {
                    int      iDocEventRet;
                    DOCEVENT_CREATEDCPRE    docEvent;

                    docEvent.pszDriver = 0;
                    docEvent.pszDevice = pustrDevice->Buffer;
                    docEvent.pdm = (PDEVMODEW)pdm;
                    docEvent.bIC = bIC;

                    iDocEventRet = DocumentEventEx(pUMPD,
                                                   hSpooler,
                                                   0,
                                                   DOCUMENTEVENT_CREATEDCPRE,
                                                   sizeof(docEvent),
                                                   (PVOID)&docEvent,
                                                   sizeof(pdmAlt),
                                                   (PVOID)&pdmAlt);
                    
                    if (iDocEventRet == DOCUMENTEVENT_FAILURE)
                    {
                        goto MSGERROR;
                    }
                    
                    bDocEvent = TRUE;

                    if (pdmAlt)
                        pdm = pdmAlt;
                }
            }
        }
    }

    hdc = NtGdiOpenDCW(pustrDevice,
                       (PDEVMODEW)pdm,
                       pustrPort,
                       (ULONG)bIC ? DCTYPE_INFO : DCTYPE_DIRECT,
                       (pUMPD == NULL) ? NULL : hSpooler,
                       (pUMPD == NULL) ? NULL : pUMPD->pDriverInfo2,
                       &pUMdhpdev);

    if (hdc)
    {
        //
        // The only way it could be an ALTDC at this point is to be a
        // printer DC
        //

        if (IS_ALTDC_TYPE(hdc) && hSpooler)
        {
            pldc = pldcCreate(hdc,LO_DC);

            if (!pldc)
            {
                goto MSGERROR;
            }

            // Need to save DEVMODE in client side for later use.

            if (pdm)
            {
                ULONG cjDevMode = pdm->dmSize + pdm->dmDriverExtra;

                pldc->pDevMode = (DEVMODEW*) LOCALALLOC(cjDevMode);

                if (pldc->pDevMode == NULL)
                {
                    goto MSGERROR;
                }

                // Validate DEVMMODE, then copy to buffer.

                if ((pdm->dmSize >= offsetof(DEVMODEW,dmDuplex)) &&
                    (pdm->dmFields & DM_COLOR) &&
                    (pdm->dmColor == DMCOLOR_MONOCHROME))
                {
                    // if devmode says, this is monochrome mode, we don't need to
                    // validate devmode since this validation is for ICM which
                    // only needs for color case. Just copy whatever apps gives us.

                    RtlCopyMemory( (PBYTE) pldc->pDevMode, (PBYTE) pdm, cjDevMode );
                }
                else if ((*fpDocumentPropertiesW)
                            (NULL,hSpooler,
                             (LPWSTR) pdm->dmDeviceName,
                             pldc->pDevMode,  // output devmode
                             (PDEVMODEW) pdm, // input devmode
                             DM_IN_BUFFER |
                             DM_OUT_BUFFER) != IDOK)
                {
                    // if error, just copy original

                    RtlCopyMemory( (PBYTE) pldc->pDevMode, (PBYTE) pdm, cjDevMode );
                }
            }

            pldc->hSpooler = hSpooler;
            pldc->pUMPD = pUMPD;
            pldc->pUMdhpdev = pUMdhpdev;

            //
            // if the UMPD driver is first loaded
            // and no one has set either the METAFILE_DRIVER nor the NON_METAFILE_DRIVER flag,
            // set it here
            //

            if (pUMPD)
            {
               if (!(pldc->pUMPD->dwFlags & UMPDFLAG_NON_METAFILE_DRIVER)
                   && !(pldc->pUMPD->dwFlags & UMPDFLAG_METAFILE_DRIVER))
               {
                  ULONG InData = METAFILE_DRIVER;

                  if (ExtEscape(hdc,QUERYESCSUPPORT,sizeof(ULONG),(LPCSTR)&InData,0,NULL))
                  {
                     pldc->pUMPD->dwFlags |= UMPDFLAG_METAFILE_DRIVER;
                  }
                  else
                  {
                     pldc->pUMPD->dwFlags |= UMPDFLAG_NON_METAFILE_DRIVER;
                  }
               }
            }

            // remember if it is an IC

            if (bIC)
                pldc->fl |= LDC_INFO;

            // Initialize ICM stuff for this DC.
            //
            // (if pdem is substituted by DrvDocumentEvent,
            //  use the substituted devmode).

            IcmInitLocalDC(hdc,hSpooler,pdm,FALSE);

            // got to save the port name for StartDoc();

            if (pustrPort)
            {
                int cj = pustrPort->Length + sizeof(WCHAR);

                pldc->pwszPort = (LPWSTR)LOCALALLOC(cj);

                if (pldc->pwszPort)
                    memcpy(pldc->pwszPort,pustrPort->Buffer,cj);
            }

            // we need to do the CREATEDCPOST document event

            DocumentEventEx(pldc->pUMPD,
                    hSpooler,
                    hdc,
                    DOCUMENTEVENT_CREATEDCPOST,
                    sizeof(pdmAlt),
                    (PVOID)&pdmAlt,
                    0,
                    NULL);
        }
        else
        {
            // Initialize ICM stuff for this DC.

            IcmInitLocalDC(hdc,NULL,pdm,FALSE);

            if (pwszPort)
                LOCALFREE(pwszPort);
        }

    }
    else
    {
    // Handle errors.

    MSGERROR:
        if (hSpooler)
        {
            if (bDocEvent)
            {
                DocumentEventEx(pUMPD,
                                hSpooler,
                                0,
                                DOCUMENTEVENT_CREATEDCPOST,
                                sizeof(pdmAlt),
                                (PVOID)&pdmAlt,
                                0,
                                NULL);

            }

            if (pUMPD)
                UnloadUserModePrinterDriver(pUMPD, TRUE, hSpooler);

            (*fpClosePrinter)(hSpooler);
        }

        if (pwszPort)
            LOCALFREE(pwszPort);

        if (pldc)
            bDeleteLDC(pldc);

        if (hdc)
            NtGdiDeleteObjectApp(hdc);

        hdc = (HDC)0;
    }

    if (pvFree != NULL)
    {
        LOCALFREE(pvFree);
    }

    return(hdc);
}

/******************************Public*Routine******************************\
* bCreateDCW                                                               *
*                                                                          *
* Client side stub.  Allocates a client side LDC as well.                  *
*                                                                          *
* Note that it calls the server only after all client side stuff has       *
* succeeded, we don't want to ask the server to clean up.                  *
*                                                                          *
* History:                                                                 *
*  Sat 01-Jun-1991 16:13:22 -by- Charles Whitmer [chuckwh]                 *
*  8-18-92 Unicode enabled and combined with CreateIC                      *
* Wrote it.                                                                *
\**************************************************************************/

CONST WCHAR gwszDisplayDevice[] = L"\\\\.\\DISPLAY";

HDC bCreateDCW
(
    LPCWSTR     pszDriver,
    LPCWSTR     pszDevice,
    LPCWSTR     pszPort  ,
    CONST DEVMODEW *pdm,
    BOOL       bIC
)
{
    UNICODE_STRING ustrDevice;
    UNICODE_STRING ustrPort;

    PUNICODE_STRING pustrDevice = NULL;
    PUNICODE_STRING pustrPort   = NULL;

    BOOL            bDisplay = FALSE;

// check for multi-monitor cases, first.

    if (pszDevice != NULL)
    {
        if (_wcsnicmp(pszDevice,
                      gwszDisplayDevice,
                      ((sizeof(gwszDisplayDevice)/sizeof(WCHAR))-1)) == 0)
        {
        // CreateDC(?, L"\\.\DISPLAY?",...);
        // (this case, we don't care whatever passed into pszDriver)
        //
        // if apps call, CreateDC("DISPLAY","\\.\DISPLAY?",...);,
        // we handle this as multi-monitor case. that's why
        // we check multi-monitor case first.

            bDisplay = TRUE;
        }
    }

// check for most typical case to create display DC

    if (!bDisplay && (pszDriver != NULL))
    {
        if (_wcsicmp(pszDriver,(LPWSTR)L"DISPLAY") == 0)
        {
        // CreateDC(L"DISPLAY",?,...);
        //
        // Comments Win9x [gdi\dcman1.asm]
        //
        //    This fix is for people who called CreateDC/IC with
        //    ("Display","Display", xxxxx) rather than ("Display",
        //    NULL, NULL) which it was supposed to.
        //
        // NULL to pszDevice.

            pszDevice = NULL;
            bDisplay = TRUE;
        }
    }

// check for memphis compatibility

    if (!bDisplay && (pszDriver != NULL))
    {
    // The comment and code from Memphis.
    //
    // // the normal syntax apps will use is
    // //
    // //  CreateDC(NULL, "\\.\DisplayX", ...)
    // //
    // // but USER uses this syntax, so we will support it too.
    // //
    // //  CreateDC("\\.\DisplayX", NULL, ...)
    // //
    // if (lpDriverName != NULL && *(DWORD FAR *)lpDriverName == 0x5C2E5C5C)
    // {
    //    lpDeviceName = lpDriverName;
    //    lpDriverName = NULL;
    // }
        if (_wcsnicmp(pszDriver,
                      gwszDisplayDevice,
                      ((sizeof(gwszDisplayDevice)/sizeof(WCHAR))-1)) == 0)
        {
            pszDevice = pszDriver;
            bDisplay = TRUE;
        }
    }

// convert the strings

    if (pszDevice)
    {
        RtlInitUnicodeString(&ustrDevice,pszDevice);
        pustrDevice = &ustrDevice;
    }

    if (pszPort)
    {
        RtlInitUnicodeString(&ustrPort,pszPort);
        pustrPort = &ustrPort;
    }

// call the common stub

    return(hdcCreateDCW(pustrDevice,pustrPort,pdm,bDisplay,bIC));
}


/******************************Public*Routine******************************\
* bCreateDCA
*
* Client side stub.  Allocates a client side LDC as well.
*
*
* Note that it calls the server only after all client side stuff has
* succeeded, we don't want to ask the server to clean up.
*
* History:
*  8-18-92 Gerrit van Wingerden
* Wrote it.
\**************************************************************************/

CONST CHAR gszDisplayDevice[] = "\\\\.\\DISPLAY";

HDC bCreateDCA
(
    LPCSTR     pszDriver,
    LPCSTR     pszDevice,
    LPCSTR     pszPort  ,
    LPDEVMODEA pdm,
    BOOL       bIC
)
{
    HDC             hdcRet = 0;

    UNICODE_STRING  ustrDevice;
    UNICODE_STRING  ustrPort;

    PUNICODE_STRING pustrDevice = NULL;
    PUNICODE_STRING pustrPort   = NULL;

    DEVMODEW       *pdmw = NULL;

    BOOL            bDisplay = FALSE;

// check for multi-monitor cases, first.

    if (pszDevice != NULL)
    {
        if (_strnicmp(pszDevice,
                      gszDisplayDevice,
                      ((sizeof(gszDisplayDevice)/sizeof(CHAR))-1)) == 0)
        {
        // CreateDC(?,"\\.\DISPLAY?",...);
        // (this case, we don't care whatever passed into pszDriver)
        //
        // if apps call, CreateDC("DISPLAY","\\.\DISPLAY?",...);,
        // we handle this as multi-monitor case. that's why
        // we check multi-monitor case first.

            bDisplay = TRUE;
        }
    }

// check for most typical case to create display DC

    if (!bDisplay && (pszDriver != NULL))
    {
        if (_stricmp(pszDriver,"DISPLAY") == 0)
        {
        // CreateDC("DISPLAY",?,...);
        //
        // Comments Win9x [gdi\dcman1.asm]
        //
        //    This fix is for people who called CreateDC/IC with
        //    ("Display","Display", xxxxx) rather than ("Display",
        //    NULL, NULL) which it was supposed to.
        //
        // NULL to pszDevice.

            pszDevice = NULL;
            bDisplay = TRUE;
        }
    }

// check for memphis compatibility

    if (!bDisplay && (pszDriver != NULL))
    {
    // The comment and code from Memphis.
    //
    // // the normal syntax apps will use is
    // //
    // //  CreateDC(NULL, "\\.\DisplayX", ...)
    // //
    // // but USER uses this syntax, so we will support it too.
    // //
    // //  CreateDC("\\.\DisplayX", NULL, ...)
    // //
    // if (lpDriverName != NULL && *(DWORD FAR *)lpDriverName == 0x5C2E5C5C)
    // {
    //    lpDeviceName = lpDriverName;
    //    lpDriverName = NULL;
    // }
        if (_strnicmp(pszDriver,
                      gszDisplayDevice,
                      ((sizeof(gszDisplayDevice)/sizeof(CHAR))-1)) == 0)
        {
            pszDevice = pszDriver;
            bDisplay = TRUE;
        }
    }

// convert the strings

    if (pszDevice)
    {

    // [NOTE:]
    //   RtlCreateUnicodeStringFromAsciiz() returns boolean, NOT NTSTATUS !

        if (!RtlCreateUnicodeStringFromAsciiz(&ustrDevice,pszDevice))
        {
            goto MSGERROR;
        }
        pustrDevice = &ustrDevice;
    }

    if (pszPort)
    {

    // [NOTE:]
    //   RtlCreateUnicodeStringFromAsciiz() returns boolean, NOT NTSTATUS !

        if (!RtlCreateUnicodeStringFromAsciiz(&ustrPort,pszPort))
        {
            goto MSGERROR;
        }

        pustrPort = &ustrPort;
    }

// if it is a display, don't use the devmode if the dmDeviceName is empty

    if (pdm != NULL)
    {
        if (!bDisplay || (pdm->dmDeviceName[0] != 0))
        {
            pdmw = GdiConvertToDevmodeW(pdm);

            if( pdmw == NULL )
                goto MSGERROR;

        }
    }

// call the common stub

    hdcRet = hdcCreateDCW(pustrDevice,pustrPort,pdmw,bDisplay,bIC);

// clean up

    MSGERROR:

    if (pustrDevice)
        RtlFreeUnicodeString(pustrDevice);

    if (pustrPort)
        RtlFreeUnicodeString(pustrPort);

    if(pdmw != NULL)
        LOCALFREE(pdmw);

    return(hdcRet);
}


/******************************Public*Routine******************************\
* CreateICW
*
* wrapper for bCreateDCW
*
* History:
*  8-18-92 Gerrit van Wingerden
* Wrote it.
\**************************************************************************/


HDC WINAPI CreateICW
(
    LPCWSTR     pwszDriver,
    LPCWSTR     pwszDevice,
    LPCWSTR     pwszPort,
    CONST DEVMODEW *pdm
)
{
    return bCreateDCW( pwszDriver, pwszDevice, pwszPort, pdm, TRUE );
}


/******************************Public*Routine******************************\
* CreateICA
*
* wrapper for bCreateICA
*
* History:
*  8-18-92 Gerrit van Wingerden
* Wrote it.
\**************************************************************************/


HDC WINAPI CreateICA
(
    LPCSTR     pszDriver,
    LPCSTR     pszDevice,
    LPCSTR     pszPort,
    CONST DEVMODEA *pdm
)
{

    return bCreateDCA( pszDriver, pszDevice, pszPort, (LPDEVMODEA)pdm, TRUE );
}


/******************************Public*Routine******************************\
* CreateDCW
*
* wrapper for bCreateDCA
*
* History:
*  8-18-92 Gerrit van Wingerden
* Wrote it.
\**************************************************************************/

HDC WINAPI CreateDCA
(
    LPCSTR     pszDriver,
    LPCSTR     pszDevice,
    LPCSTR     pszPort,
    CONST DEVMODEA *pdm
)
{
    return bCreateDCA( pszDriver, pszDevice, pszPort, (LPDEVMODEA)pdm, FALSE );
}

/******************************Public*Routine******************************\
* CreateDCW
*
* wrapper for bCreateDCW
*
* History:
*  8-18-92 Gerrit van Wingerden
* Wrote it.
\**************************************************************************/


HDC WINAPI CreateDCW
(
    LPCWSTR     pwszDriver,
    LPCWSTR     pwszDevice,
    LPCWSTR     pwszPort  ,
    CONST DEVMODEW *pdm
)
{
    return bCreateDCW( pwszDriver, pwszDevice, pwszPort, pdm, FALSE );
}


/******************************Public*Routine******************************\
* GdiConvertToDevmodeW
*
* Converts a DEVMODEA to a DEVMODEW structure
*
* History:
*  09-08-1995 Andre Vachon
* Wrote it.
\**************************************************************************/

LPDEVMODEW
GdiConvertToDevmodeW(
    LPDEVMODEA pdma
)
{
    DWORD cj;
    LPDEVMODEW pdmw;

    // Sanity check.  We should have at least up to and including the
    // dmDriverExtra field of the DEVMODE structure.
    //
    // NOTE dmSize CAN be greater than the size of the DEVMODE
    // structure (not counting driver specific data, of course) because this
    // structure grows from version to version.
    //

    if (pdma->dmSize <= (offsetof(DEVMODEA,dmDriverExtra)))
    {
        ASSERTGDI(FALSE, "GdiConvertToDevmodeW: DevMode.dmSize bad or corrupt\n");
        return(NULL);
    }

    pdmw = (DEVMODEW *) LOCALALLOC(sizeof(DEVMODEW) + pdma->dmDriverExtra);

    if (pdmw)
    {
        //
        // If we get to here, we know we have at least up to and including
        // the dmDriverExtra field.
        //

        vToUnicodeN(pdmw->dmDeviceName,
                    CCHDEVICENAME,
                    pdma->dmDeviceName,
                    CCHDEVICENAME);

        pdmw->dmSpecVersion = pdma->dmSpecVersion ;
        pdmw->dmDriverVersion = pdma->dmDriverVersion;
        pdmw->dmSize = pdma->dmSize + CCHDEVICENAME;
        pdmw->dmDriverExtra = pdma->dmDriverExtra;

        //
        // Anything left in the pdma buffer?  Copy any data between the dmDriverExtra
        // field and the dmFormName, truncating the amount to the size of the
        // pdma buffer (as specified by dmSize), of course.
        //

        cj = MIN(pdma->dmSize - offsetof(DEVMODEA,dmFields),
                 offsetof(DEVMODEA,dmFormName) - offsetof(DEVMODEA,dmFields));

        RtlCopyMemory(&pdmw->dmFields,
                      &pdma->dmFields,
                      cj);

        //
        // Is there a dmFormName field present in the pdma buffer?  If not, bail out.
        // Otherwise, convert to Unicode.
        //

        if (pdma->dmSize >= (offsetof(DEVMODEA,dmFormName)+32))
        {
            vToUnicodeN(pdmw->dmFormName,
                        CCHFORMNAME,
                        pdma->dmFormName,
                        CCHFORMNAME);

            pdmw->dmSize += CCHFORMNAME;

            //
            // Lets adjust the size of the DEVMODE in case the DEVMODE passed in
            // is from a future, larger version of the DEVMODE.
            //

            pdmw->dmSize = min(pdmw->dmSize, sizeof(DEVMODEW));

            //
            // Copy data from dmBitsPerPel to the end of the input buffer
            // (as specified by dmSize).
            //

            RtlCopyMemory(&pdmw->dmLogPixels,
                          &pdma->dmLogPixels,
                          MIN(pdma->dmSize - offsetof(DEVMODEA,dmLogPixels),
                              pdmw->dmSize - offsetof(DEVMODEW,dmLogPixels)) );

            //
            // Copy any driver specific data indicated by the dmDriverExtra field.
            //

            RtlCopyMemory((PBYTE) pdmw + pdmw->dmSize,
                          (PBYTE) pdma + pdma->dmSize,
                          pdma->dmDriverExtra );
        }
    }

    return pdmw;
}



/******************************Public*Routine******************************\
* CreateCompatibleDC                                                       *
*                                                                          *
* Client side stub.  Allocates a client side LDC as well.                  *
*                                                                          *
* Note that it calls the server only after all client side stuff has       *
* succeeded, we don't want to ask the server to clean up.                  *
*                                                                          *
* History:                                                                 *
*  Wed 24-Jul-1991 15:38:41 -by- Wendy Wu [wendywu]                        *
* Should allow hdc to be NULL.                                             *
*                                                                          *
*  Mon 03-Jun-1991 23:13:28 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HDC WINAPI CreateCompatibleDC(HDC hdc)
{
    HDC hdcNew = NULL;

    FIXUP_HANDLEZ(hdc);

    hdcNew = NtGdiCreateCompatibleDC(hdc);

    // [Windows 98 compatibility]
    //
    // if source DC has some ICM information, compatible DC should
    // inherit those information.
    //
    // Is this what Memphis does, but Win95 does not.
    //
    if (hdc && hdcNew)
    {
        PDC_ATTR pdca;

        PSHARED_GET_VALIDATE(pdca,hdc,DC_TYPE);

        if (pdca && BEXIST_ICMINFO(pdca))
        {
            IcmEnableForCompatibleDC(hdcNew,hdc,pdca);
        }
    }

    return(hdcNew);
}

/******************************Public*Routine******************************\
* DeleteDC                                                                 *
*                                                                          *
* Client side stub.  Deletes the client side LDC as well.                  *
*                                                                          *
* Note that we give the server a chance to fail the call before destroying *
* our client side data.                                                    *
*                                                                          *
* History:                                                                 *
*  Sat 01-Jun-1991 16:16:24 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL WINAPI DeleteDC(HDC hdc)
{
    FIXUP_HANDLE(hdc);
    return(InternalDeleteDC(hdc,LO_DC_TYPE));
}

BOOL InternalDeleteDC(HDC hdc,ULONG iType)
{
    ULONG bRet = FALSE;
    PLDC pldc  = NULL;
    BOOL unloadUMPD = FALSE;
    PDC_ATTR pDcAttr;
    HANDLE hSpooler = 0;

    if (IS_ALTDC_TYPE(hdc))
    {
        DC_PLDC(hdc,pldc,bRet);

    // In case a document is still open.

        if (pldc->fl & LDC_DOC_STARTED)
            AbortDoc(hdc);

    // if this was a metafiled print job, AbortDoc should have converted back

        ASSERTGDI(!(pldc->fl & LDC_META_PRINT), "InternalDeleteDC - LDC_META_PRINT\n");

    // if we have an open spooler handle

        if (pldc->hSpooler)
        {
            // now call the drivers UI portion

            DocumentEventEx(pldc->pUMPD,
                    pldc->hSpooler,
                    hdc,
                    DOCUMENTEVENT_DELETEDC,
                    0,
                    NULL,
                    0,
                    NULL);

            //
            // Remember to unload user-mode printer driver module later
            //

            unloadUMPD = (pldc->pUMPD != NULL);

            ASSERTGDI(ghSpooler != NULL,"Trying to close printer that was never opened\n");

            //
            // remember hspooler, for not printer dcs, hspooler may not be initialized
            //
            hSpooler = pldc->hSpooler;

            pldc->hSpooler = 0;
        }

    // delete the port name if it was created

        if (pldc->pwszPort != NULL)
        {
            LOCALFREE(pldc->pwszPort);
            pldc->pwszPort = NULL;
        }

    // delete UFI hash tables if they exist

        vFreeUFIHashTable( pldc->ppUFIHash, 0 );
        vFreeUFIHashTable( pldc->ppDVUFIHash, 0 );
        vFreeUFIHashTable( pldc->ppSubUFIHash, FL_UFI_SUBSET);
        if (pldc->ppUFIHash)
        {
        // client side situation: all three ppXXX tables allocated

            LOCALFREE(pldc->ppUFIHash);
        }
        else
        {
        // server side situation: possibly only ppSubUFIHash tables allocated

            ASSERTGDI(!pldc->ppDVUFIHash, "server side pldc->ppDVUFIHash not null\n");
            if (pldc->ppSubUFIHash)
                LOCALFREE(pldc->ppSubUFIHash);
        }
    }
    else
    {
        pldc = GET_PLDC(hdc);
    }

    // save the old brush, so we can DEC its counter later

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        if (ghICM || BEXIST_ICMINFO(pDcAttr))
        {
            //
            // Delete ICM stuff in this DC. (should be delete this BEFORE hdc is gone)
            //
            IcmDeleteLocalDC(hdc,pDcAttr,NULL);
        }

        bRet = NtGdiDeleteObjectApp(hdc);

        if (hSpooler)
        {
           (*fpClosePrinter)(hSpooler);
        }
    }

    // delete the client piece only if the server is successfully deleted.
    // othewise it will be orphaned.

    if (bRet && pldc)
    {
        if (unloadUMPD)
        {
            UnloadUserModePrinterDriver(pldc->pUMPD, TRUE, hSpooler);
            pldc->pUMPD = NULL;
        }

        bRet = bDeleteLDC(pldc);
        ASSERTGDI(bRet,"InteranlDeleteDC - couldn't delete LDC\n");
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* GdiReleaseDC
*
*   Free user mode ICM resources saved in DC
*
* Arguments:
*
*   hdc
*
* Return Value:
*
*    status
*
* History:
*
* Rewrite it for ICM.
*     2.Feb.1997 Hideyuki Nagase [hideyukn]
* Write it:
*    10/10/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
GdiReleaseDC(
    HDC hdc
    )
{
    PLDC     pldc;
    PDC_ATTR pDcAttr;
    BOOL bRet = TRUE;

    pldc = GET_PLDC(hdc);

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr && (ghICM || BEXIST_ICMINFO(pDcAttr)))
    {
        //
        // Delete ICM stuff in this DC.
        //
        IcmDeleteLocalDC(hdc,pDcAttr,NULL);
    }

    if (pldc)
    {
        //
        // PLDC has been allocated. free it.
        //
        // Put null-PLDC into DC_ATTR.
        //
        vSetPldc(hdc,NULL);
        //
        // And, then delete PLDC.
        //
        bRet = bDeleteLDC(pldc);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* SaveDC                                                                   *
*                                                                          *
* Client side stub.  Saves the LDC on the client side as well.             *
*                                                                          *
* History:                                                                 *
*  Sat 01-Jun-1991 16:17:43 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

int WINAPI SaveDC(HDC hdc)
{
    int   iRet = 0;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return (MF16_RecordParms1(hdc, META_SAVEDC));

        DC_PLDC(hdc,pldc,iRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_Record(hdc,EMR_SAVEDC))
                return(iRet);
        }
    }

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        PGDI_ICMINFO pIcmInfo = GET_ICMINFO(pDcAttr);

        //
        // If DC doesn't have ICMINFO, just call kernel.
        // If DC has ICMINFO, save ICMINFO first in client side, then call kernel.
        //
        if ((pIcmInfo == NULL) || (IcmSaveDC(hdc,pDcAttr,pIcmInfo)))
        {
            //
            // Call kernel to save DC.
            //
            iRet = NtGdiSaveDC(hdc);

            if ((iRet == 0) && (pIcmInfo))
            {
                //
                // if fail, restore client too.
                //
                IcmRestoreDC(pDcAttr,-1,pIcmInfo);
            }
        }

    }

    return(iRet);
}

/******************************Public*Routine******************************\
* RestoreDC                                                                *
*                                                                          *
* Client side stub.  Restores the client side LDC as well.                 *
*                                                                          *
* History:                                                                 *
*  Sat 01-Jun-1991 16:18:50 -by- Charles Whitmer [chuckwh]                 *
* Wrote it. (We could make this batchable some day.)                       *
\**************************************************************************/

BOOL WINAPI RestoreDC(HDC hdc,int iLevel)
{
    BOOL  bRet = FALSE;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    // Metafile the call.

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return (MF16_RecordParms2(hdc, iLevel, META_RESTOREDC));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_RestoreDC(hdc,iLevel))
                return(bRet);

        // zero out UFI since it will no longer be valid

            UFI_CLEAR_ID(&(pldc->ufi));
        }
    }

    // save the old brush, so we can DEC it's count later

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        //
        // Keep current ICMINFO, before restore it
        //
        PGDI_ICMINFO pIcmInfoOld = GET_ICMINFO(pDcAttr);

        if (pIcmInfoOld)
        {
            //
            // And mark the ICMINFO unreuseable since  under restoring DC.
            //
            IcmMarkInUseIcmInfo(pIcmInfoOld,TRUE);
        }

        //
        // Call kernel to do retore DC.
        //
        bRet = NtGdiRestoreDC(hdc,iLevel);

        if (bRet)
        {
            PGDI_ICMINFO pIcmInfo = GET_ICMINFO(pDcAttr);

            if (pIcmInfoOld && (pIcmInfo == NULL))
            {
                //
                // Delete ICM stuffs associated the DC before Restore.
                // beccause Restored DC does not have any ICMINFO.
                //
                // - This will delete pIcmInfoOld.
                //
                IcmDeleteLocalDC(hdc,pDcAttr,pIcmInfoOld);

                pIcmInfoOld = NULL;
            }
            else if (pIcmInfoOld == pIcmInfo)
            {
                //
                // Restore DC in client side.
                //
                IcmRestoreDC(pDcAttr,iLevel,pIcmInfo);
            }
        }

        if (pIcmInfoOld)
        {
            //
            // Unmark unreusable flags.
            //
            IcmMarkInUseIcmInfo(pIcmInfoOld,FALSE);
        }

        CLEAR_CACHED_TEXT(pDcAttr);
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* ResetDCWInternal
*
* This internal version version of ResetDC implments the functionality of
* ResetDCW, but, through the addition of a third parameter, pbBanding, handles
* ResetDC for the Printing metafile playback code.  When pbBanding is non-NULL
* ResetDCWInternal is being called by GdiPlayEMFSpoolfile. In this case
* the only thing that needs to be done is to imform the the caller whether or
* not the new surface is a banding surface.
*
*
* History:
*  13-Mar-1995 Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/

HDC WINAPI ResetDCWInternal(HDC hdc, CONST DEVMODEW *pdm, BOOL *pbBanding)
{
    HDC hdcRet = NULL;
    PLDC pldc = NULL;
    PDEVMODEW pdmAlt = NULL;
    KERNEL_PUMDHPDEV pUMdhpdev = NULL;
    BOOL bDocEvent = FALSE;

    if (IS_ALTDC_TYPE(hdc) && !IS_METADC16_TYPE(hdc))
    {
        PDC_ATTR pdcattr;
        BOOL  bBanding;
        PUMPD pUMPD;
        PGDI_ICMINFO pIcmInfoOld = NULL;
        int iEventRet;

        DC_PLDC(hdc,pldc,(HDC) 0);
        PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

        // Do nothing if we are in the middle of a page.

        if (pldc->fl & LDC_PAGE_STARTED)
            return((HDC)0);

        // see if the driver is intercepting document events

        if (pldc->hSpooler)
        {
            iEventRet = DocumentEventEx(pldc->pUMPD,
                                        pldc->hSpooler,
                                        hdc,
                                        DOCUMENTEVENT_RESETDCPRE,
                                        sizeof(pdm),
                                        (PVOID)&pdm,
                                        sizeof(pdmAlt),
                                        (PVOID)&pdmAlt);
            
            if (iEventRet == DOCUMENTEVENT_FAILURE)
            {
                return((HDC)0);
            }
            
            bDocEvent = TRUE;
            
            if (pdmAlt)
                pdm = pdmAlt;
        }

        pUMPD = pldc->pUMPD;

        if (pdcattr)
        {
            // Keep current ICMINFO, before reset it.

            pIcmInfoOld = GET_ICMINFO(pdcattr);

            if (pIcmInfoOld)
            {
                // And mark the ICMINFO unreuseable since  under restoring DC.

                IcmMarkInUseIcmInfo(pIcmInfoOld,TRUE);
            }
        }

        if (NtGdiResetDC(hdc,(PDEVMODEW)pdm,&bBanding,
                        (pUMPD == NULL)? NULL : pUMPD->pDriverInfo2, &pUMdhpdev))
        {
            PDC_ATTR pdca;

            PSHARED_GET_VALIDATE(pdca,hdc,DC_TYPE);

            // make sure we update the pldc in the dcattr before continuing

            vSetPldc(hdc,pldc);
#if 0
// EngQueryEMFInfo junk
            if (pUMdhpdev)
            {
               pUMdhpdev->hdc = hdc;
            }
#endif

            pldc->pUMdhpdev = pUMdhpdev;

            // clear cached DEVCAPS

            pldc->fl &= ~LDC_CACHED_DEVCAPS;

            // clear cached TM

            if (pdca)
            {
                CLEAR_CACHED_TEXT(pdca);
            }

            // update the devmode we store in the DC

            if (pldc->pDevMode)
            {
                LOCALFREE(pldc->pDevMode);
                pldc->pDevMode = NULL;
            }

            if (pdm != (DEVMODEW*) NULL)
            {
                ULONG cjDevMode = pdm->dmSize + pdm->dmDriverExtra;

                pldc->pDevMode = (DEVMODEW*) LOCALALLOC(cjDevMode);

                if (pldc->pDevMode == NULL)
                {
                    WARNING("MFP_ResetDCW unable to allocate memory\n");
                    goto ERROREXIT;
                }

                // Validate DEVMMODE, then copy to buffer.

                if ((pdm->dmSize >= offsetof(DEVMODEW,dmDuplex)) &&
                    (pdm->dmFields & DM_COLOR) &&
                    (pdm->dmColor == DMCOLOR_MONOCHROME))
                {
                    // if devmode says, this is monochrome mode, we don't need to
                    // validate devmode since this validation is for ICM which
                    // only needs for color case. Just copy whatever apps gives us.

                    RtlCopyMemory( (PBYTE) pldc->pDevMode, (PBYTE) pdm, cjDevMode );
                }
                else if ((*fpDocumentPropertiesW)
                            (NULL,pldc->hSpooler,
                             (LPWSTR) pdm->dmDeviceName,
                             pldc->pDevMode,  // output devmode
                             (PDEVMODEW) pdm, // input devmode
                             DM_IN_BUFFER |
                             DM_OUT_BUFFER) != IDOK)
                {
                    // if error, just copy original

                    RtlCopyMemory( (PBYTE) pldc->pDevMode, (PBYTE) pdm, cjDevMode );
                }
            }

            // make sure we update the pvICM in the dcattr before continuing

            if (pdca)
            {
                // This old ICM info will be deleted when we re-initialize ICM
                // status based on new DEVMODE.

                pdca->pvICM = pIcmInfoOld;
                pIcmInfoOld = NULL;

                // Re-initialize ICM stuff with new DEVMODE

                IcmInitLocalDC(hdc,pldc->hSpooler,pdm,TRUE);
            }

            // got to tell the spooler things have changed

            if (pldc->hSpooler)
            {
                PRINTER_DEFAULTSW prnDefaults;

                prnDefaults.pDatatype     = NULL;
                prnDefaults.pDevMode      = (PDEVMODEW)pdm;
                prnDefaults.DesiredAccess = PRINTER_ACCESS_USE;

                ResetPrinterWEx(pldc, &prnDefaults);
            }

            // now deal with the specific mode

            if( ( pldc->fl & LDC_META_PRINT ) &&
               !( pldc->fl & LDC_BANDING ) )
            {
                if( !MFP_ResetDCW( hdc, (DEVMODEW*) pdm ) )
                {
                    goto ERROREXIT;
                }

            }
            else if( pbBanding == NULL  )
            {
                if( !MFP_ResetBanding( hdc, bBanding ) )
                {
                    goto ERROREXIT;
                }
            }

            if (pbBanding)
            {
                *pbBanding = bBanding;
            }

            // need to make sure it is a direct DC

            pldc->fl &= ~LDC_INFO;

            hdcRet = hdc;
        }

        if (pIcmInfoOld)
        {
            IcmMarkInUseIcmInfo(pIcmInfoOld,FALSE);
        }
    }

ERROREXIT:    

    // see if the driver is intercepting document events
        
    if (bDocEvent)
    {
        DocumentEventEx(pldc->pUMPD,
                pldc->hSpooler,
                hdc,
                DOCUMENTEVENT_RESETDCPOST,
                sizeof(pdmAlt),
                (PVOID)&pdmAlt,
                0,
                NULL);
    }
    
    return(hdcRet);

}

/******************************Public*Routine******************************\
* ResetDCW
*
* Client side stub.  Resets the client side LDC as well.
*
* History:
*  31-Dec-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

HDC WINAPI ResetDCW(HDC hdc, CONST DEVMODEW *pdm)
{
    FIXUP_HANDLE(hdc);

    return(ResetDCWInternal( hdc, pdm, NULL ) );
}

/******************************Public*Routine******************************\
* ResetDCA
*
* Client side stub.  Resets the client side LDC as well.
*
* History:
*  31-Dec-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

HDC WINAPI ResetDCA(HDC hdc, CONST DEVMODEA *pdm)
{
    DEVMODEW   *pdmw = NULL;
    HDC         hdcRet = 0;

    FIXUP_HANDLE(hdc);

    // convert to unicode

    if ((pdm != NULL) && (pdm->dmDeviceName[0] != 0))
    {
        pdmw = GdiConvertToDevmodeW((LPDEVMODEA) pdm);

        if (pdmw == NULL)
        {
            goto MSGERROR;
        }
    }

    hdcRet = ResetDCWInternal(hdc,pdmw,NULL);

MSGERROR:

    // Clean up the conversion buffer

    if (pdmw != NULL)
        LOCALFREE(pdmw);

    return (hdcRet);
}

/******************************Public*Routine******************************\
* CreateBrush                                                              *
*                                                                          *
* A single routine which creates any brush.  Any extra data needed is      *
* assumed to be at pv.  The size of the data must be cj.  The data is      *
* appended to the LOGBRUSH.                                                *
*                                                                          *
* History:                                                                 *
*  Tue 04-Jun-1991 00:03:24 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HBRUSH CreateBrush
(
    ULONG lbStyle,
    ULONG lbColor,
    ULONG_PTR lbHatch,
    ULONG_PTR lbSaveHatch,
    PVOID pv
)
{
    HBRUSH hbrush = NULL;

    if (lbStyle == BS_SOLID)
    {
        //
        // look for a cached brush on the PEB
        //

        HBRUSH hbr = (HBRUSH)hGetPEBHandle(BrushHandle,lbColor);

        if (hbr == NULL)
        {
            hbr = NtGdiCreateSolidBrush(lbColor, 0);
        }

        return(hbr);
    }

    //
    // call into kernel to create other styles of brush
    //

    switch(lbStyle)
    {
    case BS_HOLLOW:
        return(GetStockObject(NULL_BRUSH));

    case BS_HATCHED:
        //
        // lbHatch is overloaded, actually is HS style
        // we are safe to truncate it here
        //
        return (NtGdiCreateHatchBrushInternal
               ((ULONG)(lbHatch),
                lbColor,
                FALSE));

    case BS_PATTERN:
        return (NtGdiCreatePatternBrushInternal((HBITMAP)lbHatch,FALSE,FALSE));

    case BS_PATTERN8X8:
        return (NtGdiCreatePatternBrushInternal((HBITMAP)lbHatch,FALSE,TRUE));

    case BS_DIBPATTERN:
    case BS_DIBPATTERNPT:
    case BS_DIBPATTERN8X8:
    {
        INT cj;
        HBRUSH hbr;

        PVOID pbmiDIB;

        pbmiDIB = (PVOID)pbmiConvertInfo((BITMAPINFO *) pv,lbColor, &cj, TRUE);

        if (pbmiDIB)
        {
            hbr = NtGdiCreateDIBBrush(
                            (PVOID)pbmiDIB,
                            lbColor,
                            cj,
                            (lbStyle == BS_DIBPATTERN8X8),
                            FALSE,
                            (PVOID)pv);

            if (pbmiDIB != pv)
            {
                LOCALFREE (pbmiDIB);
            }
        }
        else
        {
            hbr = 0;
        }
        return (hbr);
    }
    default:
        WARNING("GreCreateBrushIndirect failed - invalid type\n");
        return((HBRUSH)0);
    }
}

/******************************Public*Routine******************************\
* CreateHatchBrush                                                         *
*                                                                          *
* Client side stub.  Maps to the single brush creation routine.            *
*                                                                          *
* History:
*  Mon 03-Jun-1991 23:42:07 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HBRUSH WINAPI CreateHatchBrush(int iHatch,COLORREF color)
{
    return(CreateBrush(BS_HATCHED,(ULONG) color,iHatch,iHatch,NULL));
}

/******************************Public*Routine******************************\
* CreatePatternBrush                                                       *
*                                                                          *
* Client side stub.  Maps to the single brush creation routine.            *
*                                                                          *
* History:                                                                 *
*  Mon 03-Jun-1991 23:42:07 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HBRUSH WINAPI CreatePatternBrush(HBITMAP hbm_)
{
    FIXUP_HANDLE (hbm_);

    return(CreateBrush(BS_PATTERN,0,(ULONG_PTR)hbm_,(ULONG_PTR)hbm_,NULL));
}

/******************************Public*Routine******************************\
* CreateSolidBrush                                                         *
*                                                                          *
* Client side stub.  Maps to the single brush creation routine.            *
*                                                                          *
* History:                                                                 *
*  Mon 03-Jun-1991 23:42:07 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HBRUSH WINAPI CreateSolidBrush(COLORREF color)
{
    return(CreateBrush(BS_SOLID,(ULONG) color,0,0,NULL));
}

/******************************Public*Routine******************************\
* CreateBrushIndirect                                                      *
*                                                                          *
* Client side stub.  Maps to the simplest brush creation routine.          *
*                                                                          *
* History:                                                                 *
*  Tue 04-Jun-1991 00:40:27 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HBRUSH WINAPI CreateBrushIndirect(CONST LOGBRUSH * plbrush)
{
    switch (plbrush->lbStyle)
    {
    case BS_SOLID:
    case BS_HOLLOW:
    case BS_HATCHED:
        return(CreateBrush(plbrush->lbStyle,
                           plbrush->lbColor,
                           plbrush->lbHatch,
                           plbrush->lbHatch,
                           NULL));
    case BS_PATTERN:
    case BS_PATTERN8X8:
        {
            return(CreateBrush(
                        plbrush->lbStyle,
                        0,
                        plbrush->lbHatch,
                        plbrush->lbHatch,
                        NULL));
        }

    case BS_DIBPATTERNPT:
    case BS_DIBPATTERN8X8:
        {
            BITMAPINFOHEADER *pbmi = (BITMAPINFOHEADER *) plbrush->lbHatch;

            return (CreateBrush(plbrush->lbStyle,
                               plbrush->lbColor,
                               0,
                               plbrush->lbHatch,
                               pbmi));
        }
    case BS_DIBPATTERN:
        {
            BITMAPINFOHEADER *pbmi;
            HBRUSH hbrush;

            pbmi = (BITMAPINFOHEADER *) GlobalLock((HANDLE) plbrush->lbHatch);

            if (pbmi == (BITMAPINFOHEADER *) NULL)
                return((HBRUSH) 0);

            hbrush =
              CreateBrush
              (
                plbrush->lbStyle,
                plbrush->lbColor,
                0,
                plbrush->lbHatch,
                pbmi
               );

            GlobalUnlock ((HANDLE)plbrush->lbHatch);
            return (hbrush);
        }
    default:
        return((HBRUSH) 0);
    }


}

/******************************Public*Routine******************************\
* CreateDIBPatternBrush                                                    *
*                                                                          *
* Client side stub.  Maps to the single brush creation routine.            *
*                                                                          *
* History:                                                                 *
*  Mon 03-Jun-1991 23:42:07 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HBRUSH WINAPI CreateDIBPatternBrush(HGLOBAL h,UINT iUsage)
{
    BITMAPINFOHEADER *pbmi;
    HBRUSH    hbrush;

    pbmi = (BITMAPINFOHEADER *) GlobalLock(h);

    if (pbmi == (BITMAPINFOHEADER *) NULL)
        return((HBRUSH) 0);

    hbrush =
      CreateBrush
      (
        BS_DIBPATTERN,
        iUsage,
        0,
        (ULONG_PTR) h,
        pbmi
      );

    GlobalUnlock(h);

    return(hbrush);
}

/******************************Public*Routine******************************\
* CreateDIBPatternBrushPt                                                  *
*                                                                          *
* Client side stub.  Maps to the single brush creation routine.            *
*                                                                          *
* History:                                                                 *
*  Mon 03-Jun-1991 23:42:07 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HBRUSH WINAPI CreateDIBPatternBrushPt(CONST VOID *pbmi,UINT iUsage)
{
    if (pbmi == (LPVOID) NULL)
        return((HBRUSH) 0);

    return
      CreateBrush
      (
        BS_DIBPATTERNPT,
        iUsage,
        0,
        (ULONG_PTR)pbmi,
        (BITMAPINFOHEADER *)pbmi
      );
}

/******************************Public*Routine******************************\
* CreatePen                                                                *
*                                                                          *
* Stub to get the server to create a standard pen.                         *
*                                                                          *
* History:                                                                 *
*  Tue 04-Jun-1991 16:20:58 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/


HPEN WINAPI CreatePen(
    int      iStyle,
    int      cWidth,
    COLORREF color
)
{
    HPEN hpen;

    switch(iStyle)
    {
    case PS_NULL:
        return(GetStockObject(NULL_PEN));

    case PS_SOLID:
    case PS_DASH:
    case PS_DOT:
    case PS_DASHDOT:
    case PS_DASHDOTDOT:
    case PS_INSIDEFRAME:
        break;

    default:
        // Bug 195478:  objects created with illegal styles should be of style PS_SOLID to
        // maintain Memphis compatibility.

        iStyle = PS_SOLID;
        break;
    }

    // try to get local cached pen

    if ((cWidth == 0) && (iStyle == PS_SOLID))
    {
        hpen = (HPEN)hGetPEBHandle(PenHandle,0);

        if (hpen)
        {
            PBRUSHATTR pBrushattr;

            PSHARED_GET_VALIDATE(pBrushattr,hpen,BRUSH_TYPE);

            //
            // setup the fields
            //

            if (pBrushattr)
            {
                ASSERTGDI (!(pBrushattr->AttrFlags & ATTR_TO_BE_DELETED),"createbrush : how come del flag is on?\n");

                //
                // clear cahced flag, set new style and color
                //

                if (pBrushattr->lbColor != color)
                {
                    pBrushattr->AttrFlags |= ATTR_NEW_COLOR;
                    pBrushattr->lbColor = color;
                }

                return(hpen);
            }
            else
            {
                WARNING ("pBrushattr == NULL, bad handle on TEB/PEB! \n");
                DeleteObject(hpen);
            }
        }
    }

    //
    // validate
    //

    return(NtGdiCreatePen(iStyle,cWidth,color,(HBRUSH)NULL));
}

/******************************Public*Routine******************************\
* ExtCreatePen
*
* Client side stub.  The style array is appended to the end of the
* EXTLOGPEN structure, and if the call requires a DIBitmap it is appended
* at the end of this.
*
* History:
*  Wed 22-Jan-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

HPEN WINAPI ExtCreatePen
(
    DWORD       iPenStyle,
    DWORD       cWidth,
    CONST LOGBRUSH *plbrush,
    DWORD       cStyle,
    CONST DWORD *pstyle
)
{
    HANDLE            hRet;
    ULONG             cjStyle;
    ULONG             cjBitmap = 0;
    ULONG_PTR          lNewHatch;
    BITMAPINFOHEADER* pbmi = (BITMAPINFOHEADER*) NULL;
    UINT              uiBrushStyle = plbrush->lbStyle;
    PVOID             pbmiDIB = NULL;

    if ((iPenStyle & PS_STYLE_MASK) == PS_USERSTYLE)
    {
        if (pstyle == (LPDWORD) NULL)
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            return((HPEN) 0);
        }
    }
    else
    {
    // Make sure style array is empty if PS_USERSTYLE not specified:

        if (cStyle != 0 || pstyle != (LPDWORD) NULL)
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            return((HPEN) 0);
        }
    }

    switch(uiBrushStyle)
    {
    case BS_SOLID:
    case BS_HOLLOW:
    case BS_HATCHED:
        lNewHatch = plbrush->lbHatch;
        break;

    case BS_PATTERN:
        lNewHatch = plbrush->lbHatch;
        if (lNewHatch == 0)
            return((HPEN) 0);
        break;

    case BS_DIBPATTERNPT:
        pbmi = (BITMAPINFOHEADER *) plbrush->lbHatch;
        pbmiDIB = (PVOID) pbmiConvertInfo ((BITMAPINFO *) pbmi, plbrush->lbColor, &cjBitmap, TRUE);
        lNewHatch = (ULONG_PTR)pbmiDIB;
        break;

    case BS_DIBPATTERN:
        // Convert BS_DIBPATTERN to a BS_DIBPATTERNPT call:

        uiBrushStyle = BS_DIBPATTERNPT;
        pbmi = (BITMAPINFOHEADER *) GlobalLock((HANDLE) plbrush->lbHatch);
        if (pbmi == (BITMAPINFOHEADER *) NULL)
            return((HPEN) 0);

        pbmiDIB = (PVOID) pbmiConvertInfo ((BITMAPINFO *) pbmi, plbrush->lbColor, &cjBitmap, TRUE);
        lNewHatch = (ULONG_PTR)pbmiDIB;

        break;
    }

// Ask the server to create the pen:

    cjStyle = cStyle * sizeof(DWORD);

    hRet = NtGdiExtCreatePen(
                        iPenStyle,
                        cWidth,
                        uiBrushStyle,
                        plbrush->lbColor,
                        plbrush->lbHatch,
                        lNewHatch,
                        cStyle,
                        (DWORD*)pstyle,
                        cjBitmap,
                        FALSE,
                        0);

    if (hRet)
    {
        ASSERTGDI(((LO_TYPE (hRet) == LO_PEN_TYPE) ||
                   (LO_TYPE (hRet) == LO_EXTPEN_TYPE)), "EXTCreatePen - type wrong\n");
    }

    if (plbrush->lbStyle == BS_DIBPATTERN)
        GlobalUnlock((HANDLE) plbrush->lbHatch);

    if (pbmiDIB && (pbmiDIB != (PVOID)pbmi))
        LOCALFREE(pbmiDIB);

    return((HPEN) hRet);
}

/******************************Public*Routine******************************\
* CreatePenIndirect                                                        *
*                                                                          *
* Client side stub.  Maps to the single pen creation routine.              *
*                                                                          *
* History:                                                                 *
*  Tue 04-Jun-1991 16:21:56 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HPEN WINAPI CreatePenIndirect(CONST LOGPEN *plpen)
{

    return
      CreatePen
      (
        plpen->lopnStyle,
        plpen->lopnWidth.x,
        plpen->lopnColor
      );
}

/******************************Public*Routine******************************\
* CreateCompatibleBitmap                                                   *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Tue 04-Jun-1991 16:35:51 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL bDIBSectionSelected(
    PDC_ATTR pdca
    )
{
    BOOL bRet = FALSE;

    if ((pdca != NULL) && ((pdca->ulDirty_ & DC_DIBSECTION)))
    {
        bRet = TRUE;
    }

    return(bRet);
}


HBITMAP WINAPI CreateCompatibleBitmap
(
    HDC   hdc,
    int cx,
    int cy
)
{
    HBITMAP hbm;

    //
    // validate hdc
    //

    PDC_ATTR pdca;

    FIXUP_HANDLEZ(hdc);

    PSHARED_GET_VALIDATE(pdca,hdc,DC_TYPE);

    if (pdca)
    {
        ULONG  ulRet;
        DWORD  bmi[(sizeof(DIBSECTION)+256*sizeof(RGBQUAD))/sizeof(DWORD)];

    // check if it is an empty bitmap

        if ((cx == 0) || (cy == 0))
        {
            return(GetStockObject(PRIV_STOCK_BITMAP));
        }

        if (bDIBSectionSelected(pdca))
        {
            if (GetObject((HBITMAP)GetDCObject(hdc, LO_BITMAP_TYPE), sizeof(DIBSECTION),
                          &bmi) != (int)sizeof(DIBSECTION))
            {
                WARNING("CreateCompatibleBitmap: GetObject failed\n");
                return((HBITMAP) 0);
            }

            if (((DIBSECTION *)&bmi)->dsBm.bmBitsPixel <= 8)
                GetDIBColorTable(hdc, 0, 256,
                                 (RGBQUAD *)&((DIBSECTION *)&bmi)->dsBitfields[0]);

            ((DIBSECTION *)&bmi)->dsBmih.biWidth = cx;
            ((DIBSECTION *)&bmi)->dsBmih.biHeight = cy;

            return(CreateDIBSection(hdc, (BITMAPINFO *)&((DIBSECTION *)&bmi)->dsBmih,
                                    DIB_RGB_COLORS, NULL, 0, 0));
        }

        hbm = NtGdiCreateCompatibleBitmap(hdc,cx,cy);

#if TRACE_SURFACE_ALLOCS
        {
            PULONG  pUserAlloc;

            PSHARED_GET_VALIDATE(pUserAlloc, hbm, SURF_TYPE);

            if (pUserAlloc != NULL)
            {
                pUserAlloc[1] = RtlWalkFrameChain((PVOID *)&pUserAlloc[2], pUserAlloc[0], 0);
            }
        }
#endif

        return(hbm);
    }

    return(NULL);
}

/******************************Public*Routine******************************\
* CreateDiscardableBitmap                                                  *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Tue 04-Jun-1991 16:35:51 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HBITMAP WINAPI CreateDiscardableBitmap
(
    HDC   hdc,
    int   cx,
    int   cy
)
{
    return CreateCompatibleBitmap(hdc, cx, cy);
}

/******************************Public*Routine******************************\
* CreateEllipticRgn                                                        *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Tue 04-Jun-1991 16:58:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HRGN WINAPI CreateEllipticRgn(int x1,int y1,int x2,int y2)
{
    return(NtGdiCreateEllipticRgn(x1,y1,x2,y2));
}

/******************************Public*Routine******************************\
* CreateEllipticRgnIndirect                                                *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Tue 04-Jun-1991 16:58:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HRGN WINAPI CreateEllipticRgnIndirect(CONST RECT *prcl)
{
    return
      CreateEllipticRgn
      (
        prcl->left,
        prcl->top,
        prcl->right,
        prcl->bottom
      );
}

/******************************Public*Routine******************************\
* CreateRoundRectRgn                                                       *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Tue 04-Jun-1991 17:23:16 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HRGN WINAPI CreateRoundRectRgn
(
    int x1,
    int y1,
    int x2,
    int y2,
    int cx,
    int cy
)
{
    return(NtGdiCreateRoundRectRgn(x1,y1,x2,y2,cx,cy));
}

/******************************Public*Routine******************************\
* CreatePalette                                                            *
*                                                                          *
* Simple client side stub.                                                 *
*                                                                          *
* Warning:                                                                 *
*   The pv field of a palette's lhe is used to determine if a palette      *
*   has been modified since it was last realized.  SetPaletteEntries       *
*   and ResizePalette will increment this field after they have            *
*   modified the palette.  It is only updated for metafiled palettes       *
*                                                                          *
*  Tue 04-Jun-1991 20:43:39 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HPALETTE WINAPI CreatePalette(CONST LOGPALETTE *plpal)
{

    return(NtGdiCreatePaletteInternal((LOGPALETTE*)plpal,plpal->palNumEntries));

}

/******************************Public*Routine******************************\
* CreateFontIndirectExW                                                    *
*                                                                          *
* Client Side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  7-12-94 -by- Lingyun Wang [lingyunw] removed LOCALFONT                  *
*  Sun 10-Jan-1993 04:08:33 -by- Charles Whitmer [chuckwh]                 *
* Restructured for best tail merging.  Added creation of the LOCALFONT.    *
*                                                                          *
*  Thu 15-Aug-1991 08:40:26 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

HFONT WINAPI CreateFontIndirectExW(CONST ENUMLOGFONTEXDVW *pelfw)
{
    LOCALFONT *plf;
    FLONG  fl = 0;
    HFONT hfRet = (HFONT) 0;

    if (pelfw->elfEnumLogfontEx.elfLogFont.lfEscapement | pelfw->elfEnumLogfontEx.elfLogFont.lfOrientation)
    {
        fl = LF_HARDWAY;
    }

    ENTERCRITICALSECTION(&semLocal);
    plf = plfCreateLOCALFONT(fl);
    LEAVECRITICALSECTION(&semLocal);

    if( plf != NULL )
    {
        if (pelfw->elfDesignVector.dvNumAxes <= MM_MAX_NUMAXES)
        {
            ULONG cjElfw = offsetof(ENUMLOGFONTEXDVW,elfDesignVector) +
                           SIZEOFDV(pelfw->elfDesignVector.dvNumAxes) ;
            hfRet = NtGdiHfontCreate((ENUMLOGFONTEXDVW *)pelfw, cjElfw, LF_TYPE_USER, 0, (PVOID) plf);
        }
    }

    if( !hfRet && plf )
    {
        vDeleteLOCALFONT( plf );
    }

    return(hfRet);
}


/******************************Public*Routine******************************\
* CreateFontIndirect                                                       *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Fri 16-Aug-1991 12:35:17 by Kirk Olynyk [kirko]                         *                          *
* Now uses CreateFontIndirectExW().                                       *
*                                                                          *
*  Tue 04-Jun-1991 21:06:44 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HFONT WINAPI CreateFontIndirectA(CONST LOGFONTA *plf)
{
    ENUMLOGFONTEXDVW elfw;

    if (plf == (LPLOGFONTA) NULL)
        return ((HFONT) 0);

    vConvertLogFont(&elfw,(LOGFONTA *) plf);

    if (GetAppCompatFlags2(VER40) & GACF2_DEFAULTCHARSET)
    {
        if (!_wcsicmp(elfw.elfEnumLogfontEx.elfLogFont.lfFaceName, L"OCR-A"))
            elfw.elfEnumLogfontEx.elfLogFont.lfCharSet = (BYTE) DEFAULT_CHARSET;
    }

    return(CreateFontIndirectExW(&elfw));
}

/******************************Public*Routine******************************\
* CreateFont                                                               *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Tue 04-Jun-1991 21:06:44 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HFONT WINAPI
CreateFontA(
    int      cHeight,
    int      cWidth,
    int      cEscapement,
    int      cOrientation,
    int      cWeight,
    DWORD    bItalic,
    DWORD    bUnderline,
    DWORD    bStrikeOut,
    DWORD    iCharSet,
    DWORD    iOutPrecision,
    DWORD    iClipPrecision,
    DWORD    iQuality,
    DWORD    iPitchAndFamily,
    LPCSTR   pszFaceName
    )
{
    LOGFONTA lf;

    lf.lfHeight             = (LONG)  cHeight;
    lf.lfWidth              = (LONG)  cWidth;
    lf.lfEscapement         = (LONG)  cEscapement;
    lf.lfOrientation        = (LONG)  cOrientation;
    lf.lfWeight             = (LONG)  cWeight;
    lf.lfItalic             = (BYTE)  bItalic;
    lf.lfUnderline          = (BYTE)  bUnderline;
    lf.lfStrikeOut          = (BYTE)  bStrikeOut;
    lf.lfCharSet            = (BYTE)  iCharSet;
    lf.lfOutPrecision       = (BYTE)  iOutPrecision;
    lf.lfClipPrecision      = (BYTE)  iClipPrecision;
    lf.lfQuality            = (BYTE)  iQuality;
    lf.lfPitchAndFamily     = (BYTE)  iPitchAndFamily;
    {
        INT jj;

    // Copy the facename if pointer not NULL.

        if (pszFaceName != (LPSTR) NULL)
        {
            for (jj=0; jj<LF_FACESIZE; jj++)
            {
                if( ( lf.lfFaceName[jj] = pszFaceName[jj] ) == 0 )
                {
                    break;
                }
            }
        }
        else
        {
            // If NULL pointer, substitute a NULL string.

            lf.lfFaceName[0] = '\0';
        }
    }

    return(CreateFontIndirectA(&lf));
}

/******************************Public*Routine******************************\
* HFONT WINAPI CreateFontIndirectW(LPLOGFONTW plfw)                        *
*                                                                          *
* History:                                                                 *
*  Fri 16-Aug-1991 14:12:44 by Kirk Olynyk [kirko]                         *
* Now uses CreateFontIndirectExW().                                       *
*                                                                          *
*  13-Aug-1991 -by- Bodin Dresevic [BodinD]                                *
* Wrote it.                                                                *
\**************************************************************************/

HFONT WINAPI CreateFontIndirectW(CONST LOGFONTW *plfw)
{
    ENUMLOGFONTEXDVW elfw;

    if (plfw == (LPLOGFONTW) NULL)
        return ((HFONT) 0);

    vConvertLogFontW(&elfw,(LOGFONTW *)plfw);

    if (GetAppCompatFlags2(VER40) & GACF2_DEFAULTCHARSET)
    {
        if (!_wcsicmp(elfw.elfEnumLogfontEx.elfLogFont.lfFaceName, L"OCR-A"))
            elfw.elfEnumLogfontEx.elfLogFont.lfCharSet = (BYTE) DEFAULT_CHARSET;
    }

    return(CreateFontIndirectExW(&elfw));
}

/******************************Public*Routine******************************\
* HFONT WINAPI CreateFontW, UNICODE version of CreateFont                  *
*                                                                          *
* History:                                                                 *
*  13-Aug-1991 -by- Bodin Dresevic [BodinD]                                *
* Wrote it.                                                                *
\**************************************************************************/

HFONT WINAPI CreateFontW
(
    int      cHeight,
    int      cWidth,
    int      cEscapement,
    int      cOrientation,
    int      cWeight,
    DWORD    bItalic,
    DWORD    bUnderline,
    DWORD    bStrikeOut,
    DWORD    iCharSet,
    DWORD    iOutPrecision,
    DWORD    iClipPrecision,
    DWORD    iQuality,
    DWORD    iPitchAndFamily,
    LPCWSTR  pwszFaceName
)
{
    LOGFONTW lfw;

    lfw.lfHeight             = (LONG)  cHeight;
    lfw.lfWidth              = (LONG)  cWidth;
    lfw.lfEscapement         = (LONG)  cEscapement;
    lfw.lfOrientation        = (LONG)  cOrientation;
    lfw.lfWeight             = (LONG)  cWeight;
    lfw.lfItalic             = (BYTE)  bItalic;
    lfw.lfUnderline          = (BYTE)  bUnderline;
    lfw.lfStrikeOut          = (BYTE)  bStrikeOut;
    lfw.lfCharSet            = (BYTE)  iCharSet;
    lfw.lfOutPrecision       = (BYTE)  iOutPrecision;
    lfw.lfClipPrecision      = (BYTE)  iClipPrecision;
    lfw.lfQuality            = (BYTE)  iQuality;
    lfw.lfPitchAndFamily     = (BYTE)  iPitchAndFamily;
    {
        INT jj;

    // Copy the facename if pointer not NULL.

        if (pwszFaceName != (LPWSTR) NULL)
        {
            for (jj=0; jj<LF_FACESIZE; jj++)
            {
                if( ( lfw.lfFaceName[jj] = pwszFaceName[jj] ) == (WCHAR) 0 )
                {
                    break;
                }
            }
        }
        else
        {
            // If NULL pointer, substitute a NULL string.

            lfw.lfFaceName[0] = L'\0';
        }
    }

    return(CreateFontIndirectW(&lfw));
}

/******************************Public*Routine******************************\
* CreateFontIndirectExA                                                   *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  31-Jan-1992 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

HFONT WINAPI CreateFontIndirectExA(CONST ENUMLOGFONTEXDVA *pelf)
{
    ENUMLOGFONTEXDVW elfw;

    if (!pelf)
        return ((HFONT) 0);

    vConvertEnumLogFontExDvAtoW(&elfw, (ENUMLOGFONTEXDVA *)pelf);

    if (GetAppCompatFlags2(VER40) & GACF2_DEFAULTCHARSET)
    {
        if (!_wcsicmp(elfw.elfEnumLogfontEx.elfLogFont.lfFaceName, L"OCR-A"))
            elfw.elfEnumLogfontEx.elfLogFont.lfCharSet = (BYTE) DEFAULT_CHARSET;
    }

    return(CreateFontIndirectExW(&elfw));
}

/******************************Public*Routine******************************\
* UnrealizeObject
*
* This nukes the realization for a object.
*
* History:
*  16-May-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL WINAPI UnrealizeObject(HANDLE h)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(h);

// Validate the object.  Only need to handle palettes.

    if (LO_TYPE(h) == LO_BRUSH_TYPE)
    {
        bRet = TRUE;
    }
    else
    {
        bRet = NtGdiUnrealizeObject(h);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* DeleteObject()
*
\**************************************************************************/

BOOL META DeleteObject (HANDLE h)
{
    BOOL bRet = TRUE;
    INT iType = GRE_TYPE(h);
    BOOL bValidate;
    BOOL bDynamicNonStock;
    LOCALFONT *plf = NULL;    // essental initialization

    FIXUP_HANDLEZ(h);

    VALIDATE_HANDLE_AND_STOCK (bValidate, h, iType, bDynamicNonStock);
    if (!bValidate)
    {
        if (!bValidate)
            return (0);
    }

        if (iType != DC_TYPE)
        {
            if ((LO_TYPE(h) == LO_METAFILE16_TYPE) || (LO_TYPE(h) == LO_METAFILE_TYPE))
            {
                return(FALSE);
            }
            else if (LO_TYPE(h) == LO_REGION_TYPE)
            {
                return(DeleteRegion(h));
            }
            else if (LO_TYPE(h) == LO_ICMLCS_TYPE)
            {
            // ATTENTION: Win95 does not allow delete ColorSpace by DeleteObject()
            // This might causes imcompatibility... but keep consistant 
            // with other GDI objects                                   

                return(DeleteColorSpace(h));
            }
            else if (IS_STOCKOBJ(h))
            {
            // Don't delete a stock object, just return TRUE for 3.1 compatibility.

                return(TRUE);
            }
            else
            {
            // Inform the metafile if it knows this object.

                if (pmetalink16Get(h) != NULL)
                {
                // must recheck the metalink because MF_DeleteObject might delete it

                    if (!MF_DeleteObject(h) ||
                        (pmetalink16Get(h) && !MF16_DeleteObject(h)))
                    {
                        return(FALSE);
                    }
                }

            // handle delete LogFont

                if (LO_TYPE(h) == LO_FONT_TYPE)
                {
                    PSHARED_GET_VALIDATE(plf,h,LFONT_TYPE);

                    if (plf)
                    {
                    // we always force deletion of the client side memory even if
                    // the font is still selected in some dc's. All that means is that
                    // text api's will have to go through the slow code paths in this
                    // pathological case.

                        vDeleteLOCALFONT(plf);
                    }
                }

                if (bDynamicNonStock)
                    h = (HANDLE)((ULONG_PTR)h|GDISTOCKOBJ);

            // handle deletebrush

                if (
                     (LO_TYPE(h) == LO_BRUSH_TYPE) ||
                     (LO_TYPE(h) == LO_PEN_TYPE)
                   )
                {
                    PBRUSHATTR pBrushattr;

                    PSHARED_GET_VALIDATE(pBrushattr,h,BRUSH_TYPE);

                    if (
                         (bDynamicNonStock) ||
                         ((pBrushattr) &&
                         (!(pBrushattr->AttrFlags & (ATTR_CACHED|ATTR_TO_BE_DELETED|ATTR_CANT_SELECT))))
                       )
                    {
                        BEGIN_BATCH(BatchTypeDeleteBrush,BATCHDELETEBRUSH);

                            if (!bDynamicNonStock)
                                pBrushattr->AttrFlags |= ATTR_CANT_SELECT;
                            pBatch->Type    = BatchTypeDeleteBrush;
                            pBatch->Length  = sizeof(BATCHDELETEBRUSH);
                            pBatch->hbrush  = h;

                        COMPLETE_BATCH_COMMAND();

                        return(TRUE);
                    }

                }

            // handle delete bitmap

                if (LO_TYPE(h) == LO_BITMAP_TYPE)
                {
                    // PCACHED_COLORSPACE pColorSpace;
                    //
                    // if this bitmap has thier own color space delete it, too.
                    //
                    // [NOTE:] Only DIB section can has a thier own color space,
                    // then, if we can identify this is DIB section or not from
                    // client side, we can optimize this call for non-DIB section case.
                    //
                    // pColorSpace = IcmGetColorSpaceforBitmap(h);
                    //
                    // if (pColorSpace)
                    // {
                    //     IcmReleaseColorSpace((HGDIOBJ)h,pColorSpace,TRUE);
                    // }
                    //

                    //
                    // Release any color space associated to this bitmap.
                    //
                    IcmReleaseCachedColorSpace((HGDIOBJ)h);
                }
            }

UNBATCHED_COMMAND:

            bRet = NtGdiDeleteObjectApp(h);

            #if DBG
                if (bRet && (LO_TYPE(h) == LO_FONT_TYPE))
                {
                    PSHARED_GET_VALIDATE(plf,h,LFONT_TYPE);
                    ASSERTGDI(plf == NULL, "DeleteFont: plf nonzero after deletion\n");
                }
            #endif
        }
        else
        {
            bRet = DeleteDC(h);
        }

    return(bRet);
}

/**************************************************************************\
* SelectObject
*
*  Thu 06-Jun-1991 00:58:46 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

HANDLE META SelectObject(HDC hdc,HANDLE h)
{
    HANDLE hRet = 0;
    HDC  *phdc;
    FLONG fl;
    INT   iType;
    PDC_ATTR pdcattr = NULL;
    BOOL bValid;

    FIXUP_HANDLE(hdc);
    FIXUP_HANDLE_NOW(h);

    VALIDATE_HANDLE(bValid, h, GRE_TYPE(h));

    if (!bValid)
    {
       return (HANDLE)0;
    }

    iType = LO_TYPE(h);

    // Palettes isn't allowed

    if (iType == LO_PALETTE_TYPE)
    {
        SetLastError(ERROR_INVALID_FUNCTION);
        return (HANDLE)0;
    }

    // Do region first so that it is not metafiled twice.

    if (iType == LO_REGION_TYPE)
    {
        LONG_PTR iRet = ExtSelectClipRgn(hdc,h,RGN_COPY);
        return((HANDLE)iRet);
    }
    else if (iType == LO_ICMLCS_TYPE)
    {
        return(SetColorSpace(hdc,h));
    }

    //
    // Metafile the call.
    //

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_SelectObject(hdc, h));

        DC_PLDC(hdc,pldc,0);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SelectAnyObject(hdc,h,EMR_SELECTOBJECT))
                return((HANDLE) 0);
        }
    }

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        switch (iType)
        {
        case LO_EXTPEN_TYPE:

            if (bNeedTranslateColor(pdcattr))
            {
                return(IcmSelectExtPen(hdc,pdcattr,h));
            }

            //hRet = NtGdiSelectPen(hdc,(HPEN)h);
            pdcattr->ulDirty_ |= DC_PEN_DIRTY;
            hRet = pdcattr->hpen;
            pdcattr->hpen = h;

            break;

        case LO_PEN_TYPE:

            if (bNeedTranslateColor(pdcattr))
            {
                return(IcmSelectPen(hdc,pdcattr,h));
            }

            //
            // Always set the dirty flag to
            // make sure the brush is checked in
            // the kernel. For example, NEW_COLOR, might be set.
            //

            pdcattr->ulDirty_ |= DC_PEN_DIRTY;
            hRet = pdcattr->hpen;
            pdcattr->hpen = h;

            break;

        case LO_BRUSH_TYPE:

            if (bNeedTranslateColor(pdcattr))
            {
                return(IcmSelectBrush(hdc,pdcattr,h));
            }

            //
            // Always set the dirty flag to
            // make sure the brush is checked in
            // the kernel. For example, NEW_COLOR, might be set.
            //

            pdcattr->ulDirty_ |= DC_BRUSH_DIRTY;
            hRet = pdcattr->hbrush;
            pdcattr->hbrush = h;

            break;

        case LO_BITMAP_TYPE:
            {
                BOOL bDIBSelected;

                //
                // Currently DIB section is selected ?
                //
                bDIBSelected = bDIBSectionSelected(pdcattr);

                //
                // Select bitmap into DC.
                //

                hRet = NtGdiSelectBitmap(hdc,(HBITMAP)h);

                if (hRet)
                {
                    //
                    // DDB to DDB case, color space never has been changed.
                    //
                    if (bDIBSelected || bDIBSectionSelected(pdcattr))
                    {
                        //
                        // Marks the color space might be changed.
                        //
                        pdcattr->ulDirty_ |= (DIRTY_COLORSPACE|DIRTY_COLORTRANSFORM);

                        //
                        // if ICM is currently turned-ON, update now.
                        //
                        if (IS_ICM_INSIDEDC(pdcattr->lIcmMode))
                        {
                            //
                            // Destination bitmap surface has been changed,
                            // then need to update destination color space and
                            // color transform.
                            //
                            IcmUpdateDCColorInfo(hdc,pdcattr);
                        }
                    }
                }
            }

            break;

        case LO_FONT_TYPE:
            {
                UINT uiIndex = HANDLE_TO_INDEX(h);
                PENTRY pentry = NULL;

                pentry = &pGdiSharedHandleTable[uiIndex];

                if (pentry->Flags & HMGR_ENTRY_LAZY_DEL)
                {
                   hRet = 0;
                }
                else
                {
                   hRet = pdcattr->hlfntNew;

                   if (DIFFHANDLE(hRet, h))
                   {
                      pdcattr->ulDirty_ |= DIRTY_CHARSET;
                      pdcattr->ulDirty_ &= ~SLOW_WIDTHS;

                      pdcattr->hlfntNew = h;

                      //
                      // batch selectfont, to ensure ref count is correct when
                      // deletefont comes in
                      // we have to allow lazy deletion.
                      //
                      BEGIN_BATCH_HDC(hdc,pdcattr,BatchTypeSelectFont,BATCHSELECTFONT);

                          pBatch->hFont  = h;

                      COMPLETE_BATCH_COMMAND();
                          return ((HANDLE)hRet);

                      UNBATCHED_COMMAND:
                          return(NtGdiSelectFont(hdc,h));

                   }

                }
            }
            break;

        default:
            break;
        }
    }
    else
    {
        WARNING("Bad DC passed to SelectObject\n");
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        hRet = 0;
    }


    return((HANDLE) hRet);
}

/******************************Public*Routine******************************\
* GetCurrentObject                                                         *
*                                                                          *
* Client side routine.                                                     *
*                                                                          *
*  03-Oct-1991 00:58:46 -by- John Colleran [johnc]                         *
* Wrote it.                                                                *
\**************************************************************************/

HANDLE WINAPI GetCurrentObject(HDC hdc, UINT iObjectType)
{
    HANDLE hRet;

    FIXUP_HANDLE(hdc);

    switch (iObjectType)
    {
    case OBJ_BRUSH:
        iObjectType = LO_BRUSH_TYPE;
        break;

    case OBJ_PEN:
    case OBJ_EXTPEN:
        iObjectType = LO_PEN_TYPE;
        break;

    case OBJ_FONT:
        iObjectType = LO_FONT_TYPE;
        break;

    case OBJ_PAL:
        iObjectType = LO_PALETTE_TYPE;
        break;

    case OBJ_BITMAP:
        iObjectType = LO_BITMAP_TYPE;
        break;

    case OBJ_COLORSPACE:
        iObjectType = LO_ICMLCS_TYPE;
        break;

    default:
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return((HANDLE) 0);
    }

    hRet = GetDCObject(hdc, iObjectType);

    return(hRet);
}

/******************************Public*Routine******************************\
* GetStockObject                                                           *
*                                                                          *
* A simple function which looks the object up in a table.                  *
*                                                                          *
\**************************************************************************/

HANDLE
GetStockObject(
    int iObject)
{
    //
    // if it is in range, 0 - PRIV_STOCK_LAST, and we have gotten the stock
    // objects, return the handle.  Otherwise fail.
    //

    //
    // WINBUG #82871 2-7-2000 bhouse Possible bug in GetStockObject
    // Old Comment:
    //     - what about our private stock bitmap ??
    //
    // NOTE we should make this table part of the shared section since it is
    // used by all applications.
    //

    if ((ULONG)iObject <= PRIV_STOCK_LAST)
    {
        if ((HANDLE) ahStockObjects[iObject] == NULL)
        {
            //
            // If the kernel transition fails, the return value
            // may actually an NTSTATUS return value such as
            // STATUS_INVALID_SYSTEM_SERVICE (this has happened
            // under rare stress scenarios).
            //
            // If we return the occasional bad handle under stress,
            // so be it, but we shouldn't cache these bad handles
            // in gdi32.dll.  So do validation before accepting
            // the handle.
            //

            HANDLE h = NtGdiGetStockObject(iObject);
            BOOL bValid;

            VALIDATE_HANDLE(bValid, h, GRE_TYPE(h));

            if (bValid)
            {
                ahStockObjects[iObject] = (ULONG_PTR) h;
            }
        }
        return((HANDLE) ahStockObjects[iObject]);
    }
    else
    {
        return((HANDLE)0);
    }
}

/******************************Public*Routine******************************\
* EqualRgn                                                                 *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Thu 06-Jun-1991 00:58:46 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL WINAPI EqualRgn(HRGN hrgnA,HRGN hrgnB)
{
    FIXUP_HANDLE(hrgnA);
    FIXUP_HANDLE(hrgnB);

    return(NtGdiEqualRgn(hrgnA,hrgnB));
}

/******************************Public*Routine******************************\
* GetBitmapDimensionEx                                                       *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Thu 06-Jun-1991 00:58:46 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL WINAPI GetBitmapDimensionEx(HBITMAP hbm,LPSIZE psizl)
{
    FIXUP_HANDLE(hbm);

    return(NtGdiGetBitmapDimension(hbm, psizl));
}

/******************************Public*Routine******************************\
* GetNearestPaletteIndex
*
* Client side stub.
*
*  Sat 31-Aug-1991 -by- Patrick Haluptzok [patrickh]
* Change to UINT
*
*  Thu 06-Jun-1991 00:58:46 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

UINT WINAPI GetNearestPaletteIndex(HPALETTE hpal,COLORREF color)
{
    FIXUP_HANDLE(hpal);

    return(NtGdiGetNearestPaletteIndex(hpal,color));
}

/******************************Public*Routine******************************\
* ULONG cchCutOffStrLen(PSZ pwsz, ULONG cCutOff)
*
* search for terminating zero but make sure not to slipp off the edge,
* return value counts in the term. zero if one is found
*
*
* History:
*  22-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

ULONG cchCutOffStrLen(PSZ psz, ULONG cCutOff)
{
    ULONG cch;

    for(cch = 0; cch < cCutOff; cch++)
    {
        if (*psz++ == 0)
            return(cch);        // terminating NULL is NOT included in count!
    }

    return(cCutOff);
}

/******************************Public*Routine******************************\
* ULONG cwcCutOffStrLen(PWSZ pwsz, ULONG cCutOff)
*
* search for terminating zero but make sure not to slipp off the edge,
* return value counts in the term. zero if one is found
*
*
* History:
*  22-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

ULONG cwcCutOffStrLen(PWSZ pwsz, ULONG cCutOff)
{
    ULONG cwc;

    for(cwc = 0; cwc < cCutOff; cwc++)
    {
        if (*pwsz++ == 0)
            return(cwc + 1);  // include the terminating NULL
    }

    return(cCutOff);
}

/******************************Public*Routine******************************\
* int cjGetNonFontObject()
*
* Does a GetObject on all objects that are not fonts.
*
* History:
*  19-Mar-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

int cjGetNonFontObject(HANDLE h, int c, LPVOID pv)
{
    int cRet = 0;
    int cGet = c;
    int iType;

    iType = LO_TYPE(h);

    ASSERTGDI(iType != LO_FONT_TYPE, "Can't handle fonts");

    if (iType == LO_REGION_TYPE)
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
        return(cRet);
    }

    if (pv == NULL)
    {
        if (iType == LO_BRUSH_TYPE)
        {
            return(sizeof(LOGBRUSH));
        }
        else if (iType == LO_PEN_TYPE)
        {
            return(sizeof(LOGPEN));
        }
    }

    FIXUP_HANDLE_NOW (h);

    cRet = NtGdiExtGetObjectW(h,c,pv);

    return(cRet);
}

/******************************Public*Routine******************************\
* int WINAPI GetObjectW(HANDLE h,int c,LPVOID pv)
*
* History:
*  07-Dec-1994 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

int  WINAPI GetObjectW(HANDLE h,int c,LPVOID pv)
{
    int cRet = 0;

    FIXUP_HANDLEZ(h);

    switch (LO_TYPE(h))
    {
    case LO_ALTDC_TYPE:
    case LO_DC_TYPE:
    case LO_METAFILE16_TYPE:
    case LO_METAFILE_TYPE:
        GdiSetLastError(ERROR_INVALID_HANDLE);
        cRet = 0;
        break;

    case LO_FONT_TYPE:
        if (pv == (LPVOID) NULL)
        {
            return(sizeof(LOGFONTW));
        }

        if (c > (int)sizeof(ENUMLOGFONTEXDVW))
            c = (int)sizeof(ENUMLOGFONTEXDVW);

        cRet = NtGdiExtGetObjectW(h,c,pv);

        break;

    case LO_ICMLCS_TYPE:
        if (GetLogColorSpaceW(h,pv,c))
        {
            cRet = sizeof(LOGCOLORSPACEW);
        }
        break;

    default:
        cRet = cjGetNonFontObject(h,c,pv);
        break;
    }

    return(cRet);
}

/******************************Public*Routine******************************\
* int WINAPI GetObjectA(HANDLE h,int c,LPVOID pv)
*
* History:
*  07-Dec-1994 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

int  WINAPI GetObjectA(HANDLE h,int c,LPVOID pv)
{
    int  cRet = 0;

    FIXUP_HANDLEZ(h);

    switch (LO_TYPE(h))
    {
    case LO_ALTDC_TYPE:
    case LO_DC_TYPE:
    case LO_METAFILE16_TYPE:
    case LO_METAFILE_TYPE:
        GdiSetLastError(ERROR_INVALID_HANDLE);
        return(0);

    case LO_FONT_TYPE:
        break;

    case LO_ICMLCS_TYPE:
        if (GetLogColorSpaceA(h,pv,c))
        {
            cRet = sizeof(LOGCOLORSPACEW);
        }
        break;

    default:
        return(cjGetNonFontObject(h,c,pv));
    }

// Now handle only font objects:

    if (pv)
    {
        ENUMLOGFONTEXDVW elfw;

        cRet = NtGdiExtGetObjectW(h,sizeof(ENUMLOGFONTEXDVW),&elfw);

        if (cRet)
        {
        // we shall optimize usual cases when the caller is asking the whole thing

            //
            // Hack, Hack:Office ME 97 call GetObjectA with a pointer to LOGFONTA and
            // specify c = sizeof(LOGFONTW) by mistake, But it use to work under NT 4
            // Then what we do here is check this case and still return the sizeof(LOGFONTA)
            //

            if ((c == sizeof(LOGFONTA)) || (c == sizeof(LOGFONTW)))
            {
                if (bConvertLogFontWToLogFontA((LOGFONTA *)pv,
                                               &elfw.elfEnumLogfontEx.elfLogFont))
                {
                    cRet = sizeof(LOGFONTA);
                }
                else
                {
                    cRet = 0;
                }
            }
            else if (c == sizeof(ENUMLOGFONTEXA))
            {
                if (bConvertEnumLogFontExWToEnumLogFontExA((ENUMLOGFONTEXA*)pv, &elfw.elfEnumLogfontEx))
                {
                    cRet = c;
                }
                else
                {
                    cRet = 0;
                }
            }
            else if (c == sizeof(ENUMLOGFONTEXDVA))
            {
                if (bConvertEnumLogFontExWToEnumLogFontExA((ENUMLOGFONTEXA*)pv, &elfw.elfEnumLogfontEx))
                {
                // copy out design vector

                    RtlMoveMemory(&((ENUMLOGFONTEXDVA*)pv)->elfDesignVector,
                                  &elfw.elfDesignVector,
                                  SIZEOFDV(elfw.elfDesignVector.dvNumAxes));

                    cRet = c;
                }
                else
                {
                    cRet = 0;
                }
            }
            else // general case
            {
                ENUMLOGFONTEXDVA elfa;
                c = min(c,sizeof(ENUMLOGFONTEXDVA));

                if (bConvertEnumLogFontExWToEnumLogFontExA(&elfa.elfEnumLogfontEx,
                                                           &elfw.elfEnumLogfontEx))
                {

                // copy out design vector

                    RtlMoveMemory(&elfa.elfDesignVector,
                                  &elfw.elfDesignVector,
                                  SIZEOFDV(elfw.elfDesignVector.dvNumAxes));

                    cRet = c;
                    RtlMoveMemory(pv,&elfa,cRet);
                }
                else
                {
                    cRet = 0;
                }
            }
        }
    }
    else
    {
        cRet = sizeof(LOGFONTA);
    }

    return(cRet);
}


/******************************Public*Routine******************************\
* GetObjectType(HANDLE)
*
* History:
*  25-Jul-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

DWORD alPublicTypes[] =
{
    0,              // LO_NULL,
    OBJ_DC,         // LO_DC,
    OBJ_ENHMETADC   // LO_METADC,
};

DWORD GetObjectType(HGDIOBJ h)
{
    DWORD dwRet = 0;
    UINT uiIndex;

    FIXUP_HANDLE(h);

    uiIndex = HANDLE_TO_INDEX(h);

    if (uiIndex < MAX_HANDLE_COUNT)
    {
        PENTRY pentry = &pGdiSharedHandleTable[uiIndex];

        if (
             (pentry->FullUnique == (USHORT)((ULONG_PTR)h >> 16)) &&
             ((OBJECTOWNER_PID(pentry->ObjectOwner) == gW32PID) ||
              (OBJECTOWNER_PID(pentry->ObjectOwner) == 0))
              )
        {
            switch (LO_TYPE(h))
            {
            case LO_BRUSH_TYPE:
                dwRet = OBJ_BRUSH;
                break;

            case LO_REGION_TYPE:
                dwRet = OBJ_REGION;
                break;

            case LO_PEN_TYPE:
                dwRet = OBJ_PEN;
                break;

            case LO_EXTPEN_TYPE:
                dwRet = OBJ_EXTPEN;
                break;

            case LO_FONT_TYPE:
                dwRet = OBJ_FONT;
                break;

            case LO_BITMAP_TYPE:
                dwRet = OBJ_BITMAP;
                break;

            case LO_PALETTE_TYPE:
                dwRet = OBJ_PAL;
                break;

            case LO_METAFILE16_TYPE:
                dwRet = OBJ_METAFILE;
                break;

            case LO_METAFILE_TYPE:
                dwRet = OBJ_ENHMETAFILE;
                break;

            case LO_METADC16_TYPE:
                dwRet = OBJ_METADC;
                break;

            case LO_DC_TYPE:

                if( GetDCDWord( h, DDW_ISMEMDC, FALSE ) )
                {
                    dwRet = OBJ_MEMDC;
                }
                else
                {
                    dwRet = OBJ_DC;
                }
                break;

            case LO_ALTDC_TYPE:
                {
                    PLDC pldc;
                    DC_PLDC(h,pldc,0);

                    if (pldc->fl & LDC_META_PRINT)
                    {
                        //
                        // While we are doing EMF spooling, we lie to
                        // application to the HDC is real DC, not metafile
                        // DC, even it is actually metafile DC.
                        //
                        // This resolve the problem with Office97 + WordArt.
                        //
                        // (Raid #98810: WordArt doesn't print correctly to PS
                        //               printers when EMF spooling is turned on)
                        //

                        dwRet = OBJ_DC;
                    }
                    else
                    {
                        dwRet = alPublicTypes[pldc->iType];
                    }
                }
                break;

            case LO_ICMLCS_TYPE:
                dwRet = OBJ_COLORSPACE;
                break;

            default:
                GdiSetLastError(ERROR_INVALID_HANDLE);
                break;
            }
        }
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* ResizePalette                                                            *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* Warning:                                                                 *
*   The pv field of a palette's LHE is used to determine if a palette      *
*   has been modified since it was last realized.  SetPaletteEntries       *
*   and ResizePalette will increment this field after they have            *
*   modified the palette.  It is only updated for metafiled palettes       *
*                                                                          *
*  Thu 06-Jun-1991 00:58:46 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL WINAPI ResizePalette(HPALETTE hpal,UINT c)
{
    ULONG bRet = FALSE;
    PMETALINK16 pml16;

    FIXUP_HANDLE(hpal);

// Inform the metafile if it knows this object.

    if (pml16 = pmetalink16Get(hpal))
    {
        if (LO_TYPE(hpal) != LO_PALETTE_TYPE)
            return(bRet);

        if (!MF_ResizePalette(hpal,c))
            return(bRet);

        if (!MF16_ResizePalette(hpal,c))
           return(bRet);

        // Mark the palette as changed (for 16-bit metafile tracking)

        pml16->pv = (PVOID)(((ULONG_PTR)pml16->pv)++);
    }

    return(NtGdiResizePalette(hpal,c));
}

/******************************Public*Routine******************************\
* SetBitmapDimensionEx                                                       *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Thu 06-Jun-1991 00:58:46 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL WINAPI SetBitmapDimensionEx
(
    HBITMAP    hbm,
    int        cx,
    int        cy,
    LPSIZE psizl
)
{
    FIXUP_HANDLE(hbm);

    return(NtGdiSetBitmapDimension(hbm, cx, cy, psizl));

}

/******************************Public*Routine******************************\
* GetMetaRgn                                                               *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Fri Apr 10 10:12:36 1992     -by-    Hock San Lee    [hockl]            *
* Wrote it.                                                                *
\**************************************************************************/

int WINAPI GetMetaRgn(HDC hdc,HRGN hrgn)
{
    FIXUP_HANDLE(hdc);
    FIXUP_HANDLE(hrgn);

    return(GetRandomRgn(hdc, hrgn, 2));         // hrgnMeta
}

/******************************Private*Routine******************************\
* GdiSetLastError                                                          *
*                                                                          *
* Client side private function.                                            *
*                                                                          *
\**************************************************************************/

VOID GdiSetLastError(ULONG iError)
{
#if DBG_X
    PSZ psz;
    switch (iError)
    {
    case ERROR_INVALID_HANDLE:
        psz = "ERROR_INVALID_HANDLE";
        break;

    case ERROR_NOT_ENOUGH_MEMORY:
        psz = "ERROR_NOT_ENOUGH_MEMORY";
        break;

    case ERROR_INVALID_PARAMETER:
        psz = "ERROR_INVALID_PARAMETER";
        break;

    case ERROR_BUSY:
        psz = "ERROR_BUSY";
        break;

    default:
        psz = "unknown error code";
        break;
    }

    KdPrint(( "GDI Err: %s = 0x%04X\n",psz,(USHORT) iError ));
#endif

    NtCurrentTeb()->LastErrorValue = iError;
}

/******************************Public*Routine******************************\
* ExtCreateRegion
*
* Upload a region to the server
*
* History:
*  29-Oct-1991 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

HRGN WINAPI ExtCreateRegion(
CONST XFORM * lpXform,
DWORD     nCount,
CONST RGNDATA * lpRgnData)
{

    ULONG   ulRet;

    if (lpRgnData == (LPRGNDATA) NULL)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return((HRGN) 0);
    }

    //
    // Perf: use CreateRectRgn when possible
    //
    if ((lpXform == NULL) && (lpRgnData->rdh.nCount == 1))
    {
       RECT * prcl = (RECT *)(lpRgnData->Buffer);

       return (CreateRectRgn(prcl->left, prcl->top, prcl->right, prcl->bottom));
    }
    else
    {
        return(NtGdiExtCreateRegion((LPXFORM)lpXform, nCount, (LPRGNDATA)lpRgnData));
    }

}

/******************************Public*Routine******************************\
* MonoBitmap(hbr)
*
* Test if a brush is monochrome
*
* History:
*  09-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL MonoBitmap(HBITMAP hbm)
{
    return(NtGdiMonoBitmap(hbm));
}

/******************************Public*Routine******************************\
* GetObjectBitmapHandle(hbr)
*
* Get the SERVER handle of the bitmap used to create the brush or pen.
*
* History:
*  09-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

HBITMAP GetObjectBitmapHandle(
HBRUSH  hbr,
UINT   *piUsage)
{
    FIXUP_HANDLE(hbr);

    return(NtGdiGetObjectBitmapHandle(hbr,piUsage));
}

/******************************Public*Routine******************************\
* EnumObjects
*
* Calls the NtGdiEnumObjects function twice: once to determine the number of
* objects to be enumerated, and a second time to fill a buffer with the
* objects.
*
* The callback function is called for each of the objects in the buffer.
* The enumeration will be prematurely terminated if the callback function
* returns 0.
*
* Returns:
*   The last callback return value.  Meaning is user defined.  ERROR if
*   an error occurs.
*
* History:
*  25-Mar-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

int EnumObjects (
    HDC             hdc,
    int             iObjectType,
    GOBJENUMPROC    lpObjectFunc,
#ifdef STRICT
    LPARAM          lpData
#else
    LPVOID          lpData
#endif
    )
{
    int     iRet = ERROR;
    ULONG   cjObject;       // size of a single object
    ULONG   cObjects;       // number of objects to process
    ULONG   cjBuf;          // size of buffer (in BYTEs)
    PVOID   pvBuf;          // object buffer; do callbacks with pointers into this buffer
    PBYTE   pjObj, pjObjEnd;// pointers into callback buffer

    FIXUP_HANDLE(hdc);

// Determine size of object.

    switch (iObjectType)
    {
    case OBJ_PEN:
        cjObject = sizeof(LOGPEN);
        break;

    case OBJ_BRUSH:
        cjObject = sizeof(LOGBRUSH);
        break;

    default:
        WARNING1("gdi!EnumObjects(): bad object type\n");
        GdiSetLastError(ERROR_INVALID_PARAMETER);

        return iRet;
    }

// Call NtGdiEnumObjects to determine number of objects.

    if ( (cObjects = NtGdiEnumObjects(hdc, iObjectType, 0, (PVOID) NULL)) == 0 )
    {
        WARNING("gdi!EnumObjects(): error, no objects\n");
        return iRet;
    }

// Allocate buffer for callbacks.

    cjBuf = cObjects * cjObject;

    if ( (pvBuf = (PVOID) LOCALALLOC(cjBuf)) == (PVOID) NULL )
    {
        WARNING("gdi!EnumObjects(): error allocating callback buffer\n");
        GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);

        return iRet;
    }

// Call NtGdiEnumObjects to fill buffer.

// Note: while NtGdiEnumObjects will never return a count more than the size of
// the buffer (this would be an ERROR condition), it might return less.

    if ( (cObjects = NtGdiEnumObjects(hdc, iObjectType, cjBuf, pvBuf)) == 0 )
    {
        WARNING("gdi!EnumObjects(): error filling callback buffer\n");
        LOCALFREE(pvBuf);

        return iRet;
    }

// Process callbacks.

    pjObj    = (PBYTE) pvBuf;
    pjObjEnd = (PBYTE) pvBuf + cjBuf;

    for (; pjObj < pjObjEnd; pjObj += cjObject)
    {
    // Terminate early if callback returns 0.

        if ( (iRet = (*lpObjectFunc)((LPVOID) pjObj, lpData)) == 0 )
            break;
    }

// Release callback buffer.

    LOCALFREE(pvBuf);

// Return last callback return value.

    return iRet;
}

/**********************************************************************\
* GetDCObject                                                         *
* Get Server side DC objects                                          *
*                                                                     *
* 14-11-94 -by- Lingyun Wang [lingyunw]                               *
* Wrote it                                                            *
\**********************************************************************/

HANDLE GetDCObject (HDC hdc, int iType)
{
    if (
         (iType == LO_BRUSH_TYPE)  ||
         (iType == LO_PEN_TYPE)    ||
         (iType == LO_EXTPEN_TYPE) ||
         (iType == LO_ICMLCS_TYPE)
       )
    {
        PDC_ATTR pdca;
        HANDLE      iret = 0;

        PSHARED_GET_VALIDATE(pdca,hdc,DC_TYPE);

        if (pdca != NULL)
        {
            switch (iType)
            {
            case LO_BRUSH_TYPE:
                iret = pdca->hbrush;
                break;

            case LO_PEN_TYPE:
            case LO_EXTPEN_TYPE:
                iret = pdca->hpen;
                break;

            case LO_ICMLCS_TYPE:
                iret = pdca->hColorSpace;
                break;
            }
        }

        return(iret);
    }
    else
    {
        return(NtGdiGetDCObject(hdc,iType));
    }
}


/******************************Public*Routine******************************\
* HANDLE CreateClientObj()
*
* History:
*  18-Jan-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HANDLE CreateClientObj(
    ULONG ulType)
{
    return(NtGdiCreateClientObj(ulType));
}

/******************************Public*Routine******************************\
* BOOL DeleteClientObj()
*
* History:
*  18-Jan-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL DeleteClientObj(
    HANDLE h)
{
    return(NtGdiDeleteClientObj(h));
}

/******************************Public*Routine******************************\
* BOOL MakeInfoDC()
*
*   Temporarily make a printer DC a INFO DC.  This is used to be able to
*   associate a metafile with a printer DC.
*
*   bSet = TRUE  - set as info
*          FALSE - restore
*
* History:
*  19-Jan-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL MakeInfoDC(
    HDC hdc,
    BOOL bSet)
{
    FIXUP_HANDLE(hdc);

    return(NtGdiMakeInfoDC(hdc,bSet));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\path.c ===
/******************************Module*Header*******************************\
* Module Name: path.c
*
* Client side stubs for graphics path calls.
*
* Created: 13-Sep-1991
* Author: J. Andrew Goossen [andrewgo]
*
* Copyright (c) 1991-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

/******************************Public*Routine******************************\
* AbortPath
*
* Client side stub.
*
* History:
*  20-Mar-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL META WINAPI AbortPath(HDC hdc)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(bRet);

        DC_PLDC(hdc,pldc,bRet);

        if ((pldc->iType == LO_METADC) &&
            !MF_Record(hdc,EMR_ABORTPATH))
        {
            return(bRet);
        }
    }

    return(NtGdiAbortPath(hdc));
}

/******************************Public*Routine******************************\
* BeginPath
*
* Client side stub.
*
* History:
*  13-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL META WINAPI BeginPath(HDC hdc)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(bRet);

        DC_PLDC(hdc,pldc,bRet);

        if ((pldc->iType == LO_METADC) &&
            !MF_Record(hdc,EMR_BEGINPATH))
        {
            return(bRet);
        }
    }

    return(NtGdiBeginPath(hdc));

}

/******************************Public*Routine******************************\
* SelectClipPath
*
* Client side stub.
*
* History:
*  13-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL META WINAPI SelectClipPath(HDC hdc, int iMode)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(bRet);

        DC_PLDC(hdc,pldc,bRet);

        if ((pldc->iType == LO_METADC) &&
            !MF_SelectClipPath(hdc,iMode))
        {
            return(bRet);
        }
    }

    return(NtGdiSelectClipPath(hdc,iMode));
}

/******************************Public*Routine******************************\
* CloseFigure
*
* Client side stub.
*
* History:
*  13-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL META WINAPI CloseFigure(HDC hdc)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE (hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(bRet);

        DC_PLDC(hdc,pldc,bRet);

        if ((pldc->iType == LO_METADC) &&
            !MF_Record(hdc,EMR_CLOSEFIGURE))
        {
            return(bRet);
        }
    }

    return(NtGdiCloseFigure(hdc));

}

/******************************Public*Routine******************************\
* EndPath
*
* Client side stub.
*
* History:
*  13-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL META WINAPI EndPath(HDC hdc)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(bRet);

        DC_PLDC(hdc,pldc,bRet);

        if ((pldc->iType == LO_METADC) &&
            !MF_Record(hdc,EMR_ENDPATH))
        {
            return(bRet);
        }
    }


    return(NtGdiEndPath(hdc));

}

/******************************Public*Routine******************************\
* FlattenPath
*
* Client side stub.
*
* History:
*  13-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL META WINAPI FlattenPath(HDC hdc)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(bRet);

        DC_PLDC(hdc,pldc,bRet);

        if ((pldc->iType == LO_METADC) &&
            !MF_Record(hdc,EMR_FLATTENPATH))
        {
            return(bRet);
        }
    }


    return(NtGdiFlattenPath(hdc));

}

/******************************Public*Routine******************************\
* StrokeAndFillPath
*
* Client side stub.
*
* History:
*  13-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL META WINAPI StrokeAndFillPath(HDC hdc)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(bRet);

        DC_PLDC(hdc,pldc,bRet);

        if ((pldc->iType == LO_METADC) &&
            !MF_BoundRecord(hdc,EMR_STROKEANDFILLPATH))
        {
            return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    return(NtGdiStrokeAndFillPath(hdc));

}

/******************************Public*Routine******************************\
* StrokePath
*
* Client side stub.
*
* History:
*  13-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL META WINAPI StrokePath(HDC hdc)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE (hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(bRet);

        DC_PLDC(hdc,pldc,bRet);

        if ((pldc->iType == LO_METADC) &&
            !MF_BoundRecord(hdc,EMR_STROKEPATH))
        {
            return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();


    return(NtGdiStrokePath(hdc));

}

/******************************Public*Routine******************************\
* FillPath
*
* Client side stub.
*
* History:
*  13-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL META WINAPI FillPath(HDC hdc)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE (hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(bRet);

        DC_PLDC(hdc,pldc,bRet);

        if ((pldc->iType == LO_METADC) &&
            !MF_BoundRecord(hdc,EMR_FILLPATH))
        {
            return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    return(NtGdiFillPath(hdc));

}

/******************************Public*Routine******************************\
* WidenPath
*
* Client side stub.
*
* History:
*  13-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL META WINAPI WidenPath(HDC hdc)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE (hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(bRet);

        DC_PLDC(hdc,pldc,bRet);

        if ((pldc->iType == LO_METADC) &&
            !MF_Record(hdc,EMR_WIDENPATH))
        {
            return(bRet);
        }
    }

    return(NtGdiWidenPath(hdc));

}

/******************************Public*Routine******************************\
* PathToRegion
*
* Client side stub.
*
*  13-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

HRGN META WINAPI PathToRegion(HDC hdc)
{
    HRGN hrgn = (HRGN)0;

    FIXUP_HANDLE (hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(hrgn);

        DC_PLDC(hdc,pldc,hrgn);

        // Metafile the call.
        // Note that since PathToRegion returns region in device coordinates, we
        // cannot record it in a metafile which can be played to different devices.
        // Instead, we will treat the returned region the same as the other regions
        // created in other region calls.  However, we still need to discard the
        // path definition in the metafile.

        if ((pldc->iType == LO_METADC) &&
            !MF_Record(hdc,EMR_ABORTPATH))
        {
            return(hrgn);
        }
    }

    hrgn = NtGdiPathToRegion(hdc);

    if (hrgn && MIRRORED_HDC(hdc)) {
        MirrorRgnDC(hdc, hrgn, NULL);
    }        

    return(hrgn);
}

/******************************Public*Routine******************************\
* GetPath
*
* GetPath client side stub.
*
*  13-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

int WINAPI GetPath(HDC hdc,LPPOINT apt,LPBYTE aj,int cpt)
{
    FIXUP_HANDLE(hdc);

    // Check to make sure we don't have an unreasonable number of points or bad handle

    if (IS_METADC16_TYPE(hdc))
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(-1);
    }

    return(NtGdiGetPath(hdc, apt, aj, cpt));

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\output.c ===
/******************************Module*Header*******************************\
* Module Name: output.c                                                    *
*                                                                          *
* Client side stubs for graphics output calls.                             *
*                                                                          *
* Created: 05-Jun-1991 01:41:18                                            *
* Author: Charles Whitmer [chuckwh]                                        *
*                                                                          *
* Copyright (c) 1991-1999 Microsoft Corporation                            *
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

// 2 seconds is way way too long for either non-preemptive wow apps or
// an input-synchronized journal situation (like w/mstest). 1/20 a second
// is much better - scottlu
//#define CALLBACK_INTERVAL   2000

// Even better - 1/4 a second
// scottlu
#define CALLBACK_INTERVAL   250

extern BOOL MF_WriteEscape(HDC hdc, int nEscape, int nCount, LPCSTR lpInData, int type );

//
// WINBUG #82877 2-7-2000 bhouse Need to move definition of ETO_NULL_PRCL
//

#define ETO_NULL_PRCL 0x80000000

ULONG GdiBatchLimit = 20;

const XFORM xformIdentity = { 1.00000000f, 0.00000000f, 0.00000000f, 1.00000000f,
                        0.00000000f, 0.00000000f };

/******************************Public*Routine******************************\
* AngleArc                                                                 *
*                                                                          *
* Client side stub.  Copies all LDC attributes into the message.           *
*                                                                          *
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI AngleArc(
    HDC hdc,
    int x,
    int y,
    DWORD r,
    FLOAT eA,
    FLOAT eB
)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(bRet);

        DC_PLDC(hdc,pldc,bRet);

        if ((pldc->iType == LO_METADC) &&
            !MF_AngleArc(hdc,x,y,r,eA,eB)
           )
            return(bRet);

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    return(NtGdiAngleArc(hdc,x,y,r,FLOATARG(eA),FLOATARG(eB)));
}

/******************************Public*Routine******************************\
* Arc                                                                      *
*                                                                          *
* Client side stub.  Copies all LDC attributes into the message.           *
*                                                                          *
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI Arc
(
    HDC hdc,
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4
)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return (MF16_RecordParms9(hdc,x1,y1,x2,y2,x3,y3,x4,y4,META_ARC));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_ArcChordPie(hdc,x1,y1,x2,y2,x3,y3,x4,y4,EMR_ARC))
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    return(NtGdiArcInternal(ARCTYPE_ARC,hdc,x1,y1,x2,y2,x3,y3,x4,y4));

}

/******************************Public*Routine******************************\
* ArcTo                                                                    *
*                                                                          *
* Client side stub.  Copies all LDC attributes into the message.           *
*                                                                          *
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]                           *
* Wrote it.  Cloned it from Arc.                                           *
\**************************************************************************/

BOOL META WINAPI ArcTo(
    HDC hdc,
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4
)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(bRet);

        DC_PLDC(hdc,pldc,bRet);

        if ((pldc->iType == LO_METADC) &&
            !MF_ArcChordPie(hdc,x1,y1,x2,y2,x3,y3,x4,y4,EMR_ARCTO))
        {
            return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    return(NtGdiArcInternal(ARCTYPE_ARCTO,hdc,x1,y1,x2,y2,x3,y3,x4,y4));

}

/******************************Public*Routine******************************\
* LineTo                                                                   *
*                                                                          *
* Client side stub.  Copies all LDC attributes into the message.           *
*                                                                          *
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI LineTo(HDC hdc,int x,int y)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return (MF16_RecordParms3(hdc,x,y,META_LINETO));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SetDD(hdc,(DWORD)x,(DWORD)y,EMR_LINETO))
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    return(NtGdiLineTo(hdc,x,y));

}

/******************************Public*Routine******************************\
* Chord                                                                    *
*                                                                          *
* Client side stub.  Copies all LDC attributes into the message.           *
*                                                                          *
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI Chord(
    HDC hdc,
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4
)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return (MF16_RecordParms9(hdc,x1,y1,x2,y2,x3,y3,x4,y4,META_CHORD));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_ArcChordPie(hdc,x1,y1,x2,y2,x3,y3,x4,y4,EMR_CHORD))
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    return(NtGdiArcInternal(ARCTYPE_CHORD,hdc,x1,y1,x2,y2,x3,y3,x4,y4));

}

/******************************Public*Routine******************************\
* Ellipse                                                                  *
*                                                                          *
* Client side stub.  Copies all LDC attributes into the message.           *
*                                                                          *
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI Ellipse(HDC hdc,int x1,int y1,int x2,int y2)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return (MF16_RecordParms5(hdc,x1,y1,x2,y2,META_ELLIPSE));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_EllipseRect(hdc,x1,y1,x2,y2,EMR_ELLIPSE))
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    return(NtGdiEllipse(hdc,x1,y1,x2,y2));

}

/******************************Public*Routine******************************\
* Pie                                                                      *
*                                                                          *
* Client side stub.  Copies all LDC attributes into the message.           *
*                                                                          *
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI Pie(
    HDC hdc,
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3,
    int x4,
    int y4
)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return (MF16_RecordParms9(hdc,x1,y1,x2,y2,x3,y3,x4,y4,META_PIE));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_ArcChordPie(hdc,x1,y1,x2,y2,x3,y3,x4,y4,EMR_PIE))
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    return(NtGdiArcInternal(ARCTYPE_PIE,hdc,x1,y1,x2,y2,x3,y3,x4,y4));

}

/******************************Public*Routine******************************\
* Rectangle                                                                *
*                                                                          *
* Client side stub.  Copies all LDC attributes into the message.           *
*                                                                          *
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI Rectangle(HDC hdc,int x1,int y1,int x2,int y2)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return (MF16_RecordParms5(hdc,x1,y1,x2,y2,META_RECTANGLE));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_EllipseRect(hdc,x1,y1,x2,y2,EMR_RECTANGLE))
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    return(NtGdiRectangle(hdc,x1,y1,x2,y2));

}

/******************************Public*Routine******************************\
* RoundRect                                                                *
*                                                                          *
* Client side stub.  Copies all LDC attributes into the message.           *
*                                                                          *
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI RoundRect(
    HDC hdc,
    int x1,
    int y1,
    int x2,
    int y2,
    int x3,
    int y3
)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return (MF16_RecordParms7(hdc,x1,y1,x2,y2,x3,y3,META_ROUNDRECT));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_RoundRect(hdc,x1,y1,x2,y2,x3,y3))
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    return(NtGdiRoundRect(hdc,x1,y1,x2,y2,x3,y3));

}

/******************************Public*Routine******************************\
* PatBlt                                                                   *
*                                                                          *
* Client side stub.  Copies all LDC attributes into the message.           *
*                                                                          *
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI PatBlt(
    HDC hdc,
    int x,
    int y,
    int cx,
    int cy,
    DWORD rop
)
{
    BOOL bRet = FALSE;
    PDC_ATTR pdca;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParmsWWWWD(hdc,(WORD)x,(WORD)y,(WORD)cx,(WORD)cy,rop,META_PATBLT));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_AnyBitBlt(hdc,x,y,cx,cy,(LPPOINT)NULL,(HDC)NULL,0,0,0,0,(HBITMAP)NULL,0,0,rop,EMR_BITBLT))
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    PSHARED_GET_VALIDATE(pdca,hdc,DC_TYPE);

    BEGIN_BATCH_HDC(hdc,pdca,BatchTypePatBlt,BATCHPATBLT);

        //
        // check DC to see if call can be batched, all DCs in use
        // by the client must have a valid dc_attr
        //

        pBatch->rop4            = rop;
        pBatch->x               = x;
        pBatch->y               = y;
        pBatch->cx              = cx;
        pBatch->cy              = cy;
        pBatch->hbr             = pdca->hbrush;
        pBatch->TextColor       = (ULONG)pdca->crForegroundClr;
        pBatch->BackColor       = (ULONG)pdca->crBackgroundClr;
        pBatch->DCBrushColor    = (ULONG)pdca->crDCBrushClr;
        pBatch->IcmBrushColor   = (ULONG)pdca->IcmBrushColor;
        pBatch->ptlViewportOrg  = pdca->ptlViewportOrg;
        pBatch->ulTextColor       = pdca->ulForegroundClr;
        pBatch->ulBackColor       = pdca->ulBackgroundClr;
        pBatch->ulDCBrushColor    = pdca->ulDCBrushClr;

    COMPLETE_BATCH_COMMAND();

    return(TRUE);

UNBATCHED_COMMAND:

    return(NtGdiPatBlt(hdc,x,y,cx,cy,rop));
}

/******************************Public*Routine******************************\
* PolyPatBlt
*
* Arguments:
*
*  hdc   - dest DC
*  rop   - ROP for all patblt elements
*  pPoly - pointer to array of PPOLYPATBLT structures
*  Count - number of polypatblts
*  Mode  - mode for all polypatblts
*
* Return Value:
*
*   BOOL Status
*
\**************************************************************************/

BOOL
META WINAPI
PolyPatBlt(
    HDC         hdc,
    DWORD       rop,
    PPOLYPATBLT pPoly,
    DWORD       Count,
    DWORD       Mode
    )
{
    BOOL bRet = FALSE;
    PDC_ATTR pdca;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pdca,hdc,DC_TYPE);

    // If ICM is enabled, we need to select the brush onto the DC in
    // client side, so that ICM can translate brush color to DC color
    // space. thus we can not use Batch, here. because Batch will selet
    // the brush onto the DC in kernel side. so, there is no chance to
    // ICM will be invoked.

    if (IS_ALTDC_TYPE(hdc) || (pdca && IS_ICM_INSIDEDC(pdca->lIcmMode)))
    {
        ULONG Index;
        HBRUSH hOld = 0;

        for (Index=0;Index<Count;Index++)
        {
            //
            // select brush, save first to restore
            //

            if (Index == 0)
            {
                hOld = SelectObject(hdc,(HBRUSH)pPoly[0].BrClr.hbr);
            }
            else
            {
                SelectObject(hdc,(HBRUSH)pPoly[Index].BrClr.hbr);
            }

            bRet = PatBlt(hdc,
                          pPoly[Index].x,
                          pPoly[Index].y,
                          pPoly[Index].cx,
                          pPoly[Index].cy,
                          rop
                         );
        }

        //
        // restore brush if needed
        //

        if (hOld)
        {
            SelectObject(hdc,hOld);
        }
    }
    else
    {
        RESETUSERPOLLCOUNT();

        if ((Count != 0) && (pPoly != NULL) && (Mode == PPB_BRUSH))
        {
            //
            // size of batched structure
            //

            USHORT uSize = (USHORT)(sizeof(BATCHPOLYPATBLT) +
                           Count * sizeof(POLYPATBLT));

            BEGIN_BATCH_HDC_SIZE(hdc,pdca,BatchTypePolyPatBlt,BATCHPOLYPATBLT,uSize);

                pBatch->rop4    = rop;
                pBatch->Count   = Count;
                pBatch->Mode    = Mode;
                pBatch->TextColor  = (ULONG)pdca->crForegroundClr;
                pBatch->BackColor  = (ULONG)pdca->crBackgroundClr;
                pBatch->DCBrushColor  = (ULONG)pdca->crDCBrushClr;
                pBatch->ptlViewportOrg  = pdca->ptlViewportOrg;
                pBatch->ulTextColor  = pdca->ulForegroundClr;
                pBatch->ulBackColor  = pdca->ulBackgroundClr;
                pBatch->ulDCBrushColor  = pdca->ulDCBrushClr;

                memcpy(&pBatch->ulBuffer[0],pPoly,Count*sizeof(POLYPATBLT));

                //
                // if the first hbr entry is NULL, copy in current hbr so
                // it is remembered.
                //

                if (((PPOLYPATBLT)(&pBatch->ulBuffer[0]))->BrClr.hbr == NULL)
                {
                    ((PPOLYPATBLT)(&pBatch->ulBuffer[0]))->BrClr.hbr = pdca->hbrush;
                }

                bRet = TRUE;

            COMPLETE_BATCH_COMMAND();

        UNBATCHED_COMMAND:

            if (!bRet)
            {
                bRet = NtGdiPolyPatBlt(hdc,rop,pPoly,Count,Mode);
            }
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BitBlt                                                                   *
*                                                                          *
* Client side stub.  Copies all LDC attributes into the message.           *
*                                                                          *
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI BitBlt(
    HDC hdc,
    int x,
    int y,
    int cx,
    int cy,
    HDC hdcSrc,
    int x1,
    int y1,
    DWORD rop
)
{
    BOOL     bRet = FALSE;

    //
    // if this call redueces to PatBlt, then let PatBlt
    // do the metafile and/or output.
    //

    if ((((rop << 2) ^ rop) & 0x00CC0000) == 0)
    {
        return(PatBlt(hdc,x,y,cx,cy,rop));
    }

    //
    // Src is required by ROP, do bitblt
    //

    FIXUP_HANDLE(hdc);
    FIXUP_HANDLE(hdcSrc);

    if (gbICMEnabledOnceBefore)
    {
        PDC_ATTR pdcattr, pdcattrSrc;

        PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);
        PSHARED_GET_VALIDATE(pdcattrSrc,hdcSrc,DC_TYPE);

        //
        // if source DC has DIB section, and destination DC is ICM turned on
        // do ICM-aware BitBlt.
        //
        if (pdcattr && pdcattrSrc)
        {
            if (IS_ICM_INSIDEDC(pdcattr->lIcmMode) &&
                (bDIBSectionSelected(pdcattrSrc) ||
                 (IS_ICM_LAZY_CORRECTION(pdcattrSrc->lIcmMode) && (GetDCDWord(hdc,DDW_ISMEMDC,FALSE) == FALSE))))
            {
                if (IcmStretchBlt(hdc,x,y,cx,cy,hdcSrc,x1,y1,cx,cy,rop,pdcattr,pdcattrSrc))
                {
                    return (TRUE);
                }
            }
        }
    }

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return (MF16_BitBlt(hdc,x,y,cx,cy,hdcSrc,x1,y1,rop));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_AnyBitBlt(hdc,x,y,cx,cy,(LPPOINT)NULL,hdcSrc,x1,y1,cx,cy,(HBITMAP)NULL,0,0,rop,EMR_BITBLT))
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

//
// Define _WINDOWBLT_NOTIFICATION_ to turn on Window BLT notification.
// This notification will set a special flag in the SURFOBJ passed to
// drivers when the DrvCopyBits operation is called to move a window.
//
// See also:
//      ntgdi\gre\maskblt.cxx
//
#ifdef _WINDOWBLT_NOTIFICATION_
    return(NtGdiBitBlt(hdc,x,y,cx,cy,hdcSrc,x1,y1,rop,(COLORREF)-1,0));
#else
    return(NtGdiBitBlt(hdc,x,y,cx,cy,hdcSrc,x1,y1,rop,(COLORREF)-1));
#endif
}

/******************************Public*Routine******************************\
* StretchBlt                                                               *
*                                                                          *
* Client side stub.  Copies all LDC attributes into the message.           *
*                                                                          *
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI StretchBlt(
    HDC   hdc,
    int   x,
    int   y,
    int   cx,
    int   cy,
    HDC   hdcSrc,
    int   x1,
    int   y1,
    int   cx1,
    int   cy1,
    DWORD rop
)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);
    FIXUP_HANDLEZ(hdcSrc);

    if (gbICMEnabledOnceBefore)
    {
        PDC_ATTR pdcattr, pdcattrSrc;

        PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);
        PSHARED_GET_VALIDATE(pdcattrSrc,hdcSrc,DC_TYPE);

        //
        // if source DC has DIB section, and destination DC is ICM turned on
        // do ICM-aware BitBlt.
        //
        if (pdcattr && pdcattrSrc)
        {
            if (IS_ICM_INSIDEDC(pdcattr->lIcmMode) &&
                (bDIBSectionSelected(pdcattrSrc) ||
                 (IS_ICM_LAZY_CORRECTION(pdcattrSrc->lIcmMode) && (GetDCDWord(hdc,DDW_ISMEMDC,FALSE) == FALSE))))
            {
                if (IcmStretchBlt(hdc,x,y,cx,cy,hdcSrc,x1,y1,cx1,cy1,rop,pdcattr,pdcattrSrc))
                {
                    return (TRUE);
                }
            }
        }
    }

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return (MF16_StretchBlt(hdc,x,y,cx,cy,hdcSrc,x1,y1,cx1,cy1,rop));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_AnyBitBlt(hdc,x,y,cx,cy,(LPPOINT)NULL,hdcSrc,x1,y1,cx1,cy1,(HBITMAP)NULL,0,0,rop,EMR_STRETCHBLT))
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    return(NtGdiStretchBlt(hdc,x,y,cx,cy,hdcSrc,x1,y1,cx1,cy1,rop,(COLORREF)-1));
}

/******************************Public*Routine******************************\
* PlgBlt                                                                   *
*                                                                          *
* Client side stub.  Copies all LDC attributes into the message.           *
*                                                                          *
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI PlgBlt(
    HDC        hdc,
    CONST POINT *pptl,
    HDC        hdcSrc,
    int        x1,
    int        y1,
    int        x2,
    int        y2,
    HBITMAP    hbm,
    int        xMask,
    int        yMask
)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);
    FIXUP_HANDLEZ(hdcSrc);
    FIXUP_HANDLEZ(hbm);

// Check out the source DC and the mask(OPTIONAL).

    if (!hdcSrc || IS_METADC16_TYPE(hdcSrc))
        return(FALSE);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(FALSE);

        DC_PLDC(hdc,pldc,bRet);

        if ((pldc->iType == LO_METADC) &&
            !MF_AnyBitBlt(hdc,0,0,0,0,pptl,hdcSrc,x1,y1,x2,y2,hbm,xMask,yMask,0xCCAA0000,EMR_PLGBLT))
        {
            return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    return(NtGdiPlgBlt(hdc,(POINT *)pptl,hdcSrc,x1,y1,x2,y2,hbm,xMask,yMask,
                       GetBkColor(hdcSrc)));

}

/******************************Public*Routine******************************\
* MaskBlt                                                                  *
*                                                                          *
* Client side stub.  Copies all LDC attributes into the message.           *
*                                                                          *
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI MaskBlt(
    HDC     hdc,
    int     x,
    int     y,
    int     cx,
    int     cy,
    HDC     hdcSrc,
    int     x1,
    int     y1,
    HBITMAP hbm,
    int     x2,
    int     y2,
    DWORD   rop
)
{
    BOOL bRet = FALSE;
    ULONG crBackColor;

    FIXUP_HANDLE(hdc);
    FIXUP_HANDLEZ(hdcSrc);
    FIXUP_HANDLEZ(hbm);

// Check out the source DC and the mask(OPTIONAL).

    if (!hdcSrc || IS_METADC16_TYPE(hdcSrc))
        return(FALSE);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(FALSE);

        DC_PLDC(hdc,pldc,bRet);

        if ((pldc->iType == LO_METADC) &&
            !MF_AnyBitBlt(hdc,x,y,cx,cy,(LPPOINT)NULL,hdcSrc,x1,y1,cx,cy,hbm,x2,y2,rop,EMR_MASKBLT))
        {
            return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    crBackColor = GetBkColor(hdcSrc);

    RESETUSERPOLLCOUNT();

    // WINBUG #82879 2-7-2000 bhouse Possible bug in MaskBlt
    // Old Comment:
    //    - GetBkColor should be performed in the kernel
    // Not a problem. GetBkColor() picks up the color from the PEB DCattr cache.

    return(NtGdiMaskBlt(hdc,x,y,cx,cy,hdcSrc,x1,y1,hbm,x2,y2,rop,crBackColor));
}

/******************************Public*Routine******************************\
* ExtFloodFill                                                             *
*                                                                          *
* Client side stub.  Copies all LDC attributes into the message.           *
*                                                                          *
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI ExtFloodFill(
    HDC      hdc,
    int      x,
    int      y,
    COLORREF color,
    UINT     iMode
)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParmsWWDW(hdc,(WORD)x,(WORD)y,(DWORD)color,(WORD)iMode,META_EXTFLOODFILL));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_ExtFloodFill(hdc,x,y,color,iMode))
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    //
    // if the specified COLORREF is not palette index,
    // we need to do color conversion, when ICM is enabled.
    //

    if (!(color & 0x01000000))
    {
        PDC_ATTR pdcattr;

        PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

        if (pdcattr && bNeedTranslateColor(pdcattr))
        {
            COLORREF NewColor;

            if (IcmTranslateCOLORREF(hdc,pdcattr,color,&NewColor,ICM_FORWARD))
            {
                color = NewColor;
            }
        }
    }

    return(NtGdiExtFloodFill(hdc,x,y,color,iMode));
}

/******************************Public*Routine******************************\
* FloodFill                                                                *
*                                                                          *
* Just passes the call to the more general ExtFloodFill.                   *
*                                                                          *
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL WINAPI FloodFill(HDC hdc,int x,int y,COLORREF color)
{
    return(ExtFloodFill(hdc,x,y,color,FLOODFILLBORDER));
}

/******************************Public*Routine******************************\
* PaintRgn                                                                 *
*                                                                          *
* Client side stub.  Copies all LDC attributes into the message.           *
*                                                                          *
* 23-11-94 -by- Lingyun Wang [lingyunw]
* Now hrgn is server side handle
*
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI PaintRgn(HDC hdc,HRGN hrgn)
{
    BOOL  bRet = FALSE;

    FIXUP_HANDLE(hdc);
    FIXUP_HANDLE(hrgn);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_DrawRgn(hdc,hrgn,(HBRUSH)0,0,0,META_PAINTREGION));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_InvertPaintRgn(hdc,hrgn,EMR_PAINTRGN))
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    return(NtGdiFillRgn(hdc,hrgn,(HBRUSH)GetDCObject(hdc,LO_BRUSH_TYPE)));

}


/******************************Public*Routine******************************\
* bBatchTextOut
*
*   Attempt to batch a textout call on TEB
*
* Arguments:
*
*
*
* Return Value:
*
*   TRUE means call is batched, FALSE means call could not be batched
*
*    18-Oct-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

//
// full DWORDS!
//

#define MAX_BATCH_CCHAR  ((GDI_BATCH_SIZE - sizeof(BATCHTEXTOUT)) & 0xfffffff0)
#define MAX_BATCH_WCHAR  MAX_BATCH_CCHAR / 2

BOOL
bBatchTextOut(
    HDC         hdc,
    LONG        x,
    LONG        y,
    UINT        fl,
    CONST RECT *prcl,
    LPCWSTR     pwsz,
    CONST INT  *pdx,
    UINT        UnicodeCharCount,
    UINT        ByteCount,
    DWORD       dwCodePage
    )
{
    BOOL     bRet = FALSE;
    ULONG    AlignedByteCount;
    USHORT   usSize;
    ULONG    cjPdx;
    PDC_ATTR pdca;

    AlignedByteCount =
        (ByteCount + sizeof(PVOID) - 1) & ~(sizeof(PVOID)-1);

    //
    // account for pdx space if needed
    //

    if (pdx != NULL)
    {
        cjPdx = UnicodeCharCount * sizeof(INT);
        if (fl & ETO_PDY)
            cjPdx *= 2;

        AlignedByteCount += cjPdx;
    }

    usSize = (USHORT)(sizeof(BATCHTEXTOUT) + AlignedByteCount);

    PSHARED_GET_VALIDATE(pdca,hdc,DC_TYPE);

    BEGIN_BATCH_HDC_SIZE(hdc,pdca,BatchTypeTextOut,BATCHTEXTOUT,usSize);

        if (pdca->lTextAlign & TA_UPDATECP)
        {
            goto UNBATCHED_COMMAND;
        }

        pBatch->TextColor  = (ULONG)pdca->crForegroundClr;
        pBatch->BackColor  = (ULONG)pdca->crBackgroundClr;
        pBatch->BackMode   = (ULONG)((pdca->lBkMode == OPAQUE) ? OPAQUE : TRANSPARENT);
        pBatch->ulTextColor  = pdca->ulForegroundClr;
        pBatch->ulBackColor  = pdca->ulBackgroundClr;
        pBatch->x          = x;
        pBatch->y          = y;
        pBatch->fl         = fl;
        pBatch->cChar      = UnicodeCharCount;
        pBatch->PdxOffset  = 0;
        pBatch->dwCodePage = dwCodePage;
        pBatch->hlfntNew   = pdca->hlfntNew;
        pBatch->flTextAlign = pdca->flTextAlign;
        pBatch->ptlViewportOrg = pdca->ptlViewportOrg;

        //
        // copy output RECT if needed
        //

        if (prcl != NULL)
        {
            pBatch->rcl.left   = prcl->left;
            pBatch->rcl.top    = prcl->top;
            pBatch->rcl.right  = prcl->right;
            pBatch->rcl.bottom = prcl->bottom;
        }
        else
        {
            pBatch->fl |= ETO_NULL_PRCL;
        }

        //
        // copy characters
        //

        if (ByteCount)
        {
            RtlCopyMemory((PUCHAR)&pBatch->ulBuffer[0],(PUCHAR)pwsz,ByteCount);
        }

        //
        // copy pdx array
        //

        if (pdx != NULL)
        {
           //
           // start pdx at INT aligned offset after WCAHR data
           //

           pBatch->PdxOffset = (ByteCount + 3) & 0xfffffffc;

           RtlCopyMemory((PUCHAR)&pBatch->ulBuffer[0] + pBatch->PdxOffset,
                         (PUCHAR)pdx,
                         cjPdx);
        }

        bRet = TRUE;

    COMPLETE_BATCH_COMMAND();

UNBATCHED_COMMAND:

    return(bRet);
}

/******************************Public*Routine******************************\
*
* BOOL META WINAPI ExtTextOutW
*
* similar to traditional ExtTextOut, except that it takes UNICODE string
*
* History:
*  Thu 28-Apr-1994 -by- Patrick Haluptzok [patrickh]
* Special Case 0 char case for Winbench4.0
*
*  05-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL META WINAPI ExtTextOutW(
    HDC        hdc,
    int        x,
    int        y,
    UINT       fl,
    CONST RECT *prcl,
    LPCWSTR    pwsz,
    UINT       c,      // count of bytes = 2 * (# of WCHAR's)
    CONST INT *pdx
)
{
    BOOL bRet = FALSE;
    BOOL bEMFDriverComment = FALSE;

    if ((fl & ETO_PDY) && !pdx)
        return FALSE;

// if we do not know what to do with the rectangle, ignore it.

    if (prcl && !(fl & (ETO_OPAQUE | ETO_CLIPPED)))
    {
        prcl = NULL;
    }
    if (!prcl)
    {
        fl &= ~(ETO_CLIPPED | ETO_OPAQUE); // ignore flags if no rect, win95 compat
    }

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return (MF16_ExtTextOut(hdc,x,y,fl,prcl,(LPCSTR)pwsz,c,pdx,TRUE));

        DC_PLDC(hdc,pldc,bRet);



    // if we are EMF spooling then metafile glyph index calls, otherwise don't

// if we are EMF spooling then metafile glyph index calls, otherwise don't
/*
   LDC_META_PRINT       ETO_GLYPH_INDEX      ETO_IGNORELANGUAGE      gbLpk    MetaFileTheCall
        0                     0                      0                 0            1
        0                     0                      0                 1            1
        0                     0                      1                 0            1
Case1   0                     0                      1                 1            0

Case2   0                     1                      0                 0            0
        0                     1                      0                 1            1     <-Win95 Compatability
Case2   0                     1                      1                 0            0
        0                     1                      1                 1            1     <-Win95 Compatability

        1                     0                      0                 0            1
Case3   1                     0                      0                 1            0
        1                     0                      1                 0            1
        1                     0                      1                 1            1

        1                     1                      0                 0            1
        1                     1                      0                 1            1
        1                     1                      1                 0            1
        1                     1                      1                 1            1

*/
// Now we will metafile the glyph index call (i.e. with ETO_GLYPH_INDEX) for ExtTextOutW.
// This is to support MS OutLook-97/BiDi, since it DEPENDS on this feature!!. Win95/BiDi allowed
// metafiling of GIs on ETOW, but rejects GIs metafiling calls to ETOA.
// This is not neat, but we have to do it to support our Apps.

        if (pldc->iType == LO_METADC)
        {
            BOOL bPrintToEMFDriver = pldc->pUMPD ? pldc->pUMPD->dwFlags & UMPDFLAG_METAFILE_DRIVER : FALSE;

            BOOL bLpkEmfCase1 = !(pldc->fl & LDC_META_PRINT) &&
                                !(fl & ETO_GLYPH_INDEX) &&
                                (fl & ETO_IGNORELANGUAGE) &&
                                gbLpk;

            BOOL bLpkEmfCase2 = !(pldc->fl & LDC_META_PRINT) &&
                                (fl & ETO_GLYPH_INDEX) &&
                                !gbLpk;

            BOOL bLpkEmfCase3 = (pldc->fl & LDC_META_PRINT) &&
                                !(fl & ETO_GLYPH_INDEX) &&
                                !(fl & ETO_IGNORELANGUAGE) &&
                                gbLpk;




            // Record a special comment containing the original
            // Unicode string for the ExtTextOutW call

            if (bLpkEmfCase3 && bPrintToEMFDriver)
            {
                DWORD nSize = (3*sizeof(DWORD)+c*sizeof(WCHAR)+3)&~3;
                DWORD *lpData = LOCALALLOC(nSize);

                if (lpData)
                {
                   lpData[0] = GDICOMMENT_IDENTIFIER;
                   lpData[1] = GDICOMMENT_UNICODE_STRING;
                   lpData[2] = c; // number of wchars in the unicode string

                   RtlCopyMemory((PBYTE)(lpData+3), pwsz, c*sizeof(WCHAR));

                   if (!MF_GdiComment(hdc,nSize,(PBYTE)lpData))
                   {
                       LOCALFREE(lpData);
                       return bRet;
                   }

                   LOCALFREE(lpData);

                   bEMFDriverComment = TRUE;
                }
            }

            if (!bLpkEmfCase1 && !bLpkEmfCase2 && !bLpkEmfCase3 &&
                !MF_ExtTextOut(hdc,x,y,fl,prcl,(LPCSTR) pwsz,c,pdx,EMR_EXTTEXTOUTW))
            {
                return(bRet);
            }

        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

#ifdef LANGPACK
    if(gbLpk && !(fl & ETO_GLYPH_INDEX) && !(fl & ETO_IGNORELANGUAGE))
    {
        bRet = ((*fpLpkExtTextOut)(hdc, x, y, fl, prcl, pwsz, c, pdx, -1));

        if (bEMFDriverComment)
        {
             DWORD lpData[2];

             lpData[0] = GDICOMMENT_IDENTIFIER;
             lpData[1] = GDICOMMENT_UNICODE_END;

             bRet = MF_GdiComment(hdc,2*sizeof(DWORD),(PBYTE)lpData);

             ASSERTGDI(bRet, "failed to write the GDICOMMENT_UNICODE_END comment\n");
        }

        return(bRet);
    }
#endif

    bRet = FALSE;

    if (c <= MAX_BATCH_WCHAR)
    {
        if ((c == 0) && (prcl != NULL))
        {
            if (fl & ETO_OPAQUE)
            {
                //
                // attempt to batch the text out rect
                //

                PDC_ATTR pdca;

                PSHARED_GET_VALIDATE(pdca,hdc,DC_TYPE);

                if ((pdca != NULL) && !(pdca->lTextAlign & TA_UPDATECP))
                {
                    BEGIN_BATCH_HDC(hdc,pdca,BatchTypeTextOutRect,BATCHTEXTOUTRECT);

                        pBatch->BackColor  = pdca->crBackgroundClr;
                        pBatch->fl         = fl;
                        pBatch->rcl.left   = prcl->left;
                        pBatch->rcl.top    = prcl->top;
                        pBatch->rcl.right  = prcl->right;
                        pBatch->rcl.bottom = prcl->bottom;
                        pBatch->ptlViewportOrg = pdca->ptlViewportOrg;
                        pBatch->ulBackColor = pdca->ulBackgroundClr;

                        bRet = TRUE;

                    COMPLETE_BATCH_COMMAND();
                }
            }
            else
            {
                bRet = TRUE;
            }
        }
        else
        {
            bRet = bBatchTextOut(hdc,
                                 x,
                                 y,
                                 fl,
                                 (LPRECT)prcl,
                                 (LPWSTR)pwsz,
                                 pdx,
                                 c,
                                 2 * c,
                                 0);
        }
    }

UNBATCHED_COMMAND:

    if (!bRet)
    {
        bRet = NtGdiExtTextOutW(hdc,
                                x,
                                y,
                                fl,
                                (LPRECT)prcl,
                                (LPWSTR)pwsz,
                                c,
                                (LPINT)pdx,
                                0);
    }

    return(bRet);
}


/******************************Public*Routine******************************\
* PolyTextOutW
*
* Arguments:
*
*     hdc      - handle to device context
*     ppt      - pointer to array of POLYTEXTW
*     nstrings - length of POLYTEXTW array
*
* Return Value:
*
*     status
*
* History:
*  7/31/92 -by- Paul Butzi and Eric Kutter
*
\**************************************************************************/

BOOL META WINAPI PolyTextOutW(HDC hdc,CONST POLYTEXTW *ppt,INT nstrings)
{

    BOOL bRet = FALSE;
    CONST POLYTEXTW *pp;

    FIXUP_HANDLE(hdc);

    if (nstrings == 0)
    {
       bRet = TRUE;
    }
    else if (nstrings < 0)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        bRet = FALSE;
    }
    else
    {

        //
        // Search for error case with string with non-0 length but sting == NULL
        //

        for ( pp = ppt; pp < (ppt + nstrings); pp += 1 )
        {
            if ( pp->lpstr == NULL)
            {
                //
                // return failure if they have a non 0 length string with NULL
                //

                if (pp->n != 0)
                {
                    GdiSetLastError(ERROR_INVALID_PARAMETER);
                    return(FALSE);
                }
            }
        }

        //
        // If we need to metafile, or print
        //

        if (IS_ALTDC_TYPE(hdc))
        {
            PLDC pldc;

            if (IS_METADC16_TYPE(hdc))
            {
                return (
                    MF16_PolyTextOut(
                            hdc,
                            (CONST POLYTEXTA*) ppt,
                            nstrings,
                            TRUE                        //  mrType == EMR_POLYTEXTOUTW
                            )
                       );
            }

            DC_PLDC(hdc,pldc,bRet);

            if (pldc->iType == LO_METADC)
            {
                if
                (
                    !MF_PolyTextOut(
                            hdc,
                            (CONST POLYTEXTA*) ppt,
                            nstrings,
                            EMR_POLYTEXTOUTW
                            )
                )
                    return(bRet);
            }

            if (pldc->fl & LDC_SAP_CALLBACK)
            {
                vSAPCallback(pldc);
            }

            if (pldc->fl & LDC_DOC_CANCELLED)
            {
                return(bRet);
            }

            if (pldc->fl & LDC_CALL_STARTPAGE)
            {
                StartPage(hdc);
            }
        }

        bRet = NtGdiPolyTextOutW(hdc,(POLYTEXTW *)ppt,nstrings, 0);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* PolyTextOutA
*
* Arguments:
*
*     hdc      - handle to device context
*     ppt      - pointer to array of POLYTEXTA
*     nstrings - length of POLYTEXTA array
*
* Return Value:
*
*     status
*
* History:
*  7/31/92 -by- Paul Butzi and Eric Kutter
*
\**************************************************************************/

BOOL META WINAPI PolyTextOutA(HDC hdc, CONST POLYTEXTA *ppt, INT nstrings)
{

    //
    // Convert text to UNICODE and make call
    //

    POLYTEXTW *pp, *pPolyTextW;


    INT szTotal = 0;
    INT cjdx;
    BOOL bRet = FALSE;
    BOOL bDBCSCodePage;
    int i;
    PVOID pCharBuffer;
    PBYTE pj;
    DWORD   dwCodePage;

    FIXUP_HANDLE(hdc);

    if (nstrings == 0)
    {
        return(TRUE);
    }

    if (nstrings < 0)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    // Figure out the size needed
    //

    pPolyTextW = (POLYTEXTW*) ppt;


    szTotal = sizeof(POLYTEXTW) * nstrings;

    for ( pp = pPolyTextW; pp < (pPolyTextW + nstrings); pp ++)
    {
        if (pp->lpstr != NULL)
        {
            szTotal += pp->n * sizeof(WCHAR);

            if ( pp->pdx != NULL )
            {
                cjdx = pp->n * sizeof(int);
                if (pp->uiFlags & ETO_PDY)
                    cjdx *= 2;

                szTotal += cjdx;
            }
        }
        else
        {
            //
            // return failure if they have a non 0 length string with NULL
            //

            if (pp->n != 0)
            {
                GdiSetLastError(ERROR_INVALID_PARAMETER);
                return(FALSE);
            }
        }
    }

    //
    // If we need to metafile, or print
    //

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
        {
            return (
                MF16_PolyTextOut(
                        hdc,
                        (CONST POLYTEXTA*) pPolyTextW,
                        nstrings,
                        FALSE
                  )
                );
        }

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if
            (
                !MF_PolyTextOut(
                        hdc,
                        (CONST POLYTEXTA*) pPolyTextW,
                        nstrings,
                        EMR_POLYTEXTOUTA
                  )
            )
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
        {
            vSAPCallback(pldc);
        }

        if (pldc->fl & LDC_DOC_CANCELLED)
        {
            return(bRet);
        }

        if (pldc->fl & LDC_CALL_STARTPAGE)
        {
            StartPage(hdc);
        }
    }

    //
    // alloc memory for WHCAR structures
    //

    pCharBuffer = LOCALALLOC(szTotal);

    if (pCharBuffer == NULL)
    {
        return(FALSE);
    }

    RtlCopyMemory(pCharBuffer, (PBYTE) pPolyTextW, nstrings*sizeof(POLYTEXTW));
    pp = (POLYTEXTW *)pCharBuffer;

    //
    // now copy the stuff into the buffer
    //

    pj = (PBYTE)pCharBuffer + nstrings*sizeof(POLYTEXTW);

    dwCodePage = GetCodePage(hdc);

    bDBCSCodePage = IS_ANY_DBCS_CODEPAGE(dwCodePage);

    for ( i = 0; i < nstrings; i += 1 )
    {
        if ((pp[i].pdx != NULL) && (pp[i].lpstr != NULL))
        {
            // patch pdx

             cjdx = pp[i].n * sizeof(INT);
             if (pp[i].uiFlags & ETO_PDY)
                cjdx *= 2;

             if(bDBCSCodePage)
             {
                 ConvertDxArray(dwCodePage,
                                (char*) pp[i].lpstr,
                                pp[i].pdx,
                                pp[i].n,
                                (int*) pj,
                                pp[i].uiFlags & ETO_PDY
                                );
             }
             else
             {
                 RtlCopyMemory(pj,pp[i].pdx,cjdx);
             }

             pp[i].pdx = (int *)pj;

             pj += cjdx;
         }
     }


    for ( i = 0; i < nstrings; i += 1 )
    {
        if ( pp[i].lpstr != NULL )
        {
            pp[i].n = MultiByteToWideChar(dwCodePage,
                                          0,
                                          (LPSTR) pp[i].lpstr,
                                          pp[i].n, (LPWSTR) pj,
                                           pp[i].n*sizeof(WCHAR));

            // patch lpstr

            pp[i].lpstr = (LPWSTR)pj;

            pj += pp[i].n * sizeof(WCHAR);
        }
    }

    //
    // send off the message and cleanup
    //

    bRet = NtGdiPolyTextOutW(hdc,(POLYTEXTW *)pCharBuffer,nstrings,dwCodePage);

    LOCALFREE(pCharBuffer);

    return(bRet);

}

/******************************Public*Routine******************************\
*
* BOOL META WINAPI TextOutW
*
*
*
* History:
*  07-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL META WINAPI TextOutW(
    HDC        hdc,
    int        x,
    int        y,
    LPCWSTR  pwsz,
    int        c
)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if ((c <= 0) || (pwsz == (LPCWSTR) NULL))
    {
        if (c == 0)
            return(TRUE);

        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_TextOut(hdc,x,y,(LPCSTR) pwsz,c,TRUE));

        DC_PLDC(hdc,pldc,bRet);

        if((pldc->iType == LO_METADC) &&
           (!(pldc->fl & LDC_META_PRINT) || !gbLpk))
        {

            if (!MF_ExtTextOut(hdc,x,y,0,(LPRECT)NULL,(LPCSTR) pwsz,c,(LPINT)NULL,EMR_EXTTEXTOUTW))
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

#ifdef LANGPACK
    if(gbLpk)
    {
        return((*fpLpkExtTextOut)(hdc, x, y, 0, NULL, pwsz, c, 0, -1));
    }
#endif

    if ((c <= MAX_BATCH_WCHAR) && (GdiBatchLimit > 1))
    {
        bRet = bBatchTextOut(hdc,
                             x,
                             y,
                             0,
                             (LPRECT)NULL,
                             (LPWSTR)pwsz,
                             NULL,
                             c,
                             2 *c,
                             0);
    }

    if (!bRet)
    {
        bRet = NtGdiExtTextOutW(hdc,
                                x,
                                y,
                                0,
                                0,
                                (LPWSTR)pwsz,
                                c,
                                0,
                                0);
    }

    return(bRet);

}


/******************************Public*Routine******************************\
*
* DWORD   GetCodePage(HDC hdc)
*
* Effects: returns the code page of the font selected in the dc
*
* History:
*  23-May-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

DWORD   GetCodePage(HDC hdc)
{
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {

        if (!(pDcAttr->ulDirty_ & DIRTY_CHARSET))
            return (0x0000ffff & pDcAttr->iCS_CP);   // mask charset
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return guintAcp; // reasonable default;
    }

// we end up here if the code page attributes are dirty so that
// we have to call to the kernel, force the mapping and retrieve
// the code page and char set of the font selected in the dc:

    return (0x0000ffff & NtGdiGetCharSet(hdc)); // mask charset
}



/******************************Public*Routine******************************\
*
* BOOL META WINAPI ExtTextOutA
* History:
*  07-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

#define CAPTURE_STRING_SIZE 130

// not in kernel, it is ok to do this much on the stack

BOOL META WINAPI ExtTextOutInternalA(
    HDC        hdc,
    int        x,
    int        y,
    UINT       fl,
    CONST RECT *prcl,
    LPCSTR     psz,
    UINT       c,
    CONST INT  *pdx,
    BOOL       bFromTextOut
)
{
    BOOL bRet = FALSE;
    DWORD   dwCodePage;
    BOOL bDBCSCodePage;

    if ((fl & ETO_PDY) && !pdx)
        return FALSE;

// if we do not know what to do with the rectangle, ignore it.

    if (prcl && !(fl & (ETO_OPAQUE | ETO_CLIPPED)))
    {
        prcl = NULL;
    }
    if (!prcl)
    {
        fl &= ~(ETO_CLIPPED | ETO_OPAQUE); // ignore flags if no rect, win95 compat
    }

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
        {
            if(bFromTextOut)
            {
            // yes this matters, some apps rely on TextOutA being metafiled at
            // TextOut and not ExtTextOutA

                return(MF16_TextOut(hdc,x,y,psz,c,FALSE));
            }
            else
            {
                return (MF16_ExtTextOut(hdc,x,y,fl,prcl,psz,c,pdx,FALSE));
            }
        }

        DC_PLDC(hdc,pldc,bRet);

    // if we are EMF spooling then metafile glyph index calls, otherwise don't

        if((pldc->iType == LO_METADC) &&
           (!((!(pldc->fl & LDC_META_PRINT) && (fl & ETO_GLYPH_INDEX)) ||
             ((pldc->fl & LDC_META_PRINT) && !(fl & ETO_GLYPH_INDEX) && (gbLpk) && !(fl & ETO_IGNORELANGUAGE) && c)) ||
             (!(pldc->fl & LDC_META_PRINT) && (!(fl & ETO_GLYPH_INDEX)) && (fl & ETO_IGNORELANGUAGE) && (gbLpk))
           )
          )
        {
            DWORD mrType = (fl & ETO_GLYPH_INDEX) ?
                           EMR_EXTTEXTOUTW        :
                           EMR_EXTTEXTOUTA        ;

            if (!MF_ExtTextOut(hdc,x,y,fl,prcl,psz,c, pdx, mrType))
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
                        vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    if (fl & ETO_GLYPH_INDEX)
    {

        bRet = FALSE;

        if ((c <= MAX_BATCH_WCHAR) && (GdiBatchLimit > 1))
        {

            bRet = bBatchTextOut(hdc,
                                 x,
                                 y,
                                 fl,
                                 (LPRECT)prcl,
                                 (LPWSTR)psz,
                                 pdx,
                                 c,
                                 2*c,
                                 0);
        }

        if (!bRet)
        {
            bRet = NtGdiExtTextOutW(hdc,
                                    x,y,
                                    fl, (LPRECT)prcl,
                                    (LPWSTR)psz, (int)c,
                                    (LPINT)pdx, 0);
        }

        return(bRet);
    }

    // Get code page

    dwCodePage = GetCodePage(hdc);

    if(fFontAssocStatus)
    {
        dwCodePage = FontAssocHack(dwCodePage,(char*)psz,c);
    }

    bDBCSCodePage = IS_ANY_DBCS_CODEPAGE(dwCodePage);

    if (c)
    {
    // get the code page of the font selected in the dc

        WCHAR awcCaptureBuffer[CAPTURE_STRING_SIZE];
        PWSZ  pwszCapt;
        INT aiDxCaptureBuffer[CAPTURE_STRING_SIZE*2]; // times 2 for pdy
        INT *pDxCapture;

    // Allocate the string buffer

        if (c <= CAPTURE_STRING_SIZE)
        {
            pwszCapt = awcCaptureBuffer;
        }
        else
        {
            if(bDBCSCodePage)
            {
                pwszCapt = LOCALALLOC((c+1) * (sizeof(WCHAR)+ 2 * sizeof(INT)));
                pDxCapture = (INT*) &pwszCapt[(c+1)&~1];  //  ^
            }                                             //  |
            else                                          // for pdy, just in case
            {
                pwszCapt = LOCALALLOC(c * sizeof(WCHAR));
            }
        }

        if (pwszCapt)
        {
            UINT u;

            if(bDBCSCodePage && pdx)
            {
                if(c <= CAPTURE_STRING_SIZE)
                {
                    pDxCapture = aiDxCaptureBuffer;
                }

                ConvertDxArray(dwCodePage,(char*) psz,(int*) pdx,c,pDxCapture, fl & ETO_PDY);
            }
            else
            {
                pDxCapture = (int*) pdx;
            }

            u = MultiByteToWideChar(
                dwCodePage, 0,
                psz,c,
                pwszCapt, c*sizeof(WCHAR));

            if (u)
            {
                bRet = FALSE;

#ifdef LANGPACK
                if (gbLpk && !(fl & ETO_IGNORELANGUAGE))
                {
                    bRet = ((*fpLpkExtTextOut)(hdc, x, y, fl, prcl, pwszCapt,
                                               u, pDxCapture, 0));

                    if (pwszCapt != awcCaptureBuffer)
                        LOCALFREE(pwszCapt);

                    return bRet;
                }
#endif

                if ((c <= MAX_BATCH_WCHAR) && (GdiBatchLimit > 1))
                {
                    bRet = bBatchTextOut(hdc,
                                         x,
                                         y,
                                         fl,
                                         (LPRECT)prcl,
                                         (LPWSTR)pwszCapt,
                                         pDxCapture,
                                         u,
                                         2 * u,
                                         dwCodePage
                                         );
                }

                if (!bRet)
                {
                    bRet = NtGdiExtTextOutW(
                                    hdc,
                                    x,y,
                                    fl, (LPRECT)prcl,
                                    (LPWSTR)pwszCapt,(int)u,
                                    pDxCapture,
                                    dwCodePage);
                }

            }

            if (pwszCapt != awcCaptureBuffer)
                LOCALFREE(pwszCapt);
        }
        else
        {
            GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }
    }
    else
    {

        bRet = FALSE;

        if ((prcl != NULL) && (fl & ETO_OPAQUE))
        {
            //
            // try to batch text out rect
            //

            PDC_ATTR pdca;

            PSHARED_GET_VALIDATE(pdca,hdc,DC_TYPE);

            if ((pdca != NULL) && !(pdca->lTextAlign & TA_UPDATECP))
            {
                BEGIN_BATCH_HDC(hdc,pdca,BatchTypeTextOutRect,BATCHTEXTOUTRECT);

                    pBatch->BackColor  = pdca->crBackgroundClr;
                    pBatch->fl         = fl;
                    pBatch->rcl.left   = prcl->left;
                    pBatch->rcl.top    = prcl->top;
                    pBatch->rcl.right  = prcl->right;
                    pBatch->rcl.bottom = prcl->bottom;
                    pBatch->ptlViewportOrg = pdca->ptlViewportOrg;

                    bRet = TRUE;

                COMPLETE_BATCH_COMMAND();
            }
        }

UNBATCHED_COMMAND:

        if (!bRet)
        {
            bRet = NtGdiExtTextOutW(hdc,
                                    x,y,
                                    fl,
                                    (LPRECT)prcl,
                                    NULL,0,NULL,dwCodePage);
        }
    }

    return(bRet);
}

BOOL META WINAPI ExtTextOutA(
    HDC        hdc,
    int        x,
    int        y,
    UINT       fl,
    CONST RECT *prcl,
    LPCSTR     psz,
    UINT       c,
    CONST INT  *pdx
)
{
    return(ExtTextOutInternalA(hdc,x,y,fl,prcl,psz,c,pdx,FALSE));
}


/******************************Public*Routine******************************\
*
* BOOL META WINAPI TextOut
*
* History:
*  07-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL META WINAPI TextOutA(
    HDC        hdc,
    int        x,
    int        y,
    LPCSTR   psz,
    int        c
    )
{
    BOOL bRet = FALSE;

    if ((c <= 0) || (psz == (LPCSTR) NULL))
    {
        if (c == 0)
            return(TRUE);

        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }
    return ExtTextOutInternalA(hdc, x, y, 0, NULL, psz, c, NULL, TRUE);
}

/******************************Public*Routine******************************\
* FillRgn                                                                  *
*                                                                          *
* Client side stub.  Copies all LDC attributes into the message.           *
*
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI FillRgn(HDC hdc,HRGN hrgn,HBRUSH hbrush)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);
    FIXUP_HANDLE(hrgn);
    FIXUP_HANDLE(hbrush);

// validate the region and brush.
    if (!hrgn || !hbrush)
        return(bRet);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_DrawRgn(hdc,hrgn,hbrush,0,0,META_FILLREGION));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_FillRgn(hdc,hrgn,hbrush))
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    return(NtGdiFillRgn(hdc,hrgn,hbrush));
}

/******************************Public*Routine******************************\
* FrameRgn                                                                 *
*                                                                          *
* Client side stub.  Copies all LDC attributes into the message.           *
*
*  23-11-94 -by- Lingyun Wang [lingyunw]
* Now hrgn and hbrush are server side handles
*
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI FrameRgn(
    HDC    hdc,
    HRGN   hrgn,
    HBRUSH hbrush,
    int    cx,
    int    cy
)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);
    FIXUP_HANDLE(hrgn);
    FIXUP_HANDLE(hbrush);

    if (!hrgn || !hbrush)
        return(FALSE);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_DrawRgn(hdc,hrgn,hbrush,cx,cy,META_FRAMEREGION));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_FrameRgn(hdc,hrgn,hbrush,cx,cy))
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    return(NtGdiFrameRgn(hdc,hrgn,hbrush,cx,cy));
}

/******************************Public*Routine******************************\
* InvertRgn                                                                *
*                                                                          *
* Client side stub.                                                        *
*
* 23-11-94 -by- Lingyun Wang [lingyunw]
* Now hrgn is server side handle
*
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI InvertRgn(HDC hdc,HRGN hrgn)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);
    FIXUP_HANDLE(hrgn);

    if (!hrgn)
        return(FALSE);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_DrawRgn(hdc,hrgn,(HBRUSH)0,0,0,META_INVERTREGION));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_InvertPaintRgn(hdc,hrgn,EMR_INVERTRGN))
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    return(NtGdiInvertRgn(hdc,hrgn));
}

/******************************Public*Routine******************************\
* SetPixelV                                                                *
*                                                                          *
* Client side stub.  This is a version of SetPixel that does not return a  *
* value.  This one can be batched for better performance.                  *
*                                                                          *
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI SetPixelV(HDC hdc,int x,int y,COLORREF color)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParmsWWD(hdc,(WORD)x,(WORD)y,(DWORD)color,META_SETPIXEL));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SetPixelV(hdc,x,y,color))
                return(bRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(bRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    //
    // ICM conversion (only happen for non-palette index color)
    //

    if (!(color & 0x01000000))
    {
        PDC_ATTR pdca;

        PSHARED_GET_VALIDATE(pdca,hdc,DC_TYPE);

        if (pdca && bNeedTranslateColor(pdca))
        {
            COLORREF NewColor;

            if (IcmTranslateCOLORREF(hdc,pdca,color,&NewColor,ICM_FORWARD))
            {
                color = NewColor;
            }
        }
    }

    return(NtGdiSetPixel(hdc,x,y,color) != CLR_INVALID);
}

/******************************Public*Routine******************************\
* SetPixel                                                                 *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

COLORREF META WINAPI SetPixel(HDC hdc,int x,int y,COLORREF color)
{
    ULONG    iRet = CLR_INVALID;
    COLORREF ColorRet = CLR_INVALID;
    COLORREF NewColor;
    BOOL     bStatus;
    PDC_ATTR pdca;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParmsWWD(hdc,(WORD)x,(WORD)y,(DWORD)color,META_SETPIXEL));

        DC_PLDC(hdc,pldc,iRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SetPixelV(hdc,x,y,color))
                return(iRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(iRet);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    RESETUSERPOLLCOUNT();

    PSHARED_GET_VALIDATE(pdca,hdc,DC_TYPE);

    if (pdca)
    {
        //
        // if the color is not a PaletteIndex and ICM is on then translate
        //

        if (!(color & 0x01000000) && bNeedTranslateColor(pdca))
        {
            bStatus = IcmTranslateCOLORREF(hdc,
                                           pdca,
                                           color,
                                           &NewColor,
                                           ICM_FORWARD);
            if (bStatus)
            {
                color = NewColor;
            }
        }

        ColorRet = NtGdiSetPixel(hdc,x,y,color);

        if ( bNeedTranslateColor(pdca)
               &&
             ( IS_32BITS_COLOR(pdca->lIcmMode)
                        ||
               ((ColorRet != CLR_INVALID) &&
                 !(ColorRet & 0x01000000))
             )
           )
        {
            //
            // Translate back to original color
            //

            bStatus = IcmTranslateCOLORREF(hdc,
                                           pdca,
                                           ColorRet,
                                           &NewColor,
                                           ICM_BACKWARD);
            if (bStatus)
            {
                ColorRet = NewColor;
            }
        }
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(ColorRet);
}

/******************************Public*Routine******************************\
* UpdateColors                                                             *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL WINAPI UpdateColors(HDC hdc)
{
    BOOL  bRet = FALSE;

    FIXUP_HANDLE(hdc);

    RESETUSERPOLLCOUNT();

    return(NtGdiUpdateColors(hdc));
}

/******************************Public*Routine******************************\
* GdiFlush                                                                 *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Wed 26-Jun-1991 13:58:00 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL WINAPI GdiFlush(VOID)
{

    NtGdiFlush();
    return(TRUE);
}

/******************************Public*Routine******************************\
* GdiSetBatchLimit
*
*
* History:
*  31-Jul-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

DWORD WINAPI
GdiSetBatchLimit(
    DWORD dwNewBatchLimit
    )
{
    DWORD OldLimit = 0;

    //
    // set batch limit (as long as it is (1 <= l <= 20))
    // return old limit if successful. A new batch limit of 0
    // means set to default (20)
    //

    if (dwNewBatchLimit == 0)
    {
        dwNewBatchLimit = 20;
    }

    if ((dwNewBatchLimit > 0 ) && (dwNewBatchLimit <= 20))
    {
        GdiFlush();
        OldLimit = GdiBatchLimit;
        GdiBatchLimit = dwNewBatchLimit;
    }

    return(OldLimit);
}

/******************************Public*Routine******************************\
* GdiGetBatchLimit
*
* History:
*  7-Apr-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD WINAPI GdiGetBatchLimit()
{
    return(GdiBatchLimit);
}

/******************************Public*Routine******************************\
* EndPage
*
* Client side stub.
*
* History:
*  Wed 12-Jun-1991 01:02:25 -by- Charles Whitmer [chuckwh]
* Wrote it.
*  9/16/97 - Ramananthan N. Venkatpathy [RamanV]
* Parameterized End Page to handle Form Pages.
\**************************************************************************/

int InternalEndPage(HDC hdc,
                    DWORD dwPageType)
{
    int  iRet = SP_ERROR;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc) && !IS_METADC16_TYPE(hdc))
    {
        PLDC pldc;

        DC_PLDC(hdc,pldc,iRet);

        //
        // If the EndPage() is already called from
        // Escape(NEXTBAND), Just return TRUE here.
        //
        // This will fixed ...
        //
        // + The KB Q118873 "PRB: EndPage() Returns -1 When Banding"
        // + NTRaid #90099 "T1R: Visio 4.1, 16-bit can't print".
        //
        if( pldc->fl & LDC_CALLED_ENDPAGE )
        {
            pldc->fl &= ~LDC_CALLED_ENDPAGE;
            return((int)TRUE);
        }

        if( pldc->fl & LDC_META_PRINT )
        {
            if (dwPageType == NORMAL_PAGE) {
                return(MFP_EndPage( hdc ));
            } else if (dwPageType == FORM_PAGE) {
                return(MFP_EndFormPage( hdc ));;
            }
        }


        if ((pldc->fl & LDC_DOC_CANCELLED) ||
            ((pldc->fl & LDC_PAGE_STARTED) == 0))
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            return(iRet);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        pldc->fl &= ~LDC_PAGE_STARTED;

    // now call the drivers UI portion

        DocumentEventEx(pldc->pUMPD,
                pldc->hSpooler,
                hdc,
                DOCUMENTEVENT_ENDPAGE,
                0,
                NULL,
                0,
                NULL);

        RESETUSERPOLLCOUNT();

        iRet = NtGdiEndPage(hdc);

        // if user mode printer, call EndPagePrinter from user mode

        if (iRet && pldc->pUMPD)
            iRet = EndPagePrinterEx(pldc->pUMPD, pldc->hSpooler);

        // For Win31 compatibility, return SP_ERROR for error.

        if (!iRet)
            iRet = SP_ERROR;
        else
            pldc->fl |= LDC_CALL_STARTPAGE;

#if PRINT_TIMER
        if( bPrintTimer )
        {
            DWORD tc;
            tc = GetTickCount();
            DbgPrint("Page took %d.%d seconds to print\n",
                     (tc - pldc->msStartPage) / 1000,
                     (tc - pldc->msStartPage) % 1000 );

        }
#endif
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
    }

    return(iRet);
}

int WINAPI EndPage(HDC hdc)
{
    return InternalEndPage(hdc, NORMAL_PAGE);
}

int WINAPI EndFormPage(HDC hdc)
{
    return InternalEndPage(hdc, FORM_PAGE);
}

/******************************Public*Routine******************************\
* StartPage
*
* Client side stub.
*
* History:
*  31-Jul-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int WINAPI StartPage(HDC hdc)
{
    int iRet = SP_ERROR;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc) && !IS_METADC16_TYPE(hdc))
    {
        PLDC pldc;

        DC_PLDC(hdc,pldc,iRet);

#if PRINT_TIMER
        pldc->msStartPage = GetTickCount();
#endif

        if( pldc->fl & LDC_META_PRINT )
            return(MFP_StartPage( hdc ));

        pldc->fl &= ~LDC_CALL_STARTPAGE;
        pldc->fl &= ~LDC_CALLED_ENDPAGE;

        // Do nothing if page has already been started.

        if (pldc->fl & LDC_PAGE_STARTED)
            return(1);

    // now call the drivers UI portion

        if (pldc->hSpooler)
        {
            if (DocumentEventEx(pldc->pUMPD,
                    pldc->hSpooler,
                    hdc,
                    DOCUMENTEVENT_STARTPAGE,
                    0,
                    NULL,
                    0,
                    NULL) == -1)
            {
                return(iRet);
            }
        }

        pldc->fl |= LDC_PAGE_STARTED;

        RESETUSERPOLLCOUNT();

   // If it is UMPD, call StartPagePrinter from user mode

        if (pldc->pUMPD)
            iRet = StartPagePrinterEx(pldc->pUMPD, pldc->hSpooler);

        if (iRet)
        {
            iRet = NtGdiStartPage(hdc);
        }

    // For Win31 compatibility, return SP_ERROR for error.

        if (!iRet)
        {
            pldc->fl &= ~LDC_PAGE_STARTED;
            EndDoc(hdc);
            iRet = SP_ERROR;
            SetLastError(ERROR_INVALID_HANDLE);
        }
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* StartFormPage
*
* This interface has been added to support watermarks and forms.
*
* History:
*     7/1/97 -- Ramanathan Venkatapathy [RamanV]
*
\**************************************************************************/

int WINAPI StartFormPage(HDC hdc)
{
    // Call StartPage. Recording required for watermarks is done in EndFormPage

    return StartPage(hdc);
}

/******************************Public*Routine******************************\
* EndDoc
*
* If a thread is created at StartDoc(), terminate it here.
*
* History:
*  31-Jul-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int WINAPI EndDoc(HDC hdc)
{
    int  iRet = SP_ERROR;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc) && !IS_METADC16_TYPE(hdc))
    {
        PLDC pldc;

        DC_PLDC(hdc,pldc,iRet);

        if( pldc->fl & LDC_META_PRINT )
            return(MFP_EndDoc( hdc ));

#if PRINT_TIMER
        if( bPrintTimer )
        {
            DWORD tc;
            tc = GetTickCount();
            DbgPrint("Document took %d.%d seconds to print\n",
                     (tc - pldc->msStartDoc) / 1000,
                     (tc - pldc->msStartDoc) % 1000 );

            DbgPrint("Peak temporary spool buffer size: %d\n", PeakTempSpoolBuf);
        }
#endif

        if ((pldc->fl & LDC_DOC_STARTED) == 0)
            return(1);

        // Call EndPage if the page has been started.

        if (pldc->fl & LDC_PAGE_STARTED)
            EndPage(hdc);

        // now call the drivers UI portion

        DocumentEventEx(pldc->pUMPD,
                pldc->hSpooler,
                hdc,
                DOCUMENTEVENT_ENDDOCPRE,
                0,
                NULL,
                0,
                NULL);

        RESETUSERPOLLCOUNT();

        iRet = NtGdiEndDoc(hdc);

        //
        // call EndDocPrinter from user mode if it is a User Mode Printer
        //
        if (pldc->pUMPD)
            iRet = EndDocPrinterEx(pldc->pUMPD, pldc->hSpooler);

        // For Win31 compatibility, return SP_ERROR for error.

        if (!iRet)
        {
            iRet = SP_ERROR;
        }
        else
        {
            DocumentEventEx(pldc->pUMPD,
                    pldc->hSpooler,
                    hdc,
                    DOCUMENTEVENT_ENDDOCPOST,
                    0,
                    NULL,
                    0,
                    NULL);
        }

        pldc->fl &= ~(LDC_DOC_STARTED  | LDC_CALL_STARTPAGE |
                      LDC_SAP_CALLBACK | LDC_CALLED_ENDPAGE);
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* AbortDoc
*
* Client side stub.
*
* History:
*  02-Apr-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

int WINAPI AbortDoc(HDC hdc)
{
    int iRet = SP_ERROR;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc) && !IS_METADC16_TYPE(hdc))
    {
        PLDC pldc;

        DC_PLDC(hdc,pldc,iRet);

        if (!(pldc->fl & LDC_DOC_STARTED))
            return(1);

    // now call the drivers UI portion

        DocumentEventEx(pldc->pUMPD,
                pldc->hSpooler,
                hdc,
                DOCUMENTEVENT_ABORTDOC,
                0,
                NULL,
                0,
                NULL);

        RESETUSERPOLLCOUNT();

        if( pldc->fl & LDC_META_PRINT )
        {
            DeleteEnhMetaFile(UnassociateEnhMetaFile( hdc, FALSE ));
            DeleteEMFSpoolData(pldc);

            //
            // bug 150446: calling fpAbortPrinter before deleting the
            // EMF file might cause EMF file leak.
            //

            iRet = (*fpAbortPrinter)( pldc->hSpooler );
        }
        else
        {

            iRet = NtGdiAbortDoc(hdc);

            // call AbortPrinter from user mode if it is UMPD

            if (iRet && pldc->pUMPD)
                iRet = AbortPrinterEx(pldc, FALSE);
        }

    // For Win31 compatibility, return SP_ERROR for error.

        if (!iRet)
            iRet = SP_ERROR;

    // turn off the flags

        pldc->fl &= ~(LDC_DOC_STARTED  | LDC_PAGE_STARTED | LDC_CALL_STARTPAGE |
                      LDC_SAP_CALLBACK | LDC_META_PRINT   | LDC_CALLED_ENDPAGE);
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_HANDLE);
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* StartDocA
*
* Client side stub.
*
* History:
*
*  21-Mar-1995 -by- Mark Enstrom [marke]
* Change to call StartDocW for kmode
*
*  31-Jul-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

ULONG  ulToASCII_N(LPSTR psz, DWORD cbAnsi, LPWSTR pwsz, DWORD c);

int WINAPI StartDocA(HDC hdc, CONST DOCINFOA * pDocInfo)
{


    DOCINFOW DocInfoW;
    WCHAR    wDocName[MAX_PATH];
    WCHAR    wOutput[MAX_PATH];
    WCHAR    wDataType[MAX_PATH];
    int      Length;

    DocInfoW.cbSize = sizeof(DOCINFOW);
    DocInfoW.lpszDocName  = NULL;
    DocInfoW.lpszOutput   = NULL;
    DocInfoW.lpszDatatype = NULL;
    DocInfoW.fwType       = 0;

    if (pDocInfo)
    {
        if (pDocInfo->lpszDocName)
        {
            Length = strlen(pDocInfo->lpszDocName)+1;

            if (Length > MAX_PATH)
            {
                ERROR_ASSERT(FALSE, "StartDocA lpszDocName Too long");
                GdiSetLastError(ERROR_FILENAME_EXCED_RANGE);
                return(SP_ERROR);
            }

            DocInfoW.lpszDocName = &wDocName[0];
            vToUnicodeN(DocInfoW.lpszDocName,MAX_PATH,pDocInfo->lpszDocName,Length);
        }

        if (pDocInfo->lpszOutput)
        {
            Length = strlen(pDocInfo->lpszOutput)+1;

            if (Length > MAX_PATH)
            {
                ERROR_ASSERT(FALSE, "StartDocA lpszOutput Too long");
                GdiSetLastError(ERROR_FILENAME_EXCED_RANGE);
                return(SP_ERROR);
            }

            DocInfoW.lpszOutput = &wOutput[0];
            vToUnicodeN(DocInfoW.lpszOutput,MAX_PATH,pDocInfo->lpszOutput,Length);
        }

        // if the datatype is specified to be raw, and the size is the size of
        // the new expanded DOCINFO, make it raw.
        // we also verify that the fwType is valid.  Otherwise, chances are
        // the app left the two new fields unitialized.

        try
        {
            if ((pDocInfo->cbSize == sizeof(DOCINFO)) &&
                pDocInfo->lpszDatatype &&
                (pDocInfo->fwType <= 1))

            {

                if (!_stricmp("emf",pDocInfo->lpszDatatype))
                {
                    DocInfoW.lpszDatatype = L"EMF";
                }
                else
                {
                    Length = strlen(pDocInfo->lpszDatatype)+1;
                    vToUnicodeN(wDataType,MAX_PATH,pDocInfo->lpszDatatype,Length);
                    DocInfoW.lpszDatatype = wDataType;
                }
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("StartDocA an app passed a new DOCINFO structure without initializing it\n");
        }
    }

    return(StartDocW(hdc,&DocInfoW));
}

/******************************Public*Routine******************************\
* StartDocW
*
* Client side stub.
*
* History:
*  31-Jul-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int WINAPI StartDocW(HDC hdc, CONST DOCINFOW * pDocInfo)
{
    int iRet = SP_ERROR;
    PWSTR pwstr = NULL;
    DOCINFOW dio;
    BOOL bForceRaw = FALSE;
    BOOL bSendStartDocPost = FALSE;
    BOOL bCallAbortPrinter = TRUE;
    BOOL bEMF = FALSE;
    INT iJob;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc) && !IS_METADC16_TYPE(hdc))
    {
        BOOL bBanding;
        PLDC pldc;

        DC_PLDC(hdc,pldc,iRet);

        // don't allow StartDoc's on info dc's

        if (pldc->fl & LDC_INFO)
        {
            SetLastError(ERROR_INVALID_HANDLE);
            return iRet;
        }

        pldc->fl &= ~LDC_DOC_CANCELLED;

        #if PRINT_TIMER
        {
            DbgPrint("StartDocW: Print Timer is on\n");
            pldc->msStartDoc = GetTickCount();
        }
        #endif

        if( pDocInfo )
        {
            dio = *pDocInfo;

            if (dio.cbSize != offsetof(DOCINFOW,lpszDatatype))
            {
                dio.cbSize       = sizeof(DOCINFOW);
                dio.lpszDatatype = NULL;
                dio.fwType       = 0;

                try
                {
                    // if it is not NULL and not "emf", go raw
                    // we also verify that the fwType is valid.  Otherwise, chances are
                    // the app left the two new fields unitialized.

                    if ((pDocInfo->cbSize == sizeof(DOCINFOW)) &&
                        pDocInfo->lpszDatatype           &&
                        (pDocInfo->fwType <= 1)          &&
                        _wcsicmp(L"emf",pDocInfo->lpszDatatype))
                    {
                        // the app requested non emf

                        bForceRaw = TRUE;
                        dio.lpszDatatype = pDocInfo->lpszDatatype;
                    }
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNING("StartDocW an app passed a new DOCINFO structure without initializing it\n");
                }
            }
        }
        else
        {
            dio.cbSize = sizeof(DOCINFOW);
            dio.lpszDatatype = NULL;
            dio.lpszOutput   = NULL;
            dio.lpszDocName  = NULL;
            dio.fwType       = 0;
        }

        // if no output port is specified but a port was specified at createDC, use
        // that port now

        if ((dio.lpszOutput == NULL) && (pldc->pwszPort != NULL))
        {
            dio.lpszOutput = pldc->pwszPort;
        }

        // StartDocDlgW returns -1 for error
        //                      -2 for user cancelled
        //                      NULL if there is no string to copy (not file port)
        //                      Non NULL if there is a valid string

        if(pldc->hSpooler != (HANDLE)0)
        {
            ASSERTGDI(ghSpooler,"non null hSpooler with unloaded WINSPOOL W\n");

            pwstr = (*fpStartDocDlgW)(pldc->hSpooler, &dio);

            if((LONG_PTR)pwstr == -2)
            {
                pldc->fl |= LDC_DOC_CANCELLED;
                return(iRet);
            }
            if((LONG_PTR)pwstr == -1)
                return(iRet);

            if(pwstr != NULL)
            {
                dio.lpszOutput = pwstr;
            }
        }

        // now call the drivers UI portion

        if (pldc->hSpooler)
        {
            PVOID pv = (PVOID)&dio;

            iRet = DocumentEventEx(pldc->pUMPD,
                    pldc->hSpooler,
                    hdc,
                    DOCUMENTEVENT_STARTDOCPRE,
                    sizeof(pv),
                    (PVOID)&pv,
                    0,
                    NULL);

            if (iRet == -1)
            {
                bCallAbortPrinter = FALSE;
                goto KMMSGERROR;
            }
            if(iRet == -2)
            {
                pldc->fl |= LDC_DOC_CANCELLED;
                goto MSGEXIT;
            }

        }

        //
        // Check application compatibility
        //
        if (GetAppCompatFlags(NULL) & GACF_NOEMFSPOOLING)
        {
            ULONG InData = POSTSCRIPT_PASSTHROUGH;

            //
            // Disable EMF spooling for postscript printer driver.
            //
            // Several PS-centric application could not work with EMF spooling.
            // This problem is introduced, because application developed for win95
            // reley on that win95 does not do EMF spooling with postscript, but
            // NT does.
            //
            if (ExtEscape(hdc,QUERYESCSUPPORT,sizeof(ULONG),(LPCSTR)&InData,0,NULL))
            {
                bForceRaw = TRUE;
            }
        }

        // Unless the driver has explicitly told us not to spool, we will first try
        // to StartDoc with datatype EMF

        // we also force to go to EMF if METAFILE_DRIVER is supported by the driver

        if ((!bForceRaw && GetDCDWord(hdc, DDW_JOURNAL, 0) &&
            RemoteRasterizerCompatible(pldc->hSpooler)) ||
             ((pldc->pUMPD) && (pldc->pUMPD->dwFlags & UMPDFLAG_METAFILE_DRIVER)))
        {
            DOC_INFO_3W    DocInfo;

            DocInfo.pDocName    = (LPWSTR) dio.lpszDocName;
            DocInfo.pOutputFile = (LPWSTR) dio.lpszOutput;
            DocInfo.pDatatype   = (LPWSTR) L"NT EMF 1.008";
            DocInfo.dwFlags = DI_MEMORYMAP_WRITE;

            iJob = (*fpStartDocPrinterW)(pldc->hSpooler, 3, (LPBYTE) &DocInfo);

            if( iJob <= 0 )
            {
                if( GetLastError() != ERROR_INVALID_DATATYPE )
                {
                    WARNING("StartDocW: StartDocPrinter failed w/ error other \
                             than INVALID_DATA_TYPE\n");
                    bCallAbortPrinter = FALSE;
                    goto KMMSGERROR;
                }
                else
                {
                    // we are going raw so just fall through
                }
            }
            else
            {
                // the spooler likes the EMF data type so let start metafiling

                MFD1("StartDocW calling MFP_StartDocW to do EMF printing\n");

                if(MFP_StartDocW( hdc, &dio, FALSE))
                {
                    iRet = iJob;
                    bSendStartDocPost = TRUE;

                    goto MSGEXIT;
                }
                else
                {
                    WARNING("StartDocW: error calling MFP_StartDocW\n");
                    bEMF = TRUE;
                    goto KMMSGERROR;
                }
            }
        }


        // if it is a UMPD driver, call StartDocPrinter at the client side

        if (pldc->pUMPD)
        {

            DOC_INFO_1W    DocInfo;

            #define MAX_DOCINFO_DATA_TYPE 80
            WCHAR awchDatatype[MAX_DOCINFO_DATA_TYPE];
            PFN pfn;

            DocInfo.pDocName    = (LPWSTR) dio.lpszDocName;
            DocInfo.pOutputFile = (LPWSTR) dio.lpszOutput;
            DocInfo.pDatatype   = NULL;


            if (pfn = pldc->pUMPD->apfn[INDEX_DrvQuerySpoolType])
            {
                awchDatatype[0] = 0;

                // did the app specify a data type and will it fit in our buffer

                if (dio.lpszDatatype)
                {
                    int cjStr = (wcslen(dio.lpszDatatype) + 1) * sizeof(WCHAR);

                    if (cjStr < (MAX_DOCINFO_DATA_TYPE * sizeof(WCHAR)))
                    {
                        RtlCopyMemory((PVOID)awchDatatype,(PVOID)dio.lpszDatatype,cjStr);
                    }
                }

                if (pfn(((PUMDHPDEV)pldc->pUMdhpdev)->dhpdev, awchDatatype))
                {
                    DocInfo.pDatatype = awchDatatype;
                }

            }

            iJob = StartDocPrinterWEx(pldc->pUMPD, pldc->hSpooler, 1, (LPBYTE) &DocInfo);

        }

        // If we got here it means we are going raw.  Mark the DC as type direct

        if (pldc->pUMPD && (pldc->pUMPD->dwFlags & UMPDFLAG_METAFILE_DRIVER))
        {
           // we have to go EMF if METAFILE_DRIVER is on

           WARNING("StartDocW failed because EMF failed and METAFILE_DRIVER is on\n");
           goto KMMSGERROR;
        }

        pldc->fl |= LDC_PRINT_DIRECT;

        iRet = NtGdiStartDoc(hdc,&dio,&bBanding, iJob);

        if (iRet)
        {
            if (pldc->pfnAbort != NULL)
            {
                vSAPCallback(pldc);

                if (pldc->fl & LDC_DOC_CANCELLED)
                    goto KMMSGERROR;

                pldc->fl |= LDC_SAP_CALLBACK;
                pldc->ulLastCallBack = GetTickCount();
            }

            pldc->fl |= LDC_DOC_STARTED;

            if (bBanding)
            {
                MFD1("StartDocW calling MFP_StartDocW to do banding\n");
                iRet = MFP_StartDocW( hdc, NULL, TRUE )  ? iRet : SP_ERROR;
            }
            else
            {
                // Only set this when we are not banding since the system will
                // get confused and try to call StartPage while playing the
                // metafile back during banding.

                pldc->fl |= LDC_CALL_STARTPAGE;
            }

            bSendStartDocPost = TRUE;
        }
        else
        {
KMMSGERROR:
            iRet = SP_ERROR;

            if (bCallAbortPrinter && pldc->pUMPD)
            {
                AbortPrinterEx(pldc, bEMF);
            }
        }

MSGEXIT:
        if (bSendStartDocPost)
        {
            // now see if we need to call the drivers UI portion

            {
                if (DocumentEventEx(pldc->pUMPD,
                        pldc->hSpooler,
                        hdc,
                        DOCUMENTEVENT_STARTDOCPOST,
                        sizeof(iRet),
                        (PVOID)&iRet,
                        0,
                        NULL) == -1)
                {
                    AbortDoc(hdc);
                    iRet = SP_ERROR;
                }
            }
        }
    }

    if (pwstr != NULL)
    {
        LocalFree(pwstr);
    }

    return(iRet);
}


/******************************Public*Routine******************************\
* StartDocEMF
*
* Special version of StartDoc used by the EMF playback code.
*
* History:
*  31-Jul-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int WINAPI StartDocEMF(HDC hdc, CONST DOCINFOW * pDocInfo, BOOL *pbBanding )
{
    int iRet = SP_ERROR;
    DOCINFOW dio;
    INT  iJob = 0;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc) && !IS_METADC16_TYPE(hdc))
    {
        BOOL bBanding;
        PLDC pldc;

        DC_PLDC(hdc,pldc,iRet);

#if PRINT_TIMER
        {
            DbgPrint("StartDocW: Print Timer is on\n");
            pldc->msStartDoc = GetTickCount();
        }
#endif

        // if no output port is specified but a port was specified at createDC, use that port now

        if (pDocInfo)
        {
            dio = *pDocInfo;

            if (dio.lpszOutput == NULL && pldc->pwszPort != NULL)
                dio.lpszOutput = pldc->pwszPort;
        }
        else
        {
            ZeroMemory(&dio, sizeof(dio));
            dio.cbSize = sizeof(dio);
        }

        // if it is a UMPD driver, call StartDocPrinter at the client side

        if (pldc->pUMPD)
        {
            DOC_INFO_3W    DocInfo;

            DocInfo.pDocName    = (LPWSTR) dio.lpszDocName;
            DocInfo.pOutputFile = (LPWSTR) dio.lpszOutput;
            DocInfo.pDatatype   = NULL;
            DocInfo.dwFlags = DI_MEMORYMAP_WRITE;

            iJob = (*fpStartDocPrinterW)( pldc->hSpooler, 3, (LPBYTE) &DocInfo );
        }

        iRet = NtGdiStartDoc(hdc,(DOCINFOW *)&dio, pbBanding, iJob);

        if (iRet)
        {
            pldc->fl |= LDC_DOC_STARTED;
            pldc->fl |= LDC_CALL_STARTPAGE;
        }
        else
        {
        // For Win31 compatibility, return SP_ERROR for error.

            iRet = SP_ERROR;

            if (pldc->pUMPD)
            {
                (*fpAbortPrinter)(pldc->hSpooler);
            }
        }
    }

    return(iRet);
}



/******************************Private*Function****************************\
* vSAPCallback
*
*  Call back to applications abort proc.
*
* History:
*  02-May-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

VOID vSAPCallback(PLDC pldc)
{
    ULONG ulCurr = GetTickCount();

    if (ulCurr - pldc->ulLastCallBack >= CALLBACK_INTERVAL)
    {
        pldc->ulLastCallBack = ulCurr;
        if (!(*pldc->pfnAbort)(pldc->hdc, 0))
        {
            CancelDC(pldc->hdc);
            AbortDoc(pldc->hdc);
        }
    }
}

/******************************Public*Routine******************************\
* SetAbortProc
*
* Save the application-supplied abort function in the LDC struct.
*
* History:
*  02-Apr-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

int WINAPI SetAbortProc(HDC hdc, ABORTPROC pfnAbort)
{
    int iRet = SP_ERROR;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc) && !IS_METADC16_TYPE(hdc))
    {
        PLDC pldc;

        DC_PLDC(hdc,pldc,iRet);

        if (pfnAbort != (ABORTPROC)NULL)
        {
            // PageMaker calls SetAbortProc after StartDoc.

            if (pldc->fl & LDC_DOC_STARTED)
            {
                pldc->fl |= LDC_SAP_CALLBACK;
                pldc->ulLastCallBack = GetTickCount();
            }
        }
        else
        {
            pldc->fl &= ~LDC_SAP_CALLBACK;
        }

        pldc->pfnAbort = pfnAbort;

        iRet = 1;
    }

    return(iRet);
}


/******************************Public*Routine******************************\
*
* GetPairKernTable
*
* support for GETPAIRKERNTABLE escape, basically reroute the call
* the the regular API
*
* History:
*  17-Jun-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

DWORD GetPairKernTable (
    HDC        hdc,
    DWORD      cjSize,  // size of buffer in bytes
    KERNPAIR * pkp
    )
{
    DWORD dwRet = GetKerningPairsA(hdc, 0, NULL);
    DWORD dwRet1, ikp;

    if (pkp && dwRet)
    {
    // pointer to receiving buffer

        KERNINGPAIR *pKernPair = LOCALALLOC(dwRet * sizeof(KERNINGPAIR));
        if (pKernPair)
        {
            dwRet1 = GetKerningPairsA(hdc, dwRet, pKernPair);
            if (dwRet1 == dwRet)  // paranoid check
            {
            // now we can copy the data out, get the number of pairs
            // that the buffer can hold:

                dwRet = cjSize / sizeof (KERNPAIR);
                if (dwRet > dwRet1)
                    dwRet = dwRet1;

                for (ikp = 0; ikp < dwRet; ikp++)
                {
                    pkp[ikp].sAmount = (SHORT)pKernPair[ikp].iKernAmount;
                    pkp[ikp].wBoth = (WORD)
                                     ((BYTE)pKernPair[ikp].wFirst |
                                     (BYTE)pKernPair[ikp].wSecond << 8);
                }
            }
            else
            {
                dwRet = 0;
            }
            LOCALFREE(pKernPair);
        }
        else
        {
            dwRet = 0;
        }
    }

    return dwRet;
}






/******************************Public*Routine******************************\
* Escape                                                                   *
*                                                                          *
* Compatibility support for the old 16 bit Escape call.                    *
*                                                                          *
* Note that there are some rules to follow here:                           *
*                                                                          *
* 1) WOW should map a selected set of old Escape calls to ExtEscape.       *
*    These should be the calls that we want to support under NT (i.e. the  *
*    ones we are forced to support), and that make sense (i.e. have well   *
*    defined output structures, where NULL is well defined).  In this      *
*    mapping, WOW insures 32 bit alignment.  It maps directly to ExtEscape *
*    just for efficiency.                                                  *
*                                                                          *
* 2) GDI should map ALL the same calls that WOW does.  Thus when a 16 bit  *
*    app that works under WOW gets ported to 32 bits, it will keep         *
*    working, even if it still calls Escape.  (I'm basically assuming that *
*    Chicago will also allow this.  On the other hand if Chicago forces    *
*    apps to migrate to ExtEscape, then we can too.  But we can't force    *
*    them by ourselves!)                                                   *
*                                                                          *
* 3) Any data structures passed to Escape must get passed unchanged to     *
*    ExtEscape.  This includes the 16 bit WORD in POSTSCRIPT_PASSTHROUGH.  *
*    Remember, we *want* Chicago to be able to easily support our          *
*    ExtEscapes.  If we remove that WORD, it will be hard for then         *
*    to put it back.  It's pretty easy for our driver to ignore it.        *
*                                                                          *
* 4) Our Escape entry point should handle QUERYESCSUPPORT in the           *
*    following way.  a) It should require an nCount of 2, not the          *
*    present 4.  b) It should return TRUE for those functions that it      *
*    handles by mapping onto APIs.  c) For any function that it would pass *
*    on to ExtEscape, it should also pass the QUERYESCSUPPORT on.  (For    *
*    example, this function can't answer for the support of                *
*    POSTSCRIPT_PASSTHROUGH.)  However, the QUERYESCSUPPORT in ExtEscape   *
*    *should* expect a DWORD.  (It is after all a 32 bit function.)  This  *
*    should not inconvenience Chicago.  They can simply reject function    *
*    numbers >64K.                                                         *
*                                         [chuckwh - 5/8/93]               *
*                                                                          *
* History:                                                                 *
*  Mon May 17 13:49:32 1993     -by-    Hock San Lee    [hockl]            *
* Made ENCAPSULATED_POSTSCRIPT call DrawEscape.                            *
*                                                                          *
*  Sat 08-May-1993 00:03:06 -by- Charles Whitmer [chuckwh]                 *
* Added support for POSTSCRIPT_PASSTHROUGH, OPENCHANNEL, CLOSECHANNEL,     *
* DOWNLOADHEADER, DOWNLOADFACE, GETFACENAME, ENCAPSULATED_POSTSCRIPT.      *
* Cleaned up the code and conventions a bit.                               *
*                                                                          *
*  02-Apr-1992 -by- Wendy Wu [wendywu]                                     *
* Modified to call the client side GDI functions.                          *
*                                                                          *
*  01-Aug-1991 -by- Eric Kutter [erick]                                    *
* Wrote it.                                                                *
\**************************************************************************/

int WINAPI Escape(
    HDC    hdc,     //  Identifies the device context.
    int    iEscape, //  Specifies the escape function to be performed.
    int    cjIn,    //  Number of bytes of data pointed to by pvIn.
    LPCSTR pvIn,    //  Points to the input data.
    LPVOID pvOut    //  Points to the structure to receive output.
)
{
    int      iRet = 0;
    DOCINFOA DocInfo;
    PLDC     pldc;
    ULONG    iQuery;
    BOOL     bFixUp;

    FIXUP_HANDLE(hdc);

// Metafile the call.

    if(IS_METADC16_TYPE(hdc))
        return((int) MF16_Escape(hdc,iEscape,cjIn,pvIn,pvOut));

// handle escapes that don't require a printer

    switch (iEscape)
    {
    case QUERYESCSUPPORT:
        switch(*((UNALIGNED USHORT *) pvIn))
        {
        // Respond OK to the calls we handle inline below.

        case QUERYESCSUPPORT:
        case PASSTHROUGH:
        case STARTDOC:
        case ENDDOC:
        case NEWFRAME:
        case ABORTDOC:
        case SETABORTPROC:
        case GETPHYSPAGESIZE:
        case GETPRINTINGOFFSET:
        case GETSCALINGFACTOR:
        case NEXTBAND:
        case GETCOLORTABLE:
        case OPENCHANNEL:
        case CLOSECHANNEL:
        case DOWNLOADHEADER:
            iRet = (IS_ALTDC_TYPE(hdc) ? 1 : 0);
            break;

        case GETEXTENDEDTEXTMETRICS:
            iRet = 1;
            break;

        // Ask the driver about the few calls we allow to pass through.

        case SETCOPYCOUNT:
        case GETDEVICEUNITS:
        case POSTSCRIPT_PASSTHROUGH:
        case POSTSCRIPT_DATA:
        case POSTSCRIPT_IGNORE:
        case POSTSCRIPT_IDENTIFY:
        case POSTSCRIPT_INJECTION:
        case DOWNLOADFACE:
        case BEGIN_PATH:
        case END_PATH:
        case CLIP_TO_PATH:
        case DRAWPATTERNRECT:

           iQuery = (ULONG) (*((UNALIGNED USHORT *) pvIn));

           iRet =
           (
                ExtEscape
                (
                    hdc,
                    (ULONG) ((USHORT) iEscape),
                    4,
                    (LPCSTR) &iQuery,
                    0,
                    (LPSTR) NULL
                )
           );
           break;



        case ENCAPSULATED_POSTSCRIPT:
            iQuery = (ULONG) (*((UNALIGNED USHORT *) pvIn));

            iRet =
            (
                DrawEscape
                (
                    hdc,
                    (int) (ULONG) ((USHORT) iEscape),
                    4,
                    (LPCSTR) &iQuery
                )
            );
            break;

        case QUERYDIBSUPPORT:
            iRet = 1;
            break;

        // Otherwise it's no deal.  Sorry.  If we answer "yes" to some
        // call we don't know *everything* about, we may find ourselves
        // actually rejecting the call later when the app actually calls
        // with some non-NULL pvOut.  This would get the app all excited
        // about our support for no reason.  It would take a path that
        // is doomed to failure. [chuckwh]

        default:
            iRet = 0;
            break;
        }
        return(iRet);

    case GETCOLORTABLE:

        iRet = GetSystemPaletteEntries(hdc,*((UNALIGNED SHORT *)pvIn),1,pvOut);

        if (iRet == 0)
            iRet = -1;
        return(iRet);

    case QUERYDIBSUPPORT:
        if ((pvOut != NULL) && (cjIn >= sizeof(BITMAPINFOHEADER)))
        {
        *((UNALIGNED LONG *)pvOut) = 0;

            switch (((UNALIGNED BITMAPINFOHEADER *)pvIn)->biCompression)
            {
            case BI_RGB:
                switch (((UNALIGNED BITMAPINFOHEADER *)pvIn)->biBitCount)
                {
                case 1:
                case 4:
                case 8:
                case 16:
                case 24:
                case 32:
            *((UNALIGNED LONG *)pvOut) = (QDI_SETDIBITS|QDI_GETDIBITS|
                                                 QDI_DIBTOSCREEN|QDI_STRETCHDIB);
                    break;
                default:
                    break;
                }

            case BI_RLE4:
                if (((UNALIGNED BITMAPINFOHEADER *)pvIn)->biBitCount == 4)
                {
            *((UNALIGNED LONG *)pvOut) = (QDI_SETDIBITS|QDI_GETDIBITS|
                                                 QDI_DIBTOSCREEN|QDI_STRETCHDIB);
                }
                break;

            case BI_RLE8:
                if (((UNALIGNED BITMAPINFOHEADER *)pvIn)->biBitCount == 8)
                {
            *((UNALIGNED LONG *)pvOut) = (QDI_SETDIBITS|QDI_GETDIBITS|
                                                 QDI_DIBTOSCREEN|QDI_STRETCHDIB);
                }
                break;

            case BI_BITFIELDS:
                switch (((UNALIGNED BITMAPINFOHEADER *)pvIn)->biBitCount)
                {
                case 16:
                case 32:
            *((UNALIGNED LONG *)pvOut) = (QDI_SETDIBITS|QDI_GETDIBITS|
                                                 QDI_DIBTOSCREEN|QDI_STRETCHDIB);
                    break;
                default:
                    break;
                }

            default:
                break;
            }
            return 1;
        }

    case GETEXTENDEDTEXTMETRICS:
        return( GetETM( hdc, pvOut ) ? 1 : 0 );

    }

// OK, ones that are related to printing and need the LDC

    if (IS_ALTDC_TYPE(hdc))
    {
        BOOL bFixUp = FALSE;
        PLDC pldc;

        DC_PLDC(hdc,pldc,iRet);

    // Call the appropriate client side APIs.

        switch (iEscape)
        {
        case CLOSECHANNEL:
        case ENDDOC:
            iRet = EndDoc(hdc);
            break;

        case ABORTDOC:
            iRet = AbortDoc(hdc);
            break;

        case SETABORTPROC:
            iRet = SetAbortProc(hdc, (ABORTPROC)pvIn);
            break;

        case GETSCALINGFACTOR:
            if (pvOut)
            {
                ((UNALIGNED POINT *)pvOut)->x = GetDeviceCaps(hdc, SCALINGFACTORX);
                ((UNALIGNED POINT *)pvOut)->y = GetDeviceCaps(hdc, SCALINGFACTORY);
            }
            iRet = 1;

            break;

        case SETCOPYCOUNT:
            iRet =
            (
                ExtEscape
                (
                    hdc,
                    (ULONG) ((USHORT) iEscape),
                    cjIn,
                    pvIn,
                    pvOut ? sizeof(int) : 0,
                    (LPSTR) pvOut
                )
            );
            break;

        case GETDEVICEUNITS:
            iRet =
            (
                ExtEscape
                (
                    hdc,
                    GETDEVICEUNITS,
                    cjIn,
                    pvIn,
                    16,
                    pvOut
                )
            );
            break;

        case POSTSCRIPT_PASSTHROUGH:
            iRet =
            (
                ExtEscape
                (
                    hdc,
                    POSTSCRIPT_PASSTHROUGH,
                    (int) (*((UNALIGNED USHORT *) pvIn))+2,
                    pvIn,
                    0,
                    (LPSTR) NULL
                )
            );
            break;

        case OPENCHANNEL:
            DocInfo.lpszDocName = (LPSTR) NULL;
            DocInfo.lpszOutput  = (LPSTR) NULL;
            DocInfo.lpszDatatype= (LPSTR) "RAW";
            DocInfo.fwType      = 0;
            iRet = StartDocA(hdc,&DocInfo);
            break;

        case DOWNLOADHEADER:
            iRet = 1;
            break;

        case POSTSCRIPT_DATA:
        case POSTSCRIPT_IGNORE:
        case POSTSCRIPT_IDENTIFY:
        case POSTSCRIPT_INJECTION:
        case DOWNLOADFACE:
        case BEGIN_PATH:
        case END_PATH:
        case CLIP_TO_PATH:
        case DRAWPATTERNRECT:
            iRet =
            (
                ExtEscape
                (
                    hdc,
                    (ULONG) ((USHORT) iEscape),
                    cjIn,
                    pvIn,
                    0,
                    (LPSTR) NULL
                )
            );
            break;



        case ENCAPSULATED_POSTSCRIPT:
            iRet =
            (
                DrawEscape
                (
                    hdc,
                    (int) (ULONG) ((USHORT) iEscape),
                    cjIn,
                    pvIn
                )
            );
            break;

        case GETPHYSPAGESIZE:
            if (pvOut)
            {
                ((UNALIGNED POINT *)pvOut)->x = GetDeviceCaps(hdc, PHYSICALWIDTH);
                ((UNALIGNED POINT *)pvOut)->y = GetDeviceCaps(hdc, PHYSICALHEIGHT);
            }
            iRet = 1;
            break;

        case GETPRINTINGOFFSET:
            if (pvOut)
            {
                ((UNALIGNED POINT *)pvOut)->x = GetDeviceCaps(hdc, PHYSICALOFFSETX);
                ((UNALIGNED POINT *)pvOut)->y = GetDeviceCaps(hdc, PHYSICALOFFSETY);
            }
            iRet = 1;
            break;

        case STARTDOC:
            DocInfo.lpszDocName = (LPSTR)pvIn;
            DocInfo.lpszOutput  = (LPSTR)NULL;
            DocInfo.lpszDatatype= (LPSTR) NULL;
            DocInfo.fwType      = 0;

            iRet = StartDocA(hdc, &DocInfo);
            bFixUp = TRUE;
            break;

        case PASSTHROUGH:

            #if (PASSTHROUGH != DEVICEDATA)
                #error PASSTHROUGH != DEVICEDATA
            #endif

            iRet = ExtEscape
                   (
                     hdc,
                     PASSTHROUGH,
                     (int) (*((UNALIGNED USHORT *) pvIn))+sizeof(WORD),
                     pvIn,
                     0,
                     (LPSTR) NULL
                   );
            bFixUp = TRUE;
            break;

        case NEWFRAME:
            if (pldc->fl & LDC_CALL_STARTPAGE)
                StartPage(hdc);

        // If no error occured in EndPage, call StartPage next time.

            if ((iRet = EndPage(hdc)) > 0)
                pldc->fl |= LDC_CALL_STARTPAGE;

            bFixUp = TRUE;
            break;

        case NEXTBAND:
        // Win31 compatibility flags.
        // GACF_MULTIPLEBANDS: Freelance thinks the first full-page band is
        //                     a text-only band.  So it ignores it and waits
        //                     for the next band to print graphics.  We'll
        //                     return the full-page band twice for each page.
        //                     The first band will be ignored while the second
        //                     band really contains graphics to print.
        //                     This flag only affects dotmatrix on win31.
        // GACF_FORCETEXTBAND: World Perfect and Freelance both have assumptions
        //                     on whether a band is text-only or not.  They
        //                     print text and graphics in different bands.
        //                     We'll return two full-page bands for each page.
        //                     One for text and the other for graphics.
        //                     This flag only affects laser jet on win31.

            if (pldc->fl & LDC_NEXTBAND)
            {
                if (GetAppCompatFlags(NULL) & (GACF_FORCETEXTBAND|GACF_MULTIPLEBANDS))
                {
                    if (pldc->fl & LDC_EMPTYBAND)
                    {
                        pldc->fl &= ~LDC_EMPTYBAND;
                    }
                    else
                    {
                        pldc->fl |= LDC_EMPTYBAND;
                        goto FULLPAGEBAND;
                    }
                }

                ((UNALIGNED RECT *)pvOut)->left = ((UNALIGNED RECT *)pvOut)->top =
                ((UNALIGNED RECT *)pvOut)->right = ((UNALIGNED RECT *)pvOut)->bottom = 0;

                pldc->fl &= ~LDC_NEXTBAND;  // Clear NextBand flag.

                if (pldc->fl & LDC_CALL_STARTPAGE)
                    StartPage(hdc);

                if ((iRet = EndPage(hdc)) > 0)
                {
                    pldc->fl |= LDC_CALL_STARTPAGE;

                //
                // Marks application is doing banding by themselves,
                // then EndPage() is called when there is no more band.
                //
                    pldc->fl |= LDC_CALLED_ENDPAGE;
                }

                bFixUp = TRUE;
            }
            else
            {
    FULLPAGEBAND:
                ((UNALIGNED RECT *)pvOut)->left = ((UNALIGNED RECT *)pvOut)->top = 0;
                ((UNALIGNED RECT *)pvOut)->right = GetDeviceCaps(hdc, HORZRES);
                ((UNALIGNED RECT *)pvOut)->bottom = GetDeviceCaps(hdc, VERTRES);

                pldc->fl |= LDC_NEXTBAND;   // Set NextBand flag.
                iRet = 1;
            }
            break;

        default:
            iRet = 0;
            break;
        }

    // Fix up the return values for STARTDOC and PASSTHROUGH so we're
    // win31 compatible.

        if (bFixUp && (iRet < 0))
        {
            if (pldc->fl & LDC_DOC_CANCELLED)
            {
                iRet = SP_APPABORT;
            }
            else
            {
                switch(GetLastError())
                {
                case ERROR_PRINT_CANCELLED:
                    iRet = SP_USERABORT;
                    break;

                case ERROR_NOT_ENOUGH_MEMORY:
                    iRet = SP_OUTOFMEMORY;
                    break;

                case ERROR_DISK_FULL:
                    iRet = SP_OUTOFDISK;
                    break;

                default:
                    iRet = SP_ERROR;
                    break;
                }
            }
        }
    }
    else
    {
        // We don't support this escape on this DC, but CorelDRAW expects
        // some non-random values back anyway. Zero the output buffer to
        // keep it happy.

        if ((iEscape == GETSCALINGFACTOR) && pvOut)
        {
            RtlZeroMemory(pvOut, sizeof(POINT));
        }
    }
    return(iRet);
}

/******************************Public*Routine******************************\
* ExtEscape                                                                *
*                                                                          *
* History:                                                                 *
*  14-Feb-1992 -by- Dave Snipp [DaveSn]                                    *
* Wrote it.                                                                *
\**************************************************************************/

#define BUFSIZE 520


int WINAPI ExtEscape(
    HDC    hdc,         //  Identifies the device context.
    int    iEscape,     //  Specifies the escape function to be performed.
    int    cjInput,     //  Number of bytes of data pointed to by lpInData
    LPCSTR lpInData,    //  Points to the input structure required
    int    cjOutput,    //  Number of bytes of data pointed to by lpOutData
    LPSTR  lpOutData    //  Points to the structure to receive output from
)                       //   this escape.
{
    int iRet = 0;
    int cjIn, cjOut, cjData;
    PLDC pldc;
    XFORM xf;

// We need some extra buffer space for at least one call.  I'm going to
// hard code it here.  The slickest thing would be to have a separate
// routine that knows how to alloc this space out of the memory window,
// but that would be more complex.  I'm rushed.  Sorry.  [chuckwh]

    BYTE jBuffer[BUFSIZE];

// We want to make this escape work just like it does in Windows which means
// that if there is a TrueType font in the DC GDI will compute it otherwise
// we'll pass the escape to the driver.  So we call off to GetETM here because
// it does just that.

    FIXUP_HANDLE(hdc);

    if( iEscape == GETEXTENDEDTEXTMETRICS )
    {
        if( GetETM( hdc, (EXTTEXTMETRIC*) jBuffer ) )
        {
            RtlCopyMemory( lpOutData, jBuffer, MIN(cjOutput,sizeof(EXTTEXTMETRIC)) );
            return(1);
        }
        else
        {
            return(0);
        }
    }
    else if (iEscape == DRAWPATTERNRECT)
    {
        if (GetAppCompatFlags2(VER40) & GACF2_NODRAWPATRECT)
        {
            // GACF_NODRAWPATRECT -
            //
            // Some of application does not work with DrawPatRect escape,
            // so that we behave as we don't support it.
            //
            return (0);
        }

        if (!cjInput)
        {
            //
            // work around 32 bits Excel (with Ofiice 97) bug.
            //
            cjInput = sizeof(DRAWPATRECT);
        }
    }
    else if (iEscape == QUERYESCSUPPORT)
    {
        if (*(ULONG*)lpInData == GETPAIRKERNTABLE)
        {
            // intercept GETPAIRKERNTABLE escape on the client side where all the work is done
            // It is interesting that this "api" works on win95 not only for device fonts but
            // also for engine fonts. Therefore this needs to be outside of
            // the IS_ALTDC_TYPE(hdc) clause below

            return (1);
        }
        else if (*(ULONG*)lpInData == DRAWPATTERNRECT)
        {
            if (GetAppCompatFlags2(VER40) & GACF2_NODRAWPATRECT)
            {
                // GACF_NODRAWPATRECT -
                //
                // Some of application does not work with DrawPatRect escape,
                // so that we behave as we don't support it.
                //
                return (0);
            }
        }
    }
    else if (iEscape == GETPAIRKERNTABLE)
    {
        return GetPairKernTable(hdc, (DWORD)cjOutput, (KERNPAIR *)lpOutData);
    }

// printer specific stuff

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        // don't allow them 16bit metafiles

        if (IS_METADC16_TYPE(hdc))
            return (0);

        DC_PLDC(hdc,pldc,iRet);

        MFD2("ExtEscapeCalled %d\n", iEscape );

        if (pldc->fl & (LDC_DOC_CANCELLED|LDC_SAP_CALLBACK))
        {
            if (pldc->fl & LDC_SAP_CALLBACK)
                vSAPCallback(pldc);

            if (pldc->fl & LDC_DOC_CANCELLED)
                return(0);
        }

        // if it is an output call that requires no return results, better make sure
        // we do a start page.

        if (( iEscape == DOWNLOADFACE ) ||
            ( iEscape == GETFACENAME ) ||
            ( iEscape == POSTSCRIPT_DATA ) ||
            ( iEscape == BEGIN_PATH ) ||
            ( iEscape == END_PATH ) ||
            ( iEscape == CLIP_TO_PATH ) ||
            ( iEscape == PASSTHROUGH ) ||
            ( iEscape == DOWNLOADHEADER ))
        {
            if (pldc->fl & LDC_CALL_STARTPAGE)
                StartPage(hdc);
        }

        if ((pldc->iType == LO_METADC) && (pldc->fl & LDC_META_PRINT))
        {
            // These two escapes should be called *before* StartDoc, any these escape
            // called *after* StartDoc will be failed when EMF is used (see SDK)

            if ((iEscape == POSTSCRIPT_IDENTIFY) || (iEscape == POSTSCRIPT_INJECTION))
            {
                WARNING("GDI32: ExtEscape() PSInjection after StartDoc with EMF, is ignored\n");

                SetLastError(ERROR_INVALID_PARAMETER);
                return (0);
            }

            // These escapes will not be recorded into metafile
            //
            // SETCOPYCOUNT - will be handled in kernel for EMF spooling case.
            //                and this will be recorded in DEVMODE.dmCopies.
            //
            // QUERYSUPPORT - will be handled in driver even EMF spooling case,
            //                since only driver knows which escape support it.
            //                and this is nothing for drawing, so not nessesary
            //                to record it.
            //
            // CHECKJPEGFORMAT & CHECKPNGFORMAT
            //              - query escapes that do not need to be reocorded
            //                into metafile.
            //

            if ((iEscape != SETCOPYCOUNT) && (iEscape != QUERYESCSUPPORT) &&
                (iEscape != CHECKJPEGFORMAT) && (iEscape != CHECKPNGFORMAT))
            {
                BOOL bSetXform = FALSE;

                // Write this escape to metafile.

                //
                // If there's transform set in the hdc by the app
                // at the time of DRAWPATRECT, select identity transform in
                // once the escape is recorded, select back the original transform
                //
                if (GetWorldTransform(hdc, &xf))
                {
                   if ((xf.eM11 != 1.0f) || (xf.eM22 != 1.0f) ||
                           (xf.eM12 != 0.0f) || (xf.eM21 != 0.0f))
                   {
                       bSetXform = TRUE;
                       MF_ModifyWorldTransform(hdc,&xformIdentity,MWT_SET);
                   }
                }

                MF_WriteEscape( hdc, iEscape, cjInput, lpInData, EMR_EXTESCAPE );

                if (bSetXform)
                {
                   MF_ModifyWorldTransform(hdc,&xf,MWT_SET);
                }

                if ((lpOutData == (LPSTR) NULL) || (cjOutput == 0))
                {
                    if ((iEscape == PASSTHROUGH) ||
                        (iEscape == POSTSCRIPT_PASSTHROUGH) ||
                        (iEscape == POSTSCRIPT_DATA))
                    {
                        if ((cjInput < (int)sizeof(WORD)) ||
                            (cjInput < (int)sizeof(WORD) + *((LPWORD) lpInData)))
                        {
                            SetLastError(ERROR_INVALID_PARAMETER);
                            return -1;
                        }

                        cjInput = *((LPWORD) lpInData);
                    }

                    return(MAX(cjInput,1));
                }
            }

            MFD2("ExtEscape goes to gre/driver Escape(%d) with EMF printing\n", iEscape);
        }

        if ((iEscape == DOWNLOADFACE) || (iEscape == GETFACENAME))
        {
            if (iEscape == DOWNLOADFACE)
            {
            // Adjust the buffer for the DOWNLOADFACE case.  Note that lpOutData
            // points at an input word for the mode.

                if ((gpwcANSICharSet == (WCHAR *) NULL) && !bGetANSISetMap())
                {
                    return(0);
                }

                RtlMoveMemory
                (
                    jBuffer + sizeof(WCHAR),
                    (BYTE *) &gpwcANSICharSet[0],
                    256*sizeof(WCHAR)
                );

                if (lpOutData)
                    *(WCHAR *) jBuffer = *(UNALIGNED WORD *) lpOutData;
                else
                    *(WCHAR *) jBuffer = 0;

                cjInput = 257 * sizeof(WCHAR);
                lpInData = (LPCSTR) jBuffer;

                ASSERTGDI(BUFSIZE >= cjInput,"Buffer too small.\n");
            }
        }

        if ((iEscape == POSTSCRIPT_INJECTION) || (iEscape == POSTSCRIPT_IDENTIFY))
        {
            // Remember escape data for EMF spooling case. (only BEFORE StartDoc)

            if (!(pldc->fl & LDC_DOC_STARTED))
            {
                PPS_INJECTION_DATA pPSInjection;

                DWORD cjCellSize = ROUNDUP_DWORDALIGN((sizeof(PS_INJECTION_DATA)-1)+cjInput);

                MFD2("ExtEscape records this Escape(%d) temporary then write EMF later\n",iEscape);

                if ((pPSInjection = LOCALALLOC(cjCellSize)) != NULL)
                {
                    cjCellSize -= offsetof(PS_INJECTION_DATA,EmfData);

                    // Fill up Injection Data.

                    pPSInjection->EmfData.cjSize  = cjCellSize;
                    pPSInjection->EmfData.nEscape = iEscape;
                    pPSInjection->EmfData.cjInput = cjInput;
                    RtlCopyMemory(pPSInjection->EmfData.EscapeData,lpInData,cjInput);

                    // Put this on list.

                    InsertTailList(&(pldc->PSDataList),&(pPSInjection->ListEntry));

                    // Update total data size.

                    pldc->dwSizeOfPSDataToRecord += cjCellSize;
                }
                else
                {
                    WARNING("ExtEscape: Failed on LOCALALLOC for POSTSCRIPT_xxxxx\n");
                    GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    return (0);
                }
            }
        }

    // now call the drivers UI portion

        if (pldc->hSpooler)
        {
            DOCEVENT_ESCAPE  docEvent;

            docEvent.iEscape = iEscape;
            docEvent.cjInput = cjInput;
            docEvent.pvInData = (PVOID)lpInData;

            DocumentEventEx(pldc->pUMPD,
                    pldc->hSpooler,
                    hdc,
                    DOCUMENTEVENT_ESCAPE,
                    sizeof(docEvent),
                    (PVOID)&docEvent,
                    cjOutput,
                    (PVOID)lpOutData);
        }
    }

    cjIn  = (lpInData == NULL) ? 0 : cjInput;
    cjOut = (lpOutData == NULL) ? 0 : cjOutput;

    iRet = NtGdiExtEscape(hdc,NULL,0,iEscape,cjIn,(LPSTR)lpInData,cjOut,lpOutData);

    return(iRet);
}

/******************************Public*Routine******************************\
* NamedEscape
*
* History:
*  5-Mar-1996 -by- Gerrit van Wingerden
* Wrote it.
\**************************************************************************/

#define BUFSIZE 520

int WINAPI NamedEscape(
    HDC    hdc,         //  Identifies the device context for EMF spooling
    LPWSTR pwszDriver,  //  Identfies the driver
    int    iEscape,     //  Specifies the escape function to be performed.
    int    cjInput,     //  Number of bytes of data pointed to by lpInData
    LPCSTR lpInData,    //  Points to the input structure required
    int    cjOutput,    //  Number of bytes of data pointed to by lpOutData
    LPSTR  lpOutData    //  Points to the structure to receive output from
)                       //   this escape.
{
    int iRet = 0;
    int cjIn, cjOut, cjData;
    PLDC pldc;

    if(hdc)
    {
        FIXUP_HANDLE(hdc);

    // if we are EMF spooling then we need to record the call here

        if (IS_ALTDC_TYPE(hdc))
        {
            PLDC pldc;

            // don't allow them in 16bit metafiles

            if (IS_METADC16_TYPE(hdc))
              return(0);

            DC_PLDC(hdc,pldc,iRet);

            MFD2("NamedEscapeCalled %d\n", iEscape );

            if (pldc->fl & (LDC_DOC_CANCELLED|LDC_SAP_CALLBACK))
            {
                if (pldc->fl & LDC_SAP_CALLBACK)
                  vSAPCallback(pldc);

                if (pldc->fl & LDC_DOC_CANCELLED)
                  return(0);
            }

            if (pldc->iType == LO_METADC)
            {
                if(!MF_WriteNamedEscape(hdc,
                                        pwszDriver,
                                        iEscape,
                                        cjInput,
                                        lpInData))
                {
                    WARNING("Error metafiling NameEscape\n");
                    return(0);
                }
            }
        }
    }

    cjIn  = (lpInData == NULL) ? 0 : cjInput;
    cjOut = (lpOutData == NULL) ? 0 : cjOutput;

    iRet = NtGdiExtEscape((HDC) 0,
                          pwszDriver,
                          wcslen(pwszDriver),
                          iEscape,cjIn,
                          (LPSTR)lpInData,
                          cjOut,lpOutData);

    return(iRet);
}



/******************************Public*Routine******************************\
* DrawEscape                                                               *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  02-Apr-1992 -by- Wendy Wu [wendywu]                                     *
* Wrote it.                                                                *
\**************************************************************************/

int WINAPI DrawEscape(
    HDC    hdc,         //  Identifies the device context.
    int    iEscape,     //  Specifies the escape function to be performed.
    int    cjIn,        //  Number of bytes of data pointed to by lpIn.
    LPCSTR lpIn         //  Points to the input data.
)
{
    int  iRet = 0;
    int  cjInput;

    FIXUP_HANDLE(hdc);

// printer specific stuff

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        // don't allow them 16bit metafiles

        if (IS_METADC16_TYPE(hdc))
            return(0);

        DC_PLDC(hdc,pldc,iRet);

        MFD2("Calling DrawEscape %d\n", iEscape );

        if( ( pldc->fl & LDC_META_PRINT ) && ( iEscape != QUERYESCSUPPORT ) )
        {
            MF_WriteEscape( hdc, iEscape, cjIn, lpIn, EMR_DRAWESCAPE );
        }
    }

// Compute the buffer size we need.  Since the in and out buffers
// get rounded up to multiples of 4 bytes, we need to simulate that
// here.

    cjInput = (lpIn == NULL) ? 0 : ((cjIn+3)&-4);

    iRet = NtGdiDrawEscape(hdc,iEscape,cjIn,(LPSTR)lpIn);

    return(iRet);
}

/******************************Public*Routine******************************\
* DeviceCapabilitiesExA
*
* This never got implemented.  The spooler suports DeviceCapabilities.
*
* History:
*  01-Aug-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int WINAPI DeviceCapabilitiesExA(
    LPCSTR     pszDriver,
    LPCSTR     pszDevice,
    LPCSTR     pszPort,
    int        iIndex,
    LPCSTR     pb,
    CONST DEVMODEA *pdm)
{
    return(GDI_ERROR);

    pszDriver;
    pszDevice;
    pszPort;
    iIndex;
    pb;
    pdm;
}

/**************************************************************************\
 *
 * New to be implemented Api's for Windows95.
 *
\**************************************************************************/

#if 0
WINGDIAPI int WINAPI GetTextCharsetInfo(
    HDC hdc,
    LPFONTSIGNATURE lpSig,
    DWORD dwFlags)
{
    return NtGdiGetTextCharsetInfo(hdc, lpSig, dwFlags);
}
#endif

WINGDIAPI int WINAPI GetTextCharset(
    HDC hdc)
{
    return NtGdiGetTextCharsetInfo(hdc, NULL, 0);
}



/******************************Public*Routine******************************\
*
* WINGDIAPI  BOOL WINAPI TranslateCharsetInfo(
*
* client side stub
*
* History:
*  06-Jan-1995 -by- Bodin Dresevic [BodinD]
* Wrote it
\**************************************************************************/

// the definition of this variable is in ntgdi\inc\hmgshare.h

CHARSET_ARRAYS



WINGDIAPI  BOOL WINAPI TranslateCharsetInfo(
    DWORD  *lpSrc,
    LPCHARSETINFO lpCs,
    DWORD dwFlags)
{
    UINT    i;
    int     index;
    CHARSETINFO cs;
    BOOL    bRet = 0;

    if (!lpCs)
        return 0;

//
// zero these out, we dont support them here.
//

    cs.fs.fsUsb[0] =
    cs.fs.fsUsb[1] =
    cs.fs.fsUsb[2] =
    cs.fs.fsUsb[3] =
    cs.fs.fsCsb[1] = 0;

    switch (dwFlags )
    {
    case TCI_SRCCHARSET :
        {
            WORD    src ;

            src = LOWORD(PtrToUlong(lpSrc));
            for ( i=0; i<NCHARSETS; i++ )
            {
                if ( charsets[i] == src )
                {
                    cs.ciACP      = codepages[i];
                    cs.ciCharset  = src;
                    cs.fs.fsCsb[0] = fs[i];
                    bRet = 1;
                    break;
                }
            }
        }
        break;

    case TCI_SRCCODEPAGE :
        {
            WORD    src ;

            src = LOWORD(PtrToUlong(lpSrc));

            for ( i=0; i<NCHARSETS; i++ )
            {
                if ( codepages[i] == src )
                {
                    cs.ciACP      = src ;
                    cs.ciCharset  = charsets[i] ;
                    cs.fs.fsCsb[0] = fs[i];
                    bRet = 1;
                    break;
                }
            }
        }
        break;

    case TCI_SRCLOCALE :
        {
        // should only come from USER.  It's used to find the charset of a
        // keyboard layout, and the fonts that it can be used with (fontsigs).
        // It is also used to obtain the fontsignature of the system font.
        // Used in WM_INPUTLANGCHANGE message, and to determine wParam low-bit
        // in WM_INPUTLANGCHANGEREQUEST message.

            LOCALESIGNATURE ls;
            int iRet;

            iRet = GetLocaleInfoW((DWORD)(LOWORD(PtrToUlong(lpSrc))),
                               LOCALE_FONTSIGNATURE,
                               (LPWSTR)&ls,
                               0);

            if (GetLocaleInfoW((DWORD)(LOWORD(PtrToUlong(lpSrc))),
                               LOCALE_FONTSIGNATURE,
                               (LPWSTR)&ls,
                               iRet)
            )
            {
                for ( i=0; i<NCHARSETS; i++ )
                {
                    if (fs[i] == ls.lsCsbDefault[0])
                    {
                        cs.ciACP       = codepages[i];
                        cs.ciCharset   = charsets[i] ;
                        cs.fs.fsCsb[0] = fs[i];                // a single fontsig
                        cs.fs.fsCsb[1] = ls.lsCsbSupported[0]; // mask of fontsigs
                        bRet = 1;
                        break;
                    }
                }
            }
        }
        break;

    case TCI_SRCFONTSIG :
        {
        DWORD src;

        //if(IsBadReadPtr(lpSrc, 8))
        //        return 0;
            try
            {
                if (!(*(lpSrc+1)))
                {
                // we dont recognise ANY of the OEM code pages here!

                    src = *lpSrc;

                    for ( i=0; i<NCHARSETS; i++ )
                    {
                        if ( fs[i] == src )
                        {
                            cs.ciACP      = codepages[i];
                            cs.ciCharset  = charsets[i] ;
                            cs.fs.fsCsb[0] = src;
                            bRet = 1;
                            break;
                        }
                    }
                }
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
            }
        }
        break;

    default:
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        break;
    }

    if (bRet)
    {
        try
        {
            *lpCs = cs; // copy out
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
        }
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\pal.c ===
/******************************Module*Header*******************************\
* Module Name: pal.c                                                       *
*                                                                          *
* C/S support for palette routines.                                        *
*                                                                          *
* Created: 29-May-1991 14:24:06                                            *
* Author: Eric Kutter [erick]                                              *
*                                                                          *
* Copyright (c) 1991-1999 Microsoft Corporation                            *
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop


/**************************************************************************\
 * gajFakeHalftone
 *
 * Copy of the pal666 hardcoded halftone palette from Win9x source code
 * (win\core\gdi\palette.asm).  Actually, we're hacking a little so
 * we'll only use the top and bottom 10 entries.
 *
\**************************************************************************/

static const ULONG gaulFakeHalftone[] = {
    0x00000000,   // 0 Sys Black      gray 0
    0x00000080,   // 1 Sys Dk Red
    0x00008000,   // 2 Sys Dk Green
    0x00008080,   // 3 Sys Dk Yellow
    0x00800000,   // 4 Sys Dk Blue
    0x00800080,   // 5 Sys Dk Violet
    0x00808000,   // 6 Sys Dk Cyan
    0x00c0c0c0,   // 7 Sys Lt Grey    gray 192
    0x00c0dcc0,   // 8 Sys 8
    0x00f0caa6,   // 9 Sys 9 (the first 10 are fixed by Windows)

    0x00f0fbff,   // 246 Sys Reserved
    0x00a4a0a0,   // 247 Sys Reserved
    0x00808080,   // 248 Sys Lt Gray  gray 128
    0x000000ff,   // 249 Sys Red
    0x0000ff00,   // 250 Sys Green
    0x0000ffff,   // 251 Sys Yellow
    0x00ff0000,   // 252 Sys Blue
    0x00ff00ff,   // 253 Sys Violet
    0x00ffff00,   // 254 Sys Cyan
    0x00ffffff    // 255 Sys White     gray 255
};

/******************************Public*Routine******************************\
* AnimatePalette                                                           *
* SetPaletteEntries                                                        *
* GetPaletteEntries                                                        *
* GetSystemPaletteEntries                                                  *
* SetDIBColorTable                                                         *
* GetDIBColorTable                                                         *
*                                                                          *
* These entry points just pass the call on to DoPalette.                   *
*                                                                          *
* Warning:                                                                 *
*   The pv field of a palette's LHE is used to determine if a palette      *
*   has been modified since it was last realized.  SetPaletteEntries       *
*   and ResizePalette will increment this field after they have            *
*   modified the palette.  It is only updated for metafiled palettes       *
*                                                                          *
*                                                                          *
* History:                                                                 *
*  Thu 20-Jun-1991 00:46:15 -by- Charles Whitmer [chuckwh]                 *
* Added handle translation.  (And filled in the comment block.)            *
*                                                                          *
*  29-May-1991 -by- Eric Kutter [erick]                                    *
* Wrote it.                                                                *
\**************************************************************************/

BOOL WINAPI AnimatePalette
(
    HPALETTE hpal,
    UINT iStart,
    UINT cEntries,
    CONST PALETTEENTRY *pPalEntries
)
{
    FIXUP_HANDLE(hpal);

// Inform the 16-bit metafile if it knows this object.
// This is not recorded by the 32-bit metafiles.

    if (pmetalink16Get(hpal))
        if (!MF16_AnimatePalette(hpal, iStart, cEntries, pPalEntries))
            return(FALSE);

    return
      !!NtGdiDoPalette
        (
          hpal,
          (WORD)iStart,
          (WORD)cEntries,
          (PALETTEENTRY*)pPalEntries,
          I_ANIMATEPALETTE,
          TRUE
        );

}

UINT WINAPI SetPaletteEntries
(
    HPALETTE hpal,
    UINT iStart,
    UINT cEntries,
    CONST PALETTEENTRY *pPalEntries
)
{
    PMETALINK16 pml16;

    FIXUP_HANDLE(hpal);

    // Inform the metafile if it knows this object.

    if (pml16 = pmetalink16Get(hpal))
    {
        if (!MF_SetPaletteEntries(hpal, iStart, cEntries, pPalEntries))
            return(0);

        // Mark the palette as changed (for 16-bit metafile tracking)

        pml16->pv = (PVOID)(((ULONG_PTR)pml16->pv)++);
    }

    return
      NtGdiDoPalette
      (
        hpal,
        (WORD)iStart,
        (WORD)cEntries,
        (PALETTEENTRY*)pPalEntries,
        I_SETPALETTEENTRIES,
        TRUE
      );

}

UINT WINAPI GetPaletteEntries
(
    HPALETTE hpal,
    UINT iStart,
    UINT cEntries,
    LPPALETTEENTRY pPalEntries
)
{
    FIXUP_HANDLE(hpal);

    return
      NtGdiDoPalette
      (
        hpal,
        (WORD)iStart,
        (WORD)cEntries,
        pPalEntries,
        I_GETPALETTEENTRIES,
        FALSE
      );

}

UINT WINAPI GetSystemPaletteEntries
(
    HDC  hdc,
    UINT iStart,
    UINT cEntries,
    LPPALETTEENTRY pPalEntries
)
{
    LONG lRet = 0;

    FIXUP_HANDLE(hdc);

    //
    // There's an app out there that sometimes calls us with a -1
    // and then whines that we overwrote some of its memory.  Win9x clamps
    // this value, so we can too.
    //

    if ((LONG)cEntries < 0)
        return (UINT) lRet;

    //
    // GreGetSystemPaletteEntries will only succeed on palettized devices.
    //

    if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
    {
        lRet =
          NtGdiDoPalette
          (
            (HPALETTE) hdc,
            (WORD)iStart,
            (WORD)cEntries,
            pPalEntries,
            I_GETSYSTEMPALETTEENTRIES,
            FALSE
          );
    }
    else
    {
        //
        // Win9x compatibility: Unlike NT, GetSystemPaletteEntries does
        // not fail on non-palettized devices, it returns the halftone
        // palette (hardcoded in win\core\gdi\palette.asm in the
        // Win9x source code).
        //
        // However, Macromedia Directory (which is used by Encarta 99)
        // relies on GetSystemPaletteEntries failing on NT.  Luckily, the
        // only apps found so far that rely on GetSystemPaletteEntries
        // returning the halftone palette on non-palettized devices
        // also ignore the return value.  This makes sense in that any
        // app that *did* check the return value also would likely have
        // code to handle the failure in the first place.
        //
        // So, attemp to satisfy both camps by filling in the return
        // buffer *and* returning failure for this case.
        //

        if (pPalEntries != NULL)
        {
            ULONG aulFake[256];
            UINT uiNumCopy;

            //
            // More cheating: to avoid having to have the whole fake
            // halftone palette taking up space in our binary (even if
            // it is const data), we can get away with just returning
            // the first and last 10 since the apps that use this on
            // non-palettized displays really just want the 20 system
            // colors and will fill in the middle 236 with their own data.
            //
            // Also, it's less code to waste 40 bytes in const data than
            // to fetch the default palette and split it into into the top
            // and bottom halves (not to mention that we don't want the
            // real magic colors in 8, 9, 246, and 247).  This is also
            // the same motivation for creating the aulFake array then
            // copying it into the return buffer.  Not worth the extra code
            // to handle copying directly into return buffer.
            //

            RtlCopyMemory(&aulFake[0], &gaulFakeHalftone[0], 10*sizeof(ULONG));
            RtlCopyMemory(&aulFake[246], &gaulFakeHalftone[10], 10*sizeof(ULONG));
            RtlZeroMemory(&aulFake[10], 236*sizeof(ULONG));

            //
            // Copy requested portion of palette.
            //

            if (iStart < 256)
            {
                uiNumCopy = min((256 - iStart), cEntries);
                RtlCopyMemory(pPalEntries, &aulFake[iStart],
                              uiNumCopy * sizeof(ULONG));
            }

            //
            // Want to return failure, so *do not* set lRet to non-zero.
            //
        }
    }

    return (UINT) lRet;
}

/******************************Public*Routine******************************\
* GetDIBColorTable
*
* Get the color table of the DIB section currently selected into the
* given hdc.  If the surface is not a DIB section, this function
* will fail.
*
* History:
*
*  03-Sep-1993 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

UINT WINAPI GetDIBColorTable
(
    HDC  hdc,
    UINT iStart,
    UINT cEntries,
    RGBQUAD *prgbq
)
{
    FIXUP_HANDLE(hdc);

    if (cEntries == 0)
        return(0);

    return
      NtGdiDoPalette
      (
        (HPALETTE) hdc,
        (WORD)iStart,
        (WORD)cEntries,
        (PALETTEENTRY *)prgbq,
        I_GETDIBCOLORTABLE,
        FALSE
      );
}

/******************************Public*Routine******************************\
* SetDIBColorTable
*
* Set the color table of the DIB section currently selected into the
* given hdc.  If the surface is not a DIB section, this function
* will fail.
*
* History:
*
*  03-Sep-1993 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

UINT WINAPI SetDIBColorTable
(
    HDC  hdc,
    UINT iStart,
    UINT cEntries,
    CONST RGBQUAD *prgbq
)
{
    FIXUP_HANDLE(hdc);

    if (cEntries == 0)
        return(0);

    return( NtGdiDoPalette(
                (HPALETTE) hdc,
                (WORD)iStart,
                (WORD)cEntries,
                (PALETTEENTRY *)prgbq,
                I_SETDIBCOLORTABLE,
                TRUE));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\pixelfmt.c ===
/******************************Module*Header*******************************\
* Module Name: pixelfmt.c
*
* Client side stubs for pixel format functions.
*
* Created: 17-Sep-1993
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1993-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

static char szOpenGL[] = "OPENGL32";

typedef int  (WINAPI *PFN1)(HDC, CONST PIXELFORMATDESCRIPTOR *);
typedef int  (WINAPI *PFN2)(HDC, int, UINT, LPPIXELFORMATDESCRIPTOR);
typedef int  (WINAPI *PFN3)(HDC);
typedef BOOL (WINAPI *PFN4)(HDC, int, CONST PIXELFORMATDESCRIPTOR *);
typedef BOOL (WINAPI *PFN5)(HDC);

BOOL gbSetPixelFormatCalled = FALSE;

// In these routines the assumption is that OpenGL is already loaded
// For that case, the LoadLibrary/FreeLibrary calls will simply
// increment and decrement the reference count of the DLL, so they
// won't be too expensive
//
// In the case where OpenGL is not loaded the DLL will be brought in
// for the duration of the call only

/***********************************************************************/

__inline FARPROC GetAPI(char *szDll, char *szAPI, HMODULE *phDll)
{
    *phDll = LoadLibraryA(szDll);

    if (*phDll == NULL)
    {
        return NULL;
    }

    return GetProcAddress(*phDll, szAPI);
}

/***********************************************************************/

int WINAPI ChoosePixelFormat(HDC hdc, CONST PIXELFORMATDESCRIPTOR *ppfd)
{
    HMODULE hDll;
    PFN1    pfn = (PFN1)GetAPI(szOpenGL, "wglChoosePixelFormat", &hDll);
    int     ipfd = 0;

    if (pfn)
    {
        ipfd = (*pfn)(hdc, ppfd);
    }

    if (hDll)
    {
        FreeLibrary(hDll);
    }
        
    return ipfd;
}

/***********************************************************************/

int WINAPI DescribePixelFormat(HDC hdc, int iPixelFormat, UINT nBytes,
                               LPPIXELFORMATDESCRIPTOR ppfd)
{
    HMODULE hDll;
    PFN2    pfn = (PFN2)GetAPI(szOpenGL, "wglDescribePixelFormat", &hDll);
    int     ipfd = 0;

    if (pfn)
    {
        ipfd = (*pfn)(hdc, iPixelFormat, nBytes, ppfd);
    }

    if (hDll)
    {
        FreeLibrary(hDll);
    }
        
    return ipfd;
}

/***********************************************************************/

int WINAPI GetPixelFormat(HDC hdc)
{
    int     ipfd = 0;

    if (gbSetPixelFormatCalled)
    {
        HMODULE hDll;
        PFN3    pfn = (PFN3)GetAPI(szOpenGL, "wglGetPixelFormat", &hDll);

        if (pfn)
        {
            ipfd = (*pfn)(hdc);
        }

        if (hDll)
        {
            FreeLibrary(hDll);
        }
    }

    return ipfd;
}

/***********************************************************************/

BOOL WINAPI SetPixelFormat(HDC hdc, int iPixelFormat,
                           CONST PIXELFORMATDESCRIPTOR *ppfd)
{
    HMODULE hDll;
    PFN4    pfn = (PFN4)GetAPI(szOpenGL, "wglSetPixelFormat", &hDll);
    BOOL    bRet = FALSE;

    gbSetPixelFormatCalled = TRUE;

    if (pfn)
    {
        bRet = (*pfn)(hdc, iPixelFormat, ppfd);

        // Metafile if necessary
        if (bRet)
        {
            if (IS_ALTDC_TYPE(hdc) && !IS_METADC16_TYPE(hdc))
            {
                PLDC pldc;

                DC_PLDC(hdc, pldc, FALSE);

                if (pldc->iType == LO_METADC)
                {
                    if (!MF_SetPixelFormat(hdc, iPixelFormat, ppfd))
                    {
                        bRet = FALSE;
                    }
                }
            }
        }
    }

    if (hDll)
    {
        FreeLibrary(hDll);
    }

    return bRet;
}

/***********************************************************************/

BOOL WINAPI SwapBuffers(HDC hdc)
{
    HMODULE hDll;
    PFN5    pfn = (PFN5)GetAPI(szOpenGL, "wglSwapBuffers", &hDll);
    BOOL    bRet = FALSE;

    if (pfn)
    {
        bRet = (*pfn)(hdc);
    }
    
    if (hDll)
    {
        FreeLibrary(hDll);
    }
        
    return bRet;
}

/***********************************************************************/

// These stubs are for the cases where OpenGL cannot handle the pixel
// format request itself because it involves device-specific information
// In that case OpenGL asks GDI to go ask the display driver in kernel
// mode

int APIENTRY GdiDescribePixelFormat(HDC hdc, int iPixelFormat, UINT nBytes,
                                    LPPIXELFORMATDESCRIPTOR ppfd)
{
    return NtGdiDescribePixelFormat(hdc, iPixelFormat, nBytes, ppfd);
}

BOOL APIENTRY GdiSetPixelFormat(HDC hdc, int iPixelFormat)
{
    return NtGdiSetPixelFormat(hdc, iPixelFormat);
}

BOOL APIENTRY GdiSwapBuffers(HDC hdc)
{
    return NtGdiSwapBuffers(hdc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\precomp.h ===
/******************************Module*Header*******************************\
* Module Name: precomp.h                                                   *
*                                                                          *
* Copyright (c) 1991-1999 Microsoft Corporation                            *
\**************************************************************************/

#if defined(_GDIPLUS_)
    #include <gpprefix.h>
#endif    

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <windows.h>
#include <winspool.h>
#include <limits.h>
#include <string.h>
#include <nlsconv.h>
#include <w32gdip.h>
#include <icmpriv.h>

#include "ddrawp.h"
#include "winddi.h"

#include "firewall.h"
#include "ntgdistr.h"
#include "ntgdi.h"

// TMP
#include "xfflags.h"
#include "hmgshare.h"

#include "local.h"
#include "gdiicm.h"
#include "metarec.h"
#include "mfrec16.h"
#include "metadef.h"

#include "font.h"

#include "winfont.h"
#include "..\inc\mapfile.h"

#if defined(_GDIPLUS_)
    #include "usermode.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\proxyport.h ===
#ifndef __PROXYPORT__
#define __PROXYPORT__

typedef KPBYTE SERVERPTR;
typedef KPBYTE CLIENTPTR;

typedef struct _PROXYMSG {
    PORT_MESSAGE    h;
    ULONG           cjIn;
    SERVERPTR       pvIn;
    ULONG           cjOut;
    SERVERPTR       pvOut;
} PROXYMSG, *PPROXYMSG;

typedef struct
{
    UMPDTHDR            umpdthdr;
    KERNEL_PVOID        umpdCookie;
    DWORD               clientPid;
    DWORD               hPrinter32;
} UMPDSIMPLEINPUT, *PUMPDSIMPLEINPUT;

//
// XXXX_UMPD must match the definition in winspool.h.
// The only difference is the pointers are widened.
//
typedef struct _DRIVER_INFO_5W_UMPD {
    DWORD cVersion;
    KLPWSTR pName;
    KLPWSTR pEnvironment;
    KLPWSTR pDriverPath;
    KLPWSTR pDataFile;
    KLPWSTR pConfigFile;
    DWORD   dwDriverAttributes;
    DWORD   dwConfigVersion;
    DWORD   dwDriverVersion;
} DRIVER_INFO_5W_UMPD, *PDRIVER_INFO_5W_UMPD, *LPDRIVER_INFO_5W_UMPD;

typedef struct
{
    KLPWSTR         pDatatype;
    KPBYTE          pDevMode;
    ACCESS_MASK     DesiredAccess;
} PRINTERDEFSW_UMPD, *PPRINTERDEFSW_UMPD;

typedef struct
{
    UMPDTHDR                    umpdthdr;
    DRIVER_INFO_5W_UMPD         driverInfo;
    KLPWSTR                     pPrinterName;
    PRINTERDEFSW_UMPD           defaults;
    DWORD                       clientPid;
    DWORD                       hPrinter32;
} LOADDRIVERINPUT, *PLOADDRIVERINPUT;

typedef struct
{
    UMPDTHDR            umpdthdr;
    KERNEL_PVOID        umpdCookie;
    DWORD               clientPid;
    DWORD               hPrinter32;
    BOOL                bNotifySpooler;
} UNLOADDRIVERINPUT, *PUNLOADDRIVERINPUT;

typedef struct _DOCEVENT_CREATEDCPRE_UMPD
{
    KPBYTE      pszDriver;
    KPBYTE      pszDevice;
    KPBYTE      pdm;
    BOOL        bIC;
} DOCEVENT_CREATEDCPRE_UMPD, *PDOCEVENT_CREATEDCPRE_UMPD;

typedef struct _DOCEVENT_ESCAPE_UMPD
{
    int         iEscape;
    int         cjInput;
    KPBYTE      pvInData;
} DOCEVENT_ESCAPE_UMPD, *PDOCEVENT_ESCAPE_UMPD;

typedef struct
{
    UMPDTHDR            umpdthdr;
    KERNEL_PVOID        umpdCookie;
    DWORD               clientPid;
    DWORD               hPrinter32;
    KHDC                hdc;
    INT                 iEsc;
    ULONG               cjIn;
    KPBYTE              pvIn;
    ULONG               cjOut;
    KPBYTE              pvOut;
    KPBYTE              pdmCopy;
} DOCUMENTEVENTINPUT, *PDOCUMENTEVENTINPUT;


//
// XXXX_UMPD must match the definition in winspool.h.
// The only difference is the pointers are widened.
//
typedef struct _DOC_INFO_3W_UMPD {
    KLPWSTR     pDocName;
    KLPWSTR     pOutputFile;
    KLPWSTR     pDatatype;
    DWORD       dwFlags;
} DOC_INFO_3W_UMPD, *PDOC_INFO_3W_UMPD, *LPDOC_INFO_3W_UMPD;

typedef struct
{
    UMPDTHDR            umpdthdr;
    KERNEL_PVOID        umpdCookie;
    DWORD               clientPid;
    DWORD               hPrinter32;
    DWORD               level;
    DOC_INFO_3W_UMPD    docInfo;
    ULONG               lastError;
} STARTDOCPRINTERWINPUT, *PSTARTDOCPRINTERWINPUT;

//
// XXXX_UMPD must match the definition in wingdi.h.
// The only difference is the pointers are widened.
//
typedef struct _DOCINFOW_UMPD {
    int         cbSize;
    KLPWSTR     lpszDocName;
    KLPWSTR     lpszOutput;
    KLPWSTR     lpszDatatype;
    DWORD       fwType;
} DOCINFOW_UMPD, *LPDOCINFOW_UMPD;

typedef struct
{
    UMPDTHDR        umpdthdr;
    KERNEL_PVOID    umpdCookie;
    DWORD           clientPid;
    DWORD           hPrinter32;
    DOCINFOW_UMPD   docInfo;
    KLPWSTR         lpwstr;
} STARTDOCDLGWINPUT, *PSTARTDOCDLGWINPUT;

//
// XXXX_UMPD must match the definition in winspool.h.
// The only difference is the pointers are widened.
//

typedef struct
{
    UMPDTHDR            umpdthdr;
    KERNEL_PVOID        umpdCookie;
    DWORD               clientPid;
    DWORD               hPrinter32;
    PRINTERDEFSW_UMPD   ptrDef;
} RESETPRINTERWINPUT, *PRESETPRINTERWINPUT;

typedef struct
{
    UMPDTHDR        umpdthdr;
    KERNEL_PVOID    umpdCookie;
    DWORD           clientPid;
    DWORD           hPrinter32;
    DEVMODEW*       pDevMode;
    ULONG           ulQueryMode;
    PVOID           pvProfileData;
    ULONG           cjProfileSize;
    FLONG           flProfileFlag;
    ULONG               lastError;
} QUERYCOLORPROFILEINPUT, *PQUERYCOLORPROFILEINPUT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\print.c ===
/******************************Module*Header*******************************\
* Module Name: print.c
*
* Created: 10-Feb-1995 07:42:16
* Author:  Gerrit van Wingerden [gerritv]
*
* Copyright (c) 1993-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "glsup.h"

#if DBG
int gerritv = 0;
#endif

#if DBG
BOOL gbDownloadFonts = FALSE;
BOOL gbForceUFIMapping = FALSE;
#endif

#if PRINT_TIMER
BOOL bPrintTimer = TRUE;
#endif

#ifdef  DBGSUBSET
//Timing code
FILETIME    startPageTime, midPageTime, endPageTime;
#endif

int StartDocEMF(HDC hdc, CONST DOCINFOW * pDocInfo, BOOL *pbBanding); // output.c

/****************************************************************************
 * int PutDCStateInMetafile( HDC hdcMeta, HDC hdcSrc )
 *
 * Captures state of a DC into a metafile.
 *
 *
 * History
 *
 * Clear the UFI in LDC so we can set the force mapping for the next metafile
 * Feb-07-1997  Xudong Wu   [tessiew]
 *
 * This routine captures the states of a DC into a METAFILE.   This is important
 * because we would like each page of the spooled metafile to be completely self
 * contained.  In order to do this it must complete capture the original state
 * of the DC in which it was recorded.
 *
 *  Gerrit van Wingerden [gerritv]
 *
 *  11-7-94 10:00:00
 *
 *****************************************************************************/

BOOL PutDCStateInMetafile( HDC hdcMeta )
{
    PLDC pldc;
    POINT ptlPos;
    ULONG ul;

//    DC_PLDC(hdcMeta,pldc,0);

    pldc = GET_PLDC(hdcMeta);

    if (!pldc)
        return FALSE;

    MFD1("Selecting pen into mf\n");
    SelectObject( hdcMeta, (HGDIOBJ) GetDCObject(hdcMeta, LO_PEN_TYPE) );

    MFD1("Selecting brush into mf\n");
    SelectObject( hdcMeta, (HGDIOBJ) GetDCObject(hdcMeta, LO_BRUSH_TYPE) );

    UFI_CLEAR_ID(&pldc->ufi);

    MFD1("Selecting logfont into mf\n");
    SelectObject( hdcMeta, (HGDIOBJ) GetDCObject(hdcMeta, LO_FONT_TYPE) );

    // DON'T TRY THIS AT HOME.  We need to record the current state of the
    // dc in the metafile.  We have optimizations however, that keep us from
    // setting the same attribute if it was just set.

    if( GetBkColor( hdcMeta ) != 0xffffff )
    {
        MFD1("Changing backround color in mf\n");
        SetBkColor( hdcMeta, GetBkColor( hdcMeta ) );
    }

    if( GetTextColor( hdcMeta ) != 0 )
    {
        MFD1("Changing text color in mf\n");
        SetTextColor( hdcMeta, GetTextColor( hdcMeta ) );
    }

    if( GetBkMode( hdcMeta ) != OPAQUE )
    {
        MFD1("Changing Background Mode in mf\n");
        SetBkMode( hdcMeta, GetBkMode( hdcMeta ) );
    }

    if( GetPolyFillMode( hdcMeta ) != ALTERNATE )
    {
        MFD1("Changing PolyFill mode in mf\n");
        SetPolyFillMode( hdcMeta, GetPolyFillMode( hdcMeta ) );
    }

    if( GetROP2( hdcMeta ) != R2_COPYPEN )
    {
        MFD1("Changing ROP2 in mf\n");
        SetROP2( hdcMeta, GetROP2( hdcMeta ) );
    }

    if( GetStretchBltMode( hdcMeta ) != BLACKONWHITE )
    {
        MFD1("Changing StrechBltMode in mf\n");
        SetStretchBltMode( hdcMeta, GetStretchBltMode( hdcMeta ) );
    }

    if( GetTextAlign( hdcMeta ) != 0 )
    {
        MFD1("Changing TextAlign in mf\n");
        SetTextAlign( hdcMeta, GetTextAlign( hdcMeta ) );
    }

    if( ( GetBreakExtra( hdcMeta ) != 0 )|| ( GetcBreak( hdcMeta ) != 0 ) )
    {
        MFD1("Setting Text Justification in mf\n");
        SetTextJustification( hdcMeta, GetBreakExtra( hdcMeta ), GetcBreak( hdcMeta ) );
    }

    if( GetMapMode( hdcMeta ) != MM_TEXT )
    {
        INT iMapMode = GetMapMode( hdcMeta );
        POINT ptlWindowOrg, ptlViewportOrg;
        SIZEL WndExt, ViewExt;

        // get these before we set the map mode to MM_TEXT

        GetViewportExtEx( hdcMeta, &ViewExt );
        GetWindowExtEx( hdcMeta, &WndExt );

        GetWindowOrgEx( hdcMeta, &ptlWindowOrg );
        GetViewportOrgEx( hdcMeta, &ptlViewportOrg );

        // set it to MM_TEXT so it doesn't get optimized out

        SetMapMode(hdcMeta,MM_TEXT);

        MFD1("Setting ANISOTROPIC or ISOTROPIC mode in mf\n");

        SetMapMode( hdcMeta, iMapMode );

        if( iMapMode == MM_ANISOTROPIC || iMapMode == MM_ISOTROPIC )
        {
            SetWindowExtEx( hdcMeta, WndExt.cx, WndExt.cy, NULL );
            SetViewportExtEx( hdcMeta, ViewExt.cx, ViewExt.cy, NULL );
        }

        SetWindowOrgEx( hdcMeta,
                        ptlWindowOrg.x,
                        ptlWindowOrg.y,
                        NULL );

        SetViewportOrgEx( hdcMeta,
                          ptlViewportOrg.x,
                          ptlViewportOrg.y,
                          NULL );
    }

    if( GetCurrentPositionEx( hdcMeta, &ptlPos ) )
    {
        MFD1("Set CurPos in mf\n");
        MoveToEx( hdcMeta, ptlPos.x, ptlPos.y, NULL );
    }

    if( GetBrushOrgEx( hdcMeta, &ptlPos ) )
    {
        MFD1("Set BrushOrg in mf\n");
        SetBrushOrgEx( hdcMeta, ptlPos.x, ptlPos.y, &ptlPos );
    }

    if( SetICMMode( hdcMeta, ICM_QUERY ) )
    {
        MFD1("Set ICM mode in mf\n");
        SetICMMode( hdcMeta, SetICMMode(hdcMeta,ICM_QUERY) );
    }

    if( GetColorSpace( hdcMeta ) != NULL )
    {
        MFD1("Set ColorSpace in mf\n");
        SetColorSpace( hdcMeta, GetColorSpace(hdcMeta) );
    }

    if(!NtGdiAnyLinkedFonts())
    {
    // tell the machine to turn off linking

        MF_SetLinkedUFIs(hdcMeta, NULL, 0);
    }

    return TRUE;
}

/****************************************************************************
 * int MFP_StartDocW( HDC hdc, CONST DOCINFOW * pDocInfo )
 *
 *  Gerrit van Wingerden [gerritv]
 *
 *  11-7-94 10:00:00
 *
 ****************************************************************************/

//! this needs to be moved to a spooler header file

#define QSM_DOWNLOADFONTS   0x000000001

BOOL MFP_StartDocW( HDC hdc, CONST DOCINFOW * pDocInfo, BOOL bBanding )
{
    BOOL   bRet    = FALSE;
    PWSTR  pstr    = NULL;
    BOOL   bEpsPrinting;
    PLDC   pldc;
    UINT   cjEMFSH;
    FLONG  flSpoolMode;
    HANDLE hSpooler;
    DWORD  dwSessionId = 0;

    EMFSPOOLHEADER *pemfsh = NULL;

    MFD1("Entering StartDocW\n");

    if (!IS_ALTDC_TYPE(hdc))
        return(bRet);

    DC_PLDC(hdc,pldc,bRet);

    //
    // Create a new EMFSpoolData object to use during EMF recording
    //

    if (!AllocEMFSpoolData(pldc, bBanding))
    {
        WARNING("MFP_StartDocW: AllocEMFSpoolData failed\n");
        return bRet;
    }

    if( !bBanding )
    {
        hSpooler = pldc->hSpooler;
        cjEMFSH = sizeof(EMFSPOOLHEADER);

        if( pDocInfo->lpszDocName != NULL )
        {
            cjEMFSH += ( wcslen( pDocInfo->lpszDocName ) + 1 ) * sizeof(WCHAR);
        }

        if( pDocInfo->lpszOutput != NULL )
        {
            cjEMFSH += ( wcslen( pDocInfo->lpszOutput ) + 1 ) * sizeof(WCHAR);
        }

        pemfsh = (EMFSPOOLHEADER*) LocalAlloc( LMEM_FIXED, cjEMFSH );

        if( pemfsh == NULL )
        {
            WARNING("MFP_StartDOCW: out of memory.\n");
            goto FREEPORT;
        }

        pemfsh->cjSize = ROUNDUP_DWORDALIGN(cjEMFSH);

        cjEMFSH = 0;

        if( ( pDocInfo->lpszDocName ) != NULL )
        {
            pemfsh->dpszDocName = sizeof(EMFSPOOLHEADER);
            wcscpy( (WCHAR*) (pemfsh+1), pDocInfo->lpszDocName );
            cjEMFSH += ( wcslen( pDocInfo->lpszDocName ) + 1 ) * sizeof(WCHAR);
        }
        else
        {
            pemfsh->dpszDocName = 0;
        }

        if( pDocInfo->lpszOutput != NULL )
        {
            pemfsh->dpszOutput = sizeof(EMFSPOOLHEADER) + cjEMFSH;
            wcscpy((WCHAR*)(((BYTE*) pemfsh ) + pemfsh->dpszOutput),
                   pDocInfo->lpszOutput);
        }
        else
        {
            pemfsh->dpszOutput = 0;
        }

        ASSERTGDI(ghSpooler,"non null hSpooler with unloaded WINSPOOL\n");

        if( !(*fpQuerySpoolMode)( hSpooler, &flSpoolMode, &(pemfsh->dwVersion)))
        {
            WARNING("MFP_StartDoc: QuerySpoolMode failed\n");
            goto FREEPORT;
        }

        //
        // In the scenario of a TS session or a console session that is non zero,
        // (due to FastUserSwitching) the font is added using AddFontResource to the win32k.sys 
        // of one of the clients and the printing is done with the win32k.sys of the console.
        // Those are separate win32k.sys that have their own data. The win32k.sys of the console
        // cannot access the font that is in the data of a different win32k.sys. In this case 
        // we need to force the font to be embedded in the EMF stream.
        //
        if (!ProcessIdToSessionId(GetCurrentProcessId(), &dwSessionId) || dwSessionId != 0)
        {
            flSpoolMode |= QSM_DOWNLOADFONTS;           
        }

        ASSERTGDI((pemfsh->dwVersion == 0x00010000),
                  "QuerySpoolMode version doesn't equal 1.0\n");

        if( !WriteEMFSpoolData(pldc, pemfsh, pemfsh->cjSize))
        {
            WARNING("MFP_StartDOC: WriteData failed\n");
            goto FREEPORT;
        }
        else
        {
            MFD1("Wrote EMFSPOOLHEADER to the spooler\n");
        }

        //
        // Write PostScript Injection data.
        //
        // ATTENTION: THIS MUST BE RIGHT AFTER EMFSPOOLHEADER RECORD
        //
        if (pldc->dwSizeOfPSDataToRecord)
        {
            BOOL          bError = FALSE;
            EMFITEMHEADER emfi;
            PLIST_ENTRY   p = pldc->PSDataList.Flink;

            // Write the header to spooler.

            emfi.ulID   = EMRI_PS_JOB_DATA;
            emfi.cjSize = pldc->dwSizeOfPSDataToRecord;

            if (!WriteEMFSpoolData(pldc, &emfi, sizeof(emfi)))
            {
                WARNING("MFP_StartPage: Write printer failed for PS_JOB_DATA header\n");
                goto FREEPORT;
            }
            else
            {
                MFD1("Wrote EMRI_PS_JOB_DATA header to the spooler\n");
            }

            // Record EMFITEMPSINJECTIONDATA

            while(p != &(pldc->PSDataList))
            {
                PPS_INJECTION_DATA pPSData;

                // get pointer to this cell.

                pPSData = CONTAINING_RECORD(p,PS_INJECTION_DATA,ListEntry);

                // record this escape to EMF.

                if (!bError && !WriteEMFSpoolData(pldc, &(pPSData->EmfData), pPSData->EmfData.cjSize))
                {
                    WARNING("MFP_StartPage: Write printer failed for PS_JOB_DATA escape data\n");
                    bError = TRUE;
                }

                // get pointer to next cell.

                p = p->Flink;

                // no longer needs this cell.

                LOCALFREE(pPSData);
            }

            // mark as data already freed.

            pldc->dwSizeOfPSDataToRecord = 0;
            InitializeListHead(&(pldc->PSDataList));

            if (bError)
            {
                goto FREEPORT;
            }
        }

#if DBG
        if( gbDownloadFonts )
        {
            flSpoolMode |= QSM_DOWNLOADFONTS;
        }
#endif

        if (flSpoolMode & QSM_DOWNLOADFONTS)
        {
        // Now, QMS_DOWNLOADFONTS bit are on when print on remote print server,
        // then I just use this bit to determine attach ICM profile to metafile
        // or not. - hideyukn [May-08-1997]

            pldc->fl |= LDC_DOWNLOAD_PROFILES;

        // Configure to download fonts

            pldc->fl |= LDC_DOWNLOAD_FONTS;
            pldc->ppUFIHash = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                          sizeof( PUFIHASH ) * 3 * UFI_HASH_SIZE );

            if( pldc->ppUFIHash == NULL)
            {
                WARNING("MFP_StartDocW: unable to allocate UFI hash tables\n");
                goto FREEPORT;
            }

        // do not want to allocate memory twice

            pldc->ppDVUFIHash = &pldc->ppUFIHash[UFI_HASH_SIZE];
            pldc->ppSubUFIHash = &pldc->ppDVUFIHash[UFI_HASH_SIZE];

            pldc->fl |= LDC_FORCE_MAPPING;
            pldc->ufi.Index = 0xFFFFFFFF;
        }
        else
        {
            ULONG cEmbedFonts;

            pldc->ppUFIHash = pldc->ppDVUFIHash = pldc->ppSubUFIHash = NULL;
            if ((cEmbedFonts = NtGdiGetEmbedFonts()) && cEmbedFonts != 0xFFFFFFFF)
            {
                pldc->fl |= LDC_EMBED_FONTS;
                pldc->ppUFIHash = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(PUFIHASH) * UFI_HASH_SIZE);

                if (pldc->ppUFIHash == NULL)
                {
                    WARNING("MFP_StartDocW: unable to allocate UFI has table for embed fonts\n");
                    goto FREEPORT;
                }
            }
        }

#if DBG
        // If gbDownloadFonts is set then force all fonts to be downloaded.  Even
        // ones on the remote machine.

        if( (flSpoolMode & QSM_DOWNLOADFONTS) && !gbDownloadFonts )
#else
        if( flSpoolMode & QSM_DOWNLOADFONTS )
#endif
        {
        // query the spooler to get the list of fonts is has available

            INT nBufferSize = 0;
            PUNIVERSAL_FONT_ID pufi;

            nBufferSize = (*fpQueryRemoteFonts)( pldc->hSpooler, NULL, 0 );

            if( nBufferSize != -1 )
            {
                pufi = LocalAlloc( LMEM_FIXED, sizeof(UNIVERSAL_FONT_ID) * nBufferSize );

                if( pufi )
                {
                    INT nNewBufferSize = (*fpQueryRemoteFonts)( pldc->hSpooler,
                                                                pufi,
                                                                nBufferSize );

                    //
                    // This fixes bug 420136. We have three cases according to the result
                    // of QueryRemoteFonts. If it returns -1, nBufferSize will be set to
                    // -1 in the if statement. If nNewBufferSize is larger than what we
                    // allocated, then we use the buffer that we allocated (nBufferSize) 
                    // If nNewBufferSize is less than what we allocated, then we set
                    // nBufferSize to a lower value then the one previously held. This means
                    // we access only a part of the buffer we allocated.
                    //
                    if (nNewBufferSize < nBufferSize) 
                    {
                        nBufferSize = nNewBufferSize;
                    }

                    MFD2("Found %d fonts\n", nBufferSize );
    
                    if (nBufferSize > 0)
                    {
                        // next add all these fonts to UFI has table so we don't
                        //include them in the spool file.
    
                        while( nBufferSize-- )
                        {
                            pufihAddUFIEntry(pldc->ppUFIHash, &pufi[nBufferSize], 0, 0, 0);
                            MFD2("%x\n", pufi[nBufferSize].CheckSum );
                        }
                    }
                    LocalFree( pufi );
                }
            }
            else
            {
                WARNING("QueryRemoteFonts failed.  We will be including all fonts in \
                         the EMF spoolfile\n");
            }
        }

#if DBG
        if( gbForceUFIMapping )
        {
            pldc->fl |= LDC_FORCE_MAPPING;
        }
#endif

    }

    // we now need to create an EMF DC for this document

    if (!AssociateEnhMetaFile(hdc))
    {
        WARNING("Failed to create spool metafile");
        goto FREEPORT;
    }

    if (bBanding)
    {
        pldc->fl |= LDC_BANDING;
        
        // remove the LDC_PRINT_DIRECT which
        // was set in StartDocW before NtGdiStartDoc call.

        pldc->fl &= ~LDC_PRINT_DIRECT;
    }

    // set the data for this lhe to that of the meta file

    pldc->fl |= (LDC_DOC_STARTED|LDC_META_PRINT|LDC_CALL_STARTPAGE|LDC_FONT_CHANGE);

    // clear color page flag

    CLEAR_COLOR_PAGE(pldc);

    if (pldc->pfnAbort != NULL)
    {
        pldc->fl |= LDC_SAP_CALLBACK;
        pldc->ulLastCallBack = GetTickCount();
    }

    bRet = TRUE;

FREEPORT:

    if( pemfsh != NULL )
    {
        LOCALFREE(pemfsh);
    }

    return(bRet);
}

/****************************************************************************
 * int WINAPI MFP_EndDoc(HDC hdc)
 *
 * Gerrit van Wingerden [gerritv]
 *
 * 11-7-94 10:00:00
 *
 *****************************************************************************/

int WINAPI MFP_EndDoc(HDC hdc)
{
    int            iRet = 1;
    PLDC           pldc;
    HENHMETAFILE   hmeta;

    if (!IS_ALTDC_TYPE(hdc))
        return(iRet);

    DC_PLDC(hdc,pldc,0);

    MFD1("MFP_EndDoc\n");

    if ((pldc->fl & LDC_DOC_STARTED) == 0)
        return(1);

    if (pldc->fl & LDC_PAGE_STARTED)
    {
        MFP_EndPage(hdc);
    }

    ASSERTGDI(pldc->fl & LDC_META_PRINT,
              "DetachPrintMetafile not called on metafile D.C.\n" );

// completely detach the metafile from the original printer DC

    hmeta = UnassociateEnhMetaFile( hdc, FALSE );
    DeleteEnhMetaFile( hmeta );

    DeleteEMFSpoolData(pldc);

// Clear the LDC_SAP_CALLBACK flag.
// Also clear the META_PRINT and DOC_STARTED flags

    pldc->fl &= ~(LDC_SAP_CALLBACK | LDC_META_PRINT);

    RESETUSERPOLLCOUNT();

    MFD1("Caling spooler to end doc\n");

    if( pldc->fl & LDC_BANDING )
    {
        pldc->fl &= ~LDC_BANDING;
        EndDoc( hdc );
    }
    else
    {
        pldc->fl &= ~LDC_DOC_STARTED;
        (*fpEndDocPrinter)(pldc->hSpooler);
    }

#if PRINT_TIMER
    if( bPrintTimer )
    {
        DWORD tc;

        tc = GetTickCount();

        DbgPrint("Document took %d.%d seconds to spool\n",
                 (tc - pldc->msStartDoc) / 1000,
                 (tc - pldc->msStartDoc) % 1000 );

    }
#endif

    return(iRet);
}

/****************************************************************************
 * int WINAPI MFP_StartPage(HDC hdc)
 *
 * Gerrit van Wingerden [gerritv]
 *
 * 11-7-94 10:00:00
 *
 *****************************************************************************/

int MFP_StartPage( HDC hdc )
{
    PLDC     pldc;
    int iRet = 1;

//Timing code
#ifdef  DBGSUBSET
    if (gflSubset & FL_SS_PAGETIME)
    {
        GetSystemTimeAsFileTime(&startPageTime);
    }
#endif

    if (!IS_ALTDC_TYPE(hdc))
        return(0);

    DC_PLDC(hdc,pldc,0);

    MFD1("Entering MFP_StartPage\n");

    pldc->fl &= ~LDC_CALL_STARTPAGE;
    pldc->fl &= ~LDC_CALLED_ENDPAGE;

    pldc->fl &= ~LDC_META_ARCDIR_CLOCKWISE;

// Do nothing if page has already been started.

    if (pldc->fl & LDC_PAGE_STARTED)
        return(1);

    pldc->fl |= LDC_PAGE_STARTED;

    RESETUSERPOLLCOUNT();

    if( pldc->fl & LDC_BANDING )
    {
        iRet = SP_ERROR;

        // ATTENTION: maybe we can delay the call here and do it right before we start
        // banding.

        MakeInfoDC( hdc, FALSE );

        iRet = NtGdiStartPage(hdc);

        MakeInfoDC( hdc, TRUE );
    }
    else
    {
        ULONG               ulCopyCount;
        EMFITEMHEADER       emfi;
        EMFITEMPRESTARTPAGE emfiPre;

    // If application calls Escape(SETCOPYCOUNT), we will over-write copy count in
    // devmode and save it into metafile.

        NtGdiGetAndSetDCDword(
            hdc,
            GASDDW_COPYCOUNT,
            (DWORD) -1,
            &ulCopyCount);

        if (ulCopyCount != (ULONG) -1)
        {
            if (pldc->pDevMode)
            {
            // Set copy count into devmode.
            // No driver call happen here, since this is EMF spooling...

                pldc->pDevMode->dmFields |= DM_COPIES;
                pldc->pDevMode->dmCopies = (short) ulCopyCount;

            // Fill up EMF record for devmode.

                emfi.ulID = EMRI_DEVMODE;
                emfi.cjSize = pldc->pDevMode->dmSize + pldc->pDevMode->dmDriverExtra;

            // Force devmode data to be DWORD aligned

                emfi.cjSize = ROUNDUP_DWORDALIGN(emfi.cjSize);

                if (!WriteEMFSpoolData(pldc, &emfi, sizeof(emfi)) ||
                    !WriteEMFSpoolData(pldc, pldc->pDevMode, emfi.cjSize))
                {
                    WARNING("MFP_StartPage: Write printer failed for DEVMODE\n");
                    return(SP_ERROR);
                }
            }
        }

    // before the start page, we need to see if the EPS mode has
    // changed since the start doc.

        NtGdiGetAndSetDCDword(
            hdc,
            GASDDW_EPSPRINTESCCALLED,
            (DWORD) FALSE,
            &emfiPre.bEPS);

        if (emfiPre.bEPS)
        {
            int i;
            EMFITEMHEADER emfiHeader;

            // make sure it is true or false

            emfiPre.bEPS = !!emfiPre.bEPS;

            // This was ulCopyCount.
            // Just set -1 for keep compatibility. -1 means "up to devmode".

            emfiPre.ulUnused = -1;

            // is there anything we will need to do?  If so record the record

            emfiHeader.ulID   = EMRI_PRESTARTPAGE;
            emfiHeader.cjSize = sizeof(emfiPre);

            if (!WriteEMFSpoolData(pldc, &emfiHeader, sizeof(emfiHeader)) ||
                !WriteEMFSpoolData(pldc, &emfiPre, sizeof(emfiPre)))
            {
                WARNING("MFP_StartPage: Write printer failed for PRESTARTPAGE\n");
                return(SP_ERROR);
            }
        }

    // Metafile the start page call.  Now all the play journal code has to do is
    // play back the metafile and the StartPage call will happen automatically
    // at the right place in the metafile.

        if( !(*fpStartPagePrinter)( pldc->hSpooler ) )
        {
            WARNING("MFP_StarPage: StartPagePrinter failed\n");
            return(SP_ERROR);
        }
    }

    return(iRet);
}

/****************************************************************************
 * BOOL StartBanding( HDC hdc, POINTL *pptl )
 *
 * Tells the printer driver to get ready for banding and asks for the origin
 * of the first band.
 *
 *
 * Gerrit van Wingerden [gerritv]
 *
 * 1-7-95 10:00:00
 *
 *****************************************************************************/

BOOL StartBanding( HDC hdc, POINTL *pptl, SIZE *pSize )
{
    return (NtGdiDoBanding(hdc, TRUE, pptl, pSize));
}

/****************************************************************************
 * BOOL NextBand( HDC hdc, POINTL *pptl )
 *
 * Tells the driver to realize the image accumlated in the DC and then
 * asks for the origin of the next band.  If the origin is (-1,-1) the
 * driver is through banding.
 *
 *
 * Gerrit van Wingerden [gerritv]
 *
 * 1-7-95 10:00:00
 *
 *****************************************************************************/

BOOL NextBand( HDC hdc, POINTL *pptl )
{
    BOOL bRet=FALSE;
    SIZE szScratch;

    bRet = NtGdiDoBanding(hdc, FALSE, pptl, &szScratch);

// reset the page started flag if this is the next band

    if( bRet && ( pptl->x == -1 ) )
    {
        PLDC pldc;
        DC_PLDC(hdc,pldc,0);

        pldc->fl &= ~LDC_PAGE_STARTED;
    }

    return(bRet);
}

/****************************************************************************\
 * VOID PrintBand()
 *
 * History:
 *
 *  1-05-97 Hideyuki Nagase [hideyukn]
 * Wrote it.
 *  3-23-98 Ramanathan Venkatapathy [ramanv]
 * Fixed Scaling bugs
 *  6-26-98 Ramanathan Venkatapathy [ramanv]
 * Added pClip to correct the clipping when Xforms are applied on the
 * DC. ANDing Banding region with prect incorrectly clips off regions when
 * prect is yet to be transformed.
 *  8-24-99 Steve Kiraly [steveki]
 * Add code to not play on the DC if there is no intersection with the
 * clipping rectangle and the banding rectangle.  Fix n-up bug when the
 * imageable area of the document is larger that the physical page. The
 * solution consisted of setting up the clipping region to stay within
 * either the banding rectangle or the clipping rectangle.  See bug 377434
 * for more information.
 *
 * An illustration of the problem.
 *
 * We are printing a document that is larger than the imageable area of the page
 * thus it must print on 2 pages and we are printing 2-up with banding enabled
 * because this is a 24 bpp document.
 *
 * The printable region rectagle is (0,0) (2114,3066)
 * Page one has a clipping rectangle of (216,46) (2114,1510)
 * Page two has a clipping rectangle of (216,1601) (2114,3066)
 *
 * GDI will print using 4 bands each 784 high.
 *
 * Band 1 pptl = 0,0        pszlBand = 2400,784
 * Band 2 pptl = 0,784      pszlBand = 2400,784
 * Band 3 pptl = 0,1568     pszlBand = 2400,784
 * Band 4 pptl = 0,2352     pszlBand = 2400,784
 *
 *        0,0
 *
 * 0,0    +-----------------------------------------------------------------+
 *        | 216,46                                                          |
 *        |                                                                 |
 *        |                                                                 |
 * 0,784  |                                                                 |
 *        |                                                                 |
 *        |          [========================================]             |
 *        |          [                                        ]             |
 *        |          [                                        ]             |
 *        |          [                                        ]   2114,1510 |
 *        |-----------------------------------------------------------------|
 *        | 216,1601 [                                        ]             |
 * 0,1568 |          [                                        ]             |
 *        |          [                                        ]             |
 *        |          [                                        ]             |
 * 0,2352 |          [                                        ]             |
 *        |          [                                        ]             |
 *        |          [========================================]             |
 *        |                                                                 |
 *        |                                                       2114,3066 |
 *        +-----------------------------------------------------------------+
 *
 *                                                                  2114,3066
 *
 * Band 1 clipping region is (216,0) (2401,785)
 * Band 2 clipping region is (216,784) (2114,726)
 * Band 3 clipping region is (216,33) (2114,785)
 * Band 4 clipping region is (216,0) (2114,714)
 *
 * Band 2 and 3 are the most interesting cases.  Band 2 the clipping
 * bottom right corner is the size of the clipping rectangle rather than the
 * band size as the code orignally was.  Band 3 on the other hand has the
 * top left corner of the region adjusted to the clipping rectangle.
 *
 ****************************************************************************/

VOID
PrintBand(
    HDC            hdc,
    HENHMETAFILE   hmeta,
    POINTL        *pptl,     // Offsets from top of page for this band.
    RECT          *prect,    // Rectangle for printable reagion of this page.
    SIZEL         *pszlBand, // Size of band.
    RECT          *pClip     // Clipping rectangle, non null when n-up.
)
{
    ULONG       ulRet;
    PERBANDINFO pbi;

    MFD3("gdi32:PrintBand Print offset x,y = %d,%d\n", pptl->x, pptl->y);
    MFD3("gdi32:PrintBand Printable region top = %d, bottom = %d\n", prect->top, prect->bottom);
    MFD3("gdi32:PrintBand Printable region left = %d, right = %d\n", prect->left, prect->right);
    MFD3("gdi32:PrintBand Band size x,y = %d,%d\n",pszlBand->cx, pszlBand->cy);

    do
    {
        RECT rectPage = *prect;
        HRGN hRgnBand = NULL;
        HRGN hRgnCurrent = NULL;
        BOOL bSaveDC = FALSE;
        ULONG ulXRes, ulYRes;
        BOOL  bUsePerBandInfo = FALSE;

        // Updates view origin in specified coords.

        SetViewportOrgEx( hdc, -(pptl->x), -(pptl->y), NULL );

        // Initialize with current resolution.

        ulXRes = (ULONG)  prect->right - prect->left;
        ulYRes = (ULONG)  prect->bottom - prect->top;

        pbi.bRepeatThisBand = FALSE;
        pbi.ulHorzRes = ulXRes;
        pbi.ulVertRes = ulYRes;
        pbi.szlBand.cx = pszlBand->cx;
        pbi.szlBand.cy = pszlBand->cy;

        MFD1("GDI32:PrintBand() querying band information\n");

        // Query band information.

        ulRet = NtGdiGetPerBandInfo(hdc,&pbi);

        if (ulRet != GDI_ERROR)
        {
            SIZEL  szlClip;
            POINTL pptlMove;

            bUsePerBandInfo = (ulRet != 0);

            // If return value is 0, we will draw without scaling.

            if (bUsePerBandInfo &&
                ((ulXRes != pbi.ulHorzRes) ||
                 (ulYRes != pbi.ulVertRes)))
            {
                FLOAT  sx,sy;

                MFD1("GDI PlayEMF band information was specified\n");

                // Compute scaling ratio.

                //
                // This code has rounding errors due to
                // float to long truncation. The correct code
                // should use a LONGLONG to store the numerator and do
                // all of the computation in integer math.
                //
                // See StretchDIBits
                //
                // The fix is coded below in comments because we can't check it
                // in till someone figures out how to break the original version.
                //

                sx = (FLOAT) ulXRes / (FLOAT) pbi.ulHorzRes;
                sy = (FLOAT) ulYRes / (FLOAT) pbi.ulVertRes;

                // Shrink/Stretch drawing frame.

                //rectPage.left = (LONG)  ((LONGLONG)rectPage.left*pbi.ulHorizRes)/ulXRes;
                //rectPage.top  = (LONG) ((LONGLONG)rectPage.top*pbi.ulVertRes)/ulYRes;
                //rectPage.right = (LONG) ((LONGLONG)rectPage.right*pbi.ulHorizRes)/ulXRes;
                //rectPage.bottom  = (LONG) ((LONGLONG)rectPage.bottom*pbi.ulVertRes)/ulYRes;

                rectPage.left = (LONG) ((FLOAT) rectPage.left / sx);
                rectPage.top  = (LONG) ((FLOAT) rectPage.top / sy);
                rectPage.right = (LONG) ((FLOAT) rectPage.right / sx);
                rectPage.bottom  = (LONG) ((FLOAT) rectPage.bottom / sy);

                // Compute view origin.

                //pptlMove.x = (LONG) ((LONGLONG)pptl->x*pbi.ulHorizRes)/ulXRes;
                //pptlMove.y = (LONG) ((LONGLONG)pptl->y*pbi.ulVertRes)/ulYRes;

                pptlMove.x = (LONG) ((FLOAT) pptl->x / sx);
                pptlMove.y = (LONG) ((FLOAT) pptl->y / sy);

                // Updates view origin in specified coords.

                SetViewportOrgEx( hdc, -pptlMove.x, -pptlMove.y, NULL );

                // Set clip region size.


                //szlClip.cx = (ULONG) ((LONGLONG)pbi.szlBand.cx*pbi.ulHorizRes)/ulXRes;
                //szlClip.cy = (ULONG) ((LONGLONG)pbi.szlBand.cy*pbi.ulVertRes)/ulYRes;

                szlClip.cx = (ULONG) ((FLOAT) pbi.szlBand.cx / sx);
                szlClip.cy = (ULONG) ((FLOAT) pbi.szlBand.cy / sy);

                // Create clip region for banding.

                hRgnBand = CreateRectRgn(0,0,szlClip.cx,szlClip.cy);
            }
            else
            {
                SIZEL  szlPage      = {0,0};
                SIZEL  szlAdjust    = {0,0};

                if(!bUsePerBandInfo)
                {
                    // Set back to default values in case driver mucked with them

                    pbi.bRepeatThisBand = FALSE;
                    pbi.ulHorzRes = ulXRes;
                    pbi.ulVertRes = ulYRes;
                    pbi.szlBand.cx = pszlBand->cx;
                    pbi.szlBand.cy = pszlBand->cy;
                }

                pptlMove.x = pptl->x;
                pptlMove.y = pptl->y;

                MFD1("gdi32:PrintBand(): GetPerBandInfo NO SCALING is requested\n");

                // Page size
                if (pClip) {

                    RECT rcBand;
                    RECT rcIntersect;

                    MFD3("gdi32:PrintBand(): Clipping Rectangle top = %d, bottom = %d\n", pClip->top, pClip->bottom);
                    MFD3("gdi32:PrintBand(): Clipping Rectangle left = %d, right = %d\n", pClip->left, pClip->right);

                    rcBand.left     = pptlMove.x;
                    rcBand.top      = pptlMove.y;
                    rcBand.right    = pptlMove.x + pbi.szlBand.cx;
                    rcBand.bottom   = pptlMove.y + pbi.szlBand.cy;

                    //
                    // If the banding rect does not instersect the clip rect
                    // not much to do, just continue.
                    //
                    if (!IntersectRect(&rcIntersect, pClip, &rcBand))
                    {
                        MFD1("gdi32:PrintBand(): No intersection with band rect and pClip\n");
                        continue;
                    }

                    szlPage.cx = pClip->right;
                    szlPage.cy = pClip->bottom;

                    //
                    // The adjust point it neccessary to move the clipping
                    // region's upper or left edge.  The szlClip is used to
                    // move the clipping region's height and width.
                    //
                    if (pClip->left > pptlMove.x)
                    {
                        szlAdjust.cx = pClip->left - pptlMove.x;
                    }

                    if (pClip->top > pptlMove.y)
                    {
                        szlAdjust.cy = pClip->top - pptlMove.y;
                    }

                } else {

                    szlPage.cx = prect->right;
                    szlPage.cy = prect->bottom;
                }

                //
                // Set clip region size (clip by band size)
                //
                // if band rect over page rect, adjust it.
                //

                if ((pptlMove.x + pbi.szlBand.cx) > szlPage.cx)
                {
                    szlClip.cx = szlPage.cx - pptlMove.x;
                }
                else
                {
                    szlClip.cx = pbi.szlBand.cx;
                }

                if ((pptlMove.y + pbi.szlBand.cy) > szlPage.cy)
                {
                    szlClip.cy = szlPage.cy - pptlMove.y;
                }
                else
                {
                    szlClip.cy = pbi.szlBand.cy;
                }

                MFD3("Print offset x,y = %d,%d\n",pptlMove.x,pptlMove.y);
                MFD3("Page size x,y = %d,%d\n",szlPage.cx,szlPage.cy);
                MFD3("Band size x,y = %d,%d\n",pbi.szlBand.cx,pbi.szlBand.cy);
                MFD3("Clip size x,y = %d,%d\n",szlClip.cx,szlClip.cy);
                MFD3("Adjust size x,y = %d,%d\n",szlAdjust.cx,szlAdjust.cy);

                // Create clip region for banding.

                hRgnBand = CreateRectRgn(szlAdjust.cx,szlAdjust.cy,szlClip.cx,szlClip.cy);
            }

            if (hRgnBand)
            {
                int iRet;
                RECT rectCurrentClip;

                // Get clip box currently selected in DC.

                iRet = GetClipBox(hdc,&rectCurrentClip);

                if ((iRet == NULLREGION) || (iRet == ERROR))
                {
                    // Select simple band region as clip region.

                    SelectClipRgn(hdc, hRgnBand);
                }
                else
                {
                    MFD1("GDI PrintBand: Some region already exists\n");
                    MFD3("Clip Box top = %d, bottom = %d\n",
                          rectCurrentClip.top,rectCurrentClip.bottom);
                    MFD3("Clip Box left = %d, right = %d\n",
                          rectCurrentClip.left,rectCurrentClip.right);
                    
                    // Save currect DC to restore current clip region later.

                    SaveDC(hdc);

                    // Move to the clip reagion to proper place.

                    OffsetClipRgn(hdc,-pptlMove.x,-pptlMove.y);

                    // Some clip region already defined. we need to combine those.

                    ExtSelectClipRgn(hdc, hRgnBand, RGN_AND);

                    // Mark as we saved DC.

                    bSaveDC = TRUE;
                }
            }

            // Play metafile.

            PlayEnhMetaFile( hdc, hmeta, &rectPage );

            if (hRgnBand)
            {
                if (bSaveDC)
                {
                    RestoreDC(hdc,-1);
                }
                else
                {

                    // Set back it to NULL region.

                    SelectClipRgn(hdc,NULL);
                }

                // Reset the clip region.

                DeleteObject(hRgnBand);
            }
        }
        else
        {
            MFD1("GDI PrintBand: Got error from kernel/driver, this band will be skipped\n");

            // There is something error, Terminate printing for this band.

            return;
        }

    // Repeat this until the driver says "no".

    } while (pbi.bRepeatThisBand);
}

/****************************************************************************
 * int MFP_InternalEndPage(HDC hdc, DWORD dwEMFITEMID)
 *
 * Closes the EMF attached to the DC and writes it to the spooler.  Then
 * it creates a new metafile and binds it to the DC.
 *
 * Gerrit van Wingerden [gerritv]
 *
 * 11-7-94 10:00:00
 *
 *****************************************************************************/

int MFP_InternalEndPage(HDC hdc,
                        DWORD dwEMFITEMID)
{
    PLDC pldc;
    HENHMETAFILE hmeta;
    BOOL bOk;
    int iRet = SP_ERROR;

    MFD1("Entering MFP_EndPage\n");

    if (!IS_ALTDC_TYPE(hdc))
        return(0);

    DC_PLDC(hdc,pldc,0);

    if ((pldc->fl & LDC_DOC_CANCELLED) ||
        ((pldc->fl & LDC_PAGE_STARTED) == 0))
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(SP_ERROR);
    }
    //  Need to change the dwEMFITEMID here if mono page
    if (!(pldc->fl & LDC_COLOR_PAGE)) {
       dwEMFITEMID = (dwEMFITEMID == EMRI_METAFILE) ? EMRI_BW_METAFILE
                                                    : EMRI_BW_FORM_METAFILE;
    }
    DESIGNATE_COLOR_PAGE(pldc);

    if (pldc->fl & LDC_SAP_CALLBACK)
        vSAPCallback(pldc);

    pldc->fl &= ~LDC_PAGE_STARTED;

//tessiew
#ifdef  DBGSUBSET
    if (gflSubset & FL_SS_PAGETIME)
    {
        GetSystemTimeAsFileTime(&midPageTime);
        DbgPrint("\t%ld", (midPageTime.dwLowDateTime-startPageTime.dwLowDateTime) / 10000);
    }
#endif

// We need to write the subset font into the spool
// file first for remote printing

    if ((pldc->fl & (LDC_DOWNLOAD_FONTS | LDC_FORCE_MAPPING)) && (pldc->fl & LDC_FONT_SUBSET))
    {
        PUFIHASH  pBucket, pBucketNext;
        PUCHAR puchDestBuff;
        ULONG index, ulDestSize, ulBytesWritten;

        for (index=0; index < UFI_HASH_SIZE; index++)
        {
            pBucketNext = pldc->ppSubUFIHash[index];

            while(pBucketNext)
            {
                // We might fail on bDoFontSubset() thus pBucket would be deleted from the hash table
                // in function WriteSubFontToSpoolFile(). Need to update pBucketNext first.

                pBucket = pBucketNext;
                pBucketNext = pBucket->pNext;

                if ((pBucket->fs1 & FLUFI_DELTA) && (pBucket->u.ssi.cDeltaGlyphs == 0))
                {
                    // No delta, skip
                    if (pBucket->u.ssi.pjDelta)
                    {
                        LocalFree(pBucket->u.ssi.pjDelta);
                        pBucket->u.ssi.pjDelta = NULL;
                    }
                }
                else // first page or page with nonzero delta
                {
                 // pBucket->fs1 will change for the first page after bDoFontSubset() call,
                 // thus we can't use pBucket->fs1 & FLUFI_DELTA in WriteSubFontToSpoolFile() call.
                    BOOL  bDelta = pBucket->fs1 & FLUFI_DELTA;

                    if
                    (
                        !bDoFontSubset(pBucket, &puchDestBuff, &ulDestSize, &ulBytesWritten) ||
                        !WriteSubFontToSpoolFile(pldc, puchDestBuff, ulBytesWritten, &pBucket->ufi, bDelta)
                    )
                    {
                    // if font subsetting failed, we need to write the whole font file to the spool file
                    // and clean up the UFI entry in the ldc

                        if (!bAddUFIandWriteSpool(hdc, &pBucket->ufi, TRUE, pBucket->fs2))
                        {
                            WARNING("bAddUFIandWriteSpool failed\n");
                            return SP_ERROR;
                        }
                    }
                }
            }
        }
    }

// Metafile the EndPage call.

    MFD1("MFP_EndPage: Closing metafile\n");

    hmeta = UnassociateEnhMetaFile(hdc, TRUE);

    if( hmeta == NULL )
    {
        WARNING("MFP_InternalEndPage() Closing the Enhanced Metafile Failed\n");
        return(SP_ERROR);
    }

// now write the metafile to the spooler

    if( pldc->fl & LDC_BANDING )
    {
    // play back the metafile in bands

        RECT rect;
        POINTL ptlOrigin;
        POINT  ptlKeep;
        POINT  ptlWindowOrg;
        SIZE   szWindowExt;
        SIZE   szViewportExt;
        SIZE   szSurface;    // for open gl printing optimization
        XFORM  xf;
        ULONG  ulMapMode;

    // get bounding rectangle

        rect.left = rect.top = 0;
        rect.right = GetDeviceCaps(hdc, DESKTOPHORZRES);
        rect.bottom = GetDeviceCaps(hdc, DESKTOPVERTRES);

    #if DBG
        DbgPrint("Playing banding metafile\n");
    #endif

    // temporarily reset LDC_META_PRINT flag so we don't try to record
    // during playback

        pldc->fl &= ~LDC_META_PRINT;

        bOk = StartBanding( hdc, &ptlOrigin, &szSurface );

    // we need to clear the transform during this operation

        GetViewportOrgEx(hdc, &ptlKeep);
        GetWindowOrgEx(hdc,&ptlWindowOrg);
        GetWindowExtEx(hdc,&szWindowExt);
        GetViewportExtEx(hdc,&szViewportExt);
        GetWorldTransform(hdc,&xf);

        ulMapMode = SetMapMode(hdc,MM_TEXT);
        SetWindowOrgEx(hdc,0,0,NULL);
        ModifyWorldTransform(hdc,NULL,MWT_IDENTITY);

        if( bOk )
        {
            do
            {
            // Print this band.

                PrintBand( hdc, hmeta, &ptlOrigin, &rect, &szSurface, NULL );

            // Move down to next band.

                bOk = NextBand( hdc, &ptlOrigin );
            } while( ptlOrigin.x != -1 && bOk );
        }

        if (pldc->pUMPD && bOk && (ptlOrigin.x == -1))
        {
           //
           // if UMPD and last band
           //
           if( !(*fpEndPagePrinter)( pldc->hSpooler ) )
           {
               WARNING("MFP_StarPage: EndPagePrinter failed\n");
               iRet = SP_ERROR;
           }
        }

        SetMapMode(hdc,ulMapMode);

        SetWorldTransform(hdc,&xf);
        SetWindowOrgEx(hdc,ptlWindowOrg.x,ptlWindowOrg.y,NULL);
        SetWindowExtEx(hdc,szWindowExt.cx,szWindowExt.cy,NULL);
        SetViewportExtEx(hdc,szViewportExt.cx,szViewportExt.cy,NULL);
        SetViewportOrgEx(hdc,ptlKeep.x, ptlKeep.y, NULL);

    // reset the flag for the next page

        pldc->fl |= LDC_META_PRINT;

        if( !bOk )
        {
            WARNING("MFP_EndPage: Error doing banding\n");
        }
        else
        {
        // if we got here we suceeded
            iRet = 1;
        }

    #if DBG
        DbgPrint("Done playing banding metafile\n");
    #endif
    }
    else
    {
    //  if ResetDC was called record the devmode in the metafile stream

        bOk = TRUE;

        if( pldc->fl & LDC_RESETDC_CALLED )
        {
            EMFITEMHEADER emfi;

            emfi.ulID = EMRI_DEVMODE;
            emfi.cjSize = ( pldc->pDevMode ) ?
                            pldc->pDevMode->dmSize + pldc->pDevMode->dmDriverExtra : 0 ;

            // Force devmode data to be DWORD aligned

            emfi.cjSize = ROUNDUP_DWORDALIGN(emfi.cjSize);

            if (!WriteEMFSpoolData(pldc, &emfi, sizeof(emfi)) ||
                !WriteEMFSpoolData(pldc, pldc->pDevMode, emfi.cjSize))
            {
                WARNING("Writing DEVMODE to spooler failed.\n");
                bOk = FALSE;
            }

            pldc->fl &= ~(LDC_RESETDC_CALLED);
        }

        if (bOk)
            iRet = 1;
    }

// At this point if we suceede iRet should be 1 otherwise it should be SP_ERROR
// even if we encountered an error we still want to try to associate a new
// metafile with this DC.  That whether the app calls EndPage, AbortDoc, or
// EndDoc next, things will happend more smoothly.

    DeleteEnhMetaFile(hmeta);

//
// flush the content of the current page to spooler
// and write out a new EndPage record
//

// next create a new metafile for the next page

    if (!FlushEMFSpoolData(pldc, dwEMFITEMID) || !AssociateEnhMetaFile(hdc))
    {
        WARNING("StartPage: error creating metafile\n");
        iRet = SP_ERROR;
    }

// reset user's poll count so it counts this as output

    RESETUSERPOLLCOUNT();

    if( !(pldc->fl & LDC_BANDING ) )
    {
        if( !(*fpEndPagePrinter)( pldc->hSpooler ) )
        {
            WARNING("MFP_StarPage: EndPagePrinter failed\n");
            iRet = SP_ERROR;
        }
    }

    pldc->fl |= LDC_CALL_STARTPAGE;

#if PRINT_TIMER
    if( bPrintTimer )
    {
        DWORD tc;
        tc = GetTickCount();
        DbgPrint("Page took %d.%d seconds to print\n",
                 (tc - pldc->msStartPage) / 1000,
                 (tc - pldc->msStartPage) % 1000 );

    }
#endif

#ifdef  DBGSUBSET
    if (gflSubset & FL_SS_PAGETIME)
    {
        GetSystemTimeAsFileTime(&endPageTime);
        DbgPrint("\t%ld\n", (endPageTime.dwLowDateTime-startPageTime.dwLowDateTime) / 10000);
    }
#endif

    return(iRet);
}


/****************************************************************************
 * int WINAPI MFP_EndPage(HDC hdc)
 *
 * Closes the EMF attached to the DC and writes it to the spooler.  Then
 * it creates a new metafile and binds it to the DC.
 *
 * Gerrit van Wingerden [gerritv]
 *
 * 11-7-94 10:00:00
 *
 *****************************************************************************/

int WINAPI MFP_EndPage(HDC hdc) {

   // Call MFP_InternalEndPage with EMRI_METAFILE
   return MFP_InternalEndPage(hdc, EMRI_METAFILE);

}

/****************************************************************************
 * int WINAPI MFP_EndFormPage(HDC hdc)
 *
 * Closes the EMF attached to the DC and writes it to the spooler.  Then
 * it creates a new metafile and binds it to the DC. Saves the EMF Item as a
 * watermark file which is played on each physical page.
 *
 * Ramanathan Venkatapathy [RamanV]
 *
 * 7/1/97
 *
 *****************************************************************************/

int WINAPI MFP_EndFormPage(HDC hdc) {

   // Call MFP_InternalEndPage with EMRI_FORM_METAFILE
   return MFP_InternalEndPage(hdc, EMRI_FORM_METAFILE);

}

BOOL MFP_ResetDCW( HDC hdc, DEVMODEW *pdmw )
{
    PLDC pldc;
    HENHMETAFILE hmeta;
    ULONG   cjDevMode;

    DC_PLDC(hdc,pldc,0);

    MFD1("MFP_ResetDCW Called\n");

    pldc->fl |= LDC_RESETDC_CALLED;

// finally associate a new metafile since call to ResetDC could have changed
// the dimensions of the DC

    hmeta = UnassociateEnhMetaFile( hdc, FALSE );
    DeleteEnhMetaFile( hmeta );

    if( !AssociateEnhMetaFile( hdc ) )
    {
        WARNING("MFP_ResetDCW is unable to associate a new metafile\n");
        return(FALSE);
    }

    return(TRUE);
}

BOOL MFP_ResetBanding( HDC hdc, BOOL bBanding )
{
    PLDC           pldc;
    HENHMETAFILE   hmeta;
    DC_PLDC(hdc,pldc,0);

    if( pldc->fl & LDC_BANDING )
    {
    // we were banding before so we must remove the old metafile from the DC
    // since we might not be banding any more or the surface dimenstions could
    // have changed requiring us to have a new metafile

        hmeta = UnassociateEnhMetaFile( hdc, FALSE );
        DeleteEnhMetaFile( hmeta );

        pldc->fl &= ~(LDC_BANDING|LDC_META_PRINT);

        MFD1("Remove old banding metafile\n");

    }

    if( bBanding )
    {
    // if we are banding after the ResetDC then we must attach a new metafile

        if( !AssociateEnhMetaFile(hdc) )
        {
            WARNING("MFP_ResetBanding: Failed to attach banding metafile spool metafile");
            return(FALSE);
        }

        pldc->fl |= LDC_BANDING|LDC_META_PRINT;

        MFD1("Adding new banding metafile\n");
    }

    return(TRUE);
}

/****************************************************************************
*  BOOL MyReadPrinter( HANDLE hPrinter, BYTE *pjBuf, ULONG cjBuf )
*
*   Read a requested number of bytes from the spooler.
*
*  History:
*   5/12/1995 by Gerrit van Wingerden [gerritv]  - Author
*
*   5/1/1997 by Ramanathan N Venkatapathy [ramanv]
*                 Modified to synchronously wait during Print while spooling.
*                 SeekPrinter sets last error when spool file isn't big enough.
*****************************************************************************/

BOOL MyReadPrinter( HANDLE hPrinter, BYTE *pjBuf, ULONG cjBuf )
{
    ULONG          cjRead;
    LARGE_INTEGER  liOffset;

    ASSERTGDI(ghSpooler,"non null hSpooler with unloaded WINSPOOL\n");

    // Wait till enough bytes have been written.
    liOffset.QuadPart = cjBuf;
    if (!(*fpSeekPrinter) (hPrinter, liOffset, NULL, FILE_CURRENT, FALSE)) {
        return FALSE;
    }

    // Seek back to the original position in the spoolfile.
    liOffset.QuadPart = -liOffset.QuadPart;
    if (!(*fpSeekPrinter) (hPrinter, liOffset, NULL, FILE_CURRENT, FALSE)) {
        return FALSE;
    }

    while( cjBuf )
    {
        if(!(*fpReadPrinter)( hPrinter, pjBuf, cjBuf, &cjRead ) )
        {
            WARNING("MyReadPrinter: Read printer failed\n");
            return(FALSE);
        }

        if( cjRead == 0 )
        {
            return(FALSE);
        }

        pjBuf += cjRead;
        cjBuf -= cjRead;

    }
    return(TRUE);
}

BOOL MemMapReadPrinter(
    HANDLE  hPrinter,
    LPBYTE  *pBuf,
    ULONG   cbBuf
)
{
   LARGE_INTEGER  liOffset;

   ASSERTGDI(ghSpooler,"non null hSpooler with unloaded WINSPOOL\n");

   // Memory mapped ReadPrinter not exported.
   if (!fpSplReadPrinter) {
       return FALSE;
   }

   // Wait till enough bytes have been written.
   liOffset.QuadPart = cbBuf;
   if (!(*fpSeekPrinter) (hPrinter, liOffset, NULL, FILE_CURRENT, FALSE)) {
       return FALSE;
   }

   // Seek back to the original position in the spoolfile.
   liOffset.QuadPart = -liOffset.QuadPart;
   if (!(*fpSeekPrinter) (hPrinter, liOffset, NULL, FILE_CURRENT, FALSE)) {
       return FALSE;
   }

   if(!(*fpSplReadPrinter) (hPrinter, pBuf, (DWORD) cbBuf)) {
       WARNING("MemMapReadPrinter: Read printer failed\n");
       return FALSE;
   }

   return TRUE;
}

BOOL WINAPI GdiPlayEMF(
    LPWSTR     pwszPrinterName,
    LPDEVMODEW pDevmode,
    LPWSTR     pwszDocName,
    EMFPLAYPROC pfnEMFPlayFn,
    HANDLE     hPageQuery
)
/*++
Function Description:
         GdiPlayEMF is the old playback function. It has been replaced by a
         bunch of new GDI interfaces which give more flexibility to the print
         processor on placing and reordering the pages of the print job. This
         function has been rewritten to use these new interfaces (for backward
         compatibility and maintainance)

Parameters:

Return Values:
         If the function succeeds, the return value is TRUE;
         otherwise the result is FALSE.

History:
         8/15/1997 by Ramanathan N Venkatapathy [ramanv]

--*/
{
    HANDLE     hSpoolHandle, hEMF;
    HDC        hPrinterDC;
    BOOL       bReturn = FALSE;
    DOCINFOW   DocInfo;
    DWORD      dwPageType, dwPageNumber = 1;
    RECT       rectDocument;
    LPDEVMODEW pCurrDM, pLastDM;

    if (!(hSpoolHandle = GdiGetSpoolFileHandle(pwszPrinterName,
                                               pDevmode,
                                               pwszDocName))    ||
        !(hPrinterDC   = GdiGetDC(hSpoolHandle))) {

         goto CleanUp;
    }

    DocInfo.cbSize = sizeof(DOCINFOW);
    DocInfo.lpszDocName  = pwszDocName;
    DocInfo.lpszOutput   = NULL;
    DocInfo.lpszDatatype = NULL;

    rectDocument.left = rectDocument.top = 0;
    rectDocument.right  = GetDeviceCaps(hPrinterDC, DESKTOPHORZRES);
    rectDocument.bottom = GetDeviceCaps(hPrinterDC, DESKTOPVERTRES);

    if (!GdiStartDocEMF(hSpoolHandle, &DocInfo)) {
         goto CleanUp;
    }

    while (1) {

       hEMF = GdiGetPageHandle(hSpoolHandle,
                               dwPageNumber,
                               &dwPageType);

       if (!hEMF) {
          if (GetLastError() == ERROR_NO_MORE_ITEMS) {
             break;
          } else {
             goto CleanUp;
          }
       }

       if (!GdiGetDevmodeForPage(hSpoolHandle, dwPageNumber,
                                 &pCurrDM, &pLastDM)) {
             goto CleanUp;
       }

       if ((pCurrDM != pLastDM) && !GdiResetDCEMF(hSpoolHandle,
                                                  pCurrDM)) {
             goto CleanUp;
       }

       if (!SetGraphicsMode(hPrinterDC, GM_ADVANCED)) {

           goto CleanUp;
       }

       if (!GdiStartPageEMF(hSpoolHandle) ||
           !GdiPlayPageEMF(hSpoolHandle, hEMF, &rectDocument, NULL, NULL) ||
           !GdiEndPageEMF(hSpoolHandle, 0)) {

             goto CleanUp;
       }

       ++dwPageNumber;
    }

    GdiEndDocEMF(hSpoolHandle);

    bReturn = TRUE;

CleanUp:

    if (hSpoolHandle) {
        GdiDeleteSpoolFileHandle(hSpoolHandle);
    }

    return bReturn;
}


BOOL WINAPI GdiDeleteSpoolFileHandle(
    HANDLE SpoolFileHandle)

/*
Function Description:
         GdiDeleteSpoolFileHandle frees all the resources allocated by GDI for printing
         the corresponding job. This function should be called by the print processor just
         before it returns.

Parameters:
         SpoolFileHandle - Handle returned by GdiGetSpoolFileHandle.

Return Values:
         If the function succeeds, the return value is TRUE;
         otherwise the result is FALSE.

History:
         5/12/1995 by Gerrit van Wingerden [gerritv] - Author

         5/15/1997 by Ramanathan N Venkatapathy [ramanv] -
              Freed more resources associated with the SpoolFileHandle
*/

{
    SPOOL_FILE_HANDLE   *pSpoolFileHandle;
    LPDEVMODEW          pLastDevmode;
    UINT                PageCount;
    PRECORD_INFO_STRUCT pRecordInfo = NULL, pRecordInfoFree = NULL;
    DWORD               dwIndex;
    PEMF_HANDLE         pTemp;

    pSpoolFileHandle = (SPOOL_FILE_HANDLE*) SpoolFileHandle;

    // first check to see if this is a valid handle by checking for the tag

    try
    {
        if(pSpoolFileHandle->tag != SPOOL_FILE_HANDLE_TAG)
        {
            WARNING("GdiDeleteSpoolFileHandle: invalid handle\n");
            return(FALSE);
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("GdiDeleteSpoolFileHandle: exception accessing handle\n");
        return(FALSE);
    }

    // Loop through all the page records, find the last page on which each DEVMODE is used
    // and free it.  The first DEVMODE is always allocated along with the memory for
    // the spool file handle so never free that one. All DEVMODEs different than the original one
    // must be non-NULL since they appear in the spool file.

    for(PageCount = 0, pLastDevmode = pSpoolFileHandle->pOriginalDevmode;
        PageCount < pSpoolFileHandle->MaxPageProcessed;
        PageCount += 1 )
    {
        if(pSpoolFileHandle->pPageInfo[PageCount].pDevmode != pLastDevmode)
        {
            if(pLastDevmode != pSpoolFileHandle->pOriginalDevmode)
            {
                LocalFree(pLastDevmode);
            }

            pLastDevmode = pSpoolFileHandle->pPageInfo[PageCount].pDevmode;
        }
    }

    // free the last DEVMODE used if it is not the original DEVMODE

    if(pLastDevmode != pSpoolFileHandle->pOriginalDevmode)
    {
        LocalFree(pLastDevmode);
    }

    // free the PAGE_INFO_STRUCT array and lists held in them

    if (pSpoolFileHandle->pPageInfo) {

       for (dwIndex = pSpoolFileHandle->MaxPageProcessed; dwIndex; --dwIndex) {

           pRecordInfo = pSpoolFileHandle->pPageInfo[dwIndex-1].pRecordInfo;

           while (pRecordInfoFree = pRecordInfo) {
              pRecordInfo = pRecordInfo->pNext;
              LocalFree(pRecordInfoFree);
           }

       }
       LocalFree(pSpoolFileHandle->pPageInfo);
    }

    // free the list of EMF_HANDLEs returned to the print processor

    while (pTemp = pSpoolFileHandle->pEMFHandle) {
       pSpoolFileHandle->pEMFHandle = (pSpoolFileHandle->pEMFHandle)->pNext;
       if (pTemp->hemf) {
          InternalDeleteEnhMetaFile(pTemp->hemf, pTemp->bAllocBuffer);
       }
       LocalFree(pTemp);
    }

    // free the DC

    DeleteDC(pSpoolFileHandle->hdc);

    // then the spooler's spool handle

    (*fpClosePrinter)(pSpoolFileHandle->hSpooler);

    // finally free the data associated with this handle

    LocalFree(pSpoolFileHandle);

    return(TRUE);
}


HANDLE WINAPI GdiGetSpoolFileHandle(
    LPWSTR pwszPrinterName,
    LPDEVMODEW pDevmode,
    LPWSTR pwszDocName)
/*
Function Description:
         GdiGetSpoolFileHandle is the first function that should be called by the
         print processor. It returns a handle that will be needed for all the
         subsequent calls. The function performs initializations of opening the
         printer, creating a device context and allocating memory for the handle.

Parameters:
         pwszPrinterName - Identifies the printer on which the job is to printed.
         pDevmode - Pointer to a DEVMODE structure.
         pwszDocName - Identifies the document name of job.

Return Values:
         If the function succeeds, the return value is a valid HANDLE;
         otherwise the result is NULL.

History:
         5/12/1995 by Gerrit van Wingerden [gerritv] - Author

         5/15/1997 by Ramanathan N Venkatapathy [ramanv] -
              Handled NULL devmode case.
*/
{
    SPOOL_FILE_HANDLE *pHandle;

    if( !BLOADSPOOLER )
    {
        WARNING("GdiGetSpoolFileHandle: Unable to load spooler\n");
        return(FALSE);
    }

    if(pHandle = LOCALALLOC(sizeof(SPOOL_FILE_HANDLE) +
                            ((pDevmode != NULL) ? pDevmode->dmSize+pDevmode->dmDriverExtra
                                                : 0 )))
    {
        // Zero out the SPOOL_FILE_HANDLE
        RtlZeroMemory(pHandle , sizeof(SPOOL_FILE_HANDLE) +
                                  ((pDevmode != NULL) ? pDevmode->dmSize+pDevmode->dmDriverExtra
                                                      : 0));

        if((*fpOpenPrinterW)(pwszDocName, &pHandle->hSpooler,
                             (LPPRINTER_DEFAULTSW) NULL ) &&
           pHandle->hSpooler)
        {
            if(pHandle->hdc = CreateDCW(L"", pwszPrinterName, L"", pDevmode))
            {
                pHandle->PageInfoBufferSize = 20;

                if(pHandle->pPageInfo = LOCALALLOC(sizeof(PAGE_INFO_STRUCT) *
                                                   pHandle->PageInfoBufferSize))
                {
                    pHandle->tag = SPOOL_FILE_HANDLE_TAG;

                    if (pDevmode) {
                        pHandle->pOriginalDevmode = (LPDEVMODEW) (pHandle + 1);
                        memcpy(pHandle->pOriginalDevmode, pDevmode,pDevmode->dmSize+pDevmode->dmDriverExtra);
                    } else {
                        pHandle->pOriginalDevmode = NULL;
                    }

                    pHandle->pLastDevmode = pHandle->pOriginalDevmode;
                    pHandle->MaxPageProcessed = 0;
                    pHandle->pEMFHandle = NULL;
                    RtlZeroMemory(pHandle->pPageInfo,
                                  sizeof(PAGE_INFO_STRUCT) * pHandle->PageInfoBufferSize);

                    pHandle->dwPlayBackStatus = EMF_PLAY_FORCE_MONOCHROME;
                    if (pHandle->pLastDevmode &&
                        (pHandle->pLastDevmode->dmFields & DM_COLOR) &&
                        (pHandle->pLastDevmode->dmColor == DMCOLOR_COLOR)) {

                        pHandle->dwPlayBackStatus = EMF_PLAY_COLOR;
                    }
                    pHandle->bUseMemMap = TRUE;

                    return((HANDLE) pHandle);
                }
                else
                {
                    WARNING("GdiGetSpoolFileHandle: OutOfMemory\n");
                }

                DeleteDC(pHandle->hdc);
            }
            else
            {
                WARNING("GdiGetSpoolHandle: CreateDCW failed\n");
            }

            (*fpClosePrinter)(pHandle->hSpooler);
        }

        LocalFree(pHandle);
    }

    return((HANDLE) NULL);
}

BOOL ProcessJob(
    SPOOL_FILE_HANDLE *pSpoolFileHandle
)
{
    LARGE_INTEGER      LargeInt;
    EMFSPOOLHEADER     emsh;
    EMFITEMHEADER      emfi;

// Seek to offset 0.

    LargeInt.QuadPart = 0;
    if (!((*fpSeekPrinter)(pSpoolFileHandle->hSpooler, LargeInt, NULL, 0,FALSE)))
    {
        WARNING("GDI32 ProcessJob: seek printer to 0 failed\n");
        return(FALSE);
    }

// Read EMFSPOOLHEADER

    if(!MyReadPrinter(pSpoolFileHandle->hSpooler, (BYTE*) &emsh, sizeof(emsh)))
    {
        WARNING("GDI32 ProcessJob: MyReadPrinter to read EMFSPOOLHEADER failed\n");
        return(FALSE);
    }

// Move Offset to next record.

    LargeInt.QuadPart = emsh.cjSize;
    if (!((*fpSeekPrinter)(pSpoolFileHandle->hSpooler, LargeInt, NULL, 0,FALSE)))
    {
        WARNING("GDI32 ProcessPages: seek printer failed\n");
        return(FALSE);
    }

// Read next EMFITEMHEADER

    if(!MyReadPrinter(pSpoolFileHandle->hSpooler, (BYTE*) &emfi, sizeof(emfi)))
    {
        WARNING("GDI32 ProcessJob: MyReadPrinter to read EMFSPOOLHEADER failed\n");
        return(FALSE);
    }

// If this is EMRI_PS_JOB_DATA, process this record.

    if (emfi.ulID == EMRI_PS_JOB_DATA)
    {
        PBYTE pPSBuffer = LOCALALLOC(emfi.cjSize);

        if (pPSBuffer)
        {
            if (MyReadPrinter(pSpoolFileHandle->hSpooler, pPSBuffer, emfi.cjSize))
            {
                DWORD cjSizeProcessed = 0;
                PEMFITEMPSINJECTIONDATA pPSData = (PEMFITEMPSINJECTIONDATA) pPSBuffer;

                while (cjSizeProcessed < emfi.cjSize)
                {
                    ExtEscape(pSpoolFileHandle->hdc,
                              pPSData->nEscape,
                              pPSData->cjInput,
                              (PVOID)&(pPSData->EscapeData),
                              0, NULL);

                    cjSizeProcessed += pPSData->cjSize;

                    // Move to next record.

                    pPSData = (PEMFITEMPSINJECTIONDATA) ((PBYTE)pPSData + pPSData->cjSize);
                }
            }
            else
            {
                WARNING("GDI32 ProcessJob: MyReadPrinter to read EMFSPOOLHEADER failed\n");
                return(FALSE);
            }

            LOCALFREE(pPSBuffer);
        }
        else
        {
            WARNING("GDI32 ProcessJob: failed on LOCALALLOC\n");
            return(FALSE);
        }
    }

// Seek back to offset 0.

    LargeInt.QuadPart = 0;
    (*fpSeekPrinter)(pSpoolFileHandle->hSpooler, LargeInt, NULL, 0,FALSE);

    return (TRUE);
}

BOOL ProcessPages(
    SPOOL_FILE_HANDLE *pSpoolFileHandle,
    UINT LastPage
)
/*
Function Description:
         ProcessPages parses the spool file and processes the EMF records until the
         required page.

Parameters:
         SpoolFileHandle - Handle returned by GdiGetSpoolFileHandle.
         LastPage - Page number to process.

Return Values:
         If the function succeeds, the return value is TRUE;
         otherwise the result is FALSE.

History:
         5/12/1995 by Gerrit van Wingerden [gerritv] - Author

         5/15/1997 by Ramanathan N Venkatapathy [ramanv] -
                Added code to handle DELTA_FONT, SUBSET_FONT, DESIGN_VECTOR
                and PRESTARTPAGE.

         1/28/1998 by Ramanathan N Venkatapathy [ramanv] -
                Process EXT records
*/
{
    LARGE_INTEGER      LargeInt;
    LONGLONG           CurrentOffset, EMFOffset;
    ULONG              CurrentPage;
    LPDEVMODEW         pLastDevmode = NULL;
    EMFITEMHEADER      emfi, emfiExt;
    BYTE               *pTmpBuffer = NULL;
    UNIVERSAL_FONT_ID  ufi;
    ULONG              ulBytesWritten;
    PVOID              pvMergeBuf;
    PRECORD_INFO_STRUCT pRecordInfo;
    BOOL               bReadPrinter = FALSE;
    INT64              iOffset;
    DWORD              dwSize;
    BOOL               bLastDevmodeAllocated = FALSE;

// early exit if we've already processed the requested number of pages

    if(pSpoolFileHandle->MaxPageProcessed >= LastPage)
    {
    	//When a document is being printed back-to-front and is restarted in 
    	//the middle of the job, we won't detect the error in the normal way.  
    	//So we call SeekPrinter with NOOP arguments to check for the 
    	//ERROR_PRINT_CANCELLED return value.

    	BOOL fSeekResult;
    	LargeInt.QuadPart = 0;
    	fSeekResult = ((*fpSeekPrinter)(pSpoolFileHandle->hSpooler, LargeInt, 
    		NULL, FILE_CURRENT, FALSE));
    	return fSeekResult || GetLastError() != ERROR_PRINT_CANCELLED;
    }

// allocate memory to store info for all pages if the existing buffer isn't large
// enough

    if(LastPage > pSpoolFileHandle->PageInfoBufferSize)
    {
        PAGE_INFO_STRUCT *pTemp;

        if(pTemp = LOCALALLOC(sizeof(PAGE_INFO_STRUCT) * LastPage))
        {
            RtlZeroMemory(pTemp, sizeof(PAGE_INFO_STRUCT) * LastPage);
            memcpy(pTemp,
                   pSpoolFileHandle->pPageInfo,
                   sizeof(PAGE_INFO_STRUCT) * pSpoolFileHandle->MaxPageProcessed);

            pSpoolFileHandle->PageInfoBufferSize = LastPage;
            LocalFree(pSpoolFileHandle->pPageInfo);
            pSpoolFileHandle->pPageInfo = pTemp;
        }
        else
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            WARNING("GDI32 ProcessPages: out of memory\n");
            return(FALSE);
        }
    }

// if we've already processed some pages then start with the last page processed

    if(pSpoolFileHandle->MaxPageProcessed)
    {
        CurrentOffset =
          pSpoolFileHandle->pPageInfo[pSpoolFileHandle->MaxPageProcessed-1].SeekOffset;

        pLastDevmode =
          pSpoolFileHandle->pPageInfo[pSpoolFileHandle->MaxPageProcessed-1].pDevmode;
    }
    else
    {
        EMFSPOOLHEADER emsh;

        LargeInt.QuadPart = 0;
        if (!((*fpSeekPrinter)(pSpoolFileHandle->hSpooler, LargeInt, NULL, 0,FALSE)))
        {
            WARNING("GDI32 ProcessPages: seek printer to 0 failed\n");
            return(FALSE);
        }

        if(!MyReadPrinter(pSpoolFileHandle->hSpooler, (BYTE*) &emsh, sizeof(emsh)))
        {
            WARNING("GDI32 ProcessPages: MyReadPrinter failed\n");
            return(FALSE);
        }

        CurrentOffset = emsh.cjSize;
        pLastDevmode = pSpoolFileHandle->pOriginalDevmode;
    }

    LargeInt.QuadPart = CurrentOffset;

    if (!((*fpSeekPrinter)(pSpoolFileHandle->hSpooler,
                          LargeInt, NULL,
                          0,FALSE)))
    {
        WARNING("GDI32 ProcessPages: seek printer failed\n");
        return(FALSE);
    }

    CurrentPage = pSpoolFileHandle->MaxPageProcessed;

    while ((CurrentPage < LastPage)    &&
            MyReadPrinter(pSpoolFileHandle->hSpooler, (BYTE*) &emfi, sizeof(emfi))) {

        CurrentOffset += sizeof(emfi);

        if (emfi.cjSize == 0)
        {
            continue;
        }

        bReadPrinter = FALSE;

        // For records to be processed now, read into a buffer

        if ((emfi.ulID == EMRI_DEVMODE)       ||
            (emfi.ulID == EMRI_ENGINE_FONT)   ||
            (emfi.ulID == EMRI_TYPE1_FONT)    ||
            (emfi.ulID == EMRI_SUBSET_FONT)   ||
            (emfi.ulID == EMRI_DELTA_FONT)    ||
            (emfi.ulID == EMRI_DESIGNVECTOR)) {

             if (pTmpBuffer = (BYTE*) LOCALALLOC(emfi.cjSize)) {

                 if(MyReadPrinter(pSpoolFileHandle->hSpooler,
                                  pTmpBuffer, emfi.cjSize)) {

                     bReadPrinter = TRUE;
                     dwSize = emfi.cjSize;

                 } else {

                     WARNING("Gdi32: Process Pages error reading font or devmode\n");
                     goto exit;
                 }

             } else {

                 WARNING("Out of memory in ProcessPages\n");
                 goto exit;
             }

        } else if ((emfi.ulID == EMRI_ENGINE_FONT_EXT)   ||
                   (emfi.ulID == EMRI_TYPE1_FONT_EXT)    ||
                   (emfi.ulID == EMRI_SUBSET_FONT_EXT)   ||
                   (emfi.ulID == EMRI_DELTA_FONT_EXT)    ||
                   (emfi.ulID == EMRI_DESIGNVECTOR_EXT)  ||
                   (emfi.ulID == EMRI_EMBED_FONT_EXT)) {

             // For EXT records get the buffer from an offset

             if (emfi.cjSize < sizeof(INT64)) {
                 WARNING("Ext Record bad size\n");
                 goto exit;
             }

             if (MyReadPrinter(pSpoolFileHandle->hSpooler, (PBYTE) &iOffset, sizeof(INT64)) &&
                 (iOffset > 0)) {

                 LargeInt.QuadPart = -1 * (iOffset + sizeof(emfi) + sizeof(INT64));

                 if ((*fpSeekPrinter)(pSpoolFileHandle->hSpooler,
                                      LargeInt, NULL, FILE_CURRENT, FALSE) &&
                     MyReadPrinter(pSpoolFileHandle->hSpooler, (BYTE*) &emfiExt,
                                   sizeof(emfiExt))) {

                     if (pTmpBuffer = (BYTE*) LOCALALLOC(emfiExt.cjSize)) {

                         if (!MyReadPrinter(pSpoolFileHandle->hSpooler,
                                            pTmpBuffer, emfiExt.cjSize)) {

                             WARNING("Gdi32: Process Pages error reading font or devmode\n");
                             goto exit;
                         }

                         dwSize = emfiExt.cjSize;

                     } else {

                         WARNING("Out of memory in ProcessPages\n");
                         goto exit;
                     }

                     // We will seek back to the correct position after the switch
                 }
             }

        }

        switch (emfi.ulID)
        {
        case EMRI_METAFILE:
        case EMRI_FORM_METAFILE:
        case EMRI_BW_METAFILE:
        case EMRI_BW_FORM_METAFILE:

            // it's a metafile so setup an entry for it

            pSpoolFileHandle->pPageInfo[CurrentPage].pDevmode = pLastDevmode;
            pSpoolFileHandle->pPageInfo[CurrentPage].EMFOffset = CurrentOffset;
            pSpoolFileHandle->pPageInfo[CurrentPage].SeekOffset = CurrentOffset + emfi.cjSize;
            pSpoolFileHandle->pPageInfo[CurrentPage].EMFSize = emfi.cjSize;
            pSpoolFileHandle->pPageInfo[CurrentPage].ulID = emfi.ulID;
            pSpoolFileHandle->MaxPageProcessed += 1;
            bLastDevmodeAllocated = FALSE;

            CurrentPage += 1;
            break;

        case EMRI_METAFILE_EXT:
        case EMRI_BW_METAFILE_EXT:

            // it's a metafile at an offset

            if (emfi.cjSize < sizeof(INT64)) {
                WARNING("Ext Record bad size\n");
                goto exit;
            }

            if (MyReadPrinter(pSpoolFileHandle->hSpooler, (PBYTE) &iOffset, sizeof(INT64)) &&
                (iOffset > 0)) {

                LargeInt.QuadPart = -1 * (iOffset + sizeof(emfi) + sizeof(INT64));

                if ((*fpSeekPrinter)(pSpoolFileHandle->hSpooler,
                                     LargeInt, NULL, FILE_CURRENT, FALSE) &&
                    MyReadPrinter(pSpoolFileHandle->hSpooler, (BYTE*) &emfiExt,
                                  sizeof(emfiExt))) {

                    pSpoolFileHandle->pPageInfo[CurrentPage].pDevmode = pLastDevmode;
                    bLastDevmodeAllocated = FALSE;

                    EMFOffset = CurrentOffset - (LONGLONG) iOffset;
                    if (EMFOffset) {
                        pSpoolFileHandle->pPageInfo[CurrentPage].EMFOffset = EMFOffset;
                    } else {
                        WARNING("Bad Ext Record\n");
                        goto exit;
                    }
                    pSpoolFileHandle->pPageInfo[CurrentPage].SeekOffset =
                                                               CurrentOffset + emfi.cjSize;
                    pSpoolFileHandle->pPageInfo[CurrentPage].EMFSize = emfiExt.cjSize;
                    pSpoolFileHandle->pPageInfo[CurrentPage].ulID =
                                  (emfi.ulID == EMRI_METAFILE_EXT) ? EMRI_METAFILE
                                                                   : EMRI_BW_METAFILE;
                    pSpoolFileHandle->MaxPageProcessed += 1;

                    CurrentPage += 1;
                    break;

                    // We will seek back to the correct position after the switch
                }
            }

            WARNING("ReadPrinter or SeekPrinter failed\n");
            goto exit;

        case EMRI_DEVMODE:

            pLastDevmode = (LPDEVMODEW) pTmpBuffer;
            pTmpBuffer = NULL;
            bLastDevmodeAllocated = TRUE;
            break;

        case EMRI_METAFILE_DATA:

            // Start of EMF data. Wait till EMRI_(BW_)METAFILE_EXT so that fonts can
            // be correctly processed
            break;

        case EMRI_ENGINE_FONT:
        case EMRI_ENGINE_FONT_EXT:
        case EMRI_TYPE1_FONT:
        case EMRI_TYPE1_FONT_EXT:

            if (!NtGdiAddRemoteFontToDC(pSpoolFileHandle->hdc,
                                        pTmpBuffer, dwSize , NULL))
            {
                WARNING("Error adding remote font\n");
                goto exit;
            }

            if ((emfi.ulID == EMRI_TYPE1_FONT) ||
                (emfi.ulID == EMRI_TYPE1_FONT_EXT))
            {
                // force ResetDC so Type1 fonts get loaded
                pSpoolFileHandle->pLastDevmode = NULL;
            }

            break;

        case EMRI_SUBSET_FONT:
        case EMRI_SUBSET_FONT_EXT:

            if (bMergeSubsetFont(pSpoolFileHandle->hdc, pTmpBuffer, dwSize,
                                 &pvMergeBuf, &ulBytesWritten, FALSE, &ufi)) {

                 if (!NtGdiAddRemoteFontToDC(pSpoolFileHandle->hdc, pvMergeBuf,
                                             ulBytesWritten, &ufi)) {
                    WARNING("Error adding subsetted font\n");
                 }

            } else {

                 WARNING("Error merging subsetted fonts\n");
            }

            break;

        case EMRI_DELTA_FONT:
        case EMRI_DELTA_FONT_EXT:

            if (bMergeSubsetFont(pSpoolFileHandle->hdc, pTmpBuffer, dwSize,
                                 &pvMergeBuf, &ulBytesWritten, TRUE, &ufi)) {

               if (NtGdiRemoveMergeFont(pSpoolFileHandle->hdc, &ufi)) {

                   if (!NtGdiAddRemoteFontToDC(pSpoolFileHandle->hdc, pvMergeBuf,
                                               ulBytesWritten, &ufi)) {

                       WARNING("Error adding subsetted font\n");

                   }

               } else {

                   WARNING("Error removing merged font\n");
               }

            } else {

               WARNING("Error merging subsetted fonts\n");
            }

            break;

        case EMRI_DESIGNVECTOR:
        case EMRI_DESIGNVECTOR_EXT:

            MFD1("Unpackaging designvector \n");

            if (!NtGdiAddRemoteMMInstanceToDC(pSpoolFileHandle->hdc,
                                              (DOWNLOADDESIGNVECTOR *) pTmpBuffer,
                                              dwSize)) {

                WARNING("Error adding remote mm instance font\n");

            }

            break;

        case EMRI_EMBED_FONT_EXT:
            
            MFD1("Unpackaging embed fonts\n");

            if (!NtGdiAddEmbFontToDC(pSpoolFileHandle->hdc,(VOID **) pTmpBuffer))
            {
                WARNING("Error adding embed font to DC\n");
            }

            break;

        case EMRI_PRESTARTPAGE:

            if (!(pRecordInfo =
                    (PRECORD_INFO_STRUCT) LOCALALLOC(sizeof(RECORD_INFO_STRUCT)))) {

                WARNING("Out of memory in ProcessPages\n");
                goto exit;
            }

            pRecordInfo->pNext = pSpoolFileHandle->pPageInfo[CurrentPage].pRecordInfo;
            pSpoolFileHandle->pPageInfo[CurrentPage].pRecordInfo = pRecordInfo;

            pRecordInfo->RecordID = emfi.ulID;
            pRecordInfo->RecordSize = emfi.cjSize;
            pRecordInfo->RecordOffset = CurrentOffset;

            break;

        case EMRI_PS_JOB_DATA:

            // Already processed at GdiStartDocEMF().

            break;

        default:

            WARNING("GDI32: ProcessPages: Unknown ITEM record\n");
            break;
        }

        CurrentOffset += emfi.cjSize;

        LargeInt.QuadPart = CurrentOffset;

        if(!bReadPrinter && !(*fpSeekPrinter)(pSpoolFileHandle->hSpooler,
                                              LargeInt, NULL, 0, FALSE))
        {
            WARNING("GDI32 Process Pages: seekprinter failed\n");
            goto exit;
        }

        //
        // Release temp buffer each time through the loop.
        //
        if(pTmpBuffer)
        {
            LocalFree(pTmpBuffer);
            pTmpBuffer = NULL;
        }
    }

exit:

    //
    // Release the temp buffer, it is a temp so it should not
    // live beyond this subroutine.
    //
    if(pTmpBuffer)
    {
        LocalFree(pTmpBuffer);
    }

    //
    // Only release the last devmode pointer if one was allocated.
    //
    if(pLastDevmode && bLastDevmodeAllocated)
    {
        LocalFree(pLastDevmode);
    }

    return(CurrentPage >= LastPage);
}

HDC WINAPI GdiGetDC(
    HANDLE SpoolFileHandle)

/*
Function Description:
         GdiGetDC returns a handle to the device context of the printer.
         This handle can be used to apply transformations (translation, rotation, scaling etc)
         before playing any page at the printer

Parameters:
         SpoolFileHandle    -- handle returned by GdiGetSpoolFileHandle

Return Values:
         If the function succeeds, the return value is a valid HANDLE;
         otherwise the result is NULL.

History:
         5/12/1995 by Gerrit van Wingerden [gerritv] - Author
*/

{
    SPOOL_FILE_HANDLE *pSpoolFileHandle;
    pSpoolFileHandle = (SPOOL_FILE_HANDLE*) SpoolFileHandle;

    // first check to see if this is a valid handle by checking for the tag

    try
    {
        if(pSpoolFileHandle->tag != SPOOL_FILE_HANDLE_TAG)
        {
            WARNING("GdiGetDC: invalid handle\n");
            return(NULL);
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("GdiGetDC: exception accessing handle\n");
        return(NULL);
    }

    return(pSpoolFileHandle->hdc);
}


DWORD WINAPI GdiGetPageCount(
     HANDLE SpoolFileHandle)

/*
Function Description:
         GdiGetPageCount returns the number of pages in the print job. If print
         while spooling option is used, GdiGetPageCount synchronously waits till
         the job is completely spooled and then returns the page count.

Parameters:
         SpoolFileHandle    -- handle returned by GdiGetSpoolFileHandle

Return Values:
         If the function succeeds, the return value is the page count
         otherwise the result is 0.

History:
         5/12/1995 by Gerrit van Wingerden [gerritv] - Author
*/

{
    UINT Page = 10;
    LARGE_INTEGER LargeInt;
    SPOOL_FILE_HANDLE *pSpoolFileHandle;

    pSpoolFileHandle = (SPOOL_FILE_HANDLE*) SpoolFileHandle;

    // first check to see if this is a valid handle by checking for the tag

    try
    {
        if(pSpoolFileHandle->tag != SPOOL_FILE_HANDLE_TAG)
        {
            WARNING("GdiGetPageCount: invalid handle\n");
            return 0;
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("GdiGetPageCount: exception accessing handle\n");
        return 0;
    }


    while(ProcessPages(pSpoolFileHandle, Page))
    {
        Page += 10;
    }

    LargeInt.QuadPart = 0;

    if(!(*fpSeekPrinter)(pSpoolFileHandle->hSpooler, LargeInt, NULL, 0,
                         FALSE))
    {
        WARNING("GDI32 GdiGetPageCount: seek failed\n");
        return 0;
    }

    return ((DWORD) pSpoolFileHandle->MaxPageProcessed);
}


HANDLE WINAPI GdiGetPageHandle(
    HANDLE SpoolFileHandle,
    DWORD Page,
    LPDWORD pdwPageType)

/*
Function Description:
         GdiGetPageHandle returns a handle to contents of the required page.
         This handle should be used while playing the page at the printer. If the
         spool file is not sufficiently large, the last error is set to ERROR_NO_MORE_ITEMS.
         If print while spooling is supported, the print processor will have to examine
         for this error code to determine the end of the print job. Using GdiGetPageCount
         will stall the processing till the entire print job is spooled.

Parameters:
         SpoolFileHandle    -- handle returned by GdiGetSpoolFileHandle
         Page               -- number of the page required
         pdwPageType        -- pointer to store the type of the page (Normal/Watermark)

Return Values:
         If the function succeeds, the return value is a valid HANDLE;
         otherwise the result is NULL.

History:
         5/12/1995 by Gerrit van Wingerden [gerritv] - Author

         5/15/1997 by Ramanathan N Venkatapathy [ramanv] -
             Changed the return value to a HANDLE that contains the page number along
             with the handle to the EMF file
*/

{
    SPOOL_FILE_HANDLE *pSpoolFileHandle;
    PEMF_HANDLE  pEMF = NULL;

    pSpoolFileHandle = (SPOOL_FILE_HANDLE*) SpoolFileHandle;

    // first check to see if this is a valid handle by checking for the tag

    try
    {
        if(pSpoolFileHandle->tag != SPOOL_FILE_HANDLE_TAG)
        {
            WARNING("GdiGetPageHandle: invalid handle\n");
            return(FALSE);
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("GdiGetPageHandle: exception accessing handle\n");
        return(NULL);
    }

    if(!ProcessPages(pSpoolFileHandle, (UINT) Page))
    {
        return(NULL);
    }

    if (pEMF = (PEMF_HANDLE) LOCALALLOC(sizeof(EMF_HANDLE))) {

         pEMF->tag = EMF_HANDLE_TAG;
         pEMF->hemf = NULL;
         pEMF->bAllocBuffer = FALSE;
         pEMF->dwPageNumber = Page;

         if (pdwPageType) {
            switch (pSpoolFileHandle->pPageInfo[Page-1].ulID) {

            case EMRI_METAFILE:
            case EMRI_BW_METAFILE:

                 *pdwPageType = EMF_PP_NORMAL;
                 break;

            case EMRI_FORM_METAFILE:
            case EMRI_BW_FORM_METAFILE:

                 *pdwPageType = EMF_PP_FORM;
                 break;

            default:
                 // should not occur
                 *pdwPageType = 0;
                 break;
            }
         }

         // Save the handle in spoolfilehandle to be freed later
         pEMF->pNext = pSpoolFileHandle->pEMFHandle;
         pSpoolFileHandle->pEMFHandle = pEMF;

    } else {
         WARNING("GDI32 GdiGetPageHandle: out of memory\n");
    }

    return ((HANDLE) pEMF);
}

BOOL WINAPI GdiStartDocEMF(
    HANDLE      SpoolFileHandle,
    DOCINFOW    *pDocInfo)

/*
Function Description:
         GdiStartDocEMF performs the initializations required for before printing
         a document. It calls StartDoc and allocates memory to store data about the
         page layout. It also sets up the banding field in the SpoolFileHandle.

Parameters:
         SpoolFileHandle    -- handle returned by GdiGetSpoolFileHandle
         pDocInfo           -- pointer to DOCINFOW struct containing information of
                               the job. This struct is required for StartDoc.

Return Values:
         If the function succeeds, the return value is TRUE;
         otherwise the result is FALSE.

History:
         5/15/1997 by Ramanathan N Venkatapathy [ramanv] - Author
*/

{
   SPOOL_FILE_HANDLE *pSpoolFileHandle;

   pSpoolFileHandle = (SPOOL_FILE_HANDLE*) SpoolFileHandle;

   // first check to see if this is a valid handle by checking for the tag

   try
   {
       if(pSpoolFileHandle->tag != SPOOL_FILE_HANDLE_TAG)
       {
           WARNING("GdiStartDocEMF: invalid handle\n");
           return(FALSE);
       }
   }
   except(EXCEPTION_EXECUTE_HANDLER)
   {
       WARNING("GdiStartDocEMF: exception accessing handle\n");
       return(FALSE);
   }

   // Process Job data (before StartDoc)
   if (!ProcessJob(pSpoolFileHandle))
   {
        WARNING("StartDocW failed at ProcessJob\n");
        return(FALSE);
   }

   // StartDoc and get banding information
   if (StartDocEMF(pSpoolFileHandle->hdc,
                   pDocInfo,
                   &(pSpoolFileHandle->bBanding)) == SP_ERROR) {
        WARNING("StartDocW failed at StartDocEMF\n");
        return(FALSE);
   }

   pSpoolFileHandle->dwNumberOfPagesInCurrSide = 0;
   pSpoolFileHandle->dwNumberOfPagesAllocated = SPOOL_FILE_MAX_NUMBER_OF_PAGES_PER_SIDE;

   // Allocate memory for page layout
   if (!(pSpoolFileHandle->pPageLayout = LOCALALLOC(sizeof(PAGE_LAYOUT_STRUCT) *
                                              pSpoolFileHandle->dwNumberOfPagesAllocated))) {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        WARNING("GDI32 GdiStartDocEMF: out of memory\n");
        return(FALSE);
   }

   return(TRUE);

}

BOOL WINAPI GdiStartPageEMF(
    HANDLE       SpoolFileHandle)

/*
Function Description:
         GdiStartPageEMF performs the initializations required before printing
         a page.

Parameters:
         SpoolFileHandle    -- handle returned by GdiGetSpoolFileHandle

Return Values:
         If the function succeeds, the return value is TRUE;
         otherwise the result is FALSE.

History:
         5/15/1997 by Ramanathan N Venkatapathy [ramanv] - Author
*/

{
   SPOOL_FILE_HANDLE *pSpoolFileHandle;

   pSpoolFileHandle = (SPOOL_FILE_HANDLE*) SpoolFileHandle;

   // first check to see if this is a valid handle by checking for the tag
   try
   {
       if(pSpoolFileHandle->tag != SPOOL_FILE_HANDLE_TAG)
       {
           WARNING("GdiStartPageEMF: invalid handle\n");
           return(FALSE);
       }
   }
   except(EXCEPTION_EXECUTE_HANDLER)
   {
       WARNING("GdiStartPageEMF: exception accessing handle\n");
       return(FALSE);
   }

   return(TRUE);
}

BOOL WINAPI GdiPlayPageEMF(
    HANDLE       SpoolFileHandle,
    HANDLE       hEMF,
    RECT         *prectDocument,
    RECT         *prectBorder,
    RECT         *prectClip)

/*
Function Description:
         GdiPlayPageEMF allows the print processor to play any EMF page inside a
         specified rectangle. It also draws a border around the page, if one is specified.
         GdiPlayPageEMF saves all the information required for playing the page in the
         SpoolFileHandle. When GdiEndPageEMF is called to eject the current physical page,
         all the logical pages are played in the correct positions and the page is ejected.
         This delayed printing operation is used to enable n-up printing with banding.

Parameters:
         SpoolFileHandle    -- handle returned by GdiGetSpoolFileHandle
         hEMF               -- handle returned by GdiGetEMFFromSpoolHandle
         prectDocument      -- pointer to the RECT containing coordinates where
                               the page is to be played
         prectBorder        -- pointer to the RECT containing coordinates where
                               the border (if any) is to be drawn
         prectClip          -- pointer to the RECT containing coordinates where
                               the page is to clipped

Return Values:
         If the function succeeds, the return value is TRUE;
         otherwise the result is FALSE.

History:
         5/15/1997 by Ramanathan N Venkatapathy [ramanv] - Author
*/

{
   SPOOL_FILE_HANDLE  *pSpoolFileHandle;
   PAGE_LAYOUT_STRUCT *pPageLayout;
   PEMF_HANDLE         pEMF;
   LPBYTE              pBuffer = NULL;
   HANDLE              hFile = NULL;
   BOOL                bAllocBuffer = FALSE;
   ULONG               Size;
   LARGE_INTEGER       Offset;
   HENHMETAFILE        hEMFPage = NULL;
   DWORD               dwPageNumber;

   pEMF = (PEMF_HANDLE) hEMF;

   pSpoolFileHandle = (SPOOL_FILE_HANDLE*) SpoolFileHandle;

   // first check to see if this is a valid handle by checking for the tag

   try
   {
       if ((pSpoolFileHandle->tag != SPOOL_FILE_HANDLE_TAG) ||
           (pEMF->tag != EMF_HANDLE_TAG))
       {
           WARNING("GdiPlayPageEMF: invalid handle\n");
           return(FALSE);
       }

   }
   except(EXCEPTION_EXECUTE_HANDLER)
   {
       WARNING("GdiPlayPageEMF: exception accessing handle\n");
       return(FALSE);
   }

   dwPageNumber = pEMF->dwPageNumber;

   if (pEMF->hemf == NULL) {

       // Allocate the EMF handle
       Size = pSpoolFileHandle->pPageInfo[dwPageNumber-1].EMFSize;
       Offset.QuadPart = pSpoolFileHandle->pPageInfo[dwPageNumber-1].EMFOffset;

       // Use memory mapped read first and buffered next
       if (pSpoolFileHandle->bUseMemMap) {

          if ((*fpSeekPrinter) (pSpoolFileHandle->hSpooler, Offset, NULL, 0, FALSE) &&
              MemMapReadPrinter(pSpoolFileHandle->hSpooler, &pBuffer, Size)) {

               hEMFPage = SetEnhMetaFileBitsAlt((HLOCAL)pBuffer, NULL, NULL, 0);
          }
          else
          {
              WARNING("GdiPlayPageEMF() Failed to get memory map pointer to EMF\n");
          }
       }

       #define kTempSpoolFileThreshold  0x100000
       #define kScratchBufferSize       0x10000
       
       if (hEMFPage == NULL && Size > kTempSpoolFileThreshold) {

           // if larger then a meg, attempt create a temporary spool file
           // and copy the page to the spool file

           WARNING("GdiPlayPageEMF() Page size is large using temporary spool file\n");

           // If memory mapped read didnt work, dont try it again

           pSpoolFileHandle->bUseMemMap = FALSE;

           hFile = CreateTempSpoolFile();

           if(hFile)
           {
               if(fpSeekPrinter(pSpoolFileHandle->hSpooler, Offset, NULL, 0, FALSE))
               {
                   PVOID pvScratch = LocalAlloc(LMEM_FIXED, kScratchBufferSize);

                   if(pvScratch)
                   {
                       ULONG dwOffset = 0;
                       
                       while(dwOffset < Size)
                       {
                           ULONG    dwSize = MIN(kScratchBufferSize, (Size - dwOffset));
                           ULONG    dwBytesWritten;

                           if(!MyReadPrinter(pSpoolFileHandle->hSpooler, pvScratch, dwSize))
                           {
                               WARNING("GdiPlayPageEMF() Failed reading from spooler\n");
                               break;
                           }

                           if(!WriteFile(hFile, pvScratch, dwSize, &dwBytesWritten, NULL))
                           {
                               WARNING("GdiPlayPageEMF() Failed writing to temp spool file\n");
                               break;
                           }

                           if(dwBytesWritten != dwSize)
                           {
                               WARNING("GdiPlayPageEMF() Unexpected mismatch between attempted write size and actual\n");
                               break;
                           }

                           dwOffset += dwBytesWritten;
                       }

                       if(dwOffset == Size)
                       {
                           hEMFPage = SetEnhMetaFileBitsAlt(NULL, NULL, hFile, 0);

                           if(!hEMFPage)
                           {
                               WARNING("GdiPlayPageEMF() Failed creating EMF handle\n");
                           }
                       }

                       LocalFree(pvScratch);
                   }
                   else
                   {
                       WARNING("GdiPlayPageEMF() Failed creating scratch buffer\n");
                   }
               }
               else
               {
                   WARNING("GdiPlayPageEMF() Failed seeking spooler\n");
               }
                
               pBuffer = NULL;
               bAllocBuffer = TRUE;

           }

       }

       if (hEMFPage == NULL) {
           // If memory mapped read didnt work, dont try it again

           pSpoolFileHandle->bUseMemMap = FALSE;

           if ((pBuffer = (BYTE*) LocalAlloc(LMEM_FIXED, Size)) &&
               (*fpSeekPrinter)(pSpoolFileHandle->hSpooler, Offset, NULL, 0, FALSE) &&
               MyReadPrinter(pSpoolFileHandle->hSpooler, pBuffer, Size)) {

                hEMFPage = SetEnhMetaFileBitsAlt((HLOCAL)pBuffer, NULL, NULL, 0);
           }

           bAllocBuffer = TRUE;
       }
       
       // Check if the handle was created
       if (hEMFPage == NULL) {

          // Free resources and quit
          if (pBuffer && bAllocBuffer) {
             LocalFree(pBuffer);
          }

          if(hFile)
          {
              if(!CloseHandle(hFile))
              {
                  WARNING("GdiPlayPageEMF() Failed closing temp spool file handle\n");
              }
          }

          WARNING("GdiPlayPageEMF: Failed to Create EMF Handle\n");
          return FALSE;

       } else {

          // Save hEMFPage in pEMF struct for future calls to GdiPlayPageEMF
          pEMF->hemf = hEMFPage;
          pEMF->bAllocBuffer = bAllocBuffer;
       }
   }

   if (pSpoolFileHandle->dwNumberOfPagesInCurrSide >=
                     pSpoolFileHandle->dwNumberOfPagesAllocated) {

        PAGE_LAYOUT_STRUCT  *pTemp;

        if (pTemp = LOCALALLOC(sizeof(PAGE_LAYOUT_STRUCT) *
                               (pSpoolFileHandle->dwNumberOfPagesAllocated +
                                SPOOL_FILE_MAX_NUMBER_OF_PAGES_PER_SIDE))) {

           memcpy(pTemp,
                  pSpoolFileHandle->pPageLayout,
                  sizeof(PAGE_LAYOUT_STRUCT) * pSpoolFileHandle->dwNumberOfPagesAllocated);
           LocalFree(pSpoolFileHandle->pPageLayout);
           pSpoolFileHandle->pPageLayout = pTemp;
           pSpoolFileHandle->dwNumberOfPagesAllocated += SPOOL_FILE_MAX_NUMBER_OF_PAGES_PER_SIDE;

        } else {

           SetLastError(ERROR_NOT_ENOUGH_MEMORY);
           WARNING("GdiPlayPageEMF: out of memory\n");
           return(FALSE);
        }
   }

   // update the fields
   pPageLayout = &(pSpoolFileHandle->pPageLayout[pSpoolFileHandle->dwNumberOfPagesInCurrSide]);
   pPageLayout->hemf = pEMF->hemf;
   pPageLayout->bAllocBuffer = pEMF->bAllocBuffer;
   pPageLayout->dwPageNumber = pEMF->dwPageNumber;

   pPageLayout->rectDocument.top    = prectDocument->top;
   pPageLayout->rectDocument.bottom = prectDocument->bottom;
   pPageLayout->rectDocument.left   = prectDocument->left;
   pPageLayout->rectDocument.right  = prectDocument->right;

   // Set the border
   if (prectBorder) {
      pPageLayout->rectBorder.top    = prectBorder->top;
      pPageLayout->rectBorder.bottom = prectBorder->bottom;
      pPageLayout->rectBorder.left   = prectBorder->left;
      pPageLayout->rectBorder.right  = prectBorder->right;
   } else {
      pPageLayout->rectBorder.top    = -1; //invalid coordinates
      pPageLayout->rectBorder.bottom = -1; //invalid coordinates
      pPageLayout->rectBorder.left   = -1; //invalid coordinates
      pPageLayout->rectBorder.right  = -1; //invalid coordinates
   }

   // Set the clipping rectangle
   if (prectClip) {
      pPageLayout->rectClip.top    = prectClip->top;
      pPageLayout->rectClip.bottom = prectClip->bottom;
      pPageLayout->rectClip.left   = prectClip->left;
      pPageLayout->rectClip.right  = prectClip->right;
   } else {
      pPageLayout->rectClip.top    = -1; //invalid coordinates
      pPageLayout->rectClip.bottom = -1; //invalid coordinates
      pPageLayout->rectClip.left   = -1; //invalid coordinates
      pPageLayout->rectClip.right  = -1; //invalid coordinates
   }

   // Save the current transformation at the DC
   if (!GetWorldTransform(pSpoolFileHandle->hdc, &(pPageLayout->XFormDC))) {
       WARNING("GdiPlayPageEMF: GetWorldTransform failed\n");
       return(FALSE);
   }

   // increment the number of pages
   pSpoolFileHandle->dwNumberOfPagesInCurrSide += 1;

   return(TRUE);
}

BOOL WINAPI GdiPlayPrivatePageEMF(
    HANDLE       SpoolFileHandle,
    HENHMETAFILE hEnhMetaFile,
    RECT         *prectDocument)

/*
Function Description:
         GdiPlayPrivatePageEMF allows the print processor to play EMF pages other than the
         ones present in the spool file (like watermarks) inside a specified rectangle.

Parameters:
         SpoolFileHandle    -- handle returned by GdiGetSpoolFileHandle
         hEnhMetaFile       -- handle to an EMF which is to be played on the current physical
                               page
         prectDocument      -- pointer to the RECT containing coordinates where
                               the page is to be played

Return Values:
         If the function succeeds, the return value is TRUE;
         otherwise the result is FALSE.

History:
         6/15/1997 by Ramanathan N Venkatapathy [ramanv] - Author
*/

{
    EMF_HANDLE   hRecord;

    hRecord.tag          = EMF_HANDLE_TAG;
    hRecord.hemf         = hEnhMetaFile;
    hRecord.dwPageNumber = 0;                 // Invalid value
    hRecord.bAllocBuffer = FALSE;

    return GdiPlayPageEMF(SpoolFileHandle,
                          (HANDLE) &hRecord,
                          prectDocument,
                          NULL,
                          NULL);
}

BOOL InternalProcessEMFRecord(
     SPOOL_FILE_HANDLE    *pSpoolFileHandle,
     DWORD                dwPageNumber)

/*
Function Description:
         InternalProcessEMFRecord processes any EMF records that appear before the given
         EMF page which should be processed immediately before playing the page.

Parameters:
         pSpoolFileHandle  -- pointer to the SPOOL_FILE_HANDLE struct for the job.
         dwPageNumber      -- number of the page being played

Return Values:
         If the function succeeds, the return value is TRUE;
         otherwise the result is FALSE.

History:
         5/15/1997 by Ramanathan N Venkatapathy [ramanv] - Author
*/

{
     PRECORD_INFO_STRUCT  pRecordInfo;
     BYTE                 *pTmpBuffer = NULL;
     LARGE_INTEGER        liOffset;
     BOOL                 bReturn = FALSE;
     PEMFITEMPRESTARTPAGE pemfiPre;


     pRecordInfo = pSpoolFileHandle->pPageInfo[dwPageNumber-1].pRecordInfo;

     // loop thru all the records seen before the page
     while (pRecordInfo) {

        liOffset.QuadPart = pRecordInfo->RecordOffset;

        if (pTmpBuffer = (BYTE*) LOCALALLOC(pRecordInfo->RecordSize)) {

           if (!(*fpSeekPrinter) (pSpoolFileHandle->hSpooler,
                                  liOffset,
                                  NULL,
                                  FILE_BEGIN,
                                  FALSE)      ||
               !MyReadPrinter(pSpoolFileHandle->hSpooler,
                              pTmpBuffer,
                              pRecordInfo->RecordSize)) {

                WARNING("Gdi32:  error reading record\n");
                goto exit;
           }

        } else {

             WARNING("Out of memory in InternalProcessEMFRecord\n");
             goto exit;
        }

        switch (pRecordInfo->RecordID) {

        case EMRI_PRESTARTPAGE:

            MFD1("pre start page commands\n");

            pemfiPre = (PEMFITEMPRESTARTPAGE) pTmpBuffer;

            if (pemfiPre->bEPS & 1) {

                SHORT b = 1;

                MFD1("MFP_StartDocW calling bEpsPrinting\n");
                ExtEscape(pSpoolFileHandle->hdc, EPSPRINTING, sizeof(b),
                          (LPCSTR) &b, 0 , NULL );
            }

            break;

        // add cases for new records that must be processed before the page is played

        default:

            WARNING("unknown ITEM record\n");
            break;
        }

        LocalFree(pTmpBuffer);
        pTmpBuffer = NULL;
        pRecordInfo = pRecordInfo->pNext;
     }

     bReturn = TRUE;

exit:

     if (pTmpBuffer) {
         LocalFree(pTmpBuffer);
     }
     return bReturn;
}

BOOL InternalGdiPlayPageEMF(
     SPOOL_FILE_HANDLE    *pSpoolFileHandle,
     PAGE_LAYOUT_STRUCT   *pPageLayout,
     POINTL               *pptlOrigin,
     SIZE                 *pszSurface,
     BOOL                 bBanding)

/*
Function Description:
         InternalGdiPlayPageEMF plays the EMF file on the page and draws borders, if
         specified. It also performs initialization for GL records that may present in
         EMF file.

Parameters:
         pSpoolFileHandle  -- pointer to the SPOOL_FILE_HANDLE struct for the job
         pPageLayout       -- pointer to PAGE_LAYOUT_STRUCT which contains information
                              about playing the page
         pptlOrigin        -- pointer to a POINTL structure used for banding
         pszSurface        -- pointer to a SIZE structure used for banding
         bBanding          -- flag to indicate if banding is being used

Return Values:
         If the function succeeds, the return value is TRUE;
         otherwise the result is FALSE.

History:
         5/15/1997 by Ramanathan N Venkatapathy [ramanv] - Author

*/

{
     BOOL         bPrintGl, bReturn = FALSE;
     XFORM        OldXForm;
     POINTL       ptlOrigin;
     SIZE         szSurface;
     HPEN         hPen;
     GLPRINTSTATE gps;
     HDC          hPrinterDC = pSpoolFileHandle->hdc;
     RECT         *rectBorder = &(pPageLayout->rectBorder);
     RECT         *rectClip   = &(pPageLayout->rectClip);
     RECT         *rectBand = NULL;
     HRGN         hClipRgn = NULL;
     INT          indexDC = 0;

     if (bBanding) {
        // New structs created so that each page is played for the same band
        ptlOrigin.x = pptlOrigin->x;
        ptlOrigin.y = pptlOrigin->y;
        szSurface.cx = pszSurface->cx;
        szSurface.cy = pszSurface->cy;

        // Print only on the correct band
        SetViewportOrgEx(hPrinterDC, -ptlOrigin.x, -ptlOrigin.y, NULL);
     }

     // Process any PRESTARTPAGE records that appear immediately before this page
     if (pPageLayout->dwPageNumber > 0) {
        InternalProcessEMFRecord(pSpoolFileHandle, pPageLayout->dwPageNumber);
     }

     // Draw Page borders (if any)
     if (!((rectBorder->top    == -1) &&
           (rectBorder->bottom == -1) &&
           (rectBorder->right  == -1) &&
           (rectBorder->left   == -1)) &&
         ModifyWorldTransform(hPrinterDC, NULL, MWT_IDENTITY) &&
         (hPen = CreatePen(PS_SOLID, 1, 0x00000000))) {
        {
          HRGN hBandRgn = NULL;
          if (bBanding && !IsMetafileWithGl(pPageLayout->hemf))
          {
             ULONG ulRet,ulXRes,ulYRes;
             PERBANDINFO pbi;
             RECT *prect = &(pPageLayout->rectDocument);
             ulXRes = (ULONG)  prect->right - prect->left;
             ulYRes = (ULONG)  prect->bottom - prect->top;

             pbi.bRepeatThisBand = FALSE;
             pbi.ulHorzRes = ulXRes;
             pbi.ulVertRes = ulYRes;
             pbi.szlBand.cx = szSurface.cx;
             pbi.szlBand.cy = szSurface.cy;

             ulRet = NtGdiGetPerBandInfo(hPrinterDC,&pbi);

             if (ulRet && ulRet != GDI_ERROR && 
                  pbi.ulHorzRes == ulXRes && pbi.ulVertRes == ulYRes) 
             {
                hBandRgn = CreateRectRgn(0,0,pbi.szlBand.cx,pbi.szlBand.cy);
                if (hBandRgn)
                    SelectClipRgn(hPrinterDC, hBandRgn);
             }
          }

          MoveToEx(hPrinterDC, rectBorder->left, rectBorder->top, NULL);
          LineTo(hPrinterDC, rectBorder->right, rectBorder->top);
          MoveToEx(hPrinterDC, rectBorder->right, rectBorder->top, NULL);
          LineTo(hPrinterDC, rectBorder->right, rectBorder->bottom);
          MoveToEx(hPrinterDC, rectBorder->right, rectBorder->bottom, NULL);
          LineTo(hPrinterDC, rectBorder->left, rectBorder->bottom);
          MoveToEx(hPrinterDC, rectBorder->left, rectBorder->bottom, NULL);
          LineTo(hPrinterDC, rectBorder->left, rectBorder->top);
          DeleteObject(hPen);
          if (hBandRgn)
          {
             SelectClipRgn(hPrinterDC,NULL);
             DeleteObject(hBandRgn);
          }
	}
     }

     // Save the old transformation
     if (!GetWorldTransform(hPrinterDC, &OldXForm)) {
         WARNING("InternalGdiPlayEMFPage: GetWorldTransform failed\n");
         return FALSE;
     }

     // Set the new transformation
     if (!SetWorldTransform(hPrinterDC, &(pPageLayout->XFormDC))) {
         WARNING("InternalGdiPlayEMFPage: SetWorldTransform failed\n");
         goto CleanUp;
     }

     if (!((rectClip->top    == -1) &&
           (rectClip->bottom == -1) &&
           (rectClip->right  == -1) &&
           (rectClip->left   == -1))) {

         rectBand = rectClip;

         if (!bBanding) {

             // Set the clipping rectangle
             hClipRgn = CreateRectRgn(rectClip->left, rectClip->top,
                                      rectClip->right, rectClip->bottom);

             indexDC = SaveDC(hPrinterDC);

             if (!hClipRgn || !indexDC ||
                 (SelectClipRgn(hPrinterDC, hClipRgn) == ERROR)) {

                  WARNING("InternalGdiPlayEMFPage: SelectClipRgn failed\n");
                  goto CleanUp;
             }
         }
     }

     // Perform GL initialization if necessary
     bPrintGl = IsMetafileWithGl(pPageLayout->hemf);
     if (bPrintGl) {
        if (!InitGlPrinting(pPageLayout->hemf,
                            hPrinterDC,
                            &(pPageLayout->rectDocument),
                            pSpoolFileHandle->pLastDevmode,
                            &gps)) {

             WARNING("InternalGdiPlayEMFPage: InitGlPrinting failed\n");
             goto CleanUp;
        }
     }

     if (bBanding) {
        // call printing functions for banding case
        if (bPrintGl) {

            SetViewportOrgEx(hPrinterDC, -ptlOrigin.x, -ptlOrigin.y, NULL);
            PrintMfWithGl(pPageLayout->hemf, &gps, &ptlOrigin, &szSurface);
            EndGlPrinting(&gps);

        } else {


           PrintBand( hPrinterDC,
                      pPageLayout->hemf,
                      &ptlOrigin,
                      &(pPageLayout->rectDocument),
                      &szSurface,
                      rectBand );
        }

     } else {

        // call priting functions for non-banding case
        if (bPrintGl) {
            PrintMfWithGl(pPageLayout->hemf, &gps, NULL, NULL);
            EndGlPrinting(&gps);
        } else {
            PlayEnhMetaFile( hPrinterDC, pPageLayout->hemf, &(pPageLayout->rectDocument) );
        }

     }

     bReturn = TRUE;

CleanUp:

     // Restore the old clipping region
     if (indexDC) {
         RestoreDC(hPrinterDC, indexDC);
     }

     // Reset the world transformation
     if (!SetWorldTransform(hPrinterDC, &OldXForm)) {
         WARNING("InternalGdiPlayEMFPage: SetWorldTransform failed\n");
         bReturn = FALSE;
     }

     // Delete the clipping region
     if (hClipRgn) {
         DeleteObject(hClipRgn);
     }

     return bReturn;
}


BOOL AddTempNode(
    PEMF_LIST     *ppHead,
    HENHMETAFILE  hemf,
    BOOL          bAllocBuffer)

/*
Function Description:
         AddTempNode adds a EMF handle to a list that does not contain duplicates.
         This list is used for deleting the handles later.

Parameters:
         ppHead  - pointer to the start of the list
         hemf    - handle to EMF to be added to the list
         bAllocBuffer - flag indicating if buffer was allocated for hemf

Return Values:
         If the function succeeds, the return value is TRUE;
         otherwise the result is FALSE.

History:
         7/7/1997 by Ramanathan N Venkatapathy [ramanv] - Author
*/

{
    BOOL      bReturn = FALSE;
    PEMF_LIST pTemp;

    for (pTemp = *ppHead; pTemp; ppHead = &(pTemp->pNext), pTemp = *ppHead) {
       if (pTemp->hemf == hemf) {
          return TRUE;
       }
    }

    if (!(pTemp = (PEMF_LIST) LOCALALLOC(sizeof(EMF_LIST)))) {
       return FALSE;
    }

    pTemp->hemf = hemf;
    pTemp->bAllocBuffer = bAllocBuffer;
    pTemp->pNext = NULL;
    *ppHead = pTemp;

    return TRUE;
}

VOID RemoveFromSpoolFileHandle(
    SPOOL_FILE_HANDLE  *pSpoolFileHandle,
    HENHMETAFILE hemf)

/*
Function Description:
         The EMF handles that are played get deleted at the end of the page (GdiEndPageEMF).
         The rest of the handles are deleted in the cleanup routine (GdiDeleteSpoolFileHandle).
         These are handles are listed in pSpoolFileHandle->pEMFHandle. RemoveFromSpoolFileHandle
         removes deleted handles from this list, to avoid freeing the handles twice.

Parameters:
         pSpoolFileHandle   -- pointer to the SPOOL_FILE_HANDLE
         hemf               -- Handle to EMF that is going to be deleted

Return Values:
         NONE

History:
         9/18/1997 by Ramanathan N Venkatapathy [ramanv] - Author
*/
{
    PEMF_HANDLE pTemp;

    for (pTemp = pSpoolFileHandle->pEMFHandle; pTemp; pTemp = pTemp->pNext) {
         if (pTemp->hemf == hemf) {
             pTemp->hemf = NULL;
         }
    }

    return;
}

BOOL SetColorOptimization(
    SPOOL_FILE_HANDLE  *pSpoolFileHandle,
    DWORD              dwOptimization)

/*
Function Description:
         SetColorOptimization examines the page types on the next physical page and
         sets the device context to take advantage of monochrome pages.

Parameters:
         pSpoolFileHandle   -- pointer to the SPOOL_FILE_HANDLE
         dwOptimization     -- flag indicating optimizations to be performed

Return Values:
         TRUE if successful; FALSE otherwise

History:
         9/23/1997 by Ramanathan N Venkatapathy [ramanv] - Author
*/

{
    BOOL   bReturn = TRUE, bFoundColor = FALSE, bReset;
    short  dmColor;
    DWORD  dmFields, dwIndex, dwPageNumber, dwRecordID;
    PAGE_LAYOUT_STRUCT *pPageLayout;

    // Dont process for monochrome detection if the optimization is not
    // applied
    if (!(dwOptimization & EMF_PP_COLOR_OPTIMIZATION)) {
        return TRUE;
    }

    // Search for color in the pages on the current physical page
    for (dwIndex = 0, pPageLayout = pSpoolFileHandle->pPageLayout;
         dwIndex < pSpoolFileHandle->dwNumberOfPagesInCurrSide;
         ++dwIndex, ++pPageLayout)
    {
        dwPageNumber = pPageLayout->dwPageNumber;
        dwRecordID = pSpoolFileHandle->pPageInfo[dwPageNumber-1].ulID;

        if ((dwRecordID == EMRI_METAFILE) ||
            (dwRecordID == EMRI_FORM_METAFILE)) {

            bFoundColor = TRUE;
            break;
        }
    }

    // Determine if the status has to changed
    bReset = (bFoundColor && (pSpoolFileHandle->dwPlayBackStatus == EMF_PLAY_MONOCHROME)) ||
             (!bFoundColor && (pSpoolFileHandle->dwPlayBackStatus == EMF_PLAY_COLOR));

    if (bReset) {
        // Save the old settings
        dmFields = pSpoolFileHandle->pLastDevmode->dmFields;
        dmColor  = pSpoolFileHandle->pLastDevmode->dmColor;

        pSpoolFileHandle->pLastDevmode->dmFields |= DM_COLOR;
        pSpoolFileHandle->pLastDevmode->dmColor  = bFoundColor ? DMCOLOR_COLOR
                                                               : DMCOLOR_MONOCHROME;

        // Reset the DC and set graphics mode
        bReturn = ResetDCWInternal(pSpoolFileHandle->hdc,
                                   pSpoolFileHandle->pLastDevmode,
                                   &(pSpoolFileHandle->bBanding))      &&
                  SetGraphicsMode(pSpoolFileHandle->hdc, GM_ADVANCED);

        // Restore old settings and update status
        pSpoolFileHandle->pLastDevmode->dmFields = dmFields;
        pSpoolFileHandle->pLastDevmode->dmColor = dmColor;
        pSpoolFileHandle->dwPlayBackStatus = bFoundColor ? EMF_PLAY_COLOR
                                                         : EMF_PLAY_MONOCHROME;
    }

    return bReturn;
}

BOOL WINAPI GdiEndPageEMF(
    HANDLE     SpoolFileHandle,
    DWORD      dwOptimization)

/*
Function Description:
         GdiEndPageEMF completes printing on the current page and ejects it. It
         loops thru the different bands while printing the page. GdiEndPageEMF also
         frees up the buffers allocated for the emf handle.

Parameters:
         SpoolFileHandle    -- handle returned by GdiGetSpoolFileHandle
         dwOptimization     -- flag color optimizations. To be extended for copies

Return Values:
         If the function succeeds, the return value is TRUE;
         otherwise the result is FALSE.

History:
         5/15/1997 by Ramanathan N Venkatapathy [ramanv] - Author
*/

{
   SPOOL_FILE_HANDLE  *pSpoolFileHandle;
   DWORD              dwIndex;
   PAGE_LAYOUT_STRUCT *pPageLayout;
   BOOL               bReturn = FALSE;
   PEMF_LIST          pTemp, pHead = NULL;

   pSpoolFileHandle = (SPOOL_FILE_HANDLE*) SpoolFileHandle;

   // first check to see if this is a valid handle by checking for the tag
   try
   {
       if(pSpoolFileHandle->tag != SPOOL_FILE_HANDLE_TAG)
       {
           WARNING("GdiEndPageEMF: invalid handle\n");
           return(FALSE);
       }
   }
   except(EXCEPTION_EXECUTE_HANDLER)
   {
       WARNING("GdiEndPageEMF: exception accessing handle\n");
       return(FALSE);
   }

   if (!SetColorOptimization(pSpoolFileHandle, dwOptimization)) {
       WARNING("GdiEndPageEMF: Color optimizations failed\n");
   }

   if (!StartPage(pSpoolFileHandle->hdc)) {
       WARNING("GdiEndPageEMF: StartPage failed\n");
       return(FALSE);
   }

   if (pSpoolFileHandle->bBanding) {

        // for opengl optimization
        POINTL ptlOrigin;
        SIZE szSurface;

        // initialize for banding
        if (!StartBanding( pSpoolFileHandle->hdc, &ptlOrigin, &szSurface )) {
           goto CleanUp;
        }

        // loop till all the bands are printed
        do {
           for (dwIndex = 0, pPageLayout = pSpoolFileHandle->pPageLayout;
                dwIndex < pSpoolFileHandle->dwNumberOfPagesInCurrSide;
                ++dwIndex, ++pPageLayout) {

               if (!InternalGdiPlayPageEMF(pSpoolFileHandle,
                                           pPageLayout,
                                           &ptlOrigin,
                                           &szSurface,
                                           TRUE)) {
                   WARNING("GdiEndPageEMF: InternalGdiPlayEMFPage failed");
                   goto CleanUp;
               }
           }

           if (!NextBand(pSpoolFileHandle->hdc, &ptlOrigin)) {
               WARNING("GdiEndPageEMF: NextBand failed\n");
               goto CleanUp;
           }

        } while (ptlOrigin.x != -1);

   } else {
        for (dwIndex = 0, pPageLayout = pSpoolFileHandle->pPageLayout;
             dwIndex < pSpoolFileHandle->dwNumberOfPagesInCurrSide;
             ++dwIndex, ++pPageLayout) {

               if (!InternalGdiPlayPageEMF(pSpoolFileHandle,
                                           pPageLayout,
                                           NULL,
                                           NULL,
                                           FALSE)) {
                   WARNING("GdiEndPageEMF: InternalGdiPlayEMFPage failed");
                   goto CleanUp;
               }
        }
   }

   bReturn = TRUE;

CleanUp:

   // eject the current page
   if (!EndPage(pSpoolFileHandle->hdc)) {
       WARNING("GdiEndPageEMF: EndPage failed\n");
       bReturn = FALSE;
   }

   // free the emf handles
   for (dwIndex = 0, pPageLayout = pSpoolFileHandle->pPageLayout;
        dwIndex < pSpoolFileHandle->dwNumberOfPagesInCurrSide;
        ++dwIndex, ++pPageLayout) {

         AddTempNode(&pHead, pPageLayout->hemf, pPageLayout->bAllocBuffer);
   }

   while (pTemp = pHead) {
      pHead = pHead->pNext;
      RemoveFromSpoolFileHandle(pSpoolFileHandle, pTemp->hemf);
      InternalDeleteEnhMetaFile(pTemp->hemf, pTemp->bAllocBuffer);
      LocalFree(pTemp);
   }

   // reset the number of logical pages for the next physical page
   pSpoolFileHandle->dwNumberOfPagesInCurrSide = 0;

   return bReturn;
}

BOOL WINAPI GdiEndDocEMF(
    HANDLE SpoolFileHandle)

/*
Function Description:
         GdiEndDocEMF completes printing the current document. GdiEndPageEMF is called
         if the last physical page was not ejected. Some of the resources associated with
         printing of the document are released.

Parameters:
         SpoolFileHandle    -- handle returned by GdiGetSpoolFileHandle

Return Values:
         If the function succeeds, the return value is TRUE;
         otherwise the result is FALSE.

History:
         5/15/1997 by Ramanathan N Venkatapathy [ramanv] - Author
*/

{
   SPOOL_FILE_HANDLE *pSpoolFileHandle;

   pSpoolFileHandle = (SPOOL_FILE_HANDLE*) SpoolFileHandle;

   // first check to see if this is a valid handle by checking for the tag

   try
   {
       if(pSpoolFileHandle->tag != SPOOL_FILE_HANDLE_TAG)
       {
           WARNING("GdiEndDocEMF: invalid handle\n");
           return(FALSE);
       }
   }
   except(EXCEPTION_EXECUTE_HANDLER)
   {
       WARNING("GdiEndDocEMF: exception accessing handle\n");
       return(FALSE);
   }

   // call GdiEndPageEMF if the last physical page was not ejected
   if (pSpoolFileHandle->dwNumberOfPagesInCurrSide) {
      GdiEndPageEMF(SpoolFileHandle,0);
   }

   EndDoc(pSpoolFileHandle->hdc);

   // free the memory used for saving the page layouts
   LOCALFREE(pSpoolFileHandle->pPageLayout);
   pSpoolFileHandle->pPageLayout = NULL;

   return TRUE;
}

BOOL WINAPI GdiGetDevmodeForPage(
    HANDLE     SpoolFileHandle,
    DWORD      dwPageNumber,
    PDEVMODEW  *pCurrDM,
    PDEVMODEW  *pLastDM)

/*
Function Description:
         GdiGetDevmodeForPage allows the print processor to retrieve the last devmode
         set at the printer device context and the last devmode that appears before
         any given page. If the 2 devmodes are different the print processor has to
         call GdiResetDCEMF with the current devmode. However since ResetDC can be called
         only at page boundaries, the print processor must end printing on the current
         page before calling GdiResetDCEMF. GdiEndPageEMF allows the print processor to
         complete printing on the current physical page.

Parameters:
         SpoolFileHandle    -- handle returned by GdiGetSpoolFileHandle
         dwPageNumber       -- page number for which the devmode is sought
         *pCurrDM           -- buffer to store the pointer to the devmode for the page
         *pLastDM           -- buffer to store the pointer to the last devmode used in
                               ResetDC

Return Values:
         If the function succeeds, the return value is TRUE;
         otherwise the result is FALSE.

History:
         5/15/1997 by Ramanathan N Venkatapathy [ramanv] - Author
*/

{
   SPOOL_FILE_HANDLE *pSpoolFileHandle;

   pSpoolFileHandle = (SPOOL_FILE_HANDLE*) SpoolFileHandle;

   // first check to see if this is a valid handle by checking for the tag

   try
   {
      if(pSpoolFileHandle->tag != SPOOL_FILE_HANDLE_TAG)
      {
         WARNING("GdiGetDevmodeForPage: invalid handle\n");
         return(FALSE);
      }
   }
   except(EXCEPTION_EXECUTE_HANDLER)
   {
      WARNING("GdiGetDevmodeForPage: exception accessing handle\n");
      return(FALSE);
   }

   // process the spool file till the required page is found
   if(!ProcessPages(pSpoolFileHandle, (UINT)dwPageNumber))
   {
       WARNING("GdiGetDevmodeForPage: ProcessPages failed\n");
       return(FALSE);
   }

   // return the pointers in the buffers
   if (pCurrDM) {
      *pCurrDM = pSpoolFileHandle->pPageInfo[dwPageNumber-1].pDevmode;
   }
   if (pLastDM) {
      *pLastDM = pSpoolFileHandle->pLastDevmode;
   }
   return(TRUE);

}

BOOL WINAPI GdiResetDCEMF(
    HANDLE    SpoolFileHandle,
    PDEVMODEW pCurrDM)

/*
Function Description:
         GdiResetDCEMF should be use to reset the printer device context with a new
         devmode. The memory for the devmode will be released by GDI.

Parameters:
         SpoolFileHandle    -- handle returned by GdiGetSpoolFileHandle
         pCurrDM            -- pointer to the devmode that was used in the last ResetDC
                               call by the print processor

Return Values:
         If the function succeeds, the return value is TRUE;
         otherwise the result is FALSE.

History:
         5/15/1997 by Ramanathan N Venkatapathy [ramanv] - Author
*/

{
   SPOOL_FILE_HANDLE *pSpoolFileHandle;
   BOOL  bReturn;

   pSpoolFileHandle = (SPOOL_FILE_HANDLE*) SpoolFileHandle;

   // first check to see if this is a valid handle by checking for the tag
   try
   {
       if(pSpoolFileHandle->tag != SPOOL_FILE_HANDLE_TAG)
       {
           WARNING("GdiResetDCEMF: invalid handle\n");
           return(FALSE);
       }
   }
   except(EXCEPTION_EXECUTE_HANDLER)
   {
       WARNING("GdiResetDCEMF: exception accessing handle\n");
       return(FALSE);
   }

   if (pCurrDM &&
       ResetDCWInternal(pSpoolFileHandle->hdc,
                        pCurrDM,
                        &(pSpoolFileHandle->bBanding)))
   {
        // set the last devmode in the SpoolFileHandle
        pSpoolFileHandle->pLastDevmode = pCurrDM;
        bReturn = TRUE;
   }
   else
   {
        bReturn = FALSE;
   }

   if (pCurrDM && (pCurrDM->dmFields & DM_COLOR)) {

       if (pCurrDM->dmColor == DMCOLOR_COLOR) {
           pSpoolFileHandle->dwPlayBackStatus = EMF_PLAY_COLOR;
       } else {
           pSpoolFileHandle->dwPlayBackStatus = EMF_PLAY_FORCE_MONOCHROME;
       }
   }

   return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\poly.c ===
/******************************Module*Header*******************************\
* Module Name: poly.c                                                      *
*                                                                          *
* Chunks large data to the server.                                         *
*                                                                          *
* Created: 30-May-1991 14:22:40                                            *
* Author: Eric Kutter [erick]                                              *
*                                                                          *
* Copyright (c) 1991-1999 Microsoft Corporation                            *
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

/******************************Public*Routine******************************\
* PolyPolygon                                                              *
* PolyPolyline                                                             *
* Polygon                                                                  *
* Polyline                                                                 *
* PolyBezier                                                               *
* PolylineTo                                                               *
* PolyBezierTo                                                             *
*                                                                          *
* Output routines that call PolyPolyDraw to do the work.                   *
*                                                                          *
* History:                                                                 *
*  Thu 20-Jun-1991 01:08:40 -by- Charles Whitmer [chuckwh]                 *
* Added metafiling, handle translation, and the attribute cache.           *
*                                                                          *
*  04-Jun-1991 -by- Eric Kutter [erick]                                    *
* Wrote it.                                                                *
\**************************************************************************/

BOOL WINAPI PolyPolygon(HDC hdc, CONST POINT *apt, CONST INT *asz, int csz)
{
    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return (MF16_PolyPolygon(hdc, apt, asz, csz));

        DC_PLDC(hdc,pldc,FALSE);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_PolyPoly(hdc, apt, asz, (DWORD) csz,EMR_POLYPOLYGON))
                return(FALSE);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(FALSE);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    return (BOOL)
      NtGdiPolyPolyDraw
      (
        hdc,
        (PPOINT)apt,
        (LPINT)asz,
        csz,
        I_POLYPOLYGON
      );

}

BOOL WINAPI PolyPolyline(HDC hdc, CONST POINT *apt, CONST DWORD *asz, DWORD csz)
{
    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(FALSE);

        DC_PLDC(hdc,pldc,FALSE);

        if (pldc->iType == LO_METADC && !MF_PolyPoly(hdc,apt, asz, csz, EMR_POLYPOLYLINE))
            return(FALSE);

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(FALSE);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    return (BOOL)
      NtGdiPolyPolyDraw
      (
        hdc,
        (PPOINT)apt,
        (LPINT)asz,
        csz,
        I_POLYPOLYLINE
      );
}

BOOL WINAPI Polygon(HDC hdc, CONST POINT *apt,int cpt)
{
    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParmsPoly(hdc,(LPPOINT)apt,(INT)cpt,META_POLYGON));

        DC_PLDC(hdc,pldc,FALSE);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_Poly(hdc,apt,cpt,EMR_POLYGON))
                return(FALSE);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(FALSE);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    return (BOOL)
      NtGdiPolyPolyDraw
      (
        hdc,
        (PPOINT)apt,
        &cpt,
        1,
        I_POLYPOLYGON
      );
}

BOOL WINAPI Polyline(HDC hdc, CONST POINT *apt,int cpt)
{
    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParmsPoly(hdc,(LPPOINT)apt,cpt,META_POLYLINE));

        DC_PLDC(hdc,pldc,FALSE);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_Poly(hdc,apt,cpt,EMR_POLYLINE))
                return(FALSE);
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(FALSE);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    return (BOOL)
      NtGdiPolyPolyDraw
      (
        hdc,
        (PPOINT)apt,
        &cpt,
        1,
        I_POLYPOLYLINE
      );

}

BOOL WINAPI PolyBezier(HDC hdc, CONST POINT * apt,DWORD cpt)
{
    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(FALSE);

        DC_PLDC(hdc,pldc,FALSE);

        if (pldc->iType == LO_METADC && !MF_Poly(hdc,apt,cpt,EMR_POLYBEZIER))
            return(FALSE);

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(FALSE);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    return (BOOL)
      NtGdiPolyPolyDraw
      (
        hdc,
        (PPOINT)apt,
        (LPINT)&cpt,
        1,
        I_POLYBEZIER
      );
}

BOOL WINAPI PolylineTo(HDC hdc, CONST POINT * apt,DWORD cpt)
{
    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(FALSE);

        DC_PLDC(hdc,pldc,FALSE);

        if (pldc->iType == LO_METADC && !MF_Poly(hdc,apt,cpt,EMR_POLYLINETO))
            return(FALSE);

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(FALSE);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    return (BOOL)
      NtGdiPolyPolyDraw
      (
        hdc,
        (PPOINT)apt,
        (LPINT)&cpt,
        1,
        I_POLYLINETO
      );

}

BOOL WINAPI PolyBezierTo(HDC hdc, CONST POINT * apt,DWORD cpt)
{
    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(FALSE);

        DC_PLDC(hdc,pldc,FALSE);

        if (pldc->iType == LO_METADC && !MF_Poly(hdc,apt,cpt,EMR_POLYBEZIERTO))
            return(FALSE);

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(FALSE);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    return (BOOL)
      NtGdiPolyPolyDraw
      (
        hdc,
        (PPOINT)apt,
        (LPINT)&cpt,
        1,
        I_POLYBEZIERTO
      );
}

/******************************Public*Routine******************************\
* CreatePolygonRgn                                                         *
*                                                                          *
* Client side stub.  Creates a local region handle, calls PolyPolyDraw to  *
* pass the call to the server.                                             *
*                                                                          *
*  Tue 04-Jun-1991 17:39:51 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HRGN WINAPI CreatePolygonRgn
(
    CONST POINT *pptl,
    int        cPoint,
    int        iMode
)
{
    LONG_PTR Mode = iMode;

    return((HRGN)
      NtGdiPolyPolyDraw
      (
        (HDC)Mode,
        (PPOINT)pptl,
        &cPoint,
        1,
        I_POLYPOLYRGN
      ));
}

/******************************Public*Routine******************************\
* CreatePolyPolygonRgn                                                     *
*                                                                          *
* Client side stub.  Creates a local region handle, calls PolyPolyDraw to  *
* pass the call to the server.                                             *
*                                                                          *
*  Tue 04-Jun-1991 17:39:51 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HRGN WINAPI CreatePolyPolygonRgn
(
    CONST POINT *pptl,
    CONST INT   *pc,
    int        cPoly,
    int        iMode
)
{
    LONG_PTR Mode = iMode;

    return((HRGN)
      NtGdiPolyPolyDraw
      (
        (HDC)Mode,
        (PPOINT)pptl,
        (LPINT)pc,
        cPoly,
        I_POLYPOLYRGN
      ));

}

/******************************Public*Routine******************************\
* PolyDraw
*
* The real PolyDraw client side stub.
*
*  13-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL WINAPI PolyDraw(HDC hdc, CONST POINT * apt, CONST BYTE * aj, int cpt)
{
    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(FALSE);

        DC_PLDC(hdc,pldc,FALSE);

        if (pldc->iType == LO_METADC && !MF_PolyDraw(hdc,apt,aj,cpt))
            return(FALSE);

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return(FALSE);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    return((BOOL)NtGdiPolyDraw(hdc,(PPOINT)apt,(PBYTE)aj,cpt));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\script.c ===
/******************************Module*Header*******************************\
* Module Name: script.c
*
* (Brief description)
*
* Created: 13-Mar-1992 09:57:12
* Author:  Eric Kutter [erick]
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
* (General description of its use)
*
* Dependencies:
*
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

/******************************Member*Function*****************************\
* GdiPlayScript()
*
* History:
*  13-Mar-1992 Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL GdiPlayScript(
    PULONG pulScript,
    ULONG  cjScript,
    PULONG pulEnv,
    ULONG  cjEnv,
    PULONG pulOutput,
    ULONG  cjOutput,
    ULONG  cLimit)
{
    pulScript;
    cjScript;
    pulEnv;
    cjEnv;
    pulOutput;
    cjOutput;
    cLimit;

    return(FALSE);
}

/******************************Public*Routine******************************\
* OpenRemoteGdi()
*
* History:
*  13-Mar-1992 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL GdiPlayDCScript(
    HDC    hdc,
    PULONG pulScript,
    ULONG  cjScript,
    PULONG pulOutput,
    ULONG  cjOutput,
    ULONG  cLimit)
{
    hdc;
    pulScript;
    cjScript;
    pulOutput;
    cjOutput;
    cLimit;

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\region.c ===
/******************************Module*Header*******************************\
* Module Name: region.c
*
*   Client region support
*
* Created: 15-Jun-1995
* Author: Mark Enstrom [marke]
*
* Copyright (c) 1995-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

void OrderRects(LPRECT lpR, int nRects)
{
    RECT R;
    int i,j;

//Sort Left to right
    for (i=0; i<nRects; i++){
        for (j=i+1; (j<nRects) && ((lpR+j)->top == (lpR+i)->top); j++){
            if (((lpR+j)->left < (lpR+i)->left)) {
                R = *(lpR+i);
                *(lpR+i) = *(lpR+j);
                *(lpR+j) = R;
            }
        }
    }

}

/******************************Public*Routine******************************\
* MirrorRgnByWidth
*  Mirror a region (hrgn) according a specific width (cx)
*  hrgn  : region to get mirrored.
*  cx    : width used to mirror the region.
*  phrgn : If it is not NULL the hrgn will not be touched and the new mirrored 
             region will be returned in phrgn
*          But if it is NULL the mirrored region will be copied to hrgn.
*
* WORRNING:
*          if phrng is not NULL it is the caller responsibility to free *phrgn latter.
*           
* returns:
*  TRUE  : if the region get mirrored
*  FALSE : otherwise.   
*  See the comment about phrng.
*
\**************************************************************************/
BOOL MirrorRgnByWidth(HRGN hrgn, int cx, HRGN *phrgn)
{
    int        nRects, i, nDataSize;
    HRGN       hrgn2 = NULL;
    RECT       *lpR;
    int        Saveleft;
    RGNDATA    *lpRgnData;
    BOOL       bRet = FALSE;

    nDataSize = GetRegionData(hrgn, 0, NULL);
    if (nDataSize && (lpRgnData = (RGNDATA *)LocalAlloc(0, nDataSize * sizeof(DWORD)))) {
        if (GetRegionData(hrgn, nDataSize, lpRgnData)) {
            nRects       = lpRgnData->rdh.nCount;
            lpR          = (RECT *)lpRgnData->Buffer;

            Saveleft                     = lpRgnData->rdh.rcBound.left;
            lpRgnData->rdh.rcBound.left  = cx - lpRgnData->rdh.rcBound.right;
            lpRgnData->rdh.rcBound.right = cx - Saveleft;


            for (i=0; i<nRects; i++){
                Saveleft   = lpR->left;
                lpR->left  = cx - lpR->right;
                lpR->right = cx - Saveleft;

                lpR++;
            }

            OrderRects((RECT *)lpRgnData->Buffer, nRects);
            hrgn2 = ExtCreateRegion(NULL, nDataSize, lpRgnData);
            if (hrgn2) {
                if (phrgn == NULL) {
                    CombineRgn(hrgn, hrgn2, NULL, RGN_COPY);
                    DeleteObject((HGDIOBJ)hrgn2);
                } else {
                    *phrgn = hrgn2;
                }

                bRet = TRUE;
            }
        }

        //Free mem.
        LocalFree(lpRgnData);
    }
    return bRet;
}

BOOL
WINAPI
MirrorRgn(HWND hwnd, HRGN hrgn)
{
    RECT       rc;

    GetWindowRect(hwnd, &rc);
    rc.right -= rc.left;
    return MirrorRgnByWidth(hrgn, rc.right, NULL);
}

BOOL
MirrorRgnDC(HDC hdc, HRGN hrgn, HRGN *phrgn)
{
    FIXUP_HANDLE(hdc);
    if(!IS_ALTDC_TYPE(hdc))
    {
        PDC_ATTR pdcattr;
        PSHARED_GET_VALIDATE((PVOID)pdcattr,hdc,DC_TYPE);

        if (pdcattr) {
            return MirrorRgnByWidth(hrgn, NtGdiGetDeviceWidth(hdc), phrgn);
        }
    }
    return FALSE;
}

/******************************Public*Routine******************************\
* iRectRelation
*
* returns:
*   CONTAINS where  prcl1 contains prcl2
*   CONTAINED where prcl1 contained by prcl2
*   0 - otherwise
*
* History:
*  19-Nov-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int
iRectRelation(
    PRECTL prcl1,
    PRECTL prcl2
    )
{
    int iRet = 0;

    if ((prcl1->left   <= prcl2->left)  &&
        (prcl1->right  >= prcl2->right) &&
        (prcl1->top    <= prcl2->top)   &&
        (prcl1->bottom >= prcl2->bottom))
    {
        iRet = CONTAINS;
    }
    else if (
        (prcl2->left   <= prcl1->left)  &&
        (prcl2->right  >= prcl1->right) &&
        (prcl2->top    <= prcl1->top)   &&
        (prcl2->bottom >= prcl1->bottom))
    {
        iRet = CONTAINED;
    }
    else if (
        (prcl1->left   >= prcl2->right)  ||
        (prcl1->right  <= prcl2->left)   ||
        (prcl1->top    >= prcl2->bottom) ||
        (prcl1->bottom <= prcl2->top))
    {
        iRet = DISJOINT;
    }
    return(iRet);
}

/******************************Public*Routine******************************\
*
*  CreateRectRgn gets an hrgn with user-mode PRGNATTR pointer and
*  sets the type to SIMPLEREGION.
*
* Arguments:
*
*  x1
*  y1
*  x2
*  y2
*
* Return Value:
*
*  HRGN or NULL
*
* History:
*
*    15-Jun-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

#define MIN_REGION_COORD    ((LONG) 0xF8000000)
#define MAX_REGION_COORD    ((LONG) 0x07FFFFFF)

HRGN
WINAPI
CreateRectRgn(
    int x1,
    int y1,
    int x2,
    int y2
    )
{
    //
    // get a region handle, allocate memory for the
    // region and associate handle with memory
    //

    PRGNATTR prRegion;
    HRGN hrgn;

    //
    // rectangle must be ordered
    //

    #if NOREORDER_RGN

        if ((x1 > x2) || (y1 > y2))
        {
            WARNING("CreateRectRgn called with badly ordered region");

            x1 = 0;
            x2 = 0;
            y1 = 0;
            y2 = 0;
        }

    #else

        if (x1 > x2)
        {
            int t = x1;
            x1 = x2;
            x2 = t;
        }

        if (y1 > y2)
        {
            int t = y1;
            y1 = y2;
            y2 = t;
        }

    #endif

    //
    // make sure ordered coordinates are legal
    //

    if ((x1 < MIN_REGION_COORD) ||
        (y1 < MIN_REGION_COORD) ||
        (x2 > MAX_REGION_COORD) ||
        (y2 > MAX_REGION_COORD))
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return((HRGN) 0);
    }

    //
    // get a handle for the new region
    //

    hrgn = (HRGN)hGetPEBHandle(RegionHandle,0);

    if (hrgn == NULL)
    {
        hrgn = NtGdiCreateRectRgn(0,0,1,1);
    }

    PSHARED_GET_VALIDATE(prRegion,hrgn,RGN_TYPE);

    if (prRegion)
    {
        if ((x1 == x2) || (y1 == y2))
        {
            prRegion->Flags = NULLREGION;

            prRegion->Rect.left   = 0;
            prRegion->Rect.top    = 0;
            prRegion->Rect.right  = 0;
            prRegion->Rect.bottom = 0;
        }
        else
        {
            prRegion->Flags = SIMPLEREGION;

            //
            // assign region rectangle
            //

            prRegion->Rect.left   = x1;
            prRegion->Rect.top    = y1;
            prRegion->Rect.right  = x2;
            prRegion->Rect.bottom = y2;
        }

        //
        // mark user-mode region as valid, not cached
        //

        prRegion->AttrFlags = ATTR_RGN_VALID | ATTR_RGN_DIRTY;
    }
    else
    {
        if (hrgn != NULL)
        {
            WARNING("Shared hrgn handle has no valid PRGNATTR");
            DeleteRegion(hrgn);
            hrgn = NULL;
        }
    }

    return(hrgn);
}

/******************************Public*Routine******************************\
* CreateRectRgnIndirect                                                    *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Tue 04-Jun-1991 16:58:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HRGN WINAPI CreateRectRgnIndirect(CONST RECT *prcl)
{
    return
      CreateRectRgn
      (
        prcl->left,
        prcl->top,
        prcl->right,
        prcl->bottom
      );
}

/******************************Public*Routine******************************\
*
*   The PtInRegion function determines whether the specified point is
*   inside the specified region.
*
* Arguments:
*
*   hrgn - app region handle
*   x    - point x
*   y    - point y
*
* Return Value:
*
*   If the specified point is in the region, the return value is TRUE.
*   If the function fails, the return value is FALSE.
*
* History:
*
*    21-Jun-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
WINAPI
PtInRegion(
    HRGN hrgn,
    int x,
    int y
    )
{
    BOOL  bRet = FALSE;
    BOOL  bUserMode = FALSE;
    PRECTL prcl;
    PRGNATTR prRegion;

    FIXUP_HANDLE(hrgn);

    PSHARED_GET_VALIDATE(prRegion,hrgn,RGN_TYPE);

    if (prRegion != NULL)
    {
        if (prRegion->Flags == NULLREGION)
        {
            bRet      = FALSE;
            bUserMode = TRUE;
        }
        else if (prRegion->Flags == SIMPLEREGION)
        {
            prcl = &prRegion->Rect;

            if ((x >= prcl->left) && (x < prcl->right) &&
                (y >= prcl->top)  && (y < prcl->bottom))
            {
                bRet = TRUE;
            }

            bUserMode = TRUE;
        }
    }

    if (!bUserMode)
    {
        bRet = NtGdiPtInRegion(hrgn,x,y);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
*
* The RectInRegion function determines whether any part of the specified
* rectangle is within the boundaries of a region.
*
* Arguments:
*
*   hrgn - app region handle
*   prcl - app rectangle
*
* Return Value:
*
*   If any part of the specified rectangle lies within the boundaries
*   of the region, the return value is TRUE.
*
*   If the function fails, the return value is FALSE.
*
* History:
*
*    21-Jun-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
WINAPI
RectInRegion(
    HRGN hrgn,
    CONST RECT *prcl
    )
{
    PRGNATTR prRegion;
    BOOL  bRet = FALSE;
    RECTL TempRect;
    LONG  iRelation;
    BOOL  bUserMode = FALSE;

    FIXUP_HANDLE(hrgn);

    PSHARED_GET_VALIDATE(prRegion,hrgn,RGN_TYPE);

    if (prRegion != NULL)
    {
        if (prRegion->Flags == NULLREGION)
        {
            bRet      = FALSE;
            bUserMode = TRUE;
        }
        else if (prRegion->Flags == SIMPLEREGION)
        {
            TempRect = *((PRECTL)prcl);
            ORDER_PRECTL((&TempRect));

            iRelation = iRectRelation(&prRegion->Rect,&TempRect);

            if (iRelation != DISJOINT)
            {
                bRet = TRUE;
            }

            bUserMode = TRUE;
        }
    }

    if (!bUserMode)
    {
        bRet = NtGdiRectInRegion(hrgn, (PRECT)prcl);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
*
* The CombineRgn function combines two regions and stores the result in
* a third region. The two regions are combined according to the specified
* mode.
*
* Arguments:
*
*   hrgnDst  -   destination region
*   hrgnSrc1 -   source region
*   hrgnSrc2 -   source region
*   iMode    -   destination region
*
* Return Value:
*
*   The resulting type of region or ERROR
*
* History:
*
*    21-Jun-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/


int
WINAPI
CombineRgn(
    HRGN hrgnDst,
    HRGN hrgnSrc1,
    HRGN hrgnSrc2,
    int  iMode
    )
{

    LONG ResultComplexity = COMPLEXREGION;
    int  iRet             = ERROR;

    //
    // Check if this operation can be completed in user-mode.
    // hrgnDst must have a user mode RGNATTR. hrgnSrc1 must
    // also have a user mode RGNATTR. If iMode is not RGN_COPY
    // then hrgnSrc2 must have a user mode RGNATTR except for certain
    // combinations.
    //

    PRGNATTR    prRegionDst;
    PRGNATTR    prRegionSrc1;
    PRGNATTR    prRegionSrc2;
    PRECTL      prclRes;
    PRECTL      prclSrc1;
    PRECTL      prclSrc2;
    LONG        ComplexSrc1;
    LONG        ComplexSrc2;

    FIXUP_HANDLE(hrgnDst);
    FIXUP_HANDLE(hrgnSrc1);
    FIXUP_HANDLEZ(hrgnSrc2);

    PSHARED_GET_VALIDATE(prRegionDst,hrgnDst,RGN_TYPE);
    PSHARED_GET_VALIDATE(prRegionSrc1,hrgnSrc1,RGN_TYPE);

    if ((prRegionDst != (PRGNATTR)NULL) &&
        (prRegionSrc1 != (PRGNATTR)NULL))
    {

        //
        // region Src1 must me NULL or SIMPLE for current
        // user-mode optimizations. If Rect is the region
        // bounding box, then it will be possible for
        // some combinations with regionC to become
        // SIMPLE or NULL.
        //

        prclSrc1    = &prRegionSrc1->Rect;
        ComplexSrc1 = prRegionSrc1->Flags;

        if (ComplexSrc1 > SIMPLEREGION)
        {
            goto CombineRgnKernelMode;
        }

        if (iMode == RGN_COPY)
        {
            prclRes = prclSrc1;
            ResultComplexity = ComplexSrc1;
        }
        else
        {
            LONG iRelation;

            //
            // validate regionSrc2
            //

            PSHARED_GET_VALIDATE(prRegionSrc2,hrgnSrc2,RGN_TYPE);

            if (
                 (prRegionSrc2 == (PRGNATTR)NULL) ||
                 (prRegionSrc2->Flags > SIMPLEREGION)
               )
            {
                goto CombineRgnKernelMode;
            }

            prclSrc2    = &prRegionSrc2->Rect;
            ComplexSrc2 = prRegionSrc2->Flags;

            switch (iMode)
            {
            case RGN_AND:

                //
                // Creates the intersection of the two
                // combined regions.
                //

                if ((ComplexSrc1 == NULLREGION) ||
                    (ComplexSrc2 == NULLREGION))
                {
                    //
                    // intersection with NULL is NULL
                    //

                    ResultComplexity = NULLREGION;
                }
                else
                {
                    iRelation = iRectRelation(prclSrc1,prclSrc2);

                    if (iRelation == DISJOINT)
                    {
                        ResultComplexity = NULLREGION;
                    }
                    else if (iRelation == CONTAINED)
                    {
                        //
                        // Src1 is contained in Src2
                        //

                        ResultComplexity = SIMPLEREGION;
                        prclRes = prclSrc1;
                    }
                    else if (iRelation == CONTAINS)
                    {
                        //
                        // Src1 is contains Src2
                        //

                        ResultComplexity = SIMPLEREGION;
                        prclRes = prclSrc2;
                    }
                }

                break;

            case RGN_OR:
            case RGN_XOR:

                //
                // RGN_OR:  Creates the union of two combined regions.
                // RGN_XOR:     Creates the union of two combined regions
                //            except for any overlapping areas.
                //


                if (ComplexSrc1 == NULLREGION)
                {
                    if (ComplexSrc2 == NULLREGION)
                    {
                        ResultComplexity = NULLREGION;
                    }
                    else
                    {
                        ResultComplexity = SIMPLEREGION;
                        prclRes = prclSrc2;
                    }
                }
                else if (ComplexSrc2 == NULLREGION)
                {
                    ResultComplexity = SIMPLEREGION;
                    prclRes = prclSrc1;
                }
                else if (iMode == RGN_OR)
                {
                    iRelation = iRectRelation(prclSrc1,prclSrc2);

                    if (iRelation == CONTAINED)
                    {
                        //
                        // Src1 contained in Src2
                        //

                        ResultComplexity = SIMPLEREGION;
                        prclRes = prclSrc2;
                    }
                    else if (iRelation == CONTAINS)
                    {
                        //
                        // Src1 contains Src2
                        //

                        ResultComplexity = SIMPLEREGION;
                        prclRes = prclSrc1;
                    }
                }

                break;

            case RGN_DIFF:

                //
                // Combines the parts of hrgnSrc1 that are not
                // part of hrgnSrc2.
                //

                if (ComplexSrc1 == NULLREGION)
                {
                    ResultComplexity = NULLREGION;
                }
                else if (ComplexSrc2 == NULLREGION)
                {
                    ResultComplexity = SIMPLEREGION;
                    prclRes = prclSrc1;
                }
                else
                {
                    iRelation = iRectRelation(prclSrc1,prclSrc2);

                    if (iRelation == DISJOINT)
                    {
                        //
                        // don't intersect so don't subtract anything
                        //

                        ResultComplexity = SIMPLEREGION;
                        prclRes  = prclSrc1;
                    }
                    else if (iRelation == CONTAINED)
                    {
                        ResultComplexity = NULLREGION;
                    }
                }

                break;
            }
        }

        //
        // try to combine
        //

        if (ResultComplexity == NULLREGION)
        {
            if (SetRectRgn(hrgnDst,0,0,0,0))
            {
               iRet = NULLREGION;
            }
        }
        else if (ResultComplexity == SIMPLEREGION)
        {
            if (SetRectRgn(hrgnDst,
                           prclRes->left,
                           prclRes->top,
                           prclRes->right,
                           prclRes->bottom))
            {
                iRet = SIMPLEREGION;
            }
        }

    }

    if (ResultComplexity != COMPLEXREGION)
    {
        prRegionDst->AttrFlags |= ATTR_RGN_DIRTY;
    }

CombineRgnKernelMode:

    if (ResultComplexity == COMPLEXREGION)
    {
        iRet = NtGdiCombineRgn(hrgnDst,hrgnSrc1,hrgnSrc2,iMode);
    }

    return(iRet);
}

/******************************Public*Routine******************************\
*
* OffsetRgn checks for user-mode region data, if it exits the the
* rectregio is offset, otherwise the kernel is called
*
* Arguments:
*
*   hrgn - app region handle
*   x    - offset in x
*   y    - offset in y
*
* Return Value:
*
*
*
* History:
*
*    21-Jun-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

int
WINAPI
OffsetRgn(
    HRGN hrgn,
    int x,
    int y
    )
{
    int  iRet;
    BOOL bClientRegion = FALSE;

    PRGNATTR prRegion;

    FIXUP_HANDLE(hrgn);

    PSHARED_GET_VALIDATE(prRegion,hrgn,RGN_TYPE);

    if (prRegion != NULL)
    {
        iRet = prRegion->Flags;

        if (iRet == NULLREGION)
        {
            bClientRegion = TRUE;
        }
        else if (iRet == SIMPLEREGION)
        {
            RECTL rcl     = prRegion->Rect;

            bClientRegion = TRUE;

            //
            // try to offset the region, check for overflow
            //

            if ( !((rcl.left >= rcl.right) ||
                   (rcl.top >= rcl.bottom)))
            {
                rcl.left   += x;
                rcl.top    += y;
                rcl.right  += x;
                rcl.bottom += y;

                if (VALID_SCRRC(rcl))
                {
                    prRegion->Rect = rcl;
                    prRegion->AttrFlags |= ATTR_RGN_DIRTY;
                }
                else
                {
                    //
                    // over/underflow
                    //

                    iRet = ERROR;
                }
            }
        }
    }

    if (!bClientRegion)
    {
        iRet = NtGdiOffsetRgn(hrgn,x,y);
    }

    return(iRet);
}

/******************************Public*Routine******************************\
*
* GetRgnBox tries to return user-mode rectregion data, otherwies
* make kernel mode transition to get region data.
*
* Arguments:
*
*    hrgn   - app region handle
*    prcl   - app rect pointer
*
* Return Value:
*
*   region complexity, if the hrgn parameter does not identify a
*   valid region, the return value is zero.
*
* History:
*
*    21-Jun-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

int
WINAPI
GetRgnBox(
    HRGN hrgn,
    LPRECT prcl
    )
{
    int  iRet;
    BOOL bClientRegion = FALSE;

    //
    // check for user-mode region data
    //

    PRGNATTR prRegion;

    FIXUP_HANDLE(hrgn);

    PSHARED_GET_VALIDATE(prRegion,hrgn,RGN_TYPE);

    if (prRegion != NULL)
    {
        iRet = prRegion->Flags;

        if (iRet == NULLREGION)
        {
            bClientRegion = TRUE;
            prcl->left    = 0;
            prcl->top     = 0;
            prcl->right   = 0;
            prcl->bottom  = 0;
        }
        else if (iRet == SIMPLEREGION)
        {
            bClientRegion = TRUE;
            prcl->left    = prRegion->Rect.left;
            prcl->top     = prRegion->Rect.top;
            prcl->right   = prRegion->Rect.right;
            prcl->bottom  = prRegion->Rect.bottom;
        }
    }

    if (!bClientRegion)
    {
        iRet = NtGdiGetRgnBox(hrgn, prcl);
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* PtVisible                                                                *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Thu 06-Jun-1991 00:58:46 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL
WINAPI
PtVisible(
    HDC hdc,
    int x,
    int y
    )
{
    FIXUP_HANDLE(hdc);

    return(NtGdiPtVisible(hdc,x,y));
}

/******************************Public*Routine******************************\
* RectVisible                                                              *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Thu 06-Jun-1991 00:58:46 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL
WINAPI
RectVisible(
    HDC hdc,
    CONST RECT *prcl
    )
{
    FIXUP_HANDLE(hdc);

    return(NtGdiRectVisible(hdc,(LPRECT)prcl));
}

/******************************Public*Routine******************************\
*
* SetRectRgn checks for a user-mode portion of the region. If the
* User-mode data is valid, the region is set to rect locally, otherwise
* a kernel mode call is made to set the region
*
* Arguments:
*
*   hrgn         - app region handle
*   x1,y1,x2,y2  - app region data
*
* Return Value:
*
*   BOOL status
*
\**************************************************************************/

BOOL
WINAPI
SetRectRgn(
    HRGN hrgn,
    int x1,
    int y1,
    int x2,
    int y2
    )
{
    BOOL bStatus;
    PRGNATTR prRegion;

    //
    // if hrgn has a user-mode rectregion, then set
    //

    FIXUP_HANDLE(hrgn);

    PSHARED_GET_VALIDATE(prRegion,hrgn,RGN_TYPE);

    if (prRegion != NULL)
    {
        PRECTL prcl = &prRegion->Rect;

        if ((x1 == x2) || (y1 == y2))
        {
            prRegion->Flags = NULLREGION;

            prcl->left   = 0;
            prcl->top    = 0;
            prcl->right  = 0;
            prcl->bottom = 0;
        }
        else
        {
            //
            // assign and order rectangle
            //


            prcl->left   = x1;
            prcl->top    = y1;
            prcl->right  = x2;
            prcl->bottom = y2;

            ORDER_PRECTL(prcl);

            //
            // set region flag
            //

            prRegion->Flags = SIMPLEREGION;
        }
        prRegion->AttrFlags |= ATTR_RGN_DIRTY;

        bStatus = TRUE;
    }
    else
    {
        bStatus = NtGdiSetRectRgn(hrgn,x1,y1,x2,y2);
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* GetRandomRgn
*
* Client side stub.
*
*  10-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

int APIENTRY GetRandomRgn(HDC hdc,HRGN hrgn,int iNum)
{
    FIXUP_HANDLE(hdc);
    FIXUP_HANDLE(hrgn);

    return(NtGdiGetRandomRgn(hdc,hrgn,iNum));

}

/******************************Public*Routine******************************\
* GetClipRgn                                                               *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Sat 08-Jun-1991 17:38:18 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

int WINAPI GetClipRgn(HDC hdc,HRGN hrgn)
{
    BOOL bRet;

    FIXUP_HANDLE(hdc);
    FIXUP_HANDLE(hrgn);

    bRet = NtGdiGetRandomRgn(hdc, hrgn, 1);

    if (hrgn && MIRRORED_HDC(hdc)) {
        MirrorRgnDC(hdc, hrgn, NULL);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* GetRegionData
*
* Download a region from the server
*
* History:
*  29-Oct-1991 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

DWORD
WINAPI
GetRegionData(
    HRGN      hrgn,
    DWORD     nCount,
    LPRGNDATA lpRgnData
    )
{
    DWORD   iRet;

    FIXUP_HANDLE(hrgn);

    //
    // If this is just an inquiry, pass over dummy parameters.
    //

    if (lpRgnData == (LPRGNDATA) NULL)
    {
        nCount = 0;
    }

    return(NtGdiGetRegionData(hrgn,nCount,lpRgnData));
}

/******************************Public*Routine******************************\
*
* Try to cache regions with user-mode rectregion defined
*
* Arguments:
*
*    h - region handle
*
* Return Value:
*
*   BOOL
*
* History:
*
*    21-Jun-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
DeleteRegion(
    HRGN hRgn
    )
{
    PRGNATTR pRgnattr = NULL;
    BOOL     bRet = FALSE;

    BEGIN_BATCH(BatchTypeDeleteRegion,BATCHDELETEREGION);

    PSHARED_GET_VALIDATE(pRgnattr,hRgn,RGN_TYPE);

        if (pRgnattr)
        {
            pBatch->hregion = hRgn;
            bRet = TRUE;
        }
        else
        {
            goto UNBATCHED_COMMAND;
        }

    COMPLETE_BATCH_COMMAND();

UNBATCHED_COMMAND:

    //
    // All other cases
    //

    if (!bRet)
    {
        bRet = NtGdiDeleteObjectApp(hRgn);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* SelectClipRgn
*
* Client side stub.
*
* History:
*  01-Nov-1991 12:53:47 -by- Donald Sidoroff [donalds]
* Now just call ExtSelectClipRgn
\**************************************************************************/

int META WINAPI SelectClipRgn(HDC hdc,HRGN hrgn)
{
    return(ExtSelectClipRgn(hdc, hrgn, RGN_COPY));
}

/******************************Public*Routine******************************\
*
*   The ExtSelectClipRgn function combines the specified region with the
*   current clipping region by using the specified mode.
*
* Arguments:
*
*   hdc   - app DC handle
*   hrgn  - app region handle
*   iMode - Select mode
*
* Return Value:
*
*   If the function succeeds, the return value specifies the new clipping
*   region's complexity and can be any one of the following values:
*
*   Value           Meaning
*   NULLREGION      Region is empty.
*   SIMPLEREGION    Region is a single rectangle.
*   COMPLEXREGION   Region is more than one rectangle.
*   ERROR           An error occurred
*
* History:
*
*    21-Jun-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

int
META
WINAPI
ExtSelectClipRgn(
    HDC hdc,
    HRGN hrgn,
    int iMode
    )
{
    int iRet = RGN_ERROR;
    HRGN hrgnMirror = NULL;

    FIXUP_HANDLE(hdc);
    FIXUP_HANDLEZ(hrgn);

    //
    // Check Metafile
    //

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
        {
            return(MF16_SelectClipRgn(hdc,hrgn,iMode));
        }

        DC_PLDC(hdc,pldc,iRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_ExtSelectClipRgn(hdc,hrgn,iMode))
            {
                return(iRet);
            }
        }
    }

    //
    // Attempt to batch ExtSelectClipRgn:
    //
    //  The DC_ATTR structure has a copy of the current vis region
    //  bounding rectangle, and the handle table has a flag indicating
    //  whether this region is valid.
    //
    //  Calls can be batched when the iMode is RGN_COPY and either
    //  hrgn is NULL, or hrgn complexity is SIMPLE. (and the DC is not
    //  a DIBSECTION DC)
    //
    //
    //  FUTURE PERF:
    //
    //  A check is made to determine if the region being selected
    //  is the same as the last selected region. In this case, only the
    //  correct return value needs to be calculated, no region changes
    //  are needed.
    //
    //
    if (hrgn && MIRRORED_HDC(hdc)) {
        if (MirrorRgnDC(hdc, hrgn, &hrgnMirror) && hrgnMirror) {
            hrgn = hrgnMirror;
        }
    }

    if (iMode == RGN_COPY)
    {
        //
        // validate DC
        //

        BOOL        bBatch = FALSE;
        PRGNATTR    prRegion = NULL;
        PDC_ATTR    pdca;
        PENTRY      pDCEntry;

        PSHARED_GET_VALIDATE(pdca,hdc,DC_TYPE);

        //
        // check if call can be batched. DC must be valid,non-dibsection
        // DC and there must be room on the batch and same batch DC
        //

        BEGIN_BATCH_HDC(hdc,pdca,BatchTypeSelectClip,BATCHSELECTCLIP);

            pDCEntry = &pGdiSharedHandleTable[HANDLE_TO_INDEX(hdc)];
            ASSERTGDI(pDCEntry,"pDCEntry must be valid when pdcattr is valid");

            if (hrgn == NULL)
            {
                //
                // deleting the clip region, so the return complexity
                // will be the vis rgn complexity. Just batch the call.
                //

                if (!(pDCEntry->Flags & HMGR_ENTRY_INVALID_VIS))
                {
                    bBatch = TRUE;
                    iRet   = pdca->VisRectRegion.Flags;
                }
            }
            else
            {
                PSHARED_GET_VALIDATE(prRegion,hrgn,RGN_TYPE);

                //
                // pDCEntry must be valid because pdcattr is valid.
                // In order to batch, the user-mode RectRegion must
                // be valid and the complexity must be simple
                //

                if (
                     (prRegion)                                &&
                     (prRegion->Flags == SIMPLEREGION)         &&
                     (!(prRegion->AttrFlags & ATTR_CACHED))
                      &&
                      !(pDCEntry->Flags & HMGR_ENTRY_INVALID_VIS)
                   )
                {
                    //
                    // Batch the call.
                    //

                    bBatch = TRUE;

                    //
                    // if the new clip region intersects the DC vis region, the
                    // return value is SIMPLEREGION, otherwise it is NULLREGION
                    //

                    iRet = SIMPLEREGION;

                    if (
                        (pdca->VisRectRegion.Rect.left   >= prRegion->Rect.right)  ||
                        (pdca->VisRectRegion.Rect.top    >= prRegion->Rect.bottom) ||
                        (pdca->VisRectRegion.Rect.right  <= prRegion->Rect.left)   ||
                        (pdca->VisRectRegion.Rect.bottom <= prRegion->Rect.top)
                       )
                    {
                        iRet = NULLREGION;
                    }

                }
            }

            //
            // if the call is to be batched, add to the batch
            // and return
            //

            if (!bBatch)
            {
                goto UNBATCHED_COMMAND;
            }

            if (hrgn == NULL)
            {
                iMode |= REGION_NULL_HRGN;
            }
            else
            {
                pBatch->rclClip.left   = prRegion->Rect.left;
                pBatch->rclClip.top    = prRegion->Rect.top;
                pBatch->rclClip.right  = prRegion->Rect.right;
                pBatch->rclClip.bottom = prRegion->Rect.bottom;
            }

            pBatch->iMode          = iMode;

        COMPLETE_BATCH_COMMAND();

        goto BATCHED_COMMAND;
    }

    //
    // call kernel on fall-through and error cases
    //

UNBATCHED_COMMAND:

    iRet = NtGdiExtSelectClipRgn(hdc,hrgn,iMode);

BATCHED_COMMAND:
    if (hrgnMirror) {
        DeleteObject((HGDIOBJ)hrgnMirror);
    }
    return(iRet);
}

/******************************Public*Routine******************************\
* ExcludeClipRect                                                          *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

int
META WINAPI
ExcludeClipRect(
    HDC hdc,
    int x1,
    int y1,
    int x2,
    int y2
    )
{
    int  iRet = RGN_ERROR;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParms5(hdc,x1,y1,x2,y2,META_EXCLUDECLIPRECT));

        DC_PLDC(hdc,pldc,iRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_AnyClipRect(hdc,x1,y1,x2,y2,EMR_EXCLUDECLIPRECT))
                return(iRet);
        }
    }

    return(NtGdiExcludeClipRect(hdc,x1,y1,x2,y2));

}

/******************************Public*Routine******************************\
* IntersectClipRect                                                        *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

int
META WINAPI
IntersectClipRect(
    HDC hdc,
    int x1,
    int y1,
    int x2,
    int y2
    )
{
    int  iRet = RGN_ERROR;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParms5(hdc,x1,y1,x2,y2,META_INTERSECTCLIPRECT));

        DC_PLDC(hdc,pldc,iRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_AnyClipRect(hdc,x1,y1,x2,y2,EMR_INTERSECTCLIPRECT))
                return(iRet);
        }
    }

    return(NtGdiIntersectClipRect(hdc,x1,y1,x2,y2));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\daytona\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\sources.inc ===
MAJORCOMP=windows
MINORCOMP=GDI

TARGETNAME=gdi32
TARGETNAMEP=gdi32p
TARGETTYPE=DYNLINK

TARGETPATH=$(_OBJ_DIR)
UMPDDDILIB=$(NTGDI_PATH)\client\$(ALT_PROJECT)\$(O)\umpdddi.lib
WINPPILIB=$(NTGDI_PATH)\client\$(ALT_PROJECT)\$(O)\winppi.lib
NTGDIH=$(NTGDI_PATH)\inc\ntgdi.h

PASS1_PUBLISH=\
    {$(DYNLINK_LIB)=$(SDK_LIB_DEST)\$(DYNLINK_LIBDIR)} \
    {$(DYNLINK_LIBP)=$(WINDOWS_LIB_DEST)\$(DYNLINK_LIBPDIR)} \
    {$(UMPDDDILIB)=$(WINDOWS_LIB_DEST)\$(ALT_PROJECT_TARGET)\$(TARGET_DIRECTORY)\umpdddi.lib} \
    {$(WINPPILIB)=$(WINDOWS_LIB_DEST)\$(ALT_PROJECT_TARGET)\$(TARGET_DIRECTORY)\winppi.lib} \
    {$(UMPDDDILIB)=$(DDK_LIB_DEST)\$(ALT_PROJECT_TARGET)\$(TARGET_DIRECTORY)\umpdddi.lib} \
    {$(WINPPILIB)=$(DDK_LIB_DEST)\$(ALT_PROJECT_TARGET)\$(TARGET_DIRECTORY)\winppi.lib} \
    {$(NTGDIH)=$(WINDOWS_INC_PATH)\ntgdi.h}

TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib                               \
           $(WINDOWS_LIB_DEST)\$(ALT_PROJECT_TARGET)\*\w32umode.lib   \
           $(WINDOWS_LIB_DEST)\$(ALT_PROJECT_TARGET)\*\user32p.lib    \
           $(NTGDI_PATH)\math\$(ALT_PROJECT)\$(O)\efloat.lib          \
           $(SDK_LIB_PATH)\ntdll.lib                                  \
           $(SDK_LIB_PATH)\advapi32.lib                               \
           $(SDK_LIB_PATH)\psapi.lib

LINKLIBS= $(WINDOWS_LIB_DEST)\$(ALT_PROJECT_TARGET)\*\w32umode.lib

NTTARGETFILES= $(SDK_LIB_DEST)\$(DYNLINK_LIBDIR)  \
               $(WINDOWS_LIB_DEST)\$(DYNLINK_LIBPDIR) \
               $(WINDOWS_LIB_DEST)\$(ALT_PROJECT_TARGET)\*\umpdddi.lib   \
               $(WINDOWS_LIB_DEST)\$(ALT_PROJECT_TARGET)\*\winppi.lib   \
               ..\$(TARGETNAME).def

NTTARGETFILE1=$(DYNLINK_LIBP) $(UMPDDDILIB) $(WINPPILIB)

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

INCLUDES=..;                                   \
         ..\..\inc;                            \
         $(WINCORE_PATH)\w32inc;                      \
         ..\..\direct\ddraw\main;              \
         ..\..\icm\inc;                        \
         $(BASE_INC_PATH); \
         $(MULTIMEDIA_INC_PATH);               \
         $(DDK_INC_PATH)

C_DEFINES=$(C_DEFINES) -D_GDI32_ -DGL_METAFILE -DFE_SB -DLANGPACK -DINTEL -DDS_ENABLE_OLD_STUFF=0

USE_NTDLL=1

DLLDEF=..\$(TARGETNAME).def
DLLORDER=..\$(TARGETNAME).prf

SOURCES= ..\cfont.c        \
         ..\csxobj.cxx     \
         ..\bitmap.c       \
         ..\xform.c        \
         ..\d3d.c          \
         ..\dllinit.c      \
         ..\dcmod.c        \
         ..\dcquery.c      \
         ..\ddraw.c        \
         ..\emfspool.cxx   \
         ..\font.c         \
         ..\icm.c          \
         ..\image.c        \
         ..\ldc.c          \
         ..\linedda.c      \
         ..\local.c        \
         ..\metafile.cxx   \
         ..\metarec.cxx    \
         ..\metasup.cxx    \
         ..\mem.c          \
         ..\mfdc.cxx       \
         ..\mfplay16.c     \
         ..\mfrec.cxx      \
         ..\mfrec16.c      \
         ..\nlsconv.c      \
         ..\object.c       \
         ..\output.c       \
         ..\pal.c          \
         ..\path.c         \
         ..\pixelfmt.c     \
         ..\poly.c         \
         ..\region.c       \
         ..\script.c       \
         ..\fareast.c      \
         ..\print.c        \
         ..\ufi.c          \
         ..\glsup.c        \
         ..\umpd.cxx       \
         ..\umpdeng.c      \
         ..\umpddrv.c      \
         ..\drawstream.c   \
         ..\gdi.rc

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\ufi.c ===
/******************************Module*Header*******************************\
* Module Name: ufi.c
*
* Copyright (c) 1995-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

FPCREATEFONTPACKAGE gfpCreateFontPackage= (FPCREATEFONTPACKAGE)NULL;
FPMERGEFONTPACKAGE  gfpMergeFontPackage = (FPMERGEFONTPACKAGE)NULL;

ULONG   gulMaxCig = 3000;

#ifdef  DBGSUBSET
FLONG    gflSubset = 0;
#endif //  DBGSUBSET


/***********************************************************
* BOOL bAddGlyphIndices(HDC, PUFIHASH, WCHAR, int, BOOL)
*
* Adds distinct glyph indices into UFI hash bucket
*
* History
*   Dec-13-96 Xudong Wu [tessiew]
* Wrote it.
*
************************************************************/

#define MAX_STACK_STRING 80


BOOL bAddGlyphIndices(HDC hdc, PUFIHASH pBucket, WCHAR *pwsz, int c, UINT flETO)
{
    BOOL     bDelta = pBucket->fs1 & FLUFI_DELTA;
    WCHAR   *pwc=pwsz;
    WORD    *pgi, *pgiTmp, *pgiEnd;
    PBYTE    pb, pbDelta;
    WORD     agi[MAX_STACK_STRING];
    BOOL     bRet = FALSE;

    if (c && pwsz)
    {
        if (bDelta && (pBucket->u.ssi.pjDelta == NULL))
        {
             pBucket->u.ssi.cDeltaGlyphs = 0;

             pBucket->u.ssi.pjDelta = (PBYTE)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, pBucket->u.ssi.cjBits);

             if (pBucket->u.ssi.pjDelta == NULL)
             {
                 WARNING("bAddGlyphIndices: unable to allocate mem for delta glyph indices\n");
                 return FALSE;
             }
        }

        if (c > MAX_STACK_STRING)
        {
            pgi = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, c * sizeof(WORD));
        }
        else
        {
            pgi = agi;
        }
        
        if (pgi)
        {
            if (flETO & ETO_GLYPH_INDEX)
            {
                RtlCopyMemory((PBYTE)pgi, (PBYTE)pwsz, c*sizeof(WORD));
            }

			pgiTmp = pgi;
			if ((flETO & ETO_GLYPH_INDEX) ||
                (NtGdiGetGlyphIndicesWInternal(hdc, pwc, c, pgi, 0, TRUE) != GDI_ERROR))
            {
                for (pgiEnd = pgiTmp + c ; pgi < pgiEnd; pgi++)
                {
                    BYTE jTmp;

                    pb = pBucket->u.ssi.pjBits + (*pgi >> 3);
                    pbDelta = pBucket->u.ssi.pjDelta + (*pgi >> 3);

                // map to the u.ssi.pjBits  and u.ssi.pjDelta if bDelta

                    jTmp = (BYTE)(1 << (*pgi & 7));

                    if (!(*pb & jTmp))
                    {
                        *pb |= jTmp;
                        pBucket->u.ssi.cGlyphsSoFar++;

                    // if this gi is not found in pjBits, it certainly
                    // will not be found in pjDelta

                        if (bDelta)
                        {
                            ASSERTGDI((*pbDelta & jTmp) == 0,
                                "pbDelta contains the gi\n");
                            *pbDelta |= jTmp;
                            pBucket->u.ssi.cDeltaGlyphs++;
                        }
                    }
                }

                bRet = TRUE;
            }
            if (pgiTmp != agi)
                LocalFree(pgiTmp);
        }
        #if DBG
        else
        {
            WARNING("bAddGlyphIndices unable to allocate mem for pgi\n");
        }
        #endif
    }
    else
    {
        bRet = TRUE;
    }

    return bRet;
}


/******************************************************************
* BOOL  bGetDistGlyphIndices(PUFIHASH, USHORT*, BOOL)
*
* Get distinct glyph indices from pjMemory in the ufi hash bucket
* Reverse of bAddGlyphIndices
* Clean up the u.ssi.pjDelta and u.ssi.cDeltaGlyphs before it return.
*
* History
*   Dec-17-96 Xudong Wu [tessiew]
* Wrote it.
*
*******************************************************************/

BOOL bGetDistGlyphIndices(PUFIHASH pBucket, USHORT *pusSubsetKeepList, BOOL bDelta)
{
    ULONG  ulBytes;
    PBYTE  pb;
    USHORT gi, index;
    USHORT *pNextGlyph;

    ulBytes = pBucket->u.ssi.cjBits;
    pb = (bDelta ? pBucket->u.ssi.pjDelta : pBucket->u.ssi.pjBits);

    for(index = 0, pNextGlyph = pusSubsetKeepList; index < ulBytes; index++, pb++)
    {
        if (*pb)
        {
            gi = index << 3;

            if (*pb & 0x01)
            {
                *pNextGlyph ++= gi;
            }
            if (*pb & 0x02)
            {
                *pNextGlyph ++= gi+1;
            }
            if (*pb & 0x04)
            {
                *pNextGlyph ++= gi+2;
            }
            if (*pb & 0x08)
            {
                *pNextGlyph ++= gi+3;
            }
            if (*pb & 0x10)
            {
                *pNextGlyph ++= gi+4;
            }
            if (*pb & 0x20)
            {
                *pNextGlyph ++= gi+5;
            }
            if (*pb & 0x40)
            {
                *pNextGlyph ++= gi+6;
            }
            if (*pb & 0x80)
            {
                *pNextGlyph ++= gi+7;
            }
        }

    }

    return TRUE;
}


/********************************************************************************
* BOOL bWriteUFItoDC(PUFIHASH*, PUNIVERSAL_FONT_ID, PUFIHASH, PVOID, ULONG)
*
* Write merge font image into the UFI hash table on the print server side.
* pBucketIn == NULL, indicates a new font subsetting.
* This is only called on print server
*
* History
* Jan-28-1997   Xudong Wu   [tessiew]
* Wrote it.
*
*********************************************************************************/

BOOL bWriteUFItoDC(
    PUFIHASH          *ppHashBase,
    PUNIVERSAL_FONT_ID pufi,
    PUFIHASH           pBucketIn,// NULL=>First page, else
    PVOID              pvBuffer, // points to the merged font image preceeded with DOWNLOADFONTHEADER
    ULONG              ulBytes
)
{
    PUFIHASH pBucket = pBucketIn;
    ULONG index, ulHeaderSize;

    ASSERTGDI(pvBuffer != NULL, "pWriteUFItoDC attempts to add an NULL ufi\n");

// First page for font subset

    if (!pBucketIn)
    {
        index = UFI_HASH_VALUE(pufi) % UFI_HASH_SIZE;
        pBucket = LOCALALLOC (offsetof(UFIHASH,u.mvw) + sizeof(MERGEDVIEW));

        if (pBucket == NULL)
        {
            WARNING("pWriteUFItoDC: unable to allocate mem for glyph indices\n");
            return FALSE;
        }

        pBucket->ufi = *pufi;
        pBucket->pNext = ppHashBase[index];
        pBucket->fs1 = FLUFI_SERVER; // server side hash bucket

        ppHashBase[index] = pBucket;
    }
    else
    {
    // pjMemory contains the image of the font subsetted up unil
    // the page preceeding this one. Other info in pBucket is ok.

        LocalFree(pBucket->u.mvw.pjMem);
    }

// pvBuffer includes the DOWNLOADFONTHEADER information

    pBucket->u.mvw.pjMem = (PBYTE)pvBuffer;
    pBucket->u.mvw.cjMem = ulBytes;

    return TRUE;
}


/**************************************************************************
*
* Adds an entry to the UFI hash table, this routine only executes
* on a print client machine.
*
* History
*   Dec-16-96 Xudong Wu [tessiew]
* Modify to return the bucket pointer.
*   1-27-95 Gerrit van Wingerden [gerritv]
* Wrote it.
*
***************************************************************************/

PUFIHASH pufihAddUFIEntry(
    PUFIHASH *ppHashBase,
    PUNIVERSAL_FONT_ID pufi,
    ULONG  ulCig,
    FLONG  fl,
    FLONG  fs2)
{
    PUFIHASH pBucket;
    ULONG index;
    ULONG cjGlyphBitfield = (ulCig + 7) / 8;

    index = UFI_HASH_VALUE(pufi) % UFI_HASH_SIZE;
    pBucket = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                 (fl & FL_UFI_SUBSET)                ?
                 (offsetof(UFIHASH,u.ssi) + sizeof(SSINFO) + cjGlyphBitfield) :
                  offsetof(UFIHASH,u)
                 );

    if (pBucket == NULL)
    {
        WARNING("pufihAddUFIEntry: unable to allocate mem for glyph indices\n");
        return NULL;
    }

// these fields are always there

    pBucket->ufi = *pufi;
    pBucket->pNext = ppHashBase[index];
    pBucket->fs1 = 0;
    pBucket->fs2 = (FSHORT)fs2;
    ppHashBase[index] = pBucket;

// these fields are there only for subsetting case

    if (fl & FL_UFI_SUBSET)
    {
    // all other fields are zero initialized by LocalAlloc

        ASSERTGDI (ulCig, "no font subsetting for ulCig == 0\n");
        pBucket->u.ssi.cjBits = cjGlyphBitfield; // bitfield size
        pBucket->u.ssi.pjBits = (PBYTE)pBucket + offsetof(UFIHASH,u.ssi) + sizeof(SSINFO);
    }

    return(pBucket);
}

/**************************************************************************
*
* Checks to see if an entry is in the UFI table.
*
* History
*   Dec-13-96  Xudong Wu [tessiew]
* Changed its return value from BOOL to PUFIHASH.
*   1-27-95 Gerrit van Wingerden [gerritv]
* Wrote it.
*
***************************************************************************/


PUFIHASH pufihFindUFIEntry(PUFIHASH *ppHashBase, PUNIVERSAL_FONT_ID pufi, BOOL SubsetHashBase)
{
    PUFIHASH pBucket;
    ULONG index;

    index = UFI_HASH_VALUE(pufi) %  UFI_HASH_SIZE;

    pBucket = ppHashBase[index];

    if( pBucket == NULL )
    {
        return(NULL);
    }

    do
    {
        if (UFI_SAME_FILE(&pBucket->ufi,pufi))
        {
            if (SubsetHashBase)
            {
                if ((pBucket->ufi.Index -1)/2 == (pufi->Index -1)/2)
                {
                    return (pBucket);
                }
            }
            else
            {
                return(pBucket);
            }
        }

        pBucket = pBucket->pNext;
    } while( pBucket != NULL );

    return(NULL);
}


/************************************************************
* VOID vRemoveUFIEntry(PUFIHASH*, PUNIVERSAL_FONT_ID)
*
* Remove a UFI entry from the UFI hash list
* Function returns TRUE if UFI doesn't exist in the table.
* This is happening on the print client, typically when subsetter failed
* we call this to remove the bucket from ppSubUFIHash table (and then later
* add it to the ppUFIHash, ie hash table of fonts that are going to be shipped
* over without subsetting.
*
* History
*   Feb-03-97  Xudong Wu [tessiew]
* Wrote it.
*
***************************************************************************/
VOID vRemoveUFIEntry(PUFIHASH *ppHashBase, PUNIVERSAL_FONT_ID pufi)
{
    PUFIHASH pBucket, pPrev;
    ULONG index;

    index = UFI_HASH_VALUE(pufi) %  UFI_HASH_SIZE;
    pPrev = pBucket = ppHashBase[index];

    while(pBucket)
    {
        if (UFI_SAME_FILE(&pBucket->ufi, pufi) &&
           ((pBucket->ufi.Index - 1)/2 == (pufi->Index - 1)/2))
        {
            break;
        }
        else
        {
            pPrev = pBucket;
            pBucket = pBucket->pNext;
        }
    }

    if (pBucket != NULL)
    {
        if (pPrev == pBucket)
        {
            ppHashBase[index] = pBucket->pNext;
        }
        else
        {
            pPrev->pNext = pBucket->pNext;
        }

    // this is only happening for subsetting ufi hash list => u.ssi.pjDelta exists

        if (pBucket->u.ssi.pjDelta)
        {
            LocalFree(pBucket->u.ssi.pjDelta);
        }

        LocalFree(pBucket);
    }
}


/**************************************************************************
* VOID vFreeUFIHashTable( PUFIHASH *ppHashTable )
*
* Frees all the memory allocated for the UFI has table.
*
* History
*   1-27-95 Gerrit van Wingerden [gerritv]
* Wrote it.
*
***************************************************************************/


VOID vFreeUFIHashTable(PUFIHASH *ppHashTable, FLONG fl)
{
    PUFIHASH pBucket, *ppHashEnd, pBucketTmp, *ppTableBase;

    if( ppHashTable == NULL )
    {
        return;
    }

    ppTableBase = ppHashTable;  // save ptr to the base so we can free it later

// Next loop through the whole table looking for buckets lists

    for( ppHashEnd = ppHashTable + UFI_HASH_SIZE;
         ppHashTable < ppHashEnd;
         ppHashTable += 1 )
    {
        pBucket = *ppHashTable;

        while( pBucket != NULL )
        {
            pBucketTmp = pBucket;
            pBucket = pBucket->pNext;

        // subsetting hash table

            if (fl & FL_UFI_SUBSET)
            {
                if (pBucketTmp->fs1 & FLUFI_SERVER)  // server, clean the merged font image
                {
                    if (pBucketTmp->u.mvw.pjMem)
                    {
                        LocalFree(pBucketTmp->u.mvw.pjMem);
                    }
                }
                else    // client, clean the glyph indices list
                {
                    if (pBucketTmp->u.ssi.pjDelta)
                    {
                        LocalFree(pBucketTmp->u.ssi.pjDelta);
                    }
                }
            }

            LocalFree (pBucketTmp);
        }
    }
}



ULONG GetRecdEmbedFonts(PUFIHASH *ppHashTable)
{
    PUFIHASH pBucket, *ppHashEnd;
    ULONG cEmbedFonts = 0;

    if( ppHashTable == NULL )
        return 0;

    for( ppHashEnd = ppHashTable + UFI_HASH_SIZE;
         ppHashTable < ppHashEnd;
         ppHashTable += 1 )
    {
        pBucket = *ppHashTable;

        while( pBucket != NULL )
        {
            cEmbedFonts++;
            pBucket = pBucket->pNext;
        }
    }
    return cEmbedFonts;
}


typedef union _DLHEADER
{
    DOWNLOADFONTHEADER dfh;
    double             f;    // to achieve max alignment
} DLHEADER;

BOOL WriteFontToSpoolFile(PLDC pldc, PUNIVERSAL_FONT_ID pufi, FLONG fl)
{
    BOOL bRet = FALSE;

    ULONG cwcPathname, cNumFiles;
    WCHAR  *pwszFile = NULL;
    WCHAR   pwszPathname[MAX_PATH * 3];
    CLIENT_SIDE_FILEVIEW    fvw;
    DLHEADER dlh;
    ULONG   cjView;
    PVOID   pvView = NULL;
    BOOL    bMemFont = FALSE, bMapOK = TRUE;

#ifdef  DBGSUBSET
    FILETIME    fileTimeStart, fileTimeEnd;
    DbgPrint("\nWriteFontToSpoolFile called\n");

    if (gflSubset & FL_SS_SPOOLTIME)
    {
        GetSystemTimeAsFileTime(&fileTimeStart);
    }
#endif

    RtlZeroMemory(&dlh, sizeof(DLHEADER));

    if (NtGdiGetUFIPathname(pufi,
                            &cwcPathname,
                            pwszPathname,
                            &cNumFiles,
                            fl,
                            &bMemFont,
                            &cjView,
                            NULL,
                            NULL,
                            NULL))
    {
        if (cNumFiles == 1)
        {
            ASSERTGDI(cwcPathname <= MAX_PATH, "WriteFontToSpoolFile:  cwcPathname\n");

            if (!bMemFont)
            {
                if (!bMapFileUNICODEClideSide(pwszPathname, &fvw, TRUE))
                {
                    bMapOK = FALSE;
                    WARNING("WriteFontToSpooler: error map the font file\n");
                }
            }
            else
            {
            // must allocate memory and call again to get the bits:

                pvView = LocalAlloc( LMEM_FIXED, cjView ) ;
                if (!pvView)
                {
                    bMapOK = FALSE;
                    WARNING("WriteFontToSpooler: error allocating mem for mem font\n");
                }

            // Write the bits into the buffer

                if (!NtGdiGetUFIPathname(pufi,NULL,NULL,NULL,fl,
                                         NULL,NULL,pvView,NULL,NULL))
                {
                    bMapOK = FALSE;
                    LocalFree(pvView);
                    pvView = NULL;
                    WARNING("WriteFontToSpooler: could not get mem bits\n");
                }
            }

            if (bMapOK)
            {
                DOWNLOADFONTHEADER*  pdfh = &dlh.dfh;

                pdfh->Type1ID = 0;
                pdfh->NumFiles = cNumFiles;

                if (!bMemFont)
                {
                    cjView = fvw.cjView;
                    pvView = fvw.pvView;
                }

                pdfh->FileOffsets[0] = cjView;

                if (WriteFontDataAsEMFComment(
                            pldc,
                            EMRI_ENGINE_FONT,
                            pdfh,
                            sizeof(DLHEADER),
                            pvView,
                            cjView))
                {
                    MFD1("Done writing UFI to printer\n");
                    bRet = TRUE;
                }
                else
                {
                    WARNING("WriteFontToSpooler: error writing to printer\n");
                }

                if (bMemFont)
                {
                    if (pvView) { LocalFree(pvView);}
                }
                else
                {
                    vUnmapFileClideSide(&fvw);
                }
            }
        }
        else
        {
            CLIENT_SIDE_FILEVIEW    afvw[3];
            ULONG   iFile;
            ULONG   cjdh;

            if (cNumFiles > 3)
                return FALSE;

            ASSERTGDI(cwcPathname <= (cNumFiles * MAX_PATH), "cwcPathname too big\n");
            ASSERTGDI(!bMemFont, "there can not be memory type1 font\n");

            pwszFile = pwszPathname;

            bMapOK = TRUE;

            cjView = 0;

            for (iFile = 0; iFile < cNumFiles; iFile++)
            {
                if (!bMapFileUNICODEClideSide(pwszFile, &afvw[iFile], TRUE))
                {
                    ULONG   iFile2;
                    bMapOK = FALSE;
                    WARNING("WriteFontToSpooler: error mapping the font file\n");

                    for (iFile2 = 0; iFile2 < cNumFiles; iFile2++)
                    {
                        vUnmapFileClideSide(&afvw[iFile2]);
                    }

                    break;
                }

            // advance to the path name of the next font file

                while (*pwszFile++);
                cjView += ALIGN4(afvw[iFile].cjView);
            }

            if (bMapOK)
            {
                cjdh = ALIGN8(offsetof(DOWNLOADFONTHEADER, FileOffsets) + cNumFiles * sizeof(ULONG));

                pvView = LocalAlloc(LMEM_FIXED, cjdh + cjView);
                if (pvView)
                {
                    DOWNLOADFONTHEADER*  pdfh = (DOWNLOADFONTHEADER *) pvView;
                    ULONG dpFile;
                    BYTE *pjFile = (BYTE *)pvView + cjdh;

                    RtlZeroMemory(pvView, cjdh); // zero out top portion of the buffer only

                    for (dpFile = 0, iFile = 0; iFile < cNumFiles; iFile++)
                    {
                    // first offset is implicit at cjdh, the second offset is
                    // at ALIGN4(cjView) of the first file etc.

                        dpFile += ALIGN4(afvw[iFile].cjView);
                        pdfh->FileOffsets[iFile] = dpFile;

                        RtlCopyMemory(pjFile, afvw[iFile].pvView, afvw[iFile].cjView);
                        pjFile += ALIGN4(afvw[iFile].cjView);
                    }

                    pdfh->Type1ID = 0; // is this correct?
                    pdfh->NumFiles = cNumFiles;

                    if (WriteFontDataAsEMFComment(
                                pldc,
                                EMRI_TYPE1_FONT,
                                pdfh,
                                cjdh,
                                (BYTE *)pvView + cjdh,
                                cjView))
                    {
                        MFD1("Done writing UFI to printer\n");
                        bRet = TRUE;
                    }
                    else
                    {
                        WARNING("WriteFontToSpooler: error writing to printer\n");
                    }

                    LocalFree(pvView);
                }

                // clean up

                for (iFile = 0; iFile < cNumFiles; iFile++)
                {
                    vUnmapFileClideSide(&afvw[iFile]);
                }
            }
        }
    }
    else
    {
        WARNING("NtGdiGetUFIPathname failed\n");
    }

//timing code
#ifdef  DBGSUBSET
    if (gflSubset & FL_SS_SPOOLTIME)
    {
        GetSystemTimeAsFileTime(&fileTimeEnd);
        DbgPrint("WriteFontToSpoolfile(millisec):   %ld\n", (fileTimeEnd.dwLowDateTime - fileTimeStart.dwLowDateTime) / 10000);
    }
#endif
    return(bRet);
}


/******************************Public*Routine******************************\
*
*
*
* Effects:
*
* Warnings:
*
* History:
*  16-Jan-1997 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


BOOL WriteDesignVectorToSpoolFile (
    PLDC               pldc,
    UNIVERSAL_FONT_ID *pufiBase,
    DESIGNVECTOR      *pdv,
    ULONG              cjDV
)
{
    BOOL                 bRet = FALSE;
    DOWNLOADDESIGNVECTOR ddv;

    ddv.ufiBase = *pufiBase;
    RtlCopyMemory(&ddv.dv, pdv, cjDV); // small copy

    if (WriteFontDataAsEMFComment(
            pldc,
            EMRI_DESIGNVECTOR,
            &ddv,
            offsetof(DOWNLOADDESIGNVECTOR,dv) + cjDV,
            NULL,
            0))
    {
        MFD1("Done writing DesignVector to spool file\n");
        bRet = TRUE;
    }
    else
    {
        WARNING("WriteDesignVectorToSpooler: spooling error\n");
    }

    return(bRet);
}


/***********************************************************
* BOOL bAddUFIandWriteSpool(HDC,PUNIVERSAL_FONT_ID,BOOL)
* Called only on the print client when subsetter failed
* or when we could not write a subsetted font to the spool file.
*
* History
*   Feb-03-1997  Xudong Wu  [tessiew]
* Wrote it.
************************************************************/
BOOL bAddUFIandWriteSpool(
    HDC                hdc,
    PUNIVERSAL_FONT_ID pufi,
    BOOL               bSubset,
    FLONG              fl
)
{
    PLDC  pldc;
    UNIVERSAL_FONT_ID  ufi = *pufi;

    pldc = GET_PLDC(hdc);

    if (pldc == NULL)
    {
        return (FALSE);
    }

    if(bSubset)
    {
        vRemoveUFIEntry(pldc->ppSubUFIHash, pufi);
    }

    // We might have freed the bucket entry,
    // which means that pufi pointer might not be valid anymore.
    // That is why we saved it above before calling vRemoveUFIEntry.

    if (!pufihAddUFIEntry(pldc->ppUFIHash, &ufi, 0, 0, fl) ||
        !WriteFontToSpoolFile(pldc, &ufi, fl))
    {
        return FALSE;
    }

    return TRUE;
}


#define QUICK_UFIS 8

/**************************************************************************
 * BOOL bDoFontChange( HDC hdc )
 *
 * Called everytime the font changes in the DC.  This routines checks to
 * see if the font has already been packaged in the spool file and if not
 * gets the raw bits for it and packages it into the spool file.
 *
 * History
 *   Dec-12-96  Xudong Wu  [tessiew]
 * Modify it so it can handle the font subsetting.
 *   1-27-95 Gerrit van Wingerden [gerritv]
 * Wrote it.
 *
 ***************************************************************************/

BOOL bDoFontChange( HDC hdc, WCHAR *pwsz, int c, UINT flETO )
{
    PLDC pldc;
    BOOL bRet = FALSE;
    UNIVERSAL_FONT_ID ufi;
    UNIVERSAL_FONT_ID ufiBase;
    DESIGNVECTOR dv;
    ULONG        cjDV = 0;
    ULONG        ulBaseCheckSum;
    FLONG       fl = 0; // initialization essential

    pldc = GET_PLDC( hdc );
    
    if (pldc == NULL)
    {
    WARNING("bDoFontChange: unable to retrieve pldc\n");
    return(FALSE);
    }

    pldc->fl &= ~LDC_FONT_CHANGE;

    if (!NtGdiGetUFI(hdc, &ufi, &dv, &cjDV, &ulBaseCheckSum, &fl))
    {
        WARNING("bDoFontChange: call to GetUFI failed\n");
        return(FALSE);
    }

// if the UFI to which we are forcing mapping does not match the new UFI then
// set forced mapping to the new UFI

    if((pldc->fl & LDC_FORCE_MAPPING) &&
       (!UFI_SAME_FACE(&pldc->ufi,&ufi) || (pldc->fl & LDC_LINKED_FONTS)))
    {
        INT NumLinkedUFIs;

        if (!UFI_SAME_FACE(&pldc->ufi, &ufi))
        {
            if(!MF_ForceUFIMapping(hdc, &ufi))
            {
                WARNING("bDoFontChange: call to MF_ForceUFIMapping failed\n");
                return(FALSE);
            }
            pldc->ufi = ufi;
        }

        if(NtGdiAnyLinkedFonts())
        {
            UNIVERSAL_FONT_ID QuickLinks[QUICK_UFIS];
            PUNIVERSAL_FONT_ID pUFIs = NULL;

            NumLinkedUFIs = NtGdiGetLinkedUFIs(hdc, NULL, 0);

            if (NumLinkedUFIs > 0)
            {
                pldc->fl |= LDC_LINKED_FONTS;

                if(NumLinkedUFIs <= QUICK_UFIS)
                {
                    pUFIs = QuickLinks;
                }
                else
                {
                    pUFIs = LocalAlloc(LMEM_FIXED, NumLinkedUFIs * sizeof(UNIVERSAL_FONT_ID));
                }
            }

            if (pUFIs)
            {
                if(NumLinkedUFIs = NtGdiGetLinkedUFIs(hdc,pUFIs,NumLinkedUFIs))
                {
                    INT u;
                    WORD    *pgi = NULL, agi[MAX_STACK_STRING];
                    BOOL    bNeedLinkFont = FALSE;

                    bRet = TRUE;

                    if((pldc->fl & LDC_DOWNLOAD_FONTS) &&
                        c && pwsz && !(flETO & ETO_GLYPH_INDEX))
                    {
                        if (c > MAX_STACK_STRING)
                        {
                            pgi = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, c * sizeof(WORD));
                        }
                        else
                        {
                            pgi = agi;
                        }
                        
                        // check whether there are glyphs from linked font

                        if (pgi &&
                            NtGdiGetGlyphIndicesW(hdc, pwsz, c, pgi, GGI_MARK_NONEXISTING_GLYPHS) != GDI_ERROR)
                        {
                            for (u = 0; u < c; u++)
                            {
                                if (pgi[u] == 0xffff)
                                {
                                    bNeedLinkFont = TRUE;
                                    break;
                                }
                            }
                        }
                        else
                        {
                            bNeedLinkFont = TRUE; // ship them, just in case
                        }
                        
                        if (bNeedLinkFont)
                        {
                            for(u = 0; u < NumLinkedUFIs; u++)
                            {                            
                                if(pufihFindUFIEntry(pldc->ppUFIHash, &pUFIs[u], FALSE))
                                {
                                // already in spool file or on remote machine so skip it
                                    continue;
                                }
    
                                #if DBG
                                DbgPrint("Writing link to spooler\n");
                                #endif
    
                            // WHAT IS fs2 flag that should be passed to these 2 functions ???
    
                                if(!pufihAddUFIEntry(pldc->ppUFIHash, &pUFIs[u], 0, 0, 0) ||
                                   !WriteFontToSpoolFile(pldc,&pUFIs[u], 0))
                                {
                                    WARNING("GDI32:error writing linked font to spooler\n");
                                    bRet = FALSE;
                                }
                            }
                            if (bRet)
                            {
                                pldc->fl &= ~LDC_LINKED_FONTS;
                            }
                        }
                    }

                    if (pgi && (pgi != agi))
                    {
                        LocalFree(pgi);
                    }
                }

                if(bRet)
                {
                // If there are no linked UFI's we still need to metafile the call
                // so that the server knows to turn off linking.

                    bRet = MF_SetLinkedUFIs(hdc, pUFIs, (UINT)NumLinkedUFIs);
                }

                if(pUFIs != QuickLinks)
                {
                    LocalFree(pUFIs);
                }

                if(!bRet)
                {
                    return(FALSE);
                }
            }
        }
    }


    if( UFI_DEVICE_FONT(&ufi)  ||
       !(pldc->fl & LDC_DOWNLOAD_FONTS) )
    {
        return(TRUE);
    }

// now comes the interesting part:
// If this is a mm instance, we send the base font first (if not sent already)
// and then we send the design vector with the ufi of the base font.

    ufiBase = ufi;

    if (fl & FL_UFI_DESIGNVECTOR_PFF)
    {
    // little bit dirty, we should not know what is in ufi

        ufiBase.CheckSum = ulBaseCheckSum;
    }

    // pldc->ppUFIHash is used to remember all remote fonts which have been
    // copied into the spool file without subset. Once it is in spool file,
    // there is no need to copy again.

    if (pufihFindUFIEntry(pldc->ppUFIHash, &ufiBase, FALSE) == NULL)
    {

        if (fl & FL_UFI_DESIGNVECTOR_PFF)
        {
            pufihAddUFIEntry(pldc->ppUFIHash, &ufiBase,0, 0, fl);
            bRet = WriteFontToSpoolFile(pldc, &ufiBase, fl);

        // now since this is a mm instance, write a design vector object in the spool file
        // if we have not done it already

            if (bRet)
            {
                if (!pufihFindUFIEntry(pldc->ppDVUFIHash, &ufi, FALSE))
                {
                    pufihAddUFIEntry(pldc->ppDVUFIHash, &ufi,0, 0, fl);
                    bRet = WriteDesignVectorToSpoolFile(pldc, &ufiBase, &dv, cjDV);
                }
            }
        }
        else
        {
            BOOL  bFontSubset = TRUE, bSubsetFail = FALSE;
            PUFIHASH pBucket;

        // Check the ppSubUFIHash to see whether ufi already exists

            if ((pBucket = pufihFindUFIEntry(pldc->ppSubUFIHash, &ufi, TRUE)) == NULL)
            {
                ULONG ulCig = NtGdiGetGlyphIndicesW(hdc, NULL, 0, NULL, 0);
                DWORD cjGlyf = NtGdiGetFontData(hdc, 'fylg', 0, NULL, 0);

            // Subset only if ulCig > gulMaxCig AND this is a tt font, not OTF,
            // Which we test by making sure the font has 'glyf' table. ('fylg',)

                if (bFontSubset = ((ulCig != GDI_ERROR) && (ulCig > gulMaxCig) && (cjGlyf != GDI_ERROR) && cjGlyf))
                {
                    #ifdef DBGSUBSET
                    DbgPrint("bDoFontChange  cig= %lx\n", ulCig);
                    #endif

                    if (!(pBucket = pufihAddUFIEntry(pldc->ppSubUFIHash, &ufi, ulCig, FL_UFI_SUBSET, fl)) ||
                        !(bRet = bAddGlyphIndices(hdc, pBucket, pwsz, c, flETO)))  
                    {
                        bSubsetFail = TRUE;
                    }
                }
            }
            else
            {
                if (!(bRet = bAddGlyphIndices(hdc, pBucket, pwsz, c, flETO)))
                {
                    bSubsetFail = TRUE;
                }
            }

            if (bFontSubset && !bSubsetFail)
            {
                pldc->fl |= LDC_FONT_SUBSET;
            }
            else
            {
                bRet = bAddUFIandWriteSpool(hdc, &ufi, bFontSubset,fl);
            }
        }
    }

    return(bRet);
}


BOOL bRecordEmbedFonts(HDC hdc)
{
    ULONG   cEmbedFonts;
    UNIVERSAL_FONT_ID   ufi;
    DESIGNVECTOR dv;
    ULONG        cjDV = 0;
    ULONG        ulBaseCheckSum;
    KERNEL_PVOID embFontID;
    FLONG       fl = 0;
    PLDC pldc;

    if (!NtGdiGetEmbUFI(hdc, &ufi, &dv, &cjDV, &ulBaseCheckSum, &fl, &embFontID))      // get UFI
        return FALSE;

    if ((fl & (FL_UFI_PRIVATEFONT | FL_UFI_MEMORYFONT)) && embFontID )
    {
        if ((pldc = GET_PLDC(hdc)) == NULL)
            return FALSE;
        
        if (!pufihFindUFIEntry(pldc->ppUFIHash, &ufi, FALSE))               // new UFI
        {
            if(!pufihAddUFIEntry(pldc->ppUFIHash, &ufi, 0, 0, 0))
                return FALSE;
            else
            {
                if (!NtGdiChangeGhostFont(&embFontID, TRUE))
                {
                    vRemoveUFIEntry(pldc->ppUFIHash, &ufi);
                    return FALSE;
                }
    
                if (!WriteFontDataAsEMFComment(
                            pldc,
                            EMRI_EMBED_FONT_EXT,
                            &embFontID,
                            sizeof(VOID *),
                            NULL,
                            0))
                {
                    NtGdiChangeGhostFont(&embFontID, FALSE);                  // Can't record it into the spool file
                    return FALSE;
                }
                
                // check to see whether it gets all of the embedded fonts
            
                cEmbedFonts = NtGdiGetEmbedFonts();
            
                if (cEmbedFonts != 0xFFFFFFFF &&
                    (cEmbedFonts == 1 || cEmbedFonts == GetRecdEmbedFonts(pldc->ppUFIHash)))
                {
                    pldc->fl &= ~LDC_EMBED_FONTS;
                }        
            }
        }
    }

    return TRUE;
}

/**************************************************************************
* BOOL RemoteRasterizerCompatible()
*
* This routine is used if we are about to print using remote EMF.  If a
* Type 1 font rasterizer has been installed on the client machine, we need
* to query the remote machine to make sure that it has a rasterizer that is
* compatable with the local version.  If it isn't, we will return false
* telling the caller that we should go RAW.
*
* History
*   6-4-96 Gerrit van Wingerden [gerritv]
* Wrote it.
*
***************************************************************************/

BOOL gbQueriedRasterizerVersion = FALSE;
UNIVERSAL_FONT_ID gufiLocalType1Rasterizer;

BOOL RemoteRasterizerCompatible(HANDLE hSpooler)
{
// if we haven't queried the rasterizer for the version yet do so first

    UNIVERSAL_FONT_ID ufi;
    LARGE_INTEGER TimeStamp;

    if(!gbQueriedRasterizerVersion)
    {
    // we have a contract with NtGdiQueryFonts (the routine called by the spooler
    // on the remote machine) that if a Type1 rasterizer is installed, the UFI
    // for it will always be first in the UFI list returned.  So we can call
    // NtGdiQueryFonts

        if(!NtGdiQueryFonts(&gufiLocalType1Rasterizer, 1, &TimeStamp))
        {
            WARNING("Unable to get local Type1 information\n");
            return(FALSE);
        }

        gbQueriedRasterizerVersion = TRUE;
    }

    if(!UFI_TYPE1_RASTERIZER(&gufiLocalType1Rasterizer))
    {
    // no need to disable remote printing if there is no ATM driver installed
        return(TRUE);
    }

// Since we made it this far there must be a Type1 rasterizer on the local machine.
// Let's find out the version number of the Type1 rasterizer (if one is installed)
// on the print server.


    if((*fpQueryRemoteFonts)(hSpooler, &ufi, 1 ) &&
       (UFI_SAME_RASTERIZER_VERSION(&gufiLocalType1Rasterizer,&ufi)))
    {
        return(TRUE);
    }
    else
    {
        WARNING("Remote Type1 rasterizer missing or wrong version. Going RAW\n");
        return(FALSE);
    }
}


/****************************************************************
* VOID* AllocCallback(VOID* pvBuffer, size_t size)
*
* Passed to CreateFontPackage() to allocate or reallocate memory
*
* History
*  Jan-07-97 Xudong Wu [tessiew]
* Wrote it.
*****************************************************************/
void* WINAPIV AllocCallback(void* pvBuffer, size_t size)
{
    if (size == 0)
    {
        return (void*)NULL;
    }
    else
    {
        return ((void*)(LocalAlloc(LMEM_FIXED, size)));
    }
}


/****************************************************************
* VOID* ReAllocCallback(VOID* pvBuffer, size_t size)
*
* Passed to CreateFontPackage() to allocate or reallocate memory
*
* History
*  Jan-07-97 Xudong Wu [tessiew]
* Wrote it.
*****************************************************************/
void* WINAPIV ReAllocCallback(void* pvBuffer, size_t size)
{
    if (size == 0)
    {
        return (void*)NULL;
    }
    else if (pvBuffer == (void*)NULL)
    {
        return ((void*)(LocalAlloc(LMEM_FIXED, size)));
    }
    else
    {
        return ((void*)(LocalReAlloc(pvBuffer, size, LMEM_MOVEABLE)));
    }
}


/*******************************************************
* VOID* FreeCallback(VOID* pvBuffer)
*
* Passed to CreateFontPackage() to free memory
*
* History
*  Jan-07-97 Xudong Wu [tessiew]
* Wrote it.
********************************************************/
void WINAPIV FreeCallback(void* pvBuffer)
{
    if (pvBuffer)
    {
        if (LocalFree(pvBuffer))
        {
            WARNING("FreeCallback(): Can't free the local memory\n");
        }
    }
}

/*****************************************************************************
* BOOL bInitSubsetterFunctionPointer(PVOID *ppfn)
*
* the name says it all
*
* History
*   Dec-18-96 Xudong Wu [tessiew]
* Wrote it.
*
******************************************************************************/


BOOL bInitSubsetterFunctionPointer(PVOID *ppfn)
{
    BOOL bRet = TRUE;

    if (*ppfn == NULL)
    {
        HANDLE hFontSubset = LoadLibraryW(L"fontsub.dll");

        if (hFontSubset)
        {
            *ppfn = (PVOID)GetProcAddress(hFontSubset,
                                         (ppfn == (PVOID *)&gfpCreateFontPackage) ?
                                         "CreateFontPackage" : "MergeFontPackage");

            if (*ppfn == NULL)
            {
                FreeLibrary(hFontSubset);
                WARNING("GetProcAddress(fontsub.dll) failed\n");
                bRet = FALSE;
            }
        }
        else
        {
            WARNING("LoadLibrary(fontsub.dll) failed\n");
            bRet = FALSE;
        }
    }
    return bRet;
}

/*****************************************************************************
* BOOL bDoFontSubset
*
* Called everytime we need to subset a font. This routine converts the bit
* fields of pjMemory/u.ssi.pjDelta in pBucket into a glyph index list and call the
* font subsetting functions to generate subset/delta font.
*
* History
*   Dec-18-96 Xudong Wu [tessiew]
* Wrote it.
*
******************************************************************************/

BOOL bDoFontSubset(PUFIHASH pBucket,
    PUCHAR* ppuchDestBuff, // output: buffer will contain the subsetted image or delta
    ULONG* pulDestSize,    // output: size of the buffer above, may be more than needed
    ULONG* pulBytesWritten // output: bytes written into the buffer above
)
{
    BOOL     bDelta = pBucket->fs1 & FLUFI_DELTA;
    USHORT  *pusSubsetKeepList = NULL;
    ULONG   cSubset; // number of glyphs to be subsetted
    BOOL    bRet = FALSE;

#ifdef  DBGSUBSET
    FILETIME    fileTimeStart, fileTimeEnd;
    if (gflSubset & FL_SS_SUBSETTIME)
    {
        GetSystemTimeAsFileTime(&fileTimeStart);
    }
#endif

    ENTERCRITICALSECTION(&semLocal);
    bRet = bInitSubsetterFunctionPointer((PVOID *)&gfpCreateFontPackage);
    LEAVECRITICALSECTION(&semLocal);

    if (!bRet)
        return FALSE;
    bRet = FALSE;

    cSubset = bDelta ? pBucket->u.ssi.cDeltaGlyphs : pBucket->u.ssi.cGlyphsSoFar;

#ifdef  DBGSUBSET
    if (gflSubset & FL_SS_KEEPLIST)
    {
        DbgPrint("\t%ld", cSubset);
    }
#endif //  DBGSUBSET

    pusSubsetKeepList = (USHORT*)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(USHORT) * cSubset);

    if (pusSubsetKeepList == NULL)
    {
        WARNING("bDoFontSubset unable to allocate memory for pusSubsetKeepList\n");
        return FALSE;
    }

// transfer appropriate bit field into glyph indices

    if (bGetDistGlyphIndices(pBucket, pusSubsetKeepList, bDelta))
    {
        WCHAR    pwszPathname[MAX_PATH * 3];
        ULONG    cwcPathname, cNumFiles;
        BOOL     bMemFont = FALSE, bMapOK = TRUE;
        ULONG    cjView;
        PVOID    pvView = NULL;
        BOOL     bTTC = FALSE;
        ULONG    iTTC = 0;

    // Instead of calling NtGdiGetUFIBits, we get the file path and map the file

        if (NtGdiGetUFIPathname(&pBucket->ufi,
                                &cwcPathname,
                                pwszPathname,
                                &cNumFiles,
                                pBucket->fs2,
                                &bMemFont,
                                &cjView,
                                NULL,
                                &bTTC,
                                &iTTC))

        {
            PVOID   pvSrcBuff;
            ULONG   ulSrcSize;
            CLIENT_SIDE_FILEVIEW  fvw;

            if (!bMemFont)
            {
                ASSERTGDI(cNumFiles == 1, "bDoFontSubset:  cNumFiles != 1\n");

                if (bMapOK = bMapFileUNICODEClideSide(pwszPathname, &fvw, TRUE))
                {
                    pvSrcBuff = (PVOID)fvw.pvView;
                    ulSrcSize = fvw.cjView;
                }
            }
            else
            {
                pvView = LocalAlloc(LMEM_FIXED, cjView);
                if (pvView)
                {
                    if (NtGdiGetUFIPathname(&pBucket->ufi,NULL,NULL,NULL,
                        pBucket->fs2,NULL,NULL,pvView,NULL,NULL))
                    {
                        bMapOK = TRUE;
                        pvSrcBuff = (PVOID)pvView;
                        ulSrcSize = cjView;
                    }
                    else
                    {
                        LocalFree(pvView);
                    }
                }
            }

            if (bMapOK)
            {
            // font subsetting

                ASSERTGDI(gfpCreateFontPackage != NULL, "fonsub.dll is not load\n");

                if ((*gfpCreateFontPackage)((PUCHAR)pvSrcBuff,
                                             ulSrcSize,
                                             ppuchDestBuff,
                                             pulDestSize,
                                             pulBytesWritten,
                                             (USHORT)(bTTC ? 0x000d : 0x0009),      // TTFCFP_FLAGS_SUBSET | TTFCFP_FLAGS_GLYPHLIST
                                             (USHORT)iTTC,                // usTTCIndex
                                             (USHORT)(bDelta ? 2 : 1),    // usSubsetFormat
                                             0,                           // usSubsetLanguage
                                             3,                           // usSubsetPlatform  TTFCFP_MS_PLATFORMID
                                             0xFFFF,                      // usSubsetEncoding  TTFCFP_DONT_CARE
                                             pusSubsetKeepList,
                                             (USHORT)cSubset,
                                             (CFP_ALLOCPROC)AllocCallback,
                                             (CFP_REALLOCPROC)ReAllocCallback,
                                             (CFP_FREEPROC)FreeCallback,
                                             NULL)  != 0)
                {
                    WARNING("bDofontSubset failed on gfpCreateFontPackage\n");
                }
                else
                {
                    if (bDelta)      // clean up the u.ssi.pjDelta and u.ssi.cDeltaGlyphs
                    {
                        LocalFree(pBucket->u.ssi.pjDelta);
                        pBucket->u.ssi.pjDelta = NULL;
                        pBucket->u.ssi.cDeltaGlyphs = 0;
                    }
                    else    // set fs1 to prepare for the next page.
                    {
                        pBucket->fs1 = FLUFI_DELTA;
                    }

                    bRet = TRUE;
                }

                if (bMemFont)
                {
                    LocalFree(pvView);
                }
                else
                {
                    vUnmapFileClideSide(&fvw);
                }
            }
            else
            {
                WARNING("bDoFontSubset: failed on bMapFileUNICODEClideSide()\n");
            }
        }
        else
        {
            WARNING("bDoFontSubset: failed on NtGdiGetUFIPathname()\n");
        }
    }
    else
    {
        WARNING("bDoFontSubset: failed on bGetDistGlyphIndices()\n");
    }

    LocalFree(pusSubsetKeepList);

//Timing code
#ifdef  DBGSUBSET
    if (gflSubset & FL_SS_SUBSETTIME)
    {
        GetSystemTimeAsFileTime(&fileTimeEnd);
        DbgPrint("\t%ld",
            (fileTimeEnd.dwLowDateTime - fileTimeStart.dwLowDateTime) / 10000);
    }
#endif

    return bRet;
}

/************************************************************************************
* BOOL WriteSubFontToSpoolFile(HANDLE, PUCHAR, ULONG, UNIVERSAL_FONT_ID, BOOL)
*
* Write subsetted font or a delta in the print spool file.
*
* History
*   Jan-09-97 Xudong Wu [tessiew]
* Wrote it.
*
*************************************************************************************/
BOOL  WriteSubFontToSpoolFile(
    PLDC               pldc,
    PUCHAR             puchBuff,         // image pointer
    ULONG              ulBytesWritten,   // bytes to be written to spool file
    UNIVERSAL_FONT_ID *pufi,             // ufi of the original font file
    BOOL               bDelta            // delta or first page
)
{
    BOOL bRet = FALSE;

#ifdef  DBGSUBSET
    FILETIME    fileTimeStart, fileTimeEnd;
    if (gflSubset & FL_SS_SPOOLTIME)
    {
        GetSystemTimeAsFileTime(&fileTimeStart);
    }
#endif

    if (ulBytesWritten)
    {
        DWORD ulID = bDelta ? EMRI_DELTA_FONT : EMRI_SUBSET_FONT;

    #ifdef  DBGSUBSET
        if (gflSubset & FL_SS_BUFFSIZE)
        {
            DbgPrint("\t%ld\n", ulBytesWritten);
        }
    #endif // DBGSUBSET

        if (WriteFontDataAsEMFComment(
                    pldc,
                    ulID,
                    pufi,
                    sizeof(UNIVERSAL_FONT_ID),
                    puchBuff,
                    ulBytesWritten))
        {
            bRet = TRUE;
        }
        else
        {
            WARNING("WriteSubFontToSpooler: error writing to printer\n");
        }

        LocalFree(puchBuff);
    }
    else
    {
        WARNING("WriteSubFontToSpooler: input ulBytesWritten == 0\n");
    }

//timing code
#ifdef  DBGSUBSET
    if (gflSubset & FL_SS_SPOOLTIME)
    {
        GetSystemTimeAsFileTime(&fileTimeEnd);
        DbgPrint("\t%ld", (fileTimeEnd.dwLowDateTime - fileTimeStart.dwLowDateTime) / 10000);
    }
#endif
    return(bRet);
}


/************************************************************************************
* BOOL bMergeSubsetFont(HDC, PVOID, ULONG, PVOID*, ULONG*, BOOL, UNIVERSAL_FONT_ID*)
*
* Merge the font delta into a working font containing pages up to this one.
* This routine is only called on print server
*
* History
*   Jan-12-97 Xudong Wu [tessiew]
* Wrote it.
*
*************************************************************************************/
BOOL bMergeSubsetFont(
    HDC    hdc,
    PVOID  pvBuf,
    ULONG  ulBuf,
    PVOID* ppvOutBuf,
    ULONG* pulOutSize,
    BOOL   bDelta,
    UNIVERSAL_FONT_ID *pufi)
{
    PLDC   pldc;
    PBYTE  pjBase;
    ULONG  ulMergeBuf, ulBytesWritten, ulBaseFontSize = 0;
    PVOID  pvMergeBuf, pvBaseFont = NULL;
    UFIHASH  *pBucket = NULL;
    BOOL    bRet = FALSE;

#define SZDLHEADER    ((sizeof(DOWNLOADFONTHEADER) + 7)&~7)

    ENTERCRITICALSECTION(&semLocal);
    bRet = bInitSubsetterFunctionPointer((PVOID *)&gfpMergeFontPackage);
    LEAVECRITICALSECTION(&semLocal);

    if (!bRet)
        return FALSE;

// get the orignal UFI

    *pufi = *(PUNIVERSAL_FONT_ID) pvBuf;

    pjBase = (PBYTE)pvBuf + sizeof(UNIVERSAL_FONT_ID);
    ulBuf -= sizeof(UNIVERSAL_FONT_ID);

    pldc = GET_PLDC(hdc);

    if (pldc == NULL)
    {
    WARNING("bMergeSubsetFont: unable to retrieve pldc\n");
    return FALSE;
    }

    ASSERTGDI(!pldc->ppUFIHash, "printer server side ppUFIHash != NULL\n");
    ASSERTGDI(!pldc->ppDVUFIHash,"printer server side ppDVUFIHash != NULL\n");

// init the hash table if needed

    if (pldc->ppSubUFIHash == NULL)
    {
        pldc->ppSubUFIHash = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(PUFIHASH) * UFI_HASH_SIZE);

        if(pldc->ppSubUFIHash == NULL)
        {
            WARNING("bMergeSubsetFont: unable to allocate UFI hash table2\n");
            return FALSE;
        }
    }

// for delta merge, get the font image from pBucket->u.mvw.pjMem

    if (bDelta)
    {
        pBucket = pufihFindUFIEntry(pldc->ppSubUFIHash, pufi, TRUE);

        if (!pBucket)
            return FALSE;
            
    // We need to exclude the DOWNLOADFONTHEADER
    // information from the pBucket->u.mvw.pjMem

        pvBaseFont = pBucket->u.mvw.pjMem + SZDLHEADER;
        ulBaseFontSize = pBucket->u.mvw.cjMem - SZDLHEADER;
    }

    if ((*gfpMergeFontPackage)((UCHAR*)pvBaseFont, ulBaseFontSize,
                                   (PUCHAR)pjBase, ulBuf,
                                   (PUCHAR*)&pvMergeBuf, &ulMergeBuf, &ulBytesWritten,
                                   (USHORT) (bDelta ? 2 : 1),     //usMode 1=generate font; 2=delta merge
                                   (CFP_ALLOCPROC)AllocCallback,
                                   (CFP_REALLOCPROC)ReAllocCallback,
                                   (CFP_FREEPROC)FreeCallback,
                                   NULL) != 0)
    {
        WARNING("MergeSubsetFont failed on funsub!MergeFontPackage\n");
    }
    else
    {
    // In order to use FreeFileView when we delete the font after printing,
    // we need a fake DOWNLOADFONTHEADER
    // before we pass the buffer into kenerl for NtGdiAddRemoteFontToDC call.

        *pulOutSize = SZDLHEADER + ulBytesWritten;
        *ppvOutBuf = (PVOID*)LocalAlloc(LMEM_FIXED, *pulOutSize);

        if (*ppvOutBuf == NULL)
        {
            WARNING("bMergeSubsetFont failed to alloc memory\n");
        }
        else
        {
            DOWNLOADFONTHEADER  *pdfh;

            pdfh = (DOWNLOADFONTHEADER*)*ppvOutBuf;
            pdfh->Type1ID = 0;
            pdfh->NumFiles = 1;
            pdfh->FileOffsets[0] = ulBytesWritten;

            RtlCopyMemory((PVOID)((PBYTE)*ppvOutBuf + SZDLHEADER), pvMergeBuf, ulBytesWritten);

            if (bWriteUFItoDC(pldc->ppSubUFIHash, pufi, pBucket, *ppvOutBuf, *pulOutSize))
            {
                bRet = TRUE;
            }
            else
            {
                LocalFree(*ppvOutBuf);
                WARNING("bMergeSubsetFont failed on bWriteUFItoDC\n");
            }
        }

// pvMergeBuf comes from the merge routine which uses LMEM_MOVEABLE
// for memory allocation Needs to be freed by the handle.

        LocalFree(pvMergeBuf);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\gdiplus\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\keizon\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\xform.c ===
/******************************Module*Header*******************************\
* Module Name: xform.c
*
* Created: 01-Dec-1994 09:58:41
* Author:  Eric Kutter [erick]
*
* Copyright (c) 1993-1999 Microsoft Corporation
*
\**************************************************************************/
#include "precomp.h"
#pragma hdrstop


/******************************Macro***************************************\
*
* Transform macros
*
*
*
*
*
*
*
* History:
*
*    16-Jan-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/


#define DCA_PAGE_EXTENTS_CHANGED(pdcattr)               \
{                                                       \
    CLEAR_CACHED_TEXT(pdcattr);                         \
    pdcattr->flXform |= (INVALIDATE_ATTRIBUTES    |     \
                         PAGE_EXTENTS_CHANGED     |     \
                         DEVICE_TO_WORLD_INVALID);      \
}

#define DCA_PAGE_XLATE_CHANGED(pdcattr)                 \
{                                                       \
    pdcattr->flXform |=  (PAGE_XLATE_CHANGED |          \
                          DEVICE_TO_WORLD_INVALID);     \
}


#define GET_LOGICAL_WINDOW_ORG_X(pdcattr, pptl)         \
{                                                       \
    pptl->x  = pdcattr->lWindowOrgx;                    \
}

#define SET_LOGICAL_WINDOW_ORG_X(pdcattr, x)            \
{                                                       \
    pdcattr->lWindowOrgx = x;                           \
}

#define MIRROR_WINDOW_ORG(hdc, pdcAttr)                 \
{                                                       \
    if (pdcAttr->dwLayout & LAYOUT_RTL) {               \
        NtGdiMirrorWindowOrg(hdc);                      \
    }                                                   \
}

#define MIRROR_X(pdcAttr, x)                            \
{                                                       \
    if (pdcAttr->dwLayout & LAYOUT_RTL)                 \
        x = -x;                                         \
}

DWORD APIENTRY
SetLayoutWidth(HDC hdc, LONG wox, DWORD dwLayout)
{

    DWORD dwRet = GDI_ERROR;

    FIXUP_HANDLE(hdc);
    if(!IS_ALTDC_TYPE(hdc))
    {
        PDC_ATTR pdcattr;
        PSHARED_GET_VALIDATE((PVOID)pdcattr,hdc,DC_TYPE);

        if (pdcattr) {
            dwRet = NtGdiSetLayout(hdc, wox, dwLayout);
        } else {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
        }
    }

    return dwRet;
}

DWORD APIENTRY
SetLayout(HDC hdc, DWORD dwLayout)
{
    PDC_ATTR pdcattr;
    DWORD dwRet = GDI_ERROR;

    FIXUP_HANDLE(hdc);
    if(IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParmsD(hdc,dwLayout,META_SETLAYOUT));

        DC_PLDC(hdc,pldc,dwRet)

        if (pldc->iType == LO_METADC) {
            if (!MF_SetD(hdc,dwLayout,EMR_SETLAYOUT)) {
                return dwRet;
            }
        }
    }

    PSHARED_GET_VALIDATE((PVOID)pdcattr,hdc,DC_TYPE);

    if (pdcattr) {
        dwRet = NtGdiSetLayout(hdc, -1, dwLayout);
    } else {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return dwRet;
}

DWORD APIENTRY
GetLayout(HDC hdc)
{
    DWORD dwRet = GDI_ERROR;

    FIXUP_HANDLE(hdc);

    if(!IS_METADC16_TYPE(hdc)) {
        PDC_ATTR pdcattr;
        PSHARED_GET_VALIDATE((PVOID)pdcattr,hdc,DC_TYPE);

        if (pdcattr) {
            dwRet = pdcattr->dwLayout;
        } else {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
        }
    }
    return dwRet;
}
/******************************Public*Routine******************************\
* GetMapMode                                                               *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Fri 07-Jun-1991 18:01:50 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

int APIENTRY GetMapMode(HDC hdc)
{
    int iRet = 0;

    FIXUP_HANDLE(hdc);

    if (!IS_METADC16_TYPE(hdc))
    {
        PDC_ATTR pdcattr;
        PSHARED_GET_VALIDATE((PVOID)pdcattr,hdc,DC_TYPE);

        if (pdcattr)
        {
            iRet = pdcattr->iMapMode;
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
        }
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* SetMapMode                                                               *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
*                                                                          *
*  Mon 22-May-1993 -by- Paul Butzi                                         *
* Converted to Size measured in micrometers.                               *
\**************************************************************************/

int META WINAPI SetMapMode(HDC hdc,int iMode)
{
    int iRet = 0;

    FIXUP_HANDLE(hdc);

    if (IS_METADC16_TYPE(hdc))
    {
        iRet = MF16_RecordParms2(hdc,iMode,META_SETMAPMODE);
    }
    else
    {
        PDC_ATTR pdcattr;
        PSHARED_GET_VALIDATE((PVOID)pdcattr,hdc,DC_TYPE);

        if (pdcattr)
        {

            iRet = pdcattr->iMapMode;

            if ((iMode != pdcattr->iMapMode) || (iMode == MM_ISOTROPIC))
            {

               CLEAR_CACHED_TEXT(pdcattr);

               iRet =(int) GetAndSetDCDWord(
                                         hdc,
                                         GASDDW_MAPMODE,
                                         iMode,
                                         EMR_SETMAPMODE,
                                         0,
                                         0);
            }
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
        }
    }

    return(iRet);
}

/******************************Public*Function*****************************\
* GetWindowExtEx
* GetViewportOrgEx
* GetWindowOrgEx
*
* Client side stub.
*
* History:
*
*  11-Jan-1996 -by- Mark Enstrom [marke]
* User dcattr for ext and org data
*  09-Dec-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GetViewportExtEx(HDC hdc,LPSIZE psizl)
{
    BOOL bRet = FALSE;
    PDC_ATTR pdcattr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE((PVOID)pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        if (psizl != (PSIZEL) NULL)
        {
            if ((pdcattr->flXform & PAGE_EXTENTS_CHANGED) &&
                (pdcattr->iMapMode == MM_ISOTROPIC))
            {
                NtGdiGetDCPoint (hdc, DCPT_VPEXT, (PPOINTL)psizl);
            }
            else
            {
                *psizl = pdcattr->szlViewportExt;
            }

            bRet = TRUE;
        }
    }

    return(bRet);

}

BOOL APIENTRY GetWindowExtEx(HDC hdc,LPSIZE psizl)
{
   BOOL bRet = FALSE;
   PDC_ATTR pdcattr;

   FIXUP_HANDLE(hdc);

   PSHARED_GET_VALIDATE((PVOID)pdcattr,hdc,DC_TYPE);

   if (pdcattr)
   {
       if (psizl != (PSIZEL) NULL)
       {
           *psizl = pdcattr->szlWindowExt;
           MIRROR_X(pdcattr, psizl->cx);
           bRet = TRUE;
       }
   }

   return(bRet);

}

BOOL APIENTRY GetViewportOrgEx(HDC hdc,LPPOINT pptl)
{
    BOOL bRet = FALSE;
    PDC_ATTR pdcattr;

    FIXUP_HANDLE(hdc);
    //
    // get DCATTR
    //

    PSHARED_GET_VALIDATE((PVOID)pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {

        if (pptl != (LPPOINT) NULL)
        {
            *pptl = *((LPPOINT)&pdcattr->ptlViewportOrg);
            MIRROR_X(pdcattr, pptl->x);
            bRet = TRUE;
        }
    }

    return(bRet);

}

BOOL APIENTRY GetWindowOrgEx(HDC hdc,LPPOINT pptl)
{
    BOOL bRet = FALSE;
    PDC_ATTR pdcattr;

    FIXUP_HANDLE(hdc);

    //
    // get DCATTR
    //

    PSHARED_GET_VALIDATE((PVOID)pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {

        if (pptl != (LPPOINT) NULL)
        {
            *pptl = *((LPPOINT)&pdcattr->ptlWindowOrg);
            GET_LOGICAL_WINDOW_ORG_X(pdcattr, pptl);
            bRet = TRUE;
        }
    }

    return(bRet);

}

/******************************Public*Routine******************************\
* SetViewportExtEx                                                         *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI SetViewportExtEx(HDC hdc,int x,int y,LPSIZE psizl)
{
    BOOL bRet = FALSE;
    PDC_ATTR pdcattr;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParms3(hdc,x,y,META_SETVIEWPORTEXT));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SetViewportExtEx(hdc,x,y))
                return(bRet);
        }
    }

    PSHARED_GET_VALIDATE((PVOID)pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        //
        // if psizl is supplied, return old viewport ext
        //

        if (psizl != (PSIZEL) NULL)
        {
            *psizl = pdcattr->szlViewportExt;
        }

        //
        // if fixed scale and new exts equal old exts then no work needs
        // to be done
        //

        if (
             (pdcattr->iMapMode <= MM_MAX_FIXEDSCALE) ||
             (
               (pdcattr->szlViewportExt.cx == x) &&
               (pdcattr->szlViewportExt.cy == y)
             )
           )
        {
            return(TRUE);
        }

        //
        // Can't set to zero extents.
        //

        if ((x == 0) || (y == 0))
        {
            return(TRUE);
        }

        //
        // update extents and flags
        //
        CHECK_AND_FLUSH(hdc, pdcattr);

        pdcattr->szlViewportExt.cx = x;
        pdcattr->szlViewportExt.cy = y;
        MIRROR_WINDOW_ORG(hdc, pdcattr);

        DCA_PAGE_EXTENTS_CHANGED(pdcattr);

        return(TRUE);
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* SetViewportOrgEx                                                         *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI SetViewportOrgEx(HDC hdc,int x,int y,LPPOINT pptl)
{
    POINT pt;
    BOOL bRet = FALSE;
    PDC_ATTR pdcattr;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParms3(hdc,x,y,META_SETVIEWPORTORG));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SetViewportOrgEx(hdc,x,y))
                return(bRet);
        }
    }

    //
    // get DCATTR
    //

    PSHARED_GET_VALIDATE((PVOID)pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        bRet = TRUE;
        MIRROR_X(pdcattr, x);

        if (pptl != (LPPOINT) NULL)
        {
            *pptl = *((LPPOINT)&pdcattr->ptlViewportOrg);
            MIRROR_X(pdcattr, pptl->x);
        }

        if (!
             ((pdcattr->ptlViewportOrg.x == x) && (pdcattr->ptlViewportOrg.y == y))
           )
        {
             pdcattr->ptlViewportOrg.x = x;
             pdcattr->ptlViewportOrg.y = y;

             DCA_PAGE_XLATE_CHANGED(pdcattr);
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* SetWindowExtEx                                                           *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI SetWindowExtEx(HDC hdc,int x,int y,LPSIZE psizl)
{
    BOOL bRet = FALSE;
    PDC_ATTR pdcattr;

#if DBG_XFORM
    DbgPrint("SetWindowExtEx: hdc = %p, (%lx, %lx)\n", hdc, x, y);
#endif

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParms3(hdc,x,y,META_SETWINDOWEXT));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SetWindowExtEx(hdc,x,y))
                return(bRet);
        }
    }

    PSHARED_GET_VALIDATE((PVOID)pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        bRet = TRUE;

        //
        // Get old extents and return if either of these is true
        // 1) Fixed scale mapping mode.  (Can't change extent)
        // 2) Set to the same size.
        //
        MIRROR_X(pdcattr, x);

        if (psizl != (PSIZEL) NULL)
        {
            *psizl = pdcattr->szlWindowExt;
            MIRROR_X(pdcattr, psizl->cx);
        }

        if (
             (pdcattr->iMapMode <= MM_MAX_FIXEDSCALE) ||
             ((pdcattr->szlWindowExt.cx == x) && (pdcattr->szlWindowExt.cy == y))
           )
        {
            return(TRUE);
        }

        //
        // Can't set to zero.
        //

        if (x == 0 || y == 0)
        {
            return(FALSE);
        }

        CHECK_AND_FLUSH(hdc,pdcattr);

        pdcattr->szlWindowExt.cx = x;
        pdcattr->szlWindowExt.cy = y;
        MIRROR_WINDOW_ORG(hdc, pdcattr);

        DCA_PAGE_EXTENTS_CHANGED(pdcattr);
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* SetWindowOrgEx                                                           *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI SetWindowOrgEx(HDC hdc,int x,int y,LPPOINT pptl)
{
    BOOL bRet = FALSE;
    PDC_ATTR pdcattr;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParms3(hdc,x,y,META_SETWINDOWORG));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SetWindowOrgEx(hdc,x,y))
                return(bRet);
        }
    }

    PSHARED_GET_VALIDATE((PVOID)pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {

        bRet = TRUE;

        if (pptl != (LPPOINT) NULL)
        {
            *pptl = *((LPPOINT)&pdcattr->ptlWindowOrg);
            GET_LOGICAL_WINDOW_ORG_X(pdcattr, pptl);
        }

        if (
            !((pdcattr->ptlWindowOrg.x == x) && (pdcattr->ptlWindowOrg.y == y))
           )
        {
            CHECK_AND_FLUSH(hdc,pdcattr);

            pdcattr->ptlWindowOrg.x = x;
            pdcattr->ptlWindowOrg.y = y;
            SET_LOGICAL_WINDOW_ORG_X(pdcattr, x);
            MIRROR_WINDOW_ORG(hdc, pdcattr);

            DCA_PAGE_XLATE_CHANGED(pdcattr);
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* OffsetViewportOrgEx                                                      *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI OffsetViewportOrgEx(HDC hdc,int x,int y,LPPOINT pptl)
{
    POINT pt;
    BOOL bRet = FALSE;
    PDC_ATTR pdcattr;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParms3(hdc,x,y,META_OFFSETVIEWPORTORG));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_OffsetViewportOrgEx(hdc,x,y))
                return(bRet);
        }
    }

    //
    // get DCATTR
    //

    PSHARED_GET_VALIDATE((PVOID)pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        bRet = TRUE;
        MIRROR_X(pdcattr, x);

        if (pptl != (LPPOINT) NULL)
        {
            *pptl = *((LPPOINT)&pdcattr->ptlViewportOrg);
            MIRROR_X(pdcattr, pptl->x);
        }

        if ((x != 0) || (y != 0))
        {
            CHECK_AND_FLUSH(hdc, pdcattr);

            pdcattr->ptlViewportOrg.x+=x;
            pdcattr->ptlViewportOrg.y+=y;

            DCA_PAGE_XLATE_CHANGED(pdcattr);
        }

    }

    return(bRet);
}

/******************************Public*Routine******************************\
* OffsetWindowOrgEx                                                        *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI OffsetWindowOrgEx(HDC hdc,int x,int y,LPPOINT pptl)
{
    BOOL bRet = FALSE;
    PDC_ATTR pdcattr;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParms3(hdc,x,y,META_OFFSETWINDOWORG));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_OffsetWindowOrgEx(hdc,x,y))
                return(bRet);
        }
    }

    PSHARED_GET_VALIDATE((PVOID)pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {

        bRet = TRUE;

        if (pptl != (LPPOINT) NULL)
        {
            *pptl = *((LPPOINT)&pdcattr->ptlWindowOrg);
            GET_LOGICAL_WINDOW_ORG_X(pdcattr, pptl);
        }

        if ((x != 0) || (y != 0))
        {
            CHECK_AND_FLUSH(hdc,pdcattr);

            pdcattr->ptlWindowOrg.x+=x;
            pdcattr->ptlWindowOrg.y+=y;
            pdcattr->lWindowOrgx   +=x;
            DCA_PAGE_XLATE_CHANGED(pdcattr);
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
*
* int SetGraphicsMode(HDC hdc,int iMode)
*
* the same as SetGraphicsMode, except it does not do any checks
*
* History:
*  3-Nov-1994 -by- Lingyun Wang [lingyunw]
* moved client side attr to server side
*  02-Dec-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

int META APIENTRY SetGraphicsMode(HDC hdc,int iMode)
{
    int iRet = 0;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE((PVOID)pDcAttr,hdc,DC_TYPE);

    if (pDcAttr &&
        ((iMode == GM_COMPATIBLE) || (iMode == GM_ADVANCED)))

    {
        if (iMode == pDcAttr->iGraphicsMode)
            return iMode;

        CLEAR_CACHED_TEXT(pDcAttr);

        iRet = pDcAttr->iGraphicsMode;

        CHECK_AND_FLUSH(hdc,pDcAttr);

        pDcAttr->iGraphicsMode = iMode;


    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* ScaleViewportExtEx                                                         *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI ScaleViewportExtEx
(
    HDC hdc,
    int xNum,
    int xDenom,
    int yNum,
    int yDenom,
    LPSIZE psizl
)
{
    BOOL bRet = FALSE;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return (MF16_RecordParms5(hdc,xNum,xDenom,yNum,
                                      yDenom,META_SCALEVIEWPORTEXT));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SetDDDD(hdc,(DWORD)xNum,(DWORD)xDenom,
                            (DWORD)yNum,(DWORD)yDenom,EMR_SCALEVIEWPORTEXTEX))
                return(bRet);
        }
    }

    PSHARED_GET_VALIDATE((PVOID)pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        CLEAR_CACHED_TEXT(pDcAttr);
        bRet = NtGdiScaleViewportExtEx(hdc,xNum,xDenom,yNum,yDenom,psizl);
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(bRet);
}


/******************************Public*Routine******************************\
* ScaleWindowExtEx                                                         *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI ScaleWindowExtEx
(
    HDC hdc,
    int xNum,
    int xDenom,
    int yNum,
    int yDenom,
    LPSIZE psizl
)
{
    BOOL  bRet = FALSE;

    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return (MF16_RecordParms5(hdc,xNum,xDenom,yNum,yDenom,META_SCALEWINDOWEXT));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SetDDDD(hdc,(DWORD)xNum,(DWORD)xDenom,(DWORD)yNum,(DWORD)yDenom,EMR_SCALEWINDOWEXTEX))
                return(bRet);
        }
    }

    PSHARED_GET_VALIDATE((PVOID)pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        CLEAR_CACHED_TEXT(pDcAttr);
        bRet = NtGdiScaleWindowExtEx(hdc,xNum,xDenom,yNum,yDenom,psizl);
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* SetVirtualResolution                                                     *
*                                                                          *
* Client side stub.  This is a private api for metafile component.         *
*                                                                          *
* Set the virtual resolution of the specified dc.                          *
* The virtual resolution is used to compute transform matrix in metafiles. *
* Otherwise, we will need to duplicate server transform code here.         *
*                                                                          *
* If the virtual units are all zeros, the default physical units are used. *
* Otherwise, non of the units can be zero.                                 *
*                                                                          *
* Currently used by metafile component only.                               *
*                                                                          *
* History:                                                                 *
*  Tue Aug 27 16:55:36 1991     -by-    Hock San Lee    [hockl]            *
* Wrote it.                                                                *
\**************************************************************************/

BOOL WINAPI SetVirtualResolution
(
    HDC    hdc,
    int    cxVirtualDevicePixel,     // Width of the device in pels
    int    cyVirtualDevicePixel,     // Height of the device in pels
    int    cxVirtualDeviceMm,        // Width of the device in millimeters
    int    cyVirtualDeviceMm         // Height of the device in millimeters
)
{
    FIXUP_HANDLE(hdc);

    return(NtGdiSetVirtualResolution(
                hdc,
                cxVirtualDevicePixel,
                cyVirtualDevicePixel,
                cxVirtualDeviceMm,
                cyVirtualDeviceMm
                ));
}

/******************************Public*Routine******************************\
* SetSizeDevice                                                            *
*                                                                          *
* Client side stub.  This is a private api for metafile component.         *
*                                                                          *
* This is to fix rounding error in vMakeIso in xformgdi.cxx                *
* The cx/yVirtualDeviceMm set in SetVirtualResoltion could result in slight*
* rounding error which will cause problem when accumulated                 *
*                                                                          *
* Currently used by metafile component only.                               *
*                                                                          *
* History:                                                                 *
*  5/17/99     -by-    Lingyun Wang    [lingyunw]                          *
* Wrote it.                                                                *
\**************************************************************************/
BOOL SetSizeDevice
(
    HDC    hdc,
    int    cxVirtualDevice,        // Width of the device in micrometers
    int    cyVirtualDevice         // Height of the device in micrometers
)
{
    FIXUP_HANDLE(hdc);

    return(NtGdiSetSizeDevice(
                hdc,
                cxVirtualDevice,
                cyVirtualDevice
                ));
}


/******************************Public*Routine******************************\
* GetTransform()
*
* History:
*  30-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GetTransform(
    HDC     hdc,
    ULONG   iXform,
    PXFORM  pxf)
{
    FIXUP_HANDLE(hdc);
    return(NtGdiGetTransform(hdc,iXform,pxf));
}

/******************************Public*Routine******************************\
* GetWorldTransform                                                        *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Fri 07-Jun-1991 18:01:50 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL APIENTRY GetWorldTransform(HDC hdc,LPXFORM pxform)
{
    FIXUP_HANDLE(hdc);
    return(GetTransform(hdc,XFORM_WORLD_TO_PAGE,pxform));
}

/******************************Public*Routine******************************\
* ModifyTransform()
*
* History:
*  30-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL META WINAPI ModifyWorldTransform(
    HDC          hdc,
    CONST XFORM *pxf,
    DWORD        iMode)
{
    BOOL bRet = FALSE;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(FALSE);

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (((iMode == MWT_SET) && !MF_SetWorldTransform(hdc,pxf)) ||
                !MF_ModifyWorldTransform(hdc,pxf,iMode))
            {
                return(FALSE);
            }
        }
    }

    PSHARED_GET_VALIDATE((PVOID)pDcAttr,hdc,DC_TYPE);
    if (pDcAttr)
    {
        if (pDcAttr->iGraphicsMode == GM_ADVANCED)
        {
            CLEAR_CACHED_TEXT(pDcAttr);
            bRet = NtGdiModifyWorldTransform(hdc,(PXFORM)pxf,iMode);
        }
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }
    return(bRet);
}

/******************************Public*Routine******************************\
* SetWorldTransform                                                        *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI SetWorldTransform(HDC hdc, CONST XFORM * pxform)
{
    return(ModifyWorldTransform(hdc,pxform,MWT_SET));
}

/******************************Public*Routine******************************\
* CombineTransform                                                         *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 30-Jan-1992 16:10:09 -by- Wendy Wu [wendywu]                        *
* Wrote it.                                                                *
\**************************************************************************/

BOOL WINAPI CombineTransform
(
     LPXFORM pxformDst,
     CONST XFORM * pxformSrc1,
     CONST XFORM * pxformSrc2
)
{
    return(NtGdiCombineTransform(pxformDst,(PXFORM)pxformSrc1,(PXFORM)pxformSrc2));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\wow6432\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\umpddrv.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    umpddrv.c

Abstract:

    User-mode printer driver stubs for Drv callback functions

Environment:

        Windows NT 5.0

Revision History:

        09/30/97 -lingyunw-
                Created it by moving GdiPrinterThunk out of umpd.c.

--*/

#include "precomp.h"
#pragma hdrstop

RTL_CRITICAL_SECTION semUMPD;   // Critical section for user-mode printer driver

#if !defined(_GDIPLUS_)

#include "winddi.h"
#include "proxyport.h"

/*
#if DBG
#define DBG_TRACE(x) DbgPrint("UMPD: "#x"\n")
#else
#define DBG_TRACE(x)
#endif
*/

//
// Adjust user mode printer driver DHPDEV field in a SURFOBJ
//

__inline PUMDHPDEV
AdjustUMdhpdev(
    SURFOBJ *pso
    )

{
    PUMDHPDEV   pUMdhpdev = (PUMDHPDEV) pso->dhpdev;

    pso->dhpdev = pUMdhpdev->dhpdev;
    return pUMdhpdev;
}
  

BOOL
GdiCopyFD_GLYPHSET(
    FD_GLYPHSET *dst,
    FD_GLYPHSET *src,
    ULONG       cjSize
    )

{
    ULONG   index, offset, size;
    PBYTE   phg, pbMax;
    
    size = offsetof(FD_GLYPHSET, awcrun) + src->cRuns * sizeof(WCRUN);
    RtlCopyMemory(dst, src, size);

    dst->cjThis = cjSize;
    pbMax = (PBYTE)dst + cjSize;
    phg = (PBYTE)dst + size;
        
    //
    // Patch up memory pointers in each WCRUN structure
    //

    for (index=0; index < src->cRuns; index++)
    {
        if (src->awcrun[index].phg != NULL)
        {
            size = src->awcrun[index].cGlyphs * sizeof(HGLYPH);

            if (phg + size <= pbMax)
            {
                RtlCopyMemory(phg, src->awcrun[index].phg, size);
                dst->awcrun[index].phg = (HGLYPH*) phg;
                phg += size;
            }
            else
                return FALSE;
        }
    }

    return TRUE;
}

BOOL  bAddPrinterHandle(PUMPD pUMPD, DWORD clientPid, DWORD hPrinter32, HANDLE hPrinter64)
{
    PHPRINTERLIST pPtrList;
    BOOL bRet = FALSE;
    
    if (pPtrList = LOCALALLOC(sizeof(HPRINTERLIST)))
    {
        pPtrList->clientPid = clientPid;
        pPtrList->hPrinter32 = hPrinter32;
        pPtrList->hPrinter64 = hPrinter64;
        
        ENTERCRITICALSECTION(&semUMPD);
        
        pPtrList->pNext = pUMPD->pHandleList;
        pUMPD->pHandleList = pPtrList;
        
        bRet = TRUE;

        LEAVECRITICALSECTION(&semUMPD);
    }
    
    return bRet;
}

PHPRINTERLIST FindPrinterHandle(PUMPD pUMPD, DWORD clientPid, DWORD hPrinter32)
{
    PHPRINTERLIST pList;
    
    ENTERCRITICALSECTION(&semUMPD);
    
    pList = pUMPD->pHandleList;

    while(pList)
    {
        if (pList->clientPid == clientPid && pList->hPrinter32 == hPrinter32)
        {
            break;
        }
        pList = pList->pNext;
    }
    
    LEAVECRITICALSECTION(&semUMPD);
    
    return pList;                 
}

VOID  DeletePrinterHandle(PUMPD pUMPD, PHPRINTERLIST pNode)
{
    PHPRINTERLIST  pList;

    ENTERCRITICALSECTION(&semUMPD);

    pList = pUMPD->pHandleList;

    if (pList == pNode)
    {
        pUMPD->pHandleList = pNode->pNext;
    }
    else
    {
        while(pList && pList->pNext != pNode)
        {
            pList = pList->pNext;
        }
        
        if (pList)
        {
            pList->pNext = pNode->pNext;
        }
    }

    LEAVECRITICALSECTION(&semUMPD);

    if (pList)
    {
        LOCALFREE(pNode);
    }
}

//
// KERNEL_PVOID  UMPDAllocUserMem
//
// WOW64 printing only
//

KERNEL_PVOID UMPDAllocUserMem(ULONG cjSize)
{
    return ((KERNEL_PVOID) LOCALALLOC(cjSize));
}


//
//  KERNEL_PVOID  UMPDCopyMemory
//
//  WOW64 printing only
//
//  pvSrc
//        source
//
//  pvDest
//       dest
//
//  cjBits
//          size to copy
// 

KERNEL_PVOID UMPDCopyMemory(
    KERNEL_PVOID  pvSrc,
    KERNEL_PVOID  pvDest,
    ULONG         cjBits
)
{
    if (pvDest != NULL)
        RtlCopyMemory(pvDest, pvSrc, cjBits);
    
    return pvDest;
}

//
//  BOOL UMPDFreeMemory
//
//  WOW64 only
//

BOOL UMPDFreeMemory(
    KERNEL_PVOID pv1,
    KERNEL_PVOID pv2,
    KERNEL_PVOID pv3
)
{
    if (pv1)
        LOCALFREE(pv1);
    
    if (pv2)
       LOCALFREE(pv2);

    if (pv3)
       LOCALFREE(pv3);

    return TRUE;
}


/******************************Public*Routine******************************\
* GdiPrinterThunk function
*
* GDI callback for user-mode printer drivers.
*
* Parameters    pumth
*                   Pointer to input buffer.  Buffer has UMTHDR at
*                   beginning.
*
*               pvOut
*                   Output buffer.
*
*               cjOut
*                   Size of output buffer.
*
* Return Value
*
*   The function returns GPT_ERROR if an error occurs.  Otherwise, the
*   return value is dependent on the command specified by pumth->ulType.
*
* History:
*  7/17/97     -by- Lingyun Wang [lingyunw] Added giant body to
*                  Make it do the real work
*  30-Jun-1997 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

extern PUMPD
FindUserModePrinterDriver(
    PCWSTR  pDriverDllName,
    DWORD   dwDriverVersion,
    BOOL    bUseVersion
    );

WINGDIAPI
ULONG
WINAPI
GdiPrinterThunk (
    UMTHDR *    pvIn,
    PVOID       pvOut,
    ULONG       cjOut
    )
{
    INT         iRet = 1;
    UMPDTHDR *  pumpdthdr = (UMPDTHDR *) pvIn;
    HUMPD       hSaved;
    BOOL        bWOW64 = FALSE, bSetPUMPD = FALSE;
    ULONG       ulType = pvIn->ulType;
    
    //
    //  Call NtGdiSetPUMPDOBJ to set the W32THREAD.pUMPDObj pointer
    //  only if this is a DDI thunk
    //

    if (ulType <= INDEX_LAST+1)
    {
        if (!(bSetPUMPD = NtGdiSetPUMPDOBJ(pumpdthdr->humpd, TRUE, &hSaved, &bWOW64)))
        {
            WARNING ("NtGdiSetPUMPDOBJ failed\n");
            return GPT_ERROR;
        }
    }

    switch (ulType)
    {
        case INDEX_LoadUMPrinterDrv:
            {
                PLOADDRIVERINPUT    pInput = (PLOADDRIVERINPUT) pvIn;
                PUMPD               pUMPD = NULL;
                HANDLE              hPrinter = NULL;

                *((PUMPD *)pvOut) = NULL;
                
                if(BLOADSPOOLER)
                {
                    (*fpOpenPrinterW)(pInput->pPrinterName, &hPrinter, (LPPRINTER_DEFAULTSW)&pInput->defaults);

                    if(hPrinter)
                    {
                        if(LoadUserModePrinterDriverEx((PDRIVER_INFO_5W)&pInput->driverInfo, NULL, &pUMPD, NULL, 0) &&
                           bAddPrinterHandle(pUMPD, pInput->clientPid, pInput->hPrinter32, hPrinter))
                        {
                            *((PUMPD *) pvOut) = pUMPD;
                        }
                        else
                        {
                            if (pUMPD)
                                UnloadUserModePrinterDriver(pUMPD, TRUE, 0);
                            
                            (*fpClosePrinter)(hPrinter);
                            
                            WARNING("GdiPrinterThunk: failed to load umpd or add printer handles\n");
                        }
                    }
                    else
                    {
                        WARNING(("failed opening printer '%ls' on proxy\n", (PCH)pInput->pPrinterName));
                    }
                }
                else
                {
                    WARNING("GdiPrinterThunk: failed loading spooler\n");
                }
            }
            break;
    
        case INDEX_UnloadUMPrinterDrv:
            {
                PUNLOADDRIVERINPUT    pInput = (PUNLOADDRIVERINPUT) pvIn;
                PUMPD                 pUMPD = (PUMPD) pInput->umpdCookie;
                PHPRINTERLIST         pList;
                
                if (pInput->hPrinter32 &&
                    (pList = FindPrinterHandle(pUMPD, pInput->clientPid, pInput->hPrinter32)))
                {
                    (*fpClosePrinter)(pList->hPrinter64);
                    DeletePrinterHandle(pUMPD, pList);
                }
 
                UnloadUserModePrinterDriver(pUMPD, pInput->bNotifySpooler, 0);
            }
        break;

        case INDEX_UMDriverFN:
            {
                PDRVDRIVERFNINPUT pInput = (PDRVDRIVERFNINPUT) pvIn;
                PUMPD pUMPD = (PUMPD) pInput->cookie;
                BOOL * pbDrvFn = (BOOL *) pvOut;
                int index;

                if(pUMPD)
                {
                    for(index = 0; index < INDEX_LAST; index++)
                        pbDrvFn[index] = (pUMPD->apfn[index] != NULL ? TRUE : FALSE);
                }
                else
                {
                    RtlZeroMemory(pvOut, sizeof(BOOL) * INDEX_LAST);
                }
            }
        break;

        case INDEX_DocumentEvent:
            {
                PDOCUMENTEVENTINPUT  pInput = (PDOCUMENTEVENTINPUT) pvIn;
                PHPRINTERLIST  pList = FindPrinterHandle((PUMPD)pInput->umpdCookie, pInput->clientPid, pInput->hPrinter32);                
                
                if (pList)
                {
                    *((int*)pvOut) = (*fpDocumentEvent)(pList->hPrinter64,
                                                        pInput->hdc,
                                                        pInput->iEsc,
                                                        pInput->cjIn,
                                                        (PVOID)pInput->pvIn,
                                                        pInput->cjOut,
                                                        (PVOID)pInput->pvOut);
    
                    if (pInput->iEsc == DOCUMENTEVENT_CREATEDCPRE || pInput->iEsc == DOCUMENTEVENT_RESETDCPRE)
                    {
                        if ((*((int*)pvOut) != DOCUMENTEVENT_FAILURE) &&
                            *((DEVMODEW**)pInput->pvOut))
                        {
                            RtlCopyMemory(pInput->pdmCopy, *((DEVMODEW**)pInput->pvOut), sizeof(DEVMODEW));
                        }
                    }
                }
                else
                    *((int*)pvOut) = DOCUMENTEVENT_FAILURE;
            }
        break;

        case INDEX_StartDocPrinterW:
            {
                PSTARTDOCPRINTERWINPUT pInput = (PSTARTDOCPRINTERWINPUT) pvIn;
                PHPRINTERLIST  pList = FindPrinterHandle((PUMPD)pInput->umpdCookie, pInput->clientPid, pInput->hPrinter32);                

                if (pList)
                {
                    *((DWORD*)pvOut) = (*fpStartDocPrinterW)(pList->hPrinter64,
                                                            pInput->level,
                                                            (LPBYTE)&pInput->docInfo);
    
                    pInput->lastError = GetLastError();
                }
                else
                    *((DWORD*)pvOut) = 0; 
            }
        break;
        
        case INDEX_StartPagePrinter:
            {
                PUMPDSIMPLEINPUT    pInput = (PUMPDSIMPLEINPUT) pvIn;
                PHPRINTERLIST       pList = FindPrinterHandle((PUMPD)pInput->umpdCookie, pInput->clientPid, pInput->hPrinter32);                

                if (pList)
                    *((BOOL*)pvOut) = (*fpStartPagePrinter)(pList->hPrinter64);
                else
                    *((BOOL*)pvOut) = FALSE;
            }                
        break;
        
        case INDEX_EndPagePrinter:
            {
                PUMPDSIMPLEINPUT    pInput = (PUMPDSIMPLEINPUT) pvIn;
                PHPRINTERLIST       pList = FindPrinterHandle((PUMPD)pInput->umpdCookie, pInput->clientPid, pInput->hPrinter32);                

                if (pList)
                {
                    *((BOOL*)pvOut) = (*fpEndPagePri