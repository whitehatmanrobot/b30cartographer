r,
                             LPCTSTR szAllDrivers );

/////////////////////////////////////////////////////////////////////////////
VOID VrfAddDriverNameNoDuplicates( LPCTSTR szDriver,
                                   CString &strAllDrivers );        

/////////////////////////////////////////////////////////////////////////////
BOOL VrfIsStringInArray( LPCTSTR szText,
                         const CStringArray &astrAllTexts );

#endif //#ifndef __VRF_UTIL_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\vsetting.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: VSetting.h
// author: DMihai
// created: 11/1/00
//
// Description:
//

//////////////////////////////////////////////////////////////////////

#if !defined(AFX_VSETTING_H__478A94E4_3D60_4419_950C_2144CB86691D__INCLUDED_)
#define AFX_VSETTING_H__478A94E4_3D60_4419_950C_2144CB86691D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "ProgCtrl.h"

///////////////////////////////////////////////////////////////
//
// CDriverData class
//
// Has information about one driver
//

class CDriverData : public CObject
{
public:
    CDriverData();
    CDriverData( const CDriverData &DriverData );
    CDriverData( LPCTSTR szDriverName );
    virtual ~CDriverData();

public:
    //
    // Operators
    //

    //
    // Methods
    //

    BOOL LoadDriverImageData();

    //
    // Overrides
    //

    virtual void AssertValid( ) const;

protected:
    BOOL LoadDriverHeaderData();
    BOOL LoadDriverVersionData();

public:
    //
    // Type definitions
    //
    
    typedef enum
    {
        SignedNotVerifiedYet = 1,
        SignedYes,
        SignedNo
    } SignedTypeEnum;

    typedef enum
    {
        VerifyDriverNo = 1,
        VerifyDriverYes
    } VerifyDriverTypeEnum;

public:
    //
    // Data
    //

    CString                 m_strName;
    
    SignedTypeEnum          m_SignedStatus;
    VerifyDriverTypeEnum    m_VerifyDriverStatus;

    //
    // If the current driver is a miniport then 
    // m_strMiniportName is the driver it is linked against (videoprt.sys, etc.)
    //

    CString                 m_strMiniportName;

    //
    // If this is a "special driver" this is the name to add to the verification list
    //
    // - hal.dll for the HAL
    // - ntoskrnl.exe fro the kernel
    //

    CString                 m_strReservedName;

    //
    // Binary header info
    //

    WORD                    m_wMajorOperatingSystemVersion;
    WORD                    m_wMajorImageVersion;

    //
    // Version info
    //

    CString                 m_strCompanyName;
    CString                 m_strFileVersion;
    CString                 m_strFileDescription;
};

///////////////////////////////////////////////////////////////
//
// CDriverDataArray class
//
// ObArray of CDriverData
//

class CDriverDataArray : public CObArray
{
public:
    ~CDriverDataArray();

public:
    VOID DeleteAll();
    CDriverData *GetAt( INT_PTR nIndex ) const;
    
public:
    //
    // Operators
    //

    CDriverDataArray &operator = (const CDriverDataArray &DriversSet);
};

///////////////////////////////////////////////////////////////
//
// CDriversSet class 
//
// Describes a set of drivers to verify
//

class CDriversSet : public CObject  
{
public:
	CDriversSet();
	virtual ~CDriversSet();

public:
    //
    // Find all installed unsigned drivers if we didn't do that already
    //

    BOOL LoadAllDriversData( HANDLE hAbortEvent,
                             CVrfProgressCtrl	&ProgressCtl );

    BOOL FindUnsignedDrivers( HANDLE hAbortEvent,
                              CVrfProgressCtrl	&ProgressCtl );

    BOOL ShouldDriverBeVerified( const CDriverData *pDriverData ) const;
    BOOL ShouldVerifySomeDrivers( ) const;

    BOOL GetDriversToVerify( CString &strDriversToVerify );

    //
    // Operators
    //

    CDriversSet &operator = (const CDriversSet &DriversSet);

    //
    // Add a new verifier data structure based on the name
    // Returns the new item's index in the array.
    //

    INT_PTR AddNewDriverData( LPCTSTR szDriverName, BOOL bForceIfFileNotFound = FALSE );

    //
    // Is this driver name already in our list?
    //

    BOOL IsDriverNameInList( LPCTSTR szDriverName );

    //
    // Overrides
    //

    virtual void AssertValid( ) const;

protected:

    //
    // Load all installed driver names if we didn't do this already
    // 

    BOOL LoadAllDriversNames( HANDLE hAbortEvent );

public:
    //
    // Types
    //

    typedef enum
    {
        DriversSetCustom = 1,
        DriversSetOldOs,
        DriversSetNotSigned,
        DriversSetAllDrivers
    } DriversSetTypeEnum;

    //
    // Data
    //

    //
    // Standard, custom, etc.
    //

    DriversSetTypeEnum  m_DriverSetType;

    //
    // Array with data for all the currently installed drivers
    //

    CDriverDataArray    m_aDriverData;

    //
    // Extra drivers (not currenly installed) to verify
    //

    CStringArray        m_astrNotInstalledDriversToVerify;

    //
    // Did we initialize already the driver data array?
    //

    BOOL                m_bDriverDataInitialized;

    //
    // Did we initialize already the unsigned drivers member 
    // of the driver data structure?
    //

    BOOL                m_bUnsignedDriverDataInitialized;
};


///////////////////////////////////////////////////////////////
//
// CSettingsBits class 
//
// Describes a set of verifier settings bits
//

class CSettingsBits : public CObject  
{
public:
	CSettingsBits();
	virtual ~CSettingsBits();

public:
    //
    // Type definitions
    //

    typedef enum
    {
        SettingsTypeTypical = 1,
        SettingsTypeCustom,
    } SettingsTypeEnum;

public:
    //
    // Operators
    //

    CSettingsBits &operator = (const CSettingsBits &VerifSettings);

    //
    // Overrides
    //

    virtual void AssertValid() const;

    //
    // Methods
    //

    VOID SetTypicalOnly();

    VOID EnableTypicalTests( BOOL bEnable );
    VOID EnableExcessiveTests( BOOL bEnable );
    VOID EnableLowResTests( BOOL bEnable );

    BOOL GetVerifierFlags( DWORD &dwVerifyFlags );

public:
    //
    // Data
    //

    SettingsTypeEnum    m_SettingsType;

    BOOL            m_bSpecialPoolEnabled;
    BOOL            m_bForceIrqlEnabled;
    BOOL            m_bLowResEnabled;
    BOOL            m_bPoolTrackingEnabled;
    BOOL            m_bIoEnabled;
    BOOL            m_bDeadlockDetectEnabled;
    BOOL            m_bDMAVerifEnabled;
    BOOL            m_bEnhIoEnabled;
};

///////////////////////////////////////////////////////////////
//
// CVerifierSettings class 
//
// Describes a set of drivers to verify and the verifier settings bits
//

class CVerifierSettings : public CObject  
{
public:
	CVerifierSettings();
	virtual ~CVerifierSettings();

public:
    //
    // Operators
    //

    CVerifierSettings &operator = (const CVerifierSettings &VerifSettings);

    //
    // Overrides
    //

    virtual void AssertValid() const;

    //
    // Methods
    //

    BOOL SaveToRegistry();

public:
    //
    // Data
    //
    
    CSettingsBits   m_SettingsBits;

    CDriversSet     m_DriversSet;
};

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//
// Runtime data - queried from the kernel
//
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
//
// class CRuntimeDriverData
//

class CRuntimeDriverData : public CObject
{
public:
    //
    // Construction
    //

    CRuntimeDriverData();

public:
    //
    // Data
    //

    CString m_strName;

    ULONG Loads;
    ULONG Unloads;

    ULONG CurrentPagedPoolAllocations;
    ULONG CurrentNonPagedPoolAllocations;
    ULONG PeakPagedPoolAllocations;
    ULONG PeakNonPagedPoolAllocations;

    SIZE_T PagedPoolUsageInBytes;
    SIZE_T NonPagedPoolUsageInBytes;
    SIZE_T PeakPagedPoolUsageInBytes;
    SIZE_T PeakNonPagedPoolUsageInBytes;
};

//////////////////////////////////////////////////////////////////////
//
// class CRuntimeDriverDataArray
//

class CRuntimeDriverDataArray : public CObArray
{
public:
    ~CRuntimeDriverDataArray();

public:
    CRuntimeDriverData *GetAt( INT_PTR nIndex );

    VOID DeleteAll();
};

//////////////////////////////////////////////////////////////////////
//
// class CRuntimeVerifierData
//

class CRuntimeVerifierData : public CObject
{
public:
    //
    // Construction
    //

    CRuntimeVerifierData();

public:
    //
    // Methods
    //

    VOID FillWithDefaults();
    BOOL IsDriverVerified( LPCTSTR szDriveName );

public:
    //
    // Data
    //

    BOOL            m_bSpecialPool;
    BOOL            m_bPoolTracking;
    BOOL            m_bForceIrql;
    BOOL            m_bIo;
    BOOL            m_bEnhIo;
    BOOL            m_bDeadlockDetect;
    BOOL            m_bDMAVerif;
    BOOL            m_bLowRes;

    ULONG RaiseIrqls;
    ULONG AcquireSpinLocks;
    ULONG SynchronizeExecutions;
    ULONG AllocationsAttempted;

    ULONG AllocationsSucceeded;
    ULONG AllocationsSucceededSpecialPool;
    ULONG AllocationsWithNoTag;

    ULONG Trims;
    ULONG AllocationsFailed;
    ULONG AllocationsFailedDeliberately;

    ULONG UnTrackedPool;

    DWORD Level;

    CRuntimeDriverDataArray m_RuntimeDriverDataArray;
};


#endif // !defined(AFX_VSETTING_H__478A94E4_3D60_4419_950C_2144CB86691D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\vglobal.h ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: VGlobal.h
// author: DMihai
// created: 11/1/00
//
// Description:
//

#ifndef __VGLOBAL_H_INCLUDED__
#define __VGLOBAL_H_INCLUDED__

#include "vsheet.h"

//
// Help file name
//

extern TCHAR g_szVerifierHelpFile[];

//
// Application name ("Driver Verifier Manager")
//

extern CString g_strAppName;

//
// Exe module handle - used for loading resources
//

extern HMODULE g_hProgramModule;

//
// GUI mode or command line mode?
//

extern BOOL g_bCommandLineMode;

//
// Brush used to fill out the background of our steps lists
//

extern HBRUSH g_hDialogColorBrush;

//
// Path to %windir%\system32\drivers
//

extern CString g_strSystemDir;

//
// Path to %windir%\system32\drivers
//

extern CString g_strDriversDir;

//
// Initial current directory
//

extern CString g_strInitialCurrentDirectory;

//
// Filled out by CryptCATAdminAcquireContext
//

extern HCATADMIN g_hCatAdmin;

//
// Highest user address - used to filter out user-mode stuff
// returned by NtQuerySystemInformation ( SystemModuleInformation )
//

extern PVOID g_pHighestUserAddress;

//
// Did we enable the debugprivilege already?
//

extern BOOL g_bPrivegeEnabled;

//
// Need to reboot ?
//

extern BOOL g_bSettingsSaved;

//
// Dummy text used to insert an item in a list control with checkboxes
//

extern TCHAR g_szVoidText[];

//
// New registry settings
//

extern CVerifierSettings   g_NewVerifierSettings;

//
// Are all drivers verified? (loaded from the registry)
//

extern BOOL g_bAllDriversVerified;

//
// Drivers to be verified names (loaded from the registry)
// We have data in this array only if g_bAllDriversVerified == FALSE.
//

extern CStringArray g_astrVerifyDriverNamesRegistry;

//
// Verifier flags (loaded from the registry)
//

extern DWORD g_dwVerifierFlagsRegistry;


////////////////////////////////////////////////////////////////
BOOL VerifInitalizeGlobalData( VOID );

#endif //#ifndef __VGLOBAL_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\vsheet.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: VSheet.cpp
// author: DMihai
// created: 11/1/00
//
// Description:
//

#include "stdafx.h"
#include "verifier.h"

#include "vsheet.h"
#include "taspage.h"
#include "vglobal.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CVerifierPropSheet dialog

CVerifierPropSheet::CVerifierPropSheet()
	: CPropertySheet(IDS_APPTITLE)
{
	//{{AFX_DATA_INIT(CVerifierPropSheet)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32

    m_TypAdvStatPage.SetParentSheet( this );
    m_DriverSetPage.SetParentSheet( this );
    m_CustSettPage.SetParentSheet( this );
    m_ConfDriversListPage.SetParentSheet( this );
    m_SelectDriversPage.SetParentSheet( this );
    m_FullListSettingsPage.SetParentSheet( this );
    m_DriverStatusPage.SetParentSheet( this );
    m_CrtRegSettingsPage.SetParentSheet( this );
    m_GlobalCountPage.SetParentSheet( this );
    m_DriverCountersPage.SetParentSheet( this );

    m_TypAdvStatPage.m_psp.dwFlags &= ~PSH_HASHELP;
    m_DriverSetPage.m_psp.dwFlags &= ~PSH_HASHELP;
    m_CustSettPage.m_psp.dwFlags &= ~PSH_HASHELP;
    m_ConfDriversListPage.m_psp.dwFlags &= ~PSH_HASHELP;
    m_SelectDriversPage.m_psp.dwFlags &= ~PSH_HASHELP;
    m_FullListSettingsPage.m_psp.dwFlags &= ~PSH_HASHELP;
    m_DriverStatusPage.m_psp.dwFlags &= ~PSH_HASHELP;
    m_CrtRegSettingsPage.m_psp.dwFlags &= ~PSH_HASHELP;
    m_GlobalCountPage.m_psp.dwFlags &= ~PSH_HASHELP;
    m_DriverCountersPage.m_psp.dwFlags &= ~PSH_HASHELP;

    m_psh.dwFlags &= ~PSH_HASHELP;
    m_psh.dwFlags |= PSH_WIZARDCONTEXTHELP;

    AddPage( &m_TypAdvStatPage );
    AddPage( &m_DriverSetPage );
    AddPage( &m_CustSettPage );
    AddPage( &m_ConfDriversListPage );
    AddPage( &m_SelectDriversPage );
    AddPage( &m_FullListSettingsPage );
    AddPage( &m_CrtRegSettingsPage );
    AddPage( &m_DriverStatusPage );
    AddPage( &m_GlobalCountPage );
    AddPage( &m_DriverCountersPage );
    
    SetWizardMode();

    m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CVerifierPropSheet::DoDataExchange(CDataExchange* pDX)
{
	CPropertySheet::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CVerifierPropSheet)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CVerifierPropSheet, CPropertySheet)
	//{{AFX_MSG_MAP(CVerifierPropSheet)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
    ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
BOOL CVerifierPropSheet::SetContextStrings( ULONG uTitleResId )
{
    return m_ConfDriversListPage.SetContextStrings( uTitleResId );
}

/////////////////////////////////////////////////////////////////////////////
VOID CVerifierPropSheet::HideHelpButton()
{
    INT xDelta;
    CRect rect1;
    CRect rect2;
    CWnd *pButton;

    //
    // Help button
    //

    pButton = GetDlgItem( IDHELP );

    if( NULL == pButton )
    {
        //
        // No help button?!?
        //

        goto Done;
    }

    pButton->ShowWindow( SW_HIDE );

    pButton->GetWindowRect( &rect1 );
    ScreenToClient( &rect1 );

    //
    // Cancel button
    //

    pButton = GetDlgItem( IDCANCEL );

    if( NULL == pButton )
    {
        //
        // No Cancel button?!?
        //

        goto Done;
    }

    pButton->GetWindowRect( &rect2 );
    ScreenToClient( &rect2 );

    xDelta = rect1.left - rect2.left;
    
    rect2.OffsetRect( xDelta, 0 );
    pButton->MoveWindow( rect2 );

    //
    // Back button
    //

    pButton = GetDlgItem( ID_WIZBACK );

    if( NULL != pButton )
    {
        pButton->GetWindowRect( &rect2 );
        ScreenToClient( &rect2 );
        rect2.OffsetRect( xDelta, 0 );
        pButton->MoveWindow( rect2 );
    }

    //
    // Next button
    //

    pButton = GetDlgItem( ID_WIZNEXT );

    if( NULL != pButton )
    {
        pButton->GetWindowRect( &rect2 );
        ScreenToClient( &rect2 );
        rect2.OffsetRect( xDelta, 0 );
        pButton->MoveWindow( rect2 );
    }

    //
    // Finish button
    //

    pButton = GetDlgItem( ID_WIZFINISH );

    if( NULL != pButton )
    {
        pButton->GetWindowRect( &rect2 );
        ScreenToClient( &rect2 );
        rect2.OffsetRect( xDelta, 0 );
        pButton->MoveWindow( rect2 );
    }

Done:

    NOTHING;
}

/////////////////////////////////////////////////////////////////////////////
// CVerifierPropSheet message handlers

BOOL CVerifierPropSheet::OnInitDialog()
{
	CPropertySheet::OnInitDialog();

    //
	// Add "About..." menu item to system menu.
    //

    //
	// IDM_ABOUTBOX must be in the system command range.
    //

	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

    //
	// Set the icon for this dialog.  The framework does this automatically
	// when the application's main window is not a dialog.
    //

	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon

    //
    // Hide the big Help button - NT keeps creating it even if we
    // have specified ~PSH_HASHELP
    //

    HideHelpButton();

    //
    // Add the context sensitive button to the titlebar
    //

    LONG lStyle = ::GetWindowLong(m_hWnd, GWL_EXSTYLE);
    lStyle |= WS_EX_CONTEXTHELP;
    ::SetWindowLong(m_hWnd, GWL_EXSTYLE, lStyle);

    return TRUE;  // return TRUE  unless you set the focus to a control
}

/////////////////////////////////////////////////////////////////////////////
void CVerifierPropSheet::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
        ShellAbout( m_hWnd, 
                    (LPCTSTR)g_strAppName, 
                    NULL, 
                    m_hIcon );
	}
	else
	{
		CPropertySheet::OnSysCommand( nID, 
                                      lParam);
	}
}

/////////////////////////////////////////////////////////////////////////////
//
// If you add a minimize button to your dialog, you will need the code below
// to draw the icon.  For MFC applications using the document/view model,
// this is automatically done for you by the framework.
//

void CVerifierPropSheet::OnPaint() 
{
	if (IsIconic())
	{
        //
        // Device context for painting
        //

		CPaintDC dc(this); 

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

        //
		// Center icon in client rectangle
        //

		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

        //
		// Draw the icon
        //

		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CPropertySheet::OnPaint();
	}
}

/////////////////////////////////////////////////////////////////////////////
//
// The system calls this to obtain the cursor to display while the user drags
// the minimized window.
//

HCURSOR CVerifierPropSheet::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CVerifierPropSheet::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	return TRUE;
}

/////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\win2k\cntpage.cxx ===
//
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//

//
// module: CntPage.cxx
// author: DMihai
// created: 01/04/98
//
// Description:
//
//      Global Counters PropertyPage.

#include "stdafx.h"
#include "drvvctrl.hxx"
#include "CntPage.hxx"

#include "DrvCSht.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// timer ID
#define REFRESH_TIMER_ID    0x4321

// manual, high, normal, low speed
#define REFRESH_SPEED_VARS  4

// timer intervals in millisec for manual, high, normal, low speed
static UINT uTimerIntervals[ REFRESH_SPEED_VARS ] =
{
    0,      // Manual
    1000,   // High Speed
    5000,   // Normal Speed
    10000   // Low Speed
};

//
// help IDs
//

static DWORD MyHelpIds[] =
{
    IDC_COUNT_RAISEIRQL_EDIT,       IDH_DV_CountersTab_other_irql,
    IDC_COUNT_ACQSPINL_EDIT,        IDH_DV_CountersTab_other_spinlocks,
    IDC_COUNT_SYNCREX_EDIT,         IDH_DV_CountersTab_other_sync,
    IDC_COUNT_TRIMS_EDIT,           IDH_DV_CountersTab_other_trims,
    IDC_COUNT_ALLOC_ATTEMPT_EDIT,   IDH_DV_CountersTab_allocations_attempt,
    IDC_COUNT_ALLOC_SUCC_EDIT,      IDH_DV_CountersTab_allocations_succeed,
    IDC_COUNT_ALLOCSUCC_SPECPOOL_EDIT, IDH_DV_CountersTab_allocations_succeed_pool,
    IDC_COUNT_ALLOC_NOTAG_EDIT,     IDH_DV_CountersTab_allocations_wotag,
    IDC_COUNT_ALLOC_FAILED_EDIT,    IDH_DV_CountersTab_allocations_failed,
    IDC_COUNT_ALLOC_FAILEDDEL_EDIT, IDH_DV_CountersTab_other_faults,

    IDC_COUNT_REFRESH_BUTTON,     IDH_DV_common_refresh_nowbutton,
    IDC_COUNT_MANUAL_RADIO,       IDH_DV_common_refresh_manual,
    IDC_COUNT_HSPEED_RADIO,       IDH_DV_common_refresh_high,
    IDC_COUNT_NORM_RADIO,         IDH_DV_common_refresh_normal,
    IDC_COUNT_LOW_RADIO,          IDH_DV_common_refresh_low,
    0,                              0
};

/////////////////////////////////////////////////////////////////////
static void GetStringFromULONG( CString &strValue, ULONG uValue )
{
    LPTSTR lptstrValue = strValue.GetBuffer( 64 );
    if( lptstrValue != NULL )
    {
        _stprintf( lptstrValue, _T( "%lu" ), uValue );
        strValue.ReleaseBuffer();
    }
    else
    {
        ASSERT( FALSE );
        strValue.Empty();
    }
}


/////////////////////////////////////////////////////////////////////
// CCountersPage property page

IMPLEMENT_DYNCREATE(CCountersPage, CPropertyPage)

CCountersPage::CCountersPage()
	: CPropertyPage(CCountersPage::IDD)
{
    //{{AFX_DATA_INIT(CCountersPage)
    m_strAcqSpinlEdit = _T("");
    m_strAllocAttemptEdit = _T("");
    m_strAllocFailed = _T("");
    m_strAllocFailedDelEdit = _T("");
    m_strAllocNoTagEdit = _T("");
    m_strAllocSucc = _T("");
    m_strAllocSuccSpecPool = _T("");
    m_strRaiseIrqLevelEdit = _T("");
    m_strSyncrExEdit = _T("");
    m_strTrimsEdit = _T("");
    m_nUpdateIntervalIndex = 2;
    //}}AFX_DATA_INIT

    m_uTimerHandler = 0;
}


void CCountersPage::DoDataExchange(CDataExchange* pDX)
{
    if( ! pDX->m_bSaveAndValidate )
    {
        // query the kernel
        if( KrnGetSystemVerifierState( &m_KrnVerifState ) &&
            m_KrnVerifState.DriverCount > 0 )
        {
            // RaiseIrqls
            GetStringFromULONG( m_strRaiseIrqLevelEdit,
                m_KrnVerifState.RaiseIrqls );

            // AcquireSpinLocks
            GetStringFromULONG( m_strAcqSpinlEdit,
                m_KrnVerifState.AcquireSpinLocks );

            // SynchronizeExecutions
            GetStringFromULONG( m_strSyncrExEdit,
                m_KrnVerifState.SynchronizeExecutions );

            // AllocationsAttempted
            GetStringFromULONG( m_strAllocAttemptEdit,
                m_KrnVerifState.AllocationsAttempted );

            // AllocationsSucceeded
            GetStringFromULONG( m_strAllocSucc,
                m_KrnVerifState.AllocationsSucceeded );

            // AllocationsSucceededSpecialPool
            GetStringFromULONG( m_strAllocSuccSpecPool,
                m_KrnVerifState.AllocationsSucceededSpecialPool );

            // AllocationsWithNoTag
            GetStringFromULONG( m_strAllocNoTagEdit,
                m_KrnVerifState.AllocationsWithNoTag );

            // Trims
            GetStringFromULONG( m_strTrimsEdit,
                m_KrnVerifState.Trims );

            // AllocationsFailed
            GetStringFromULONG( m_strAllocFailed,
                m_KrnVerifState.AllocationsFailed );

            // AllocationsFailedDeliberately
            GetStringFromULONG( m_strAllocFailedDelEdit,
                m_KrnVerifState.AllocationsFailedDeliberately );
        }
        else
        {
            // RaiseIrqls
            VERIFY( m_strRaiseIrqLevelEdit.LoadString( IDS_ZERO ) );

            // AcquireSpinLocks
            VERIFY( m_strAcqSpinlEdit.LoadString( IDS_ZERO ) );

            // SynchronizeExecutions
            VERIFY( m_strSyncrExEdit.LoadString( IDS_ZERO ) );

            // AllocationsAttempted
            VERIFY( m_strAllocAttemptEdit.LoadString( IDS_ZERO ) );

            // AllocationsSucceeded
            VERIFY( m_strAllocSucc.LoadString( IDS_ZERO ) );

            // AllocationsSucceededSpecialPool
            VERIFY( m_strAllocSuccSpecPool.LoadString( IDS_ZERO ) );

            // AllocationsWithNoTag
            VERIFY( m_strAllocNoTagEdit.LoadString( IDS_ZERO ) );

            // Trims
            VERIFY( m_strTrimsEdit.LoadString( IDS_ZERO ) );

            // AllocationsFailed
            VERIFY( m_strAllocFailed.LoadString( IDS_ZERO ) );

            // AllocationsFailedDeliberately
            VERIFY( m_strAllocFailedDelEdit.LoadString( IDS_ZERO ) );

        }
    }

    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CCountersPage)
    DDX_Text(pDX, IDC_COUNT_ACQSPINL_EDIT, m_strAcqSpinlEdit);
    DDX_Text(pDX, IDC_COUNT_ALLOC_ATTEMPT_EDIT, m_strAllocAttemptEdit);
    DDX_Text(pDX, IDC_COUNT_ALLOC_FAILED_EDIT, m_strAllocFailed);
    DDX_Text(pDX, IDC_COUNT_ALLOC_FAILEDDEL_EDIT, m_strAllocFailedDelEdit);
    DDX_Text(pDX, IDC_COUNT_ALLOC_NOTAG_EDIT, m_strAllocNoTagEdit);
    DDX_Text(pDX, IDC_COUNT_ALLOC_SUCC_EDIT, m_strAllocSucc);
    DDX_Text(pDX, IDC_COUNT_ALLOCSUCC_SPECPOOL_EDIT, m_strAllocSuccSpecPool);
    DDX_Text(pDX, IDC_COUNT_RAISEIRQL_EDIT, m_strRaiseIrqLevelEdit);
    DDX_Text(pDX, IDC_COUNT_SYNCREX_EDIT, m_strSyncrExEdit);
    DDX_Text(pDX, IDC_COUNT_TRIMS_EDIT, m_strTrimsEdit);
    DDX_Radio(pDX, IDC_COUNT_MANUAL_RADIO, m_nUpdateIntervalIndex);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCountersPage, CPropertyPage)
    //{{AFX_MSG_MAP(CCountersPage)
    ON_BN_CLICKED(IDC_COUNT_REFRESH_BUTTON, OnCountRefreshButton)
    ON_WM_TIMER()
    ON_BN_CLICKED(IDC_COUNT_HSPEED_RADIO, OnCountHspeedRadio)
    ON_BN_CLICKED(IDC_COUNT_LOW_RADIO, OnCountLowRadio)
    ON_BN_CLICKED(IDC_COUNT_MANUAL_RADIO, OnCountManualRadio)
    ON_BN_CLICKED(IDC_COUNT_NORM_RADIO, OnCountNormRadio)
    ON_MESSAGE( WM_HELP, OnHelp )
    ON_MESSAGE( WM_CONTEXTMENU, OnContextMenu )
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////
void CCountersPage::OnRefreshTimerChanged()
{
    UINT uTimerElapse = 0;

    // kill the pending timer
    if( m_uTimerHandler != 0 )
    {
        VERIFY( KillTimer( REFRESH_TIMER_ID ) );
    }

    // sanity check
    if( m_nUpdateIntervalIndex < 0 ||
        m_nUpdateIntervalIndex >= REFRESH_SPEED_VARS )
    {
        m_nUpdateIntervalIndex = 0;
        CheckRadioButton( IDC_COUNT_MANUAL_RADIO, IDC_COUNT_LOW_RADIO,
            IDC_COUNT_MANUAL_RADIO );
    }

    // new timer interval
    uTimerElapse = uTimerIntervals[ m_nUpdateIntervalIndex ];
    if( uTimerElapse > 0 )
    {
        VERIFY( m_uTimerHandler = SetTimer( REFRESH_TIMER_ID,
            uTimerElapse, NULL ) );
    }
}

/////////////////////////////////////////////////////////////////////
// CCountersPage message handlers
BOOL CCountersPage::OnInitDialog()
{
    CPropertyPage::OnInitDialog();

    OnRefreshTimerChanged();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////
void CCountersPage::OnCountRefreshButton()
{
    UpdateData( FALSE );
}

/////////////////////////////////////////////////////////////////////
void CCountersPage::OnTimer(UINT nIDEvent)
{
    if( nIDEvent == REFRESH_TIMER_ID )
    {
        CDrvChkSheet *pParentSheet = (CDrvChkSheet *)GetParent();
        if( pParentSheet != NULL )
        {
            ASSERT_VALID( pParentSheet );
            if( pParentSheet->GetActivePage() == this )
            {
                // refresh the displayed data
                OnCountRefreshButton();
            }
        }
    }

    CPropertyPage::OnTimer(nIDEvent);
}

/////////////////////////////////////////////////////////////////////
BOOL CCountersPage::OnQueryCancel()
{
    // give parent PropertySheet a chance to refuse the Cancel if needed

    CDrvChkSheet *pParentSheet = (CDrvChkSheet *)GetParent();
    if( pParentSheet != NULL )
    {
        ASSERT_VALID( pParentSheet );
        if( ! pParentSheet->OnQueryCancel() )
        {
            return FALSE;
        }
    }

    return CPropertyPage::OnQueryCancel();
}

/////////////////////////////////////////////////////////////////////
BOOL CCountersPage::OnApply()
{
    // refuse to apply
    // (we don't use the standard PropertSheet buttons; Apply, OK)
    return FALSE;
}

/////////////////////////////////////////////////////////////////////
void CCountersPage::OnCountManualRadio()
{
    // switch to manual refresh
    m_nUpdateIntervalIndex = 0;
    OnRefreshTimerChanged();
}

void CCountersPage::OnCountHspeedRadio()
{
    // switch to high speed refresh
    m_nUpdateIntervalIndex = 1;
    OnRefreshTimerChanged();
}

void CCountersPage::OnCountNormRadio()
{
    // switch to normal speed refresh
    m_nUpdateIntervalIndex = 2;
    OnRefreshTimerChanged();
}

void CCountersPage::OnCountLowRadio()
{
    // switch to low speed refresh
    m_nUpdateIntervalIndex = 3;
    OnRefreshTimerChanged();
}

/////////////////////////////////////////////////////////////
LONG CCountersPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        VERIFIER_HELP_FILE,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////
LONG CCountersPage::OnContextMenu( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;

    ::WinHelp( 
        (HWND) wParam,
        VERIFIER_HELP_FILE,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\vrfutil.cpp ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
//
// module: VrfUtil.cpp
// author: DMihai
// created: 11/1/00
//
// Description
//

#include "stdafx.h"
#include "verifier.h"

#include "vrfutil.h"
#include "vglobal.h"
#include "VSetting.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Global data
//

const TCHAR RegMemoryManagementKeyName[] =
    _T( "System\\CurrentControlSet\\Control\\Session Manager\\Memory Management" );

const TCHAR RegVerifyDriverLevelValueName[] =
    _T( "VerifyDriverLevel" );

const TCHAR RegVerifyDriversValueName[] =
    _T( "VerifyDrivers" );

///////////////////////////////////////////////////////////////////////////
//
// Report an error using a dialog box or a console message.
// The message format string is loaded from the resources.
//

void __cdecl VrfErrorResourceFormat( UINT uIdResourceFormat,
                                     ... )
{
    TCHAR szMessage[ 256 ];
    TCHAR strFormat[ 256 ];
    BOOL bResult;
    va_list prms;

    //
    // Load the format string from the resources
    //

    bResult = VrfLoadString( uIdResourceFormat,
                             strFormat,
                             ARRAY_LENGTH( strFormat ) );

    ASSERT( bResult );

    if( bResult )
    {
        va_start (prms, uIdResourceFormat);

        //
        // Format the message in our local buffer
        //

        _vsntprintf ( szMessage, 
                      ARRAY_LENGTH( szMessage ), 
                      strFormat, 
                      prms);

        if( g_bCommandLineMode )
        {
            //
            // Command console mode
            //

            _putts( szMessage );
            
            TRACE( _T( "%s\n" ), szMessage );
        }
        else
        {
            //
            // GUI mode
            //

            AfxMessageBox( szMessage, 
                           MB_OK | MB_ICONSTOP );
        }

        va_end (prms);
    }
}

///////////////////////////////////////////////////////////////////////////
//
// Print out a message to the console
// The message string is loaded from the resources.
//

void __cdecl VrfTPrintfResourceFormat( UINT uIdResourceFormat,
                                       ... )
{
    TCHAR szMessage[ 256 ];
    TCHAR strFormat[ 256 ];
    BOOL bResult;
    va_list prms;

    ASSERT( g_bCommandLineMode );

    //
    // Load the format string from the resources
    //

    bResult = VrfLoadString( uIdResourceFormat,
                             strFormat,
                             ARRAY_LENGTH( strFormat ) );

    ASSERT( bResult );

    if( bResult )
    {
        va_start (prms, uIdResourceFormat);

        //
        // Format the message in our local buffer
        //

        _vsntprintf ( szMessage, 
                      ARRAY_LENGTH( szMessage ), 
                      strFormat, 
                      prms);

        _putts( szMessage );

        va_end (prms);
    }
}

///////////////////////////////////////////////////////////////////////////
//
// Print out a simple (non-formatted) message to the console
// The message string is loaded from the resources.
//

void __cdecl VrfPrintStringFromResources( UINT uIdString )
{
    TCHAR szMessage[ 256 ];

    ASSERT( g_bCommandLineMode );

    VERIFY( VrfLoadString( uIdString,
                           szMessage,
                           ARRAY_LENGTH( szMessage ) ) );

    _putts( szMessage );
}

///////////////////////////////////////////////////////////////////////////
//
// Report an error using a dialog box or a console message.
// The message string is loaded from the resources.
//

void __cdecl VrfMesssageFromResource( UINT uIdString )
{
    TCHAR szMessage[ 256 ];

    VERIFY( VrfLoadString( uIdString,
                           szMessage,
                           ARRAY_LENGTH( szMessage ) ) );

    if( g_bCommandLineMode )
    {
        //
        // Command console mode
        //

        _putts( szMessage );
    }
    else
    {
        //
        // GUI mode
        //

        AfxMessageBox( szMessage, 
                       MB_OK | MB_ICONINFORMATION );
    }
}

///////////////////////////////////////////////////////////////////////////
//
// Load a string from resources.
// Return TRUE if we successfully loaded and FALSE if not.
//

BOOL VrfLoadString( ULONG uIdResource,
                    TCHAR *szBuffer,
                    ULONG uBufferLength )
{
    ULONG uLoadStringResult;

    if( uBufferLength < 1 )
    {
        ASSERT( FALSE );
        return FALSE;
    }

    uLoadStringResult = LoadString (
        g_hProgramModule,
        uIdResource,
        szBuffer,
        uBufferLength );

    //
    // We should never try to load non-existent strings.
    //

    ASSERT (uLoadStringResult > 0);

    return (uLoadStringResult > 0);
}

///////////////////////////////////////////////////////////////////////////
//
// Load a string from resources.
// Return TRUE if we successfully loaded and FALSE if not.
//

BOOL VrfLoadString( ULONG uIdResource,
                    CString &strText )
{
    TCHAR szText[ 256 ];
    BOOL bSuccess;

    bSuccess = VrfLoadString( uIdResource,
                          szText,
                          ARRAY_LENGTH( szText ) );

    if( TRUE == bSuccess )
    {
        strText = szText;
    }
    else
    {
        strText = "";
    }

    return bSuccess;
}


///////////////////////////////////////////////////////////////////////////
VOID
CopyStringArray( const CStringArray &strArraySource,
                 CStringArray &strArrayDest )
{
    INT_PTR nNewSize;
    INT_PTR nCrtElem;

    strArrayDest.RemoveAll();

    nNewSize = strArraySource.GetSize();

    for( nCrtElem = 0; nCrtElem < nNewSize; nCrtElem += 1 )
    {
        strArrayDest.Add( strArraySource.GetAt( nCrtElem ) );
    }
}

/////////////////////////////////////////////////////////////////////////////
//
// Copied from sdktools\bvtsigvf
//

BOOL VerifyIsFileSigned( LPCTSTR pcszMatchFile, 
                         PDRIVER_VER_INFO lpVerInfo)
{
    HRESULT             hRes;
    WINTRUST_DATA       WinTrustData;
    WINTRUST_FILE_INFO  WinTrustFile;
    GUID                gOSVerCheck = DRIVER_ACTION_VERIFY;
    GUID                gPublishedSoftware = WINTRUST_ACTION_GENERIC_VERIFY_V2;
#ifndef UNICODE
    INT                 iRet;
    WCHAR               wszFileName[MAX_PATH];
#endif

    ZeroMemory(&WinTrustData, sizeof(WINTRUST_DATA));
    WinTrustData.cbStruct = sizeof(WINTRUST_DATA);
    WinTrustData.dwUIChoice = WTD_UI_NONE;
    WinTrustData.fdwRevocationChecks = WTD_REVOKE_NONE;
    WinTrustData.dwUnionChoice = WTD_CHOICE_FILE;
    WinTrustData.dwStateAction = WTD_STATEACTION_AUTO_CACHE;
    WinTrustData.pFile = &WinTrustFile;
    WinTrustData.pPolicyCallbackData = (LPVOID)lpVerInfo;
    
    ZeroMemory(lpVerInfo, sizeof(DRIVER_VER_INFO));
    lpVerInfo->cbStruct = sizeof(DRIVER_VER_INFO);

    ZeroMemory(&WinTrustFile, sizeof(WINTRUST_FILE_INFO));
    WinTrustFile.cbStruct = sizeof(WINTRUST_FILE_INFO);

#ifndef UNICODE
    iRet = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pcszMatchFile, -1, wszFileName, ARRAY_LENGTH(wszFileName));
    WinTrustFile.pcwszFilePath = wszFileName;
#else
    WinTrustFile.pcwszFilePath = pcszMatchFile;
#endif

    hRes = WinVerifyTrust( AfxGetMainWnd()->m_hWnd, &gOSVerCheck, &WinTrustData);
    if (hRes != ERROR_SUCCESS)
        hRes = WinVerifyTrust( AfxGetMainWnd()->m_hWnd, &gPublishedSoftware, &WinTrustData);

    //
    // Free the pcSignerCertContext member of the DRIVER_VER_INFO struct
    // that was allocated in our call to WinVerifyTrust.
    //

    if (lpVerInfo && lpVerInfo->pcSignerCertContext) {

        CertFreeCertificateContext(lpVerInfo->pcSignerCertContext);
        lpVerInfo->pcSignerCertContext = NULL;
    }

    return (hRes == ERROR_SUCCESS);
}

#define HASH_SIZE   100

BOOL IsDriverSigned( LPCTSTR szDriverFileName )
{
    HANDLE hFile;
    BOOL bSigned;
    BOOL bSuccess;
    HRESULT hTrustResult;
    DWORD dwHashSize;
    GUID guidSubSystemDriver = DRIVER_ACTION_VERIFY;
    HCATINFO hCatInfo;
    HCATINFO hPrevCatInfo;
    BYTE Hash[ HASH_SIZE ];
    WINTRUST_DATA WinTrustData;
    DRIVER_VER_INFO VerInfo;
    WINTRUST_CATALOG_INFO WinTrustCatalogInfo;
    CATALOG_INFO CatInfo;

#ifndef UNICODE
    WCHAR szUnicodeFileName[MAX_PATH];
#endif

    ASSERT( NULL != szDriverFileName );

    bSigned = FALSE;

    //
    // Open the file
    //

    hFile = CreateFile( szDriverFileName,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
                        
    if( hFile == INVALID_HANDLE_VALUE )
    {
        //
        // ISSUE:
        //
        // If we cannot find the file we assume it's signed
        //

        bSigned = TRUE;

        goto Done;
    }

    //
    // Generate the hash from the file handle and store it in Hash
    //

    dwHashSize = ARRAY_LENGTH( Hash );

    ZeroMemory( Hash, 
                sizeof( Hash ) );

    bSuccess = CryptCATAdminCalcHashFromFileHandle( hFile, 
                                                          &dwHashSize, 
                                                          Hash, 
                                                          0);

    CloseHandle( hFile );

    if( TRUE != bSuccess )
    {
        //
        // If we couldn't generate a hash assume the file is not signed
        //

        goto Done;
    }

    //
    // Now we have the file's hash.  Initialize the structures that
    // will be used later on in calls to WinVerifyTrust.
    //

    //
    // Initialize the VerInfo structure
    //

    ZeroMemory( &VerInfo, sizeof( VerInfo ) );

    VerInfo.cbStruct = sizeof( VerInfo );

    //
    // Initialize the WinTrustCatalogInfo structure
    //

    ZeroMemory( &WinTrustCatalogInfo, sizeof( WinTrustCatalogInfo ) );

    WinTrustCatalogInfo.cbStruct = sizeof(WinTrustCatalogInfo);
    WinTrustCatalogInfo.pbCalculatedFileHash = Hash;
    WinTrustCatalogInfo.cbCalculatedFileHash = dwHashSize;

#ifdef UNICODE

    WinTrustCatalogInfo.pcwszMemberTag = szDriverFileName;

#else

    MultiByteToWideChar( CP_ACP, 
                         0, 
                         szDriverFileName, 
                         -1, 
                         szUnicodeFileName, 
                         ARRAY_LENGTH( szUnicodeFileName ) );

    WinTrustCatalogInfo.pcwszMemberTag = szUnicodeFileName;

#endif
    
    //
    // Initialize the WinTrustData structure
    //

    ZeroMemory( &WinTrustData, sizeof( WinTrustData ) );
    
    WinTrustData.cbStruct = sizeof( WinTrustData );
    WinTrustData.dwUIChoice = WTD_UI_NONE;
    WinTrustData.fdwRevocationChecks = WTD_REVOKE_NONE;
    WinTrustData.dwUnionChoice = WTD_CHOICE_CATALOG;
    WinTrustData.dwStateAction = WTD_STATEACTION_AUTO_CACHE;
    WinTrustData.pPolicyCallbackData = (LPVOID)&VerInfo;
    
    WinTrustData.pCatalog = &WinTrustCatalogInfo;

    //
    // If we don't have a g_hCatAdmin yet, acquire one
    //

    if( NULL == g_hCatAdmin )
    {
        CryptCATAdminAcquireContext( &g_hCatAdmin, 
                                     NULL, 
                                     0);

        if( NULL == g_hCatAdmin )
        {
            //
            // Bad luck - consider that the file is not signed and bail out
            //

            goto Done;            
        }
    }
    
    //
    // Now we try to find the file hash in the catalog list, via CryptCATAdminEnumCatalogFromHash
    //

    hPrevCatInfo = NULL;
    
    hCatInfo = CryptCATAdminEnumCatalogFromHash(
        g_hCatAdmin, 
        Hash, 
        dwHashSize, 
        0, 
        &hPrevCatInfo );

    while( TRUE != bSigned && NULL != hCatInfo )
    {
        ZeroMemory( &CatInfo, sizeof( CatInfo ) );
        CatInfo.cbStruct = sizeof( CatInfo );

        bSuccess = CryptCATCatalogInfoFromContext( hCatInfo, 
                                                   &CatInfo, 
                                                   0);

        if( FALSE != bSuccess )
        {
            WinTrustCatalogInfo.pcwszCatalogFilePath = CatInfo.wszCatalogFile;

            //
            // Now verify that the file is an actual member of the catalog.
            //

            hTrustResult = WinVerifyTrust( AfxGetMainWnd()->m_hWnd, 
                                           &guidSubSystemDriver, 
                                           &WinTrustData );

            bSigned = SUCCEEDED( hTrustResult );

            //
            // Free the pcSignerCertContext member of the DRIVER_VER_INFO struct
            // that was allocated in our call to WinVerifyTrust.
            //

            if( VerInfo.pcSignerCertContext != NULL ) 
            {
                CertFreeCertificateContext( VerInfo.pcSignerCertContext );
                VerInfo.pcSignerCertContext = NULL;
            }
        }

        if( TRUE != bSigned )
        {
            //
            // The hash was in this catalog, but the file wasn't a member... so off to the next catalog
            //

            hPrevCatInfo = hCatInfo;

            hCatInfo = CryptCATAdminEnumCatalogFromHash( g_hCatAdmin, 
                                                         Hash, 
                                                         dwHashSize, 
                                                         0, 
                                                         &hPrevCatInfo );
        }
    }

    if( NULL == hCatInfo )
    {
        //
        // If it wasn't found in the catalogs, check if the file is individually signed.
        //

        bSigned = VerifyIsFileSigned( szDriverFileName,
                                      &VerInfo );
    }

Done:

    return bSigned;
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfSetWindowText( CWnd &Wnd,
                       ULONG uIdResourceString )
{
    BOOL bLoaded;
    CString strText;

    //
    // It's safe to use CString::LoadString here because we are 
    // in GUI mode
    //

    ASSERT( FALSE == g_bCommandLineMode );

    bLoaded = strText.LoadString( uIdResourceString );

    ASSERT( TRUE == bLoaded );

    Wnd.SetWindowText( strText );

    return ( TRUE == bLoaded );
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfWriteVerifierSettings( BOOL bHaveNewDrivers,
                               const CString &strDriversToVerify,
                               BOOL bHaveNewFlags,
                               DWORD dwVerifyFlags )
{
    HKEY hMmKey = NULL;
    LONG lResult;
    BOOL bSuccess;

    ASSERT( bHaveNewDrivers || bHaveNewFlags );

    bSuccess = FALSE;

    if( bHaveNewDrivers && strDriversToVerify.GetLength() == 0 )
    {
        //
        // No drivers to verify
        //

        ASSERT( FALSE && "VrfDeleteAllVerifierSettings should have been called for this" );

        return VrfDeleteAllVerifierSettings();
    }

    if( bHaveNewFlags )
    {
        TRACE( _T( "VrfWriteVerifierSettings: New verifier flags = %#x\n" ),
            dwVerifyFlags );
    }
    
    if( bHaveNewDrivers )
    {
        TRACE( _T( "VrfWriteVerifierSettings: New drivers = %s\n" ),
            (LPCTSTR) strDriversToVerify );
    }

    //
    // Open the Mm key
    //

    lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            RegMemoryManagementKeyName,
                            0,
                            KEY_SET_VALUE,
                            &hMmKey );

    if( lResult != ERROR_SUCCESS ) 
    {
        if( lResult == ERROR_ACCESS_DENIED ) 
        {
            VrfErrorResourceFormat(
                IDS_ACCESS_IS_DENIED );
        }
        else 
        {
            VrfErrorResourceFormat(
                IDS_REGOPENKEYEX_FAILED,
                RegMemoryManagementKeyName,
                (DWORD)lResult);
        }

        goto Done;
    }

    if( bHaveNewFlags )
    {
        //
        // Write VerifyDriverLevel value
        //

        if( VrfWriteRegistryDwordValue( hMmKey, 
                                        RegVerifyDriverLevelValueName, 
                                        dwVerifyFlags ) == FALSE ) 
        {
            RegCloseKey (hMmKey);

            goto Done;
        }
    }

    if( bHaveNewDrivers )
    {
        //
        // Write VerifyDrivers value
        //

        if( VrfWriteRegistryStringValue( hMmKey, 
                                         RegVerifyDriversValueName, 
                                         strDriversToVerify ) == FALSE ) 
        {
            RegCloseKey (hMmKey);
        
            goto Done;
        }
    }

    //
    // Close the Mm key and return success
    //

    RegCloseKey( hMmKey );

    bSuccess = TRUE;

    if( bSuccess )
    {
        if( g_bSettingsSaved )
        {
            VrfMesssageFromResource( IDS_REBOOT );
        }
        else
        {
            VrfMesssageFromResource( IDS_NO_SETTINGS_WERE_CHANGED );
        }
    }

Done:
    
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfWriteRegistryDwordValue( HKEY hKey,
                                 LPCTSTR szValueName,
                                 DWORD dwValue )
{
    LONG lResult;
    BOOL bSuccess;

    lResult = RegSetValueEx( hKey,
                            szValueName,
                            0,
                            REG_DWORD,
                            ( LPBYTE ) &dwValue,
                            sizeof( dwValue ) );

    bSuccess = ( lResult == ERROR_SUCCESS );

    g_bSettingsSaved = g_bSettingsSaved | bSuccess;

    if( TRUE != bSuccess ) 
    {
        VrfErrorResourceFormat(
            IDS_REGSETVALUEEX_FAILED,
            szValueName,
            (DWORD) lResult );
    }

    return bSuccess;
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfWriteRegistryStringValue( HKEY hKey,
                                  LPCTSTR szValueName,
                                  LPCTSTR szValue )
{
    BOOL bSuccess;
    LONG lResult;

    lResult = RegSetValueEx ( hKey,
                              szValueName,
                              0,
                              REG_SZ,
                              (LPBYTE) szValue,
                              ( _tcslen( szValue ) + 1 ) * sizeof (TCHAR) );

    bSuccess = ( lResult == ERROR_SUCCESS );

    g_bSettingsSaved = g_bSettingsSaved | bSuccess;

    if( TRUE != bSuccess ) 
    {
        VrfErrorResourceFormat(
            IDS_REGSETVALUEEX_FAILED,
            szValueName,
            (DWORD) lResult);
    }

    return bSuccess;
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfReadVerifierSettings( CString &strDriversToVerify,
                              DWORD &dwVerifyFlags )
{
    HKEY hMmKey = NULL;
    LONG lResult;
    BOOL bSuccess;

    bSuccess = FALSE;

    //
    // Open the Mm key
    //

    lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            RegMemoryManagementKeyName,
                            0,
                            KEY_QUERY_VALUE,
                            &hMmKey );

    if( lResult != ERROR_SUCCESS ) 
    {
        if( lResult == ERROR_ACCESS_DENIED ) 
        {
            VrfErrorResourceFormat(
                IDS_ACCESS_IS_DENIED );
        }
        else 
        {
            VrfErrorResourceFormat(
                IDS_REGOPENKEYEX_FAILED,
                RegMemoryManagementKeyName,
                (DWORD)lResult);
        }

        goto Done;
    }

    //
    // Read VerifyDriverLevel value
    //

    if( VrfReadRegistryDwordValue( hMmKey, 
                                   RegVerifyDriverLevelValueName, 
                                   dwVerifyFlags ) == FALSE ) 
    {
        RegCloseKey (hMmKey);

        goto Done;
    }

    //
    // Read VerifyDrivers value
    //

    if( VrfReadRegistryStringValue( hMmKey, 
                                    RegVerifyDriversValueName, 
                                    strDriversToVerify ) == FALSE ) 
    {
        RegCloseKey (hMmKey);
        
        goto Done;
    }

    //
    // Close the Mm key and return success
    //

    RegCloseKey( hMmKey );

    bSuccess = TRUE;

Done:
    
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrtLoadCurrentRegistrySettings( BOOL &bAllDriversVerified,
                                     CStringArray &astrDriversToVerify,
                                     DWORD &dwVerifyFlags )
{
    BOOL bResult;
    CString strDriversToVerify;

    astrDriversToVerify.RemoveAll();
    dwVerifyFlags = 0;
    bAllDriversVerified = FALSE;

    bResult = VrfReadVerifierSettings( strDriversToVerify,
                                       dwVerifyFlags );

    strDriversToVerify.TrimLeft();
    strDriversToVerify.TrimRight();

    if( strDriversToVerify.CompareNoCase( _T( "*" ) ) == 0 )
    {
        bAllDriversVerified = TRUE;
    }
    else
    {
        VrfSplitDriverNamesSpaceSeparated( strDriversToVerify,
                                           astrDriversToVerify );
    }

    return bResult;
}

/////////////////////////////////////////////////////////////////////////////
VOID VrfSplitDriverNamesSpaceSeparated( CString strAllDrivers,
                                        CStringArray &astrVerifyDriverNames )
{
    INT nCharIndex;
    CString strCrtDriverName;

    astrVerifyDriverNames.RemoveAll();

    //
    // Split the space separated driver names in astrDriversToVerify
    //

    strAllDrivers.TrimRight();

    while( TRUE )
    {
        strAllDrivers.TrimLeft();

        if( strAllDrivers.GetLength() == 0 )
        {
            //
            // We are done parsing the whole string
            //

            break;
        }

        //
        // Look for a space or a tab
        //

        nCharIndex = strAllDrivers.Find( _T( ' ' ) );

        if( nCharIndex < 0 )
        {
            nCharIndex = strAllDrivers.Find( _T( '\t' ) );
        }

        if( nCharIndex >= 0 )
        {
            //
            // Found a separator  character
            //

            strCrtDriverName = strAllDrivers.Left( nCharIndex );

            if( strCrtDriverName.GetLength() > 0 &&
                FALSE == VrfIsStringInArray( strCrtDriverName,
                                             astrVerifyDriverNames ) )
            {
                astrVerifyDriverNames.Add( strCrtDriverName );
            }

            strAllDrivers = strAllDrivers.Right( strAllDrivers.GetLength() - nCharIndex - 1 );
        }
        else
        {
            //
            // This is the last driver name
            //

            if( FALSE == VrfIsStringInArray( strAllDrivers,
                                             astrVerifyDriverNames ) )
            {
                astrVerifyDriverNames.Add( strAllDrivers );
            }

            break;
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfIsDriversSetDifferent( CString strAllDrivers1, 
                               const CStringArray &astrVerifyDriverNames2 )
{
    BOOL bDifferent;
    INT_PTR nDriverNames1;
    INT_PTR nDriverNames2;
    INT_PTR nCrtDriver1;
    INT_PTR nCrtDriver2;
    CString strDriver1;
    CString strDriver2;
    CStringArray astrVerifyDriverNames1;

    bDifferent = TRUE;

    VrfSplitDriverNamesSpaceSeparated( strAllDrivers1,
                                       astrVerifyDriverNames1 );

    nDriverNames1 = astrVerifyDriverNames1.GetSize();
    nDriverNames2 = astrVerifyDriverNames2.GetSize();

    if( nDriverNames1 == nDriverNames2 )
    {
        //
        // Same number of drivers
        //

        bDifferent = FALSE;

        for( nCrtDriver1 = 0; nCrtDriver1 < nDriverNames1; nCrtDriver1 += 1 )
        {
            strDriver1 = astrVerifyDriverNames1.GetAt( nCrtDriver1 );

            bDifferent = TRUE;

            //
            // Look for strDriver1 in astrVerifyDriverNames2
            //

            for( nCrtDriver2 = 0; nCrtDriver2 < nDriverNames2; nCrtDriver2 += 1 )
            {
                strDriver2 = astrVerifyDriverNames2.GetAt( nCrtDriver2 );

                if( strDriver1.CompareNoCase( strDriver2 ) == 0 )
                {
                    bDifferent = FALSE;

                    break;
                }
            }

            if( TRUE == bDifferent )
            {
                //
                // Did not find strDriver1 in astrVerifyDriverNames2
                //

                break;
            }
        }
    }

    return bDifferent;
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfReadRegistryDwordValue( HKEY hKey,
                                LPCTSTR szValueName,
                                DWORD &dwValue )
{
    LONG lResult;
    BOOL bSuccess;
    DWORD dwType;
    DWORD dwDataSize;

    dwDataSize = sizeof( dwValue );

    lResult = RegQueryValueEx( hKey,
                               szValueName,
                               0,
                               &dwType,
                               ( LPBYTE ) &dwValue,
                               &dwDataSize );

    if( lResult == ERROR_FILE_NOT_FOUND )
    {
        //
        // The value doesn't currently exist
        //

        dwValue = 0;
        bSuccess = TRUE;
    }
    else
    {
        bSuccess = ( ERROR_SUCCESS == lResult && 
                     REG_DWORD == dwType &&
                     dwDataSize == sizeof( dwValue ) );
    }

    if( TRUE != bSuccess ) 
    {
        VrfErrorResourceFormat(
            IDS_REGQUERYVALUEEX_FAILED,
            szValueName,
            (DWORD) lResult );
    }

    return bSuccess;
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfReadRegistryStringValue( HKEY hKey,
                                 LPCTSTR szValueName,
                                 CString &strDriversToVerify )
{
    BOOL bSuccess;
    LONG lResult;
    LPTSTR szDriversToVerify;
    ULONG uRegKeyLength;
    DWORD dwType;
    DWORD dwDataSize;

    bSuccess = FALSE;
    lResult = ERROR_NOT_ENOUGH_MEMORY;
    szDriversToVerify = NULL;

    for( uRegKeyLength = 128; uRegKeyLength < 4096; uRegKeyLength += 128 )
    {
        //
        // Try allocate a local buffer and use it to query
        //

        szDriversToVerify = new TCHAR[ uRegKeyLength ];

        if( NULL != szDriversToVerify )
        {
            dwDataSize = uRegKeyLength * sizeof (TCHAR);

            lResult = RegQueryValueEx( hKey,
                                       szValueName,
                                       0,
                                       &dwType,
                                       (LPBYTE) szDriversToVerify,
                                       &dwDataSize );

            switch( lResult )
            {
            case ERROR_FILE_NOT_FOUND:
                //
                // Return an empty string
                //

                szDriversToVerify[ 0 ] = (TCHAR)0;

                bSuccess = TRUE;
                
                break;

            case ERROR_SUCCESS:
                //
                // Got the driver names from the registry
                //

                bSuccess = ( REG_SZ == dwType );

                break;

            default:
                //
                // Try with a bigger buffer
                //

                break;
            }

        }

        if( FALSE != bSuccess )
        {
            //
            // Got what we needed
            //

            break;
        }
        else
        {
            //
            // Delete the current buffer and try with a bigger one
            //

            ASSERT( NULL != szDriversToVerify );

            strDriversToVerify = szDriversToVerify;

            delete [] szDriversToVerify;
            szDriversToVerify = NULL;
        }
    }

    if( TRUE != bSuccess ) 
    {
        VrfErrorResourceFormat(
            IDS_REGSETVALUEEX_FAILED,
            szValueName,
            (DWORD) lResult);
    }
    else
    {
        ASSERT( NULL != szDriversToVerify );

        strDriversToVerify = szDriversToVerify;

        delete [] szDriversToVerify;
        szDriversToVerify = NULL;
    }

    return bSuccess;
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfDeleteAllVerifierSettings()
{
    HKEY hMmKey = NULL;
    LONG lResult;
    BOOL bSuccess;

    bSuccess = FALSE;

    //
    // Open the Mm key
    //

    lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            RegMemoryManagementKeyName,
                            0,
                            KEY_SET_VALUE,
                            &hMmKey );

    if( lResult != ERROR_SUCCESS ) 
    {
        if( lResult == ERROR_ACCESS_DENIED ) 
        {
            VrfErrorResourceFormat(
                IDS_ACCESS_IS_DENIED );
        }
        else 
        {
            VrfErrorResourceFormat(
                IDS_REGOPENKEYEX_FAILED,
                RegMemoryManagementKeyName,
                (DWORD)lResult);
        }

        goto Done;
    }

    //
    // Delete VerifyDriverLevel value
    //

    lResult = RegDeleteValue( hMmKey, 
                              RegVerifyDriverLevelValueName );

    if( lResult != ERROR_SUCCESS && lResult != ERROR_FILE_NOT_FOUND ) 
    {
        VrfErrorResourceFormat(
            IDS_REGDELETEVALUE_FAILED,
            RegVerifyDriverLevelValueName,
            (DWORD) lResult );

        goto Done;
    }

    g_bSettingsSaved = g_bSettingsSaved | ( lResult != ERROR_FILE_NOT_FOUND );

    //
    // Delete VerifyDrivers value
    //

    lResult = RegDeleteValue( hMmKey, 
                              RegVerifyDriversValueName );
 
    if( lResult != ERROR_SUCCESS && lResult != ERROR_FILE_NOT_FOUND ) 
    {
        VrfErrorResourceFormat(
            IDS_REGDELETEVALUE_FAILED,
            RegVerifyDriversValueName,
            (DWORD) lResult );

        RegCloseKey (hMmKey);
        
        goto Done;
    }

    g_bSettingsSaved = g_bSettingsSaved | ( lResult != ERROR_FILE_NOT_FOUND );

    //
    // Close the Mm key and return success
    //

    RegCloseKey( hMmKey );

    bSuccess = TRUE;

    if( bSuccess && g_bSettingsSaved )
    {
        VrfMesssageFromResource( IDS_REBOOT );
    }
    else
    {
        VrfMesssageFromResource(
            IDS_NO_SETTINGS_WERE_CHANGED );
    }

Done:
    
    return bSuccess;
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfGetRuntimeVerifierData( CRuntimeVerifierData *pRuntimeVerifierData )
{
    NTSTATUS Status;
    ULONG Length = 0;
    ULONG buffersize;
    BOOL bSuccess;
    PSYSTEM_VERIFIER_INFORMATION VerifierInfo;
    PSYSTEM_VERIFIER_INFORMATION VerifierInfoBase;
    CRuntimeDriverData *pCrtDriverData;
    LPTSTR szName;

    ASSERT_VALID( pRuntimeVerifierData );

    pRuntimeVerifierData->FillWithDefaults();

    pRuntimeVerifierData->m_RuntimeDriverDataArray.DeleteAll();

    bSuccess = FALSE;

    //
    // Try to get the right size for the NtQuery buffer
    //

    buffersize = 1024;

    do 
    {
        VerifierInfo = (PSYSTEM_VERIFIER_INFORMATION)malloc (buffersize);
        
        if (VerifierInfo == NULL) 
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        Status = NtQuerySystemInformation (SystemVerifierInformation,
                                           VerifierInfo,
                                           buffersize,
                                           &Length);

        if (Status != STATUS_INFO_LENGTH_MISMATCH) 
        {
            break;
        }

        free (VerifierInfo);
        buffersize += 1024;

    } while (1);

    if (! NT_SUCCESS(Status)) 
    {
        VrfErrorResourceFormat(
            IDS_QUERY_SYSINFO_FAILED,
            Status);

        goto Done;
    }

    //
    // If no info fill out return success but no info.
    //

    if (Length == 0) 
    {
        free (VerifierInfo);
        
        bSuccess = TRUE;

        goto Done;
    }

    //
    // Fill out the cumulative-driver stuff.
    //

    VerifierInfoBase = VerifierInfo;

    pRuntimeVerifierData->m_bSpecialPool    = (VerifierInfo->Level & DRIVER_VERIFIER_SPECIAL_POOLING) ? TRUE : FALSE;
    pRuntimeVerifierData->m_bForceIrql      = (VerifierInfo->Level & DRIVER_VERIFIER_FORCE_IRQL_CHECKING) ? TRUE : FALSE;
    pRuntimeVerifierData->m_bLowRes         = (VerifierInfo->Level & DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES) ? TRUE : FALSE;
    pRuntimeVerifierData->m_bPoolTracking   = (VerifierInfo->Level & DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS) ? TRUE : FALSE;
    pRuntimeVerifierData->m_bIo             = (VerifierInfo->Level & DRIVER_VERIFIER_IO_CHECKING) ? TRUE : FALSE;
    pRuntimeVerifierData->m_bDeadlockDetect = (VerifierInfo->Level & DRIVER_VERIFIER_DEADLOCK_DETECTION) ? TRUE : FALSE;
    pRuntimeVerifierData->m_bDMAVerif       = (VerifierInfo->Level & DRIVER_VERIFIER_DMA_VERIFIER) ? TRUE : FALSE;
    pRuntimeVerifierData->m_bEnhIo          = (VerifierInfo->Level & DRIVER_VERIFIER_ENHANCED_IO_CHECKING) ? TRUE : FALSE;

    pRuntimeVerifierData->RaiseIrqls = VerifierInfo->RaiseIrqls;
    pRuntimeVerifierData->AcquireSpinLocks = VerifierInfo->AcquireSpinLocks;
    pRuntimeVerifierData->SynchronizeExecutions = VerifierInfo->SynchronizeExecutions;
    pRuntimeVerifierData->AllocationsAttempted = VerifierInfo->AllocationsAttempted;
    pRuntimeVerifierData->AllocationsSucceeded = VerifierInfo->AllocationsSucceeded;
    pRuntimeVerifierData->AllocationsSucceededSpecialPool = VerifierInfo->AllocationsSucceededSpecialPool;
    pRuntimeVerifierData->AllocationsWithNoTag = VerifierInfo->AllocationsWithNoTag;

    pRuntimeVerifierData->Trims = VerifierInfo->Trims;
    pRuntimeVerifierData->AllocationsFailed = VerifierInfo->AllocationsFailed;
    pRuntimeVerifierData->AllocationsFailedDeliberately = VerifierInfo->AllocationsFailedDeliberately;

    pRuntimeVerifierData->UnTrackedPool = VerifierInfo->UnTrackedPool;
    
    pRuntimeVerifierData->Level = VerifierInfo->Level;

    //
    // Fill out the per-driver stuff.
    //

    VerifierInfo = VerifierInfoBase;

    do 
    {
        //
        // Allocate a new driver data structure
        //

        pCrtDriverData = new CRuntimeDriverData;
        
        if( NULL == pCrtDriverData )
        {
            VrfErrorResourceFormat( IDS_NOT_ENOUGH_MEMORY );

            break;
        }

#ifndef UNICODE
        ANSI_STRING Name;
        NTSTATUS Status;

        Status = RtlUnicodeStringToAnsiString (
            & Name,
            & VerifierInfo->DriverName,
            TRUE);

        if (! (NT_SUCCESS(Status) ) ) 
        {
            VrfErrorResourceFormat( IDS_NOT_ENOUGH_MEMORY );

            break;
        }

        szName = pCrtDriverData->m_strName.GetBuffer( Name.Length + 1 );

        if( NULL != szName )
        {
            CopyMemory( szName,
                        Name.Buffer,
                        ( Name.Length + 1 ) * sizeof( Name.Buffer[ 0 ] ) );

            szName[ Name.Length ] = 0;

            pCrtDriverData->m_strName.ReleaseBuffer();
        }

        RtlFreeAnsiString (& Name);

#else

        szName = pCrtDriverData->m_strName.GetBuffer( VerifierInfo->DriverName.Length + 1 );

        if( NULL != szName )
        {
            CopyMemory( szName,
                        VerifierInfo->DriverName.Buffer,
                        ( VerifierInfo->DriverName.Length + 1 ) * sizeof( VerifierInfo->DriverName.Buffer[ 0 ] ) );

            szName[ VerifierInfo->DriverName.Length ] = 0;
            
            pCrtDriverData->m_strName.ReleaseBuffer();
        }

#endif //#ifndef UNICODE

        if( FALSE != pRuntimeVerifierData->IsDriverVerified( pCrtDriverData->m_strName ) )
        {
            //
            // This is a duplicate entry - ignore it.
            //

            delete pCrtDriverData;
        }
        else 
        {
            pCrtDriverData->Loads = VerifierInfo->Loads;
            pCrtDriverData->Unloads = VerifierInfo->Unloads;

            pCrtDriverData->CurrentPagedPoolAllocations = VerifierInfo->CurrentPagedPoolAllocations;
            pCrtDriverData->CurrentNonPagedPoolAllocations = VerifierInfo->CurrentNonPagedPoolAllocations;
            pCrtDriverData->PeakPagedPoolAllocations = VerifierInfo->PeakPagedPoolAllocations;
            pCrtDriverData->PeakNonPagedPoolAllocations = VerifierInfo->PeakNonPagedPoolAllocations;

            pCrtDriverData->PagedPoolUsageInBytes = VerifierInfo->PagedPoolUsageInBytes;
            pCrtDriverData->NonPagedPoolUsageInBytes = VerifierInfo->NonPagedPoolUsageInBytes;
            pCrtDriverData->PeakPagedPoolUsageInBytes = VerifierInfo->PeakPagedPoolUsageInBytes;
            pCrtDriverData->PeakNonPagedPoolUsageInBytes = VerifierInfo->PeakNonPagedPoolUsageInBytes;

            pRuntimeVerifierData->m_RuntimeDriverDataArray.Add( pCrtDriverData );
        }

        if (VerifierInfo->NextEntryOffset == 0) {
            break;
        }

        VerifierInfo = (PSYSTEM_VERIFIER_INFORMATION)((PCHAR)VerifierInfo + VerifierInfo->NextEntryOffset);

    } 
    while (1);

    free (VerifierInfoBase);

Done:
    return TRUE;

}

/////////////////////////////////////////////////////////////////////
PLOADED_IMAGE VrfImageLoad( LPTSTR szBinaryName,
                            LPTSTR szDirectory )
{
#ifdef UNICODE

    char *szOemImageName;
    char *szOemDirectory;
    int nStringLength;
    PLOADED_IMAGE pLoadedImage;

    pLoadedImage = NULL;
        
    nStringLength = wcslen( szBinaryName );

    szOemImageName = new char [ nStringLength + 1 ];
    
    if( NULL != szOemImageName )
    {
        CharToOem( szBinaryName,
                   szOemImageName );

        if( NULL == szDirectory )
        {
            szOemDirectory = NULL;
        }
        else
        {
            nStringLength = wcslen( szDirectory );
            
            szOemDirectory = new char [ nStringLength + 1 ];

            CharToOem( szDirectory,
                       szOemDirectory );
        }

        pLoadedImage = ImageLoad( szOemImageName,
                                  szOemDirectory );

        if( NULL != szOemDirectory )
        {
            delete [] szOemDirectory;
        }

        delete [] szOemImageName;
    }

    return pLoadedImage;

#else

    //
    // Already have ANSI strings
    //

    return ImageLoad( szBinaryName,
                      szDirectory );

#endif //#ifdef UNICODE
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfDumpStateToFile( FILE *file )
{
    BOOL bSuccess;
    INT_PTR nDriversNo;
    INT_PTR nCrtDriver;
    SYSTEMTIME SystemTime;
    TCHAR strLocalTime[ 64 ];
    TCHAR strLocalDate[ 64 ];
    CRuntimeDriverData *pRunDriverData;
    CRuntimeVerifierData RunTimeVerifierData;

    //
    // Output the date&time in the current user format
    //

    GetLocalTime( &SystemTime );

    if( GetDateFormat(
        LOCALE_USER_DEFAULT,
        0,
        &SystemTime,
        NULL,
        strLocalDate,
        ARRAY_LENGTH( strLocalDate ) ) )
    {
        VrfFTPrintf(
            file,
            _T( "%s, " ),
            strLocalDate );
    }
    else
    {
        ASSERT( FALSE );
    }

    if( GetTimeFormat(
        LOCALE_USER_DEFAULT,
        0,
        &SystemTime,
        NULL,
        strLocalTime,
        ARRAY_LENGTH( strLocalTime ) ) )
    {
        VrfFTPrintf(
            file,
            _T( "%s\n" ),
            strLocalTime);
    }
    else
    {
        ASSERT( FALSE );

        VrfFTPrintf(
            file,
            _T( "\n" ) );
    }

    //
    // Get the current verifier statistics
    //

    if( VrfGetRuntimeVerifierData( &RunTimeVerifierData ) == FALSE) {

       VrfOuputStringFromResources(
            IDS_CANTGET_VERIF_STATE,
            file );

        bSuccess = FALSE;
        
        goto Done;
    }

    nDriversNo = RunTimeVerifierData.m_RuntimeDriverDataArray.GetSize();

    if( 0 == nDriversNo ) 
    {
        //
        // no statistics to dump
        //

        bSuccess = VrfOuputStringFromResources(
            IDS_NO_DRIVER_VERIFIED,
            file );
    }
    else 
    {
        //
        // dump the counters
        //

        //
        // global counters
        //

        if( ( ! VrfFTPrintfResourceFormat( file, IDS_LEVEL, RunTimeVerifierData.Level ) ) ||
            ( ! VrfFTPrintfResourceFormat( file, IDS_RAISEIRQLS, RunTimeVerifierData.RaiseIrqls ) ) ||
            ( ! VrfFTPrintfResourceFormat( file, IDS_ACQUIRESPINLOCKS, RunTimeVerifierData.AcquireSpinLocks ) ) ||
            ( ! VrfFTPrintfResourceFormat( file, IDS_SYNCHRONIZEEXECUTIONS, RunTimeVerifierData.SynchronizeExecutions) ) ||

            ( ! VrfFTPrintfResourceFormat( file, IDS_ALLOCATIONSATTEMPTED, RunTimeVerifierData.AllocationsAttempted) ) ||
            ( ! VrfFTPrintfResourceFormat( file, IDS_ALLOCATIONSSUCCEEDED, RunTimeVerifierData.AllocationsSucceeded) ) ||
            ( ! VrfFTPrintfResourceFormat( file, IDS_ALLOCATIONSSUCCEEDEDSPECIALPOOL, RunTimeVerifierData.AllocationsSucceededSpecialPool) ) ||
            ( ! VrfFTPrintfResourceFormat( file, IDS_ALLOCATIONSWITHNOTAG, RunTimeVerifierData.AllocationsWithNoTag) ) ||

            ( ! VrfFTPrintfResourceFormat( file, IDS_ALLOCATIONSFAILED, RunTimeVerifierData.AllocationsFailed) ) ||
            ( ! VrfFTPrintfResourceFormat( file, IDS_ALLOCATIONSFAILEDDELIBERATELY, RunTimeVerifierData.AllocationsFailedDeliberately) ) ||

            ( ! VrfFTPrintfResourceFormat( file, IDS_TRIMS, RunTimeVerifierData.Trims) ) ||

            ( ! VrfFTPrintfResourceFormat( file, IDS_UNTRACKEDPOOL, RunTimeVerifierData.UnTrackedPool) ) )
        {

            bSuccess = FALSE;

            goto Done;
        }

        //
        // per driver counters
        //

        if( ! VrfOuputStringFromResources(
            IDS_THE_VERIFIED_DRIVERS,
            file ) )
        {
            bSuccess = FALSE;

            goto Done;
        }

        for( nCrtDriver = 0; nCrtDriver < nDriversNo; nCrtDriver += 1 ) 
        {
            VrfFTPrintf(
                file,
                _T( "\n" ) );

            pRunDriverData = RunTimeVerifierData.m_RuntimeDriverDataArray.GetAt( nCrtDriver ) ;

            ASSERT_VALID( pRunDriverData );

            if( VrfFTPrintfResourceFormat(
                    file,
                    IDS_NAME_LOADS_UNLOADS,
                    (LPCTSTR)pRunDriverData->m_strName,
                    pRunDriverData->Loads,
                    pRunDriverData->Unloads) == FALSE )
            {
                bSuccess = FALSE;

                goto Done;
            }

            //
            // pool statistics
            //

            if( ( ! VrfFTPrintfResourceFormat( file, IDS_CURRENTPAGEDPOOLALLOCATIONS, pRunDriverData->CurrentPagedPoolAllocations) ) ||
                ( ! VrfFTPrintfResourceFormat( file, IDS_CURRENTNONPAGEDPOOLALLOCATIONS, pRunDriverData->CurrentNonPagedPoolAllocations) ) ||
                ( ! VrfFTPrintfResourceFormat( file, IDS_PEAKPAGEDPOOLALLOCATIONS, pRunDriverData->PeakPagedPoolAllocations) ) ||
                ( ! VrfFTPrintfResourceFormat( file, IDS_PEAKNONPAGEDPOOLALLOCATIONS, pRunDriverData->PeakNonPagedPoolAllocations) ) ||

                ( ! VrfFTPrintfResourceFormat( file, IDS_PAGEDPOOLUSAGEINBYTES, (ULONG) pRunDriverData->PagedPoolUsageInBytes) ) ||
                ( ! VrfFTPrintfResourceFormat( file, IDS_NONPAGEDPOOLUSAGEINBYTES, (ULONG) pRunDriverData->NonPagedPoolUsageInBytes) ) ||
                ( ! VrfFTPrintfResourceFormat( file, IDS_PEAKPAGEDPOOLUSAGEINBYTES, (ULONG) pRunDriverData->PeakPagedPoolUsageInBytes) ) ||
                ( ! VrfFTPrintfResourceFormat( file, IDS_PEAKNONPAGEDPOOLUSAGEINBYTES, (ULONG) pRunDriverData->PeakNonPagedPoolUsageInBytes) ) )
            {
                bSuccess = FALSE;

                goto Done;
            }
        }
    }

Done:

    return bSuccess;
}

/////////////////////////////////////////////////////////////////////////////
BOOL __cdecl VrfFTPrintf( FILE *file,
                          LPCTSTR szFormat,
                          ... )
{
    TCHAR szMessage[ 256 ];
    BOOL bResult;
    va_list prms;

    ASSERT( NULL != file );
    ASSERT( g_bCommandLineMode );

    va_start (prms, szFormat);

    //
    // Format the message in our local buffer
    //

    _vsntprintf ( szMessage, 
                  ARRAY_LENGTH( szMessage ), 
                  szFormat, 
                  prms );

    bResult = ( _fputts( szMessage, file ) >= 0 );

    va_end (prms);

    return bResult;
}

/////////////////////////////////////////////////////////////////////////////
BOOL __cdecl VrfFTPrintfResourceFormat( FILE *file,
                                        UINT uIdResourceFormat,
                                        ... )
{
    TCHAR szMessage[ 256 ];
    TCHAR strFormat[ 256 ];
    BOOL bResult;
    va_list prms;
    
    ASSERT( NULL != file );

    //
    // Load the format string from the resources
    //

    bResult = VrfLoadString( uIdResourceFormat,
                             strFormat,
                             ARRAY_LENGTH( strFormat ) );

    ASSERT( bResult );

    if( bResult )
    {
        va_start (prms, uIdResourceFormat);

        //
        // Format the message in our local buffer
        //

        _vsntprintf ( szMessage, 
                      ARRAY_LENGTH( szMessage ), 
                      strFormat, 
                      prms);

        bResult = ( _fputts( szMessage, file ) >= 0 );

        va_end (prms);
    }

    return bResult;
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfOuputStringFromResources( UINT uIdString,
                                  FILE *file )
{
    TCHAR szText[ 256 ];
    BOOL bResult;

    ASSERT( NULL != file );

    bResult = VrfLoadString( uIdString,
                             szText,
                             ARRAY_LENGTH( szText ) );

    if( FALSE == bResult )
    {
        goto Done;
    }

    bResult = ( _fputts( szText, file ) >= 0 );

Done:

    return bResult;
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfSetNewFlagsVolatile( DWORD dwNewFlags )
{
    BOOL bResult;
    NTSTATUS Status;
    INT_PTR nCurrentlyVerifiedDrivers;
    CRuntimeVerifierData RunTimeVerifierData;

    bResult = TRUE;

    nCurrentlyVerifiedDrivers = 0;

    if( VrfGetRuntimeVerifierData( &RunTimeVerifierData ) == FALSE )
    {
        //
        // Cannot get current verifier settings
        //

        VrfErrorResourceFormat( IDS_CANTGET_VERIF_STATE );

        bResult = FALSE;

        goto Done;
    }

    nCurrentlyVerifiedDrivers = RunTimeVerifierData.m_RuntimeDriverDataArray.GetSize();

    if( nCurrentlyVerifiedDrivers > 0 )
    {
        //
        // There are some drivers currently verified
        //

        if( RunTimeVerifierData.Level != dwNewFlags )
        {
            //
            // Just use NtSetSystemInformation to set the flags
            // that can be modified on the fly. Don't write anything to the registry.
            //

            //
            // Enable debug privilege
            //

            if( g_bPrivegeEnabled != TRUE )
            {
                g_bPrivegeEnabled = VrfEnableDebugPrivilege();

                if( g_bPrivegeEnabled != TRUE )
                {
                    bResult = FALSE;

                    goto Done;
                }
            }

            //
            // Set the new flags
            //

            Status = NtSetSystemInformation(
                SystemVerifierInformation,
                &dwNewFlags,
                sizeof( dwNewFlags ) );

            if( ! NT_SUCCESS( Status ) )
            {
                if( Status == STATUS_ACCESS_DENIED )
                {
                    //
                    // Access denied
                    //

                    VrfErrorResourceFormat(
                        IDS_ACCESS_IS_DENIED );
                }
                else
                {
                    //
                    // Some other error
                    //

                    VrfErrorResourceFormat(
                        IDS_CANNOT_CHANGE_SETTING_ON_FLY );
                }

                bResult = FALSE;

                goto Done;
            }
        }
    }
    
Done:

    if( g_bCommandLineMode )
    {
        VrfDumpChangedSettings( RunTimeVerifierData.Level,
                                dwNewFlags,
                                nCurrentlyVerifiedDrivers );
    }

    return bResult;
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfAddDriversVolatile( const CStringArray &astrNewDrivers )
{
    BOOL bSuccess;
    INT_PTR nDrivers;
    INT_PTR nCrtDriver;
    CString strCrtDriver;

    bSuccess = TRUE;

    nDrivers = astrNewDrivers.GetSize();

    for( nCrtDriver = 0; nCrtDriver < nDrivers; nCrtDriver += 1 )
    {
        strCrtDriver = astrNewDrivers.GetAt( nCrtDriver );

        if( TRUE != VrfAddDriverVolatile( strCrtDriver ) )
        {
            bSuccess = FALSE;
        }
    }

    return bSuccess;
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfAddDriverVolatile( const CString &strCrtDriver )
{
    NTSTATUS Status;
    UINT uIdErrorString;
    BOOL bSuccess;
    UNICODE_STRING usDriverName;
#ifndef UNICODE

    WCHAR *szUnicodeName = NULL;
    INT_PTR nNameLength;

#endif //#ifndef UNICODE


    bSuccess = TRUE;

    //
    // Enable debug privilege
    //

    if( g_bPrivegeEnabled != TRUE )
    {
        g_bPrivegeEnabled = VrfEnableDebugPrivilege();

        if( g_bPrivegeEnabled != TRUE )
        {
            bSuccess = FALSE;

            goto Done;
        }
    }

    //
    // Must have driver name as a UNICODE_STRING
    //

#ifdef UNICODE

    //
    // UNICODE
    //

    RtlInitUnicodeString(
        &usDriverName,
        (LPCTSTR) strCrtDriver );

#else
    //
    // ANSI
    //
    
    nNameLength = strCrtDriver.GetLength();

    szUnicodeName = new WCHAR[ nNameLength + 1 ];

    if( NULL == szUnicodeName )
    {
        VrfErrorResourceFormat( IDS_NOT_ENOUGH_MEMORY );

        bSuccess  = FALSE;

        goto Done;
    }

    MultiByteToWideChar( CP_ACP, 
                         0, 
                         (LPCSTR) strCrtDriver, 
                         -1, 
                         szUnicodeName, 
                         nNameLength + 1 );

    RtlInitUnicodeString(
        &usDriverName,
        szUnicodeName );

#endif //#ifdef UNICODE

    Status = NtSetSystemInformation(
        SystemVerifierAddDriverInformation,
        &usDriverName,
        sizeof( UNICODE_STRING ) );

    if( ! NT_SUCCESS( Status ) )
    {
        switch( Status )
        {
        case STATUS_INVALID_INFO_CLASS:
            uIdErrorString = IDS_VERIFIER_ADD_NOT_SUPPORTED;
            break;

        case STATUS_NOT_SUPPORTED:
            uIdErrorString = IDS_DYN_ADD_NOT_SUPPORTED;
            break;

        case STATUS_IMAGE_ALREADY_LOADED:
            uIdErrorString = IDS_DYN_ADD_ALREADY_LOADED;
            break;

        case STATUS_INSUFFICIENT_RESOURCES:
        case STATUS_NO_MEMORY:
            uIdErrorString = IDS_DYN_ADD_INSUF_RESOURCES;
            break;

        case STATUS_PRIVILEGE_NOT_HELD:
            uIdErrorString = IDS_DYN_ADD_ACCESS_DENIED;
            break;

        default:
            VrfErrorResourceFormat(
                IDS_DYN_ADD_MISC_ERROR,
                (LPCTSTR) strCrtDriver,
                Status );

            bSuccess  = FALSE;
        }

        VrfErrorResourceFormat(
            uIdErrorString,
            (LPCTSTR) strCrtDriver );

        bSuccess  = FALSE;
    }

#ifndef UNICODE

    if( NULL != szUnicodeName )
    {
        delete [] szUnicodeName;
    }

#endif //#ifndef UNICODE

Done:

    return bSuccess;
}


/////////////////////////////////////////////////////////////////////////////
BOOL VrfRemoveDriversVolatile( const CStringArray &astrNewDrivers )
{
    INT_PTR nDrivers;
    INT_PTR nCrtDriver;
    BOOL bSuccess;
    CString strCrtDriver;

    bSuccess = TRUE;

    nDrivers = astrNewDrivers.GetSize();

    for( nCrtDriver = 0; nCrtDriver < nDrivers; nCrtDriver += 1 )
    {
        strCrtDriver = astrNewDrivers.GetAt( nCrtDriver );

        if( TRUE != VrfRemoveDriverVolatile( strCrtDriver ) )
        {
            bSuccess = FALSE;
        }
    }

    return bSuccess;
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfRemoveDriverVolatile( const CString &strDriverName )
{
    NTSTATUS Status;
    UINT uIdErrorString;
    BOOL bSuccess;
    UNICODE_STRING usDriverName;
#ifndef UNICODE

    WCHAR *szUnicodeName = NULL;
    INT_PTR nNameLength;

#endif //#ifndef UNICODE

    bSuccess = TRUE;

    //
    // Enable debug privilege
    //

    if( g_bPrivegeEnabled != TRUE )
    {
        g_bPrivegeEnabled = VrfEnableDebugPrivilege();

        if( g_bPrivegeEnabled != TRUE )
        {
            bSuccess = FALSE;

            goto Done;
        }
    }

    //
    // Must have driver name as a UNICODE_STRING
    //

#ifdef UNICODE

    //
    // UNICODE
    //

    RtlInitUnicodeString(
        &usDriverName,
        (LPCTSTR) strDriverName );

#else
    //
    // ANSI
    //
    
    nNameLength = strDriverName.GetLength();

    szUnicodeName = new WCHAR[ nNameLength + 1 ];

    if( NULL == szUnicodeName )
    {
        VrfErrorResourceFormat( IDS_NOT_ENOUGH_MEMORY );

        bSuccess  = FALSE;

        goto Done;
    }

    MultiByteToWideChar( CP_ACP, 
                         0, 
                         (LPCSTR) strDriverName, 
                         -1, 
                         szUnicodeName, 
                         nNameLength + 1 );

    RtlInitUnicodeString(
        &usDriverName,
        szUnicodeName );

#endif //#ifdef UNICODE

    Status = NtSetSystemInformation(
        SystemVerifierRemoveDriverInformation,
        &usDriverName,
        sizeof( UNICODE_STRING ) );

    if( ! NT_SUCCESS( Status ) )
    {
        switch( Status )
        {
        case STATUS_INVALID_INFO_CLASS:
            uIdErrorString = IDS_VERIFIER_REMOVE_NOT_SUPPORTED;
            break;

        case STATUS_NOT_SUPPORTED:
            //
            // the driver verifier is not currently active at all -> success
            //

        case STATUS_NOT_FOUND:
            //
            // the driver is not currently verified -> success
            //

            return TRUE;

        case STATUS_IMAGE_ALREADY_LOADED:
            uIdErrorString = IDS_DYN_REMOVE_ALREADY_LOADED;
            break;

        case STATUS_INSUFFICIENT_RESOURCES:
        case STATUS_NO_MEMORY:
            uIdErrorString = IDS_DYN_REMOVE_INSUF_RESOURCES;
            break;

        case STATUS_PRIVILEGE_NOT_HELD:
            uIdErrorString = IDS_DYN_REMOVE_ACCESS_DENIED;
            break;

        default:
            VrfErrorResourceFormat(
                IDS_DYN_REMOVE_MISC_ERROR,
                (LPCTSTR) strDriverName,
                Status );

            bSuccess  = FALSE;
        }

        VrfErrorResourceFormat(
            uIdErrorString,
            (LPCTSTR) strDriverName );

        bSuccess  = FALSE;
    }

Done:

#ifndef UNICODE

    if( NULL != szUnicodeName )
    {
        delete [] szUnicodeName;
    }

#endif //#ifndef UNICODE

    return bSuccess;
}


//////////////////////////////////////////////////////////////////////
BOOL VrfEnableDebugPrivilege( )
{
    struct
    {
        DWORD Count;
        LUID_AND_ATTRIBUTES Privilege [1];

    } Info;

    HANDLE Token;
    BOOL Result;

    //
    // Open the process token
    //

    Result = OpenProcessToken (
        GetCurrentProcess (),
        TOKEN_ADJUST_PRIVILEGES,
        & Token);

    if( Result != TRUE )
    {
        VrfErrorResourceFormat(
            IDS_ACCESS_IS_DENIED );

        return FALSE;
    }

    //
    // Prepare the info structure
    //

    Info.Count = 1;
    Info.Privilege[0].Attributes = SE_PRIVILEGE_ENABLED;

    Result = LookupPrivilegeValue (
        NULL,
        SE_DEBUG_NAME,
        &(Info.Privilege[0].Luid));

    if( Result != TRUE )
    {
        VrfErrorResourceFormat(
            IDS_ACCESS_IS_DENIED );

        CloseHandle( Token );

        return FALSE;
    }

    //
    // Adjust the privileges
    //

    Result = AdjustTokenPrivileges (
        Token,
        FALSE,
        (PTOKEN_PRIVILEGES) &Info,
        NULL,
        NULL,
        NULL);

    if( Result != TRUE || GetLastError() != ERROR_SUCCESS )
    {
        VrfErrorResourceFormat(
            IDS_ACCESS_IS_DENIED );

        CloseHandle( Token );

        return FALSE;
    }

    CloseHandle( Token );

    return TRUE;
}

//////////////////////////////////////////////////////////////////////
VOID VrfDumpChangedSettings( UINT OldFlags,
                             UINT NewFlags,
                             INT_PTR nDriversVerified )
{
    UINT uDifferentFlags;

    if( nDriversVerified == 0 )
    {
        VrfPrintStringFromResources( 
            IDS_NO_DRIVER_VERIFIED );

        goto Done;
    }

    if( OldFlags == NewFlags )
    {
        //
        // no settings were changed
        //

        VrfPrintStringFromResources(
            IDS_NO_SETTINGS_WERE_CHANGED );
    }
    else
    {
        VrfPrintStringFromResources(
            IDS_CHANGED_SETTINGS_ARE );

        uDifferentFlags = OldFlags ^ NewFlags;

        //
        // changed DRIVER_VERIFIER_SPECIAL_POOLING ?
        //

        if( uDifferentFlags & DRIVER_VERIFIER_SPECIAL_POOLING )
        {
            if( NewFlags & DRIVER_VERIFIER_SPECIAL_POOLING )
            {
                VrfPrintStringFromResources(
                    IDS_SPECIAL_POOL_ENABLED_NOW );
            }
            else
            {
                VrfPrintStringFromResources(
                    IDS_SPECIAL_POOL_DISABLED_NOW );
            }
        }

        //
        // changed DRIVER_VERIFIER_FORCE_IRQL_CHECKING ?
        //

        if( uDifferentFlags & DRIVER_VERIFIER_FORCE_IRQL_CHECKING )
        {
            if( NewFlags & DRIVER_VERIFIER_FORCE_IRQL_CHECKING )
            {
                VrfPrintStringFromResources(
                    IDS_FORCE_IRQLCHECK_ENABLED_NOW );
            }
            else
            {
                VrfPrintStringFromResources(
                    IDS_FORCE_IRQLCHECK_DISABLED_NOW );
            }
        }

        //
        // changed DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES ?
        //

        if( uDifferentFlags & DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES )
        {
            if( NewFlags & DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES )
            {
                VrfPrintStringFromResources(
                    IDS_FAULT_INJECTION_ENABLED_NOW );
            }
            else
            {
                VrfPrintStringFromResources(
                    IDS_FAULT_INJECTION_DISABLED_NOW );
            }
        }

        //
        // changed DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS ?
        //

        if( uDifferentFlags & DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS )
        {
            if( NewFlags & DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS )
            {
                VrfPrintStringFromResources(
                    IDS_POOL_TRACK_ENABLED_NOW );
            }
            else
            {
                VrfPrintStringFromResources(
                    IDS_POOL_TRACK_DISABLED_NOW );
            }
        }

        //
        // changed DRIVER_VERIFIER_IO_CHECKING ?
        //

        if( uDifferentFlags & DRIVER_VERIFIER_IO_CHECKING )
        {
            if( NewFlags & DRIVER_VERIFIER_IO_CHECKING )
            {
                VrfPrintStringFromResources(
                    IDS_IO_CHECKING_ENABLED_NOW );
            }
            else
            {
                VrfPrintStringFromResources(
                    IDS_IO_CHECKING_DISABLED_NOW );
            }
        }

        //
        // the changes are not saved to the registry
        //

        VrfPrintStringFromResources(
            IDS_CHANGES_ACTIVE_ONLY_BEFORE_REBOOT );
    }

Done:

    NOTHING;
}

/////////////////////////////////////////////////////////////////////////////
DWORD VrfGetStandardFlags()
{
    DWORD dwStandardFlags;

    dwStandardFlags = DRIVER_VERIFIER_SPECIAL_POOLING           |
                      DRIVER_VERIFIER_FORCE_IRQL_CHECKING       |
                      DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS    |
                      DRIVER_VERIFIER_IO_CHECKING               |
                      DRIVER_VERIFIER_DEADLOCK_DETECTION        |
                      DRIVER_VERIFIER_DMA_VERIFIER;

    return dwStandardFlags;
}

/////////////////////////////////////////////////////////////////////////////
VOID VrfAddMiniports( CStringArray &astrVerifiedDrivers )
{
    CStringArray astrToAdd;
    CString strCrtDriver;
    CString strCrtDriverToAdd;
    CString strLinkedDriver;
    INT_PTR nVerifiedDrivers;
    INT_PTR nCrtDriver;
    INT_PTR nDriversToAdd;
    INT_PTR nCrtDriverToAdd;

    nVerifiedDrivers = astrVerifiedDrivers.GetSize();

    for( nCrtDriver = 0; nCrtDriver < nVerifiedDrivers; nCrtDriver += 1 )
    {
        //
        // This will be a verified driver
        //

        strCrtDriver = astrVerifiedDrivers.GetAt( nCrtDriver );

        //
        // Check if it is a miniport driver
        //

        if( VrfIsDriverMiniport( strCrtDriver,
                                 strLinkedDriver ) )
        {
            //
            // Check if we didn't add already strLinkedDriver
            //

            nDriversToAdd = astrToAdd.GetSize();

            for( nCrtDriverToAdd = 0; nCrtDriverToAdd < nDriversToAdd; nCrtDriverToAdd += 1 )
            {
                strCrtDriverToAdd = astrToAdd.GetAt( nCrtDriverToAdd );

                if( strCrtDriverToAdd.CompareNoCase( strLinkedDriver ) == 0 )
                {
                    //
                    // We already wanted to add this driver
                    //

                    break;
                }
            }

            if( nCrtDriverToAdd >= nDriversToAdd )
            {
                //
                // Add this new driver (strLinkedDriver)
                //

                astrToAdd.Add( strLinkedDriver );
            }
        }
    }

    //
    // Flush astrToAdd into  astrVerifiedDrivers
    //

    nDriversToAdd = astrToAdd.GetSize();

    for( nCrtDriverToAdd = 0; nCrtDriverToAdd < nDriversToAdd; nCrtDriverToAdd += 1 )
    {
        strCrtDriverToAdd = astrToAdd.GetAt( nCrtDriverToAdd );

        astrVerifiedDrivers.Add( strCrtDriverToAdd );
    }
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfIsDriverMiniport( CString &strCrtDriver,
                          CString &strLinkedDriver )
{
    //
    // N.B. 
    //
    // The imagehlp functions are not multithreading safe 
    // (see Whistler bug #88373) so if we want to use them from more than
    // one thread we will have to aquire some critical section before.
    //
    // Currently only one thread is using the imagehlp APIs in this app
    // (CSlowProgressDlg::LoadDriverDataWorkerThread) so we don't need
    // our synchronization.
    //

    LPTSTR szDriverName;
    LPTSTR szDriversDir;
    PLOADED_IMAGE pLoadedImage;
    BOOL bIsMiniport;
    BOOL bUnloaded;

    bIsMiniport = FALSE;

    ASSERT( strCrtDriver.GetLength() > 0 );

    //
    // ImageLoad doesn't know about const pointers so
    // we have to GetBuffer here :-(
    //

    szDriverName = strCrtDriver.GetBuffer( strCrtDriver.GetLength() + 1 );

    if( NULL == szDriverName )
    {
        goto Done;
    }

    szDriversDir = g_strDriversDir.GetBuffer( g_strDriversDir.GetLength() + 1 );

    if( NULL == szDriversDir )
    {
        strCrtDriver.ReleaseBuffer();

        goto Done;
    }

    //
    // Load the image
    //

    pLoadedImage = VrfImageLoad( szDriverName,
                                 szDriversDir );

    if( NULL == pLoadedImage )
    {
        //
        // Could not load the image from %windir%\system32\drivers
        // Try again from the PATH
        //

        pLoadedImage = VrfImageLoad( szDriverName,
                                     NULL );
    }

    //
    // Give our string buffers back to MFC
    //

    strCrtDriver.ReleaseBuffer();
    g_strDriversDir.ReleaseBuffer();

    if( NULL == pLoadedImage )
    {
        //
        // We couldn't load this image - bad luck
        //

        TRACE( _T( "ImageLoad failed for %s, error %u\n" ),
            (LPCTSTR) strCrtDriver,
            GetLastError() );

        goto Done;
    }

    //
    // Check if the current driver is a miniport
    //

    bIsMiniport = VrfIsDriverMiniport( pLoadedImage,
                                       strLinkedDriver );

    //
    // Clean-up
    //

    bUnloaded = ImageUnload( pLoadedImage );

    //
    // If ImageUnload fails we cannot do much about it...
    //

    ASSERT( bUnloaded );

Done:

    return bIsMiniport;
}

/////////////////////////////////////////////////////////////////////////////
LPSTR g_szSpecialDrivers[] = 
{
    "videoprt.sys",
    "scsiport.sys"
};

BOOL VrfpLookForAllImportDescriptors( PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor,
                                      ULONG_PTR uVACorrection,
                                      CString &strLinkedAgainst )
{
    PIMAGE_IMPORT_DESCRIPTOR pCurrentDescriptor;
    PCHAR pCrtName;
    ULONG uCrtSpecialDriver;
    BOOL bIsMiniport;
#ifdef UNICODE
    //
    // UNICODE
    //

    INT nCrtStringLength;
    PWSTR szMiniportName;

#endif //#ifdef UNICODE

    bIsMiniport = FALSE;

    for( uCrtSpecialDriver = 0; ! bIsMiniport && uCrtSpecialDriver < ARRAY_LENGTH( g_szSpecialDrivers ); uCrtSpecialDriver += 1 )
    {
        pCurrentDescriptor = pImportDescriptor;

        while( pCurrentDescriptor->Characteristics != NULL )
        {
            pCrtName = (PCHAR)UlongToPtr( pCurrentDescriptor->Name ) + uVACorrection;

            if( lstrcmpiA( g_szSpecialDrivers[ uCrtSpecialDriver ] , pCrtName ) == 0 )
            {
                //
                // This is a miniport
                //

#ifndef UNICODE

                //
                // ANSI
                //

                strLinkedAgainst = g_szSpecialDrivers[ uCrtSpecialDriver ];

#else
                //
                // UNICODE
                //

                nCrtStringLength = strlen( g_szSpecialDrivers[ uCrtSpecialDriver ] );

                szMiniportName = strLinkedAgainst.GetBuffer( nCrtStringLength + 1 );

                if( NULL != szMiniportName )
                {
                    MultiByteToWideChar( CP_ACP, 
                                         0, 
                                         g_szSpecialDrivers[ uCrtSpecialDriver ],
                                         -1, 
                                         szMiniportName, 
                                         ( nCrtStringLength + 1 ) * sizeof( TCHAR ) );

                    strLinkedAgainst.ReleaseBuffer();
                }
#endif

                bIsMiniport = TRUE;

                break;
            }

            pCurrentDescriptor += 1;
        }
    }

    return bIsMiniport;
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfIsDriverMiniport( PLOADED_IMAGE pLoadedImage,
                          CString &strLinkedDriver )
{
    PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor;
    PIMAGE_SECTION_HEADER pSectionHeader;
    ULONG_PTR uVACorrection;
    ULONG uDataSize;
    BOOL bIsMiniport;

    bIsMiniport = FALSE;

    //
    // We are protecting ourselves against corrupted binaries 
    // with this exception handler
    //

    try
    {
        pSectionHeader = NULL;

        pImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)ImageDirectoryEntryToDataEx(
            pLoadedImage->MappedAddress,
            FALSE,
            IMAGE_DIRECTORY_ENTRY_IMPORT,
            &uDataSize,
            &pSectionHeader );

        if( NULL == pSectionHeader )
        {
            goto Done;
        }

        uVACorrection = (ULONG_PTR) pLoadedImage->MappedAddress +
                        pSectionHeader->PointerToRawData -
                        pSectionHeader->VirtualAddress;

        bIsMiniport = VrfpLookForAllImportDescriptors( pImportDescriptor, 
                                                       uVACorrection,
                                                       strLinkedDriver );
#ifdef _DEBUG
        if( bIsMiniport )
        {
            TRACE( _T( "%s will be auto-enabled\n" ),
                   (LPCTSTR) strLinkedDriver );
        }
#endif //#ifdef DEBUG
    }
    catch( ... )
    {
        TRACE( _T( "VrfIsDriverMiniport: Caught exception\n" ) );
    }

Done:

    return bIsMiniport;
}

/////////////////////////////////////////////////////////////////////////////
VOID VrfpDumpSettingToConsole( ULONG uIdResourceString,
                               BOOL bEnabled )
{
    CString strTitle;
    CString strEnabled;
    ULONG uIdEnabledString;
    TCHAR szBigBuffer[ 128 ];

    VERIFY( VrfLoadString( uIdResourceString, strTitle ) );

    if( FALSE == bEnabled )
    {
        uIdEnabledString = IDS_DISABLED;
    }
    else
    {
        uIdEnabledString = IDS_ENABLED;
    }

    VERIFY( VrfLoadString( uIdEnabledString, strEnabled ) );

    _sntprintf( szBigBuffer,
                ARRAY_LENGTH( szBigBuffer ),
                _T( "%s: %s" ),
                (LPCTSTR) strTitle,
                (LPCTSTR) strEnabled );

    szBigBuffer[ ARRAY_LENGTH( szBigBuffer ) - 1 ] = 0;

    _putts( szBigBuffer );
}

/////////////////////////////////////////////////////////////////////////////
VOID VrfDumpRegistrySettingsToConsole()
{
    BOOL bLoaded;
    BOOL bAllDriversVerified;
    DWORD dwVerifyFlags;
    INT_PTR nDrivers;
    INT_PTR nCrtDriver;
    CString strCrtDriver;
    CStringArray astrDriversToVerify;
    
    bLoaded = VrtLoadCurrentRegistrySettings( bAllDriversVerified,
                                              astrDriversToVerify,
                                              dwVerifyFlags );

    if( FALSE != bLoaded )
    {
        VrfpDumpSettingToConsole( IDS_SPECIAL_POOL,             ( dwVerifyFlags & DRIVER_VERIFIER_SPECIAL_POOLING ) != 0 );
        VrfpDumpSettingToConsole( IDS_FORCE_IRQL_CHECKING,      ( dwVerifyFlags & DRIVER_VERIFIER_FORCE_IRQL_CHECKING ) != 0 );
        VrfpDumpSettingToConsole( IDS_LOW_RESOURCE_SIMULATION,  ( dwVerifyFlags & DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES ) != 0 );
        VrfpDumpSettingToConsole( IDS_POOL_TRACKING,            ( dwVerifyFlags & DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS ) != 0 );
        VrfpDumpSettingToConsole( IDS_IO_VERIFICATION,          ( dwVerifyFlags & DRIVER_VERIFIER_IO_CHECKING ) != 0 );
        VrfpDumpSettingToConsole( IDS_DEADLOCK_DETECTION,       ( dwVerifyFlags & DRIVER_VERIFIER_DEADLOCK_DETECTION ) != 0 );
        VrfpDumpSettingToConsole( IDS_ENH_IO_VERIFICATION,      ( dwVerifyFlags & DRIVER_VERIFIER_ENHANCED_IO_CHECKING ) != 0 );
        VrfpDumpSettingToConsole( IDS_DMA_CHECHKING,            ( dwVerifyFlags & DRIVER_VERIFIER_DMA_VERIFIER ) != 0 );

        VrfPrintStringFromResources( IDS_VERIFIED_DRIVERS );
        
        if( bAllDriversVerified )
        {
            VrfPrintStringFromResources( IDS_ALL );
        }
        else
        {
            nDrivers = astrDriversToVerify.GetSize();

            if( nDrivers > 0 )
            {
                for( nCrtDriver = 0; nCrtDriver < nDrivers; nCrtDriver += 1 )
                {
                    strCrtDriver = astrDriversToVerify.GetAt( nCrtDriver );

                    _putts( (LPCTSTR) strCrtDriver );
                }
            }
            else
            {
                VrfPrintStringFromResources( IDS_NONE );
            }
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfIsNameAlreadyInList( LPCTSTR szDriver,
                             LPCTSTR szAllDrivers )
{
    INT nNameLength;
    INT nLastIndex;
    INT nIndex;
    BOOL bFoundIt;
    CString strDriver( szDriver );
    CString strAllDrivers( szAllDrivers );

    bFoundIt = FALSE;

    strDriver.MakeLower();
    strAllDrivers.MakeLower();

    nNameLength = strDriver.GetLength();

    nLastIndex = 0;
    
    do
    {
        nIndex = strAllDrivers.Find( (LPCTSTR)strDriver, nLastIndex );

        if( nIndex >= 0 )
        {
            //
            // Found the substring. Verify it is separated of spaces, etc.
            //

            if( (nIndex == 0 || _T( ' ' ) == strAllDrivers[ nIndex - 1 ]) &&
                ( (TCHAR)0 == strAllDrivers[ nNameLength + nIndex ] || _T( ' ' ) == strAllDrivers[ nNameLength + nIndex ]) )
            {
                //
                // This is our driver.
                //

                bFoundIt = TRUE;

                break;
            }
            else
            {
                //
                // Continue searching.
                //

                nLastIndex = nIndex + 1;
            }
        }
    }
    while( nIndex >= 0 );

    return bFoundIt;
}

/////////////////////////////////////////////////////////////////////////////
VOID VrfAddDriverNameNoDuplicates( LPCTSTR szDriver,
                                   CString &strAllDrivers )
{
    if( FALSE == VrfIsNameAlreadyInList( szDriver,
                                         strAllDrivers ) )
    {
        if( strAllDrivers.GetLength() > 0 )
        {
            strAllDrivers += _T( ' ' );
        }

        strAllDrivers += szDriver;
    }
}

/////////////////////////////////////////////////////////////////////////////
BOOL VrfIsStringInArray( LPCTSTR szText,
                         const CStringArray &astrAllTexts )
{
    INT_PTR nTexts;
    BOOL bFound;

    bFound = FALSE;

    nTexts = astrAllTexts.GetSize();

    while( nTexts > 0 )
    {
        nTexts -= 1;

        if( 0 == astrAllTexts.GetAt( nTexts ).CompareNoCase( szText ) )
        {
            bFound = TRUE;
            break;
        }
    }

    return bFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\win2k\drvcsht.cxx ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
// module: DrvCSht.cxx
// author: DMihai
// created: 01/04/98
//
// Description:
//
//      App's PropertySheet. 
//

#include "stdafx.h"
#include "drvvctrl.hxx"
#include "DrvCSht.hxx"

//
// help IDs
//

static DWORD MyHelpIds[] =
{
    IDCANCEL,                       IDH_DV_common_exit,
    0,                              0
};

/////////////////////////////////////////////////////////////////////////////
// CDrvChkSheet property sheet

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDrvChkSheet::CDrvChkSheet()
: CPropertySheet(IDS_APPTITLE)
{
    //{{AFX_DATA_INIT(CDrvChkSheet)
    //}}AFX_DATA_INIT

    AddPage( &m_CrtSettPage );
    AddPage( &m_CountPage );
    AddPage( &m_PoolCountersPage );
    AddPage( &m_ModifPage );
    AddPage( &m_VolatilePage );

    m_psh.dwFlags |= PSH_NOAPPLYNOW;

    m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

CDrvChkSheet::~CDrvChkSheet()
{
}

//////////////////////////////////////////////////////////////////////
void CDrvChkSheet::DoDataExchange(CDataExchange* pDX)
{
    CPropertySheet::DoDataExchange( pDX );

    //{{AFX_DATA_MAP(CDrvChkSheet)
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CDrvChkSheet, CPropertySheet)
    //{{AFX_MSG_MAP(CDrvChkSheet)
    ON_WM_SYSCOMMAND()
    ON_WM_PAINT()
    ON_WM_QUERYDRAGICON()
    ON_MESSAGE( WM_HELP, OnHelp )
    ON_MESSAGE( WM_CONTEXTMENU, OnContextMenu )
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//////////////////////////////////////////////////////////////////////
void CDrvChkSheet::ModifyButtons()
{
    BOOL bHaveHelpButton = FALSE;
    CWnd *pWnd;
    CString strQuit;
    CRect rectHelp;

    //
    // Hide the OK button
    //

    pWnd = GetDlgItem( IDOK );
    
    if( pWnd != NULL )
    {
        ASSERT_VALID( pWnd );

        pWnd->ShowWindow( SW_HIDE );
    }

    //
    // Hide the Help button
    //

    pWnd = GetDlgItem( IDHELP );

    if( pWnd != NULL )
    {
        ASSERT_VALID( pWnd );

        pWnd->GetWindowRect( rectHelp );
        ScreenToClient( rectHelp );
        bHaveHelpButton = TRUE;

        pWnd->ShowWindow( SW_HIDE );
    }

    //
    // Cancel button becomes Exit
    //

    pWnd = GetDlgItem( IDCANCEL );
    
    if( pWnd != NULL )
    {
        ASSERT_VALID( pWnd );

        VERIFY( strQuit.LoadString( IDS_QUIT ) );
        pWnd->SetWindowText( strQuit );

        if( bHaveHelpButton )
        {
            pWnd->MoveWindow( rectHelp );
        }
    }
}

//////////////////////////////////////////////////////////////////////
// message handlers
BOOL CDrvChkSheet::OnInitDialog() 
{
    BOOL bResult = CPropertySheet::OnInitDialog();

    //
    // Add the context sensitive button to the titlebar
    //

    LONG lStyle = ::GetWindowLong(m_hWnd, GWL_EXSTYLE);
    lStyle |= WS_EX_CONTEXTHELP;
    ::SetWindowLong(m_hWnd, GWL_EXSTYLE, lStyle);

    // Add "About..." menu item to system menu.

    // IDM_ABOUTBOX must be in the system command range.
    ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
    ASSERT(IDM_ABOUTBOX < 0xF000);

    CMenu* pSysMenu = GetSystemMenu(FALSE);
    if (pSysMenu != NULL)
    {
        CString strAboutMenu;
        strAboutMenu.LoadString(IDS_ABOUTBOX);
        if (!strAboutMenu.IsEmpty())
        {
            pSysMenu->AppendMenu(MF_SEPARATOR);
            pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
        }
    }

    // Set the icon for this dialog.  The framework does this automatically
    //  when the application's main window is not a dialog
    SetIcon(m_hIcon, TRUE);			// Set big icon
    SetIcon(m_hIcon, FALSE);		// Set small icon

    // TODO: Add extra initialization here
    ModifyButtons();

    return bResult;
}

//////////////////////////////////////////////////////////////////////
void CDrvChkSheet::OnSysCommand(UINT nID, LPARAM lParam)
{
    CString strWndTitle;
    if ((nID & 0xFFF0) == IDM_ABOUTBOX)
    {
        GetWindowText( strWndTitle );
        ShellAbout( m_hWnd, (LPCTSTR)strWndTitle, NULL, m_hIcon );
    }
    else
    {
        CPropertySheet::OnSysCommand(nID, lParam);
    }
}

//////////////////////////////////////////////////////////////////////
// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CDrvChkSheet::OnPaint() 
{
    if (IsIconic())
    {
        CPaintDC dc(this); // device context for painting

        SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

        // Center icon in client rectangle
        int cxIcon = GetSystemMetrics(SM_CXICON);
        int cyIcon = GetSystemMetrics(SM_CYICON);
        CRect rect;
        GetClientRect(&rect);
        int x = (rect.Width() - cxIcon + 1) / 2;
        int y = (rect.Height() - cyIcon + 1) / 2;

        // Draw the icon
        dc.DrawIcon(x, y, m_hIcon);
    }
    else
    {
        CPropertySheet::OnPaint();
    }
}

//////////////////////////////////////////////////////////////////////
// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CDrvChkSheet::OnQueryDragIcon()
{
    return (HCURSOR) m_hIcon;
}


//////////////////////////////////////////////////////////////////////
BOOL CDrvChkSheet::OnQueryCancel()
{
    if( GetActivePage() != &m_ModifPage )
    {
        return m_ModifPage.OnQueryCancel();
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////
LONG CDrvChkSheet::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        VERIFIER_HELP_FILE,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////
LONG CDrvChkSheet::OnContextMenu( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;

    ::WinHelp( 
        (HWND) wParam,
        VERIFIER_HELP_FILE,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\win2k\crtspage.cxx ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//

//
// module: CrtSPage.cxx
// author: DMihai
// created: 01/04/99
//
// Description:
//
//      Current settings PropertyPage. 

#include "stdafx.h"
#include "drvvctrl.hxx"
#include "CrtSPage.hxx"

#include "DrvCSht.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define MIN_MEM_SIZE_TO_DISABLE_WARNING 0x80000000  // 2 Gb
#define MIN_ALLOCATIONS_SIGNIFICANT     100
#define MIN_PERCENTAGE_AVOID_WARNING    95

//
// timer ID
//

#define REFRESH_TIMER_ID    0x1234

//
// manual, high, normal, low speed
//

#define REFRESH_SPEED_VARS  4

//
// timer intervals in millisec for manual, high, normal, low speed
//

static UINT uTimerIntervals[ REFRESH_SPEED_VARS ] =
{
    0,      // Manual
    1000,   // High Speed
    5000,   // Normal Speed
    10000   // Low Speed
};

//
// help IDs
//

static DWORD MyHelpIds[] =
{
    IDC_CRTSTAT_DRIVERS_LIST,       IDH_DV_VolatileTab_driver_details,
    IDC_CRTSTAT_IRQLCHCK_EDIT,      IDH_DV_StatusTab_flag_irql,
    IDC_CRTSTAT_FAULTINJ_EDIT,      IDH_DV_StatusTab_flag_resource,
    IDC_CRTSTAT_POOLT_EDIT,         IDH_DV_StatusTab_flag_tracking,
    IDC_CRTSTAT_IOVERIF_EDIT,       IDH_DV_StatusTab_flag_io,
    IDC_CRTSTAT_SPECPOOL_EDIT,      IDH_DV_StatusTab_flag_pool,
    IDC_CRTSTAT_REFRESH_BUTTON,     IDH_DV_common_refresh_nowbutton,
    IDC_CRTSTAT_MANUAL_RADIO,       IDH_DV_common_refresh_manual,
    IDC_CRTSTAT_HSPEED_RADIO,       IDH_DV_common_refresh_high,
    IDC_CRTSTAT_NORM_RADIO,         IDH_DV_common_refresh_normal,
    IDC_CRTSTAT_LOW_RADIO,          IDH_DV_common_refresh_low,
    0,                              0
};

/////////////////////////////////////////////////////////////
static void GetEnabledStringFromBool( BOOL bEnabled, CString &strValue )
{
    if( bEnabled )
        VERIFY( strValue.LoadString( IDS_ENABLED ) );
    else
        VERIFY( strValue.LoadString( IDS_DISABLED ) );
}

/////////////////////////////////////////////////////////////
// CCrtSettPage property page

IMPLEMENT_DYNCREATE(CCrtSettPage, CPropertyPage)

CCrtSettPage::CCrtSettPage() : CPropertyPage(CCrtSettPage::IDD)
{
    //{{AFX_DATA_INIT(CCrtSettPage)
    m_strSpecPool = _T("");
    m_strIrqLevelCheckEdit = _T("");
    m_strFaultInjEdit = _T("");
    m_strPoolTrackEdit = _T("");
    m_strIoVerifEdit = _T("");
    m_strWarnMsg = _T("");
    m_nUpdateIntervalIndex = 2;
    //}}AFX_DATA_INIT

    m_bAscendDrvNameSort = FALSE;
    m_bAscendDrvStatusSort = FALSE;

    m_uTimerHandler = 0;

    m_nSortColumnIndex = 0;
}

CCrtSettPage::~CCrtSettPage()
{
}

void CCrtSettPage::DoDataExchange(CDataExchange* pDX)
{
    if( ! pDX->m_bSaveAndValidate )
    {
        // query the kernel
        if( KrnGetSystemVerifierState( &m_KrnVerifState ) && 
            m_KrnVerifState.DriverCount > 0 )
        {
            // SpecialPool
            GetEnabledStringFromBool( m_KrnVerifState.SpecialPool, m_strSpecPool );

            // IrqlChecking
            GetEnabledStringFromBool( m_KrnVerifState.IrqlChecking, m_strIrqLevelCheckEdit );

            // FaultInjection
            GetEnabledStringFromBool( m_KrnVerifState.FaultInjection, m_strFaultInjEdit );

            // PoolTrack
            GetEnabledStringFromBool( m_KrnVerifState.PoolTrack, m_strPoolTrackEdit );

            // IoVerif
            GetEnabledStringFromBool( m_KrnVerifState.IoVerif, m_strIoVerifEdit );

            // warning message
            GetPoolCoverageWarnMessage();
        }
        else
        {
            // SpecialPool
            VERIFY( m_strSpecPool.LoadString( IDS_DISABLED ) );

            // IrqlChecking
            VERIFY( m_strIrqLevelCheckEdit.LoadString( IDS_DISABLED ) );

            // FaultInjection
            VERIFY( m_strFaultInjEdit.LoadString( IDS_DISABLED ) );

            // PoolTrack
            VERIFY( m_strPoolTrackEdit.LoadString( IDS_DISABLED ) );

            //IoVerif
            VERIFY( m_strIoVerifEdit.LoadString( IDS_DISABLED ) );

            // warning message
            m_strWarnMsg.Empty();
        }
    }

    CPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CCrtSettPage)
    DDX_Control(pDX, IDC_CRTSTAT_DRIVERS_LIST, m_DriversList);
    DDX_Text(pDX, IDC_CRTSTAT_SPECPOOL_EDIT, m_strSpecPool);
    DDX_Text(pDX, IDC_CRTSTAT_IRQLCHCK_EDIT, m_strIrqLevelCheckEdit);
    DDX_Text(pDX, IDC_CRTSTAT_FAULTINJ_EDIT, m_strFaultInjEdit);
    DDX_Text(pDX,IDC_CRTSTAT_POOLT_EDIT, m_strPoolTrackEdit);
    DDX_Text(pDX,IDC_CRTSTAT_IOVERIF_EDIT, m_strIoVerifEdit);
    DDX_Text(pDX,IDC_CRTSTAT_WARN_MSG, m_strWarnMsg);
    DDX_Radio(pDX, IDC_CRTSTAT_MANUAL_RADIO, m_nUpdateIntervalIndex);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCrtSettPage, CPropertyPage)
    //{{AFX_MSG_MAP(CCrtSettPage)
    ON_BN_CLICKED(IDC_CRTSTAT_REFRESH_BUTTON, OnCrtstatRefreshButton)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_CRTSTAT_DRIVERS_LIST, OnColumnclickCrtstatDriversList)
    ON_WM_TIMER()
    ON_BN_CLICKED(IDC_CRTSTAT_HSPEED_RADIO, OnCrtstatHspeedRadio)
    ON_BN_CLICKED(IDC_CRTSTAT_LOW_RADIO, OnCrtstatLowRadio)
    ON_BN_CLICKED(IDC_CRTSTAT_MANUAL_RADIO, OnCrtstatManualRadio)
    ON_BN_CLICKED(IDC_CRTSTAT_NORM_RADIO, OnCrtstatNormRadio)
    ON_MESSAGE( WM_HELP, OnHelp )
    ON_MESSAGE( WM_CONTEXTMENU, OnContextMenu )
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////
void CCrtSettPage::SetupListHeader()
{
    CString strDrivers, strStatus;
    VERIFY( strDrivers.LoadString( IDS_DRIVERS ) );
    VERIFY( strStatus.LoadString( IDS_STATUS ) );

    // list's regtangle
    CRect rectWnd;
    m_DriversList.GetClientRect( &rectWnd );
    
    LVCOLUMN lvColumn;

    // column 0
    memset( &lvColumn, 0, sizeof( lvColumn ) );
    lvColumn.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;
    
    lvColumn.iSubItem = 0;
    lvColumn.pszText = strDrivers.GetBuffer( strDrivers.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.47 );
    VERIFY( m_DriversList.InsertColumn( 0, &lvColumn ) != -1 );
    strDrivers.ReleaseBuffer();

    // column 1
    lvColumn.iSubItem = 1;
    lvColumn.pszText = strStatus.GetBuffer( strStatus.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.47 );
    VERIFY( m_DriversList.InsertColumn( 1, &lvColumn ) != -1 );
    strStatus.ReleaseBuffer();
}

/////////////////////////////////////////////////////////////
void CCrtSettPage::FillTheList()
{
    LVITEM lvItem;
    int nActualIndex; 
    BOOL *pbAlreadyInList;
    ULONG uCrtVerifiedDriver;
    int nItemCount;
    int nCrtListItem;
    TCHAR strDriverName[ _MAX_PATH ];
    BOOL bResult;

    if( m_KrnVerifState.DriverCount == 0 )
    {
        //
        // clear the list
        //

        VERIFY( m_DriversList.DeleteAllItems() );
    }
    else
    {
        //
        // there are some drivers currently verified
        //

        pbAlreadyInList = new BOOL[ m_KrnVerifState.DriverCount ];
        if( pbAlreadyInList == NULL )
        {
            return;
        }
        
        for( uCrtVerifiedDriver = 0; uCrtVerifiedDriver < m_KrnVerifState.DriverCount; uCrtVerifiedDriver++)
        {
            pbAlreadyInList[ uCrtVerifiedDriver ] = FALSE;
        }

        //
        // parse all the current list items
        //

        nItemCount = m_DriversList.GetItemCount();

        for( nCrtListItem = 0; nCrtListItem < nItemCount; nCrtListItem++ )
        {
            //
            // get the current driver's name from the list
            //

            ZeroMemory( &lvItem, sizeof( lvItem ) );

            lvItem.mask = LVIF_TEXT;
            lvItem.iItem = nCrtListItem;
            lvItem.iSubItem = 0;
            lvItem.pszText = strDriverName;
            lvItem.cchTextMax = sizeof( strDriverName ) / sizeof( strDriverName[0] );

            bResult = m_DriversList.GetItem( &lvItem );
            if( bResult == FALSE )
            {
                //
                // could not get the current item's attributes?
                //

                ASSERT( FALSE );

                //
                // remove this item from the list
                //

                VERIFY( m_DriversList.DeleteItem( nCrtListItem ) );

                nCrtListItem--;
                nItemCount--;
            }
            else
            {
                //
                // see is the current driver is still in m_KrnVerifState
                //

                for( uCrtVerifiedDriver = 0; uCrtVerifiedDriver < m_KrnVerifState.DriverCount; uCrtVerifiedDriver++)
                {
                    if( _tcsicmp( strDriverName, 
                        m_KrnVerifState.DriverInfo[ uCrtVerifiedDriver ].Name ) == 0 )
                    {
                        //
                        // update the item's data with the current index in the array
                        //

                        lvItem.mask = LVIF_PARAM;
                        lvItem.lParam = uCrtVerifiedDriver;
                        
                        VERIFY( m_DriversList.SetItem( &lvItem ) != -1 );

                        //
                        // update the second column
                        //

                        UpdateStatusColumn( nCrtListItem, uCrtVerifiedDriver ); 

                        //
                        // mark the current driver as updated
                        //

                        pbAlreadyInList[ uCrtVerifiedDriver ] = TRUE;

                        break;
                    }
                }

                //
                // If the driver is no longer verified, remove it from the list
                //

                if( uCrtVerifiedDriver >= m_KrnVerifState.DriverCount )
                {
                    VERIFY( m_DriversList.DeleteItem( nCrtListItem ) );

                    nCrtListItem--;
                    nItemCount--;
                }
            }
        }

        //
        // add the drivers that were not in the list before this update
        //

        for( uCrtVerifiedDriver = 0; uCrtVerifiedDriver < m_KrnVerifState.DriverCount; uCrtVerifiedDriver++)
        {
            if( ! pbAlreadyInList[ uCrtVerifiedDriver ] )
            {
                // 
                // add a new item for this
                //

                ZeroMemory( &lvItem, sizeof( lvItem ) );

                //
                // sub-item 0
                //

                lvItem.mask = LVIF_TEXT | LVIF_PARAM;
                lvItem.lParam = uCrtVerifiedDriver;
                lvItem.iItem = m_DriversList.GetItemCount();
                lvItem.iSubItem = 0;
                lvItem.pszText = m_KrnVerifState.DriverInfo[ uCrtVerifiedDriver ].Name;
                nActualIndex = m_DriversList.InsertItem( &lvItem );
                VERIFY( nActualIndex != -1 );

                //
                // sub-item 1
                //

                UpdateStatusColumn( nActualIndex, uCrtVerifiedDriver ); 
            }
        }

        delete pbAlreadyInList;
    }
}

/////////////////////////////////////////////////////////////
void CCrtSettPage::UpdateStatusColumn( int nItemIndex, ULONG uCrtDriver )
{
    LVITEM lvItem;
    CString strStatus;

    ASSERT( nItemIndex >= 0 && 
            (UINT)nItemIndex < m_KrnVerifState.DriverCount &&
            nItemIndex < m_DriversList.GetItemCount() &&
            uCrtDriver >= 0 &&
            uCrtDriver < m_KrnVerifState.DriverCount &&
            uCrtDriver < (ULONG)m_DriversList.GetItemCount() );

    // determine what's the appropriate value for the second column
    if( ! m_KrnVerifState.DriverInfo[ uCrtDriver ].Loads )
    {
        VERIFY( strStatus.LoadString( IDS_NEVER_LOADED ) );
    }
    else
    {
        if( m_KrnVerifState.DriverInfo[ uCrtDriver ].Loads == 
            m_KrnVerifState.DriverInfo[ uCrtDriver ].Unloads )
        {
            VERIFY( strStatus.LoadString( IDS_UNLOADED ) );
        }
        else
        {
            if( m_KrnVerifState.DriverInfo[ uCrtDriver ].Loads > 
                m_KrnVerifState.DriverInfo[ uCrtDriver ].Unloads )
            {
                VERIFY( strStatus.LoadString( IDS_LOADED ) );
            }
            else
            {
                ASSERT( FALSE );
                VERIFY( strStatus.LoadString( IDS_UNKNOWN ) );
            }
        }
    }

    // update the list item
    memset( &lvItem, 0, sizeof( lvItem ) );
    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nItemIndex;
    lvItem.iSubItem = 1;
    lvItem.pszText = strStatus.GetBuffer( strStatus.GetLength() + 1 );
    VERIFY( m_DriversList.SetItem( &lvItem ) != -1 );
    strStatus.ReleaseBuffer();
}

/////////////////////////////////////////////////////////////
int CALLBACK CCrtSettPage::DrvStatusCmpFunc(
    LPARAM lParam1, 
    LPARAM lParam2, 
    LPARAM lParamSort)
{
    UINT uIndex1 = (UINT)lParam1;
    UINT uIndex2 = (UINT)lParam2;
    CCrtSettPage *pThis = (CCrtSettPage *)lParamSort;
    ASSERT_VALID( pThis );

    int nCmpRez = 0;

    // sanity check
    if( uIndex1 > pThis->m_KrnVerifState.DriverCount || 
        uIndex2 > pThis->m_KrnVerifState.DriverCount )
    {
        ASSERT( FALSE );
        return 0;
    }

    // difference between loads and unloads #
    LONG lLoadDiff1 = (LONG)pThis->m_KrnVerifState.DriverInfo[ uIndex1 ].Loads -
                      (LONG)pThis->m_KrnVerifState.DriverInfo[ uIndex1 ].Unloads;
    LONG lLoadDiff2 = (LONG)pThis->m_KrnVerifState.DriverInfo[ uIndex2 ].Loads - 
                      (LONG)pThis->m_KrnVerifState.DriverInfo[ uIndex2 ].Unloads;

    if( lLoadDiff1 == lLoadDiff2 )
    {
        nCmpRez = 0;
    }
    else
    {
        if( lLoadDiff1 > lLoadDiff2 )
            nCmpRez = 1;
        else
            nCmpRez = -1;
    }

    if( pThis->m_bAscendDrvStatusSort )
        nCmpRez *= -1;

    return nCmpRez;
}

/////////////////////////////////////////////////////////////
int CALLBACK CCrtSettPage::DrvNameCmpFunc(
    LPARAM lParam1, 
    LPARAM lParam2, 
    LPARAM lParamSort)
{
    UINT uIndex1 = (UINT)lParam1;
    UINT uIndex2 = (UINT)lParam2;
    CCrtSettPage *pThis = (CCrtSettPage *)lParamSort;
    ASSERT_VALID( pThis );

    int nCmpRez = 0;

    // sanity check
    if( uIndex1 > pThis->m_KrnVerifState.DriverCount || 
        uIndex2 > pThis->m_KrnVerifState.DriverCount )
    {
        ASSERT( FALSE );
        return 0;
    }

    nCmpRez = _tcsicmp( pThis->m_KrnVerifState.DriverInfo[ uIndex1 ].Name, 
                        pThis->m_KrnVerifState.DriverInfo[ uIndex2 ].Name );
    if( ! nCmpRez )
    {
        // same name ???
        nCmpRez = 0;
    }
    else
    {
        if( pThis->m_bAscendDrvNameSort )
            nCmpRez *= -1;
    }

    return nCmpRez;
}

/////////////////////////////////////////////////////////////
void CCrtSettPage::OnRefreshTimerChanged()
{
    UINT uTimerElapse = 0;

    // kill the pending timer
    if( m_uTimerHandler != 0 )
    {
        VERIFY( KillTimer( REFRESH_TIMER_ID ) );
    }

    // sanity check
    if( m_nUpdateIntervalIndex < 0 || 
        m_nUpdateIntervalIndex >= REFRESH_SPEED_VARS )
    {
        m_nUpdateIntervalIndex = 0;
        CheckRadioButton( IDC_CRTSTAT_MANUAL_RADIO, IDC_CRTSTAT_LOW_RADIO, 
            IDC_CRTSTAT_MANUAL_RADIO );
    }

    // new timer interval
    uTimerElapse = uTimerIntervals[ m_nUpdateIntervalIndex ];
    if( uTimerElapse > 0 )
    {
        VERIFY( m_uTimerHandler = SetTimer( REFRESH_TIMER_ID, 
            uTimerElapse, NULL ) );
    }
}

/////////////////////////////////////////////////////////////
void CCrtSettPage::SortTheList()
{
    if( m_nSortColumnIndex )
    {
        m_DriversList.SortItems( DrvStatusCmpFunc, (LPARAM)this );
    }
    else
    {
        m_DriversList.SortItems( DrvNameCmpFunc, (LPARAM)this );
    }
}

/////////////////////////////////////////////////////////////
void CCrtSettPage::GetPoolCoverageWarnMessage()
{
    ULONGLONG ullPercentageCoverage;
    CString strMsgFormat;

    if( m_KrnVerifState.SpecialPool &&
        m_KrnVerifState.AllocationsSucceeded > MIN_ALLOCATIONS_SIGNIFICANT  )
    {
        // 
        // special pool verification is enabled
        // there is a significant number of allocations
        //

        ASSERT( m_KrnVerifState.AllocationsSucceeded >= m_KrnVerifState.AllocationsSucceededSpecialPool );

        //
        // the coverage percentage
        //

        ullPercentageCoverage = 
            ( (ULONGLONG)m_KrnVerifState.AllocationsSucceededSpecialPool * (ULONGLONG) 100 ) / 
            (ULONGLONG)m_KrnVerifState.AllocationsSucceeded;

        ASSERT( ullPercentageCoverage <= 100 );

        if( ullPercentageCoverage < MIN_PERCENTAGE_AVOID_WARNING )
        {
            //
            // warn the user
            //

            if( strMsgFormat.LoadString( IDS_COVERAGE_WARNING_FORMAT ) )
            {
                TCHAR *strMessage = m_strWarnMsg.GetBuffer( strMsgFormat.GetLength() + 32 );

                if( strMessage != NULL )
                {
                    _stprintf( strMessage, (LPCTSTR)strMsgFormat, ullPercentageCoverage );
                    m_strWarnMsg.ReleaseBuffer();
                    return;
                }
            }
            else
            {
                ASSERT( FALSE );
            }
        }
    }

    //
    // no warning message
    //

    m_strWarnMsg.Empty();
}

/////////////////////////////////////////////////////////////
// CCrtSettPage message handlers

BOOL CCrtSettPage::OnInitDialog() 
{
    CPropertyPage::OnInitDialog();

    SetupListHeader();
    FillTheList();
    SortTheList();

    OnRefreshTimerChanged();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////
void CCrtSettPage::OnCrtstatRefreshButton() 
{
    if( UpdateData( FALSE ) )
    {
        FillTheList();
        SortTheList();
    }
}

/////////////////////////////////////////////////////////////
void CCrtSettPage::OnColumnclickCrtstatDriversList(NMHDR* pNMHDR, 
                                                   LRESULT* pResult) 
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    if( pNMListView->iSubItem )
    {
        if( m_nSortColumnIndex == pNMListView->iSubItem )
        {
            // change the current ascend/descend order for this column
            m_bAscendDrvStatusSort = !m_bAscendDrvStatusSort;
        }
    }
    else
    {
        if( m_nSortColumnIndex == pNMListView->iSubItem )
        {
            // change the current ascend/descend order for this column
            m_bAscendDrvNameSort = !m_bAscendDrvNameSort;
        }
    }

    m_nSortColumnIndex = pNMListView->iSubItem;

    SortTheList();

    *pResult = 0;
}

/////////////////////////////////////////////////////////////
void CCrtSettPage::OnTimer(UINT nIDEvent) 
{
    if( nIDEvent == REFRESH_TIMER_ID )
    {
        CDrvChkSheet *pParentSheet = (CDrvChkSheet *)GetParent();
        if( pParentSheet != NULL )
        {
            ASSERT_VALID( pParentSheet );
            if( pParentSheet->GetActivePage() == this )
            {
                // refresh the displayed data 
                OnCrtstatRefreshButton();
            }
        }
    }

    CPropertyPage::OnTimer(nIDEvent);
}

/////////////////////////////////////////////////////////////
BOOL CCrtSettPage::OnQueryCancel() 
{
    // give parent PropertySheet a chance to refuse the Cancel if needed

    CDrvChkSheet *pParentSheet = (CDrvChkSheet *)GetParent();
    if( pParentSheet != NULL )
    {
        ASSERT_VALID( pParentSheet );
        if( ! pParentSheet->OnQueryCancel() )
        {
            return FALSE;
        }
    }

    return CPropertyPage::OnQueryCancel();
}

/////////////////////////////////////////////////////////////
BOOL CCrtSettPage::OnApply() 
{
    // refuse to apply 
    // (we don't use the standard PropertSheet buttons; Apply, OK)
    return FALSE;
}

/////////////////////////////////////////////////////////////
void CCrtSettPage::OnCrtstatManualRadio() 
{
    // switch to manual refresh
    m_nUpdateIntervalIndex = 0;
    OnRefreshTimerChanged();
}

void CCrtSettPage::OnCrtstatHspeedRadio() 
{
    // switch to high speed refresh
    m_nUpdateIntervalIndex = 1;
    OnRefreshTimerChanged();
}

void CCrtSettPage::OnCrtstatNormRadio() 
{
    // switch to normal speed refresh
    m_nUpdateIntervalIndex = 2;
    OnRefreshTimerChanged();
}

void CCrtSettPage::OnCrtstatLowRadio() 
{
    // switch to low speed refresh
    m_nUpdateIntervalIndex = 3;
    OnRefreshTimerChanged();
}

/////////////////////////////////////////////////////////////
LONG CCrtSettPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        VERIFIER_HELP_FILE,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////
LONG CCrtSettPage::OnContextMenu( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;

    ::WinHelp( 
        (HWND) wParam,
        VERIFIER_HELP_FILE,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\win2k\modspage.cxx ===
//
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//
//
// module: ModSPage.cxx
// author: DMihai
// created: 01/04/98
//
// Description:
//
//      Modify settings PropertyPage.

#include "stdafx.h"
#include "drvvctrl.hxx"
#include "ModSPage.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// if this is FALSE we will prompt the user when Exit is clicked
//

BOOL g_bSettingsSaved = FALSE;

//
// help IDs
//

static DWORD MyHelpIds[] =
{
    IDC_DRIVERS_LIST,               IDH_DV_SettingsTab_driver_details,
    IDC_VERIFALL_RADIO,             IDH_DV_SettingsTab_verifyall,
    IDC_VERIFSEL_RADIO,             IDH_DV_SettingsTab_verifyselec,
    IDC_NORMAL_VERIF_CHECK,         IDH_DV_SettingsTab_verifytype_sppool,
    IDC_PAGEDC_VERIF_CHECK,         IDH_DV_SettingsTab_verifytype_irql,
    IDC_ALLOCF_VERIF_CHECK,         IDH_DV_SettingsTab_verifytype_resource,
    IDC_POOLT_VERIF_CHECK,          IDH_DV_SettingsTab_verifytype_pooltrack,
    IDC_IO_VERIF_CHECK,             IDH_DV_SettingsTab_verifytype_io,
    IDC_VERIFY_BUTTON,              IDH_DV_SettingsTab_verifybut,
    IDC_DONTVERIFY_BUTTON,          IDH_DV_SettingsTab_noverifybut,
    ID_APPLY_BUTTON,                IDH_DV_SettingsTab_applybut,
    IDC_ADDIT_DRVNAMES_EDIT,        IDH_DV_SettingsTab_verifyaddfield,
    ID_RESETALL_BUTTON,             IDH_DV_SettingsTab_resetallbut,
    ID_PREF_BUTTON,                 IDH_DV_SettingsTab_prefsetbut,
    IDC_MODSETT_IO_SELDRIVERS_RADIO,IDH_DV_SettingsTab_verifytype_io_level1,
    IDC_MODSETT_IO_SYSWIDE_RADIO,   IDH_DV_SettingsTab_verifytype_io_level2,
    0,                              0
};

/////////////////////////////////////////
void __cdecl VrfError ( TCHAR *fmt, ...)
{
    TCHAR strMessage[ 256 ];
    va_list prms;

    if( fmt == NULL )
        return;

    va_start (prms, fmt);

    _vsntprintf ( strMessage, ARRAY_LENGTH( strMessage ), fmt, prms);

    if( g_bCommandLineMode )
    {
        VrfPutTS( strMessage );
    }
    else
    {
        AfxMessageBox( strMessage, MB_OK | MB_ICONSTOP );
    }

    va_end (prms);
}

/////////////////////////////////////////
void
__cdecl
VrfErrorResourceFormat(
    UINT uIdResourceFormat,
    ... )
{
    TCHAR strMessage[ 256 ];
    TCHAR strFormat[ 256 ];
    va_list prms;

    if( GetStringFromResources(
        uIdResourceFormat,
        strFormat,
        ARRAY_LENGTH( strFormat ) ) )
    {
        va_start (prms, uIdResourceFormat);

        _vsntprintf ( strMessage, ARRAY_LENGTH( strMessage ), strFormat, prms);

        if( g_bCommandLineMode )
        {
            VrfPutTS( strMessage );
        }
        else
        {
            AfxMessageBox( strMessage, MB_OK | MB_ICONSTOP );
        }

        va_end (prms);
    }
    else
    {
        ASSERT( FALSE );
    }
}


/////////////////////////////////////////////////////////////////////////////
// CModifSettPage property page

IMPLEMENT_DYNCREATE(CModifSettPage, CPropertyPage)

CModifSettPage::CModifSettPage() : CPropertyPage(CModifSettPage::IDD)
{
    //{{AFX_DATA_INIT(CModifSettPage)
    m_bAllocFCheck = FALSE;
    m_bSpecialPoolCheck = FALSE;
    m_bPagedCCheck = FALSE;
    m_bPoolTCheck = FALSE;
    m_bIoVerifierCheck = FALSE;
    m_nVerifyAllRadio = -1;
    m_strAdditDrivers = _T("");
    //}}AFX_DATA_INIT

    m_nIoVerTypeRadio = 0;

    m_eListState = vrfControlEnabled;
    m_eApplyButtonState = vrfControlDisabled;

    m_bAscendDrvVerifSort = FALSE;
    m_bAscendDrvNameSort = FALSE;
    m_bAscendProviderSort = FALSE;
    m_bAscendVersionSort = FALSE;

    m_nLastColumnClicked = -1;
}

CModifSettPage::~CModifSettPage()
{
}

void CModifSettPage::DoDataExchange(CDataExchange* pDX)
{
//    CPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CModifSettPage)
    DDX_Control(pDX, IDC_PAGEDC_VERIF_CHECK, m_PagedCCheck);
    DDX_Control(pDX, IDC_NORMAL_VERIF_CHECK, m_SpecialPoolVerifCheck);
    DDX_Control(pDX, IDC_ALLOCF_VERIF_CHECK, m_AllocFCheck);
    DDX_Control(pDX, IDC_POOLT_VERIF_CHECK, m_PoolTCheck);
    DDX_Control(pDX, IDC_IO_VERIF_CHECK, m_IOVerifCheck);
    DDX_Control(pDX, IDC_ADDIT_DRVNAMES_EDIT, m_AdditDrvEdit);
    DDX_Control(pDX, ID_RESETALL_BUTTON, m_ResetAllButton);
    DDX_Control(pDX, IDC_VERIFY_BUTTON, m_VerifyButton);
    DDX_Control(pDX, IDC_DRIVERS_LIST, m_DriversList);
    DDX_Control(pDX, IDC_DONTVERIFY_BUTTON, m_DontVerifButton);
    DDX_Control(pDX, ID_APPLY_BUTTON, m_ApplyButton);
    DDX_Check(pDX, IDC_ALLOCF_VERIF_CHECK, m_bAllocFCheck);
    DDX_Check(pDX, IDC_NORMAL_VERIF_CHECK, m_bSpecialPoolCheck);
    DDX_Check(pDX, IDC_PAGEDC_VERIF_CHECK, m_bPagedCCheck);
    DDX_Check(pDX, IDC_POOLT_VERIF_CHECK, m_bPoolTCheck);
    DDX_Check(pDX, IDC_IO_VERIF_CHECK, m_bIoVerifierCheck);
    DDX_Radio(pDX, IDC_VERIFALL_RADIO, m_nVerifyAllRadio);
    DDX_Radio(pDX, IDC_MODSETT_IO_SELDRIVERS_RADIO, m_nIoVerTypeRadio);
    //}}AFX_DATA_MAP

    DDX_Text(pDX, IDC_ADDIT_DRVNAMES_EDIT, m_strAdditDrivers);
    DDV_MaxChars(pDX, m_strAdditDrivers, MI_SUSPECT_DRIVER_BUFFER_LENGTH - 1 );

    if( pDX->m_bSaveAndValidate )
    {
        m_VerifState.AllDriversVerified = ( m_nVerifyAllRadio == 0 );

        m_VerifState.SpecialPoolVerification = m_bSpecialPoolCheck;
        m_VerifState.PagedCodeVerification = m_bPagedCCheck;
        m_VerifState.AllocationFaultInjection = m_bAllocFCheck;
        m_VerifState.PoolTracking = m_bPoolTCheck;
        m_VerifState.IoVerifier = m_bIoVerifierCheck;
        m_VerifState.SysIoVerifierLevel = m_nIoVerTypeRadio + 1;

        _tcscpy( m_VerifState.AdditionalDriverNames,
            (LPCTSTR)m_strAdditDrivers );
    }
}


BEGIN_MESSAGE_MAP(CModifSettPage, CPropertyPage)
    //{{AFX_MSG_MAP(CModifSettPage)
    ON_BN_CLICKED(IDC_VERIFALL_RADIO, OnVerifallRadio)
    ON_BN_CLICKED(IDC_VERIFSEL_RADIO, OnVerifselRadio)
    ON_BN_CLICKED(IDC_ALLOCF_VERIF_CHECK, OnCheck )
    ON_BN_CLICKED(IDC_VERIFY_BUTTON, OnVerifyButton)
    ON_BN_CLICKED(IDC_DONTVERIFY_BUTTON, OnDontverifyButton)
    ON_BN_CLICKED(ID_APPLY_BUTTON, OnApplyButton)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_DRIVERS_LIST, OnColumnclickDriversList)
    ON_EN_CHANGE(IDC_ADDIT_DRVNAMES_EDIT, OnChangeAdditDrvnamesEdit)
    ON_BN_CLICKED(ID_RESETALL_BUTTON, OnResetallButton)
    ON_BN_CLICKED(ID_PREF_BUTTON, OnPrefButton)
    ON_BN_CLICKED(IDC_NORMAL_VERIF_CHECK, OnCheck )
    ON_BN_CLICKED(IDC_PAGEDC_VERIF_CHECK, OnCheck )
    ON_BN_CLICKED(IDC_POOLT_VERIF_CHECK, OnCheck )
    ON_BN_CLICKED(IDC_IO_VERIF_CHECK, OnIoCheck )
    ON_NOTIFY(NM_RCLICK, IDC_DRIVERS_LIST, OnRclickDriversList)
    ON_COMMAND(ID_MODIF_DO_VERIFY, OnDoVerify)
    ON_COMMAND(ID_MODIF_DONT_VERIFY, OnDontVerify)
    ON_BN_CLICKED(IDC_MODSETT_IO_SELDRIVERS_RADIO, OnCheck)
    ON_BN_CLICKED(IDC_MODSETT_IO_SYSWIDE_RADIO, OnCheck)
    ON_MESSAGE( WM_HELP, OnHelp )
    ON_MESSAGE( WM_CONTEXTMENU, OnContextMenu )
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CModifSettPage implementation

void CModifSettPage::GetDlgDataFromSett()
{
    m_strAdditDrivers = m_VerifState.AdditionalDriverNames;

    // all drivers verified ?
    if( m_VerifState.AllDriversVerified )
    {
        m_nVerifyAllRadio = 0;

        // list state
        m_eListState = vrfControlDisabled;
    }
    else
    {
        m_nVerifyAllRadio = 1;

        // list state
        m_eListState = vrfControlEnabled;
    }

    // SpecialPoolVerification
    m_bSpecialPoolCheck = m_VerifState.SpecialPoolVerification;

    // PagedCodeVerification
    m_bPagedCCheck = m_VerifState.PagedCodeVerification;

    // AllocationFaultInjection
    m_bAllocFCheck = m_VerifState.AllocationFaultInjection;

    // PoolTracking
    m_bPoolTCheck = m_VerifState.PoolTracking;

    // IoVerifier
    m_bIoVerifierCheck = m_VerifState.IoVerifier;

    if( m_bIoVerifierCheck )
    {
        m_eIoRadioState = vrfControlEnabled;
    }
    else
    {
        m_eIoRadioState = vrfControlDisabled;
    }

    // SysIoVerifierLevel
    if( m_VerifState.SysIoVerifierLevel )
    {
        ASSERT( m_bIoVerifierCheck );

        m_nIoVerTypeRadio = m_VerifState.SysIoVerifierLevel - 1;
    }
    else
    {
        m_nIoVerTypeRadio = 0;
    }

    // Apply button state
    m_eApplyButtonState = vrfControlDisabled;
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::UpdateControlsState()
{
    CWnd *pRadioButton;

    EnableControl( m_DriversList, m_eListState );
    EnableControl( m_VerifyButton, m_eListState );
    EnableControl( m_DontVerifButton, m_eListState );
    EnableControl( m_AdditDrvEdit, m_eListState );

    EnableControl( m_ApplyButton, m_eApplyButtonState );

    pRadioButton = GetDlgItem( IDC_MODSETT_IO_SELDRIVERS_RADIO );
    if( pRadioButton != NULL )
    {
        EnableControl( *pRadioButton, m_eIoRadioState );
    }
    else
    {
        ASSERT( FALSE );
    }

    pRadioButton = GetDlgItem( IDC_MODSETT_IO_SYSWIDE_RADIO );
    if( pRadioButton != NULL )
    {
        EnableControl( *pRadioButton, m_eIoRadioState );
    }
    else
    {
        ASSERT( FALSE );
    }
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::EnableControl( CWnd &wndCtrl,
                                   VRF_CONTROL_STATE eNewState )
{
    BOOL bEnabled = wndCtrl.IsWindowEnabled();
    if( bEnabled )
    {
        if( eNewState == vrfControlDisabled )
            wndCtrl.EnableWindow( FALSE );
    }
    else
    {
        if( eNewState == vrfControlEnabled )
            wndCtrl.EnableWindow( TRUE );
    }
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::SetupTheList()
{
    SetupListHeader();
    AddTheListItems();
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::SetupListHeader()
{
    CString strDrivers, strStatus, strProvider, strVersion;

    VERIFY( strDrivers.LoadString( IDS_DRIVERS ) );
    VERIFY( strStatus.LoadString( IDS_VERIFICATION_STATUS ) );
    VERIFY( strProvider.LoadString( IDS_PROVIDER ) );
    VERIFY( strVersion.LoadString( IDS_VERSION ) );

    CRect rectWnd;
    m_DriversList.GetClientRect( &rectWnd );

    LVCOLUMN lvColumn;

    // column 0
    memset( &lvColumn, 0, sizeof( lvColumn ) );
    lvColumn.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;

    lvColumn.iSubItem = 0;
    lvColumn.pszText = strDrivers.GetBuffer( strDrivers.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.17 );
    VERIFY( m_DriversList.InsertColumn( 0, &lvColumn ) != -1 );
    strDrivers.ReleaseBuffer();

    // column 1
    lvColumn.iSubItem = 1;
    lvColumn.pszText = strStatus.GetBuffer( strStatus.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.34 );
    VERIFY( m_DriversList.InsertColumn( 1, &lvColumn ) != -1 );
    strStatus.ReleaseBuffer();

    // column 2
    lvColumn.iSubItem = 2;
    lvColumn.pszText = strProvider.GetBuffer( strProvider.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.27 );
    VERIFY( m_DriversList.InsertColumn( 2, &lvColumn ) != -1 );
    strProvider.ReleaseBuffer();

    // column 3
    lvColumn.iSubItem = 3;
    lvColumn.pszText = strVersion.GetBuffer( strVersion.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.19 );
    VERIFY( m_DriversList.InsertColumn( 3, &lvColumn ) != -1 );
    strVersion.ReleaseBuffer();
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::AddTheListItems()
{
    LVITEM lvItem;
    int nActualIndex;

    VERIFY( m_DriversList.DeleteAllItems() );

    ASSERT( m_VerifState.DriverCount == 0 ||
            ::AfxIsValidAddress(
                m_VerifState.DriverInfo,
                m_VerifState.DriverCount * sizeof( PVRF_DRIVER_STATE ),
                TRUE)
          );

    memset( &lvItem, 0, sizeof( lvItem ) );

    for(UINT uCrtItem = 0; uCrtItem < m_VerifState.DriverCount; uCrtItem++ )
    {
        //
        // sub-item 0
        //

        lvItem.mask = LVIF_TEXT | LVIF_PARAM;
        lvItem.lParam = uCrtItem;
        lvItem.iItem = m_DriversList.GetItemCount();
        lvItem.iSubItem = 0;
        lvItem.pszText = m_VerifState.DriverInfo[ uCrtItem ].Name;
        nActualIndex = m_DriversList.InsertItem( &lvItem );

        if( nActualIndex != -1 )
        {
            //
            // sub-item 1
            //

            UpdateSecondColumn( nActualIndex,
                m_VerifState.DriverInfo[ uCrtItem ].Verified,
                m_VerifState.DriverInfo[ uCrtItem ].CurrentlyVerified );

            //
            // sub-item 2
            //

            lvItem.mask = LVIF_TEXT;
            lvItem.iItem = nActualIndex;
            lvItem.iSubItem = 2;
            lvItem.pszText = m_VerifState.DriverInfo[ uCrtItem ].Provider;
            VERIFY( m_DriversList.SetItem( &lvItem ) != -1 );

            //
            // sub-item 3
            //

            lvItem.mask = LVIF_TEXT;
            lvItem.iItem = nActualIndex;
            lvItem.iSubItem = 3;
            lvItem.pszText = m_VerifState.DriverInfo[ uCrtItem ].Version;
            VERIFY( m_DriversList.SetItem( &lvItem ) != -1 );
        }
        else
        {
            //
            // cannot add a list item?!?
            //

            ASSERT( FALSE );
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::UpdateSecondColumn( int nItemIndex,
    BOOL bVerifiedAfterBoot, BOOL bVerifiedNow )
{
    LVITEM lvItem;
    CString strValue;

    ASSERT( nItemIndex >= 0 &&
            (UINT)nItemIndex < m_VerifState.DriverCount &&
            nItemIndex < m_DriversList.GetItemCount() );

    // determine what's the status
    if( bVerifiedAfterBoot )
    {
        if( bVerifiedNow )
        {
            VERIFY( strValue.LoadString( IDS_VERIFIED ) );
        }
        else
        {
            VERIFY( strValue.LoadString( IDS_VERIFIED_AFTER_BOOT ) );
        }
    }
    else
    {
        if( bVerifiedNow )
        {
            VERIFY( strValue.LoadString( IDS_NOT_VERIFIED_AFTER_BOOT ) );
        }
        else
        {
            VERIFY( strValue.LoadString( IDS_NOT_VERIFIED ) );
        }
    }

    // update the list item
    memset( &lvItem, 0, sizeof( lvItem ) );
    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nItemIndex;
    lvItem.iSubItem = 1;
    lvItem.pszText = strValue.GetBuffer( strValue.GetLength() + 1 );
    VERIFY( m_DriversList.SetItem( &lvItem ) != -1 );
    strValue.ReleaseBuffer();
}

/////////////////////////////////////////////////////////////////////////////
int CALLBACK CModifSettPage::DrvVerifCmpFunc(
    LPARAM lParam1,
    LPARAM lParam2,
    LPARAM lParamSort)
{
    UINT uIndex1 = (UINT)lParam1;
    UINT uIndex2 = (UINT)lParam2;
    CModifSettPage *pThis = (CModifSettPage *)lParamSort;
    ASSERT_VALID( pThis );

    int nCmpRez = 0;

    // sanity check
    if( uIndex1 > pThis->m_VerifState.DriverCount ||
        uIndex2 > pThis->m_VerifState.DriverCount )
    {
        ASSERT( FALSE );
        return 0;
    }

    if( pThis->m_VerifState.DriverInfo[ uIndex1 ].Verified ==
        pThis->m_VerifState.DriverInfo[ uIndex2 ].Verified )
    {
        // same flag for after boot verified

        if( pThis->m_VerifState.DriverInfo[ uIndex1 ].CurrentlyVerified ==
            pThis->m_VerifState.DriverInfo[ uIndex2 ].CurrentlyVerified )
        {
            // same flag for currently verified

            nCmpRez = _tcsicmp( pThis->m_VerifState.DriverInfo[ uIndex1 ].Name,
                                pThis->m_VerifState.DriverInfo[ uIndex2 ].Name );
        }
        else
        {
            // different flags for currently verified
            if( pThis->m_VerifState.DriverInfo[ uIndex1 ].CurrentlyVerified )
            {
                nCmpRez = 1;
            }
            else
            {
                nCmpRez = -1;
            }
        }
    }
    else
    {
        // different flags for after boot verified

        if( pThis->m_VerifState.DriverInfo[ uIndex1 ].Verified )
        {
            nCmpRez = 1;
        }
        else
        {
            nCmpRez = -1;
        }
    }

    if( pThis->m_bAscendDrvVerifSort )
        nCmpRez *= -1;

    return nCmpRez;
}

/////////////////////////////////////////////////////////////////////////////
int CALLBACK CModifSettPage::DrvNameCmpFunc(
    LPARAM lParam1,
    LPARAM lParam2,
    LPARAM lParamSort)
{
    UINT uIndex1 = (UINT)lParam1;
    UINT uIndex2 = (UINT)lParam2;
    CModifSettPage *pThis = (CModifSettPage *)lParamSort;
    ASSERT_VALID( pThis );

    int nCmpRez = 0;

    // sanity check
    if( uIndex1 > pThis->m_VerifState.DriverCount ||
        uIndex2 > pThis->m_VerifState.DriverCount )
    {
        ASSERT( FALSE );
        return 0;
    }

    // compare the names
    nCmpRez = _tcsicmp( pThis->m_VerifState.DriverInfo[ uIndex1 ].Name,
                        pThis->m_VerifState.DriverInfo[ uIndex2 ].Name );
    if( ! nCmpRez )
    {
        // same name ???
        if( pThis->m_VerifState.DriverInfo[ uIndex1 ].Verified ==
            pThis->m_VerifState.DriverInfo[ uIndex2 ].Verified )
        {
            // same flag
            return 0;
        }
        else
        {
            if( pThis->m_VerifState.DriverInfo[ uIndex1 ].Verified )
            {
                if( pThis->m_bAscendDrvVerifSort )
                    return 1;
                else
                    return -1;
            }
            else
            {
                if( pThis->m_bAscendDrvVerifSort )
                    return -1;
                else
                    return 1;
            }
        }
    }
    else
    {
        if( pThis->m_bAscendDrvNameSort )
            nCmpRez *= -1;
    }

    return nCmpRez;
}

/////////////////////////////////////////////////////////////////////////////
int CALLBACK CModifSettPage::ProviderCmpFunc(
    LPARAM lParam1,
    LPARAM lParam2,
    LPARAM lParamSort)
{
    BOOL bNotAvailable1;
    BOOL bNotAvailable2;
    CString strNotAvailable;

    UINT uIndex1 = (UINT)lParam1;
    UINT uIndex2 = (UINT)lParam2;

    CModifSettPage *pThis = (CModifSettPage *)lParamSort;
    ASSERT_VALID( pThis );

    int nCmpRez = 0;

    //
    // sanity checks
    //

    if( uIndex1 > pThis->m_VerifState.DriverCount ||
        uIndex2 > pThis->m_VerifState.DriverCount )
    {
        ASSERT( FALSE );
        return 0;
    }

    //
    // are the strings valid or (Not Available)?
    //

    VERIFY( strNotAvailable.LoadString( IDS_NOT_AVAILABLE ) );

    bNotAvailable1 = ( strNotAvailable.CompareNoCase(
        pThis->m_VerifState.DriverInfo[ uIndex1 ].Provider ) == 0 );

    bNotAvailable2 = ( strNotAvailable.CompareNoCase(
        pThis->m_VerifState.DriverInfo[ uIndex2 ].Provider ) == 0 );

    if( bNotAvailable1 )
    {
        if( bNotAvailable2 )
        {
            return 0;
        }
        else
        {
            if( pThis->m_bAscendProviderSort )
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }
    }
    else
    {
        if( bNotAvailable2 )
        {
            if( pThis->m_bAscendProviderSort )
            {
                return 1;
            }
            else
            {
                return -1;
            }
        }
    }

    //
    // compare the names of the providers
    //

    nCmpRez = _tcsicmp( pThis->m_VerifState.DriverInfo[ uIndex1 ].Provider,
                        pThis->m_VerifState.DriverInfo[ uIndex2 ].Provider );
    if( ! nCmpRez )
    {
        //
        // same name for the provider
        //

        if( pThis->m_VerifState.DriverInfo[ uIndex1 ].Verified ==
            pThis->m_VerifState.DriverInfo[ uIndex2 ].Verified )
        {
            //
            // same verified flag
            //

            return 0;
        }
        else
        {
            if( pThis->m_VerifState.DriverInfo[ uIndex1 ].Verified )
            {
                return 1;
            }
            else
            {
                return -1;
            }
        }
    }
    else
    {
        if( pThis->m_bAscendProviderSort )
            nCmpRez *= -1;
    }

    return nCmpRez;
}

/////////////////////////////////////////////////////////////////////////////
int CALLBACK CModifSettPage::VersionCmpFunc(
    LPARAM lParam1,
    LPARAM lParam2,
    LPARAM lParamSort)
{
    BOOL bNotAvailable1;
    BOOL bNotAvailable2;
    CString strNotAvailable;

    UINT uIndex1 = (UINT)lParam1;
    UINT uIndex2 = (UINT)lParam2;

    CModifSettPage *pThis = (CModifSettPage *)lParamSort;
    ASSERT_VALID( pThis );

    int nCmpRez = 0;

    //
    // sanity checks
    //

    if( uIndex1 > pThis->m_VerifState.DriverCount ||
        uIndex2 > pThis->m_VerifState.DriverCount )
    {
        ASSERT( FALSE );
        return 0;
    }

    //
    // are the strings valid or (Not Available)?
    //

    VERIFY( strNotAvailable.LoadString( IDS_NOT_AVAILABLE ) );

    bNotAvailable1 = ( strNotAvailable.CompareNoCase(
        pThis->m_VerifState.DriverInfo[ uIndex1 ].Version ) == 0 );

    bNotAvailable2 = ( strNotAvailable.CompareNoCase(
        pThis->m_VerifState.DriverInfo[ uIndex2 ].Version ) == 0 );

    if( bNotAvailable1 )
    {
        if( bNotAvailable2 )
        {
            return 0;
        }
        else
        {
            if( pThis->m_bAscendVersionSort )
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }
    }
    else
    {
        if( bNotAvailable2 )
        {
            if( pThis->m_bAscendVersionSort )
            {
                return 1;
            }
            else
            {
                return -1;
            }
        }
    }

    //
    // compare the names of the providers
    //

    nCmpRez = _tcsicmp( pThis->m_VerifState.DriverInfo[ uIndex1 ].Version,
                        pThis->m_VerifState.DriverInfo[ uIndex2 ].Version );
    if( ! nCmpRez )
    {
        //
        // same name for the provider
        //

        if( pThis->m_VerifState.DriverInfo[ uIndex1 ].Verified ==
            pThis->m_VerifState.DriverInfo[ uIndex2 ].Verified )
        {
            //
            // same verified flag
            //

            return 0;
        }
        else
        {
            if( pThis->m_VerifState.DriverInfo[ uIndex1 ].Verified )
            {
                return 1;
            }
            else
            {
                return -1;
            }
        }
    }
    else
    {
        if( pThis->m_bAscendVersionSort )
            nCmpRez *= -1;
    }

    return nCmpRez;
}

/////////////////////////////////////////////////////////////////////////////
// CModifSettPage message handlers

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::OnVerifallRadio()
{
    m_eListState = vrfControlDisabled;
    m_eApplyButtonState = vrfControlEnabled;
    UpdateControlsState();
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::OnVerifselRadio()
{
    m_eListState = vrfControlEnabled;
    m_eApplyButtonState = vrfControlEnabled;
    UpdateControlsState();
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::OnIoCheck()
{
    if( m_IOVerifCheck.GetCheck() == 1 )
    {
        m_eIoRadioState = vrfControlEnabled;
    }
    else
    {
        m_eIoRadioState = vrfControlDisabled;
    }

    OnCheck();
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::OnCheck()
{
    m_eApplyButtonState = vrfControlEnabled;
    UpdateControlsState();
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::ToggleItemsState( BOOL bVerified )
{
    BOOL bChanged = FALSE;

    if( m_eListState != vrfControlEnabled )
        return;

    int nItems = m_DriversList.GetItemCount();
    for(int nCrtItem = 0; nCrtItem < nItems; nCrtItem++ )
    {
        if( m_DriversList.GetItemState( nCrtItem, LVIS_SELECTED ) &
            LVIS_SELECTED )
        {
            UINT uIndexInArray = (UINT)m_DriversList.GetItemData( nCrtItem );

            if( m_VerifState.DriverInfo[ uIndexInArray ].Verified !=
                bVerified )
            {
                //
                // Toggle its state
                //

                m_VerifState.DriverInfo[ uIndexInArray ].Verified = bVerified;

                if( bVerified )
                {
                    //
                    // Will be verified from now on.
                    // Send a notification about this, in order to detect any miniports.
                    //

                    VrfNotifyDriverSelection( &m_VerifState, uIndexInArray );
                }

                bChanged = TRUE;
            }
        }
    }

    // refill the second column of the list
    for(nCrtItem = 0; nCrtItem < nItems; nCrtItem++ )
    {
        UINT uIndexInArray = (UINT)m_DriversList.GetItemData( nCrtItem );
        UpdateSecondColumn( nCrtItem,
            m_VerifState.DriverInfo[ uIndexInArray ].Verified,
            m_VerifState.DriverInfo[ uIndexInArray ].CurrentlyVerified );
    }

    // some status changed, enable the Apply button
    if( bChanged )
    {
        m_eApplyButtonState = vrfControlEnabled;
        UpdateControlsState();
    }
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::OnVerifyButton()
{
    ToggleItemsState( TRUE );
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::OnDontverifyButton()
{
    ToggleItemsState( FALSE );
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::OnApplyButton()
{
    if( ApplyTheChanges() )
    {
        CWaitCursor WaitCursor;

        g_bSettingsSaved = TRUE;

        VrfGetVerifierState( &m_VerifState );

        GetDlgDataFromSett();

        UpdateData( FALSE );

        AddTheListItems();

        // all updated
        m_eApplyButtonState = vrfControlDisabled;
        UpdateControlsState();

        WaitCursor.Restore();
    }
}

/////////////////////////////////////////////////////////////////////////////
BOOL CModifSettPage::ApplyTheChanges()
{
	if( UpdateData( TRUE ) )
    {
        // check if we have to clean-up all the registry values
        BOOL bAnythingEnabled = FALSE;

        if( m_VerifState.AllDriversVerified ||
            m_VerifState.SpecialPoolVerification ||
            m_VerifState.PagedCodeVerification ||
            m_VerifState.AllocationFaultInjection ||
            m_VerifState.PoolTracking ||
            m_VerifState.IoVerifier )
        {
            bAnythingEnabled = TRUE;
        }
        else
        {
            for( ULONG uCrtDriver = 0; uCrtDriver < m_VerifState.DriverCount; uCrtDriver++ )
            {
                if( m_VerifState.DriverInfo[ uCrtDriver ].Verified )
                {
                    bAnythingEnabled = TRUE;
                    break;
                }
            }

            if( ! bAnythingEnabled )
            {
                // check if we have some significative characters in Additional... edit
                int nBufferSize = sizeof( m_VerifState.AdditionalDriverNames ) / sizeof( TCHAR );
                for(int nCrtChar = 0; nCrtChar < nBufferSize; nCrtChar++ )
                {
                    if( m_VerifState.AdditionalDriverNames[nCrtChar] == (TCHAR)0 )
                    {
                        // end of string
                        break;
                    }

                    if( m_VerifState.AdditionalDriverNames[nCrtChar] != _T(' ') )
                    {
                        // significant char
                        bAnythingEnabled = TRUE;
                        break;
                    }
                }
            }
        }

        if( bAnythingEnabled )
            return VrfSetVerifierState( &m_VerifState );
        else
            return VrfClearAllVerifierSettings();
    }

    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::OnColumnclickDriversList(NMHDR* pNMHDR, LRESULT* pResult)
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    switch( pNMListView->iSubItem )
    {
    case 0:
        if( m_nLastColumnClicked == pNMListView->iSubItem )
        {
            //
            // change the sort order for this sub-item
            //

            m_bAscendDrvNameSort = !m_bAscendDrvNameSort;
        }

        m_DriversList.SortItems( DrvNameCmpFunc, (LPARAM)this );

        break;

    case 1:
        if( m_nLastColumnClicked == pNMListView->iSubItem )
        {
            //
            // change the sort order for this sub-item
            //
            m_bAscendDrvVerifSort = !m_bAscendDrvVerifSort;
        }

        m_DriversList.SortItems( DrvVerifCmpFunc, (LPARAM)this );

        break;

    case 2:
        if( m_nLastColumnClicked == pNMListView->iSubItem )
        {
            //
            // change the sort order for this sub-item
            //

            m_bAscendProviderSort = !m_bAscendProviderSort;
        }

        m_DriversList.SortItems( ProviderCmpFunc, (LPARAM)this );

        break;

    case 3:
        if( m_nLastColumnClicked == pNMListView->iSubItem )
        {
            //
            // change the sort order for this sub-item
            //

            m_bAscendVersionSort = !m_bAscendVersionSort;
        }

        m_DriversList.SortItems( VersionCmpFunc, (LPARAM)this );

        break;

    default:
        ASSERT( FALSE );
    }	

    //
    // keep the index of the last clicked column
    //

    m_nLastColumnClicked = pNMListView->iSubItem;

    *pResult = 0;
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::OnChangeAdditDrvnamesEdit()
{
    // send this notification unless you override the CDialog::OnInitDialog()
    // function and call CRichEditCtrl().SetEventMask()
    // with the ENM_CHANGE flag ORed into the mask.

    // TODO: Add your control notification handler code here
    m_eApplyButtonState = vrfControlEnabled;
    UpdateControlsState();
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::OnResetallButton()
{
    m_VerifState.AllDriversVerified = FALSE;

    m_VerifState.SpecialPoolVerification = FALSE;
    m_VerifState.PagedCodeVerification = FALSE;
    m_VerifState.AllocationFaultInjection = FALSE;
    m_VerifState.PoolTracking = FALSE;
    m_VerifState.IoVerifier = FALSE;

    for(ULONG uCrtDriver = 0; uCrtDriver < m_VerifState.DriverCount;
        uCrtDriver++ )
    {
        m_VerifState.DriverInfo[ uCrtDriver ].Verified = FALSE;
    }

    m_VerifState.AdditionalDriverNames[0] = (TCHAR)0;

    AddTheListItems();
    CheckRadioButton( IDC_VERIFALL_RADIO, IDC_VERIFSEL_RADIO,
        IDC_VERIFSEL_RADIO );

    m_PagedCCheck.SetCheck( 0 );
    m_SpecialPoolVerifCheck.SetCheck( 0 );
    m_AllocFCheck.SetCheck( 0 );
    m_PoolTCheck.SetCheck( 0 );
    m_IOVerifCheck.SetCheck( 0 );
    m_AdditDrvEdit.SetWindowText( _T("") );

    m_eListState = vrfControlEnabled;
    m_eApplyButtonState = vrfControlEnabled;

    m_eIoRadioState = vrfControlDisabled;

    UpdateControlsState();
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::OnPrefButton()
{
    m_VerifState.AllDriversVerified = TRUE;

    m_VerifState.SpecialPoolVerification = TRUE;
    m_VerifState.PagedCodeVerification = TRUE;
    m_VerifState.AllocationFaultInjection = FALSE;
    m_VerifState.PoolTracking = TRUE;
    m_VerifState.IoVerifier = TRUE;
    m_VerifState.SysIoVerifierLevel = 1;

    m_VerifState.AdditionalDriverNames[0] = (TCHAR)0;

    CheckRadioButton( IDC_VERIFALL_RADIO, IDC_VERIFSEL_RADIO,
        IDC_VERIFALL_RADIO );

    m_PagedCCheck.SetCheck( 1 );
    m_SpecialPoolVerifCheck.SetCheck( 1 );
    m_PoolTCheck.SetCheck( 1 );
    m_AllocFCheck.SetCheck( 0 );
    m_IOVerifCheck.SetCheck( 1 );

    m_eListState = vrfControlDisabled;
    m_eApplyButtonState = vrfControlEnabled;

    m_eIoRadioState = vrfControlEnabled;
    CheckRadioButton(
        IDC_MODSETT_IO_SELDRIVERS_RADIO,
        IDC_MODSETT_IO_SYSWIDE_RADIO,
        IDC_MODSETT_IO_SYSWIDE_RADIO );

    UpdateControlsState();
}

/////////////////////////////////////////////////////////////////////////////
BOOL CModifSettPage::OnInitDialog()
{
    //
    // get the current status
    //

    CWaitCursor WaitCursor;

    VrfGetVerifierState( &m_VerifState );

    if( m_VerifState.IoVerifier == TRUE )
    {
        m_eIoRadioState = vrfControlEnabled;
    }
    else
    {
        m_eIoRadioState = vrfControlDisabled;
    }

    GetDlgDataFromSett();

    CPropertyPage::OnInitDialog();

    //
    // the list of drivers
    //

    SetupTheList();

    //
    // sort the list by the driver name
    //

    m_nLastColumnClicked = 0;
    m_DriversList.SortItems( DrvNameCmpFunc, (LPARAM)this );

    //
    // update all controls
    //

    UpdateControlsState();

    WaitCursor.Restore();

    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::OnRclickDriversList(NMHDR* pNMHDR, LRESULT* pResult)
{
    POINT point;
    CMenu theMenu, *pTrackedMenu = NULL;
    BOOL bVerifiedMenu = FALSE, bNotVerifiedMenu = FALSE;

    if( m_eListState != vrfControlEnabled )
        return;

    int nItems = m_DriversList.GetItemCount();
    for(int nCrtItem = 0; nCrtItem < nItems; nCrtItem++ )
    {
        if( m_DriversList.GetItemState( nCrtItem, LVIS_SELECTED ) &
            LVIS_SELECTED )
        {
            UINT uIndexInArray = (UINT)m_DriversList.GetItemData( nCrtItem );

            if( m_VerifState.DriverInfo[ uIndexInArray ].Verified )
            {
                bVerifiedMenu = TRUE;
            }
            else
            {
                bNotVerifiedMenu = TRUE;
            }
        }
    }

    if( bVerifiedMenu && bNotVerifiedMenu )
    {
        VERIFY( theMenu.LoadMenu( IDM_BOTH_VERIFIED_ITEM ) );
    }
    else
    {
        if( bVerifiedMenu )
        {
            VERIFY( theMenu.LoadMenu( IDM_VERIFIED_ITEM ) );
        }
        else
        {
            if( bNotVerifiedMenu )
            {
                VERIFY( theMenu.LoadMenu( IDM_NOT_VERIFIED_ITEM ) );
            }
        }
    }

    pTrackedMenu = theMenu.GetSubMenu( 0 );
    if( pTrackedMenu != NULL )
    {
        ASSERT_VALID( pTrackedMenu );
        VERIFY( ::GetCursorPos( &point ) );
        VERIFY( pTrackedMenu->TrackPopupMenu(
                TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                point.x, point.y,
                this ) );
    }
    else
    {
        ASSERT( FALSE );
    }

      *pResult = 0;
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::OnDoVerify()
{
    OnVerifyButton();
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::OnDontVerify()
{
    OnDontverifyButton();
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::OnCancel()
{
    if( g_bSettingsSaved )
    {
        ::AfxMessageBox( IDS_REBOOT, MB_OK | MB_ICONINFORMATION );
    }

    CPropertyPage::OnCancel();
}

/////////////////////////////////////////////////////////////////////////////
void CModifSettPage::OnOK()
{
    if( g_bSettingsSaved )
    {
        ::AfxMessageBox( IDS_REBOOT, MB_OK | MB_ICONINFORMATION );
    }
	
    CPropertyPage::OnOK();
}

/////////////////////////////////////////////////////////////////////////////
BOOL CModifSettPage::OnQueryCancel()
{
    if( m_eApplyButtonState == vrfControlEnabled )
    {
        if( ::AfxMessageBox( IDS_CHANGES_NOT_SAVED,
            MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2 ) == IDNO )
            return FALSE;
    }
	
    return CPropertyPage::OnQueryCancel();
}

/////////////////////////////////////////////////////////////////////////////
BOOL CModifSettPage::OnApply()
{
    return FALSE;
}

/////////////////////////////////////////////////////////////
LONG CModifSettPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        VERIFIER_HELP_FILE,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////
LONG CModifSettPage::OnContextMenu( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;

    ::WinHelp( 
        (HWND) wParam,
        VERIFIER_HELP_FILE,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\win2k\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by drvvctrl.rc
//

//////////////////////////////////////////////////////

//
// first icon ID
//

#define ID_ICON_FIRST                   128

//
// first string ID
//

#define ID_STRING_FIRST                 10000

//
// first menu ID
//

#define ID_MENU_FIRST                   0x0010

//
// first dialog ID
//

#define ID_DIALOG_FIRST                 1001

//
// first control ID in a dialog
//

#define ID_CONTROL_FIRST                5000

//////////////////////////////////////////////////////
//
// menu & menu items IDs
//

#define IDM_ABOUTBOX                    16  // ID_MENU_FIRST
#define IDM_VERIFIED_ITEM               17  // ( ID_MENU_FIRST + 1 )
#define IDM_NOT_VERIFIED_ITEM           18  // ( ID_MENU_FIRST + 2 )
#define IDM_BOTH_VERIFIED_ITEM          19  // ( ID_MENU_FIRST + 3 )
#define IDM_ADD_REMOVE_DRIVERS          20  // ( ID_MENU_FIRST + 4 )
#define IDM_ADD_DRIVERS                 21  // ( ID_MENU_FIRST + 5 )

#define ID_MODIF_DO_VERIFY              26  // ( ID_MENU_FIRST + 10 )
#define ID_MODIF_DONT_VERIFY            27  // ( ID_MENU_FIRST + 11 )
#define ID_VOLATILE_ADD_DRIVERS         28  // ( ID_MENU_FIRST + 12 )
#define ID_VOLATILE_REMOVE_DRIVERS      29  // ( ID_MENU_FIRST + 13 )

//////////////////////////////////////////////////////
//
// icon IDs
//

#define IDR_MAINFRAME                   ID_ICON_FIRST

//////////////////////////////////////////////////////
//
// dialog IDs
//

#define IDD_MODIF_PAGE                  1001    // ID_DIALOG_FIRST
#define IDD_GCOUNT_PAGE                 1002    // ( ID_DIALOG_FIRST + 1 )
#define IDD_DRVSTAT_PAGE                1003    // ( ID_DIALOG_FIRST + 2 )
#define IDD_POOLTRACK_PAGE              1004    // ( ID_DIALOG_FIRST + 3 )
#define IDD_VSETTINGS_PAGE              1005    // ( ID_DIALOG_FIRST + 4 )

//
// control IDs for IDD_MODIF_PAGE
//

#define IDC_DRIVERS_LIST                ID_CONTROL_FIRST
#define IDC_VERIFALL_RADIO              ( ID_CONTROL_FIRST + 1 )
#define IDC_VERIFSEL_RADIO              ( ID_CONTROL_FIRST + 2 )
#define IDC_NORMAL_VERIF_CHECK          ( ID_CONTROL_FIRST + 3 )
#define IDC_PAGEDC_VERIF_CHECK          ( ID_CONTROL_FIRST + 4 )
#define IDC_ALLOCF_VERIF_CHECK          ( ID_CONTROL_FIRST + 5 )
#define IDC_POOLT_VERIF_CHECK           ( ID_CONTROL_FIRST + 6 )
#define IDC_IO_VERIF_CHECK              ( ID_CONTROL_FIRST + 7 )
#define IDC_VERIFY_BUTTON               ( ID_CONTROL_FIRST + 8 )
#define IDC_DONTVERIFY_BUTTON           ( ID_CONTROL_FIRST + 9 )
#define ID_APPLY_BUTTON                 ( ID_CONTROL_FIRST + 10 )
#define IDC_ADDIT_DRVNAMES_EDIT         ( ID_CONTROL_FIRST + 11 )
#define ID_RESETALL_BUTTON              ( ID_CONTROL_FIRST + 12 )
#define ID_PREF_BUTTON                  ( ID_CONTROL_FIRST + 13 )
#define IDC_MODSETT_IO_SELDRIVERS_RADIO ( ID_CONTROL_FIRST + 14 )
#define IDC_MODSETT_IO_SYSWIDE_RADIO    ( ID_CONTROL_FIRST + 15 )
//
// control IDs for IDD_GCOUNT_PAGE
//

#define IDC_COUNT_RAISEIRQL_EDIT        ( ID_CONTROL_FIRST + 50 )
#define IDC_COUNT_ACQSPINL_EDIT         ( ID_CONTROL_FIRST + 51 )
#define IDC_COUNT_SYNCREX_EDIT          ( ID_CONTROL_FIRST + 52 )
#define IDC_COUNT_TRIMS_EDIT            ( ID_CONTROL_FIRST + 54 )
#define IDC_COUNT_ALLOC_ATTEMPT_EDIT    ( ID_CONTROL_FIRST + 55 )
#define IDC_COUNT_ALLOC_SUCC_EDIT       ( ID_CONTROL_FIRST + 56 )
#define IDC_COUNT_ALLOCSUCC_SPECPOOL_EDIT ( ID_CONTROL_FIRST + 57 )
#define IDC_COUNT_ALLOC_NOTAG_EDIT      ( ID_CONTROL_FIRST + 58 )
#define IDC_COUNT_ALLOC_FAILED_EDIT     ( ID_CONTROL_FIRST + 59 )
#define IDC_COUNT_ALLOC_FAILEDDEL_EDIT  ( ID_CONTROL_FIRST + 60 )
#define IDC_COUNT_MANUAL_RADIO          ( ID_CONTROL_FIRST + 61 )
#define IDC_COUNT_HSPEED_RADIO          ( ID_CONTROL_FIRST + 62 )
#define IDC_COUNT_NORM_RADIO            ( ID_CONTROL_FIRST + 63 )
#define IDC_COUNT_LOW_RADIO             ( ID_CONTROL_FIRST + 64 )
#define IDC_COUNT_REFRESH_BUTTON        ( ID_CONTROL_FIRST + 65 )

//
// control IDs for IDD_POOLTRACK_PAGE
//

#define IDC_POOLCNT_REFRESH_BUTTON              ( ID_CONTROL_FIRST + 100 )
#define IDC_POOLCNT_MANUAL_RADIO                ( ID_CONTROL_FIRST + 101 )
#define IDC_POOLCNT_HSPEED_RADIO                ( ID_CONTROL_FIRST + 102 )
#define IDC_POOLCNT_NORM_RADIO                  ( ID_CONTROL_FIRST + 103 )
#define IDC_POOLCNT_LOW_RADIO                   ( ID_CONTROL_FIRST + 104 )
#define IDC_POOLCNT_CRT_PPOOL_ALLOC_EDIT        ( ID_CONTROL_FIRST + 105 )
#define IDC_POOLCNT_CRT_NPPOOL_ALLOC_EDIT       ( ID_CONTROL_FIRST + 106 )
#define IDC_POOLCNT_PEAK_PPOOL_ALLOC_EDIT       ( ID_CONTROL_FIRST + 107 )
#define IDC_POOLCNT_PEAK_NPPOOL_ALLOC_EDIT      ( ID_CONTROL_FIRST + 108 )
#define IDC_POOLCNT_UNTRACK_ALLOC_EDIT          ( ID_CONTROL_FIRST + 109 )
#define IDC_POOLCNT_CRT_PPOOL_BYTES_EDIT        ( ID_CONTROL_FIRST + 110 )
#define IDC_POOLCNT_CRT_NPPOOL_BYTES_EDIT       ( ID_CONTROL_FIRST + 111 )
#define IDC_POOLCNT_PEAK_PPOOL_BYTES_EDIT       ( ID_CONTROL_FIRST + 112 )
#define IDC_POOLCNT_PEAK_NPPOOL_BYTES_EDIT      ( ID_CONTROL_FIRST + 113 )
#define IDC_POOLCNT_DRVNAME_COMBO               ( ID_CONTROL_FIRST + 114 )

//
// control IDs for IDD_DRVSTAT_PAGE
//

#define IDC_CRTSTAT_DRIVERS_LIST        ( ID_CONTROL_FIRST + 150 )
#define IDC_CRTSTAT_SPECPOOL_EDIT       ( ID_CONTROL_FIRST + 151 )
#define IDC_CRTSTAT_IRQLCHCK_EDIT       ( ID_CONTROL_FIRST + 152 )
#define IDC_CRTSTAT_FAULTINJ_EDIT       ( ID_CONTROL_FIRST + 153 )
#define IDC_CRTSTAT_POOLT_EDIT          ( ID_CONTROL_FIRST + 154 )
#define IDC_CRTSTAT_IOVERIF_EDIT        ( ID_CONTROL_FIRST + 155 )
#define IDC_CRTSTAT_POOLUSAGE_EDIT      ( ID_CONTROL_FIRST + 156 )
#define IDC_CRTSTAT_REFRESH_BUTTON      ( ID_CONTROL_FIRST + 157 )
#define IDC_CRTSTAT_MANUAL_RADIO        ( ID_CONTROL_FIRST + 158 )
#define IDC_CRTSTAT_HSPEED_RADIO        ( ID_CONTROL_FIRST + 159 )
#define IDC_CRTSTAT_NORM_RADIO          ( ID_CONTROL_FIRST + 160 )
#define IDC_CRTSTAT_LOW_RADIO           ( ID_CONTROL_FIRST + 161 )
#define IDC_CRTSTAT_WARN_MSG            ( ID_CONTROL_FIRST + 162 )


//
// control IDs for IDD_VSETTINGS_PAGE
//

#define IDC_VSETTINGS_REFRESH_BUTTON    ( ID_CONTROL_FIRST + 200 )
#define IDC_VSETTINGS_MANUAL_RADIO      ( ID_CONTROL_FIRST + 201 )
#define IDC_VSETTINGS_HSPEED_RADIO      ( ID_CONTROL_FIRST + 202 )
#define IDC_VSETTINGS_NORM_RADIO        ( ID_CONTROL_FIRST + 203 )
#define IDC_VSETTINGS_LOW_RADIO         ( ID_CONTROL_FIRST + 204 )
#define IDC_VSETTINGS_DRIVERS_LIST      ( ID_CONTROL_FIRST + 205 )
#define IDC_VSETTINGS_NORMAL_VERIF_CHECK    ( ID_CONTROL_FIRST + 206 )
#define IDC_VSETTINGS_PAGEDC_VERIF_CHECK    ( ID_CONTROL_FIRST + 207 )
#define IDC_VSETTINGS_ALLOCF_VERIF_CHECK    ( ID_CONTROL_FIRST + 208 )
#define IDC_VSETTINGS_APPLY_BUTTON      ( ID_CONTROL_FIRST + 209 )
#define IDC_VSETTINGS_WARN_STATIC       ( ID_CONTROL_FIRST + 210 )
#define IDC_VSETTINGS_ADD_BUTTON        ( ID_CONTROL_FIRST + 211 )
#define IDC_VSETTINGS_DONTVERIFY_BUTTON ( ID_CONTROL_FIRST + 212 )

//////////////////////////////////////////////////////
//
// string IDs
//

#define IDS_ABOUTBOX                    ID_STRING_FIRST
#define IDS_DRIVERS                     ( ID_STRING_FIRST + 1 )
#define IDS_STATUS                      ( ID_STRING_FIRST + 2 )
#define IDS_VERIFIED                    ( ID_STRING_FIRST + 3 )
#define IDS_NOT_VERIFIED                ( ID_STRING_FIRST + 4 )
#define IDS_REBOOT                      ( ID_STRING_FIRST + 5 )
#define IDS_APPTITLE                    ( ID_STRING_FIRST + 6 )
#define IDS_ENABLED                     ( ID_STRING_FIRST + 7 )
#define IDS_DISABLED                    ( ID_STRING_FIRST + 8 )
#define IDS_LOADS                       ( ID_STRING_FIRST + 9 )
#define IDS_UNLOADS                     ( ID_STRING_FIRST + 10 )
#define IDS_NEVER_LOADED                ( ID_STRING_FIRST + 11 )
#define IDS_UNLOADED                    ( ID_STRING_FIRST + 12 )
#define IDS_LOADED                      ( ID_STRING_FIRST + 13)
#define IDS_UNKNOWN                     ( ID_STRING_FIRST + 14 )
#define IDS_QUIT                        ( ID_STRING_FIRST + 15 )
#define IDS_CHANGES_NOT_SAVED           ( ID_STRING_FIRST + 16 )
#define IDS_ZERO                        ( ID_STRING_FIRST + 17 )
#define IDS_VERIFIED_AFTER_BOOT         ( ID_STRING_FIRST + 18 )
#define IDS_NOT_VERIFIED_AFTER_BOOT     ( ID_STRING_FIRST + 19 )
#define IDS_FAULT_INJECTION_DISABLED_NOW ( ID_STRING_FIRST + 20 )
#define IDS_BUILD_WARN                  ( ID_STRING_FIRST + 21 )
#define IDS_ACCESS_IS_DENIED            ( ID_STRING_FIRST + 22 )
#define IDS_REGOPENKEYEX_FAILED         ( ID_STRING_FIRST + 23 )
#define IDS_REGDELETEVALUE_FAILED       ( ID_STRING_FIRST + 24 )
#define IDS_QUERY_SYSINFO_FAILED        ( ID_STRING_FIRST + 25 )
#define IDS_REGQUERYVALUEEX_FAILED      ( ID_STRING_FIRST + 26 )
#define IDS_REGQUERYVALUEEX_UNEXP_TYPE  ( ID_STRING_FIRST + 27 )
#define IDS_REGQUERYVALUEEX_UNEXP_SIZE  ( ID_STRING_FIRST + 28 )
#define IDS_REGSETVALUEEX_FAILED        ( ID_STRING_FIRST + 29 )
#define IDS_CANT_GET_ACTIVE_DRVLIST     ( ID_STRING_FIRST + 30 )
#define IDS_CANT_FIND_IMAGE             ( ID_STRING_FIRST + 31 )
#define IDS_INVALID_IMAGE               ( ID_STRING_FIRST + 32 )
#define IDS_CANTGET_VERIF_STATE         ( ID_STRING_FIRST + 33 )
#define IDS_NAME_LOADS_UNLOADS          ( ID_STRING_FIRST + 34 )
#define IDS_NO_DRIVER_VERIFIED          ( ID_STRING_FIRST + 35 )
#define IDS_LEVEL                       ( ID_STRING_FIRST + 36 )
#define IDS_RAISEIRQLS                  ( ID_STRING_FIRST + 37 )
#define IDS_ACQUIRESPINLOCKS            ( ID_STRING_FIRST + 38 )
#define IDS_SYNCHRONIZEEXECUTIONS       ( ID_STRING_FIRST + 39 )
#define IDS_ALLOCATIONSATTEMPTED        ( ID_STRING_FIRST + 40 )
#define IDS_ALLOCATIONSSUCCEEDED        ( ID_STRING_FIRST + 41 )
#define IDS_ALLOCATIONSSUCCEEDEDSPECIALPOOL ( ID_STRING_FIRST + 42 )
#define IDS_ALLOCATIONSWITHNOTAG        ( ID_STRING_FIRST + 43 )
#define IDS_ALLOCATIONSFAILED           ( ID_STRING_FIRST + 44 )
#define IDS_ALLOCATIONSFAILEDDELIBERATELY ( ID_STRING_FIRST + 45 )
#define IDS_TRIMS                       ( ID_STRING_FIRST + 46 )
#define IDS_UNTRACKEDPOOL               ( ID_STRING_FIRST + 47 )
#define IDS_CURRENTPAGEDPOOLALLOCATIONS ( ID_STRING_FIRST + 48 )
#define IDS_CURRENTNONPAGEDPOOLALLOCATIONS ( ID_STRING_FIRST + 49 )
#define IDS_PEAKPAGEDPOOLALLOCATIONS    ( ID_STRING_FIRST + 50 )
#define IDS_PEAKNONPAGEDPOOLALLOCATIONS ( ID_STRING_FIRST + 51 )
#define IDS_PAGEDPOOLUSAGEINBYTES       ( ID_STRING_FIRST + 52 )
#define IDS_NONPAGEDPOOLUSAGEINBYTES    ( ID_STRING_FIRST + 53 )
#define IDS_PEAKPAGEDPOOLUSAGEINBYTES   ( ID_STRING_FIRST + 54 )
#define IDS_PEAKNONPAGEDPOOLUSAGEINBYTES ( ID_STRING_FIRST + 55 )
#define IDS_HELP_CMDLINE_SWITCH         ( ID_STRING_FIRST + 56 )
#define IDS_LOG_CMDLINE_SWITCH          ( ID_STRING_FIRST + 57 )
#define IDS_INTERVAL_CMDLINE_SWITCH     ( ID_STRING_FIRST + 58 )
#define IDS_CANT_APPEND_FILE            ( ID_STRING_FIRST + 59 )
#define IDS_CANT_WRITE_FILE             ( ID_STRING_FIRST + 60 )
#define IDS_QUERY_CMDLINE_SWITCH        ( ID_STRING_FIRST + 61 )
#define IDS_FLAGS_CMDLINE_SWITCH        ( ID_STRING_FIRST + 62 )
#define IDS_ALL_CMDLINE_SWITCH          ( ID_STRING_FIRST + 63 )
#define IDS_DRIVER_CMDLINE_SWITCH       ( ID_STRING_FIRST + 64 )
#define IDS_RESET_CMDLINE_SWITCH        ( ID_STRING_FIRST + 65 )
#define IDS_COVERAGE_WARNING_FORMAT     ( ID_STRING_FIRST + 66 )
#define IDS_THE_VERIFIED_DRIVERS        ( ID_STRING_FIRST + 67 )
#define IDS_DONTREBOOT_CMDLINE_SWITCH   ( ID_STRING_FIRST + 68 )
#define IDS_CANNOT_CHANGE_SETTING_ON_FLY ( ID_STRING_FIRST + 69 )
#define IDS_SAME_FLAGS_AS_ACTIVE        ( ID_STRING_FIRST + 70 )
#define IDS_CANT_CHANGE_SETTINGS_BUILD_OLD ( ID_STRING_FIRST + 71 )
#define IDS_NO_SETTINGS_WERE_CHANGED    ( ID_STRING_FIRST + 72 )
#define IDS_SPECIAL_POOL_ENABLED_NOW    ( ID_STRING_FIRST + 73 )
#define IDS_SPECIAL_POOL_DISABLED_NOW   ( ID_STRING_FIRST + 74 )
#define IDS_FORCE_IRQLCHECK_ENABLED_NOW ( ID_STRING_FIRST + 75 )
#define IDS_FORCE_IRQLCHECK_DISABLED_NOW ( ID_STRING_FIRST + 76 )
#define IDS_FAULT_INJECTION_ENABLED_NOW ( ID_STRING_FIRST + 77 )
#define IDS_POOL_TRACK_ENABLED_NOW      ( ID_STRING_FIRST + 78 )
#define IDS_POOL_TRACK_DISABLED_NOW     ( ID_STRING_FIRST + 79 )
#define IDS_IO_CHECKING_ENABLED_NOW     ( ID_STRING_FIRST + 80 )
#define IDS_IO_CHECKING_DISABLED_NOW    ( ID_STRING_FIRST + 81 )
#define IDS_CHANGES_ACTIVE_ONLY_BEFORE_REBOOT ( ID_STRING_FIRST + 82 )
#define IDS_MUST_SPECIFY_NEW_FLAGS      ( ID_STRING_FIRST + 83 )
#define IDS_CHANGED_SETTINGS_ARE        ( ID_STRING_FIRST + 84 )
#define IDS_REGCREATEKEYEX_FAILED       ( ID_STRING_FIRST + 85 )
#define IDS_VERIFICATION_STATUS         ( ID_STRING_FIRST + 86 )
#define IDS_PROVIDER                    ( ID_STRING_FIRST + 87 )
#define IDS_VERSION                     ( ID_STRING_FIRST + 88 )
#define IDS_NOT_AVAILABLE               ( ID_STRING_FIRST + 89 )
#define IDS_IOLEVEL_CMDLINE_SWITCH      ( ID_STRING_FIRST + 90 )
#define IDS_DYN_REMOVE_NOT_SUPPORTED    ( ID_STRING_FIRST + 91 )
#define IDS_DYN_REMOVE_ALREADY_LOADED   ( ID_STRING_FIRST + 92 ) 
#define IDS_DYN_REMOVE_MISC_ERROR       ( ID_STRING_FIRST + 93 )
#define IDS_DYN_REMOVE_INSUF_RESOURCES  ( ID_STRING_FIRST + 94 )
#define IDS_DYN_REMOVE_ACCESS_DENIED    ( ID_STRING_FIRST + 95 )
#define IDS_DYN_ADD_NOT_SUPPORTED       ( ID_STRING_FIRST + 96 )
#define IDS_DYN_ADD_ALREADY_LOADED      ( ID_STRING_FIRST + 97 )
#define IDS_DYN_ADD_MISC_ERROR          ( ID_STRING_FIRST + 98 )
#define IDS_DYN_ADD_INSUF_RESOURCES     ( ID_STRING_FIRST + 99 )
#define IDS_DYN_ADD_ACCESS_DENIED       ( ID_STRING_FIRST + 100 )
#define IDS_ADDDRIVER_CMDLINE_SWITCH    ( ID_STRING_FIRST + 101 )
#define IDS_REMOVEDRIVER_CMDLINE_SWITCH ( ID_STRING_FIRST + 102 )
#define IDS_CANT_CHANGE_SETTINGS_BUILD_OLD2 ( ID_STRING_FIRST + 103 )
#define IDS_INSUFFICIENT_MEMORY         ( ID_STRING_FIRST + 104 )
#define IDS_TOO_MANY_FILES_SELECTED     ( ID_STRING_FIRST + 105 )
#define IDS_CANNOT_OPEN_FILES           ( ID_STRING_FIRST + 106 )
#define IDS_DYN_ADD_VERIFIED_NOW        ( ID_STRING_FIRST + 107 )
#define IDS_DYN_ADD_NOT_VERIFIED_NOW    ( ID_STRING_FIRST + 108 )
#define IDS_VERIFIER_ADD_NOT_SUPPORTED  ( ID_STRING_FIRST + 109 )
#define IDS_VERIFIER_REMOVE_NOT_SUPPORTED  ( ID_STRING_FIRST + 110 )


#define IDS_HELP_LINE1                  ( ID_STRING_FIRST + 500 )
#define IDS_HELP_LINE3                  ( ID_STRING_FIRST + 501 )
#define IDS_HELP_LINE4                  ( ID_STRING_FIRST + 502 )
#define IDS_HELP_LINE5                  ( ID_STRING_FIRST + 503 )
#define IDS_HELP_LINE6                  ( ID_STRING_FIRST + 504 )
#define IDS_HELP_LINE7                  ( ID_STRING_FIRST + 505 )
#define IDS_HELP_LINE8                  ( ID_STRING_FIRST + 506 )
#define IDS_HELP_LINE9                  ( ID_STRING_FIRST + 507 )
#define IDS_HELP_LINE10                 ( ID_STRING_FIRST + 508 )
#define IDS_HELP_LINE11                 ( ID_STRING_FIRST + 509 )
#define IDS_HELP_LINE12                 ( ID_STRING_FIRST + 510 )
#define IDS_HELP_LINE13                 ( ID_STRING_FIRST + 511 )
#define IDS_HELP_LINE14                 ( ID_STRING_FIRST + 512 )
#define IDS_HELP_LINE15                 ( ID_STRING_FIRST + 513 )
#define IDS_HELP_LINE16                 ( ID_STRING_FIRST + 514 )
#define IDS_HELP_LINE17                 ( ID_STRING_FIRST + 515 )
#define IDS_HELP_LINE18                 ( ID_STRING_FIRST + 516 )
#define IDS_HELP_LINE19                 ( ID_STRING_FIRST + 517 )
#define IDS_HELP_LINE20                 ( ID_STRING_FIRST + 518 )
#define IDS_HELP_LINE21                 ( ID_STRING_FIRST + 519 )
#define IDS_HELP_LINE22                 ( ID_STRING_FIRST + 520 )
#define IDS_HELP_LINE23                 ( ID_STRING_FIRST + 521 )
#define IDS_HELP_LINE24                 ( ID_STRING_FIRST + 522 )
#define IDS_HELP_LINE25                 ( ID_STRING_FIRST + 523 )
#define IDS_HELP_LINE26                 ( ID_STRING_FIRST + 524 )
#define IDS_HELP_LINE27                 ( ID_STRING_FIRST + 525 )
#define IDS_HELP_LINE28                 ( ID_STRING_FIRST + 526 )
#define IDS_HELP_LINE29                 ( ID_STRING_FIRST + 527 )
#define IDS_HELP_LINE30                 ( ID_STRING_FIRST + 528 )
#define IDS_HELP_LINE31                 ( ID_STRING_FIRST + 529 )


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        20000
#define _APS_NEXT_COMMAND_VALUE         30000
#define _APS_NEXT_CONTROL_VALUE         40000
#define _APS_NEXT_SYMED_VALUE           50000
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\win2k\pcntpage.cxx ===
// PCntPage.cpp : implementation file
//

#include "stdafx.h"
#include "drvvctrl.hxx"
#include "PCntPage.hxx"

#include "DrvCSht.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// timer ID
#define REFRESH_TIMER_ID    0x1243

// manual, high, normal, low speed
#define REFRESH_SPEED_VARS  4

// timer intervals in millisec for manual, high, normal, low speed
static UINT uTimerIntervals[ REFRESH_SPEED_VARS ] =
{
    0,      // Manual
    1000,   // High Speed
    5000,   // Normal Speed
    10000   // Low Speed
};

//
// help IDs
//

static DWORD MyHelpIds[] =
{
    IDC_POOLCNT_CRT_PPOOL_ALLOC_EDIT,       IDH_DV_PoolTab_paged_allocations_current,
    IDC_POOLCNT_CRT_NPPOOL_ALLOC_EDIT,      IDH_DV_PoolTab_nonpaged_allocations_current,
    IDC_POOLCNT_PEAK_PPOOL_ALLOC_EDIT,      IDH_DV_PoolTab_paged_allocations_peak,
    IDC_POOLCNT_PEAK_NPPOOL_ALLOC_EDIT,     IDH_DV_PoolTab_nonpaged_allocations_peak,
    IDC_POOLCNT_UNTRACK_ALLOC_EDIT,         IDH_DV_PoolTab_globalcounters,
    IDC_POOLCNT_CRT_PPOOL_BYTES_EDIT,       IDH_DV_PoolTab_paged_currentbytes,
    IDC_POOLCNT_CRT_NPPOOL_BYTES_EDIT,      IDH_DV_PoolTab_nonpaged_currentbytes,
    IDC_POOLCNT_PEAK_PPOOL_BYTES_EDIT,      IDH_DV_PoolTab_paged_peakbytes,
    IDC_POOLCNT_PEAK_NPPOOL_BYTES_EDIT,     IDH_DV_PoolTab_nonpaged_peakbytes,
    IDC_POOLCNT_DRVNAME_COMBO,              IDH_DV_PoolTab_indivcounters,

    IDC_POOLCNT_REFRESH_BUTTON,     IDH_DV_common_refresh_nowbutton,
    IDC_POOLCNT_MANUAL_RADIO,       IDH_DV_common_refresh_manual,
    IDC_POOLCNT_HSPEED_RADIO,       IDH_DV_common_refresh_high,
    IDC_POOLCNT_NORM_RADIO,         IDH_DV_common_refresh_normal,
    IDC_POOLCNT_LOW_RADIO,          IDH_DV_common_refresh_low,
    0,                              0
};


/////////////////////////////////////////////////////////////////////
static void GetStringFromULONG( CString &strValue, ULONG_PTR uValue )
{
    LPTSTR lptstrValue = strValue.GetBuffer( 64 );
    if( lptstrValue != NULL )
    {
        _stprintf( lptstrValue, _T( "%lu" ), uValue );
        strValue.ReleaseBuffer();
    }
    else
    {
        ASSERT( FALSE );
        strValue.Empty();
    }
}

/////////////////////////////////////////////////////////////////////////////
// CPoolCntPage property page

IMPLEMENT_DYNCREATE(CPoolCntPage, CPropertyPage)

CPoolCntPage::CPoolCntPage()
	: CPropertyPage(CPoolCntPage::IDD)
{
	//{{AFX_DATA_INIT(CPoolCntPage)
    m_nUpdateIntervalIndex = 2;
	m_strCrtNPAlloc = _T("");
	m_strCrtNPBytes = _T("");
	m_strCrtPPAlloc = _T("");
	m_strCrtPPBytes = _T("");
	m_strPeakNPPAlloc = _T("");
	m_strPeakNPPBytes = _T("");
	m_strPeakPPAlloc = _T("");
	m_strPeakPPBytes = _T("");
	m_strUnTrackedAlloc = _T("");
	//}}AFX_DATA_INIT

    m_uTimerHandler = 0;
}


void CPoolCntPage::DoDataExchange(CDataExchange* pDX)
{
    TCHAR szCrtDriverName [ _MAX_PATH ];
    BOOL bComboEnabled;

	CPropertyPage::DoDataExchange(pDX);

    //
    // subclass the combo-box
    //

	DDX_Control(pDX, IDC_POOLCNT_DRVNAME_COMBO, m_DrvNamesCombo);

    //
    // get the date from the kernel
    //

    bComboEnabled = TRUE;

    if( ! pDX->m_bSaveAndValidate )
    {
        //
        // get the currently selected driver name
        //

        GetCurrentSelDriverName( szCrtDriverName, ARRAY_LENGTH( szCrtDriverName ) );

        //
        // query the kernel
        //

        if( KrnGetSystemVerifierState( &m_KrnVerifState ) && 
            m_KrnVerifState.DriverCount > 0 )
        {
            //
            // UnTrackedPool - global counter
            //

            GetStringFromULONG( m_strUnTrackedAlloc, 
                m_KrnVerifState.UnTrackedPool );

            //
            // update combo content
            //
            
            FillDriversNameCombo( szCrtDriverName );
        }
        else
        {
            //
            // UnTrackedPool - global counter
            //

            VERIFY( m_strUnTrackedAlloc.LoadString( IDS_ZERO ) );

            //
            // disable the drivers name list
            //

            bComboEnabled = FALSE;
            
            m_DrvNamesCombo.ResetContent();

            //
            // this is used by OnDriversNameSelChanged
            //
            
            m_KrnVerifState.DriverCount = 0;
        }

        //
        // update per driver counters
        //

        OnDriversNameSelChanged();
    }

	//{{AFX_DATA_MAP(CPoolCntPage)
    DDX_Radio(pDX, IDC_POOLCNT_MANUAL_RADIO, m_nUpdateIntervalIndex);
	DDX_Text(pDX, IDC_POOLCNT_UNTRACK_ALLOC_EDIT, m_strUnTrackedAlloc);
	//}}AFX_DATA_MAP

    if( ! pDX->m_bSaveAndValidate )
    {
        m_DrvNamesCombo.EnableWindow( bComboEnabled );
    }
}


BEGIN_MESSAGE_MAP(CPoolCntPage, CPropertyPage)
	//{{AFX_MSG_MAP(CPoolCntPage)
    ON_BN_CLICKED(IDC_POOLCNT_REFRESH_BUTTON, OnCountRefreshButton)
    ON_WM_TIMER()
    ON_BN_CLICKED(IDC_POOLCNT_HSPEED_RADIO, OnCountHspeedRadio)
    ON_BN_CLICKED(IDC_POOLCNT_LOW_RADIO, OnCountLowRadio)
    ON_BN_CLICKED(IDC_POOLCNT_MANUAL_RADIO, OnCountManualRadio)
    ON_BN_CLICKED(IDC_POOLCNT_NORM_RADIO, OnCountNormRadio)
	ON_CBN_SELENDOK(IDC_POOLCNT_DRVNAME_COMBO, OnDriversNameSelChanged)
    ON_MESSAGE( WM_HELP, OnHelp )
    ON_MESSAGE( WM_CONTEXTMENU, OnContextMenu )
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPoolCntPage message handlers

/////////////////////////////////////////////////////////////////////
void CPoolCntPage::OnRefreshTimerChanged()
{
    UINT uTimerElapse = 0;

    // kill the pending timer
    if( m_uTimerHandler != 0 )
    {
        VERIFY( KillTimer( REFRESH_TIMER_ID ) );
    }

    // sanity check
    if( m_nUpdateIntervalIndex < 0 || 
        m_nUpdateIntervalIndex >= REFRESH_SPEED_VARS )
    {
        m_nUpdateIntervalIndex = 0;
        CheckRadioButton( IDC_POOLCNT_MANUAL_RADIO, IDC_POOLCNT_LOW_RADIO, 
            IDC_POOLCNT_MANUAL_RADIO );
    }

    // new timer interval
    uTimerElapse = uTimerIntervals[ m_nUpdateIntervalIndex ];
    if( uTimerElapse > 0 )
    {
        VERIFY( m_uTimerHandler = SetTimer( REFRESH_TIMER_ID, 
            uTimerElapse, NULL ) );
    }
}

/////////////////////////////////////////////////////////////////////
// CPoolCntPage message handlers
BOOL CPoolCntPage::OnInitDialog() 
{
    CPropertyPage::OnInitDialog();

    OnRefreshTimerChanged();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////
void CPoolCntPage::OnCountRefreshButton() 
{
    UpdateData( FALSE );
}

/////////////////////////////////////////////////////////////////////
void CPoolCntPage::OnTimer(UINT nIDEvent) 
{
    if( nIDEvent == REFRESH_TIMER_ID )
    {
        CDrvChkSheet *pParentSheet = (CDrvChkSheet *)GetParent();
        if( pParentSheet != NULL )
        {
            ASSERT_VALID( pParentSheet );
            if( pParentSheet->GetActivePage() == this )
            {
                // refresh the displayed data 
                OnCountRefreshButton();
            }
        }
    }

    CPropertyPage::OnTimer(nIDEvent);
}

/////////////////////////////////////////////////////////////////////
BOOL CPoolCntPage::OnQueryCancel() 
{
    // give parent PropertySheet a chance to refuse the Cancel if needed

    CDrvChkSheet *pParentSheet = (CDrvChkSheet *)GetParent();
    if( pParentSheet != NULL )
    {
        ASSERT_VALID( pParentSheet );
        if( ! pParentSheet->OnQueryCancel() )
        {
            return FALSE;
        }
    }

    return CPropertyPage::OnQueryCancel();
}

/////////////////////////////////////////////////////////////////////
BOOL CPoolCntPage::OnApply() 
{
    // refuse to apply 
    // (we don't use the standard PropertSheet buttons; Apply, OK)
    return FALSE;
}

/////////////////////////////////////////////////////////////////////
void CPoolCntPage::OnCountManualRadio() 
{
    // switch to manual refresh
    m_nUpdateIntervalIndex = 0;
    OnRefreshTimerChanged();
}

void CPoolCntPage::OnCountHspeedRadio() 
{
    // switch to high speed refresh
    m_nUpdateIntervalIndex = 1;
    OnRefreshTimerChanged();
}

void CPoolCntPage::OnCountNormRadio() 
{
    // switch to normal speed refresh
    m_nUpdateIntervalIndex = 2;
    OnRefreshTimerChanged();
}

void CPoolCntPage::OnCountLowRadio() 
{
    // switch to low speed refresh
    m_nUpdateIntervalIndex = 3;
    OnRefreshTimerChanged();
}

/////////////////////////////////////////////////////////////////////
void CPoolCntPage::OnDriversNameSelChanged() 
{
	int nCrtSelItem;
    int nIndexInArray;
    BOOL bAllCountersZero;

    bAllCountersZero = TRUE;

    nCrtSelItem = m_DrvNamesCombo.GetCurSel();

    if( nCrtSelItem >= 0 && nCrtSelItem < (int)m_KrnVerifState.DriverCount )
    {
        nIndexInArray = (int)m_DrvNamesCombo.GetItemData( nCrtSelItem );

        if( nIndexInArray >= 0 && nIndexInArray < (int)m_KrnVerifState.DriverCount )
        {
            bAllCountersZero = FALSE;

            // CurrentPagedPoolAllocations
            GetStringFromULONG( m_strCrtPPAlloc, 
                m_KrnVerifState.DriverInfo[ nIndexInArray ].CurrentPagedPoolAllocations );

            // CurrentNonPagedPoolAllocations
            GetStringFromULONG( m_strCrtNPAlloc, 
                m_KrnVerifState.DriverInfo[ nIndexInArray ].CurrentNonPagedPoolAllocations );

            // PeakPagedPoolAllocations
            GetStringFromULONG( m_strPeakPPAlloc, 
                m_KrnVerifState.DriverInfo[ nIndexInArray ].PeakPagedPoolAllocations );

            // PeakNonPagedPoolAllocations
            GetStringFromULONG( m_strPeakNPPAlloc, 
                m_KrnVerifState.DriverInfo[ nIndexInArray ].PeakNonPagedPoolAllocations );

            // PagedPoolUsageInBytes
            GetStringFromULONG( m_strCrtPPBytes, 
                m_KrnVerifState.DriverInfo[ nIndexInArray ].PagedPoolUsageInBytes );

            // NonPagedPoolUsageInBytes
            GetStringFromULONG( m_strCrtNPBytes, 
                m_KrnVerifState.DriverInfo[ nIndexInArray ].NonPagedPoolUsageInBytes );

            // PeakPagedPoolUsageInBytes
            GetStringFromULONG( m_strPeakPPBytes, 
                m_KrnVerifState.DriverInfo[ nIndexInArray ].PeakPagedPoolUsageInBytes );

            // PeakNonPagedPoolUsageInBytes
            GetStringFromULONG( m_strPeakNPPBytes, 
                m_KrnVerifState.DriverInfo[ nIndexInArray ].PeakNonPagedPoolUsageInBytes );
        }
        else
        {
            ASSERT( FALSE );
        }
    }

    if( bAllCountersZero )
    {
        // CurrentPagedPoolAllocations
        VERIFY( m_strCrtPPAlloc.LoadString( IDS_ZERO ) );

        // CurrentNonPagedPoolAllocations
        VERIFY( m_strCrtNPAlloc.LoadString( IDS_ZERO ) );

        // PeakPagedPoolAllocations
        VERIFY( m_strPeakPPAlloc.LoadString( IDS_ZERO ) );

        // PeakNonPagedPoolAllocations
        VERIFY( m_strPeakNPPAlloc.LoadString( IDS_ZERO ) );

        // PagedPoolUsageInBytes
        VERIFY( m_strCrtPPBytes.LoadString( IDS_ZERO ) );

        // NonPagedPoolUsageInBytes
        VERIFY( m_strCrtNPBytes.LoadString( IDS_ZERO ) );

        // PeakPagedPoolUsageInBytes
        VERIFY( m_strPeakPPBytes.LoadString( IDS_ZERO ) );

        // PeakNonPagedPoolUsageInBytes
        VERIFY( m_strPeakNPPBytes.LoadString( IDS_ZERO ) );
    }

    //
    // set the text in edit controls
    //
	
    SetDlgItemText( IDC_POOLCNT_CRT_NPPOOL_ALLOC_EDIT, m_strCrtNPAlloc);
	SetDlgItemText( IDC_POOLCNT_CRT_NPPOOL_BYTES_EDIT, m_strCrtNPBytes);
	SetDlgItemText( IDC_POOLCNT_CRT_PPOOL_ALLOC_EDIT, m_strCrtPPAlloc);
	SetDlgItemText( IDC_POOLCNT_CRT_PPOOL_BYTES_EDIT, m_strCrtPPBytes);
	SetDlgItemText( IDC_POOLCNT_PEAK_NPPOOL_ALLOC_EDIT, m_strPeakNPPAlloc);
	SetDlgItemText( IDC_POOLCNT_PEAK_NPPOOL_BYTES_EDIT, m_strPeakNPPBytes);
	SetDlgItemText( IDC_POOLCNT_PEAK_PPOOL_ALLOC_EDIT, m_strPeakPPAlloc);
	SetDlgItemText( IDC_POOLCNT_PEAK_PPOOL_BYTES_EDIT, m_strPeakPPBytes);
}

/////////////////////////////////////////////////////////////////////
// operations

void CPoolCntPage::GetCurrentSelDriverName( 
    TCHAR *szCrtDriverName,
    int nBufferLength )
{
    int nCrtSel;
    int nNameLength;
    int nDriverEntryIndex;

    if( nBufferLength < 1 )
    {
        ASSERT( FALSE );
        return;
    }

    szCrtDriverName[ 0 ] = (TCHAR)0;

    nCrtSel = m_DrvNamesCombo.GetCurSel();
    
    if( nCrtSel != CB_ERR && nCrtSel < (int)m_KrnVerifState.DriverCount )
    {
        nDriverEntryIndex = (int)m_DrvNamesCombo.GetItemData( nCrtSel );

        if( nDriverEntryIndex >= 0 && nDriverEntryIndex < (int)m_KrnVerifState.DriverCount )
        {
            nNameLength = _tcslen( m_KrnVerifState.DriverInfo[ nDriverEntryIndex ].Name );

            if( nNameLength < nBufferLength )
            {
                _tcscpy( szCrtDriverName, m_KrnVerifState.DriverInfo[ nDriverEntryIndex ].Name );
            }
        }
        else
        {
            ASSERT( FALSE );
        }
    }
}

/////////////////////////////////////////////////////////////////////
void CPoolCntPage::FillDriversNameCombo(
    TCHAR *strNameToSelect )
{
    BOOL *pbAlreadyInCombo;
    CString strDriverName;
    UINT uCrtVerifiedDriver;
    int nCrtItemIndex;
    int nCrtSelectedItem;
    int nComboItemCount;
    int nActualIndex;

    nCrtSelectedItem = 0;

    if( m_KrnVerifState.DriverCount > 0 )
    {
        //
        // allocate a logical value for each currently verified driver 
        // with initial value FALSE
        //

        pbAlreadyInCombo = new BOOL[ m_KrnVerifState.DriverCount ];
    
        if( pbAlreadyInCombo == NULL )
        {
            m_DrvNamesCombo.ResetContent();
            return;
        }

        for( uCrtVerifiedDriver = 0; uCrtVerifiedDriver < m_KrnVerifState.DriverCount; uCrtVerifiedDriver++ )
        {
            pbAlreadyInCombo[ uCrtVerifiedDriver ] = FALSE;
        }

        //
        // parse each name currently in combo
        //

        nComboItemCount = m_DrvNamesCombo.GetCount();

        for( nCrtItemIndex = 0; nCrtItemIndex < nComboItemCount; nCrtItemIndex++ )
        {
            m_DrvNamesCombo.GetLBText( nCrtItemIndex, strDriverName );

            //
            // parse the driver names in m_KrnVerifState and see if we have a match
            //

            for( uCrtVerifiedDriver = 0; uCrtVerifiedDriver < m_KrnVerifState.DriverCount; uCrtVerifiedDriver++ )
            {
                if( _tcsicmp( (LPCTSTR)strDriverName, m_KrnVerifState.DriverInfo[ uCrtVerifiedDriver ].Name ) == 0 )
                {
                    //
                    // it's still verified
                    //

                    pbAlreadyInCombo[ uCrtVerifiedDriver ] = TRUE;

                    //
                    // update the index in m_KrnVerifState.DriverInfo array
                    //

                    m_DrvNamesCombo.SetItemData( nCrtItemIndex, uCrtVerifiedDriver );
                    
                    break;
                }
            }

            if( uCrtVerifiedDriver >= m_KrnVerifState.DriverCount )
            {
                //
                // this driver is no longer verified, remove it from the list
                //

                m_DrvNamesCombo.DeleteString( nCrtItemIndex );

                nCrtItemIndex--;
                nComboItemCount--;
            }
        }

        //
        // add the new verified drivers
        //

        for( uCrtVerifiedDriver = 0; uCrtVerifiedDriver < m_KrnVerifState.DriverCount; uCrtVerifiedDriver++ )
        {
            if( pbAlreadyInCombo[ uCrtVerifiedDriver ] == FALSE )
            {
                nActualIndex = m_DrvNamesCombo.AddString( m_KrnVerifState.DriverInfo[ uCrtVerifiedDriver ].Name );

                if( nActualIndex != CB_ERR )
                {   
                    m_DrvNamesCombo.SetItemData( nActualIndex, uCrtVerifiedDriver );
                }   
            }
        }

        ASSERT( m_DrvNamesCombo.GetCount() == m_KrnVerifState.DriverCount );

        //
        // current selection
        //

        nComboItemCount = m_DrvNamesCombo.GetCount();

        for( nCrtItemIndex = 0; nCrtItemIndex < nComboItemCount; nCrtItemIndex++ )
        {
            m_DrvNamesCombo.GetLBText( nCrtItemIndex, strDriverName );

            if( _tcsicmp( (LPCTSTR)strDriverName, strNameToSelect ) == 0 )
            {
                nCrtSelectedItem = nCrtItemIndex;
                break;
            }
        }

        delete pbAlreadyInCombo;
    }
    else
    {
        m_DrvNamesCombo.ResetContent();
    }

    m_DrvNamesCombo.SetCurSel( nCrtSelectedItem );
}

/////////////////////////////////////////////////////////////
LONG CPoolCntPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        VERIFIER_HELP_FILE,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////
LONG CPoolCntPage::OnContextMenu( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;

    ::WinHelp( 
        (HWND) wParam,
        VERIFIER_HELP_FILE,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\win2k\makefile.inc ===
!IF "$(BUILD_ALT_DIR)" == "d"
VERIFIER_BIN_DIR=binD
!ELSE
VERIFIER_BIN_DIR=bin
!ENDIF

copyexe:
    if exist $(_OBJ_DIR)\i386\*.exe copy $(_OBJ_DIR)\i386\*.exe ..\$(VERIFIER_BIN_DIR)\i386
    if exist $(_OBJ_DIR)\i386\*.dll copy $(_OBJ_DIR)\i386\*.exe ..\$(VERIFIER_BIN_DIR)\i386
    if exist $(_OBJ_DIR)\Alpha\*.exe copy $(_OBJ_DIR)\Alpha\*.exe ..\$(VERIFIER_BIN_DIR)\alpha
    if exist $(_OBJ_DIR)\Alpha\*.dll copy $(_OBJ_DIR)\Alpha\*.exe ..\$(VERIFIER_BIN_DIR)\alpha
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\win2k\drvvctrl.cxx ===
//
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//

//
// module: DrvVCtrl.cxx
// author: DMihai
// created: 01/04/98
//
// Description:
//
//      Defines the class behaviors for the application..
//


#include "stdafx.h"
#include "DrvVCtrl.hxx"

#include "DrvCSht.hxx"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


static BOOL IsBuildNumberAcceptable()
{
    if( g_OsVersion.dwMajorVersion < 5 || g_OsVersion.dwBuildNumber < 1954 )
    {
        ::AfxMessageBox( IDS_BUILD_WARN,
            MB_OK | MB_ICONSTOP );
        return FALSE;
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CDrvVCtrlApp

BEGIN_MESSAGE_MAP(CDrvVCtrlApp, CWinApp)
    //{{AFX_MSG_MAP(CDrvVCtrlApp)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG
    ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDrvVCtrlApp construction

CDrvVCtrlApp::CDrvVCtrlApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance

    CString strAppName;

    if( strAppName.LoadString( IDS_APPTITLE ) )
    {
        m_pszAppName = _tcsdup( (LPCTSTR)strAppName );
    }
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CDrvVCtrlApp object

CDrvVCtrlApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CDrvVCtrlApp initialization

BOOL CDrvVCtrlApp::InitInstance()
{
    DWORD dwExitCode;

    //
    // Get the OS version and build nuber
    //

    ZeroMemory (&g_OsVersion, sizeof g_OsVersion);
    g_OsVersion.dwOSVersionInfoSize = sizeof g_OsVersion;
    GetVersionEx (&g_OsVersion);

    //
    // check for command line arguments
    //

    if( __argc > 1 )
    {
        //
        // run just in command line mode
        //

        dwExitCode = VrfExecuteCommandLine( __argc, __targv );
        exit( dwExitCode );
    }
    else
    {
        FreeConsole();

        //
        // check if the build # is acceptable
        //

        if( ! ::IsBuildNumberAcceptable() )
        {
            return FALSE;
        }
    }

    AfxEnableControlContainer();

    //
    // There is only one property sheet in this program so
    // we declare it static. It is embedding very big KRN_VERIFIER_STATE and
    // VRF_VERIFIER_STATE structures so we don't want them pushed on the stack
    //
    
    static CDrvChkSheet dlg;

    //
    // show the dialog
    //

    m_pMainWnd = &dlg;
    dlg.DoModal();

    //
    // all done, exit the application
    //
    
    if( g_bSettingsSaved )
    {
        exit( EXIT_CODE_REBOOT_NEEDED );
    }
    else
    {
        exit( EXIT_CODE_SUCCESS );
    }

    //
    // not reached
    // 
    
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\win2k\image.cxx ===
//
// Driver Verifier Control Applet
// Copyright (c) Microsoft Corporation, 1999
//

//
// module: image.cxx
// author: silviuc
// created: Thu Jan 07 20:05:09 1999
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <tchar.h>
#include <windows.h>

#include "image.hxx"
#include "verify.hxx"


//
// Function:
//
//     ImgInitializeBrowseInfo
//
// Description:
//
//     This functions fills oout the `Info' structure with
//     various pointers to PE data from the mapped image file.
//
//     Note. Even if the function returned false the destructor
//     `ImgDeleteBrowseInfo' should be called because it does some
//     cleanup.
//
// Return:
//
//     True if all the PE data pointers have been obtained.
//

BOOL
ImgInitializeBrowseInfo (

    LPCTSTR FilePath,
    PIMAGE_BROWSE_INFO Info)
{
    DWORD Index;

    if (Info == NULL) {
        return FALSE;
    }

    ZeroMemory (Info, sizeof *Info);

    Info->File = CreateFile (

        FilePath,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if (Info->File == INVALID_HANDLE_VALUE) {

      return FALSE;
    }

    Info->Section = CreateFileMapping (

        Info->File,
        NULL,
        PAGE_READONLY,
        0,
        0,
        NULL);

    if (Info->Section == NULL) {

      return FALSE;
    }

    Info->ImageBase = (LPBYTE) MapViewOfFile (

        Info->Section,
        FILE_MAP_READ,
        0,
        0,
        0);

    if (Info->ImageBase == NULL) {

      return FALSE;
    }

    //
    // Check the signature
    //

    Info->DosHeader = (PIMAGE_DOS_HEADER)Info->ImageBase;

    if (Info->DosHeader->e_magic != 'ZM') {

      return FALSE;
    }

    Info->FileHeader = (PIMAGE_FILE_HEADER)
        (Info->ImageBase + Info->DosHeader->e_lfanew + sizeof(DWORD));

    Info->FileSignature = *((DWORD *)Info->FileHeader - 1);

    if (Info->FileSignature != IMAGE_NT_SIGNATURE) {

      return FALSE;
    }


    Info->OptionalHeader = (PIMAGE_OPTIONAL_HEADER)(Info->FileHeader + 1);
    Info->ImportDirectory = & (Info->OptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]);
    Info->SectionHeader = (PIMAGE_SECTION_HEADER)(Info->OptionalHeader + 1);
    Info->ImportSection = NULL;

    //
    // Find the section containing the import table
    //

    for (Index = 0; Index < Info->FileHeader->NumberOfSections; Index++) {

        DWORD Start = (Info->SectionHeader + Index)->VirtualAddress;
        DWORD Size =  (Info->SectionHeader + Index)->SizeOfRawData;
        DWORD Import = Info->ImportDirectory->VirtualAddress;

        if (Start <= Import && Start + Size > Import) {

            Info->ImportSection = &(Info->SectionHeader[Index]);
            break;
        }
    }

    if (Info->ImportSection == NULL) {

        return FALSE;
    }

    //
    // Find the address of import data in the section body.
    //

    Info->AddressCorrection = (DWORD_PTR)Info->ImageBase 
        + Info->ImportSection->PointerToRawData
        - Info->ImportSection->VirtualAddress;

    Info->ImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)(Info->AddressCorrection
         + Info->ImportDirectory->VirtualAddress);

    //
    // Finish
    //

    return TRUE;
}


//
// Function:
//
//     ImgDeleteBrowseInfo
//
// Description:
//
//     This function cleans up the `Info' structure, unmaps views, 
//     closes handles, etc.
//

BOOL
ImgDeleteBrowseInfo (

    PIMAGE_BROWSE_INFO Info)
{
    if (Info == NULL)
        return FALSE;

    UnmapViewOfFile (Info->ImageBase);
    CloseHandle (Info->Section);
    CloseHandle (Info->File);

    ZeroMemory (Info, sizeof *Info);

    return TRUE;
}


//
// Function:
//
//     ImgSearchDriverName
//
// Description:
//
//     This function checks if a driver is in `system32' or
//     `drivers\system32' directory. If it is then the full
//     path to the driver is written in `DriverPath'.
//
// Return:
//
//     True if driver found in system 32 or system32\drivers.
//

BOOL
ImgSearchDriverImage (

    LPCTSTR DriverName,
    LPTSTR DriverPath,
    UINT DriverPathBufferLength )
{
    HANDLE File;
    UINT SysDirPathLength;

    if (DriverName == NULL)
        return FALSE;

    //
    // Search in `system32\drivers'
    //

    SysDirPathLength = GetSystemDirectory (DriverPath, DriverPathBufferLength );

    if( 0 == SysDirPathLength || SysDirPathLength > DriverPathBufferLength ) {

        //
        // Bad luck - we couldn't read the %windir%\system32 value
        //

        return FALSE;
    }

    _tcscat (DriverPath, TEXT("\\drivers\\"));
    _tcscat (DriverPath, DriverName);

    File = CreateFile (

        DriverPath,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if (File != INVALID_HANDLE_VALUE) {

      CloseHandle (File);
      return TRUE;
    }

    //
    // Search in `system32'
    //

    GetSystemDirectory (DriverPath, MAX_PATH);
    _tcscat (DriverPath, TEXT("\\"));
    _tcscat (DriverPath, DriverName);

    File = CreateFile (

        DriverPath,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if (File != INVALID_HANDLE_VALUE) {

      CloseHandle (File);
      return TRUE;
    }

    //
    // Nothing found.
    //

    return FALSE;
}



//
// end of module: image.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vi\ascii.h ===
/* $Header: /nw/tony/src/stevie/src/RCS/ascii.h,v 1.2 89/03/11 22:42:03 tony Exp $
 *
 * Definitions of various common control characters
 */

#define NUL     '\0'
#define BS      '\010'
#define TAB     '\011'
#define NL      '\012'
#define CR      '\015'
#define ESC     '\033'

#define CTRL(x) ((x) & 0x1f)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\win2k\stdafx.cxx ===
// stdafx.cpp : source file that includes just the standard includes
//	DrvVCtrl.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vi\alloc.c ===
/*
 * Various allocation routines and routines returning information about
 * allocated objects.
 */

#include "stevie.h"

char *
alloc(size)
unsigned size;
{
        char    *p;             /* pointer to new storage space */

        p = malloc(size);
        if ( p == (char *)NULL ) {      /* if there is no more room... */
                emsg("Insufficient memory");
        }
        return(p);
}

char *
ralloc(char *block,unsigned newsize)
{
    char *p;

    if((p = realloc(block,newsize)) == NULL) {
        emsg("Insufficient memory");
    }
    return(p);
}

char *
strsave(string)
char    *string;
{
        return(strcpy(alloc((unsigned)(strlen(string)+1)),string));
}

void
screenalloc()
{
        /*
         * If we're changing the size of the screen, free the old arrays
         */
        if (Realscreen != NULL)
                free(Realscreen);
        if (Nextscreen != NULL)
                free(Nextscreen);

        Realscreen = malloc((unsigned)(Rows*Columns));
        Nextscreen = malloc((unsigned)(Rows*Columns));
}

/*
 * Allocate and initialize a new line structure with room for
 * 'nchars'+1 characters. We add one to nchars here to allow for
 * null termination because all the callers would just do it otherwise.
 */
LINE *
newline(nchars)
int     nchars;
{
        register LINE   *l;

        if ((l = (LINE *) alloc(sizeof(LINE))) == NULL)
                return (LINE *) NULL;

        l->s = alloc((unsigned) (nchars+1));    /* the line is empty */
        l->s[0] = NUL;
        l->size = nchars + 1;

        l->prev = (LINE *) NULL;        /* should be initialized by caller */
        l->next = (LINE *) NULL;

        return l;
}

/*
 * filealloc() - construct an initial empty file buffer
 */
void
filealloc()
{
        if ((Filemem->linep = newline(0)) == NULL) {
                fprintf(stderr,"Unable to allocate file memory!\n");
                exit(1);
        }
        if ((Filetop->linep = newline(0)) == NULL) {
                fprintf(stderr,"Unable to allocate file memory!\n");
                exit(1);
        }
        if ((Fileend->linep = newline(0)) == NULL) {
                fprintf(stderr,"Unable to allocate file memory!\n");
                exit(1);
        }
        Filemem->index = 0;
        Filetop->index = 0;
        Fileend->index = 0;

        Filetop->linep->next = Filemem->linep;  /* connect Filetop to Filemem */
        Filemem->linep->prev = Filetop->linep;

        Filemem->linep->next = Fileend->linep;  /* connect Filemem to Fileend */
        Fileend->linep->prev = Filemem->linep;

        *Curschar = *Filemem;
        *Topchar  = *Filemem;

        Filemem->linep->num = 0;
        Fileend->linep->num = 0xffff;

        clrall();               /* clear all marks */
        u_clear();              /* clear the undo buffer */
}

/*
 * freeall() - free the current buffer
 *
 * Free all lines in the current buffer.
 */
void
freeall()
{
        register LINE   *lp, *xlp;

        for (lp = Filetop->linep; lp != NULL ;lp = xlp) {
                if (lp->s != NULL)
                        free(lp->s);
                xlp = lp->next;
                free((char *)lp);
        }

        Curschar->linep = NULL;         /* clear pointers */
        Filetop->linep = NULL;
        Filemem->linep = NULL;
        Fileend->linep = NULL;

        u_clear();
        /* _heapmin(); */
}

/*
 * bufempty() - return TRUE if the buffer is empty
 */
bool_t
bufempty()
{
        return (buf1line() && Filemem->linep->s[0] == NUL);
}

/*
 * buf1line() - return TRUE if there is only one line
 */
bool_t
buf1line()
{
        return (Filemem->linep->next == Fileend->linep);
}

/*
 * lineempty() - return TRUE if the current line is empty
 */
bool_t
lineempty()
{
        return (Curschar->linep->s[0] == NUL);
}

/*
 * endofline() - return TRUE if the given position is at end of line
 *
 * This routine will probably never be called with a position resting
 * on the NUL byte, but handle it correctly in case it happens.
 */
bool_t
endofline(p)
register LNPTR   *p;
{
        return (p->linep->s[p->index] == NUL || p->linep->s[p->index+1] == NUL);
}
/*
 * canincrease(n) - returns TRUE if the current line can be increased 'n' bytes
 *
 * This routine returns immediately if the requested space is available.
 * If not, it attempts to allocate the space and adjust the data structures
 * accordingly. If everything fails it returns FALSE.
 */
bool_t
canincrease(n)
register int    n;
{
        register int    nsize;
        register char   *s;             /* pointer to new space */

        nsize = strlen(Curschar->linep->s) + 1 + n;     /* size required */

        if (nsize <= Curschar->linep->size)
                return TRUE;

        /*
         * Need to allocate more space for the string. Allow some extra
         * space on the assumption that we may need it soon. This avoids
         * excessive numbers of calls to malloc while entering new text.
         */
        if ((s = alloc((unsigned) (nsize + SLOP))) == NULL) {
                emsg("Can't add anything, file is too big!");
                State = NORMAL;
                return FALSE;
        }

        Curschar->linep->size = nsize + SLOP;
        strcpy(s, Curschar->linep->s);
        free(Curschar->linep->s);
        Curschar->linep->s = s;

        return TRUE;
}

char *
mkstr(c)
char    c;
{
        static  char    s[2];

        s[0] = c;
        s[1] = NUL;

        return s;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vi\cmdline.c ===
/* $Header: /nw/tony/src/stevie/src/RCS/cmdline.c,v 1.20 89/08/13 11:41:23 tony Exp $
 *
 * Routines to parse and execute "command line" commands, such as searches
 * or colon commands.
 */

#include "stevie.h"

static  char    *altfile = NULL;        /* alternate file */
static  int     altline;                /* line # in alternate file */

static  char    *nowrtmsg = "No write since last change (use ! to override)";
static  char    *nooutfile = "No output file";
static  char    *morefiles = "more files to edit";

extern  char    **files;                /* used for "n" and "rew" */
extern  int     numfiles, curfile;

#define CMDSZ   100             /* size of the command buffer */

bool_t rangeerr;
static  bool_t	doecmd(char*arg, bool_t force);
static	void   badcmd(void);
static	void get_range(char**cp, LNPTR*lower, LNPTR*upper);
static	LNPTR	*get_line(char**cp);
void   ex_delete(LINE *l,LINE *u);
void   dolist(LINE *l,LINE *u);

extern char    *lastcmd;	/* in dofilter */

/*
 * getcmdln() - read a command line from the terminal
 *
 * Reads a command line started by typing '/', '?', '!', or ':'. Returns a
 * pointer to the string that was read. For searches, an optional trailing
 * '/' or '?' is removed.
 */
char *
getcmdln(firstc)
char    firstc;
{
        static  char    buff[CMDSZ];
        register char   *p = buff;
        register int    c;
        register char   *q;

        gotocmd(TRUE, firstc);

        /* collect the command string, handling '\b' and @ */
        do {
                switch (c = vgetc()) {

                default:                /* a normal character */
                        outchar(c);
                        *p++ = (char)c;
                        break;

                case BS:
                        if (p > buff) {
                                /*
                                 * this is gross, but it relies
                                 * only on 'gotocmd'
                                 */
                                p--;
                                gotocmd(TRUE, firstc);
                                for (q = buff; q < p ;q++)
                                        outchar(*q);
                        } else {
                                msg("");
                                return NULL;            /* back to cmd mode */
                        }
                        break;
#if 0
                case '@':                       /* line kill */
                        p = buff;
                        gotocmd(TRUE, firstc);
                        break;
#endif
                case NL:                        /* done reading the line */
                case CR:
                        break;
                }
        } while (c != NL && c != CR);

        *p = '\0';

        if (firstc == '/' || firstc == '?') {   /* did we do a search? */
                /*
                 * Look for a terminating '/' or '?'. This will be the first
                 * one that isn't quoted. Truncate the search string there.
                 */
                for (p = buff; *p ;) {
                        if (*p == firstc) {     /* we're done */
                                *p = '\0';
                                break;
                        } else if (*p == '\\')  /* next char quoted */
                                p += 2;
                        else
                                p++;            /* normal char */
                }
        }
        return buff;
}

/*
 * docmdln() - handle a colon command
 *
 * Handles a colon command received interactively by getcmdln() or from
 * the environment variable "EXINIT" (or eventually .virc).
 */
void
docmdln(cmdline)
char    *cmdline;
{
        char    buff[CMDSZ];
        char    cmdbuf[CMDSZ];
        char    argbuf[CMDSZ];
        char    *cmd, *arg;
        register char   *p;
        /*
         * The next two variables contain the bounds of any range given in a
         * command. If no range was given, both contain null line pointers.
         * If only a single line was given, u_pos will contain a null line
         * pointer.
         */
        LNPTR    l_pos, u_pos;


        /*
         * Clear the range variables.
         */
        l_pos.linep = (struct line *) NULL;
        u_pos.linep = (struct line *) NULL;

        if (cmdline == NULL)
                return;

        if (strlen(cmdline) > CMDSZ-2) {
                msg("Error: command line too long");
                return;
        }
        strcpy(buff, cmdline);

        /* skip any initial white space */
        for (cmd = buff; *cmd != NUL && isspace(*cmd) ;cmd++)
                ;

        if (*cmd == '%') {              /* change '%' to "1,$" */
                strcpy(cmdbuf, "1,$");  /* kind of gross... */
                strcat(cmdbuf, cmd+1);
                strcpy(cmd, cmdbuf);
        }

        while ((p=strchr(cmd, '%')) != NULL && *(p-1) != '\\') {
                                        /* change '%' to Filename */
                if (Filename == NULL) {
                        emsg("No filename");
                        return;
                }
                *p= NUL;
                strcpy (cmdbuf, cmd);
                strcat (cmdbuf, Filename);
                strcat (cmdbuf, p+1);
                strcpy(cmd, cmdbuf);
                msg(cmd);                       /*repeat */
        }

        while ((p=strchr(cmd, '#')) != NULL && *(p-1) != '\\') {
                                        /* change '#' to Altname */
                if (altfile == NULL) {
                        emsg("No alternate file");
                        return;
                }
                *p= NUL;
                strcpy (cmdbuf, cmd);
                strcat (cmdbuf, altfile);
                strcat (cmdbuf, p+1);
                strcpy(cmd, cmdbuf);
                msg(cmd);                       /*repeat */
        }

        /*
         * Parse a range, if present (and update the cmd pointer).
         */
        rangeerr = FALSE;
        get_range(&cmd, &l_pos, &u_pos);
        if(rangeerr) {
            return;
        }

        if (l_pos.linep != NULL) {
                if (LINEOF(&l_pos) > LINEOF(&u_pos)) {
                        emsg("Invalid range");
                        return;
                }
        }

        strcpy(cmdbuf, cmd);    /* save the unmodified command */

        /* isolate the command and find any argument */
        for ( p=cmd; *p != NUL && ! isspace(*p); p++ )
                ;
        if ( *p == NUL )
                arg = NULL;
        else {
                *p = NUL;
                for (p++; *p != NUL && isspace(*p) ;p++)
                        ;
                if (*p == NUL)
                        arg = NULL;
                else {
                        strcpy(argbuf, p);
                        arg = argbuf;
                }
        }
        if (strcmp(cmd,"q!") == 0)
                getout();
        if (strcmp(cmd,"q") == 0) {
                if (Changed)
                        emsg(nowrtmsg);
                else {
                        if ((curfile + 1) < numfiles)
                                emsg(morefiles);
                        else
                                getout();
                }
                return;
        }
        if ((strcmp(cmd,"w") == 0) ||
            (strcmp(cmd,"w!") == 0)) {
                if (arg == NULL) {
                        if (Filename != NULL) {
                                writeit(Filename, &l_pos, &u_pos);
                        } else
                                emsg(nooutfile);
                }
                else {
                        if (altfile)
                                free(altfile);
                        altfile = strsave(arg);
                        writeit(arg, &l_pos, &u_pos);
                }
                return;
        }
        if (strcmp(cmd,"wq") == 0) {
                if (Filename != NULL) {
                        if (writeit(Filename, (LNPTR *)NULL, (LNPTR *)NULL))
                                getout();
                } else
                        emsg(nooutfile);
                return;
        }
        if (strcmp(cmd, "x") == 0) {
                doxit();
                return;
        }

        if (strcmp(cmd,"f") == 0 && arg == NULL) {
                fileinfo();
                return;
        }
        if (*cmd == 'n') {
                if ((curfile + 1) < numfiles) {
                        /*
                         * stuff ":e[!] FILE\n"
                         */
                        stuffin(":e");
                        if (cmd[1] == '!')
                                stuffin("!");
                        stuffin(" ");
                        stuffin(files[++curfile]);
                        stuffin("\n");
                } else
                        emsg("No more files!");
                return;
        }
        if (*cmd == 'N') {
                if (curfile > 0) {
                        /*
                         * stuff ":e[!] FILE\n"
                         */
                        stuffin(":e");
                        if (cmd[1] == '!')
                                stuffin("!");
                        stuffin(" ");
                        stuffin(files[--curfile]);
                        stuffin("\n");
                } else
                        emsg("No more files!");
                return;
        }
        if(*cmd == 'l' || !strncmp(cmd,"li",2)) {
            if(arg != NULL) {
                msg("extra characters at end of \"list\" command");
            } else {
                dolist(l_pos.linep,u_pos.linep);
            }
            return;
        }
        if (strncmp(cmd, "rew", 3) == 0) {
                if (numfiles <= 1)              /* nothing to rewind */
                        return;
                curfile = 0;
                /*
                 * stuff ":e[!] FILE\n"
                 */
                stuffin(":e");
                if (cmd[3] == '!')
                        stuffin("!");
                stuffin(" ");
                stuffin(files[0]);
                stuffin("\n");
                return;
        }
        if (strcmp(cmd,"e") == 0 || strcmp(cmd,"e!") == 0) {
                (void) doecmd(arg, cmd[1] == '!');
                return;
        }
        /*
         * The command ":e#" gets expanded to something like ":efile", so
         * detect that case here.
         */
        if (*cmd == 'e' && arg == NULL) {
                if (cmd[1] == '!')
                        (void) doecmd(&cmd[2], TRUE);
                else
                        (void) doecmd(&cmd[1], FALSE);
                return;
        }
        if (strcmp(cmd,"f") == 0) {
                Filename = strsave(arg);
                setviconsoletitle();
                filemess("");
                return;
        }
        if (strcmp(cmd,"r") == 0) {
                if (arg == NULL) {
                        badcmd();
                        return;
                }
                if (readfile(arg, Curschar, 1)) {
                        emsg("Can't open file");
                        return;
                }
                updatescreen();
                CHANGED;
                return;
        }
        if (*cmd == 'd') {
            if(arg != NULL) {
                msg("extra characters at end of \"delete\" command");
            } else {
                ex_delete(l_pos.linep,u_pos.linep);
            }
            return;
        }
        if (strcmp(cmd,"=") == 0) {
                smsg("%d", cntllines(Filemem, &l_pos));
                return;
        }
        if (strncmp(cmd,"ta", 2) == 0) {
                dotag(arg, cmd[2] == '!');
                return;
        }
        if (strncmp(cmd,"set", 2) == 0) {
                doset(arg);
                return;
        }
        if (strcmp(cmd,"help") == 0) {
                if (help()) {
                        screenclear();
                        updatescreen();
                }
                return;
        }
        if (strncmp(cmd, "ve", 2) == 0) {
                extern  char    *Version;

                msg(Version);
                return;
        }
        if (strcmp(cmd, "sh") == 0) {
                doshell(NULL, FALSE);
                return;
        }
        if (strcmp(cmd, "source") == 0 ||
            strcmp(cmd, "so") == 0) {
                if(l_pos.linep != NULL) {
                    emsg("No range allowed on this command");
                } else {
                    dosource(arg,TRUE);
                }
                return;
        }
        if (*cmd == '!' || *cmd == '@') {
                if (*(cmd+1) == *cmd) {
	                if (lastcmd == (char*)NULL) {
	                        emsg("No previous command");
	                        return;
	                }
	                msg(lastcmd);
	                doshell(lastcmd, *cmd == '@');
                }
                else {
	                doshell(cmdbuf+1, *cmd == '@');
	                if (lastcmd == (char*)NULL)
	                	lastcmd = (char*)alloc(CMDSZ);
	                strcpy(lastcmd, cmdbuf+1);
                }
                return;
        }
        if (strncmp(cmd, "s/", 2) == 0) {
                dosub(&l_pos, &u_pos, cmdbuf+1);
                return;
        }
        if (strncmp(cmd, "g/", 2) == 0) {
                doglob(&l_pos, &u_pos, cmdbuf+1);
                return;
        }
        if (strcmp(cmd, "cd") == 0) {
                dochdir(arg);
                return;
        }
        /*
         * If we got a line, but no command, then go to the line.
         */
        if (*cmd == NUL && l_pos.linep != NULL) {
                *Curschar = l_pos;
                return;
        }

        badcmd();
}


void doxit()
{
        if (Changed) {
                if (Filename != NULL) {
                        if (!writeit(Filename, (LNPTR *)NULL, (LNPTR *)NULL))
                                return;
                } else {
                        emsg(nooutfile);
                        return;
                }
        }
        if ((curfile + 1) < numfiles)
                emsg(morefiles);
        else
                getout();
}

void dosource(char *arg,bool_t giveerror)
{
    FILE *f;
    char string[256];

    if(arg == NULL) {
        emsg("No filename given");
        return;
    }
    if((f = fopen(arg,"r")) == NULL) {
        if(giveerror) {
            emsg("No such file or error opening file");
        }
    } else {
        while(fgets(string,sizeof(string),f) != NULL) {
            docmdln(string);
        }
    }
}

void ex_delete(LINE *l,LINE *u)
{
    int ndone = 0;
    LINE *cp;
    LINE *np;
    LNPTR savep;

    if (l == NULL) {                // no address?  use current line.
        l = u = Curschar->linep;
    }

    u_save(l->prev,u->next);        // save for undo

    for(cp = l; cp != NULL && !got_int; cp = np) {
        np = cp->next;              // set next before we delete the line
        if(Curschar->linep != cp) {
            savep = *Curschar;
            Curschar->linep = cp;
            Curschar->index = 0;
            delline(1,FALSE);
            *Curschar = savep;
        } else {
            delline(1,FALSE);
        }
        ndone++;
        if(cp == u) {
            break;
        }
    }
    updatescreen();
    if((ndone >= P(P_RP)) || got_int) {
        smsg("%s%d fewer line%c",
             got_int ? "Interrupt: " : "",
             ndone,
             ndone == 1 ? ' ' : 's');
    }
}

void dolist(LINE *l,LINE *u)
{
    LINE *cp;
    char  ch;
    char *txt;

    if(l == NULL) {
        l = u = Curschar->linep;
    }

    puts("");         // scroll one line

    for(cp = l; cp != NULL && !got_int; cp = cp->next) {

        for(txt = cp->s,ch = *txt; ch; ch = *(++txt)) {

            if(chars[ch].ch_size > 1) {
                outstr(chars[ch].ch_str);
            } else {
                outchar(ch);
            }
        }
        outstr("$\n");
        if(cp == u) {
            break;
        }
    }
    if(got_int) {
        puts("Interrupt");
    }
    wait_return();
}

/*
 * get_range - parse a range specifier
 *
 * Ranges are of the form:
 *
 * addr[,addr]
 *
 * where 'addr' is:
 *
 * $  [+- NUM]
 * 'x [+- NUM]  (where x denotes a currently defined mark)
 * .  [+- NUM]
 * NUM
 *
 * The pointer *cp is updated to point to the first character following
 * the range spec. If an initial address is found, but no second, the
 * upper bound is equal to the lower.
 */
static void
get_range(cp, lower, upper)
register char   **cp;
LNPTR    *lower, *upper;
{
        register LNPTR   *l;
        register char   *p;

        if ((l = get_line(cp)) == NULL)
                return;

        *lower = *l;

        for (p = *cp; *p != NUL && isspace(*p) ;p++)
                ;

        *cp = p;

        if (*p != ',') {                /* is there another line spec ? */
                *upper = *lower;
                return;
        }

        *cp = ++p;

        if ((l = get_line(cp)) == NULL) {
                *upper = *lower;
                return;
        }

        *upper = *l;
}

static LNPTR *
get_line(cp)
char    **cp;
{
        static  LNPTR    pos;
        LNPTR    *lp;
        register char   *p, c;
        register int    lnum;

        pos.index = 0;          /* shouldn't matter... check back later */

        p = *cp;
        /*
         * Determine the basic form, if present.
         */
        switch (c = *p++) {

        case '$':
                pos.linep = Fileend->linep->prev;
                break;

        case '.':
                pos.linep = Curschar->linep;
                break;

        case '\'':
                if ((lp = getmark(*p++)) == NULL) {
                        emsg("Unknown mark");
                        rangeerr = TRUE;
                        return (LNPTR *) NULL;
                }
                pos = *lp;
                break;

        case '0': case '1': case '2': case '3': case '4':
        case '5': case '6': case '7': case '8': case '9':
                for (lnum = c - '0'; isdigit(*p) ;p++)
                        lnum = (lnum * 10) + (*p - '0');

                pos = *gotoline(lnum);
                break;

        default:
                return (LNPTR *) NULL;
        }

        while (*p != NUL && isspace(*p))
                p++;

        if (*p == '-' || *p == '+') {
                bool_t  neg = (*p++ == '-');

                for (lnum = 0; isdigit(*p) ;p++)
                        lnum = (lnum * 10) + (*p - '0');

                if (neg)
                        lnum = -lnum;

                pos = *gotoline( cntllines(Filemem, &pos) + lnum );
        }

        *cp = p;
        return &pos;
}

static void
badcmd()
{
        emsg("Unrecognized command");
}

#define LSIZE   256     /* max. size of a line in the tags file */

/*
 * dotag(tag, force) - goto tag
 */
void
dotag(tag, force)
char    *tag;
bool_t  force;
{
        FILE    *tp;
        char    lbuf[LSIZE];            /* line buffer */
        char    pbuf[LSIZE];            /* search pattern buffer */
        bool_t  match;
        register char   *fname, *str;
        register char   *p;

        if ((tp = fopen("tags", "r")) == NULL) {
                emsg("Can't open tags file");
                return;
        }

        while (fgets(lbuf, LSIZE, tp) != NULL) {

                if (lbuf[0] == ';') {
			/* Allow comment line. */
			continue;
		}
                if ((fname = strchr(lbuf, TAB)) == NULL) {
                        emsg("Format error in tags file");
                        return;
                }
                *fname++ = '\0';
                if ((str = strchr(fname, TAB)) == NULL) {
                        emsg("Format error in tags file");
                        return;
                }
                *str++ = '\0';

                if (P(P_IC)) {
	                match = _stricmp(lbuf, tag) == 0;
	        } else {
	                match = strcmp(lbuf, tag) == 0;
	        }
                if (match) {

                        /*
                         * Scan through the search string. If we see a magic
                         * char, we have to quote it. This lets us use "real"
                         * implementations of ctags.
                         */
                        p = pbuf;
                        *p++ = *str++;          /* copy the '/' or '?' */
                        *p++ = *str++;          /* copy the '^' */

                        for (; *str != NUL ;str++) {
                                if (*str == '\\') {
                                        *p++ = *str++;
                                        *p++ = *str;
                                } else if (strchr("/?", *str) != NULL) {
                                        if (str[1] != '\n') {
                                                *p++ = '\\';
                                                *p++ = *str;
                                        } else
                                                *p++ = *str;
                                } else if (strchr("^()*.", *str) != NULL) {
                                        *p++ = '\\';
                                        *p++ = *str;
                                } else
                                        *p++ = *str;
                        }
                        *p = NUL;

                        /*
                         * This looks out of order, but by calling stuffin()
                         * before doecmd() we keep an extra screen update
                         * from occuring. This stuffins() have no effect
                         * until we get back to the main loop, anyway.
                         */
                        stuffin(pbuf);          /* str has \n at end */
                        stuffin("\007");        /* CTRL('g') */

                        if (doecmd(fname, force)) {
                                fclose(tp);
                                return;
                        } else
                                stuffin(NULL);  /* clear the input */
                }
        }
        emsg("tag not found");
        fclose(tp);
}

static  bool_t
doecmd(arg, force)
char    *arg;
bool_t  force;
{
        int     line = 1;               /* line # to go to in new file */

        if (!force && Changed) {
                emsg(nowrtmsg);
                if ( arg != NULL ) {
                        if (altfile)
                                free(altfile);
                        altfile = strsave(arg);
                }
                return FALSE;
        }
        if (arg != NULL) {
                /*
                 * First detect a ":e" on the current file. This is mainly
                 * for ":ta" commands where the destination is within the
                 * current file.
                 */
                if (Filename != NULL && strcmp(arg, Filename) == 0) {
                        if (!Changed || (Changed && !force))
                                return TRUE;
                }
                if (altfile) {
                        if (strcmp (arg, altfile) == 0)
                                line = altline;
                        free(altfile);
                }
                altfile = Filename;
                altline = cntllines(Filemem, Curschar);
                Filename = strsave(arg);
        }
        if (Filename == NULL) {
                emsg("No filename");
                return FALSE;
        }

        /* clear mem and read file */
        freeall();
        filealloc();
        UNCHANGED;

        if (readfile(Filename, Filemem, 0))
                filemess("[New File]");
        setviconsoletitle();

        *Topchar = *Curschar;
        if (line != 1) {
                stuffnum(line);
                stuffin("G");
        }
        do_mlines();
        setpcmark();
        updatescreen();
        return TRUE;
}

void
gotocmd(clr, firstc)
bool_t  clr;
char    firstc;
{
        windgoto(Rows-1,0);
        if (clr)
                EraseLine();            /* clear the bottom line */
        if (firstc)
                outchar(firstc);
}

/*
 * msg(s) - displays the string 's' on the status line
 */
void
msg(s)
char    *s;
{
        gotocmd(TRUE, 0);
        outstr(s);
        flushbuf();
}

/*VARARGS1*/
void
smsg(s, a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16)
char    *s;
int     a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16;
{
        char    sbuf[256];   /* Status line, > 80 chars to allow wrap. */

        sprintf(sbuf, s,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16);
        msg(sbuf);
}

/*
 * emsg() - display an error message
 *
 * Rings the bell, if appropriate, and calls message() to do the real work
 */
void
emsg(s)
char    *s;
{
        if (P(P_EB))
                beep();
        msg(s);
}

int
wait_return0()
{
        register char   c;
        if (got_int)
                outstr("Interrupt: ");

        outstr("Press RETURN to continue");

        do {
                c = (char)vgetc();
        } while (c != CR && c != NL && c != ' ' && c != ':');

        return c;
}

void
wait_return()
{
        char c = (char)wait_return0();

        if (c == ':') {
                outchar(NL);
                docmdln(getcmdln(c));
        } else
                screenclear();

        updatescreen();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\win2k\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__94E2C131_A3FC_11D2_98C6_00A0C9A26FFC__INCLUDED_)
#define AFX_STDAFX_H__94E2C131_A3FC_11D2_98C6_00A0C9A26FFC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
// #include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <Afxdlgs.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__94E2C131_A3FC_11D2_98C6_00A0C9A26FFC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\win2k\vsetpage.cxx ===
//                                          
// Driver Verifier UI
// Copyright (c) Microsoft Corporation, 1999
//

//
// module: VSetPage.cxx
// author: DMihai
// created: 07/07/99
//
// Description:
//
//      Volatile settings PropertyPage.

#include "stdafx.h"
#include "drvvctrl.hxx"
#include "VSetPage.hxx"

#include "DrvCSht.hxx"
#include <Cderr.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// timer ID
#define REFRESH_TIMER_ID    0x1324

// manual, high, normal, low speed
#define REFRESH_SPEED_VARS  4

// timer intervals in millisec for manual, high, normal, low speed
static UINT uTimerIntervals[ REFRESH_SPEED_VARS ] =
{
    0,      // Manual
    1000,   // High Speed
    5000,   // Normal Speed
    10000   // Low Speed
};

//
// help IDs
//

static DWORD MyHelpIds[] =
{
    IDC_VSETTINGS_DRIVERS_LIST,         IDH_DV_VolatileTab_driver_details,
    IDC_VSETTINGS_NORMAL_VERIF_CHECK,   IDH_DV_SettingsTab_verifytype_sppool,
    IDC_VSETTINGS_PAGEDC_VERIF_CHECK,   IDH_DV_SettingsTab_verifytype_irql,
    IDC_VSETTINGS_ALLOCF_VERIF_CHECK,   IDH_DV_SettingsTab_verifytype_resource,
    IDC_VSETTINGS_APPLY_BUTTON,         IDH_DV_VolatileTab_Applybut,
    IDC_VSETTINGS_ADD_BUTTON,           IDH_DV_VolatileTab_Addbut,
    IDC_VSETTINGS_DONTVERIFY_BUTTON,    IDH_DV_VolatileTab_Removebut,
    
    IDC_VSETTINGS_REFRESH_BUTTON,     IDH_DV_common_refresh_nowbutton,
    IDC_VSETTINGS_MANUAL_RADIO,       IDH_DV_common_refresh_manual,
    IDC_VSETTINGS_HSPEED_RADIO,       IDH_DV_common_refresh_high,
    IDC_VSETTINGS_NORM_RADIO,         IDH_DV_common_refresh_normal,
    IDC_VSETTINGS_LOW_RADIO,          IDH_DV_common_refresh_low,
    0,                              0
};

/////////////////////////////////////////////////////////////
// CVolatileSettPage property page

IMPLEMENT_DYNCREATE(CVolatileSettPage, CPropertyPage)

CVolatileSettPage::CVolatileSettPage() : CPropertyPage(CVolatileSettPage::IDD)
{
    //{{AFX_DATA_INIT(CVolatileSettPage)
    m_nUpdateIntervalIndex = 2;
    m_bAllocFCheck = FALSE;
    m_bNormalCheck = FALSE;
    m_bPagedCCheck = FALSE;
    //}}AFX_DATA_INIT

    m_bAscendDrvNameSort = FALSE;
    m_bAscendDrvStatusSort = FALSE;

    m_uTimerHandler = 0;

    m_nSortColumnIndex = 0;

    m_eApplyButtonState = vrfControlDisabled;

    m_bTimerBlocked = FALSE;
}

CVolatileSettPage::~CVolatileSettPage()
{
}

void CVolatileSettPage::DoDataExchange(CDataExchange* pDX)
{
    if( ! pDX->m_bSaveAndValidate )
    {
        // query the kernel
        
        KrnGetSystemVerifierState( &m_KrnVerifState );
    }

    CPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CVolatileSettPage)
    DDX_Control(pDX, IDC_VSETTINGS_DRIVERS_LIST, m_DriversList);
    DDX_Control(pDX, IDC_VSETTINGS_PAGEDC_VERIF_CHECK, m_PagedCCheck);
    DDX_Control(pDX, IDC_VSETTINGS_NORMAL_VERIF_CHECK, m_NormalVerifCheck);
    DDX_Control(pDX, IDC_VSETTINGS_ALLOCF_VERIF_CHECK, m_AllocFCheck);
    DDX_Control(pDX, IDC_VSETTINGS_APPLY_BUTTON, m_ApplyButton);
    DDX_Radio(pDX, IDC_VSETTINGS_MANUAL_RADIO, m_nUpdateIntervalIndex);
	//}}AFX_DATA_MAP

    if( pDX->m_bSaveAndValidate )
    {
        DDX_Check(pDX, IDC_VSETTINGS_NORMAL_VERIF_CHECK, m_bNormalCheck);
        DDX_Check(pDX, IDC_VSETTINGS_PAGEDC_VERIF_CHECK, m_bPagedCCheck);
        DDX_Check(pDX, IDC_VSETTINGS_ALLOCF_VERIF_CHECK, m_bAllocFCheck);
    }
}


BEGIN_MESSAGE_MAP(CVolatileSettPage, CPropertyPage)
    //{{AFX_MSG_MAP(CVolatileSettPage)
    ON_BN_CLICKED(IDC_VSETTINGS_REFRESH_BUTTON, OnCrtstatRefreshButton)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_VSETTINGS_DRIVERS_LIST, OnColumnclickCrtstatDriversList)
    ON_WM_TIMER()
    ON_BN_CLICKED(IDC_VSETTINGS_HSPEED_RADIO, OnCrtstatHspeedRadio)
    ON_BN_CLICKED(IDC_VSETTINGS_LOW_RADIO, OnCrtstatLowRadio)
    ON_BN_CLICKED(IDC_VSETTINGS_MANUAL_RADIO, OnCrtstatManualRadio)
    ON_BN_CLICKED(IDC_VSETTINGS_NORM_RADIO, OnCrtstatNormRadio)
    ON_BN_CLICKED(IDC_VSETTINGS_APPLY_BUTTON, OnApplyButton)
    ON_BN_CLICKED(IDC_VSETTINGS_ALLOCF_VERIF_CHECK, OnCheck )
    ON_BN_CLICKED(IDC_VSETTINGS_ADD_BUTTON, OnAddButton)
    ON_BN_CLICKED(IDC_VSETTINGS_DONTVERIFY_BUTTON, OnDontVerifyButton)
    ON_BN_CLICKED(IDC_VSETTINGS_NORMAL_VERIF_CHECK, OnCheck )
    ON_BN_CLICKED(IDC_VSETTINGS_PAGEDC_VERIF_CHECK, OnCheck )
    ON_NOTIFY(NM_RCLICK, IDC_VSETTINGS_DRIVERS_LIST, OnRclickDriversList)
    ON_COMMAND(ID_VOLATILE_ADD_DRIVERS, OnAddButton)
    ON_COMMAND(ID_VOLATILE_REMOVE_DRIVERS, OnDontVerifyButton)
    ON_MESSAGE( WM_HELP, OnHelp )
    ON_MESSAGE( WM_CONTEXTMENU, OnContextMenu )
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
void CVolatileSettPage::UpdateControlsState()
{
    EnableControl( m_ApplyButton, m_eApplyButtonState );
}

/////////////////////////////////////////////////////////////////////////////
void CVolatileSettPage::EnableControl( CWnd &wndCtrl, 
                                   VRF_CONTROL_STATE eNewState )
{
    BOOL bEnabled = wndCtrl.IsWindowEnabled();
    if( bEnabled )
    {
        if( eNewState == vrfControlDisabled )
            wndCtrl.EnableWindow( FALSE );
    }
    else
    {
        if( eNewState == vrfControlEnabled )
            wndCtrl.EnableWindow( TRUE );
    }
}

/////////////////////////////////////////////////////////////
void CVolatileSettPage::SetupListHeader()
{
    CString strDrivers, strStatus;
    VERIFY( strDrivers.LoadString( IDS_DRIVERS ) );
    VERIFY( strStatus.LoadString( IDS_STATUS ) );

    // list's regtangle
    CRect rectWnd;
    m_DriversList.GetClientRect( &rectWnd );
    
    LVCOLUMN lvColumn;

    // column 0
    memset( &lvColumn, 0, sizeof( lvColumn ) );
    lvColumn.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;
    
    lvColumn.iSubItem = 0;
    lvColumn.pszText = strDrivers.GetBuffer( strDrivers.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.47 );
    VERIFY( m_DriversList.InsertColumn( 0, &lvColumn ) != -1 );
    strDrivers.ReleaseBuffer();

    // column 1
    lvColumn.iSubItem = 1;
    lvColumn.pszText = strStatus.GetBuffer( strStatus.GetLength() + 1 );
    lvColumn.cx = (int)( rectWnd.Width() * 0.47 );
    VERIFY( m_DriversList.InsertColumn( 1, &lvColumn ) != -1 );
    strStatus.ReleaseBuffer();
}

/////////////////////////////////////////////////////////////
void CVolatileSettPage::FillTheList()
{
    LVITEM lvItem;
    int nActualIndex; 
    BOOL *pbAlreadyInList;
    ULONG uCrtVerifiedDriver;
    int nItemCount;
    int nCrtListItem;
    TCHAR strDriverName[ _MAX_PATH ];
    BOOL bResult;

    if( m_KrnVerifState.DriverCount == 0 )
    {
        //
        // clear the list
        //

        VERIFY( m_DriversList.DeleteAllItems() );
    }
    else
    {
        //
        // there are some drivers currently verified
        //

        pbAlreadyInList = new BOOL[ m_KrnVerifState.DriverCount ];
        if( pbAlreadyInList == NULL )
        {
            return;
        }
        
        for( uCrtVerifiedDriver = 0; uCrtVerifiedDriver < m_KrnVerifState.DriverCount; uCrtVerifiedDriver++)
        {
            pbAlreadyInList[ uCrtVerifiedDriver ] = FALSE;
        }

        //
        // parse all the current list items
        //

        nItemCount = m_DriversList.GetItemCount();

        for( nCrtListItem = 0; nCrtListItem < nItemCount; nCrtListItem++ )
        {
            //
            // get the current driver's name from the list
            //

            ZeroMemory( &lvItem, sizeof( lvItem ) );

            lvItem.mask = LVIF_TEXT;
            lvItem.iItem = nCrtListItem;
            lvItem.iSubItem = 0;
            lvItem.pszText = strDriverName;
            lvItem.cchTextMax = sizeof( strDriverName ) / sizeof( strDriverName[0] );

            bResult = m_DriversList.GetItem( &lvItem );
            if( bResult == FALSE )
            {
                //
                // could not get the current item's attributes?
                //

                ASSERT( FALSE );

                //
                // remove this item from the list
                //

                VERIFY( m_DriversList.DeleteItem( nCrtListItem ) );

                nCrtListItem--;
                nItemCount--;
            }
            else
            {
                //
                // see is the current driver is still in m_KrnVerifState
                //

                for( uCrtVerifiedDriver = 0; uCrtVerifiedDriver < m_KrnVerifState.DriverCount; uCrtVerifiedDriver++)
                {
                    if( _tcsicmp( strDriverName, 
                        m_KrnVerifState.DriverInfo[ uCrtVerifiedDriver ].Name ) == 0 )
                    {
                        //
                        // update the item's data with the current index in the array
                        //

                        lvItem.mask = LVIF_PARAM;
                        lvItem.lParam = uCrtVerifiedDriver;
                        
                        VERIFY( m_DriversList.SetItem( &lvItem ) != -1 );

                        //
                        // update the second column
                        //

                        UpdateStatusColumn( nCrtListItem, uCrtVerifiedDriver ); 

                        //
                        // mark the current driver as updated
                        //

                        pbAlreadyInList[ uCrtVerifiedDriver ] = TRUE;

                        break;
                    }
                }

                //
                // If the driver is no longer verified, remove it from the list
                //

                if( uCrtVerifiedDriver >= m_KrnVerifState.DriverCount )
                {
                    VERIFY( m_DriversList.DeleteItem( nCrtListItem ) );

                    nCrtListItem--;
                    nItemCount--;
                }
            }
        }

        //
        // add the drivers that were not in the list before this update
        //

        for( uCrtVerifiedDriver = 0; uCrtVerifiedDriver < m_KrnVerifState.DriverCount; uCrtVerifiedDriver++)
        {
            if( ! pbAlreadyInList[ uCrtVerifiedDriver ] )
            {
                // 
                // add a new item for this
                //

                ZeroMemory( &lvItem, sizeof( lvItem ) );

                //
                // sub-item 0
                //

                lvItem.mask = LVIF_TEXT | LVIF_PARAM;
                lvItem.lParam = uCrtVerifiedDriver;
                lvItem.iItem = m_DriversList.GetItemCount();
                lvItem.iSubItem = 0;
                lvItem.pszText = m_KrnVerifState.DriverInfo[ uCrtVerifiedDriver ].Name;
                nActualIndex = m_DriversList.InsertItem( &lvItem );
                VERIFY( nActualIndex != -1 );

                //
                // sub-item 1
                //

                UpdateStatusColumn( nActualIndex, uCrtVerifiedDriver ); 
            }
        }

        delete pbAlreadyInList;
    }
}

/////////////////////////////////////////////////////////////
void CVolatileSettPage::UpdateStatusColumn( int nItemIndex, ULONG uCrtDriver )
{
    LVITEM lvItem;
    CString strStatus;

    ASSERT( nItemIndex >= 0 && 
            (UINT)nItemIndex < m_KrnVerifState.DriverCount &&
            nItemIndex < m_DriversList.GetItemCount() &&
            uCrtDriver >= 0 &&
            uCrtDriver < m_KrnVerifState.DriverCount &&
            uCrtDriver < (ULONG)m_DriversList.GetItemCount() );

    // determine what's the appropriate value for the second column
    if( ! m_KrnVerifState.DriverInfo[ uCrtDriver ].Loads )
    {
        VERIFY( strStatus.LoadString( IDS_NEVER_LOADED ) );
    }
    else
    {
        if( m_KrnVerifState.DriverInfo[ uCrtDriver ].Loads == 
            m_KrnVerifState.DriverInfo[ uCrtDriver ].Unloads )
        {
            VERIFY( strStatus.LoadString( IDS_UNLOADED ) );
        }
        else
        {
            if( m_KrnVerifState.DriverInfo[ uCrtDriver ].Loads > 
                m_KrnVerifState.DriverInfo[ uCrtDriver ].Unloads )
            {
                VERIFY( strStatus.LoadString( IDS_LOADED ) );
            }
            else
            {
                ASSERT( FALSE );
                VERIFY( strStatus.LoadString( IDS_UNKNOWN ) );
            }
        }
    }

    // update the list item
    memset( &lvItem, 0, sizeof( lvItem ) );
    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nItemIndex;
    lvItem.iSubItem = 1;
    lvItem.pszText = strStatus.GetBuffer( strStatus.GetLength() + 1 );
    VERIFY( m_DriversList.SetItem( &lvItem ) != -1 );
    strStatus.ReleaseBuffer();
}

/////////////////////////////////////////////////////////////
int CALLBACK CVolatileSettPage::DrvStatusCmpFunc(
    LPARAM lParam1, 
    LPARAM lParam2, 
    LPARAM lParamSort)
{
    UINT uIndex1 = (UINT)lParam1;
    UINT uIndex2 = (UINT)lParam2;
    CVolatileSettPage *pThis = (CVolatileSettPage *)lParamSort;
    ASSERT_VALID( pThis );

    int nCmpRez = 0;

    // sanity check
    if( uIndex1 > pThis->m_KrnVerifState.DriverCount || 
        uIndex2 > pThis->m_KrnVerifState.DriverCount )
    {
        ASSERT( FALSE );
        return 0;
    }

    // difference between loads and unloads #
    LONG lLoadDiff1 = (LONG)pThis->m_KrnVerifState.DriverInfo[ uIndex1 ].Loads -
                      (LONG)pThis->m_KrnVerifState.DriverInfo[ uIndex1 ].Unloads;
    LONG lLoadDiff2 = (LONG)pThis->m_KrnVerifState.DriverInfo[ uIndex2 ].Loads - 
                      (LONG)pThis->m_KrnVerifState.DriverInfo[ uIndex2 ].Unloads;

    if( lLoadDiff1 == lLoadDiff2 )
    {
        nCmpRez = 0;
    }
    else
    {
        if( lLoadDiff1 > lLoadDiff2 )
            nCmpRez = 1;
        else
            nCmpRez = -1;
    }

    if( pThis->m_bAscendDrvStatusSort )
        nCmpRez *= -1;

    return nCmpRez;
}

/////////////////////////////////////////////////////////////
int CALLBACK CVolatileSettPage::DrvNameCmpFunc(
    LPARAM lParam1, 
    LPARAM lParam2, 
    LPARAM lParamSort)
{
    UINT uIndex1 = (UINT)lParam1;
    UINT uIndex2 = (UINT)lParam2;
    CVolatileSettPage *pThis = (CVolatileSettPage *)lParamSort;
    ASSERT_VALID( pThis );

    int nCmpRez = 0;

    // sanity check
    if( uIndex1 > pThis->m_KrnVerifState.DriverCount || 
        uIndex2 > pThis->m_KrnVerifState.DriverCount )
    {
        ASSERT( FALSE );
        return 0;
    }

    nCmpRez = _tcsicmp( pThis->m_KrnVerifState.DriverInfo[ uIndex1 ].Name, 
                        pThis->m_KrnVerifState.DriverInfo[ uIndex2 ].Name );
    if( ! nCmpRez )
    {
        // same name ???
        nCmpRez = 0;
    }
    else
    {
        if( pThis->m_bAscendDrvNameSort )
            nCmpRez *= -1;
    }

    return nCmpRez;
}

/////////////////////////////////////////////////////////////
void CVolatileSettPage::OnRefreshTimerChanged()
{
    UINT uTimerElapse = 0;

    // kill the pending timer
    if( m_uTimerHandler != 0 )
    {
        VERIFY( KillTimer( REFRESH_TIMER_ID ) );
    }

    // sanity check
    if( m_nUpdateIntervalIndex < 0 || 
        m_nUpdateIntervalIndex >= REFRESH_SPEED_VARS )
    {
        m_nUpdateIntervalIndex = 0;
        CheckRadioButton( IDC_VSETTINGS_MANUAL_RADIO, IDC_VSETTINGS_LOW_RADIO, 
            IDC_VSETTINGS_MANUAL_RADIO );
    }

    // new timer interval
    uTimerElapse = uTimerIntervals[ m_nUpdateIntervalIndex ];
    if( uTimerElapse > 0 )
    {
        VERIFY( m_uTimerHandler = SetTimer( REFRESH_TIMER_ID, 
            uTimerElapse, NULL ) );
    }
}

/////////////////////////////////////////////////////////////
void CVolatileSettPage::SortTheList()
{
    if( m_nSortColumnIndex )
    {
        m_DriversList.SortItems( DrvStatusCmpFunc, (LPARAM)this );
    }
    else
    {
        m_DriversList.SortItems( DrvNameCmpFunc, (LPARAM)this );
    }
}

/////////////////////////////////////////////////////////////
// CVolatileSettPage message handlers

BOOL CVolatileSettPage::OnInitDialog() 
{
    CPropertyPage::OnInitDialog();

    //
    // set the checkboxes state
    //

    if( KrnGetSystemVerifierState( &m_KrnVerifState ) && 
        m_KrnVerifState.DriverCount > 0 )
    {
        m_NormalVerifCheck.SetCheck( m_KrnVerifState.SpecialPool );
        m_PagedCCheck.SetCheck( m_KrnVerifState.IrqlChecking );
        m_AllocFCheck.SetCheck( m_KrnVerifState.FaultInjection );
    }

    //
    // see if we can modify options on the fly
    //

    if( g_OsVersion.dwMajorVersion < 5 || g_OsVersion.dwBuildNumber < 2055 )
    {
        m_NormalVerifCheck.EnableWindow( FALSE );
        m_PagedCCheck.EnableWindow( FALSE );
        m_AllocFCheck.EnableWindow( FALSE );
    }

    //
    // setup the list
    //

    SetupListHeader();
    FillTheList();
    SortTheList();

    OnRefreshTimerChanged();

    UpdateControlsState();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////
void CVolatileSettPage::OnCrtstatRefreshButton() 
{
    if( UpdateData( FALSE ) )
    {
        FillTheList();
        SortTheList();
    }
}

/////////////////////////////////////////////////////////////
void CVolatileSettPage::OnColumnclickCrtstatDriversList(NMHDR* pNMHDR, 
                                                   LRESULT* pResult) 
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    if( pNMListView->iSubItem )
    {
        if( m_nSortColumnIndex == pNMListView->iSubItem )
        {
            // change the current ascend/descend order for this column
            m_bAscendDrvStatusSort = !m_bAscendDrvStatusSort;
        }
    }
    else
    {
        if( m_nSortColumnIndex == pNMListView->iSubItem )
        {
            // change the current ascend/descend order for this column
            m_bAscendDrvNameSort = !m_bAscendDrvNameSort;
        }
    }

    m_nSortColumnIndex = pNMListView->iSubItem;

    SortTheList();

    *pResult = 0;
}

/////////////////////////////////////////////////////////////
void CVolatileSettPage::OnRclickDriversList(NMHDR* pNMHDR, LRESULT* pResult) 
{
    POINT point;
    CMenu theMenu, *pTrackedMenu = NULL;
    BOOL bShowRemoveMenuItem = FALSE;

    int nItems = m_DriversList.GetItemCount();

    for(int nCrtItem = 0; nCrtItem < nItems; nCrtItem++ )
    {
        if( m_DriversList.GetItemState( nCrtItem, LVIS_SELECTED ) &
            LVIS_SELECTED )
        {
            bShowRemoveMenuItem = TRUE;
        }
    }

    if( bShowRemoveMenuItem )
    {
        VERIFY( theMenu.LoadMenu( IDM_ADD_REMOVE_DRIVERS ) );
    }
    else
    {
        VERIFY( theMenu.LoadMenu( IDM_ADD_DRIVERS ) );
    }

    pTrackedMenu = theMenu.GetSubMenu( 0 );
    if( pTrackedMenu != NULL )
    {
        ASSERT_VALID( pTrackedMenu );
        VERIFY( ::GetCursorPos( &point ) );
        VERIFY( pTrackedMenu->TrackPopupMenu(
                TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                point.x, point.y,
                this ) );
    }
    else
    {
        ASSERT( FALSE );
    }

    *pResult = 0;
}

/////////////////////////////////////////////////////////////
void CVolatileSettPage::OnTimer(UINT nIDEvent) 
{
    if( m_bTimerBlocked != TRUE && nIDEvent == REFRESH_TIMER_ID )
    {
        CDrvChkSheet *pParentSheet = (CDrvChkSheet *)GetParent();
        if( pParentSheet != NULL )
        {
            ASSERT_VALID( pParentSheet );
            if( pParentSheet->GetActivePage() == this )
            {
                // refresh the displayed data 
                OnCrtstatRefreshButton();
            }
        }
    }

    CPropertyPage::OnTimer(nIDEvent);
}

/////////////////////////////////////////////////////////////////////////////
void CVolatileSettPage::OnCheck() 
{
    m_eApplyButtonState = vrfControlEnabled;
    UpdateControlsState();
}

/////////////////////////////////////////////////////////////////////////////
void CVolatileSettPage::OnApplyButton() 
{
    if( ApplyTheChanges() )
    {
        m_eApplyButtonState = vrfControlDisabled;
        UpdateControlsState();
    }
}

/////////////////////////////////////////////////////////////////////////////
BOOL CVolatileSettPage::ApplyTheChanges()
{
    if( UpdateData( TRUE ) )
    {
        return VrfSetVolatileOptions( 
            m_bNormalCheck,
            m_bPagedCCheck,
            m_bAllocFCheck );
    }

    return FALSE;
}

/////////////////////////////////////////////////////////////
BOOL CVolatileSettPage::OnQueryCancel() 
{
    // give parent PropertySheet a chance to refuse the Cancel if needed

    CDrvChkSheet *pParentSheet = (CDrvChkSheet *)GetParent();
    if( pParentSheet != NULL )
    {
        ASSERT_VALID( pParentSheet );
        if( ! pParentSheet->OnQueryCancel() )
        {
            return FALSE;
        }
    }

    return CPropertyPage::OnQueryCancel();
}

/////////////////////////////////////////////////////////////
BOOL CVolatileSettPage::OnApply() 
{
    // refuse to apply 
    // (we don't use the standard PropertSheet buttons; Apply, OK)
    return FALSE;
}

/////////////////////////////////////////////////////////////
void CVolatileSettPage::OnCrtstatManualRadio() 
{
    // switch to manual refresh
    m_nUpdateIntervalIndex = 0;
    OnRefreshTimerChanged();
}

void CVolatileSettPage::OnCrtstatHspeedRadio() 
{
    // switch to high speed refresh
    m_nUpdateIntervalIndex = 1;
    OnRefreshTimerChanged();
}

void CVolatileSettPage::OnCrtstatNormRadio() 
{
    // switch to normal speed refresh
    m_nUpdateIntervalIndex = 2;
    OnRefreshTimerChanged();
}

void CVolatileSettPage::OnCrtstatLowRadio() 
{
    // switch to low speed refresh
    m_nUpdateIntervalIndex = 3;
    OnRefreshTimerChanged();
}

/////////////////////////////////////////////////////////////

#define VRF_MAX_CHARS_FOR_OPEN  4096

void CVolatileSettPage::OnAddButton() 
{
    static BOOL bChangedDirectory = FALSE;

    POSITION pos;
    BOOL bEnabledSome = FALSE;
    DWORD dwRetValue;
    DWORD dwOldMaxFileName = 0;
    DWORD dwErrorCode;
    int nFileNameStartIndex;
    INT_PTR nResult;
    TCHAR szDriversDir[ _MAX_PATH ];
    TCHAR szAppTitle[ _MAX_PATH ];
    TCHAR *szFilesBuffer = NULL;
    TCHAR *szOldFilesBuffer = NULL;
    CString strPathName;
    CString strFileName;

    CFileDialog fileDlg( 
        TRUE,                               // open file
        _T( "sys" ),                        // default extension
        NULL,                               // no initial file name
        OFN_ALLOWMULTISELECT    |           // multiple selection
        OFN_HIDEREADONLY        |           // hide the "open read-only" checkbox
        OFN_NONETWORKBUTTON     |           // no network button
        OFN_NOTESTFILECREATE    |           // don't test for write protection, a full disk, etc.
        OFN_SHAREAWARE,                     // don't check the existance of file with OpenFile
        _T( "Drivers (*.sys)|*.sys||" ) );  // only one filter

    //
    // check the max length for the returned string
    //

    if( fileDlg.m_ofn.nMaxFile < VRF_MAX_CHARS_FOR_OPEN )
    {
        //
        // allocate a new buffer for the file names
        // 

        szFilesBuffer = new TCHAR[ VRF_MAX_CHARS_FOR_OPEN ];
        szFilesBuffer[ 0 ] = (TCHAR)0;

        if( szFilesBuffer != NULL )
        {
            //
            // Save the old buffer address and length
            //

            dwOldMaxFileName = fileDlg.m_ofn.nMaxFile;
            szOldFilesBuffer = fileDlg.m_ofn.lpstrFile;
            
            //
            // Set the new buffer address and length
            //

            fileDlg.m_ofn.lpstrFile = szFilesBuffer;
            fileDlg.m_ofn.nMaxFile = VRF_MAX_CHARS_FOR_OPEN;
        }
    }

    //
    // Dialog title
    //

    if( GetStringFromResources(
        IDS_APPTITLE,
        szAppTitle,
        ARRAY_LENGTH( szAppTitle ) ) )
    {
        fileDlg.m_ofn.lpstrTitle = szAppTitle;
    }

    //
    // We change directory first time we try this to %windir%\system32\drivers
    //

    if( bChangedDirectory == FALSE )
    {

        dwRetValue = ExpandEnvironmentStrings(
            _T( "%windir%\\system32\\drivers" ),
            szDriversDir,
            ARRAY_LENGTH( szDriversDir ) );

        if( dwRetValue > 0 && dwRetValue <= ARRAY_LENGTH( szDriversDir ) )
        {
            fileDlg.m_ofn.lpstrInitialDir = szDriversDir;
        }

        bChangedDirectory = TRUE;
    }

    //
    // show the file selection dialog
    //

    nResult = fileDlg.DoModal();

    switch( nResult )
    {
    case IDOK:
        break;

    case IDCANCEL:
        goto cleanup;

    default:
        dwErrorCode = CommDlgExtendedError();

        if( dwErrorCode == FNERR_BUFFERTOOSMALL )
        {
            VrfErrorResourceFormat(
                IDS_TOO_MANY_FILES_SELECTED );
        }
        else
        {
            VrfErrorResourceFormat(
                IDS_CANNOT_OPEN_FILES,
                dwErrorCode );
        }

        goto cleanup;
    }

    //
    // Block the timer
    //

    m_bTimerBlocked = TRUE;

    //
    // Parse all the selected files and try to enable them for verification
    //

    pos = fileDlg.GetStartPosition();

    while( pos != NULL )
    {
        //
        // Get the full path for the next file
        //

        strPathName = fileDlg.GetNextPathName( pos );

        //
        // split only the file name, without the directory
        //

        nFileNameStartIndex = strPathName.ReverseFind( _T( '\\' ) );
        
        if( nFileNameStartIndex < 0 )
        {
            //
            // this shoudn't happen but you never know :-)
            //

            nFileNameStartIndex = 0;
        }
        else
        {
            //
            // skip the backslash
            //

            nFileNameStartIndex++;
        }

        strFileName = strPathName.Right( strPathName.GetLength() - nFileNameStartIndex );

        //
        // Try to add this driver to the current verification list
        //

        if( VrfVolatileAddDriver( (LPCTSTR)strFileName ) )
        {
            bEnabledSome = TRUE;
        }
    }

    //
    // Enable the timer
    //

    m_bTimerBlocked = FALSE;

    //
    // Refresh
    //

    if( bEnabledSome == TRUE )
    {
        OnCrtstatRefreshButton();
    }

cleanup:
    if( szFilesBuffer != NULL )
    {
        fileDlg.m_ofn.nMaxFile = dwOldMaxFileName;
        fileDlg.m_ofn.lpstrFile = szOldFilesBuffer;

        delete szFilesBuffer;
    }
}

/////////////////////////////////////////////////////////////
void CVolatileSettPage::OnDontVerifyButton() 
{
    int nItems;
    UINT uIndexInArray;
    BOOL bDisabledSome = FALSE;

    //
    // Block the timer
    //

    m_bTimerBlocked = TRUE;

    //
    // The number of items in the list
    //

    nItems = m_DriversList.GetItemCount();
    
    //
    // Parse all the items, looking for the selected ones.
    //

    for(int nCrtItem = 0; nCrtItem < nItems; nCrtItem++ )
    {
        if( m_DriversList.GetItemState( nCrtItem, LVIS_SELECTED ) & LVIS_SELECTED )
        {
            //
            // Get the index of the corresponding entry in the array
            //

            uIndexInArray = (UINT)m_DriversList.GetItemData( nCrtItem );

            //
            // sanity checks
            //

            if( uIndexInArray >= m_KrnVerifState.DriverCount )
            {
                ASSERT( FALSE );
                continue;
            }

            if( VrfVolatileRemoveDriver( m_KrnVerifState.DriverInfo[ uIndexInArray ].Name ) )
            {
                bDisabledSome = TRUE;
            }
        }
    }

    //
    // Enable the timer
    //

    m_bTimerBlocked = FALSE;

    //
    // If we disabled some drivers' verification we need to refresh the list
    //

    if( bDisabledSome )
    {
        OnCrtstatRefreshButton();
    }
}

/////////////////////////////////////////////////////////////
LONG CVolatileSettPage::OnHelp( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    ::WinHelp( 
        (HWND) lpHelpInfo->hItemHandle,
        VERIFIER_HELP_FILE,
        HELP_WM_HELP,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}

/////////////////////////////////////////////////////////////
LONG CVolatileSettPage::OnContextMenu( WPARAM wParam, LPARAM lParam )
{
    LONG lResult = 0;

    ::WinHelp( 
        (HWND) wParam,
        VERIFIER_HELP_FILE,
        HELP_CONTEXTMENU,
        (DWORD_PTR) MyHelpIds );

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\verifier\win2k\verify.cxx ===
//
// Driver Verifier Control Applet
// Copyright (c) Microsoft Corporation, 1999
//

//
// module: verify.cxx
// author: silviuc
// created: Mon Jan 04 12:40:57 1999
//



extern "C" {
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
}

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <tchar.h>
#include <windows.h>
#include <time.h>
#include <ntverp.h>
#include <common.ver>

#include "verify.hxx"
#include "image.hxx"
#include "resource.h"

//
// IO verification levels
//

#define IO_VERIFICATION_LEVEL_MAX   3

//
// all the possible verification flags
//

const UINT VerifierAllOptions = (DRIVER_VERIFIER_SPECIAL_POOLING |
                                 DRIVER_VERIFIER_FORCE_IRQL_CHECKING |
                                 DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES |
                                 DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS |
                                 DRIVER_VERIFIER_IO_CHECKING |
                                 DRIVER_VERIFIER_DEADLOCK_DETECTION );

//
// the options that can be modified on the fly
//

const UINT VerifierModifyableOptions = (DRIVER_VERIFIER_SPECIAL_POOLING |
                                 DRIVER_VERIFIER_FORCE_IRQL_CHECKING |
                                 DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES);

//
// system IO verifier values
//

#define SYS_IO_VERIFIER_DISABLED_VALUE  0
#define SYS_IO_VERIFIER_BASE_VALUE   1


//////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////// Global Data
//////////////////////////////////////////////////////////////////////

//
// Command line / GUI
//

BOOL g_bCommandLineMode = FALSE;

//
// OS version and build number information
//

OSVERSIONINFO g_OsVersion;

//
// Was the debug privilege already enabled?
// We need this privilege to set volatile options.
//

BOOL g_bPrivegeEnabled = FALSE;

//////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////// Registry Strings
//////////////////////////////////////////////////////////////////////

LPCTSTR RegMemoryManagementKeyName =
TEXT ("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management");

LPCTSTR RegVerifyDriversValueName =
TEXT ("VerifyDrivers");

LPCTSTR RegVerifyDriverLevelValueName =
TEXT ("VerifyDriverLevel");

LPCTSTR RegSessionManagerKeyName =
    TEXT ("System\\CurrentControlSet\\Control\\Session Manager");

LPCTSTR RegIOVerifyKeyName =
    TEXT ("System\\CurrentControlSet\\Control\\Session Manager\\I/O System");

LPCTSTR RegIOVerifySubKeyName =
    TEXT ("I/O System");

LPCTSTR RegIOVerifyLevelValueName =
    TEXT ("IoVerifierLevel");

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////// command line support
//////////////////////////////////////////////////////////////////////

void
VrfDumpChangedSettings(

    UINT OldFlags,
    UINT NewFlags );

BOOL
VrfEnableDebugPrivilege (
    );

//////////////////////////////////////////////////////////////////////
/////////////// Forward decl for local registry manipulation functions
//////////////////////////////////////////////////////////////////////

BOOL
ReadRegistryValue (

    HKEY HKey,
    LPCTSTR Name,
    DWORD * Value,
    DWORD DefaultValue);

BOOL
WriteRegistryValue (

    HKEY HKey,
    LPCTSTR Name,
    DWORD Value);

BOOL
ReadMmString (

    HKEY MmKey,
    LPCTSTR Name,
    LPTSTR Buffer,
    DWORD BufferSize);

BOOL
WriteMmString (

    HKEY MmKey,
    LPCTSTR Name,
    LPTSTR Value);

//////////////////////////////////////////////////////////////////////
/////////////// Forward decl for local sys level IO verifier functions
//////////////////////////////////////////////////////////////////////

BOOL
SetSysIoVerifierSettings(
    ULONG SysIoVerifierLevel );


//////////////////////////////////////////////////////////////////////
/////////////////////// Forward decl for driver manipulation functions
//////////////////////////////////////////////////////////////////////

typedef enum {

    VRF_DRIVER_LOAD_SUCCESS,
    VRF_DRIVER_LOAD_CANNOT_FIND_IMAGE,
    VRF_DRIVER_LOAD_INVALID_IMAGE

} VRF_DRIVER_LOAD_STATUS;


ULONG
GetActiveDriversList (

    PVRF_DRIVER_STATE DriverInfo,
    ULONG MaxNumberOfDrivers);

BOOL
SetVerifiedDriversFromNamesString (

    PVRF_VERIFIER_STATE VrfState );

BOOL
GetVerifiedDriversToString (

    PVRF_VERIFIER_STATE VrfState );

BOOL
SetAllDriversStatus (

    PVRF_VERIFIER_STATE VrfState,
    BOOL Verified);


BOOL
VrfSearchVerifierDriver (

    PVRF_VERIFIER_STATE VrfState,
    LPCTSTR DriverName,
    ULONG & HitIndex);

BOOL
KrnSearchVerifierDriver (

    LPCTSTR DriverName,
    ULONG & HitIndex);

LPCTSTR
IsMiniportDriver (

    LPCTSTR DriverName, VRF_DRIVER_LOAD_STATUS &ErrorCode);

BOOL
VrfGetVersionInfo(
    LPTSTR lptstrFileName,
    LPTSTR lptstrCompany,
    int nCompanyBufferLength,
    LPTSTR lptstrVersion,
    int nVersionBufferLength );

BOOL
ConvertAnsiStringToTcharString (

    LPBYTE Source,
    ULONG SourceLength,
    LPTSTR Destination,
    ULONG DestinationLength);

//
// Support for dynamic set of verified drivers
//

BOOL
VrfVolatileAddOrRemoveDriversCmdLine(

    int nArgsNo,
    LPTSTR szCmdLineArgs[] );


//////////////////////////////////////////////////////////////////////
////////////////////////////////////////// Exported Verifier Functions
//////////////////////////////////////////////////////////////////////

//
// Function:
//
//     VrfGetVerifierState
//
// Description:
//
//     Reads all Mm related registry settings and fills the structure
//     with the appropriate BOOLean values.
//

BOOL
VrfGetVerifierState (

    PVRF_VERIFIER_STATE VrfState)
{
    static KRN_VERIFIER_STATE KrnState;

    HKEY MmKey = NULL;
    HKEY IoKey = NULL;
    LONG Result;
    DWORD Value;
    DWORD IoValue;
    ULONG Index;
    ULONG FoundIndex;

    if (VrfState == NULL) {

        return FALSE;
    }

    //
    // Open the Mm key
    //

    Result = RegOpenKeyEx (

        HKEY_LOCAL_MACHINE,
        RegMemoryManagementKeyName,
        0,
        KEY_QUERY_VALUE,
        &MmKey);

    if (Result != ERROR_SUCCESS) {

        if( Result == ERROR_ACCESS_DENIED ) {

            VrfErrorResourceFormat ( IDS_ACCESS_IS_DENIED );
        }
        else {

            VrfErrorResourceFormat (
                IDS_REGOPENKEYEX_FAILED,
                RegMemoryManagementKeyName,
                (DWORD)Result);
        }

        return FALSE;
    }

    //
    // Set the driver specific information.
    //

    VrfState->DriverNames[ 0 ] = 0;
    VrfState->AdditionalDriverNames[ 0 ] = 0;

    VrfState->DriverCount = GetActiveDriversList (
        VrfState->DriverInfo, ARRAY_LENGTH( VrfState->DriverInfo ) );

    //
    // Read VerifyDriverLevel value
    //

    if (ReadRegistryValue (MmKey, RegVerifyDriverLevelValueName, &Value, 0) == FALSE) {

        RegCloseKey (MmKey);
        return FALSE;
    }

    VrfState->SpecialPoolVerification = (Value & DRIVER_VERIFIER_SPECIAL_POOLING) ? TRUE : FALSE;
    VrfState->PagedCodeVerification = (Value & DRIVER_VERIFIER_FORCE_IRQL_CHECKING) ? TRUE : FALSE;
    VrfState->AllocationFaultInjection = (Value & DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES) ? TRUE : FALSE;
    VrfState->PoolTracking = (Value & DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS) ? TRUE : FALSE;
    VrfState->IoVerifier = (Value & DRIVER_VERIFIER_IO_CHECKING) ? TRUE : FALSE;

    //
    // the sys level IO verifier can be enabled only if VrfState->IoVerifier == TRUE
    //

    if( VrfState->IoVerifier == TRUE )
    {
        //
        // don't know yet if the sys level IO verifier is enabled
        //

        IoValue = SYS_IO_VERIFIER_DISABLED_VALUE;

        //
        // Open the IO key
        //

        Result = RegOpenKeyEx (

            HKEY_LOCAL_MACHINE,
            RegIOVerifyKeyName,
            0,
            KEY_QUERY_VALUE,
            &IoKey);

        if (Result != ERROR_SUCCESS ) {

            //
            // if Result == ERROR_FILE_NOT_FOUND just use out default value for IoValue
            //

            if( Result != ERROR_FILE_NOT_FOUND ) {

                //
                // the key is there but we cannot read it, fatal error
                //

                if( Result == ERROR_ACCESS_DENIED ) {

                    VrfErrorResourceFormat(
                        IDS_ACCESS_IS_DENIED );
                }
                else {

                    VrfErrorResourceFormat(
                        IDS_REGOPENKEYEX_FAILED,
                        RegIOVerifyKeyName,
                        (DWORD)Result);
                }

                RegCloseKey (MmKey);
                return FALSE;
            }
        }
        else {

            //
            // IO key opened, read the IoVerifierLevel value
            //

            if ( ReadRegistryValue (
                    IoKey,
                    RegIOVerifyLevelValueName,
                    &IoValue,
                    SYS_IO_VERIFIER_DISABLED_VALUE ) == FALSE) {

                RegCloseKey (IoKey);
                RegCloseKey (MmKey);
                return FALSE;
            }

            //
            // done with the IO key
            //

            RegCloseKey (IoKey);
        }
        
        if (IoValue) 
        {
            VrfState->SysIoVerifierLevel = IoValue - SYS_IO_VERIFIER_BASE_VALUE;
        }
        
    }

    //
    // Read VerifyDrivers value
    //

    VrfState->AllDriversVerified = FALSE;

    if (ReadMmString (MmKey, 
            RegVerifyDriversValueName, 
            VrfState->DriverNames, 
            sizeof( VrfState->DriverNames ) ) == FALSE) {

        RegCloseKey (MmKey);
        return FALSE;
    }

    if ( VrfState->DriverNames[ 0 ] == TEXT('*') ) {

        VrfState->AllDriversVerified = TRUE;
        SetAllDriversStatus (VrfState, TRUE);
    }
    else {

        SetVerifiedDriversFromNamesString ( VrfState );
    }

    //
    // Get the kernel verifier state and mark any active drivers
    // as already verified.
    //

    if (KrnGetSystemVerifierState ( &KrnState ) == TRUE) {

        for (Index = 0; Index < KrnState.DriverCount; Index++) {

            if (VrfSearchVerifierDriver (
                VrfState, 
                KrnState.DriverInfo[Index].Name, 
                FoundIndex) == TRUE) {

                VrfState->DriverInfo[FoundIndex].CurrentlyVerified = TRUE;
            }
        }
    }

    //
    // Close the Mm key and return success
    //

    RegCloseKey (MmKey);
    return TRUE;
}


//
// Function:
//
//     VrfSetVerifierState
//
// Description:
//
//     Writes all Mm related registry settings according with
//     the structure.
//

BOOL
VrfSetVerifierState (

    PVRF_VERIFIER_STATE VrfState)
{
    HKEY MmKey = NULL;
    LONG Result;
    DWORD Value;
    size_t StringLength;
    size_t CrtCharIndex;

    //
    // Open the Mm key
    //

    Result = RegOpenKeyEx (

        HKEY_LOCAL_MACHINE,
        RegMemoryManagementKeyName,
        0,
        KEY_SET_VALUE,
        &MmKey);

    if (Result != ERROR_SUCCESS) {

        if( Result == ERROR_ACCESS_DENIED ) {

            VrfErrorResourceFormat(
                IDS_ACCESS_IS_DENIED );
        }
        else {

            VrfErrorResourceFormat(
                IDS_REGOPENKEYEX_FAILED,
                RegMemoryManagementKeyName,
                (DWORD)Result);
        }

        return FALSE;
    }

    //
    // Write VerifyDriverLevel value
    //

    Value = (VrfState->SpecialPoolVerification ? DRIVER_VERIFIER_SPECIAL_POOLING : 0);
    Value |= (VrfState->PagedCodeVerification ? DRIVER_VERIFIER_FORCE_IRQL_CHECKING : 0);
    Value |= (VrfState->AllocationFaultInjection ? DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES : 0);
    Value |= (VrfState->PoolTracking ? DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS : 0);
    Value |= (VrfState->IoVerifier ? DRIVER_VERIFIER_IO_CHECKING : 0);

    if (WriteRegistryValue (MmKey, RegVerifyDriverLevelValueName, Value) == FALSE) {

        RegCloseKey (MmKey);
        return FALSE;
    }

    //
    // enable/disable system level IO verifier
    //   
    if ( VrfState->IoVerifier == FALSE ) 
    {
        VrfState->SysIoVerifierLevel = 0;
    }    

    if( ! SetSysIoVerifierSettings(
        VrfState->SysIoVerifierLevel ) )
    {
        RegCloseKey (MmKey);
        return FALSE;
    }

    //
    // Write VerifyDrivers value
    //

    if (VrfState->AllDriversVerified) {

        if (WriteMmString (MmKey, RegVerifyDriversValueName, TEXT("*")) == FALSE) {

            RegCloseKey (MmKey);
            return FALSE;
        }
    }
    else {

        GetVerifiedDriversToString (
            VrfState );

        //
        // do we have any significant characters in VrfState->DriverNames?
        //

        StringLength = _tcslen( VrfState->DriverNames );

        for( CrtCharIndex = 0; CrtCharIndex < StringLength; CrtCharIndex++ ) {

            if( VrfState->DriverNames[ CrtCharIndex ] != _T( ' ' ) &&
                VrfState->DriverNames[ CrtCharIndex ] != _T( '\t' ) ) {

                break;
            }

        }

        if( CrtCharIndex < StringLength )
        {
            //
            // we have at least one significant character in the string
            //

            if (WriteMmString (MmKey, RegVerifyDriversValueName, VrfState->DriverNames) == FALSE) {

                RegCloseKey (MmKey);
                return FALSE;
            }
        }
        else {

            //
            // no drivers will be verified, erase the driver list from the registry
            //

            Result = RegDeleteValue (MmKey, RegVerifyDriversValueName);

            if (Result != ERROR_SUCCESS && Result != ERROR_FILE_NOT_FOUND) {

                VrfErrorResourceFormat(
                    IDS_REGDELETEVALUE_FAILED,
                    RegVerifyDriversValueName,
                    (DWORD)Result);

                RegCloseKey (MmKey);
                return FALSE;
            }

        }
    }

    //
    // Close the Mm key and return success
    //

    RegCloseKey (MmKey);
    return TRUE;
}


//
// Function:
//
//     VrfSetVolatileFlags
//
// Description:
//
//     This functions modifies verifier options on the fly.
//

BOOL
VrfSetVolatileFlags (

    UINT uNewFlags)
{
    NTSTATUS Status;

    //
    // Just use NtSetSystemInformation to set the flags
    // that can be modified on the fly. Don't write anything to the registry.
    //

    //
    // enable debug privilege
    //

    if( g_bPrivegeEnabled != TRUE )
    {
        g_bPrivegeEnabled = VrfEnableDebugPrivilege();

        if( g_bPrivegeEnabled != TRUE )
        {
            return FALSE;
        }
    }

    //
    // set the new flags
    //

    Status = NtSetSystemInformation(
        SystemVerifierInformation,
        &uNewFlags,
        sizeof( uNewFlags ) );

    if( ! NT_SUCCESS( Status ) )
    {
        if( Status == STATUS_ACCESS_DENIED )
        {
            //
            // access denied
            //

            VrfErrorResourceFormat(
                IDS_ACCESS_IS_DENIED );
        }
        else
        {
            //
            // some other error
            //

            VrfErrorResourceFormat(
                IDS_CANNOT_CHANGE_SETTING_ON_FLY );
        }

        return FALSE;
    }

    return TRUE;
}

//
// Function:
//
//     VrfSetVolatileOptions
//
// Description:
//
//     This functions modifies verifier options on the fly.
//

BOOL
VrfSetVolatileOptions(

    BOOL bSpecialPool,
    BOOL bIrqlChecking,
    BOOL bFaultInjection )
{
    ULONG uNewFlags;

    uNewFlags = 0;

    if( bSpecialPool )
    {
        uNewFlags |= DRIVER_VERIFIER_SPECIAL_POOLING;
    }

    if( bIrqlChecking )
    {
        uNewFlags |= DRIVER_VERIFIER_FORCE_IRQL_CHECKING;
    }

    if( bFaultInjection )
    {
        uNewFlags |= DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES;
    }

    return VrfSetVolatileFlags( uNewFlags );
}


//
// Function:
//
//     VrfClearAllVerifierSettings
//
// Description:
//
//     This functions deletes all registry values that control in one
//     way or another the Driver Verifier.
//

BOOL
VrfClearAllVerifierSettings (

    )
{
    HKEY MmKey = NULL;
    HKEY IoKey = NULL;
    LONG Result;
    LPTSTR ValueName;

    //
    // Open the Mm key
    //

    Result = RegOpenKeyEx (

        HKEY_LOCAL_MACHINE,
        RegMemoryManagementKeyName,
        0,
        KEY_SET_VALUE,
        &MmKey);

    if (Result != ERROR_SUCCESS) {

        if( Result == ERROR_ACCESS_DENIED ) {

            VrfErrorResourceFormat(
                IDS_ACCESS_IS_DENIED );
        }
        else {

            VrfErrorResourceFormat(
                IDS_REGOPENKEYEX_FAILED,
                RegMemoryManagementKeyName,
                (DWORD)Result);
        }

        return FALSE;
    }

    //
    // Delete VerifyDriverLevel value
    //

    ValueName = (LPTSTR)RegVerifyDriverLevelValueName;
    Result = RegDeleteValue (MmKey, ValueName);

    if (Result != ERROR_SUCCESS && Result != ERROR_FILE_NOT_FOUND) {

        VrfErrorResourceFormat(
            IDS_REGDELETEVALUE_FAILED,
            ValueName,
            (DWORD)Result);

        RegCloseKey (MmKey);
        return FALSE;
    }

    //
    // Delete VerifyDrivers value
    //

    ValueName = (LPTSTR)RegVerifyDriversValueName;
    Result = RegDeleteValue (MmKey, ValueName);

    if (Result != ERROR_SUCCESS && Result != ERROR_FILE_NOT_FOUND) {

        VrfErrorResourceFormat(
            IDS_REGDELETEVALUE_FAILED,
            ValueName,
            (DWORD)Result);

        RegCloseKey (MmKey);
        return FALSE;
    }

    //
    // Close the Mm key
    //

    RegCloseKey (MmKey);

    //
    // delete the sys level IO verifier value
    //

    return SetSysIoVerifierSettings( 0 );
}


//
// Function:
//
//     VrfSearchVerifiedDriver
//
// Description:
//
//     This function searches the VerifierState->DriverInfo database for the specified
//     driver. It sets the index if something has been found.
//

BOOL
VrfSearchVerifierDriver (

    PVRF_VERIFIER_STATE VrfState,
    LPCTSTR DriverName,
    ULONG & HitIndex)
{
    ULONG Index;

    ASSERT (DriverName != NULL);

    for (Index = 0; Index < VrfState->DriverCount; Index++) {

        if (_tcsicmp (DriverName, VrfState->DriverInfo[Index].Name) == 0) {

            HitIndex = Index;
            return TRUE;
        }
    }

    return FALSE;
}


//////////////////////////////////////////////////////////////////////
////////////////////////////////////////// System verifier information
//////////////////////////////////////////////////////////////////////


//
// Function:
//
//     KrnGetSystemVerifierState
//
// Description:
//
//     This function queries the system verifier state using
//     NtQuerysystemInformation().
//

BOOL
KrnGetSystemVerifierState (

    PKRN_VERIFIER_STATE KrnState)
{
    ULONG Index;
    NTSTATUS Status;
    ULONG Length = 0;
    ULONG buffersize;
    PSYSTEM_VERIFIER_INFORMATION VerifierInfo;
    PSYSTEM_VERIFIER_INFORMATION VerifierInfoBase;

    //
    // Sanity checks
    //

    if (KrnState == NULL) {

        return FALSE;
    }

    //
    // Initalize the returned structure and global vars
    // before the search.
    //

    VerifierInfo = NULL;

    KrnState->DriverCount = 0;

    //
    // Try to get the right size for the NtQuery buffer
    //

    buffersize = 1024;

    do {
        VerifierInfo = (PSYSTEM_VERIFIER_INFORMATION)malloc (buffersize);
        if (VerifierInfo == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        Status = NtQuerySystemInformation (SystemVerifierInformation,
                                           VerifierInfo,
                                           buffersize,
                                           &Length);

        if (Status != STATUS_INFO_LENGTH_MISMATCH) {
            break;
        }

        free (VerifierInfo);
        buffersize += 1024;
    } while (1);

    if (! NT_SUCCESS(Status)) {

        VrfErrorResourceFormat(
            IDS_QUERY_SYSINFO_FAILED,
            Status);

        return FALSE;
    }

    //
    // If no info fill out return success but no info.
    //

    if (Length == 0) {

        free (VerifierInfo);
        return TRUE;
    }

    //
    // Fill out the cumulative-driver stuff.
    //

    VerifierInfoBase = VerifierInfo;

    KrnState->Level = VerifierInfo->Level;
    KrnState->SpecialPool = (VerifierInfo->Level & DRIVER_VERIFIER_SPECIAL_POOLING) ? TRUE : FALSE;
    KrnState->IrqlChecking = (VerifierInfo->Level & DRIVER_VERIFIER_FORCE_IRQL_CHECKING) ? TRUE : FALSE;
    KrnState->FaultInjection = (VerifierInfo->Level & DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES) ? TRUE : FALSE;
    KrnState->PoolTrack = (VerifierInfo->Level & DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS) ? TRUE : FALSE;
    KrnState->IoVerif = (VerifierInfo->Level & DRIVER_VERIFIER_IO_CHECKING) ? TRUE : FALSE;

    KrnState->RaiseIrqls = VerifierInfo->RaiseIrqls;
    KrnState->AcquireSpinLocks = VerifierInfo->AcquireSpinLocks;
    KrnState->SynchronizeExecutions = VerifierInfo->SynchronizeExecutions;
    KrnState->AllocationsAttempted = VerifierInfo->AllocationsAttempted;
    KrnState->AllocationsSucceeded = VerifierInfo->AllocationsSucceeded;
    KrnState->AllocationsSucceededSpecialPool = VerifierInfo->AllocationsSucceededSpecialPool;
    KrnState->AllocationsWithNoTag = VerifierInfo->AllocationsWithNoTag;

    KrnState->Trims = VerifierInfo->Trims;
    KrnState->AllocationsFailed = VerifierInfo->AllocationsFailed;
    KrnState->AllocationsFailedDeliberately = VerifierInfo->AllocationsFailedDeliberately;

    KrnState->UnTrackedPool = VerifierInfo->UnTrackedPool;

    //
    // Fill out the per-driver stuff.
    //

    VerifierInfo = VerifierInfoBase;
    Index = 0;

    do {

        ANSI_STRING Name;
        NTSTATUS Status;

        Status = RtlUnicodeStringToAnsiString (
            & Name,
            & VerifierInfo->DriverName,
            TRUE);

        if (! (NT_SUCCESS(Status))) {

            free (VerifierInfoBase);
            return FALSE;
        }

        ConvertAnsiStringToTcharString (

            (LPBYTE)(Name.Buffer),
            Name.Length,
            KrnState->DriverInfo[Index].Name,
            ARRAY_LENGTH( KrnState->DriverInfo[Index].Name ) - 1 );

        RtlFreeAnsiString (& Name);

        KrnState->DriverInfo[Index].Loads = VerifierInfo->Loads;
        KrnState->DriverInfo[Index].Unloads = VerifierInfo->Unloads;

        KrnState->DriverInfo[Index].CurrentPagedPoolAllocations = VerifierInfo->CurrentPagedPoolAllocations;
        KrnState->DriverInfo[Index].CurrentNonPagedPoolAllocations = VerifierInfo->CurrentNonPagedPoolAllocations;
        KrnState->DriverInfo[Index].PeakPagedPoolAllocations = VerifierInfo->PeakPagedPoolAllocations;
        KrnState->DriverInfo[Index].PeakNonPagedPoolAllocations = VerifierInfo->PeakNonPagedPoolAllocations;

        KrnState->DriverInfo[Index].PagedPoolUsageInBytes = VerifierInfo->PagedPoolUsageInBytes;
        KrnState->DriverInfo[Index].NonPagedPoolUsageInBytes = VerifierInfo->NonPagedPoolUsageInBytes;
        KrnState->DriverInfo[Index].PeakPagedPoolUsageInBytes = VerifierInfo->PeakPagedPoolUsageInBytes;
        KrnState->DriverInfo[Index].PeakNonPagedPoolUsageInBytes = VerifierInfo->PeakNonPagedPoolUsageInBytes;

        KrnState->DriverCount++;
        Index++;

        if (VerifierInfo->NextEntryOffset == 0) {
            break;
        }

        VerifierInfo = (PSYSTEM_VERIFIER_INFORMATION)((PCHAR)VerifierInfo + VerifierInfo->NextEntryOffset);

    } 
    while (1);

    free (VerifierInfoBase);
    return TRUE;
}


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////// Read/write Mm Registry Values
//////////////////////////////////////////////////////////////////////

BOOL
ReadRegistryValue (

    HKEY HKey,
    LPCTSTR Name,
    DWORD * Value,
    DWORD DefaultValue)
{
    LONG Result;
    DWORD Reserved;
    DWORD Type;
    DWORD Size;

    //
    // default value
    //

    *Value = DefaultValue;
    Size = sizeof *Value;

    Result = RegQueryValueEx (

        HKey,
        Name,
        0,
        &Type,
        (LPBYTE)(Value),
        &Size);

    //
    // Deal with a value that is not defined.
    //

    if (Result == ERROR_FILE_NOT_FOUND) {
        *Value = 0;
        return TRUE;
    }

    if (Result != ERROR_SUCCESS) {

        VrfErrorResourceFormat(
            IDS_REGQUERYVALUEEX_FAILED,
            Name,
            (DWORD)Result);

        return FALSE;
    }

    if (Type != REG_DWORD) {

        VrfErrorResourceFormat(
            IDS_REGQUERYVALUEEX_UNEXP_TYPE,
            Name);

        return FALSE;
    }

    if (Size != sizeof *Value) {

        VrfErrorResourceFormat(
            IDS_REGQUERYVALUEEX_UNEXP_SIZE,
            Name);

        return FALSE;
    }

    return TRUE;
}



BOOL
WriteRegistryValue (

    HKEY HKey,
    LPCTSTR Name,
    DWORD Value)
{
    LONG Result;

    Result = RegSetValueEx (

        HKey,
        Name,
        0,
        REG_DWORD,
        (LPBYTE)(&Value),
        sizeof Value);


    if (Result != ERROR_SUCCESS) {

        VrfErrorResourceFormat(
            IDS_REGSETVALUEEX_FAILED,
            Name,
            (DWORD)Result);

        return FALSE;
    }

    return TRUE;
}


BOOL
ReadMmString (

    HKEY MmKey,
    LPCTSTR Name,
    LPTSTR Buffer,
    DWORD BufferSize)
{
    LONG Result;
    DWORD Reserved;
    DWORD Type;
    DWORD Size;

    //
    // default value
    //

    *Buffer = 0;
    Size = BufferSize;

    Result = RegQueryValueEx (

        MmKey,
        Name,
        0,
        &Type,
        (LPBYTE)(Buffer),
        &Size);

    //
    // Deal with a value that is not defined.
    //

    if (Result == ERROR_FILE_NOT_FOUND) {
        *Buffer = 0;
        return TRUE;
    }

    if (Result != ERROR_SUCCESS) {

        VrfErrorResourceFormat(
            IDS_REGQUERYVALUEEX_FAILED,
            Name,
            (DWORD)Result);

        return FALSE;
    }

    if (Type != REG_SZ) {

        VrfErrorResourceFormat(
            IDS_REGQUERYVALUEEX_UNEXP_TYPE,
            Name);

        return FALSE;
    }

    return TRUE;
}


BOOL
WriteMmString (

    HKEY MmKey,
    LPCTSTR Name,
    LPTSTR Value)
{
    LONG Result;
    DWORD Reserved;
    DWORD Type;
    DWORD Size;

    Result = RegSetValueEx (

        MmKey,
        Name,
        0,
        REG_SZ,
        (LPBYTE)(Value),
        (_tcslen (Value) + 1) * sizeof (TCHAR));

    if (Result != ERROR_SUCCESS) {

        VrfErrorResourceFormat(
            IDS_REGSETVALUEEX_FAILED,
            Name,
            (DWORD)Result);

        return FALSE;
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////
BOOL
SetSysIoVerifierSettings(
    ULONG SysIoVerifierLevel )
{
    HKEY IoKey = NULL;
    HKEY SmKey = NULL;
    BOOL IoKeyOpened;
    LONG Result;
    BOOL bSuccess;

    bSuccess = TRUE;

    //
    // Open the "I/O System" key
    //

    IoKeyOpened = FALSE;

    Result = RegOpenKeyEx (
        HKEY_LOCAL_MACHINE,
        RegIOVerifyKeyName,
        0,
        KEY_QUERY_VALUE | KEY_WRITE,
        &IoKey);

    if( Result != ERROR_SUCCESS ) {

        if( Result == ERROR_FILE_NOT_FOUND ) {

            if( SysIoVerifierLevel != 0 ) {

                //
                // the IO key doesn't exist, try to create it
                //

                //
                // open the "Session Manager" key
                //

                Result = RegOpenKeyEx (
                    HKEY_LOCAL_MACHINE,
                    RegSessionManagerKeyName,
                    0,
                    KEY_QUERY_VALUE | KEY_WRITE,
                    &SmKey);

                if( Result != ERROR_SUCCESS ) {

                    VrfErrorResourceFormat(
                        IDS_REGOPENKEYEX_FAILED,
                        RegSessionManagerKeyName,
                        (DWORD)Result);

                    return FALSE;
                }

                //
                // create the IO key
                //

                Result = RegCreateKeyEx(
                    SmKey,
                    RegIOVerifySubKeyName,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_WRITE | KEY_QUERY_VALUE,
                    NULL,
                    &IoKey,
                    NULL );

                if( Result != ERROR_SUCCESS ) {

                    VrfErrorResourceFormat(
                        IDS_REGCREATEKEYEX_FAILED,
                        RegIOVerifyKeyName,
                        (DWORD)Result);

                    RegCloseKey (SmKey);
                    return FALSE;
                }

                //
                // IO key creation successful
                //

                RegCloseKey (SmKey);

                IoKeyOpened = TRUE;
            }

            //
            // else ( SysIoVerifierLevel == 0 )
            // don't need to create the IO key
            //

        }
        else {

            if( Result == ERROR_ACCESS_DENIED ) {

                //
                // access is denied
                //

                VrfErrorResourceFormat(
                    IDS_ACCESS_IS_DENIED );
            }
            else {

                //
                // other error opening the IO key
                //

                VrfErrorResourceFormat(
                    IDS_REGOPENKEYEX_FAILED,
                    RegIOVerifyKeyName,
                    (DWORD)Result);
            }

            return FALSE;
        }
    }
    else {

        IoKeyOpened = TRUE;
    }

    if( SysIoVerifierLevel != 0 ) {

        ASSERT( IoKeyOpened == TRUE );

        //
        // set the key
        //

        bSuccess = WriteRegistryValue(
            IoKey,
            RegIOVerifyLevelValueName,
            SYS_IO_VERIFIER_BASE_VALUE + SysIoVerifierLevel );

        RegCloseKey (IoKey);
    }
    else {

        if( IoKeyOpened == TRUE ) {

            //
            // the IO key exists, delete the value
            //

            Result = RegDeleteValue (IoKey, RegIOVerifyLevelValueName);

            if (Result != ERROR_SUCCESS && Result != ERROR_FILE_NOT_FOUND) {

                VrfErrorResourceFormat(
                    IDS_REGDELETEVALUE_FAILED,
                    RegIOVerifyLevelValueName,
                    (DWORD)Result);

                bSuccess = FALSE;
            }

            RegCloseKey (IoKey);
        }
    }

    return bSuccess;
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////// Driver Management
//////////////////////////////////////////////////////////////////////

//
// Function:
//
//     GetActiveDriversList
//
// Description:
//
//     This function determines all the drivers that are currently
//     loaded in the system. It will fill the 'DriverInfo' vector
//     with the drivers' names.
//
// Return:
//
//     The number of drivers detected whose names are written in
//     the 'DriverInfo' vector.
//

ULONG
GetActiveDriversList (

    PVRF_DRIVER_STATE DriverInfo,
    ULONG MaxNumberOfDrivers)
{
    LPTSTR Buffer;
    ULONG BufferSize;
    NTSTATUS Status;
    PRTL_PROCESS_MODULES Modules;
    ULONG Index;
    ULONG DriverIndex;
    BOOL bResult;
    TCHAR TcharBuffer [MAX_PATH];

    for (BufferSize = 0x10000; TRUE; BufferSize += 0x1000) {

        Buffer = (LPTSTR) malloc (BufferSize);

        if (Buffer == NULL) {
            return 0;
        }

        Status = NtQuerySystemInformation (

            SystemModuleInformation,
            (PVOID)Buffer,
            BufferSize,
            NULL);

        if (! NT_SUCCESS(Status)) {

            if (Status == STATUS_INFO_LENGTH_MISMATCH) {

                free( Buffer );

                continue;
            }
            else {

                VrfErrorResourceFormat(
                    IDS_CANT_GET_ACTIVE_DRVLIST,
                    Status);

                free (Buffer);
                return 0;
            }
        }
        else {
            break;
        }
    }

    Modules = (PRTL_PROCESS_MODULES)Buffer;

    for (   Index = 0, DriverIndex = 0; 
            Index < Modules->NumberOfModules && DriverIndex < MaxNumberOfDrivers; 
            Index++ ) 
    {

        TCHAR *First, *Last, *Current;

        //
        // Get to work in processing the full path driver.
        //

        ConvertAnsiStringToTcharString (

            Modules->Modules[Index].FullPathName,
            strlen( (const char *)(Modules->Modules[Index].FullPathName) ),
            TcharBuffer,
            ARRAY_LENGTH( TcharBuffer ) - 1 );

        First = TcharBuffer;
        Last = First + _tcslen (TcharBuffer);

        //
        // Filter modules not ending in ".sys"
        //

        if (Last - 4 <= First || _tcsicmp (Last - 4, TEXT(".sys")) != 0)
            continue;

        //
        // Extract the file name from the full path name
        //

        for (Current = Last; Current >= First; Current--) {

            if (*Current == TEXT('\\')) {
                break;
            }
        }

        ZeroMemory (&(DriverInfo[DriverIndex]), sizeof (DriverInfo[DriverIndex]));
        _tcsncpy ((DriverInfo[DriverIndex].Name), Current + 1, 30);

        bResult = VrfGetVersionInfo(
            DriverInfo[DriverIndex].Name,
            DriverInfo[DriverIndex].Provider,
            ARRAY_LENGTH( DriverInfo[DriverIndex].Provider ),
            DriverInfo[DriverIndex].Version,
            ARRAY_LENGTH( DriverInfo[DriverIndex].Version ) );

        if( bResult != TRUE )
        {
            //
            // defaults
            //

            bResult = GetStringFromResources(
                IDS_NOT_AVAILABLE,
                DriverInfo[DriverIndex].Provider,
                ARRAY_LENGTH( DriverInfo[DriverIndex].Provider ) );

            if( bResult != TRUE )
            {
                ASSERT( FALSE );
                DriverInfo[DriverIndex].Provider[ 0 ] = 0;
            }

            bResult = GetStringFromResources(
                IDS_NOT_AVAILABLE,
                DriverInfo[DriverIndex].Version,
                ARRAY_LENGTH( DriverInfo[DriverIndex].Version ) );

            if( bResult != TRUE )
            {
                ASSERT( FALSE );
                DriverInfo[DriverIndex].Version[ 0 ] = 0;
            }
        }

        DriverIndex++;
    }

    free (Buffer);
    return DriverIndex;
}


//
// Function:
//
//     SetVerifiedDriversFromNamesString
//
// Description:
//
//     This function parses the string containing all the 
//     verified drivers as it was read from the  registry, 
//     marks corresponding entries in the DriverInfo array
//     as verified and adds the rest of the driver names to 
//     AdditionalDriverNames.
//

BOOL
SetVerifiedDriversFromNamesString (

    PVRF_VERIFIER_STATE VrfState )
{
    ULONG Index;
    LPTSTR First, Last, Current, End;
    TCHAR Save;

    //
    // Sanity checks
    //

    if ( VrfState == NULL ) {

        return FALSE;
    }

    VrfState->AdditionalDriverNames[0] = 0;
    First = VrfState->DriverNames;
    Last = First + _tcslen (VrfState->DriverNames);

    for (Current = First; Current < Last; Current++) {

        if (*Current == TEXT(' ')
            || *Current == TEXT('\t')
            || *Current == TEXT('\n')) {

            continue;
        }

        //
        // Search for a driver name.
        //

        for (End = Current;
             *End != 0 && *End != TEXT(' ') && *End != TEXT('\n') && *End != TEXT('\t');
             End++) {

            // nothing
        }

        Save = *End;
        *End = 0;

        //
        // Search for the found driver in the VrfState->DriverInfo vector.
        //

        for (Index = 0; Index < VrfState->DriverCount; Index++) {

            if (_tcsicmp (VrfState->DriverInfo[Index].Name, Current) == 0) {

                VrfState->DriverInfo[Index].Verified = TRUE;
                break;
            }
        }

        //
        // Add the driver to the string with unloaded drivers if this is
        // not in the list.
        //

        if (Index == VrfState->DriverCount) {

            if( _tcslen( VrfState->AdditionalDriverNames ) + _tcslen( Current ) >= ARRAY_LENGTH( VrfState->AdditionalDriverNames ) )
            {
                //
                // Cannot strcat to AdditionalDriverNames, overflow 
                //

                return FALSE;
            }

            _tcscat (VrfState->AdditionalDriverNames, Current);
            _tcscat (VrfState->AdditionalDriverNames, TEXT(" "));
        }

        //
        // Restore written character and resume search for the next driver.
        //

        *End = Save;
        Current = End;
    }


    //
    // Now we have to mark miniports as checked in case we get something
    // from the registry string that links against a miniport.
    //

    for (Index = 0; Index < VrfState->DriverCount; Index++) {

        if (VrfState->DriverInfo[Index].Verified == TRUE) {

            VrfNotifyDriverSelection (VrfState, Index);
        }
    }

    //
    // The same check should happen for drivers that appear
    // in the AdditionalDriverNames buffer. These are drivers
    // that are not loaded right now but they still need the miniport
    // check.
    //

    First = VrfState->AdditionalDriverNames;
    Last = First + _tcslen (VrfState->AdditionalDriverNames);

    for (Current = First; Current < Last; Current++) {

        if (*Current == TEXT(' ') || *Current == TEXT('\t') || *Current == TEXT('\n')) {

            continue;
        }

        //
        // Search for a driver name.
        //

        for (End = Current;
             *End != 0 && *End != TEXT(' ') && *End != TEXT('\n') && *End != TEXT('\t');
             End++) {

            // nothing
        }

        Save = *End;
        *End = 0;

        //
        // Find out if there is a miniport linked against this driver.
        //

        {
            LPCTSTR Miniport;
            ULONG FoundIndex;
            VRF_DRIVER_LOAD_STATUS LoadStatus;

            Miniport = IsMiniportDriver (Current, LoadStatus);

            if (Miniport != NULL) {

                if (VrfSearchVerifierDriver (VrfState, Miniport, FoundIndex)) {

                    VrfState->DriverInfo[FoundIndex].Verified = TRUE;
                }
            }
        }

        //
        // Restore written character and resume search for the next driver.
        //

        *End = Save;
        Current = End;
    }

    //
    // Finally return
    //

    return TRUE;
}


//
// Function:
//
//     GetVerifiedDriversToString
//
// Description:
//
//     This function gets the state of settings as they are kept
//     in VrfState->DriverInfo and VrfState->AdditionalDriverNames and 
//     fills VrfState->DriverNames with driver names without duplicates.
//

BOOL
GetVerifiedDriversToString (

    PVRF_VERIFIER_STATE VrfState )
{
    ULONG Index;
    LPTSTR First, Last, Current;
    ULONG NameLength;
    TCHAR *Buffer;

    //
    // Sanity checks
    //

    if (VrfState == NULL) {

        return FALSE;
    }

    Buffer = VrfState->DriverNames;

    First = Buffer;
    Last = First + ARRAY_LENGTH( VrfState->DriverNames );
    Current = First;
    *Current = 0;

    for (Index = 0; Index < VrfState->DriverCount; Index++) {

        if ( VrfState->DriverInfo[Index].Verified ) {

            NameLength = _tcslen (VrfState->DriverInfo[Index].Name);

            if (Current + NameLength + 2 >= Last) {

                //
                // Buffer overflow
                //

                return FALSE;
            }

            _tcscpy (Current, VrfState->DriverInfo[Index].Name);
            Current += NameLength;
            *Current++ = TEXT(' ');
            *Current = 0;
        }
    }

    //
    // Copy the additional drivers at the end of the driver string
    // and avoid duplicates.
    //

    {
        LPTSTR FirstAddtl, CurrentAddtl, LastAddtl, EndAddtl;
        TCHAR SaveAddtl;

        _tcslwr (Buffer);
        _tcslwr (VrfState->AdditionalDriverNames);

        FirstAddtl = VrfState->AdditionalDriverNames;
        LastAddtl = FirstAddtl + _tcslen (VrfState->AdditionalDriverNames);

        for (CurrentAddtl = FirstAddtl; CurrentAddtl < LastAddtl; CurrentAddtl++) {

            if (*CurrentAddtl == TEXT(' ') || *CurrentAddtl == TEXT('\t') || *CurrentAddtl == TEXT('\n')) {

                continue;
            }

            //
            // Search for a driver name.
            //

            for (EndAddtl = CurrentAddtl;
                 *EndAddtl != TEXT('\0') && *EndAddtl != TEXT(' ') && *EndAddtl != TEXT('\n') && *EndAddtl != TEXT('\t');
                 EndAddtl++) {

                // nothing
            }

            SaveAddtl = *EndAddtl;
            *EndAddtl = 0;

            if (_tcsstr (Buffer, CurrentAddtl) == NULL) {

                _tcscat (Buffer, TEXT(" "));
                _tcscat (Buffer, CurrentAddtl);

                //
                // Figure out if we need to add a miniport to the checked
                // drivers string.
                //

                {
                    LPCTSTR MiniportName;
                    VRF_DRIVER_LOAD_STATUS LoadStatus;

                    MiniportName = IsMiniportDriver (CurrentAddtl, LoadStatus);

                    if (MiniportName == NULL && LoadStatus != VRF_DRIVER_LOAD_SUCCESS) {

                        switch (LoadStatus) {

                        case VRF_DRIVER_LOAD_SUCCESS:
                            break;

                        case VRF_DRIVER_LOAD_CANNOT_FIND_IMAGE:

                            VrfErrorResourceFormat(
                                IDS_CANT_FIND_IMAGE,
                                CurrentAddtl);

                            break;

                        case VRF_DRIVER_LOAD_INVALID_IMAGE:

                            VrfErrorResourceFormat(
                                IDS_INVALID_IMAGE,
                                CurrentAddtl);

                            break;

                        default:
                            ASSERT ( FALSE );
                            break;
                        }

                    }
                    else if (MiniportName != NULL && _tcsstr (Buffer, MiniportName) == NULL) {

                        _tcscat (Buffer, TEXT(" "));
                        _tcscat (Buffer, MiniportName);
                    }
                }
            }

            //
            // Restore written character and resume search for the next driver.
            //

            *EndAddtl = SaveAddtl;
            CurrentAddtl = EndAddtl;
        }

    }


    //
    // Finish
    //

    return TRUE;
}


BOOL
SetAllDriversStatus (

    PVRF_VERIFIER_STATE VrfState,
    BOOL Verified)
{
    ULONG Index;

    for (Index = 0; Index < VrfState->DriverCount; Index++) {

        VrfState->DriverInfo[Index].Verified = Verified;
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////// Driver selection notification
//////////////////////////////////////////////////////////////////////


LPTSTR Miniport [] = {

    TEXT ("videoprt.sys"),
    TEXT ("scsiport.sys"),
    NULL
};


LPCTSTR
IsMiniportDriver (

    LPCTSTR DriverName,
    VRF_DRIVER_LOAD_STATUS &ErrorCode)
{
    IMAGE_BROWSE_INFO Info;
    TCHAR DriverPath [MAX_PATH];
    ULONG Index;
    BOOL TryAgain = FALSE;


    ErrorCode = VRF_DRIVER_LOAD_SUCCESS;

    //
    // Search for the driver image.
    //

    if (ImgSearchDriverImage (DriverName, DriverPath, ARRAY_LENGTH( DriverPath ) ) == FALSE) {

        ErrorCode = VRF_DRIVER_LOAD_CANNOT_FIND_IMAGE;
        return NULL;
    }

    //
    // Parse the image
    //

    if (ImgInitializeBrowseInfo (DriverPath, &Info) == FALSE) {

        ImgDeleteBrowseInfo (& Info);
        ErrorCode = VRF_DRIVER_LOAD_INVALID_IMAGE;
        return NULL;
    }

    //
    // Iterate import modules
    //

    {
        PIMAGE_IMPORT_DESCRIPTOR CurrentDescriptor;

        CurrentDescriptor = Info.ImportDescriptor;

        while (CurrentDescriptor->Characteristics) {

            for (Index = 0; Miniport[Index]; Index++) {

                //
                // We need to apply an address correction to the descriptor name
                // because the address in an RVA for the loaded image not for the
                // file layout.
                //

                {
                    TCHAR NameBuffer [MAX_PATH];

                    ConvertAnsiStringToTcharString (
                        (LPBYTE)(CurrentDescriptor->Name + Info.AddressCorrection),
                        strlen( (const char *)( CurrentDescriptor->Name + Info.AddressCorrection ) ),
                        NameBuffer,
                        ARRAY_LENGTH( NameBuffer ) - 1 );

                    if (_tcsicmp (NameBuffer, Miniport[Index]) == 0) {

                        ImgDeleteBrowseInfo (& Info);
                        return Miniport[Index];
                    }
                }
            }

            CurrentDescriptor++;
        }
    }

    ImgDeleteBrowseInfo (& Info);
    return NULL;
}


//
// Function:
//
//     VrfNotifyDriverSelection
//
// Description:
//
//     This function is called from GUI part when a driver is
//     selected. In case the driver is linked against a miniport
//     driver we have to automatically add to the verified
//     drivers list the specific miniport.
//
// Return:
//
//     TRUE if an additional driver has been marked selected
//     due to indirect linking. FALSE if no change has been
//     made.
//

BOOL
VrfNotifyDriverSelection (

    PVRF_VERIFIER_STATE VerifierState,
    ULONG Index)
{
    LPCTSTR MiniportName;
    ULONG FoundIndex;
    VRF_DRIVER_LOAD_STATUS LoadStatus;

    //
    // Sanity checks
    //

    if ( Index >= VerifierState->DriverCount ) {

        return FALSE;
    }

    //
    // If this is a driver that links against a miniport as
    // opposed to ntoskrnl we should add the miniport to the
    // verified list.
    //

    try {

        MiniportName = IsMiniportDriver (

            VerifierState->DriverInfo[Index].Name,
            LoadStatus);

        switch (LoadStatus) {

        case VRF_DRIVER_LOAD_SUCCESS:
            break;

        case VRF_DRIVER_LOAD_CANNOT_FIND_IMAGE:

            VrfErrorResourceFormat(
                IDS_CANT_FIND_IMAGE,
                VerifierState->DriverInfo[Index].Name);

            break;

        case VRF_DRIVER_LOAD_INVALID_IMAGE:

            VrfErrorResourceFormat(
                IDS_INVALID_IMAGE,
                VerifierState->DriverInfo[Index].Name);

            break;

        default:
            ASSERT ( FALSE );
            break;
        }

    } catch (...) {

        //
        // Protect against a blunder in the image parsing code
        //

        VrfErrorResourceFormat(
            IDS_INVALID_IMAGE,
            VerifierState->DriverInfo[Index].Name);

        return FALSE;
    }

    if (MiniportName != NULL) {

        if (VrfSearchVerifierDriver (VerifierState, MiniportName, FoundIndex) == FALSE) {

            return FALSE;
        }

        VerifierState->DriverInfo[FoundIndex].Verified = TRUE;
        return TRUE;
    }

    return FALSE;
}


//////////////////////////////////////////////////////////////////////
BOOL
VrfGetVersionInfo(
    LPTSTR lptstrFileName,
    LPTSTR lptstrCompany,
    int nCompanyBufferLength,
    LPTSTR lptstrVersion,
    int nVersionBufferLength )
{
    DWORD dwWholeBlockSize;
    DWORD dwDummyHandle;
    UINT uInfoLengthInTChars;
    LPVOID lpWholeVerBlock;
    LPVOID lpTranslationInfoBuffer;
    LPVOID lpVersionString;
    LPVOID lpCompanyString;
    BOOL bResult;
    TCHAR strLocale[ 32 ];
    TCHAR strBlockName[ 64 ];
    TCHAR strDriverPath[ MAX_PATH ];

    //
    // sanity checks
    //

    if( lptstrFileName == NULL ||
        lptstrCompany == NULL || nCompanyBufferLength <= 0 ||
        lptstrVersion == NULL || nVersionBufferLength <= 0 )
    {
        ASSERT( FALSE );
        return FALSE;
    }

    //
    // get the full driver path
    //

    bResult = ImgSearchDriverImage(
        lptstrFileName,
        strDriverPath,
        ARRAY_LENGTH( strDriverPath ) );

    if( bResult != TRUE )
    {
        return FALSE;
    }

    //
    // get the size of the file info block
    //

    dwWholeBlockSize = GetFileVersionInfoSize(
        strDriverPath,
        &dwDummyHandle );

    if( dwWholeBlockSize == 0 )
    {
        return FALSE;
    }

    //
    // allocate the buffer for the version information
    //

    lpWholeVerBlock = malloc( dwWholeBlockSize );

    if( lpWholeVerBlock == NULL )
    {
        return FALSE;
    }

    //
    // get the version information
    //

    bResult = GetFileVersionInfo(
        strDriverPath,
        dwDummyHandle,
        dwWholeBlockSize,
        lpWholeVerBlock );

    if( bResult != TRUE )
    {
        free( lpWholeVerBlock );

        return FALSE;
    }

    //
    // get the locale info
    //

    bResult = VerQueryValue(
        lpWholeVerBlock,
        _T( "\\VarFileInfo\\Translation" ),
        &lpTranslationInfoBuffer,
        &uInfoLengthInTChars );

    if( bResult != TRUE || lpTranslationInfoBuffer == NULL )
    {
        free( lpWholeVerBlock );

        return FALSE;
    }

    //
    // Locale info comes back as two little endian words.
    // Flip 'em, 'cause we need them big endian for our calls.
    //

    _stprintf(
        strLocale,
        _T( "%02X%02X%02X%02X" ),
		HIBYTE( LOWORD ( * (LPDWORD) lpTranslationInfoBuffer) ),
		LOBYTE( LOWORD ( * (LPDWORD) lpTranslationInfoBuffer) ),
		HIBYTE( HIWORD ( * (LPDWORD) lpTranslationInfoBuffer) ),
		LOBYTE( HIWORD ( * (LPDWORD) lpTranslationInfoBuffer) ) );

    //
    // get the file version
    //

    _stprintf(
        strBlockName,
        _T( "\\StringFileInfo\\%s\\FileVersion" ),
        strLocale );

    bResult = VerQueryValue(
        lpWholeVerBlock,
        strBlockName,
        &lpVersionString,
        &uInfoLengthInTChars );

    if( bResult != TRUE )
    {
        free( lpWholeVerBlock );

        return FALSE;
    }

    if( uInfoLengthInTChars > (UINT)nVersionBufferLength )
    {
        uInfoLengthInTChars = (UINT)nVersionBufferLength;
    }

    if( uInfoLengthInTChars == 0 )
    {
        *lptstrVersion = 0;
    }
    else
    {
        MoveMemory(
            lptstrVersion,
            lpVersionString,
            uInfoLengthInTChars * sizeof( TCHAR ) );

        //
        // we need to zero terminate the string for above case
        // uInfoLengthInTChars > (UINT)nVersionBufferLength
        //

        lptstrVersion[ uInfoLengthInTChars - 1 ] = 0;
    }

    //
    // get the company name
    //

    _stprintf(
        strBlockName,
        _T( "\\StringFileInfo\\%s\\CompanyName" ),
        strLocale );

    bResult = VerQueryValue(
        lpWholeVerBlock,
        strBlockName,
        &lpCompanyString,
        &uInfoLengthInTChars );

    if( bResult != TRUE )
    {
        free( lpWholeVerBlock );

        return FALSE;
    }

    if( uInfoLengthInTChars > (UINT)nCompanyBufferLength )
    {
        uInfoLengthInTChars = (UINT)nCompanyBufferLength;
    }

    if( uInfoLengthInTChars == 0 )
    {
        *lptstrCompany = 0;
    }
    else
    {
        MoveMemory(
            lptstrCompany,
            lpCompanyString,
            uInfoLengthInTChars * sizeof( TCHAR ) );

        //
        // we need to zero terminate the string for above case
        // uInfoLengthInTChars > (UINT)nCompanyBufferLength
        //

        lptstrCompany[ uInfoLengthInTChars - 1 ] = 0;
    }

    //
    // clean-up
    //

    free( lpWholeVerBlock );

    return TRUE;
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////// String conversion
//////////////////////////////////////////////////////////////////////

//
// Function:
//
//     ConvertAnsiStringToTcharString
//
// Description:
//
//     This function converts an ANSI string to a TCHAR string,
//     that is ANSO or UNICODE.
//
//     The function is needed because the system returns the active
//     modules as ANSI strings.
//

BOOL
ConvertAnsiStringToTcharString (

    LPBYTE Source,
    ULONG SourceLength,
    LPTSTR Destination,
    ULONG DestinationLength)
{
    int nCharsConverted;
    int nBytesToTranslate;

    nBytesToTranslate = (int)( (SourceLength < DestinationLength) ? SourceLength : DestinationLength ) * sizeof( char );

    nCharsConverted = MultiByteToWideChar(
        CP_ACP,
        MB_ERR_INVALID_CHARS,
        (LPCSTR)Source,
        nBytesToTranslate,
        Destination,
        DestinationLength );

    ASSERT( nBytesToTranslate == nCharsConverted );

    if( nCharsConverted > 0 )
    {
        Destination[ nCharsConverted ] = 0;

        CharLower( Destination );
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////
////////////////////////////////////////////// Command-line processing
//////////////////////////////////////////////////////////////////////

BOOL
VrfDumpStateToFile(
    FILE *file,
    BOOL bConvertToOEM
)
{
    static KRN_VERIFIER_STATE KrnState;

    UINT Index;
    SYSTEMTIME SystemTime;
    TCHAR strLocalTime[ 64 ];
    TCHAR strLocalDate[ 64 ];


    if( file == NULL )
        return FALSE;

    //
    // output the date&time in the current user format
    //

    GetLocalTime( &SystemTime );

    if( GetDateFormat(
        LOCALE_USER_DEFAULT,
        0,
        &SystemTime,
        NULL,
        strLocalDate,
        ARRAY_LENGTH( strLocalDate ) ) )
    {
        VrfFTPrintf(
            bConvertToOEM,
            file,
            _T( "%s, " ),
            strLocalDate );
    }
    else
    {
        ASSERT( FALSE );
    }

    if( GetTimeFormat(
        LOCALE_USER_DEFAULT,
        0,
        &SystemTime,
        NULL,
        strLocalTime,
        ARRAY_LENGTH( strLocalTime ) ) )
    {
        VrfFTPrintf(
            bConvertToOEM,
            file,
            _T( "%s\n" ),
            strLocalTime);
    }
    else
    {
        ASSERT( FALSE );

        VrfFTPrintf(
            bConvertToOEM,
            file,
            _T( "\n" ) );
    }

    //
    // get the current verifier statistics
    //

    if (KrnGetSystemVerifierState (& KrnState) == FALSE) {

       VrfOuputStringFromResources(
            IDS_CANTGET_VERIF_STATE,
            bConvertToOEM,
            file );

        return FALSE;
    }

    if (KrnState.DriverCount == 0) {

        //
        // no statistics to dump
        //

        return VrfOuputStringFromResources(
            IDS_NO_DRIVER_VERIFIED,
            bConvertToOEM,
            file );
    }
    else {

        //
        // dump the counters
        //

        //
        // global counters
        //

        if( ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_LEVEL, KrnState.Level ) ) ||
            ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_RAISEIRQLS, KrnState.RaiseIrqls ) ) ||
            ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_ACQUIRESPINLOCKS, KrnState.AcquireSpinLocks ) ) ||
            ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_SYNCHRONIZEEXECUTIONS, KrnState.SynchronizeExecutions) ) ||

            ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_ALLOCATIONSATTEMPTED, KrnState.AllocationsAttempted) ) ||
            ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_ALLOCATIONSSUCCEEDED, KrnState.AllocationsSucceeded) ) ||
            ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_ALLOCATIONSSUCCEEDEDSPECIALPOOL, KrnState.AllocationsSucceededSpecialPool) ) ||
            ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_ALLOCATIONSWITHNOTAG, KrnState.AllocationsWithNoTag) ) ||

            ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_ALLOCATIONSFAILED, KrnState.AllocationsFailed) ) ||
            ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_ALLOCATIONSFAILEDDELIBERATELY, KrnState.AllocationsFailedDeliberately) ) ||

            ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_TRIMS, KrnState.Trims) ) ||

            ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_UNTRACKEDPOOL, KrnState.UnTrackedPool) ) )
        {

            return FALSE;
        }

        //
        // per driver counters
        //

        if( ! VrfOuputStringFromResources(
            IDS_THE_VERIFIED_DRIVERS,
            bConvertToOEM,
            file ) )
        {
            return FALSE;
        }

        for ( Index = 0; Index < KrnState.DriverCount; Index++) {

            VrfFTPrintf(
                bConvertToOEM,
                file,
                _T( "\n" ) );

            if( VrfFTPrintfResourceFormat(
                    bConvertToOEM,
                    file,
                    IDS_NAME_LOADS_UNLOADS,
                    KrnState.DriverInfo[Index].Name,
                    KrnState.DriverInfo[Index].Loads,
                    KrnState.DriverInfo[Index].Unloads) == FALSE )
            {
                return FALSE;
            }

            //
            // pool statistics
            //

            if( ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_CURRENTPAGEDPOOLALLOCATIONS, KrnState.DriverInfo[Index].CurrentPagedPoolAllocations) ) ||
                ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_CURRENTNONPAGEDPOOLALLOCATIONS, KrnState.DriverInfo[Index].CurrentNonPagedPoolAllocations) ) ||
                ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_PEAKPAGEDPOOLALLOCATIONS, KrnState.DriverInfo[Index].PeakPagedPoolAllocations) ) ||
                ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_PEAKNONPAGEDPOOLALLOCATIONS, KrnState.DriverInfo[Index].PeakNonPagedPoolAllocations) ) ||

                ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_PAGEDPOOLUSAGEINBYTES, (ULONG) KrnState.DriverInfo[Index].PagedPoolUsageInBytes) ) ||
                ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_NONPAGEDPOOLUSAGEINBYTES, (ULONG) KrnState.DriverInfo[Index].NonPagedPoolUsageInBytes) ) ||
                ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_PEAKPAGEDPOOLUSAGEINBYTES, (ULONG) KrnState.DriverInfo[Index].PeakPagedPoolUsageInBytes) ) ||
                ( ! VrfFTPrintfResourceFormat( bConvertToOEM, file, IDS_PEAKNONPAGEDPOOLUSAGEINBYTES, (ULONG) KrnState.DriverInfo[Index].PeakNonPagedPoolUsageInBytes) ) )
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////
void
PrintHelpInformation()
{
    VrfTPrintfResourceFormat( IDS_HELP_LINE1, VER_PRODUCTVERSION_STR );

    VrfPrintNarrowStringOEMFormat( VER_LEGALCOPYRIGHT_STR );

    VrfPrintStringFromResources( IDS_HELP_LINE3 );
    VrfPrintStringFromResources( IDS_HELP_LINE4 );
    VrfPrintStringFromResources( IDS_HELP_LINE5 );
    VrfPrintStringFromResources( IDS_HELP_LINE6 );
    VrfPrintStringFromResources( IDS_HELP_LINE7 );
    VrfPrintStringFromResources( IDS_HELP_LINE8 );
    VrfPrintStringFromResources( IDS_HELP_LINE9 );
    VrfPrintStringFromResources( IDS_HELP_LINE10 );
    VrfPrintStringFromResources( IDS_HELP_LINE11 );
    VrfPrintStringFromResources( IDS_HELP_LINE12 );
    VrfPrintStringFromResources( IDS_HELP_LINE13 );
    VrfPrintStringFromResources( IDS_HELP_LINE14 );
    VrfPrintStringFromResources( IDS_HELP_LINE15 );
    VrfPrintStringFromResources( IDS_HELP_LINE16 );
    VrfPrintStringFromResources( IDS_HELP_LINE17 );
    VrfPrintStringFromResources( IDS_HELP_LINE18 );
    VrfPrintStringFromResources( IDS_HELP_LINE19 );
    VrfPrintStringFromResources( IDS_HELP_LINE20 );
    VrfPrintStringFromResources( IDS_HELP_LINE21 );
    VrfPrintStringFromResources( IDS_HELP_LINE22 );
    VrfPrintStringFromResources( IDS_HELP_LINE23 );
    VrfPrintStringFromResources( IDS_HELP_LINE24 );
    VrfPrintStringFromResources( IDS_HELP_LINE25 );
    VrfPrintStringFromResources( IDS_HELP_LINE26 );
    VrfPrintStringFromResources( IDS_HELP_LINE27 );
    VrfPrintStringFromResources( IDS_HELP_LINE28 );
    VrfPrintStringFromResources( IDS_HELP_LINE29 );
    VrfPrintStringFromResources( IDS_HELP_LINE30 );
    VrfPrintStringFromResources( IDS_HELP_LINE31 );
}

//////////////////////////////////////////////////////////////////////
DWORD
VrfExecuteCommandLine (

    int Count,
    LPTSTR Args[])
{
    static KRN_VERIFIER_STATE KrnState;

    ULONG Flags;
    ULONG IoLevel;
    int Index;
    UINT LoadStringResult;
    VRF_DRIVER_LOAD_STATUS LoadStatus;
    BOOL CreateLog;
    LPTSTR LogFileName;
    DWORD LogInterval;
    FILE *file;
    BOOL bFlagsSpecified = FALSE;
    BOOL bIoLevelSpecified = FALSE;
    BOOL bNamesSpecified = FALSE;
    BOOL bVolatileSpecified = FALSE;
    TCHAR strDriver[ 64 ];
    DWORD nReturnValue;
    NTSTATUS Status;
    BOOL bResult;
    BOOL bIoVerifierEnabled;
    ULONG SysIoVerifierLevel;
    TCHAR Names [4196];
    TCHAR OldNames [4196];
    TCHAR strCmdLineOption[ 128 ];
    TCHAR WarningBuffer [256];

    g_bCommandLineMode = TRUE;
    nReturnValue = EXIT_CODE_SUCCESS;

    ASSERT (Count != 0);

    Flags = 1;
    Names[0] = 0;

    //
    // Search for help
    //

    if( GetStringFromResources(
        IDS_HELP_CMDLINE_SWITCH,
        strCmdLineOption,
        ARRAY_LENGTH( strCmdLineOption ) ) )
    {
        if (Count == 2 && _tcsicmp (Args[1], strCmdLineOption) == 0)
        {
            PrintHelpInformation();

            return nReturnValue;
        }
    }

    //
    // Figure out if we are on a valid build for the
    // driver verifier functionality.
    //

    if (g_OsVersion.dwMajorVersion < 5 || g_OsVersion.dwBuildNumber < 1954) {

        //
        // Right now we do not do anything if we do not have the right build.
        //

        VrfPrintStringFromResources( IDS_BUILD_WARN );

        return nReturnValue;
    }

    //
    // Search for /reset
    //

    if( GetStringFromResources(
        IDS_RESET_CMDLINE_SWITCH,
        strCmdLineOption,
        ARRAY_LENGTH( strCmdLineOption ) ) )
    {
        if (Count == 2 && _tcsicmp (Args[1], strCmdLineOption) == 0)
        {
            if( VrfClearAllVerifierSettings() )
            {
                return EXIT_CODE_REBOOT_NEEDED;
            }
            else
            {
                return EXIT_CODE_ERROR;
            }
        }
    }

    //
    // Search for /log
    //

    CreateLog = FALSE;

    if( GetStringFromResources(
        IDS_LOG_CMDLINE_SWITCH,
        strCmdLineOption,
        ARRAY_LENGTH( strCmdLineOption ) ) )
    {

        for (Index = 1; Index < Count - 1; Index++)
        {
            if (_tcsicmp (Args[Index], strCmdLineOption ) == 0)
            {
                CreateLog = TRUE;

                LogFileName = Args[Index + 1];

                break;
            }
        }
    }

    if( CreateLog )
    {
        //
        // Default Value
        //

        LogInterval = 30000; // 30 sec

        //
        // Search for /interval
        //

        if( GetStringFromResources(
            IDS_INTERVAL_CMDLINE_SWITCH,
            strCmdLineOption,
            ARRAY_LENGTH( strCmdLineOption ) ) )
        {
            for (Index = 1; Index < Count - 1; Index++)
            {
                if (_tcsicmp (Args[Index], strCmdLineOption) == 0)
                {
                    LogInterval = _ttoi (Args[Index + 1]) * 1000;

                    if( LogInterval == 0 )
                    {
                        LogInterval = 30000; // 30 sec
                    }
                }
            }
        }

        //
        // Infinite loop
        //

        while( TRUE )
        {
            //
            // Open the file
            //

            file = _tfopen( LogFileName, TEXT("a+") );

            if( file == NULL )
            {
                //
                // print a error message
                //

                VrfTPrintfResourceFormat(
                    IDS_CANT_APPEND_FILE,
                    LogFileName );

                break;
            }

            //
            // Dump current information
            //

            if( ! VrfDumpStateToFile ( file, FALSE ) ) {

                //
                // Insufficient disk space ?
                //

                VrfTPrintfResourceFormat(
                    IDS_CANT_WRITE_FILE,
                    LogFileName );
            }

            fflush( file );

            VrfFTPrintf(
                FALSE,
                file,
                TEXT("\n\n") );

            //
            // Close the file
            //

            fclose( file );

            //
            // Sleep
            //

            Sleep( LogInterval );
        }

        return nReturnValue;
    }

    //
    // Search for /query
    //

    if( GetStringFromResources(
        IDS_QUERY_CMDLINE_SWITCH,
        strCmdLineOption,
        ARRAY_LENGTH( strCmdLineOption ) ) )
    {
        if (Count == 2 && _tcsicmp (Args[1], strCmdLineOption) == 0)
        {
            VrfDumpStateToFile ( stdout, TRUE );
            fflush( stdout );

            return nReturnValue;
        }
    }

    //
    // Search for /flags
    //

    if( GetStringFromResources(
        IDS_FLAGS_CMDLINE_SWITCH,
        strCmdLineOption,
        ARRAY_LENGTH( strCmdLineOption ) ) )
    {
        for (Index = 1; Index < Count - 1; Index++)
        {
            if (_tcsicmp (Args[Index], strCmdLineOption) == 0)
            {
                Flags = _ttoi (Args[Index + 1]);

                Flags &= VerifierAllOptions;

                bFlagsSpecified = TRUE;
            }
        }
    }

    //
    // Search for /iolevel
    //

    if( GetStringFromResources(
        IDS_IOLEVEL_CMDLINE_SWITCH,
        strCmdLineOption,
        ARRAY_LENGTH( strCmdLineOption ) ) )
    {
        for (Index = 1; Index < Count - 1; Index++)
        {
            if (_tcsicmp (Args[Index], strCmdLineOption) == 0)
            {
                IoLevel = _ttoi (Args[Index + 1]);

                if( ( IoLevel != 0 ) && ( IoLevel <= IO_VERIFICATION_LEVEL_MAX ) )
                {
                    bIoLevelSpecified = TRUE;
                }
            }
        }
    }

    //
    // Search for /all
    //

    if( GetStringFromResources(
        IDS_ALL_CMDLINE_SWITCH,
        strCmdLineOption,
        ARRAY_LENGTH( strCmdLineOption ) ) )
    {
        for (Index = 1; Index < Count; Index++)
        {
            if (_tcsicmp (Args[Index], strCmdLineOption) == 0)
            {
                _tcscat (Names, TEXT("*"));

                bNamesSpecified = TRUE;
            }
        }
    }

    //
    // Search for /driver
    //

    LoadStringResult = LoadString (         // cannot reuse the static string buffer

        GetModuleHandle (NULL),
        IDS_DRIVER_CMDLINE_SWITCH,
        strDriver,
        sizeof strDriver / sizeof (TCHAR));

    ASSERT (LoadStringResult > 0);

    if (LoadStringResult > 0) {

        for (Index = 1; Index < Count - 1; Index++) {

            if (_tcsicmp (Args[Index], strDriver) == 0) {

                int NameIndex;
                LPCTSTR MiniportName;

                bNamesSpecified = ( Index < ( Count - 1 ) ); // have some driver names?

                for (NameIndex = Index + 1; NameIndex < Count; NameIndex++) {

                    _tcscat (Names, Args[NameIndex]);
                    _tcscat (Names, TEXT(" "));

                    MiniportName = IsMiniportDriver (Args[NameIndex], LoadStatus);

                    if (MiniportName == NULL && LoadStatus != VRF_DRIVER_LOAD_SUCCESS) {

                        switch (LoadStatus) {
                        case VRF_DRIVER_LOAD_SUCCESS:
                            break;

                        case VRF_DRIVER_LOAD_CANNOT_FIND_IMAGE:

                            VrfTPrintfResourceFormat(
                                IDS_CANT_FIND_IMAGE,
                                Args[NameIndex] );

                            //
                            // newline
                            //

                            VrfPutTS( _TEXT( "" ) );

                            break;

                        case VRF_DRIVER_LOAD_INVALID_IMAGE:

                            VrfTPrintfResourceFormat(
                                IDS_INVALID_IMAGE,
                                Args[NameIndex] );

                            //
                            // newline
                            //

                            VrfPutTS( _TEXT( "" ) );

                            break;

                        default:
                            ASSERT ( FALSE );
                            break;
                        }
                    }
                    else if (MiniportName != NULL && _tcsstr (Names, MiniportName) == NULL) {

                        _tcscat (Names, MiniportName);
                        _tcscat (Names, TEXT(" "));
                    }
                }

                break;
            }
        }
    }

    //
    // Search for /volatile
    //

    if( GetStringFromResources(
        IDS_DONTREBOOT_CMDLINE_SWITCH,
        strCmdLineOption,
        ARRAY_LENGTH( strCmdLineOption ) ) )
    {
        for (Index = 1; Index < Count; Index++)
        {

            if (_tcsicmp (Args[Index], strCmdLineOption) == 0)
            {
                bVolatileSpecified = TRUE;

                //
                // found /volatile in the command line
                //

                if( bFlagsSpecified && ! bNamesSpecified )
                {
                    if( g_OsVersion.dwBuildNumber >= 2055 )
                    {
                        //
                        // see if there are any verifier flags active
                        //

                        if (KrnGetSystemVerifierState (& KrnState) == FALSE)
                        {
                            //
                            // cannot get current verifier settings
                            //

                            VrfPrintStringFromResources( IDS_CANTGET_VERIF_STATE );

                            return EXIT_CODE_ERROR;
                        }
                        else
                        {
                            //
                            // compare the active flags with the new ones
                            //

                            if( KrnState.DriverCount != 0 )
                            {
                                //
                                // there are some drivers currently verified
                                //

                                if( KrnState.Level != Flags )
                                {
                                    //
                                    // try to change something on the fly
                                    //

                                    bResult = VrfSetVolatileFlags(
                                        Flags );

                                    if( bResult )
                                    {
                                        //
                                        // success - tell the user what flags have changed
                                        //

                                        VrfDumpChangedSettings(
                                            KrnState.Level,
                                            Flags );

                                        return EXIT_CODE_SUCCESS;
                                    }
                                    else
                                    {
                                        //
                                        // cannot change settings
                                        //

                                        return EXIT_CODE_ERROR;
                                    }
                                }
                                else
                                {
                                    //
                                    // the specified flags are the same as the active ones
                                    //

                                    VrfPrintStringFromResources( IDS_SAME_FLAGS_AS_ACTIVE );

                                    return EXIT_CODE_SUCCESS;
                                }
                            }
                            else
                            {
                                VrfPrintStringFromResources( IDS_NO_DRIVER_VERIFIED );

                                return EXIT_CODE_SUCCESS;
                            }
                        }
                    }
                    else
                    {
                        //
                        // the build is too old - we cannot change options on the fly
                        //

                        VrfPrintStringFromResources( IDS_CANT_CHANGE_SETTINGS_BUILD_OLD );

                        return EXIT_CODE_ERROR;
                    }
                }
                else
                {
                    //
                    // the flags were not specified - look for /adddriver, /removedriver
                    //
                    
                    if( VrfVolatileAddOrRemoveDriversCmdLine( Count, Args ) == TRUE )
                    {
                        //
                        // changed the verified drivers list
                        //

                        return EXIT_CODE_SUCCESS;
                    }
                    else
                    {
                        //
                        // nothing to change
                        //

                        VrfPrintStringFromResources( IDS_NO_SETTINGS_WERE_CHANGED );

                        return EXIT_CODE_ERROR;
                    }
                }

                //
                // Unreached - the code above will always return from the function.
                //

                ASSERT( FALSE );

                return EXIT_CODE_ERROR;
            }
        }
    }
    else
    {
        ASSERT( FALSE );
    }

    //
    // Write everything to the registry
    //

    if( !bVolatileSpecified && ( bFlagsSpecified || bNamesSpecified ) )
    {
        HKEY MmKey = NULL;
        LONG Result;
        DWORD Value;
        DWORD OldValue;

        Result = RegOpenKeyEx (

            HKEY_LOCAL_MACHINE,
            RegMemoryManagementKeyName,
            0,
            KEY_SET_VALUE | KEY_QUERY_VALUE,
            &MmKey);

        if (Result != ERROR_SUCCESS) {

            if( Result == ERROR_ACCESS_DENIED ) {

                VrfPrintStringFromResources(
                    IDS_ACCESS_IS_DENIED );

                return EXIT_CODE_ERROR;
            }
            else {

                VrfTPrintfResourceFormat(
                    IDS_REGOPENKEYEX_FAILED,
                    RegMemoryManagementKeyName,
                    (DWORD)Result);

                //
                // newline
                //

                VrfPutTS( _TEXT( "" ) );

                return EXIT_CODE_ERROR;
            }
        }

        if( bFlagsSpecified )
        {
            Value = Flags;

            if( ReadRegistryValue ( MmKey, RegVerifyDriverLevelValueName, &OldValue, 0) == FALSE) {
                RegCloseKey (MmKey);
                return EXIT_CODE_ERROR;
            }

            if (WriteRegistryValue (MmKey, RegVerifyDriverLevelValueName, Value) == FALSE) {
                RegCloseKey (MmKey);
                return EXIT_CODE_ERROR;
            }

            bIoVerifierEnabled = ( (Flags & DRIVER_VERIFIER_IO_CHECKING) != 0 );

            if( bIoVerifierEnabled && bIoLevelSpecified == TRUE )
            {
                SysIoVerifierLevel = IoLevel;                               
            }
            else
            {
                SysIoVerifierLevel = 0;
            }

            if ( ! SetSysIoVerifierSettings ( SysIoVerifierLevel ) )
            {
                RegCloseKey (MmKey);
                return EXIT_CODE_ERROR;
            }

            if( OldValue != Value ) {

                nReturnValue = EXIT_CODE_REBOOT_NEEDED;
            }
        }

        if( bNamesSpecified )
        {
            if (ReadMmString (MmKey, RegVerifyDriversValueName, OldNames, sizeof( OldNames ) ) == FALSE) {
                RegCloseKey (MmKey);
                return EXIT_CODE_ERROR;
            }

            if (WriteMmString (MmKey, RegVerifyDriversValueName, Names) == FALSE) {
                RegCloseKey (MmKey);
                return EXIT_CODE_ERROR;
            }

            if( _tcsicmp (OldNames, Names) ){

                nReturnValue = EXIT_CODE_REBOOT_NEEDED;
            }
        }

        RegCloseKey (MmKey);

    }
    else
    {
        PrintHelpInformation();
    }

    return nReturnValue;
}

//////////////////////////////////////////////////////////////////////

BOOL
GetStringFromResources(

    UINT uIdResource,
    TCHAR *strBuffer,
    int nBufferLength )
{
    UINT LoadStringResult;

    if( strBuffer == NULL || nBufferLength < 1 )
    {
        ASSERT( FALSE );
        return FALSE;
    }

    LoadStringResult = LoadString (

        GetModuleHandle (NULL),
        uIdResource,
        strBuffer,
        nBufferLength );

    ASSERT (LoadStringResult > 0);

    return (LoadStringResult > 0);
}

//////////////////////////////////////////////////////////////////////

void
VrfPrintStringFromResources(

    UINT uIdResource)
{
    TCHAR strText[ 256 ];

    if( GetStringFromResources(
        uIdResource,
        strText,
        ARRAY_LENGTH( strText ) ) )
    {
        VrfOutputWideStringOEMFormat( strText, TRUE, stdout );
    }
}

//////////////////////////////////////////////////////////////////////

BOOL
VrfOuputStringFromResources(

    UINT uIdResource,
    BOOL bConvertToOEM,
    FILE *file )
{
    TCHAR strText[ 256 ];

    BOOL bResult;

    bResult = TRUE;

    if( GetStringFromResources(
        uIdResource,
        strText,
        ARRAY_LENGTH( strText ) ) )
    {
        if( bConvertToOEM )
        {
            VrfOutputWideStringOEMFormat( strText, TRUE, file );
        }
        else
        {
            bResult = ( _fputts( strText, file ) >= 0 );
        }
    }

    return bResult;
}

//////////////////////////////////////////////////////////////////////

void
VrfDumpChangedSettings(

    UINT OldFlags,
    UINT NewFlags )
{
    UINT uDifferentFlags;

    OldFlags &= VerifierModifyableOptions;
    NewFlags &= VerifierModifyableOptions;

    if( OldFlags == NewFlags )
    {
        //
        // no settings were changed
        //

        VrfPrintStringFromResources(
            IDS_NO_SETTINGS_WERE_CHANGED );
    }
    else
    {
        VrfPrintStringFromResources(
            IDS_CHANGED_SETTINGS_ARE );

        uDifferentFlags = OldFlags ^ NewFlags;

        //
        // changed DRIVER_VERIFIER_SPECIAL_POOLING ?
        //

        if( uDifferentFlags & DRIVER_VERIFIER_SPECIAL_POOLING )
        {
            if( NewFlags & DRIVER_VERIFIER_SPECIAL_POOLING )
            {
                VrfPrintStringFromResources(
                    IDS_SPECIAL_POOL_ENABLED_NOW );
            }
            else
            {
                VrfPrintStringFromResources(
                    IDS_SPECIAL_POOL_DISABLED_NOW );
            }
        }

        //
        // changed DRIVER_VERIFIER_FORCE_IRQL_CHECKING ?
        //

        if( uDifferentFlags & DRIVER_VERIFIER_FORCE_IRQL_CHECKING )
        {
            if( NewFlags & DRIVER_VERIFIER_FORCE_IRQL_CHECKING )
            {
                VrfPrintStringFromResources(
                    IDS_FORCE_IRQLCHECK_ENABLED_NOW );
            }
            else
            {
                VrfPrintStringFromResources(
                    IDS_FORCE_IRQLCHECK_DISABLED_NOW );
            }
        }

        //
        // changed DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES ?
        //

        if( uDifferentFlags & DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES )
        {
            if( NewFlags & DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES )
            {
                VrfPrintStringFromResources(
                    IDS_FAULT_INJECTION_ENABLED_NOW );
            }
            else
            {
                VrfPrintStringFromResources(
                    IDS_FAULT_INJECTION_DISABLED_NOW );
            }
        }

        //
        // changed DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS ?
        //

        if( uDifferentFlags & DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS )
        {
            if( NewFlags & DRIVER_VERIFIER_TRACK_POOL_ALLOCATIONS )
            {
                VrfPrintStringFromResources(
                    IDS_POOL_TRACK_ENABLED_NOW );
            }
            else
            {
                VrfPrintStringFromResources(
                    IDS_POOL_TRACK_DISABLED_NOW );
            }
        }

        //
        // changed DRIVER_VERIFIER_IO_CHECKING ?
        //

        if( uDifferentFlags & DRIVER_VERIFIER_IO_CHECKING )
        {
            if( NewFlags & DRIVER_VERIFIER_IO_CHECKING )
            {
                VrfPrintStringFromResources(
                    IDS_IO_CHECKING_ENABLED_NOW );
            }
            else
            {
                VrfPrintStringFromResources(
                    IDS_IO_CHECKING_DISABLED_NOW );
            }
        }

        //
        // the changes are not saved to the registry
        //

        VrfPrintStringFromResources(
            IDS_CHANGES_ACTIVE_ONLY_BEFORE_REBOOT );
    }
}


//////////////////////////////////////////////////////////////////////

BOOL
VrfEnableDebugPrivilege (
    )
{
    struct
    {
        DWORD Count;
        LUID_AND_ATTRIBUTES Privilege [1];

    } Info;

    HANDLE Token;
    BOOL Result;

    //
    // open the process token
    //

    Result = OpenProcessToken (
        GetCurrentProcess (),
        TOKEN_ADJUST_PRIVILEGES,
        & Token);

    if( Result != TRUE )
    {
        VrfErrorResourceFormat(
            IDS_ACCESS_IS_DENIED );

        return FALSE;
    }

    //
    // prepare the info structure
    //

    Info.Count = 1;
    Info.Privilege[0].Attributes = SE_PRIVILEGE_ENABLED;

    Result = LookupPrivilegeValue (
        NULL,
        SE_DEBUG_NAME,
        &(Info.Privilege[0].Luid));

    if( Result != TRUE )
    {
        VrfErrorResourceFormat(
            IDS_ACCESS_IS_DENIED );

        CloseHandle( Token );

        return FALSE;
    }

    //
    // adjust the privileges
    //

    Result = AdjustTokenPrivileges (
        Token,
        FALSE,
        (PTOKEN_PRIVILEGES) &Info,
        NULL,
        NULL,
        NULL);

    if( Result != TRUE || GetLastError() != ERROR_SUCCESS )
    {
        VrfErrorResourceFormat(
            IDS_ACCESS_IS_DENIED );

        CloseHandle( Token );

        return FALSE;
    }

    CloseHandle( Token );

    return TRUE;
}

//////////////////////////////////////////////////////////////////////

void
VrfPrintNarrowStringOEMFormat(

    char *szText )
{
    char szTextOEM[ 512 ];

    ASSERT( szText != NULL );

    //
    // make a copy of the string
    //

    strncpy( szTextOEM, szText, ARRAY_LENGTH( szTextOEM ) - 1 );

    szTextOEM[ ARRAY_LENGTH( szTextOEM ) - 1 ] = (char)0;

    //
    // convert the string to OEM
    //

    if( CharToOemA( szTextOEM, szTextOEM ) )
    {
        puts( szTextOEM );
    }
    else
    {
        ASSERT( FALSE );
    }
}

//////////////////////////////////////////////////////////////////////

BOOL
VrfOutputWideStringOEMFormat(

    LPTSTR strText,
    BOOL bAppendNewLine,
    FILE *file )
{
    TCHAR strTextCopy[ 512 ];
    BOOL bResult;
    char szTextOEM[ 512 ];

    if( strText == NULL || file == NULL )
    {
        ASSERT( FALSE );
        return FALSE;
    }

    //
    // make a copy of the string
    //

    _tcsncpy( strTextCopy, strText, ARRAY_LENGTH( strTextCopy ) - 1 );

    strTextCopy[ ARRAY_LENGTH( strTextCopy ) - 1 ] = (TCHAR)0;

    //
    // convert the string to OEM
    //

    if( CharToOem( strTextCopy, szTextOEM ) )
    {
        bResult = ( fputs( szTextOEM, file ) >= 0 );

        if( bResult && bAppendNewLine )
        {
            bResult = ( fputs( "\n", file ) >= 0 );
        }
    }
    else
    {
        ASSERT( FALSE );
        bResult = FALSE;
    }

    return bResult;
}

//////////////////////////////////////////////////////////////////////

BOOL
__cdecl
VrfFTPrintf(
    BOOL bConvertToOEM,
    FILE *file,
    LPTSTR fmt,
    ...)
{
    BOOL bResult;
    TCHAR strMessage[ 256 ];
    va_list prms;

    if( fmt == NULL || file == NULL )
    {
        ASSERT( FALSE );
        return FALSE;
    }

    va_start (prms, fmt);

    _vsntprintf ( strMessage, ARRAY_LENGTH( strMessage ), fmt, prms);

    if( bConvertToOEM )
    {
        bResult = VrfOutputWideStringOEMFormat(
            strMessage,
            FALSE,
            file );
    }
    else
    {
        bResult = ( _ftprintf( file, _T( "%s" ), strMessage ) >= 0 );
    }

    va_end (prms);

    return bResult;
}

//////////////////////////////////////////////////////////////////////

BOOL
__cdecl
VrfFTPrintfResourceFormat(
    BOOL bConvertToOEM,
    FILE *file,
    UINT uIdResFmtString,
    ...)
{
    TCHAR strFormat[ 256 ];
    TCHAR strMessage[ 256 ];
    va_list prms;
    BOOL bResult;

    bResult = TRUE;

    if( GetStringFromResources(
        uIdResFmtString,
        strFormat,
        ARRAY_LENGTH( strFormat ) ) )
    {
        va_start (prms, uIdResFmtString);

        _vsntprintf ( strMessage, ARRAY_LENGTH( strMessage ), strFormat, prms);

        if( bConvertToOEM )
        {
            bResult = VrfOutputWideStringOEMFormat(
                strMessage,
                FALSE,
                file );
        }
        else
        {
            bResult = ( _ftprintf( file, _T( "%s" ), strMessage ) >= 0 );
        }

        va_end (prms);
    }
    else
    {
        ASSERT( FALSE );
        bResult = FALSE;
    }

    return bResult;
}

//////////////////////////////////////////////////////////////////////

void
__cdecl
VrfTPrintfResourceFormat(
    UINT uIdResFmtString,
    ...)
{
    TCHAR strMessage[ 256 ];
    TCHAR strFormat[ 256 ];
    va_list prms;

    //
    // get the format string
    //

    if( GetStringFromResources(
            uIdResFmtString,
            strFormat,
            ARRAY_LENGTH( strFormat ) ) )
    {
        va_start (prms, uIdResFmtString);

        //
        // get the message string as UNICODE
        //

        _vsntprintf (
            strMessage,
            ARRAY_LENGTH( strMessage ),
            strFormat,
            prms);

        //
        // output it as OEM
        //

        VrfOutputWideStringOEMFormat(
            strMessage,
            FALSE,
            stdout );

        va_end (prms);
    }

    return;
}

//////////////////////////////////////////////////////////////////////

void
VrfPutTS(
    LPTSTR strText )
{
    if( strText == NULL )
    {
        ASSERT( FALSE );
        return;
    }

    VrfOutputWideStringOEMFormat(
        strText,
        TRUE,
        stdout );
}

//////////////////////////////////////////////////////////////////////
//
// Support for dynamic set of verified drivers
//

BOOL VrfVolatileAddDriver( 

    const WCHAR *szDriverName )
{
    UNICODE_STRING usDriverName;
    NTSTATUS Status;
    UINT uIdErrorString;

    //
    // enable debug privilege
    //

    if( g_bPrivegeEnabled != TRUE )
    {
        g_bPrivegeEnabled = VrfEnableDebugPrivilege();

        if( g_bPrivegeEnabled != TRUE )
        {
            return FALSE;
        }
    }

    //
    // Must driver name as a UNICODE_STRING
    //

    ASSERT( szDriverName != NULL );
        
    RtlInitUnicodeString(
        &usDriverName,
        szDriverName );

    Status = NtSetSystemInformation(
        SystemVerifierAddDriverInformation,
        &usDriverName,
        sizeof( UNICODE_STRING ) );

    if( ! NT_SUCCESS( Status ) )
    {
        switch( Status )
        {
        case STATUS_INVALID_INFO_CLASS:
            uIdErrorString = IDS_VERIFIER_ADD_NOT_SUPPORTED;
            break;

        case STATUS_NOT_SUPPORTED:
            uIdErrorString = IDS_DYN_ADD_NOT_SUPPORTED;
            break;

        case STATUS_IMAGE_ALREADY_LOADED:
            uIdErrorString = IDS_DYN_ADD_ALREADY_LOADED;
            break;

        case STATUS_INSUFFICIENT_RESOURCES:
        case STATUS_NO_MEMORY:
            uIdErrorString = IDS_DYN_ADD_INSUF_RESOURCES;
            break;

        case STATUS_PRIVILEGE_NOT_HELD:
            uIdErrorString = IDS_DYN_ADD_ACCESS_DENIED;
            break;

        default:
            VrfErrorResourceFormat(
                IDS_DYN_ADD_MISC_ERROR,
                szDriverName,
                Status );

            return FALSE;
        }

        VrfErrorResourceFormat(
            uIdErrorString,
            szDriverName );

        return FALSE;
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////
BOOL VrfVolatileRemoveDriver( 

    const WCHAR *szDriverName )
{
    UNICODE_STRING usDriverName;
    NTSTATUS Status;
    UINT uIdErrorString;

    //
    // enable debug privilege
    //

    if( g_bPrivegeEnabled != TRUE )
    {
        g_bPrivegeEnabled = VrfEnableDebugPrivilege();

        if( g_bPrivegeEnabled != TRUE )
        {
            return FALSE;
        }
    }

    //
    // Must driver name as a UNICODE_STRING
    //

    ASSERT( szDriverName != NULL );
        
    RtlInitUnicodeString(
        &usDriverName,
        szDriverName );

    Status = NtSetSystemInformation(
        SystemVerifierRemoveDriverInformation,
        &usDriverName,
        sizeof( UNICODE_STRING ) );

    if( ! NT_SUCCESS( Status ) )
    {
        switch( Status )
        {
        case STATUS_INVALID_INFO_CLASS:
            uIdErrorString = IDS_VERIFIER_REMOVE_NOT_SUPPORTED;
            break;

        case STATUS_NOT_SUPPORTED:
            //
            // the driver verifier is not currently active at all -> success
            //

        case STATUS_NOT_FOUND:
            //
            // the driver is not currently verified -> success
            //

            return TRUE;

        case STATUS_IMAGE_ALREADY_LOADED:
            uIdErrorString = IDS_DYN_REMOVE_ALREADY_LOADED;
            break;

        case STATUS_INSUFFICIENT_RESOURCES:
        case STATUS_NO_MEMORY:
            uIdErrorString = IDS_DYN_REMOVE_INSUF_RESOURCES;
            break;

        case STATUS_PRIVILEGE_NOT_HELD:
            uIdErrorString = IDS_DYN_REMOVE_ACCESS_DENIED;
            break;

        default:
            VrfErrorResourceFormat(
                IDS_DYN_REMOVE_MISC_ERROR,
                szDriverName,
                Status );

            return FALSE;
        }

        VrfErrorResourceFormat(
            uIdErrorString,
            szDriverName );

        return FALSE;
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////
BOOL
VrfVolatileAddOrRemoveDriversCmdLine(

    int nArgsNo,
    LPTSTR szCmdLineArgs[] )
{
    int nCrtArg;
    BOOL bChangedSomething;
    BOOL bResult;
    BOOL bAddDriverSpecified = FALSE;
    BOOL bRemoveDriverSpecified  = FALSE;
    TCHAR szAddDriverOption[ 128 ];
    TCHAR szRemoveDriverOption[ 128 ];

    //
    // /loaddriver and /removedriver command line options
    //

    bResult = GetStringFromResources(
        IDS_ADDDRIVER_CMDLINE_SWITCH,
        szAddDriverOption,
        ARRAY_LENGTH( szAddDriverOption ) );

    if( bResult != TRUE )
    {
        return FALSE;
    }

    bResult = GetStringFromResources(
        IDS_REMOVEDRIVER_CMDLINE_SWITCH,
        szRemoveDriverOption,
        ARRAY_LENGTH( szRemoveDriverOption ) );

    if( bResult != TRUE )
    {
        return FALSE;
    }

    //
    // parse all the cmd line args
    //

    for( nCrtArg = 0; nCrtArg < nArgsNo; nCrtArg++ )
    {
        if( _tcsicmp( szCmdLineArgs[ nCrtArg ], szAddDriverOption ) == 0 )
        {
            //
            // /adddriver
            //

            bAddDriverSpecified = TRUE;
            bRemoveDriverSpecified = FALSE;
        }
        else
        {
            if( _tcsicmp( szCmdLineArgs[ nCrtArg ], szRemoveDriverOption ) == 0 )
            {
                //
                // /removedriver
                //

                bRemoveDriverSpecified = TRUE;
                bAddDriverSpecified = FALSE;
            }
            else
            {
                if( bAddDriverSpecified )
                {
                    //
                    // this must be a driver name to be added
                    // 
                    
                    if( VrfVolatileAddDriver( szCmdLineArgs[ nCrtArg ] ) )
                    {
                        bChangedSomething = TRUE;

                        VrfTPrintfResourceFormat(
                            IDS_DYN_ADD_VERIFIED_NOW,
                            szCmdLineArgs[ nCrtArg ] );
                    }
                }
                else
                {
                    if( bRemoveDriverSpecified )
                    {
                        //
                        // this must be a driver name to be added
                        // 
                    
                        if( VrfVolatileRemoveDriver( szCmdLineArgs[ nCrtArg ] ) )
                        {
                            bChangedSomething = TRUE;

                            VrfTPrintfResourceFormat(
                                IDS_DYN_ADD_NOT_VERIFIED_NOW,
                                szCmdLineArgs[ nCrtArg ] );
                        }
                    }
                }
            }
        }
    }

    return bChangedSomething;
}


//
// end of module: verify.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vi\edit.c ===
/*
 * The main edit loop as well as some other simple cursor movement routines.
 */

#include "stevie.h"

/*
 * This flag is used to make auto-indent work right on lines where only
 * a <RETURN> or <ESC> is typed. It is set when an auto-indent is done,
 * and reset when any other editting is done on the line. If an <ESC>
 * or <RETURN> is received, and did_ai is TRUE, the line is truncated.
 */
bool_t  did_ai = FALSE;

void
edit()
{
    extern  bool_t  need_redraw;
    int     c;
    register char   *p, *q;

    Prenum = 0;

    /* position the display and the cursor at the top of the file. */
    *Topchar = *Filemem;
    *Curschar = *Filemem;
    Cursrow = Curscol = 0;

    do_mlines();            /* check for mode lines before starting */

    updatescreen();

    for ( ;; ) {

        /* Figure out where the cursor is based on Curschar. */
        cursupdate();

        if (need_redraw && !anyinput()) {
                updatescreen();
                need_redraw = FALSE;
        }

        if (!anyinput())
                windgoto(Cursrow,Curscol);


        c = vgetc();

        if (State == NORMAL) {

                /* We're in the normal (non-insert) mode. */

                /* Pick up any leading digits and compute 'Prenum' */
                if ( (Prenum>0 && isdigit(c)) || (isdigit(c) && c!='0') ){
                        Prenum = Prenum*10 + (c-'0');
                        continue;
                }
                /* execute the command */
                normal(c);
                Prenum = 0;

        } else {

                /*
                 * Insert or Replace mode.
                 */
                switch (c) {

                case ESC:       /* an escape ends input mode */

                        /*
                         * If we just did an auto-indent, truncate the
                         * line, and put the cursor back.
                         */
                        if (did_ai) {
                                Curschar->linep->s[0] = NUL;
                                Curschar->index = 0;
                                did_ai = FALSE;
                        }

                        set_want_col = TRUE;

                        /* Don't end up on a '\n' if you can help it. */
                        if (gchar(Curschar) == NUL && Curschar->index != 0)
                                dec(Curschar);

                        /*
                         * The cursor should end up on the last inserted
                         * character. This is an attempt to match the real
                         * 'vi', but it may not be quite right yet.
                         */
                        if (Curschar->index != 0 && !endofline(Curschar))
                                dec(Curschar);

                        State = NORMAL;
                        msg("");

                        /* construct the Redo buffer */
                        p = ralloc(Redobuff,
                                   Ninsert+2 < REDOBUFFMIN
                                   ? REDOBUFFMIN : Ninsert+2);
                        if(p == NULL) {
                            msg("Insufficient memory -- command not saved for redo");
                        } else {
                            Redobuff=p;
                            q=Insbuff;
                            while ( q < Insptr )
                                *p++ = *q++;
                            *p++ = ESC;
                            *p = NUL;
                        }
                        updatescreen();
                        break;

                case CTRL('D'):
                        /*
                         * Control-D is treated as a backspace in insert
                         * mode to make auto-indent easier. This isn't
                         * completely compatible with vi, but it's a lot
                         * easier than doing it exactly right, and the
                         * difference isn't very noticeable.
                         */
                case BS:
                        /* can't backup past starting point */
                        if (Curschar->linep == Insstart->linep &&
                            Curschar->index <= Insstart->index) {
                                beep();
                                break;
                        }

                        /* can't backup to a previous line */
                        if (Curschar->linep != Insstart->linep &&
                            Curschar->index <= 0) {
                                beep();
                                break;
                        }

                        did_ai = FALSE;
                        dec(Curschar);
                        if (State == INSERT)
                                delchar(TRUE);
                        /*
                         * It's a little strange to put backspaces into
                         * the redo buffer, but it makes auto-indent a
                         * lot easier to deal with.
                         */
                        insertchar(BS);
                        cursupdate();
                        updateline();
                        break;

                case CR:
                case NL:
                        insertchar(NL);
                        opencmd(FORWARD, TRUE);         /* open a new line */
                        break;

                case TAB:
                        if (!P(P_HT)) {
                            /* fake TAB with spaces */
                            int i = P(P_TS) - (Curscol % P(P_TS));
                            did_ai = FALSE;
                            while (i--) {
                                inschar(' ');
                                insertchar(' ');
                            }
                            updateline();
                            break;
                        }

                        /* else fall through to normal case */

                default:
                        did_ai = FALSE;
                        inschar(c);
                        insertchar(c);
                        updateline();
                        break;
                }
        }
    }
}

void
insertchar(c)
int     c;
{
    char *p;

    *Insptr++ = (char)c;
    Ninsert++;

    if(Ninsert == InsbuffSize) {        // buffer is full -- enlarge it

        if((p = ralloc(Insbuff,InsbuffSize+INSERTSLOP)) != NULL) {

            Insptr += p - Insbuff;
            Insbuff = p;
            InsbuffSize += INSERTSLOP;

        } else {                            // could not get bigger buffer

            stuffin(mkstr(ESC));            // just end insert mode
        }
    }
}

void
getout()
{
        windgoto(Rows-1,0);
        //putchar('\r');
        putchar('\n');
        windexit(0);
}

void
scrolldown(nlines)
int     nlines;
{
    register LNPTR   *p;
        register int    done = 0;       /* total # of physical lines done */

        /* Scroll up 'nlines' lines. */
        while (nlines--) {
                if ((p = prevline(Topchar)) == NULL)
                        break;
                done += plines(p);
                *Topchar = *p;
                /*
                 * If the cursor is on the bottom line, we need to
                 * make sure it gets moved up the appropriate number
                 * of lines so it stays on the screen.
                 */
                if (Curschar->linep == Botchar->linep->prev) {
                        int     i = 0;
                        while (i < done) {
                                i += plines(Curschar);
                                *Curschar = *prevline(Curschar);
                        }
                }
        }
        s_ins(0, done);
}

void
scrollup(nlines)
int     nlines;
{
    register LNPTR   *p;
        register int    done = 0;       /* total # of physical lines done */
        register int    pl;             /* # of plines for the current line */

        /* Scroll down 'nlines' lines. */
        while (nlines--) {
                pl = plines(Topchar);
                if ((p = nextline(Topchar)) == NULL)
                        break;
                done += pl;
                if (Curschar->linep == Topchar->linep)
                        *Curschar = *p;
                *Topchar = *p;

        }
        s_del(0, done);
}

/*
 * oneright
 * oneleft
 * onedown
 * oneup
 *
 * Move one char {right,left,down,up}.  Return TRUE when
 * sucessful, FALSE when we hit a boundary (of a line, or the file).
 */

bool_t
oneright()
{
        set_want_col = TRUE;

        switch (inc(Curschar)) {

        case 0:
                return TRUE;

        case 1:
                dec(Curschar);          /* crossed a line, so back up */
                /* fall through */
        case -1:
                return FALSE;

        DEFAULT_UNREACHABLE;
        }
        /*NOTREACHED*/
}

bool_t
oneleft()
{
        set_want_col = TRUE;

        switch (dec(Curschar)) {

        case 0:
                return TRUE;

        case 1:
                inc(Curschar);          /* crossed a line, so back up */
                /* fall through */
        case -1:
                return FALSE;

        DEFAULT_UNREACHABLE;
        }
        /*NOTREACHED*/
}

void
beginline(flag)
bool_t  flag;
{
        while ( oneleft() )
                ;
        if (flag) {
                while (isspace(gchar(Curschar)) && oneright())
                        ;
        }
        set_want_col = TRUE;
}

bool_t
oneup(n)
int     n;
{
    LNPTR    p, *np;
        register int    k;

        p = *Curschar;
        for ( k=0; k<n; k++ ) {
                /* Look for the previous line */
                if ( (np=prevline(&p)) == NULL ) {
                        /* If we've at least backed up a little .. */
                        if ( k > 0 )
                                break;  /* to update the cursor, etc. */
                        else
                                return FALSE;
                }
                p = *np;
        }
        *Curschar = p;
        /* This makes sure Topchar gets updated so the complete line */
        /* is one the screen. */
        cursupdate();
        /* try to advance to the column we want to be at */
        *Curschar = *coladvance(&p, Curswant);
        return TRUE;
}

bool_t
onedown(n)
int     n;
{
    LNPTR    p, *np;
        register int    k;

        p = *Curschar;
        for ( k=0; k<n; k++ ) {
                /* Look for the next line */
                if ( (np=nextline(&p)) == NULL ) {
                        if ( k > 0 )
                                break;
                        else
                                return FALSE;
                }
                p = *np;
        }
        /* try to advance to the column we want to be at */
        *Curschar = *coladvance(&p, Curswant);
        return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vi\keymap.h ===
/*
 *
 *
 * Keycode definitions for special keys
 *
 * On systems that have any of these keys, the routine 'inchar' in the
 * machine-dependent code should return one of the codes here.
 */

#define K_HOME          0x80
#define K_END           0x81
#define K_INSERT        0x82
#define K_DELETE        0x83
#define K_UARROW        0x84
#define K_DARROW        0x85
#define K_LARROW        0x86
#define K_RARROW        0x87
#define K_CGRAVE        0x88    /* control grave accent */
#define K_PAGEUP        0x89
#define K_PAGEDOWN      0x8a

#define K_F1            0x91    /* function keys */
#define K_F2            0x92
#define K_F3            0x93
#define K_F4            0x94
#define K_F5            0x95
#define K_F6            0x96
#define K_F7            0x97
#define K_F8            0x98
#define K_F9            0x99
#define K_F10           0x9a
#define K_F11           0x9b
#define K_F12           0x9c

#define K_SF1           0xa1    /* shifted function keys */
#define K_SF2           0xa2
#define K_SF3           0xa3
#define K_SF4           0xa4
#define K_SF5           0xa5
#define K_SF6           0xa6
#define K_SF7           0xa7
#define K_SF8           0xa8
#define K_SF9           0xa9
#define K_SF10          0xaa
#define K_SF11          0xab
#define K_SF12          0xac

/*
    for keyboard translation tables
*/

#define K_EN            K_END
#define K_HO            K_HOME
#define K_LE            K_LARROW
#define K_RI            K_RARROW
#define K_UP            K_UARROW
#define K_DO            K_DARROW
#define K_IN            K_INSERT
#define K_DE            K_DELETE
#define K_CG            K_CGRAVE
#define K_PU            K_PAGEUP
#define K_PD            K_PAGEDOWN

#define K_FA            K_F10
#define K_FB            K_F11
#define K_FC            K_F12

#define K_S1            K_SF1
#define K_S2            K_SF2
#define K_S3            K_SF3
#define K_S4            K_SF4
#define K_S5            K_SF5
#define K_S6            K_SF6
#define K_S7            K_SF7
#define K_S8            K_SF8
#define K_S9            K_SF9
#define K_SA            K_SF10
#define K_SB            K_SF11
#define K_SC            K_SF12
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vi\hexchars.c ===
/* $Header: /nw/tony/src/stevie/src/RCS/hexchars.c,v 1.4 89/03/11 22:42:27 tony Exp $
 *
 * Contains information concerning the representation of characters for
 * visual output by the editor.
 */

#include "stevie.h"

/*
 * This file shows how to display characters on the screen. This is
 * approach is something of an overkill. It's a remnant from the
 * original code that isn't worth messing with for now. TABS are
 * special-cased depending on the value of the "list" parameter.
 */

struct charinfo chars[] = {
        /* 000 */       1, NULL,
        /* 001 */       2, "^A",
        /* 002 */       2, "^B",
        /* 003 */       2, "^C",
        /* 004 */       2, "^D",
        /* 005 */       2, "^E",
        /* 006 */       2, "^F",
        /* 007 */       2, "^G",
        /* 010 */       2, "^H",
        /* 011 */       2, "^I",
        /* 012 */       7, "[ERROR]",   /* shouldn't occur */
        /* 013 */       2, "^K",
        /* 014 */       2, "^L",
        /* 015 */       2, "^M",
        /* 016 */       2, "^N",
        /* 017 */       2, "^O",
        /* 020 */       2, "^P",
        /* 021 */       2, "^Q",
        /* 022 */       2, "^R",
        /* 023 */       2, "^S",
        /* 024 */       2, "^T",
        /* 025 */       2, "^U",
        /* 026 */       2, "^V",
        /* 027 */       2, "^W",
        /* 030 */       2, "^X",
        /* 031 */       2, "^Y",
        /* 032 */       2, "^Z",
        /* 033 */       2, "^[",
        /* 034 */       2, "^\\",
        /* 035 */       2, "^]",
        /* 036 */       2, "^^",
        /* 037 */       2, "^_",
        /* 040 */       1, NULL,
        /* 041 */       1, NULL,
        /* 042 */       1, NULL,
        /* 043 */       1, NULL,
        /* 044 */       1, NULL,
        /* 045 */       1, NULL,
        /* 046 */       1, NULL,
        /* 047 */       1, NULL,
        /* 050 */       1, NULL,
        /* 051 */       1, NULL,
        /* 052 */       1, NULL,
        /* 053 */       1, NULL,
        /* 054 */       1, NULL,
        /* 055 */       1, NULL,
        /* 056 */       1, NULL,
        /* 057 */       1, NULL,
        /* 060 */       1, NULL,
        /* 061 */       1, NULL,
        /* 062 */       1, NULL,
        /* 063 */       1, NULL,
        /* 064 */       1, NULL,
        /* 065 */       1, NULL,
        /* 066 */       1, NULL,
        /* 067 */       1, NULL,
        /* 070 */       1, NULL,
        /* 071 */       1, NULL,
        /* 072 */       1, NULL,
        /* 073 */       1, NULL,
        /* 074 */       1, NULL,
        /* 075 */       1, NULL,
        /* 076 */       1, NULL,
        /* 077 */       1, NULL,
        /* 100 */       1, NULL,
        /* 101 */       1, NULL,
        /* 102 */       1, NULL,
        /* 103 */       1, NULL,
        /* 104 */       1, NULL,
        /* 105 */       1, NULL,
        /* 106 */       1, NULL,
        /* 107 */       1, NULL,
        /* 110 */       1, NULL,
        /* 111 */       1, NULL,
        /* 112 */       1, NULL,
        /* 113 */       1, NULL,
        /* 114 */       1, NULL,
        /* 115 */       1, NULL,
        /* 116 */       1, NULL,
        /* 117 */       1, NULL,
        /* 120 */       1, NULL,
        /* 121 */       1, NULL,
        /* 122 */       1, NULL,
        /* 123 */       1, NULL,
        /* 124 */       1, NULL,
        /* 125 */       1, NULL,
        /* 126 */       1, NULL,
        /* 127 */       1, NULL,
        /* 130 */       1, NULL,
        /* 131 */       1, NULL,
        /* 132 */       1, NULL,
        /* 133 */       1, NULL,
        /* 134 */       1, NULL,
        /* 135 */       1, NULL,
        /* 136 */       1, NULL,
        /* 137 */       1, NULL,
        /* 140 */       1, NULL,
        /* 141 */       1, NULL,
        /* 142 */       1, NULL,
        /* 143 */       1, NULL,
        /* 144 */       1, NULL,
        /* 145 */       1, NULL,
        /* 146 */       1, NULL,
        /* 147 */       1, NULL,
        /* 150 */       1, NULL,
        /* 151 */       1, NULL,
        /* 152 */       1, NULL,
        /* 153 */       1, NULL,
        /* 154 */       1, NULL,
        /* 155 */       1, NULL,
        /* 156 */       1, NULL,
        /* 157 */       1, NULL,
        /* 160 */       1, NULL,
        /* 161 */       1, NULL,
        /* 162 */       1, NULL,
        /* 163 */       1, NULL,
        /* 164 */       1, NULL,
        /* 165 */       1, NULL,
        /* 166 */       1, NULL,
        /* 167 */       1, NULL,
        /* 170 */       1, NULL,
        /* 171 */       1, NULL,
        /* 172 */       1, NULL,
        /* 173 */       1, NULL,
        /* 174 */       1, NULL,
        /* 175 */       1, NULL,
        /* 176 */       1, NULL,
        /* 177 */       2, "^?",
        /* 200 */       2, "^?",
        /* 201 */       2, "^?",
        /* 202 */       2, "^?",
        /* 203 */       2, "^?",
        /* 204 */       2, "^?",
        /* 205 */       2, "^?",
        /* 206 */       2, "^?",
        /* 207 */       2, "^?",
        /* 210 */       2, "^?",
        /* 211 */       2, "^?",
        /* 212 */       2, "^?",
        /* 213 */       2, "^?",
        /* 214 */       2, "^?",
        /* 215 */       2, "^?",
        /* 216 */       2, "^?",
        /* 217 */       2, "^?",
        /* 220 */       2, "^?",
        /* 221 */       2, "^?",
        /* 222 */       2, "^?",
        /* 223 */       2, "^?",
        /* 224 */       2, "^?",
        /* 225 */       2, "^?",
        /* 226 */       2, "^?",
        /* 227 */       2, "^?",
        /* 230 */       2, "^?",
        /* 231 */       2, "^?",
        /* 232 */       2, "^?",
        /* 233 */       2, "^?",
        /* 234 */       2, "^?",
        /* 235 */       2, "^?",
        /* 236 */       2, "^?",
        /* 237 */       2, "^?",
        /* 240 */       2, "^?",
        /* 241 */       2, "^?",
        /* 242 */       2, "^?",
        /* 243 */       2, "^?",
        /* 244 */       2, "^?",
        /* 245 */       2, "^?",
        /* 246 */       2, "^?",
        /* 247 */       2, "^?",
        /* 250 */       2, "^?",
        /* 251 */       2, "^?",
        /* 252 */       2, "^?",
        /* 253 */       2, "^?",
        /* 254 */       2, "^?",
        /* 255 */       2, "^?",
        /* 256 */       2, "^?",
        /* 257 */       2, "^?",
        /* 260 */       2, "^?",
        /* 261 */       2, "^?",
        /* 262 */       2, "^?",
        /* 263 */       2, "^?",
        /* 264 */       2, "^?",
        /* 265 */       2, "^?",
        /* 266 */       2, "^?",
        /* 267 */       2, "^?",
        /* 270 */       2, "^?",
        /* 271 */       2, "^?",
        /* 272 */       2, "^?",
        /* 273 */       2, "^?",
        /* 274 */       2, "^?",
        /* 275 */       2, "^?",
        /* 276 */       2, "^?",
        /* 277 */       2, "^?",
        /* 300 */       2, "^?",
        /* 301 */       2, "^?",
        /* 302 */       2, "^?",
        /* 303 */       2, "^?",
        /* 304 */       2, "^?",
        /* 305 */       2, "^?",
        /* 306 */       2, "^?",
        /* 307 */       2, "^?",
        /* 310 */       2, "^?",
        /* 311 */       2, "^?",
        /* 312 */       2, "^?",
        /* 313 */       2, "^?",
        /* 314 */       2, "^?",
        /* 315 */       2, "^?",
        /* 316 */       2, "^?",
        /* 317 */       2, "^?",
        /* 320 */       2, "^?",
        /* 321 */       2, "^?",
        /* 322 */       2, "^?",
        /* 323 */       2, "^?",
        /* 324 */       2, "^?",
        /* 325 */       2, "^?",
        /* 326 */       2, "^?",
        /* 327 */       2, "^?",
        /* 330 */       2, "^?",
        /* 331 */       2, "^?",
        /* 332 */       2, "^?",
        /* 333 */       2, "^?",
        /* 334 */       2, "^?",
        /* 335 */       2, "^?",
        /* 336 */       2, "^?",
        /* 337 */       2, "^?",
        /* 340 */       2, "^?",
        /* 341 */       2, "^?",
        /* 342 */       2, "^?",
        /* 343 */       2, "^?",
        /* 344 */       2, "^?",
        /* 345 */       2, "^?",
        /* 346 */       2, "^?",
        /* 347 */       2, "^?",
        /* 350 */       2, "^?",
        /* 351 */       2, "^?",
        /* 352 */       2, "^?",
        /* 353 */       2, "^?",
        /* 354 */       2, "^?",
        /* 355 */       2, "^?",
        /* 356 */       2, "^?",
        /* 357 */       2, "^?",
        /* 360 */       2, "^?",
        /* 361 */       2, "^?",
        /* 362 */       2, "^?",
        /* 363 */       2, "^?",
        /* 364 */       2, "^?",
        /* 365 */       2, "^?",
        /* 366 */       2, "^?",
        /* 367 */       2, "^?",
        /* 370 */       2, "^?",
        /* 371 */       2, "^?",
        /* 372 */       2, "^?",
        /* 373 */       2, "^?",
        /* 374 */       2, "^?",
        /* 375 */       2, "^?",
        /* 376 */       2, "^?",
        /* 377 */       2, "^?"
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vi\env.h ===
/*
 * The defines in this file establish the environment we're compiling
 * in. Set these appropriately before compiling the editor.
 */

/*
 * One (and only 1) of the following defines should be uncommented.
 * Most of the code is pretty machine-independent. Machine dependent
 * code goes in a file like tos.c or unix.c. The only other place
 * where machine dependent code goes is term.h for escape sequences.
 */

#define NT
/* #define      ATARI                   /* For the Atari ST */
/* #define      UNIX                    /* System V or BSD */
/* #define      OS2                     /* Microsoft OS/2 1.1 */
/* #define      DOS                     /* MSDOS 3.3 (on AT) */

/*
 * If UNIX is defined above, then BSD may be defined.
 */
#ifdef  UNIX
/* #define      BSD                     /* Berkeley UNIX */
#endif

/*
 * If ATARI is defined, MINIX may be defined. Otherwise, the editor
 * is set up to compile using the Sozobon C compiler under TOS.
 */
#ifdef  ATARI
#define MINIX                   /* Minix for the Atari ST */
#endif

/*
 * The yank buffer is still static, but its size can be specified
 * here to override the default of 4K.
 */
/* #define      YBSIZE  8192            /* yank buffer size */

/*
 * STRCSPN should be defined if the target system doesn't have the
 * routine strcspn() available. See regexp.c for details.
 */

#ifdef  ATARI

#ifdef  MINIX
#define STRCSPN
#endif

#endif

/*
 * The following defines control the inclusion of "optional" features. As
 * the code size of the editor grows, it will probably be useful to be able
 * to tailor the editor to get the features you most want in environments
 * with code size limits.
 *
 * TILDEOP
 *      Normally the '~' command works on a single character. This define
 *      turns on code that allows it to work like an operator. This is
 *      then enabled at runtime with the "tildeop" parameter.
 *
 * HELP
 *      If defined, a series of help screens may be views with the ":help"
 *      command. This eats a fair amount of data space.
 *
 * TERMCAP
 *      Where termcap support is provided, it is generally optional. If
 *      not enabled, you generally get hard-coded escape sequences for
 *      some "reasonable" terminal. In Minix, this means the console. For
 *      UNIX, this means an ANSI standard terminal. See the file "term.h"
 *      for details about specific environments.
 *
 */
#define TILDEOP         /* enable tilde to be an operator */
#define HELP            /* enable help command */
#ifndef NT
#define TERMCAP         /* enable termcap support */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vi\fileio.c ===
/*
 *
 * Basic file I/O routines.
 */


#include "stevie.h"
#include <io.h>
#include <errno.h>

void
filemess(s)
char    *s;
{
        smsg("\"%s\" %s", (Filename == NULL) ? "" : Filename, s);
        flushbuf();
}

void
renum()
{
    LNPTR    *p;
        unsigned long l = 0;

        for (p = Filemem; p != NULL ;p = nextline(p), l += LINEINC)
                if (p->linep)
			p->linep->num = l;

        Fileend->linep->num = 0xffffffff;
}

#define MAXLINE 512     /* maximum size of a line */

bool_t
readfile(fname,fromp,nochangename)
char    *fname;
LNPTR    *fromp;
bool_t  nochangename;   /* if TRUE, don't change the Filename */
{
        FILE    *f;
        register LINE   *curr;
        char    buff[MAXLINE], buf2[80];
        register int    i, c;
        register long   nchars = 0;
        int     linecnt = 0;
        bool_t  wasempty = bufempty();
        int     nulls = 0;              /* count nulls */
        bool_t  incomplete = FALSE;     /* was the last line incomplete? */
        bool_t  toolong = FALSE;        /* a line was too long */
        int	ctoolong = 0;
        bool_t  readonly = FALSE;       /* file is not writable */

        curr = fromp->linep;

        if ( ! nochangename ) {
                Filename = strsave(fname);
                setviconsoletitle();
        }

        if((_access(fname,2) == -1) && (errno == EACCES)) {
            readonly = TRUE;
        }

        if ( (f=fopen(fixname(fname),"r")) == NULL )
                return TRUE;

        filemess("");

        i = 0;
        do {
                c = getc(f);

                if (c == EOF) {
                        if (i == 0)     /* normal loop termination */
                                break;

                        /*
                         * If we get EOF in the middle of a line, note the
                         * fact and complete the line ourselves.
                         */
                        incomplete = TRUE;
                        c = NL;
                }

                /*
                 * Abort if we get an interrupt, but finished reading the
                 * current line first.
                 */
                if (got_int && i == 0)
                        break;

                /*
                 * If we reached the end of the line, OR we ran out of
                 * space for it, then process the complete line.
                 */
                if (c == NL || i == (MAXLINE-1)) {
                        LINE    *lp;

                        if (c != NL) {
                                toolong = TRUE;
                                ctoolong++;
                        }

                        buff[i] = '\0';
                        if ((lp = newline(strlen(buff))) == NULL)
                                exit(1);

                        strcpy(lp->s, buff);

                        curr->next->prev = lp;  /* new line to next one */
                        lp->next = curr->next;

                        curr->next = lp;        /* new line to prior one */
                        lp->prev = curr;

                        curr = lp;              /* new line becomes current */
                        i = 0;
                        linecnt++;
                        if (toolong) {
                        	buff[i++] = (char)c;
                        	toolong = FALSE;
                        }

                } else if (c == NUL)
                        nulls++;                /* count and ignore nulls */
                else {
                        buff[i++] = (char)c;    /* normal character */
                }

                nchars++;

        } while (!incomplete);

        fclose(f);

        /*
         * If the buffer was empty when we started, we have to go back
         * and remove the "dummy" line at Filemem and patch up the ptrs.
         */
        if (wasempty && nchars != 0) {
                LINE    *dummy = Filemem->linep;        /* dummy line ptr */

                free(dummy->s);                         /* free string space */
                Filemem->linep = Filemem->linep->next;
                free((char *)dummy);                    /* free LINE struct */
                Filemem->linep->prev = Filetop->linep;
                Filetop->linep->next = Filemem->linep;

                Curschar->linep = Filemem->linep;
                Topchar->linep  = Filemem->linep;
        }

        renum();

        if (got_int) {
                smsg("\"%s\" Interrupt", fname);
                got_int = FALSE;
                return FALSE;           /* an interrupt isn't really an error */
        }

        if (ctoolong != 0) {
                smsg("\"%s\" %d Line(s) too long - split", fname, ctoolong);
                return FALSE;
        }

        sprintf(buff, "\"%s\" %s%s%d line%s, %ld character%s",
                fname,
                readonly ? "[Read only] " : "",
                incomplete ? "[Incomplete last line] " : "",
                linecnt, (linecnt != 1) ? "s" : "",
                nchars, (nchars != 1) ? "s" : "");

        buf2[0] = NUL;

        if (nulls) {
           sprintf(buf2, " (%d null)", nulls);
        }
        strcat(buff, buf2);
        msg(buff);

        return FALSE;
}


/*
 * writeit - write to file 'fname' lines 'start' through 'end'
 *
 * If either 'start' or 'end' contain null line pointers, the default
 * is to use the start or end of the file respectively.
 */
bool_t
writeit(fname, start, end)
char    *fname;
LNPTR    *start, *end;
{
        FILE    *f;
        FILE    *fopenb();              /* open in binary mode, where needed */
        char    *backup;
        register char   *s;
        register long   nchars;
        register int    lines;
        register LNPTR   *p;


        if((_access(fname,2) == -1) && (errno == EACCES)) {
            msg("Write access to file is denied");
            return FALSE;
        }

        smsg("\"%s\"", fname);

        /*
         * Form the backup file name - change foo.* to foo.bak
         */
        backup = alloc((unsigned) (strlen(fname) + 5));
        strcpy(backup, fname);
        for (s = backup; *s && *s != '.' ;s++)
                ;
        *s = NUL;
        strcat(backup, ".bak");

        /*
         * Delete any existing backup and move the current version
         * to the backup. For safety, we don't remove the backup
         * until the write has finished successfully. And if the
         * 'backup' option is set, leave it around.
         */
        rename(fname, backup);


        f = P(P_CR) ? fopen(fixname(fname), "w") : fopenb(fixname(fname), "w");

        if (f == NULL) {
                emsg("Can't open file for writing!");
                free(backup);
                return FALSE;
        }

        /*
         * If we were given a bound, start there. Otherwise just
         * start at the beginning of the file.
         */
        if (start == NULL || start->linep == NULL)
                p = Filemem;
        else
                p = start;

        lines = nchars = 0;
        do {
                if (p->linep) {
	                if (fprintf(f, "%s\n", p->linep->s) < 0) {
	                    emsg("Can't write file!");
	                    return FALSE;
	                }
	                nchars += strlen(p->linep->s) + 1;
	                lines++;
	
                }
                /*
                 * If we were given an upper bound, and we just did that
                 * line, then bag it now.
                 */
                if (end != NULL && end->linep != NULL) {
                        if (end->linep == p->linep)
                                break;
                }

        } while ((p = nextline(p)) != NULL);

        fclose(f);
        smsg("\"%s\" %d line%s, %ld character%s", fname,
                lines, (lines > 1) ? "s" : "",
                nchars, (nchars > 1) ? "s" : "");

        UNCHANGED;

        /*
         * Remove the backup unless they want it left around
         */
        if (!P(P_BK))
                remove(backup);

        free(backup);

        return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vi\help.c ===
/* $Header: /nw/tony/src/stevie/src/RCS/help.c,v 1.9 89/08/06 09:50:09 tony Exp $
 *
 * Routine to display a command summary.
 */

#include "stevie.h"

extern  char    *Version;

static  int     helprow;

#ifdef  HELP

static  void    longline();

bool_t
help()
{

/***********************************************************************
 * First Screen:   Positioning within file, Adjusting the Screen
 ***********************************************************************/

        ClearDisplay();
        windgoto(helprow = 0, 0);

longline(
"   Positioning within file\n"
"   =======================\n"
"      ^F             Forward screenfull             Developed by:\n"
"      ^B             Backward screenfull                Tony Andrews\n");
longline(
"      ^D             scroll down half screen\n"
"      ^U             scroll up half screen          Based on a program by:\n");
longline(
"      G              Goto line (end default)            Tim Thompson\n"
"      ]]             next function\n"
"      [[             previous function\n"
"      /re            next occurence of regular expression 're'\n");
longline(
"      ?re            prior occurence of regular expression 're'\n"
"      n              repeat last / or ?\n"
"      N              reverse last / or ?\n"
"      %              find matching (, ), {, }, [, or ]\n");
longline(
"\n"
"   Adjusting the screen\n"
"   ====================\n"
"      ^L             Redraw the screen\n"
"      ^E             scroll window down 1 line\n"
"      ^Y             scroll window up 1 line\n");
longline(
"      z<RETURN>      redraw, current line at top\n"
"      z-             ... at bottom\n"
"      z.             ... at center\n");

        windgoto(0, 52);
        longline(Version);

        windgoto(helprow = Rows-2, 47);
        longline("<Press space bar to continue>\n");
        windgoto(helprow = Rows-1, 47);
        longline("<Any other key will quit>");

        if ( vgetc() != ' ' )
                return TRUE;

/***********************************************************************
 * Second Screen:   Character positioning
 ***********************************************************************/

        ClearDisplay();
        windgoto(helprow = 0, 0);

longline(
"   Character Positioning\n"
"   =====================\n"
"      ^              first non-white\n"
"      0              beginning of line\n"
"      $              end of line\n"
"      h              backward\n");
longline(
"      l              forward\n"
"      ^H             same as h\n"
"      space          same as l\n"
"      fx             find 'x' forward\n");
longline(
"      Fx             find 'x' backward\n"
"      tx             upto 'x' forward\n"
"      Tx             upto 'x' backward\n"
"      ;              Repeat last f, F, t, or T\n");
longline(
"      ,              inverse of ;\n"
"      |              to specified column\n"
"      %              find matching (, ), {, }, [, or ]\n");

        windgoto(helprow = Rows-2, 47);
        longline("<Press space bar to continue>\n");
        windgoto(helprow = Rows-1, 47);
        longline("<Any other key will quit>");

        if ( vgetc() != ' ' )
                return TRUE;

/***********************************************************************
 * Third Screen:   Line Positioning, Marking and Returning
 ***********************************************************************/

        ClearDisplay();
        windgoto(helprow = 0, 0);

longline(
"    Line Positioning\n"
"    ================\n"
"    H           home window line\n"
"    L           last window line\n"
"    M           middle window line\n");
longline(
"    +           next line, at first non-white\n"
"    -           previous line, at first non-white\n"
"    CR          return, same as +\n"
"    j           next line, same column\n"
"    k           previous line, same column\n");

longline(
"\n"
"    Marking and Returning\n"
"    =====================\n"
"    ``          previous context\n"
"    ''          ... at first non-white in line\n");
longline(
"    mx          mark position with letter 'x'\n"
"    `x          to mark 'x'\n"
"    'x          ... at first non-white in line\n");

longline("\n"
"    Undo  &  Redo\n"
"    =============\n"
"    u           undo last change\n"
"    U           restore current line\n"
"    .           repeat last change\n");

        windgoto(helprow = Rows-2, 47);
        longline("<Press space bar to continue>\n");
        windgoto(helprow = Rows-1, 47);
        longline("<Any other key will quit>");

        if ( vgetc() != ' ' )
                return TRUE;
/***********************************************************************
 * Fourth Screen:   Insert & Replace,
 ***********************************************************************/

        ClearDisplay();
        windgoto(helprow = 0, 0);

longline(
"    Insert and Replace\n"
"    ==================\n"
"    a           append after cursor\n"
"    i           insert before cursor\n"
"    A           append at end of line\n"
"    I           insert before first non-blank\n");
longline(
"    o           open line below\n"
"    O           open line above\n"
"    rx          replace single char with 'x'\n"
"    R           replace characters\n");

longline(
"\n"
"    Words, sentences, paragraphs\n"
"    ============================\n"
"    w           word forward\n"
"    b           back word\n"
"    e           end of word\n"
"    )           to next sentence (not yet)\n"
"    }           to next paragraph (not yet)\n");
longline(
"    (           back sentence (not yet)\n"
"    {           back paragraph (not yet)\n"
"    W           blank delimited word\n"
"    B           back W\n"
"    E           to end of W\n");

        windgoto(helprow = Rows-2, 47);
        longline("<Press space bar to continue>\n");
        windgoto(helprow = Rows-1, 47);
        longline("<Any other key will quit>");

        if ( vgetc() != ' ' )
                return TRUE;

/***********************************************************************
 * Fifth Screen:   Misc. operations,
 ***********************************************************************/

        ClearDisplay();
        windgoto(helprow = 0, 0);

longline(
"    Miscellaneous Commands\n"
"    ======================\n");
longline(
"    :w          write back changes\n"
"    :wq         write and quit\n"
"    :x          write if modified, and quit\n"
"    :q          quit\n"
"    :q!         quit, discard changes\n"
"    :e name     edit file 'name'\n");
longline(
"    :e!         reedit, discard changes\n"
"    :e #        edit alternate file\n"
"    :w name     write file 'name'\n");
longline(
"    :n          edit next file in arglist\n"
"    :N          edit prior file in arglist\n"
"    :n args     specify new arglist (not yet)\n"
"    :rew        rewind arglist\n"
"    :f          show current file and lines\n");
longline(
"    :f file     change current file name\n"
"    :g/pat/p|d  global command (print or delete only)\n"
"    :s/p1/p2/   text substitution (trailing 'g' optional)\n"
"");
longline(
"    :ta tag     to tag file entry 'tag'\n"
"    ^]          :ta, current word is tag\n"
"    :sh         run an interactive shell\n"
"    :!cmd       execute a shell command\n"
"");

        windgoto(helprow = Rows-2, 47);
        longline("<Press space bar to continue>\n");
        windgoto(helprow = Rows-1, 47);
        longline("<Any other key will quit>");

        if ( vgetc() != ' ' )
                return TRUE;

/***********************************************************************
 * Sixth Screen:   Operators, Misc. operations, Yank & Put
 ***********************************************************************/

        ClearDisplay();
        windgoto(helprow = 0, 0);

longline(
"    Operators (double to affect lines)\n"
"    ==================================\n"
"    d           delete\n"
"    c           change\n");
longline(
"    <           left shift\n"
"    >           right shift\n"
"    y           yank to buffer\n"
"    !           filter lines\n");

longline("\n"
"    Miscellaneous operations\n"
"    ========================\n"
"    C           change rest of line\n"
"    D           delete rest of line\n"
"    s           substitute chars\n");
longline(
"    S           substitute lines (not yet)\n"
"    J           join lines\n"
"    x           delete characters\n"
"    X           ... before cursor\n");

longline("\n"
"    Yank and Put\n"
"    ============\n"
"    p           put back text\n"
"    P           put before\n"
"    Y           yank lines");

        windgoto(helprow = Rows-1, 47);
        longline("<Press any key>");

        (void) vgetc();

        return TRUE;
}

static void
longline(p)
char    *p;
{
        register char   *s;

        for ( s = p; *s ;s++ ) {
                if ( *s == '\n' )
                        windgoto(++helprow, 0);
                else
                        outchar(*s);
        }
}
#else

bool_t
help()
{
        msg("Sorry, help not configured");
        return FALSE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vi\linefunc.c ===
/* $Header: /nw/tony/src/stevie/src/RCS/linefunc.c,v 1.2 89/03/11 22:42:32 tony Exp $
 *
 * Basic line-oriented motions.
 */

#include "stevie.h"

/*
 * nextline(curr)
 *
 * Return a pointer to the beginning of the next line after the one
 * referenced by 'curr'. Return NULL if there is no next line (at EOF).
 */

LNPTR *
nextline(curr)
LNPTR    *curr;
{
    static  LNPTR    next;

        if (curr->linep && curr->linep->next != Fileend->linep) {
                next.index = 0;
                next.linep = curr->linep->next;
                return &next;
        }
    return (LNPTR *) NULL;
}

/*
 * prevline(curr)
 *
 * Return a pointer to the beginning of the line before the one
 * referenced by 'curr'. Return NULL if there is no prior line.
 */

LNPTR *
prevline(curr)
LNPTR    *curr;
{
    static  LNPTR    prev;

        if (curr->linep->prev != Filetop->linep) {
                prev.index = 0;
                prev.linep = curr->linep->prev;
                return &prev;
        }
    return (LNPTR *) NULL;
}

/*
 * coladvance(p,col)
 *
 * Try to advance to the specified column, starting at p.
 */

LNPTR *
coladvance(p, col)
LNPTR    *p;
register int    col;
{
        static  LNPTR    lp;
        register int    c, in;

        lp.linep = p->linep;
        lp.index = p->index;

        /* If we're on a blank ('\n' only) line, we can't do anything */
        if (lp.linep->s[lp.index] == '\0')
                return &lp;
        /* try to advance to the specified column */
        for ( c=0; col-- > 0; c++ ) {
                /* Count a tab for what it's worth (if list mode not on) */
                if ( gchar(&lp) == TAB && !P(P_LS) ) {
                        in = ((P(P_TS)-1) - c%P(P_TS));
                        col -= in;
                        c += in;
                }
                /* Don't go past the end of */
                /* the file or the line. */
                if (inc(&lp)) {
                        dec(&lp);
                        break;
                }
        }
        return &lp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vi\mark.c ===
/* $Header: /nw/tony/src/stevie/src/RCS/mark.c,v 1.3 89/03/11 22:42:39 tony Exp $
 *
 * Routines to save and retrieve marks.
 */

#include "stevie.h"

#define	NMARKS	10		/* max. # of marks that can be saved */

struct	mark {
	char	name;
    LNPTR    pos;
};

static	struct	mark	mlist[NMARKS];
static	struct	mark	pcmark;		/* previous context mark */
static	bool_t	pcvalid = FALSE;	/* true if pcmark is valid */

/*
 * setmark(c) - set mark 'c' at current cursor position
 *
 * Returns TRUE on success, FALSE if no room for mark or bad name given.
 */
bool_t
setmark(c)
register char	c;
{
	register int	i;

	if (!isalpha(c))
		return FALSE;

	/*
	 * If there is already a mark of this name, then just use the
	 * existing mark entry.
	 */
	for (i=0; i < NMARKS ;i++) {
		if (mlist[i].name == c) {
			mlist[i].pos = *Curschar;
			return TRUE;
		}
	}

	/*
	 * There wasn't a mark of the given name, so find a free slot
	 */
	for (i=0; i < NMARKS ;i++) {
		if (mlist[i].name == NUL) {	/* got a free one */
			mlist[i].name = c;
			mlist[i].pos = *Curschar;
			return TRUE;
		}
	}
	return FALSE;
}

/*
 * setpcmark() - set the previous context mark to the current position
 */
void
setpcmark()
{
	pcmark.pos = *Curschar;
	pcvalid = TRUE;
}

/*
 * getmark(c) - find mark for char 'c'
 *
 * Return pointer to LNPTR or NULL if no such mark.
 */
LNPTR *
getmark(c)
register char	c;
{
	register int	i;

	if (c == '\'' || c == '`')	/* previous context mark */
        return pcvalid ? &(pcmark.pos) : (LNPTR *) NULL;

	for (i=0; i < NMARKS ;i++) {
		if (mlist[i].name == c)
			return &(mlist[i].pos);
	}
    return (LNPTR *) NULL;
}

/*
 * clrall() - clear all marks
 *
 * Used mainly when trashing the entire buffer during ":e" type commands
 */
void
clrall()
{
	register int	i;

	for (i=0; i < NMARKS ;i++)
		mlist[i].name = NUL;
	pcvalid = FALSE;
}

/*
 * clrmark(line) - clear any marks for 'line'
 *
 * Used any time a line is deleted so we don't have marks pointing to
 * non-existent lines.
 */
void
clrmark(line)
register LINE	*line;
{
	register int	i;

	for (i=0; i < NMARKS ;i++) {
		if (mlist[i].pos.linep == line)
			mlist[i].name = NUL;
	}
	if (pcvalid && (pcmark.pos.linep == line))
		pcvalid = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vi\param.c ===
/* $Header: /nw/tony/src/stevie/src/RCS/param.c,v 1.10 89/08/02 10:59:10 tony Exp $
 *
 * Code to handle user-settable parameters. This is all pretty much table-
 * driven. To add a new parameter, put it in the params array, and add a
 * macro for it in param.h. If it's a numeric parameter, add any necessary
 * bounds checks to doset(). String parameters aren't currently supported.
 */

#include "stevie.h"

extern long CursorSize;

struct  param   params[] = {

        { "tabstop",    "ts",           4,      P_NUM },
        { "scroll",     "scroll",       12,     P_NUM },
        { "report",     "report",       5,      P_NUM },
        { "lines",      "lines",        25,     P_NUM },
        { "vbell",      "vb",           TRUE,   P_BOOL },
        { "showmatch",  "sm",           FALSE,  P_BOOL },
        { "wrapscan",   "ws",           TRUE,   P_BOOL },
        { "errorbells", "eb",           FALSE,  P_BOOL },
        { "showmode",   "mo",           FALSE,  P_BOOL },
        { "backup",     "bk",           FALSE,  P_BOOL },
        { "return",     "cr",           TRUE,   P_BOOL },
        { "list",       "list",         FALSE,  P_BOOL },
        { "ignorecase", "ic",           FALSE,  P_BOOL },
        { "autoindent", "ai",           FALSE,  P_BOOL },
        { "number",     "nu",           FALSE,  P_BOOL },
        { "modelines",  "ml",           FALSE,  P_BOOL },
        { "tildeop",    "to",           FALSE,  P_BOOL },
        { "terse",      "terse",        FALSE,  P_BOOL },
        { "cursorsize", "cs",           25,     P_NUM },
        { "highlightsearch", "hs",      TRUE,   P_BOOL },
        { "columns",    "co",           80,     P_NUM },
        { "hardtabs",   "ht",           FALSE,  P_BOOL },
        { "shiftwidth", "sw",           4,      P_NUM },
        { "",           "",             0,      0, }            /* end marker */

};

static  void    showparms();
void wchangescreen();

void
doset(arg)
char    *arg;           /* parameter string */
{
        register int    i;
        register char   *s;
        bool_t  did_lines = FALSE;
        bool_t  state = TRUE;           /* new state of boolean parms. */

        if (arg == NULL) {
                showparms(FALSE);
                return;
        }
        if (strncmp(arg, "all", 3) == 0) {
                showparms(TRUE);
                return;
        }
        if (strncmp(arg, "no", 2) == 0) {
                state = FALSE;
                arg += 2;
        }

        for (i=0; params[i].fullname[0] != NUL ;i++) {
                s = params[i].fullname;
                if (strncmp(arg, s, strlen(s)) == 0)    /* matched full name */
                        break;
                s = params[i].shortname;
                if (strncmp(arg, s, strlen(s)) == 0)    /* matched short name */
                        break;
        }

        if (params[i].fullname[0] != NUL) {     /* found a match */
                if (params[i].flags & P_NUM) {
                        did_lines = ((i == P_LI) || (i == P_CO));
                        if (arg[strlen(s)] != '=' || state == FALSE)
                                emsg("Invalid set of numeric parameter");
                        else {
                                params[i].value = atoi(arg+strlen(s)+1);
                                params[i].flags |= P_CHANGED;
                        }
                } else /* boolean */ {
                        if (arg[strlen(s)] == '=')
                                emsg("Invalid set of boolean parameter");
                        else {
                                params[i].value = state;
                                params[i].flags |= P_CHANGED;
                        }
                }
        } else
                emsg("Unrecognized 'set' option");

        /*
         * Update the screen in case we changed something like "tabstop"
         * or "list" that will change its appearance.
         */
        updatescreen();

        CursorSize = P(P_CS);
        VisibleCursor();

        if (did_lines) {
                Rows = P(P_LI);
                Columns = P(P_CO);
                screenalloc();          /* allocate new screen buffers */
                screenclear();
                (void)wchangescreen(Rows, Columns);
                updatescreen();
        }
        /*
         * Check the bounds for numeric parameters here
         */
        if (P(P_TS) <= 0 || P(P_TS) > 32) {
                emsg("Invalid tab size specified");
                P(P_TS) = 8;
                return;
        }

        if (P(P_SS) <= 0 || P(P_SS) > Rows) {
                emsg("Invalid scroll size specified");
                P(P_SS) = 12;
                return;
        }

#ifndef TILDEOP
        if (P(P_TO)) {
                emsg("Tilde-operator not enabled");
                P(P_TO) = FALSE;
                return;
        }
#endif
        /*
         * Check for another argument, and call doset() recursively, if
         * found. If any argument results in an error, no further
         * parameters are processed.
         */
        while (*arg != ' ' && *arg != '\t') {   /* skip to next white space */
                if (*arg == NUL)
                        return;                 /* end of parameter list */
                arg++;
        }
        while (*arg == ' ' || *arg == '\t')     /* skip to next non-white */
                arg++;

        if (*arg)
                doset(arg);     /* recurse on next parameter */
}

static  void
showparms(all)
bool_t  all;    /* show ALL parameters */
{
        register struct param   *p;
        char    buf[64];

        gotocmd(TRUE, 0);
        outstr("Parameters:\r\n");

        for (p = &params[0]; p->fullname[0] != NUL ;p++) {
                if (!all && ((p->flags & P_CHANGED) == 0))
                        continue;
                if (p->flags & P_BOOL)
                        sprintf(buf, "\t%s%s\r\n",
                                (p->value ? "" : "no"), p->fullname);
                else
                        sprintf(buf, "\t%s=%d\r\n", p->fullname, p->value);

                outstr(buf);
        }
        wait_return();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vi\ops.c ===
/* $Header: /nw/tony/src/stevie/src/RCS/ops.c,v 1.5 89/08/06 09:50:42 tony Exp $
 *
 * Contains routines that implement the operators in vi. Everything in this
 * file is called only from code in normal.c
 */

#include "stevie.h"
#include <io.h>
#include "ops.h"

char    *lastcmd = NULL;/* the last thing we did */

static void inslines();
static void tabinout();

/*
 * doshift - handle a shift operation
 */
void
doshift(op, c1, c2, num)
int     op;
char    c1, c2;
int     num;
{
        LNPTR   top, bot;
        int     nlines;
        char    opchar;

        top = startop;
        bot = *Curschar;

        if (lt(&bot, &top))
                pswap(&top, &bot);

        u_save(top.linep->prev, bot.linep->next);

        nlines = cntllines(&top, &bot);
        *Curschar = top;
        tabinout((op == LSHIFT), nlines);

        /* construct Redo buff */
        opchar = (char)((op == LSHIFT) ? '<' : '>');
        if (num != 0)
                sprintf(Redobuff, "%c%d%c%c", opchar, num, c1, c2);
        else
                sprintf(Redobuff, "%c%c%c", opchar, c1, c2);

        /*
         * The cursor position afterward is the prior of the two positions.
         */
        *Curschar = top;

        /*
         * If we were on the last char of a line that got shifted left,
         * then move left one so we aren't beyond the end of the line
         */
        if (gchar(Curschar) == NUL && Curschar->index > 0)
                Curschar->index--;

        updatescreen();

        if (nlines > P(P_RP))
                smsg("%d lines %ced", nlines, opchar);
}

/*
 * dodelete - handle a delete operation
 */
void
dodelete(c1, c2, num)
char    c1, c2;
int     num;
{
        LNPTR    top, bot;
        int     nlines;
        register int    n;

        /*
         * Do a yank of whatever we're about to delete. If there's too much
         * stuff to fit in the yank buffer, then get a confirmation before
         * doing the delete. This is crude, but simple. And it avoids doing
         * a delete of something we can't put back if we want.
         */
        if (!doyank()) {
                msg("yank buffer exceeded: press <y> to confirm");
                if (vgetc() != 'y') {
                        msg("delete aborted");
                        *Curschar = startop;
                        return;
                }
        }

        top = startop;
        bot = *Curschar;

        if (lt(&bot, &top))
                pswap(&top, &bot);

        u_save(top.linep->prev, bot.linep->next);

        nlines = cntllines(&top, &bot);
        *Curschar = top;
        cursupdate();

        if (mtype == MLINE) {
                delline(nlines, TRUE);
        } else {
                if (!mincl && bot.index != 0)
                        dec(&bot);

                if (top.linep == bot.linep) {           /* del. within line */
                        n = bot.index - top.index + 1;
                        while (n--)
                                if (!delchar(TRUE))
                                        break;
                } else {                                /* del. between lines */
                        n = Curschar->index;
                        while (Curschar->index >= n)
                                if (!delchar(TRUE))
                                        break;

                        top = *Curschar;
                        *Curschar = *nextline(Curschar);
                        delline(nlines-2, TRUE);
                        Curschar->index = 0;
                        n = bot.index + 1;
                        while (n--)
                                if (!delchar(TRUE))
                                        break;
                        *Curschar = top;
                        (void) dojoin(FALSE);
                        oneright();     /* we got bumped left up above */
                }
        }

        /* construct Redo buff */
        if (num != 0)
                sprintf(Redobuff, "d%d%c%c", num, c1, c2);
        else
                sprintf(Redobuff, "d%c%c", c1, c2);

        if (mtype == MCHAR && nlines == 1)
                updateline();
        else
                updatescreen();

        if (nlines > P(P_RP))
                smsg("%d fewer lines", nlines);
}

/*
 * dofilter - handle a filter operation
 */

#define ITMP    "viXXXXXX"
#define OTMP    "voXXXXXX"

static  char    itmp[32];
static  char    otmp[32];


/*
 * dofilter - filter lines through a command given by the user
 *
 * We use temp files and the system() routine here. This would normally
 * be done using pipes on a UNIX machine, but this is more portable to
 * the machines we usually run on. The system() routine needs to be able
 * to deal with redirection somehow, and should handle things like looking
 * at the PATH env. variable, and adding reasonable extensions to the
 * command name given by the user. All reasonable versions of system()
 * do this.
 */
void
dofilter(c1, c2, num)
char    c1, c2;
int     num;
{
        char    *buff;                  /* cmd buffer from getcmdln() */
        char    cmdln[200];             /* filtering command line */
        LNPTR    top, bot;
        int     nlines;

        top = startop;
        bot = *Curschar;

        buff = getcmdln('!');

        if (buff == NULL)       /* user backed out of the command prompt */
                return;

        if (*buff == '!') {             /* use the 'last' command */
                if (lastcmd == NULL) {
                        emsg("No previous command");
                        return;
                }
                buff = lastcmd;
        }

        /*
         * Remember the current command
         */
        if (lastcmd != NULL)
                free(lastcmd);
        lastcmd = strsave(buff);

        if (lt(&bot, &top))
                pswap(&top, &bot);

        u_save(top.linep->prev, bot.linep->next);

        nlines = cntllines(&top, &bot);
        *Curschar = top;
        cursupdate();

        /*
         * 1. Form temp file names
         * 2. Write the lines to a temp file
         * 3. Run the filter command on the temp file
         * 4. Read the output of the command into the buffer
         * 5. Delete the original lines to be filtered
         * 6. Remove the temp files
         */

#ifdef  TMPDIR
        strcpy(itmp, TMPDIR);
        strcpy(otmp, TMPDIR);
#else
        itmp[0] = otmp[0] = NUL;
#endif
        strcat(itmp, ITMP);
        strcat(otmp, OTMP);

        if (_mktemp(itmp) == NULL || _mktemp(otmp) == NULL) {
                emsg("Can't get temp file names");
                return;
        }

        if (!writeit(itmp, &top, &bot)) {
                emsg("Can't create input temp file");
                return;
        }

        sprintf(cmdln, "%s <%s >%s", buff, itmp, otmp);

        if (system(cmdln) != 0) {
                emsg("Filter command failed");
                remove(ITMP);
                return;
        }

        if (readfile(otmp, &bot, TRUE)) {
                emsg("Can't read filter output");
                return;
        }

        delline(nlines, TRUE);

        remove(itmp);
        remove(otmp);

        /* construct Redo buff */
        if (num != 0)
                sprintf(Redobuff, "d%d%c%c", num, c1, c2);
        else
                sprintf(Redobuff, "d%c%c", c1, c2);

        updatescreen();

        if (nlines > P(P_RP))
                smsg("%d lines filtered", nlines);
}

#ifdef  TILDEOP
void
dotilde(c1, c2, num)
char    c1, c2;
int     num;
{
    LNPTR    top, bot;
        register char   c;

        /* construct Redo buff */
        if (num != 0)
                sprintf(Redobuff, "~%d%c%c", num, c1, c2);
        else
                sprintf(Redobuff, "~%c%c", c1, c2);

        top = startop;
        bot = *Curschar;

        if (lt(&bot, &top))
                pswap(&top, &bot);

        u_save(top.linep->prev, bot.linep->next);

        if (mtype == MLINE) {
                top.index = 0;
                bot.index = strlen(bot.linep->s);
        } else {
                if (!mincl) {
                        if (bot.index)
                                bot.index--;
                }
        }

        for (; ltoreq(&top, &bot) ;inc(&top)) {
                /*
                 * Swap case through the range
                 */
                c = (char)gchar(&top);
                if (isalpha(c)) {
                        if (islower(c))
                                c = (char)toupper(c);
                        else
                                c = (char)tolower(c);

                        pchar(&top, c);         /* Change current character. */
                        CHANGED;
                }
        }
        *Curschar = startop;
        updatescreen();
}
#endif

/*
 * dochange - handle a change operation
 */
void
dochange(c1, c2, num)
char    c1, c2;
int     num;
{
        char    sbuf[16];
        bool_t  doappend;       /* true if we should do append, not insert */
        bool_t  at_eof;         /* changing through the end of file */
    LNPTR    top, bot;

        top = startop;
        bot = *Curschar;

        if (lt(&bot, &top))
                pswap(&top, &bot);

        doappend = endofline(&bot);
        at_eof = (bot.linep->next == Fileend->linep);

        dodelete(c1, c2, num);

        if (mtype == MLINE) {
                /*
                 * If we made a change through the last line of the file,
                 * then the cursor got backed up, and we need to open a
                 * new line forward, otherwise we go backward.
                 */
                if (at_eof)
                        opencmd(FORWARD, FALSE);
                else
                        opencmd(BACKWARD, FALSE);
        } else {
                if (doappend && !lineempty())
                        inc(Curschar);
        }

        if (num)
                sprintf(sbuf, "c%d%c%c", num, c1, c2);
        else
                sprintf(sbuf, "c%c%c", c1, c2);

        startinsert(sbuf, mtype == MLINE);
}


/*
 * docasechange - handle a case change operation
 */
void
docasechange(char c1, char c2, int num, bool_t fToUpper)
{
        LNPTR         top, bot;
        register char c;

        /* construct Redo buff */
        if (num != 0)
                sprintf(Redobuff, "%c%d%c%c", fToUpper ? 'V' : 'v',num, c1, c2);
        else
                sprintf(Redobuff, "%c%c%c", fToUpper ? 'V' : 'v',c1, c2);

        top = startop;
        bot = *Curschar;

        if (lt(&bot, &top))
                pswap(&top, &bot);

        u_save(top.linep->prev, bot.linep->next);

        if (mtype == MLINE) {
                top.index = 0;
                bot.index = strlen(bot.linep->s);
        } else {
                if (!mincl) {
                        if (bot.index)
                                bot.index--;
                }
        }

        for (; ltoreq(&top, &bot) ;inc(&top)) {
                /*
                 * change case through the range
                 */
                c = (char)gchar(&top);
                if (isalpha(c)) {

                        c = fToUpper ? (char)toupper(c) : (char)tolower(c);

                        pchar(&top, c);         /* Change current character. */
                        CHANGED;
                }
        }
        *Curschar = startop;
        updatescreen();
}

#define YBSLOP  2048                // yank buffer initial and incr size
char    *YankBuffers[27];
int     CurrentYBSize[27];
int     ybtype[27];

void
inityank()
{
    int i;

    for(i=0; i<27; i++) {
        ybtype[i] = MBAD;
        if((YankBuffers[i] = malloc(CurrentYBSize[i] = YBSLOP)) == NULL) {
            fprintf(stderr,"Cannot allocate initial yank buffers\n");
            windexit(1);
        }
        YankBuffers[i][0] = '\0';
    }
}

void GetBufferIndex(int *index,bool_t *append)
{
    int     i;
    bool_t  a = FALSE;

    if(namedbuff == -1) {
        i = 26;
    } else if(islower(namedbuff)) {
        i = namedbuff - (int)'a';
    } else {
        i = namedbuff - (int)'A';
        a = TRUE;
    }
    *index = i;
    *append = a;
    return;
}

bool_t
doyank()
{
        LNPTR   top, bot;
        char    *ybuf;
        char    *ybstart;
        char    *ybend;
        char    *yptr;
        int     nlines;
        int     buffindex;
        bool_t  buffappend;

        GetBufferIndex(&buffindex,&buffappend);
        namedbuff = -1;

        if(!buffappend) {
            // the given buffer may have grown huge.  Shrink it here.  The
            // realloc should never fail because the buffer is either being
            // shrunk or is staying the same size.
            YankBuffers[buffindex] = ralloc(YankBuffers[buffindex],YBSLOP);
            CurrentYBSize[buffindex] = YBSLOP;
        }

        ybuf = YankBuffers[buffindex];

        ybstart = ybuf;
        yptr = ybstart;
        if(buffappend) {
            yptr += strlen(ybstart);
        }
        ybend = &ybuf[CurrentYBSize[buffindex]-1];

        top = startop;
        bot = *Curschar;

        if (lt(&bot, &top))
                pswap(&top, &bot);

        nlines = cntllines(&top, &bot);

        ybtype[buffindex] = mtype;           /* set the yank buffer type */

        if (mtype == MLINE) {
                top.index = 0;
                bot.index = strlen(bot.linep->s);
                /*
                 * The following statement checks for the special case of
                 * yanking a blank line at the beginning of the file. If
                 * not handled right, we yank an extra char (a newline).
                 */
                if (dec(&bot) == -1) {
                        *yptr = NUL;
                        if (operator == YANK)
                                *Curschar = startop;
                        return TRUE;
                }
        } else {
                if (!mincl) {
                        if (bot.index)
                                bot.index--;
                }
        }

        for (; ltoreq(&top, &bot) ;inc(&top)) {

                // See if we've filled the buffer as currently
                // allocated.  If so, reallocate the buffer and
                // update pointers accordingly before we store the
                // current character.  This is necessary because we will
                // always be storing at least one more char (the NUL)
                // and probably more.

                if(yptr == ybend) {
                        ybstart = ralloc(ybuf,CurrentYBSize[buffindex] + YBSLOP);
                        if(ybstart == NULL) {
                                ybtype[buffindex] = MBAD;
                                return(FALSE);
                        }
                        CurrentYBSize[buffindex] += YBSLOP;
                        yptr += ybstart - ybuf;
                        ybend = &ybstart[CurrentYBSize[buffindex] - 1];
                        ybuf = ybstart;
                        YankBuffers[buffindex] = ybuf;
                }

                *yptr++ = (char)((gchar(&top) != NUL) ? gchar(&top) : NL);
        }

        *yptr = NUL;

        if (operator == YANK) { /* restore Curschar if really doing yank */
                *Curschar = startop;

                if (nlines > P(P_RP))
                        smsg("%d lines yanked", nlines);
        }
        return TRUE;
}

/*
 * doput(dir)
 *
 * Put the yank buffer at the current location, using the direction given
 * by 'dir'.
 */
void
doput(dir)
int     dir;
{
        int     buffindex;
        bool_t  buffappend;
        char   *ybuf;
        int     nb = namedbuff;

        GetBufferIndex(&buffindex,&buffappend);
        namedbuff = -1;
        ybuf = YankBuffers[buffindex];

        if (ybtype[buffindex] == MBAD) {
                char msgbuff[30];
                sprintf(msgbuff,"Nothing in register %c",nb);
                emsg(msgbuff);
                return;
        }

        u_saveline();

        if (ybtype[buffindex] == MLINE)
                inslines(Curschar->linep, dir, ybuf);
        else {
                /*
                 * If we did a character-oriented yank, and the buffer
                 * contains multiple lines, the situation is more complex.
                 * For the moment, we punt, and pretend the user did a
                 * line-oriented yank. This doesn't actually happen that
                 * often.
                 */
                if (strchr(ybuf, NL) != NULL)
                        inslines(Curschar->linep, dir, ybuf);
                else {
                        char    *s;
                        int     len;

                        len = strlen(Curschar->linep->s) + strlen(ybuf) + 1;
                        s = alloc((unsigned) len);
                        strcpy(s, Curschar->linep->s);
                        if (dir == FORWARD)
                                Curschar->index++;
                        strcpy(s + Curschar->index, ybuf);
                        strcat(s, &Curschar->linep->s[Curschar->index]);
                        free(Curschar->linep->s);
                        Curschar->linep->s = s;
                        Curschar->linep->size = len;
                        updateline();
                }
        }

        CHANGED;
}

bool_t
dojoin(join_cmd)
bool_t  join_cmd;               /* handling a real "join" command? */
{
        int     scol;           /* save cursor column */
        int     size;           /* size of the joined line */

        if (nextline(Curschar) == NULL)         /* on last line */
                return FALSE;

        if (!canincrease(size = strlen(Curschar->linep->next->s)))
                return FALSE;

        while (oneright())                      /* to end of line */
                ;

        strcat(Curschar->linep->s, Curschar->linep->next->s);

        /*
         * Delete the following line. To do this we move the cursor
         * there briefly, and then move it back. Don't back up if the
         * delete made us the last line.
         */
        Curschar->linep = Curschar->linep->next;
        scol = Curschar->index;

        if (nextline(Curschar) != NULL) {
                delline(1, TRUE);
                Curschar->linep = Curschar->linep->prev;
        } else
                delline(1, TRUE);

        Curschar->index = scol;

        if (join_cmd)
                oneright();     /* go to first char. of joined line */

        if (join_cmd && size != 0) {
                /*
                 * Delete leading white space on the joined line
                 * and insert a single space.
                 */
                while (gchar(Curschar) == ' ' || gchar(Curschar) == TAB)
                        delchar(TRUE);
                inschar(' ');
        }

        return TRUE;
}

void
startinsert(initstr, startln)
char    *initstr;
int     startln;        /* if set, insert point really at start of line */
{
        register char   *p, c;

        *Insstart = *Curschar;
        if (startln)
                Insstart->index = 0;
        Ninsert = 0;
        Insptr = Insbuff;
        for (p=initstr; (c=(*p++))!='\0'; ) {
                *Insptr++ = c;
                Ninsert++;
        }

        if (*initstr == 'R')
                State = REPLACE;
        else
                State = INSERT;

        if (P(P_MO))
                msg((State == INSERT) ? "Insert Mode" : "Replace Mode");
}
/*
 * tabinout(inout,num)
 *
 * If inout==0, add a tab to the begining of the next num lines.
 * If inout==1, delete a tab from the beginning of the next num lines.
 */
static void
tabinout(inout, num)
int     inout;
int     num;
{
    int     ntodo = num;
    int     c;
    int     col;
    LNPTR    *p;

    while (ntodo-- > 0) {

        beginline(FALSE);

        /*
         * eat leading space, calc the column of first non-white
         */
        col = 0;
        while ((c = gchar(Curschar)) == ' ' || c == TAB) {
            if (c == ' ') {
                ++col;
            } else {
                col += P(P_TS);
                col -= (col % P(P_TS));
            }
            delchar(TRUE);
        }

        /*
         * add or subtract shiftwidth spaces
         */


        if (inout == 0) {
            col += P(P_SW);
        } else {
            col -= P(P_SW);
        }

        if (col < 0) {
            col = 0;
        }

        /*
         * insert space, using TABS if hardtabs is set
         */
        while (col % P(P_TS)) {
            inschar(' ');
            col--;
        }
        if (P(P_HT)) {
            while (col) {
                inschar(TAB);
                col -= P(P_TS);
            }
        } else {
            while (col--) {
                inschar(' ');
            }
        }

        /*
         * next line
         */
        if ( ntodo > 0 ) {
            if ((p = nextline(Curschar)) != NULL) {
                *Curschar = *p;
            }
        }
    }
}

/*
 * inslines(lp, dir, buf)
 *
 * Inserts lines in the file from the given buffer. Lines are inserted
 * before or after "lp" according to the given direction flag. Newlines
 * in the buffer result in multiple lines being inserted. The cursor
 * is left on the first of the inserted lines.
 */
static void
inslines(lp, dir, buf)
LINE    *lp;
int     dir;
char    *buf;
{
        register char   *cp = buf;
        register size_t  len;
        char    *ep;
        LINE    *l, *nc = NULL;

        if (dir == BACKWARD)
                lp = lp->prev;

        do {
                if ((ep = strchr(cp, NL)) == NULL)
                        len = strlen(cp);
                else
                        len = (size_t)(ep - cp);

                l = newline(len);
                if (len != 0)
                        strncpy(l->s, cp, len);
                l->s[len] = NUL;

                l->next = lp->next;
                l->prev = lp;
                lp->next->prev = l;
                lp->next = l;

                if (nc == NULL)
                        nc = l;

                lp = lp->next;

                cp = ep + 1;
        } while (ep != NULL);

        if (dir == BACKWARD)    /* fix the top line in case we were there */
                Filemem->linep = Filetop->linep->next;

        renum();

        updatescreen();
        Curschar->linep = nc;
        Curschar->index = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vi\nt.c ===
/* $Header: /nw/tony/src/stevie/src/RCS/os2.c,v 1.7 89/08/07 05:49:19 tony Exp $
 *
 * NT System-dependent routines.
 */

/*
 * Revision history:
 *
 *      6/1/93 - Joe Mitchell
 *      Add support to create a new screen buffer. This fixes the
 *      problem of scrolling the number of lines that "screen buffer size
 *      height" is set to when a vertical scroll bar is present.
 *      Allow filenames longer than 8.3 for use with HPFS/NTFS.
 */

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <signal.h>
#include <conio.h>
#include <io.h>
#include <direct.h>
#undef max
#undef min
#include "stevie.h"

#define     MAX_VK   0x7f
#define     UCHR     unsigned char      // so table looks nice


UCHR RegularTable[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 08 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 10 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 18 */  0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x00,
              /* 20 */  0x00, K_PU, K_PD, K_EN, K_HO, K_LE, K_UP, K_RI,
              /* 28 */  K_DO, 0x00, 0x00, 0x00, 0x00, K_IN, K_DE, 0x00,
              /* 30 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 38 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 40 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 48 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 50 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 58 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 60 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 68 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 70 */  K_F1, K_F2, K_F3, K_F4, K_F5, K_F6, K_F7, K_F8,
              /* 78 */  K_F9, K_FA, K_FB, K_FC, 0x00, 0x00, 0x00, 0x00 };

UCHR ShiftedTable[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 08 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 10 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 18 */  0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x00,
              /* 20 */  0x00, K_PU, K_PD, K_EN, K_HO, K_LE, K_UP, K_RI,
              /* 28 */  K_DO, 0x00, 0x00, 0x00, 0x00, K_IN, K_DE, 0x00,
              /* 30 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 38 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 40 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 48 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 50 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 58 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 60 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 68 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 70 */  K_S1, K_S2, K_S3, K_S4, K_S5, K_S6, K_S7, K_S8,
              /* 78 */  K_S9, K_SA, K_SB, K_SC, 0x00, 0x00, 0x00, 0x00 };

UCHR ControlTable[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 08 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 10 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 18 */  0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, K_CG, 0x00,
              /* 20 */  0x00, K_PU, K_PD, K_EN, K_HO, K_LE, K_UP, K_RI,
              /* 28 */  K_DO, 0x00, 0x00, 0x00, 0x00, K_IN, K_DE, 0x00,
              /* 30 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 38 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 40 */  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
              /* 48 */  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
              /* 50 */  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
              /* 58 */  0x18, 0x19, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 60 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 68 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 70 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              /* 78 */  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

#define ALT_PRESSED (RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED)
#define CTL_PRESSED (RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED)
#define CONTROL_ALT (ALT_PRESSED | CTL_PRESSED)

#define OMODE (ENABLE_PROCESSED_OUTPUT | ENABLE_WRAP_AT_EOL_OUTPUT)
static HANDLE CurrConsole;
static HANDLE ViConsole,ConsoleIn;
static HANDLE PrevConsole; // [jrm 6/93] Save previous screen buffer
static DWORD OldConsoleMode;
static DWORD ViConsoleInputMode;

/*
 * inchar() - get a character from the keyboard
 */
int
inchar()
{
    INPUT_RECORD    InputRec;
    DWORD           NumRead;

    got_int = FALSE;

    flushbuf(); /* flush any pending output */

    while(1) {    /* loop until we get a valid console event */

        ReadConsoleInput(ConsoleIn,&InputRec,1,&NumRead);
        if((InputRec.EventType == KEY_EVENT)
        && (InputRec.Event.KeyEvent.bKeyDown))
        {
            KEY_EVENT_RECORD *KE = &InputRec.Event.KeyEvent;
            unsigned char *Table;

            if(KE->dwControlKeyState & ALT_PRESSED) {
                continue;       // no ALT keys allowed.
            } else if(KE->dwControlKeyState & CTL_PRESSED) {
                Table = ControlTable;
            } else if(KE->uChar.AsciiChar) {    // no control, no alt
                return(KE->uChar.AsciiChar);
            } else if(KE->dwControlKeyState & SHIFT_PRESSED) {
                Table = ShiftedTable;
            } else {
                Table = RegularTable;
            }

            if((KE->wVirtualKeyCode > MAX_VK) || !Table[KE->wVirtualKeyCode]) {
                continue;
            }
            return(Table[KE->wVirtualKeyCode]);
        }
    }
}

#if 0
        switch (c = _getch()) {
        case 0x1e:
            return K_CGRAVE;
        case 0:             /* special key */
            if (State != NORMAL) {
                c = _getch();    /* throw away next char */
                continue;   /* and loop for another char */
            }
            switch (c = _getch()) {
            case 0x50:
                return K_DARROW;
            case 0x48:
                return K_UARROW;
            case 0x4b:
                return K_LARROW;
            case 0x4d:
                return K_RARROW;
            case 0x52:
                return K_INSERT;
            case 0x47:
                stuffin("1G");
                return -1;
            case 0x4f:
                stuffin("G");
                return -1;
            case 0x51:
                stuffin(mkstr(CTRL('F')));
                return -1;
            case 0x49:
                stuffin(mkstr(CTRL('B')));
                return -1;
            /*
             * Hard-code some useful function key macros.
             */
            case 0x3b: /* F1 */
                stuffin(":N\n");
                return -1;
            case 0x54: /* SF1 */
                stuffin(":N!\n");
                return -1;
            case 0x3c: /* F2 */
                stuffin(":n\n");
                return -1;
            case 0x55: /* SF2 */
                stuffin(":n!\n");
                return -1;
            case 0x3d: /* F3 */
                stuffin(":e #\n");
                return -1;
            case 0x3e: /* F4 */
                stuffin(":rew\n");
                return -1;
            case 0x57: /* SF4 */
                stuffin(":rew!\n");
                return -1;
            case 0x3f: /* F5 */
                stuffin("[[");
                return -1;
            case 0x40: /* F6 */
                stuffin("]]");
                return -1;
            case 0x41: /* F7 - explain C declaration */
                stuffin("yyp^iexplain \033!!cdecl\n");
                return -1;
            case 0x42: /* F8 - declare C variable */
                stuffin("yyp!!cdecl\n");
                return -1;
            case 0x43: /* F9 */
                stuffin(":x\n");
                return -1;
            case 0x44: /* F10 */
                stuffin(":help\n");
                return -1;
            default:
                break;
            }
            break;

        default:
            return c;
        }
    }
}
#endif

#define BSIZE   2048
static  char    outbuf[BSIZE];
static  int bpos = 0;
DWORD CursorSize;
DWORD OrgCursorSize;

void
flushbuf()
{
    BOOL st;     // [jrm 6/93]
    DWORD count; // [jrm 6/93]

    //
    // [jrm 6/93] Use WriteFile rather than "write" to take advantage of
    // new screen buffer.
    //
    if (bpos != 0) {
//jrm   write(1, outbuf, bpos);
        st = WriteFile(CurrConsole, outbuf, bpos, &count, NULL);
        if (!st) {
            fprintf(stderr, "vi: Error calling WriteFile");
        }
    }

    bpos = 0;
}

/*
 * Macro to output a character. Used within this file for speed.
 */
#define outone(c)   outbuf[bpos++] = c; if (bpos >= BSIZE) flushbuf()

/*
 * Function version for use outside this file.
 */
void
outchar(c)
register char   c;
{
    outbuf[bpos++] = c;
    if (bpos >= BSIZE)
        flushbuf();
}

/*
 * outstr(s) - write a string to the console
 */
void
outstr(s)
register char   *s;
{
    while (*s) {
        outone(*s++);
    }
}

void
beep()
{
	Beep(500,50);      // 500Hz for 1/4 sec
}

void sleep(n)
int n;
{
    Sleep(1000L * n);
}

void
delay()
{
    flushbuf();
    Sleep(300L);
}

void
sig()
{
//  signal(SIGINT, sig);

    got_int = TRUE;
}

WORD  Attribute;
WORD  HighlightAttribute;

void
useviconsole()
{
    flushbuf();

    SetConsoleActiveScreenBuffer(CurrConsole = ViConsole);
    CursorSize = P(P_CS);
    VisibleCursor();
    FlushConsoleInputBuffer(ConsoleIn);
    SetConsoleMode(ConsoleIn,ViConsoleInputMode);
}

void
usecmdconsole()
{
    flushbuf();

    SetConsoleActiveScreenBuffer(CurrConsole = PrevConsole);
    CursorSize = OrgCursorSize;
    VisibleCursor();
    FlushConsoleInputBuffer(ConsoleIn);
    SetConsoleMode(ConsoleIn,OldConsoleMode);
}

void
windinit()
{
    COORD coord;
    CONSOLE_SCREEN_BUFFER_INFO Info;
    CONSOLE_CURSOR_INFO Info2;
    DWORD NumRead;

    ConsoleIn=GetStdHandle(STD_INPUT_HANDLE);

    //
    // [jrm 6/93] Create a new screen buffer. This fixes the scroll problem
    // when there is a vertical scroll bar.
    //
    PrevConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    CurrConsole =
    ViConsole = CreateConsoleScreenBuffer(GENERIC_READ | GENERIC_WRITE,
                                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                                          NULL,
                                          CONSOLE_TEXTMODE_BUFFER,
                                          NULL);
    if (ViConsole == INVALID_HANDLE_VALUE) {
        printf("CreateConsoleScreenBuffer failed in windinit\n");
        printf("LastError = 0x%lx\n", GetLastError());
        exit(0);
    }
    SetConsoleActiveScreenBuffer(ViConsole);
    SetConsoleMode(ViConsole, OMODE);

    GetConsoleScreenBufferInfo(ViConsole,&Info);
    P(P_CO) = Columns = Info.dwSize.X;
    P(P_LI) = Rows = Info.dwSize.Y;
    P(P_SS) = Rows / 2;

    GetConsoleCursorInfo(ViConsole,&Info2);
    P(P_CS) = OrgCursorSize = CursorSize = Info2.dwSize;
    coord.X = coord.Y = 0;
    ReadConsoleOutputAttribute(ViConsole,
                               &Attribute,
                               sizeof(Attribute)/sizeof(WORD),
                               coord,
                               &NumRead);
    GetConsoleMode(ConsoleIn,&OldConsoleMode);
    ViConsoleInputMode = OldConsoleMode & ~(ENABLE_PROCESSED_INPUT |
                                            ENABLE_LINE_INPUT |
                                            ENABLE_ECHO_INPUT |
                                            ENABLE_WINDOW_INPUT |
                                            ENABLE_MOUSE_INPUT
                                           );
    SetConsoleMode(ConsoleIn,ViConsoleInputMode);







    setviconsoletitle();

//  signal(SIGINT, sig);

    //
    // Calculate a reasonable default search highlight
    // by flipping colors for the current screen.
    //

    HighlightAttribute = ((Attribute & 0xff00) | ((Attribute & 0x00f0) >> 4) |
                         ((Attribute & 0x000f) << 4));
}

void
setviconsoletitle()
{
    char title[2000];
    strcpy(title, Appname);
    if (Filename) {
        strcat(title, " ");
        strcat(title, Filename);
    }
    SetConsoleTitle(title);
}

void
wchangescreen(NewRows, NewColumns)
int NewRows;
int NewColumns;
{
#if 0
    CONSOLE_SCREEN_BUFFER_INFO info;
#endif
    SMALL_RECT                 screenRect;
    COORD                      screenSize;

#if 0
    GetConsoleScreenBufferInfo(ViConsole,&info);

    info.dwSize.X = NewRows;
    info.dwSize.Y = NewColumns;
#endif

    screenSize.X = (short)NewColumns;
    screenSize.Y = (short)NewRows;

    SetConsoleScreenBufferSize(ViConsole, screenSize);

    screenRect.Top = 0;
    screenRect.Left = 0;
    screenRect.Right = NewColumns - 1;
    screenRect.Bottom = NewRows - 1;

    SetConsoleWindowInfo(ViConsole, TRUE, &screenRect);
}

void
windexit(r)
int r;
{
    usecmdconsole();
    exit(r);
}

void
windgoto(r, c)
register int    r, c;
{
    COORD coord;

    flushbuf();
    coord.X = (SHORT)c;
    coord.Y = (SHORT)r;
    SetConsoleCursorPosition(ViConsole,coord);
}

FILE *
fopenb(fname, mode)
char    *fname;
char    *mode;
{
    char    modestr[16];

    sprintf(modestr, "%sb", mode);
    return fopen(fname, modestr);
}

#define PSIZE   128

/*
 * fixname(s) - fix up a dos name
 *
 * Takes a name like:
 *
 *  d:\x\y\z\base.ext
 *
 * and trims 'base' to 8 characters, and 'ext' to 3.
 */
char *
fixname(s)
char    *s;
{
    static  char    f[PSIZE];
    char    base[32];
    char    ext[32];
    char    *p;
    int	d = 0;
    int i;

    strcpy(f, s);

    if (f[1] == ':') {
    	if (('a' <= f[0] && f[0] <= 'z') ||
    	    ('A' <= f[0] && f[0] <= 'Z')) {
    	    d = 2;
    	}
    }

    for (i=0; i < PSIZE ;i++)
        if (f[d+i] == '/')
            f[d+i] = '\\';

    /*
     * Split the name into directory, base, extension.
     */
    if ((p = strrchr(f+d, '\\')) != NULL) {
        strcpy(base, p+1);
        p[1] = '\0';
    } else {
        strcpy(base, f+d);
        f[d] = '\0';
    }

    if ((p = strchr(base, '.')) != NULL) {
        strcpy(ext, p+1);
        *p = '\0';
    } else
        ext[0] = '\0';

#if 0 /* [jrm 6/93] Allow longer filenames for HPFS/NTFS */
    /*
     * Trim the base name if necessary.
     */
    if (strlen(base) > 8)
        base[8] = '\0';

    if (strlen(ext) > 3)
        ext[3] = '\0';
#endif

    /*
     * Paste it all back together
     */
    strcat(f, base);
    strcat(f, ".");
    strcat(f, ext);

    return f;
}

LONG
mysystem(cmd, async)
char *cmd;
int  async;
{
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    BOOL ok;
    DWORD status;
    char *cmdline;
    char title[200];
    char *title2;

    char *shell = getenv("SHELL");

    if (!shell) {
        shell = getenv("COMSPEC");
    }

    if (!shell) {
        shell = "cmd.exe";
    }

    if (!cmd) {
        return !_access(shell,0);
    }

    if (!*cmd) {
        cmdline = _strdup(shell);
    } else {
        cmdline = malloc(strlen(shell) + strlen(cmd) + 5);
        strcpy(cmdline, shell);
        strcat(cmdline, " /c ");
        strcat(cmdline, cmd);
    }


    memset(&si, 0, sizeof(si));
    si.cb = sizeof(si);

    if (async) {
        si.dwFlags = STARTF_USESHOWWINDOW;
        si.wShowWindow = SW_SHOWNA;
    }

    if (!async) {
        GetConsoleTitle(title, sizeof(title));
        title2 = malloc(strlen(title) + 4 + strlen(cmdline));
        strcpy(title2, title);
        strcat(title2, " - ");
        strcat(title2, cmdline);
        SetConsoleTitle(title2);
        free(title2);
    }

    ok = CreateProcess(NULL,
                       cmdline,
                       NULL,
                       NULL,
                       FALSE,
                       CREATE_NEW_PROCESS_GROUP |
                        (async ? CREATE_NEW_CONSOLE : 0),
                       NULL,
                       NULL,
                       &si,
                       &pi
                       );
    free(cmdline);

    if (!ok) {
        status = (DWORD)-1;
    } else {
        if (async) {
            status = 0;
        } else {
            SetConsoleCtrlHandler(NULL, TRUE);
            WaitForSingleObject(pi.hProcess, INFINITE);
            SetConsoleCtrlHandler(NULL, FALSE);
            GetExitCodeProcess(pi.hProcess, &status);
        }
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
    }

    if (!async) {
        SetConsoleTitle(title);
    }

    return (LONG)status;
}

void
doshell(cmd, async)
char    *cmd;
int     async;
{
    int c;

    if (async) {

        mysystem(cmd? cmd : "", async);

    } else {

        usecmdconsole();

        if (!cmd) {
            mysystem("", async);
        } else {
            outchar('!');
            outstr(cmd);
            outchar('\n');
            flushbuf();
            mysystem(cmd, async);
        }

        c = wait_return0();
        outchar('\n');
        useviconsole();

        if (c == ':') {
            outchar(NL);
            docmdln(getcmdln(c));
        } else {
           screenclear();
        }
        updatescreen();
    }
}

void
dochdir(arg)
char *arg;
{
    if (_chdir(arg)) {
        emsg("bad directory");
    }
}


/*
    NT console stuff
*/

static DWORD RowSave,ColSave;

void Scroll(int t,int l,int b,int r,int Row,int Col)
{
    SMALL_RECT  ScrollRect;
    COORD       Coord;
    CHAR_INFO   CharInfo;

    ScrollRect.Left = (SHORT)l;
    ScrollRect.Right = (SHORT)r;
    ScrollRect.Top = (SHORT)t;
    ScrollRect.Bottom = (SHORT)b;
    Coord.X = (SHORT)Col;
    Coord.Y = (SHORT)Row;
    CharInfo.Char.AsciiChar = ' ';
    CharInfo.Attributes = Attribute;
    ScrollConsoleScreenBuffer(ViConsole,&ScrollRect,NULL,Coord,&CharInfo);
}

void EraseLine(void)
{
    CONSOLE_SCREEN_BUFFER_INFO Info;
    DWORD NumWritten;

    flushbuf();
    GetConsoleScreenBufferInfo(ViConsole,&Info);
    Info.dwCursorPosition.X = 0;
    SetConsoleCursorPosition(ViConsole,Info.dwCursorPosition);
    FillConsoleOutputCharacter(ViConsole,' ',Columns,Info.dwCursorPosition, &NumWritten);
}

void EraseNLinesAtRow(int n,int row)
{
    COORD coord;
    DWORD NumWritten;

    flushbuf();
    coord.X = 0;
    coord.Y = (short)row;
    FillConsoleOutputCharacter(ViConsole,' ',n*Columns,coord, &NumWritten);
}

void ClearDisplay(void)
{
    COORD c;
    DWORD NumWritten;

    flushbuf();
    c.X = c.Y = 0;
    SetConsoleCursorPosition(ViConsole,c);
    FillConsoleOutputCharacter(ViConsole,' ',Rows*Columns,c, &NumWritten);
}

void SaveCursor(void)
{
    CONSOLE_SCREEN_BUFFER_INFO Info;

    flushbuf();
    GetConsoleScreenBufferInfo(ViConsole,&Info);
    ColSave = Info.dwCursorPosition.X;
    RowSave = Info.dwCursorPosition.Y;
}

void RestoreCursor(void)
{
    COORD c;

    flushbuf();
    c.X = (SHORT)ColSave;
    c.Y = (SHORT)RowSave;
    SetConsoleCursorPosition(ViConsole,c);
}

void InvisibleCursor(void)
{
    CONSOLE_CURSOR_INFO Info;

    flushbuf();
    Info.dwSize = CursorSize;
    Info.bVisible = FALSE;
    SetConsoleCursorInfo(CurrConsole,&Info);
}

void VisibleCursor(void)
{
    CONSOLE_CURSOR_INFO Info;

    flushbuf();
    Info.dwSize = CursorSize;
    Info.bVisible = TRUE;
    SetConsoleCursorInfo(CurrConsole,&Info);
}

int CurHighlightLine = -1;
int CurHighlightColumn = -1;
int CurHighlightLength = -1;
char CurHighlightString[512];

int
StrLength(char *cp)
{
    int length = 0;
    int diff;

    while (*cp) {
        if (*cp == '\t') {
            diff = P(P_TS) - (length % P(P_TS));
            length += diff;
        } else {
            length++;
        }
        cp++;
    }
    return length;
}

void HighlightLine( int col, unsigned long line, char *string )
{
    COORD	dwWriteCoord;
    DWORD   dwNumWritten;
    int     length;

    if (P(P_HS) == FALSE)
        return;

    length = StrLength(string);

    if (length > Columns) {
        length = Columns;
    }
    if (col >= (Columns - 1)) {
        col--;
    }
    dwWriteCoord.X = CurHighlightColumn = col;
    dwWriteCoord.Y = CurHighlightLine = line;
    FillConsoleOutputAttribute(ViConsole,
                               HighlightAttribute,
                               length,
                               dwWriteCoord,
                               &dwNumWritten);
    updateline();
#if 0
    WriteConsoleOutputCharacter(ViConsole,
                                string,
                                length,
                                dwWriteCoord,
                                &dwNumWritten);
#endif
    strcpy(CurHighlightString, string);
    CurHighlightLength = length;
}

#define FOREGROUND_WHITE (FOREGROUND_BLUE | \
                          FOREGROUND_GREEN | \
                          FOREGROUND_RED | \
                          FOREGROUND_INTENSITY)

void RemoveHighlight( int col, unsigned long line, int length, char *string )
{
    COORD	dwWriteCoord;
    DWORD   dwNumWritten;

    length = StrLength(string);
    if (length > Columns) {
        length = Columns;
    }
    dwWriteCoord.X = (short)col;
    dwWriteCoord.Y = (int)line;
    FillConsoleOutputAttribute(ViConsole,
                               Attribute,
                               length,
                               dwWriteCoord,
                               &dwNumWritten);
    updateline();
#if 0
    WriteConsoleOutputCharacter(ViConsole,
                                string,
                                length,
                                dwWriteCoord,
                                &dwNumWritten);

#endif
}

void HighlightCheck()
{
    if (P(P_HS) == FALSE)
        return;

    if (CurHighlightLine != -1) {
        RemoveHighlight(CurHighlightColumn,
                        CurHighlightLine,
                        CurHighlightLength,
                        CurHighlightString);
        CurHighlightLine = -1;
        CurHighlightColumn = -1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vi\normal.c ===
/*
 *
 * Contains the main routine for processing characters in command mode.
 * Communicates closely with the code in ops.c to handle the operators.
 */

#include "stevie.h"
#include "ops.h"

/*
 * Generally speaking, every command in normal() should either clear any
 * pending operator (with CLEAROP), or set the motion type variable.
 */

#define CLEAROP (operator=NOP, namedbuff = -1)  /* clear any pending operator */

int     operator = NOP;         /* current pending operator */
int     mtype;                  /* type of the current cursor motion */
bool_t  mincl;                  /* true if char motion is inclusive */
LNPTR    startop;        /* cursor pos. at start of operator */

/*
 * Operators can have counts either before the operator, or between the
 * operator and the following cursor motion as in:
 *
 *      d3w or 3dw
 *
 * If a count is given before the operator, it is saved in opnum. If
 * normal() is called with a pending operator, the count in opnum (if
 * present) overrides any count that came later.
 */
static  int     opnum = 0;

#define DEFAULT1(x)     (((x) == 0) ? 1 : (x))

void HighlightCheck();

/*
 * normal(c)
 *
 * Execute a command in command mode.
 *
 * This is basically a big switch with the cases arranged in rough categories
 * in the following order:
 *
 *      1. File positioning commands
 *      2. Control commands (e.g. ^G, Z, screen redraw, etc)
 *      3. Character motions
 *      4. Search commands (of various kinds)
 *      5. Edit commands (e.g. J, x, X)
 *      6. Insert commands (e.g. i, o, O, A)
 *      7. Operators
 *      8. Abbreviations (e.g. D, C)
 *      9. Marks
 */
void
normal(c)
register int    c;
{
        register int    n;
        register char   *s;     /* temporary variable for misc. strings */
        bool_t  flag = FALSE;
        int     type = 0;       /* used in some operations to modify type */
        int     dir = FORWARD;  /* search direction */
        int     nchar = NUL;
        bool_t  finish_op;

        /*
         * If there is an operator pending, then the command we take
         * this time will terminate it. Finish_op tells us to finish
         * the operation before returning this time (unless the operation
         * was cancelled.
         */
        finish_op = (operator != NOP);

        /*
         * If we're in the middle of an operator AND we had a count before
         * the operator, then that count overrides the current value of
         * Prenum. What this means effectively, is that commands like
         * "3dw" get turned into "d3w" which makes things fall into place
         * pretty neatly.
         */
        if (finish_op) {
                if (opnum != 0)
                        Prenum = opnum;
        } else {
                opnum = 0;
        }

        u_lcheck();     /* clear the "line undo" buffer if we've moved */
        HighlightCheck();

        switch (c & 0xff) {

        /*
         * named buffer support
         */

        case('"'):
            // not allowed anywhere but at the beginning of a command
            if(finish_op || !isalpha(namedbuff = vgetc())) {
                CLEAROP;
                beep();
            } else {
            }
            break;

        /*
         * Screen positioning commands
         */
        case CTRL('D'):
                CLEAROP;
                if (Prenum)
                        P(P_SS) = (Prenum > Rows-1) ? Rows-1 : Prenum;
                scrollup(P(P_SS));
                onedown(P(P_SS));
                updatescreen();
                break;

        case CTRL('U'):
                CLEAROP;
                if (Prenum)
                        P(P_SS) = (Prenum > Rows-1) ? Rows-1 : Prenum;
                scrolldown(P(P_SS));
                oneup(P(P_SS));
                updatescreen();
                break;

        /*
         * This is kind of a hack. If we're moving by one page, the calls
         * to stuffin() do exactly the right thing in terms of leaving
         * some context, and so on. If a count was given, we don't have
         * to worry about these issues.
         */
        case K_PAGEDOWN:
        case CTRL('F'):
                CLEAROP;
                n = DEFAULT1(Prenum);
                if (n > 1) {
                        if ( ! onedown(Rows * n) )
                                beep();
                        cursupdate();
                } else {
                        screenclear();
                        stuffin("Lz\nM");
                }
                break;

        case K_PAGEUP:
        case CTRL('B'):
                CLEAROP;
                n = DEFAULT1(Prenum);
                if (n > 1) {
                        if ( ! oneup(Rows * n) )
                                beep();
                        cursupdate();
                } else {
                        screenclear();
                        stuffin("Hz-M");
                }
                break;

        case CTRL('E'):
                CLEAROP;
                scrollup(DEFAULT1(Prenum));
                updatescreen();
                break;

        case CTRL('Y'):
                CLEAROP;
                scrolldown(DEFAULT1(Prenum));
                updatescreen();
                break;

        case 'z':
                CLEAROP;
                switch (vgetc()) {
                case NL:                /* put Curschar at top of screen */
                case CR:
                        *Topchar = *Curschar;
                        Topchar->index = 0;
                        updatescreen();
                        break;

                case '.':               /* put Curschar in middle of screen */
                        n = Rows/2;
                        goto dozcmd;

                case '-':               /* put Curschar at bottom of screen */
                        n = Rows-1;
                        /* fall through */

                dozcmd:
                        {
                register LNPTR   *lp = Curschar;
                                register int    l = 0;

                                while ((l < n) && (lp != NULL)) {
                                        l += plines(lp);
                                        *Topchar = *lp;
                                        lp = prevline(lp);
                                }
                        }
                        Topchar->index = 0;
                        updatescreen();
                        break;

                default:
                        beep();
                }
                break;

        /*
         * Control commands
         */
        case ':':
                CLEAROP;
                if ((s = getcmdln(c)) != NULL)
                        docmdln(s);
                break;

        case CTRL('L'):
                CLEAROP;
                screenclear();
                updatescreen();
                break;


        case CTRL('O'):                 /* ignored */
                /*
                 * A command that's ignored can be useful. We use it at
                 * times when we want to postpone redraws. By stuffing
                 * in a control-o, redraws get suspended until the editor
                 * gets back around to processing input.
                 */
                break;

        case CTRL('G'):
                CLEAROP;
                fileinfo();
                break;

        case K_CGRAVE:                  /* shorthand command */
                CLEAROP;
                stuffin(":e #\n");
                break;

        case 'Z':                       /* write, if changed, and exit */
                if (vgetc() != 'Z') {
                        beep();
                        break;
                }
                doxit();
                break;

        /*
         * Macro evaluates true if char 'c' is a valid identifier character
         */
#       define  IDCHAR(c)       (isalpha(c) || isdigit(c) || (c) == '_')

        case CTRL(']'):                 /* :ta to current identifier */
                CLEAROP;
                {
                        char    ch;
                        LNPTR    save;

                        save = *Curschar;
                        /*
                         * First back up to start of identifier. This
                         * doesn't match the real vi but I like it a
                         * little better and it shouldn't bother anyone.
                         */
                        ch = (char)gchar(Curschar);
                        while (IDCHAR(ch)) {
                                if (!oneleft())
                                        break;
                                ch = (char)gchar(Curschar);
                        }
                        if (!IDCHAR(ch))
                                oneright();

                        stuffin(":ta ");
                        /*
                         * Now grab the chars in the identifier
                         */
                        ch = (char)gchar(Curschar);
                        while (IDCHAR(ch)) {
                                stuffin(mkstr(ch));
                                if (!oneright())
                                        break;
                                ch = (char)gchar(Curschar);
                        }
                        stuffin("\n");

                        *Curschar = save;       /* restore, in case of error */
                }
                break;

        /*
         * Character motion commands
         */
        case 'G':
                mtype = MLINE;
                *Curschar = *gotoline(Prenum);
                beginline(TRUE);
                break;

        case 'H':
                mtype = MLINE;
                *Curschar = *Topchar;
                for (n = Prenum; n && onedown(1) ;n--)
                        ;
                beginline(TRUE);
                break;

        case 'M':
                mtype = MLINE;
                *Curschar = *Topchar;
                for (n = 0; n < Rows/2 && onedown(1) ;n++)
                        ;
                beginline(TRUE);
                break;

        case 'L':
                mtype = MLINE;
                *Curschar = *prevline(Botchar);
                for (n = Prenum; n && oneup(1) ;n--)
                        ;
                beginline(TRUE);
                break;

        case 'l':
        case K_RARROW:
        case ' ':
                mtype = MCHAR;
                mincl = FALSE;
                n = DEFAULT1(Prenum);
                while (n--) {
                        if ( ! oneright() )
                                beep();
                }
                set_want_col = TRUE;
                break;

        case 'h':
        case K_LARROW:
        case CTRL('H'):
                mtype = MCHAR;
                mincl = FALSE;
                n = DEFAULT1(Prenum);
                while (n--) {
                        if ( ! oneleft() )
                                beep();
                }
                set_want_col = TRUE;
                break;

        case '-':
                flag = TRUE;
                /* fall through */

        case 'k':
        case K_UARROW:
        case CTRL('P'):
                mtype = MLINE;
                if ( ! oneup(DEFAULT1(Prenum)) )
                        beep();
                if (flag)
                        beginline(TRUE);
                break;

        case '+':
        case CR:
        case NL:
                flag = TRUE;
                /* fall through */

        case 'j':
        case K_DARROW:
        case CTRL('N'):
                mtype = MLINE;
                if ( ! onedown(DEFAULT1(Prenum)) )
                        beep();
                if (flag)
                        beginline(TRUE);
                break;

        /*
         * This is a strange motion command that helps make operators
         * more logical. It is actually implemented, but not documented
         * in the real 'vi'. This motion command actually refers to "the
         * current line". Commands like "dd" and "yy" are really an alternate
         * form of "d_" and "y_". It does accept a count, so "d3_" works to
         * delete 3 lines.
         */
        case '_':
        lineop:
                mtype = MLINE;
                onedown(DEFAULT1(Prenum)-1);
                break;

        case '|':
                mtype = MCHAR;
                mincl = TRUE;
                beginline(FALSE);
                if (Prenum > 0)
                        *Curschar = *coladvance(Curschar, Prenum-1);
                Curswant = Prenum - 1;
                break;

        /*
         * Word Motions
         */

        case 'B':
                type = 1;
                /* fall through */

        case 'b':
                mtype = MCHAR;
                mincl = FALSE;
                set_want_col = TRUE;
                for (n = DEFAULT1(Prenum); n > 0 ;n--) {
            LNPTR    *pos;

                        if ((pos = bck_word(Curschar, type)) == NULL) {
                                beep();
                                CLEAROP;
                                break;
                        } else
                                *Curschar = *pos;
                }
                break;

        case 'W':
                type = 1;
                /* fall through */

        case 'w':
                /*
                 * This is a little strange. To match what the real vi
                 * does, we effectively map 'cw' to 'ce', and 'cW' to 'cE'.
                 * This seems impolite at first, but it's really more
                 * what we mean when we say 'cw'.
                 */
                if (operator == CHANGE)
                        goto doecmd;

                mtype = MCHAR;
                mincl = FALSE;
                set_want_col = TRUE;
                for (n = DEFAULT1(Prenum); n > 0 ;n--) {
                        LNPTR    *pos;

                        if ((pos = fwd_word(Curschar, type)) == NULL) {
                                beep();
                                CLEAROP;
                                break;
                        } else
                                *Curschar = *pos;
                }
                break;

        case 'E':
                type = 1;
                /* fall through */

        case 'e':
        doecmd:
                mtype = MCHAR;
                mincl = TRUE;
                set_want_col = TRUE;
                for (n = DEFAULT1(Prenum); n > 0 ;n--) {
            LNPTR    *pos;

                        /*
                         * The first motion gets special treatment if we're
                         * do a 'CHANGE'.
                         */
                        if (n == DEFAULT1(Prenum))
                                pos = end_word(Curschar,type,operator==CHANGE);
                        else
                                pos = end_word(Curschar, type, FALSE);

                        if (pos == NULL) {
                                beep();
                                CLEAROP;
                                break;
                        } else
                                *Curschar = *pos;
                }
                break;

        case '$':
                mtype = MCHAR;
                mincl = TRUE;
                while ( oneright() )
                        ;
                Curswant = 999;         /* so we stay at the end */
                break;

        case '^':
                mtype = MCHAR;
                mincl = FALSE;
                beginline(TRUE);
                break;

        case '0':
                mtype = MCHAR;
                mincl = TRUE;
                beginline(FALSE);
                break;

        /*
         * Searches of various kinds
         */
        case '?':
        case '/':
                s = getcmdln(c);        /* get the search string */

                /*
                 * If they backspaced out of the search command,
                 * just bag everything.
                 */
                if (s == NULL) {
                        CLEAROP;
                        break;
                }

                mtype = MCHAR;
                mincl = FALSE;
                set_want_col = TRUE;

                /*
                 * If no string given, pass NULL to repeat the prior search.
                 * If the search fails, abort any pending operator.
                 */
                if (!dosearch(
                                (c == '/') ? FORWARD : BACKWARD,
                                (*s == NUL) ? NULL : s
                             ))
                        CLEAROP;
                break;

        case 'n':
                mtype = MCHAR;
                mincl = FALSE;
                set_want_col = TRUE;
                if (!repsearch(0))
                        CLEAROP;
                break;

        case 'N':
                mtype = MCHAR;
                mincl = FALSE;
                set_want_col = TRUE;
                if (!repsearch(1))
                        CLEAROP;
                break;

        /*
         * Character searches
         */
        case 'T':
                dir = BACKWARD;
                /* fall through */

        case 't':
                type = 1;
                goto docsearch;

        case 'F':
                dir = BACKWARD;
                /* fall through */

        case 'f':
        docsearch:
                mtype = MCHAR;
                mincl = TRUE;
                set_want_col = TRUE;
                if ((nchar = vgetc()) == ESC)   /* search char */
                        break;

                for (n = DEFAULT1(Prenum); n > 0 ;n--) {
                        if (!searchc(nchar, dir, type)) {
                                CLEAROP;
                                beep();
                        }
                }
                break;

        case ',':
                flag = 1;
                /* fall through */

        case ';':
                mtype = MCHAR;
                mincl = TRUE;
                set_want_col = TRUE;
                for (n = DEFAULT1(Prenum); n > 0 ;n--) {
                        if (!crepsearch(flag)) {
                                CLEAROP;
                                beep();
                        }
                }
                break;

        case '[':                       /* function searches */
                dir = BACKWARD;
                /* fall through */

        case ']':
                mtype = MLINE;
                set_want_col = TRUE;
                if (vgetc() != c) {
                        beep();
                        CLEAROP;
                        break;
                }

                if (!findfunc(dir)) {
                        beep();
                        CLEAROP;
                }
                break;

        case '%':
        {
                char   initc;
                LNPTR *pos;
                LNPTR  save;
                int    done = 0;

                mtype = MCHAR;
                mincl = TRUE;

                save = *Curschar;  /* save position in case we fail */
                while (!done) {
                        initc = (char)gchar(Curschar);
                        switch (initc) {
                        case '(':
                        case ')':
                        case '{':
                        case '}':
                        case '[':
                        case ']':

                                //
                                // Currently on a showmatch character.
                                //

                                done = 1;
                                break;
                        default:

                                //
                                // Didn't find anything try next character.
                                //

                                if (oneright() == FALSE) {

                                        //
                                        // no more on the line.  Restore
                                        // location and let the showmatch()
                                        // call fail and beep the user.
                                        //

                                        *Curschar = save;
                                        done = 1;
                                }
                                break;
                        }
                }

                if ((pos = showmatch()) == NULL) {
                        beep();
                        CLEAROP;
                } else {
                        setpcmark();
                        *Curschar = *pos;
                        set_want_col = TRUE;
                }
                break;
        }

        /*
         * Edits
         */
        case '.':               /* repeat last change (usually) */
                /*
                 * If a delete is in effect, we let '.' help out the same
                 * way that '_' helps for some line operations. It's like
                 * an 'l', but subtracts one from the count and is inclusive.
                 */
                if (operator == DELETE || operator == CHANGE) {
                        if (Prenum != 0) {
                                n = DEFAULT1(Prenum) - 1;
                                while (n--)
                                        if (! oneright())
                                                break;
                        }
                        mtype = MCHAR;
                        mincl = TRUE;
                } else {                        /* a normal 'redo' */
                        CLEAROP;
                        stuffin(Redobuff);
                }
                break;

        case 'u':
                CLEAROP;
                u_undo();
                break;

        case 'U':
                CLEAROP;
                u_lundo();
                break;

        case 'x':
                CLEAROP;
                if (lineempty())        /* can't do it on a blank line */
                        beep();
                if (Prenum)
                        stuffnum(Prenum);
                stuffin("d.");
                break;

        case 'X':
                CLEAROP;
                if (!oneleft())
                        beep();
                else {
                        u_saveline();
	                if (Prenum) {
	                	int i=Prenum;
		                sprintf(Redobuff, "%dX", i);
	                	while (--i)
	                		oneleft();
	                        stuffnum(Prenum);
		                stuffin("d.");
	                }
			else {
	                        strcpy(Redobuff, "X");
				delchar(TRUE);
	                        updateline();
	                }
                }
                break;

        case 'r':
                CLEAROP;
                if (lineempty()) {      /* Nothing to replace */
                        beep();
                        break;
                }
                if ((nchar = vgetc()) == ESC)
                        break;

                if ((nchar & 0x80) || nchar == CR || nchar == NL) {
                        beep();
                        break;
                }
                u_saveline();

                /* Change current character. */
                pchar(Curschar, nchar);

                /* Save stuff necessary to redo it */
                sprintf(Redobuff, "r%c", nchar);

                CHANGED;
                updateline();
                break;

        case '~':               /* swap case */
                if (!P(P_TO)) {
                        CLEAROP;
                        if (lineempty()) {
                                beep();
                                break;
                        }
                        c = gchar(Curschar);

                        if (isalpha(c)) {
                                if (islower(c))
                                        c = toupper(c);
                                else
                                        c = tolower(c);
                        }
                        u_saveline();

                        pchar(Curschar, c);     /* Change current character. */
                        oneright();

                        strcpy(Redobuff, "~");

                        CHANGED;
                        updateline();
                }
#ifdef  TILDEOP
                else {
                        if (operator == TILDE)          /* handle '~~' */
                                goto lineop;
                        if (Prenum != 0)
                                opnum = Prenum;
                        startop = *Curschar;
                        operator = TILDE;
                }
#endif

                break;

        case 'J':
                CLEAROP;

                u_save(Curschar->linep->prev, Curschar->linep->next->next);

                if (!dojoin(TRUE))
                        beep();

                strcpy(Redobuff, "J");
                updatescreen();
                break;

        /*
         * Inserts
         */
        case 'A':
                set_want_col = TRUE;
                while (oneright())
                        ;
                /* fall through */

        case 'a':
                CLEAROP;
                /* Works just like an 'i'nsert on the next character. */
                if (!lineempty())
                        inc(Curschar);
                u_saveline();
                startinsert(mkstr(c), FALSE);
                break;

        case 'I':
                beginline(TRUE);
                /* fall through */

        case 'i':
        case K_INSERT:
                CLEAROP;
                u_saveline();
                startinsert(mkstr(c), FALSE);
                break;

        case 'o':
                CLEAROP;
                u_save(Curschar->linep, Curschar->linep->next);
                opencmd(FORWARD, TRUE);
                startinsert("o", TRUE);
                break;

        case 'O':
                CLEAROP;
                u_save(Curschar->linep->prev, Curschar->linep);
                opencmd(BACKWARD, TRUE);
                startinsert("O", TRUE);
                break;

        case 'R':
                CLEAROP;
                u_saveline();
                startinsert("R", FALSE);
                break;

        /*
         * Operators
         */
        case 'd':
                if (operator == DELETE)         /* handle 'dd' */
                        goto lineop;
                if (Prenum != 0)
                        opnum = Prenum;
                startop = *Curschar;
                operator = DELETE;
                break;

        case 'c':
                if (operator == CHANGE)         /* handle 'cc' */
                        goto lineop;
                if (Prenum != 0)
                        opnum = Prenum;
                startop = *Curschar;
                operator = CHANGE;
                break;

        case 'y':
                if (operator == YANK)           /* handle 'yy' */
                        goto lineop;
                if (Prenum != 0)
                        opnum = Prenum;
                startop = *Curschar;
                operator = YANK;
                break;

        case '>':
                if (operator == RSHIFT)         /* handle >> */
                        goto lineop;
                if (Prenum != 0)
                        opnum = Prenum;
                startop = *Curschar;
                operator = RSHIFT;
                break;

        case '<':
                if (operator == LSHIFT)         /* handle << */
                        goto lineop;
                if (Prenum != 0)
                        opnum = Prenum;
                startop = *Curschar;    /* save current position */
                operator = LSHIFT;
                break;

        case '!':
                if (operator == FILTER)         /* handle '!!' */
                        goto lineop;
                if (Prenum != 0)
                        opnum = Prenum;
                startop = *Curschar;
                operator = FILTER;
                break;

        case 'p':
                doput(FORWARD);
                break;

        case 'P':
                doput(BACKWARD);
                break;

        case 'v':
                if (operator == LOWERCASE)         /* handle 'vv' */
                        goto lineop;
                if (Prenum != 0)
                        opnum = Prenum;
                startop = *Curschar;
                operator = LOWERCASE;
                break;

        case 'V':
                if (operator == UPPERCASE)         /* handle 'VV' */
                        goto lineop;
                if (Prenum != 0)
                        opnum = Prenum;
                startop = *Curschar;
                operator = UPPERCASE;
                break;

        /*
         * Abbreviations
         */
        case 'D':
                stuffin("d$");
                break;

        case 'Y':
                if (Prenum)
                        stuffnum(Prenum);
                stuffin("yy");
                break;

        case 'C':
                stuffin("c$");
                break;

        case 's':                               /* substitute characters */
                if (Prenum)
                        stuffnum(Prenum);
                stuffin("c.");
                break;

        /*
         * Marks
         */
        case 'm':
                CLEAROP;
                if (!setmark(vgetc()))
                        beep();
                break;

        case '\'':
                flag = TRUE;
                /* fall through */

        case '`':
                {
            LNPTR    mtmp, *mark = getmark(vgetc());

                        if (mark == NULL) {
                                beep();
                                CLEAROP;
                        } else {
                                mtmp = *mark;
                                setpcmark();
                                *Curschar = mtmp;
                                if (flag)
                                        beginline(TRUE);
                        }
                        mtype = flag ? MLINE : MCHAR;
                        mincl = TRUE;           /* ignored if not MCHAR */
                        set_want_col = TRUE;
                }
                break;

        default:
                CLEAROP;
                beep();
                break;
        }

        /*
         * If an operation is pending, handle it...
         */
        if (finish_op) {                /* we just finished an operator */
                if (operator == NOP)    /* ... but it was cancelled */
                        return;

                switch (operator) {

                case LSHIFT:
                case RSHIFT:
                        doshift(operator, c, nchar, Prenum);
                        break;

                case DELETE:
                        dodelete(c, nchar, Prenum);
                        break;

                case YANK:
                        (void) doyank();        /* no redo on yank... */
                        break;

                case CHANGE:
                        dochange(c, nchar, Prenum);
                        break;

                case FILTER:
                        dofilter(c, nchar, Prenum);
                        break;

#ifdef  TILDEOP
                case TILDE:
                        dotilde(c, nchar, Prenum);
                        break;
#endif

                case LOWERCASE:
                case UPPERCASE:
                        docasechange((char)c,
                                     (char)nchar,
                                     Prenum,
                                     operator == UPPERCASE);
                        break;

                default:
                        beep();
                }
                operator = NOP;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vi\param.h ===
/* $Header: /nw/tony/src/stevie/src/RCS/param.h,v 1.8 89/08/02 10:59:35 tony Exp $
 *
 * Settable parameters
 */

struct  param {
        char    *fullname;      /* full parameter name */
        char    *shortname;     /* permissible abbreviation */
        int     value;          /* parameter value */
        int     flags;
};

extern  struct  param   params[];

/*
 * Flags
 */
#define P_BOOL          0x01    /* the parameter is boolean */
#define P_NUM           0x02    /* the parameter is numeric */
#define P_CHANGED       0x04    /* the parameter has been changed */

/*
 * The following are the indices in the params array for each parameter
 */

/*
 * Numeric parameters
 */
#define P_TS            0       /* tab size */
#define P_SS            1       /* scroll size */
#define P_RP            2       /* report */
#define P_LI            3       /* lines */

/*
 * Boolean parameters
 */
#define P_VB            4       /* visual bell */
#define P_SM            5       /* showmatch */
#define P_WS            6       /* wrap scan */
#define P_EB            7       /* error bells */
#define P_MO            8       /* show mode */
#define P_BK            9       /* make backups when writing out files */
#define P_CR            10      /* use cr-lf to terminate lines on writes */
#define P_LS            11      /* show tabs and newlines graphically */
#define P_IC            12      /* ignore case in searches */
#define P_AI            13      /* auto-indent */
#define P_NU            14      /* number lines on the screen */
#define P_ML            15      /* enables mode-lines processing */
#define P_TO            16      /* if true, tilde is an operator */
#define P_TE            17      /* ignored; here for compatibility */
#define P_CS            18      /* Cursor size */
#define P_HS            19      /* Highlight search result */
#define P_CO            20      /* Number of columns */
#define P_HT            21      /* hard tabs flag */
#define P_SW            22      /* shift width for << and >> */

/*
 * Macro to get the value of a parameter
 */
#define P(n)    (params[n].value)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vi\ops.h ===
/* $Header: /nw/tony/src/stevie/src/RCS/ops.h,v 1.2 89/07/19 08:08:21 tony Exp $
 *
 * Macros and declarations for the operator code in ops.c
 */

/*
 * Operators
 */
#define	NOP	0		/* no pending operation */
#define DELETE    1
#define YANK      2
#define CHANGE    3
#define LSHIFT    4
#define RSHIFT    5
#define FILTER    6
#define TILDE     7
#define LOWERCASE 8
#define UPPERCASE 9

extern	int	operator;		/* current pending operator */

/*
 * When a cursor motion command is made, it is marked as being a character
 * or line oriented motion. Then, if an operator is in effect, the operation
 * becomes character or line oriented accordingly.
 *
 * Character motions are marked as being inclusive or not. Most char.
 * motions are inclusive, but some (e.g. 'w') are not.
 */

/*
 * Cursor motion types
 */
#define	MBAD	(-1)		/* 'bad' motion type marks unusable yank buf */
#define	MCHAR	0
#define	MLINE	1

extern	int	mtype;			/* type of the current cursor motion */
extern	bool_t	mincl;			/* true if char motion is inclusive */

extern  LNPTR    startop;        /* cursor pos. at start of operator */

/*
 * Functions defined in ops.c
 */
void    doshift(), dodelete(), doput(), dochange(), dofilter();
void    docasechange(char,char,int,bool_t);
#ifdef	TILDEOP
void	dotilde();
#endif
bool_t	dojoin(), doyank();
void	startinsert();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vi\misccmds.c ===
/* $Header: /nw/tony/src/stevie/src/RCS/misccmds.c,v 1.14 89/08/06 09:50:17 tony Exp $
 *
 * Various routines to perform specific editing operations or return
 * useful information about the file.
 */

#include "stevie.h"
#include <io.h>
#include <errno.h>

static  void    openfwd(), openbwd();

extern  bool_t  did_ai;

/*
 * opencmd
 *
 * Add a blank line above or below the current line.
 */

void
opencmd(dir, can_ai)
int     dir;
int     can_ai;                 /* if true, consider auto-indent */
{
        if (dir == FORWARD)
                openfwd(can_ai);
        else
                openbwd(can_ai);
}

static void
openfwd(can_ai)
int     can_ai;
{
        register LINE   *l;
        LNPTR    *next;
        register char   *s;     /* string to be moved to new line, if any */
        int     newindex = 0;   /* index of the cursor on the new line */

        /*
         * If we're in insert mode, we need to move the remainder of the
         * current line onto the new line. Otherwise the new line is left
         * blank.
         */
        if (State == INSERT || State == REPLACE)
                s = &Curschar->linep->s[Curschar->index];
        else
                s = "";

        if ((next = nextline(Curschar)) == NULL)        /* open on last line */
                next = Fileend;

        /*
         * By asking for as much space as the prior line had we make sure
         * that we'll have enough space for any auto-indenting.
         */
        if ((l = newline(strlen(Curschar->linep->s) + SLOP)) == NULL)
                return;

        if (*s != NUL)
                strcpy(l->s, s);                /* copy string to new line */

        else if (can_ai && P(P_AI) && !anyinput()) {
                char    *p;

                /*
                 * Copy prior line, and truncate after white space
                 */
                strcpy(l->s, Curschar->linep->s);

                for (p = l->s; *p == ' ' || *p == TAB ;p++)
                        ;
                *p = NUL;
                newindex = (int)(p - l->s);

                /*
                 * If we just did an auto-indent, then we didn't type
                 * anything on the prior line, and it should be truncated.
                 */
                if (did_ai)
                        Curschar->linep->s[0] = NUL;

                did_ai = TRUE;
        }

        /* truncate current line at cursor */
        if (State == INSERT || State == REPLACE)
                *s = NUL;


        Curschar->linep->next = l;      /* link neighbors to new line */
        next->linep->prev = l;

        l->prev = Curschar->linep;      /* link new line to neighbors */
        l->next = next->linep;

        if (next == Fileend)                    /* new line at end */
                l->num = Curschar->linep->num + LINEINC;

        else if ((l->prev->num) + 1 == l->next->num)    /* no gap, renumber */
                renum();

        else {                                  /* stick it in the middle */
                unsigned long   lnum;
                lnum = ((long)l->prev->num + (long)l->next->num) / 2;
                l->num = lnum;
        }

        /*
         * Get the cursor to the start of the line, so that 'Cursrow'
         * gets set to the right physical line number for the stuff
         * that follows...
         */
        Curschar->index = 0;
        cursupdate();

        /*
         * If we're doing an open on the last logical line, then
         * go ahead and scroll the screen up. Otherwise, just insert
         * a blank line at the right place. We use calls to plines()
         * in case the cursor is resting on a long line.
         */
        if (Cursrow + plines(Curschar) == (Rows - 1))
                scrollup(1);
        else
                s_ins(Cursrow+plines(Curschar), 1);

        *Curschar = *nextline(Curschar);        /* cursor moves down */
        Curschar->index = newindex;

        updatescreen();         /* because Botchar is now invalid... */

        cursupdate();           /* update Cursrow before insert */
}

static void
openbwd(can_ai)
int     can_ai;
{
        register LINE   *l;
        LINE    *prev;
        int     newindex = 0;

        prev = Curschar->linep->prev;

        if ((l = newline(strlen(Curschar->linep->s) + SLOP)) == NULL)
                return;

        Curschar->linep->prev = l;      /* link neighbors to new line */
        prev->next = l;

        l->next = Curschar->linep;      /* link new line to neighbors */
        l->prev = prev;

        if (can_ai && P(P_AI) && !anyinput()) {
                char    *p;

                /*
                 * Copy current line, and truncate after white space
                 */
                strcpy(l->s, Curschar->linep->s);

                for (p = l->s; *p == ' ' || *p == TAB ;p++)
                        ;
                *p = NUL;
                newindex = (int)(p - l->s);

                did_ai = TRUE;
        }

        Curschar->linep = Curschar->linep->prev;
        Curschar->index = newindex;

        if (prev == Filetop->linep)             /* new start of file */
                Filemem->linep = l;

        renum();        /* keep it simple - we don't do this often */

        cursupdate();                   /* update Cursrow before insert */
        if (Cursrow != 0)
                s_ins(Cursrow, 1);              /* insert a physical line */

        updatescreen();
}

int
cntllines(pbegin,pend)
register LNPTR   *pbegin, *pend;
{
        register LINE   *lp;
        int     lnum = 1;

        if (pbegin->linep && pend->linep)
	        for (lp = pbegin->linep; lp != pend->linep ;lp = lp->next)
	                lnum++;

        return(lnum);
}

/*
 * plines(p) - return the number of physical screen lines taken by line 'p'
 */
int
plines(p)
LNPTR    *p;
{
        register int    col = 0;
        register char   *s;

        s = p->linep->s;

        if (*s == NUL)          /* empty line */
                return 1;

        for (; *s != NUL ;s++) {
                if ( *s == TAB && !P(P_LS))
                        col += P(P_TS) - (col % P(P_TS));
                else
                        col += chars[(unsigned)(*s & 0xff)].ch_size;
        }

        /*
         * If list mode is on, then the '$' at the end of
         * the line takes up one extra column.
         */
        if (P(P_LS))
                col += 1;
        /*
         * If 'number' mode is on, add another 8.
         */
        if (P(P_NU))
                col += 8;

        return ((col + (Columns-1)) / Columns);
}

void
fileinfo()
{
        extern  int     numfiles, curfile;
        register long   l1, l2;
        bool_t readonly = FALSE;

        if (Filename != NULL) {
            if((_access(Filename,2) == -1) && (errno == EACCES)) {
                readonly = TRUE;
            }
        }

        if (bufempty()) {
                l1 = 0;
                l2 = 1;                 /* don't div by zero */
        } else {
                l1 = cntllines(Filemem, Curschar);
                l2 = cntllines(Filemem, Fileend) - 1;
        }

        if (numfiles > 1)
                smsg("\"%s\"%s%s line %ld of %ld -- %ld %% -- (file %d of %d)",
                        (Filename != NULL) ? Filename : "No File",
                        Changed ? " [Modified]" : "",
                        readonly == TRUE ? " [Read only]" : "",
                        l1, l2, (l1 * 100)/l2,
                        curfile+1, numfiles);
        else
                smsg("\"%s\"%s%s line %ld of %ld -- %ld %% --",
                        (Filename != NULL) ? Filename : "No File",
                        Changed ? " [Modified]" : "",
                        readonly == TRUE ? " [Read only]" : "",
                        l1, l2, (l1 * 100)/l2);
}

/*
 * gotoline(n) - return a pointer to line 'n'
 *
 * Returns a pointer to the last line of the file if n is zero, or
 * beyond the end of the file.
 */
LNPTR *
gotoline(n)
register int    n;
{
    static  LNPTR    l;

        l.index = 0;

        if ( n == 0 )
                l = *prevline(Fileend);
        else {
        LNPTR    *p;

                for (l = *Filemem; --n > 0 ;l = *p)
                        if ((p = nextline(&l)) == NULL)
                                break;
        }
        return &l;
}

void
inschar(c)
int     c;
{
        register char   *p, *pend;

        /* make room for the new char. */
        if ( ! canincrease(1) )
                return;

        if (State != REPLACE) {
                p = &Curschar->linep->s[strlen(Curschar->linep->s) + 1];
                pend = &Curschar->linep->s[Curschar->index];

                for (; p > pend ;p--)
                        *p = *(p-1);

                *p = (char)c;

        } else {        /* replace mode */
                /*
                 * Once we reach the end of the line, we are effectively
                 * inserting new text, so make sure the string terminator
                 * stays out there.
                 */
                if (gchar(Curschar) == NUL)
                        Curschar->linep->s[Curschar->index+1] = NUL;
                pchar(Curschar, c);
        }

        /*
         * If we're in insert mode and showmatch mode is set, then
         * check for right parens and braces. If there isn't a match,
         * then beep. If there is a match AND it's on the screen, then
         * flash to it briefly. If it isn't on the screen, don't do anything.
         */
        if (P(P_SM) && State == INSERT && (c == ')' || c == '}' || c == ']')) {
        LNPTR    *lpos, csave;

                if ((lpos = showmatch()) == NULL)       /* no match, so beep */
                        beep();
                else if (LINEOF(lpos) >= LINEOF(Topchar)) {
                        updatescreen();         /* show the new char first */
                        csave = *Curschar;
                        *Curschar = *lpos;      /* move to matching char */
                        cursupdate();
                        windgoto(Cursrow, Curscol);
                        delay();                /* brief pause */
                        *Curschar = csave;      /* restore cursor position */
                        cursupdate();
                }
        }

        inc(Curschar);
        CHANGED;
}

bool_t
delchar(fixpos)
bool_t  fixpos;         /* if TRUE, fix the cursor position when done */
{
        register int    i;

        /* Check for degenerate case; there's nothing in the file. */
        if (bufempty())
                return FALSE;

        if (lineempty())        /* can't do anything */
                return FALSE;

        /* Delete the char. at Curschar by shifting everything */
        /* in the line down. */
        for ( i=Curschar->index+1; i < Curschar->linep->size ;i++)
                Curschar->linep->s[i-1] = Curschar->linep->s[i];

        /* If we just took off the last character of a non-blank line, */
        /* we don't want to end up positioned at the newline. */
        if (fixpos) {
                if (gchar(Curschar)==NUL && Curschar->index>0 && State!=INSERT)
                        Curschar->index--;
        }
        CHANGED;

        return TRUE;
}


void
delline(nlines, can_update)
int     nlines;
bool_t  can_update;
{
        register LINE   *p, *q;
        int      dlines = 0;
        bool_t   do_update = FALSE;

        while ( nlines-- > 0 ) {

                if (bufempty())                 /* nothing to delete */
                        break;

                if (buf1line()) {               /* just clear the line */
                        Curschar->linep->s[0] = NUL;
                        Curschar->index = 0;
                        break;
                }

                p = Curschar->linep->prev;
                q = Curschar->linep->next;

                if (p == Filetop->linep) {      /* first line of file so... */
                        Filemem->linep = q;     /* adjust start of file */
                        Topchar->linep = q;     /* and screen */
                }
                p->next = q;
                if (q)
		    q->prev = p;

                clrmark(Curschar->linep);       /* clear marks for the line */

                /*
                 * Delete the correct number of physical lines on the screen
                 */
                if (can_update) {
                        do_update = TRUE;
                        dlines += plines(Curschar);
                }

                /*
                 * If deleting the top line on the screen, adjust Topchar
                 */
                if (Topchar->linep == Curschar->linep)
                        Topchar->linep = q;

                free(Curschar->linep->s);
                free((char *) Curschar->linep);

                Curschar->linep = q;
                Curschar->index = 0;            /* is this right? */
                CHANGED;

                /* If we delete the last line in the file, back up */
                if ( Curschar->linep == Fileend->linep) {
                        Curschar->linep = Curschar->linep->prev;
                        /* and don't try to delete any more lines */
                        break;
                }
        }
        if(do_update) {
                s_del(Cursrow, dlines);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vi\ptrfunc.c ===
/* $Header: /nw/tony/src/stevie/src/RCS/ptrfunc.c,v 1.5 89/03/11 22:43:12 tony Exp $
 *
 * The routines in this file attempt to imitate many of the operations
 * that used to be performed on simple character pointers and are now
 * performed on LNPTR's. This makes it easier to modify other sections
 * of the code. Think of an LNPTR as representing a position in the file.
 * Positions can be incremented, decremented, compared, etc. through
 * the functions implemented here.
 */

#include "stevie.h"

/*
 * inc(p)
 *
 * Increment the line pointer 'p' crossing line boundaries as necessary.
 * Return 1 when crossing a line, -1 when at end of file, 0 otherwise.
 */
int
inc(lp)
register LNPTR   *lp;
{
	register char	*p;

	if (lp && lp->linep)
		p = &(lp->linep->s[lp->index]);
	else
		return -1;

	if (*p != NUL) {			/* still within line */
		lp->index++;
		return ((p[1] != NUL) ? 0 : 1);
	}

	if (lp->linep->next != Fileend->linep) {  /* there is a next line */
		lp->index = 0;
		lp->linep = lp->linep->next;
		return 1;
	}

	return -1;
}

/*
 * dec(p)
 *
 * Decrement the line pointer 'p' crossing line boundaries as necessary.
 * Return 1 when crossing a line, -1 when at start of file, 0 otherwise.
 */
int
dec(lp)
register LNPTR   *lp;
{
	if (lp->index > 0) {			/* still within line */
		lp->index--;
		return 0;
	}

	if (lp->linep &&
	    lp->linep->prev != Filetop->linep) { /* there is a prior line */
		lp->linep = lp->linep->prev;
		lp->index = strlen(lp->linep->s);
		return 1;
	}

	lp->index = 0;				/* stick at first char */
	return -1;				/* at start of file */
}

/*
 * gchar(lp) - get the character at position "lp"
 */
int
gchar(lp)
register LNPTR   *lp;
{
	if (lp && lp->linep)
		return (lp->linep->s[lp->index]);
	else
		return 0;
}

/*
 * pchar(lp, c) - put character 'c' at position 'lp'
 */
void
pchar(lp, c)
register LNPTR   *lp;
char	c;
{
	lp->linep->s[lp->index] = c;
}

/*
 * pswap(a, b) - swap two position pointers
 */
void
pswap(a, b)
register LNPTR   *a, *b;
{
    LNPTR    tmp;

	tmp = *a;
	*a  = *b;
	*b  = tmp;
}

/*
 * Position comparisons
 */

bool_t
lt(a, b)
register LNPTR   *a, *b;
{
	register int	an, bn;

	an = LINEOF(a);
	bn = LINEOF(b);

	if (an != bn)
		return (an < bn);
	else
		return (a->index < b->index);
}

#if 0
bool_t
gt(a, b)
LNPTR    *a, *b;
{
	register int an, bn;

	an = LINEOF(a);
	bn = LINEOF(b);

	if (an != bn)
		return (an > bn);
	else
		return (a->index > b->index);
}
#endif

bool_t
equal(a, b)
register LNPTR   *a, *b;
{
	return (a->linep == b->linep && a->index == b->index);
}

bool_t
ltoreq(a, b)
register LNPTR   *a, *b;
{
	return (lt(a, b) || equal(a, b));
}

#if 0
bool_t
gtoreq(a, b)
LNPTR    *a, *b;
{
	return (gt(a, b) || equal(a, b));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vi\regexp.h ===
/*
 * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
 *
 * This is NOT the original regular expression code as written by
 * Henry Spencer. This code has been modified specifically for use
 * with the STEVIE editor, and should not be used apart from compiling
 * STEVIE. If you want a good regular expression library, get the
 * original code. The copyright notice that follows is from the
 * original.
 *
 * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
 *
 * Definitions etc. for regexp(3) routines.
 *
 * Caveat:  this is V8 regexp(3) [actually, a reimplementation thereof],
 * not the System V one.
 */
#define NSUBEXP  10
typedef struct regexp {
        char *startp[NSUBEXP];
        char *endp[NSUBEXP];
        char regstart;          /* Internal use only. */
        char reganch;           /* Internal use only. */
        char *regmust;          /* Internal use only. */
        int regmlen;            /* Internal use only. */
        char program[1];        /* Unwarranted chumminess with compiler. */
} regexp;

extern regexp *regcomp();
extern int regexec();
extern void regsub();
extern void regerror();

#ifndef ORIGINAL
extern int reg_ic;              /* set non-zero to ignore case in searches */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vi\regexp.c ===
/* $Header: /nw/tony/src/stevie/src/RCS/regexp.c,v 1.5 89/07/07 16:27:11 tony Exp $
 *
 * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
 *
 * This is NOT the original regular expression code as written by
 * Henry Spencer. This code has been modified specifically for use
 * with the STEVIE editor, and should not be used apart from compiling
 * STEVIE. If you want a good regular expression library, get the
 * original code. The copyright notice that follows is from the
 * original.
 *
 * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
 *
 *
 * regcomp and regexec -- regsub and regerror are elsewhere
 *
 *      Copyright (c) 1986 by University of Toronto.
 *      Written by Henry Spencer.  Not derived from licensed software.
 *
 *      Permission is granted to anyone to use this software for any
 *      purpose on any computer system, and to redistribute it freely,
 *      subject to the following restrictions:
 *
 *      1. The author is not responsible for the consequences of use of
 *              this software, no matter how awful, even if they arise
 *              from defects in it.
 *
 *      2. The origin of this software must not be misrepresented, either
 *              by explicit claim or by omission.
 *
 *      3. Altered versions must be plainly marked as such, and must not
 *              be misrepresented as being the original software.
 *
 * Beware that some of this code is subtly aware of the way operator
 * precedence is structured in regular expressions.  Serious changes in
 * regular-expression syntax might require a total rethink.
 *
 */

#include "env.h"

#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include "regexp.h"
#include "regmagic.h"

int cstrncmp(char *,char *,int);
char *cstrchr(char *,char);
/*
 * The "internal use only" fields in regexp.h are present to pass info from
 * compile to execute that permits the execute phase to run lots faster on
 * simple cases.  They are:
 *
 * regstart     char that must begin a match; '\0' if none obvious
 * reganch      is the match anchored (at beginning-of-line only)?
 * regmust      string (pointer into program) that match must include, or NULL
 * regmlen      length of regmust string
 *
 * Regstart and reganch permit very fast decisions on suitable starting points
 * for a match, cutting down the work a lot.  Regmust permits fast rejection
 * of lines that cannot possibly match.  The regmust tests are costly enough
 * that regcomp() supplies a regmust only if the r.e. contains something
 * potentially expensive (at present, the only such thing detected is * or +
 * at the start of the r.e., which can involve a lot of backup).  Regmlen is
 * supplied because the test in regexec() needs it and regcomp() is computing
 * it anyway.
 */

/*
 * Structure for regexp "program".  This is essentially a linear encoding
 * of a nondeterministic finite-state machine (aka syntax charts or
 * "railroad normal form" in parsing technology).  Each node is an opcode
 * plus a "next" pointer, possibly plus an operand.  "Next" pointers of
 * all nodes except BRANCH implement concatenation; a "next" pointer with
 * a BRANCH on both ends of it is connecting two alternatives.  (Here we
 * have one of the subtle syntax dependencies:  an individual BRANCH (as
 * opposed to a collection of them) is never concatenated with anything
 * because of operator precedence.)  The operand of some types of node is
 * a literal string; for others, it is a node leading into a sub-FSM.  In
 * particular, the operand of a BRANCH node is the first node of the branch.
 * (NB this is *not* a tree structure:  the tail of the branch connects
 * to the thing following the set of BRANCHes.)  The opcodes are:
 */

/* definition   number  opnd?   meaning */
#define END     0       /* no   End of program. */
#define BOL     1       /* no   Match "" at beginning of line. */
#define EOL     2       /* no   Match "" at end of line. */
#define ANY     3       /* no   Match any one character. */
#define ANYOF   4       /* str  Match any character in this string. */
#define ANYBUT  5       /* str  Match any character not in this string. */
#define BRANCH  6       /* node Match this alternative, or the next... */
#define BACK    7       /* no   Match "", "next" ptr points backward. */
#define EXACTLY 8       /* str  Match this string. */
#define NOTHING 9       /* no   Match empty string. */
#define STAR    10      /* node Match this (simple) thing 0 or more times. */
#define PLUS    11      /* node Match this (simple) thing 1 or more times. */
#define OPEN    20      /* no   Mark this point in input as start of #n. */
                        /*      OPEN+1 is number 1, etc. */
#define CLOSE   30      /* no   Analogous to OPEN. */

/*
 * Opcode notes:
 *
 * BRANCH       The set of branches constituting a single choice are hooked
 *              together with their "next" pointers, since precedence prevents
 *              anything being concatenated to any individual branch.  The
 *              "next" pointer of the last BRANCH in a choice points to the
 *              thing following the whole choice.  This is also where the
 *              final "next" pointer of each individual branch points; each
 *              branch starts with the operand node of a BRANCH node.
 *
 * BACK         Normal "next" pointers all implicitly point forward; BACK
 *              exists to make loop structures possible.
 *
 * STAR,PLUS    '?', and complex '*' and '+', are implemented as circular
 *              BRANCH structures using BACK.  Simple cases (one character
 *              per match) are implemented with STAR and PLUS for speed
 *              and to minimize recursive plunges.
 *
 * OPEN,CLOSE   ...are numbered at compile time.
 */

/*
 * A node is one char of opcode followed by two chars of "next" pointer.
 * "Next" pointers are stored as two 8-bit pieces, high order first.  The
 * value is a positive offset from the opcode of the node containing it.
 * An operand, if any, simply follows the node.  (Note that much of the
 * code generation knows about this implicit relationship.)
 *
 * Using two bytes for the "next" pointer is vast overkill for most things,
 * but allows patterns to get big without disasters.
 */
#define OP(p)   (*(p))
#define NEXT(p) (((*((p)+1)&0377)<<8) + (*((p)+2)&0377))
#define OPERAND(p)      ((p) + 3)

/*
 * See regmagic.h for one further detail of program structure.
 */


/*
 * Utility definitions.
 */
#ifndef CHARBITS
#define UCHARAT(p)      ((int)*(unsigned char *)(p))
#else
#define UCHARAT(p)      ((int)*(p)&CHARBITS)
#endif

#define FAIL(m) { regerror(m); return(NULL); }
#define ISMULT(c)       ((c) == '*' || (c) == '+' || (c) == '?')
#define META    "^$.[()|?+*\\"

/*
 * Flags to be passed up and down.
 */
#define HASWIDTH        01      /* Known never to match null string. */
#define SIMPLE          02      /* Simple enough to be STAR/PLUS operand. */
#define SPSTART         04      /* Starts with * or +. */
#define WORST           0       /* Worst case. */

#ifndef ORIGINAL
/*
 * The following supports the ability to ignore case in searches.
 */

#include <ctype.h>

int reg_ic = 0;                 /* set by callers to ignore case */

/*
 * mkup - convert to upper case IF we're doing caseless compares
 */
#define mkup(c)         ((reg_ic && islower(c)) ? toupper(c) : (c))

#endif

/*
 * Global work variables for regcomp().
 */
static char *regparse;          /* Input-scan pointer. */
static int regnpar;             /* () count. */
static char regdummy;
static char *regcode;           /* Code-emit pointer; &regdummy = don't. */
static long regsize;            /* Code size. */

/*
 * Forward declarations for regcomp()'s friends.
 */
#ifndef STATIC
#define STATIC  static
#endif
STATIC char *reg();
STATIC char *regbranch();
STATIC char *regpiece();
STATIC char *regatom();
STATIC char *regnode();
STATIC char *regnext();
STATIC void regc();
STATIC void reginsert();
STATIC void regtail();
STATIC void regoptail();
#ifdef STRCSPN
STATIC int strcspn();
#endif

/*
 - regcomp - compile a regular expression into internal code
 *
 * We can't allocate space until we know how big the compiled form will be,
 * but we can't compile it (and thus know how big it is) until we've got a
 * place to put the code.  So we cheat:  we compile it twice, once with code
 * generation turned off and size counting turned on, and once "for real".
 * This also means that we don't allocate space until we are sure that the
 * thing really will compile successfully, and we never have to move the
 * code and thus invalidate pointers into it.  (Note that it has to be in
 * one piece because free() must be able to free it all.)
 *
 * Beware that the optimization-preparation code in here knows about some
 * of the structure of the compiled regexp.
 */
regexp *
regcomp(exp)
char *exp;
{
        register regexp *r;
        register char *scan;
        register char *longest;
        register int len;
        int flags;

        if (exp == NULL)
                FAIL("NULL argument");

        /* First pass: determine size, legality. */
        regparse = exp;
        regnpar = 1;
        regsize = 0L;
        regcode = &regdummy;
        regc(MAGIC);
        if (reg(0, &flags) == NULL)
                return(NULL);

        /* Small enough for pointer-storage convention? */
        if (regsize >= 32767L)          /* Probably could be 65535L. */
                FAIL("regexp too big");

        /* Allocate space. */
        r = (regexp *)malloc(sizeof(regexp) + (unsigned)regsize);
        if (r == NULL)
                FAIL("out of space");

        /* Second pass: emit code. */
        regparse = exp;
        regnpar = 1;
        regcode = r->program;
        regc(MAGIC);
        if (reg(0, &flags) == NULL)
                return(NULL);

        /* Dig out information for optimizations. */
        r->regstart = '\0';     /* Worst-case defaults. */
        r->reganch = 0;
        r->regmust = NULL;
        r->regmlen = 0;
        scan = r->program+1;                    /* First BRANCH. */
        if (OP(regnext(scan)) == END) {         /* Only one top-level choice. */
                scan = OPERAND(scan);

                /* Starting-point info. */
                if (OP(scan) == EXACTLY)
                        r->regstart = *OPERAND(scan);
                else if (OP(scan) == BOL)
                        r->reganch++;

                /*
                 * If there's something expensive in the r.e., find the
                 * longest literal string that must appear and make it the
                 * regmust.  Resolve ties in favor of later strings, since
                 * the regstart check works with the beginning of the r.e.
                 * and avoiding duplication strengthens checking.  Not a
                 * strong reason, but sufficient in the absence of others.
                 */
                if (flags&SPSTART) {
                        longest = NULL;
                        len = 0;
                        for (; scan != NULL; scan = regnext(scan))
                                if (OP(scan) == EXACTLY && strlen(OPERAND(scan)) >= (size_t)len) {
                                        longest = OPERAND(scan);
                                        len = strlen(OPERAND(scan));
                                }
                        r->regmust = longest;
                        r->regmlen = len;
                }
        }

        return(r);
}

/*
 - reg - regular expression, i.e. main body or parenthesized thing
 *
 * Caller must absorb opening parenthesis.
 *
 * Combining parenthesis handling with the base level of regular expression
 * is a trifle forced, but the need to tie the tails of the branches to what
 * follows makes it hard to avoid.
 */
static char *
reg(paren, flagp)
int paren;                      /* Parenthesized? */
int *flagp;
{
        register char *ret;
        register char *br;
        register char *ender;
        register int parno;
        int flags;

        *flagp = HASWIDTH;      /* Tentatively. */

        /* Make an OPEN node, if parenthesized. */
        if (paren) {
                if (regnpar >= NSUBEXP)
                        FAIL("too many ()");
                parno = regnpar;
                regnpar++;
                ret = regnode(OPEN+parno);
        } else
                ret = NULL;

        /* Pick up the branches, linking them together. */
        br = regbranch(&flags);
        if (br == NULL)
                return(NULL);
        if (ret != NULL)
                regtail(ret, br);       /* OPEN -> first. */
        else
                ret = br;
        if (!(flags&HASWIDTH))
                *flagp &= ~HASWIDTH;
        *flagp |= flags&SPSTART;
        while (*regparse == '|') {
                regparse++;
                br = regbranch(&flags);
                if (br == NULL)
                        return(NULL);
                regtail(ret, br);       /* BRANCH -> BRANCH. */
                if (!(flags&HASWIDTH))
                        *flagp &= ~HASWIDTH;
                *flagp |= flags&SPSTART;
        }

        /* Make a closing node, and hook it on the end. */
        ender = regnode((paren) ? CLOSE+parno : END);
        regtail(ret, ender);

        /* Hook the tails of the branches to the closing node. */
        for (br = ret; br != NULL; br = regnext(br))
                regoptail(br, ender);

        /* Check for proper termination. */
        if (paren && *regparse++ != ')') {
                FAIL("unmatched ()");
        } else if (!paren && *regparse != '\0') {
                if (*regparse == ')') {
                        FAIL("unmatched ()");
                } else
                        FAIL("junk on end");    /* "Can't happen". */
                /* NOTREACHED */
        }

        return(ret);
}

/*
 - regbranch - one alternative of an | operator
 *
 * Implements the concatenation operator.
 */
static char *
regbranch(flagp)
int *flagp;
{
        register char *ret;
        register char *chain;
        register char *latest;
        int flags;

        *flagp = WORST;         /* Tentatively. */

        ret = regnode(BRANCH);
        chain = NULL;
        while (*regparse != '\0' && *regparse != '|' && *regparse != ')') {
                latest = regpiece(&flags);
                if (latest == NULL)
                        return(NULL);
                *flagp |= flags&HASWIDTH;
                if (chain == NULL)      /* First piece. */
                        *flagp |= flags&SPSTART;
                else
                        regtail(chain, latest);
                chain = latest;
        }
        if (chain == NULL)      /* Loop ran zero times. */
                (void) regnode(NOTHING);

        return(ret);
}

/*
 - regpiece - something followed by possible [*+?]
 *
 * Note that the branching code sequences used for ? and the general cases
 * of * and + are somewhat optimized:  they use the same NOTHING node as
 * both the endmarker for their branch list and the body of the last branch.
 * It might seem that this node could be dispensed with entirely, but the
 * endmarker role is not redundant.
 */
static char *
regpiece(flagp)
int *flagp;
{
        register char *ret;
        register char op;
        register char *next;
        int flags;

        ret = regatom(&flags);
        if (ret == NULL)
                return(NULL);

        op = *regparse;
        if (!ISMULT(op)) {
                *flagp = flags;
                return(ret);
        }

        if (!(flags&HASWIDTH) && op != '?')
                FAIL("*+ operand could be empty");
        *flagp = (op != '+') ? (WORST|SPSTART) : (WORST|HASWIDTH);

        if (op == '*' && (flags&SIMPLE))
                reginsert(STAR, ret);
        else if (op == '*') {
                /* Emit x* as (x&|), where & means "self". */
                reginsert(BRANCH, ret);                 /* Either x */
                regoptail(ret, regnode(BACK));          /* and loop */
                regoptail(ret, ret);                    /* back */
                regtail(ret, regnode(BRANCH));          /* or */
                regtail(ret, regnode(NOTHING));         /* null. */
        } else if (op == '+' && (flags&SIMPLE))
                reginsert(PLUS, ret);
        else if (op == '+') {
                /* Emit x+ as x(&|), where & means "self". */
                next = regnode(BRANCH);                 /* Either */
                regtail(ret, next);
                regtail(regnode(BACK), ret);            /* loop back */
                regtail(next, regnode(BRANCH));         /* or */
                regtail(ret, regnode(NOTHING));         /* null. */
        } else if (op == '?') {
                /* Emit x? as (x|) */
                reginsert(BRANCH, ret);                 /* Either x */
                regtail(ret, regnode(BRANCH));          /* or */
                next = regnode(NOTHING);                /* null. */
                regtail(ret, next);
                regoptail(ret, next);
        }
        regparse++;
        if (ISMULT(*regparse))
                FAIL("nested *?+");

        return(ret);
}

/*
 - regatom - the lowest level
 *
 * Optimization:  gobbles an entire sequence of ordinary characters so that
 * it can turn them into a single node, which is smaller to store and
 * faster to run.  Backslashed characters are exceptions, each becoming a
 * separate node; the code is simpler that way and it's not worth fixing.
 */
static char *
regatom(flagp)
int *flagp;
{
        register char *ret;
        int flags;

        *flagp = WORST;         /* Tentatively. */

        switch (*regparse++) {
        case '^':
                ret = regnode(BOL);
                break;
        case '$':
                ret = regnode(EOL);
                break;
        case '.':
                ret = regnode(ANY);
                *flagp |= HASWIDTH|SIMPLE;
                break;
        case '[': {
                        register int class;
                        register int classend;

                        if (*regparse == '^') { /* Complement of range. */
                                ret = regnode(ANYBUT);
                                regparse++;
                        } else
                                ret = regnode(ANYOF);
                        if (*regparse == ']' || *regparse == '-')
                                regc(*regparse++);
                        while (*regparse != '\0' && *regparse != ']') {
                                if (*regparse == '-') {
                                        regparse++;
                                        if (*regparse == ']' || *regparse == '\0')
                                                regc('-');
                                        else {
                                                class = UCHARAT(regparse-2)+1;
                                                classend = UCHARAT(regparse);
                                                if (class > classend+1)
                                                        FAIL("invalid [] range");
                                                for (; class <= classend; class++)
                                                        regc(class);
                                                regparse++;
                                        }
                                } else
                                        regc(*regparse++);
                        }
                        regc('\0');
                        if (*regparse != ']')
                                FAIL("unmatched []");
                        regparse++;
                        *flagp |= HASWIDTH|SIMPLE;
                }
                break;
        case '(':
                ret = reg(1, &flags);
                if (ret == NULL)
                        return(NULL);
                *flagp |= flags&(HASWIDTH|SPSTART);
                break;
        case '\0':
        case '|':
        case ')':
                FAIL("internal urp");   /* Supposed to be caught earlier. */
                break;
        case '?':
        case '+':
        case '*':
                FAIL("?+* follows nothing");
                break;
        case '\\':
                if (*regparse == '\0')
                        FAIL("trailing \\");
                ret = regnode(EXACTLY);
                regc(*regparse++);
                regc('\0');
                *flagp |= HASWIDTH|SIMPLE;
                break;
        default: {
                        register int len;
                        register char ender;

                        regparse--;
                        len = strcspn(regparse, META);
                        if (len <= 0)
                                FAIL("internal disaster");
                        ender = *(regparse+len);
                        if (len > 1 && ISMULT(ender))
                                len--;          /* Back off clear of ?+* operand. */
                        *flagp |= HASWIDTH;
                        if (len == 1)
                                *flagp |= SIMPLE;
                        ret = regnode(EXACTLY);
                        while (len > 0) {
                                regc(*regparse++);
                                len--;
                        }
                        regc('\0');
                }
                break;
        }

        return(ret);
}

/*
 - regnode - emit a node
 */
static char *                   /* Location. */
regnode(op)
char op;
{
        register char *ret;
        register char *ptr;

        ret = regcode;
        if (ret == &regdummy) {
                regsize += 3;
                return(ret);
        }

        ptr = ret;
        *ptr++ = op;
        *ptr++ = '\0';          /* Null "next" pointer. */
        *ptr++ = '\0';
        regcode = ptr;

        return(ret);
}

/*
 - regc - emit (if appropriate) a byte of code
 */
static void
regc(b)
char b;
{
        if (regcode != &regdummy)
                *regcode++ = b;
        else
                regsize++;
}

/*
 - reginsert - insert an operator in front of already-emitted operand
 *
 * Means relocating the operand.
 */
static void
reginsert(op, opnd)
char op;
char *opnd;
{
        register char *src;
        register char *dst;
        register char *place;

        if (regcode == &regdummy) {
                regsize += 3;
                return;
        }

        src = regcode;
        regcode += 3;
        dst = regcode;
        while (src > opnd)
                *--dst = *--src;

        place = opnd;           /* Op node, where operand used to be. */
        *place++ = op;
        *place++ = '\0';
        *place++ = '\0';
}

/*
 - regtail - set the next-pointer at the end of a node chain
 */
static void
regtail(p, val)
char *p;
char *val;
{
        register char *scan;
        register char *temp;
        register int offset;

        if (p == &regdummy)
                return;

        /* Find last node. */
        scan = p;
        for (;;) {
                temp = regnext(scan);
                if (temp == NULL)
                        break;
                scan = temp;
        }

        if (OP(scan) == BACK)
                offset = (int)(scan - val);
        else
                offset = (int)(val - scan);
        *(scan+1) = (char)((offset>>8)&0377);
        *(scan+2) = (char)(offset&0377);
}

/*
 - regoptail - regtail on operand of first argument; nop if operandless
 */
static void
regoptail(p, val)
char *p;
char *val;
{
        /* "Operandless" and "op != BRANCH" are synonymous in practice. */
        if (p == NULL || p == &regdummy || OP(p) != BRANCH)
                return;
        regtail(OPERAND(p), val);
}

/*
 * regexec and friends
 */

/*
 * Global work variables for regexec().
 */
static char *reginput;          /* String-input pointer. */
static char *regbol;            /* Beginning of input, for ^ check. */
static char **regstartp;        /* Pointer to startp array. */
static char **regendp;          /* Ditto for endp. */

/*
 * Forwards.
 */
STATIC int regtry();
STATIC int regmatch();
STATIC int regrepeat();

#ifdef DEBUG
int regnarrate = 0;
void regdump();
STATIC char *regprop();
#endif

/*
 - regexec - match a regexp against a string
 */
int
regexec(regexp *prog, char *string, int at_bol)
{
        register char *s;

        /* Be paranoid... */
        if (prog == NULL || string == NULL) {
                regerror("NULL parameter");
                return(0);
        }

        /* Check validity of program. */
        if (UCHARAT(prog->program) != MAGIC) {
                regerror("corrupted program");
                return(0);
        }

        /* If there is a "must appear" string, look for it. */
        if (prog->regmust != NULL) {
                s = string;
                while ((s = cstrchr(s, prog->regmust[0])) != NULL) {
                        if (cstrncmp(s, prog->regmust, prog->regmlen) == 0)
                                break;  /* Found it. */
                        s++;
                }
                if (s == NULL)  /* Not present. */
                        return(0);
        }

        /* Mark beginning of line for ^ . */
        if (at_bol)
                regbol = string;        /* is possible to match bol */
        else
                regbol = NULL;          /* we aren't there, so don't match it */

        /* Simplest case:  anchored match need be tried only once. */
        if (prog->reganch)
                return(regtry(prog, string));

        /* Messy cases:  unanchored match. */
        s = string;
        if (prog->regstart != '\0')
                /* We know what char it must start with. */
                while ((s = cstrchr(s, prog->regstart)) != NULL) {
                        if (regtry(prog, s))
                                return(1);
                        s++;
                }
        else
                /* We don't -- general case. */
                do {
                        if (regtry(prog, s))
                                return(1);
                } while (*s++ != '\0');

        /* Failure. */
        return(0);
}

/*
 - regtry - try match at specific point
 */
static int                      /* 0 failure, 1 success */
regtry(prog, string)
regexp *prog;
char *string;
{
        register int i;
        register char **sp;
        register char **ep;

        reginput = string;
        regstartp = prog->startp;
        regendp = prog->endp;

        sp = prog->startp;
        ep = prog->endp;
        for (i = NSUBEXP; i > 0; i--) {
                *sp++ = NULL;
                *ep++ = NULL;
        }
        if (regmatch(prog->program + 1)) {
                prog->startp[0] = string;
                prog->endp[0] = reginput;
                return(1);
        } else
                return(0);
}

/*
 - regmatch - main matching routine
 *
 * Conceptually the strategy is simple:  check to see whether the current
 * node matches, call self recursively to see whether the rest matches,
 * and then act accordingly.  In practice we make some effort to avoid
 * recursion, in particular by going through "ordinary" nodes (that don't
 * need to know whether the rest of the match failed) by a loop instead of
 * by recursion.
 */
static int                      /* 0 failure, 1 success */
regmatch(prog)
char *prog;
{
        register char *scan;    /* Current node. */
        char *next;             /* Next node. */

        scan = prog;
#ifdef DEBUG
        if (scan != NULL && regnarrate)
                fprintf(stderr, "%s(\n", regprop(scan));
#endif
        while (scan != NULL) {
#ifdef DEBUG
                if (regnarrate)
                        fprintf(stderr, "%s...\n", regprop(scan));
#endif
                next = regnext(scan);

                switch (OP(scan)) {
                case BOL:
                        if (reginput != regbol)
                                return(0);
                        break;
                case EOL:
                        if (*reginput != '\0')
                                return(0);
                        break;
                case ANY:
                        if (*reginput == '\0')
                                return(0);
                        reginput++;
                        break;
                case EXACTLY: {
                                register int len;
                                register char *opnd;

                                opnd = OPERAND(scan);
                                /* Inline the first character, for speed. */
                                if (mkup(*opnd) != mkup(*reginput))
                                        return(0);
                                len = strlen(opnd);
                                if (len > 1 && cstrncmp(opnd,reginput,len) != 0)
                                        return(0);
                                reginput += len;
                        }
                        break;
                case ANYOF:
                        if (*reginput == '\0' || strchr(OPERAND(scan), *reginput) == NULL)
                                return(0);
                        reginput++;
                        break;
                case ANYBUT:
                        if (*reginput == '\0' || strchr(OPERAND(scan), *reginput) != NULL)
                                return(0);
                        reginput++;
                        break;
                case NOTHING:
                        break;
                case BACK:
                        break;
                case OPEN+1:
                case OPEN+2:
                case OPEN+3:
                case OPEN+4:
                case OPEN+5:
                case OPEN+6:
                case OPEN+7:
                case OPEN+8:
                case OPEN+9: {
                                register int no;
                                register char *save;

                                no = OP(scan) - OPEN;
                                save = reginput;

                                if (regmatch(next)) {
                                        /*
                                         * Don't set startp if some later
                                         * invocation of the same parentheses
                                         * already has.
                                         */
                                        if (regstartp[no] == NULL)
                                                regstartp[no] = save;
                                        return(1);
                                } else
                                        return(0);
                        }
                        break;
                case CLOSE+1:
                case CLOSE+2:
                case CLOSE+3:
                case CLOSE+4:
                case CLOSE+5:
                case CLOSE+6:
                case CLOSE+7:
                case CLOSE+8:
                case CLOSE+9: {
                                register int no;
                                register char *save;

                                no = OP(scan) - CLOSE;
                                save = reginput;

                                if (regmatch(next)) {
                                        /*
                                         * Don't set endp if some later
                                         * invocation of the same parentheses
                                         * already has.
                                         */
                                        if (regendp[no] == NULL)
                                                regendp[no] = save;
                                        return(1);
                                } else
                                        return(0);
                        }
                        break;
                case BRANCH: {
                                register char *save;

                                if (OP(next) != BRANCH)         /* No choice. */
                                        next = OPERAND(scan);   /* Avoid recursion. */
                                else {
                                        do {
                                                save = reginput;
                                                if (regmatch(OPERAND(scan)))
                                                        return(1);
                                                reginput = save;
                                                scan = regnext(scan);
                                        } while (scan != NULL && OP(scan) == BRANCH);
                                        return(0);
                                        /* NOTREACHED */
                                }
                        }
                        break;
                case STAR:
                case PLUS: {
                                register char nextch;
                                register int no;
                                register char *save;
                                register int min;

                                /*
                                 * Lookahead to avoid useless match attempts
                                 * when we know what character comes next.
                                 */
                                nextch = '\0';
                                if (OP(next) == EXACTLY)
                                        nextch = *OPERAND(next);
                                min = (OP(scan) == STAR) ? 0 : 1;
                                save = reginput;
                                no = regrepeat(OPERAND(scan));
                                while (no >= min) {
                                        /* If it could work, try it. */
                                        if (nextch == '\0' || *reginput == nextch)
                                                if (regmatch(next))
                                                        return(1);
                                        /* Couldn't or didn't -- back up. */
                                        no--;
                                        reginput = save + no;
                                }
                                return(0);
                        }
                        break;
                case END:
                        return(1);      /* Success! */
                        break;
                default:
                        regerror("memory corruption");
                        return(0);
                        break;
                }

                scan = next;
        }

        /*
         * We get here only if there's trouble -- normally "case END" is
         * the terminating point.
         */
        regerror("corrupted pointers");
        return(0);
}

/*
 - regrepeat - repeatedly match something simple, report how many
 */
static int
regrepeat(p)
char *p;
{
        register int count = 0;
        register char *scan;
        register char *opnd;

        scan = reginput;
        opnd = OPERAND(p);
        switch (OP(p)) {
        case ANY:
                count = strlen(scan);
                scan += count;
                break;
        case EXACTLY:
                while (mkup(*opnd) == mkup(*scan)) {
                        count++;
                        scan++;
                }
                break;
        case ANYOF:
                while (*scan != '\0' && strchr(opnd, *scan) != NULL) {
                        count++;
                        scan++;
                }
                break;
        case ANYBUT:
                while (*scan != '\0' && strchr(opnd, *scan) == NULL) {
                        count++;
                        scan++;
                }
                break;
        default:                /* Oh dear.  Called inappropriately. */
                regerror("internal foulup");
                count = 0;      /* Best compromise. */
                break;
        }
        reginput = scan;

        return(count);
}

/*
 - regnext - dig the "next" pointer out of a node
 */
static char *
regnext(p)
register char *p;
{
        register int offset;

        if (p == &regdummy)
                return(NULL);

        offset = NEXT(p);
        if (offset == 0)
                return(NULL);

        if (OP(p) == BACK)
                return(p-offset);
        else
                return(p+offset);
}

#ifdef DEBUG

STATIC char *regprop();

/*
 - regdump - dump a regexp onto stdout in vaguely comprehensible form
 */
void
regdump(r)
regexp *r;
{
        register char *s;
        register char op = EXACTLY;     /* Arbitrary non-END op. */
        register char *next;

        s = r->program + 1;
        while (op != END) {     /* While that wasn't END last time... */
                op = OP(s);
                printf("%2d%s", s-r->program, regprop(s));      /* Where, what. */
                next = regnext(s);
                if (next == NULL)               /* Next ptr. */
                        printf("(0)");
                else
                        printf("(%d)", (s-r->program)+(next-s));
                s += 3;
                if (op == ANYOF || op == ANYBUT || op == EXACTLY) {
                        /* Literal string, where present. */
                        while (*s != '\0') {
                                putchar(*s);
                                s++;
                        }
                        s++;
                }
                putchar('\n');
        }

        /* Header fields of interest. */
        if (r->regstart != '\0')
                printf("start `%c' ", r->regstart);
        if (r->reganch)
                printf("anchored ");
        if (r->regmust != NULL)
                printf("must have \"%s\"", r->regmust);
        printf("\n");
}

/*
 - regprop - printable representation of opcode
 */
static char *
regprop(op)
char *op;
{
        register char *p;
        static char buf[50];

        (void) strcpy(buf, ":");

        switch (OP(op)) {
        case BOL:
                p = "BOL";
                break;
        case EOL:
                p = "EOL";
                break;
        case ANY:
                p = "ANY";
                break;
        case ANYOF:
                p = "ANYOF";
                break;
        case ANYBUT:
                p = "ANYBUT";
                break;
        case BRANCH:
                p = "BRANCH";
                break;
        case EXACTLY:
                p = "EXACTLY";
                break;
        case NOTHING:
                p = "NOTHING";
                break;
        case BACK:
                p = "BACK";
                break;
        case END:
                p = "END";
                break;
        case OPEN+1:
        case OPEN+2:
        case OPEN+3:
        case OPEN+4:
        case OPEN+5:
        case OPEN+6:
        case OPEN+7:
        case OPEN+8:
        case OPEN+9:
                sprintf(buf+strlen(buf), "OPEN%d", OP(op)-OPEN);
                p = NULL;
                break;
        case CLOSE+1:
        case CLOSE+2:
        case CLOSE+3:
        case CLOSE+4:
        case CLOSE+5:
        case CLOSE+6:
        case CLOSE+7:
        case CLOSE+8:
        case CLOSE+9:
                sprintf(buf+strlen(buf), "CLOSE%d", OP(op)-CLOSE);
                p = NULL;
                break;
        case STAR:
                p = "STAR";
                break;
        case PLUS:
                p = "PLUS";
                break;
        default:
                regerror("corrupted opcode");
                break;
        }
        if (p != NULL)
                (void) strcat(buf, p);
        return(buf);
}
#endif

/*
 * The following is provided for those people who do not have strcspn() in
 * their C libraries.  They should get off their butts and do something
 * about it; at least one public-domain implementation of those (highly
 * useful) string routines has been published on Usenet.
 */
#ifdef STRCSPN
/*
 * strcspn - find length of initial segment of s1 consisting entirely
 * of characters not from s2
 */

static int
strcspn(s1, s2)
char *s1;
char *s2;
{
        register char *scan1;
        register char *scan2;
        register int count;

        count = 0;
        for (scan1 = s1; *scan1 != '\0'; scan1++) {
                for (scan2 = s2; *scan2 != '\0';)       /* ++ moved down. */
                        if (*scan1 == *scan2++)
                                return(count);
                count++;
        }
        return(count);
}
#endif

int
cstrncmp(s1, s2, n)
char    *s1, *s2;
int     n;
{
        char    *p, *S1, *S2, *strsave();
        int     rval;

        if (!reg_ic)
                return (strncmp(s1, s2, n));

        S1 = strsave(s1);
        S2 = strsave(s2);

        for (p = S1; *p ;p++)
                if (islower(*p))
                        *p = (char)toupper(*p);

        for (p = S2; *p ;p++)
                if (islower(*p))
                        *p = (char)toupper(*p);

        rval = strncmp(S1, S2, n);

        free(S1);
        free(S2);

        return rval;
}

char *
cstrchr(
char	*s,
char	c)
{
        char    *p;

        for (p = s; *p ;p++) {
                if (mkup(*p) == mkup(c))
                        return p;
        }
        return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vi\regmagic.h ===
/*
 * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
 *
 * This is NOT the original regular expression code as written by
 * Henry Spencer. This code has been modified specifically for use
 * with the STEVIE editor, and should not be used apart from compiling
 * STEVIE. If you want a good regular expression library, get the
 * original code. The copyright notice that follows is from the
 * original.
 *
 * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
 *
 * The first byte of the regexp internal "program" is actually this magic
 * number; the start node begins in the second byte.
 */
#define     MAGIC   0234
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vi\regsub.c ===
/* $Header: /nw/tony/src/stevie/src/RCS/regsub.c,v 1.4 89/03/11 22:43:30 tony Exp $
 *
 * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
 *
 * This is NOT the original regular expression code as written by
 * Henry Spencer. This code has been modified specifically for use
 * with the STEVIE editor, and should not be used apart from compiling
 * STEVIE. If you want a good regular expression library, get the
 * original code. The copyright notice that follows is from the
 * original.
 *
 * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
 *
 * regsub
 *
 *      Copyright (c) 1986 by University of Toronto.
 *      Written by Henry Spencer.  Not derived from licensed software.
 *
 *      Permission is granted to anyone to use this software for any
 *      purpose on any computer system, and to redistribute it freely,
 *      subject to the following restrictions:
 *
 *      1. The author is not responsible for the consequences of use of
 *              this software, no matter how awful, even if they arise
 *              from defects in it.
 *
 *      2. The origin of this software must not be misrepresented, either
 *              by explicit claim or by omission.
 *
 *      3. Altered versions must be plainly marked as such, and must not
 *              be misrepresented as being the original software.
 *
 */

#include <stdio.h>
#include <string.h>
#include "regexp.h"
#include "regmagic.h"

#ifndef CHARBITS
#define UCHARAT(p)      ((int)*(unsigned char *)(p))
#else
#define UCHARAT(p)      ((int)*(p)&CHARBITS)
#endif

/*
 - regsub - perform substitutions after a regexp match
 */
void
regsub(prog, source, dest)
regexp *prog;
char *source;
char *dest;
{
        register char *src;
        register char *dst;
        register char c;
        register int no;
        register size_t len;

        if (prog == NULL || source == NULL || dest == NULL) {
                regerror("NULL parm to regsub");
                return;
        }
        if (UCHARAT(prog->program) != MAGIC) {
                regerror("damaged regexp fed to regsub");
                return;
        }

        src = source;
        dst = dest;
        while ((c = *src++) != '\0') {
                if (c == '&')
                        no = 0;
                else if (c == '\\' && '0' <= *src && *src <= '9')
                        no = *src++ - '0';
                else
                        no = -1;
                if (no < 0) {   /* Ordinary character. */
                        if (c == '\\' && (*src == '\\' || *src == '&'))
                                c = *src++;
                        *dst++ = c;
                } else if (prog->startp[no] != NULL && prog->endp[no] != NULL) {
                        len = (size_t)(prog->endp[no] - prog->startp[no]);
                        strncpy(dst, prog->startp[no], len);
                        dst += len;
                        if (len != 0 && *(dst-1) == '\0') {     /* strncpy hit NUL. */
                                regerror("damaged match string");
                                return;
                        }
                }
        }
        *dst++ = '\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vi\screen.c ===
/*
 *
 * Routines to manipulate the screen representations.
 */

#include "stevie.h"

/*
 * This gets set if we ignored an update request while input was pending.
 * We check this when the input is drained to see if the screen should be
 * updated.
 */
bool_t  need_redraw = FALSE;

/*
 * The following variable is set (in filetonext) to the number of physical
 * lines taken by the line the cursor is on. We use this to avoid extra
 * calls to plines(). The optimized routines lfiletonext() and lnexttoscreen()
 * make sure that the size of the cursor line hasn't changed. If so, lines
 * below the cursor will move up or down and we need to call the routines
 * filetonext() and nexttoscreen() to examine the entire screen.
 */
static  int     Cline_size;     /* size (in rows) of the cursor line */
static  int     Cline_row;      /* starting row of the cursor line */

static  char    *mkline();      /* calculate line string for "number" mode */

/*
 * filetonext()
 *
 * Based on the current value of Topchar, transfer a screenfull of
 * stuff from Filemem to Nextscreen, and update Botchar.
 */

static void
filetonext()
{
        register int    row, col;
        register char   *screenp = Nextscreen;
        LNPTR    memp;
        LNPTR    save;                   /* save pos. in case line won't fit */
        register char   *endscreen;
        register char   *nextrow;
        char    extra[16];
        int     nextra = 0;
        register int    c;
        int     n;
        bool_t  done;           /* if TRUE, we hit the end of the file */
        bool_t  didline;        /* if TRUE, we finished the last line */
        int     srow;           /* starting row of the current line */
        int     lno;            /* number of the line we're doing */
        int     coff;           /* column offset */

        coff = P(P_NU) ? 8 : 0;

        save = memp = *Topchar;

        if (P(P_NU))
                lno = cntllines(Filemem, Topchar);

        /*
         * The number of rows shown is Rows-1.
         * The last line is the status/command line.
         */
        endscreen = &screenp[(Rows-1)*Columns];

        done = didline = FALSE;
        srow = row = col = 0;
        /*
         * We go one past the end of the screen so we can find out if the
         * last line fit on the screen or not.
         */
        while ( screenp <= endscreen && !done) {


                if (P(P_NU) && col == 0 && memp.index == 0) {
                        strcpy(extra, mkline(lno++));
                        nextra = 8;
                }

                /* Get the next character to put on the screen. */

                /* The 'extra' array contains the extra stuff that is */
                /* inserted to represent special characters (tabs, and */
                /* other non-printable stuff.  The order in the 'extra' */
                /* array is reversed. */

                if ( nextra > 0 )
                        c = extra[--nextra];
                else {
                        c = (unsigned)(0xff & gchar(&memp));
                        if (inc(&memp) == -1)
                                done = 1;
                        /* when getting a character from the file, we */
                        /* may have to turn it into something else on */
                        /* the way to putting it into 'Nextscreen'. */
                        if ( c == TAB && !P(P_LS) ) {
                                strcpy(extra,"        ");
                                /* tab amount depends on current column */
                                nextra = ((P(P_TS)-1) - (col - coff)%P(P_TS));
                                c = ' ';
                        }
                        else if ( c == NUL && P(P_LS) ) {
                                extra[0] = NUL;
                                nextra = 1;
                                c = '$';
                        } else if ((n = chars[c].ch_size) > 1 ) {
                                char *p;
                                nextra = 0;
                                p = chars[c].ch_str;
                                /* copy 'ch-str'ing into 'extra' in reverse */
                                while ( n > 1 )
                                        extra[nextra++] = p[--n];
                                c = p[0];
                        }
                }

                if (screenp == endscreen) {
                        /*
                         * We're one past the end of the screen. If the
                         * current character is null, then we really did
                         * finish, so set didline = TRUE. In either case,
                         * break out because we're done.
                         */
                        dec(&memp);
                        if (memp.index != 0 && c == NUL) {
                                didline = TRUE;
                                inc(&memp);
                        }
                        break;
                }

                if ( c == NUL ) {
                        srow = ++row;
                        /*
                         * Save this position in case the next line won't
                         * fit on the screen completely.
                         */
                        save = memp;
                        /* get pointer to start of next row */
                        nextrow = &Nextscreen[row*Columns];
                        /* blank out the rest of this row */
                        while ( screenp != nextrow )
                                *screenp++ = ' ';
                        col = 0;
                        continue;
                }
                if ( col >= Columns ) {
                        row++;
                        col = 0;
                }
                /* store the character in Nextscreen */
                *screenp++ = (char)c;
                col++;
        }
        /*
         * If we didn't hit the end of the file, and we didn't finish
         * the last line we were working on, then the line didn't fit.
         */
        if (!done && !didline) {
                /*
                 * Clear the rest of the screen and mark the unused lines.
                 */
                screenp = &Nextscreen[srow * Columns];
                while (screenp < endscreen)
                        *screenp++ = ' ';
                for (; srow < (Rows-1) ;srow++)
                        Nextscreen[srow * Columns] = '@';
                *Botchar = save;
                return;
        }
        /* make sure the rest of the screen is blank */
        while ( screenp < endscreen )
                *screenp++ = ' ';
        /* put '~'s on rows that aren't part of the file. */
        if ( col != 0 )
                row++;
        while ( row < Rows ) {
                Nextscreen[row*Columns] = '~';
                row++;
        }
        if (done)       /* we hit the end of the file */
                *Botchar = *Fileend;
        else
                *Botchar = memp;        /* FIX - prev? */
}

/*
 * nexttoscreen
 *
 * Transfer the contents of Nextscreen to the screen, using Realscreen
 * to avoid unnecessary output.
 */
static void
nexttoscreen()
{
        register char   *np = Nextscreen;
        register char   *rp = Realscreen;
        register char   *endscreen;
        register int    row = 0, col = 0;
        int     gorow = -1, gocol = -1;

        if (anyinput()) {
                need_redraw = TRUE;
                return;
        }

        endscreen = &np[(Rows-1)*Columns];

        InvisibleCursor();

        for ( ; np < endscreen ; np++,rp++ ) {
                /* If desired screen (contents of Nextscreen) does not */
                /* match what's really there, put it there. */
                if ( *np != *rp ) {
                        /* if we are positioned at the right place, */
                        /* we don't have to use windgoto(). */
                        if (gocol != col || gorow != row) {
                                /*
                                 * If we're just off by one, don't send
                                 * an entire esc. seq. (this happens a lot!)
                                 */
                                if (gorow == row && gocol+1 == col) {
                                        outchar(*(np-1));
                                        gocol++;
                                } else
                                        windgoto(gorow=row,gocol=col);
                        }
                        outchar(*rp = *np);
                        gocol++;
                }
                if ( ++col >= Columns ) {
                        col = 0;
                        row++;
                }
        }
        VisibleCursor();
}

/*
 * lfiletonext() - like filetonext() but only for cursor line
 *
 * Returns true if the size of the cursor line (in rows) hasn't changed.
 * This determines whether or not we need to call filetonext() to examine
 * the entire screen for changes.
 */
static bool_t
lfiletonext()
{
        register int    row, col;
        register char   *screenp;
        LNPTR    memp;
        register char   *nextrow;
        char    extra[16];
        int     nextra = 0;
        register int    c;
        int     n;
        bool_t  eof;
        int     lno;            /* number of the line we're doing */
        int     coff;           /* column offset */

        coff = P(P_NU) ? 8 : 0;

        /*
         * This should be done more efficiently.
         */
        if (P(P_NU))
                lno = cntllines(Filemem, Curschar);

        screenp = Nextscreen + (Cline_row * Columns);

        memp = *Curschar;
        memp.index = 0;

        eof = FALSE;
        col = 0;
        row = Cline_row;

        while (!eof) {

                if (P(P_NU) && col == 0 && memp.index == 0) {
                        strcpy(extra, mkline(lno));
                        nextra = 8;
                }

                /* Get the next character to put on the screen. */

                /* The 'extra' array contains the extra stuff that is */
                /* inserted to represent special characters (tabs, and */
                /* other non-printable stuff.  The order in the 'extra' */
                /* array is reversed. */

                if ( nextra > 0 )
                        c = extra[--nextra];
                else {
                        c = (unsigned)(0xff & gchar(&memp));
                        if (inc(&memp) == -1)
                                eof = TRUE;
                        /* when getting a character from the file, we */
                        /* may have to turn it into something else on */
                        /* the way to putting it into 'Nextscreen'. */
                        if ( c == TAB && !P(P_LS) ) {
                                strcpy(extra,"        ");
                                /* tab amount depends on current column */
                                nextra = ((P(P_TS)-1) - (col - coff)%P(P_TS));
                                c = ' ';
                        } else if ( c == NUL && P(P_LS) ) {
                                extra[0] = NUL;
                                nextra = 1;
                                c = '$';
                        } else if (c != NUL && (n=chars[c].ch_size) > 1 )
                        {
                                char *p;
                                nextra = 0;
                                p = chars[c].ch_str;
                                /* copy 'ch-str'ing into 'extra' in reverse */
                                while ( n > 1 )
                                        extra[nextra++] = p[--n];
                                c = p[0];
                        }
                }

                if ( c == NUL ) {
                        row++;
                        /* get pointer to start of next row */
                        nextrow = &Nextscreen[row*Columns];
                        /* blank out the rest of this row */
                        while ( screenp != nextrow )
                                *screenp++ = ' ';
                        col = 0;
                        break;
                }

                if ( col >= Columns ) {
                        row++;
                        col = 0;
                }
                /* store the character in Nextscreen */
                *screenp++ = (char)c;
                col++;
        }
        return ((row - Cline_row) == Cline_size);
}

/*
 * lnexttoscreen
 *
 * Like nexttoscreen() but only for the cursor line.
 */
static void
lnexttoscreen()
{
        register char   *np = Nextscreen + (Cline_row * Columns);
        register char   *rp = Realscreen + (Cline_row * Columns);
        register char   *endline;
        register int    row, col;
        int     gorow = -1, gocol = -1;

        if (anyinput()) {
                need_redraw = TRUE;
                return;
        }

        endline = np + (Cline_size * Columns);

        row = Cline_row;
        col = 0;

        InvisibleCursor();

        for ( ; np < endline ; np++,rp++ ) {
                /* If desired screen (contents of Nextscreen) does not */
                /* match what's really there, put it there. */
                if ( *np != *rp ) {
                        /* if we are positioned at the right place, */
                        /* we don't have to use windgoto(). */
                        if (gocol != col || gorow != row) {
                                /*
                                 * If we're just off by one, don't send
                                 * an entire esc. seq. (this happens a lot!)
                                 */
                                if (gorow == row && gocol+1 == col) {
                                        outchar(*(np-1));
                                        gocol++;
                                } else
                                        windgoto(gorow=row,gocol=col);
                        }
                        outchar(*rp = *np);
                        gocol++;
                }
                if ( ++col >= Columns ) {
                        col = 0;
                        row++;
                }
        }
        VisibleCursor();
}

static char *
mkline(n)
register int    n;
{
        static  char    lbuf[9];
        register int    i = 2;

        strcpy(lbuf, "        ");

        lbuf[i++] = (char)((n % 10) + '0');
        n /= 10;
        if (n != 0) {
                lbuf[i++] = (char)((n % 10) + '0');
                n /= 10;
        }
        if (n != 0) {
                lbuf[i++] = (char)((n % 10) + '0');
                n /= 10;
        }
        if (n != 0) {
                lbuf[i++] = (char)((n % 10) + '0');
                n /= 10;
        }
        if (n != 0) {
                lbuf[i++] = (char)((n % 10) + '0');
                n /= 10;
        }
        return lbuf;
}

/*
 * updateline() - update the line the cursor is on
 *
 * Updateline() is called after changes that only affect the line that
 * the cursor is on. This improves performance tremendously for normal
 * insert mode operation. The only thing we have to watch for is when
 * the cursor line grows or shrinks around a row boundary. This means
 * we have to repaint other parts of the screen appropriately. If
 * lfiletonext() returns FALSE, the size of the cursor line (in rows)
 * has changed and we have to call updatescreen() to do a complete job.
 */
void
updateline()
{
        if (!lfiletonext())
                updatescreen(); /* bag it, do the whole screen */
        else
                lnexttoscreen();
}

void
updatescreen()
{
        extern  bool_t  interactive;

        if (interactive) {
                filetonext();
                nexttoscreen();
        }
}

/*
 * prt_line() - print the given line
 */
void
prt_line(s)
char    *s;
{
        register int    si = 0;
        register int    c;
        register int    col = 0;

        char    extra[16];
        int     nextra = 0;
        int     n;

        for (;;) {

                if ( nextra > 0 )
                        c = extra[--nextra];
                else {
                        c = s[si++];
                        if ( c == TAB && !P(P_LS) ) {
                                strcpy(extra, "        ");
                                /* tab amount depends on current column */
                                nextra = (P(P_TS) - 1) - col%P(P_TS);
                                c = ' ';
                        } else if ( c == NUL && P(P_LS) ) {
                                extra[0] = NUL;
                                nextra = 1;
                                c = '$';
                        } else if ( c != NUL && (n=chars[c].ch_size) > 1 ) {
                                char    *p;

                                nextra = 0;
                                p = chars[c].ch_str;
                                /* copy 'ch-str'ing into 'extra' in reverse */
                                while ( n > 1 )
                                        extra[nextra++] = p[--n];
                                c = p[0];
                        }
                }

                if ( c == NUL )
                        break;

                outchar(c);
                col++;
        }
}

void
screenclear()
{
        register char   *rp, *np;
        register char   *end;

        ClearDisplay();

        rp  = Realscreen;
        end = Realscreen + Rows * Columns;
        np  = Nextscreen;

        /* blank out the stored screens */
        while (rp != end)
                *rp++ = *np++ = ' ';
}

void
cursupdate()
{
        register LNPTR   *p;
        register int    icnt, c, nlines;
        register int    i;
        int     didinc;

        if (bufempty()) {               /* special case - file is empty */
                *Topchar  = *Filemem;
                *Curschar = *Filemem;
        } else if ( LINEOF(Curschar) < LINEOF(Topchar) ) {
                nlines = cntllines(Curschar,Topchar);
                /* if the cursor is above the top of */
                /* the screen, put it at the top of the screen.. */
                *Topchar = *Curschar;
                Topchar->index = 0;
                /* ... and, if we weren't very close to begin with, */
                /* we scroll so that the line is close to the middle. */
                if ( nlines > Rows/3 ) {
                        for (i=0, p = Topchar; i < Rows/3 ;i++, *Topchar = *p)
                                if ((p = prevline(p)) == NULL)
                                        break;
                } else
                        s_ins(0, nlines-1);
                updatescreen();
        }
        else if (LINEOF(Curschar) >= LINEOF(Botchar)) {
                nlines = cntllines(Botchar,Curschar);
                /* If the cursor is off the bottom of the screen, */
                /* put it at the top of the screen.. */
                /* ... and back up */
                if ( nlines > Rows/3 ) {
                        p = Curschar;
                        for (i=0; i < (2*Rows)/3 ;i++)
                                if ((p = prevline(p)) == NULL)
                                        break;
                        *Topchar = *p;
                } else {
                        scrollup(nlines+1);
                }
                updatescreen();
        }

        Cursrow = Curscol = Cursvcol = 0;
        for ( p=Topchar; p->linep != Curschar->linep ;p = nextline(p) )
                Cursrow += plines(p);

        Cline_row = Cursrow;
        Cline_size = plines(p);

        if (P(P_NU))
                Curscol = 8;

        for (i=0; i <= Curschar->index ;i++) {
                c = Curschar->linep->s[i];
                /* A tab gets expanded, depending on the current column */
                if ( c == TAB && !P(P_LS) )
                        icnt = P(P_TS) - (Cursvcol % P(P_TS));
                else
                        icnt = chars[(unsigned)(c & 0xff)].ch_size;
                Curscol += icnt;
                Cursvcol += icnt;
                if ( Curscol >= Columns ) {
                        Curscol -= Columns;
                        Cursrow++;
                        didinc = TRUE;
                }
                else
                        didinc = FALSE;
        }
        if (didinc)
                Cursrow--;

        if (c == TAB && State == NORMAL && !P(P_LS)) {
                Curscol--;
                Cursvcol--;
        } else {
                Curscol -= icnt;
                Cursvcol -= icnt;
        }
        if (Curscol < 0)
                Curscol += Columns;

        if (set_want_col) {
                Curswant = Cursvcol;
                set_want_col = FALSE;
        }
}

/*
 * The rest of the routines in this file perform screen manipulations.
 * The given operation is performed physically on the screen. The
 * corresponding change is also made to the internal screen image.
 * In this way, the editor anticipates the effect of editing changes
 * on the appearance of the screen. That way, when we call screenupdate
 * a complete redraw isn't usually necessary. Another advantage is that
 * we can keep adding code to anticipate screen changes, and in the
 * meantime, everything still works.
 */

/*
 * s_ins(row, nlines) - insert 'nlines' lines at 'row'
 */
void
s_ins(row, nlines)
int     row;
int     nlines;
{
        register char   *s, *d;         /* src & dest for block copy */
        register char   *e;             /* end point for copy */

        SaveCursor();

        // clip to screen

        if(row <= Rows-2-nlines) {
            Scroll(row,0,Rows-2-nlines,Columns-1,row+nlines,0);
            EraseNLinesAtRow(nlines,row);
        } else {
            // just erase to end of screen
            EraseNLinesAtRow(Rows-2-row+1,row);
        }

        windgoto(Rows-1, 0);    /* delete any garbage that may have */
        EraseLine();
        RestoreCursor();

        /*
         * Now do a block move to update the internal screen image
         */
        d = Realscreen + (Columns * (Rows - 1)) - 1;
        s = d - (Columns * nlines);
        e = Realscreen + (Columns * row);

        while (s >= e)
                *d-- = *s--;

        /*
         * Clear the inserted lines
         */
        s = Realscreen + (row * Columns);
        e = s + (nlines * Columns);
        while (s < e)
                *s++ = ' ';
}

/*
 * s_del(row, nlines) - delete 'nlines' lines at 'row'
 */
void
s_del(row, nlines)
int     row;
int     nlines;
{
        register char   *s, *d, *e;

        SaveCursor();
        windgoto(Rows-1,0);
        EraseLine();                        // erase status line
        windgoto(row,0);

        if(row + nlines >= Rows - 1) {      // more than a screenfull?
            EraseNLinesAtRow(Rows-row-1,row);
        } else {
            Scroll(row+nlines,0,Rows-2,Columns-1,row,0);
            EraseNLinesAtRow(nlines,Rows-nlines-1);
        }
        RestoreCursor();

        /*
         * do a block move to update the internal image
         */
        d = Realscreen + (row * Columns);
        s = d + (nlines * Columns);
        e = Realscreen + ((Rows - 1) * Columns);

        while (s < e)
                *d++ = *s++;

        while (d < e)           /* clear the lines at the bottom */
                *d++ = ' ';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vi\undo.c ===
/* $Header: /nw/tony/src/stevie/src/RCS/undo.c,v 1.7 89/08/06 09:51:06 tony Exp $
 *
 * Undo facility
 *
 * The routines in this file comprise a general undo facility for use
 * throughout the rest of the editor. The routine u_save() is called
 * before each edit operation to save the current contents of the lines
 * to be editted. Later, u_undo() can be called to return those lines
 * to their original state. The routine u_clear() should be called
 * whenever a new file is going to be editted to clear the undo buffer.
 */

#include "stevie.h"

/*
 * The next two variables mark the boundaries of the changed section
 * of the file. Lines BETWEEN the lower and upper bounds are changed
 * and originally contained the lines pointed to by u_lines. To undo
 * the last change, insert the lines in u_lines between the lower and
 * upper bounds.
 */
static  LINE    *u_lbound = NULL; /* line just prior to first changed line */
static  LINE    *u_ubound = NULL; /* line just after the last changed line */

static  LINE    *u_lline  = NULL; /* bounds of the saved lines */
static  LINE    *u_uline  = NULL;

static  int     u_col;
static  bool_t  u_valid = FALSE;  /* is the undo buffer valid */

/*
 * Local forward declarations
 */
static  LINE    *copyline();
static  void    u_lsave();
static  void    u_lfree();

/*
 * u_save(l, u) - save the current contents of part of the file
 *
 * The lines between 'l' and 'u' are about to be changed. This routine
 * saves their current contents into the undo buffer. The range l to u
 * is not inclusive because when we do an open, for example, there aren't
 * any lines in between. If no lines are to be saved, then l->next == u.
 */
void
u_save(l, u)
LINE    *l, *u;
{
        LINE    *nl;                    /* copy of the current line */

        /*
         * If l or u is null, there's an error. We don't return an
         * indication to the caller. They should find the problem
         * while trying to perform whatever edit is being requested
         * (e.g. a join on the last line).
         */
        if (l == NULL || u == NULL)
                return;

        u_clear();                      /* clear the buffer, first */

        u_lsave(l, u);          /* save to the "line undo" buffer, if needed */

        u_lbound = l;
        u_ubound = u;

        if (l->next != u) {             /* there are lines in the middle */
                l = l->next;
                u = u->prev;

                u_lline = nl = copyline(l);     /* copy the first line */
                while (l != u) {
                        nl->next = copyline(l->next);
                        nl->next->prev = nl;
                        l = l->next;
                        nl = nl->next;
                }
                u_uline = nl;
        } else
                u_lline = u_uline = NULL;

        u_valid = TRUE;
        u_col = Cursvcol;
}

/*
 * u_saveline() - save the current line in the undo buffer
 */
void
u_saveline()
{
        u_save(Curschar->linep->prev, Curschar->linep->next);
}

/*
 * u_undo() - effect an 'undo' operation
 *
 * The last edit is undone by restoring the modified section of the file
 * to its original state. The lines we're going to trash are copied to
 * the undo buffer so that even an 'undo' can be undone. Rings the bell
 * if the undo buffer is empty.
 */
void
u_undo()
{
        LINE    *tl, *tu;

        if (!u_valid) {
                beep();
                return;
        }

        /*
         * Get the first line of the thing we're undoing on the screen.
         */
        Curschar->linep = u_lbound->next;
        Curschar->index = 0;                    /* for now */
        if (Curschar->linep == Fileend->linep)
                Curschar->linep = Curschar->linep->prev;
        cursupdate();

        /*
         * Save pointers to what's in the file now.
         */
        if (u_lbound->next != u_ubound) {       /* there are lines to get */
                tl = u_lbound->next;
                tu = u_ubound->prev;
                tl->prev = NULL;
                tu->next = NULL;
        } else
                tl = tu = NULL;                 /* no lines between bounds */

        /*
         * Link the undo buffer into the right place in the file.
         */
        if (u_lline != NULL) {          /* there are lines in the undo buf */

                /*
                 * If the top line of the screen is being undone, we need to
                 * fix up Topchar to point to the new line that will be there.
                 */
                if (u_lbound->next == Topchar->linep)
                        Topchar->linep = u_lline;

                u_lbound->next = u_lline;
                u_lline->prev  = u_lbound;
                u_ubound->prev = u_uline;
                u_uline->next  = u_ubound;
        } else {                        /* no lines... link the bounds */
                if (u_lbound->next == Topchar->linep)
                        Topchar->linep = u_ubound;
                if (u_lbound == Filetop->linep)
                        Topchar->linep = u_ubound;

                u_lbound->next = u_ubound;
                u_ubound->prev = u_lbound;
        }

        /*
         * If we swapped the top line, patch up Filemem appropriately.
         */
        if (u_lbound == Filetop->linep)
                Filemem->linep = Filetop->linep->next;

        /*
         * Now save the old stuff in the undo buffer.
         */
        u_lline = tl;
        u_uline = tu;

        renum();                /* have to renumber everything */

        /*
         * Put the cursor on the first line of the 'undo' region.
         */
        Curschar->linep = u_lbound->next;
        Curschar->index = 0;
        if (Curschar->linep == Fileend->linep)
                Curschar->linep = Curschar->linep->prev;
        *Curschar = *coladvance(Curschar, u_col);
        cursupdate();
        updatescreen();         /* now show the change */

        u_lfree();              /* clear the "line undo" buffer */
}

/*
 * u_clear() - clear the undo buffer
 *
 * This routine is called to clear the undo buffer at times when the
 * pointers are about to become invalid, such as when a new file is
 * about to be editted.
 */
void
u_clear()
{
        LINE    *l, *nextl;

        if (!u_valid)           /* nothing to do */
                return;

        for (l = u_lline; l != NULL ;l = nextl) {
                nextl = l->next;
                free(l->s);
                free((char *)l);
        }

        u_lbound = u_ubound = u_lline = u_uline = NULL;
        u_valid = FALSE;
}

/*
 * The following functions and data implement the "line undo" feature
 * performed by the 'U' command.
 */

static  LINE    *u_line;                /* pointer to the line we last saved */
static  LINE    *u_lcopy = NULL;        /* local copy of the original line */

/*
 * u_lfree() - free the line save buffer
 */
static  void
u_lfree()
{
        if (u_lcopy != NULL) {
                free(u_lcopy->s);
                free((char *)u_lcopy);
                u_lcopy = NULL;
        }
        u_line = NULL;
}

/*
 * u_lsave() - save the current line if necessary
 */
static  void
u_lsave(l, u)
LINE    *l, *u;
{

        if (l->next != u->prev) {       /* not changing exactly one line */
                u_lfree();
                return;
        }

        if (l->next == u_line)          /* more edits on the same line */
                return;

        u_lfree();
        u_line = l->next;
        u_lcopy = copyline(l->next);
}

/*
 * u_lundo() - undo the current line (the 'U' command)
 */
void
u_lundo()
{
        if (u_lcopy != NULL) {
                free(Curschar->linep->s);
                Curschar->linep->s = u_lcopy->s;
                Curschar->linep->size = u_lcopy->size;
                free((char *)u_lcopy);
        } else
                beep();
        Curschar->index = 0;

        cursupdate();
        updatescreen();         /* now show the change */

        u_lcopy = NULL; /* can't undo this kind of undo */
        u_line = NULL;
}

/*
 * u_lcheck() - clear the "line undo" buffer if we've moved to a new line
 */
void
u_lcheck()
{
        if (Curschar->linep != u_line)
                u_lfree();
}

/*
 * copyline(l) - copy the given line, and return a pointer to the copy
 */
static LINE *
copyline(l)
LINE    *l;
{
        LINE    *nl;            /* the new line */

        nl = newline(strlen(l->s));
        strcpy(nl->s, l->s);

        return nl;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vi\stevie.h ===
/*
 * $Header: /nw/tony/src/stevie/src/RCS/stevie.h,v 1.19 89/07/12 21:33:32 tony Exp $
 *
 * Main header file included by all source files.
 */

#include "env.h"        /* defines to establish the compile-time environment */

#include <excpt.h>
#include <ntdef.h>
#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>

#include "ascii.h"
#include "keymap.h"
#include "param.h"

#define NORMAL 0
#define CMDLINE 1
#define INSERT 2
#define REPLACE 3
#define FORWARD 4
#define BACKWARD 5

/*
 * Boolean type definition and constants
 */
typedef unsigned  bool_t;

#ifndef TRUE
#define FALSE   (0)
#define TRUE    (1)
#endif

/*
 * SLOP is the amount of extra space we get for text on a line during
 * editing operations that need more space. This keeps us from calling
 * malloc every time we get a character during insert mode. No extra
 * space is allocated when the file is initially read.
 */
#define SLOP            10
#define INSERTSLOP      1024    // for insert buffer
#define REDOBUFFMIN     100     // minimum size of redo buffer

/*
 * LINEINC is the gap we leave between the artificial line numbers. This
 * helps to avoid renumbering all the lines every time a new line is
 * inserted.
 */
#define LINEINC 10

#define CHANGED         Changed=TRUE
#define UNCHANGED       Changed=FALSE

struct  line {
        struct  line    *prev, *next;   /* previous and next lines */
        char    *s;                     /* text for this line */
        int     size;                   /* actual size of space at 's' */
        unsigned long   num;            /* line "number" */
};

#define LINEOF(x)       ((x)->linep->num)

struct  LNPTR {
        struct  line    *linep;         /* line we're referencing */
        int     index;                  /* position within that line */
};

typedef struct line     LINE;
typedef struct LNPTR     LNPTR;

struct charinfo {
        char ch_size;
        char *ch_str;
};

extern struct charinfo chars[];

extern  int     State;
extern  int     Rows;
extern  int     Columns;
extern  char    *Realscreen;
extern  char    *Nextscreen;
extern  char    *Filename;
extern  char    *Appname;
extern  LNPTR    *Filemem;
extern  LNPTR    *Filetop;
extern  LNPTR    *Fileend;
extern  LNPTR    *Topchar;
extern  LNPTR    *Botchar;
extern  LNPTR    *Curschar;
extern  LNPTR    *Insstart;
extern  int     Cursrow, Curscol, Cursvcol, Curswant;
extern  bool_t  set_want_col;
extern  int     Prenum,namedbuff;
extern  bool_t  Changed;
extern  char    *Redobuff, *Insbuff;
extern  int     InsbuffSize;
extern  char    *Insptr;
extern  int     Ninsert;
extern  bool_t  got_int;

/*
 * alloc.c
 */
char    *alloc(), *strsave(), *mkstr();
char    *ralloc(char *,unsigned);
void    screenalloc(), filealloc(), freeall();
LINE    *newline();
bool_t  bufempty(), buf1line(), lineempty(), endofline(), canincrease();

/*
 * cmdline.c
 */
void    doxit(),docmdln(), dotag(), msg(), emsg();
void    smsg(), gotocmd(), wait_return();
int     wait_return0();
void    dosource(char *,bool_t);
char    *getcmdln();

/*
 * edit.c
 */
void    edit(), insertchar(), getout(), scrollup(), scrolldown(), beginline();
bool_t  oneright(), oneleft(), oneup(), onedown();

/*
 * fileio.c
 */
void    filemess(), renum();
bool_t  readfile(), writeit();

/*
 * help.c
 */
bool_t  help();

/*
 * linefunc.c
 */
LNPTR    *nextline(), *prevline(), *coladvance();

/*
 * main.c
 */
void    stuffin(), stuffnum();
void    do_mlines();
int     vgetc();
bool_t  anyinput();

/*
 * mark.c
 */
void    setpcmark(), clrall(), clrmark();
bool_t  setmark();
LNPTR    *getmark();

/*
 * misccmds.c
 */
void    opencmd(), fileinfo(), inschar(), delline();
bool_t  delchar();
int     cntllines(), plines();
LNPTR    *gotoline();

/*
 * normal.c
 */
void    normal();

/*
 * ops.c
 */

void inityank();

/*
 * param.c
 */
void    doset();

/*
 * ptrfunc.c
 */
int     inc(), dec();
int     gchar();
void    pchar(), pswap();
bool_t  lt(), equal(), ltoreq();
#if 0
/* not currently used */
bool_t  gtoreq(), gt();
#endif

/*
 * screen.c
 */
void    updatescreen(), updateline();
void    screenclear(), cursupdate();
void    s_ins(), s_del();
void    prt_line();

/*
 * search.c
 */
void    dosub(), doglob();
bool_t  searchc(), crepsearch(), findfunc(), dosearch(), repsearch();
LNPTR    *showmatch();
LNPTR    *fwd_word(), *bck_word(), *end_word();

/*
 * undo.c
 */
void    u_save(), u_saveline(), u_clear();
void    u_lcheck(), u_lundo();
void    u_undo();

/*
 * Machine-dependent routines.
 */
int     inchar();
void    flushbuf();
void    outchar(), outstr(), beep();
char    *fixname();
void    windinit(), windexit(), windgoto();
void    delay();
void    doshell();
void    sleep(int);
void    setviconsoletitle();
void    dochdir();

void Scroll(int t,int l,int b,int r,int Row,int Col);
void EraseLine(void);
void EraseNLinesAtRow(int n,int row);
void InsertLine(void);
void SaveCursor(void);
void RestoreCursor(void);
void ClearDisplay(void);
void InvisibleCursor(void);
void VisibleCursor(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vi\search.c ===
/* $Header: /nw/tony/src/stevie/src/RCS/search.c,v 1.16 89/08/06 09:50:51 tony Exp $
 *
 * This file contains various searching-related routines. These fall into
 * three groups: string searches (for /, ?, n, and N), character searches
 * within a single line (for f, F, t, T, etc), and "other" kinds of searches
 * like the '%' command, and 'word' searches.
 */

#include "stevie.h"
#include "regexp.h"     /* Henry Spencer's (modified) reg. exp. routines */

/*
 * String searches
 *
 * The actual searches are done using Henry Spencer's regular expression
 * library.
 */

#define BEGWORD "([^a-zA-Z0-9_]|^)"     /* replaces "\<" in search strings */
#define ENDWORD "([^a-zA-Z0-9_]|$)"     /* likewise replaces "\>" */

#define BEGCHAR(c)      (islower(c) || isupper(c) || isdigit(c) || ((c) == '_'))

bool_t  begword;        /* does the search include a 'begin word' match */

static  LNPTR    *bcksearch(), *fwdsearch();

void HighlightLine();

/*
 * mapstring(s) - map special backslash sequences
 */
static char *
mapstring(s)
register char   *s;
{
        static  char    ns[80];
        register char   *p;

        begword = FALSE;

        for (p = ns; *s ;s++) {
                if (*s != '\\') {       /* not an escape */
                        *p++ = *s;
                        continue;
                }
                switch (*++s) {
                case '/':
                        *p++ = '/';
                        break;

                case '<':
                        strcpy(p, BEGWORD);
                        p += strlen(BEGWORD);
                        begword = TRUE;
                        break;

                case '>':
                        strcpy(p, ENDWORD);
                        p += strlen(ENDWORD);
                        break;

                default:
                        *p++ = '\\';
                        *p++ = *s;
                        break;
                }
        }
        *p++ = NUL;

        return ns;
}

static char *laststr = NULL;
static int lastsdir;

static LNPTR *
ssearch(dir,str)
int     dir;    /* FORWARD or BACKWARD */
char    *str;
{
    LNPTR    *pos;
        char    *old_ls = laststr;

        reg_ic = P(P_IC);       /* tell the regexp routines how to search */

        laststr = strsave(str);
        lastsdir = dir;

        if (old_ls != NULL)
                free(old_ls);

        if (dir == BACKWARD) {
                smsg("?%s", laststr);
                pos = bcksearch(mapstring(laststr));
        } else {
                smsg("/%s", laststr);
                pos = fwdsearch(mapstring(laststr));
        }

        /*
         * This is kind of a kludge, but its needed to make
         * 'beginning of word' searches land on the right place.
         */
        if (pos != NULL && begword) {
                if (pos->index != 0 || !BEGCHAR(pos->linep->s[0]))
                        pos->index += 1;
        }
        return pos;
}

bool_t
dosearch(dir,str)
int     dir;
char    *str;
{
    LNPTR    *p;

        if (str == NULL) {
                if (laststr == NULL) {
                    msg("No previous regular expression");
                    got_int = FALSE;
                    return FALSE;
                }
                str = laststr;
        }

        got_int = FALSE;

        if ((p = ssearch(dir,str)) == NULL) {
                if (got_int)
                        msg("Interrupt");
                else
                        msg("Pattern not found");

                got_int = FALSE;
                return FALSE;
        } else {
                LNPTR savep;
                char  string[256];
                unsigned long lno;
                unsigned long toplno;

                cursupdate();
                /*
                 * if we're backing up, we make sure the line we're on
                 * is on the screen.
                 */
                setpcmark();
                *Curschar = savep = *p;
                set_want_col = TRUE;
                cursupdate();

                HighlightLine(0,
                              Cursrow,
                              p->linep->s);
                return TRUE;
        }
}

#define OTHERDIR(x)     (((x) == FORWARD) ? BACKWARD : FORWARD)

bool_t
repsearch(flag)
int     flag;
{
        int     dir = lastsdir;
        bool_t  found;

        if ( laststr == NULL ) {
                beep();
                return FALSE;
        }

        found = dosearch(flag ? OTHERDIR(lastsdir) : lastsdir, laststr);

        /*
         * We have to save and restore 'lastsdir' because it gets munged
         * by ssearch() and winds up saving the wrong direction from here
         * if 'flag' is true.
         */
        lastsdir = dir;

        return found;
}

/*
 * regerror - called by regexp routines when errors are detected.
 */
void
regerror(s)
char    *s;
{
        emsg(s);
}

static LNPTR *
fwdsearch(str)
register char   *str;
{
    static LNPTR infile;
    register LNPTR   *p;
        regexp  *prog;

        register char   *s;
        register int    i;

        if ((prog = regcomp(str)) == NULL) {
                emsg("Invalid search string");
                return NULL;
        }

        p = Curschar;
        i = Curschar->index + 1;
        do {
                s = p->linep->s + i;

                if (regexec(prog, s, i == 0)) {         /* got a match */
                        infile.linep = p->linep;
                        infile.index = (int) (prog->startp[0] - p->linep->s);
                        free((char *)prog);
                        return (&infile);
                }
                i = 0;

                if (got_int)
                        goto fwdfail;

        } while ((p = nextline(p)) != NULL);

        /*
         * If wrapscan isn't set, then don't scan from the beginning
         * of the file. Just return failure here.
         */
        if (!P(P_WS))
                goto fwdfail;

        /* search from the beginning of the file to Curschar */
        for (p = Filemem; p != NULL ;p = nextline(p)) {
                s = p->linep->s;

                if (regexec(prog, s, TRUE)) {           /* got a match */
                        infile.linep = p->linep;
                        infile.index = (int) (prog->startp[0] - s);
                        free((char *)prog);
                        return (&infile);
                }

                if (p->linep == Curschar->linep)
                        break;

                if (got_int)
                        goto fwdfail;
        }

fwdfail:
        free((char *)prog);
        return NULL;
}

static LNPTR *
bcksearch(str)
char    *str;
{
    static LNPTR infile;
    register LNPTR   *p = &infile;
        register char   *s;
        register int    i;
        register char   *match;
        regexp  *prog;

        /* make sure str isn't empty */
        if (str == NULL || *str == NUL)
                return NULL;

        if ((prog = regcomp(str)) == NULL) {
                emsg("Invalid search string");
                return NULL;
        }

        *p = *Curschar;
        if (dec(p) == -1) {     /* already at start of file? */
                *p = *Fileend;
                p->index = strlen(p->linep->s) - 1;
        }

        if (begword)            /* so we don't get stuck on one match */
                dec(p);

        i = p->index;

        do {
                s = p->linep->s;

                if (regexec(prog, s, TRUE)) {   /* match somewhere on line */

                        /*
                         * Now, if there are multiple matches on this line,
                         * we have to get the last one. Or the last one
                         * before the cursor, if we're on that line.
                         */
                        match = prog->startp[0];

                        while (regexec(prog, prog->endp[0], FALSE)) {
                                if ((i >= 0) && ((prog->startp[0] - s) > i))
                                        break;
                                match = prog->startp[0];
                        }

                        if ((i >= 0) && ((match - s) > i)) {
                                i = -1;
                                continue;
                        }

                        infile.linep = p->linep;
                        infile.index = (int) (match - s);
                        free((char *)prog);
                        return (&infile);
                }
                i = -1;

                if (got_int)
                        goto bckfail;

        } while ((p = prevline(p)) != NULL);

        /*
         * If wrapscan isn't set, bag the search now
         */
        if (!P(P_WS))
                goto bckfail;

        /* search backward from the end of the file */
        p = prevline(Fileend);
        do {
                s = p->linep->s;

                if (regexec(prog, s, TRUE)) {   /* match somewhere on line */

                        /*
                         * Now, if there are multiple matches on this line,
                         * we have to get the last one.
                         */
                        match = prog->startp[0];

                        while (regexec(prog, prog->endp[0], FALSE))
                                match = prog->startp[0];

                        infile.linep = p->linep;
                        infile.index = (int) (match - s);
                        free((char *)prog);
                        return (&infile);
                }

                if (p->linep == Curschar->linep)
                        break;

                if (got_int)
                        goto bckfail;

        } while ((p = prevline(p)) != NULL);

bckfail:
        free((char *)prog);
        return NULL;
}

/*
 * dosub(lp, up, cmd)
 *
 * Perform a substitution from line 'lp' to line 'up' using the
 * command pointed to by 'cmd' which should be of the form:
 *
 * /pattern/substitution/g
 *
 * The trailing 'g' is optional and, if present, indicates that multiple
 * substitutions should be performed on each line, if applicable.
 * The usual escapes are supported as described in the regexp docs.
 */
void
dosub(lp, up, cmd)
LNPTR    *lp, *up;
char    *cmd;
{
        LINE    *cp;
        char    *pat, *sub;
        regexp  *prog;
        int     nsubs;
        bool_t  do_all;         /* do multiple substitutions per line */

        /*
         * If no range was given, do the current line. If only one line
         * was given, just do that one.
         */
        if (lp->linep == NULL)
                *up = *lp = *Curschar;
        else {
                if (up->linep == NULL)
                        *up = *lp;
        }

        pat = ++cmd;            /* skip the initial '/' */

        while (*cmd) {
                if (*cmd == '\\')       /* next char is quoted */
                        cmd += 2;
                else if (*cmd == '/') { /* delimiter */
                        *cmd++ = NUL;
                        break;
                } else
                        cmd++;          /* regular character */
        }

        if (*pat == NUL) {
                if (laststr == NULL) {
                        emsg("NULL pattern specified");
                        return;
                }
                pat = laststr;
        } else {
                if (laststr != NULL) {
                        free(laststr);
                }
                laststr = strsave(pat);
        }

        sub = cmd;

        do_all = FALSE;

        while (*cmd) {
                if (*cmd == '\\')       /* next char is quoted */
                        cmd += 2;
                else if (*cmd == '/') { /* delimiter */
                        do_all = (cmd[1] == 'g');
                        *cmd++ = NUL;
                        break;
                } else
                        cmd++;          /* regular character */
        }

        reg_ic = P(P_IC);       /* set "ignore case" flag appropriately */

        if ((prog = regcomp(pat)) == NULL) {
                emsg("Invalid search string");
                return;
        }

        nsubs = 0;

        for (cp = lp->linep; cp != NULL ;cp = cp->next) {
                if (regexec(prog, cp->s, TRUE)) { /* a match on this line */
                        char    *ns, *sns, *p;

                        /*
                         * Get some space for a temporary buffer
                         * to do the substitution into.
                         */
                        sns = ns = alloc(2048);
                        *sns = NUL;

                        p = cp->s;

                        do {
                                for (ns = sns; *ns ;ns++)
                                        ;
                                /*
                                 * copy up to the part that matched
                                 */
                                while (p < prog->startp[0])
                                        *ns++ = *p++;

                                regsub(prog, sub, ns);

                                /*
                                 * continue searching after the match
                                 */
                                p = prog->endp[0];

                        } while (regexec(prog, p, FALSE) && do_all);

                        for (ns = sns; *ns ;ns++)
                                ;

                        /*
                         * copy the rest of the line, that didn't match
                         */
                        while (*p)
                                *ns++ = *p++;

                        *ns = NUL;

                        free(cp->s);            /* free the original line */
                        cp->s = strsave(sns);   /* and save the modified str */
                        cp->size = strlen(cp->s) + 1;
                        free(sns);              /* free the temp buffer */
                        nsubs++;
                        CHANGED;
                }
                if (cp == up->linep)
                        break;
        }

        if (nsubs) {
                updatescreen();
                if (nsubs >= P(P_RP))
                        smsg("%d substitution%c", nsubs, (nsubs>1) ? 's' : ' ');
        } else
                msg("No match");

        free((char *)prog);
}

/*
 * doglob(cmd)
 *
 * Execute a global command of the form:
 *
 * g/pattern/X
 *
 * where 'x' is a command character, currently one of the following:
 *
 * d    Delete all matching lines
 * p    Print all matching lines
 *
 * The command character (as well as the trailing slash) is optional, and
 * is assumed to be 'p' if missing.
 */
void
doglob(lp, up, cmd)
LNPTR    *lp, *up;
char    *cmd;
{
        LINE    *cp;
        char    *pat;
        regexp  *prog;
        int     ndone;
        char    cmdchar = NUL;  /* what to do with matching lines */

        /*
         * If no range was given, do every line. If only one line
         * was given, just do that one.
         */
        if (lp->linep == NULL) {
                *lp = *Filemem;
                *up = *Fileend;
        } else {
                if (up->linep == NULL)
                        *up = *lp;
        }

        pat = ++cmd;            /* skip the initial '/' */

        while (*cmd) {
                if (*cmd == '\\')       /* next char is quoted */
                        cmd += 2;
                else if (*cmd == '/') { /* delimiter */
                        cmdchar = cmd[1];
                        *cmd++ = NUL;
                        break;
                } else
                        cmd++;          /* regular character */
        }
        if (cmdchar == NUL)
                cmdchar = 'p';

        reg_ic = P(P_IC);       /* set "ignore case" flag appropriately */

        if (cmdchar != 'd' && cmdchar != 'p') {
                emsg("Invalid command character");
                return;
        }

        if (*pat == NUL) {
                //
                // Check and use previous expressions.
                //
                if (laststr != NULL) {
                        pat = laststr;
                }
        } else {
                if (laststr != NULL) {
                        free(laststr);
                }
                laststr = strsave(pat);
        }

        if ((prog = regcomp(pat)) == NULL) {
                emsg("Invalid search string");
                return;
        }

        msg("");
        ndone = 0;
        got_int = FALSE;

        for (cp = lp->linep; cp != NULL && !got_int ;cp = cp->next) {
                if (regexec(prog, cp->s, TRUE)) { /* a match on this line */
                        switch (cmdchar) {

                        case 'd':               /* delete the line */
                                if (Curschar->linep != cp) {
                    LNPTR    savep;

                                        savep = *Curschar;
                                        Curschar->linep = cp;
                                        Curschar->index = 0;
                                        delline(1, FALSE);
                                        *Curschar = savep;
                                } else
                                        delline(1, FALSE);
                                break;

                        case 'p':               /* print the line */
                                prt_line(cp->s);
                                outstr("\r\n");
                                break;
                        }
                        ndone++;
                }
                if (cp == up->linep)
                        break;
        }

        if (ndone) {
                switch (cmdchar) {

                case 'd':
                        updatescreen();
                        if (ndone >= P(P_RP) || got_int)
                                smsg("%s%d fewer line%c",
                                        got_int ? "Interrupt: " : "",
                                        ndone,
                                        (ndone > 1) ? 's' : ' ');
                        break;

                case 'p':
                        wait_return();
                        break;
                }
        } else {
                if (got_int)
                        msg("Interrupt");
                else
                        msg("No match");
        }

        got_int = FALSE;
        free((char *)prog);
}

/*
 * Character Searches
 */

static char lastc = NUL;        /* last character searched for */
static int  lastcdir;           /* last direction of character search */
static int  lastctype;          /* last type of search ("find" or "to") */

/*
 * searchc(c, dir, type)
 *
 * Search for character 'c', in direction 'dir'. If type is 0, move to
 * the position of the character, otherwise move to just before the char.
 */
bool_t
searchc(c, dir, type)
char    c;
int     dir;
int     type;
{
    LNPTR    save;

        save = *Curschar;       /* save position in case we fail */
        lastc = c;
        lastcdir = dir;
        lastctype = type;

        /*
         * On 'to' searches, skip one to start with so we can repeat
         * searches in the same direction and have it work right.
         */
        if (type)
                (dir == FORWARD) ? oneright() : oneleft();

        while ( (dir == FORWARD) ? oneright() : oneleft() ) {
                if (gchar(Curschar) == c) {
                        if (type)
                                (dir == FORWARD) ? oneleft() : oneright();
                        return TRUE;
                }
        }
        *Curschar = save;
        return FALSE;
}

bool_t
crepsearch(flag)
int     flag;
{
        int     dir = lastcdir;
        int     rval;

        if (lastc == NUL)
                return FALSE;

        rval = searchc(lastc, flag ? OTHERDIR(lastcdir) : lastcdir, lastctype);

        lastcdir = dir;         /* restore dir., since it may have changed */

        return rval;
}

/*
 * "Other" Searches
 */

/*
 * showmatch - move the cursor to the matching paren or brace
 */
LNPTR *
showmatch()
{
    static  LNPTR    pos;
        int     (*move)(), inc(), dec();
        char    initc = (char)gchar(Curschar);  /* initial char */
        char    findc;                          /* terminating char */
        char    c;
        int     count = 0;

        pos = *Curschar;                /* set starting point */

        switch (initc) {

        case '(':
                findc = ')';
                move = inc;
                break;
        case ')':
                findc = '(';
                move = dec;
                break;
        case '{':
                findc = '}';
                move = inc;
                break;
        case '}':
                findc = '{';
                move = dec;
                break;
        case '[':
                findc = ']';
                move = inc;
                break;
        case ']':
                findc = '[';
                move = dec;
                break;
        default:
        return (LNPTR *) NULL;
        }

        while ((*move)(&pos) != -1) {           /* until end of file */
                c = (char)gchar(&pos);
                if (c == initc)
                        count++;
                else if (c == findc) {
                        if (count == 0)
                                return &pos;
                        count--;
                }
        }
    return (LNPTR *) NULL;           /* never found it */
}

/*
 * findfunc(dir) - Find the next function in direction 'dir'
 *
 * Return TRUE if a function was found.
 */
bool_t
findfunc(dir)
int     dir;
{
    LNPTR    *curr;

        curr = Curschar;

        do {
                curr = (dir == FORWARD) ? nextline(curr) : prevline(curr);

                if (curr != NULL && curr->linep->s[0] == '{') {
                        setpcmark();
                        *Curschar = *curr;
                        return TRUE;
                }
        } while (curr != NULL);

        return FALSE;
}

/*
 * The following routines do the word searches performed by the
 * 'w', 'W', 'b', 'B', 'e', and 'E' commands.
 */

/*
 * To perform these searches, characters are placed into one of three
 * classes, and transitions between classes determine word boundaries.
 *
 * The classes are:
 *
 * 0 - white space
 * 1 - letters, digits, and underscore
 * 2 - everything else
 */

static  int     stype;          /* type of the word motion being performed */

#define C0(c)   (((c) == ' ') || ((c) == '\t') || ((c) == NUL))
#define C1(c)   (isalpha(c) || isdigit(c) || ((c) == '_'))

/*
 * cls(c) - returns the class of character 'c'
 *
 * The 'type' of the current search modifies the classes of characters
 * if a 'W', 'B', or 'E' motion is being done. In this case, chars. from
 * class 2 are reported as class 1 since only white space boundaries are
 * of interest.
 */
static  int
cls(c)
char    c;
{
        if (C0(c))
                return 0;

        if (C1(c))
                return 1;

        /*
         * If stype is non-zero, report these as class 1.
         */
        return (stype == 0) ? 2 : 1;
}


/*
 * fwd_word(pos, type) - move forward one word
 *
 * Returns the resulting position, or NULL if EOF was reached.
 */
LNPTR *
fwd_word(p, type)
LNPTR    *p;
int     type;
{
    static  LNPTR    pos;
        int     sclass = cls(gchar(p));         /* starting class */

        pos = *p;

        stype = type;

        /*
         * We always move at least one character.
         */
        if (inc(&pos) == -1)
                return NULL;

        if (sclass != 0) {
                while (cls(gchar(&pos)) == sclass) {
                        if (inc(&pos) == -1)
                                return NULL;
                }
                /*
                 * If we went from 1 -> 2 or 2 -> 1, return here.
                 */
                if (cls(gchar(&pos)) != 0)
                        return &pos;
        }

        /* We're in white space; go to next non-white */

        while (cls(gchar(&pos)) == 0) {
                /*
                 * We'll stop if we land on a blank line
                 */
                if (pos.index == 0 && pos.linep->s[0] == NUL)
                        break;

                if (inc(&pos) == -1)
                        return NULL;
        }

        return &pos;
}

/*
 * bck_word(pos, type) - move backward one word
 *
 * Returns the resulting position, or NULL if EOF was reached.
 */
LNPTR *
bck_word(p, type)
LNPTR    *p;
int     type;
{
    static  LNPTR    pos;
        int     sclass = cls(gchar(p));         /* starting class */

        pos = *p;

        stype = type;

        if (dec(&pos) == -1)
                return NULL;

        /*
         * If we're in the middle of a word, we just have to
         * back up to the start of it.
         */
        if (cls(gchar(&pos)) == sclass && sclass != 0) {
                /*
                 * Move backward to start of the current word
                 */
                while (cls(gchar(&pos)) == sclass) {
                        if (dec(&pos) == -1)
                                return NULL;
                }
                inc(&pos);                      /* overshot - forward one */
                return &pos;
        }

        /*
         * We were at the start of a word. Go back to the start
         * of the prior word.
         */

        while (cls(gchar(&pos)) == 0) {         /* skip any white space */
                /*
                 * We'll stop if we land on a blank line
                 */
                if (pos.index == 0 && pos.linep->s[0] == NUL)
                        return &pos;

                if (dec(&pos) == -1)
                        return NULL;
        }

        sclass = cls(gchar(&pos));

        /*
         * Move backward to start of this word.
         */
        while (cls(gchar(&pos)) == sclass) {
                if (dec(&pos) == -1)
                        return NULL;
        }
        inc(&pos);                      /* overshot - forward one */

        return &pos;
}

/*
 * end_word(pos, type, in_change) - move to the end of the word
 *
 * There is an apparent bug in the 'e' motion of the real vi. At least
 * on the System V Release 3 version for the 80386. Unlike 'b' and 'w',
 * the 'e' motion crosses blank lines. When the real vi crosses a blank
 * line in an 'e' motion, the cursor is placed on the FIRST character
 * of the next non-blank line. The 'E' command, however, works correctly.
 * Since this appears to be a bug, I have not duplicated it here.
 *
 * There's a strange special case here that the 'in_change' parameter
 * helps us deal with. Vi effectively turns 'cw' into 'ce'. If we're on
 * a word with only one character, we need to stick at the current
 * position so we don't change two words.
 *
 * Returns the resulting position, or NULL if EOF was reached.
 */
LNPTR *
end_word(p, type, in_change)
LNPTR    *p;
int     type;
bool_t  in_change;
{
    static  LNPTR    pos;
        int     sclass = cls(gchar(p));         /* starting class */

        pos = *p;

        stype = type;

        if (inc(&pos) == -1)
                return NULL;

        /*
         * If we're in the middle of a word, we just have to
         * move to the end of it.
         */
        if (cls(gchar(&pos)) == sclass && sclass != 0) {
                /*
                 * Move forward to end of the current word
                 */
                while (cls(gchar(&pos)) == sclass) {
                        if (inc(&pos) == -1)
                                return NULL;
                }
                dec(&pos);                      /* overshot - forward one */
                return &pos;
        }

        /*
         * We were at the end of a word. Go to the end of the next
         * word, unless we're doing a change. In that case we stick
         * at the end of the current word.
         */
        if (in_change)
                return p;

        while (cls(gchar(&pos)) == 0) {         /* skip any white space */
                if (inc(&pos) == -1)
                        return NULL;
        }

        sclass = cls(gchar(&pos));

        /*
         * Move forward to end of this word.
         */
        while (cls(gchar(&pos)) == sclass) {
                if (inc(&pos) == -1)
                        return NULL;
        }
        dec(&pos);                      /* overshot - forward one */

        return &pos;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmmreg32\makefile.inc ===
$(O)\vmmreg32.res: vmmreg32.rc vmmreg32.rcv
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmmreg32\dllentry.c ===
//
//  DLLENTRY.C
//
//  Copyright (C) Microsoft Corporation, 1995
//

#include "pch.h"

#ifdef USEHEAP
#define RGHEAP_SIZE                 9256*1024
HANDLE g_RgHeap = NULL;
#endif

BOOL
WINAPI
VMMRegDllEntry(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    )
{

    switch (dwReason) {

        case DLL_PROCESS_ATTACH:
#ifdef USEHEAP
            if ((g_RgHeap = HeapCreate(0, RGHEAP_SIZE, RGHEAP_SIZE)) == NULL)
                return FALSE;
#endif

            if (VMMRegLibAttach(0) != ERROR_SUCCESS)
                return FALSE;

            break;

        case DLL_PROCESS_DETACH:
            VMMRegLibDetach();

#ifdef USEHEAP
            if (g_RgHeap != NULL)
                HeapDestroy(g_RgHeap);
#endif

            break;

    }

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmmreg32\pch.c ===
#include "pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vi\version.c ===
static  char    RCSid[] =
"$Header: /nw/tony/src/stevie/src/RCS/version.c,v 3.69 89/08/13 11:41:58 tony Exp $";

/*
 * Contains the declaration of the global version number variable.
 *
 *  revision 0.23 JohnRo    1/20/92
 *  Make tag search obey ignorecase flag.
 *
 *  revision 0.22 JohnRo    11/6/91
 *  Made Tags file more like that of other versions of VI.
 *
 *  revision 0.21 tedm      6/9/91
 *  add named buffers (numbered buffers still absent)
 *
 *  revision 0.16 tedm      6/8/91
 *  add v and V visual operators for lowercasing and uppercasing.
 *
 *  revision 0.15 tedm
 *  add :list
 *
 *  revision 0.14 tedm
 *  add source command and automatic 'source $init:ntvi.exe' at startup
 *
 *  Revision 0.13 tedm
 *  add undo for line-oriented delete.  Still no undo for global or substitute.
 *
 *  Revision 0.12 tedm
 *  add line-oriented delete command.
 *
 *  Revision 0.11 tedm
 *  Changes various buffers to be dynamically allocated.  Insert mode is no
 *  longer limited to 1024 characters at a time.
 *
 *  NT version 0.1 tedm
 *  ported
 *
 * $Log:        version.c,v $
 * Revision 3.69  89/08/13  11:41:58  tony
 * Fixed a bug that caused messages from fileinfo() (in misccmds.c) to get
 * messed up. The routine smsg() which uses the kludge approach to varargs
 * didn't have enough parameters for some of the calls made to it.
 *
 * Revision 3.68  89/08/06  09:51:20  tony
 * Misc. minor changes to make lint happier before posting to USENET.
 *
 * Revision 3.67  89/08/03  13:08:52  tony
 * There was some code in ops.c that was duplicating the function of the
 * getcmdln() routine in cmdline.c. I modified getcmdln() to be slightly
 * more general, and changed dofilter() in ops.c to use it.
 *
 * Revision 3.66  89/08/02  20:00:12  tony
 * Fixed some problems with mode lines. There were still extra screen
 * redraws that needed to be avoided. There was also a problem involving
 * nested calls to docmdln() that can occur when mode lines are used.
 *
 * Revision 3.65  89/08/02  15:50:03  tony
 * Finally got around to providing full support for the "change" operator.
 * Multi-line changes (like "cL" or "3cc") now work correctly. Also fixed
 * a small problem with multi-line character-oriented deletes leaving the
 * cursor in the wrong location (off by one character). This is mainly
 * useful for multi-line changes (such as "c%") so the insert starts in
 * the right place.
 *
 * Revision 3.64  89/08/02  12:47:04  tony
 * This message intentionally left blank.
 *
 * Revision 3.63  89/08/02  12:43:44  tony
 * I just noticed that I had used the RCS cookie for log messages in one
 * of my prior version messages. This caused these version update messages
 * to be duplicated in this file. I just removed that string, and the
 * extra message copies that had been generated.
 *
 * Revision 3.62  89/08/02  12:26:20  tony
 * The ^G command now shows where you are in the file list, if more than one
 * file is being edited. Also, the commands ":e#" and ":e!#" (note the lack
 * of a space between the command and file name) will now work.
 *
 * Revision 3.61  89/08/02  11:03:16  tony
 * Misc. cleanups regarding tags. Also added support for the "terse" option.
 * This is ignored, but improves compatibility with vi, since we no longer
 * complain about an unknown option if "terse" is used.
 *
 * Revision 3.60  89/08/02  09:26:39  tony
 * Added code to avoid screen redraws when input is being read from the
 * "stuffin" buffer. This avoids extra redraws when switching to the
 * alternate file, or when invoking the editor with one of the "+" options,
 * or when using tags.
 *
 * Revision 3.59  89/08/01  16:28:31  tony
 * Added better support for counts on several cursor motion commands. These
 * include ^F, ^B, f, F, t, T, as well as the repeated character search
 * commands (command and semi-colon).
 *
 * Revision 3.58  89/07/19  08:08:23  tony
 * Added the ability for '~' to be an operator. If enabled (by defined TILDEOP
 * in env.h), the parameter "tildeop" (or "to") may be set to turn tilde into
 * an operator.
 *
 * Revision 3.57  89/07/13  22:47:05  tony
 * Made some generic speed improvements in screen.c and some TOS-specific
 * improvements in tos.c. The TOS version is now much faster at screen
 * updates than before.
 *
 * Revision 3.56  89/07/13  14:52:03  tony
 * Minor cleanups in normal.c
 *
 * Revision 3.55  89/07/13  14:19:12  tony
 * Cleaned up the logic in getcmdln() A LOT. The routine docmdln() needs a
 * similar overhaul.
 *
 * Revision 3.54  89/07/12  21:40:01  tony
 * Lots of misc. cleanup in normal.c and cmdline.c, but nothing much in the
 * way of functional improvements. One change is that things like d/foo<CR>
 * will now work since searches are less of a special case now.
 *
 * Revision 3.53  89/07/11  16:16:08  tony
 * Added general support for interrupt-handling for those environments that
 * can actually generate them. Basically, long-running operations are now
 * able to terminate early if an error occurs. These operations are: string
 * searches, the global command (":g/.../"), and file reads. File writes
 * should probably be done as well, but this is more dangerous. In all cases,
 * the user is given an indication on the status line that the operation
 * terminated due to an interrupt.
 *
 * Revision 3.52  89/07/11  12:35:09  tony
 * Improved the code in dosub() and doglob() that detects quoted characters
 * and delimiters in search strings and replacement patterns. The current
 * code didn't allow certain valid strings to be used. The delimiter is still
 * required to be '/', but it can be quoted reliably now with backslash.
 *
 * Revision 3.51  89/07/10  14:01:58  tony
 * Removed the function addtobuff() since it was rarely used and could be
 * replaced by calls to other library functions. Also removed some other
 * obsolete code that was already ifdef'd out anyway.
 *
 * Revision 3.50  89/07/10  13:10:32  tony
 * Added a workaround in normal.c to avoid problems with broken versions of
 * strncpy() that don't properly deal with a count of zero.
 *
 * Revision 3.49  89/07/07  16:28:37  tony
 * Fixed a long-standing bug with 'cw' when the cursor is positioned on a
 * word with only one character. Also fixed a problems with zero-length files
 * and reverse searches.
 *
 * Revision 3.48  89/03/22  10:26:58  tony
 * Fixed some outdated uses of the ":p" command (which has been changed to
 * ":N" in os2.c and dos.c. Also added macros (F7 and F8) for dos and os/2
 * to use the "cdecl" program to convert lines to and from a pseudo-english
 * form. Use F7 to "explain" the declaration on the current line, and F8 to
 * convert an english-style declaration to the C form. In both cases, the
 * new form is placed on the next line, leaving the original line intact.
 *
 * Revision 3.47  89/03/11  22:44:14  tony
 * General cleanup. Removed the static "rcsid" variables and the log
 * strings (except in version.c). Fixed some coding style inconsistencies
 * and added a few register declarations.
 *
 * Revision 3.46  89/02/14  09:52:07  tony
 * Made a first pass at adding Robert Regn's changes, starting with the
 * more portable ones. Added better support for '#' and '%' in colon
 * commands, support for a configurable temp directory, and made the
 * termcap code less picky about capabilities.
 *
 * Revision 3.45  88/11/10  09:00:06  tony
 * Added support for mode lines. Strings like "vi:stuff:" or "ex:stuff:"
 * occurring in the first or last 5 lines of a file cause the editor to
 * pretend that "stuff" was types as a colon command. This examination
 * is done only if the parameter "modelines" (or "ml") is set. This is
 * not enabled, by default, because of the security implications involved.
 *
 * Revision 3.44  88/11/01  21:34:11  tony
 * Fixed a couple of minor points for Minix, and improved the speed of
 * the 'put' command dramatically.
 *
 * Revision 3.43  88/10/31  13:11:33  tony
 * Added optional support for termcap. Initialization is done in term.c
 * and also affects the system-dependent files. To enable termcap in those
 * environments that support it, define the symbol "TERMCAP" in env.h
 *
 * Revision 3.42  88/10/27  18:30:19  tony
 * Removed support for Megamax. Added '%' as an alias for '1,$'. Made the
 * 'r' command more robust. Now prints the string on repeated searches.
 * The ':=" command now works. Some pointer operations are now safer.
 * The ":!" and ":sh" now work correctly. Re-organized the help screens
 * a little.
 *
 * Revision 3.41  88/10/06  10:15:00  tony
 * Fixed a bug involving ^Y that occurs when the cursor is on the last
 * line, and the line above the screen is long. Also hacked up fileio.c
 * to pass pathnames off to fixname() for system-dependent processing.
 * Used under DOS & OS/2 to trim parts of the name appropriately.
 *
 * Revision 3.40  88/09/16  08:37:36  tony
 * No longer beeps when repeated searches fail.
 *
 * Revision 3.39  88/09/06  06:51:07  tony
 * Fixed a bug with shifts that was introduced when replace mode was added.
 *
 * Revision 3.38  88/08/31  20:48:28  tony
 * Made another fix in search.c related to repeated searches.
 *
 * Revision 3.37  88/08/30  20:37:16  tony
 * After much prodding from Mark, I finally added support for replace mode.
 *
 * Revision 3.36  88/08/26  13:46:34  tony
 * Added support for the '!' (filter) operator.
 *
 * Revision 3.35  88/08/26  08:46:01  tony
 * Misc. changes to make lint happy.
 *
 * Revision 3.34  88/08/25  15:13:36  tony
 * Fixed a bug where the cursor didn't land on the right place after
 * "beginning-of-word" searches if the word was preceded by the start
 * of the line and a single character.
 *
 * Revision 3.33  88/08/23  12:53:08  tony
 * Fixed a bug in ssearch() where repeated searches ('n' or 'N') resulted
 * in dynamic memory being referenced after it was freed.
 *
 * Revision 3.32  88/08/17  07:37:07  tony
 * Fixed a general problem in u_save() by checking both parameters for
 * null values. The specific symptom was that a join on the last line of
 * the file would crash the editor.
 *
 * Revision 3.31  88/07/09  20:39:38  tony
 * Implemented the "line undo" command (i.e. 'U').
 *
 * Revision 3.30  88/06/28  07:54:22  tony
 * Fixed a bug involving redo's of the '~' command. The redo would just
 * repeat the replacement last performed instead of switching the case of
 * the current character.
 *
 * Revision 3.29  88/06/26  14:53:19  tony
 * Added support for a simple form of the "global" command. It supports
 * commands of the form "g/pat/d" or "g/pat/p", to delete or print lines
 * that match the given pattern. A range spec may be used to limit the
 * lines to be searched.
 *
 * Revision 3.28  88/06/25  21:44:22  tony
 * Fixed a problem in the processing of colon commands that caused
 * substitutions of patterns containing white space to fail.
 *
 * Revision 3.27  88/06/20  14:52:21  tony
 * Merged in changes for BSD Unix sent in by Michael Lichter.
 *
 * Revision 3.26  88/06/10  13:44:06  tony
 * Fixed a bug involving writing out files with long pathnames. A small
 * fixed size buffer was being used. The space for the backup file name
 * is now allocated dynamically.
 *
 * Revision 3.25  88/05/04  08:29:02  tony
 * Fixed a minor incompatibility with vi involving the 'G' command. Also
 * changed the RCS version number of version.c to match the actual version
 * of the editor.
 *
 * Revision 1.12  88/05/03  14:39:52  tony
 * Changed the screen representation of the ascii character DELETE to be
 * compatible with vi. Also merged in support for DOS.
 *
 * Revision 1.11  88/05/02  21:38:21  tony
 * The code that reads files now handles boundary/error conditions much
 * better, and generates status/error messages that are compatible with
 * the real vi. Also fixed a bug in repeated reverse searches that got
 * inserted in the recent changes to search.c.
 *
 * Revision 1.10  88/05/02  07:35:41  tony
 * Fixed a bug in the routine plines() that was introduced during changes
 * made for the last version.
 *
 * Revision 1.9  88/05/01  20:10:19  tony
 * Fixed some problems with auto-indent, and added support for the "number"
 * parameter.
 *
 * Revision 1.8  88/04/30  20:00:49  tony
 * Added support for the auto-indent feature.
 *
 * Revision 1.7  88/04/29  14:50:11  tony
 * Fixed a class of bugs involving commands like "ct)" where the cursor
 * motion part of the operator can fail. If the motion failed, the operator
 * was continued, with the cursor position unchanged. Cases like this were
 * modified to abort the operation if the motion fails.
 *
 * Revision 1.6  88/04/28  08:19:35  tony
 * Modified Henry Spencer's regular expression library to support new
 * features that couldn't be done easily with the existing interface.
 * This code is now a direct part of the editor source code. The editor
 * now supports the "ignorecase" parameter, and multiple substitutions
 * per line, as in "1,$s/foo/bar/g".
 *
 * Revision 1.5  88/04/24  21:38:00  tony
 * Added preliminary support for the substitute command. Full range specs.
 * are supported, but only a single substitution is allowed on each line.
 *
 * Revision 1.4  88/04/23  20:41:01  tony
 * Worked around a problem with adding lines to the end of the buffer when
 * the cursor is at the bottom of the screen (in misccmds.c). Also fixed a
 * bug that caused reverse searches from the start of the file to bomb.
 *
 * Revision 1.3  88/03/24  08:57:00  tony
 * Fixed a bug in cmdline() that had to do with backspacing out of colon
 * commands or searches. Searches were okay, but colon commands backed out
 * one backspace too early.
 *
 * Revision 1.2  88/03/21  16:47:55  tony
 * Fixed a bug in renum() causing problems with large files (>6400 lines).
 * Also moved system-specific defines out of stevie.h and into a new file
 * named env.h. This keeps volatile information outside the scope of RCS.
 *
 * Revision 1.1  88/03/20  21:00:39  tony
 * Initial revision
 *
 */

char    *Version = "NT VI - Version 0.23";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vi\vi.c ===
/* $Header: /nw/tony/src/stevie/src/RCS/main.c,v 1.12 89/08/02 19:53:27 tony Exp $
 *
 * The main routine and routines to deal with the input buffer.
 */

#include "stevie.h"

int Rows;               /* Number of Rows and Columns */
int Columns;            /* in the current window. */

char INITFILENAME[] = "ntvi.ini";   /* file that's source'd at startup */

char *Realscreen = NULL;        /* What's currently on the screen, a single */
                                /* array of size Rows*Columns. */
char *Nextscreen = NULL;        /* What's to be put on the screen. */

char *Filename = NULL;  /* Current file name */

char *Appname = NULL;   /* Name of program (vi, for instance) */

LNPTR *Filemem;      /* Pointer to the first line of the file */

LNPTR *Filetop;      /* Line 'above' the start of the file */

LNPTR *Fileend;      /* Pointer to the end of the file in Filemem. */
                     /* (It points to the byte AFTER the last byte.) */

LNPTR *Topchar;      /* Pointer to the byte in Filemem which is */
                        /* in the upper left corner of the screen. */

LNPTR *Botchar;      /* Pointer to the byte in Filemem which is */
                        /* just off the bottom of the screen. */

LNPTR *Curschar;     /* Pointer to byte in Filemem at which the */
                        /* cursor is currently placed. */

int Cursrow, Curscol;   /* Current position of cursor */

int Cursvcol;           /* Current virtual column, the column number of */
                        /* the file's actual line, as opposed to the */
                        /* column number we're at on the screen.  This */
                        /* makes a difference on lines that span more */
                        /* than one screen line. */

int Curswant = 0;       /* The column we'd like to be at. This is used */
                        /* try to stay in the same column through up/down */
                        /* cursor motions. */

bool_t set_want_col;    /* If set, then update Curswant the next time */
                        /* through cursupdate() to the current virtual */
                        /* column. */

int State = NORMAL;     /* This is the current state of the command */
                        /* interpreter. */

int Prenum = 0;         /* The (optional) number before a command. */
int namedbuff = -1;     /* the (optional) named buffer before a command */

LNPTR *Insstart;     /* This is where the latest insert/append */
                        /* mode started. */

bool_t Changed = 0;     /* Set to 1 if something in the file has been */
                        /* changed and not written out. */

char *Redobuff;         /* Each command should stuff characters into this */
                        /* buffer that will re-execute itself. */

char *Insbuff;          /* Each insertion gets stuffed into this buffer. */
int   InsbuffSize;

int Ninsert = 0;        /* Number of characters in the current insertion. */
char *Insptr = NULL;

bool_t  got_int=FALSE;  /* set to TRUE when an interrupt occurs (if possible) */

bool_t  interactive = FALSE;    /* set TRUE when main() is ready to roll */

char **files;           /* list of input files */
int  numfiles;          /* number of input files */
int  curfile;           /* number of the current file */

static char *getcbuff;
static char *getcnext = NULL;

static void chk_mline();

static void
usage()
{
        fprintf(stderr, "usage: stevie [file ...]\n");
        fprintf(stderr, "       stevie -t tag\n");
        fprintf(stderr, "       stevie +[num] file\n");
        fprintf(stderr, "       stevie +/pat  file\n");
        exit(1);
}

__cdecl main(argc,argv)
int     argc;
char    *argv[];
{
        char    *initstr;               /* init string from the environment */
        char    *tag = NULL;            /* tag from command line */
        char    *pat = NULL;            /* pattern from command line */
        int     line = -1;              /* line number from command line */
        char    *p1, *p2;

        p1 = strrchr(argv[0], '\\');
        if (!p1)
            p1 = strrchr(argv[0], ':');
        if (p1)
            p1++;
        else
            p1 = argv[0];
        p2 = strrchr(p1, '.');
        if (!p2)
            Appname = strsave(p1);
        else {
            Appname = malloc((size_t)(p2-p1+1));
            strncpy(Appname, p1, (size_t)(p2-p1));
            Appname[p2-p1] = '\0';
        }

        /*
         * Process the command line arguments.
         */
        if (argc > 1) {
                switch (argv[1][0]) {

                case '-':                       /* -t tag */
                        if (argv[1][1] != 't')
                                usage();

                        if (argv[2] == NULL)
                                usage();

                        Filename = NULL;
                        tag = argv[2];
                        numfiles = 1;
                        break;

                case '+':                       /* +n or +/pat */
                        if (argv[1][1] == '/') {
                                if (argv[2] == NULL)
                                        usage();
                                Filename = strsave(argv[2]);
                                pat = &(argv[1][1]);
                                numfiles = 1;

                        } else if (isdigit(argv[1][1]) || argv[1][1] == NUL) {
                                if (argv[2] == NULL)
                                        usage();
                                Filename = strsave(argv[2]);
                                numfiles = 1;

                                line = (isdigit(argv[1][1])) ?
                                        atoi(&(argv[1][1])) : 0;
                        } else
                                usage();

                        break;

                default:                        /* must be a file name */
                        Filename = strsave(argv[1]);
                        files = &(argv[1]);
                        numfiles = argc - 1;
                        break;
                }
        } else {
                Filename = NULL;
                numfiles = 1;
        }
        curfile = 0;

        if (numfiles > 1)
                fprintf(stderr, "%d files to edit\n", numfiles);

        windinit();

        /*
         * Allocate LNPTR structures for all the various position pointers
         */
    if ((Filemem = (LNPTR *) malloc(sizeof(LNPTR))) == NULL ||
        (Filetop = (LNPTR *) malloc(sizeof(LNPTR))) == NULL ||
        (Fileend = (LNPTR *) malloc(sizeof(LNPTR))) == NULL ||
        (Topchar = (LNPTR *) malloc(sizeof(LNPTR))) == NULL ||
        (Botchar = (LNPTR *) malloc(sizeof(LNPTR))) == NULL ||
        (Curschar = (LNPTR *) malloc(sizeof(LNPTR))) == NULL ||
        (Insstart = (LNPTR *) malloc(sizeof(LNPTR))) == NULL ) {
                fprintf(stderr, "Can't allocate data structures\n");
                windexit(0);
        }

        screenalloc();
        filealloc();            /* Initialize Filemem, Filetop, and Fileend */
        inityank();

        getcbuff = malloc(1);
        if(((getcbuff = malloc(1          )) == NULL)
        || ((Redobuff = malloc(REDOBUFFMIN)) == NULL)
        || ((Insbuff  = malloc(INSERTSLOP )) == NULL))
        {
            fprintf(stderr,"Can't allocate buffers\n");
            windexit(1);
        }
        *getcbuff = 0;
        InsbuffSize = INSERTSLOP;

        screenclear();


        {
            char     *srcinitname,*initvar;
            bool_t   unmalloc;
            unsigned x;

            if((initvar = getenv("INIT")) == NULL) {
                srcinitname = INITFILENAME;
                unmalloc = FALSE;
            } else {
                srcinitname = malloc((x = strlen(initvar))+strlen(INITFILENAME)+2);
                if(srcinitname == NULL) {
                    fprintf(stderr,"Can't allocate initial source buffer\n");
                    windexit(1);
                }
                unmalloc = TRUE;
                strcpy(srcinitname,initvar);
                if(srcinitname[x-1] != '\\') {      // not NLS-aware!!
                    srcinitname[x] = '\\';
                    srcinitname[x+1]   = '\0';
                }
                strcat(srcinitname,INITFILENAME);
            }
            dosource(srcinitname,FALSE);
            if(unmalloc) {
                free(srcinitname);
            }
        }


        if ((initstr = getenv("EXINIT")) != NULL) {
                char *lp, buf[128];

                if ((lp = getenv("LINES")) != NULL) {
                        sprintf(buf, "%s lines=%s", initstr, lp);
                        docmdln(buf);
                } else
                        docmdln(initstr);
        }

        if (Filename != NULL) {
                if (readfile(Filename, Filemem, FALSE))
                        filemess("[New File]");
        } else if (tag == NULL)
                msg("Empty Buffer");

        setpcmark();

        if (tag) {
                stuffin(":ta ");
                stuffin(tag);
                stuffin("\n");

        } else if (pat) {
                stuffin(pat);
                stuffin("\n");

        } else if (line >= 0) {
                if (line > 0)
                        stuffnum(line);
                stuffin("G");
        }

        interactive = TRUE;

        edit();

        windexit(0);

        return 1;               /* shouldn't be reached */
}

void
stuffin(s)
char    *s;
{
        char *p;

        if (s == NULL) {                /* clear the stuff buffer */
                getcnext = NULL;
                return;
        }

        if (getcnext == NULL) {
                p = ralloc(getcbuff,strlen(s)+1);
                if(p) {
                    getcbuff = p;
                    strcpy(getcbuff,s);
                    getcnext = getcbuff;
                } else {
                    getcnext = NULL;
                }
        } else {
                p = ralloc(getcbuff,strlen(getcbuff)+strlen(s)+1);
                if(p) {
                    getcnext += p - getcbuff;
                    getcbuff = p;
                    strcat(getcbuff,s);
                } else {
                    getcnext = NULL;
                }
        }
}

void
stuffnum(n)
int     n;
{
        char    buf[32];

        sprintf(buf, "%d", n);
        stuffin(buf);
}

int
vgetc()
{
        register int    c;

        /*
         * inchar() may map special keys by using stuffin(). If it does
         * so, it returns -1 so we know to loop here to get a real char.
         */
        do {
                if ( getcnext != NULL ) {
                        int nextc = *getcnext++;
                        if ( *getcnext == NUL ) {
                                *getcbuff = NUL;
                                getcnext = NULL;
                        }
                        return(nextc);
                }
                c = inchar();
        } while (c == -1);

        return c;
}

/*
 * anyinput
 *
 * Return non-zero if input is pending.
 */

bool_t
anyinput()
{
        return (getcnext != NULL);
}

/*
 * do_mlines() - process mode lines for the current file
 *
 * Returns immediately if the "ml" parameter isn't set.
 */
#define NMLINES 5       /* no. of lines at start/end to check for modelines */

void
do_mlines()
{
        int     i;
    register LNPTR   *p;

        if (!P(P_ML))
                return;

        p = Filemem;
        for (i=0; i < NMLINES ;i++) {
                chk_mline(p->linep->s);
                if ((p = nextline(p)) == NULL)
                        break;
        }

        if ((p = prevline(Fileend)) == NULL)
                return;

        for (i=0; i < NMLINES ;i++) {
                chk_mline(p->linep->s);
                if ((p = prevline(p)) == NULL)
                        break;
        }
}

/*
 * chk_mline() - check a single line for a mode string
 */
static void
chk_mline(s)
register char   *s;
{
        register char   *cs;            /* local copy of any modeline found */
        register char   *e;

        for (; *s != NUL ;s++) {
                if (strncmp(s, "vi:", 3) == 0 || strncmp(s, "ex:", 3) == 0) {
                        cs = strsave(s+3);
                        if ((e = strchr(cs, ':')) != NULL) {
                                *e = NUL;
                                stuffin(mkstr(CTRL('o')));
                                docmdln(cs);
                        }
                        free(cs);
                }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmmreg32\regdblk.c ===
//
//  REGDBLK.C
//
//  Copyright (C) Microsoft Corporation, 1995
//

#include "pch.h"

DECLARE_DEBUG_COUNT(g_RgDatablockLockCount);

//  Don't let a FREE_RECORD shrink less than this value.
#define MINIMUM_FREE_RECORD_LENGTH  (sizeof(KEY_RECORD) + sizeof(VALUE_RECORD))

//
//  RgAllocDatablockInfoBuffers
//
//  Allocates the buffers associated with a DATABLOCK_INFO structure.  The
//  size of the datablock buffer is determined by the BlockSize member.
//

int
INTERNAL
RgAllocDatablockInfoBuffers(
                           LPDATABLOCK_INFO lpDatablockInfo
                           )
{

    lpDatablockInfo-> lpDatablockHeader = (LPDATABLOCK_HEADER)
                                          RgAllocMemory(lpDatablockInfo-> BlockSize);

    if (!IsNullPtr(lpDatablockInfo-> lpDatablockHeader)) {

        lpDatablockInfo-> lpKeyRecordTable = (LPKEY_RECORD_TABLE_ENTRY)
                                             RgSmAllocMemory(sizeof(KEY_RECORD_TABLE_ENTRY) *
                                                             KEY_RECORDS_PER_DATABLOCK);

        if (!IsNullPtr(lpDatablockInfo-> lpKeyRecordTable))
            return ERROR_SUCCESS;

        RgFreeDatablockInfoBuffers(lpDatablockInfo);

    }

    return ERROR_OUTOFMEMORY;

}

//
//  RgFreeDatablockInfoBuffers
//
//  Frees the buffers associated with a DATABLOCK_INFO structure.
//

VOID
INTERNAL
RgFreeDatablockInfoBuffers(
                          LPDATABLOCK_INFO lpDatablockInfo
                          )
{

    if (!IsNullPtr(lpDatablockInfo-> lpDatablockHeader)) {
        RgFreeMemory(lpDatablockInfo-> lpDatablockHeader);
        lpDatablockInfo-> lpDatablockHeader = NULL;
    }

    if (!IsNullPtr(lpDatablockInfo-> lpKeyRecordTable)) {
        RgSmFreeMemory(lpDatablockInfo-> lpKeyRecordTable);
        lpDatablockInfo-> lpKeyRecordTable = NULL;
    }

}

//
//  RgBuildKeyRecordTable
//
//  Builds a KEY_RECORD index table for the given datablock.
//
//  A datablock consists of a header followed by a series of variable-sized
//  KEY_RECORDs, each with a unique id.  To make lookups fast, an index table is
//  used to map from the unique id to that KEY_RECORD's location.
//
//  As we walk over each KEY_RECORD, we do checks to validate the structure of
//  the datablock, so the error code should be checked for corruption.
//

int
INTERNAL
RgBuildKeyRecordTable(
                     LPDATABLOCK_INFO lpDatablockInfo
                     )
{

    LPDATABLOCK_HEADER lpDatablockHeader;
    UINT Offset;
    UINT BytesRemaining;
    LPKEY_RECORD lpKeyRecord;
    DWORD DatablockAddress;

    ZeroMemory(lpDatablockInfo-> lpKeyRecordTable,
               sizeof(KEY_RECORD_TABLE_ENTRY) * KEY_RECORDS_PER_DATABLOCK);

    lpDatablockHeader = lpDatablockInfo-> lpDatablockHeader;
    Offset = sizeof(DATABLOCK_HEADER);
    BytesRemaining = lpDatablockInfo-> BlockSize - sizeof(DATABLOCK_HEADER);

    while (BytesRemaining) {

        lpKeyRecord = (LPKEY_RECORD) ((LPBYTE) lpDatablockHeader + Offset);
        DatablockAddress = lpKeyRecord-> DatablockAddress;

        if ((lpKeyRecord-> AllocatedSize == 0) || (lpKeyRecord-> AllocatedSize >
                                                   BytesRemaining) || ((DatablockAddress != REG_NULL) &&
                                                                       (LOWORD(DatablockAddress) >= KEY_RECORDS_PER_DATABLOCK))) {

            TRACE(("RgBuildKeyRecordTable: invalid key record detected\n"));

            TRACE(("lpdh=%x\n", lpDatablockHeader));
            TRACE(("lpkr=%x\n", lpKeyRecord));
            TRACE(("as=%x\n", lpKeyRecord-> AllocatedSize));
            TRACE(("br=%x\n", BytesRemaining));
            TRACE(("dba=%x\n", DatablockAddress));
            TRAP();

            return ERROR_BADDB;

        }

        if (DatablockAddress != REG_NULL) {
            lpDatablockInfo-> lpKeyRecordTable[LOWORD(DatablockAddress)] =
            (KEY_RECORD_TABLE_ENTRY) Offset;
        }

        Offset += SmallDword(lpKeyRecord-> AllocatedSize);
        BytesRemaining -= SmallDword(lpKeyRecord-> AllocatedSize);

    }

    return ERROR_SUCCESS;

}

//
//  RgLockDatablock
//
//  Locks the specified datablock in memory, indicating that it is about to be
//  used.  If the datablock is not currently in memory, then it is brought in.
//  Unlocked datablocks are freed as necessary to make room for this new
//  datablock.
//
//  IMPORTANT:  Locking a datablock only means that it's guaranteed to be kept
//  in memory.  It does not mean that pointers contained in a DATABLOCK_INFO
//  structure will remain the same: routines that could change the
//  DATABLOCK_INFO pointers are labeled "IMPORTANT" as well.
//
//  lpFileInfo, registry file containing the datablock.
//  BlockIndex, index of the datablock.
//

int
INTERNAL
RgLockDatablock(
               LPFILE_INFO lpFileInfo,
               UINT BlockIndex
               )
{

    int ErrorCode;
    LPDATABLOCK_INFO lpDatablockInfo;
    HFILE hFile = HFILE_ERROR;

    if (BlockIndex >= lpFileInfo-> FileHeader.BlockCount) {
        TRACE(("RgLockDatablock: invalid datablock number\n"));
        return ERROR_BADDB;
    }

    lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockIndex);

    //
    //  Is the datablock currently in memory?
    //

    if (!(lpDatablockInfo-> Flags & DIF_PRESENT)) {

        NOISE(("RgLockDatablock: "));
        NOISE((lpFileInfo-> FileName));
        NOISE((", block %d\n", BlockIndex));

        ASSERT(lpDatablockInfo-> FileOffset != -1);

        if ((ErrorCode = RgAllocDatablockInfoBuffers(lpDatablockInfo)) !=
            ERROR_SUCCESS)
            goto CleanupAfterError;

        NOISE(("    lpDatablockHeader=%x\n", lpDatablockInfo-> lpDatablockHeader));
        NOISE(("    lpKeyRecordTable=%x\n", lpDatablockInfo-> lpKeyRecordTable));

        if ((hFile = RgOpenFile(lpFileInfo-> FileName, OF_READ)) == HFILE_ERROR)
            goto CleanupAfterFileError;

        if (!RgSeekFile(hFile, lpDatablockInfo-> FileOffset))
            goto CleanupAfterFileError;

        if (!RgReadFile(hFile, lpDatablockInfo-> lpDatablockHeader,
                        (UINT) lpDatablockInfo-> BlockSize))
            goto CleanupAfterFileError;

        if (!RgIsValidDatablockHeader(lpDatablockInfo-> lpDatablockHeader)) {
            ErrorCode = ERROR_BADDB;
            goto CleanupAfterError;
        }

        if ((ErrorCode = RgBuildKeyRecordTable(lpDatablockInfo)) !=
            ERROR_SUCCESS)
            goto CleanupAfterError;

        RgCloseFile(hFile);

    }

    lpDatablockInfo-> Flags |= (DIF_ACCESSED | DIF_PRESENT);
    lpDatablockInfo-> LockCount++;

    INCREMENT_DEBUG_COUNT(g_RgDatablockLockCount);
    return ERROR_SUCCESS;

    CleanupAfterFileError:
    ErrorCode = ERROR_REGISTRY_IO_FAILED;

    CleanupAfterError:
    if (hFile != HFILE_ERROR)
        RgCloseFile(hFile);

    RgFreeDatablockInfoBuffers(lpDatablockInfo);

    DEBUG_OUT(("RgLockDatablock() returning error %d\n", ErrorCode));
    return ErrorCode;

}

//
//  RgUnlockDatablock
//
//  Unlocks the datablock, indicating that the datablock is no longer in active
//  use.  After a datablock has been unlocked, the datablock may be freed after
//  flushing to disk if dirty.
//

VOID
INTERNAL
RgUnlockDatablock(
                 LPFILE_INFO lpFileInfo,
                 UINT BlockIndex,
                 BOOL fMarkDirty
                 )
{

    LPDATABLOCK_INFO lpDatablockInfo;

    ASSERT(BlockIndex < lpFileInfo-> FileHeader.BlockCount);

    lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockIndex);

    ASSERT(lpDatablockInfo-> LockCount > 0);
    lpDatablockInfo-> LockCount--;

    if (fMarkDirty) {
        lpDatablockInfo-> Flags |= DIF_DIRTY;
        lpFileInfo-> Flags |= FI_DIRTY;
        RgDelayFlush();
    }

    DECREMENT_DEBUG_COUNT(g_RgDatablockLockCount);

}

//
//  RgLockKeyRecord
//
//  Wraps RgLockDatablock, returning the address of the specified KEY_RECORD
//  structure.
//

int
INTERNAL
RgLockKeyRecord(
               LPFILE_INFO lpFileInfo,
               UINT BlockIndex,
               BYTE KeyRecordIndex,
               LPKEY_RECORD FAR* lplpKeyRecord
               )
{

    int ErrorCode;
    LPDATABLOCK_INFO lpDatablockInfo;

    if ((ErrorCode = RgLockDatablock(lpFileInfo, BlockIndex)) ==
        ERROR_SUCCESS) {

        lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockIndex);

        if (IsNullKeyRecordTableEntry(lpDatablockInfo->
                                      lpKeyRecordTable[KeyRecordIndex])) {
            RgUnlockDatablock(lpFileInfo, BlockIndex, FALSE);
            TRACE(("RgLockKeyRecord: invalid datablock address %x:%x\n",
                   BlockIndex, KeyRecordIndex));
            ErrorCode = ERROR_BADDB;
        }

        else {
            *lplpKeyRecord = RgIndexKeyRecordPtr(lpDatablockInfo,
                                                 KeyRecordIndex);
        }

    }

    return ErrorCode;

}

//
//  RgCompactDatablock
//
//  Compacts the datablock by pushing all KEY_RECORDS together and leaving a
//  single FREEKEY_RECORD at the end.
//
//  The datablock must be marked dirty by the caller, if desired.
//
//  Returns TRUE if any action was taken.
//

BOOL
INTERNAL
RgCompactDatablock(
                  LPDATABLOCK_INFO lpDatablockInfo
                  )
{

    LPDATABLOCK_HEADER lpDatablockHeader;
    LPFREEKEY_RECORD lpFreeKeyRecord;
    LPBYTE lpSource;
    LPBYTE lpDestination;
    UINT Offset;
    UINT BlockSize;
    UINT BytesToPushDown;

    lpDatablockHeader = lpDatablockInfo-> lpDatablockHeader;

    //  Only need to compact if there's a free record in this datablock.
    if (lpDatablockHeader-> FirstFreeOffset == REG_NULL)
        return FALSE;

    lpFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpDatablockHeader +
                                          SmallDword(lpDatablockHeader-> FirstFreeOffset));

    //  Only need to compact if the all the free bytes aren't already at the end
    //  of the datablock (datablocks can't be greater than 64K-1, so no overflow
    //  is possible).
    if ((SmallDword(lpDatablockHeader-> FirstFreeOffset) +
         SmallDword(lpFreeKeyRecord-> AllocatedSize) >= lpDatablockInfo->
         BlockSize) && (lpFreeKeyRecord-> NextFreeOffset == REG_NULL))
        return FALSE;

    NOISE(("RgCompactDatablock: block %d\n", lpDatablockHeader-> BlockIndex));

    lpSource = NULL;
    lpDestination = NULL;
    Offset = sizeof(DATABLOCK_HEADER);
    BlockSize = lpDatablockInfo-> BlockSize;

    while (Offset < BlockSize) {

        //  Advance to the next free record or the end of the block.
        for (;;) {

            lpFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpDatablockHeader +
                                                  Offset);

            if (Offset >= BlockSize || IsKeyRecordFree(lpFreeKeyRecord)) {

                //
                //  If lpSource is valid, then we can push down the bytes from
                //  lpSource through lpFreeKeyRecord to lpDestination.
                //

                if (!IsNullPtr(lpSource)) {
                    BytesToPushDown = (LPBYTE) lpFreeKeyRecord -
                                      (LPBYTE) lpSource;
                    MoveMemory(lpDestination, lpSource, BytesToPushDown);
                    lpDestination += BytesToPushDown;
                }

                if (IsNullPtr(lpDestination))
                    lpDestination = (LPBYTE) lpFreeKeyRecord;

                break;

            }

            Offset += SmallDword(lpFreeKeyRecord-> AllocatedSize);

        }

        //  Advance to the next key record.
        while (Offset < BlockSize) {

            lpFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpDatablockHeader +
                                                  Offset);

            if (!IsKeyRecordFree(lpFreeKeyRecord)) {
                lpSource = (LPBYTE) lpFreeKeyRecord;
                break;
            }

            Offset += SmallDword(lpFreeKeyRecord-> AllocatedSize);

        }

    }

    //  lpDestination now points at the end of the datablock where the giant
    //  free record is to be placed.  Initialize this record and patch up the
    //  datablock header.
    lpDatablockHeader-> FirstFreeOffset = (LPBYTE) lpDestination -
                                          (LPBYTE) lpDatablockHeader;
    ((LPFREEKEY_RECORD) lpDestination)-> AllocatedSize = lpDatablockInfo->
                                                         FreeBytes;
    ((LPFREEKEY_RECORD) lpDestination)-> DatablockAddress = REG_NULL;
    ((LPFREEKEY_RECORD) lpDestination)-> NextFreeOffset = REG_NULL;

    //  The key record table is now invalid, so we must refresh its contents.
    RgBuildKeyRecordTable(lpDatablockInfo);

    return TRUE;

}

//
//  RgCreateDatablock
//
//  Creates a new datablock at the end of the file of the specified length (plus
//  padding to align the block).
//
//  The datablock is locked, so RgUnlockDatablock must be called on the last
//  datablock in the file.
//

int
INTERNAL
RgCreateDatablock(
                 LPFILE_INFO lpFileInfo,
                 UINT Length
                 )
{

    UINT BlockCount;
    LPDATABLOCK_INFO lpDatablockInfo;
    LPDATABLOCK_HEADER lpDatablockHeader;
    LPFREEKEY_RECORD lpFreeKeyRecord;

    BlockCount = lpFileInfo-> FileHeader.BlockCount;

    if (BlockCount >= DATABLOCKS_PER_FILE)
        return ERROR_OUTOFMEMORY;

    if (BlockCount >= lpFileInfo-> DatablockInfoAllocCount) {

        //  lpDatablockInfo is too small to hold the info for a new datablock,
        //  so we must grow it a bit.
        if (IsNullPtr((lpDatablockInfo = (LPDATABLOCK_INFO)
                       RgSmReAllocMemory(lpFileInfo-> lpDatablockInfo, (BlockCount +
                                                                        DATABLOCK_INFO_SLACK_ALLOC) * sizeof(DATABLOCK_INFO)))))
            return ERROR_OUTOFMEMORY;

        lpFileInfo-> lpDatablockInfo = lpDatablockInfo;
        lpFileInfo-> DatablockInfoAllocCount += DATABLOCK_INFO_SLACK_ALLOC;

    }

    lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockCount);

    Length = RgAlignBlockSize(Length + sizeof(DATABLOCK_HEADER));
    lpDatablockInfo-> BlockSize = Length;

    if (RgAllocDatablockInfoBuffers(lpDatablockInfo) != ERROR_SUCCESS)
        return ERROR_OUTOFMEMORY;

    lpDatablockInfo-> FreeBytes = Length - sizeof(DATABLOCK_HEADER);
    lpDatablockInfo-> FirstFreeIndex = 0;
    lpDatablockInfo-> FileOffset = -1;          //  Set during file flush
    lpDatablockInfo-> Flags = DIF_PRESENT | DIF_ACCESSED | DIF_DIRTY;
    lpDatablockInfo-> LockCount = 1;

    lpDatablockHeader = lpDatablockInfo-> lpDatablockHeader;
    lpDatablockHeader-> Signature = DH_SIGNATURE;
    lpDatablockHeader-> BlockSize = Length;
    lpDatablockHeader-> FreeBytes = lpDatablockInfo-> FreeBytes;
    lpDatablockHeader-> Flags = DHF_HASBLOCKNUMBERS;
    lpDatablockHeader-> BlockIndex = (WORD) BlockCount;
    lpDatablockHeader-> FirstFreeOffset = sizeof(DATABLOCK_HEADER);
    lpDatablockHeader-> MaxAllocatedIndex = 0;
    //  lpDatablockHeader-> FirstFreeIndex is copied back on the flush.
    //  lpDatablockHeader-> Reserved is worthless because it was randomly set
    //      to a pointer in the old code.

    lpFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpDatablockHeader +
                                          sizeof(DATABLOCK_HEADER));
    lpFreeKeyRecord-> AllocatedSize = lpDatablockInfo-> FreeBytes;
    lpFreeKeyRecord-> DatablockAddress = REG_NULL;
    lpFreeKeyRecord-> NextFreeOffset = REG_NULL;

    lpFileInfo-> FileHeader.BlockCount++;
    lpFileInfo-> FileHeader.Flags |= FHF_DIRTY;

    lpFileInfo-> Flags |= FI_DIRTY | FI_EXTENDED;
    RgDelayFlush();

    INCREMENT_DEBUG_COUNT(g_RgDatablockLockCount);

    //  We must initialize the key record table, so we might as well let
    //  RgBuildKeyRecordTable check the validity of what we just created...
    return RgBuildKeyRecordTable(lpDatablockInfo);

}

//
//  RgExtendDatablock
//
//  Extends the given datablock to the specified size.  If successful, then the
//  resulting datablock will be compacted with a single FREEKEY_RECORD at the
//  end of the datablock which will include the added space.
//

int
INTERNAL
RgExtendDatablock(
                 LPFILE_INFO lpFileInfo,
                 UINT BlockIndex,
                 UINT Length
                 )
{

    LPDATABLOCK_INFO lpDatablockInfo;
    DWORD NewBlockSize;
    LPDATABLOCK_HEADER lpNewDatablockHeader;
    LPFREEKEY_RECORD lpFreeKeyRecord;

    ASSERT(BlockIndex < lpFileInfo-> FileHeader.BlockCount);
    lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockIndex);
    ASSERT(lpDatablockInfo-> Flags & DIF_PRESENT);

    //  Check if enough free bytes already exist: if so, no need to extend.
    if (lpDatablockInfo-> FreeBytes >= Length) {
        DEBUG_OUT(("RgExtendDatablock: unexpectedly called\n"));
        return ERROR_SUCCESS;
    }

    NewBlockSize = RgAlignBlockSize(lpDatablockInfo-> BlockSize + Length -
                                    lpDatablockInfo-> FreeBytes);

    if (NewBlockSize > MAXIMUM_DATABLOCK_SIZE) {
        TRACE(("RgExtendDatablock: datablock too big\n"));
        return ERROR_OUTOFMEMORY;
    }

    NOISE(("RgExtendDatablock: block %d\n", BlockIndex));
    NOISE(("block size=%x, new block size=%x\n", lpDatablockInfo-> BlockSize,
           NewBlockSize));

    if (IsNullPtr((lpNewDatablockHeader = (LPDATABLOCK_HEADER)
                   RgReAllocMemory(lpDatablockInfo-> lpDatablockHeader, (UINT)
                                   NewBlockSize))))
        return ERROR_OUTOFMEMORY;

    lpDatablockInfo-> lpDatablockHeader = lpNewDatablockHeader;

    RgCompactDatablock(lpDatablockInfo);

    if (lpNewDatablockHeader-> FirstFreeOffset == REG_NULL) {
        lpNewDatablockHeader-> FirstFreeOffset = lpDatablockInfo-> BlockSize;
        lpFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpNewDatablockHeader +
                                              SmallDword(lpNewDatablockHeader-> FirstFreeOffset));
        lpFreeKeyRecord-> DatablockAddress = REG_NULL;
        lpFreeKeyRecord-> NextFreeOffset = REG_NULL;
    }

    else {
        lpFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpNewDatablockHeader +
                                              SmallDword(lpNewDatablockHeader-> FirstFreeOffset));
    }

    lpDatablockInfo-> FreeBytes += (UINT) NewBlockSize - lpDatablockInfo->
                                   BlockSize;
    lpFreeKeyRecord-> AllocatedSize = lpDatablockInfo-> FreeBytes;
    lpDatablockInfo-> BlockSize = (UINT) NewBlockSize;

    lpDatablockInfo-> Flags |= (DIF_DIRTY | DIF_EXTENDED);

    lpFileInfo-> Flags |= FI_DIRTY | FI_EXTENDED;
    RgDelayFlush();

    return ERROR_SUCCESS;

}

//
//  RgAllocKeyRecordFromDatablock
//
//  Creates an uninitialized KEY_RECORD of the desired size from the provided
//  datablock.  On exit, only AllocatedSize is valid.
//
//  The datablock referred to by lpDatablockInfo must have been locked to
//  guarantee that the its data is actually present.  The datablock is not
//  dirtied.
//
//  IMPORTANT:  Any datablock may be relocated as a result of calling this
//  routine.  All pointers to datablocks should be refetched.
//

int
INTERNAL
RgAllocKeyRecordFromDatablock(
                             LPFILE_INFO lpFileInfo,
                             UINT BlockIndex,
                             UINT Length,
                             LPKEY_RECORD FAR* lplpKeyRecord
                             )
{

    LPDATABLOCK_INFO lpDatablockInfo;
    LPDATABLOCK_HEADER lpDatablockHeader;
    LPFREEKEY_RECORD lpFreeKeyRecord;
    UINT AllocatedSize;
    LPFREEKEY_RECORD lpNewFreeKeyRecord;
    UINT ExtraBytes;

    ASSERT(BlockIndex < lpFileInfo-> FileHeader.BlockCount);
    lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockIndex);
    ASSERT(lpDatablockInfo-> Flags & DIF_PRESENT);

    if (Length > lpDatablockInfo-> FreeBytes)
        return ERROR_OUTOFMEMORY;

    RgCompactDatablock(lpDatablockInfo);

    lpDatablockHeader = lpDatablockInfo-> lpDatablockHeader;

    lpFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpDatablockHeader +
                                          SmallDword(lpDatablockHeader-> FirstFreeOffset));

    AllocatedSize = SmallDword(lpFreeKeyRecord-> AllocatedSize);

    if (Length > AllocatedSize) {
        TRACE(("RgAllocKeyRecordFromDatablock() detected corruption?\n"));
        return ERROR_OUTOFMEMORY;
    }

    ExtraBytes = AllocatedSize - Length;

    //
    //  If we were to break this FREEKEY_RECORD into two records, would the
    //  second chunk be too small?  If so, then don't do it.  Just give back
    //  the full allocated size to the caller.
    //

    if (ExtraBytes >= MINIMUM_FREE_RECORD_LENGTH) {

        lpNewFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpFreeKeyRecord +
                                                 Length);

        lpDatablockHeader-> FirstFreeOffset += Length;

        lpFreeKeyRecord-> AllocatedSize = Length;

        //  IMPORTANT:	Note that lpNewFreeKeyRecord and lpFreeKeyRecord may
        //  overlap so we have to be careful when changing these fields!
        lpNewFreeKeyRecord-> NextFreeOffset = lpFreeKeyRecord-> NextFreeOffset;
        lpNewFreeKeyRecord-> DatablockAddress = REG_NULL;
        lpNewFreeKeyRecord-> AllocatedSize = ExtraBytes;

    }

    else {

        Length = AllocatedSize;

        lpDatablockHeader-> FirstFreeOffset = lpFreeKeyRecord-> NextFreeOffset;

    }

    //  Adjust the number of free bytes in this datablock.  At this point,
    //  Length is equal to the size of the newly formed record.
    lpDatablockInfo-> FreeBytes -= Length;

    *lplpKeyRecord = (LPKEY_RECORD) lpFreeKeyRecord;
    return ERROR_SUCCESS;

}

//
//  RgAllocKeyRecordIndex
//
//  Allocates a key record index from the provided datablock.  If no indexs
//  are available in the datablock, then KEY_RECORDS_PER_DATABLOCK is returned.
//
//  The datablock referred to by lpDatablockInfo must have been locked to
//  guarantee that the its data is actually present.  The datablock is not
//  dirtied.
//

UINT
INTERNAL
RgAllocKeyRecordIndex(
                     LPDATABLOCK_INFO lpDatablockInfo
                     )
{

    LPDATABLOCK_HEADER lpDatablockHeader;
    UINT KeyRecordIndex;
    UINT NextFreeIndex;
    LPKEY_RECORD_TABLE_ENTRY lpKeyRecordTableEntry;

    lpDatablockHeader = lpDatablockInfo-> lpDatablockHeader;
    KeyRecordIndex = lpDatablockInfo-> FirstFreeIndex;
    NextFreeIndex = KeyRecordIndex + 1;

    ASSERT(KeyRecordIndex < KEY_RECORDS_PER_DATABLOCK);
    ASSERT(IsNullKeyRecordTableEntry(lpDatablockInfo->
                                     lpKeyRecordTable[KeyRecordIndex]));

    if (KeyRecordIndex > lpDatablockHeader-> MaxAllocatedIndex)
        lpDatablockHeader-> MaxAllocatedIndex = (WORD) KeyRecordIndex;

    else {

        //  Find the next free hole in the key record table or leave ourselves
        //  at the end of the table.
        for (lpKeyRecordTableEntry =
             &lpDatablockInfo-> lpKeyRecordTable[NextFreeIndex]; NextFreeIndex <=
            lpDatablockHeader-> MaxAllocatedIndex; NextFreeIndex++,
            lpKeyRecordTableEntry++) {
            if (IsNullKeyRecordTableEntry(*lpKeyRecordTableEntry))
                break;
        }

    }

    lpDatablockInfo-> FirstFreeIndex = NextFreeIndex;

    return KeyRecordIndex;

}

//
//  RgAllocKeyRecord
//
//
//  IMPORTANT:  Any datablock may be relocated as a result of calling this
//  routine.  All pointers to datablocks should be refetched.
//

int
INTERNAL
RgAllocKeyRecord(
                LPFILE_INFO lpFileInfo,
                UINT Length,
                LPKEY_RECORD FAR* lplpKeyRecord
                )
{

    BOOL fExtendDatablock;
    UINT BlockIndex;
    LPDATABLOCK_INFO lpDatablockInfo;
    UINT KeyRecordIndex;

    if (lpFileInfo-> FileHeader.BlockCount == 0)
        goto MakeNewDatablock;

    //
    //  Find a datablock that can satisfy the allocation request.  Two passes
    //  may be made over this routine-- during the second pass, datablocks may
    //  be extended.
    //

    fExtendDatablock = FALSE;

    DoSecondPass:
    BlockIndex = lpFileInfo-> FileHeader.BlockCount;
    //  We overindex by one, but this gets decremented at the start of the loop.
    lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockIndex);

    while (BlockIndex--) {

        lpDatablockInfo--;

        //  Are there any more ids available in this datablock?
        if (lpDatablockInfo-> FirstFreeIndex >= KEY_RECORDS_PER_DATABLOCK)
            continue;

        if (fExtendDatablock) {
            //  Can we grow this datablock without exceeding the maximum size?
            if ((DWORD) (lpDatablockInfo-> BlockSize - lpDatablockInfo->
                         FreeBytes) + Length > MAXIMUM_DATABLOCK_SIZE)
                continue;
        } else {
            //  Is there enough free space in this datablock for this record?
            if (Length > lpDatablockInfo-> FreeBytes)
                continue;
        }

        if (RgLockDatablock(lpFileInfo, BlockIndex) == ERROR_SUCCESS) {

            if (!fExtendDatablock || RgExtendDatablock(lpFileInfo, BlockIndex,
                                                       Length) == ERROR_SUCCESS) {

                if (RgAllocKeyRecordFromDatablock(lpFileInfo, BlockIndex,
                                                  Length, lplpKeyRecord) == ERROR_SUCCESS)
                    goto AllocatedKeyRecord;

            }

            RgUnlockDatablock(lpFileInfo, BlockIndex, FALSE);

        }

    }

    //  If we haven't already tried to extend some datablock, make another
    //  pass over the blocks to do so.
    if (!fExtendDatablock) {
        fExtendDatablock = TRUE;
        goto DoSecondPass;
    }

    //
    //  No datablock has enough space to satisfy the request, so attempt to
    //  create a new one at the end of the file.
    //

    MakeNewDatablock:
    if (RgCreateDatablock(lpFileInfo, Length) == ERROR_SUCCESS) {

        BlockIndex = lpFileInfo-> FileHeader.BlockCount - 1;
        lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockIndex);

        if (RgAllocKeyRecordFromDatablock(lpFileInfo, BlockIndex, Length,
                                          lplpKeyRecord) == ERROR_SUCCESS) {

            AllocatedKeyRecord:
            KeyRecordIndex = RgAllocKeyRecordIndex(lpDatablockInfo);
            (*lplpKeyRecord)-> DatablockAddress = MAKELONG(KeyRecordIndex,
                                                           BlockIndex);
            lpDatablockInfo-> lpKeyRecordTable[KeyRecordIndex] =
            (KEY_RECORD_TABLE_ENTRY) ((LPBYTE) (*lplpKeyRecord) -
                                      (LPBYTE) lpDatablockInfo-> lpDatablockHeader);
            return ERROR_SUCCESS;

        }

        RgUnlockDatablock(lpFileInfo, BlockIndex, FALSE);

    }

    return ERROR_OUTOFMEMORY;

}

//
//  RgExtendKeyRecord
//
//  Attempts to extend the given KEY_RECORD by combining it with an adjacent
//  FREE_RECORD.
//
//  The datablock referred to by lpDatablockInfo must have been locked to
//  guarantee that the its data is actually present.  The datablock is not
//  dirtied.
//
//  Returns ERROR_SUCCESS if the KEY_RECORD could be extended, else
//  ERROR_OUTOFMEMORY.
//

int
INTERNAL
RgExtendKeyRecord(
                 LPFILE_INFO lpFileInfo,
                 UINT BlockIndex,
                 UINT Length,
                 LPKEY_RECORD lpKeyRecord
                 )
{

    LPDATABLOCK_INFO lpDatablockInfo;
    LPDATABLOCK_HEADER lpDatablockHeader;
    LPFREEKEY_RECORD lpFreeKeyRecord;
    UINT AllocatedSize;
    UINT FreeSizeAllocation;
    UINT ExtraBytes;
    LPFREEKEY_RECORD lpTempFreeKeyRecord;
    DWORD NewFreeOffset;                    //  May be REG_NULL
    UINT FreeOffset;
    DWORD Offset;                           //  May be REG_NULL

    ASSERT(BlockIndex < lpFileInfo-> FileHeader.BlockCount);

    lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockIndex);
    lpDatablockHeader = lpDatablockInfo-> lpDatablockHeader;

    AllocatedSize = SmallDword(lpKeyRecord-> AllocatedSize);

    lpFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpKeyRecord +
                                          AllocatedSize);
    FreeOffset = (LPBYTE) lpFreeKeyRecord - (LPBYTE) lpDatablockHeader;

    //  Check if this key record is at the very end of the datablock and that
    //  lpFreeKeyRecord is really a free key record.
    if (FreeOffset >= lpDatablockInfo-> BlockSize ||
        !IsKeyRecordFree(lpFreeKeyRecord))
        return ERROR_OUTOFMEMORY;

    ASSERT(Length >= AllocatedSize);
    FreeSizeAllocation = Length - AllocatedSize;

    AllocatedSize = SmallDword(lpFreeKeyRecord-> AllocatedSize);

    if (FreeSizeAllocation > AllocatedSize)
        return ERROR_OUTOFMEMORY;

    ExtraBytes = AllocatedSize - FreeSizeAllocation;

    //
    //  If we were to break this FREEKEY_RECORD into two records, would the
    //  second chunk be too small?  If so, then don't do it.  Just give back
    //  the full allocated size to the caller.
    //

    if (ExtraBytes >= MINIMUM_FREE_RECORD_LENGTH) {

        NewFreeOffset = FreeOffset + FreeSizeAllocation;
        lpTempFreeKeyRecord = (LPFREEKEY_RECORD) ((LPBYTE) lpFreeKeyRecord +
                                                  FreeSizeAllocation);

        //  IMPORTANT:	Note that lpNewFreeKeyRecord and lpFreeKeyRecord may
        //  overlap so we have to be careful when changing these fields!
        lpTempFreeKeyRecord-> NextFreeOffset = lpFreeKeyRecord-> NextFreeOffset;
        lpTempFreeKeyRecord-> DatablockAddress = REG_NULL;
        lpTempFreeKeyRecord-> AllocatedSize = ExtraBytes;

    }

    else {

        NewFreeOffset = lpFreeKeyRecord-> NextFreeOffset;

        //  The key record's allocated length will also include all of the extra
        //  bytes.
        FreeSizeAllocation += ExtraBytes;

    }

    lpKeyRecord-> AllocatedSize += FreeSizeAllocation;
    lpDatablockInfo-> FreeBytes -= FreeSizeAllocation;

    //
    //  Unlink the free record that we just extended into and possibly link in
    //  the new FREEKEY_RECORD if a split occurred.
    //

    Offset = lpDatablockHeader-> FirstFreeOffset;

    if (Offset == FreeOffset) {
        lpDatablockHeader-> FirstFreeOffset = NewFreeOffset;
    }

    else {

        while (Offset != REG_NULL) {

            lpTempFreeKeyRecord =
            (LPFREEKEY_RECORD) ((LPBYTE) lpDatablockHeader +
                                SmallDword(Offset));

            Offset = lpTempFreeKeyRecord-> NextFreeOffset;

            if (Offset == FreeOffset) {
                lpTempFreeKeyRecord-> NextFreeOffset = NewFreeOffset;
                break;
            }

        }

    }

    return ERROR_SUCCESS;

}

//
//  RgFreeKeyRecord
//
//  The datablock referred to by lpDatablockInfo must have been locked to
//  guarantee that the its data is actually present.  The datablock is not
//  dirtied.
//

VOID
INTERNAL
RgFreeKeyRecord(
               LPDATABLOCK_INFO lpDatablockInfo,
               LPKEY_RECORD lpKeyRecord
               )
{

    LPDATABLOCK_HEADER lpDatablockHeader;

    lpDatablockHeader = lpDatablockInfo-> lpDatablockHeader;

    ((LPFREEKEY_RECORD) lpKeyRecord)-> DatablockAddress = REG_NULL;
    ((LPFREEKEY_RECORD) lpKeyRecord)-> NextFreeOffset = lpDatablockHeader->
                                                        FirstFreeOffset;
    lpDatablockHeader-> FirstFreeOffset = (LPBYTE) lpKeyRecord - (LPBYTE)
                                          lpDatablockHeader;
    lpDatablockInfo-> FreeBytes += SmallDword(((LPFREEKEY_RECORD) lpKeyRecord)->
                                              AllocatedSize);

}

//
//  RgFreeKeyRecordIndex
//
//  The datablock referred to by lpDatablockInfo must have been locked to
//  guarantee that the its data is actually present.  The datablock is not
//  dirtied.
//
//  We don't bother updated MaxAllocatedIndex because it's only really useful
//  if we're always freeing from the maximum index to zero.  This is very
//  rarely the case, so no point in keeping that test around or touching the
//  datablock header page just to do it.
//

VOID
INTERNAL
RgFreeKeyRecordIndex(
                    LPDATABLOCK_INFO lpDatablockInfo,
                    UINT KeyRecordIndex
                    )
{

    ASSERT(lpDatablockInfo-> lpDatablockHeader-> MaxAllocatedIndex >=
           KeyRecordIndex);

    if (lpDatablockInfo-> FirstFreeIndex > KeyRecordIndex)
        lpDatablockInfo-> FirstFreeIndex = KeyRecordIndex;

    lpDatablockInfo-> lpKeyRecordTable[KeyRecordIndex] =
    NULL_KEY_RECORD_TABLE_ENTRY;

}

//
//  RgWriteDatablocks
//
//  Writes all dirty datablocks to the file specified by the file handle.
//

int
INTERNAL
RgWriteDatablocks(
                 LPFILE_INFO lpFileInfo,
                 HFILE hSourceFile,
                 HFILE hDestinationFile
                 )
{

    UINT BlockIndex;
    LPDATABLOCK_INFO lpDatablockInfo;
    LPDATABLOCK_HEADER lpDatablockHeader;
    LONG FileOffset;

    lpDatablockInfo = lpFileInfo-> lpDatablockInfo;
    FileOffset = lpFileInfo-> FileHeader.Size;

    for (BlockIndex = 0; BlockIndex < lpFileInfo-> FileHeader.BlockCount;
        BlockIndex++, lpDatablockInfo++) {

        if (lpDatablockInfo-> Flags & DIF_PRESENT) {

            //  The block is currently in memory.  If we're either extending
            //  the file or the block is dirty, then write out our in-memory
            //  copy to disk.
            if (hSourceFile != HFILE_ERROR || lpDatablockInfo-> Flags &
                DIF_DIRTY) {

                NOISE(("writing datablock #%d of ", BlockIndex));
                NOISE((lpFileInfo-> FileName));
                NOISE(("\n"));

                lpDatablockHeader = lpDatablockInfo-> lpDatablockHeader;

                //  Copy back the fields that we've been maintaining in the
                //  DATABLOCK_INFO structure.
                lpDatablockHeader-> BlockSize = lpDatablockInfo-> BlockSize;
                lpDatablockHeader-> FreeBytes = lpDatablockInfo-> FreeBytes;
                lpDatablockHeader-> FirstFreeIndex = (WORD) lpDatablockInfo->
                                                     FirstFreeIndex;

                //  The checksum is not currently calculated, so we must clear
                //  the flag so we don't confuse Win95.
                lpDatablockHeader-> Flags &= ~DHF_HASCHECKSUM;

                if (!RgSeekFile(hDestinationFile, FileOffset))
                    return ERROR_REGISTRY_IO_FAILED;

                if (!RgWriteFile(hDestinationFile, lpDatablockHeader,
                                 lpDatablockInfo-> BlockSize))
                    return ERROR_REGISTRY_IO_FAILED;

            }

        }

        else {

            //  The block is not currently in memory.  If we're extending the
            //  file, then we must write out this datablock.  The overhead is
            //  too great to lock the datablock down, so just copy it from the
            //  original file to the extended file.
            if (hSourceFile != HFILE_ERROR) {

                if (RgCopyFileBytes(hSourceFile, lpDatablockInfo-> FileOffset,
                                    hDestinationFile, FileOffset, lpDatablockInfo->
                                    BlockSize) != ERROR_SUCCESS)
                    return ERROR_REGISTRY_IO_FAILED;

            }

        }

        FileOffset += lpDatablockInfo-> BlockSize;

    }

    return ERROR_SUCCESS;

}

//
//  RgWriteDatablocksComplete
//
//  Called after a file has been successfully written.  We can now safely clear
//  all dirty flags and update our state information with the knowledge that
//  the file is in a consistent state.
//

VOID
INTERNAL
RgWriteDatablocksComplete(
                         LPFILE_INFO lpFileInfo
                         )
{

    UINT BlockIndex;
    LPDATABLOCK_INFO lpDatablockInfo;
    LONG FileOffset;

    lpDatablockInfo = lpFileInfo-> lpDatablockInfo;
    FileOffset = lpFileInfo-> FileHeader.Size;

    for (BlockIndex = 0; BlockIndex < lpFileInfo-> FileHeader.BlockCount;
        BlockIndex++, lpDatablockInfo++) {

        lpDatablockInfo-> Flags &= ~DIF_DIRTY;
        lpDatablockInfo-> FileOffset = FileOffset;

        FileOffset += lpDatablockInfo-> BlockSize;

    }

}

//
//  RgSweepDatablocks
//
//  Makes a pass through all the present datablocks of the given FILE_INFO
//  structure and discards datablocks that have not been accessed since the last
//  sweep.
//

VOID
INTERNAL
RgSweepDatablocks(
                 LPFILE_INFO lpFileInfo
                 )
{

    UINT BlocksLeft;
    LPDATABLOCK_INFO lpDatablockInfo;

    for (BlocksLeft = lpFileInfo-> FileHeader.BlockCount, lpDatablockInfo =
         lpFileInfo-> lpDatablockInfo; BlocksLeft > 0; BlocksLeft--,
        lpDatablockInfo++) {

        if (((lpDatablockInfo-> Flags & (DIF_PRESENT | DIF_ACCESSED |
                                         DIF_DIRTY)) == DIF_PRESENT) && (lpDatablockInfo-> LockCount == 0)) {

            NOISE(("discarding datablock #%d of ",
                   lpFileInfo-> FileHeader.BlockCount - BlocksLeft));
            NOISE((lpFileInfo-> FileName));
            NOISE(("\n"));

            RgFreeDatablockInfoBuffers(lpDatablockInfo);

            lpDatablockInfo-> Flags = 0;

        }

        //  Reset the accessed bit for the next sweep.
        lpDatablockInfo-> Flags &= ~DIF_ACCESSED;

    }

}

//
//  RgIsValidDatablockHeader
//
//  Returns TRUE if lpDatablockHeader is a valid DATABLOCK_HEADER structure.
//

BOOL
INTERNAL
RgIsValidDatablockHeader(
                        LPDATABLOCK_HEADER lpDatablockHeader
                        )
{

    if (lpDatablockHeader-> Signature != DH_SIGNATURE ||
        HIWORD(lpDatablockHeader-> BlockSize) != 0)
        return FALSE;

    return TRUE;

}

#ifdef VXD
    #pragma VxD_RARE_CODE_SEG
#endif

//
//  RgInitDatablockInfo
//
//  Initializes fields in the provided FILE_INFO related to the datablocks.
//

int
INTERNAL
RgInitDatablockInfo(
                   LPFILE_INFO lpFileInfo,
                   HFILE hFile
                   )
{

    UINT BlockCount;
    UINT BlockIndex;
    LPDATABLOCK_INFO lpDatablockInfo;
    LONG FileOffset;
    DATABLOCK_HEADER DatablockHeader;

    BlockCount = lpFileInfo-> FileHeader.BlockCount;

    if (IsNullPtr((lpDatablockInfo = (LPDATABLOCK_INFO)
                   RgSmAllocMemory((BlockCount + DATABLOCK_INFO_SLACK_ALLOC) *
                                   sizeof(DATABLOCK_INFO)))))
        return ERROR_OUTOFMEMORY;

    ZeroMemory(lpDatablockInfo, BlockCount * sizeof(DATABLOCK_INFO));
    lpFileInfo-> lpDatablockInfo = lpDatablockInfo;
    lpFileInfo-> DatablockInfoAllocCount = BlockCount +
                                           DATABLOCK_INFO_SLACK_ALLOC;

    FileOffset = lpFileInfo-> FileHeader.Size;

    for (BlockIndex = 0; BlockIndex < BlockCount; BlockIndex++,
        lpDatablockInfo++) {

        if (!RgSeekFile(hFile, FileOffset))
            return ERROR_REGISTRY_IO_FAILED;

        if (!RgReadFile(hFile, &DatablockHeader, sizeof(DATABLOCK_HEADER)))
            return ERROR_REGISTRY_IO_FAILED;

        if (!RgIsValidDatablockHeader(&DatablockHeader))
            return ERROR_BADDB;

        //  Following fields already zeroed by above ZeroMemory.
        //  lpDatablockInfo-> lpDatablockHeader = NULL;
        //  lpDatablockInfo-> lpKeyRecordTable = NULL;
        //  lpDatablockInfo-> Flags = 0;
        //  lpDatablockInfo-> LockCount = 0;

        lpDatablockInfo-> FileOffset = FileOffset;

        //  Cache these fields from the datablock header.  These fields should
        //  not be considered valid when the datablock is physically in memory.
        lpDatablockInfo-> BlockSize = SmallDword(DatablockHeader.BlockSize);
        lpDatablockInfo-> FreeBytes = SmallDword(DatablockHeader.FreeBytes);
        lpDatablockInfo-> FirstFreeIndex = DatablockHeader.FirstFreeIndex;

        NOISE(("DB#%d fileoff=%lx, size=%x free=%x 1stindex=%d\n", BlockIndex,
               FileOffset, lpDatablockInfo-> BlockSize, lpDatablockInfo->
               FreeBytes, lpDatablockInfo-> FirstFreeIndex));

        FileOffset += lpDatablockInfo-> BlockSize;

    }

    return ERROR_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmmreg32\regdblk.h ===
//
//  REGDBLK.H
//
//  Copyright (C) Microsoft Corporation, 1995
//

#ifndef _REGDBLK_
#define _REGDBLK_

int
INTERNAL
RgInitDatablockInfo(
    LPFILE_INFO lpFileInfo,
    HFILE hFile
    );

int
INTERNAL
RgLockDatablock(
    LPFILE_INFO lpFileInfo,
    UINT BlockIndex
    );

VOID
INTERNAL
RgUnlockDatablock(
    LPFILE_INFO lpFileInfo,
    UINT BlockIndex,
    BOOL fMarkDirty
    );

int
INTERNAL
RgLockKeyRecord(
    LPFILE_INFO lpFileInfo,
    UINT BlockIndex,
    BYTE KeyRecordIndex,
    LPKEY_RECORD FAR* lplpKeyRecord
    );

int
INTERNAL
RgWriteDatablocks(
    LPFILE_INFO lpFileInfo,
    HFILE hSourceFile,
    HFILE hDestinationFile
    );

VOID
INTERNAL
RgWriteDatablocksComplete(
    LPFILE_INFO lpFileInfo
    );

VOID
INTERNAL
RgSweepDatablocks(
    LPFILE_INFO lpFileInfo
    );

int
INTERNAL
RgAllocKeyRecordFromDatablock(
    LPFILE_INFO lpFileInfo,
    UINT BlockIndex,
    UINT Length,
    LPKEY_RECORD FAR* lplpKeyRecord
    );

int
INTERNAL
RgAllocKeyRecord(
    LPFILE_INFO lpFileInfo,
    UINT Length,
    LPKEY_RECORD FAR* lplpKeyRecord
    );

int
INTERNAL
RgExtendKeyRecord(
    LPFILE_INFO lpFileInfo,
    UINT BlockIndex,
    UINT Length,
    LPKEY_RECORD lpKeyRecord
    );

VOID
INTERNAL
RgFreeDatablockInfoBuffers(
    LPDATABLOCK_INFO lpDatablockInfo
    );

VOID
INTERNAL
RgFreeKeyRecord(
    LPDATABLOCK_INFO lpDatablockInfo,
    LPKEY_RECORD lpKeyRecord
    );

VOID
INTERNAL
RgFreeKeyRecordIndex(
    LPDATABLOCK_INFO lpDatablockInfo,
    UINT KeyRecordIndex
    );

#endif // _REGDBLK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmmreg32\pch.h ===
//
//  PCH.H
//
//  Copyright (C) Microsoft Corporation, 1995
//

#ifndef _REGPRIV_
#define _REGPRIV_

//  Conditional enable registry "features" based on the target model.
//
//  WANT_STATIC_KEYS:  Allocates key handles from a memory pool allocated
//  during library initialization.  Especially useful for real-mode to reduce
//  the memory fragmentation caused by allocating several small fixed objects.
//
//  WANT_FULL_MEMORY_CLEANUP:  When detaching, free every memory block.  Not
//  necessary for the ring zero version where "detach" means system shutdown.
//
//  WANT_HIVE_SUPPORT:  RegLoadKey, RegUnLoadKey, RegSaveKey, RegReplaceKey
//  APIs plus support code.
//
//  WANT_DYNKEY_SUPPORT:  RegCreateDynKey plus HKEY_DYN_DATA support.
//
//  WANT_NOTIFY_CHANGE_SUPPORT:  RegNotifyChangeKeyValue plus support code.
#ifndef IS_32
#define WANT_STATIC_KEYS
#endif
#ifndef VXD
#define WANT_FULL_MEMORY_CLEANUP
#endif
#ifndef REALMODE
#define WANT_HIVE_SUPPORT
#endif
#ifdef VXD
#define WANT_REGREPLACEKEY
#define WANT_DYNKEY_SUPPORT
#define WANT_NOTIFY_CHANGE_SUPPORT
#endif

//  Map any other header's definitions of these to unused types.
#define HKEY __UNUSED_HKEY
#define LPHKEY __UNUSED_LPHKEY

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#define NORESOURCE                  //  prevent RT_* definitions from vmmsys.h
#include <windows.h>
#include <string.h>
#ifdef VXD
#include <vmmsys.h>
#include <thrdsys.h>
#endif

#ifndef UNALIGNED
#define UNALIGNED                   //  defined in standard headers for RISC
#endif

#ifndef ANYSIZE_ARRAY
#define ANYSIZE_ARRAY               1
#endif

#ifdef VXD
//  By default, all registry code and data is pageable.
#pragma VMM_PAGEABLE_CODE_SEG
#pragma VMM_PAGEABLE_DATA_SEG
#endif

#define UNREFERENCED_PARAMETER(P)   (P)

#define INTERNAL                    PASCAL NEAR
#define INTERNALV                   CDECL NEAR

//  Undefine any constants that we're about to define ourselves.
#undef HKEY
#undef LPHKEY
#undef HKEY_CLASSES_ROOT
#undef HKEY_CURRENT_USER
#undef HKEY_LOCAL_MACHINE
#undef HKEY_USERS
#undef HKEY_PERFORMANCE_DATA
#undef HKEY_CURRENT_CONFIG
#undef HKEY_DYN_DATA

typedef struct _KEY FAR*            HKEY;               //  Forward reference

#include "regdebug.h"
#include "regffmt.h"
#include "regfinfo.h"

//  Many file structures in the registry are declared as DWORDs, the HIWORD is
//  always zero.  Use SmallDword to access such DWORDs for optimal access in
//  16-bit or 32-bit code.
#if defined(IS_32)
#define SmallDword(dw)              ((UINT) (dw))
#else
#define SmallDword(dw)              ((UINT) LOWORD((dw)))
#endif

#if defined(WIN16)
#define IsNullPtr(ptr)              (SELECTOROF((ptr)) == NULL)
#else
#define IsNullPtr(ptr)              ((ptr) == NULL)
#endif

//  In either mode, the resulting code uses an instrinsic version of the memcmp
//  function.
#if defined(IS_32)
#define CompareMemory               memcmp
#else
#define CompareMemory               _fmemcmp
#endif

#if defined(WIN16) || defined(WIN32)
#define StrCpy(lpd, lps)            (lstrcpy((lpd), (lps)))
#define StrCpyN(lpd, lps, cb)       (lstrcpyn((lpd), (lps), (cb)))
#define StrLen(lpstr)               (lstrlen((lpstr)))
#define ToUpper(ch)                 ((int) (DWORD) AnsiUpper((LPSTR)((BYTE)(ch))))
#define RgCreateFile(lpfn)          ((HFILE) _lcreat((lpfn), 0))
#define RgOpenFile(lpfn, mode)      ((HFILE) _lopen((lpfn), (mode)))
#define RgCloseFile(h)              ((VOID) _lclose(h))
#if defined(WIN32)
#define RgDeleteFile(lpv)           (DeleteFile((lpv)))
#define RgRenameFile(lpv1, lpv2)    (MoveFile((lpv1), (lpv2)))
#define RgGetFileAttributes(lpv)    (GetFileAttributes((lpv)))
#define RgSetFileAttributes(lpv, a) (SetFileAttributes((lpv), (a)))
#ifdef USEHEAP
extern HANDLE g_RgHeap;             //  Low memory heap for testing
#define AllocBytes(cb)              ((LPVOID) HeapAlloc(g_RgHeap, 0, (cb)))
#define FreeBytes(lpv)              ((VOID) HeapFree(g_RgHeap, 0, (lpv)))
#define ReAllocBytes(lpv, cb)       ((LPVOID) HeapReAlloc(g_RgHeap, 0, (lpv), (cb)))
#define MemorySize(lpv)             ((UINT) HeapSize(g_RgHeap, 0, (lpv)))
#else
#define AllocBytes(cb)              ((LPVOID) LocalAlloc(LMEM_FIXED, (cb)))
#define FreeBytes(lpv)              ((VOID) LocalFree((HLOCAL) (lpv)))
#define ReAllocBytes(lpv, cb)       ((LPVOID) LocalReAlloc((HLOCAL) (lpv), (cb), LMEM_MOVEABLE))
#define MemorySize(lpv)             ((UINT) LocalSize((lpv)))
#endif // USEHEAP
#else
#define AllocBytes(cb)              ((LPVOID) MAKELP(GlobalAlloc(GMEM_FIXED, (cb)), 0))
#define FreeBytes(lpv)              ((VOID) GlobalFree((HGLOBAL) SELECTOROF((lpv))))
#define ReAllocBytes(lpv, cb)       ((LPVOID) MAKELP(GlobalReAlloc((HGLOBAL) SELECTOROF((lpv)), (cb), GMEM_MOVEABLE), 0))
#define MemorySize(lpv)             ((UINT) GlobalSize((HGLOBAL) SELECTOROF((lpv))))
//  WIN16's ZeroMemory/MoveMemory:  SETUPX is the only target WIN16 environment
//  and they already use _fmemset and _fmemmove, so just use their versions.
#define ZeroMemory(lpv, cb)         (_fmemset((lpv), 0, (cb)))
#define MoveMemory(lpd, lps, cb)    (_fmemmove((lpd), (lps), (cb)))
#endif // WIN16 || WIN32
#elif defined(REALMODE)
#define IsBadStringPtr(lpv, cb)     (FALSE)
#define IsBadHugeWritePtr(lpv, cb)  (FALSE)
#define IsBadHugeReadPtr(lpv, cb)   (FALSE)
#define StrCpy(lpd, lps)            (_fstrcpy((lpd), (lps)))
#define StrCpyN(lpd, lps, cb)       (_fstrcpyn((lpd), (lps), (cb)))
#define StrLen(lpstr)               (_fstrlen((lpstr)))
#define ToUpper(ch)                 ((int)(((ch>='a')&&(ch<='z'))?(ch-'a'+'A'):ch))
LPVOID INTERNAL AllocBytes(UINT);
VOID   INTERNAL FreeBytes(LPVOID);
LPVOID INTERNAL ReAllocBytes(LPVOID, UINT);
UINT   INTERNAL MemorySize(LPVOID);
VOID   INTERNAL ZeroMemory(LPVOID, UINT);
VOID   INTERNAL MoveMemory(LPVOID, const VOID FAR*, UINT);
#elif defined(VXD)
#undef IsBadStringPtr               //  Conflicts with windows.h
#undef ZeroMemory                   //  Conflicts with windows.h
#undef MoveMemory                   //  Conflicts with windows.h
BOOL    INTERNAL RgIsBadStringPtr(const VOID FAR*, UINT);
BOOL    INTERNAL RgIsBadOptionalStringPtr(const VOID FAR*, UINT);
BOOL    INTERNAL RgIsBadHugeWritePtr(const VOID FAR*, UINT);
BOOL    INTERNAL RgIsBadHugeOptionalWritePtr(const VOID FAR*, UINT);
BOOL    INTERNAL RgIsBadHugeReadPtr(const VOID FAR*, UINT);
#define IsBadStringPtr(lpv, cb)     (RgIsBadStringPtr((lpv), (cb)))
#define IsBadOptionalStringPtr(lpv, cb)     (RgIsBadOptionalStringPtr((lpv), (cb)))
#define IsBadHugeWritePtr(lpv, cb)  (RgIsBadHugeWritePtr((lpv), (cb)))
#define IsBadHugeOptionalWritePtr(lpv, cb)  (RgIsBadHugeOptionalWritePtr((lpv), (cb)))
#define IsBadHugeReadPtr(lpv, cb)   (RgIsBadHugeReadPtr((lpv), (cb)))
#define StrCpy(lpd, lps)            (_lstrcpyn((PCHAR)(lpd), (PCHAR)(lps), (ULONG)(-1)))
#define StrCpyN(lpd, lps, cb)       (_lstrcpyn((PCHAR)(lpd), (PCHAR)(lps), (ULONG)(cb)))
#define StrLen(lpstr)               (_lstrlen((PCHAR)(lpstr)))
extern  UCHAR UpperCaseTable[256];
#define ToUpper(ch)                 ((int)(UpperCaseTable[(UCHAR)(ch)]))
VOID	INTERNAL RgSetAndReleaseEvent(HANDLE hEvent);
#define RgGetCurrentThreadId()      ((DWORD)pthcbCur)
#define AllocBytes(cb)              ((LPVOID) _HeapAllocate((cb), HEAPSWAP))
#define FreeBytes(lpv)              ((VOID) _HeapFree((lpv), 0))
#define ReAllocBytes(lpv, cb)       ((LPVOID) _HeapReAllocate((lpv), (cb), HEAPSWAP))
#define MemorySize(lpv)             ((UINT) _HeapGetSize((lpv), 0))
#define AllocPages(cp)              ((LPVOID) _PageAllocate((cp), PG_SYS, 0, 0, 0, 0, NULL, 0))
#define FreePages(lpv)              ((VOID) _PageFree((ULONG) (lpv), 0))
#define ReAllocPages(lpv, cp)       ((LPVOID) _PageReAllocate((ULONG) (lpv), (cp), 0))
VOID   INTERNAL RgZeroMemory(LPVOID, UINT);
VOID   INTERNAL RgMoveMemory(LPVOID, const VOID FAR*, UINT);
#define ZeroMemory                  RgZeroMemory
#define MoveMemory                  RgMoveMemory
#else
#error Must define REALMODE, VXD, WIN16, or WIN32.
#endif

//  The IsBadHugeOptional*Ptr macros are used to validate pointers that may be
//  NULL.  By wrapping this "predicate", we can generate smaller code in some
//  environments, specifically VMM...
#if !defined(VXD)
#define IsBadOptionalStringPtr(lpv, cb) \
    (!IsNullPtr((lpv)) && IsBadStringPtr((lpv), (cb)))
#define IsBadHugeOptionalWritePtr(lpv, cb) \
    (!IsNullPtr((lpv)) && IsBadHugeWritePtr((lpv), (cb)))
#endif

//  The IsEnumIndexTooBig macro is used to check if a DWORD sized index can fit
//  into a UINT sized variable.  Only useful for validation of RegEnumKey or
//  RegEnumValue to make small code in both 16 and 32 bit environments.
#if defined(IS_32)
#define IsEnumIndexTooBig(index)    (FALSE)
#else
#define IsEnumIndexTooBig(index)    (HIWORD(index) > 0)
#endif

#if defined(VXD)
BOOL INTERNAL RgLockRegistry(VOID);
VOID INTERNAL RgUnlockRegistry(VOID);
VOID INTERNAL RgDelayFlush(VOID);
VOID INTERNAL RgYield(VOID);
#else
#define RgLockRegistry()            (TRUE)
#define RgUnlockRegistry()          (TRUE)
#define RgDelayFlush()              (TRUE)
#define RgYield()                   (TRUE)
#endif

//  Eliminate the need for #ifdef DBCS by using macros and letting the compiler
//  optimize out the DBCS code on SBCS systems.
#ifdef DBCS
#if !defined(WIN16) && !defined(WIN32)
BOOL INTERNAL RgIsDBCSLeadByte(BYTE TestChar);
#define IsDBCSLeadByte(ch)              RgIsDBCSLeadByte(ch)
#endif
#else
#define IsDBCSLeadByte(ch)              ((ch), FALSE)
#endif // DBCS

#ifdef WANT_DYNKEY_SUPPORT
//  Internally used for maintaining dynamic key information; only keeps the
//  fields that we actually need from the REG_PROVIDER structure given to
//  VMMRegCreateDynKey.
typedef struct _INTERNAL_PROVIDER {
    PQUERYHANDLER ipi_R0_1val;
    PQUERYHANDLER ipi_R0_allvals;
    LPVOID ipi_key_context;
}   INTERNAL_PROVIDER, FAR* PINTERNAL_PROVIDER;
#endif

typedef struct _KEY {
    WORD Signature;                             //  KEY_SIGNATURE
    WORD Flags; 				//  KEYF_* bits
    UINT ReferenceCount;
    LPFILE_INFO lpFileInfo;
    DWORD KeynodeIndex;
    DWORD ChildKeynodeIndex;
    WORD BlockIndex;
    BYTE KeyRecordIndex;
    BYTE PredefinedKeyIndex;
    struct _KEY FAR* lpNext;
    struct _KEY FAR* lpPrev;
    UINT LastEnumKeyIndex;
    DWORD LastEnumKeyKeynodeIndex;
#ifdef WANT_DYNKEY_SUPPORT
    PINTERNAL_PROVIDER pProvider;
#endif
}   KEY;

#define KEY_SIGNATURE               0x4B48      //  "HK"

#define KEYF_PREDEFINED             0x01        //  Represents one of HKEY_*
#define KEYF_DELETED                0x02        //
#define KEYF_INVALID                0x04        //
#define KEYF_STATIC                 0x08        //  Allocated from static pool
#define KEYF_ENUMKEYCACHED          0x10        //  LastEnumKey* values valid
#define KEYF_HIVESALLOWED           0x20        //
#define KEYF_PROVIDERHASVALUELENGTH 0x40        //  PROVIDER_KEEPS_VALUE_LENGTH
#define KEYF_NEVERDELETE            0x80        //  Reference count overflow

#define INDEX_CLASSES_ROOT          0
#define INDEX_CURRENT_USER          1
#define INDEX_LOCAL_MACHINE         2
#define INDEX_USERS                 3
#define INDEX_PERFORMANCE_DATA      4
#define INDEX_CURRENT_CONFIG        5
#define INDEX_DYN_DATA              6

//  Returns TRUE if the KEY references the root of a hive, such as
//  HKEY_LOCAL_MACHINE, HKEY_USERS, or any hive loaded by RegLoadKey.
#define IsKeyRootOfHive(hkey)       \
    ((hkey)-> KeynodeIndex == (hkey)-> lpFileInfo-> KeynodeHeader.RootIndex)

#include <regapix.h>
#include "regkylst.h"
#include "regdblk.h"
#include "regknode.h"
#include "regnckey.h"
#include "regfsio.h"
#include "regmem.h"

#ifdef VXD
extern BYTE g_RgPostCriticalInit;
extern BYTE g_RgFileAccessDisabled;
#define IsPostCriticalInit()        (g_RgPostCriticalInit)
#define IsFileAccessDisabled()      (g_RgFileAccessDisabled)
#else
#define IsPostCriticalInit()        (TRUE)
#define IsFileAccessDisabled()      (FALSE)
#endif

//  g_RgWorkBuffer: one buffer is always available of size SIZEOF_WORK_BUFFER.
//  These macros wrap access to this buffer for to verify only one routine is
//  attempting to use it at any time.
extern LPVOID g_RgWorkBuffer;
#ifdef DEBUG
extern BOOL g_RgWorkBufferBusy;
#define RgLockWorkBuffer()          \
    (ASSERT(!g_RgWorkBufferBusy), g_RgWorkBufferBusy = TRUE, (LPVOID) g_RgWorkBuffer)
#define RgUnlockWorkBuffer(lpv)     \
    (VOID) (ASSERT((lpv) == g_RgWorkBuffer), g_RgWorkBufferBusy = FALSE)
#else
#define RgLockWorkBuffer()          ((LPVOID) g_RgWorkBuffer)
#define RgUnlockWorkBuffer(lpv)
#endif
#define SIZEOF_WORK_BUFFER          (sizeof(W95KEYNODE_BLOCK))

#define IsKeyRecordFree(lpkr) \
    (((lpkr)-> DatablockAddress) == REG_NULL)

BOOL
INTERNAL
RgIsBadSubKey(
    LPCSTR lpSubKey
    );

UINT
INTERNAL
RgGetNextSubSubKey(
    LPCSTR lpSubKey,
    LPCSTR FAR* lplpSubSubKey,
    UINT FAR* lpSubSubKeyLength
    );

#define LK_OPEN                     0x0000      //  Open key only
#define LK_CREATE                   0x0001      //  Create or open key
#define LK_CREATEDYNDATA            0x0002      //  HKEY_DYN_DATA may create

int
INTERNAL
RgLookupKey(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPHKEY lphSubKey,
    UINT Flags
    );

int
INTERNAL
RgCreateOrOpenKey(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPHKEY lphKey,
    UINT Flags
    );

int
INTERNAL
RgLookupKeyByIndex(
    HKEY hKey,
    UINT Index,
    LPSTR lpKeyName,
    LPDWORD lpcbKeyName
    );

int
INTERNAL
RgLookupValueByName(
    HKEY hKey,
    LPCSTR lpValueName,
    LPKEY_RECORD FAR* lplpKeyRecord,
    LPVALUE_RECORD FAR* lplpValueRecord
    );

int
INTERNAL
RgLookupValueByIndex(
    HKEY hKey,
    UINT Index,
    LPVALUE_RECORD FAR* lplpValueRecord
    );

int
INTERNAL
RgCopyFromValueRecord(
    HKEY hKey,
    LPVALUE_RECORD lpValueRecord,
    LPSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

int
INTERNAL
RgReAllocKeyRecord(
    HKEY hKey,
    DWORD Length,
    LPKEY_RECORD FAR* lplpKeyRecord
    );

int
INTERNAL
RgSetValue(
    HKEY hKey,
    LPCSTR lpValueName,
    DWORD Type,
    LPBYTE lpData,
    UINT cbData
    );

int
INTERNAL
RgDeleteKey(
    HKEY hKey
    );

DWORD
INTERNAL
RgChecksum(
    LPVOID lpBuffer,
    UINT ByteCount
    );

DWORD
INTERNAL
RgHashString(
    LPCSTR lpString,
    UINT Length
    );

int
INTERNAL
RgStrCmpNI(
    LPCSTR lpString1,
    LPCSTR lpString2,
    UINT Length
    );

int
INTERNAL
RgCopyFileBytes(
    HFILE hSourceFile,
    LONG SourceOffset,
    HFILE hDestinationFile,
    LONG DestinationOffset,
    DWORD cbSize
    );

BOOL
INTERNAL
RgGenerateAltFileName(
    LPCSTR lpFileName,
    LPSTR lpAltFileName,
    char ExtensionChar
    );

int
INTERNAL
RgCopyFile(
    LPCSTR lpSourceFile,
    LPCSTR lpDestinationFile
    );

int
INTERNAL
RgReplaceFileInfo(
    LPFILE_INFO lpFileInfo
    );

#endif // _REGPRIV_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmmreg32\regdebug.h ===
//
//  DEBUG.H
//
//  Copyright (C) Microsoft Corporation, 1995
//

#ifndef _DEBUG_
#define _DEBUG_

#ifdef DEBUG

//  Disable the "in-line assembler precludes global optimizations" warning
//  because of debug breaks.
#pragma warning(disable:4704)

#if !defined(WIN32) || defined(_X86_)
#define TRAP()                      _asm {int 3}
#else
#define TRAP()                      DebugBreak()
#endif

VOID
INTERNALV
RgDebugPrintf(
    LPCSTR lpFormatString,
    ...
    );

VOID
INTERNAL
RgDebugAssert(
    LPCSTR lpFile,
    UINT LineNumber
    );

#define TRACE(x)    RgDebugPrintf ##x

#ifdef REGDEBUG
#define NOISE(x)    RgDebugPrintf ##x
#else
#define NOISE(x)
#endif

#define ASSERT(x)   ((x) ? (VOID) 0 : RgDebugAssert(__FILE__, __LINE__))

#define DECLARE_DEBUG_COUNT(var)    int var = 0;
#define INCREMENT_DEBUG_COUNT(var)  ((var)++)
#define DECREMENT_DEBUG_COUNT(var)  ASSERT(((var)--))

#if !defined(WIN32) || defined(_X86_)
#define DEBUG_OUT(x)                { TRACE(x); _asm {int 1}; }
#else
#define DEBUG_OUT(x)                { TRACE(x); TRAP(); }
#endif

#else
#define TRAP()
#define TRACE(x)
#define NOISE(x)
#define ASSERT(x)
#define DECLARE_DEBUG_COUNT(var)
#define INCREMENT_DEBUG_COUNT(var)
#define DECREMENT_DEBUG_COUNT(var)
#define DEBUG_OUT(x)
#endif

#endif // _DEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmmreg32\regdebug.c ===
//
//  REGDEBUG.C
//
//  Copyright (C) Microsoft Corporation, 1995
//

#include "pch.h"

//  VXD_NODEBUGGER:  Uses debug services available when a debugger is not
//  installed, but at the cost of an intermediate debug buffer.
//#define VXD_NODEBUGGER

#ifdef DEBUG

#include <stdarg.h>

#ifdef STDIO_DEBUG
#include <stdio.h>
#else
static char g_RgDebugBuffer[256];
#endif

#ifdef VXD_NODEBUGGER
extern	ULONG	(SERVICE*_Vsprintf)(PCHAR,PCHAR,va_list);
#endif

VOID
INTERNALV
RgDebugPrintf(
    LPCSTR lpFormatString,
    ...
    )
{

    va_list arglist;

    va_start(arglist, lpFormatString);

#ifdef STDIO_DEBUG
    vprintf(lpFormatString, arglist);
#else
#ifdef VXD
#ifdef VXD_NODEBUGGER
    _Vsprintf(g_RgDebugBuffer, (PCHAR) lpFormatString, arglist);
    _Debug_Out_Service(g_RgDebugBuffer);
#else
    _Debug_Printf_Service((PCHAR) lpFormatString, arglist);
#endif
#else
    wvsprintf(g_RgDebugBuffer, lpFormatString, arglist);
    OutputDebugString(g_RgDebugBuffer);
#endif
#endif

}

VOID
INTERNAL
RgDebugAssert(
    LPCSTR lpFile,
    UINT LineNumber
    )
{

    RgDebugPrintf("assert failed %s@%d\n", lpFile, LineNumber);

    TRAP();

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmmreg32\regdval.c ===
//
//  REGDVAL.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegDeleteValue and supporting functions.
//

#include "pch.h"

//
//  RgDeleteValueRecord
//
//  Deletes the specified VALUE_RECORD from the provided KEY_RECORD.
//

VOID
INTERNAL
RgDeleteValueRecord(
    LPKEY_RECORD lpKeyRecord,
    LPVALUE_RECORD lpValueRecord
    )
{

    UINT ValueRecordLength;
    LPBYTE lpSource;
    UINT BytesToPushDown;

    ASSERT(lpKeyRecord-> ValueCount > 0);

    ValueRecordLength = sizeof(VALUE_RECORD) + lpValueRecord-> NameLength +
        lpValueRecord-> DataLength - 1;

    ASSERT(lpKeyRecord-> RecordSize >= ValueRecordLength);

    //
    //  If this isn't the last value of this KEY_RECORD, then push down any
    //  VALUE_RECORDs after the VALUE_RECORD to delete.
    //

    if (--lpKeyRecord-> ValueCount) {

        lpSource = (LPBYTE) lpValueRecord + ValueRecordLength;

        BytesToPushDown = (UINT) ((LPBYTE) lpKeyRecord + lpKeyRecord->
            RecordSize - lpSource);

        MoveMemory((LPBYTE) lpValueRecord, lpSource, BytesToPushDown);

    }

    lpKeyRecord-> RecordSize -= ValueRecordLength;

}

//
//  VMMRegDeleteValue
//
//  See Win32 documentation of RegDeleteValue.
//

LONG
REGAPI
VMMRegDeleteValue(
    HKEY hKey,
    LPCSTR lpValueName
    )
{

    int ErrorCode;
    LPKEY_RECORD lpKeyRecord;
    LPVALUE_RECORD lpValueRecord;

    if (IsBadOptionalStringPtr(lpValueName, (UINT) -1))
        return ERROR_INVALID_PARAMETER;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) == ERROR_SUCCESS) {

        if ((ErrorCode = RgLookupValueByName(hKey, lpValueName, &lpKeyRecord,
            &lpValueRecord)) == ERROR_SUCCESS) {

            if ((hKey-> PredefinedKeyIndex == INDEX_DYN_DATA) || (hKey->
                lpFileInfo-> Flags & FI_READONLY))
                ErrorCode = ERROR_ACCESS_DENIED;
            else {
                RgDeleteValueRecord(lpKeyRecord, lpValueRecord);
                RgSignalWaitingNotifies(hKey-> lpFileInfo, hKey-> KeynodeIndex,
                    REG_NOTIFY_CHANGE_LAST_SET);
            }

            RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BlockIndex, TRUE);

        }

    }

    RgUnlockRegistry();

    return ErrorCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmmreg32\regdykey.c ===
//
//  REGDYKEY.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegCreateDynKey and supporting functions.
//

#include "pch.h"

#ifdef WANT_DYNKEY_SUPPORT

    #ifdef VXD
        #pragma VxD_RARE_CODE_SEG
    #endif

//
//  VMMRegCreateDynKey
//
//  See VMM DDK of _RegCreateDynKey.
//

LONG
REGAPI
VMMRegCreateDynKey(
                  LPCSTR lpKeyName,
                  LPVOID KeyContext,
                  PPROVIDER pProvider,
                  PPVALUE pValueList,
                  DWORD ValueCount,
                  LPHKEY lphKey
                  )
{

    LONG ErrorCode;
    HKEY hKey;
    PINTERNAL_PROVIDER pProviderCopy;
    PPVALUE pCurrentValue;

    if (IsBadHugeReadPtr(pProvider, sizeof(REG_PROVIDER)) ||
        (IsNullPtr(pProvider-> pi_R0_1val) &&
         IsNullPtr(pProvider-> pi_R0_allvals)) ||
        IsBadHugeReadPtr(pValueList, sizeof(PVALUE) * ValueCount))
        return ERROR_INVALID_PARAMETER;

    if ((ErrorCode = RgCreateOrOpenKey(HKEY_DYN_DATA, lpKeyName, &hKey,
                                       LK_CREATE | LK_CREATEDYNDATA)) != ERROR_SUCCESS)
        return ErrorCode;

    if (!RgLockRegistry())
        ErrorCode = ERROR_LOCK_FAILED;

    else {

        pProviderCopy = RgSmAllocMemory(sizeof(INTERNAL_PROVIDER));

        if (IsNullPtr(pProviderCopy))
            ErrorCode = ERROR_OUTOFMEMORY;

        else {

            //  ErrorCode = ERROR_SUCCESS;  //  Must be true if we're here...

            hKey-> pProvider = pProviderCopy;

            //  If no "get single" callback was provided, we can just use the
            //  "get atomic" callback.
            if (IsNullPtr(pProvider-> pi_R0_1val))
                pProviderCopy-> ipi_R0_1val = pProvider-> pi_R0_allvals;
            else
                pProviderCopy-> ipi_R0_1val = pProvider-> pi_R0_1val;

            pProviderCopy-> ipi_R0_allvals = pProvider-> pi_R0_allvals;
            pProviderCopy-> ipi_key_context = KeyContext;

            //  No point in keeping a whole DWORD for one bit when we can fit
            //  it inside the main key structure.
            if (pProvider-> pi_flags & PROVIDER_KEEPS_VALUE_LENGTH)
                hKey-> Flags |= KEYF_PROVIDERHASVALUELENGTH;

            //  Loop over all the values and store each name in the registry
            //  with a partial PVALUE record as the value's data.
            for (pCurrentValue = pValueList; ValueCount > 0; ValueCount--,
                pCurrentValue++) {

                if (IsBadStringPtr(pCurrentValue-> pv_valuename, (UINT) -1)) {
                    ErrorCode = ERROR_INVALID_PARAMETER;
                    break;
                }

                //  Skip storing the pv_valuename field.
                if ((ErrorCode = RgSetValue(hKey, pCurrentValue-> pv_valuename,
                                            REG_BINARY, (LPBYTE) &(pCurrentValue-> pv_valuelen),
                                            sizeof(PVALUE) - FIELD_OFFSET(PVALUE, pv_valuename))) !=
                    ERROR_SUCCESS) {
                    TRAP();
                    break;
                }

            }

        }

        RgUnlockRegistry();

    }

    //  Win95 difference: on an error, don't modify lphKey and close the key
    //  created above.
    if (ErrorCode == ERROR_SUCCESS)
        *lphKey = hKey;
    else
        VMMRegCloseKey(hKey);

    return ErrorCode;

}

#endif // WANT_DYNKEY_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmmreg32\regdkey.c ===
//
//  REGDKEY.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegDeleteKey and supporting functions.
//

#include "pch.h"

//
//  RgFreeDatablockStructures
//
//  Helper routine for RgDeleteKey.  Deletes the specified datablock structures.
//  The datablock is not assumed to be locked.  We don't care about the success
//  of this routine-- in the worst case, some stuff will be orphaned in the
//  file.
//

VOID
INTERNAL
RgFreeDatablockStructures(
    LPFILE_INFO lpFileInfo,
    UINT BlockIndex,
    UINT KeyRecordIndex
    )
{

    LPDATABLOCK_INFO lpDatablockInfo;
    LPKEY_RECORD lpKeyRecord;

    if (RgLockKeyRecord(lpFileInfo, BlockIndex, (BYTE) KeyRecordIndex,
        &lpKeyRecord) == ERROR_SUCCESS) {
        lpDatablockInfo = RgIndexDatablockInfoPtr(lpFileInfo, BlockIndex);
        RgFreeKeyRecord(lpDatablockInfo, lpKeyRecord);
        RgFreeKeyRecordIndex(lpDatablockInfo, KeyRecordIndex);
        RgUnlockDatablock(lpFileInfo, BlockIndex, TRUE);
    }

}

//
//  RgDeleteKey
//
//  Worker routine for VMMRegDeleteKey.  The given key handle references a key
//  that has already been validated as "deleteable".
//

int
INTERNAL
RgDeleteKey(
    HKEY hKey
    )
{

    int ErrorCode;
    LPFILE_INFO lpFileInfo;
    DWORD KeynodeIndex;
    LPKEYNODE lpKeynode;
    DWORD NextKeynodeIndex;
    LPKEYNODE lpNextKeynode;
    DWORD ReplacementKeynodeIndex;
    HKEY hTempKey;

    lpFileInfo = hKey-> lpFileInfo;

    //
    //  Stage one: unlink the keynode of the specified key from the keynode
    //  tree and free all associate file structures with the key.
    //

    if ((ErrorCode = RgLockInUseKeynode(lpFileInfo, hKey-> KeynodeIndex,
        &lpKeynode)) != ERROR_SUCCESS)
        return ErrorCode;

    KeynodeIndex = lpKeynode-> ParentIndex;
    ReplacementKeynodeIndex = lpKeynode-> NextIndex;
    RgUnlockKeynode(lpFileInfo, hKey-> KeynodeIndex, FALSE);

    //  Signal any waiting notifies on the parent that this key is about to be
    //  deleted.
    //
    //  Note that we may fail below, but NT does _exactly_ the same thing in
    //  this case: doesn't care.  If we get an error and don't actually delete
    //  this key, then we'll have sent a spurious notify.
    //
    //  Note also that we don't send any notification that the key itself has
    //  been deleted.  REG_NOTIFY_CHANGE_NAME is supposed to be for subkey
    //  changes only, not changes to the key itself.  But because of the
    //  incompatible way we must deal with subkeys of the key we're about to
    //  delete, we may well end up notifying the key if it has subkeys.
    RgSignalWaitingNotifies(lpFileInfo, KeynodeIndex, REG_NOTIFY_CHANGE_NAME);

    if ((ErrorCode = RgLockInUseKeynode(lpFileInfo, KeynodeIndex,
        &lpKeynode)) != ERROR_SUCCESS)
        return ErrorCode;

    //  The per-key cache that we use for RegEnumKey may be invalid, so it must
    //  be zapped.
    if (!IsNullPtr(hTempKey = RgFindOpenKeyHandle(lpFileInfo, KeynodeIndex)))
        hTempKey-> Flags &= ~KEYF_ENUMKEYCACHED;

    NextKeynodeIndex = lpKeynode-> ChildIndex;

    if (NextKeynodeIndex == hKey-> KeynodeIndex) {

        //  Update the cached child keynode index in the open handle on the
        //  parent.
        if (!IsNullPtr(hTempKey))
            hTempKey-> ChildKeynodeIndex = ReplacementKeynodeIndex;

        //  This is the parent of the keynode that we need to delete.  Replace
        //  it's "child" link.
        lpKeynode-> ChildIndex = ReplacementKeynodeIndex;

    }

    else {

        //  Loop through the siblings of the keynode we're trying to delete.
        do {

            RgUnlockKeynode(lpFileInfo, KeynodeIndex, FALSE);
            KeynodeIndex = NextKeynodeIndex;

            if (IsNullKeynodeIndex(KeynodeIndex)) {
                DEBUG_OUT(("RgDeleteKey: couldn't find the keynode to delete\n"));
                return ERROR_BADDB;
            }

            if ((ErrorCode = RgLockInUseKeynode(lpFileInfo, KeynodeIndex,
                &lpKeynode)) != ERROR_SUCCESS)
                return ErrorCode;

            NextKeynodeIndex = lpKeynode-> NextIndex;

        }   while (NextKeynodeIndex != hKey-> KeynodeIndex);

        //  This is the previous sibling of the keynode that we need to delete.
        //  Replace it's "next" link.
        lpKeynode-> NextIndex = ReplacementKeynodeIndex;

    }

    //  Unlock the updated "parent" or "next" of this keynode.
    RgUnlockKeynode(lpFileInfo, KeynodeIndex, TRUE);

    //  Free the structures associated with the datablock.
    RgFreeDatablockStructures(lpFileInfo, hKey-> BlockIndex, hKey->
        KeyRecordIndex);

    //  Free the structures associated with the keynode tables.
    RgFreeKeynode(lpFileInfo, hKey-> KeynodeIndex);

    //  The key is definitely toast now.
    hKey-> Flags |= KEYF_DELETED;

    //
    //  Stage two: the specified key is unlinked, but any of its subkeys now
    //  have to be freed.  Errors are ignored at this point: we won't try to
    //  undo the stuff we did in stage one.  The worst thing that can happen is
    //  that some file structures are orphaned.
    //

    NextKeynodeIndex = hKey-> ChildKeynodeIndex;

    if (IsNullKeynodeIndex(NextKeynodeIndex) || RgLockInUseKeynode(lpFileInfo,
        NextKeynodeIndex, &lpNextKeynode) != ERROR_SUCCESS)
        return ERROR_SUCCESS;

    while (!IsNullKeynodeIndex(NextKeynodeIndex)) {

        KeynodeIndex = NextKeynodeIndex;
        lpKeynode = lpNextKeynode;

        //  Check if the keynode has any children.  If it does and we can lock
        //  it down, then move to it.
        NextKeynodeIndex = lpKeynode-> ChildIndex;

        if (!IsNullKeynodeIndex(NextKeynodeIndex) &&
            RgLockInUseKeynode(lpFileInfo, NextKeynodeIndex, &lpNextKeynode) ==
            ERROR_SUCCESS) {

            ASSERT(KeynodeIndex == lpNextKeynode-> ParentIndex);

            RgYield();

            //  "Burn" the link to our child, so that on the way back out of
            //  the tree, we don't end up recursing.  Plus, if we hit any errors
            //  deep in the tree deletion, the child of the current keynode
            //  could have already been toasted, so we have to zap our link to
            //  it.
            lpKeynode-> ChildIndex = REG_NULL;
            RgUnlockKeynode(lpFileInfo, KeynodeIndex, TRUE);

            //  We've now caused a change in the subkeys of the current key.
            //  Note that we don't bother signaling notifies that are doing a
            //  subtree watch because any such notifies should have already been
            //  signaled by the above call or they've already been signaled
            //  during our recursion.  In the off chance that we have a lot of
            //  notifications registered, this will avoid a lot of unnecessary
            //  checking.
            RgSignalWaitingNotifies(lpFileInfo, KeynodeIndex,
                REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_NO_WATCH_SUBTREE);

            continue;

        }

        //  The keynode doesn't have any children.  Check for sibling keynodes.
        NextKeynodeIndex = lpKeynode-> NextIndex;

        if (IsNullKeynodeIndex(NextKeynodeIndex) ||
            RgLockInUseKeynode(lpFileInfo, NextKeynodeIndex, &lpNextKeynode) !=
            ERROR_SUCCESS) {

            //  The keynode doesn't have any siblings or we were unable to get
            //  at them.  Move back to the parent.
            NextKeynodeIndex = lpKeynode-> ParentIndex;

            //  If we wrapped back up to the top of the deleted branch or if we
            //  just can't access the parent keynode, then set next to REG_NULL
            //  and bail out on the next iteration.
            if ((NextKeynodeIndex == hKey-> KeynodeIndex) ||
                RgLockInUseKeynode(lpFileInfo, NextKeynodeIndex,
                &lpNextKeynode) != ERROR_SUCCESS)
                NextKeynodeIndex = REG_NULL;

        }

        //  If an open key refers to this file and keynode index, mark it as
        //  deleted.
        if (!IsNullPtr(hTempKey = RgFindOpenKeyHandle(lpFileInfo,
            KeynodeIndex)))
            hTempKey-> Flags |= KEYF_DELETED;

        //  Free the structures associated with the datablock.
        RgFreeDatablockStructures(lpFileInfo, lpKeynode-> BlockIndex,
            (BYTE) lpKeynode-> KeyRecordIndex);

        //  Free the structures associated with the keynode tables.
        RgUnlockKeynode(lpFileInfo, KeynodeIndex, TRUE);
        RgFreeKeynode(lpFileInfo, KeynodeIndex);

    }

    return ERROR_SUCCESS;

}

//
//  VMMRegDeleteKey
//
//  See Win32 documentation for a description of the behavior.
//
//  Although the Win32 documentation states that lpSubKey must be NULL, NT
//  actually allows this to pass through.  Win95 rejected the call, but the only
//  reason we didn't change it then was because we realized too late in the
//  product that it was different.
//

LONG
REGAPI
VMMRegDeleteKey(
    HKEY hKey,
    LPCSTR lpSubKey
    )
{

    LONG ErrorCode;
    HKEY hSubKey = 0;

    if ((ErrorCode = VMMRegOpenKey(hKey, lpSubKey, &hSubKey)) != ERROR_SUCCESS)
        return ErrorCode;

    if (!RgLockRegistry())
        ErrorCode = ERROR_LOCK_FAILED;

    else {

        if (IsKeyRootOfHive(hSubKey) || (hSubKey-> lpFileInfo-> Flags &
            FI_READONLY))
            ErrorCode = ERROR_ACCESS_DENIED;
        else
            ErrorCode = RgDeleteKey(hSubKey);

        RgUnlockRegistry();

    }

    VMMRegCloseKey(hSubKey);

    return ErrorCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmmreg32\regeval.c ===
//
//  REGEVAL.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegEnumValue and supporting functions.
//

#include "pch.h"

//
//  RgLookupValueByIndex
//
//  Searches for the value with the specified index and returns a pointer to its
//  VALUE_RECORD.
//

int
INTERNAL
RgLookupValueByIndex(
                    HKEY hKey,
                    UINT Index,
                    LPVALUE_RECORD FAR* lplpValueRecord
                    )
{

    int ErrorCode;
    LPKEY_RECORD lpKeyRecord;
    LPVALUE_RECORD lpValueRecord;

    //  Handle Win95 registries that don't have a key record for the root key.
    if (IsNullBlockIndex(hKey-> BlockIndex))
        return ERROR_NO_MORE_ITEMS;

    if ((ErrorCode = RgLockKeyRecord(hKey-> lpFileInfo, hKey-> BlockIndex,
                                     hKey-> KeyRecordIndex, &lpKeyRecord)) == ERROR_SUCCESS) {

        if (Index >= lpKeyRecord-> ValueCount) {
            RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BlockIndex, FALSE);
            ErrorCode = ERROR_NO_MORE_ITEMS;
        }

        else {

            lpValueRecord = (LPVALUE_RECORD) ((LPBYTE) &lpKeyRecord-> Name +
                                              lpKeyRecord-> NameLength + lpKeyRecord-> ClassLength);

            while (Index--) {
                lpValueRecord = (LPVALUE_RECORD) ((LPBYTE) &lpValueRecord->
                                                  Name + lpValueRecord-> NameLength + lpValueRecord->
                                                  DataLength);
            }

            *lplpValueRecord = lpValueRecord;
            ErrorCode = ERROR_SUCCESS;

        }

    }

    return ErrorCode;

}

//
//  VMMRegEnumValue
//
//  See Win32 documentation for a description of the behavior.
//

LONG
REGAPI
VMMRegEnumValue(
               HKEY hKey,
               DWORD Index,
               LPSTR lpValueName,
               LPDWORD lpcbValueName,
               LPDWORD lpReserved,
               LPDWORD lpType,
               LPBYTE lpData,
               LPDWORD lpcbData
               )
{

    int ErrorCode;
    LPVALUE_RECORD lpValueRecord;

    if (IsBadHugeWritePtr(lpcbValueName, sizeof(DWORD)) ||
        IsBadHugeWritePtr(lpValueName, *lpcbValueName) ||
        (IsBadHugeOptionalWritePtr(lpType, sizeof(DWORD))))
        return ERROR_INVALID_PARAMETER;

    if (IsBadHugeOptionalWritePtr(lpType, sizeof(DWORD)))
        return ERROR_INVALID_PARAMETER;

    if (IsNullPtr(lpcbData)) {
        if (!IsNullPtr(lpData))
            return ERROR_INVALID_PARAMETER;
    }

    else {
        //  Win95 compatibility: don't validate lpData is of size *lpcbData.
        //  Instead of validating the entire buffer, we'll validate just the
        //  required buffer length in RgCopyFromValueRecord.
        if (IsBadHugeWritePtr(lpcbData, sizeof(DWORD)))
            return ERROR_INVALID_PARAMETER;
    }

    if (IsEnumIndexTooBig(Index))
        return ERROR_NO_MORE_ITEMS;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) == ERROR_SUCCESS) {

        if ((ErrorCode = RgLookupValueByIndex(hKey, (UINT) Index,
                                              &lpValueRecord)) == ERROR_SUCCESS) {
            ErrorCode = RgCopyFromValueRecord(hKey, lpValueRecord, lpValueName,
                                              lpcbValueName, lpType, lpData, lpcbData);
            RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BlockIndex, FALSE);
        }

    }

    RgUnlockRegistry();

    return ErrorCode;

    UNREFERENCED_PARAMETER(lpReserved);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmmreg32\regekey.c ===
//
//  REGEKEY.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegEnumKey and supporting functions.
//

#include "pch.h"

//
//  RgLookupKeyByIndex
//
//  lpKeyName, points to a buffer that receives the name of the subkey,
//      including the null terminator.  May be NULL.
//  lpcbKeyName, on entry, specifies the size in characters of the buffer
//      pointed to be lpKeyName, and on return, specifies the size of the
//      indexed subkey.  May not be NULL.
//

int
INTERNAL
RgLookupKeyByIndex(
    HKEY hKey,
    UINT Index,
    LPSTR lpKeyName,
    LPDWORD lpcbKeyName
    )
{

    int ErrorCode;
    LPFILE_INFO lpFileInfo;
    UINT KeysToSkip;
    DWORD KeynodeIndex;
    DWORD TempOffset;
    LPKEYNODE lpKeynode;
    LPKEY_RECORD lpKeyRecord;
#ifdef WANT_HIVE_SUPPORT
    LPHIVE_INFO lpHiveInfo;
#endif

    lpFileInfo = hKey-> lpFileInfo;
    KeysToSkip = Index;

    //
    //  Check if we've cached the keynode index of the last key index
    //  (confusing?) from a previous call to this function.  If so, then we can
    //  skip ahead a bit and avoid touching a bunch of keynode pages.
    //

    if ((hKey-> Flags & KEYF_ENUMKEYCACHED) && (Index >=
        hKey-> LastEnumKeyIndex)) {
        KeysToSkip -= hKey-> LastEnumKeyIndex;
        KeynodeIndex = hKey-> LastEnumKeyKeynodeIndex;
    }

    else
        KeynodeIndex = hKey-> ChildKeynodeIndex;

    //
    //  Loop over the child keys of this key until we find our index or run out
    //  of children.
    //

    while (!IsNullKeynodeIndex(KeynodeIndex)) {

        if ((ErrorCode = RgLockInUseKeynode(lpFileInfo, KeynodeIndex,
            &lpKeynode)) != ERROR_SUCCESS)
            return ErrorCode;

        ASSERT(hKey-> KeynodeIndex == lpKeynode-> ParentIndex);

        if (KeysToSkip == 0) {

            if ((ErrorCode = RgLockKeyRecord(lpFileInfo, lpKeynode-> BlockIndex,
                (BYTE) lpKeynode-> KeyRecordIndex, &lpKeyRecord)) ==
                ERROR_SUCCESS) {

                if (!IsNullPtr(lpKeyName)) {

                    if (*lpcbKeyName <= lpKeyRecord-> NameLength)
                        ErrorCode = ERROR_MORE_DATA;

                    else {
                        MoveMemory(lpKeyName, lpKeyRecord-> Name, lpKeyRecord->
                            NameLength);
                        lpKeyName[lpKeyRecord-> NameLength] = '\0';
                    }

                }

                //  Does not include terminating null.
                *lpcbKeyName = lpKeyRecord-> NameLength;

                RgUnlockDatablock(lpFileInfo, lpKeynode-> BlockIndex, FALSE);

            }

            RgUnlockKeynode(lpFileInfo, KeynodeIndex, FALSE);

            //  Cache our current position because the caller is likely to turn
            //  around and ask for the next index.
            hKey-> LastEnumKeyIndex = Index;
            hKey-> LastEnumKeyKeynodeIndex = KeynodeIndex;
            hKey-> Flags |= KEYF_ENUMKEYCACHED;

            return ErrorCode;

        }

        TempOffset = lpKeynode-> NextIndex;
        RgUnlockKeynode(lpFileInfo, KeynodeIndex, FALSE);
        KeynodeIndex = TempOffset;

        KeysToSkip--;

    }

#ifdef WANT_HIVE_SUPPORT
    //
    //  Loop over the hives of this key until we find our index or run out of
    //  hives.
    //

    if (hKey-> Flags & KEYF_HIVESALLOWED) {

        lpHiveInfo = hKey-> lpFileInfo-> lpHiveInfoList;

        while (!IsNullPtr(lpHiveInfo)) {

            if (KeysToSkip == 0) {

                ErrorCode = ERROR_SUCCESS;

                if (!IsNullPtr(lpKeyName)) {

                    if (*lpcbKeyName <= lpHiveInfo-> NameLength)
                        ErrorCode = ERROR_MORE_DATA;

                    else {
                        MoveMemory(lpKeyName, lpHiveInfo-> Name, lpHiveInfo->
                            NameLength);
                        lpKeyName[lpHiveInfo-> NameLength] = '\0';
                    }

                }

                //  Does not include terminating null.
                *lpcbKeyName = lpHiveInfo-> NameLength;

                //  We don't worry about the enum key cache if we find a
                //  hit in this code.  This is a rare case and already the cache
                //  that we do have is much better then Win95.

                return ErrorCode;

            }

            lpHiveInfo = lpHiveInfo-> lpNextHiveInfo;
            KeysToSkip--;

        }

    }
#endif

    return ERROR_NO_MORE_ITEMS;

}

//
//  VMMRegEnumKey
//
//  See Win32 documentation for a description of the behavior.
//

LONG
REGAPI
VMMRegEnumKey(
    HKEY hKey,
    DWORD Index,
    LPSTR lpKeyName,
    DWORD cbKeyName
    )
{

    int ErrorCode;

    if (IsBadHugeWritePtr(lpKeyName, cbKeyName))
        return ERROR_INVALID_PARAMETER;

    if (IsEnumIndexTooBig(Index))
        return ERROR_NO_MORE_ITEMS;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) == ERROR_SUCCESS)
        ErrorCode = RgLookupKeyByIndex(hKey, (UINT) Index, lpKeyName,
            &cbKeyName);

    RgUnlockRegistry();

    return ErrorCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmmreg32\regfinfo.h ===
//
//  REGFINFO.H
//
//  Copyright (C) Microsoft Corporation, 1995
//

#ifndef _REGFINFO_
#define _REGFINFO_

#define PAGESHIFT                   12
#define PAGESIZE                    (1 << PAGESHIFT)
#define PAGEMASK                    (PAGESIZE - 1)

#define KEYNODE_BLOCK_SHIFT	    10
#define KEYNODES_PER_BLOCK	    (1 << KEYNODE_BLOCK_SHIFT)
#define KEYNODE_BLOCK_MASK	    (KEYNODES_PER_BLOCK-1)
#define KEYNODES_PER_PAGE	    (PAGESIZE / sizeof(KEYNODE))

#define KN_INDEX_IN_BLOCK(i)        ((i) & KEYNODE_BLOCK_MASK)
#define KN_BLOCK_NUMBER(i)          ((UINT) ((i) >> KEYNODE_BLOCK_SHIFT))

typedef struct _KEYNODE_BLOCK {
    KEYNODE	aKN[KEYNODES_PER_BLOCK];
} KEYNODE_BLOCK, FAR* LPKEYNODE_BLOCK;

#define KEYNODES_PER_PAGE	    (PAGESIZE / sizeof(KEYNODE))

typedef struct _W95KEYNODE_BLOCK {
    W95KEYNODE	aW95KN[KEYNODES_PER_BLOCK];
} W95KEYNODE_BLOCK, FAR* LPW95KEYNODE_BLOCK;

typedef struct _KEYNODE_BLOCK_INFO {
    LPKEYNODE_BLOCK lpKeynodeBlock;
    BYTE Flags;                                 // KBDF_* bits
    BYTE LockCount;
}   KEYNODE_BLOCK_INFO, FAR* LPKEYNODE_BLOCK_INFO;

#define KBIF_ACCESSED               0x01        //  Recently accessed
#define KBIF_DIRTY                  0x02        //  Must rewrite to disk

//  Number of extra KEYNODE_BLOCK_INFO structures to alloc on top of the block
//  count already in the file.  Reduces heap fragmentation in real-mode.
#define KEYNODE_BLOCK_INFO_SLACK_ALLOC 4

#ifdef WIN32
typedef UINT KEY_RECORD_TABLE_ENTRY;
#else
typedef WORD KEY_RECORD_TABLE_ENTRY;
#endif
typedef KEY_RECORD_TABLE_ENTRY FAR* LPKEY_RECORD_TABLE_ENTRY;

#define NULL_KEY_RECORD_TABLE_ENTRY     ((KEY_RECORD_TABLE_ENTRY) 0)
#define IsNullKeyRecordTableEntry(kri)  ((kri) == NULL_KEY_RECORD_TABLE_ENTRY)

typedef struct _DATABLOCK_INFO {
    LPDATABLOCK_HEADER lpDatablockHeader;
    LPKEY_RECORD_TABLE_ENTRY lpKeyRecordTable;
    UINT BlockSize;                             //  cached from datablock header
    UINT FreeBytes;                             //  cached from datablock header
    UINT FirstFreeIndex;                        //  cached from datablock header
    LONG FileOffset;
    BYTE Flags;                                 //  DIF_* bits
    BYTE LockCount;
}   DATABLOCK_INFO, FAR* LPDATABLOCK_INFO;

#define DIF_PRESENT                 0x01        //  In memory
#define DIF_ACCESSED                0x02        //  Recently accessed
#define DIF_DIRTY                   0x04        //  Must rewrite to disk
#define DIF_EXTENDED                0x08        //  Has grown in size

//  Number of extra DATABLOCK_INFO structures to alloc on top of the block count
//  already in the file.  Reduces heap fragmentation in real-mode.
#define DATABLOCK_INFO_SLACK_ALLOC  4

//  When we create or extend a datablock, try to keep it on page boundaries.
#define DATABLOCK_GRANULARITY       4096
#define RgAlignBlockSize(size) \
    (((size) + (DATABLOCK_GRANULARITY - 1)) & ~(DATABLOCK_GRANULARITY - 1))

typedef struct _FILE_INFO {
    struct _FILE_INFO FAR* lpNextFileInfo;
#ifdef WANT_HIVE_SUPPORT
    struct _HIVE_INFO FAR* lpHiveInfoList;
#endif
#ifdef WANT_NOTIFY_CHANGE_SUPPORT
#ifdef WANT_HIVE_SUPPORT
    struct _FILE_INFO FAR* lpParentFileInfo;
#endif
    struct _NOTIFY_CHANGE FAR* lpNotifyChangeList;
#endif
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo;
    UINT KeynodeBlockCount;
    UINT KeynodeBlockInfoAllocCount;
    DWORD CurTotalKnSize;           // Normally = to FileKnSize unless grown
    LPDATABLOCK_INFO lpDatablockInfo;
    UINT DatablockInfoAllocCount;
    FILE_HEADER FileHeader;
    KEYNODE_HEADER KeynodeHeader;
    WORD Flags;                                 //  FI_* bits
    char FileName[ANYSIZE_ARRAY];
}   FILE_INFO, FAR* LPFILE_INFO;

#define FI_DIRTY                    0x0001      //  Must rewrite to disk
#define FI_KEYNODEDIRTY             0x0002      //
#define FI_EXTENDED                 0x0004      //
#define FI_VERSION20                0x0008      //
#define FI_FLUSHING                 0x0010      //  Currently flushing file
#define FI_SWEEPING                 0x0020      //  Currently sweeping file
#define FI_VOLATILE                 0x0040      //  File has no backing store
#define FI_READONLY                 0x0080      //  File cannot be modified
#define FI_REPLACEMENTEXISTS        0x0100      //  RegReplaceKey called on file

typedef struct _HIVE_INFO {
    struct _HIVE_INFO FAR* lpNextHiveInfo;
    LPFILE_INFO lpFileInfo;
    UINT NameLength;
    BYTE Hash;
    char Name[ANYSIZE_ARRAY];
}   HIVE_INFO, FAR* LPHIVE_INFO;

#define CFIN_PRIMARY                0x0000      //  FHT_PRIMARY header type
#define CFIN_SECONDARY              0x0001      //  FHT_SECONDARY header type
#define CFIN_VOLATILE               0x0002      //  File has no backing store
#define CFIN_VERSION20              0x0004      //  Use compact keynode form

int
INTERNAL
RgCreateFileInfoNew(
    LPFILE_INFO FAR* lplpFileInfo,
    LPCSTR lpFileName,
    UINT Flags
    );

int
INTERNAL
RgCreateFileInfoExisting(
    LPFILE_INFO FAR* lplpFileInfo,
    LPCSTR lpFileName
    );

int
INTERNAL
RgInitRootKeyFromFileInfo(
    HKEY hKey
    );

int
INTERNAL
RgDestroyFileInfo(
    LPFILE_INFO lpFileInfo
    );

int
INTERNAL
RgFlushFileInfo(
    LPFILE_INFO lpFileInfo
    );

int
INTERNAL
RgSweepFileInfo(
    LPFILE_INFO lpFileInfo
    );

typedef int (INTERNAL* LPENUMFILEINFOPROC)(LPFILE_INFO);

VOID
INTERNAL
RgEnumFileInfos(
    LPENUMFILEINFOPROC lpEnumFileInfoProc
    );

#define RgIndexKeynodeBlockInfoPtr(lpfi, index) \
    ((LPKEYNODE_BLOCK_INFO) (&(lpfi)-> lpKeynodeBlockInfo[index]))

#define RgIndexDatablockInfoPtr(lpfi, index) \
    ((LPDATABLOCK_INFO) (&(lpfi)-> lpDatablockInfo[index]))

#define RgIndexKeyRecordPtr(lpdi, index) \
    ((LPKEY_RECORD) ((LPBYTE)(lpdi)-> lpDatablockHeader + (lpdi)-> lpKeyRecordTable[(index)]))

BOOL
INTERNAL
RgIsValidFileHeader(
    LPFILE_HEADER lpFileHeader
    );

BOOL
INTERNAL
RgIsValidKeynodeHeader(
    LPKEYNODE_HEADER lpKeynodeHeader
    );

BOOL
INTERNAL
RgIsValidDatablockHeader(
    LPDATABLOCK_HEADER lpDatablockHeader
    );

extern LPFILE_INFO g_RgFileInfoList;

#endif // _REGFINFO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmmreg32\regfinfo.c ===
//
//  REGFINFO.C
//
//  Copyright (C) Microsoft Corporation, 1995
//

#include "pch.h"

LPFILE_INFO g_RgFileInfoList = NULL;

const char g_RgDotBackslashPath[] = ".\\";

#ifdef VXD
    #pragma VxD_RARE_CODE_SEG
#endif

//
//  RgCreateFileInfoNew
//
//  If CFIN_VOLATILE is specified, then we skip trying to create the backing
//  store for the FILE_INFO.  lpFileName should point at a null byte so we can
//  initialize the FILE_INFO properly.
//
//  CFIN_PRIMARY and CFIN_SECONDARY are used to determine the FHT_* constant
//  to put in the file header.
//

int
INTERNAL
RgCreateFileInfoNew(
                   LPFILE_INFO FAR* lplpFileInfo,
                   LPCSTR lpFileName,
                   UINT Flags
                   )
{

    int ErrorCode;
    LPFILE_INFO lpFileInfo;
    HFILE hFile;
    LPKEYNODE lpKeynode;
    DWORD KeynodeIndex;

    if (IsNullPtr((lpFileInfo = (LPFILE_INFO)
                   RgSmAllocMemory(sizeof(FILE_INFO) + StrLen(lpFileName))))) {
        ErrorCode = ERROR_OUTOFMEMORY;
        goto ErrorReturn;
    }

    ZeroMemory(lpFileInfo, sizeof(FILE_INFO));
    StrCpy(lpFileInfo-> FileName, lpFileName);

    //  For volatile FILE_INFOs, we obviously don't need to create the backing
    //  store.
    if (!(Flags & CFIN_VOLATILE)) {

        //  Attempt to the create the given filename.
        if ((hFile = RgCreateFile(lpFileName)) == HFILE_ERROR) {
            ErrorCode = ERROR_REGISTRY_IO_FAILED;
            goto ErrorDestroyFileInfo;
        }

        RgCloseFile(hFile);

    }

    lpFileInfo-> Flags = FI_DIRTY | FI_KEYNODEDIRTY;
    //  lpFileInfo-> lpHiveInfoList = NULL;
    //  lpFileInfo-> lpParentFileInfo = NULL;
    //  lpFileInfo-> lpNotifyChangeList = NULL;
    //  lpFileInfo-> lpKeynodeBlockInfo = NULL;
    //  lpFileInfo-> NumKeynodeBlocks = 0;
    //  lpFileInfo-> NumAllocKNBlocks = 0;
    //  lpFileInfo-> CurTotalKnSize = 0;
    //  lpFileInfo-> lpDatablockInfo = NULL;
    //  lpFileInfo-> DatablockInfoAllocCount = 0;

    if (Flags & CFIN_VOLATILE)
        lpFileInfo-> Flags |= FI_VOLATILE;

    //  Initialize the file header.
    lpFileInfo-> FileHeader.Signature = FH_SIGNATURE;
    //  If we're using compact keynodes, up the version number to make sure
    //  Win95 doesn't try to load this hive.
    if (Flags & CFIN_VERSION20) {
        lpFileInfo-> FileHeader.Version = FH_VERSION20;
        lpFileInfo-> Flags |= FI_VERSION20;
    } else {
        lpFileInfo-> FileHeader.Version = FH_VERSION10;
    }
    //  lpFileInfo-> FileHeader.Size = 0;
    //  lpFileInfo-> FileHeader.Checksum = 0;
    //  lpFileInfo-> FileHeader.BlockCount = 0;
    lpFileInfo-> FileHeader.Flags = FHF_DIRTY;
    lpFileInfo-> FileHeader.Type = ((Flags & CFIN_SECONDARY) ? FHT_SECONDARY :
                                    FHT_PRIMARY);

    //  Initialize the keynode header.
    lpFileInfo-> KeynodeHeader.Signature = KH_SIGNATURE;
    //  lpFileInfo-> KeynodeHeader.FileKnSize = 0;
    lpFileInfo-> KeynodeHeader.RootIndex = REG_NULL;
    lpFileInfo-> KeynodeHeader.FirstFreeIndex = REG_NULL;
    lpFileInfo-> KeynodeHeader.Flags = KHF_DIRTY | KHF_NEWHASH;
    //  lpFileInfo-> KeynodeHeader.Checksum = 0;

    //  Init the keynode data structures.
    if ((ErrorCode = RgInitKeynodeInfo(lpFileInfo)) != ERROR_SUCCESS)
        goto ErrorDeleteFile;

    //  For uncompacted keynode tables, the keynode table now includes at least
    //  the header itself.
    if (!(lpFileInfo-> Flags & FI_VERSION20))
        lpFileInfo-> CurTotalKnSize = sizeof(KEYNODE_HEADER);

    //  Init the datablock data structures.
    if ((ErrorCode = RgInitDatablockInfo(lpFileInfo, HFILE_ERROR)) !=
        ERROR_SUCCESS)
        goto ErrorDeleteFile;

    //  Allocate the keynode for the root of the file.
    if ((ErrorCode = RgAllocKeynode(lpFileInfo, &KeynodeIndex, &lpKeynode)) !=
        ERROR_SUCCESS)
        goto ErrorDeleteFile;

    lpFileInfo-> KeynodeHeader.RootIndex = KeynodeIndex;

    lpKeynode-> ParentIndex = REG_NULL;
    lpKeynode-> NextIndex = REG_NULL;
    lpKeynode-> ChildIndex = REG_NULL;
    lpKeynode-> Hash = 0;
    //  Note that we don't allocate a key record for this root keynode.  Win95
    //  didn't do this either, so we already must handle this case in code that
    //  needs a key record.  Our code is smaller if we just don't allocate this
    //  key record which is rarely ever used anyway...
    lpKeynode-> BlockIndex = NULL_BLOCK_INDEX;

    RgUnlockKeynode(lpFileInfo, KeynodeIndex, TRUE);

    if ((ErrorCode = RgFlushFileInfo(lpFileInfo)) != ERROR_SUCCESS)
        goto ErrorDeleteFile;

    //  Link this FILE_INFO into the global file info list.
    lpFileInfo-> lpNextFileInfo = g_RgFileInfoList;
    g_RgFileInfoList = lpFileInfo;

    *lplpFileInfo = lpFileInfo;
    return ERROR_SUCCESS;

    ErrorDeleteFile:
    if (!(Flags & CFIN_VOLATILE))
        RgDeleteFile(lpFileName);

    ErrorDestroyFileInfo:
    RgDestroyFileInfo(lpFileInfo);

    ErrorReturn:
    TRACE(("RgCreateFileInfoNew: returning %d\n", ErrorCode));
    return ErrorCode;

}

//
//  RgCreateFileInfoExisting
//

int
INTERNAL
RgCreateFileInfoExisting(
                        LPFILE_INFO FAR* lplpFileInfo,
                        LPCSTR lpFileName
                        )
{

    int ErrorCode;
    LPFILE_INFO lpFileInfo;
    HFILE hFile;
    DWORD FileAttributes;

    if (IsNullPtr((lpFileInfo = (LPFILE_INFO)
                   RgSmAllocMemory(sizeof(FILE_INFO) + StrLen(lpFileName))))) {
        ErrorCode = ERROR_OUTOFMEMORY;
        goto ErrorReturn;
    }

    ZeroMemory(lpFileInfo, sizeof(FILE_INFO));
    StrCpy(lpFileInfo-> FileName, lpFileName);

    //  lpFileInfo-> Flags = 0;
    //  lpFileInfo-> lpHiveInfoList = NULL;
    //  lpFileInfo-> lpParentFileInfo = NULL;
    //  lpFileInfo-> lpNotifyChangeList = NULL;
    //  lpFileInfo-> lpKeynodeBlockInfo = NULL;
    //  lpFileInfo-> NumKeynodeBlocks = 0;
    //  lpFileInfo-> NumAllocKNBlocks = 0;
    //  lpFileInfo-> CurTotalKnSize = 0;
    //  lpFileInfo-> lpDatablockInfo = NULL;
    //  lpFileInfo-> DatablockInfoAllocCount = 0;

    ErrorCode = ERROR_REGISTRY_IO_FAILED;   //  Assume this error code

    //  Attempt to the open the given filename.
    if ((hFile = RgOpenFile(lpFileName, OF_READ)) == HFILE_ERROR)
        goto ErrorDestroyFileInfo;

    //  Read and validate the file header.
    if (!RgReadFile(hFile, &lpFileInfo-> FileHeader, sizeof(FILE_HEADER)))
        goto ErrorCloseFile;

    if (!RgIsValidFileHeader(&lpFileInfo-> FileHeader)) {
        ErrorCode = ERROR_BADDB;
        goto ErrorCloseFile;
    }

    lpFileInfo-> FileHeader.Flags &= ~(FHF_DIRTY | FHF_HASCHECKSUM);

    if (lpFileInfo-> FileHeader.Version == FH_VERSION20)
        lpFileInfo-> Flags |= FI_VERSION20;

    //  Read and validate the keynode header.
    if (!RgReadFile(hFile, &lpFileInfo-> KeynodeHeader,
                    sizeof(KEYNODE_HEADER)))
        goto ErrorCloseFile;

    if (lpFileInfo-> KeynodeHeader.Signature != KH_SIGNATURE) {
        ErrorCode = ERROR_BADDB;
        goto ErrorCloseFile;
    }

    //  Init the keynode data structures.
    if ((ErrorCode = RgInitKeynodeInfo(lpFileInfo)) != ERROR_SUCCESS)
        goto ErrorCloseFile;

    //  Init the datablock data structures.
    if ((ErrorCode = RgInitDatablockInfo(lpFileInfo, hFile)) != ERROR_SUCCESS)
        goto ErrorCloseFile;

    RgCloseFile(hFile);

    //  Check if the file can be written to.  We did this in Win95 by getting
    //  the current file attributes and then slamming them back on the file.  If
    //  this failed, then we treated the file as read-only (such as hive from
    //  a read-only network share).  This seems to work, so why change?
    if ((FileAttributes = RgGetFileAttributes(lpFileName)) != (DWORD) -1) {
        if (!RgSetFileAttributes(lpFileName, (UINT) FileAttributes))
            lpFileInfo-> Flags |= FI_READONLY;
    }

    //  Link this FILE_INFO into the global file info list.
    lpFileInfo-> lpNextFileInfo = g_RgFileInfoList;
    g_RgFileInfoList = lpFileInfo;

    *lplpFileInfo = lpFileInfo;
    return ERROR_SUCCESS;

    ErrorCloseFile:
    RgCloseFile(hFile);

    ErrorDestroyFileInfo:
    RgDestroyFileInfo(lpFileInfo);

    ErrorReturn:
    TRACE(("RgCreateFileInfoExisting: returning %d\n", ErrorCode));
    return ErrorCode;

}

//
//  RgIsValidFileHeader
//
//  Returns TRUE if lpFileHeader is a valid FILE_HEADER structure.
//

BOOL
INTERNAL
RgIsValidFileHeader(
                   LPFILE_HEADER lpFileHeader
                   )
{

    if (lpFileHeader-> Signature != FH_SIGNATURE ||
        (lpFileHeader-> Version != FH_VERSION10 &&
         lpFileHeader-> Version != FH_VERSION20))
        return FALSE;

    if (lpFileHeader-> Flags & FHF_HASCHECKSUM &&
        RgChecksum(lpFileHeader, sizeof(FILE_HEADER)) != 0)
        return FALSE;

    return TRUE;

}

//
//  RgDestroyFileInfo
//
//  Unlinks the FILE_INFO from the global list, if appropriate, and frees all
//  memory associated with the structure including the structure itself.
//
//  If the FILE_INFO is dirty, then all changes will be lost.  Call
//  RgFlushFileInfo first if the file should be flushed.
//

int
INTERNAL
RgDestroyFileInfo(
                 LPFILE_INFO lpFileInfo
                 )
{

    LPFILE_INFO lpPrevFileInfo;
    LPFILE_INFO lpCurrFileInfo;
#ifdef WANT_HIVE_SUPPORT
    LPHIVE_INFO lpHiveInfo;
    LPHIVE_INFO lpTempHiveInfo;
#endif
#ifdef WANT_NOTIFY_CHANGE_SUPPORT
    LPNOTIFY_CHANGE lpNotifyChange;
    LPNOTIFY_CHANGE lpTempNotifyChange;
#endif
    UINT Counter;
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo;
    LPDATABLOCK_INFO lpDatablockInfo;

    ASSERT(!IsNullPtr(lpFileInfo));

    RgInvalidateKeyHandles(lpFileInfo, (UINT) -1);

    //
    //  Unlink this FILE_INFO from the the file info list.  Note that the
    //  structure may not have actually been linked in if we're called as a
    //  result of an error in one of the create file info functions.
    //

    lpPrevFileInfo = NULL;
    lpCurrFileInfo = g_RgFileInfoList;

    while (!IsNullPtr(lpCurrFileInfo)) {

        if (lpCurrFileInfo == lpFileInfo) {
            if (IsNullPtr(lpPrevFileInfo))
                g_RgFileInfoList = lpCurrFileInfo-> lpNextFileInfo;
            else
                lpPrevFileInfo-> lpNextFileInfo = lpCurrFileInfo->
                                                  lpNextFileInfo;
            break;
        }

        lpPrevFileInfo = lpCurrFileInfo;
        lpCurrFileInfo = lpCurrFileInfo-> lpNextFileInfo;

    }

#ifdef WANT_HIVE_SUPPORT
    //
    //  Delete all of the hives connected to this FILE_INFO.
    //

    lpHiveInfo = lpFileInfo-> lpHiveInfoList;

    while (!IsNullPtr(lpHiveInfo)) {
        RgDestroyFileInfo(lpHiveInfo-> lpFileInfo);
        lpTempHiveInfo = lpHiveInfo;
        lpHiveInfo = lpHiveInfo-> lpNextHiveInfo;
        RgSmFreeMemory(lpTempHiveInfo);
    }
#endif

#ifdef WANT_NOTIFY_CHANGE_SUPPORT
    //
    //  Signal and free all of the change notifications.  On NT, a hive cannot
    //  be unloaded if there are any open handles referencing it.  Change
    //  notifications are cleaned up when a key handle is closed.  So this
    //  cleanup is unique to our registry code.
    //

    lpNotifyChange = lpFileInfo-> lpNotifyChangeList;

    while (!IsNullPtr(lpNotifyChange)) {
        RgSetAndReleaseEvent(lpNotifyChange-> hEvent);
        lpTempNotifyChange = lpNotifyChange;
        lpNotifyChange = lpNotifyChange-> lpNextNotifyChange;
        RgSmFreeMemory(lpTempNotifyChange);
    }
#endif

    //
    //  Free all memory associated with the keynode table.
    //

    if (!IsNullPtr(lpFileInfo-> lpKeynodeBlockInfo)) {

        for (Counter = 0, lpKeynodeBlockInfo = lpFileInfo-> lpKeynodeBlockInfo;
            Counter < lpFileInfo-> KeynodeBlockCount; Counter++,
            lpKeynodeBlockInfo++) {
            if (!IsNullPtr(lpKeynodeBlockInfo-> lpKeynodeBlock))
                RgFreeMemory(lpKeynodeBlockInfo-> lpKeynodeBlock);
        }

        RgSmFreeMemory(lpFileInfo-> lpKeynodeBlockInfo);

    }

    //
    //  Free all memory associated with the datablocks.
    //

    if (!IsNullPtr(lpFileInfo-> lpDatablockInfo)) {

        for (Counter = 0, lpDatablockInfo = lpFileInfo-> lpDatablockInfo;
            Counter < lpFileInfo-> FileHeader.BlockCount; Counter++,
            lpDatablockInfo++)
            RgFreeDatablockInfoBuffers(lpDatablockInfo);

        RgSmFreeMemory(lpFileInfo-> lpDatablockInfo);

    }

    //
    //  Free the FILE_INFO itself.
    //

    RgSmFreeMemory(lpFileInfo);

    return ERROR_SUCCESS;

}

#ifdef VXD
    #pragma VxD_PAGEABLE_CODE_SEG
#endif

//
//  RgFlushFileInfo
//

int
INTERNAL
RgFlushFileInfo(
               LPFILE_INFO lpFileInfo
               )
{

    int ErrorCode;
    HFILE hSourceFile;
    HFILE hDestinationFile;
    char TempFileName[MAX_PATH];
    UINT Index;

    ASSERT(!IsNullPtr(lpFileInfo));

    if (!IsPostCriticalInit() || IsFileAccessDisabled())
        return ERROR_SUCCESS;               //  Win95 compatibility.

    if (!(lpFileInfo-> Flags & FI_DIRTY))
        return ERROR_SUCCESS;

    //  If we're currently flushing this FILE_INFO and are called again because
    //  of low memory conditions, ignore this request.  Or if this is a memory
    //  only registry file, there's nothing to flush to.
    if (lpFileInfo-> Flags & (FI_FLUSHING | FI_VOLATILE))
        return ERROR_SUCCESS;

    lpFileInfo-> Flags |= FI_FLUSHING;

    ErrorCode = ERROR_REGISTRY_IO_FAILED;   //  Assume this error code

    hSourceFile = HFILE_ERROR;
    hDestinationFile = HFILE_ERROR;

    if (!RgSetFileAttributes(lpFileInfo-> FileName, FILE_ATTRIBUTE_NONE))
        goto CleanupAfterError;

    if (lpFileInfo-> Flags & FI_EXTENDED) {

        if ((Index = StrLen(lpFileInfo-> FileName)) >= MAX_PATH)
            goto CleanupAfterError;

        StrCpy(TempFileName, lpFileInfo-> FileName);

        //  Back up to the last backslash (or the start of the string) and
        //  null-terminate.
        do {
            Index--;
        }   while (Index > 0 && TempFileName[Index] != '\\');

        //  If we found a backslash, then null terminate the string after the
        //  backslash.  Otherwise, we don't have a full qualified pathname, so
        //  make the temporary file in the current directory and pray that's
        //  where the registry file is.
        if (Index != 0)
            TempFileName[Index + 1] = '\0';
        else
            StrCpy(TempFileName, g_RgDotBackslashPath);

        if ((hDestinationFile = RgCreateTempFile(TempFileName)) ==
            HFILE_ERROR)
            goto CleanupAfterError;

        if ((hSourceFile = RgOpenFile(lpFileInfo-> FileName, OF_READ)) ==
            HFILE_ERROR)
            goto CleanupAfterError;

        TRACE(("rewriting to TempFileName = \""));
        TRACE((TempFileName));
        TRACE(("\"\n"));

    }

    else {
        if ((hDestinationFile = RgOpenFile(lpFileInfo-> FileName, OF_WRITE)) ==
            HFILE_ERROR)
            goto CleanupAfterError;
    }

    //  Write out the file header.
    if (hSourceFile != HFILE_ERROR || lpFileInfo-> FileHeader.Flags &
        FHF_DIRTY) {

        //  Note that RgWriteDatablocks and RgWriteDatablocksComplete uses this
        //  value, too.
        if (lpFileInfo-> Flags & FI_VERSION20)
            lpFileInfo-> FileHeader.Size = sizeof(VERSION20_HEADER_PAGE) +
                                           lpFileInfo-> CurTotalKnSize;
        else
            lpFileInfo-> FileHeader.Size = sizeof(FILE_HEADER) +
                                           lpFileInfo-> CurTotalKnSize;

        if (!RgWriteFile(hDestinationFile, &lpFileInfo-> FileHeader,
                         sizeof(FILE_HEADER)))
            goto CleanupAfterError;

    }

    //  Write out the keynode header and table.
    if ((ErrorCode = RgWriteKeynodes(lpFileInfo, hSourceFile,
                                     hDestinationFile)) != ERROR_SUCCESS) {
        TRACE(("RgWriteKeynodes returned error %d\n", ErrorCode));
        goto CleanupAfterError;
    }

    //  Write out the datablocks.
    if ((ErrorCode = RgWriteDatablocks(lpFileInfo, hSourceFile,
                                       hDestinationFile)) != ERROR_SUCCESS) {
        TRACE(("RgWriteDatablocks returned error %d\n", ErrorCode));
        goto CleanupAfterError;
    }

    RgCloseFile(hDestinationFile);

    //  If we're extending the file, we now go back and delete the current file
    //  and replace it with our temporary file.
    if (hSourceFile != HFILE_ERROR) {

        RgCloseFile(hSourceFile);

        ErrorCode = ERROR_REGISTRY_IO_FAILED;   //  Assume this error code

        if (!RgDeleteFile(lpFileInfo-> FileName))
            goto CleanupAfterFilesClosed;

        if (!RgRenameFile(TempFileName, lpFileInfo-> FileName)) {
            DEBUG_OUT(("RgFlushFileInfo failed to replace backing file\n"));
            goto CleanupAfterFilesClosed;
        }

    }

    //  Go back and tell everyone that the write is complete-- the file has
    //  been successfully written to disk.
    RgWriteDatablocksComplete(lpFileInfo);
    RgWriteKeynodesComplete(lpFileInfo);
    lpFileInfo-> FileHeader.Flags &= ~FHF_DIRTY;
    lpFileInfo-> Flags &= ~(FI_DIRTY | FI_EXTENDED);

    ErrorCode = ERROR_SUCCESS;

    CleanupAfterFilesClosed:
    RgSetFileAttributes(lpFileInfo-> FileName, FILE_ATTRIBUTE_READONLY |
                        FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);

    lpFileInfo-> Flags &= ~FI_FLUSHING;

    if (ErrorCode != ERROR_SUCCESS)
        DEBUG_OUT(("RgFlushFileInfo() returning error %d\n", ErrorCode));

    return ErrorCode;

    CleanupAfterError:
    if (hSourceFile != HFILE_ERROR)
        RgCloseFile(hSourceFile);

    if (hDestinationFile != HFILE_ERROR) {

        //  If both hSourceFile and hDestinationFile were valid, then we must
        //  have created a temporary file.  Delete it now that we've failed.
        if (hSourceFile != HFILE_ERROR)
            RgDeleteFile(TempFileName);

        RgSetFileAttributes(lpFileInfo-> FileName, FILE_ATTRIBUTE_READONLY |
                            FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);

    }

    goto CleanupAfterFilesClosed;

}

//
//  RgSweepFileInfo
//

int
INTERNAL
RgSweepFileInfo(
               LPFILE_INFO lpFileInfo
               )
{

    ASSERT(!IsNullPtr(lpFileInfo));

    //  If we're currently sweeping this FILE_INFO and are called again because
    //  of low memory conditions, ignore this request.  Or if this is a memory
    //  only registry file, we can't sweep anything out.
    if (lpFileInfo-> Flags & (FI_FLUSHING | FI_VOLATILE))
        return ERROR_SUCCESS;

    lpFileInfo-> Flags |= FI_SWEEPING;

    RgSweepKeynodes(lpFileInfo);
    RgSweepDatablocks(lpFileInfo);

    lpFileInfo-> Flags &= ~FI_SWEEPING;

    return ERROR_SUCCESS;

}

//
//  RgEnumFileInfos
//
//  Enumerates over all FILE_INFO structures, passing each to the provided
//  callback.  Currently, all errors from callbacks are ignored.
//

VOID
INTERNAL
RgEnumFileInfos(
               LPENUMFILEINFOPROC lpEnumFileInfoProc
               )
{

    LPFILE_INFO lpFileInfo;
    LPFILE_INFO lpTempFileInfo;

    lpFileInfo = g_RgFileInfoList;

    while (!IsNullPtr(lpFileInfo)) {
        lpTempFileInfo = lpFileInfo;
        lpFileInfo = lpFileInfo-> lpNextFileInfo;
        (*lpEnumFileInfoProc)(lpTempFileInfo);
    }

}

#ifdef VXD
    #pragma VxD_RARE_CODE_SEG
#endif

//
//  RgInitRootKeyFromFileInfo
//
//  Using the FILE_INFO contained in the key, initialize the rest of the members
//  of the key.  If any errors occur, then the FILE_INFO is destroyed.
//

int
INTERNAL
RgInitRootKeyFromFileInfo(
                         HKEY hKey
                         )
{

    int ErrorCode;
    LPKEYNODE lpKeynode;

    hKey-> KeynodeIndex = hKey-> lpFileInfo-> KeynodeHeader.RootIndex;

    if ((ErrorCode = RgLockInUseKeynode(hKey-> lpFileInfo, hKey-> KeynodeIndex,
                                        &lpKeynode)) == ERROR_SUCCESS) {

        hKey-> Signature = KEY_SIGNATURE;
        hKey-> Flags &= ~(KEYF_INVALID | KEYF_DELETED | KEYF_ENUMKEYCACHED);
        hKey-> ChildKeynodeIndex = lpKeynode-> ChildIndex;
        hKey-> BlockIndex = (WORD) lpKeynode-> BlockIndex;
        hKey-> KeyRecordIndex = (BYTE) lpKeynode-> KeyRecordIndex;

        RgUnlockKeynode(hKey-> lpFileInfo, hKey-> KeynodeIndex, FALSE);

    }

    else
        RgDestroyFileInfo(hKey-> lpFileInfo);

    return ErrorCode;

}

#ifdef VXD
    #pragma VxD_INIT_CODE_SEG
#endif


//
//  VMMRegMapPredefKeyToFile2 -- Alternate version of VMMRegMapPredefKeyToFile that
//  allows remapping of HKCU.  (Called by VMMRegMapPredefKeyToFile.)
//

LONG
REGAPI
VMMRegMapPredefKeyToFile2(
                         HKEY hKey,
                         LPCSTR lpFileName,
                         UINT Flags,
                         BOOL fAllowMapToHKCU
                         )
{
    int ErrorCode;
#ifdef WIN32
    char FullPathName[MAX_PATH];
#endif
    UINT CreateNewFlags;

    if (!( hKey == HKEY_LOCAL_MACHINE ||
           hKey == HKEY_USERS ||
           (hKey == HKEY_CURRENT_USER && fAllowMapToHKCU))) {
        return ERROR_INVALID_PARAMETER;
    }

    if (IsBadOptionalStringPtr(lpFileName, (UINT) -1))
        return ERROR_INVALID_PARAMETER;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    RgValidateAndConvertKeyHandle(&hKey);

    if (!(hKey-> Flags & KEYF_INVALID))
        RgDestroyFileInfo(hKey-> lpFileInfo);

    //  Specifying NULL "unmaps" the key and leaves it invalidated.
    if (IsNullPtr(lpFileName))
        return ERROR_SUCCESS;

#ifdef WIN32
    //  For users of the Win32 DLL, resolve the path name so they don't have to.
    if ((GetFullPathName(lpFileName, sizeof(FullPathName), FullPathName,
                         NULL)) != 0)
        lpFileName = FullPathName;
#endif

    if (Flags & MPKF_CREATENEW) {
        CreateNewFlags = CFIN_PRIMARY | ((Flags & MPKF_VERSION20) ?
                                         CFIN_VERSION20 : 0);
        ErrorCode = RgCreateFileInfoNew(&hKey-> lpFileInfo, lpFileName,
                                        CreateNewFlags);
    }

    else {
        ErrorCode = RgCreateFileInfoExisting(&hKey-> lpFileInfo, lpFileName);
    }

    if (ErrorCode == ERROR_SUCCESS)
        ErrorCode = RgInitRootKeyFromFileInfo(hKey);

    RgUnlockRegistry();

    return ErrorCode;

}


//
//  VMMRegMapPredefKeyToFile
//

LONG
REGAPI
VMMRegMapPredefKeyToFile(
                        HKEY hKey,
                        LPCSTR lpFileName,
                        UINT Flags
                        )
{
    return VMMRegMapPredefKeyToFile2(hKey, lpFileName, Flags, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmmreg32\regffmt.h ===
//
//  REGFFMT.H
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Defines the physical format of a Windows VMM registry file.
//

#ifndef _REGFFMT_
#define _REGFFMT_

#ifdef WIN32
#include <pshpack1.h>
#else
#pragma pack(1)
#endif

#define REG_NULL                    0xFFFFFFFF

typedef struct _FILE_HEADER {
    DWORD Signature;                            //  FH_SIGNATURE
    DWORD Version;                              //  FH_VERSION_*
    DWORD Size;                                 //  of file header, all keynodes
    DWORD Checksum;                             //  of file header
    WORD BlockCount;
    DWORD Flags;                                //  FHF_* bits
    WORD Type;                                  //  FHT_* constant
    BYTE Reserved[8];
}   FILE_HEADER, UNALIGNED FAR* LPFILE_HEADER;

#define FH_SIGNATURE                0x47455243  //  "CREG"
#define FH_VERSION10                0x00010000  //  Win95 compatible
#define FH_VERSION20                0x00020000  //  Supports compact keynodes

#define FHF_DIRTY                   0x00000001  //  Must rewrite to disk
#define FHF_RESERVED1               0x00000002  //  Dead bit from VERY old files
#define FHF_HASCHECKSUM             0x00000004  //  Checksum member is valid

#define FHT_PRIMARY                 0x0001      //  System hives
#define FHT_SECONDARY               0x0080      //  User/application hives

typedef struct _KEYNODE_HEADER {
    DWORD Signature;                            //  KH_SIGNATURE
    DWORD FileKnSize;				//  of entire keynode table inc header
    DWORD RootIndex;
    DWORD FirstFreeIndex;
    DWORD Flags;                                //  KHF_* bits
    DWORD Checksum;                             //  of entire keynode table
    BYTE Reserved[8];
}   KEYNODE_HEADER, UNALIGNED FAR* LPKEYNODE_HEADER;

#define KH_SIGNATURE                0x4E4B4752  //  "RGKN"

#define KHF_DIRTY                   0x00000001  //  Win95: Must rewrite to disk
#define KHF_EXTENDED                0x00000002  //  Win95: Table has grown
#define KHF_HASCHECKSUM             0x00000004  //  Win95: Checksum is valid
#define KHF_NEWHASH                 0x00000008  //  Alway expect

typedef struct _VERSION20_HEADER_PAGE {
    union {
        struct {
            FILE_HEADER FileHeader;
            KEYNODE_HEADER KeynodeHeader;
        };
        struct {
            BYTE Page[4096];
        };
    };
}   VERSION20_HEADER_PAGE, UNALIGNED FAR* LPVERSION20_HEADER_PAGE;

typedef struct _W95KEYNODE {
    DWORD W95State;				//  KNS_* constant
    union {
        //  State == KNS_USED
        struct {
	    DWORD W95Hash;
            DWORD W95Reserved1;
	    DWORD W95ParentOffset;
	    DWORD W95ChildOffset;
	    DWORD W95NextOffset;
	    DWORD W95DatablockAddress;
        };
        //  State == KNS_FREE or KNS_ALLFREE
        struct {
	    DWORD W95FreeRecordSize;
	    DWORD W95NextFreeOffset;
	    DWORD W95Reserved2[4];
        };
    };
}   W95KEYNODE, UNALIGNED FAR* LPW95KEYNODE;

#define KNS_USED                    0x00000000  //  Keynode
#define KNS_FREE                    0x80000000
#define KNS_ALLFREE                 0xFFFFFFFF

typedef struct _KEYNODE {
    DWORD NextIndex:24,
          Flags:8;
    union {
        //  Flags & KNF_INUSE
	struct {
	    DWORD ChildIndex:24,
		  BinNumber:8;
	    DWORD ParentIndex:24,
                  KeyRecordIndex:8;
            WORD  BlockIndex;
	    WORD  Hash;
        };
        //  !(Flags & KNF_INUSE)
	struct {
            DWORD Reserved;
            DWORD FreeRecordSize;
        };
    };
}   KEYNODE, FAR* LPKEYNODE;

#define KNF_INUSE	0x01		    // Block is in use

#define IsNullKeynodeIndex(kni)     ((kni) >= 0x00FFFFFF)

typedef struct _DATABLOCK_HEADER {
    DWORD Signature;                            //  DH_SIGNATURE
    DWORD BlockSize;
    DWORD FreeBytes;
    WORD Flags;                                 //  DHF_* bits
    WORD BlockIndex;
    DWORD FirstFreeOffset;
    WORD MaxAllocatedIndex;
    WORD FirstFreeIndex;
    DWORD Reserved;
    DWORD Checksum;                             //  of entire datablock
}   DATABLOCK_HEADER, UNALIGNED FAR* LPDATABLOCK_HEADER;

#define DH_SIGNATURE                0x42444752  //  "RGDB"

#define DHF_DIRTY                   0x0001      //  Must rewrite to disk
#define DHF_EXTENDED                0x0002      //  Datablock size has grown
#define DHF_HASCHECKSUM             0x0004      //  Checksum member is valid
#define DHF_HASBLOCKNUMBERS         0x0008      //  Keys contain block numbers

#define DATABLOCKS_PER_FILE         0xFFFE      //  0xFFFF is 'null' block index

//  Arbitrary size pulled from the old registry code.  Oh well, makes it
//  convenient when we do 16-bit math to extend a datablock by 4K.
#define MAXIMUM_DATABLOCK_SIZE      ((DWORD)(60L*1024L))

//  Win95 registry files may not always have a key record for the root key of
//  a file.
#define NULL_BLOCK_INDEX            0xFFFF
#define IsNullBlockIndex(bi)        ((bi) == NULL_BLOCK_INDEX)

typedef struct _KEY_RECORD {
    DWORD AllocatedSize;
    union {
        DWORD DatablockAddress;
        struct {
            WORD KeyRecordIndex;
            WORD BlockIndex;
        };
    };
    DWORD RecordSize;
    WORD NameLength;
    WORD ValueCount;
    WORD ClassLength;
    WORD Reserved;
    char Name[ANYSIZE_ARRAY];
}   KEY_RECORD, UNALIGNED FAR* LPKEY_RECORD;

typedef struct _FREEKEY_RECORD {
    DWORD AllocatedSize;
    DWORD DatablockAddress;                     //  REG_NULL for free records
    DWORD NextFreeOffset;
}   FREEKEY_RECORD, UNALIGNED FAR* LPFREEKEY_RECORD;

typedef struct _VALUE_RECORD {
    DWORD DataType;
    DWORD Reserved;
    WORD NameLength;
    WORD DataLength;
    char Name[ANYSIZE_ARRAY];
}   VALUE_RECORD, UNALIGNED FAR* LPVALUE_RECORD;

#define KEY_RECORDS_PER_DATABLOCK   255

//  Arbitrary size pulled from the old registry code.  Oh well, makes it
//  convenient when we do 16-bit math to extend a datablock by 4K.
#define MAXIMUM_KEY_RECORD_SIZE     \
    ((DWORD)(MAXIMUM_DATABLOCK_SIZE-sizeof(DATABLOCK_HEADER)))

#ifdef WIN32
#include <poppack.h>
#else
#pragma pack()
#endif

#endif // _REGFFMT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmmreg32\regfsio.h ===
//
//  REGFSIO.H
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Prototypes for file system I/O.  Many of these prototypes may not be used
//  if a direct mapping is available in the target environment.
//

#ifndef _REGFSIO_
#define _REGFSIO_

//  Consistent with both 16-bit and 32-bit windows.h.
#ifndef HFILE_ERROR
typedef int HFILE;
#define HFILE_ERROR     ((HFILE)-1)
#endif

//  Special value used for the VMM version when we haven't fully initialized yet
//  but are reading SYSTEM.DAT from the XMS cache.
#define HFILE_MEMORY    ((HFILE)-2)

#ifndef RgCreateFile
HFILE
INTERNAL
RgCreateFile(
    LPCSTR lpFileName
    );
#endif

#ifndef RgOpenFile
HFILE
INTERNAL
RgOpenFile(
    LPCSTR lpFileName,
    int Mode
    );
#endif

#ifndef RgCreateTempFile
HFILE
INTERNAL
RgCreateTempFile(
    LPSTR lpFileName
    );
#endif

#ifndef RgReadFile
BOOL
INTERNAL
RgReadFile(
    HFILE hFile,
    LPVOID lpBuffer,
    UINT ByteCount
    );
#endif

#ifndef RgWriteFile
BOOL
INTERNAL
RgWriteFile(
    HFILE hFile,
    LPVOID lpBuffer,
    UINT ByteCount
    );
#endif

#ifndef RgSeekFile
BOOL
INTERNAL
RgSeekFile(
    HFILE hFile,
    LONG FileOffset
    );
#endif

#ifndef RgCloseFile
VOID
INTERNAL
RgCloseFile(
    HFILE hFile
    );
#endif

#ifndef RgDeleteFile
BOOL
INTERNAL
RgDeleteFile(
    LPCSTR lpFileName
    );
#endif

#ifndef RgRenameFile
BOOL
INTERNAL
RgRenameFile(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName
    );
#endif

#define FILE_ATTRIBUTE_NONE             0

#ifndef RgGetFileAttributes
DWORD
INTERNAL
RgGetFileAttributes(
    LPCSTR lpFileName
    );
#endif

#ifndef RgSetFileAttributes
BOOL
INTERNAL
RgSetFileAttributes(
    LPCSTR lpFileName,
    UINT FileAttributes
    );
#endif

#ifndef RgGetFileSize
DWORD
INTERNAL
RgGetFileSize(
    HFILE hFile
    );
#endif

#endif // _REGFSIO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmmreg32\reginit.c ===
//
//  REGINIT.C
//
//  Copyright (C) Microsoft Corporation, 1995
//

#include "pch.h"

#ifdef DEBUG
extern int g_RgDatablockLockCount;
extern int g_RgKeynodeLockCount;
extern int g_RgMemoryBlockCount;
#endif

#ifdef WANT_DYNKEY_SUPPORT
#ifdef VXD
#pragma VMM_IDATA_SEG
#endif
const char g_RgNull[] = "";
#ifdef VXD
#pragma VMM_PAGEABLE_DATA_SEG
#endif
#endif

#ifdef VXD
//  Set when our post critical init routine is called indicating that it's safe
//  to make disk I/O calls.  May also be set early when RegFlushKey gets the
//  magic HKEY_CRITICAL_FLUSH.
BYTE g_RgPostCriticalInit = FALSE;
//  Set when RegFlushKey gets the magic HKEY_DISABLE_REG.  No disk I/O will be
//  allowed after this flag is set.
BYTE g_RgFileAccessDisabled = FALSE;
#endif

LPVOID g_RgWorkBuffer = NULL;
#ifdef DEBUG
BOOL g_RgWorkBufferBusy = FALSE;
#endif

#ifdef VXD
#pragma VxD_INIT_CODE_SEG
#endif

//
//  VMMRegLibAttach
//
//  Prepares the registry library for use by allocating any global resources.
//  If ERROR_SUCCESS is returned, then VMMRegLibDetach should be called to 
//  release these resources.
//

LONG
REGAPI
VMMRegLibAttach(
    UINT Flags
    )
{

    if (IsNullPtr((g_RgWorkBuffer = RgAllocMemory(SIZEOF_WORK_BUFFER))))
        goto MemoryError;

#ifdef WANT_STATIC_KEYS
    if (!RgAllocKeyHandleStructures())
        goto MemoryError;
#endif

#ifdef WANT_DYNKEY_SUPPORT
    //  Initialize HKEY_DYN_DATA.  If anything fails here, we won't stop the
    //  initialize of the entire registry.
    if (RgCreateFileInfoNew(&g_RgDynDataKey.lpFileInfo, g_RgNull,
        CFIN_VERSION20 | CFIN_VOLATILE) == ERROR_SUCCESS)
        RgInitRootKeyFromFileInfo(&g_RgDynDataKey);

    ASSERT(!(g_RgDynDataKey.Flags & KEYF_INVALID));
#endif

    return ERROR_SUCCESS;

MemoryError:
    //  Release anything that we may have allocated up to this point.
    VMMRegLibDetach();

    TRACE(("VMMRegLibAttach returning ERROR_OUTOFMEMORY\n"));
    return ERROR_OUTOFMEMORY;

}

#ifdef VXD
#pragma VxD_SYSEXIT_CODE_SEG
#endif

#ifdef WANT_FULL_MEMORY_CLEANUP
//
//  RgDetachPredefKey
//
//  Destroys the memory associated with a predefined key and marks the key
//  invalid.
//

VOID
INTERNAL
RgDetachPredefKey(
    HKEY hKey
    )
{

    if (!(hKey-> Flags & KEYF_INVALID)) {
        RgDestroyFileInfo(hKey-> lpFileInfo);
        hKey-> Flags |= KEYF_INVALID;
    }

}
#endif

//
//  VMMRegLibDetach
//
//  Releases resources allocated by VMMRegLibAttach.  This function may be
//  called after VMMRegLibDetach returns an error, so this function and all
//  functions it calls must be aware that their corresponding 'alloc' function
//  was not called.
//

VOID
REGAPI
VMMRegLibDetach(
    VOID
    )
{

    RgEnumFileInfos(RgFlushFileInfo);

#ifdef VXD
    //  Reduce the chance that we'll go and try to touch the file again!
    g_RgFileAccessDisabled = TRUE;
#endif

#ifdef WANT_REGREPLACEKEY
    //  Win95 difference: file replacement used to take place on system startup,
    //  not system exit.  It's much easier to deal with file replacement now
    //  since we know somebody called RegReplaceKey and we only have to do the
    //  work in one component, instead of multiple copies in io.sys, VMM loader,
    //  and VMM.
    RgEnumFileInfos(RgReplaceFileInfo);
#endif

#ifdef WANT_FULL_MEMORY_CLEANUP
    //
    //  Delete the FILE_INFO of each of these top-level keys will cause all
    //  of their hives to be deleted.
    //

    RgDetachPredefKey(&g_RgLocalMachineKey);
    RgDetachPredefKey(&g_RgUsersKey);

#ifdef WANT_DYNKEY_SUPPORT
    RgDetachPredefKey(&g_RgDynDataKey);
#endif

    RgFreeKeyHandleStructures();

    if (!IsNullPtr(g_RgWorkBuffer))
        RgFreeMemory(g_RgWorkBuffer);
#endif

    ASSERT(g_RgDatablockLockCount == 0);
    ASSERT(g_RgKeynodeLockCount == 0);
#ifdef WANT_FULL_MEMORY_CLEANUP
    ASSERT(g_RgMemoryBlockCount == 0);
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmmreg32\regfkey.c ===
//
//  REGFKEY.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegFlushKey and supporting functions.
//

#include "pch.h"

//  Magic HKEY used by Setup to disable disk I/O for the duration of this
//  Windows session (you must restart to re-enable disk I/O).  This is done
//  just before the new SYSTEM.DAT and USER.DAT are copied to their final
//  destination.
#define HKEY_DISABLE_REG            (HKEY) 0x484A574D

//  Magic HKEY used by CONFIGMG to force a flush of the registry before we've
//  received our normal post-critical init call.
#define HKEY_CRITICAL_FLUSH         (HKEY) 0x5350574D

//
//  VMMRegFlushKey
//

LONG
REGAPI
VMMRegFlushKey(
    HKEY hKey
    )
{

    int ErrorCode;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

#ifdef VXD
    //  Set the g_RgFileAccessDisabled flag so that all create or open file
    //  calls will be failed.  The backing stores for our files are about to
    //  be changed, so there's no file for us to go to.
    if (hKey == HKEY_DISABLE_REG) {
        g_RgFileAccessDisabled = TRUE;
        ErrorCode = ERROR_SUCCESS;
        goto ReturnErrorCode;
    }

    //  Set the g_RgPostCriticalInit flag so that all I/O calls will go to disk
    //  instead of the XMS cache.  The XMS cache will be freed when/if the
    //  normal post critical init routine is called, but we should only be
    //  getting this call when we're about to die, so it doesn't really matter.
    if (hKey == HKEY_CRITICAL_FLUSH) {
        g_RgPostCriticalInit = TRUE;
        hKey = HKEY_LOCAL_MACHINE;
    }
#endif

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) == ERROR_SUCCESS)
        ErrorCode = RgFlushFileInfo(hKey-> lpFileInfo);

#ifdef VXD
ReturnErrorCode:
#endif
    RgUnlockRegistry();

    return ErrorCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmmreg32\reghive.c ===
//
//  REGHIVE.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegLoadKey, RegUnLoadKey, RegSaveKey, RegReplaceKey and
//  supporting functions.
//

#include "pch.h"

#ifdef WANT_HIVE_SUPPORT

//  Maximum number of times we'll allow RgCopyBranch to be reentered.
#define MAXIMUM_COPY_RECURSION          32

LPSTR g_RgNameBufferPtr;                //  Temporary buffer for RgCopyBranch
LPBYTE g_RgDataBufferPtr;               //  Temporary buffer for RgCopyBranch
UINT g_RgRecursionCount;                //  Tracks depth of RgCopyBranch

#if MAXIMUM_VALUE_NAME_LENGTH > MAXIMUM_SUB_KEY_LENGTH
#error Code assumes a value name can fit in a subkey buffer.
#endif

#ifdef VXD
#pragma VxD_RARE_CODE_SEG
#endif

//
//  RgValidateHiveSubKey
//
//  Note that unlike most parameter validation routines, this routine must be
//  called with the registry lock taken because we call RgGetNextSubSubKey.
//
//  Pass back the length of the subkey to deal with the trailing backslash
//  problem.
//
//  Returns TRUE if lpSubKey is a valid subkey string for hive functions.
//

BOOL
INTERNAL
RgValidateHiveSubKey(
    LPCSTR lpSubKey,
    UINT FAR* lpHiveKeyLength
    )
{

    LPCSTR lpSubSubKey;
    UINT SubSubKeyLength;

    //  Verify that we have a valid subkey that has one and only one sub-subkey.
    //  Win95 messed this up and it was possible to load a hive with a keyname
    //  containing a backslash!
    return !IsNullPtr(lpSubKey) && !RgIsBadSubKey(lpSubKey) &&
        (RgGetNextSubSubKey(lpSubKey, &lpSubSubKey, lpHiveKeyLength) > 0) &&
        (RgGetNextSubSubKey(NULL, &lpSubSubKey, &SubSubKeyLength) == 0);

}

//
//  VMMRegLoadKey
//
//  See Win32 documentation of RegLoadKey.
//

LONG
REGAPI
VMMRegLoadKey(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPCSTR lpFileName
    )
{

    int ErrorCode;
    HKEY hSubKey;
    UINT SubKeyLength;
    LPHIVE_INFO lpHiveInfo;

    if (IsBadStringPtr(lpFileName, (UINT) -1))
        return ERROR_INVALID_PARAMETER;

    if ((hKey != HKEY_LOCAL_MACHINE) && (hKey != HKEY_USERS))
        return ERROR_BADKEY;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) != ERROR_SUCCESS)
        goto ReturnErrorCode;

    if (!RgValidateHiveSubKey(lpSubKey, &SubKeyLength)) {
        ErrorCode = ERROR_BADKEY;
        goto ReturnErrorCode;
    }

    //  Check if a subkey with the specified name already exists.
    if (RgLookupKey(hKey, lpSubKey, &hSubKey, LK_OPEN) == ERROR_SUCCESS) {
        RgDestroyKeyHandle(hSubKey);
        ErrorCode = ERROR_BADKEY;       //  Win95 compatibility
        goto ReturnErrorCode;
    }

    if (IsNullPtr((lpHiveInfo = (LPHIVE_INFO)
        RgSmAllocMemory(sizeof(HIVE_INFO) + SubKeyLength)))) {
        ErrorCode = ERROR_OUTOFMEMORY;
        goto ReturnErrorCode;
    }

    //  Fill in the HIVE_INFO.
    StrCpy(lpHiveInfo-> Name, lpSubKey);
    lpHiveInfo-> NameLength = SubKeyLength;
    lpHiveInfo-> Hash = (BYTE) RgHashString(lpSubKey, SubKeyLength);

    //  Attempt to create a FILE_INFO for the specified file.  If successful,
    //  link this HIVE_INFO into the parent FILE_INFO's hive list.
    if ((ErrorCode = RgCreateFileInfoExisting(&lpHiveInfo-> lpFileInfo,
        lpFileName)) == ERROR_SUCCESS) {

#ifdef WANT_NOTIFY_CHANGE_SUPPORT
        lpHiveInfo-> lpFileInfo-> lpParentFileInfo = hKey-> lpFileInfo;
#endif
        lpHiveInfo-> lpNextHiveInfo = hKey-> lpFileInfo-> lpHiveInfoList;
        hKey-> lpFileInfo-> lpHiveInfoList = lpHiveInfo;

        //  Signal any notifications waiting on this top-level key.
        RgSignalWaitingNotifies(hKey-> lpFileInfo, hKey-> KeynodeIndex,
            REG_NOTIFY_CHANGE_NAME);

    }

    else
        RgFreeMemory(lpHiveInfo);

ReturnErrorCode:
    RgUnlockRegistry();

    return ErrorCode;

}

//
//  VMMRegUnLoadKey
//
//  See Win32 documentation of RegUnLoadKey.
//

LONG
REGAPI
VMMRegUnLoadKey(
    HKEY hKey,
    LPCSTR lpSubKey
    )
{

    int ErrorCode;
    UINT SubKeyLength;
    LPFILE_INFO lpFileInfo;
    LPHIVE_INFO lpPrevHiveInfo;
    LPHIVE_INFO lpCurrHiveInfo;

    if ((hKey != HKEY_LOCAL_MACHINE) && (hKey != HKEY_USERS))
        return ERROR_BADKEY;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) != ERROR_SUCCESS)
        goto ReturnErrorCode;

    ErrorCode = ERROR_BADKEY;               //  Assume this error code

    if (!RgValidateHiveSubKey(lpSubKey, &SubKeyLength))
        goto ReturnErrorCode;

    lpPrevHiveInfo = NULL;
    lpCurrHiveInfo = hKey-> lpFileInfo-> lpHiveInfoList;

    while (!IsNullPtr(lpCurrHiveInfo)) {

        if (SubKeyLength == lpCurrHiveInfo-> NameLength && RgStrCmpNI(lpSubKey,
            lpCurrHiveInfo-> Name, SubKeyLength) == 0) {

            //  Unlink this HIVE_INFO structure.
            if (IsNullPtr(lpPrevHiveInfo))
                hKey-> lpFileInfo-> lpHiveInfoList = lpCurrHiveInfo->
                    lpNextHiveInfo;
            else
                lpPrevHiveInfo-> lpNextHiveInfo = lpCurrHiveInfo->
                    lpNextHiveInfo;

            //  Flush and destroy it's associated FILE_INFO structure.  When we
            //  destroy the FILE_INFO, all open keys in this hive will be
            //  invalidated.
            lpFileInfo = lpCurrHiveInfo-> lpFileInfo;
            RgFlushFileInfo(lpFileInfo);
            RgDestroyFileInfo(lpFileInfo);

            //  Free the HIVE_INFO itself.
            RgSmFreeMemory(lpCurrHiveInfo);

            //  Signal any notifications waiting on this top-level key.
            RgSignalWaitingNotifies(hKey-> lpFileInfo, hKey-> KeynodeIndex,
                REG_NOTIFY_CHANGE_NAME);

            ErrorCode = ERROR_SUCCESS;
            break;

        }

        lpPrevHiveInfo = lpCurrHiveInfo;
        lpCurrHiveInfo = lpCurrHiveInfo-> lpNextHiveInfo;

    }

ReturnErrorCode:
    RgUnlockRegistry();

    return ErrorCode;

}

//
//  RgCopyBranchHelper
//
//  Copies all of the values and subkeys starting at the specified source key to
//  the specified destination key.
//
//  For Win95 compatibility, we don't stop the copy process if we encounter an
//  error.  (But unlike Win95, we do actually check more error codes)
//
//  SHOULD ONLY BE CALLED BY RgCopyBranch.
//

VOID
INTERNAL
RgCopyBranchHelper(
    HKEY hSourceKey,
    HKEY hDestinationKey
    )
{

    UINT Index;
    DWORD cbNameBuffer;
    LPVALUE_RECORD lpValueRecord;

    //
    //  Copy all of the values from the source key to the destination key.
    //

    Index = 0;

    while (RgLookupValueByIndex(hSourceKey, Index++, &lpValueRecord) ==
        ERROR_SUCCESS) {

        DWORD cbDataBuffer;
        DWORD Type;

        cbNameBuffer = MAXIMUM_VALUE_NAME_LENGTH;
        cbDataBuffer = MAXIMUM_DATA_LENGTH + 1;         //  Terminating null

        if (RgCopyFromValueRecord(hSourceKey, lpValueRecord, g_RgNameBufferPtr,
            &cbNameBuffer, &Type, g_RgDataBufferPtr, &cbDataBuffer) ==
            ERROR_SUCCESS) {
            //  Subtract the terminating null that RgCopyFromValueRecord added
            //  to cbDataBuffer.  We don't save that in the file.
            if (Type == REG_SZ) {
                ASSERT(cbDataBuffer > 0);               //  Must have the null!
                cbDataBuffer--;
            }
            RgSetValue(hDestinationKey, g_RgNameBufferPtr, Type,
                g_RgDataBufferPtr, cbDataBuffer);
        }

        RgUnlockDatablock(hSourceKey-> lpFileInfo, hSourceKey-> BlockIndex,
            FALSE);

    }

    //  We can't recurse forever, so enforce a maximum depth like Win95.
    if (g_RgRecursionCount > MAXIMUM_COPY_RECURSION)
        return;

    g_RgRecursionCount++;

    //
    //  Copy all of the subkeys from the source key to the destination key.
    //

    Index = 0;

    while (TRUE) {

        HKEY hSubSourceKey;
        HKEY hSubDestinationKey;

        cbNameBuffer = MAXIMUM_SUB_KEY_LENGTH;

        if (RgLookupKeyByIndex(hSourceKey, Index++, g_RgNameBufferPtr,
            &cbNameBuffer) != ERROR_SUCCESS)
            break;

        if (RgLookupKey(hSourceKey, g_RgNameBufferPtr, &hSubSourceKey,
            LK_OPEN) == ERROR_SUCCESS) {

            if (RgLookupKey(hDestinationKey, g_RgNameBufferPtr,
                &hSubDestinationKey, LK_CREATE) == ERROR_SUCCESS) {
                RgYield();
                RgCopyBranchHelper(hSubSourceKey, hSubDestinationKey);
                RgDestroyKeyHandle(hSubDestinationKey);
            }

            else
                TRAP();

            RgDestroyKeyHandle(hSubSourceKey);

        }

        else
            TRAP();

    }

    g_RgRecursionCount--;

}

//
//  RgCopyBranch
//
//  Copies all of the values and subkeys starting at the specified source key to
//  the specified destination key.
//
//  This function sets and cleans up for RgCopyBranchHelper who does all
//  the real copying.
//
//  The backing store of the destination file is flushed if successful.
//

int
INTERNAL
RgCopyBranch(
    HKEY hSourceKey,
    HKEY hDestinationKey
    )
{

    int ErrorCode;

    if (IsNullPtr(g_RgNameBufferPtr = RgSmAllocMemory(MAXIMUM_SUB_KEY_LENGTH)))
        ErrorCode = ERROR_OUTOFMEMORY;

    else {

        if (IsNullPtr(g_RgDataBufferPtr = RgSmAllocMemory(MAXIMUM_DATA_LENGTH +
            1)))                                        //  + terminating null
            ErrorCode = ERROR_OUTOFMEMORY;

        else {

            g_RgRecursionCount = 0;
            RgCopyBranchHelper(hSourceKey, hDestinationKey);

            //  Everything should be copied over, so flush the file now since
            //  all callers will be immediately destroying this FILE_INFO
            //  anyways.
            ErrorCode = RgFlushFileInfo(hDestinationKey-> lpFileInfo);

        }

        RgSmFreeMemory(g_RgNameBufferPtr);

    }

    RgSmFreeMemory(g_RgDataBufferPtr);

    return ErrorCode;

}

//
//  RgSaveKey
//
//  Worker routine for VMMRegSaveKey and VMMRegReplaceKey.  Saves all the keys
//  and values starting at hKey, which must point at a valid KEY structure, to
//  the location specified by lpFileName.  The file must not currently exist.
//

int
INTERNAL
RgSaveKey(
    HKEY hKey,
    LPCSTR lpFileName
    )
{

    int ErrorCode;
    HKEY hHiveKey;

    if (IsNullPtr(hHiveKey = RgCreateKeyHandle()))
        ErrorCode = ERROR_OUTOFMEMORY;

    else {

        //  Artificially increment the count, so the below destroy will work.
        RgIncrementKeyReferenceCount(hHiveKey);

        if ((ErrorCode = RgCreateFileInfoNew(&hHiveKey-> lpFileInfo, lpFileName,
            CFIN_SECONDARY)) == ERROR_SUCCESS) {

            if (((ErrorCode = RgInitRootKeyFromFileInfo(hHiveKey)) != ERROR_SUCCESS) ||
                ((ErrorCode = RgCopyBranch(hKey, hHiveKey)) != ERROR_SUCCESS)) {
                RgSetFileAttributes(hHiveKey-> lpFileInfo-> FileName,
                    FILE_ATTRIBUTE_NONE);
                RgDeleteFile(hHiveKey-> lpFileInfo-> FileName);
            }

            //  If successful, then RgCopyBranch has already flushed the file.
            RgDestroyFileInfo(hHiveKey-> lpFileInfo);

        }

        RgDestroyKeyHandle(hHiveKey);

    }

    return ErrorCode;

}

//
//  VMMRegSaveKey
//
//  See Win32 documentation of RegSaveKey.
//

LONG
REGAPI
VMMRegSaveKey(
    HKEY hKey,
    LPCSTR lpFileName,
    LPVOID lpSecurityAttributes
    )
{

    int ErrorCode;

    if (IsBadStringPtr(lpFileName, (UINT) -1))
        return ERROR_INVALID_PARAMETER;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) == ERROR_SUCCESS)
        ErrorCode = RgSaveKey(hKey, lpFileName);

    RgUnlockRegistry();

    return ErrorCode;

    UNREFERENCED_PARAMETER(lpSecurityAttributes);

}

#ifdef WANT_REGREPLACEKEY

//
//  RgGetKeyName
//

LPSTR
INTERNAL
RgGetKeyName(
    HKEY hKey
    )
{

    LPSTR lpKeyName;
    LPKEY_RECORD lpKeyRecord;

    if (RgLockKeyRecord(hKey-> lpFileInfo, hKey-> BlockIndex, hKey->
        KeyRecordIndex, &lpKeyRecord) != ERROR_SUCCESS)
        lpKeyName = NULL;

    else {

        //  A registry is corrupt if we ever hit this.  We'll continue to
        //  allocate a buffer and let downstream code fail when we try to use
        //  the string.
        ASSERT(lpKeyRecord-> NameLength < MAXIMUM_SUB_KEY_LENGTH);

        if (!IsNullPtr(lpKeyName = (LPSTR) RgSmAllocMemory(lpKeyRecord->
            NameLength + 1))) {                         //  + terminating null
            MoveMemory(lpKeyName, lpKeyRecord-> Name, lpKeyRecord->
                NameLength);
            lpKeyName[lpKeyRecord-> NameLength] = '\0';
        }

        RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BlockIndex, FALSE);

    }

    return lpKeyName;

}

//
//  RgCreateRootKeyForFile
//
//  Creates a KEY and a FILE_INFO to access the specified file.
//

int
INTERNAL
RgCreateRootKeyForFile(
    LPHKEY lphKey,
    LPCSTR lpFileName
    )
{

    int ErrorCode;
    HKEY hKey;

    if (IsNullPtr(hKey = RgCreateKeyHandle()))
        ErrorCode = ERROR_OUTOFMEMORY;

    else {

        //  Artificially increment the count, so RgDestroyKeyHandle will work.
        RgIncrementKeyReferenceCount(hKey);

        if ((ErrorCode = RgCreateFileInfoExisting(&hKey-> lpFileInfo,
            lpFileName)) == ERROR_SUCCESS) {

            if ((ErrorCode = RgInitRootKeyFromFileInfo(hKey)) ==
                ERROR_SUCCESS) {
                *lphKey = hKey;
                return ERROR_SUCCESS;
            }

            RgDestroyFileInfo(hKey-> lpFileInfo);

        }

        RgDestroyKeyHandle(hKey);

    }

    return ErrorCode;

}

//
//  RgDestroyRootKeyForFile
//
//  Destroys the resources allocated by RgCreateRootKeyForFile.
//

VOID
INTERNAL
RgDestroyRootKeyForFile(
    HKEY hKey
    )
{

    RgDestroyFileInfo(hKey-> lpFileInfo);
    RgDestroyKeyHandle(hKey);

}

//
//  RgDeleteHiveFile
//
//  Deletes the specified hive file after clearing its file attributes.
//

BOOL
INTERNAL
RgDeleteHiveFile(
    LPCSTR lpFileName
    )
{

    RgSetFileAttributes(lpFileName, FILE_ATTRIBUTE_NONE);
    //  RgSetFileAttributes may fail, but try to delete the file anyway.
    return RgDeleteFile(lpFileName);

}

//
//  VMMRegReplaceKey
//
//  See Win32 documentation of RegReplaceKey.
//

LONG
REGAPI
VMMRegReplaceKey(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPCSTR lpNewFileName,
    LPCSTR lpOldFileName
    )
{

    int ErrorCode;
    HKEY hSubKey;
    LPKEYNODE lpKeynode;
    DWORD KeynodeIndex;
    HKEY hParentKey;
    char ReplaceFileName[MAX_PATH];
    BOOL fCreatedReplaceFile;
    HKEY hReplaceKey;
    HKEY hNewKey;
    HKEY hReplaceSubKey;
    LPSTR lpReplaceSubKey;

    if (IsBadOptionalStringPtr(lpSubKey, (UINT) -1) ||
        IsBadStringPtr(lpNewFileName, (UINT) -1) ||
        IsBadStringPtr(lpOldFileName, (UINT) -1))
        return ERROR_INVALID_PARAMETER;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) != ERROR_SUCCESS)
        goto ErrorReturn;

    if ((ErrorCode = RgLookupKey(hKey, lpSubKey, &hSubKey, LK_OPEN)) !=
        ERROR_SUCCESS)
        goto ErrorReturn;

    //
    //  The provided key handle must an immediate child from the same backing
    //  store (not a hive) as either HKEY_LOCAL_MACHINE or HKEY_USERS.
    //

    if (RgLockInUseKeynode(hSubKey-> lpFileInfo, hSubKey-> KeynodeIndex,
        &lpKeynode) != ERROR_SUCCESS) {
        ErrorCode = ERROR_OUTOFMEMORY;
        goto ErrorDestroySubKey;
    }

    KeynodeIndex = lpKeynode-> ParentIndex;
    RgUnlockKeynode(hSubKey-> lpFileInfo, hSubKey-> KeynodeIndex, FALSE);

    //  Find an open key on the parent check if it's HKEY_LOCAL_MACHINE or
    //  HKEY_USERS.  If not, bail out.  KeynodeIndex may be REG_NULL, but
    //  RgFindOpenKeyHandle handles that case.
    if (IsNullPtr(hParentKey = RgFindOpenKeyHandle(hSubKey-> lpFileInfo,
        KeynodeIndex)) || ((hParentKey != &g_RgLocalMachineKey) &&
        (hParentKey != &g_RgUsersKey))) {
        ErrorCode = ERROR_INVALID_PARAMETER;
        goto ErrorDestroySubKey;
    }

    //
    //  All parameters have been validated, so begin the real work of the API.
    //

    //  Because we'll be doing a file copy below, all changes must be flushed
    //  now.
    if ((ErrorCode = RgFlushFileInfo(hSubKey-> lpFileInfo)) != ERROR_SUCCESS)
        goto ErrorDestroySubKey;

    //  Make a backup of the current contents of the subkey.
    if ((ErrorCode = RgSaveKey(hSubKey, lpOldFileName)) != ERROR_SUCCESS)
        goto ErrorDestroySubKey;

    RgGenerateAltFileName(hSubKey-> lpFileInfo-> FileName, ReplaceFileName, 'R');

    //  Check if the magic replacement file already exists and if not, create
    //  it.
    if (RgGetFileAttributes(ReplaceFileName) == (DWORD) -1) {
        if ((ErrorCode = RgCopyFile(hSubKey-> lpFileInfo-> FileName,
            ReplaceFileName)) != ERROR_SUCCESS)
            goto ErrorDeleteOldFile;
        fCreatedReplaceFile = TRUE;
    }

    else
        fCreatedReplaceFile = FALSE;

    if ((ErrorCode = RgCreateRootKeyForFile(&hNewKey, lpNewFileName)) !=
        ERROR_SUCCESS)
        goto ErrorDeleteReplaceFile;

    if ((ErrorCode = RgCreateRootKeyForFile(&hReplaceKey, ReplaceFileName)) !=
        ERROR_SUCCESS)
        goto ErrorDestroyNewRootKey;

    //  The original key that we were given may reference the subkey, so
    //  lpSubKey would be a NULL or empty string.  But we need the name that
    //  this subkey refers to, so we have to go back to the file to pull out
    //  the name.
    if (hKey != hSubKey)
        lpReplaceSubKey = (LPSTR) lpSubKey;

    else {
        //  We allocate this from the heap to reduce the requirements of an
        //  already strained stack.  If this fails, we're likely out of memory.
        //  Even if that's not why we failed, this is such an infrequent path
        //  that it's a good enough error code.
        if (IsNullPtr(lpReplaceSubKey = RgGetKeyName(hSubKey))) {
            ErrorCode = ERROR_OUTOFMEMORY;
            goto ErrorDestroyReplaceRootKey;
        }
    }

    //  Check if the specified subkey already exists and if it does, delete it.
    if (RgLookupKey(hReplaceKey, lpReplaceSubKey, &hReplaceSubKey, LK_OPEN) ==
        ERROR_SUCCESS) {
        RgDeleteKey(hReplaceSubKey);
        RgDestroyKeyHandle(hReplaceSubKey);
    }

    //  Create the specified subkey in the replacement registry and copy the
    //  new hive to that key.
    if ((ErrorCode = RgLookupKey(hReplaceKey, lpReplaceSubKey, &hReplaceSubKey,
        LK_CREATE)) == ERROR_SUCCESS) {

        //  If successful, tag the FILE_INFO so that on system exit, we'll go
        //  and rename the replacement file to actual filename.
        if ((ErrorCode = RgCopyBranch(hNewKey, hReplaceSubKey)) ==
            ERROR_SUCCESS)
            hKey-> lpFileInfo-> Flags |= FI_REPLACEMENTEXISTS;

        RgDestroyKeyHandle(hReplaceSubKey);

    }

    if (lpSubKey != lpReplaceSubKey)
        RgSmFreeMemory(lpReplaceSubKey);

ErrorDestroyReplaceRootKey:
    RgDestroyRootKeyForFile(hReplaceKey);

ErrorDestroyNewRootKey:
    RgDestroyRootKeyForFile(hNewKey);

ErrorDeleteReplaceFile:
    if (ErrorCode != ERROR_SUCCESS && fCreatedReplaceFile)
        RgDeleteHiveFile(ReplaceFileName);

ErrorDeleteOldFile:
    if (ErrorCode != ERROR_SUCCESS)
        RgDeleteHiveFile(lpOldFileName);

ErrorDestroySubKey:
    RgDestroyKeyHandle(hSubKey);

ErrorReturn:
    RgUnlockRegistry();

    return ErrorCode;

}

#ifdef VXD
#pragma VxD_SYSEXIT_CODE_SEG
#endif

//
//  RgReplaceFileOnSysExit
//
//  Essentially the same algorithm as rlReplaceFile from the Win95 registry
//  code with modifications for how file I/O is handled in this library.
//

int
INTERNAL
RgReplaceFileOnSysExit(
    LPCSTR lpFileName
    )
{

    int ErrorCode;
    char ReplaceFileName[MAX_PATH];
    char SaveFileName[MAX_PATH];

    ErrorCode = ERROR_SUCCESS;

    if (RgGenerateAltFileName(lpFileName, ReplaceFileName, 'R') &&
        RgGetFileAttributes(ReplaceFileName) == (FILE_ATTRIBUTE_READONLY |
        FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM)) {

        //  If we were able to generate the replace file name, then we must be
        //  able to generate the save file name, so ignore the result.
        RgGenerateAltFileName(lpFileName, SaveFileName, 'S');
        RgDeleteHiveFile(SaveFileName);

        //  Preserve the current hive in case something fails below.
        if (!RgSetFileAttributes(lpFileName, FILE_ATTRIBUTE_NONE) ||
            !RgRenameFile(lpFileName, SaveFileName))
            ErrorCode = ERROR_REGISTRY_IO_FAILED;

        else {
            //  Now try to move the replacement in.
            if (!RgSetFileAttributes(ReplaceFileName, FILE_ATTRIBUTE_NONE) ||
                !RgRenameFile(ReplaceFileName, lpFileName)) {
                ErrorCode = ERROR_REGISTRY_IO_FAILED;
                RgRenameFile(SaveFileName, lpFileName);
            }
            else
                RgDeleteFile(SaveFileName);
        }

        RgSetFileAttributes(lpFileName, FILE_ATTRIBUTE_READONLY |
            FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);

    }

    return ErrorCode;

}

//
//  RgReplaceFileInfo
//
//  Called during registry detach to do any necessary file replacements as a
//  result of calling RegReplaceKey.
//

int
INTERNAL
RgReplaceFileInfo(
    LPFILE_INFO lpFileInfo
    )
{

    if (lpFileInfo-> Flags & FI_REPLACEMENTEXISTS)
        RgReplaceFileOnSysExit(lpFileInfo-> FileName);

    return ERROR_SUCCESS;

}

#endif // WANT_REGREPLACEKEY

#endif // WANT_HIVE_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmmreg32\regknode.h ===
//
//  REGKNODE.H
//
//  Copyright (C) Microsoft Corporation, 1995
//

#ifndef _REGKNODE_
#define _REGKNODE_

int
INTERNAL
RgInitKeynodeInfo(
    LPFILE_INFO lpFileInfo
    );

int
INTERNAL
RgLockKeynode(
    LPFILE_INFO lpFileInfo,
    DWORD KeynodeIndex,
    LPKEYNODE FAR* lplpKeynode
    );

int
INTERNAL
RgLockInUseKeynode(
    LPFILE_INFO lpFileInfo,
    DWORD KeynodeIndex,
    LPKEYNODE FAR* lplpKeynode
    );

VOID
INTERNAL
RgUnlockKeynode(
    LPFILE_INFO lpFileInfo,
    DWORD KeynodeIndex,
    BOOL fMarkDirty
    );

int
INTERNAL
RgWriteKeynodes(
    LPFILE_INFO lpFileInfo,
    HFILE hSrcFile,
    HFILE hDestFile
    );

VOID
INTERNAL
RgWriteKeynodesComplete(
    LPFILE_INFO lpFileInfo
    );

VOID
INTERNAL
RgSweepKeynodes(
    LPFILE_INFO lpFileInfo
    );

int
INTERNAL
RgAllocKeynode(
    LPFILE_INFO lpFileInfo,
    LPDWORD lpKeynodeIndex,
    LPKEYNODE FAR* lplpKeynode
    );

int
INTERNAL
RgFreeKeynode(
    LPFILE_INFO lpFileInfo,
    DWORD KeynodeIndex
    );

#endif // _REGKNODE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmmreg32\regknode.c ===
//
//  REGKNODE.C
//
//  Copyright (C) Microsoft Corporation, 1995
//

#include "pch.h"

DECLARE_DEBUG_COUNT(g_RgKeynodeLockCount);

#define HAS_COMPACT_KEYNODES(lpfi)      ((lpfi)-> Flags & FI_VERSION20)

#define SIZEOF_KEYNODE_BLOCK(lpfi)      \
    ((HAS_COMPACT_KEYNODES(lpfi)) ? sizeof(KEYNODE_BLOCK) : sizeof(W95KEYNODE_BLOCK))

#define SIZEOF_FILE_KEYNODE(lpfi)       \
    ((HAS_COMPACT_KEYNODES(lpfi)) ? sizeof(KEYNODE) : sizeof(W95KEYNODE))

#define ROUND_UP(i, basesize) (((((i) + (basesize) - 1) / (basesize))) * (basesize))

#define BLOCK_DESC_GROW_SIZE 0x400

#define W95KEYNODES_PER_PAGE            (PAGESIZE / sizeof(W95KEYNODE))

typedef BOOL (INTERNAL *LPPROCESSKEYNODEPROC)(LPKEYNODE, LPW95KEYNODE);

//
//  RgOffsetToIndex
//

DWORD
INTERNAL
RgOffsetToIndex(
               DWORD W95KeynodeOffset
               )
{

    return (W95KeynodeOffset == REG_NULL) ? W95KeynodeOffset :
    (W95KeynodeOffset / sizeof(W95KEYNODE));

}

//
//  RgIndexToOffset
//

DWORD
INTERNAL
RgIndexToOffset(
               DWORD KeynodeIndex
               )
{

    if (IsNullKeynodeIndex(KeynodeIndex))
        return REG_NULL;

    else {
        if (KeynodeIndex >= 2 * W95KEYNODES_PER_PAGE) {
            DWORD dwUnroundedOff = (KeynodeIndex * sizeof(W95KEYNODE))
                                   + sizeof(W95KEYNODE)-1;
            DWORD dwRoundPage = ((dwUnroundedOff & PAGEMASK) / sizeof(W95KEYNODE))
                                * sizeof(W95KEYNODE);
            return ((dwUnroundedOff & ~PAGEMASK) + dwRoundPage);
        } else {
            return (((KeynodeIndex-1)*sizeof(W95KEYNODE))+sizeof(KEYNODE_HEADER));
        }
    }

}

//
//  RgPackKeynode
//
//  Packs the data from the provided W95KEYNODE to the KEYNODE structure.
//

BOOL
INTERNAL
RgPackKeynode(
             LPKEYNODE lpKeynode,
             LPW95KEYNODE lpW95Keynode
             )
{
    lpKeynode->Flags = 0;

    //  Don't use a switch statement here.  Apparently the compiler will treat
    //  lpW95Keynode->W95State as an integer, so the 16-bit compiler ends up truncating
    //  the value.

    if (lpW95Keynode->W95State == KNS_USED) {
        lpKeynode->Flags = KNF_INUSE;
        lpKeynode->ParentIndex = RgOffsetToIndex(lpW95Keynode->W95ParentOffset);
        lpKeynode->NextIndex = RgOffsetToIndex(lpW95Keynode->W95NextOffset);
        lpKeynode->ChildIndex = RgOffsetToIndex(lpW95Keynode->W95ChildOffset);
        lpKeynode->KeyRecordIndex = LOWORD(lpW95Keynode->W95DatablockAddress);
        lpKeynode->BlockIndex = HIWORD(lpW95Keynode->W95DatablockAddress);
        lpKeynode->Hash = (WORD)lpW95Keynode->W95Hash;
    }

    else if (lpW95Keynode->W95State == KNS_FREE || lpW95Keynode->W95State ==
             KNS_ALLFREE) {
        lpKeynode->FreeRecordSize = lpW95Keynode->W95FreeRecordSize;
        lpKeynode->NextIndex = RgOffsetToIndex(lpW95Keynode->W95NextFreeOffset);
        //  Review this later.  Previous versions of this code checked
        //  if the next index was REG_NULL and bailed out of the processing
        //  loop.  It's possible to have a registry with a free keynode sitting
        //  in the middle of some keynode block and that keynode is the last
        //  in the chain.  We don't want to bail out in those cases.
        //
        //  For now, just bail out if the free record size is greater than a
        //  couple keynodes indicating that this is probably the last free
        //  record and the last record of the keynode.
        if (lpKeynode-> FreeRecordSize > (sizeof(W95KEYNODE)*2))
            return TRUE;
    }

    else {
        DEBUG_OUT(("RgPackKeynode: Unrecognized state (%lx)\n", lpW95Keynode->
                   W95State));
    }

    return FALSE;
}

//
//  RgUnpackKeynode
//
//  Unpacks the data from the provided KEYNODE to the W95KEYNODE structure.
//

BOOL
INTERNAL
RgUnpackKeynode(
               LPKEYNODE lpKeynode,
               LPW95KEYNODE lpW95Keynode
               )
{

    if (lpKeynode->Flags & KNF_INUSE) {

        lpW95Keynode->W95State = KNS_USED;
        lpW95Keynode->W95ParentOffset = RgIndexToOffset(lpKeynode->ParentIndex);
        lpW95Keynode->W95NextOffset = RgIndexToOffset(lpKeynode->NextIndex);
        lpW95Keynode->W95ChildOffset = RgIndexToOffset(lpKeynode->ChildIndex);
        lpW95Keynode->W95Hash = lpKeynode->Hash;

        //  Handle Win95 registries that don't have a key record for the root
        //  key.  The datablock address must be REG_NULL for Win95 to work.
        lpW95Keynode->W95DatablockAddress = IsNullBlockIndex(lpKeynode->
                                                             BlockIndex) ? REG_NULL : MAKELONG(lpKeynode-> KeyRecordIndex,
                                                                                               lpKeynode-> BlockIndex);

    }

    else {

        lpW95Keynode->W95State = KNS_FREE;
        lpW95Keynode->W95FreeRecordSize = lpKeynode->FreeRecordSize;
        lpW95Keynode->W95NextFreeOffset = RgIndexToOffset(lpKeynode->NextIndex);

    }

    return FALSE;

}

//
//  RgProcessKeynodeBlock
//
//  The provided callback function is called for each pair of KEYNODE and
//  W95KEYNODE structures from the given keynode blocks.
//

VOID
INTERNAL
RgProcessKeynodeBlock(
                     DWORD dwStartOffset,
                     DWORD dwBlockSize,
                     LPKEYNODE_BLOCK lpKeynodeBlock,
                     LPW95KEYNODE_BLOCK lpW95KeynodeBlock,
                     LPPROCESSKEYNODEPROC lpfnProcessKeynode
                     )
{

    DWORD dwCurOffset;
    LPKEYNODE lpKeynode;
    LPW95KEYNODE lpW95Keynode;
    UINT SkipSize;

    dwCurOffset = dwStartOffset;
    lpW95Keynode = &lpW95KeynodeBlock->aW95KN[0];
    SkipSize = (dwStartOffset == 0) ? sizeof(KEYNODE_HEADER) : 0;

    for (;;) {

        lpW95Keynode = (LPW95KEYNODE)(((LPBYTE)lpW95Keynode)+SkipSize);
        dwCurOffset += SkipSize;

        if (dwCurOffset >= dwStartOffset+dwBlockSize) {
            goto Done;
        }
        lpKeynode = &lpKeynodeBlock->aKN[KN_INDEX_IN_BLOCK(RgOffsetToIndex(dwCurOffset))];
        while ((dwCurOffset < dwStartOffset+dwBlockSize) &&
               ((dwCurOffset >> PAGESHIFT) == 0) ||
               ((dwCurOffset >> PAGESHIFT) ==
                ((dwCurOffset + sizeof(W95KEYNODE)) >> PAGESHIFT))) {
            if (lpfnProcessKeynode(lpKeynode, lpW95Keynode)) {
                goto Done;
            }
            dwCurOffset += sizeof(W95KEYNODE);
            lpW95Keynode++;
            lpKeynode++;
        }
        //
        //  Compute the number of bytes to skip to get to the next page
        //
        SkipSize = PAGESIZE - (UINT) (dwCurOffset & PAGEMASK);
    }
    Done: {};

}

//
//  RgLockKeynode
//

int
INTERNAL
RgLockKeynode(
             LPFILE_INFO lpFileInfo,
             DWORD KeynodeIndex,
             LPKEYNODE FAR* lplpKeynode
             )
{

    int ErrorCode;
    UINT KeynodeBlockIndex;
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo;
    UINT KeynodeBlockSize;
    HFILE hFile;
    LPKEYNODE_BLOCK lpKeynodeBlock;
    LPW95KEYNODE_BLOCK lpW95KeynodeBlock;
    DWORD BlockOffset;
    UINT ReadBlockSize;

    KeynodeBlockIndex = KN_BLOCK_NUMBER(KeynodeIndex);

    if (KeynodeBlockIndex > lpFileInfo-> KeynodeBlockCount) {
        DEBUG_OUT(("RgLockKeynode: invalid keynode offset\n"));
        return ERROR_BADDB;
    }

    //
    //  Is the keynode block currently in memory?
    //

    lpKeynodeBlockInfo = RgIndexKeynodeBlockInfoPtr(lpFileInfo,
                                                    KeynodeBlockIndex);
    lpKeynodeBlock = lpKeynodeBlockInfo-> lpKeynodeBlock;

    if (IsNullPtr(lpKeynodeBlock)) {

        NOISE(("RgLockKeynode: "));
        NOISE((lpFileInfo-> FileName));
        NOISE((", block %d\n", KeynodeBlockIndex));

        if (IsNullPtr((lpKeynodeBlock = (LPKEYNODE_BLOCK)
                       RgAllocMemory(sizeof(KEYNODE_BLOCK)))))
            return ERROR_OUTOFMEMORY;

        KeynodeBlockSize = SIZEOF_KEYNODE_BLOCK(lpFileInfo);
        BlockOffset = (DWORD) KeynodeBlockIndex * KeynodeBlockSize;

        if (BlockOffset < lpFileInfo-> KeynodeHeader.FileKnSize) {

            ASSERT(!(lpFileInfo-> Flags & FI_VOLATILE));

            ReadBlockSize = (UINT) min(KeynodeBlockSize, (lpFileInfo->
                                                          KeynodeHeader.FileKnSize - BlockOffset));

            if ((hFile = RgOpenFile(lpFileInfo-> FileName, OF_READ)) ==
                HFILE_ERROR)
                goto CleanupAfterFileError;

            if (HAS_COMPACT_KEYNODES(lpFileInfo)) {

                if (!RgSeekFile(hFile, sizeof(VERSION20_HEADER_PAGE) +
                                BlockOffset))
                    goto CleanupAfterFileError;

                if (!RgReadFile(hFile, lpKeynodeBlock, ReadBlockSize))
                    goto CleanupAfterFileError;

            }

            else {

                if (!RgSeekFile(hFile, sizeof(FILE_HEADER) + BlockOffset))
                    goto CleanupAfterFileError;

                lpW95KeynodeBlock = (LPW95KEYNODE_BLOCK) RgLockWorkBuffer();

                if (!RgReadFile(hFile, lpW95KeynodeBlock, ReadBlockSize)) {
                    RgUnlockWorkBuffer(lpW95KeynodeBlock);
                    goto CleanupAfterFileError;
                }

                RgProcessKeynodeBlock(BlockOffset, ReadBlockSize,
                                      lpKeynodeBlock, lpW95KeynodeBlock, RgPackKeynode);

                RgUnlockWorkBuffer(lpW95KeynodeBlock);

            }

            RgCloseFile(hFile);

        }

        lpKeynodeBlockInfo-> lpKeynodeBlock = lpKeynodeBlock;
        lpKeynodeBlockInfo-> Flags = 0;
        lpKeynodeBlockInfo-> LockCount = 0;

    }

    *lplpKeynode = &lpKeynodeBlock-> aKN[KN_INDEX_IN_BLOCK(KeynodeIndex)];
    lpKeynodeBlockInfo-> Flags |= KBIF_ACCESSED;
    lpKeynodeBlockInfo-> LockCount++;

    INCREMENT_DEBUG_COUNT(g_RgKeynodeLockCount);
    return ERROR_SUCCESS;

    CleanupAfterFileError:
    ErrorCode = ERROR_REGISTRY_IO_FAILED;

    RgFreeMemory(lpKeynodeBlock);

    if (hFile != HFILE_ERROR)
        RgCloseFile(hFile);

    DEBUG_OUT(("RgLockKeynode() returning error %d\n", ErrorCode));
    return ErrorCode;

}

//
//  RgLockInUseKeynode
//
//  Wrapper for RgLockKeynode that guarantees that the returned keynode is
//  marked as being in-use.  If not, ERROR_BADDB is returned.
//

int
INTERNAL
RgLockInUseKeynode(
                  LPFILE_INFO lpFileInfo,
                  DWORD KeynodeIndex,
                  LPKEYNODE FAR* lplpKeynode
                  )
{

    int ErrorCode;

    if ((ErrorCode = RgLockKeynode(lpFileInfo, KeynodeIndex, lplpKeynode)) ==
        ERROR_SUCCESS) {
        if (!((*lplpKeynode)-> Flags & KNF_INUSE)) {
            DEBUG_OUT(("RgLockInUseKeynode: keynode unexpectedly not marked used\n"));
            RgUnlockKeynode(lpFileInfo, KeynodeIndex, FALSE);
            ErrorCode = ERROR_BADDB;
        }
    }

    return ErrorCode;

}

//
//  RgUnlockKeynode
//

VOID
INTERNAL
RgUnlockKeynode(
               LPFILE_INFO lpFileInfo,
               DWORD KeynodeIndex,
               BOOL fMarkDirty
               )
{

    UINT KeynodeBlockIndex;
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo;

    KeynodeBlockIndex = KN_BLOCK_NUMBER(KeynodeIndex);
    ASSERT(KeynodeBlockIndex < lpFileInfo-> KeynodeBlockCount);

    lpKeynodeBlockInfo = RgIndexKeynodeBlockInfoPtr(lpFileInfo,
                                                    KeynodeBlockIndex);

    ASSERT(lpKeynodeBlockInfo-> LockCount > 0);
    lpKeynodeBlockInfo-> LockCount--;

    if (fMarkDirty) {
        lpKeynodeBlockInfo-> Flags |= KBIF_DIRTY;
        lpFileInfo-> Flags |= FI_DIRTY | FI_KEYNODEDIRTY;
        RgDelayFlush();
    }

    DECREMENT_DEBUG_COUNT(g_RgKeynodeLockCount);

}

//
//  RgAllocKeynode
//

int
INTERNAL
RgAllocKeynode(
              LPFILE_INFO lpFileInfo,
              LPDWORD lpKeynodeIndex,
              LPKEYNODE FAR* lplpKeynode
              )
{

    int ErrorCode;
    DWORD FreeKeynodeOffset;
    DWORD FreeKeynodeIndex;
    UINT FreeRecordSize;
    UINT ExtraPadding;
    UINT KeynodeBlockIndex;
    UINT AllocCount;
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo;
    LPKEYNODE lpKeynode;
    DWORD NextFreeKeynodeIndex;
    LPKEYNODE lpNextFreeKeynode;
    UINT KeynodeSize;

    FreeKeynodeIndex = lpFileInfo-> KeynodeHeader.FirstFreeIndex;

    //  If no more free keynodes exist, then we try to extend the keynode table
    //  to provide more entries.
    if (IsNullKeynodeIndex(FreeKeynodeIndex)) {

        if (HAS_COMPACT_KEYNODES(lpFileInfo)) {
            FreeKeynodeIndex = ROUND_UP(lpFileInfo-> CurTotalKnSize, PAGESIZE) /
                               sizeof(KEYNODE);
            FreeRecordSize = PAGESIZE;
            ExtraPadding = 0;
        }

        else {

            //  Handle the special case of a new file being created: for
            //  uncompacted keynode tables, the first offset is immediately
            //  after the keynode header and the size of the free record must
            //  account for  the size of this header.
            if (lpFileInfo-> CurTotalKnSize == sizeof(KEYNODE_HEADER)) {
                FreeKeynodeOffset = sizeof(KEYNODE_HEADER);
                //  Win95 compatiblity:  Same initial table size, plus
                //  causes us to stress the below special grow case.
                FreeRecordSize = PAGESIZE - sizeof(KEYNODE_HEADER) * 2;
                ExtraPadding = 0;
            }

            else {

                FreeKeynodeOffset = ROUND_UP(lpFileInfo-> CurTotalKnSize,
                                             PAGESIZE);
                FreeRecordSize = PAGESIZE;
                ExtraPadding = (UINT) (FreeKeynodeOffset - lpFileInfo->
                                       CurTotalKnSize);

                //  Handle the case of a keynode table with a non-integral
                //  number of pages.  We'll place the new free keynode at the
                //  top of the existing keynode table with a size including
                //  the remaining bytes on the page plus a new page (effectively
                //  the same as Win95).
                if (ExtraPadding > sizeof(W95KEYNODE) || FreeKeynodeOffset ==
                    PAGESIZE) {
                    //	Although this code will work for any non-integral
                    //	number of pages, it should ONLY occur for <4K tables.
                    ASSERT(FreeKeynodeOffset == PAGESIZE);
                    FreeRecordSize += ExtraPadding;
                    FreeKeynodeOffset = lpFileInfo-> CurTotalKnSize;
                    ExtraPadding = 0;
                }

            }

            FreeKeynodeIndex = RgOffsetToIndex(FreeKeynodeOffset);

        }

        KeynodeBlockIndex = KN_BLOCK_NUMBER(FreeKeynodeIndex);

        //  Check if lpKeynodeBlockInfo is too small to hold the info for a new
        //  keynode block.  If so, then we must grow it a bit.
        if (KeynodeBlockIndex >= lpFileInfo-> KeynodeBlockInfoAllocCount) {

            AllocCount = KeynodeBlockIndex + KEYNODE_BLOCK_INFO_SLACK_ALLOC;

            if (IsNullPtr((lpKeynodeBlockInfo = (LPKEYNODE_BLOCK_INFO)
                           RgSmReAllocMemory(lpFileInfo-> lpKeynodeBlockInfo, AllocCount *
                                             sizeof(KEYNODE_BLOCK_INFO)))))
                return ERROR_OUTOFMEMORY;

            ZeroMemory(lpKeynodeBlockInfo + lpFileInfo->
                       KeynodeBlockInfoAllocCount, (AllocCount - lpFileInfo->
                                                    KeynodeBlockInfoAllocCount) * sizeof(KEYNODE_BLOCK_INFO));

            lpFileInfo-> lpKeynodeBlockInfo = lpKeynodeBlockInfo;
            lpFileInfo-> KeynodeBlockInfoAllocCount = AllocCount;

        }

        if (KeynodeBlockIndex >= lpFileInfo-> KeynodeBlockCount)
            lpFileInfo-> KeynodeBlockCount = KeynodeBlockIndex + 1;

        lpFileInfo-> CurTotalKnSize += (FreeRecordSize + ExtraPadding);
        lpFileInfo-> Flags |= FI_EXTENDED;
        lpFileInfo-> KeynodeHeader.FirstFreeIndex = FreeKeynodeIndex;

        if ((ErrorCode = RgLockKeynode(lpFileInfo, FreeKeynodeIndex,
                                       &lpKeynode)) != ERROR_SUCCESS)
            return ErrorCode;

        lpKeynode-> NextIndex = REG_NULL;
        lpKeynode-> Flags = 0;
        lpKeynode-> FreeRecordSize = FreeRecordSize;

    }

    else {
        if ((ErrorCode = RgLockKeynode(lpFileInfo, FreeKeynodeIndex,
                                       &lpKeynode)) != ERROR_SUCCESS)
            return ErrorCode;
    }

    NextFreeKeynodeIndex = lpKeynode-> NextIndex;
    KeynodeSize = SIZEOF_FILE_KEYNODE(lpFileInfo);

    //  If the free keynode record can be broken up into smaller chunks, then
    //  create another free record immediately after the one we're about to
    //  snag.
    if ((lpKeynode-> FreeRecordSize >= KeynodeSize * 2) &&
        (RgLockKeynode(lpFileInfo, FreeKeynodeIndex + 1, &lpNextFreeKeynode) ==
         ERROR_SUCCESS)) {

        //  Copy the next link from the current free keynode (likely REG_NULL).
        lpNextFreeKeynode-> NextIndex = NextFreeKeynodeIndex;
        lpNextFreeKeynode-> Flags = 0;
        lpNextFreeKeynode-> FreeRecordSize = lpKeynode-> FreeRecordSize -
                                             KeynodeSize;

        NextFreeKeynodeIndex = FreeKeynodeIndex + 1;
        RgUnlockKeynode(lpFileInfo, NextFreeKeynodeIndex, TRUE);

    }

    lpFileInfo-> KeynodeHeader.FirstFreeIndex = NextFreeKeynodeIndex;

    lpKeynode-> Flags |= KNF_INUSE;

    //  Mark the keynode block that holds this keynode dirty.
    lpKeynodeBlockInfo = RgIndexKeynodeBlockInfoPtr(lpFileInfo,
                                                    KN_BLOCK_NUMBER(FreeKeynodeIndex));
    lpKeynodeBlockInfo-> Flags |= KBIF_DIRTY;
    lpFileInfo-> Flags |= FI_DIRTY | FI_KEYNODEDIRTY;
    RgDelayFlush();

    //  WARNING:  The following two statements used to be above the block that
    //  dirtied the keynode.  The 16-bit compiler messed up and
    //  lpKeynodeBlockInfo ended up with a bogus offset thus corrupting random
    //  memory.  Be sure to trace through this function if you change it!
    *lpKeynodeIndex = FreeKeynodeIndex;
    *lplpKeynode = lpKeynode;

    return ERROR_SUCCESS;

}

//
//  RgFreeKeynode
//
//  Marks the specified keynode index free and adds it to the hive's free
//  keynode list.
//

int
INTERNAL
RgFreeKeynode(
             LPFILE_INFO lpFileInfo,
             DWORD KeynodeIndex
             )
{

    int ErrorCode;
    LPKEYNODE lpKeynode;

    if ((ErrorCode = RgLockKeynode(lpFileInfo, KeynodeIndex, &lpKeynode)) ==
        ERROR_SUCCESS) {

        lpKeynode-> Flags &= ~KNF_INUSE;
        lpKeynode-> NextIndex = lpFileInfo-> KeynodeHeader.FirstFreeIndex;
        lpKeynode-> FreeRecordSize = SIZEOF_FILE_KEYNODE(lpFileInfo);
        lpFileInfo-> KeynodeHeader.FirstFreeIndex = KeynodeIndex;

        RgUnlockKeynode(lpFileInfo, KeynodeIndex, TRUE);

    }

    return ErrorCode;

}

//
//  RgGetKnBlockIOInfo
//

VOID
INTERNAL
RgGetKnBlockIOInfo(
                  LPFILE_INFO lpFileInfo,
                  DWORD       BaseKeynodeIndex,
                  UINT FAR*   lpFileBlockSize,
                  LONG FAR*   lpFileOffset
                  )
{

    UINT FileBlockSize;
    DWORD FileOffset;
    DWORD BaseKeynodeOffset;

    if (HAS_COMPACT_KEYNODES(lpFileInfo)) {

        FileBlockSize = sizeof(KEYNODE_BLOCK);

        BaseKeynodeOffset = BaseKeynodeIndex * sizeof(KEYNODE);

        if (BaseKeynodeOffset + FileBlockSize > lpFileInfo-> CurTotalKnSize)
            FileBlockSize = (UINT) (lpFileInfo-> CurTotalKnSize -
                                    BaseKeynodeOffset);

        FileOffset = sizeof(VERSION20_HEADER_PAGE) + BaseKeynodeIndex *
                     sizeof(KEYNODE);

    }

    else {

        FileBlockSize = sizeof(W95KEYNODE_BLOCK);

        //  The first keynode block of an uncompacted keynode table should
        //  start writing AFTER the keynode header.
        if (BaseKeynodeIndex == 0) {
            BaseKeynodeIndex = RgOffsetToIndex(sizeof(KEYNODE_HEADER));
            FileBlockSize -= sizeof(KEYNODE_HEADER);
        }

        BaseKeynodeOffset = RgIndexToOffset(BaseKeynodeIndex);

        if (BaseKeynodeOffset + FileBlockSize > lpFileInfo-> CurTotalKnSize)
            FileBlockSize = (UINT) (lpFileInfo-> CurTotalKnSize -
                                    BaseKeynodeOffset);

        FileOffset = sizeof(FILE_HEADER) + BaseKeynodeOffset;

    }

    *lpFileBlockSize = FileBlockSize;
    *lpFileOffset = FileOffset;

}



int
_inline
RgCopyKeynodeBlock(
                  LPFILE_INFO lpFileInfo,
                  DWORD BaseIndex,
                  HFILE hSrcFile,
                  HFILE hDestFile
                  )
{
    UINT FileBlockSize;
    LONG FileOffset;
    RgGetKnBlockIOInfo(lpFileInfo, BaseIndex, &FileBlockSize, &FileOffset);
    return RgCopyFileBytes(hSrcFile,
                           FileOffset,
                           hDestFile,
                           FileOffset,
                           FileBlockSize);
}

//
//  RgWriteKeynodeBlock
//

int
INTERNAL
RgWriteKeynodeBlock(
                   LPFILE_INFO lpFileInfo,
                   DWORD BaseIndex,
                   HFILE hDestFile,
                   LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo
                   )
{
    int ErrorCode;
    UINT FileBlockSize;
    LONG FileOffset;
    LPW95KEYNODE_BLOCK lpW95KeynodeBlock;

    RgGetKnBlockIOInfo(lpFileInfo, BaseIndex, &FileBlockSize, &FileOffset);

    ErrorCode = ERROR_REGISTRY_IO_FAILED;       // Assume I/O fails
    if (!RgSeekFile(hDestFile, FileOffset)) {
        goto Exit;
    }
    if (HAS_COMPACT_KEYNODES(lpFileInfo)) {
        if (RgWriteFile(hDestFile, lpKeynodeBlockInfo->lpKeynodeBlock, FileBlockSize)) {
            ErrorCode = ERROR_SUCCESS;
        }
    } else {
        LPBYTE lpWriteBlock;
        lpW95KeynodeBlock = (LPW95KEYNODE_BLOCK) RgLockWorkBuffer();
        RgProcessKeynodeBlock(
                             BaseIndex * sizeof(W95KEYNODE),
                             FileBlockSize,
                             lpKeynodeBlockInfo->lpKeynodeBlock,
                             lpW95KeynodeBlock,
                             RgUnpackKeynode);
        lpWriteBlock = (LPBYTE)lpW95KeynodeBlock;
        if (BaseIndex == 0) {
            lpWriteBlock += sizeof(KEYNODE_HEADER);
        }
        if (RgWriteFile(hDestFile, lpWriteBlock, FileBlockSize)) {
            ErrorCode = ERROR_SUCCESS;
        }
        RgUnlockWorkBuffer(lpW95KeynodeBlock);
    }
    Exit:   ;
    return (ErrorCode);
}

//
//  RgWriteKeynodes
//

int
INTERNAL
RgWriteKeynodes(
               LPFILE_INFO lpFileInfo,
               HFILE hSrcFile,
               HFILE hDestFile
               )
{

    DWORD SavedRootIndex;
    DWORD SavedFreeIndex;
    DWORD SavedFileKnSize;
    BOOL fResult;
    UINT KeynodeBlockIndex;
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo;

    if ((hSrcFile == HFILE_ERROR) && !(lpFileInfo->Flags & FI_KEYNODEDIRTY))
        return ERROR_SUCCESS;

    NOISE(("writing keynodes of "));
    NOISE((lpFileInfo-> FileName));
    NOISE(("\n"));

    //
    //	Write out the keynode header.  If the keynodes are not compact then
    //	convert to offsets before writing.
    //

    if (!RgSeekFile(hDestFile, sizeof(FILE_HEADER)))
        return ERROR_REGISTRY_IO_FAILED;

    SavedFileKnSize = lpFileInfo-> KeynodeHeader.FileKnSize;
    SavedRootIndex = lpFileInfo-> KeynodeHeader.RootIndex;
    SavedFreeIndex = lpFileInfo-> KeynodeHeader.FirstFreeIndex;

    //  Write the real size of the keynode table to disk.
    lpFileInfo-> KeynodeHeader.FileKnSize = lpFileInfo-> CurTotalKnSize;

    //  Convert keynode indexes back to offsets temporarily for uncompacted
    //  keynode tables.
    if (!HAS_COMPACT_KEYNODES(lpFileInfo)) {
        lpFileInfo-> KeynodeHeader.RootIndex = RgIndexToOffset(lpFileInfo->
                                                               KeynodeHeader.RootIndex);
        lpFileInfo-> KeynodeHeader.FirstFreeIndex = RgIndexToOffset(lpFileInfo->
                                                                    KeynodeHeader.FirstFreeIndex);
    }

    fResult = RgWriteFile(hDestFile, &lpFileInfo-> KeynodeHeader,
                          sizeof(KEYNODE_HEADER));

    lpFileInfo-> KeynodeHeader.FileKnSize = SavedFileKnSize;
    lpFileInfo-> KeynodeHeader.RootIndex = SavedRootIndex;
    lpFileInfo-> KeynodeHeader.FirstFreeIndex = SavedFreeIndex;

    if (!fResult)
        return ERROR_REGISTRY_IO_FAILED;

    //
    //	Now loop through each block.
    //

    lpKeynodeBlockInfo = lpFileInfo-> lpKeynodeBlockInfo;

    for (KeynodeBlockIndex = 0; KeynodeBlockIndex < lpFileInfo->
        KeynodeBlockCount; KeynodeBlockIndex++, lpKeynodeBlockInfo++) {

        DWORD BaseKeynodeIndex = KeynodeBlockIndex * KEYNODES_PER_BLOCK;

        if (!IsNullPtr(lpKeynodeBlockInfo-> lpKeynodeBlock)) {
            if (hSrcFile != HFILE_ERROR || lpKeynodeBlockInfo-> Flags &
                KBIF_DIRTY) {
                if (RgWriteKeynodeBlock(lpFileInfo, BaseKeynodeIndex, hDestFile,
                                        lpKeynodeBlockInfo) != ERROR_SUCCESS)
                    return ERROR_REGISTRY_IO_FAILED;
            }
        }

        else {
            if (hSrcFile != HFILE_ERROR) {
                if (RgCopyKeynodeBlock(lpFileInfo, BaseKeynodeIndex, hSrcFile,
                                       hDestFile) != ERROR_SUCCESS)
                    return ERROR_REGISTRY_IO_FAILED;
            }
        }

    }

    return ERROR_SUCCESS;

}

//
//  RgWriteKeynodesComplete
//
//  Called after a file has been successfully written.  We can now safely clear
//  all dirty flags and update our state information with the knowledge that
//  the file is in a consistent state.
//

VOID
INTERNAL
RgWriteKeynodesComplete(
                       LPFILE_INFO lpFileInfo
                       )
{

    UINT BlocksLeft;
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo;

    lpFileInfo-> Flags &= ~FI_KEYNODEDIRTY;
    lpFileInfo-> KeynodeHeader.FileKnSize = lpFileInfo-> CurTotalKnSize;

    for (BlocksLeft = lpFileInfo-> KeynodeBlockCount, lpKeynodeBlockInfo =
         lpFileInfo-> lpKeynodeBlockInfo; BlocksLeft > 0; BlocksLeft--,
        lpKeynodeBlockInfo++)
        lpKeynodeBlockInfo-> Flags &= ~KBIF_DIRTY;

}

//
//  RgSweepKeynodes
//
//  Makes a pass through all the present keynode blocks of the given FILE_INFO
//  structure and discards keynode blocks that have not been accessed since the
//  last sweep.
//

VOID
INTERNAL
RgSweepKeynodes(
               LPFILE_INFO lpFileInfo
               )
{

    UINT BlocksLeft;
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo;

    for (BlocksLeft = lpFileInfo-> KeynodeBlockCount, lpKeynodeBlockInfo =
         lpFileInfo-> lpKeynodeBlockInfo; BlocksLeft > 0; BlocksLeft--,
        lpKeynodeBlockInfo++) {

        if (!IsNullPtr(lpKeynodeBlockInfo-> lpKeynodeBlock)) {

            if (((lpKeynodeBlockInfo-> Flags & (KBIF_ACCESSED | KBIF_DIRTY)) ==
                 0) && (lpKeynodeBlockInfo-> LockCount == 0)) {
                RgFreeMemory(lpKeynodeBlockInfo-> lpKeynodeBlock);
                lpKeynodeBlockInfo-> lpKeynodeBlock = NULL;
            }

            lpKeynodeBlockInfo-> Flags &= ~KBIF_ACCESSED;

        }

    }

}

#ifdef VXD
    #pragma VxD_RARE_CODE_SEG
#endif

//
//  RgInitKeynodeInfo
//
//  Initializes fields in the provided FILE_INFO related to the keynode table.
//

int
INTERNAL
RgInitKeynodeInfo(
                 LPFILE_INFO lpFileInfo
                 )
{

    UINT KeynodeBlockSize;
    UINT BlockCount;
    UINT AllocCount;
    LPKEYNODE_BLOCK_INFO lpKeynodeBlockInfo;

    KeynodeBlockSize = SIZEOF_KEYNODE_BLOCK(lpFileInfo);
    BlockCount = (UINT) ((DWORD) (lpFileInfo-> KeynodeHeader.FileKnSize +
                                  KeynodeBlockSize - 1) / (DWORD) KeynodeBlockSize);
    AllocCount = BlockCount + KEYNODE_BLOCK_INFO_SLACK_ALLOC;

    if (IsNullPtr((lpKeynodeBlockInfo = (LPKEYNODE_BLOCK_INFO)
                   RgSmAllocMemory(AllocCount * sizeof(KEYNODE_BLOCK_INFO)))))
        return ERROR_OUTOFMEMORY;

    ZeroMemory(lpKeynodeBlockInfo, AllocCount * sizeof(KEYNODE_BLOCK_INFO));
    lpFileInfo-> lpKeynodeBlockInfo = lpKeynodeBlockInfo;
    lpFileInfo-> KeynodeBlockCount = BlockCount;
    lpFileInfo-> KeynodeBlockInfoAllocCount = AllocCount;

    lpFileInfo-> KeynodeHeader.Flags &= ~(KHF_DIRTY | KHF_EXTENDED |
                                          KHF_HASCHECKSUM);

    //  Convert file offsets to index values for uncompressed files
    if (!HAS_COMPACT_KEYNODES(lpFileInfo)) {
        lpFileInfo-> KeynodeHeader.RootIndex = RgOffsetToIndex(lpFileInfo->
                                                               KeynodeHeader.RootIndex);
        lpFileInfo-> KeynodeHeader.FirstFreeIndex = RgOffsetToIndex(lpFileInfo->
                                                                    KeynodeHeader.FirstFreeIndex);
    }

    lpFileInfo-> CurTotalKnSize = lpFileInfo-> KeynodeHeader.FileKnSize;

    return ERROR_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmmreg32\regkylst.h ===
//
//  REGKYLST.H
//
//  Copyright (C) Microsoft Corporation, 1995
//

#ifndef _REGKYLST_
#define _REGKYLST_

BOOL
INTERNAL
RgAllocKeyHandleStructures(
    VOID
    );

VOID
INTERNAL
RgFreeKeyHandleStructures(
    VOID
    );

HKEY
INTERNAL
RgCreateKeyHandle(
    VOID
    );

VOID
INTERNAL
RgDestroyKeyHandle(
    HKEY hKey
    );

int
INTERNAL
RgValidateAndConvertKeyHandle(
    LPHKEY lphKey
    );

VOID
INTERNAL
RgIncrementKeyReferenceCount(
    HKEY hKey
    );

HKEY
INTERNAL
RgFindOpenKeyHandle(
    LPFILE_INFO lpFileInfo,
    DWORD KeynodeIndex
    );

VOID
INTERNAL
RgInvalidateKeyHandles(
    LPFILE_INFO lpFileInfo,
    UINT PredefinedKeyIndex
    );

extern KEY g_RgLocalMachineKey;
extern KEY g_RgUsersKey;
#ifdef WANT_DYNKEY_SUPPORT
extern KEY g_RgDynDataKey;
#endif

#endif // _REGKYLST_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmmreg32\regkylst.c ===
//
//  REGKYLST.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Declares the predefined key structures and manages dynamic HKEY structures.
//

#include "pch.h"
#include <limits.h>

//  We would rather just have one definition a
#ifdef WANT_DYNKEY_SUPPORT
#define INITED_PREDEFINED_KEY(index, flags)             \
    {                                                   \
        KEY_SIGNATURE,                                  \
        KEYF_PREDEFINED | KEYF_INVALID | (flags),       \
        0,                                              \
        NULL,                                           \
        REG_NULL,                                       \
        REG_NULL,                                       \
        0,                                              \
        0,                                              \
        (index),                                        \
        NULL,                                           \
        NULL,                                           \
        (UINT) -1,                                      \
        REG_NULL,                                       \
        NULL                                            \
    }
#else
#define INITED_PREDEFINED_KEY(index, flags)             \
    {                                                   \
        KEY_SIGNATURE,                                  \
        KEYF_PREDEFINED | KEYF_INVALID | (flags),       \
        0,                                              \
        NULL,                                           \
        REG_NULL,                                       \
        REG_NULL,                                       \
        0,                                              \
        0,                                              \
        (index),                                        \
        NULL,                                           \
        NULL,                                           \
        (UINT) -1,                                      \
        REG_NULL                                        \
    }
#endif

KEY g_RgLocalMachineKey =
    INITED_PREDEFINED_KEY(INDEX_LOCAL_MACHINE, KEYF_HIVESALLOWED);
KEY g_RgUsersKey = INITED_PREDEFINED_KEY(INDEX_USERS, KEYF_HIVESALLOWED);
#ifdef WANT_DYNKEY_SUPPORT
KEY g_RgDynDataKey = INITED_PREDEFINED_KEY(INDEX_DYN_DATA, 0);
#endif

HKEY g_RgPredefinedKeys[] = {
    NULL,                                       //  HKEY_CLASSES_ROOT
    NULL,                                       //  HKEY_CURRENT_USER
    &g_RgLocalMachineKey,                       //  HKEY_LOCAL_MACHINE
    &g_RgUsersKey,                              //  HKEY_USERS
    NULL,                                       //  HKEY_PERFORMANCE_DATA
    NULL,                                       //  HKEY_CURRENT_CONFIG
#ifdef WANT_DYNKEY_SUPPORT
    &g_RgDynDataKey,                            //  HKEY_DYN_DATA
#endif
};

#define NUMBER_PREDEF_KEYS      (sizeof(g_RgPredefinedKeys) / sizeof(HKEY))

#ifdef WANT_STATIC_KEYS
#define NUMBER_STATIC_KEYS              32
HKEY g_RgStaticKeyArray = NULL;
#endif

//  List of all dynamically allocated keys.
HKEY g_RgDynamicKeyList = NULL;

const char g_RgClassesRootSubKey[] = "SOFTWARE\\CLASSES";
const char g_RgCurrentUserSubKey[] = ".DEFAULT";

#ifdef WANT_STATIC_KEYS
//
//  RgAllocKeyHandleStructures
//

BOOL
INTERNAL
RgAllocKeyHandleStructures(
    VOID
    )
{

    UINT Index;
    HKEY hKey;

    ASSERT(IsNullPtr(g_RgStaticKeyArray));
    ASSERT(IsNullPtr(g_RgDynamicKeyList));

    //
    //  Allocate and initialize the static key table.
    //

    g_RgStaticKeyArray = RgSmAllocMemory(NUMBER_STATIC_KEYS * sizeof(KEY));

    if (IsNullPtr(g_RgStaticKeyArray))
        return FALSE;

    for (Index = NUMBER_STATIC_KEYS, hKey = g_RgStaticKeyArray; Index > 0;
        Index--, hKey++) {
        hKey-> Signature = KEY_SIGNATURE;
        hKey-> Flags = KEYF_STATIC | KEYF_INVALID;
        hKey-> ReferenceCount = 0;
    }

    return TRUE;

}
#endif

#ifdef WANT_FULL_MEMORY_CLEANUP
//
//  RgFreeKeyHandleStructures
//
//  Releases resources allocated by RgAllocKeyHandleStructures.
//

VOID
INTERNAL
RgFreeKeyHandleStructures(
    VOID
    )
{

    HKEY hTempKey;
    HKEY hKey;

    //
    //  Delete all of the dynamically allocated keys.
    //

    hKey = g_RgDynamicKeyList;

    if (!IsNullPtr(hKey)) {
        do {
            hTempKey = hKey;
            hKey = hKey-> lpNext;
#ifdef WANT_DYNKEY_SUPPORT
            if (!IsNullPtr(hTempKey-> pProvider))
                RgSmFreeMemory(hTempKey-> pProvider);
#endif
            RgSmFreeMemory(hTempKey);
        }   while (hKey != g_RgDynamicKeyList);
    }

    g_RgDynamicKeyList = NULL;

#ifdef WANT_STATIC_KEYS
    //
    //  Delete the static key table.
    //

    if (!IsNullPtr(g_RgStaticKeyArray)) {
        RgSmFreeMemory(g_RgStaticKeyArray);
        g_RgStaticKeyArray = NULL;
    }
#endif

}
#endif

//
//  RgCreateKeyHandle
//
//  Allocates one KEY structure, initializes some of its members, and links it
//  to the list of open key handles.
//

HKEY
INTERNAL
RgCreateKeyHandle(
    VOID
    )
{

#ifdef WANT_STATIC_KEYS
    UINT Index;
#endif
    HKEY hKey;

#ifdef WANT_STATIC_KEYS
    //
    //  Check if any keys are available in the static pool.
    //

    if (!IsNullPtr(g_RgStaticKeyArray)) {

        for (Index = NUMBER_STATIC_KEYS, hKey = g_RgStaticKeyArray; Index > 0;
            Index--, hKey++) {
            if (hKey-> Flags & KEYF_INVALID) {
                ASSERT(hKey-> ReferenceCount == 0);
                hKey-> Flags &= ~(KEYF_INVALID | KEYF_DELETED |
                    KEYF_ENUMKEYCACHED);
                return hKey;
            }
        }

    }
#endif

    //
    //  Must allocate a dynamic key.  Initialize it and add it to our list.
    //

    hKey = (HKEY) RgSmAllocMemory(sizeof(KEY));

    if (!IsNullPtr(hKey)) {

        hKey-> Signature = KEY_SIGNATURE;
        hKey-> Flags = 0;
        hKey-> ReferenceCount = 0;
#ifdef WANT_DYNKEY_SUPPORT
        hKey-> pProvider = NULL;
#endif

        if (IsNullPtr(g_RgDynamicKeyList)) {
            hKey-> lpPrev = hKey;
            hKey-> lpNext = hKey;
        }

        else if (hKey != g_RgDynamicKeyList) {
            hKey-> lpNext = g_RgDynamicKeyList;
            hKey-> lpPrev = g_RgDynamicKeyList-> lpPrev;
            hKey-> lpPrev-> lpNext = hKey;
            g_RgDynamicKeyList-> lpPrev = hKey;
        }

        g_RgDynamicKeyList = hKey;

    }

    return hKey;

}

//
//  RgDeleteKeyHandle
//
//  Decrements the reference count on the given key handle.  If the count
//  reaches zero and the key was dynamically allocated, then the key is unlinked
//  from the key list and the key is freed.
//

VOID
INTERNAL
RgDestroyKeyHandle(
    HKEY hKey
    )
{

    ASSERT(!IsNullPtr(hKey));

    //	Don't allow the reference count to underflow for predefined keys or
    //	keys marked "never delete".
    if (hKey-> ReferenceCount > 0)
        hKey-> ReferenceCount--;

    if (hKey-> ReferenceCount == 0) {

        if (!(hKey-> Flags & (KEYF_PREDEFINED | KEYF_NEVERDELETE))) {

#ifdef WANT_STATIC_KEYS
            if (hKey-> Flags & KEYF_STATIC) {
                hKey-> Flags |= KEYF_INVALID;
                return;
            }
#endif

            if (hKey == hKey-> lpNext)
                g_RgDynamicKeyList = NULL;

            else {

                hKey-> lpPrev-> lpNext = hKey-> lpNext;
                hKey-> lpNext-> lpPrev = hKey-> lpPrev;

                if (hKey == g_RgDynamicKeyList)
                    g_RgDynamicKeyList = hKey-> lpNext;

            }

#ifdef WANT_DYNKEY_SUPPORT
            if (!IsNullPtr(hKey-> pProvider))
                RgSmFreeMemory(hKey-> pProvider);
#endif

            hKey-> Signature = 0;
            RgSmFreeMemory(hKey);

        }

    }

}

//
//  RgValidateAndConvertKeyHandle
//
//  Verifies the the given key handle is valid.  If the handle is one of the
//  special predefined constants, then it is converted to the handle of the
//  real KEY structure.
//

int
INTERNAL
RgValidateAndConvertKeyHandle(
    LPHKEY lphKey
    )
{

    HKEY hKey;
    UINT Index;
    HKEY hRootKey;
    LPCSTR lpSubKey;

    hKey = *lphKey;

    //
    //  Check if this is one of the predefined key handles.
    //

    if ((DWORD) HKEY_CLASSES_ROOT <= (DWORD) hKey &&
        (DWORD) hKey < (DWORD) HKEY_CLASSES_ROOT + NUMBER_PREDEF_KEYS) {

        Index = (UINT) ((DWORD) hKey - (DWORD) HKEY_CLASSES_ROOT);
        hKey = g_RgPredefinedKeys[Index];

        //  If the predefined handle is not valid, we'll try to (re)open it for
        //  use.  This isn't pretty, but in the typical case, this code path is
        //  only executed once per handle.
        if (IsNullPtr(hKey) || (hKey-> Flags & KEYF_DELETED)) {

            if (Index == INDEX_CLASSES_ROOT) {
                hRootKey = &g_RgLocalMachineKey;
                lpSubKey = g_RgClassesRootSubKey;
            }

            else if (Index == INDEX_CURRENT_USER) {
                hRootKey = &g_RgUsersKey;
                lpSubKey = g_RgCurrentUserSubKey;
            }

			else if (Index == INDEX_USERS) {
				goto ReturnKeyAndSuccess;
			}

            else
                return ERROR_BADKEY;

            //  Extremely rare case: somebody has deleted one of the predefined
            //  key paths.  We'll clear the predefined bit on this key and throw
            //  it away.
            if (!IsNullPtr(hKey)) {
                g_RgPredefinedKeys[Index] = NULL;
                hKey-> Flags &= ~KEYF_PREDEFINED;
                RgDestroyKeyHandle(hKey);
            }

            //  If the base root key for this predefined key is valid, attempt
            //  to open the key.  Mark the key as predefined so that bad apps
            //  can't close a key more times then it has opened it.
            if (!(hRootKey-> Flags & KEYF_INVALID) && RgLookupKey(hRootKey,
                lpSubKey, &hKey, LK_CREATE) == ERROR_SUCCESS) {
                g_RgPredefinedKeys[Index] = hKey;
                hKey-> Flags |= KEYF_PREDEFINED;
                hKey-> PredefinedKeyIndex = (BYTE) Index;
                goto ReturnKeyAndSuccess;
            }

            return ERROR_BADKEY;

        }

ReturnKeyAndSuccess:
        *lphKey = hKey;
        return (hKey-> Flags & KEYF_INVALID) ? ERROR_BADKEY : ERROR_SUCCESS;

    }

    else {

        if (IsBadHugeReadPtr(hKey, sizeof(KEY)) || hKey-> Signature !=
            KEY_SIGNATURE || (hKey-> Flags & KEYF_INVALID))
            return ERROR_BADKEY;

        return (hKey-> Flags & KEYF_DELETED) ? ERROR_KEY_DELETED :
            ERROR_SUCCESS;

    }

}

//
//  RgIncrementKeyReferenceCount
//
//  Safely increments the reference count of the specified KEY.  If the count
//  overflows, then the key is marked as "never delete" since the usage count
//  is now unknown.
//

VOID
INTERNAL
RgIncrementKeyReferenceCount(
    HKEY hKey
    )
{

    if (hKey-> ReferenceCount != UINT_MAX)
        hKey-> ReferenceCount++;
    else {
        if (!(hKey-> Flags & KEYF_NEVERDELETE)) {
            TRACE(("RgIncrementKeyReferenceCount: handle %lx has overflowed\n",
                hKey));
        }
        hKey-> Flags |= KEYF_NEVERDELETE;
    }

}

//
//  RgFindOpenKeyHandle
//
//  Searches the list of currently opened keys for a key that refers to the same
//  FILE_INFO structure and keynode offset.  If found, the HKEY is returned, or
//  if not, NULL.
//

HKEY
INTERNAL
RgFindOpenKeyHandle(
    LPFILE_INFO lpFileInfo,
    DWORD KeynodeIndex
    )
{

    UINT Index;
    LPHKEY lphKey;
    HKEY hKey;

    ASSERT(!IsNullKeynodeIndex(KeynodeIndex));

    //
    //  Check if this is one of the predefined key handles.
    //

    for (Index = NUMBER_PREDEF_KEYS, lphKey = g_RgPredefinedKeys; Index > 0;
        Index--, lphKey++) {

        hKey = *lphKey;

        if (!IsNullPtr(hKey) && hKey-> lpFileInfo == lpFileInfo && hKey->
            KeynodeIndex == KeynodeIndex && !(hKey-> Flags & (KEYF_DELETED |
            KEYF_INVALID)))
            return hKey;

    }

#ifdef WANT_STATIC_KEYS
    //
    //  Check if this is one of the static key handles.
    //

    if (!IsNullPtr(g_RgStaticKeyArray)) {

        for (Index = NUMBER_STATIC_KEYS, hKey = g_RgStaticKeyArray; Index > 0;
            Index--, hKey++) {
            if (hKey-> lpFileInfo == lpFileInfo && hKey-> KeynodeIndex ==
                KeynodeIndex && !(hKey-> Flags & (KEYF_DELETED | KEYF_INVALID)))
                return hKey;
        }

    }
#endif

    //
    //  Check if this is one of the dynamic key handles.
    //

    if (!IsNullPtr((hKey = g_RgDynamicKeyList))) {

        do {

            if (hKey-> KeynodeIndex == KeynodeIndex && hKey-> lpFileInfo ==
                lpFileInfo && !(hKey-> Flags & KEYF_DELETED))
                return hKey;

            hKey = hKey-> lpNext;

        }   while (hKey != g_RgDynamicKeyList);

    }

    return NULL;

}

//
//  RgInvalidateKeyHandles
//
//  Generic routine to invalidate key handles based on a set of criteria.
//  If any key handle meets any of the given criteria, then it's marked invalid.
//

VOID
INTERNAL
RgInvalidateKeyHandles(
    LPFILE_INFO lpFileInfo,
    UINT PredefinedKeyIndex
    )
{

    UINT Index;
    LPHKEY lphKey;
    HKEY hKey;

    //
    //  Invalidate predefined key handles.
    //

    for (Index = NUMBER_PREDEF_KEYS, lphKey = g_RgPredefinedKeys; Index > 0;
        Index--, lphKey++) {

        hKey = *lphKey;

        if (!IsNullPtr(hKey)) {
            if (hKey-> lpFileInfo == lpFileInfo || hKey-> PredefinedKeyIndex ==
                (BYTE) PredefinedKeyIndex)
                hKey-> Flags |= (KEYF_DELETED | KEYF_INVALID);
        }

    }

#ifdef WANT_STATIC_KEYS
    //
    //  Invalidate static key handles.
    //

    if (!IsNullPtr(g_RgStaticKeyArray)) {

        for (Index = NUMBER_STATIC_KEYS, hKey = g_RgStaticKeyArray; Index > 0;
            Index--, hKey++) {
            if (hKey-> lpFileInfo == lpFileInfo || hKey-> PredefinedKeyIndex ==
                PredefinedKeyIndex)
                hKey-> Flags |= (KEYF_DELETED | KEYF_INVALID);
        }

    }
#endif

    //
    //  Invalidate dynamic key handles.
    //

    if (!IsNullPtr((hKey = g_RgDynamicKeyList))) {

        do {

            if (hKey-> lpFileInfo == lpFileInfo || hKey-> PredefinedKeyIndex ==
                (BYTE) PredefinedKeyIndex)
                hKey-> Flags |= (KEYF_DELETED | KEYF_INVALID);

            hKey = hKey-> lpNext;

        }   while (hKey != g_RgDynamicKeyList);

    }

}

#ifdef VXD
#pragma VxD_RARE_CODE_SEG
#endif

//
//  VMMRegMapPredefKeyToKey
//

LONG
REGAPI
VMMRegMapPredefKeyToKey(
    HKEY hTargetKey,
    HKEY hPredefKey
    )
{

    int ErrorCode;
    UINT PredefinedKeyIndex;
    HKEY hOldKey;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hTargetKey)) ==
        ERROR_SUCCESS) {

        if ((hPredefKey == HKEY_CURRENT_USER && hTargetKey->
            PredefinedKeyIndex == INDEX_USERS) || (hPredefKey ==
            HKEY_CURRENT_CONFIG && hTargetKey-> PredefinedKeyIndex ==
            INDEX_LOCAL_MACHINE)) {

            PredefinedKeyIndex = (UINT) ((DWORD) hPredefKey - (DWORD)
                HKEY_CLASSES_ROOT);

            hOldKey = g_RgPredefinedKeys[PredefinedKeyIndex];

            if (!IsNullPtr(hOldKey)) {

                //  Invalidate open handles based off the existing predefined
                //  key handle.  Win95 behavior.
                RgInvalidateKeyHandles((LPFILE_INFO) -1L, (BYTE)
                    PredefinedKeyIndex);

                hOldKey-> Flags &= ~KEYF_PREDEFINED;
                RgDestroyKeyHandle(hOldKey);

            }

            hTargetKey-> Flags |= KEYF_PREDEFINED;
            RgIncrementKeyReferenceCount(hTargetKey);
            g_RgPredefinedKeys[PredefinedKeyIndex] = hTargetKey;

        }

        else {
            DEBUG_OUT(("VMMRegMapPredefKeyToKey: invalid hTargetKey\n"));
            ErrorCode = ERROR_BADKEY;
        }

    }

    RgUnlockRegistry();

    return ErrorCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmmreg32\regmem.h ===
//
//  REGMEM.H
//
//  Copyright (C) Microsoft Corporation, 1995
//

#ifndef _REGMEM_
#define _REGMEM_

LPVOID
INTERNAL
RgAllocMemory(
    UINT cbBytes
    );

LPVOID
INTERNAL
RgReAllocMemory(
    LPVOID lpMemory,
    UINT cbBytes
    );

#ifdef DEBUG
VOID
INTERNAL
RgFreeMemory(
    LPVOID
    );
#else
#ifdef VXD
#define RgFreeMemory(lpv)           (FreePages(lpv))
#else
#define RgFreeMemory(lpv)           (FreeBytes(lpv))
#endif
#endif

//  Use the RgSm*Memory macros to allocate small chunks of memory off the heap.
//  For the VMM mode registry, the Rg*Memory functions will allocate pages,
//  while the RgSm*Memory functions will allocate from the heap.  For all other
//  modes, the two sets are equivalent.
#if defined(VXD)
#define RgSmAllocMemory             AllocBytes
#define RgSmFreeMemory              FreeBytes
#define RgSmReAllocMemory           ReAllocBytes
#else
#define RgSmAllocMemory             RgAllocMemory
#define RgSmFreeMemory              RgFreeMemory
#define RgSmReAllocMemory           RgReAllocMemory
#endif

#endif // _REGMEM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmmreg32\regkey.c ===
//
//  REGKEY.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegCreateKey, RegOpenKey, RegCloseKey, and supporting
//  functions.
//

#include "pch.h"

//
//  RgIsBadSubKey
//
//  Returns TRUE if lpSubKey is a invalid subkey string.  An invalid subkey
//  string may be an invalid pointer or contain double-backslashes or elements
//  greater than MAXIMUM_SUB_KEY_LENGTH.
//

BOOL
INTERNAL
RgIsBadSubKey(
    LPCSTR lpSubKey
    )
{

    LPCSTR lpString;
    UINT SubSubKeyLength;
    BYTE Char;

    if (IsNullPtr(lpSubKey))
        return FALSE;

    if (!IsBadStringPtr(lpSubKey, (UINT) -1)) {

        lpString = lpSubKey;
        SubSubKeyLength = 0;

        while (TRUE) {

            Char = *((LPBYTE) lpString);

            if (Char == '\0')
                return FALSE;

            else if (Char == '\\') {
                //  Catch double-backslashes and leading backslashes.  One
                //  leading backslash is acceptable...
                if (SubSubKeyLength == 0 && lpString != lpSubKey)
                    break;
                SubSubKeyLength = 0;
            }

            else {

                if (IsDBCSLeadByte(Char)) {
                    SubSubKeyLength++;
                    //  Catch an unpaired DBCS pair...
                    if (*lpString++ == '\0')
                        break;
                }

                //  Win95 compatibility: don't accept strings with control
                //  characters.
                else if (Char < ' ')
                    break;

                if (++SubSubKeyLength >= MAXIMUM_SUB_KEY_LENGTH)
                    break;

            }

            lpString++;

        }

    }

    return TRUE;

}

//
//  RgGetNextSubSubKey
//
//  Extracts the next subkey component tokenized by backslashes.  Works like
//  strtok where on the first call, lpSubKey points to the start of the subkey.
//  On subsequent calls, lpSubKey is NULL and the last offset is used to find
//  the next component.
//
//  Returns the length of the SubSubKey string.
//

UINT
INTERNAL
RgGetNextSubSubKey(
    LPCSTR lpSubKey,
    LPCSTR FAR* lplpSubSubKey,
    UINT FAR* lpSubSubKeyLength
    )
{

    static LPCSTR lpLastSubSubKey = NULL;
    LPCSTR lpString;
    UINT SubSubKeyLength;

    if (!IsNullPtr(lpSubKey))
        lpLastSubSubKey = lpSubKey;

    lpString = lpLastSubSubKey;

    if (*lpString == '\0') {
        *lplpSubSubKey = NULL;
        *lpSubSubKeyLength = 0;
        return 0;
    }

    if (*lpString == '\\')
        lpString++;

    *lplpSubSubKey = lpString;

    while (*lpString != '\0') {

        if (*lpString == '\\')
            break;

        //  The subkey has already been validated, so we know there's a matching
        //  trail byte.
        if (IsDBCSLeadByte(*lpString))
            lpString++;                 //  Trail byte skipped immediately below

        lpString++;

    }

    lpLastSubSubKey = lpString;

    SubSubKeyLength = lpString - *lplpSubSubKey;
    *lpSubSubKeyLength = SubSubKeyLength;

    return SubSubKeyLength;

}

//
//  RgLookupKey
//

int
INTERNAL
RgLookupKey(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPHKEY lphSubKey,
    UINT Flags
    )
{

    int ErrorCode;
    LPCSTR lpSubSubKey;
    UINT SubSubKeyLength;
    BOOL fCreatedKeynode;
    LPFILE_INFO lpFileInfo;
    DWORD KeynodeIndex;
#ifdef WANT_HIVE_SUPPORT
    LPHIVE_INFO lpHiveInfo;
#endif
    BOOL fPrevIsNextIndex;
    DWORD SubSubKeyHash;
    LPKEYNODE lpKeynode;
    LPKEY_RECORD lpKeyRecord;
    BOOL fFound;
    DWORD PrevKeynodeIndex;
#ifdef WANT_NOTIFY_CHANGE_SUPPORT
    DWORD NotifyKeynodeIndex;
#endif
    LPKEYNODE lpNewKeynode;
    HKEY hSubKey;

    fCreatedKeynode = FALSE;

    //
    //  Check if the caller is trying to open a key with a NULL or zero-length
    //  sub key string.  If so, simply return hKey.
    //

    if (IsNullPtr(lpSubKey) || RgGetNextSubSubKey(lpSubKey, &lpSubSubKey,
        &SubSubKeyLength) == 0) {
        hSubKey = hKey;
        goto HaveSubKeyHandle;
    }

    lpFileInfo = hKey-> lpFileInfo;
    KeynodeIndex = hKey-> ChildKeynodeIndex;
    PrevKeynodeIndex = hKey-> KeynodeIndex;

#ifdef WANT_HIVE_SUPPORT
    //
    //  If this key can have hives attached to it, check there for the first
    //  part of the subkey.  If we have a match, then switch into that
    //  FILE_INFO.
    //

    if (hKey-> Flags & KEYF_HIVESALLOWED) {

        lpHiveInfo = lpFileInfo-> lpHiveInfoList;

        while (!IsNullPtr(lpHiveInfo)) {

            if (SubSubKeyLength == lpHiveInfo-> NameLength &&
                RgStrCmpNI(lpSubSubKey, lpHiveInfo-> Name,
                SubSubKeyLength) == 0) {

                lpFileInfo = lpHiveInfo-> lpFileInfo;
                KeynodeIndex = lpFileInfo-> KeynodeHeader.RootIndex;

                if ((ErrorCode = RgLockInUseKeynode(lpFileInfo, KeynodeIndex,
                    &lpKeynode)) != ERROR_SUCCESS)
                    return ErrorCode;

                if (!RgGetNextSubSubKey(NULL, &lpSubSubKey, &SubSubKeyLength))
                    goto LookupComplete;

                PrevKeynodeIndex = KeynodeIndex;
                KeynodeIndex = lpKeynode-> ChildIndex;
                RgUnlockKeynode(lpFileInfo, PrevKeynodeIndex, FALSE);

                break;

            }

            lpHiveInfo = lpHiveInfo-> lpNextHiveInfo;

        }

    }
#endif

    //
    //  Walk as deep as we can into the registry tree using existing key
    //  records.  For each subkey component, move to the child of the current
    //  tree position and walk each sibling looking for a match.  Repeat until
    //  we're out of subkey components or we hit the end of a branch.
    //

    fPrevIsNextIndex = FALSE;

    for (;;) {

        SubSubKeyHash = RgHashString(lpSubSubKey, SubSubKeyLength);

        while (!IsNullKeynodeIndex(KeynodeIndex)) {

            if ((ErrorCode = RgLockInUseKeynode(lpFileInfo, KeynodeIndex,
                &lpKeynode)) != ERROR_SUCCESS)
                return ErrorCode;

            if (lpKeynode-> Hash == SubSubKeyHash) {

                if ((ErrorCode = RgLockKeyRecord(lpFileInfo, lpKeynode->
                    BlockIndex, (BYTE) lpKeynode-> KeyRecordIndex,
                    &lpKeyRecord)) != ERROR_SUCCESS) {
                    RgUnlockKeynode(lpFileInfo, KeynodeIndex, FALSE);
                    return ErrorCode;
                }

                fFound = (SubSubKeyLength == lpKeyRecord-> NameLength &&
                    RgStrCmpNI(lpSubSubKey, lpKeyRecord-> Name,
                    SubSubKeyLength) == 0);

                RgUnlockDatablock(lpFileInfo, lpKeynode-> BlockIndex, FALSE);

                if (fFound)
                    break;

            }

            //  Unlock the current keynode and advance to its sibling.  Set
            //  fPrevIsNextIndex so that if we have to create, we know that
            //  we'll be inserting the new keynode as a sibling.
            fPrevIsNextIndex = TRUE;
            PrevKeynodeIndex = KeynodeIndex;
            KeynodeIndex = lpKeynode-> NextIndex;
            RgUnlockKeynode(lpFileInfo, PrevKeynodeIndex, FALSE);

        }

        //  Break out if we looped over all the siblings of the previous keynode
        //  or if the previous keynode didn't have any children.  If we're in
        //  create mode, then fPrevIsNextIndex and PrevKeynodeIndex will
        //  represent where we need to start inserting.
        if (IsNullKeynodeIndex(KeynodeIndex))
            break;

        //  Break out there are no more subkey components to lookup.
        //  KeynodeIndex represents the index of the matching key.  It's
        //  corresponding keynode is locked.
        if (!RgGetNextSubSubKey(NULL, &lpSubSubKey, &SubSubKeyLength))
            break;

        //  Unlock the current keynode and advance to its child.  Clear
        //  fPrevIsNextIndex so that if we have to create, we know that we'll
        //  be inserting the new keynode as a child.
        fPrevIsNextIndex = FALSE;
        PrevKeynodeIndex = KeynodeIndex;
        KeynodeIndex = lpKeynode-> ChildIndex;
        RgUnlockKeynode(lpFileInfo, PrevKeynodeIndex, FALSE);

    }

    if (IsNullKeynodeIndex(KeynodeIndex)) {

        if (!(Flags & LK_CREATE))
            return ERROR_CANTOPEN16_FILENOTFOUND32;

        if (((hKey-> PredefinedKeyIndex == INDEX_DYN_DATA) && !(Flags &
            LK_CREATEDYNDATA)) || (lpFileInfo-> Flags & FI_READONLY))
            return ERROR_ACCESS_DENIED;

        if ((ErrorCode = RgLockInUseKeynode(lpFileInfo, PrevKeynodeIndex,
            &lpKeynode)) != ERROR_SUCCESS) {
            TRACE(("RgLookupKey: failed to lock keynode we just had?\n"));
            return ErrorCode;
        }

#ifdef WANT_NOTIFY_CHANGE_SUPPORT
        //  Which keynode index we'll notify of the subkeys we're creating
        //  depends on the state of fPrevIsNextIndex.
        NotifyKeynodeIndex = fPrevIsNextIndex ? lpKeynode-> ParentIndex :
            PrevKeynodeIndex;
#endif

        //  See if there's an open handle on the parent so that we can patch up
        //  its child keynode index member.  We only need this on the first
        //  pass.
        hSubKey = RgFindOpenKeyHandle(lpFileInfo, PrevKeynodeIndex);

        do {

            if ((ErrorCode = RgAllocKeynode(lpFileInfo, &KeynodeIndex,
                &lpNewKeynode)) != ERROR_SUCCESS)
                goto CreateAllocFailed1;

            if ((ErrorCode = RgAllocKeyRecord(lpFileInfo, sizeof(KEY_RECORD) +
                SubSubKeyLength - 1, &lpKeyRecord)) != ERROR_SUCCESS) {

                RgUnlockKeynode(lpFileInfo, KeynodeIndex, FALSE);
                RgFreeKeynode(lpFileInfo, KeynodeIndex);

CreateAllocFailed1:
                RgUnlockKeynode(lpFileInfo, PrevKeynodeIndex, fCreatedKeynode);

                DEBUG_OUT(("RgLookupKey: allocation failed\n"));
                goto SignalAndReturnErrorCode;

            }

            //  Fixup the previous keynode's next offset.
            if (fPrevIsNextIndex) {

                fPrevIsNextIndex = FALSE;
                hSubKey = NULL;
                lpNewKeynode-> ParentIndex = lpKeynode-> ParentIndex;
                lpKeynode-> NextIndex = KeynodeIndex;

            }

            //  Fixup the previous keynode's child offset.
            else {

                lpNewKeynode-> ParentIndex = PrevKeynodeIndex;
                lpKeynode-> ChildIndex = KeynodeIndex;

                //  If hSubKey is not NULL, then we may have to patch up the
                //  child offset cache to point to the newly created keynode.
                if (!IsNullPtr(hSubKey)) {
                    if (IsNullKeynodeIndex(hSubKey-> ChildKeynodeIndex))
                        hSubKey-> ChildKeynodeIndex = KeynodeIndex;
                    hSubKey = NULL;
                }

            }

            //  Fill in the keynode.
            lpNewKeynode-> NextIndex = REG_NULL;
            lpNewKeynode-> ChildIndex = REG_NULL;
            lpNewKeynode-> BlockIndex = lpKeyRecord-> BlockIndex;
            lpNewKeynode-> KeyRecordIndex = lpKeyRecord-> KeyRecordIndex;
            lpNewKeynode-> Hash = (WORD) RgHashString(lpSubSubKey,
                SubSubKeyLength);

            //  Fill in the key record.
            lpKeyRecord-> RecordSize = sizeof(KEY_RECORD) + SubSubKeyLength - 1;
            lpKeyRecord-> NameLength = (WORD) SubSubKeyLength;
            MoveMemory(lpKeyRecord-> Name, lpSubSubKey, SubSubKeyLength);
            lpKeyRecord-> ValueCount = 0;
            lpKeyRecord-> ClassLength = 0;
            lpKeyRecord-> Reserved = 0;

            //  Unlock the keynode that points to the new keynode and advance
            //  to the next keynode.
            RgUnlockKeynode(lpFileInfo, PrevKeynodeIndex, TRUE);
            PrevKeynodeIndex = KeynodeIndex;
            lpKeynode = lpNewKeynode;

            RgUnlockDatablock(lpFileInfo, lpKeyRecord-> BlockIndex, TRUE);

            fCreatedKeynode = TRUE;

            //  Following should already be zeroed for subsequent iterations.
            ASSERT(!fPrevIsNextIndex);
            ASSERT(IsNullPtr(hSubKey));

        }   while (RgGetNextSubSubKey(NULL, &lpSubSubKey, &SubSubKeyLength));

    }

    ASSERT(!IsNullKeynodeIndex(KeynodeIndex));

    //
    //  Now we've got the keynode for the request subkey.  Check if it has been
    //  previously opened.  If not, then allocate a new key handle for it and
    //  initialize it.
    //

LookupComplete:
    if (IsNullPtr(hSubKey = RgFindOpenKeyHandle(lpFileInfo, KeynodeIndex))) {

        if (IsNullPtr(hSubKey = RgCreateKeyHandle()))
            ErrorCode = ERROR_OUTOFMEMORY;

        else {

            hSubKey-> lpFileInfo = lpFileInfo;
	    hSubKey-> KeynodeIndex = KeynodeIndex;
	    hSubKey-> ChildKeynodeIndex = lpKeynode-> ChildIndex;
            hSubKey-> BlockIndex = (WORD) lpKeynode-> BlockIndex;
            hSubKey-> KeyRecordIndex = (BYTE) lpKeynode-> KeyRecordIndex;
            hSubKey-> PredefinedKeyIndex = hKey-> PredefinedKeyIndex;

        }

    }

    RgUnlockKeynode(lpFileInfo, KeynodeIndex, fCreatedKeynode);

    //
    //  Now we've got a key handle that references the requested subkey.
    //  Increment the reference count on the handle and return it to the caller.
    //  Note that this differs from NT semantic where they return a unique
    //  handle for every open.
    //

    if (!IsNullPtr(hSubKey)) {
HaveSubKeyHandle:
        RgIncrementKeyReferenceCount(hSubKey);
        *lphSubKey = hSubKey;
        ErrorCode = ERROR_SUCCESS;
    }

SignalAndReturnErrorCode:
    //  If we managed to create any keynodes, regardless of what ErrorCode is
    //  set to now, then we must signal any waiting events.
    if (fCreatedKeynode) {
        RgSignalWaitingNotifies(lpFileInfo, NotifyKeynodeIndex,
            REG_NOTIFY_CHANGE_NAME);
    }

    return ErrorCode;

}

//
//  RgCreateOrOpenKey
//
//  Common routine for VMMRegCreateKey and VMMRegOpenKey.  Valids parameters,
//  locks the registry, and calls the real worker routine.
//

int
INTERNAL
RgCreateOrOpenKey(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPHKEY lphKey,
    UINT Flags
    )
{

    int ErrorCode;

    if (RgIsBadSubKey(lpSubKey))
        return ERROR_BADKEY;

    if (IsBadHugeWritePtr(lphKey, sizeof(HKEY)))
        return ERROR_INVALID_PARAMETER;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) == ERROR_SUCCESS)
        ErrorCode = RgLookupKey(hKey, lpSubKey, lphKey, Flags);

    RgUnlockRegistry();

    return ErrorCode;

}


//
//  VMMRegCreateKey
//
//  See Win32 documentation of RegCreateKey.
//

LONG
REGAPI
VMMRegCreateKey(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPHKEY lphKey
    )
{

    return RgCreateOrOpenKey(hKey, lpSubKey, lphKey, LK_CREATE);

}

//
//  VMMRegOpenKey
//
//  See Win32 documentation of RegOpenKey.
//

LONG
REGAPI
VMMRegOpenKey(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPHKEY lphKey
    )
{

    return RgCreateOrOpenKey(hKey, lpSubKey, lphKey, LK_OPEN);

}

//
//  VMMRegCloseKey
//
//  See Win32 documentation of RegCloseKey.
//

LONG
REGAPI
VMMRegCloseKey(
    HKEY hKey
    )
{

    int ErrorCode;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    ErrorCode = RgValidateAndConvertKeyHandle(&hKey);

    if (ErrorCode == ERROR_SUCCESS || ErrorCode == ERROR_KEY_DELETED) {
        RgDestroyKeyHandle(hKey);
        ErrorCode = ERROR_SUCCESS;
    }

    RgUnlockRegistry();

    return ErrorCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmmreg32\regnckey.h ===
//
//  REGNCKEY.H
//
//  Copyright (C) Microsoft Corporation, 1995
//

#ifndef _REGNCKEY_
#define _REGNCKEY_

#ifdef WANT_NOTIFY_CHANGE_SUPPORT
typedef struct _NOTIFY_CHANGE {
    struct _NOTIFY_CHANGE FAR* lpNextNotifyChange;
    DWORD ThreadId;
    HANDLE hEvent;
    DWORD KeynodeIndex;
    DWORD NotifyFilter;
}   NOTIFY_CHANGE, FAR* LPNOTIFY_CHANGE;

//  Map the bWatchSubtree flag to this bit tucked into the NotifyFilter field.
#define REG_NOTIFY_WATCH_SUBTREE        0x40
//  Only signal events that are watching the specified keynode index, not
//  parents of the keynode index.
#define REG_NOTIFY_NO_WATCH_SUBTREE     0x80

VOID
INTERNAL
RgSignalWaitingNotifies(
    LPFILE_INFO lpFileInfo,
    DWORD KeynodeIndex,
    UINT NotifyEvent
    );
#else
#define RgSignalWaitingNotifies(lpfi, ki, nevt)
#endif

#endif // _REGNCKEY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmmreg32\regqkey.c ===
//
//  REGQKEY.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegQueryInfoKey.
//

#include "pch.h"

//
//  VMMRegQueryInfoKey
//
//  See Win32 documentation of RegQueryInfoKey.  When VXD is defined, this
//  function does not take all of the parameters that we end up ignoring anyway
//  (class, security, timestamp parameters).
//

#ifdef VXD
LONG
REGAPI
VMMRegQueryInfoKey(
    HKEY hKey,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueName,
    LPDWORD lpcbMaxValueData
    )
#else
LONG
REGAPI
VMMRegQueryInfoKey(
    HKEY hKey,
    LPSTR lpClass,
    LPDWORD lpcbClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueName,
    LPDWORD lpcbMaxValueData,
    LPVOID lpcbSecurityDescriptor,
    LPVOID lpftLastWriteTime
    )
#endif
{

    int ErrorCode;
    LPVALUE_RECORD lpValueRecord;
    UINT cItems;
    DWORD cbValueData;
    DWORD cbMaxValueData;
    DWORD cbStringLen;
    DWORD cbMaxStringLen;

    if (IsBadHugeOptionalWritePtr(lpcSubKeys, sizeof(DWORD)) ||
        IsBadHugeOptionalWritePtr(lpcbMaxSubKeyLen, sizeof(DWORD)) ||
        IsBadHugeOptionalWritePtr(lpcValues, sizeof(DWORD)) ||
        IsBadHugeOptionalWritePtr(lpcbMaxValueName, sizeof(DWORD)) ||
        IsBadHugeOptionalWritePtr(lpcbMaxValueData, sizeof(DWORD)))
        return ERROR_INVALID_PARAMETER;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) != ERROR_SUCCESS)
        goto ReturnErrorCode;

    //
    //  Compute cValues, cbMaxValueName, and cbMaxValueData.
    //

    if (!IsNullPtr(lpcValues) || !IsNullPtr(lpcbMaxValueName) ||
        !IsNullPtr(lpcbMaxValueData)) {

        cItems = 0;
        cbMaxStringLen = 0;
        cbMaxValueData = 0;

        while ((ErrorCode = RgLookupValueByIndex(hKey, cItems,
            &lpValueRecord)) == ERROR_SUCCESS) {

            cItems++;

            if (lpValueRecord-> NameLength > cbMaxStringLen)
                cbMaxStringLen = lpValueRecord-> NameLength;

            //  RgCopyFromValueRecord will handle static and dynamic keys...
            ErrorCode = RgCopyFromValueRecord(hKey, lpValueRecord, NULL, NULL,
                NULL, NULL, &cbValueData);

            RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BlockIndex, FALSE);

            if (ErrorCode != ERROR_SUCCESS)
                goto ReturnErrorCode;

            if (cbValueData > cbMaxValueData)
                cbMaxValueData = cbValueData;

        }

        if (ErrorCode == ERROR_NO_MORE_ITEMS) {

            if (!IsNullPtr(lpcValues))
                *lpcValues = cItems;

            if (!IsNullPtr(lpcbMaxValueName))
                *lpcbMaxValueName = cbMaxStringLen;

            if (!IsNullPtr(lpcbMaxValueData))
                *lpcbMaxValueData = cbMaxValueData;

            ErrorCode = ERROR_SUCCESS;

        }

    }

    //
    //  Compute cSubKeys and cbMaxSubKeyLen.  Somewhat painful because we must
    //  touch each child keynode and datablock.
    //

    if (!IsNullPtr(lpcSubKeys) || !IsNullPtr(lpcbMaxSubKeyLen)) {

        cItems = 0;
        cbMaxStringLen = 0;

        while ((ErrorCode = RgLookupKeyByIndex(hKey, cItems, NULL,
            &cbStringLen)) == ERROR_SUCCESS) {

            cItems++;

            if (cbStringLen > cbMaxStringLen)
                cbMaxStringLen = cbStringLen;

        }

        if (ErrorCode == ERROR_NO_MORE_ITEMS) {

            if (!IsNullPtr(lpcSubKeys))
                *lpcSubKeys = cItems;

            if (!IsNullPtr(lpcbMaxSubKeyLen))
                *lpcbMaxSubKeyLen = cbMaxStringLen;

            ErrorCode = ERROR_SUCCESS;

        }

    }

ReturnErrorCode:
    RgUnlockRegistry();

    return ErrorCode;

#ifndef VXD
    UNREFERENCED_PARAMETER(lpClass);
    UNREFERENCED_PARAMETER(lpcbClass);
    UNREFERENCED_PARAMETER(lpReserved);
    UNREFERENCED_PARAMETER(lpcbMaxClassLen);
    UNREFERENCED_PARAMETER(lpcbSecurityDescriptor);
    UNREFERENCED_PARAMETER(lpftLastWriteTime);
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmmreg32\regmem.c ===
//
//  REGMEM.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Upper-level memory management functions that discards unlocked memory blocks
//  as required to fulfill allocation requests.
//
//  For the ring zero version of this code, only large requests will call these
//  functions.  For most registry files, these requests will already be an
//  integral number of pages, so it's best just to do page allocations.  Small
//  allocations, such as key handles,  will use the heap services and not go
//  through this code.
//
//  For all other models of this code, all memory requests will go through this
//  code and memory is allocated from the heap.
//

#include "pch.h"

DECLARE_DEBUG_COUNT(g_RgMemoryBlockCount);

//  For the ring zero version, only large allocations that should be page
//  aligned will pass through these functions.
#ifdef VXD

//  Converts number of bytes to number of whole pages.
#define ConvertToMemoryUnits(cb)        \
    ((((cb) + (PAGESIZE - 1)) & ~(PAGESIZE - 1)) >> PAGESHIFT)

//  Generates smaller code if we don't just make this a macro...
LPVOID
INTERNAL
RgAllocMemoryUnits(
    UINT nPages
    )
{

    return AllocPages(nPages);

}

//  Generates smaller code if we don't just make this a macro...
LPVOID
INTERNAL
RgReAllocMemoryUnits(
    LPVOID lpMemory,
    UINT nPages
    )
{

    return ReAllocPages(lpMemory, nPages);

}

#define RgFreeMemoryUnits           FreePages

//  For non-ring zero version of the registry code, all allocations will funnel
//  through these functions.  All allocations are off the heap.
#else
#define ConvertToMemoryUnits(cb)    (cb)
#define RgAllocMemoryUnits          AllocBytes
#define RgReAllocMemoryUnits        ReAllocBytes
#define RgFreeMemoryUnits           FreeBytes
#endif

//
//  RgAllocMemory
//

LPVOID
INTERNAL
RgAllocMemory(
    UINT cbBytes
    )
{

    UINT MemoryUnits;
    LPVOID lpMemory;

    ASSERT(cbBytes > 0);

    MemoryUnits = ConvertToMemoryUnits(cbBytes);

    //  Can we allocate from available memory?
    if (!IsNullPtr((lpMemory = RgAllocMemoryUnits(MemoryUnits)))) {
        INCREMENT_DEBUG_COUNT(g_RgMemoryBlockCount);
        return lpMemory;
    }

    RgEnumFileInfos(RgSweepFileInfo);

    //  Can we allocate after sweeping all old memory blocks?
    if (!IsNullPtr((lpMemory = RgAllocMemoryUnits(MemoryUnits)))) {
        INCREMENT_DEBUG_COUNT(g_RgMemoryBlockCount);
        return lpMemory;
    }

    //  The first sweep will have cleared all the access bits of every memory
    //  block.  This sweep will effectively discard all unlocked blocks.
    RgEnumFileInfos(RgSweepFileInfo);

    //  Can we allocate after sweeping all unlocked and clean memory blocks?
    if (!IsNullPtr((lpMemory = RgAllocMemoryUnits(MemoryUnits)))) {
        INCREMENT_DEBUG_COUNT(g_RgMemoryBlockCount);
        return lpMemory;
    }

    //  Flush out every dirty memory block and sweep again.
    RgEnumFileInfos(RgFlushFileInfo);
    RgEnumFileInfos(RgSweepFileInfo);

    //  Can we allocate after sweeping all unlocked memory blocks?
    if (!IsNullPtr((lpMemory = RgAllocMemoryUnits(MemoryUnits)))) {
        INCREMENT_DEBUG_COUNT(g_RgMemoryBlockCount);
        return lpMemory;
    }

    DEBUG_OUT(("RgAllocMemory failure\n"));
    //  Return lpMemory, which must be NULL if we're here, generates smaller
    //  code.
    return lpMemory;                    //  Must be NULL if we're here

}

//
//  RgReAllocMemory
//

LPVOID
INTERNAL
RgReAllocMemory(
    LPVOID lpOldMemory,
    UINT cbBytes
    )
{

    UINT MemoryUnits;
    LPVOID lpMemory;

    ASSERT(!IsNullPtr(lpOldMemory));
    ASSERT(cbBytes > 0);

    MemoryUnits = ConvertToMemoryUnits(cbBytes);

    //  Can we allocate from available memory?
    if (!IsNullPtr((lpMemory = RgReAllocMemoryUnits(lpOldMemory, MemoryUnits))))
        return lpMemory;

    RgEnumFileInfos(RgSweepFileInfo);

    //  Can we allocate after sweeping all old memory blocks?
    if (!IsNullPtr((lpMemory = RgReAllocMemoryUnits(lpOldMemory, MemoryUnits))))
        return lpMemory;

    //  The first sweep will have cleared all the access bits of every memory
    //  block.  This sweep will effectively discard all unlocked blocks.
    RgEnumFileInfos(RgSweepFileInfo);

    //  Can we allocate after sweeping all unlocked and clean memory blocks?
    if (!IsNullPtr((lpMemory = RgReAllocMemoryUnits(lpOldMemory, MemoryUnits))))
        return lpMemory;

    //  Flush out every dirty memory block and sweep again.
    RgEnumFileInfos(RgFlushFileInfo);
    RgEnumFileInfos(RgSweepFileInfo);

    //  Can we allocate after sweeping all unlocked memory blocks?
    if (!IsNullPtr((lpMemory = RgReAllocMemoryUnits(lpOldMemory, MemoryUnits))))
        return lpMemory;

    DEBUG_OUT(("RgReAllocMemory failure\n"));
    //  Return lpMemory, which must be NULL if we're here, generates smaller
    //  code.
    return lpMemory;

}

#ifdef DEBUG
//
//  RgFreeMemory
//

VOID
INTERNAL
RgFreeMemory(
    LPVOID lpMemory
    )
{

    ASSERT(!IsNullPtr(lpMemory));

    DECREMENT_DEBUG_COUNT(g_RgMemoryBlockCount);

#ifdef ZEROONFREE
    ZeroMemory(lpMemory, MemorySize(lpMemory));
#endif

    RgFreeMemoryUnits(lpMemory);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmmreg32\regmisc.c ===
//
//  REGMISC.C
//
//  Copyright (C) Microsoft Corporation, 1995
//

#include "pch.h"

//
//  RgChecksum
//

DWORD
INTERNAL
RgChecksum(
    LPVOID lpBuffer,
    UINT ByteCount
    )
{

    LPDWORD lpdwBuffer;
    DWORD Checksum;

    lpdwBuffer = (LPDWORD) lpBuffer;
    ByteCount >>= 2;
    Checksum = 0;

    while (ByteCount) {
        Checksum += *lpdwBuffer++;
        ByteCount--;
    }

    return Checksum;

}

//
//  RgHashString
//
//  Simple hash computation of a counted string.  All characters less than 0x80
//  0x80 and all DBCS characters are added up.
//

DWORD
INTERNAL
RgHashString(
    LPCSTR lpString,
    UINT Length
    )
{

    DWORD Hash;
    UINT Byte;

    Hash = 0;

    while (Length) {

        Byte = *((LPBYTE) lpString)++;

        if (IsDBCSLeadByte((BYTE) Byte)) {

            Hash += Byte;
            Length--;
            Hash += (*((LPBYTE) lpString)++);

        }

        else if (Byte < 0x80)
            Hash += ToUpper(Byte);

        Length--;

    }

    return Hash;

}

//
//  RgStrCmpNI
//

int
INTERNAL
RgStrCmpNI(
    LPCSTR lpString1,
    LPCSTR lpString2,
    UINT Length
    )
{

    int Difference;

    while (Length) {

        if (IsDBCSLeadByte(*lpString1)) {

            if ((Difference = *lpString1 - *lpString2) != 0)
                return Difference;

            lpString1++;
            lpString2++;
            Length--;

            if (Length == 0)
                break;

            if ((Difference = *lpString1 - *lpString2) != 0)
                return Difference;

        }

        else if ((Difference = (int) ToUpper(*lpString1) -
            (int) ToUpper(*lpString2)) != 0)
            return Difference;

        lpString1++;
        lpString2++;
        Length--;

    }

    return 0;
}

//
//  RgCopyFileBytes
//
//  Copies the specified number of bytes from the source to the destination
//  starting at the specified offsets in each file.
//

int
INTERNAL
RgCopyFileBytes(
    HFILE hSourceFile,
    LONG SourceOffset,
    HFILE hDestinationFile,
    LONG DestinationOffset,
    DWORD cbSize
    )
{

    int ErrorCode;
    LPVOID lpWorkBuffer;
    UINT cbBytesThisPass;

    ASSERT(hSourceFile != HFILE_ERROR);
    ASSERT(hDestinationFile != HFILE_ERROR);

    ErrorCode = ERROR_REGISTRY_IO_FAILED;   //  Assume this error code

    lpWorkBuffer = RgLockWorkBuffer();

    if (!RgSeekFile(hSourceFile, SourceOffset))
        goto ErrorUnlockWorkBuffer;

    if (!RgSeekFile(hDestinationFile, DestinationOffset))
        goto ErrorUnlockWorkBuffer;

    while (cbSize) {

        cbBytesThisPass = (UINT) ((DWORD) min(cbSize, SIZEOF_WORK_BUFFER));

        if (!RgReadFile(hSourceFile, lpWorkBuffer, cbBytesThisPass)) {
            TRAP();
            goto ErrorUnlockWorkBuffer;
        }

        RgYield();

        if (!RgWriteFile(hDestinationFile, lpWorkBuffer, cbBytesThisPass)) {
            TRAP();
            goto ErrorUnlockWorkBuffer;
        }

        RgYield();

        cbSize -= cbBytesThisPass;

    }

    ErrorCode = ERROR_SUCCESS;

ErrorUnlockWorkBuffer:
    RgUnlockWorkBuffer(lpWorkBuffer);
    return ErrorCode;

}

//
//  RgGenerateAltFileName
//

BOOL
INTERNAL
RgGenerateAltFileName(
    LPCSTR lpFileName,
    LPSTR lpAltFileName,
    char ExtensionChar
    )
{

    LPSTR lpString;

    StrCpy(lpAltFileName, lpFileName);
    lpString = lpAltFileName + StrLen(lpAltFileName) - 3;

    *lpString++ = '~';
    *lpString++ = '~';
    *lpString = ExtensionChar;

    return TRUE;

}

#ifdef VXD

#pragma VxD_RARE_CODE_SEG

//
//  RgCopyFile
//

int
INTERNAL
RgCopyFile(
    LPCSTR lpSourceFile,
    LPCSTR lpDestinationFile
    )
{

    int ErrorCode;
    HFILE hSourceFile;
    HFILE hDestinationFile;
    DWORD FileSize;

    ErrorCode = ERROR_REGISTRY_IO_FAILED;   //  Assume this error code

    if ((hSourceFile = RgOpenFile(lpSourceFile, OF_READ)) != HFILE_ERROR) {

        if ((FileSize = RgGetFileSize(hSourceFile)) != (DWORD) -1) {

            if ((hDestinationFile = RgCreateFile(lpDestinationFile)) !=
                HFILE_ERROR) {

                ErrorCode = RgCopyFileBytes(hSourceFile, 0, hDestinationFile, 0,
                    FileSize);

                RgCloseFile(hDestinationFile);

                if (ErrorCode != ERROR_SUCCESS)
                    RgDeleteFile(lpDestinationFile);

            }

        }

        RgCloseFile(hSourceFile);

    }

    return ErrorCode;

}

#endif // VXD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmmreg32\regqmval.c ===
//
//  REGQMVAL.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegQueryMultipleValues and supporting functions.
//

#include "pch.h"

#ifdef VXD
#pragma VxD_RARE_CODE_SEG
#endif

#ifdef IS_32

//
//  VMMRegQueryMultipleValues
//
//  See Win32 documentation of RegQueryMultipleValues.  However, the Win95
//  implementation breaks many of the rules that are described in the
//  documentation:
//      *  num_vals is a count of VALENT structures, not a size in bytes.
//      *  data is not DWORD aligned in lpValueBuffer.
//      *  if lpValueBuffer is too small, lpValueBuffer is not filled to the
//         size specified by lpdwTotalSize.
//
//  All of this plus dynamic keys makes this an extremely ugly routine, but
//  every attempt was made to be compatible with the Win95 semantics.
//

LONG
REGAPI
VMMRegQueryMultipleValues(
    HKEY hKey,
    PVALENT val_list,
    DWORD num_vals,
    LPSTR lpValueBuffer,
    LPDWORD lpdwTotalSize
    )
{

    int ErrorCode;
    PVALENT pCurrentValent;
    DWORD Counter;
    DWORD BufferSize;
    DWORD RequiredSize;
    LPKEY_RECORD lpKeyRecord;
    LPVALUE_RECORD lpValueRecord;
    LPSTR lpCurrentBuffer;
#ifdef WANT_DYNKEY_SUPPORT
    PVALCONTEXT pValueContext;
    PINTERNAL_PROVIDER pProvider;
    PPVALUE pProviderValue;
#endif

    if (IsBadHugeReadPtr(val_list, sizeof(VALENT) * num_vals))
        return ERROR_INVALID_PARAMETER;

    if (IsBadHugeWritePtr(lpdwTotalSize, sizeof(DWORD)))
        return ERROR_INVALID_PARAMETER;

    if (IsBadHugeWritePtr(lpValueBuffer, *lpdwTotalSize))
        return ERROR_INVALID_PARAMETER;

    for (Counter = num_vals, pCurrentValent = val_list; Counter > 0; Counter--,
        pCurrentValent++) {
        if (IsBadStringPtr(pCurrentValent-> ve_valuename, (UINT) -1))
            return ERROR_INVALID_PARAMETER;
    }

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) != ERROR_SUCCESS)
        goto ReturnErrorCode;

#ifdef WANT_DYNKEY_SUPPORT
    //  Check if this a dynamic key that has a "get all" atomic callback.  If
    //  the dynamic key just has "get one" callback, then we'll fall into the
    //  non-dynamic case.
    if ((hKey-> PredefinedKeyIndex == INDEX_DYN_DATA) && !IsNullPtr(hKey->
        pProvider-> ipi_R0_allvals)) {

        pProvider = hKey-> pProvider;

        pValueContext = RgSmAllocMemory(sizeof(struct val_context) * num_vals);

        if (IsNullPtr(pValueContext)) {
            ErrorCode = ERROR_OUTOFMEMORY;
            goto ReturnErrorCode;
        }

        //
        //  Compute the required buffer size to hold all the value data and
        //  check it against the provided buffer size.
        //

        RequiredSize = 0;

        for (Counter = 0, pCurrentValent = val_list; Counter < num_vals;
            Counter++, pCurrentValent++) {

            if ((ErrorCode = RgLookupValueByName(hKey, pCurrentValent->
                ve_valuename, &lpKeyRecord, &lpValueRecord)) != ERROR_SUCCESS)
                goto ReturnErrorCode;

            //  The value data contains only part of a PROVIDER structure.
            pProviderValue = CONTAINING_RECORD(&lpValueRecord-> Name +
                lpValueRecord-> NameLength, PVALUE, pv_valuelen);

            pValueContext[Counter].value_context = pProviderValue->
                pv_value_context;
            pCurrentValent-> ve_type = pProviderValue-> pv_type;

            if (hKey-> Flags & KEYF_PROVIDERHASVALUELENGTH) {

                //  Must zero it so that some providers don't try to stomp on
                //  lpData.
                pCurrentValent-> ve_valuelen = 0;

                ErrorCode = pProvider-> ipi_R0_1val(pProvider-> ipi_key_context,
                    &pValueContext[Counter], 1, NULL, &(pCurrentValent->
                    ve_valuelen), 0);

                //  Providers should really be returning either of these errors
                //  to us.
                ASSERT((ErrorCode == ERROR_SUCCESS) || (ErrorCode ==
                    ERROR_MORE_DATA));

            }

            else {
                pCurrentValent-> ve_valuelen = pProviderValue-> pv_valuelen;
            }

            RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BlockIndex, FALSE);

            pCurrentValent-> ve_valueptr = (DWORD) NULL;
            RequiredSize += pCurrentValent-> ve_valuelen;

        }

        BufferSize = *lpdwTotalSize;
        *lpdwTotalSize = RequiredSize;

        if (BufferSize < RequiredSize)
            ErrorCode = ERROR_MORE_DATA;

        else if (pProvider-> ipi_R0_allvals(pProvider-> ipi_key_context,
            pValueContext, num_vals, lpValueBuffer, lpdwTotalSize, 0) !=
            ERROR_SUCCESS)
            ErrorCode = ERROR_CANTREAD;

        else {

            ErrorCode = ERROR_SUCCESS;

            //  Copy the pointers to the value data back to the user's buffer.
            //  Don't ask me why, but the Win95 code copies the value length
            //  back again if the provider is maintaining it.
            for (Counter = 0, pCurrentValent = val_list; Counter < num_vals;
                Counter++, pCurrentValent++) {
                pCurrentValent-> ve_valueptr = (DWORD)
                    pValueContext[Counter].val_buff_ptr;
                if (hKey-> Flags & KEYF_PROVIDERHASVALUELENGTH)
                    pCurrentValent-> ve_valuelen = pValueContext[Counter].valuelen;
            }

        }

        RgSmFreeMemory(pValueContext);

        goto ReturnErrorCode;

    }
#endif

    //
    //  First pass over the value names checks for the existence of the value
    //  and its size.  We check the total size against the provided buffer size
    //  and bail out if necessary.
    //

    RequiredSize = 0;

    for (Counter = num_vals, pCurrentValent = val_list; Counter > 0; Counter--,
        pCurrentValent++) {

        if ((ErrorCode = RgLookupValueByName(hKey, pCurrentValent->
            ve_valuename, &lpKeyRecord, &lpValueRecord)) != ERROR_SUCCESS)
            goto ReturnErrorCode;

        ErrorCode = RgCopyFromValueRecord(hKey, lpValueRecord, NULL, NULL,
            &(pCurrentValent-> ve_type), NULL, &(pCurrentValent-> ve_valuelen));

        RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BlockIndex, FALSE);

        if (ErrorCode != ERROR_SUCCESS)
            goto ReturnErrorCode;

        pCurrentValent-> ve_valueptr = (DWORD) NULL;
        RequiredSize += pCurrentValent-> ve_valuelen;

    }

    BufferSize = *lpdwTotalSize;
    *lpdwTotalSize = RequiredSize;

    if (BufferSize < RequiredSize) {
        ErrorCode = ERROR_MORE_DATA;
        goto ReturnErrorCode;
    }

    //
    //  Second pass copies the value data back to the user's buffer now that we
    //  know the buffer is large enough to contain the data.
    //

    lpCurrentBuffer = lpValueBuffer;

    for (Counter = num_vals, pCurrentValent = val_list; Counter > 0; Counter--,
        pCurrentValent++) {

        if ((ErrorCode = RgLookupValueByName(hKey, pCurrentValent->
            ve_valuename, &lpKeyRecord, &lpValueRecord)) != ERROR_SUCCESS)
            goto ReturnErrorReading;

        ErrorCode = RgCopyFromValueRecord(hKey, lpValueRecord, NULL, NULL, NULL,
            lpCurrentBuffer, &(pCurrentValent-> ve_valuelen));

        RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BlockIndex, FALSE);

        if (ErrorCode != ERROR_SUCCESS) {
ReturnErrorReading:
            TRAP();                     //  Registry is internally inconsistent?
            ErrorCode = ERROR_CANTREAD;
            goto ReturnErrorCode;
        }

        pCurrentValent-> ve_valueptr = (DWORD) lpCurrentBuffer;
        lpCurrentBuffer += pCurrentValent-> ve_valuelen;

    }

    ErrorCode = ERROR_SUCCESS;

ReturnErrorCode:
    RgUnlockRegistry();

    return ErrorCode;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmmreg32\utilw32c.c ===
//
//  UTILW32C.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Operating system interfaces for Win32 environments.
//

#include "pch.h"

//
//  RgCreateTempFile
//
//  Returns the path through lpFileName and a file handle of a temporary file
//  located in the same directory as lpFileName.  lpFileName must specify the
//

HFILE
INTERNAL
RgCreateTempFile(
    LPSTR lpFileName
    )
{

    HFILE hFile;

    if (GetTempFileName(lpFileName, "reg", 0, lpFileName) > 0) {
        if ((hFile = RgOpenFile(lpFileName, OF_WRITE)) != HFILE_ERROR)
            return hFile;
        DeleteFile(lpFileName);
    }

    DEBUG_OUT(("RgCreateTempFile failed\n"));
    return HFILE_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmmreg32\utilwinc.c ===
//
//  UTILWINC.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Operating system interfaces for Windows environments.
//

#include "pch.h"

BOOL
INTERNAL
RgReadFile(
    HFILE hFile,
    LPVOID lpBuffer,
    UINT ByteCount
    )
{

    UINT BytesRead;

    BytesRead = _lread(hFile, lpBuffer, ByteCount);

    return ByteCount == BytesRead;

}

BOOL
INTERNAL
RgWriteFile(
    HFILE hFile,
    LPVOID lpBuffer,
    UINT ByteCount
    )
{

    UINT BytesWritten;

    BytesWritten = _lwrite(hFile, lpBuffer, ByteCount);

    return ByteCount == BytesWritten;

}

#ifndef FILE_BEGIN
#define FILE_BEGIN SEEK_SET
#endif

BOOL
INTERNAL
RgSeekFile(
    HFILE hFile,
    LONG FileOffset
    )
{

    LONG NewFileOffset;

    NewFileOffset = _llseek(hFile, FileOffset, FILE_BEGIN);

    return FileOffset == NewFileOffset;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmmreg32\regqval.c ===
//
//  REGQVAL.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegQueryValue, RegQueryValueEx and supporting functions.
//

#include "pch.h"

//
//  RgLookupValueByName
//
//  Searches for the value with the specified name and returns a pointer to its
//  KEY_RECORD and VALUE_RECORD.
//

int
INTERNAL
RgLookupValueByName(
                   HKEY hKey,
                   LPCSTR lpValueName,
                   LPKEY_RECORD FAR* lplpKeyRecord,
                   LPVALUE_RECORD FAR* lplpValueRecord
                   )
{

    int ErrorCode;
    LPKEY_RECORD lpKeyRecord;
    UINT ValueNameLength;
    LPVALUE_RECORD lpValueRecord;
    UINT ValuesRemaining;

    //  Handle Win95 registries that don't have a key record for the root key.
    if (IsNullBlockIndex(hKey-> BlockIndex))
        return ERROR_CANTREAD16_FILENOTFOUND32;

    if ((ErrorCode = RgLockKeyRecord(hKey-> lpFileInfo, hKey-> BlockIndex,
                                     hKey-> KeyRecordIndex, &lpKeyRecord)) == ERROR_SUCCESS) {

        ValueNameLength = (IsNullPtr(lpValueName) ? 0 : (UINT)
                           StrLen(lpValueName));

        lpValueRecord = (LPVALUE_RECORD) ((LPBYTE) &lpKeyRecord-> Name +
                                          lpKeyRecord-> NameLength + lpKeyRecord-> ClassLength);

        ValuesRemaining = lpKeyRecord-> ValueCount;

        while (ValuesRemaining) {

            if (lpValueRecord-> NameLength == ValueNameLength &&
                (ValueNameLength == 0 || RgStrCmpNI(lpValueName, lpValueRecord->
                                                    Name, ValueNameLength) == 0)) {
                *lplpKeyRecord = lpKeyRecord;
                *lplpValueRecord = lpValueRecord;
                return ERROR_SUCCESS;
            }

            lpValueRecord = (LPVALUE_RECORD) ((LPBYTE) &lpValueRecord->
                                              Name + lpValueRecord-> NameLength + lpValueRecord->
                                              DataLength);

            ValuesRemaining--;

        }

        RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BlockIndex, FALSE);

        ErrorCode = ERROR_CANTREAD16_FILENOTFOUND32;

    }

    return ErrorCode;

}

//
//  RgCopyFromValueRecord
//
//  Shared routine for RegQueryValue and RegEnumValue.  Copies the information
//  from the VALUE_RECORD to the user-provided buffers.  All parameters should
//  have already been validated.
//
//  Because all parameters have been validated, if lpData is valid, then
//  lpcbData MUST be valid.
//

int
INTERNAL
RgCopyFromValueRecord(
                     HKEY hKey,
                     LPVALUE_RECORD lpValueRecord,
                     LPSTR lpValueName,
                     LPDWORD lpcbValueName,
                     LPDWORD lpType,
                     LPBYTE lpData,
                     LPDWORD lpcbData
                     )
{

    int ErrorCode;
    UINT BytesToTransfer;
#ifdef WANT_DYNKEY_SUPPORT
    PINTERNAL_PROVIDER pProvider;
    PPVALUE pProviderValue;
    struct val_context ValueContext;
#endif

#ifdef WANT_DYNKEY_SUPPORT
    if (hKey-> PredefinedKeyIndex == INDEX_DYN_DATA) {

        pProvider = hKey-> pProvider;

        if (IsNullPtr(pProvider))
            return ERROR_CANTOPEN;

        //  The value data contains only part of a PROVIDER structure.
        pProviderValue = CONTAINING_RECORD(&lpValueRecord-> Name +
                                           lpValueRecord-> NameLength, PVALUE, pv_valuelen);

        if (!IsNullPtr(lpType))
            *lpType = pProviderValue-> pv_type;

        if (!(hKey-> Flags & KEYF_PROVIDERHASVALUELENGTH)) {

            BytesToTransfer = pProviderValue-> pv_valuelen;

            if (IsNullPtr(lpData))
                goto ValueDataNotNeeded;

            if (BytesToTransfer > *lpcbData) {
                *lpcbData = BytesToTransfer;
                return ERROR_MORE_DATA;
            }

            //	Win95 compatibility: now that we know the required number of
            //	bytes, validate the data buffer.
            if (IsBadHugeWritePtr(lpData, BytesToTransfer))
                return ERROR_INVALID_PARAMETER;

        }

        ValueContext.value_context = pProviderValue-> pv_value_context;

        if (!IsNullPtr(lpcbData)) {

            //  Zero *lpcbData, if we aren't actually copying any data back to
            //  the user's buffer.  This keeps some providers from stomping on
            //  lpData.
            if (IsNullPtr(lpData))
                *lpcbData = 0;

            if ((ErrorCode = (int) pProvider-> ipi_R0_1val(pProvider->
                                                           ipi_key_context, &ValueContext, 1, lpData, lpcbData, 0)) !=
                ERROR_SUCCESS) {

                //  Win95 compatibility: the old code ignored any errors if
                //  lpData is NULL.  The below ASSERT will verify that we aren't
                //  dropping errors.
                if (!IsNullPtr(lpData))
                    return ErrorCode;

                ASSERT((ErrorCode == ERROR_SUCCESS) || (ErrorCode ==
                                                        ERROR_MORE_DATA));

            }

        }

        goto CopyValueName;

    }
#endif

    if (!IsNullPtr(lpType))
        *lpType = lpValueRecord-> DataType;

    BytesToTransfer = lpValueRecord-> DataLength;

    //  The terminating null is not stored in the value record.
    if (lpValueRecord-> DataType == REG_SZ)
        BytesToTransfer++;

    //
    //  Win32 compatibilty: lpData must be filled in before lpValueName.  Word
    //  NT and Excel NT broke when we validated lpValueName and failed the call
    //  before filling in lpData which was valid.  Don't rearrange this code!
    //

    if (!IsNullPtr(lpData)) {

        ErrorCode = ERROR_SUCCESS;

        if (BytesToTransfer > *lpcbData) {
            *lpcbData = BytesToTransfer;
            return ERROR_MORE_DATA;
        }

        //  Win95 compatibility: now that we know the required number of bytes,
        //  validate the data buffer.
        else if (IsBadHugeWritePtr(lpData, BytesToTransfer))
            return ERROR_INVALID_PARAMETER;

        else {

            MoveMemory(lpData, &lpValueRecord-> Name + lpValueRecord->
                       NameLength, lpValueRecord-> DataLength);

            if (lpValueRecord-> DataType == REG_SZ)
                lpData[lpValueRecord-> DataLength] = '\0';

        }

    }

#ifdef WANT_DYNKEY_SUPPORT
    ValueDataNotNeeded:
#endif
    if (!IsNullPtr(lpcbData))
        *lpcbData = BytesToTransfer;

#ifdef WANT_DYNKEY_SUPPORT
    CopyValueName:
#endif
    if (!IsNullPtr(lpValueName)) {

        ErrorCode = ERROR_SUCCESS;

        if (*lpcbValueName <= lpValueRecord-> NameLength) {

            //  Although we will not touch the lpData buffer if it's too small
            //  to hold the value data, we will partially fill lpValueName if
            //  it's too small.
            ErrorCode = ERROR_MORE_DATA;

            if (*lpcbValueName == 0)
                return ErrorCode;

            BytesToTransfer = (UINT) *lpcbValueName - 1;

        }

        else
            BytesToTransfer = lpValueRecord-> NameLength;

        MoveMemory(lpValueName, &lpValueRecord-> Name, BytesToTransfer);
        lpValueName[BytesToTransfer] = '\0';

        //  Does not include terminating null.
        *lpcbValueName = BytesToTransfer;

        return ErrorCode;

    }

    return ERROR_SUCCESS;

}

//
//  VMMRegQueryValueEx
//
//  See Win32 documentation of RegQueryValueEx.
//

LONG
REGAPI
VMMRegQueryValueEx(
                  HKEY hKey,
                  LPCSTR lpValueName,
                  LPDWORD lpReserved,
                  LPDWORD lpType,
                  LPBYTE lpData,
                  LPDWORD lpcbData
                  )
{

    int ErrorCode;
    LPKEY_RECORD lpKeyRecord;
    LPVALUE_RECORD lpValueRecord;

    if (IsBadOptionalStringPtr(lpValueName, (UINT) -1))
        return ERROR_INVALID_PARAMETER;

    if (IsBadHugeOptionalWritePtr(lpType, sizeof(DWORD)))
        return ERROR_INVALID_PARAMETER;

    if (IsNullPtr(lpcbData)) {
        if (!IsNullPtr(lpData))
            return ERROR_INVALID_PARAMETER;
    }

    else {
        //  Win95 compatibility: don't validate lpData is of size *lpcbData.
        //  Instead of validating the entire buffer, we'll validate just the
        //  required buffer length in RgCopyFromValueRecord.
        if (IsBadHugeWritePtr(lpcbData, sizeof(DWORD)))
            return ERROR_INVALID_PARAMETER;
    }

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) == ERROR_SUCCESS) {

        if ((ErrorCode = RgLookupValueByName(hKey, lpValueName, &lpKeyRecord,
                                             &lpValueRecord)) == ERROR_SUCCESS) {

            ErrorCode = RgCopyFromValueRecord(hKey, lpValueRecord, NULL, NULL,
                                              lpType, lpData, lpcbData);
            RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BlockIndex, FALSE);

        }

        else if (ErrorCode == ERROR_CANTREAD16_FILENOTFOUND32) {

            //
            //  Windows 95 compatibility problem.  If the "value
            //  record" didn't exist in Windows 3.1, then it acted like it was
            //  really a null byte REG_SZ string.  This should have only been
            //  done in RegQueryValue, but we're stuck with it now...
            //

            if (IsNullPtr(lpValueName) || *lpValueName == '\0') {

                if (!IsNullPtr(lpType))
                    *lpType = REG_SZ;

                if (!IsNullPtr(lpData) && *lpcbData > 0)
                    *lpData = 0;

                if (!IsNullPtr(lpcbData))
                    *lpcbData = sizeof(char);

                ErrorCode = ERROR_SUCCESS;

            }

        }

    }

    RgUnlockRegistry();

    return ErrorCode;

    UNREFERENCED_PARAMETER(lpReserved);

}

//
//  VMMRegQueryValue
//
//  See Win32 documentation of RegQueryValue.
//

LONG
REGAPI
VMMRegQueryValue(
                HKEY hKey,
                LPCSTR lpSubKey,
                LPBYTE lpData,
                LPDWORD lpcbData
                )
{

    LONG ErrorCode;
    HKEY hSubKey;

    if ((ErrorCode = RgCreateOrOpenKey(hKey, lpSubKey, &hSubKey, LK_OPEN)) ==
        ERROR_SUCCESS) {
        ErrorCode = VMMRegQueryValueEx(hSubKey, NULL, NULL, NULL, lpData,
                                       lpcbData);
        VMMRegCloseKey(hSubKey);
    }

    return ErrorCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmtests\mem64.c ===
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#define DbgPrint printf
#define NtTerminateProcess(a,b) ExitProcess(b)

typedef unsigned long *POINTER_64 PULONG64;

__cdecl main()
{
    LONG i, j;
    PVOID64 p1;
    PVOID64 p2;
    PVOID64 p3;
    PULONG64 long64;
    ULONG Size2, Size3;
    ULONGLONG Size1;
    NTSTATUS status, alstatus;
    HANDLE CurrentProcessHandle;
    HANDLE GiantSection;
    HANDLE Section2, Section4;
    MEMORY_BASIC_INFORMATION MemInfo;
    ULONG OldProtect;
    STRING Name3;
    HANDLE Section1;
    OBJECT_ATTRIBUTES ObjectAttributes;
    OBJECT_ATTRIBUTES Object1Attributes;
    ULONG ViewSize;
    LARGE_INTEGER Offset;
    LARGE_INTEGER SectionSize;
    UNICODE_STRING Unicode;

    CurrentProcessHandle = NtCurrentProcess();

    DbgPrint(" 64-bit Memory Management Tests - AllocVm, FreeVm, ProtectVm, QueryVm\n");

    Size1 = 1*1024*1024;
    p1 = NULL;

    alstatus = NtAllocateVirtualMemory64 (CurrentProcessHandle,
                                         (PVOID *)&p1,
                                         0,
                                         &Size1,
                                         MEM_RESERVE | MEM_COMMIT,
                                         PAGE_READWRITE);

    if (!NT_SUCCESS(alstatus)) {
        DbgPrint("failed first created vm status %X start %lx size %lx\n",
            alstatus, (ULONG)p1, Size1);
        DbgPrint("******** FAILED TEST 1 **************\n");
        return 1;
    }

    printf("starting va %lx %08lx\n", (ULONG)((ULONGLONG)p1 >> 32),(ULONG)((ULONGLONG)p1));

    printf("touching va %lx %08lx\n", (ULONG)((ULONGLONG)p1 >> 32),(ULONG)(ULONGLONG)p1);

   long64 = p1;

   *long64 = 77;

    p2 = NULL;
    alstatus = NtAllocateVirtualMemory64 (CurrentProcessHandle,
                                         (PVOID *)&p2,
                                         0,
                                         &Size1,
                                         MEM_RESERVE | MEM_COMMIT,
                                         PAGE_READWRITE);

    if (!NT_SUCCESS(alstatus)) {
        DbgPrint("failed first created vm status %X start %lx size %lx\n",
            alstatus, (ULONG)p2, Size1);
        DbgPrint("******** FAILED TEST 1 **************\n");
        return 1;
    }

    printf("starting va %lx %08lx\n", (ULONG)((ULONGLONG)p2 >> 32),(ULONG)((ULONGLONG)p2));

    p3 = NULL;
    alstatus = NtAllocateVirtualMemory64 (CurrentProcessHandle,
                                         (PVOID *)&p3,
                                         0,
                                         &Size1,
                                         MEM_RESERVE | MEM_COMMIT,
                                         PAGE_READWRITE);

    if (!NT_SUCCESS(alstatus)) {
        DbgPrint("failed first created vm status %X start %lx size %lx\n",
            alstatus, (ULONG)p3, Size1);
        DbgPrint("******** FAILED TEST 1 **************\n");
        return 1;
    }

    printf("starting va %lx %08lx\n", (ULONG)((ULONGLONG)p3 >> 32),(ULONG)((ULONGLONG)p3));

    printf("freeing va at %lx %08lx\n", (ULONG)((ULONGLONG)p2 >> 32),(ULONG)(ULONGLONG)p2);

    Size1 = 0;
    alstatus = NtFreeVirtualMemory64 (CurrentProcessHandle,
                                      (PVOID *)&p2,
                                      &Size1,
                                      MEM_RELEASE);

    if (!NT_SUCCESS(alstatus)) {
        DbgPrint("failed first free vm status %X start %lx size %lx\n",
            alstatus, (ULONG)p2, Size1);
        DbgPrint("******** FAILED TEST 1 **************\n");
        return 1;
    }

    printf("decommit va at %lx %08lx\n", (ULONG)((ULONGLONG)p3 >> 32),(ULONG)(ULONGLONG)p3);

    Size1 = 4096;
    alstatus = NtFreeVirtualMemory64 (CurrentProcessHandle,
                                      (PVOID *)&p3,
                                      &Size1,
                                      MEM_DECOMMIT);

    if (!NT_SUCCESS(alstatus)) {
        DbgPrint("failed first delete vm status %X start %lx size %lx\n",
            alstatus, (ULONG)p3, Size1);
        DbgPrint("******** FAILED TEST 1 **************\n");
        return 1;
    }
 //   return 0;


#if 0
    status = NtQueryVirtualMemory (CurrentProcessHandle, p1,
                                    MemoryBasicInformation,
                                    &MemInfo, sizeof (MEMORY_BASIC_INFORMATION),
                                    NULL);

    if (!NT_SUCCESS(status)) {
        DbgPrint("******** FAILED TEST 2 **************\n");
        DbgPrint("FAILURE query vm status %X address %lx Base %lx size %lx\n",
             status,
             p1,
             MemInfo.BaseAddress,
             MemInfo.RegionSize);
        DbgPrint("     state %lx protect %lx type %lx\n",
             MemInfo.State,
             MemInfo.Protect,
             MemInfo.Type);
    }
    if ((MemInfo.RegionSize != Size1) || (MemInfo.BaseAddress != p1) ||
        (MemInfo.Protect != PAGE_READWRITE) || (MemInfo.Type != MEM_PRIVATE) ||
        (MemInfo.State != MEM_COMMIT)) {

        DbgPrint("******** FAILED TEST 3 **************\n");
        DbgPrint("FAILURE query vm status %X address %lx Base %lx size %lx\n",
             status,
             p1,
             MemInfo.BaseAddress,
             MemInfo.RegionSize);
    }
    return 0;
#endif //0
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmtests\color.c ===
/* memtest.c, Robert Nix, December, 1993
 *            nix@vliw.enet.dec.com
 * based on:
 *      cbash.c
 *      kirk johnson @ MIT
 *      february 1993
 *
 *      RCS $Id: cbash.c,v 1.2 1993/08/12 15:30:17 tuna Exp $
 *
 * Usage: memtest <machname> <iterations> <max-mem>
 *    machname   - a short indentifier for the machine being tested.
 *    iterations - target number of iterations to run for stable timing.
 *    max-mem    - maximum working set size to test.
 *
 *    Iterations and max-mem can be specified with a "k" or "m" suffix
 *    for kilo or mega iterations/mem.
 *
 * Example: Test of a Gateway 60 Mhz Pentium system
 * Command Line: memtest gp560 8m 4m
 * Output:
 *
--------------------------------------------------------------------------------
 *                      4k   8k  16k  32k  64k 128k 256k 512k   1m   2m   4m
 * L gp560          4   68   68   86   86   86   93  104  111  111  111  122
 * L gp560          8   68   68  107  107  107  114  139  165  154  154  154
 * L gp560         16   89   68  143  143  143  161  204  232  240  243  243
 * L gp560         32   68   68  172  168  168  207  290  347  365  365  365
 * L gp560         64   68   72  168  168  168  207  290  350  368  368  368
 * L gp560        128   72   75  168  168  168  211  293  358  379  418  379
 * L gp560        256   75   79  168  168  168  207  293  379  397  401  401
 * L gp560        512   86   86  172  168  168  215  297  418  440  443  494
 * L gp560         1k  100  104  175  172  168  218  304  501  522  529  529
 * L gp560         2k  136  139  179  172  172  222  322  665  687  755  701
 * L gp560         4k  132  243  232  225  222  286  401  991 1016 1094 1048
 * L gp560         8k  132  136  243  232  225  290  350  923  973 1034 1109
 * L gp560        16k  132  136  132  243  232  225  333  937  908  994 1041
 * L gp560        32k  136  132  136  136  243  232  304  833  919  930 1012
 *
--------------------------------------------------------------------------------
 * Explanation of output.
 *
 * There are three kinds of tests.
 *
 * L - Load latency test.
 *     Measures the average repetition rate, in ns, of a latency-oriented load
 *     loop.  The two main variables are:
 *
 *        (1) working set, or the amount of memory touched by the loop.  This
 *            varies across the columns in the output above, from a low of 4k
 *            bytes to a high of max-mem, or 16m bytes.
 *
 *        (2) stride, or the the number of bytes separating successive loads.
 *            This is the number in the 3rd column of each of the "L" rows
 *            in the output above, and varies from 4 bytes to 32k bytes.
 *
 * Interpreting the results. This is easiest on a 3d chart in Excel.
 * Two strides are always particularly interesting:
 *
 *      - The cache line or block size stride (32 bytes above).
 *        Big changes in latencies across the columns show the sizes
 *        and basic performance of the load side of the cache hierarchy.
 *
 *        If you don't know the cache line size: look across the first row
 *        for the first column that takes a big jump up in latency (the jump
 *        from 68ns to 86ns between the 8k column and 16k columnabove), then (b)
 *        scan down the rows of that column for the first relativelystable value
 *        (172ns in the 32 byte stride row above).  The row containing
 *        that stable value is probably the cache line size.
 *
 *        Look across the cache line size row.  Access time jumps at 16K --
 *        so the L1 cache is 8K -- and then jumps again at 512K -- so the L2
 *        cache is 256K.  The slope between 64K and 512K could be caused
 *        by a thrash in the L2 cache; page coloring could remove this thrash.
 *
 *      - The page size stride (4k above).
 *        Big changes in latencies across the columns expose the tbsize and the cost
 *        of a tb refill.
 *
 *        Scan the 4k line. It takes a big jump in latency at the 512K working
 *        set (and actually starts to thrash at the 256K working set). This test says the TB
 *        can map somewhere in the neighborhood of 64 4K pages.  The TB fill time
 *        looks to be somewhere around 650-700 ns (subtract large working set entries
 *        in the 32-byte stride line from corresponding entries in the 4k stride line).
 *
 * The output always contains a little noise:
 *
 *      - Boost the "iterations" command line parameter to remove timing jitter.
 *
 *      - All entries contain some loop overhead.  Its fair to normalize results by subtracting
 *        out the difference between the reported times and the known latency to the fastest level
 *        of the memory hierarchy.
 *
 *      - The entries in the lower-left hand corner of the table (large
 *        strides in small memory) are dominated by loop overhead; ignore them.
 *
 *      - Implement a good page coloring algorithm to remove jitter caused by cache
 *        thrashing.  Look at the cache-line sized stride to see the frequency of thrashing.
 *
 */

#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <time.h>
#define DEF_MAXMEM 16777216
#define MINMEM 4096
#define ITYPE signed int
signed long     max_mem;
char           *mach_name;

#if defined(_WIN64)
typedef unsigned __int64 ULONG_PTR;
#else
typedef unsigned long ULONG_PTR;
#endif

#define MAXSTRIDE 32768
#define MINSTRIDE 4

char           *version_string = "1.0 (20 Dec 1993)";
extern ITYPE  arg_to_int(char *);
extern double bash(char *, long, long, long);
extern int bash_loop(char *, long, long, long);
extern void allocate_memory(char *, long);
extern void usage(char *);

int __cdecl main(
     int argc,
     char *argv[]
)
{
ITYPE           nbytes;
ITYPE           stride;
ITYPE           iters;
char           *region;

    if ((argc > 1) && (strcmp(argv[1], "-v") == 0)) {
       fprintf(stderr, "This is memtest version %s.\n", version_string);
        exit(1);
    }
    if (argc < 3)
    usage(argv[0]);
    mach_name = argv[1];
    iters = arg_to_int(argv[2]);
    if (argc < 4) {
        max_mem = DEF_MAXMEM;
    } else {
        max_mem = arg_to_int(argv[3]);
    }
    region = (char *) malloc(max_mem+(128*1024));
    region = (char *) ((((ULONG_PTR) region) + (128*1024-1)) & ~((128*1024)-1));
    if (region == NULL) {
        perror("malloc failed");
        exit(1);
    }
    printf("  %8s", "");
    printf("%8s", "");
    for (nbytes = MINMEM; nbytes <= max_mem; nbytes += nbytes) {
        if (nbytes >= (1024 * 1024))
            printf("%4dm", nbytes / (1024 * 1024));
        else if (nbytes >= 1024)
            printf("%4dk", nbytes / 1024);
        else
            printf("%5d", nbytes);
    }
    printf("\n");
    for (stride = MINSTRIDE; stride <= MAXSTRIDE; stride += stride) {
        printf("L %-8s", mach_name);
        if (stride >= (1024 * 1024))
            printf("%7dm", stride / (1024 * 1024));
        else if (stride >= 1024)
            printf("%7dk", stride / 1024);
        else
            printf("%8d", stride);
        for (nbytes = MINMEM; nbytes <= max_mem; nbytes += nbytes) {
            double ns_ref = bash(region, nbytes, stride, iters);
            printf("%5.0f", ns_ref);
            fflush(stdout);
        }
        printf("\n");
    }
    exit(0);
    return 0;
}

ITYPE
arg_to_int(char *arg)
{
ITYPE           rslt = 0;
ITYPE           mult = 1;

    switch (arg[strlen(arg) - 1]) {
    case 'k':
    case 'K':
        mult = 1024;
        break;

    case 'm':
    case 'M':
        mult = 1024 * 1024;
        break;

    default:
        mult = 1;
        break;
    }
    if (!((arg[0] >= '0') && arg[0] <= '9')) {
        fprintf(stderr, "Argument %s not a number\n", arg);
        usage("memtest");
        exit(1);
    }
    sscanf(arg, "%ld", &rslt);
    rslt *= mult;
    return rslt;
}


double
bash(
     char *region,
     long nbytes,       /* size of region to bash (bytes) */
     long stride,       /* stride through region (bytes)  */
     long iters         /* target # of loop iterations    */
)
{
signed long     count;
signed long     reps;
clock_t         start, stop;
double          utime, stime;

    count = ((nbytes - sizeof(int)) / stride) + 1;
    if (! (((count - 1) * stride + (long)sizeof(int)) <= nbytes)) {
        fprintf(stderr, "trip count problem\n");
        exit(1);
    }
    reps = (iters + count - 1) / count;
    if (reps <= 0)
        reps = 1;
    iters = reps * count;

    /* make sure the memory is allocated */
    memset(region, 0, nbytes);
    memset(region, 1, nbytes);
    allocate_memory(region, nbytes);
    memset(region, 0, nbytes);
    /* warm up the cache */
    (void) bash_loop(region, count, stride, 1L);

    /* run the bash loop */
    start = clock();
    (void) bash_loop(region, count, stride, reps);
    stop = clock();
    utime = (double) (stop - start) / CLOCKS_PER_SEC;
    stime = 0.0;

    return 1e9 * ((utime + stime) / iters);
}

/* Your virtual memory pagesize must be at least this big */
#define MIN_PAGESIZE    256

void
allocate_memory(
                char *region,   /* memory region to be bashed       */
                long nbytes)
{                       /* size of region (bytes)           */
long            i;

    for (i = 0; i < nbytes; i += MIN_PAGESIZE)
        *((int *) (region + i)) = 0;
}


int
bash_loop(
          char *region, /* memory region to be bashed       */
          long count,   /* number of locations to bash      */
          long stride,  /* stride between locations (bytes) */
          long reps     /* number of passes through region  */
)
{
long            i;
int             rslt;
char           *tmp;

    rslt = 0;
    for (; reps > 0; reps--) {
        tmp = region;
        for (i = count; i > 0; i--) {
            rslt ^= *((int *) tmp);
            tmp += stride;
        }
    }

    return rslt;
}


void
usage(char *progname)
{
    fprintf(stderr, "usage: %s <machname> <iters> [<maxmem>]\n", progname);
    fprintf(stderr, "  <machname>   machine name\n");
    fprintf(stderr, "  <iters>      target # of accesses\n");
    fprintf(stderr, "  <maxmem>     maximum amount of mem to touch (def 16 Mb)\n");
    exit(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmmreg32\regsval.c ===
//
//  REGSVAL.C
//
//  Copyright (C) Microsoft Corporation, 1995
//
//  Implementation of RegSetValue, RegSetValueEx and supporting functions.
//

#include "pch.h"

//
//  RgReAllocKeyRecord
//

int
INTERNAL
RgReAllocKeyRecord(
    HKEY hKey,
    DWORD Length,
    LPKEY_RECORD FAR* lplpKeyRecord
    )
{

    int ErrorCode;
    LPKEY_RECORD lpOldKeyRecord;
    UINT BlockIndex;
    UINT KeyRecordIndex;
    LPDATABLOCK_INFO lpOldDatablockInfo;
    LPKEYNODE lpKeynode;

    if (Length > MAXIMUM_KEY_RECORD_SIZE) {
        TRACE(("key record too big\n"));
        return ERROR_OUTOFMEMORY;
    }

    lpOldKeyRecord = *lplpKeyRecord;

    BlockIndex = HIWORD(lpOldKeyRecord-> DatablockAddress);
    KeyRecordIndex = LOWORD(lpOldKeyRecord-> DatablockAddress);

    //
    //  Check if we can simply extend this key record by taking space from an
    //  adjacent free record.
    //

    if (RgExtendKeyRecord(hKey-> lpFileInfo, BlockIndex, (UINT) Length,
        lpOldKeyRecord) == ERROR_SUCCESS)
        return ERROR_SUCCESS;

    //
    //  Check if there's enough space in the datablock lpCurrKeyRecord is in to
    //  contain a key record of the specified size.  If so, then we don't have
    //  to dirty the keynode.
    //

    if (RgAllocKeyRecordFromDatablock(hKey-> lpFileInfo, BlockIndex,
        (UINT) Length, lplpKeyRecord) == ERROR_SUCCESS) {

        //  After an alloc, we must refetch these pointers because they may be
        //  invalid.
        lpOldDatablockInfo = RgIndexDatablockInfoPtr(hKey-> lpFileInfo,
            BlockIndex);
        lpOldKeyRecord = RgIndexKeyRecordPtr(lpOldDatablockInfo,
            KeyRecordIndex);

        //  Transfer all the data to the new record, except for the allocated
        //  size which is already correctly set.
        MoveMemory(&(*lplpKeyRecord)-> DatablockAddress, &lpOldKeyRecord->
            DatablockAddress, SmallDword(lpOldKeyRecord-> RecordSize) -
            sizeof(DWORD));

        RgFreeKeyRecord(lpOldDatablockInfo, lpOldKeyRecord);

        //  Update the key record table to point to the new key record.
        lpOldDatablockInfo-> lpKeyRecordTable[KeyRecordIndex] =
            (KEY_RECORD_TABLE_ENTRY) ((LPBYTE) (*lplpKeyRecord) -
            (LPBYTE) lpOldDatablockInfo-> lpDatablockHeader);

        return ERROR_SUCCESS;

    }

    //
    //  Check if we can allocate a key record from another datablock.  If so,
    //  then copy the key to the other datablock and update the keynode.
    //

    if (RgLockInUseKeynode(hKey-> lpFileInfo, hKey-> KeynodeIndex,
        &lpKeynode) == ERROR_SUCCESS) {

        if ((ErrorCode = RgAllocKeyRecord(hKey-> lpFileInfo, (UINT) Length,
            lplpKeyRecord)) == ERROR_SUCCESS) {

            //  After an alloc, we must refetch these pointers because they may
            //  be invalid.
            lpOldDatablockInfo = RgIndexDatablockInfoPtr(hKey-> lpFileInfo,
                BlockIndex);
            lpOldKeyRecord = RgIndexKeyRecordPtr(lpOldDatablockInfo,
                KeyRecordIndex);

            //  Transfer all the data to the new record, except for the
            //  allocated size which is already correctly set.
            MoveMemory(&(*lplpKeyRecord)-> RecordSize, &lpOldKeyRecord->
                RecordSize, SmallDword(lpOldKeyRecord-> RecordSize) -
                (sizeof(DWORD) * 2));

            RgFreeKeyRecord(lpOldDatablockInfo, lpOldKeyRecord);
            RgFreeKeyRecordIndex(lpOldDatablockInfo, KeyRecordIndex);

            //  Unlock the old datablock.
            RgUnlockDatablock(hKey-> lpFileInfo, BlockIndex, TRUE);

            //  Update the open key and keynode to point to the key record in
            //  the new datablock.
            hKey-> BlockIndex = (*lplpKeyRecord)-> BlockIndex;
            lpKeynode-> BlockIndex = hKey-> BlockIndex;
            hKey-> KeyRecordIndex = (BYTE) (*lplpKeyRecord)-> KeyRecordIndex;
            lpKeynode-> KeyRecordIndex = hKey-> KeyRecordIndex;

        }

        RgUnlockKeynode(hKey-> lpFileInfo, hKey-> KeynodeIndex, TRUE);

        return ErrorCode;

    }

    return ERROR_OUTOFMEMORY;

}

//
//  RgSetValue
//

int
INTERNAL
RgSetValue(
    HKEY hKey,
    LPCSTR lpValueName,
    DWORD Type,
    LPBYTE lpData,
    UINT cbData
    )
{

    int ErrorCode;
    UINT ValueNameLength;
    UINT NewValueRecordLength;
    LPKEY_RECORD lpKeyRecord;
    LPVALUE_RECORD lpValueRecord;
    UINT CurrentValueRecordLength;
    LPBYTE lpDestination;
    UINT BytesToExtend;
    UINT TempCount;
    LPKEYNODE lpKeynode;

    ValueNameLength = (IsNullPtr(lpValueName) ? 0 : (UINT) StrLen(lpValueName));

    if (ValueNameLength > MAXIMUM_VALUE_NAME_LENGTH - 1)
        return ERROR_INVALID_PARAMETER;

    NewValueRecordLength = sizeof(VALUE_RECORD) + ValueNameLength + cbData - 1;

    ErrorCode = RgLookupValueByName(hKey, lpValueName, &lpKeyRecord,
        &lpValueRecord);

    //
    //  A value with this name already exists, so update the existing
    //  VALUE_RECORD with the new information.
    //

    if (ErrorCode == ERROR_SUCCESS) {

        CurrentValueRecordLength = sizeof(VALUE_RECORD) + lpValueRecord->
            NameLength + lpValueRecord-> DataLength - 1;

        if (NewValueRecordLength == CurrentValueRecordLength) {
            if (lpValueRecord-> DataLength == cbData && lpValueRecord->
                DataType == Type && CompareMemory((LPBYTE) lpValueRecord->
                Name + ValueNameLength, lpData, cbData) == 0) {
                RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BlockIndex, FALSE);
                return ERROR_SUCCESS;
            }
        }

        if (NewValueRecordLength < CurrentValueRecordLength) {
            lpKeyRecord-> RecordSize -= (CurrentValueRecordLength -
                NewValueRecordLength);
        }

        else if (NewValueRecordLength > CurrentValueRecordLength) {

            BytesToExtend = NewValueRecordLength - CurrentValueRecordLength;

            if (BytesToExtend > SmallDword(lpKeyRecord-> AllocatedSize) -
                SmallDword(lpKeyRecord-> RecordSize)) {

                TempCount = (LPBYTE) lpValueRecord - (LPBYTE) lpKeyRecord;

                if ((ErrorCode = RgReAllocKeyRecord(hKey, lpKeyRecord->
                    RecordSize + BytesToExtend, &lpKeyRecord)) !=
                    ERROR_SUCCESS) {
                    RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BlockIndex,
                        FALSE);
                    return ErrorCode;
                }

                lpValueRecord = (LPVALUE_RECORD) ((LPBYTE) lpKeyRecord +
                    TempCount);

            }

            lpKeyRecord-> RecordSize += BytesToExtend;

        }

        lpDestination = (LPBYTE) lpValueRecord + NewValueRecordLength;
        TempCount = (UINT) ((LPBYTE) lpKeyRecord + SmallDword(lpKeyRecord->
            RecordSize) - lpDestination);

        if (TempCount > 0) {
            MoveMemory(lpDestination, (LPBYTE) lpValueRecord +
                CurrentValueRecordLength, TempCount);
        }

    }

    //
    //  No value exists with this name.  Place a new VALUE_RECORD at the end of
    //  the KEY_RECORD.
    //

    else if (ErrorCode == ERROR_CANTREAD16_FILENOTFOUND32) {

        //  Handle Win95 registries that don't have a key record for the root
        //  key.  We don't check if this is really the root key, but it doesn't
        //  matter much.
        if (IsNullBlockIndex(hKey-> BlockIndex)) {

            if (RgLockInUseKeynode(hKey-> lpFileInfo, hKey-> KeynodeIndex,
                &lpKeynode) != ERROR_SUCCESS)
                goto LockKeynodeFailed;

            if (RgAllocKeyRecord(hKey-> lpFileInfo, sizeof(KEY_RECORD) +
                NewValueRecordLength, &lpKeyRecord) != ERROR_SUCCESS) {
                RgUnlockKeynode(hKey-> lpFileInfo, hKey-> KeynodeIndex, FALSE);
LockKeynodeFailed:
                TRAP();
                return ERROR_CANTOPEN;          //  Win95 compatibility
            }

            lpKeyRecord-> RecordSize = sizeof(KEY_RECORD);
            lpKeyRecord-> NameLength = 1;       //  Win95 compatibility
            lpKeyRecord-> Name[0] = '\0';       //  Win95 compatibility
            lpKeyRecord-> ValueCount = 0;
            lpKeyRecord-> ClassLength = 0;
            lpKeyRecord-> Reserved = 0;

            lpKeynode-> BlockIndex = lpKeyRecord-> BlockIndex;
            lpKeynode-> KeyRecordIndex = lpKeyRecord-> KeyRecordIndex;

            hKey-> BlockIndex = (WORD) lpKeynode-> BlockIndex;
            hKey-> KeyRecordIndex = (BYTE) lpKeynode-> KeyRecordIndex;

            RgUnlockKeynode(hKey-> lpFileInfo, hKey-> KeynodeIndex, TRUE);

            ErrorCode = ERROR_SUCCESS;
            goto AddValueRecord;

        }

        if ((ErrorCode = RgLockKeyRecord(hKey-> lpFileInfo, hKey-> BlockIndex,
            hKey-> KeyRecordIndex, &lpKeyRecord)) == ERROR_SUCCESS) {

            if (NewValueRecordLength > SmallDword(lpKeyRecord-> AllocatedSize) -
                SmallDword(lpKeyRecord-> RecordSize)) {

                if ((ErrorCode = RgReAllocKeyRecord(hKey, lpKeyRecord->
                    RecordSize + NewValueRecordLength, &lpKeyRecord)) !=
                    ERROR_SUCCESS) {
                    RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BlockIndex,
                        FALSE);
                    return ErrorCode;
                }

            }

AddValueRecord:
            lpValueRecord = (LPVALUE_RECORD) ((LPBYTE) lpKeyRecord +
                SmallDword(lpKeyRecord-> RecordSize));
            lpKeyRecord-> RecordSize += NewValueRecordLength;
            lpKeyRecord-> ValueCount++;

        }

    }

    //
    //  If we're successful at this point, then lpValueRecord is valid and we
    //  should copy the data into this record.
    //

    if (ErrorCode == ERROR_SUCCESS) {

        lpValueRecord-> DataType = Type;

        lpValueRecord-> NameLength = (WORD) ValueNameLength;
        MoveMemory(lpValueRecord-> Name, lpValueName, ValueNameLength);

        lpValueRecord-> DataLength = (WORD) cbData;
        MoveMemory((LPBYTE) lpValueRecord-> Name + ValueNameLength, lpData,
            cbData);

        RgUnlockDatablock(hKey-> lpFileInfo, hKey-> BlockIndex, TRUE);

    }

    return ErrorCode;

}

//
//  VMMRegSetValueEx
//
//  See Win32 documentation of RegSetValueEx.
//

LONG
REGAPI
VMMRegSetValueEx(
    HKEY hKey,
    LPCSTR lpValueName,
    DWORD Reserved,
    DWORD Type,
    LPBYTE lpData,
    DWORD cbData
    )
{

    int ErrorCode;

    if (IsBadOptionalStringPtr(lpValueName, (UINT) -1))
        return ERROR_INVALID_PARAMETER;

    //
    //  Windows 95 compatibility problem.  If the type is REG_SZ,
    //  then override cbData with the length of the string pointed to by lpData.
    //  This should have only been done in RegSetValue, but we're stuck with it
    //  now...
    //

    if (Type == REG_SZ) {
        if (IsBadStringPtr(lpData, (UINT) -1))
            return ERROR_INVALID_PARAMETER;
        cbData = StrLen(lpData);
    }
    else {
        if (cbData > 0 && IsBadHugeReadPtr(lpData, cbData))
            return ERROR_INVALID_PARAMETER;
    }

    if (cbData > MAXIMUM_DATA_LENGTH)
        return ERROR_INVALID_PARAMETER;

    if (!RgLockRegistry())
        return ERROR_LOCK_FAILED;

    if ((ErrorCode = RgValidateAndConvertKeyHandle(&hKey)) == ERROR_SUCCESS) {
        if ((hKey-> PredefinedKeyIndex == INDEX_DYN_DATA) || (hKey->
            lpFileInfo-> Flags & FI_READONLY))
            ErrorCode = ERROR_ACCESS_DENIED;
        else {
            if ((ErrorCode = RgSetValue(hKey, lpValueName, Type, lpData,
                (UINT) cbData)) == ERROR_SUCCESS) {
                RgSignalWaitingNotifies(hKey-> lpFileInfo, hKey-> KeynodeIndex,
                    REG_NOTIFY_CHANGE_LAST_SET);
            }
        }
    }

    RgUnlockRegistry();

    return ErrorCode;

    UNREFERENCED_PARAMETER(Reserved);

}

//
//  VMMRegSetValue
//
//  See Win32 documentation of RegSetValue.
//

LONG
REGAPI
VMMRegSetValue(
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD Type,
    LPBYTE lpData,
    DWORD cbData
    )
{

    LONG ErrorCode;
    HKEY hSubKey;

    if ((ErrorCode = RgCreateOrOpenKey(hKey, lpSubKey, &hSubKey, LK_CREATE)) ==
        ERROR_SUCCESS) {
        ErrorCode = VMMRegSetValueEx(hSubKey, NULL, 0, REG_SZ, lpData, 0);
        VMMRegCloseKey(hSubKey);
    }

    return ErrorCode;

    UNREFERENCED_PARAMETER(Type);
    UNREFERENCED_PARAMETER(cbData);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmtests\pageit.c ===
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>

#define ONE_MB              (1024*1024)
#define TWO_MB              (2*ONE_MB)
#define PAGE_SIZE           (4096)
#define PAGESPERTWO_MB      (TWO_MB/PAGE_SIZE)
#define TWO_MBREGIONS       (8)

#define NEW_CELL(id,i)    ( (id)<<20 | ((i)&0x000fffff) )

CRITICAL_SECTION ErrorCrit;
PUCHAR RegionBase;


DWORD
SelectPage(
    void
    )
{
    DWORD PageNum;

    PageNum = GetTickCount();
    PageNum = PageNum >> 3;
    PageNum = PageNum & (PAGESPERTWO_MB-1);

    return PageNum;
}

void
CellError(
    DWORD TwoMegRegion,
    DWORD *Address,
    DWORD ThreadId,
    DWORD OriginalCell,
    DWORD CurrentCell,
    DWORD Iteration
    )
{
    EnterCriticalSection(&ErrorCrit);
    printf("PAGEIT: Cell Error at %x %p %02lx %08x vs %08x (iter %d)\n",
        TwoMegRegion,
        Address,
        ThreadId,
        OriginalCell,
        CurrentCell,
        Iteration
        );
    DebugBreak();
    LeaveCriticalSection(&ErrorCrit);
}

void
PrintHeartBeat(
    DWORD Id,
    DWORD Counter
    )
{
    EnterCriticalSection(&ErrorCrit);
    printf("PAGEIT: HeartBeat Id %3d iter %8d\n",
        Id,
        Counter
        );
    LeaveCriticalSection(&ErrorCrit);
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif

DWORD
ThreadRoutine(
    PVOID Unused
    )

{
    DWORD Id;
    DWORD Counter;
    DWORD PageNumber;
    DWORD CellOffset;
    DWORD *CellAddress;
    DWORD OriginalCell;
    DWORD NewCell;
    DWORD i;

    SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_LOWEST);
    Id = GetCurrentThreadId();
    Counter = 0;

    for(;;) {
        PageNumber = SelectPage();
        CellOffset = PageNumber*PAGE_SIZE + Id*sizeof(DWORD);
        CellAddress = (DWORD *)(RegionBase + CellOffset);
        OriginalCell = *CellAddress;
        NewCell = NEW_CELL(Id,Counter);
        for(i=0;i<TWO_MBREGIONS;i++) {
            CellAddress = (DWORD *)(RegionBase + i*TWO_MB + CellOffset);
            if ( OriginalCell != *CellAddress ) {
                CellError(i,CellAddress,Id,OriginalCell,*CellAddress,Counter);
            }

            *CellAddress = NewCell;
        }

        Counter++;
        if ( (Counter/50) * 50 == Counter ) {
            Sleep(500);
        }

        if ( (Counter/1024) * 1024 == Counter ) {
            PrintHeartBeat(Id,Counter);
        }
    }

    return 0;
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif

DWORD
_cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    DWORD i;
    DWORD Id;
    HANDLE Thread;

    InitializeCriticalSection(&ErrorCrit);

    RegionBase = VirtualAlloc(NULL,TWO_MBREGIONS*TWO_MB,MEM_COMMIT,PAGE_READWRITE);

    if ( !RegionBase ) {
        printf("PAGEIT: VirtualAlloc Failed %d\n",GetLastError());
        ExitProcess(1);
        }
    for (i=0;i<(TWO_MBREGIONS-1);i++){
        Thread = CreateThread(NULL,0,ThreadRoutine,NULL,0,&Id);
        if ( Thread ) {
            CloseHandle(Thread);
            }
        }
    ThreadRoutine(NULL);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmtests\poolkill.c ===
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#define DbgPrint printf
#define NtTerminateProcess(a,b) ExitProcess((ULONG)(b))

__cdecl
main(
    )

{

    LONG i, j;
    PULONG p4, p3, p2, p1, oldp1;
    SIZE_T Size1;
    NTSTATUS status;
    HANDLE CurrentProcessHandle;
    HANDLE GiantSection;
    MEMORY_BASIC_INFORMATION MemInfo;
    ULONG OldProtect;
    STRING Name3;
    HANDLE Section1;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG ViewSize;
    ULONG NumberOfAllocs = 0;
    TIME DelayTime = {-15 * 1000 * 1000 * 10, -1};
    OBJECT_ATTRIBUTES Object1Attributes;
    LARGE_INTEGER SectionSize;
    BOOL PrintedOnce = FALSE;

    CurrentProcessHandle = NtCurrentProcess();

    for(i = 0; i < 3; i += 1){
        DbgPrint("Hello World...\n\n");
    }

    DbgPrint("allocating virtual memory\n");

    for (;;) {
        p1 = NULL;
        Size1 = 800;

        status = NtAllocateVirtualMemory(CurrentProcessHandle,
                                         (PVOID *)&p1,
                                         0,
                                         &Size1,
                                         MEM_RESERVE,
                                         PAGE_READWRITE);

        if (!NT_SUCCESS(status)) {
            break;
        }

        if ((PrintedOnce == FALSE) &&
            ((ULONG_PTR)p1 >= 0x80000000)) {
            printf("allocate high %p\n", p1);
            PrintedOnce = TRUE;
        }

        NumberOfAllocs += 1;
    }

    DbgPrint("allocVM failed after %ld allocs of 800 bytes\n", NumberOfAllocs);
    DbgPrint("created vm status %X start %p size %d\n",
             status,
             p1,
             Size1);

    for (i = 0; i < 4; i += 1) {
        p1 = NULL;
        Size1 = 800;

        status = NtAllocateVirtualMemory(CurrentProcessHandle,
                                         (PVOID *)&p1,
                                         0,
                                         &Size1,
                                         MEM_RESERVE,
                                         PAGE_READWRITE);

        DbgPrint("created vm status %X start %p size %d\n",
                 status,
                 p1,
                 Size1);
    }

    DbgPrint("delaying for 15 seconds\n");
    NtDelayExecution(FALSE, &DelayTime);
    DbgPrint ("end of delay\n");
    DbgPrint ("paged pool allocations\n");
    NumberOfAllocs = 0;
    for (;;) {

        //
        // Create a giant section (100mb)
        //

        InitializeObjectAttributes(&Object1Attributes,
                                   NULL,
                                   0,
                                   NULL,
                                   NULL);

        SectionSize.QuadPart = (100 * 1024 * 1024);
        status = NtCreateSection(&GiantSection,
                                 SECTION_MAP_READ | SECTION_MAP_WRITE,
                                 &Object1Attributes,
                                 &SectionSize,
                                 PAGE_READWRITE,
                                 SEC_RESERVE,
                                 NULL);

        if (!NT_SUCCESS(status)) {
            break;
        }

        NumberOfAllocs += 1;
    }

    DbgPrint("Create section failed after %ld creates of 2GB\n", NumberOfAllocs);
    DbgPrint("create section status %X\n", status);
    DbgPrint("delaying for 15 seconds\n");
    NtDelayExecution(FALSE, &DelayTime);
    DbgPrint("end of delay\n");
    DbgPrint("that's all\n");
    NtTerminateProcess(NtCurrentProcess(), STATUS_SUCCESS);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmtests\tfork.c ===
#include <nt.h>
#include <ntrtl.h>
#include <stdio.h>

ULONG ProcessNumber = 1;
#define DbgPrint printf

ULONG
fork ();

__cdecl
main(
    )

{

    LONG i, j;
    PULONG p4, p3, p2, p1, Ro3, Noaccess;
    SIZE_T Size1, Size2, Size3, SizeRo3, SizeNoaccess;
    NTSTATUS status;
    HANDLE CurrentProcessHandle;
    ULONG id = 0;
    ULONG OldProtect;

    CurrentProcessHandle = NtCurrentProcess();

    for(i=0;i<3;i++){
        DbgPrint("Hello World...\n\n");
    }

    DbgPrint("allocating virtual memory\n");

    p1 = (PULONG)NULL;
    Size1 = 30 * 4096;

    status = NtAllocateVirtualMemory (CurrentProcessHandle, (PVOID *)&p1,
                        0, &Size1, MEM_COMMIT, PAGE_READWRITE);

    DbgPrint("created vm1 status %X start %p size %lx\n",
            status, p1, Size1);

    p2 = (PULONG)NULL;
    Size2 = 16 * 4096;

    status = NtAllocateVirtualMemory (CurrentProcessHandle, (PVOID *)&p2,
                        0, &Size2, MEM_COMMIT, PAGE_READWRITE);

    DbgPrint("created vm2 status %X start %p size %lx\n",
            status, p2, Size2);


    id = fork () + id;

    DbgPrint("fork complete id %lx\n",id);

    p3 = p1 + 8 * 1024;
    Size3 = 16 * 4096;

    DbgPrint("deleting va from %p for %lx bytes\n",p3, Size3);

    status = NtFreeVirtualMemory (CurrentProcessHandle,(PVOID *)&p3, &Size3,
                                  MEM_RELEASE);

    DbgPrint("free vm status %X start %p size %lx\n",
            status, p3, Size3);

    p3 = (PULONG)NULL;
    Size3 = 50 * 4096;

    DbgPrint("allocating 50 pages of vm\n");

    status = NtAllocateVirtualMemory (CurrentProcessHandle, (PVOID *)&p3,
                        0, &Size3, MEM_COMMIT, PAGE_READWRITE);

    DbgPrint("created vm3 status %X start %p size %lx\n",
            status, p3, Size3);

    Ro3 = (PULONG)NULL;
    SizeRo3 = 393933;

    status = NtAllocateVirtualMemory (CurrentProcessHandle, (PVOID *)&Ro3,
                        0, &SizeRo3, MEM_COMMIT, PAGE_READONLY);


    DbgPrint("created vm4 status %X start %p size %lx\n",
            status, Ro3, SizeRo3);

    *p3 = *Ro3;

    p1 = p3;

    p2 = ((PULONG)((PUCHAR)p3 + Size3));
    p4 = p1;
    j = 0;

    while (p3 < p2) {
        j += 1;

        if (j % 8 == 0) {
            if (*p4 != (ULONG)((ULONG_PTR)p4)) {
                DbgPrint("bad value in cell %p value is %lx\n",p4, *p4);

            }
            p4 += 1;
            *p4 = (ULONG)((ULONG_PTR)p4);
            p4 = p4 + 1026;
        }

        *p3 = (ULONG)((ULONG_PTR)p3);
        p3 += 1027;

    }

    p3 = p1;

    //
    // Protect page as no access.
    //

    Noaccess = NULL;
    SizeNoaccess = 200*4096;

    status = NtAllocateVirtualMemory (CurrentProcessHandle, (PVOID *)&Noaccess,
                        0, &SizeNoaccess, MEM_COMMIT, PAGE_READWRITE);


    DbgPrint("created vm5 status %X start %p size %lx\n",
            status, Ro3, SizeRo3);

    //
    // Touch all the pages.
    //

    RtlZeroMemory(Noaccess, SizeNoaccess);

    *Noaccess = 91;
    Size1 = 30 * 4097;

    status = NtProtectVirtualMemory (CurrentProcessHandle, (PVOID *)&Noaccess,
                        &Size1, PAGE_NOACCESS,
                        &OldProtect);

    DbgPrint("protected VM1 status %X, base %p, size %lx, old protect %lx\n",
                    status, p1, Size1, OldProtect);


    DbgPrint("forking a second time\n");

    id = fork () + id;
    DbgPrint("fork2 complete id %lx\n",id);

    DbgPrint("changing page protection\n");

    Size1 = 9000;

    OldProtect = *p3;

    status = NtProtectVirtualMemory (CurrentProcessHandle, (PVOID *)&p3,
                        &Size1, PAGE_EXECUTE_READWRITE | PAGE_NOCACHE,
                        &OldProtect);

    DbgPrint("protected VM2 status %X, base %p, size %lx, old protect %lx\n",
                    status, p1, Size1, OldProtect);


    status = NtProtectVirtualMemory (CurrentProcessHandle, (PVOID *)&Ro3,
                        &Size1, PAGE_READONLY | PAGE_NOCACHE, &OldProtect);

    DbgPrint("protected VM3 status %X, base %p, size %lx, old protect %lx\n",
                    status, Ro3, Size1, OldProtect);
    p1 += 1;

    while (p3 < p2) {

        *p1 = (ULONG)((ULONG_PTR)p1);

        if (*p3 != (ULONG)((ULONG_PTR)p3)) {
            DbgPrint("bad value in cell %p value is %lx\n",p3, *p3);
        }
        p3 += 1027;
        p1 += 1027;

    }

    DbgPrint("trying noaccess test\n");

    try {
        if (*Noaccess != 91) {
            DbgPrint("*************** FAILED NOACCESS TEST 1 *************\n");

        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        if (GetExceptionCode() != STATUS_ACCESS_VIOLATION) {
            DbgPrint("*************** FAILED NOACCESS TEST 2 *************\n");
        }
    }

    //
    // Make no access page accessable.
    //

    status = NtProtectVirtualMemory (CurrentProcessHandle, (PVOID *)&Noaccess,
                        &Size1, PAGE_READWRITE,
                        &OldProtect);

    if (*Noaccess != 91) {
        DbgPrint("*************** FAILED NOACCESS TEST 3 *************\n");
    }

    DbgPrint("that's all process %lx\n", id);
    NtTerminateProcess(NtCurrentProcess(),STATUS_SUCCESS);
    return 0;
}

ULONG
fork ()

{
    LONG i;
    PULONG Foo;
    NTSTATUS status;
    HANDLE CurrentProcessHandle;
    HANDLE ProcessHandle;
    CONTEXT ThreadContext;
    CLIENT_ID Cid1;
    HANDLE Thread1;
    LARGE_INTEGER DelayTime;
    PINITIAL_TEB Teb;
    
    CurrentProcessHandle = NtCurrentProcess();
    DbgPrint("creating new process\n");

    status = NtCreateProcess(
             &ProcessHandle,
             PROCESS_ALL_ACCESS, //DesiredAccess,
             NULL, //ObjectAttributes,
             CurrentProcessHandle, //ParentProcess
             TRUE, //InheritObjectTable,
             NULL, //SectionHandle
             NULL, //DebugPort OPTIONAL,
             NULL  //ExceptionPort OPTIONAL
             );

    DbgPrint("status from create process %lx\n",status);

    if (!NT_SUCCESS(status)) {
        return 0;
    }
    ThreadContext.ContextFlags = CONTEXT_FULL;

    status = NtGetContextThread (NtCurrentThread(), &ThreadContext);

    DbgPrint("status from get context %lx\n",status);

    if (status == 0) {

#ifdef i386
        ThreadContext.Eax = 0x7777;
        ThreadContext.Esp -= 0x18;
        Foo = (PULONG)ThreadContext.Esp;
        DbgPrint("stack value is %lx\n",*Foo);
#endif

        Teb= (PINITIAL_TEB) NtCurrentTeb ();

        status = NtCreateThread(
                &Thread1,
                THREAD_ALL_ACCESS,
                NULL,
                ProcessHandle,
                &Cid1,
                &ThreadContext,
                Teb,
                FALSE
                );

//        DelayTime.HighPart = -1;
//        DelayTime.LowPart = 0;
//        NtDelayExecution (FALSE, &DelayTime);

        return 0;
    } else {

        ProcessNumber += ProcessNumber;
        return ProcessNumber;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmtests\vmperf32.c ===
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <windows.h>

#define SEG_1_SIZE 1024 * 1024
#define SEG_X_SIZE 1024 * 1024 * 64

#define W32_MEMMAN_ITERATIONS       150
#define W32_MEMMAN_ITERATIONS2    20000
#define W32_MMST04_ITERATIONS       100
#define MemManSubtest5Count         200

int TotalBenchMarks = 0;
#define MAX_BENCHMARKS 32
char *BenchMarkNames[ MAX_BENCHMARKS ];
ULONG BenchMarkRates[ MAX_BENCHMARKS ];
ULONG BenchMarkFracs[ MAX_BENCHMARKS ];

typedef struct _PERFINFO {
    DWORD StartTime;
    DWORD StopTime;
    PCHAR Title;
    ULONG Iterations;
} PERFINFO, *PPERFINFO;

int
StartBenchMark(
    PCHAR Title,
    ULONG Iterations,
    PPERFINFO PerfInfo
    );

VOID
FinishBenchMark(
    PPERFINFO PerfInfo
    );

__cdecl
main(
    )

{

    PULONG_PTR p1, p2, p3, p4; // pointers into new segment
    PCHAR pa[MemManSubtest5Count]; // array for section pointers
    PULONG_PTR u1;
    ULONG actual;         // actual xfer count for read
    ULONG ssize;          // section allocation size var
    ULONG ii, ix;         // loop index variables
    PERFINFO PerfInfo;
    ULONG Seg1Size;
    ULONG SegxSize;
    ULONG CommitSize;
    HANDLE CurrentProcessHandle, Section1;
    LARGE_INTEGER SectionSize;
    ULONG Size;
    ULONG ViewSize;

    printf("Win32 Memory Management test\n");
    Size = 1024 * 1024;
    p1 = NULL;
    p1 = VirtualAlloc(NULL, Size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    if (p1 == NULL) {
        printf("failed first created vm status %X start %p size %lx\n",
               GetLastError(),
               p1,
               Size);
    }

    for (p2 = p1; p2 < (p1 + (Size / sizeof(ULONG_PTR))); p2 += 1) {
        *p2 = (ULONG_PTR)p2;
    }

    SectionSize.QuadPart = 1024 * 1024;
    Section1 = CreateFileMapping(INVALID_HANDLE_VALUE,
                                 NULL,
                                 PAGE_READWRITE | SEC_COMMIT,
                                 SectionSize.HighPart,
                                 SectionSize.LowPart,
                                 NULL);

    if (!Section1) {
        printf("failed create big section status %ld\n", GetLastError());
    }

    p3 = NULL;
    ViewSize = 0;
    p3 = MapViewOfFile(Section1, FILE_MAP_WRITE, 0, 0, 0);
    if (p3 == NULL) {
        printf("service failed mapview - status %X\n", GetLastError());
    }

//
//  Memory Management sub-test 1
//
//      Create a 1 MB segment with commitment of the pages,
//      then touch each page, which should cause a fault and
//      a demand zero page to be allocated.
//
//

    StartBenchMark("Win32 MemMan0 - 1 Meg Copy", 150, &PerfInfo);
    for (ii = 0; ii < 150; ii += 1) {
        MoveMemory (p3, p1, Size);
    }

    FinishBenchMark(&PerfInfo);
    CloseHandle(Section1);
    if (!UnmapViewOfFile(p3)) {
        printf("unmap view service failed - status %X\n", GetLastError());
    }

//
//  Memory Management sub-test 1
//
//      Create a 1 MB segment with commitment of the pages,
//      then touch each page, which should cause a fault and
//      a demand zero page to be allocated.
//
//

    StartBenchMark("Win32 MemMan01 - create 1mb section, copy 1mb, delete",
                   150,
                   &PerfInfo);

    for (ii = 0; ii < 150; ii += 1) {
        Section1 = CreateFileMapping(INVALID_HANDLE_VALUE,
                                     NULL,
                                     PAGE_READWRITE | SEC_COMMIT,
                                     SectionSize.HighPart,
                                     SectionSize.LowPart,
                                     NULL);

        if (!Section1) {
            printf("failed create big section status %X\n", GetLastError());
        }

        p3 = MapViewOfFile(Section1, FILE_MAP_WRITE, 0, 0, 0);
        if (p3 == NULL) {
            printf("service failed mapview - status %X\n", GetLastError());
        }

        MoveMemory(p3, p1, Size);
        p4 = MapViewOfFile(Section1, FILE_MAP_WRITE, 0, 0, 0);
        if (p4 == NULL) {
            printf("service failed mapview - status %X\n", GetLastError());
        }

        CloseHandle(Section1);
        if (!UnmapViewOfFile(p3)) {
            printf("unmap view service failed - status %X\n", GetLastError());
        }

        if (!UnmapViewOfFile(p4)) {
            printf("unmap view service failed - status %X\n", GetLastError());
        }
    }

    FinishBenchMark(&PerfInfo);

//
//  Memory Management sub-test 1
//
//      Create a 1 MB segment with commitment of the pages,
//      then touch each page, which should cause a fault and
//      a demand zero page to be allocated.
//
//

    StartBenchMark("Win32 MemMan02 - alloc 1mb vm, copy 1mb, delete",
                   150,
                   &PerfInfo);

    for (ii = 0; ii < 150; ii++) {
        Size = 1024 * 1024;
        p3 = VirtualAlloc(NULL, Size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
        if (p3 == NULL) {
            printf("service failed allocvm - status %ld\n", GetLastError());
        }

        MoveMemory (p3, p1, Size);
        if (!VirtualFree(p3, 0, MEM_RELEASE)) {
            printf("service failed freevm1 - status %X\n", GetLastError());
        }
    }

    FinishBenchMark(&PerfInfo);

    if (!VirtualFree (p1, 0, MEM_RELEASE)) {
        printf("service failed freevm2 - status %X\n", GetLastError());
    }

//
//  Memory Management sub-test 1
//
//      Create a 1 MB segment with commitment of the pages,
//      then touch each page, which should cause a fault and
//      a demand zero page to be allocated.
//
//

    StartBenchMark("Win32 MemMan1 - 1 Meg Seg, Create, Commit & Touch",
                   W32_MEMMAN_ITERATIONS,
                   &PerfInfo);

    for (ii = 0; ii < W32_MEMMAN_ITERATIONS; ii += 1) {
        Seg1Size = SEG_1_SIZE;
        p1 = VirtualAlloc(NULL, Seg1Size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
        if (p1 == NULL) {
            printf("service failed - status %X\n", GetLastError());
        }

        for (p2 = p1; p2 < (p1 + (Seg1Size / sizeof(ULONG_PTR))); p2 += 4096 /sizeof(ULONG_PTR)) {
            *p2 = 99;
        }

        if (!VirtualFree(p1, 0, MEM_RELEASE)) {
            printf("service failed freevm3 - status %X\n", GetLastError());
        }
    }

    FinishBenchMark(&PerfInfo);

//
//  Memory Management sub-test 1
//
//      Create a 1 MB segment with commitment of the pages,
//      then touch each page, which should cause a fault and
//      a demand zero page to be allocated.
//
//

    StartBenchMark("Win32 MemMan1.5 - 1 Meg Seg, Create, reserve Commit & Touch",
                   W32_MEMMAN_ITERATIONS,
                   &PerfInfo);

    for (ii = 0; ii < W32_MEMMAN_ITERATIONS; ii += 1) {
        Seg1Size = SEG_1_SIZE;
        p1 = VirtualAlloc(NULL, Seg1Size, MEM_RESERVE | MEM_COMMIT, PAGE_READONLY);
        if (p1 == NULL) {
            printf("service failed - status %X\n", GetLastError());
        }

        if (!VirtualProtect(p1, Seg1Size, PAGE_READWRITE, &CommitSize)) {
            printf("service failed (ntprotect)- status %X\n", GetLastError());
        }

        for (p2 = p1; p2 < (p1 + (Seg1Size / sizeof(ULONG_PTR))); p2 += (4096 / sizeof(ULONG_PTR))) {
            *p2 = 99;
        }

        if (!VirtualFree(p1, 0, MEM_RELEASE)) {
            printf("service failed freevm4 - status %X\n", GetLastError());
        }
    }

    FinishBenchMark(&PerfInfo);

//
//  Memory Management sub-test 2
//
//      Create a 1 MB segment with commitment of the pages,
//      but never use the segment.
//

    StartBenchMark("Win32 MemMan2 - 1 Meg Seg, Create & Commit Only",
                   W32_MEMMAN_ITERATIONS2,
                   &PerfInfo);

    for (ii = 0; ii < W32_MEMMAN_ITERATIONS2; ii += 1) {
        p1 = NULL;
        Seg1Size = SEG_1_SIZE;
        p1 = VirtualAlloc(NULL, Seg1Size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
        if (p1 == NULL) {
            printf("service failed - status %X\n", GetLastError());
        }

        if (!VirtualFree(p1, 0, MEM_RELEASE)) {
            printf("service failed freevm5 - status %X\n", GetLastError());
        }
    }

    FinishBenchMark(&PerfInfo);

//
//  Memory Management sub-test 3
//
//      Create a 1 MB segment without commitment of the pages,
//      but never use or commit the segment.
//

    StartBenchMark("Win32 MemMan3 - 1 Meg Seg Create Only",
                   W32_MEMMAN_ITERATIONS2,
                   &PerfInfo);

    for (ii = 0; ii < W32_MEMMAN_ITERATIONS2; ii += 1) {
        p1 = NULL;
        Seg1Size = SEG_1_SIZE;
        p1 = VirtualAlloc(NULL, Seg1Size, MEM_RESERVE, PAGE_READWRITE);
        if (p1 == NULL) {
            printf("service failed - status %X\n", GetLastError());
        }

        if (!VirtualFree(p1, 0, MEM_RELEASE)) {
            printf("service failed freevm6 - status %X\n", GetLastError());
        }
    }

    FinishBenchMark(&PerfInfo);

//
//  Memory Management sub-test 4
//
//      Create a 64 MB segment without committing the pages,
//      then commit and touch at 128 KB intervals.
//
//

    StartBenchMark("Win32 MemMan4 - 64 Meg Seg, Commit Sparse",
                   W32_MMST04_ITERATIONS,
                   &PerfInfo);

    for (ii = 0; ii < W32_MMST04_ITERATIONS; ii += 1) {
        p1 = NULL;
        SegxSize = SEG_X_SIZE;
        p1 = VirtualAlloc(NULL, SegxSize, MEM_RESERVE, PAGE_READWRITE);
        if (p1 == NULL) {
            printf("service failed - status %X\n", GetLastError());
        }

        CommitSize = 4;
        for (p2 = p1; p2 < (p1 + (SegxSize / sizeof(ULONG_PTR))); p2 += (256 * 1024 / sizeof(ULONG_PTR))) {
            p2 = VirtualAlloc(p2, CommitSize, MEM_COMMIT, PAGE_READWRITE);
            if (p2 == NULL) {
                printf("service failed - status %X\n", GetLastError());
            }

            if (*p2 != 0) {
                printf("%p = %lx\n", p2, *p2);
            }
        }

        if (!VirtualFree(p1, 0, MEM_RELEASE)) {
            printf("service failed freevm7 - status %X\n", GetLastError());
        }
    }

    FinishBenchMark(&PerfInfo);

//
//  Memory Management sub-test 5
//
//      Create a alternatively 232k and 112 k memory sections.
//      For every 2 created, delete 1.  Do this for MemManSubtest5Count times.
//
//

    StartBenchMark("Win32 MemMan5 - Sparse Section Create/Delete Benchmark",
                   W32_MEMMAN_ITERATIONS,
                   &PerfInfo);

    for (ii = 0; ii < W32_MEMMAN_ITERATIONS; ii += 1) {
        for (ix = 0; ix < MemManSubtest5Count; ix += 1) {

            //
            // determine if even or odd allocation, if even and not 0,
            // delete a section
            //

            ssize = (112 * 1024);       //assume ODD allocation
            if ((ix & 1) == 0) {        //if it is an even one
                ssize = (232 * 1024);   //allocate 232 K on even passes
                if (ix) {                //except on pass 0
                    if (!VirtualFree(pa[ix/2], 0, MEM_RELEASE)) {
                        printf("service failed freevm8 - status %X\n", GetLastError());
                    }

                    pa[ix / 2] = 0;     //remember this one is gone
                }
            }

            pa[ix] = VirtualAlloc(NULL, ssize, MEM_RESERVE, PAGE_READWRITE);
            if (pa[ix] == NULL) {
                printf("service failed - status %X\n", GetLastError());
            }
        }

        //
        // Now free up the memory used in this test
        //

        for (ix = 0; ix < MemManSubtest5Count; ix += 1) {
            if (pa[ix] != 0) {
                if (!VirtualFree(pa[ix], 0, MEM_RELEASE)) {
                    printf("service failed freevm9 - status %X\n", GetLastError());
                }
            }
        }
    }

    FinishBenchMark(&PerfInfo);
    printf("that's all\n");
    return (TRUE);
}
int
StartBenchMark(
    PCHAR Title,
    ULONG Iterations,
    PPERFINFO PerfInfo
    )

{

    printf("*** Start %s\n",
           PerfInfo->Title = Title,
           PerfInfo->Iterations = Iterations);

    PerfInfo->StartTime = GetCurrentTime();
    return TRUE;
}

VOID
FinishBenchMark(
    PPERFINFO PerfInfo
    )

{

    ULONG TotalMilliSeconds;
    ULONG IterationsPerSecond;
    ULONG IterationFractions;
    DWORD Delta;

    PerfInfo->StopTime = GetCurrentTime();
    TotalMilliSeconds = PerfInfo->StopTime - PerfInfo->StartTime;
    IterationsPerSecond = (1000 * PerfInfo->Iterations) / TotalMilliSeconds;
    IterationFractions  = (1000 * PerfInfo->Iterations) % TotalMilliSeconds;
    IterationFractions  = (1000 * IterationFractions) / TotalMilliSeconds;
    if (1) {
        printf("        iterations     - %9d\n", PerfInfo->Iterations );
        printf("        milliseconds   - %9d\n", TotalMilliSeconds );
        printf("        iterations/sec - %5d.%3d\n\n",
               IterationsPerSecond,
               IterationFractions);
    }

    BenchMarkNames[TotalBenchMarks] = PerfInfo->Title;
    BenchMarkRates[TotalBenchMarks] = IterationsPerSecond;
    BenchMarkFracs[TotalBenchMarks] = IterationFractions;
    TotalBenchMarks++;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmtests\vmperf.c ===
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#define DbgPrint printf

#define SEG_1_SIZE 1024 * 1024
#define SEG_X_SIZE 1024 * 1024 * 64

#define VM_MEMMAN_ITERATIONS       150
#define VM_MEMMAN_ITERATIONS2     2000
#define MemManSubtest5Count         200

int TotalBenchMarks = 0;
#define MAX_BENCHMARKS 32
char *BenchMarkNames[ MAX_BENCHMARKS ];
ULONG BenchMarkRates[ MAX_BENCHMARKS ];
ULONG BenchMarkFracs[ MAX_BENCHMARKS ];

typedef struct _PERFINFO {
    LARGE_INTEGER StartTime;
    LARGE_INTEGER StopTime;
    PCHAR Title;
    ULONG Iterations;
} PERFINFO, *PPERFINFO;

int
StartBenchMark(
    PCHAR Title,
    ULONG Iterations,
    PPERFINFO PerfInfo
    );

VOID
FinishBenchMark(
    PPERFINFO PerfInfo
    );

__cdecl main()
{
    PCHAR   p1, p2, p3, p4;         // pointers into new segment
    PCHAR   pa[MemManSubtest5Count]; // array for section pointers
    PULONG  u1;
    ULONG   actual;         // actual xfer count for read
    ULONG   ssize;          // section allocation size var
    ULONG   ii, ix;         // loop index variables
    PERFINFO PerfInfo;
    ULONG Seg1Size;
    ULONG SegxSize;
    ULONG CommitSize;
    NTSTATUS status;
    HANDLE CurrentProcessHandle, Section1;
    LARGE_INTEGER SectionSize;
    ULONG Size;
    ULONG ViewSize;

    DbgPrint("NT Memory Management test\n");

    CurrentProcessHandle = NtCurrentProcess();

    Size = 1024L * 1024L;
    p1 = NULL;

    status = NtAllocateVirtualMemory (CurrentProcessHandle,
                                      (PVOID *)&p1,
                                       0,
                                       &Size,
                                       MEM_RESERVE | MEM_COMMIT,
                                       PAGE_READWRITE);

    if (!NT_SUCCESS(status)) {
        DbgPrint("service failed allocvm - status %X\n", status);
    }

    for (p2=p1; p2 < (p1 + Size); p2 += 4) {
            u1 = (PULONG)p2;
            *u1 = (ULONG)p2;
    }  // for

    SectionSize.LowPart = 1024*1024;
    SectionSize.HighPart = 0;
    status = NtCreateSection (&Section1,
                              SECTION_MAP_READ | SECTION_MAP_WRITE,
                              NULL,
                              &SectionSize,
                              PAGE_READWRITE,
                              SEC_COMMIT,
                              NULL);

    if (!NT_SUCCESS(status)) {
        DbgPrint("service failed create sect - status %X\n", status);
    }

    p3 = NULL;
    ViewSize = 0;
    status = NtMapViewOfSection (Section1,
                                 CurrentProcessHandle,
                                 (PVOID *)&p3,
                                 0L,
                                 0,
                                 NULL,
                                 &ViewSize,
                                 ViewUnmap,
                                 0,
                                 PAGE_READWRITE );

    if (!NT_SUCCESS(status)) {
        DbgPrint("service failed mapview - status %X\n", status);
    }

    RtlMoveMemory ((PVOID)p3, (PVOID)p1, Size);

    StartBenchMark( "NT MemMan00 -- 1 Meg Copy",
                    150,
                    &PerfInfo
                  );
//
//  Memory Management sub-test 1 --
//
//      Create a 1 MB segment with commitment of the pages,
//      then touch each page, which should cause a fault and
//      a demand zero page to be allocated.
//
//

    for (ii=0; ii<150; ii++) {

        RtlMoveMemory ((PVOID)p3, (PVOID)p1, Size);
    }


    FinishBenchMark( &PerfInfo );

    status = NtClose (Section1);

    if (!NT_SUCCESS(status)) {
        DbgPrint("service failed close sect - status %X\n", status);
    }

    status = NtUnmapViewOfSection (CurrentProcessHandle,
                                   p3);

    if (!NT_SUCCESS(status)) {
        DbgPrint("service failed - status %X\n", status);
    }

//
//  Memory Management sub-test 1 --
//
//      Create a 1 MB segment with commitment of the pages,
//      then touch each page, which should cause a fault and
//      a demand zero page to be allocated.
//
//
    StartBenchMark( "NT MemMan01 -- create 1mb section, copy 1mb, delete",
                    150,
                    &PerfInfo
                  );

    for (ii=0; ii<150; ii++) {

        status = NtCreateSection (&Section1,
                                  SECTION_MAP_READ | SECTION_MAP_WRITE,
                                  NULL,
                                  &SectionSize,
                                  PAGE_READWRITE,
                                  SEC_COMMIT,
                                  NULL);

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed create sect - status %X\n", status);
        }

        p3 = NULL;
        ViewSize = 0;
        status = NtMapViewOfSection (Section1,
                                     CurrentProcessHandle,
                                     (PVOID *)&p3,
                                     0L,
                                     0,
                                     NULL,
                                     &ViewSize,
                                     ViewUnmap,
                                     0,
                                     PAGE_READWRITE );

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed mapview - status %X\n", status);
        }

        RtlMoveMemory ((PVOID)p3, (PVOID)p1, Size);

        p4 = NULL;
        ViewSize = 0;
        status = NtMapViewOfSection (Section1,
                                     CurrentProcessHandle,
                                     (PVOID *)&p4,
                                     0L,
                                     0,
                                     NULL,
                                     &ViewSize,
                                     ViewUnmap,
                                     0,
                                     PAGE_READWRITE );

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed mapview - status %X\n", status);
        }

        status = NtClose (Section1);

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed close sect - status %X\n", status);
        }

        status = NtUnmapViewOfSection (CurrentProcessHandle,
                                       p3);

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed - status %X\n", status);
        }

        status = NtUnmapViewOfSection (CurrentProcessHandle,
                                       p4);

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed - status %X\n", status);
        }
    }

    FinishBenchMark( &PerfInfo );

//
//  Memory Management sub-test 1 --
//
//      Create a 1 MB segment with commitment of the pages,
//      then touch each page, which should cause a fault and
//      a demand zero page to be allocated.
//
//
    StartBenchMark( "NT MemMan02 -- alloc 1mb vm, copy 1mb, delete",
                    150,
                    &PerfInfo
                  );

    for (ii=0; ii<150; ii++) {

        Size = 1024*1024;
        p3 = NULL;
        status = NtAllocateVirtualMemory (CurrentProcessHandle,
                                          (PVOID *)&p3,
                                           0,
                                           &Size,
                                           MEM_RESERVE | MEM_COMMIT,
                                           PAGE_READWRITE);

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed allocvm - status %X\n", status);
        }

        RtlMoveMemory ((PVOID)p3, (PVOID)p1, Size);

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed close sect - status %X\n", status);
        }

        status = NtFreeVirtualMemory (CurrentProcessHandle,
                                      (PVOID *)&p3,
                                      &Size,
                                      MEM_RELEASE);

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed freevm - status %X\n", status);
        }

    }

    FinishBenchMark( &PerfInfo );

    status = NtFreeVirtualMemory (CurrentProcessHandle,
                                  (PVOID *)&p1,
                                  &Size,
                                  MEM_RELEASE);

    if (!NT_SUCCESS(status)) {
        DbgPrint("service failed freevm - status %X\n", status);
    }

    //
    // start regular benchmarks.
    //

    StartBenchMark( "NT MemMan1 -- 1 Meg Seg, Create, Commit & Touch",
                    VM_MEMMAN_ITERATIONS,
                    &PerfInfo
                  );
//
//  Memory Management sub-test 1 --
//
//      Create a 1 MB segment with commitment of the pages,
//      then touch each page, which should cause a fault and
//      a demand zero page to be allocated.
//
//

    for (ii=0; ii<VM_MEMMAN_ITERATIONS; ii++) {

        p1 = NULL;
        Seg1Size = SEG_1_SIZE;
        status = NtAllocateVirtualMemory (CurrentProcessHandle,
                                          (PVOID *)&p1,
                                          0,
                                          &Seg1Size,
                                          MEM_RESERVE | MEM_COMMIT,
                                          PAGE_READWRITE);

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed - status %lx\n", status);
        }

        for (p2=p1; p2 < (p1 + Seg1Size); p2 += 4096) {
            u1 = (PULONG)p2;
            *u1=99;
//            for (ix=0; ix<1023; ix++) {
//                u1++;
//                if (*u1 != 0) DbgPrint("%lx = %lx\n",u1,*u1);
//            }
        }  // for

        status = NtFreeVirtualMemory (CurrentProcessHandle,
                                      (PVOID *)&p1,
                                      &Seg1Size,
                                      MEM_RELEASE);

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed - status %lx\n", status);
        }
    }

    FinishBenchMark( &PerfInfo );

    StartBenchMark( "NT MemMan1.5 -- 1 Meg Seg, Create, reserve Commit & Touch",
                    VM_MEMMAN_ITERATIONS,
                    &PerfInfo
                  );
//
//  Memory Management sub-test 1 --
//
//      Create a 1 MB segment with commitment of the pages,
//      then touch each page, which should cause a fault and
//      a demand zero page to be allocated.
//
//

    for (ii=0; ii<VM_MEMMAN_ITERATIONS; ii++) {

        p1 = NULL;
        Seg1Size = SEG_1_SIZE;
        status = NtAllocateVirtualMemory (CurrentProcessHandle,
                                          (PVOID *)&p1,
                                          0,
                                          &Seg1Size,
                                          MEM_RESERVE | MEM_COMMIT,
                                          PAGE_READONLY);

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed - status %lx\n", status);
        }

        status = NtProtectVirtualMemory (CurrentProcessHandle,
                                         (PVOID *)&p1,
                                         &Seg1Size,
                                         PAGE_READWRITE,
                                         &CommitSize);

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed (ntprotect)- status %lx\n", status);
            return 0;
        }

        for (p2=p1; p2 < (p1 + Seg1Size); p2 += 4096) {
            u1 = (PULONG)p2;
            *u1=99;
//            for (ix=0; ix<1023; ix++) {
//                u1++;
//                if (*u1 != 0) DbgPrint("%lx = %lx\n",u1,*u1);
//            }
        }  // for

        status = NtFreeVirtualMemory (CurrentProcessHandle,
                                      (PVOID *)&p1,
                                      &Seg1Size,
                                      MEM_RELEASE);

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed - status %lx\n", status);
        }
    }

    FinishBenchMark( &PerfInfo );

    StartBenchMark( "NT MemMan2 -- 1 Meg Seg, Create & Commit Only",
                    VM_MEMMAN_ITERATIONS2,
                    &PerfInfo
                  );
//
//  Memory Management sub-test 2 --
//
//      Create a 1 MB segment with commitment of the pages,
//      but never use the segment.
//

    for (ii=0; ii<VM_MEMMAN_ITERATIONS2; ii++) {

        p1 = NULL;
        Seg1Size = SEG_1_SIZE;
        status = NtAllocateVirtualMemory (CurrentProcessHandle,
                                          (PVOID *)&p1,
                                          0,
                                          &Seg1Size,
                                          MEM_RESERVE | MEM_COMMIT,
                                          PAGE_READWRITE);

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed - status %lx\n", status);
        }

        status = NtFreeVirtualMemory (CurrentProcessHandle,
                                      (PVOID *)&p1,
                                      &Seg1Size,
                                      MEM_RELEASE);

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed - status %lx\n", status);
        }

    }

    FinishBenchMark( &PerfInfo );

    StartBenchMark( "NT MemMan3 -- 1 Meg Seg Create Only",
                    VM_MEMMAN_ITERATIONS2,
                    &PerfInfo
                  );

//
//  Memory Management sub-test 3 --
//
//      Create a 1 MB segment without commitment of the pages,
//      but never use or commit the segment.
//

    for (ii=0; ii<VM_MEMMAN_ITERATIONS2; ii++) {

        p1 = NULL;
        Seg1Size = SEG_1_SIZE;
        status = NtAllocateVirtualMemory (CurrentProcessHandle,
                                          (PVOID *)&p1,
                                          0,
                                          &Seg1Size,
                                          MEM_RESERVE,
                                          PAGE_READWRITE);

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed - status %lx\n", status);
        }

        status = NtFreeVirtualMemory (CurrentProcessHandle,
                                      (PVOID *)&p1,
                                      &Seg1Size,
                                      MEM_RELEASE);

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed - status %lx\n", status);
        }
    }

    FinishBenchMark( &PerfInfo );

//
//  Reduce the number of iterations on this subtest for now.
//      When NT can perform it faster, up the interations again
//
#define VM_MMST04_ITERATIONS 4     //temporarily reduce the iterations


    StartBenchMark( "NT MemMan4 -- 64 Meg Seg, Commit Sparse",
                    VM_MMST04_ITERATIONS,
                    &PerfInfo
                  );

//
//  Memory Management sub-test 4 --
//
//      Create a 64 MB segment without committing the pages,
//      then commit and touch at 128 KB intervals.
//
//
    for (ii=0; ii<VM_MMST04_ITERATIONS; ii++) {

        p1 = NULL;
        SegxSize = SEG_X_SIZE;
        status = NtAllocateVirtualMemory (CurrentProcessHandle,
                                          (PVOID *)&p1,
                                          0,
                                          &SegxSize,
                                          MEM_RESERVE,
                                          PAGE_READWRITE);

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed - status %lx\n", status);
        }

        CommitSize = 4;

        for (p2=p1; p2 < (p1 + SegxSize); p2 += 256 * 1024) {

            status = NtAllocateVirtualMemory (CurrentProcessHandle,
                                              (PVOID *)&p2,
                                              0,
                                              &CommitSize,
                                              MEM_COMMIT,
                                              PAGE_READWRITE);

            if (!NT_SUCCESS(status)) {
                DbgPrint("service failed - status %lx\n", status);
            }
            if (*p2 != 0) DbgPrint("%lx = %lx\n",p2,*p2);
            }  // for
        status = NtFreeVirtualMemory (CurrentProcessHandle,
                                      (PVOID *)&p1,
                                      &SegxSize,
                                      MEM_RELEASE);

        if (!NT_SUCCESS(status)) {
            DbgPrint("service failed - status %lx\n", status);
        }

    }
    FinishBenchMark( &PerfInfo );

//


    StartBenchMark( "NT MemMan5 -- Sparse Section Create/Delete Benchmark",
                    VM_MEMMAN_ITERATIONS,
                    &PerfInfo
                  );

//
//  Memory Management sub-test 5 --
//
//      Create a alternatively 232k and 112 k memory sections.
//      For every 2 created, delete 1.  Do this for MemManSubtest5Count times.
//
//
    for (ii=0; ii<VM_MEMMAN_ITERATIONS; ii++) {
        for (ix=0; ix<MemManSubtest5Count; ix++) {
//
// determine if even or odd allocation, if even and not 0, delete a section
//
            ssize = (112 * 1024);       //assume ODD allocation
            if ((ix & 1) == 0) {        //if it is an even one
                ssize = (232 * 1024);   //allocate 232 K on even passes
                if (ix){                //except on pass 0
                    SegxSize = 0;
                    status = NtFreeVirtualMemory (CurrentProcessHandle,
                                                  (PVOID *)&pa[ix/2],
                                                  &SegxSize,
                                                  MEM_RELEASE);

                    if (!NT_SUCCESS(status)) {
                        DbgPrint("service failed - status %lx\n", status);
                    }
                    pa[ix / 2] = 0;     //remember this one is gone
                }
            }  // end if even allocation


            pa[ix] = NULL;

            status = NtAllocateVirtualMemory (CurrentProcessHandle,
                                              (PVOID *)&pa[ix],
                                              0,
                                              &ssize,
                                              MEM_RESERVE,
                                              PAGE_READWRITE);

            if (!NT_SUCCESS(status)) {
                DbgPrint("service failed - status %lx\n", status);
            }
        }  // for ix
//
// Now free up the memory used in this test
//
        for (ix=0; ix<MemManSubtest5Count; ix++) {
            if (pa[ix] != 0) {
                SegxSize = 0;
                status = NtFreeVirtualMemory (CurrentProcessHandle,
                                              (PVOID *)&pa[ix],
                                              &SegxSize,
                                              MEM_RELEASE);

                if (!NT_SUCCESS(status)) {
                    DbgPrint("service failed - status %lx\n", status);
                }
            }  // if
        }  // for
    }  // for ii

    FinishBenchMark( &PerfInfo );

    DbgPrint("that's all\n");
    return (TRUE);

}
int
StartBenchMark(
    PCHAR Title,
    ULONG Iterations,
    PPERFINFO PerfInfo
    )
{
    DbgPrint( "*** Start %s (%d iterations)\n",
            PerfInfo->Title = Title,
            PerfInfo->Iterations = Iterations
          );

    NtQuerySystemTime( (PLARGE_INTEGER)&PerfInfo->StartTime );
    return( TRUE );
}

VOID
FinishBenchMark(
    PPERFINFO PerfInfo
    )
{
    ULONG TotalMilliSeconds;
    ULONG IterationsPerSecond;
    ULONG IterationFractions;
    LARGE_INTEGER Delta;

    NtQuerySystemTime( (PLARGE_INTEGER)&PerfInfo->StopTime );

    Delta.QuadPart = PerfInfo->StopTime.QuadPart -
                                     PerfInfo->StartTime.QuadPart;

    TotalMilliSeconds = Delta.LowPart / 10000;

    IterationsPerSecond = (1000 * PerfInfo->Iterations) / TotalMilliSeconds;
    IterationFractions  = (1000 * PerfInfo->Iterations) % TotalMilliSeconds;
    IterationFractions  = (1000 * IterationFractions) / TotalMilliSeconds;
    if (1) {
        DbgPrint( "        iterations     - %9d\n", PerfInfo->Iterations );
        DbgPrint( "        milliseconds   - %9d\n", TotalMilliSeconds );
        DbgPrint( "        iterations/sec - %5d.%3d\n\n",
                IterationsPerSecond,
                IterationFractions
              );
        }
    BenchMarkNames[ TotalBenchMarks ] = PerfInfo->Title;
    BenchMarkRates[ TotalBenchMarks ] = IterationsPerSecond;
    BenchMarkFracs[ TotalBenchMarks ] = IterationFractions;
    TotalBenchMarks++;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmtests\vmread.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    taststrs.c

Abstract:

    Tasking stress test.

Author:

    Mark Lucovsky (markl) 26-Sep-1990

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <string.h>

HANDLE Semaphore, Event;

VOID
TestThread(
    LPVOID ThreadParameter
    )
{
    DWORD st;

    (ReleaseSemaphore(Semaphore,1,NULL));

    st = WaitForSingleObject(Event,500);

    ExitThread(0);
}

VOID
NewProcess()
{
    PUCHAR buffer;

    buffer = VirtualAlloc (NULL, 600*1024, MEM_COMMIT, PAGE_READWRITE);

    Sleep(10000);

    TerminateProcess(GetCurrentProcess(),0);
}


DWORD
_cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    SIZE_T st;
    DWORD ProcessCount;
    SMALL_RECT Window;
    MEMORY_BASIC_INFORMATION info;
    PUCHAR address;
    PUCHAR buffer;
    PUCHAR SystemRangeStart;

    ProcessCount = 0;
    if ( strchr(GetCommandLine(),'+') ) {
        NewProcess();
        }

    if (!NT_SUCCESS(NtQuerySystemInformation(SystemRangeStartInformation,
                                             &SystemRangeStart,
                                             sizeof(SystemRangeStart),
                                             NULL))) {
        // assume usermode is the low half of the address space
        SystemRangeStart = (PUCHAR)MAXLONG_PTR;
    }

    GetStartupInfo(&StartupInfo);

    if (CreateProcess(
                    NULL,
                    "vmread +",
                    NULL,
                    NULL,
                    FALSE,
                    CREATE_NEW_CONSOLE,
                    NULL,
                    NULL,
                    &StartupInfo,
                    &ProcessInfo
                    ))
    {
        printf("Process Created\n");

        Sleep (1000);


        buffer = VirtualAlloc (NULL, 10*1000*1000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

        if (!buffer) {
            printf("virtual alloc failed %ld.\n",GetLastError());
            return 1;
        }

        address = NULL;
        do {

            if (!VirtualQueryEx (ProcessInfo.hProcess,
                                      (PVOID)address,
                                      &info,
                                      sizeof(info)))
            {
                printf ("virtual query failed %ld.\n",GetLastError());
                break;
            } else {
                printf("address: %p size %lx state %lx protect %lx type %lx\n",
                    address,
                    info.RegionSize,
                    info.State,
                    info.Protect,
                    info.Type);
            }
            if ((info.Protect != PAGE_NOACCESS) &&
                (info.Protect != 0) &&
                (!(info.Protect & PAGE_GUARD))) {
                if (!ReadProcessMemory (ProcessInfo.hProcess,
                                             address,
                                             buffer,
                                             4,
                                             &st))
                {
                    printf("read vm4 failed at %p error %ld. \n",
                        address,
                        GetLastError());
                    return 1;
                }

                if (!ReadProcessMemory (ProcessInfo.hProcess,
                                             address,
                                             buffer,
                                             info.RegionSize,
                                             &st))
                {
                    printf("read vm failed at %p error %ld. \n",
                        address,
                        GetLastError());
                    return 1;
                }

            }

            address += info.RegionSize;
        } while (address < SystemRangeStart);

        address = NULL;
        do {

            if (!VirtualQueryEx (ProcessInfo.hProcess,
                                      (PVOID)address,
                                      &info,
                                      sizeof(info)))
            {
                printf ("virtual query failed %ld.\n",GetLastError());
                return 1;
            } else {
                printf("address: %p size %lx state %lx protect %lx type %lx\n",
                    address,
                    info.RegionSize,
                    info.State,
                    info.Protect,
                    info.Type);
            }
            if ((info.Protect != PAGE_NOACCESS) &&
                (info.Protect != 0) &&
                (!(info.Protect & PAGE_GUARD)) &&
                (info.Protect & PAGE_READWRITE) &&
                (info.State != MEM_IMAGE)) {
                if (!ReadProcessMemory (ProcessInfo.hProcess,
                                              address,
                                              buffer,
                                              4,
                                              &st) )
                {
                    printf("read vm5 failed at %p error %ld. \n",
                        address,
                        GetLastError());
                    return 1;
                }
                if (!WriteProcessMemory (ProcessInfo.hProcess,
                                              address,
                                              buffer,
                                              4,
                                              &st))
                {
                    printf("write vm4 failed at %p error %ld. \n",
                        address,
                        GetLastError());
                    return 1;
                }

                if (!ReadProcessMemory (ProcessInfo.hProcess,
                                              address,
                                              buffer,
                                              info.RegionSize,
                                              &st))
                {
                    printf("read 5 vm failed at %p error %ld. \n",
                        address,
                        GetLastError());
                    return 1;
                }

                if (!WriteProcessMemory (ProcessInfo.hProcess,
                                              address,
                                              buffer,
                                              info.RegionSize,
                                              &st))
                {
                    printf("write vm failed at %p error %ld. \n",
                        address,
                        GetLastError());
                    return 1;
                }

            }

            address += info.RegionSize;
        } while (address < SystemRangeStart);

        CloseHandle(ProcessInfo.hProcess);
        CloseHandle(ProcessInfo.hThread);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmtests\vmquery.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    taststrs.c

Abstract:

    Tasking stress test.

Author:

    Mark Lucovsky (markl) 26-Sep-1990

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <string.h>

HANDLE Semaphore, Event;

VOID
TestThread(
    LPVOID ThreadParameter
    )
{
    DWORD st;

    (ReleaseSemaphore(Semaphore,1,NULL));

    st = WaitForSingleObject(Event,500);

    ExitThread(0);
}

VOID
NewProcess()
{
    PUCHAR buffer;

    buffer = VirtualAlloc (NULL, 600*1024, MEM_COMMIT, PAGE_READWRITE);

    Sleep(50000);

    TerminateProcess(GetCurrentProcess(),0);
}


DWORD
_cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    BOOL Success;
    DWORD st;
    DWORD ProcessCount;
    SMALL_RECT Window;
    MEMORY_BASIC_INFORMATION info;
    PUCHAR address;
    PUCHAR buffer;
    PUCHAR SystemRangeStart;

    ProcessCount = 0;
    if ( strchr(GetCommandLine(),'+') ) {
        NewProcess();
        }

    if (!NT_SUCCESS(NtQuerySystemInformation(SystemRangeStartInformation,
                                             &SystemRangeStart,
                                             sizeof(SystemRangeStart),
                                             NULL))) {
        // assume usermode is the low half of the address space
        SystemRangeStart = (PUCHAR)MAXLONG_PTR;
    }

    GetStartupInfo(&StartupInfo);

    Success = CreateProcess(
                    NULL,
                    "vmread +",
                    NULL,
                    NULL,
                    FALSE,
                    CREATE_NEW_CONSOLE,
                    NULL,
                    NULL,
                    &StartupInfo,
                    &ProcessInfo
                    );

    if (Success) {
        printf("Process Created\n");

        Sleep (1000);


        buffer = VirtualAlloc (NULL, 10*1000*1000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

        if (!buffer) {
            printf("virtual alloc failed at %ld.\n",GetLastError());
            return 1;
        }

        address = NULL;
        do {

            Success = VirtualQueryEx (ProcessInfo.hProcess,
                                      (PVOID)address,
                                      &info,
                                      sizeof(info));

            if (!Success) {
                printf ("virtual query failed at %lx - %ld.\n",address,GetLastError());
                break;
            } else {
                printf("address: %lx size %lx state %lx protect %lx type %lx\n",
                    address,
                    info.RegionSize,
                    info.State,
                    info.Protect,
                    info.Type);
            }

            address += info.RegionSize;
        } while (address < SystemRangeStart);

        address = 0x40000000;
        do {

            Success = VirtualQueryEx (ProcessInfo.hProcess,
                                      (PVOID)address,
                                      &info,
                                      sizeof(info));

            if (!Success) {
                printf ("virtual query failed at %lx %ld.\n",address,GetLastError());
                return 1;
            } else {
                if (info.AllocationBase == address) {
                    printf("address: %lx size %lx state %lx protect %lx type %lx\n",
                        address,
                        info.RegionSize,
                        info.State,
                        info.Protect,
                        info.Type);
                }
            }
            address += 4096;
        } while (address < SystemRangeStart);

        CloseHandle(ProcessInfo.hProcess);
        CloseHandle(ProcessInfo.hThread);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmtests\vmstress.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    vmstress.c

Abstract:

    Test stress program for virtual memory.

Author:

    Lou Perazzoli (LouP) 26-Jul-91

Revision History:

--*/

#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

typedef struct _INIT_ARG {
    PULONG_PTR Va;
    SIZE_T Size;
} INIT_ARG, *PINITARG;

VOID
VmRandom1 (
    LPVOID ThreadParameter
    );

VOID
VmRandom2 (
    LPVOID ThreadParameter
    );


VOID
VmRandom1 (
    LPVOID ThreadParameter
    )
{

    PINITARG InitialArg;
    ULONG Seed = 8373833;
    SIZE_T size;
    PULONG_PTR startva0;
    PULONG_PTR Va;
    ULONG i,j;

    InitialArg = (PINITARG)ThreadParameter;

    startva0 = InitialArg->Va;
    size = InitialArg->Size;

//    printf("starting random references in thread1\n");
    for (j = 1; j < 10; j++) {
        for (i = 1 ; i < 2500; i++) {

             RtlRandom (&Seed);
             Va = startva0 + (Seed % (size / sizeof(ULONG_PTR)));


             if (*Va == (((ULONG_PTR)Va + 1))) {
                 *Va = (ULONG_PTR)Va;

             } else {
                 if (*Va != (ULONG_PTR)Va) {
                     printf("bad random value in cell %p was %p\n", Va, *Va);
                 }
             }

        }
        Sleep (150);
    }
//    printf("terminating thread1\n");
    ExitThread(0);
}

VOID
VmRandom2 (
    LPVOID ThreadParameter
    )
{

    PINITARG InitialArg;
    ULONG Seed = 8373839;
    SIZE_T size;
    PULONG_PTR startva0;
    PULONG_PTR Va;
    ULONG i,j;

    InitialArg = (PINITARG)ThreadParameter;

    startva0 = InitialArg->Va;
    size = InitialArg->Size;

//    printf("starting random references in thread2\n");

    for (j = 1; j < 10; j++) {
        for (i = 1 ; i < 2500; i++) {

             RtlRandom (&Seed);
             Va = startva0 + (Seed % (size / sizeof(ULONG_PTR)));


             if (*Va == (((ULONG_PTR)Va + 1))) {
                 *Va = (ULONG_PTR)Va;

             } else {
                 if (*Va != (ULONG_PTR)Va) {
                     printf("bad random value in cell %p was %lx\n", Va, *Va);
                 }
             }
        }

        Sleep (150);
    }
//    printf("terminating thread2\n");
    ExitThread(0);
}


DWORD
__cdecl main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    HANDLE Objects[2];
    MEMORYSTATUS MemStatus;
    INIT_ARG InitialArg;
    PULONG_PTR Va;
    PULONG_PTR EndVa;
    SIZE_T size;
    PULONG_PTR startva0;
    NTSTATUS status;
    DWORD ThreadId1, ThreadId2;
    ULONG count = 0;

    printf("Starting virtual memory stress test\n");

    for (;;) {

        //
        // Create a region of private memory based on the number of
        // available pages on this system.
        //

        GlobalMemoryStatus(&MemStatus);

        size = MemStatus.dwAvailPhys;
        if (size == 0) {
            size = 4096;
        }
        else {
            size -= 4*4096;
        }

        while (size != 0) {
            startva0 = NULL;
            status = NtAllocateVirtualMemory (NtCurrentProcess(),
                                              (PVOID *)&startva0,
                                              0,
                                              &size,
                                              MEM_COMMIT | MEM_RESERVE,
                                              PAGE_READWRITE);
            if (NT_SUCCESS(status)) {
                break;
            }
            else {

                //
                // Try for less memory.
                //

                size -= 4096;
            }
        }

        printf("created vm status, startva, size, %lX %p %p\n",
                status, startva0, size);

        if (!NT_SUCCESS(status)) {
            ExitProcess (0);
        }

        InitialArg.Va = startva0;
        InitialArg.Size = size;

        //
        // Set all memory to know values (not zeroes).
        //

        printf("initializing memory\n");

        EndVa = (PULONG_PTR)startva0 + (size/sizeof(ULONG_PTR));

        Va = startva0;

        while (Va < EndVa) {
            *Va = (ULONG_PTR)Va + 1;
            Va += 1;
        }

        do {
            Objects[0] = CreateThread(NULL,
                                  0L,
                                  (LPTHREAD_START_ROUTINE)VmRandom1,
                                  (LPVOID)&InitialArg,
                                  0,
                                  &ThreadId1);
            //
            // Must have run out of memory, wait a while and then try again.
            //

            if (Objects[0] == (HANDLE)0) {
                Sleep (3000);
            }

        } while (Objects[0] == (HANDLE)0);

        do {
            Objects[1] = CreateThread(NULL,
                                  0L,
                                  (LPTHREAD_START_ROUTINE)VmRandom2,
                                  (LPVOID)&InitialArg,
                                  0,
                                  &ThreadId2);
            //
            // Must have run out of memory, wait a while and then try again.
            //

            if (Objects[1] == (HANDLE)0) {
                Sleep (3000);
            }
        } while (Objects[1] == (HANDLE)0);

        WaitForMultipleObjects (2,
                                Objects,
                                TRUE,
                                -1);

        count += 1;
        printf("stress test pass number %ld complete\n",count);

        CloseHandle (Objects[0]);
        CloseHandle (Objects[1]);

        printf("freeing vm startva, size, %p %p\n",
                startva0, size);

        status = NtFreeVirtualMemory (NtCurrentProcess(),
                                      (PVOID *)&startva0,
                                      &size,
                                      MEM_RELEASE);

        if (!NT_SUCCESS(status)) {
            ExitProcess (0);
        }

        Sleep (1000);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\vmtests\vmtest.c ===
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#define DbgPrint printf
#define NtTerminateProcess(a,b) ExitProcess(b)

__cdecl
main(
    )

{

    SIZE_T size, Size;
    PVOID BaseAddress;
    LONG i, j;
    PULONG p4, p3, p2, p1, oldp1, vp1;
    SIZE_T Size1, Size2, Size3;
    NTSTATUS status, alstatus;
    HANDLE CurrentProcessHandle;
    HANDLE GiantSection;
    HANDLE Section2, Section4;
    MEMORY_BASIC_INFORMATION MemInfo;
    ULONG OldProtect;
    STRING Name3;
    HANDLE Section1;
    OBJECT_ATTRIBUTES ObjectAttributes;
    OBJECT_ATTRIBUTES Object1Attributes;
    SIZE_T ViewSize;
    LARGE_INTEGER Offset;
    LARGE_INTEGER SectionSize;
    UNICODE_STRING Unicode;
    LOGICAL Os64Bit;
    SYSTEM_PROCESSOR_INFORMATION SysInfo;

    Os64Bit = FALSE;

    //
    // If we're running on a 64-bit OS, make large memory calls.
    //

    status = NtQuerySystemInformation (SystemProcessorInformation,
                                       &SysInfo,
                                       sizeof(SYSTEM_PROCESSOR_INFORMATION),
                                       NULL);

    if (NT_SUCCESS(status)) {
        if (SysInfo.ProcessorArchitecture == PROCESSOR_ARCHITECTURE_ALPHA64 ||
            SysInfo.ProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64) {
            Os64Bit = TRUE;
        }
    }

    DbgPrint("****Memory Management Tests (%d-bit) - AllocVm, FreeVm, ProtectVm, QueryVm\n", Os64Bit == TRUE ? 64 : 32);

    CurrentProcessHandle = NtCurrentProcess();

    p1 = (PULONG)0x20020000;
    Size1 = 0xbc0000;
    DbgPrint("    Test 1 - ");
    alstatus = NtAllocateVirtualMemory(CurrentProcessHandle,
                                       (PVOID *)&p1,
                                       0,
                                       &Size1,
                                       MEM_RESERVE | MEM_COMMIT,
                                       PAGE_READWRITE);

    if (!NT_SUCCESS(alstatus)) {
        DbgPrint("Failed allocate with status %lx start %p size %p\n",
                 alstatus,
                 p1,
                 Size1);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 2 - ");
    status = NtQueryVirtualMemory(CurrentProcessHandle,
                                  p1,
                                  MemoryBasicInformation,
                                  &MemInfo,
                                  sizeof(MEMORY_BASIC_INFORMATION),
                                  NULL);

    if (!NT_SUCCESS(status) ||
        (MemInfo.RegionSize != Size1) ||
        (MemInfo.BaseAddress != p1) ||
        (MemInfo.Protect != PAGE_READWRITE) ||
        (MemInfo.Type != MEM_PRIVATE) ||
        (MemInfo.State != MEM_COMMIT)) {
        DbgPrint("Failed query with status %lx address %p Base %p size %p\n",
                 status,
                 p1,
                 MemInfo.BaseAddress,
                 MemInfo.RegionSize);

        DbgPrint("    state %lx protect %lx type %lx\n",
                 MemInfo.State,
                 MemInfo.Protect,
                 MemInfo.Type);

    } else {
        DbgPrint("Succeeded\n");
    }


    DbgPrint("    Test 3 - ");
    p2 = NULL;
    Size2 = 0x100000;
    status = NtAllocateVirtualMemory(CurrentProcessHandle,
                                     (PVOID *)&p2,
                                     3,
                                     &Size2,
                                     MEM_TOP_DOWN | MEM_RESERVE | MEM_COMMIT,
                                     PAGE_READWRITE);

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed allocate with status %lx start %p size %p\n",
                 status,
                 p2,
                 Size2);

    } else {
        DbgPrint("Succeeded\n");
    }

    //
    // Touch every other page.
    //

    DbgPrint("    Test 4 - ");
    try {
        vp1 = p2 + 3000;
        while (vp1 < (p2 + (Size2 / sizeof(ULONG)))) {
            *vp1 = 938;
            vp1 += 3000;
        }

        DbgPrint("Succeeded\n");

    } except(EXCEPTION_EXECUTE_HANDLER) {
        DbgPrint("Failed with an exception\n");
    }

    //
    // Decommit pages.
    //

    DbgPrint("    Test 5 - ");
    Size3 = Size2 - 5044;
    vp1 = p2 + 3000;
    status = NtFreeVirtualMemory(CurrentProcessHandle,
                                 (PVOID *)&p2,
                                 &Size3,
                                 MEM_DECOMMIT);

    if (!(NT_SUCCESS(status))) {
        DbgPrint("Failed free with status %lx\n", status);

    } else {
        DbgPrint("Succeeded\n");
    }

    //
    // Split the memory block using MEM_RELEASE.
    //

    DbgPrint("    Test 6 - ");
    vp1 = p2 + 5000;
    Size3 = Size2 - 50000;
    status = NtFreeVirtualMemory(CurrentProcessHandle,
                                 (PVOID *)&vp1,
                                 &Size3,
                                 MEM_RELEASE);

    if (!(NT_SUCCESS(status))) {
        DbgPrint("Failed free with status %lx\n", status);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 7 - ");
    vp1 = p2 + 3000;
    Size3 = 41;
    status = NtFreeVirtualMemory(CurrentProcessHandle,
                                 (PVOID *)&vp1,
                                 &Size3,
                                 MEM_RELEASE);

    if (!(NT_SUCCESS(status))) {
        DbgPrint("Failed free with status %lx\n", status);

    } else {
        DbgPrint("Succeeded\n");
    }

    //
    // free every page, ignore the status.
    //

    vp1 = p2;
    Size3 = 30;
    while (vp1 < (p2 + (Size2 / sizeof(ULONG)))) {
        status = NtFreeVirtualMemory(CurrentProcessHandle,
                                     (PVOID *)&vp1,
                                     &Size3,
                                     MEM_RELEASE);
        vp1 += 128;
    }

    DbgPrint("    Test 8 - ");
    p2 = NULL;
    Size2 = 0x10000;
    status = NtAllocateVirtualMemory(CurrentProcessHandle,
                                     (PVOID *)&p2,
                                     3,
                                     &Size2,
                                     MEM_TOP_DOWN | MEM_RESERVE | MEM_COMMIT,
                                     PAGE_READWRITE);

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed allocate with status %lx start %p size %p\n",
                 status,
                 p2,
                 Size1);

    } else {
        if (p2 < (PULONG)0x1fff0000) {
            DbgPrint("Failed allocate at top of memory at %p\n", p2);
        }

        status = NtFreeVirtualMemory(CurrentProcessHandle,
                                     (PVOID *)&p2,
                                     &Size2,
                                     MEM_RELEASE);

        if (!(NT_SUCCESS(status))) {
            DbgPrint("Failed free with status %lx\n", status);

        } else {
            DbgPrint("Succeeded with allocation at %p\n", p2);
        }
    }

    DbgPrint("    Test 9 - ");
    if (NT_SUCCESS(alstatus)) {
        status = NtFreeVirtualMemory(CurrentProcessHandle,
                                     (PVOID *)&p1,
                                     &Size1,
                                     MEM_RELEASE);

        if (!(NT_SUCCESS(status))) {
            DbgPrint("Failed free with status %lx\n", status);

        } else {
            DbgPrint("Succeeded\n");
        }

    } else {
        DbgPrint("Failed allocate with status %lx\n", alstatus);
    }


    DbgPrint("    Test 10 - ");
    p1 = NULL;
    Size1 = 16 * 4096;
    status = NtAllocateVirtualMemory(CurrentProcessHandle,
                                     (PVOID *)&p1,
                                     0,
                                     &Size1,
                                     MEM_RESERVE, PAGE_READWRITE | PAGE_GUARD);

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed created with status %lx start %p size %p\n",
                 status,
                 p1,
                 Size1);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 11 - ");
    status = NtQueryVirtualMemory(CurrentProcessHandle,
                                  p1,
                                  MemoryBasicInformation,
                                  &MemInfo,
                                  sizeof(MEMORY_BASIC_INFORMATION),
                                  NULL);

    if (!NT_SUCCESS(status) ||
        (MemInfo.RegionSize != Size1) ||
        (MemInfo.BaseAddress != p1) ||
        (MemInfo.AllocationProtect != (PAGE_READWRITE | PAGE_GUARD)) ||
        (MemInfo.Protect != 0) ||
        (MemInfo.Type != MEM_PRIVATE) ||
        (MemInfo.State != MEM_RESERVE)) {
        DbgPrint("Failed query with status %lx address %p Base %p size %p\n",
                 status,
                 p1,
                 MemInfo.BaseAddress,
                 MemInfo.RegionSize);

        DbgPrint("    state %lx protect %lx alloc_protect %lx type %lx\n",
                 MemInfo.State,
                 MemInfo.Protect,
                 MemInfo.AllocationProtect,
                 MemInfo.Type);

    } else {
        DbgPrint("Succeeded\n");
    }


    DbgPrint("    Test 12 - ");
    Size2 = 8192;
    oldp1 = p1;
    p1 = p1 + 14336;  // 64k -8k /4
    status = NtAllocateVirtualMemory(CurrentProcessHandle,
                                     (PVOID *)&p1,
                                     0,
                                     &Size2,
                                     MEM_COMMIT, PAGE_EXECUTE_READWRITE);

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed creat with status %lx start %p size %p\n",
                 status,
                 p1,
                 Size1);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 13 - ");
    status = NtQueryVirtualMemory(CurrentProcessHandle,
                                  oldp1,
                                  MemoryBasicInformation,
                                  &MemInfo,
                                  sizeof(MEMORY_BASIC_INFORMATION),
                                  NULL);

    if (!NT_SUCCESS(status) ||
        (MemInfo.RegionSize != 56*1024) ||
        (MemInfo.BaseAddress != oldp1) ||
        (MemInfo.AllocationProtect != (PAGE_READWRITE | PAGE_GUARD)) ||
        (MemInfo.Protect != 0) ||
        (MemInfo.Type != MEM_PRIVATE) ||
        (MemInfo.State != MEM_RESERVE)) {
        DbgPrint("Failed query with status %lx address %p Base %p size %p\n",
                 status,
                 oldp1,
                 MemInfo.BaseAddress,
                 MemInfo.RegionSize);

        DbgPrint("    state %lx protect %lx alloc_protect %lx type %lx\n",
                 MemInfo.State,
                 MemInfo.Protect,
                 MemInfo.AllocationProtect,
                 MemInfo.Type);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 14 - ");
    status = NtQueryVirtualMemory(CurrentProcessHandle,
                                  p1,
                                  MemoryBasicInformation,
                                  &MemInfo,
                                  sizeof(MEMORY_BASIC_INFORMATION),
                                  NULL);

    if (!NT_SUCCESS(status) ||
        (MemInfo.RegionSize != Size2) || (MemInfo.BaseAddress != p1) ||
        (MemInfo.Protect != PAGE_EXECUTE_READWRITE) || (MemInfo.Type != MEM_PRIVATE) ||
        (MemInfo.State != MEM_COMMIT)
        || (MemInfo.AllocationBase != oldp1)) {
        DbgPrint("Failed query with status %lx address %p Base %p size %p\n",
                 status,
                 oldp1,
                 MemInfo.BaseAddress,
                 MemInfo.RegionSize);

        DbgPrint("    state %lx protect %lx type %lx\n",
                 MemInfo.State,
                 MemInfo.Protect,
                 MemInfo.Type);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 15 - ");
    Size1 = Size2;
    status = NtProtectVirtualMemory(CurrentProcessHandle,
                                    (PVOID *)&p1,
                                    &Size1,
                                    PAGE_READONLY | PAGE_NOCACHE, &OldProtect);

    if ((!NT_SUCCESS(status)) ||
        (OldProtect != PAGE_EXECUTE_READWRITE)) {
        DbgPrint("Failed protect with status %lx base %p size %p old protect %lx\n",
                 status,
                 p1,
                 Size1,
                 OldProtect);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 16 - ");
    status = NtQueryVirtualMemory(CurrentProcessHandle,
                                  p1,
                                  MemoryBasicInformation,
                                  &MemInfo,
                                  sizeof(MEMORY_BASIC_INFORMATION),
                                  NULL);

    if ((!NT_SUCCESS(status)) ||
        (MemInfo.Protect != (PAGE_NOCACHE | PAGE_READONLY))) {
        DbgPrint("Failed query with status %lx address %p Base %p size %p\n",
                 status,
                 p1,
                 MemInfo.BaseAddress,
                 MemInfo.RegionSize);

        DbgPrint("    state %lx protect %lx type %lx\n",
                 MemInfo.State,
                 MemInfo.Protect,
                 MemInfo.Type);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 17 - ");
    i = *p1;
    status = NtProtectVirtualMemory(CurrentProcessHandle,
                                    (PVOID *)&p1,
                                    &Size1,
                                    PAGE_NOACCESS | PAGE_NOCACHE, &OldProtect);

    if (status != STATUS_INVALID_PAGE_PROTECTION) {
        DbgPrint("Failed protect with status %lx, base %p, size %p, old protect %lx\n",
                 status,
                 p1,
                 Size1,
                 OldProtect);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 18 - ");
    status = NtProtectVirtualMemory(CurrentProcessHandle,
                                    (PVOID *)&p1,
                                    &Size1,
                                    PAGE_READONLY,
                                    &OldProtect);

    if ((!NT_SUCCESS(status)) ||
        (OldProtect != (PAGE_NOCACHE | PAGE_READONLY))) {
        DbgPrint("Failed protect with status %lx base %p size %p old protect %lx\n",
                 status,
                 p1,
                 Size1,
                 OldProtect);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 19 - ");
    status = NtProtectVirtualMemory(CurrentProcessHandle,
                                    (PVOID *)&p1,
                                    &Size1,
                                    PAGE_READWRITE,
                                    &OldProtect);

    if ((!NT_SUCCESS(status)) ||
        (OldProtect != (PAGE_READONLY))) {
        DbgPrint("Failed protect with status %lx base %p size %p old protect %lx\n",
                 status,
                 p1,
                 Size1,
                 OldProtect);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 20 - ");
    for (i = 1; i < 12; i++) {
        p2 = NULL;
        Size2 = i * 4096;
        status = NtAllocateVirtualMemory(CurrentProcessHandle,
                                         (PVOID *)&p2,
                                         0,
                                         &Size2,
                                         MEM_COMMIT,
                                         PAGE_READWRITE);

        if (!NT_SUCCESS(status)) {
            DbgPrint("Failed creat with status %lx start %p size %p\n",
                     status,
                     p2,
                     Size2);

            break;

        }

        if (i == 4) {
            p3 = p2;
        }

        if (i == 8) {
            Size3 = 12000;
            status = NtFreeVirtualMemory(CurrentProcessHandle,
                                         (PVOID *)&p3,
                                         &Size3,
                                         MEM_RELEASE);

            if (!NT_SUCCESS(status)) {
                DbgPrint("Failed free with status %lx start %p size %p\n",
                         status,
                         p3,
                         Size3);

                break;
            }
        }
    }

    if (i == 12) {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 21 - ");
    p3 = p1 + 8 * 1024;
    status = NtQueryVirtualMemory(CurrentProcessHandle,
                                  p3,
                                  MemoryBasicInformation,
                                  &MemInfo,
                                  sizeof(MEMORY_BASIC_INFORMATION),
                                  NULL);

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed query with status %lx address %p Base %p size %p\n",
                 status,
                 p3,
                 MemInfo.BaseAddress,
                 MemInfo.RegionSize);

        DbgPrint("    state %lx protect %lx type %lx\n",
                 MemInfo.State,
                 MemInfo.Protect,
                 MemInfo.Type);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 22 - ");
    p3 = p1 - 8 * 1024;
    status = NtQueryVirtualMemory(CurrentProcessHandle,
                                  p3,
                                  MemoryBasicInformation,
                                  &MemInfo,
                                  sizeof(MEMORY_BASIC_INFORMATION),
                                  NULL);

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed query with status %lx address %p Base %p size %p\n",
                 status,
                 p3,
                 MemInfo.BaseAddress,
                 MemInfo.RegionSize);

        DbgPrint("    state %lx protect %lx type %lx\n",
                 MemInfo.State,
                 MemInfo.Protect,
                 MemInfo.Type);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 23 - ");
    Size3 = 16 * 4096;
    status = NtFreeVirtualMemory(CurrentProcessHandle,
                                 (PVOID *)&p3,
                                 &Size3,
                                 MEM_RELEASE);

    if (status != STATUS_UNABLE_TO_FREE_VM) {
        DbgPrint("Failed free with status %lx start %p size %p\n",
                 status,
                 p3,
                 Size3);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 24 - ");
    Size3 = 1 * 4096;
    status = NtFreeVirtualMemory(CurrentProcessHandle,
                                 (PVOID *)&p3,
                                 &Size3,
                                 MEM_RELEASE);

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed free with status %lx start %p size %p\n",
                 status,
                 p3,
                 Size3);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 25 - ");
    p3 = NULL;
    Size3 = 300 * 4096;
    status = NtAllocateVirtualMemory(CurrentProcessHandle,
                                     (PVOID *)&p3,
                                     0,
                                     &Size3,
                                     MEM_COMMIT, PAGE_READWRITE);

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed creat with status %lx start %p size %p\n",
                 status,
                 p3,
                 Size3);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 26 - ");
    p1 = p3;
    p2 = ((PULONG)((PUCHAR)p3 + Size3));
    p4 = p1;
    j = 0;
    while (p3 < p2) {
        j += 1;
        if (j % 8 == 0) {
            if (*p4 != (ULONG)((ULONG_PTR)p4)) {
                DbgPrint("Failed bad value in xcell %p value is %lx\n", p4, *p4);
                break;
            }

            p4 += 1;
            *p4 = (ULONG)((ULONG_PTR)p4);
            p4 = p4 + 1026;
        }

        *p3 = (ULONG)((ULONG_PTR)p3);
        p3 += 1027;
    }

    if (p3 >= p2) {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 27 - ");
    status = NtQueryVirtualMemory(CurrentProcessHandle,
                                  p3,
                                  MemoryBasicInformation,
                                  &MemInfo,
                                  sizeof(MEMORY_BASIC_INFORMATION),
                                  NULL);

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed query with status %lx address %p Base %p size %p\n",
                 status,
                 p3,
                 MemInfo.BaseAddress,
                 MemInfo.RegionSize);

        DbgPrint("    state %lx protect %lx type %lx\n",
                 MemInfo.State,
                 MemInfo.Protect,
                 MemInfo.Type);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 28 - ");
    p3 = p1;
    while (p3 < p2) {
        if (*p3 != (ULONG)((ULONG_PTR)p3)) {
            DbgPrint("Failed bad value in 1cell %p value is %lx\n", p3, *p3);
            break;
        }

        p3 += 1027;
    }

    if (p3 >= p2) {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 29 - ");
    p3 = p1;
    while (p3 < p2) {
        if (*p3 != (ULONG)((ULONG_PTR)p3)) {
            DbgPrint("Failed bad value in 2cell %p value is %lx\n", p3, *p3);
            break;
        }

        p3 += 1027;
    }

    if (p3 >= p2) {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 30 - ");
    p3 = p1;
    while (p3 < p2) {
        if (*p3 != (ULONG)((ULONG_PTR)p3)) {
            DbgPrint("Failed bad value in 3cell %p value is %lx\n", p3, *p3);
            break;
        }

        p3 += 1027;
    }

    if (p3 >= p2) {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 31 - ");
    p3 = p1;
    while (p3 < p2) {
        if (*p3 != (ULONG)((ULONG_PTR)p3)) {
            DbgPrint("Failed bad value in 4cell %p value is %lx\n", p3, *p3);
            break;
        }

        p3 += 1027;
    }

    if (p3 >= p2) {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 32 - ");
    p3 = p1;
    while (p3 < p2) {
        if (*p3 != (ULONG)((ULONG_PTR)p3)) {
            DbgPrint("Failed bad value in 5cell %p value is %lx\n", p3, *p3);
            break;
        }

        p3 += 1027;
    }

    if (p3 >= p2) {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 33 - ");
    p3 = p1;
    while (p3 < p2) {
        if (*p3 != (ULONG)((ULONG_PTR)p3)) {
            DbgPrint("Failed bad value in cell %p value is %lx\n", p3, *p3);
            break;
        }

        p3 += 1027;
    }

    if (p3 >= p2) {
        DbgPrint("Succeeded\n");
    }

    //
    // Check physical frame mapping.
    //

    DbgPrint("    Test 34 - ");
    RtlInitAnsiString(&Name3, "\\Device\\PhysicalMemory");
    RtlAnsiStringToUnicodeString(&Unicode, &Name3, TRUE);
    InitializeObjectAttributes(&ObjectAttributes,
                               &Unicode,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtOpenSection(&Section1,
                           SECTION_MAP_READ | SECTION_MAP_WRITE,
                           &ObjectAttributes);

    RtlFreeUnicodeString(&Unicode);
    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed open physical section with status %lx\n", status);
        DbgPrint("              skipping test 35\n");
        goto Test36;

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 35 - ");
    p1 = NULL;
    Offset.QuadPart = 0x810ff033;
    ViewSize = 300 * 4096;
    status = NtMapViewOfSection(Section1,
                                NtCurrentProcess(),
                                (PVOID *)&p1,
                                0,
                                ViewSize,
                                &Offset,
                                &ViewSize,
                                ViewUnmap,
                                0,
                                PAGE_READWRITE);

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed map physical section %lx offset %p base %p\n",
                 status,
                 Offset.QuadPart,
                 p1);

    } else {
        DbgPrint("Succeeded\n");
    }

Test36:
    DbgPrint("    Test 36 - ");
    p1 = NULL;
    Size1 = 8 * 1024 * 1024;
    alstatus = NtAllocateVirtualMemory(CurrentProcessHandle,
                                       (PVOID *)&p1,
                                       0,
                                       &Size1,
                                       MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

    if (!NT_SUCCESS(alstatus)) {
        DbgPrint("Failed created with status %lx start %p size %p\n",
                 alstatus,
                 p1,
                 Size1);

    } else {
        DbgPrint("Succeeded\n");
    }

    try {
        RtlZeroMemory(p1, Size1);

    } except(EXCEPTION_EXECUTE_HANDLER) {
    }

    DbgPrint("    Test 37 - ");
    Size1 -= 20000;
    (PUCHAR)p1 += 5000;
    status = NtFreeVirtualMemory(CurrentProcessHandle,
                                 (PVOID *)&p1,
                                 &Size1 ,
                                 MEM_DECOMMIT);

    if (!(NT_SUCCESS(status))) {
        DbgPrint("Failed free with status %lx\n", status);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 38 - ");
    Size1 -= 20000;
    (PUCHAR)p1 += 5000;
    status = NtAllocateVirtualMemory(CurrentProcessHandle,
                                       (PVOID *)&p1,
                                       0,
                                       &Size1,
                                       MEM_COMMIT, PAGE_EXECUTE_READWRITE);

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed create with status %lx start %p size %p\n",
                 status,
                 p1,
                 Size1);

    } else {
        DbgPrint("Succeeded\n");
    }

    try {
        RtlZeroMemory(p1, Size1);

    } except(EXCEPTION_EXECUTE_HANDLER) {
    }

    DbgPrint("    Test 39 - ");
    Size1 = 28 * 4096;
    p1 = NULL;
    status = NtAllocateVirtualMemory(CurrentProcessHandle,
                                     (PVOID *)&p1,
                                     0,
                                     &Size1,
                                     MEM_COMMIT, PAGE_READWRITE | PAGE_GUARD);

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed create with status %lx start %p size %p\n",
                 status,
                 p1,
                 Size1);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 40 - ");
    try {

        //
        // attempt to write the guard page.
        //

        *p1 = 973;
        DbgPrint("Failed guard page exception did not occur\n");

    } except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        if (status != STATUS_GUARD_PAGE_VIOLATION) {
            DbgPrint("Failed incorrect guard exception code %lx\n", status);

        } else {
            DbgPrint("Succeeded\n");
        }
    }

    DbgPrint("    Test 41 - ");
    p2 = NULL;
    Size2 = 200 * 1024 * 1024;  //200MB
    status = NtAllocateVirtualMemory(CurrentProcessHandle,
                                     (PVOID *)&p2,
                                     0,
                                     &Size2,
                                     MEM_COMMIT, PAGE_READWRITE);

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed allocate with status %lx\n", status);

    } else {
        status = NtFreeVirtualMemory(CurrentProcessHandle,
                                     (PVOID *)&p2,
                                     &Size2,
                                     MEM_RELEASE);

        if (!NT_SUCCESS(status)) {
            DbgPrint("Failed free with status %lx\n", status);

        } else {
            DbgPrint("Succeeded\n");
        }
    }

    //
    // Create a giant section 2gb on 32-bit system, 4gb on 64_bit system.
    //

    DbgPrint("    Test 42 - ");
    InitializeObjectAttributes(&Object1Attributes,
                               NULL,
                               0,
                               NULL,
                               NULL);

#if defined(_WIN64)

    SectionSize.QuadPart = 0xffffffff;

#else

    SectionSize.QuadPart = 0x7f000000;

#endif

    status = NtCreateSection(&GiantSection,
                             SECTION_MAP_READ | SECTION_MAP_WRITE,
                             &Object1Attributes,
                             &SectionSize,
                             PAGE_READWRITE,
                             SEC_RESERVE,
                             NULL);

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed create big section with status %lx\n", status);
        DbgPrint("              skipping test 43\n");
        goto Test44;

    } else {
        DbgPrint("Succeeded\n");
    }

    //
    // Attempt to map the section (this should fail).
    //

    DbgPrint("    Test 43 - ");
    p1 = NULL;
    ViewSize = 0;
    status = NtMapViewOfSection(GiantSection,
                                CurrentProcessHandle,
                                (PVOID *)&p1,
                                0L,
                                0,
                                0,
                                &ViewSize,
                                ViewUnmap,
                                0,
                                PAGE_READWRITE );

    if (status != STATUS_NO_MEMORY) {
        DbgPrint("Failed map big section status %lx\n", status);

    } else {
        DbgPrint("Succeeded\n");
    }

Test44:
    DbgPrint("    Test 44 - ");
    i = 0;

#if defined(_WIN64)
    if (Os64Bit == TRUE) {
        Size2 = (SIZE_T)(32i64 * 1024 * 1024 * 1024 + 9938);
    }
    else {
        Size2 = 8 * 1024 * 1024 + 9938;
    }
#else
    Size2 = 8 * 1024 * 1024 + 9938;
#endif

    do {
        p2 = NULL;
        i += 1;
        status = NtAllocateVirtualMemory(CurrentProcessHandle,
                                         (PVOID *)&p2,
                                         0,
                                         &Size2,
                                         MEM_RESERVE, PAGE_READWRITE);

    } while (NT_SUCCESS(status));

    if (status != STATUS_NO_MEMORY) {
        DbgPrint("Failed with status %lx after %d allocations\n", status, i);

    } else {
        DbgPrint("Succeeded with %d allocations\n", i);
    }

    //
    // we pass an address of 1, so mm will round it down to 0.  if we
    // passed 0, it looks like a not present argument
    //
    // N.B.  We have to make two separate calls to allocatevm, because
    //       we want a specific virtual address.  If we don't first reserve
    //       the address, the mm fails the commit call.
    //

    DbgPrint("    Test 45 - ");
    Size = 50 * 1024;
    size = Size - 1;
    BaseAddress = (PVOID)1;
    status = NtAllocateVirtualMemory(NtCurrentProcess(),
                                     &BaseAddress,
                                     0L,
                                     &size,
                                     MEM_RESERVE,
                                     PAGE_READWRITE );

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed reserve with status = %lx\n", status);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 46 - ");
    size = Size - 1;
    BaseAddress = (PVOID)1;
    status = NtAllocateVirtualMemory(NtCurrentProcess(),
                                     &BaseAddress,
                                     0L,
                                     &size,
                                     MEM_COMMIT,
                                     PAGE_READWRITE );

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed commit with status = %lx\n", status);

    } else {
        DbgPrint("Succeeded\n");
    }

    //
    // Test MEM_DOS_LIM support.
    //

#ifdef i386

    DbgPrint("    Test 47 - ");
    InitializeObjectAttributes(&Object1Attributes,
                               NULL,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    SectionSize.QuadPart = 1575757,
    status = NtCreateSection(&Section4,
                             SECTION_MAP_READ | SECTION_MAP_WRITE,
                             &Object1Attributes,
                             &SectionSize,
                             PAGE_READWRITE,
                             SEC_COMMIT,
                             NULL);

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed create section with status %lx section handle %lx\n",
                 status,
                 (ULONG)Section4);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 48 - ");
    p3 = (PVOID)0x9001000;
    ViewSize = 8000;
    status = NtMapViewOfSection(Section4,
                                CurrentProcessHandle,
                                (PVOID *)&p3,
                                0L,
                                0,
                                0,
                                &ViewSize,
                                ViewUnmap,
                                MEM_DOS_LIM,
                                PAGE_READWRITE );

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed map section with status %lx base %lx size %lx\n",
                 status,
                 (ULONG)p3,
                 ViewSize);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 49 - ");
    p2 = (PVOID)0x9003000;
    ViewSize = 8000;
    status = NtMapViewOfSection(Section4,
                                CurrentProcessHandle,
                                (PVOID *)&p2,
                                0L,
                                0,
                                0,
                                &ViewSize,
                                ViewUnmap,
                                MEM_DOS_LIM,
                                PAGE_READWRITE );

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed map section with status %lx base %lx size %lx\n",
                 status,
                 (ULONG)p3,
                 ViewSize);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 50 - ");
    status = NtQueryVirtualMemory(CurrentProcessHandle,
                                  p3,
                                  MemoryBasicInformation,
                                  &MemInfo,
                                  sizeof(MEMORY_BASIC_INFORMATION),
                                  NULL);

    if (!NT_SUCCESS(status)) {
        DbgPrint("Failed query with status %lx address %lx Base %lx size %lx\n",
                 status,
                 p1,
                 MemInfo.BaseAddress,
                 MemInfo.RegionSize);

        DbgPrint("    state %lx protect %lx type %lx\n",
                 MemInfo.State,
                 MemInfo.Protect,
                 MemInfo.Type);

    } else {
        DbgPrint("Succeeded\n");
    }

    DbgPrint("    Test 51 - ");
    *p3 = 98;
    if (*p3 != *p2) {
        DbgPrint("Failed compare with %lx %lx\n", *p3, *p2);

    } else {
        DbgPrint("Succeeded\n");
    }


    DbgPrint("    Test 52 - ");
    Size2 = 8;
    p1 = (PVOID)((ULONG)p2 - 0x3000);
    status = NtAllocateVirtualMemory(CurrentProcessHandle,
                                     (PVOID *)&p1,
                                     0,
                                     &Size2,
                                     MEM_COMMIT,
                                     PAGE_EXECUTE_READWRITE);

    if (NT_SUCCESS(status)) {
        DbgPrint("Failed create with status %lx start %lx size %lx\n",
                 status,
                 p1,
                 Size1);

    } else {
        DbgPrint("Succeeded\n");
    }

#endif
    DbgPrint("****End of Memory Management Tests\n");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\walk\walk.c ===
/*      WALK - Walk a directory hierarchy
 *
 *      Mark Z.         ??/??/83
 *
 *      WALK walks a directory heirarchy and for each
 *      file or directory or both,
 *      prints the pathname, runs a program, or both.
 *
 *      walk [-f] [-d] [-h] [-print] topdir [command]
 *
 *      -f      deal with files
 *      -d      deal with directorys
 *              if neither is specified, deal with both
 *
 *      -h      Also find hidden directories and files
 *      -p[rint] print the pathnames on stdout
 *
 *      command optional command and arguments.  Pathname is
 *              substituted for every "%s" in the arguments
 *      Modification History
 *
 *      11/07/83        JGL
 *              - added -print switch
 *              - no longer an error to omit [command]
 *      15-May-87   bw  Add /h switch
 *      18-May-87   bw  Add code to recognize root directories
 *      23-Dec-1987 mz  Fix poor ./.. processing;  use system
 *      18-Oct-1990 w-barry Removed 'dead' code.
 *
 */

#define INCL_DOSMISC

#include <direct.h>
#include <errno.h>

#include <malloc.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <process.h>
#include <windows.h>
#include <tools.h>

// Forward Function Declarations...
void walk( char *, struct findType *, void* );
void usage( void );


char **vec;
flagType fD = FALSE;            /* apply function to directories only */
flagType fF = FALSE;            /* apply function to files only       */
flagType fPrint = FALSE;        /* print pathnames                    */
unsigned srch_attr = FILE_ATTRIBUTE_DIRECTORY; /* Find non-hidden files and dirs          */
char cmdline[MAXLINELEN];       /* command line to be executed        */
char dir[MAX_PATH];
char cdir[MAX_PATH];

void walk (p, b, dummy)
char *p;
struct findType *b;
void * dummy;
{
    static flagType fFirst = TRUE;
    int i;
    char *ppat, *pdst;

    if (fFirst || strcmp (b->fbuf.cFileName, ".") && strcmp (b->fbuf.cFileName, "..")) {
        fFirst = FALSE;
        if ((!fD && !fF) ||                     /* no special processing */
            (fD && HASATTR(b->fbuf.dwFileAttributes,FILE_ATTRIBUTE_DIRECTORY)) ||       /* only dir and dir */
            (fF && !HASATTR(b->fbuf.dwFileAttributes,FILE_ATTRIBUTE_DIRECTORY))) {      /* only file and file */
            if (fPrint)
                printf ("%s\n", p);
            if (vec[0]) {
                cmdline[0] = 0;
                for (i = 0; vec[i] != NULL; i++) {
                    strcat (cmdline, " ");
                    pdst = strend (cmdline);
                    ppat = vec[i];
                    while (*ppat != '\0')
                        if (ppat[0] == '%') {
                            if (ppat[1] == 'l') {
                                strcpy (pdst, p);
                                _strlwr (pdst);
                                pdst = strend (pdst);
                                ppat += 2;
                                }
                            else
                            if (ppat[1] == 'u') {
                                strcpy (pdst, p);
                                _strupr (pdst);
                                pdst = strend (pdst);
                                ppat += 2;
                                }
                            else
                            if (ppat[1] == 's') {
                                strcpy (pdst, p);
                                pdst = strend (pdst);
                                ppat += 2;
                                }
                            else
                                *pdst++ = *ppat++;
                        } else
                            *pdst++ = *ppat++;
                    *pdst = 0;
                    }
                i = system (cmdline);
                if (HIGH(i) != 0)
                    exit (1);
                }
            }

        if (HASATTR(b->fbuf.dwFileAttributes,FILE_ATTRIBUTE_DIRECTORY)) {
            switch (p[strlen(p)-1]) {
            case '/':
            case '\\':
                strcat (p, "*.*");
                break;
            default:
                strcat (p, "\\*.*");
                }
            forfile (p, srch_attr, walk, NULL);
            }
        }
    dummy;
}

int
__cdecl main (c, v)
int c;
char *v[];
{
    struct findType buf;

    ConvertAppToOem( c, v );
    SHIFT (c, v);
    while (c && fSwitChr (**v)) {
        switch (*(*v+1)) {
            case 'd':
                fD = TRUE;
                break;
            case 'f':
                fF = TRUE;
                break;
            case 'p':
                fPrint = TRUE;
                break;
            case 'h':
                srch_attr |= (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM); /* Find hidden/system files       */
                break;
            default:
                usage ();
            }
        SHIFT(c,v);
    }

    if (c == 0)
        usage ();

    strcpy (dir, *v);
    buf.fbuf.dwFileAttributes = GetFileAttributes( *v );
    SHIFT (c, v);

    if (c == 0 && !fPrint)
        usage ();

    if ( !HASATTR(buf.fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY) )/* DOS doesn't think it's a directory, but */
        switch (dir[strlen(dir)-1]) {
            case '/':              /* ... the user does.                    */
            case '\\':
                SETFLAG (buf.fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY);
                break;
            default:                /* ... it could be a root directory     */
                _getcwd (cdir, MAX_PATH);
                if ( _chdir(dir) == 0 ) {
                    SETFLAG (buf.fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY);
                    _chdir (cdir);
                    }
            }

    vec = v;

    walk (dir, &buf, NULL);
    return( 0 );
}

void usage ()
{
    printf ("walk [/d] [/f] [/p] [/h] dir [cmd]\n\n");

    printf ("WALK walks a directory heirarchy and for each file, directory or both,\n");
    printf ("prints the pathname, runs a program, or both.\n\n");

    printf ("    -f       deal with files\n");
    printf ("    -d       deal with directorys\n");
    printf ("             if neither is specified, deal with both\n");
    printf ("    -h       Also find hidden directories and files\n");
    printf ("    -p[rint] print the pathnames on stdout\n");
    printf ("    [cmd]    optional command and arguments. \n");

    exit (1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\wav-gen\gen-wav.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       gen-wav.c
//
//--------------------------------------------------------------------------



#include "stdio.h"
#include "stdlib.h"
#include "windows.h"
// #include "ntddk.h"


//
// MAX is defined to prevent overflow errors
// floor( (0xffffffff - 54)/(4*44100) )
//

#define MAX_SECONDS     24347
#define SAMPLE_STEP         1


VOID
__cdecl
    WriteIncreasingSawTooth(
        FILE *  OutFile,
        ULONG32 NumberOfSeconds
        )
{
    ULONG32 i;
    ULONG32 currentSample = 0;
    ULONG32 samples = 44100 * NumberOfSeconds;

    for ( i = 0; i < samples; i++ ) {
        putc( (currentSample >> 0) & 0xff, OutFile );
        putc( (currentSample >> 8) & 0xff, OutFile );
        putc( (currentSample >> 0) & 0xff, OutFile );
        putc( (currentSample >> 8) & 0xff, OutFile );

        currentSample += SAMPLE_STEP;
    }

}

VOID
__cdecl
    WriteDecreasingSawTooth(
        FILE *  OutFile,
        ULONG32 NumberOfSeconds
        )
{
    ULONG32 i;
    ULONG32 currentSample = 0;
    ULONG32 samples = 44100 * NumberOfSeconds;

    for ( i = 0; i < samples; i++ ) {
        putc( (currentSample >> 0) & 0xff, OutFile );
        putc( (currentSample >> 8) & 0xff, OutFile );
        putc( (currentSample >> 0) & 0xff, OutFile );
        putc( (currentSample >> 8) & 0xff, OutFile );

        currentSample -= SAMPLE_STEP;
    }
}

VOID
__cdecl
    WriteTriangle(
        FILE *  OutFile,
        ULONG32 NumberOfSeconds
        )
{
    ULONG32 i;
    ULONG32 samples       = 44100 * NumberOfSeconds;
    ULONG32 increasing    = TRUE;
    LONG32  currentSample = 0;
    LONG32  highestSample = 0x00007fff - SAMPLE_STEP + 1;
    LONG32  lowestSample =  0xffff8000 + SAMPLE_STEP - 1;

    for ( i = 0; i < samples; i++ ) {
        putc( (currentSample >> 0) & 0xff, OutFile );
        putc( (currentSample >> 8) & 0xff, OutFile );
        putc( (currentSample >> 0) & 0xff, OutFile );
        putc( (currentSample >> 8) & 0xff, OutFile );

        if ( increasing == TRUE &&
             currentSample >= highestSample
             ) {
            increasing = FALSE;
        }
        if ( increasing == FALSE &&
             currentSample <= lowestSample
             ) {
            increasing = TRUE;
        }
        if ( increasing == TRUE ) {
            currentSample += SAMPLE_STEP;
        } else {
            currentSample -= SAMPLE_STEP;
        }
    }
}


VOID
__cdecl
    WriteHeader(
        FILE *  OutFile,
        ULONG32 NumberOfSeconds
        )
{
    unsigned char header[] = {
        0x52, 0x49, 0x46, 0x46,  0x00, 0x00, 0x00, 0x00,  //  0- 7
        0x57, 0x41, 0x56, 0x45,  0x66, 0x6D, 0x74, 0x20,  //  8-15
        0x12, 0x00, 0x00, 0x00,  0x01, 0x00, 0x02, 0x00,  // 16-23
        0x44, 0xAC, 0x00, 0x00,  0x10, 0xB1, 0x02, 0x00,  // 24-31
        0x04, 0x00, 0x10, 0x00,  0x00, 0x00, 0x66, 0x61,  // 32-39
        0x63, 0x74, 0x04, 0x00,  0x00, 0x00, 0x00, 0x00,  // 40-47
        0x00, 0x00, 0x64, 0x61,  0x74, 0x61, 0x00, 0x00,  // 48-55
        0x00, 0x00                                        // 56-57 (length 58)
    };
    ULONG32 length;
    ULONG32 samples;
    ULONG32 other;
    ULONG32 i;

    //
    // setup the variable header info
    //
    // samples = 44100 * NumberOfSeconds
    // other   = (samples * 4) + 8
    // length  = other + 54

    samples =    44100 * NumberOfSeconds + 1;  // one extra sample?
    other   =  ((44100 * NumberOfSeconds + 1) * 4) + 4;
    length  = (((44100 * NumberOfSeconds + 1) * 4) + 4) + 50;

    //
    // Fill it in
    //

    header[4] = (length >>  0) & 0xff;
    header[5] = (length >>  8) & 0xff;
    header[6] = (length >> 16) & 0xff;
    header[7] = (length >> 24) & 0xff;

    header[46] = (samples >>  0) & 0xff;
    header[47] = (samples >>  8) & 0xff;
    header[48] = (samples >> 16) & 0xff;
    header[49] = (samples >> 24) & 0xff;

    header[54] = (other >>  0) & 0xff;
    header[55] = (other >>  8) & 0xff;
    header[56] = (other >> 16) & 0xff;
    header[57] = (other >> 24) & 0xff;

    for ( i = 0; i < sizeof(header); i++ ) {
        fprintf( OutFile, "%c", header[i] );
    }
}

/* 02b3c146
The header to a WAV file is as follows:

52 49 46 46 XX XX XX XX-57 41 56 45 66 6D 74 20
12 00 00 00 01 00 02 00-44 AC 00 00 10 B1 02 00
04 00 10 00 00 00 66 61-63 74 04 00 00 00 YY YY
YY YY 64 61 74 61 ZZ ZZ-ZZ ZZ

      XX XX XX XX    YY YY YY YY    ZZ ZZ ZZ ZZ
--------------------------------------------------------------
  1 = 46 b1 02 00    44 ac 00 00    14 b1 02 00 (0x2b110* +4)
  2 = 56 62 05 00    88 58 01 00    24 62 05 00 (0x2b110* +4)
267 = 46 c1 b3 02    44 f0 ac 00    14 c1 b3 02 (0x2b110* +4)


X = (length - 4) in reverse-byte order
    (eight is number of bytes including this part of the struct)
Y = number of samples (0xac44 == 44100 == 1 second)
Z = (# of seconds) * 0x02b1

*/

VOID
__inline
    WriteFooter(
        FILE *  OutFile
        )
{
    printf( "writing the footer\n" );
    putc( 0x50, OutFile );
    putc( 0xB5, OutFile );
    putc( 0x50, OutFile );
    putc( 0xB5, OutFile );
    putc( 0x00, OutFile );
    putc( 0x00, OutFile );
    putc( 0x00, OutFile );
    putc( 0x00, OutFile );
}



VOID
__cdecl
    main(
        int Argc,
        char ** Argv
        )
{
    FILE *  outFile;
    ULONG32 seconds;
    ULONG32 wavType = 1;
    CHAR    fileName[256];

    if ( Argc > 1 ) {

        //
        // try to get number seconds they want audio
        //

        seconds = atoi( Argv[1] );

        if ( Argc > 2 ) {

            //
            // get the type of wavform
            //

            wavType = atoi( Argv[2] );

        }

    }

    if ( Argc < 2                   ||
         Argc > 3                   ||
         strcmp(Argv[1], "-?") == 0 ||
         strcmp(Argv[1], "-h") == 0 ||
         seconds > MAX_SECONDS      ||
         wavType < 1                ||
         wavType > 3                ) {

        //
        // give usage help
        //

        printf( "\nUsage: %s seconds [wavtype]\n"
                "\tseconds must be a positive integer\n"
                "\tless than %d (prevents overflow)\n"
                "\twavtype can be one of three integers:\n"
                "\t\t1: increasing sawtooth (default)\n"
                "\t\t2: decreasing sawtooth\n"
                "\t\t3: triangular wav\n"
                "\n"
                , Argv[0]
                , MAX_SECONDS
                );
        exit(1);
    }
    switch( wavType ) {
        case 1:
            sprintf( fileName, "increase-%d.wav", seconds );
            printf( "Requesting %d seconds of increasing sawtooth wav output\n", seconds );
            outFile = fopen( fileName, "wb" );
            WriteHeader( outFile, seconds );
            WriteIncreasingSawTooth( outFile, seconds );
            WriteFooter( outFile );
            break;
        case 2:
            sprintf( fileName, "decrease-%d.wav", seconds );
            printf( "Requesting %d seconds of decreasing sawtooth wav output\n", seconds );
            outFile = fopen( fileName, "wb" );
            WriteHeader( outFile, seconds );
            WriteDecreasingSawTooth( outFile, seconds );
            WriteFooter( outFile );
            break;
        case 3:
            sprintf( fileName, "triangle-%d.wav", seconds );
            printf( "Requesting %d seconds of triangle wav output\n", seconds );
            outFile = fopen( fileName, "wb" );
            WriteHeader( outFile, seconds );
            WriteTriangle( outFile, seconds );
            WriteFooter( outFile );
            break;
        default:
            break;

    }
    exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\wcache\scsi.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    scsi.h

Abstract:

    These are the structures and defines that are used in the
    SCSI port and class drivers.

Authors:

    John Freeman (johnfr) 28-Mar-90
    Andre Vachon (andrev) 06-Jun-90
    Mike Glass (mglass)
    Jeff Havens (jhavens)

Revision History:

--*/
#ifndef _NTSCSI_
#define _NTSCSI_

//
// Define SCSI maximum configuration parameters.
//

#define SCSI_MAXIMUM_TARGETS 8
#define SCSI_MAXIMUM_LOGICAL_UNITS 8
#define SCSI_MAXIMUM_TARGETS_PER_BUS 32

#define MAXIMUM_CDB_SIZE 12

//
// Command Descriptor Block. Passed by SCSI controller chip over the SCSI bus
//

typedef union _CDB {

    //
    // Generic 6-Byte CDB
    //

    struct _CDB6GENERIC {
       UCHAR  OperationCode;
       UCHAR  Immediate : 1;
       UCHAR  CommandUniqueBits : 4;
       UCHAR  LogicalUnitNumber : 3;
       UCHAR  CommandUniqueBytes[3];
       UCHAR  Link : 1;
       UCHAR  Flag : 1;
       UCHAR  Reserved : 4;
       UCHAR  VendorUnique : 2;
    } CDB6GENERIC, *PCDB6GENERIC;

    //
    // Standard 6-byte CDB
    //

    struct _CDB6READWRITE {
        UCHAR OperationCode;
        UCHAR LogicalBlockMsb1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR LogicalBlockMsb0;
        UCHAR LogicalBlockLsb;
        UCHAR TransferBlocks;
        UCHAR Control;
    } CDB6READWRITE, *PCDB6READWRITE;


    //
    // SCSI Inquiry CDB
    //

    struct _CDB6INQUIRY {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR PageCode;
        UCHAR IReserved;
        UCHAR AllocationLength;
        UCHAR Control;
    } CDB6INQUIRY, *PCDB6INQUIRY;

    //
    // SCSI Format CDB
    //

    struct _CDB6FORMAT {
        UCHAR OperationCode;
        UCHAR FormatControl : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR FReserved1;
        UCHAR InterleaveMsb;
        UCHAR InterleaveLsb;
        UCHAR FReserved2;
    } CDB6FORMAT, *PCDB6FORMAT;

    //
    // Standard 10-byte CDB

    struct _CDB10 {
        UCHAR OperationCode;
        UCHAR RelativeAddress : 1;
        UCHAR Reserved1 : 2;
        UCHAR ForceUnitAccess : 1;
        UCHAR DisablePageOut : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR LogicalBlockByte0;
        UCHAR LogicalBlockByte1;
        UCHAR LogicalBlockByte2;
        UCHAR LogicalBlockByte3;
        UCHAR Reserved2;
        UCHAR TransferBlocksMsb;
        UCHAR TransferBlocksLsb;
        UCHAR Control;
    } CDB10, *PCDB10;

    //
    // CD Rom Audio CDBs
    //

    struct _PAUSE_RESUME {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[6];
        UCHAR Action;
        UCHAR Control;
    } PAUSE_RESUME, *PPAUSE_RESUME;

    //
    // Read Table of Contents
    //

    struct _READ_TOC {
        UCHAR OperationCode;
        UCHAR Reserved0 : 1;
        UCHAR Msf : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[4];
        UCHAR StartingTrack;
        UCHAR AllocationLength[2];
        UCHAR Control : 6;
        UCHAR Format : 2;
    } READ_TOC, *PREAD_TOC;

    struct _PLAY_AUDIO_MSF {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2;
        UCHAR StartingM;
        UCHAR StartingS;
        UCHAR StartingF;
        UCHAR EndingM;
        UCHAR EndingS;
        UCHAR EndingF;
        UCHAR Control;
    } PLAY_AUDIO_MSF, *PPLAY_AUDIO_MSF;

    //
    // Read SubChannel Data
    //

    struct _SUBCHANNEL {
        UCHAR OperationCode;
        UCHAR Reserved0 : 1;
        UCHAR Msf : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2 : 6;
        UCHAR SubQ : 1;
        UCHAR Reserved3 : 1;
        UCHAR Format;
        UCHAR Reserved4[2];
        UCHAR TrackNumber;
        UCHAR AllocationLength[2];
        UCHAR Control;
    } SUBCHANNEL, *PSUBCHANNEL;

    //
    // Mode sense
    //

    struct _MODE_SENSE {
        UCHAR OperationCode;
        UCHAR Reserved1 : 3;
        UCHAR Dbd : 1;
        UCHAR Reserved2 : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR PageCode : 6;
        UCHAR Pc : 2;
        UCHAR Reserved3;
        UCHAR AllocationLength;
        UCHAR Control;
    } MODE_SENSE, *PMODE_SENSE;

    //
    // Mode select
    //

    struct _MODE_SELECT {
        UCHAR OperationCode;
        UCHAR SPBit : 1;
        UCHAR Reserved1 : 3;
        UCHAR PFBit : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[2];
        UCHAR ParameterListLength;
        UCHAR Control;
    } MODE_SELECT, *PMODE_SELECT;

    struct _LOCATE {
        UCHAR OperationCode;
        UCHAR Immediate : 1;
        UCHAR CPBit : 1;
        UCHAR BTBit : 1;
        UCHAR Reserved1 : 2;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved3;
        UCHAR LogicalBlockAddress[4];
        UCHAR Reserved4;
        UCHAR Partition;
        UCHAR Control;
    } LOCATE, *PLOCATE;

    struct _LOGSENSE {
        UCHAR OperationCode;
        UCHAR SPBit : 1;
        UCHAR PPCBit : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR PageCode : 6;
        UCHAR PCBit : 2;
        UCHAR Reserved2;
        UCHAR Reserved3;
        UCHAR ParameterPointer[2];  // [0]=MSB, [1]=LSB
        UCHAR AllocationLength[2];  // [0]=MSB, [1]=LSB
        UCHAR Control;
    } LOGSENSE, *PLOGSENSE;

    struct _PRINT {
        UCHAR OperationCode;
        UCHAR Reserved : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransferLength[3];
        UCHAR Control;
    } PRINT, *PPRINT;

    struct _SEEK {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR LogicalBlockAddress[4];
        UCHAR Reserved2[3];
        UCHAR Control;
    } SEEK, *PSEEK;

    struct _ERASE {
        UCHAR OperationCode;
        UCHAR Long : 1;
        UCHAR Immediate : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[3];
        UCHAR Control;
    } ERASE, *PERASE;

    struct _START_STOP {
        UCHAR OperationCode;
        UCHAR Immediate: 1;
        UCHAR Reserved1 : 4;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[2];
        UCHAR Start : 1;
        UCHAR LoadEject : 1;
        UCHAR Reserved3 : 6;
        UCHAR Control;
    } START_STOP, *PSTART_STOP;

    struct _MEDIA_REMOVAL {
        UCHAR OperationCode;
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[2];
        UCHAR Prevent;
        UCHAR Control;
    } MEDIA_REMOVAL, *PMEDIA_REMOVAL;

    //
    // Tape CDBs
    //

    struct _SEEK_BLOCK {
        UCHAR OperationCode;
        UCHAR Immediate : 1;
        UCHAR Reserved1 : 7;
        UCHAR BlockAddress[3];
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved2 : 4;
        UCHAR VendorUnique : 2;
    } SEEK_BLOCK, *PSEEK_BLOCK;

    struct _REQUEST_BLOCK_ADDRESS {
        UCHAR OperationCode;
        UCHAR Reserved1[3];
        UCHAR AllocationLength;
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved2 : 4;
        UCHAR VendorUnique : 2;
    } REQUEST_BLOCK_ADDRESS, *PREQUEST_BLOCK_ADDRESS;

    struct _PARTITION {
        UCHAR OperationCode;
        UCHAR Immediate : 1;
        UCHAR Sel: 1;
        UCHAR PartitionSelect : 6;
        UCHAR Reserved1[3];
        UCHAR Control;
    } PARTITION, *PPARTITION;

    struct _WRITE_TAPE_MARKS {
        UCHAR OperationCode;
        UCHAR Immediate : 1;
        UCHAR WriteSetMarks: 1;
        UCHAR Reserved : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransferLength[3];
        UCHAR Control;
    } WRITE_TAPE_MARKS, *PWRITE_TAPE_MARKS;

    struct _SPACE_TAPE_MARKS {
        UCHAR OperationCode;
        UCHAR Code : 3;
        UCHAR Reserved : 2;
        UCHAR LogicalUnitNumber : 3;
        UCHAR NumMarksMSB ;
        UCHAR NumMarks;
        UCHAR NumMarksLSB;
        union {
            UCHAR value;
            struct {
                UCHAR Link : 1;
                UCHAR Flag : 1;
                UCHAR Reserved : 4;
                UCHAR VendorUnique : 2;
            } Fields;
        } Byte6;
    } SPACE_TAPE_MARKS, *PSPACE_TAPE_MARKS;

    //
    // Read tape position
    //

    struct _READ_POSITION {
        UCHAR Operation;
        UCHAR BlockType:1;
        UCHAR Reserved1:4;
        UCHAR Lun:3;
        UCHAR Reserved2[7];
        UCHAR Control;
    } READ_POSITION, *PREAD_POSITION;

    //
    // ReadWrite for Tape
    //

    struct _CDB6READWRITETAPE {
        UCHAR OperationCode;
        UCHAR VendorSpecific : 5;
        UCHAR Reserved : 3;
        UCHAR TransferLenMSB;
        UCHAR TransferLen;
        UCHAR TransferLenLSB;
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved1 : 4;
        UCHAR VendorUnique : 2;
     } CDB6READWRITETAPE, *PCDB6READWRITETAPE;

} CDB, *PCDB;

//
// Command Descriptor Block constants.
//

#define CDB6GENERIC_LENGTH                   6
#define CDB10GENERIC_LENGTH                  10

#define SETBITON                             1
#define SETBITOFF                            0
//
// Mode Sense/Select page constants.
//

#define MODE_PAGE_ERROR_RECOVERY        0x01
#define MODE_PAGE_DISCONNECT            0x02
#define MODE_PAGE_FORMAT_DEVICE         0x03
#define MODE_PAGE_RIGID_GEOMETRY        0x04
#define MODE_PAGE_FLEXIBILE             0x05
#define MODE_PAGE_VERIFY_ERROR          0x07
#define MODE_PAGE_CACHING               0x08
#define MODE_PAGE_PERIPHERAL            0x09
#define MODE_PAGE_CONTROL               0x0A
#define MODE_PAGE_MEDIUM_TYPES          0x0B
#define MODE_PAGE_NOTCH_PARTITION       0x0C
#define MODE_SENSE_RETURN_ALL           0x3f
#define MODE_SENSE_CURRENT_VALUES       0x00
#define MODE_SENSE_CHANGEABLE_VALUES    0x40
#define MODE_SENSE_DEFAULT_VAULES       0x80
#define MODE_SENSE_SAVED_VALUES         0xc0
#define MODE_PAGE_DEVICE_CONFIG         0x10
#define MODE_PAGE_MEDIUM_PARTITION      0x11
#define MODE_PAGE_DATA_COMPRESS         0x0f

//
// SCSI CDB operation codes
//

#define SCSIOP_TEST_UNIT_READY     0x00
#define SCSIOP_REZERO_UNIT         0x01
#define SCSIOP_REWIND              0x01
#define SCSIOP_REQUEST_BLOCK_ADDR  0x02
#define SCSIOP_REQUEST_SENSE       0x03
#define SCSIOP_FORMAT_UNIT         0x04
#define SCSIOP_READ_BLOCK_LIMITS   0x05
#define SCSIOP_REASSIGN_BLOCKS     0x07
#define SCSIOP_READ6               0x08
#define SCSIOP_RECEIVE             0x08
#define SCSIOP_WRITE6              0x0A
#define SCSIOP_PRINT               0x0A
#define SCSIOP_SEND                0x0A
#define SCSIOP_SEEK6               0x0B
#define SCSIOP_TRACK_SELECT        0x0B
#define SCSIOP_SLEW_PRINT          0x0B
#define SCSIOP_SEEK_BLOCK          0x0C
#define SCSIOP_PARTITION           0x0D
#define SCSIOP_READ_REVERSE        0x0F
#define SCSIOP_WRITE_FILEMARKS     0x10
#define SCSIOP_FLUSH_BUFFER        0x10
#define SCSIOP_SPACE               0x11
#define SCSIOP_INQUIRY             0x12
#define SCSIOP_VERIFY6             0x13
#define SCSIOP_RECOVER_BUF_DATA    0x14
#define SCSIOP_MODE_SELECT         0x15
#define SCSIOP_RESERVE_UNIT        0x16
#define SCSIOP_RELEASE_UNIT        0x17
#define SCSIOP_COPY                0x18
#define SCSIOP_ERASE               0x19
#define SCSIOP_MODE_SENSE          0x1A
#define SCSIOP_START_STOP_UNIT     0x1B
#define SCSIOP_STOP_PRINT          0x1B
#define SCSIOP_LOAD_UNLOAD         0x1B
#define SCSIOP_RECEIVE_DIAGNOSTIC  0x1C
#define SCSIOP_SEND_DIAGNOSTIC     0x1D
#define SCSIOP_MEDIUM_REMOVAL      0x1E
#define SCSIOP_READ_CAPACITY       0x25
#define SCSIOP_READ                0x28
#define SCSIOP_WRITE               0x2A
#define SCSIOP_SEEK                0x2B
#define SCSIOP_LOCATE              0x2B
#define SCSIOP_WRITE_VERIFY        0x2E
#define SCSIOP_VERIFY              0x2F
#define SCSIOP_SEARCH_DATA_HIGH    0x30
#define SCSIOP_SEARCH_DATA_EQUAL   0x31
#define SCSIOP_SEARCH_DATA_LOW     0x32
#define SCSIOP_SET_LIMITS          0x33
#define SCSIOP_READ_POSITION       0x34
#define SCSIOP_SYNCHRONIZE_CACHE   0x35
#define SCSIOP_COMPARE             0x39
#define SCSIOP_COPY_COMPARE        0x3A
#define SCSIOP_WRITE_DATA_BUFF     0x3B
#define SCSIOP_READ_DATA_BUFF      0x3C
#define SCSIOP_CHANGE_DEFINITION   0x40
#define SCSIOP_READ_SUB_CHANNEL    0x42
#define SCSIOP_READ_TOC            0x43
#define SCSIOP_READ_HEADER         0x44
#define SCSIOP_PLAY_AUDIO          0x45
#define SCSIOP_PLAY_AUDIO_MSF      0x47
#define SCSIOP_PLAY_TRACK_INDEX    0x48
#define SCSIOP_PLAY_TRACK_RELATIVE 0x49
#define SCSIOP_PAUSE_RESUME        0x4B
#define SCSIOP_LOG_SELECT          0x4C
#define SCSIOP_LOG_SENSE           0x4D

//
// If the IMMED bit is 1, status is returned as soon
// as the operation is initiated. If the IMMED bit
// is 0, status is not returned until the operation
// is completed.
//

#define CDB_RETURN_ON_COMPLETION   0
#define CDB_RETURN_IMMEDIATE       1

//
// CDB Force media access used in extended read and write commands.
//

#define CDB_FORCE_MEDIA_ACCESS 0x08

//
// Denon CD ROM operation codes
//

#define SCSIOP_DENON_EJECT_DISC    0xE6
#define SCSIOP_DENON_STOP_AUDIO    0xE7
#define SCSIOP_DENON_PLAY_AUDIO    0xE8
#define SCSIOP_DENON_READ_TOC      0xE9
#define SCSIOP_DENON_READ_SUBCODE  0xEB

//
// SCSI Bus Messages
//

#define SCSIMESS_ABORT                0x06
#define SCSIMESS_ABORT_WITH_TAG       0x0D
#define SCSIMESS_BUS_DEVICE_RESET     0X0C
#define SCSIMESS_CLEAR_QUEUE          0X0E
#define SCSIMESS_COMMAND_COMPLETE     0X00
#define SCSIMESS_DISCONNECT           0X04
#define SCSIMESS_EXTENDED_MESSAGE     0X01
#define SCSIMESS_IDENTIFY             0X80
#define SCSIMESS_IDENTIFY_WITH_DISCON 0XC0
#define SCSIMESS_IGNORE_WIDE_RESIDUE  0X23
#define SCSIMESS_INITIATE_RECOVERY    0X0F
#define SCSIMESS_INIT_DETECTED_ERROR  0X05
#define SCSIMESS_LINK_CMD_COMP        0X0A
#define SCSIMESS_LINK_CMD_COMP_W_FLAG 0X0B
#define SCSIMESS_MESS_PARITY_ERROR    0X09
#define SCSIMESS_MESSAGE_REJECT       0X07
#define SCSIMESS_NO_OPERATION         0X08
#define SCSIMESS_HEAD_OF_QUEUE_TAG    0X21
#define SCSIMESS_ORDERED_QUEUE_TAG    0X22
#define SCSIMESS_SIMPLE_QUEUE_TAG     0X20
#define SCSIMESS_RELEASE_RECOVERY     0X10
#define SCSIMESS_RESTORE_POINTERS     0X03
#define SCSIMESS_SAVE_DATA_POINTER    0X02
#define SCSIMESS_TERMINATE_IO_PROCESS 0X11

//
// SCSI Extended Message operation codes
//

#define SCSIMESS_MODIFY_DATA_POINTER  0X00
#define SCSIMESS_SYNCHRONOUS_DATA_REQ 0X01
#define SCSIMESS_WIDE_DATA_REQUEST    0X03

//
// SCSI Extended Message Lengths
//

#define SCSIMESS_MODIFY_DATA_LENGTH   5
#define SCSIMESS_SYNCH_DATA_LENGTH    3
#define SCSIMESS_WIDE_DATA_LENGTH     2

//
// SCSI extended message structure
//

#pragma pack (1)
typedef struct _SCSI_EXTENDED_MESSAGE {
    UCHAR InitialMessageCode;
    UCHAR MessageLength;
    UCHAR MessageType;
    union _EXTENDED_ARGUMENTS {

        struct {
            UCHAR Modifier[4];
        } Modify;

        struct {
            UCHAR TransferPeriod;
            UCHAR ReqAckOffset;
        } Synchronous;

        struct{
            UCHAR Width;
        } Wide;
    }ExtendedArguments;
}SCSI_EXTENDED_MESSAGE, *PSCSI_EXTENDED_MESSAGE;
#pragma pack ()

//
// SCSI bus status codes.
//

#define SCSISTAT_GOOD                  0x00
#define SCSISTAT_CHECK_CONDITION       0x02
#define SCSISTAT_CONDITION_MET         0x04
#define SCSISTAT_BUSY                  0x08
#define SCSISTAT_INTERMEDIATE          0x10
#define SCSISTAT_INTERMEDIATE_COND_MET 0x14
#define SCSISTAT_RESERVATION_CONFLICT  0x18
#define SCSISTAT_COMMAND_TERMINATED    0x22
#define SCSISTAT_QUEUE_FULL            0x28

//
// Enable Vital Product Data Flag (EVPD)
// used with INQUIRY command.
//

#define CDB_INQUIRY_EVPD           0x01

//
// Defines for format CDB
//

#define LUN0_FORMAT_SAVING_DEFECT_LIST 0
#define USE_DEFAULTMSB  0
#define USE_DEFAULTLSB  0

#define START_UNIT_CODE 0x01
#define STOP_UNIT_CODE  0x00

//
// Inquiry buffer structure. This is the data returned from the target
// after it receives an inquiry.
//
// This structure may be extended by the number of bytes specified
// in the field AdditionalLength. The defined size constant only
// includes fields through ProductRevisionLevel.
//
// The NT SCSI drivers are only interested in the first 36 bytes of data.
//

#define INQUIRYDATABUFFERSIZE 36

typedef struct _INQUIRYDATA {
    UCHAR DeviceType : 5;
    UCHAR DeviceTypeQualifier : 3;
    UCHAR DeviceTypeModifier : 7;
    UCHAR RemovableMedia : 1;
    UCHAR Versions;
    UCHAR ResponseDataFormat;
    UCHAR AdditionalLength;
    UCHAR Reserved[2];
    UCHAR SoftReset : 1;
    UCHAR CommandQueue : 1;
    UCHAR Reserved2 : 1;
    UCHAR LinkedCommands : 1;
    UCHAR Synchronous : 1;
    UCHAR Wide16Bit : 1;
    UCHAR Wide32Bit : 1;
    UCHAR RelativeAddressing : 1;
    UCHAR VendorId[8];
    UCHAR ProductId[16];
    UCHAR ProductRevisionLevel[4];
    UCHAR VendorSpecific[20];
    UCHAR Reserved3[40];
} INQUIRYDATA, *PINQUIRYDATA;

//
// Inquiry defines. Used to interpret data returned from target as result
// of inquiry command.
//
// DeviceType field
//

#define DIRECT_ACCESS_DEVICE            0x00    // disks
#define SEQUENTIAL_ACCESS_DEVICE        0x01    // tapes
#define PRINTER_DEVICE                  0x02    // printers
#define PROCESSOR_DEVICE                0x03    // scanners, printers, etc
#define WRITE_ONCE_READ_MULTIPLE_DEVICE 0x04    // worms
#define READ_ONLY_DIRECT_ACCESS_DEVICE  0x05    // cdroms
#define SCANNER_DEVICE                  0x06    // scanners
#define OPTICAL_DEVICE                  0x07    // optical disks
#define MEDIUM_CHANGER                  0x08    // jukebox
#define COMMUNICATION_DEVICE            0x09    // network
#define LOGICAL_UNIT_NOT_PRESENT_DEVICE 0x7F

//
// DeviceTypeQualifier field
//

#define DEVICE_CONNECTED 0x00

//
// Sense Data Format
//

typedef struct _SENSE_DATA {
    UCHAR ErrorCode:7;
    UCHAR Valid:1;
    UCHAR SegmentNumber;
    UCHAR SenseKey:4;
    UCHAR Reserved:1;
    UCHAR IncorrectLength:1;
    UCHAR EndOfMedia:1;
    UCHAR FileMark:1;
    UCHAR Information[4];
    UCHAR AdditionalSenseLength;
    UCHAR CommandSpecificInformation[4];
    UCHAR AdditionalSenseCode;
    UCHAR AdditionalSenseCodeQualifier;
    UCHAR FieldReplaceableUnitCode;
    UCHAR SenseKeySpecific[3];
} SENSE_DATA, *PSENSE_DATA;

//
// Default request sense buffer size
//

#define SENSE_BUFFER_SIZE 18

//
// Sense codes
//

#define SCSI_SENSE_NO_SENSE         0x00
#define SCSI_SENSE_RECOVERED_ERROR  0x01
#define SCSI_SENSE_NOT_READY        0x02
#define SCSI_SENSE_MEDIUM_ERROR     0x03
#define SCSI_SENSE_HARDWARE_ERROR   0x04
#define SCSI_SENSE_ILLEGAL_REQUEST  0x05
#define SCSI_SENSE_UNIT_ATTENTION   0x06
#define SCSI_SENSE_DATA_PROTECT     0x07
#define SCSI_SENSE_BLANK_CHECK      0x08
#define SCSI_SENSE_UNIQUE           0x09
#define SCSI_SENSE_COPY_ABORTED     0x0A
#define SCSI_SENSE_ABORTED_COMMAND  0x0B
#define SCSI_SENSE_EQUAL            0x0C
#define SCSI_SENSE_VOL_OVERFLOW     0x0D
#define SCSI_SENSE_MISCOMPARE       0x0E
#define SCSI_SENSE_RESERVED         0x0F

//
// Additional tape bit
//

#define SCSI_ILLEGAL_LENGTH         0x20
#define SCSI_EOM                    0x40
#define SCSI_FILE_MARK              0x80

//
// Additional Sense codes
//

#define SCSI_ADSENSE_NO_SENSE       0x00
#define SCSI_ADSENSE_LUN_NOT_READY  0x04
#define SCSI_ADSENSE_ILLEGAL_COMMAND 0x20
#define SCSI_ADSENSE_ILLEGAL_BLOCK  0x21
#define SCSI_ADSENSE_INVALID_LUN    0x25
#define SCSI_ADSENSE_MUSIC_AREA     0xA0
#define SCSI_ADSENSE_DATA_AREA      0xA1
#define SCSI_ADSENSE_VOLUME_OVERFLOW 0xA7

#define SCSI_ADSENSE_NO_MEDIA_IN_DEVICE 0x3a
#define SCSI_ADWRITE_PROTECT        0x27
#define SCSI_ADSENSE_MEDIUM_CHANGED 0x28
#define SCSI_ADSENSE_BUS_RESET      0x29
#define SCSI_ADSENSE_TRACK_ERROR    0x14
#define SCSI_ADSENSE_SEEK_ERROR     0x15
#define SCSI_ADSENSE_REC_DATA_NOECC 0x17
#define SCSI_ADSENSE_REC_DATA_ECC   0x18

//
// Additional sense code qualifier
//

#define SCSI_SENSEQ_FORMAT_IN_PROGRESS 0x04
#define SCSI_SENSEQ_INIT_COMMAND_REQUIRED 0x02
#define SCSI_SENSEQ_MANUAL_INTERVENTION_REQUIRED 0x03
#define SCSI_SENSEQ_BECOMING_READY 0x01
#define SCSI_SENSEQ_FILEMARK_DETECTED 0x01
#define SCSI_SENSEQ_SETMARK_DETECTED 0x03
#define SCSI_SENSEQ_END_OF_MEDIA_DETECTED 0x02
#define SCSI_SENSEQ_BEGINNING_OF_MEDIA_DETECTED 0x04

//
// SCSI IO Device Control Codes
//

#define FILE_DEVICE_SCSI 0x0000001b

#define IOCTL_SCSI_EXECUTE_IN   ((FILE_DEVICE_SCSI << 16) + 0x0011)
#define IOCTL_SCSI_EXECUTE_OUT  ((FILE_DEVICE_SCSI << 16) + 0x0012)
#define IOCTL_SCSI_EXECUTE_NONE ((FILE_DEVICE_SCSI << 16) + 0x0013)

//
// Read Capacity Data - returned in Big Endian format
//

typedef struct _READ_CAPACITY_DATA {
    ULONG LogicalBlockAddress;
    ULONG BytesPerBlock;
} READ_CAPACITY_DATA, *PREAD_CAPACITY_DATA;


//
// Read Block Limits Data - returned in Big Endian format
// This structure returns the maximum and minimum block
// size for a TAPE device.
//

typedef struct _READ_BLOCK_LIMITS {
    UCHAR Reserved;
    UCHAR BlockMaximumSize[3];
    UCHAR BlockMinimumSize[2];
} READ_BLOCK_LIMITS_DATA, *PREAD_BLOCK_LIMITS_DATA;

//
// Mode data structures.
//

//
// Define Mode parameter header.
//

typedef struct _MODE_PARAMETER_HEADER {
    UCHAR ModeDataLength;
    UCHAR MediumType;
    UCHAR DeviceSpecificParameter;
    UCHAR BlockDescriptorLength;
}MODE_PARAMETER_HEADER, *PMODE_PARAMETER_HEADER;

#define MODE_FD_SINGLE_SIDE     0x01
#define MODE_FD_DOUBLE_SIDE     0x02
#define MODE_FD_MAXIMUM_TYPE    0x1E
#define MODE_DSP_FUA_SUPPORTED  0x10
#define MODE_DSP_WRITE_PROTECT  0x80

//
// Define the mode parameter block.
//

typedef struct _MODE_PARAMETER_BLOCK {
    UCHAR DensityCode;
    UCHAR NumberOfBlocks[3];
    UCHAR Reserved;
    UCHAR BlockLength[3];
}MODE_PARAMETER_BLOCK, *PMODE_PARAMETER_BLOCK;

//
// Define Disconnect-Reconnect page.
//

typedef struct _MODE_DISCONNECT_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR BufferFullRatio;
    UCHAR BufferEmptyRatio;
    UCHAR BusInactivityLimit[2];
    UCHAR BusDisconnectTime[2];
    UCHAR BusConnectTime[2];
    UCHAR MaximumBurstSize[2];
    UCHAR DataTransferDisconnect : 2;
    UCHAR Reserved2[3];
}MODE_DISCONNECT_PAGE, *PMODE_DISCONNECT_PAGE;

//
// Define mode caching page.
//

typedef struct _MODE_CACHING_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR ReadDisableCache : 1;
    UCHAR MultiplicationFactor : 1;
    UCHAR WriteCacheEnable : 1;
    UCHAR Reserved2 : 5;
    UCHAR WriteRetensionPriority : 4;
    UCHAR ReadRetensionPriority : 4;
    UCHAR DisablePrefetchTransfer[2];
    UCHAR MinimumPrefectch[2];
    UCHAR MaximumPrefectch[2];
    UCHAR MaximumPrefectchCeil[2];
}MODE_CACHING_PAGE, *PMODE_CACHING_PAGE;

//
// Define mode flexible disk page.
//

typedef struct _MODE_FLEXIBLE_DISK_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR TransferRate[2];
    UCHAR NumberOfHeads;
    UCHAR SectorsPerTrack;
    UCHAR BytesPerSector[2];
    UCHAR NumberOfCylinders[2];
    UCHAR StartWritePrecom[2];
    UCHAR StartReducedCurrent[2];
    UCHAR StepRate[2];
    UCHAR StepPluseWidth;
    UCHAR HeadSettleDelay[2];
    UCHAR MotorOnDelay;
    UCHAR MotorOffDelay;
    UCHAR Reserved2 : 5;
    UCHAR MotorOnAsserted : 1;
    UCHAR StartSectorNumber : 1;
    UCHAR TrueReadySignal : 1;
    UCHAR StepPlusePerCyclynder : 4;
    UCHAR Reserved3 : 4;
    UCHAR WriteCompenstation;
    UCHAR HeadLoadDelay;
    UCHAR HeadUnloadDelay;
    UCHAR Pin2Usage : 4;
    UCHAR Pin34Usage : 4;
    UCHAR Pin1Usage : 4;
    UCHAR Pin4Usage : 4;
    UCHAR MediumRotationRate[2];
    UCHAR Reserved4[2];
}MODE_FLEXIBLE_DISK_PAGE, *PMODE_FLEXIBLE_DISK_PAGE;

//
// Define mode format page.
//

typedef struct _MODE_FORMAT_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR TracksPerZone[2];
    UCHAR AlternetSectorsPerZone[2];
    UCHAR AlternetTracksPerZone[2];
    UCHAR SectorsPerTrack[2];
    UCHAR BytesPerPhysicalSector[2];
    UCHAR Interleave[2];
    UCHAR TrackSkewFactor[2];
    UCHAR CylinderSkewFactor[2];
    UCHAR Reserved2 : 4;
    UCHAR SurfaceFirst : 1;
    UCHAR RemovableMedia : 1;
    UCHAR HardSectorFormating : 1;
    UCHAR SoftSectorFormating : 1;
    UCHAR Reserved3[2];
}MODE_FORMAT_PAGE, *PMODE_FORMAT_PAGE;

//
// Define rigid disk driver geometry page.
//

typedef struct _MODE_RIGID_GEOMETRY_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR NumberOfCylinders[2];
    UCHAR NumberOfHeads;
    UCHAR StartWritePrecom[2];
    UCHAR StartReducedCurrent[2];
    UCHAR DriveStepRate[2];
    UCHAR LandZoneCyclinder[2];
    UCHAR RotationalPositionLock : 2;
    UCHAR Reserved2 : 6;
    UCHAR RotationOffset;
    UCHAR Reserved3;
    UCHAR RoataionRate[2];
    UCHAR Reserved4[2];
}MODE_RIGID_GEOMETRY_PAGE, *PMODE_RIGID_GEOMETRY_PAGE;

//
// Define read write recovery page
//

typedef struct _MODE_READ_WRITE_RECOVERY_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR DCRBit : 1;
    UCHAR DTEBit : 1;
    UCHAR PERBit : 1;
    UCHAR EERBit : 1;
    UCHAR Reserved2 : 1;
    UCHAR TBBit : 1;
    UCHAR Reserved3 : 2;
    UCHAR ReadRetryCount;
    UCHAR Reserved4[4];
    UCHAR WriteRetryCount;
    UCHAR Reserved5[3];

} MODE_READ_WRITE_RECOVERY_PAGE, *PMODE_READ_WRITE_RECOVERY_PAGE;

//
// Mode parameter list block descriptor -
// set the block length for reading/writing
//
//

#define MODE_BLOCK_DESC_LENGTH               8

typedef struct _MODE_PARM_READ_WRITE {

   MODE_PARAMETER_HEADER  ParameterListHeader;  // List Header Format
   MODE_PARAMETER_BLOCK   ParameterListBlock;   // List Block Descriptor

} MODE_PARM_READ_WRITE_DATA, *PMODE_PARM_READ_WRITE_DATA;

//
// CDROM audio control (0x0E)
//

#define CDB_AUDIO_PAUSE 0
#define CDB_AUDIO_RESUME 1

#define CDB_DEVICE_START 0x11
#define CDB_DEVICE_STOP 0x10

#define CDB_EJECT_MEDIA 0x10
#define CDB_LOAD_MEDIA 0x01

#define CDB_SUBCHANNEL_HEADER      0x00
#define CDB_SUBCHANNEL_BLOCK       0x01

#define CDROM_AUDIO_CONTROL_PAGE   0x0E
#define MODE_SELECT_IMMEDIATE      0x04
#define MODE_SELECT_PFBIT          0x10

#define CDB_USE_MSF                0x01

typedef struct _PORT_OUTPUT {
    UCHAR ChannelSelection;
    UCHAR Volume;
} PORT_OUTPUT, *PPORT_OUTPUT;

typedef struct _AUDIO_OUTPUT {
    UCHAR CodePage;
    UCHAR ParameterLength;
    UCHAR Immediate;
    UCHAR Reserved[2];
    UCHAR LbaFormat;
    UCHAR LogicalBlocksPerSecond[2];
    PORT_OUTPUT PortOutput[4];
} AUDIO_OUTPUT, *PAUDIO_OUTPUT;

//
// Multisession CDROM
//

#define GET_LAST_SESSION 0x01
#define GET_SESSION_DATA 0x02;

//
// Tape definitions
//

typedef struct _TAPE_POSITION_DATA {
    UCHAR Reserved1:2;
    UCHAR BlockPositionUnsupported:1;
    UCHAR Reserved2:3;
    UCHAR EndOfPartition:1;
    UCHAR BeginningOfPartition:1;
    UCHAR PartitionNumber;
    USHORT Reserved3;
    UCHAR FirstBlock[4];
    UCHAR LastBlock[4];
    UCHAR Reserved4;
    UCHAR NumberOfBlocks[3];
    UCHAR NumberOfBytes[4];
} TAPE_POSITION_DATA, *PTAPE_POSITION_DATA;

//
// Byte reversing macro for converting
// between big- and little-endian formats
//

#define REVERSE_BYTES(Destination, Source) {                \
    (Destination)->Byte3 = (Source)->Byte0;                 \
    (Destination)->Byte2 = (Source)->Byte1;                 \
    (Destination)->Byte1 = (Source)->Byte2;                 \
    (Destination)->Byte0 = (Source)->Byte3;                 \
}

//
// This structure is used to convert little endian
// ULONGs to SCSI CDB 4 byte big endians values.
//

typedef struct _FOUR_BYTE {
    UCHAR Byte0;
    UCHAR Byte1;
    UCHAR Byte2;
    UCHAR Byte3;
} FOUR_BYTE, *PFOUR_BYTE;

//
// This macro has the effect of Bit = log2(Data)
//

#define WHICH_BIT(Data, Bit) {                      \
    for (Bit = 0; Bit < 32; Bit++) {                \
        if ((Data >> Bit) == 1) {                   \
            break;                                  \
        }                                           \
    }                                               \
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\wcache\wcache.c ===
#include <nt.h>
#include <ntddscsi.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <process.h>
#include <memory.h>
#include <string.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <scsi.h>

typedef struct _MODE_SENSE_PASS_THROUGH {
    SCSI_PASS_THROUGH Srb;
    ULONG             Reserved;
    UCHAR             SenseData[32];
    UCHAR             DataBuffer[256];

} MODE_SENSE_PASS_THROUGH, *PMODE_SENSE_PASS_THROUGH;


VOID
Usage(
   VOID
   );


int __cdecl
main( int argc, char **argv )
{
    ULONG              portNumber = 0;
    ULONG              physicalDrive = 0,
                       selectedDrive = 0xFFFFFFFF;

    HANDLE             volumeHandle,driveHandle;
    UNICODE_STRING     unicodeString;
    OBJECT_ATTRIBUTES  objectAttributes;
    NTSTATUS           ntStatus;
    PSCSI_ADAPTER_BUS_INFO  adapterInfo;
    PSCSI_BUS_DATA     busData;
    PSCSI_INQUIRY_DATA inquiryData;
    PINQUIRYDATA       deviceInquiryData;
    ULONG bytesTransferred;
    ULONG i, j;
    PCHAR              pageData,pch;
    UCHAR              modeOperation,
                       cacheSettings;
    INT                args;
    BOOLEAN            disableCache = FALSE,
                       enableCache = FALSE;
    BOOLEAN            displayAll = TRUE;
    UCHAR              buffer[32];
    UCHAR              driveBuffer[20];
    CHAR               driver[9];
    MODE_SENSE_PASS_THROUGH modeSenseData;



    if ( argc > 3 ) {
        Usage();
        exit(1);
    } else if (argc > 1 ) {

        displayAll = FALSE;

        args = 1;

        while ( args < argc ) {

            pch = argv[args];

            if ( *pch == '-' ) {
                BOOL exitSwitch = FALSE;
                pch++;
                switch( *pch ) {
                case 'd':
                    disableCache = TRUE;
                    break;
                case 'e':
                    enableCache = TRUE;
                    break;

                case '?':
                    Usage();
                    exit(1);
                    break;
                default:
                    Usage();
                    exit(1);
                }
                pch++;
            } else {
                if (!isdigit(*pch)) {
                    Usage();
                    exit(1);
                }
                selectedDrive = atol(pch);

            }
            args++;
        }
    }

    printf("\nDrive Port Bus TID LUN Vendor                   ReadCache WriteCache\n");
    printf(  "--------------------------------------------------------------------");
    while (TRUE) {

        memset( buffer, 0, sizeof( buffer ) );
        sprintf( buffer,"\\\\.\\Scsi%d:",portNumber);

        //
        // Open the volume with the DOS name.
        //

        volumeHandle = CreateFile(buffer,
                                  GENERIC_READ,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  OPEN_EXISTING,
                                  0,
                                  0);

        if( volumeHandle == INVALID_HANDLE_VALUE ) {
            break;
        }

        //
        // Allocate memory to store the inquiry data.
        //

        adapterInfo = (PSCSI_ADAPTER_BUS_INFO)malloc( 0x400 );

        if (adapterInfo == NULL) {
            printf( "Can't allocate memory for bus data\n" );
            CloseHandle( volumeHandle );
            return 1;
        }

        //
        // Issue device control to get configuration information.
        //

        if (!DeviceIoControl( volumeHandle,
                              IOCTL_SCSI_GET_INQUIRY_DATA,
                              NULL,
                              0,
                              adapterInfo,
                              0x400,
                              &bytesTransferred,
                              NULL)) {

            fprintf(stderr, "IOCTL_SCSI_GET_INQUIRY_DATA failed [Error %d].\n", GetLastError() );
            free(adapterInfo);
            CloseHandle( volumeHandle );
            return 2;
        }

        //
        // Display devices on buses.
        //

        for (i=0; i < adapterInfo->NumberOfBuses; i++) {

            busData = &adapterInfo->BusData[i];

            inquiryData = (PSCSI_INQUIRY_DATA)((PUCHAR)adapterInfo + busData->InquiryDataOffset);

            for (j=0; j<busData->NumberOfLogicalUnits; j++) {

                //
                // Make sure VendorId string is null terminated.
                //

                deviceInquiryData = (PINQUIRYDATA)&inquiryData->InquiryData[0];

                //
                // Determine the perpherial type.
                //

                if (deviceInquiryData->DeviceType == DIRECT_ACCESS_DEVICE) {

                    deviceInquiryData->ProductRevisionLevel[0] = '\0';
                    if (displayAll || (selectedDrive == physicalDrive)) {

                        printf("\n%2d    %2d   %2d  %2d  %2d ",
                                physicalDrive,
                                portNumber,
                                inquiryData->PathId,
                                inquiryData->TargetId,
                                inquiryData->Lun);

                        //
                        // Display product information.
                        //

                        printf(" %s", deviceInquiryData->VendorId);

                        //
                        // Open handle to the PhysicalDrive
                        //

                        sprintf(driveBuffer,"\\\\.\\PhysicalDrive%d",physicalDrive);

                        driveHandle = CreateFile(driveBuffer,
                                                 GENERIC_READ | GENERIC_WRITE,
                                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                                 NULL,
                                                 OPEN_EXISTING,
                                                 0,
                                                 NULL);

                        if (driveHandle == INVALID_HANDLE_VALUE) {
                            printf("CreateFile for %s failed. Error = %x\n",
                                    driveBuffer,
                                    GetLastError() );
                            return 3;
                        }


                        //
                        // Issue mode sense to see if caches are enabled.
                        //

                        ZeroMemory(&modeSenseData, sizeof(MODE_SENSE_PASS_THROUGH));

                        modeSenseData.Srb.Length = sizeof(SCSI_PASS_THROUGH);
                        modeSenseData.Srb.CdbLength = 6;
                        modeSenseData.Srb.DataIn = SCSI_IOCTL_DATA_IN;
                        modeSenseData.Srb.DataBufferOffset = offsetof(MODE_SENSE_PASS_THROUGH, DataBuffer);
                        modeSenseData.Srb.SenseInfoOffset = offsetof(MODE_SENSE_PASS_THROUGH, SenseData);
                        modeSenseData.Srb.DataTransferLength = 0xFF;
                        modeSenseData.Srb.TimeOutValue = 10;

                        ZeroMemory(&modeSenseData.Srb.Cdb, 16);

                        modeSenseData.Srb.Cdb[0] = 0x1A;
                        modeSenseData.Srb.Cdb[2] = 8;
                        modeSenseData.Srb.Cdb[4] = 0xFF;

                        if (!DeviceIoControl(driveHandle,
                                             IOCTL_SCSI_PASS_THROUGH_DIRECT,
                                             &modeSenseData,
                                             sizeof(modeSenseData),
                                             &modeSenseData,
                                             sizeof(modeSenseData),
                                             &bytesTransferred,
                                             FALSE)) {

                            fprintf(stderr,"Mode sense failed. Error = %x\n",
                                    GetLastError() );
                            return 4;
                        }

                        //
                        // Display current values
                        //

                        pageData = modeSenseData.DataBuffer;
                        (ULONG_PTR)pageData += 6 + pageData[3];
                        cacheSettings = *pageData;


                        if (displayAll || (physicalDrive == selectedDrive)) {
                            printf(" %s  ", (cacheSettings & 1) ? "Disabled" : "Enabled");
                            printf(" %s", (cacheSettings & 4) ? "Enabled" : "Disabled");
                        }

                        if ((enableCache || disableCache) && (physicalDrive == selectedDrive)) {

                            //
                            // Build mode select - caching page.
                            //
                            // Clean out reserved areas of data buffer and update others
                            //

                            modeSenseData.Srb.SenseInfoLength = 32;
                            pageData = modeSenseData.DataBuffer;
                            modeSenseData.Srb.Cdb[4] = *pageData + 1;
                            modeSenseData.Srb.Cdb[2] = 0x00;
                            modeSenseData.Srb.Cdb[1] = 0x11;
                            *pageData = 0;
                            (ULONG_PTR)pageData += 4 + pageData[3];
                            *pageData &= 0x3F;
                            pageData++;
                            pageData++;
                            *pageData &= 0x07;

                            modeSenseData.DataBuffer[5] = 0x00;
                            modeSenseData.DataBuffer[6] = 0x00;
                            modeSenseData.DataBuffer[7] = 0x00;



                            modeSenseData.Srb.DataIn = SCSI_IOCTL_DATA_OUT;
                            modeSenseData.Srb.DataTransferLength = modeSenseData.Srb.Cdb[4];

                            if (disableCache) {

                                //
                                // Disable write cache
                                //

                                *pageData &= 0x03;
                            } else {

                                //
                                // Enable the cache.
                                //

                                *pageData |= 0x04;
                            }

                            modeSenseData.Srb.Cdb[0] = 0x15;

                            if (!DeviceIoControl(driveHandle,
                                                 IOCTL_SCSI_PASS_THROUGH_DIRECT,
                                                 &modeSenseData,
                                                 sizeof(modeSenseData),
                                                 &modeSenseData,
                                                 sizeof(modeSenseData),
                                                 &bytesTransferred,
                                                 FALSE)) {

                                fprintf(stderr,"Mode select failed. Error = %x\n",
                                        GetLastError() );
                            } else {

                                printf("\nWrite cache successfully %s\n", (enableCache ? "Enabled" : "Disabled"));
                            }
                        }

                        CloseHandle(driveHandle );
                    }


                    physicalDrive++;
                }

                //
                // Get next device data.
                //

                inquiryData =
                    (PSCSI_INQUIRY_DATA)((PUCHAR)adapterInfo + inquiryData->NextInquiryDataOffset);

            }
        }

        free (adapterInfo);
        CloseHandle(volumeHandle );

        portNumber++;
    }

    printf("\n");
    return 0;
}


VOID Usage(
    VOID
) {
    fprintf(stderr,"WCACHE: Usage  wcache [-options] <PhysicalDrive Number>\n");
    fprintf(stderr,"\n");
    fprintf(stderr,"  where options are:   e - Enable Write Cache for the <PhysicalDrive>\n");
    fprintf(stderr,"                       d - Disable Write Cache for the  <PhysicalDrive>\n");
    fprintf(stderr,"  dumps current values for all drives when invoked with no options\n");
    fprintf(stderr,"\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\wcshdr\wcshdr.c ===
/* WCSHDR
 * generate UNICODE, ANSI & NEUTRAL typedefs and prototypes from a master file
 *
 * string% = string{W,A,}
 * LPTSTR% = {LPWSTR,LPSTR,LPTSTR}
 * TCHAR%  = {WCHAR,CHAR,TCHAR}
 * LPTCH%  = {LPWCH,LPCH,LPTCH}
 * If whitespace follows the symbol, a space is appended as required to
 * prevent shortening, and thus screwwing layout.
 *
 * History:
 *   04-Mar-1991 IanJa Wrote it.
 *   19-Mar-1991 IanJa Not all fgets() implementations append '\0' upon EOF.
 *   29-Mar-1991 IanJa Workaround NT fgets bug ("\r\n" not collapsed to "\n"),
 *                     & Command line, Usage and Version numbers added.
 *   13-May-1991 IanJa All neutrality achieved by #define - no neutral structs
 *   14-May-1991 IanJa Minor improvements to version display, help
 *   21-May-1991 IanJa Realloc() pbs->pStart when required
 *   27-May-1991 GregoryW bug fix, add LPTSTRID, LPTSTRNULL
 *   13-Jun-1991 IanJa Convert #define's too. Eg: #define Fn%(a) FnEx%(0, a)
 *   19-Jun-1991 IanJa improve #define treatment & simplify main loop
 *   12-Aug-1991 IanJa fix multi-line #defines, NEAR & FAR typedefs
 *   12-Aug-1991 IanJa fix braceless typedefs with %s; add LPTSTR2
 *   13-Aug-1991 IanJa add braceless typedefs #defines
 *   21-Aug-1991 IanJa fix string% substitutions for #defines
 *   21-Aug-1991 IanJa add BCHAR% -> BYTE or WCHAR as per BodinD request
 *   26-Aug-1991 IanJa init pbs->iType (NT-mode bug fix)
 *   26-Aug-1991 IanJa workaround NT fgets bug (CR LF not collapsed to NL)
 *   17-Nov-1992 v-griffk map #defines to typedef's on structs
 *               for debugger support
 *   08-Sep-1993 IanJa add pLastParen for complex function typedefs such as
 *               typedef BOOL ( CALLBACK * FOO% ) (BLAH% blah) ;
 *   24-Feb-1994 IanJa add CONV_FLUSH for blocks starting #if, #endif etc.
 *               #if (WINVER > 0x400)
 *               foo%(void);
 *               #endif
 *   11-Nov-1994 RaymondC propagate ;internal-ness to trailers
 */
char *Version = "WCSHDR v1.20 1994-11-11:";

#include <excpt.h>
#include <ntdef.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>

#define TRUE 1
#define FALSE 0

#define INITIAL_STORE_SIZE 2048
#define EXTRA_STORE_SIZE   1024
#define FN_NAME_SIZE       100

#define CONV_NONE       0
#define CONV_FN_PROTO   1
#define CONV_TYPEDEF    2
#define CONV_DEFINE     3
#define CONV_FLUSH      4

#define ASSERT(pbs, exp) if (!(exp)) AssertFail(__FILE__, __LINE__, pbs, #exp);

typedef int BOOL;
typedef char *PSZ;

typedef struct {
    char   *pStart;     // 1st char in store
    char   *pLastLine;  // 1st char of last line in store
    int    line;        // number of lines read

    char   *pEnd;       /* '\0' at end of store */
    size_t cbSize;
    size_t cbFree;

    int    iType;       // FnPrototype, Typedef, #define or none
    int    nParen;      // nesting index: ( & { increment; ) & } decrement
    char   *p1stParen;  // Pointer to first '(' or '{' in current block.
    char   *pLastParen; // Pointer to last '(' or '{' in current block.
    char  *pSymNam;     // copy of function name, null-terminated
    int    cbSymNam;    // bytes available for fn name
    char  *pszInternal; // "" if external or "\t// ;internal" if internal
} BLOCKSTORE, *PBLOCKSTORE;

void ArgProcess(int argc, PSZ argv[]);
void Usage(void);
void InitBS(PBLOCKSTORE);
void SetInternalnessBS(PBLOCKSTORE);
BOOL ReadLineBS(PBLOCKSTORE);
void WriteBS(PBLOCKSTORE);
void WriteAllTypesBS(PBLOCKSTORE, int);
int  ConversionRequiredBS(PBLOCKSTORE);
void GetSymNameBS(PBLOCKSTORE, int);
BOOL WriteRedefinedTypeNamesBS(PBLOCKSTORE);
void WriteConvertBS(PBLOCKSTORE, int, BOOL);
void EmptyBS(PBLOCKSTORE);
DECLSPEC_NORETURN void error_exit(PBLOCKSTORE pbs, int exitval);
void PrintSubstitute(PBLOCKSTORE, PSZ, PSZ, int, BOOL);

void AssertFail(PSZ pszfnam, int lineno, PBLOCKSTORE pbs, PSZ pszExp);

#define NEUT 0
#define ANSI 1
#define UNIC 2

/*
 * Command line flags
 */
int fDebug = FALSE;

void
__cdecl main(
    int argc,
    PSZ argv[])
{
    /*
     * block store.
     * lines from input are saved in here until we know
     * enough about how to process them.
     */
    BLOCKSTORE bs;
    int BlockType;

    ArgProcess(argc, argv);

    /*
     * buffer is empty
     */
    InitBS(&bs);
    if (fDebug) {
        fprintf(stderr, "About to start main loop\n");
    }

    while (ReadLineBS(&bs)) {
        /*
         * if line is blank then we have a complete block not requiring
         * any conversion.
         */
        if (bs.pLastLine[strspn(bs.pLastLine, " \t\r")] == '\n') {
            WriteBS(&bs);
            EmptyBS(&bs);

            continue;
        }

        if ((BlockType = ConversionRequiredBS(&bs)) != 0) {
            WriteAllTypesBS(&bs, BlockType);
        }
    }

    /*
     * Flush last BlockStore
     */
    WriteBS(&bs);
}

void
WriteAllTypesBS(PBLOCKSTORE pbs, int BlockType)
{
    if (fDebug) {
        fprintf(stderr, "WriteAllTypes(%p, %d)\n", pbs, BlockType);
    }

    switch (BlockType) {
    case CONV_NONE:
        /*
         * No conversion required, keep accumulating block.
         */
        return;

    case CONV_DEFINE:
    case CONV_FN_PROTO:
        SetInternalnessBS(pbs);
        GetSymNameBS(pbs, BlockType);

        WriteConvertBS(pbs, ANSI, TRUE);
        WriteConvertBS(pbs, UNIC, TRUE);

        ASSERT(pbs, pbs->pszInternal);
        /*
         * UNICODE defn.
         */
        fprintf(stdout, "#ifdef UNICODE%s\n#define %s  %sW%s\n",
                pbs->pszInternal, pbs->pSymNam, pbs->pSymNam, pbs->pszInternal);

        /*
         * ANSI defn.
         */
        fprintf(stdout, "#else%s\n#define %s  %sA%s\n",
                pbs->pszInternal, pbs->pSymNam, pbs->pSymNam, pbs->pszInternal);
        fprintf(stdout, "#endif // !UNICODE%s\n", pbs->pszInternal);

        /*
         * Neutral defn.
         */
        break;

    case CONV_TYPEDEF:
        SetInternalnessBS(pbs);
        WriteConvertBS(pbs, ANSI, FALSE);
        WriteConvertBS(pbs, UNIC, FALSE);
        WriteRedefinedTypeNamesBS(pbs);
        break;

    case CONV_FLUSH:
        WriteBS(pbs);
        EmptyBS(pbs);
        break;

    default:
        fprintf(stderr, "Don't understand block");
        error_exit(pbs, 2);
    }

    EmptyBS(pbs);
}

BOOL
ReadLineBS(PBLOCKSTORE pbs)
{
    int cbLine;
    if (fDebug) {
        fprintf(stderr, "ReadLineBS(%p)\n", pbs);
    }

    /*
     * Not all implementations of fgets() put a '\0' in the buffer upon EOF.
     * This will cause ReadLineBS() to leave the BlockStore untouched when
     * it returns FALSE.
     * We must ensure that BlockStore contents are valid whenever this routine
     * is called.  InitBS() and EmptyBS() must set contents to '\0' !!
     */
    if (fgets(pbs->pEnd, pbs->cbFree, stdin) == NULL) {
        return FALSE;
    }
    cbLine = strlen(pbs->pEnd);
    if (fDebug) {
        fprintf(stderr, "read %d characters: \"%s\"\n", cbLine, pbs->pEnd);
    }
    pbs->pLastLine = pbs->pEnd;
    pbs->pEnd += cbLine;
    pbs->cbFree -= cbLine;
    pbs->line++;
    if (pbs->cbFree <= 1) {
        PSZ p;
        p = realloc(pbs->pStart, pbs->cbSize + EXTRA_STORE_SIZE);

        /*
         * Fatal Errror if allocation failed
         */
        ASSERT(pbs, p != NULL);
        if (p == NULL) {
            fprintf(stderr, "Reallocate BlockStore to %d bytes failed",
                    pbs->cbSize + EXTRA_STORE_SIZE);
            error_exit(pbs, 2);
        }

        /*
         * adjust the pointers and counts
         */
        pbs->pLastLine = p + (pbs->pLastLine - pbs->pStart);
        pbs->pEnd      = p + (pbs->pEnd      - pbs->pStart);
        pbs->cbSize   += EXTRA_STORE_SIZE;
        pbs->cbFree   += EXTRA_STORE_SIZE;

        pbs->pStart = p;
    }
    return TRUE;
}

void
WriteBS(PBLOCKSTORE pbs)
{
    if (fDebug) {
        fprintf(stderr, "WriteBS(%p)\n", pbs);
    }
    fputs(pbs->pStart, stdout);
}

/*
 * Each time a new line is read in, this function is called to determine
 * whether a complete block has been accumulated for conversion and output.
 */
int
ConversionRequiredBS(PBLOCKSTORE pbs)
{
    PSZ p;

    if (fDebug) {
        fprintf(stderr, "ConversionRequiredBS(%p)\n", pbs);
    }

    if (pbs->iType == CONV_NONE) {
        if (strncmp(pbs->pStart, "#define", 7) == 0) {
            /*
             * The block starts with #define
             */
            pbs->iType = CONV_DEFINE;
        } else if (pbs->pStart[0] == '#') {
            /*
             * The block starts with #if, #else, #endif etc.
             */
            return CONV_FLUSH;
        }
    }

    if (pbs->iType != CONV_DEFINE) {
        /*
         * Scan this line for parentheses and braces to identify
         * a complete Function Prototype or Structure definition.
         * NOTE: comments containing unbalanced parentheses or braces
         *       will mess this up!
         */
        for (p = pbs->pLastLine; p <= pbs->pEnd; p++) {
            if ((*p == '(') || (*p == '{')) {
                pbs->pLastParen = p;
                if (pbs->p1stParen == NULL) {
                    pbs->p1stParen = p;
                }
                pbs->nParen++;
            } else if ((*p == ')') || (*p == '}')) {
                pbs->nParen--;
            }

            if ((*p == ';') && (pbs->nParen == 0)) {
                /*
                 * We have a function prototype or a typedef
                 * (Balanced brackets and a semi-colon)
                 */
                if (pbs->p1stParen && *(pbs->p1stParen) == '(') {
                    pbs->iType = CONV_FN_PROTO;
                } else {
                    pbs->iType = CONV_TYPEDEF;
                }
                goto CheckPercents;
            }
        }
        /*
         * Not a #define, nor a complete Typedef or Function prototype.
         */
        if (fDebug) {
            fprintf(stderr, "  CONV_NONE (incomplete fn.proto/typedef)\n");
        }
        return CONV_NONE;

    } else if (pbs->iType == CONV_DEFINE) {
        /*
         * We know the block is a #define - we must detect the end
         * (it can extend for more than one line using backslashes)
         */
        if ((p = strrchr(pbs->pStart, '\\')) != NULL) {
            /*
             * There is a backslash on the line: if is it the last
             * non-whitespace character on the line, then this #define
             * is continuing on to the next line.
             */
            p++;
            p += strspn(p, " \t\r\n");
            if (*p == '\0') {
                /*
                 * No conversion required *yet*. Continue accumulating
                 * the multi-line #define statement.
                 */
                if (fDebug) {
                    fprintf(stderr, "  CONV_NONE (incomplete #define)\n");
                }
                return CONV_NONE;  // ...yet
            }
        }
    }

CheckPercents:
    /*
     * We have a complete block of known type pbs->iType.  We will need
     * to convert this block if it contains any %'s, so search for '%'
     */
    p = pbs->pStart;
    while ((p = strchr(p, '%')) != NULL) {
        if (!isalnum(p[1])) {
            if (fDebug) {
                fprintf(stderr, "  return %d (%% found)\n", pbs->iType);
            }
            return pbs->iType;
        }

        /*
         * We found a %, but it followed by an alphanumeric character,
         * so can't require wcshdr.exe substitution.  Look for more '%'s
         */
        p++;
    }

    if (fDebug) {
        fprintf(stderr, "  CONV_FLUSH (no %%'s)\n");
    }
    return CONV_FLUSH;
}

BOOL
GetDefinedNameBS(PBLOCKSTORE pbs) {
    PSZ pPercent = pbs->p1stParen - 1;
    PSZ pStartNam;

    if (fDebug) {
        fprintf(stderr, "GetDefinedNameBS(%p)\n", pbs);
    }
    /*
     * Scan forwards for name (starting from beyond the "#define")
     */
    pStartNam = pbs->pStart + 7;
    while (isspace(*pStartNam)) {
        pStartNam++;
    }

    /*
     * Scan forwards for '%', starting at beginning of literal name
     */
    for (pPercent = pStartNam; *pPercent; pPercent++) {
        if (*pPercent == '%') {
            /*
             * Make sure we have enough space to store the literal name
             */
            if ((pPercent - pStartNam) > pbs->cbSymNam) {
                fprintf(stderr, "REALLOCATE DEFINED NAME BUFFER!");
                error_exit(pbs, 2);
            }
            /*
             * store the literal name
             */
            *pPercent = '\0';
            strcpy(pbs->pSymNam, pStartNam);
            *pPercent = '%';
            return TRUE;
        }
    }

    /*
     * didn't find percent!
     */
    fprintf(stderr, "DEFINED NAME ???");
    error_exit(pbs, 2);
}

BOOL
GetFnNameBS(PBLOCKSTORE pbs)
{
    PSZ pPercent = pbs->pLastParen - 1;
    PSZ pStartNam;

    if (fDebug) {
        fprintf(stderr, "GetFnNameBS(%p)\n", pbs);
    }
    /*
     * Scan backwards for '%'
     */
    while (*pPercent != '%') {
        if (--pPercent <= pbs->pStart) {
            fprintf(stderr, "FUNCTION NAME ???");
            error_exit(pbs, 2);
        }
    }

    /*
     * Scan back for start of function name
     */
    for (pStartNam = pPercent - 1; pStartNam >= pbs->pStart; pStartNam--) {
        if (!isalnum(*pStartNam) && *pStartNam != '_')
            break;
    }
    pStartNam++;

    /*
     * Make sure we have enough space to store the function name
     */
    if ((pPercent - pStartNam) > pbs->cbSymNam) {
        fprintf(stderr, "REALLOCATE FN NAME BUFFER!");
        error_exit(pbs, 2);
    }

    /*
     * store the function name
     */
    *pPercent = '\0';
    strcpy(pbs->pSymNam, pStartNam);
    *pPercent = '%';
    return TRUE;
}

void
GetSymNameBS(PBLOCKSTORE pbs, int iType)
{
   if (iType == CONV_DEFINE) {
       GetDefinedNameBS(pbs);
   } else {
       GetFnNameBS(pbs);
   }
}

BOOL
WriteRedefinedTypeNamesBS(PBLOCKSTORE pbs)
{
    PSZ pFirstName = NULL;
    PSZ pToken;
    PSZ pPercent;
    BOOL fSkipFirst;

    if (fDebug) {
        fprintf(stderr, "WriteRedefinedTypeNamesBS(%p)\n", pbs);
    }

    ASSERT(pbs, pbs->pszInternal);

    if (pbs->p1stParen && (*(pbs->p1stParen) == '{')) {
        /*
         * Scan backwards for the closing brace
         */
        for (pToken = pbs->pEnd; *pToken != '}'; pToken--) {
            if (pToken <= pbs->pStart) {
                /*
                 * No closing brace found!?
                 */
                fprintf(stderr, "CLOSING BRACE ???");
                error_exit(pbs, 2);
            }
        }
        pToken++;
        fSkipFirst = FALSE;
    } else {
        /*
         * skip past "typedef"
         */
        pToken = pbs->pStart + 7;

        /*
         * Skip the first name
         */
        fSkipFirst = TRUE;
    }

    /*
     * UNICODE pass
     */
    fprintf(stdout, "#ifdef UNICODE%s\n", pbs->pszInternal);
    while (pToken = strtok(pToken, ",; \t*\n\r")) {
        if (fDebug) {
            fprintf(stderr, "token: \"%s\"\n", pToken);
        }
        /*
         * Write out the #define for UNICODE, excluding "NEAR" & "FAR"
         */
        if (   (_stricmp(pToken, "NEAR") == 0)
            || (_stricmp(pToken, "FAR")  == 0)) {
            goto NextUnicodeToken;
        }

        if (fSkipFirst) {
            fSkipFirst = FALSE;
            goto NextUnicodeToken;
        } else if (pFirstName == NULL) {
            pFirstName = pToken;
        }

        pPercent = pToken + strlen(pToken) - 1;
        if (*pPercent == '%') {
            fprintf(stdout, "typedef ");
            PrintSubstitute(pbs, pToken, pPercent, UNIC, FALSE);
            fputs(" ", stdout);
            PrintSubstitute(pbs, pToken, pPercent, NEUT, FALSE);
            fprintf(stdout, ";%s\n", pbs->pszInternal);
        }

NextUnicodeToken:
        pToken = NULL;
    }

    if (pFirstName == NULL) {
        fprintf(stderr, "TYPE NAME ???");
        error_exit(pbs, 2);
    }

    fprintf(stdout, "#else%s\n", pbs->pszInternal);
    if (fDebug) {
        fprintf(stderr, "FirstName = %s\n", pFirstName);
    }

    /*
     * ANSI pass
     */
    pToken = pFirstName;
    while ((pToken += strspn(pToken, "%,; \t*\n\r")) < pbs->pEnd) {
        /*
         * Write out the #define for ANSI, excluding "NEAR" and "FAR"
         */
        if (   (_stricmp(pToken, "NEAR") == 0)
            || (_stricmp(pToken, "FAR")  == 0)) {
            goto NextAnsiToken;
        }

        pPercent = pToken + strlen(pToken) - 1;
        if (*pPercent == '%') {
            fprintf(stdout, "typedef ");
            PrintSubstitute(pbs, pToken, pPercent, ANSI, FALSE);
            fputs(" ", stdout);
            PrintSubstitute(pbs, pToken, pPercent, NEUT, FALSE);
            fprintf(stdout, ";%s\n", pbs->pszInternal);
        }

NextAnsiToken:
        while (*pToken++) {
            ;
        }
    }

    fprintf(stdout, "#endif // UNICODE%s\n", pbs->pszInternal);

    return TRUE;
}

void
WriteConvertBS(PBLOCKSTORE pbs, int Type, int fVertAlign)
{
    PSZ p = pbs->pStart;
    PSZ pPercent;

    if (fDebug) {
        fprintf(stderr, "WriteConvertBS(%p, %d, %d)\n", pbs, Type, fVertAlign);
    }
    while ((pPercent = strchr(p, '%')) != NULL) {
        if (isalnum(pPercent[1])) {
            goto ContinueSearch;
        }

        /*
         * print the substitution
         */
        PrintSubstitute(pbs, p, pPercent, Type, fVertAlign);

        /*
         * Advance beyond the %
         */
ContinueSearch:
        p = pPercent+1;
    }

    /*
     * Print remainder of store
     */
    fputs(p, stdout);
}

void
EmptyBS(PBLOCKSTORE pbs)
{
    if (fDebug) {
        fprintf(stderr, "EmptyBS(%p)\n", pbs);
    }
    pbs->pEnd = pbs->pStart;
    pbs->pLastLine = pbs->pStart;
    pbs->cbFree = pbs->cbSize;
    if (pbs->pStart) {
        *(pbs->pStart) = '\0';
    }

    pbs->iType = CONV_NONE;
    pbs->p1stParen = NULL;
    pbs->pLastParen = NULL;
    pbs->nParen = 0;
    if (pbs->pSymNam) {
        *(pbs->pSymNam) = '\0';
    }
}

void
InitBS(PBLOCKSTORE pbs) {
    pbs->line = 0;
    pbs->pStart = malloc(INITIAL_STORE_SIZE);
    ASSERT(pbs, pbs->pStart != NULL);

    pbs->pLastLine = pbs->pStart;
    pbs->pEnd = pbs->pStart;
    *(pbs->pStart) = '\0';

    pbs->iType = CONV_NONE;
    pbs->p1stParen = NULL;
    pbs->pLastParen = NULL;
    pbs->nParen = 0;
    pbs->pszInternal = 0;

    pbs->cbSize = INITIAL_STORE_SIZE;
    pbs->cbFree = INITIAL_STORE_SIZE;

    pbs->pSymNam = malloc(FN_NAME_SIZE);
    ASSERT(pbs, pbs->pSymNam != NULL);
    pbs->cbSymNam = FN_NAME_SIZE;
    *(pbs->pSymNam) = '\0';
}

void
SetInternalnessBS(PBLOCKSTORE pbs) {
    if (strstr(pbs->pStart, ";internal")) {
        pbs->pszInternal = "\t// ;internal";
    } else {
        pbs->pszInternal = "";
    }
}

void
AssertFail(
    PSZ pszfnam,
    int lineno,
    PBLOCKSTORE pbs,
    PSZ pszExp)
{
    fprintf(stderr, "ASSERT failed: file %s, line %d:\n", pszfnam, lineno);
    fprintf(stderr, "input line %d: \"%s\"\n", pbs->line, pszExp);
}

void
ArgProcess(
    int argc,
    PSZ argv[])
{
    int ArgIndex;
    PSZ pszArg;

    for (ArgIndex = 1; ArgIndex < argc; ArgIndex++) {

        pszArg = argv[ArgIndex];
        if ((*pszArg == '-') || (*pszArg == '/')) {
            switch (pszArg[1]) {
            case '?':
                fprintf(stderr, "%s\n", Version);
                Usage();
                exit(0);

            case 'd':
            case 'D':
                fDebug = TRUE;
                break;

            default:
                fprintf(stderr, "%s Invalid switch: %s\n", Version, pszArg);
                Usage();
                exit(1);
            }
        }
    }
}

void Usage(void)
{
    fprintf(stderr, "usage: WCSHDR [-?] display this message\n");
    fprintf(stderr, "              [-d] debug (to stderr)\n");
    fprintf(stderr, "              reads stdin, writes to stdout\n");
}

void
DECLSPEC_NORETURN
error_exit(PBLOCKSTORE pbs, int exitval) {
    fprintf(stderr, " (line %d)\n", pbs->line);
    exit(exitval);
}

/*
 * Substitutions performed on strings ending '%'
 *
 */

typedef struct {
    int  cchTemplate;
    PSZ pszTemplate;
    PSZ apszSub[3];
} SUBSTR, *PSUBSTR;

/*
 * Strings that are replaced:
 *   BCHAR%
 *   TCHAR%
 *   LPTCH%
 *   LPTSTR%
 *   LPTSTR2%
 *   LPTSTRID%
 *   LPTSTRNULL%
 *   %
 *
 * "%" MUST comes last (before the null terminator)
 *
 * The other strings must be ordered from sensibly:
 *    if FRED% came before BIGFRED% in Substrs[], then the Substitute()
 *    procedure would match input BIGFRED% to FRED%, not BIGFRED%.  The
 *    simplest way to avoid this is to arrange strings in descending lengths.
 */
SUBSTR Substrs[] = {
    { 10, "LPTSTRNULL%",  "LPTSTRNULL", "LPSTRNULL", "LPWSTRNULL" },
    {  8, "LPTSTRID%",    "LPTSTRID",   "LPSTRID",   "LPWSTRID"   },
    {  7, "LPTSTR2%",     "LPTSTR2",    "LPSTR2",    "LPWSTR2"    },
    {  7, "LPCTSTR%",     "LPCTSTR",    "LPCSTR",    "LPCWSTR"    },
    {  6, "LPTSTR%",      "LPTSTR",     "LPSTR",     "LPWSTR"     },
    {  5, "TCHAR%",       "TCHAR",      "CHAR",      "WCHAR"      },
    {  5, "BCHAR%",       "BCHAR",      "BYTE",      "WCHAR"      },
    {  5, "LPTCH%",       "LPTCH",      "LPCH",      "LPWCH"      },
    {  0, "%",            "",           "A",         "W"          },
    {  0, NULL,           NULL,          NULL,       NULL         }
};

PSZ special_pad[] = {
    " ",              // Neutral
    "  ",             // ANSI
    " "               // UNICODE
};

PSZ normal_pad[] = {
    " ",              // Neutral
    "",               // ANSI
    ""                // UNICODE
};

void PrintSubstitute(
    PBLOCKSTORE pbs,         // just for error reporting
    PSZ pStart,              // where to start substitution
    PSZ pPercent,            // ptr to '%' at end of input string
    int Type,                // NEUT, ANSI or UNIC
    BOOL fVertAlign)         // attempt  to maintain vertical alignment?
{
    PSUBSTR pSub;
    char  chTmp;
    PSZ pChangedPart = NULL;

    if (fDebug) {
        fprintf(stderr, "PrintSubstitute(%p, %p, %p, %d, %d)\n",
                pbs, pStart, pPercent, Type, fVertAlign);
    }

    for (pSub = Substrs; pSub->pszTemplate; pSub++) {
        int cch = pSub->cchTemplate;
        if ((pPercent - cch) < pStart) {
            continue;
        }
        if (strncmp(pPercent - cch, pSub->pszTemplate, cch+1) == 0) {
            pChangedPart = pPercent-cch;

            /*
             * print out unaltered bit
             */
            chTmp = *pChangedPart;
            *pChangedPart = '\0';
            fputs(pStart, stdout);
            *pChangedPart = chTmp;

            /*
             * print out replacement bit
             */
            fputs(pSub->apszSub[Type], stdout);
            break;
        }
    }
    if (pChangedPart == NULL) {
        /*
         * NO match was found in Substrs[] !!!
         */
        fprintf(stderr, "Can't substitute");
        error_exit(pbs, 2);
    }

    /*
     * preserve alignment if required.
     * (not for function prototypes, and only if whitespace follows
     */
    if (!fVertAlign &&
        ((pPercent[1] == ' ') || (pPercent[1] == '\t'))) {
        if (pChangedPart != pPercent) {
            fputs(special_pad[Type], stdout);
        } else {
            fputs(normal_pad[Type], stdout);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\who\who.cpp ===
/****************************** Module Header ******************************\
* Module Name: who.c
*
* Copyright (c) 1998, Microsoft Corporation
*
* Command line exchange lookup of phone and office numbers.
*
* History:
* 26-Mar-1998 vadimg    created
\***************************************************************************/

#include <stdio.h>
#include <locale.h>
#include <mapix.h>
#include <mapi.h>
#include <mapiwin.h>
#include <mapiutil.h>
#include <mapidefs.h>

#include <initguid.h>
#include <mapiguid.h>

#define DISPLAY_NAME                0
#define ACCOUNT                     1
#define BUSINESS_TELEPHONE_NUMBER   2
#define OFFICE_LOCATION             3

DWORD gdwCodePage;

void FreeRowSet(LPSRowSet psrs)
{
    ULONG i;
    for (i = 0; i < psrs->cRows; i++) {
        LPSPropValue pspv = psrs->aRow[i].lpProps;

        if (pspv != NULL) {
            MAPIFreeBuffer((LPVOID)pspv);
        }
    }
    MAPIFreeBuffer((LPVOID)psrs);
}

void PrintName(ULONG cProps, LPSPropValue rgspv)
{
    if (rgspv[DISPLAY_NAME].Value.err != MAPI_E_NOT_FOUND) {
        WCHAR buffW[30];
        int len;
        len = MultiByteToWideChar(CP_ACP,
                            0,
                            rgspv[DISPLAY_NAME].Value.lpszA,
                            -1,
                            buffW,
                            30);
        WideCharToMultiByte(gdwCodePage,
                            0,
                            buffW,
                            len,
                            rgspv[DISPLAY_NAME].Value.lpszA,
                            30, NULL, NULL);
        printf("%-25.23s", rgspv[DISPLAY_NAME].Value.lpszA);
    }
    if (rgspv[ACCOUNT].Value.err != MAPI_E_NOT_FOUND) {
        printf("%-17.15s", rgspv[ACCOUNT].Value.lpszA);
    }
    if (rgspv[BUSINESS_TELEPHONE_NUMBER].Value.err != MAPI_E_NOT_FOUND) {
        printf("%-22.21s", rgspv[BUSINESS_TELEPHONE_NUMBER].Value.lpszA);
    }
    if (rgspv[OFFICE_LOCATION].Value.err != MAPI_E_NOT_FOUND) {
        printf("%-15.15s", rgspv[OFFICE_LOCATION].Value.lpszA);
    }
    printf("\n");
}

BOOL PrintNames(LPSTR psz, LPSRowSet psrs)
{
    ULONG i;

    if (psrs->cRows == 0)
        return FALSE;

    for (i = 0; i < psrs->cRows; i++) {
        PrintName(psrs->aRow[i].cValues, psrs->aRow[i].lpProps);
    }
    return TRUE;
}

BOOL FindNames(LPMAPITABLE pmtb, char *psz)
{
    SRestriction sres;
    SPropValue spv;
    SizedSPropTagArray(4, rgspt) = {4, {PR_DISPLAY_NAME, PR_ACCOUNT,
            PR_BUSINESS_TELEPHONE_NUMBER, PR_OFFICE_LOCATION}};

    if (FAILED(pmtb->SetColumns((LPSPropTagArray)&rgspt, 0)))
        return FALSE;

    spv.ulPropTag = PR_ANR;
    spv.Value.lpszA = psz;

    sres.rt = RES_PROPERTY;
    sres.res.resProperty.relop = RELOP_EQ;
    sres.res.resProperty.ulPropTag = spv.ulPropTag;
    sres.res.resProperty.lpProp = &spv;

    if (FAILED(pmtb->Restrict(&sres, 0)))
        return FALSE;

    return TRUE;
}

BOOL GetGlobalAdressListTable(LPADRBOOK padb, LPMAPITABLE *ppmtb)
{
    ULONG ulType;
    IABContainer *pabc = NULL;
    LPMAPITABLE pmtb = NULL;
    LPSRowSet psrs = NULL;
    SRestriction sres;
    SPropValue spv;
    SizedSPropTagArray(1, rgspt) = {1, {PR_ENTRYID}};
    BOOL fRet = FALSE;

    if (FAILED(padb->OpenEntry(0, NULL, NULL, MAPI_BEST_ACCESS |
            MAPI_DEFERRED_ERRORS, &ulType, (LPUNKNOWN*)&pabc)))
        goto Cleanup;

    if (FAILED(pabc->GetHierarchyTable(MAPI_DEFERRED_ERRORS, &pmtb)))
        goto Cleanup;

    pabc->Release();
    pabc = NULL;

    spv.ulPropTag = PR_DISPLAY_NAME;
    spv.Value.lpszA = "Global Address List";

    sres.rt = RES_PROPERTY;
    sres.res.resProperty.relop = RELOP_EQ;
    sres.res.resProperty.ulPropTag = spv.ulPropTag;
    sres.res.resProperty.lpProp = &spv;

    if (FAILED(pmtb->FindRow(&sres, BOOKMARK_BEGINNING, 0)))
        goto Cleanup;

    if (FAILED(pmtb->SetColumns((LPSPropTagArray)&rgspt, 0)))
        goto Cleanup;

    if (FAILED(pmtb->QueryRows(1, 0, &psrs)))
        goto Cleanup;

    if (FAILED(padb->OpenEntry(psrs->aRow[0].lpProps[0].Value.bin.cb,
            (LPENTRYID)psrs->aRow[0].lpProps[0].Value.bin.lpb,
            NULL, MAPI_BEST_ACCESS | MAPI_DEFERRED_ERRORS, 
            &ulType, (LPUNKNOWN*)&pabc)))
        goto Cleanup;

    if (FAILED(pabc->GetContentsTable(MAPI_DEFERRED_ERRORS, ppmtb)))
        goto Cleanup;

    fRet = TRUE;

Cleanup:
    if (pmtb != NULL) {
        pmtb->Release();
    }
    if (pabc != NULL) {
        pabc->Release();
    }
    if (psrs != NULL) {
        FreeRowSet(psrs);
    }

    return fRet;
}

void PrintUsage(void)
{
    printf("Sample Usage:\n");
    printf("    who jane\n");
    printf("    who janed\n");
    printf("    who \"jane d\"\n");
}

int __cdecl main(int argc, char **argv)
{
    IMAPISession *pmss = NULL;
    LPADRBOOK padb = NULL;
    LPMAPITABLE pmtb;
    LPSRowSet psrs = NULL;
    ULONG cRows;
    BOOL fContinue;
    LPSTR psz = argv[1];
    char lBuf[6];

    if (argc == 1 || (argc == 2 && argv[1][0] == '-')) {
        PrintUsage();
        return 0;
    }

    gdwCodePage = GetConsoleOutputCP();
#if 0
    SetThreadLocale(MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
                         SORT_DEFAULT));
    sprintf(lBuf, ".%.6d", gdwCodePage);
    setlocale(LC_ALL, lBuf);
#endif

    if (FAILED(MAPIInitialize(NULL)))
        return 0;

    if (FAILED(MAPILogonEx(0, NULL, NULL, MAPI_ALLOW_OTHERS |
            MAPI_USE_DEFAULT, &pmss)))
        goto Cleanup;

    if (FAILED(pmss->OpenAddressBook(NULL, NULL, AB_NO_DIALOG, &padb)))
        goto Cleanup;

    if (!GetGlobalAdressListTable(padb, &pmtb))
        goto Cleanup;

    if (!FindNames(pmtb, psz))
        goto Cleanup;

    if (FAILED(pmtb->GetRowCount(0, &cRows)))
        goto Cleanup;

    do {

        if (FAILED(pmtb->QueryRows(cRows, 0, &psrs)))
            goto Cleanup;

        if (psrs == NULL)
            break;

        fContinue = PrintNames(psz, psrs);

        FreeRowSet(psrs);

    } while (fContinue);

Cleanup:
    if (padb != NULL) {
        padb->Release();
    }

    if (pmss != NULL) {
        pmss->Release();
    }

    MAPIUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\wc\wc.c ===
/*
 *      wc.c - counts lines, words and chars.  A word is defined as a
 *      maximal string of non-blank characters separated by blanks.
 */

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <process.h>
#include <windows.h>
#include <tools.h>
/*
 *      options flags
 */
int     lflg, wflg, cflg, tflg;
unsigned long sumlines, sumwords, sumchars;

void
usage()
{
        fprintf(stderr, "usage: wc [-lwc] [files]\n" );
        exit(EXIT_FAILURE);
}

void
wc( fh )
FILE *fh;
{
        unsigned long lines, words, chars;
        int ch, inword = 0;

        lines = words = chars = 0L;

        while (1)
        {
                if ((ch = getc(fh)) == EOF ) break;
                ++chars;

                if ( isspace(ch) )
                {
                        if ( inword )
                                inword = 0;
                        if ( ch == '\n' )
                                ++lines;
                        continue;
                }

                if ( isalnum(ch) && !inword )
                {
                        inword = 1;
                        ++words;
                }
        }

        if ( lflg ) printf(" %10lu", lines );
        if ( wflg ) printf(" %10lu", words );
        if ( cflg ) printf(" %10lu", chars );

        sumlines += lines;
        sumwords += words;
        sumchars += chars;

        return;
}

__cdecl
main(
    int argc,
    char **argv
    )
{
        FILE    *fh;
        char    *p;

        SHIFT( argc, argv );

        while ( argc > 0 && ( **argv == '-' || **argv == '/' ) )
        {
                p = *argv;
                while (*++p)
                {
                        switch(*p)
                        {
                        case 'l':
                                lflg++;
                                break;
                        case 'w':
                                wflg++;
                                break;
                        case 'c':
                                cflg++;
                                break;
                        case '?':
                        default:
                                usage();
                        }
                }
                SHIFT( argc, argv );
        }
        if (!(lflg||wflg||cflg)) lflg = wflg = cflg = 1;
        if ( argc > 1 ) tflg++;                 /* print totals */

        if ( argc == 0 )
        {
                wc( stdin );
                printf("\n");
        }
        else
        {
                while ( argc )
                {
                        if (( fh = fopen( *argv, "rb" )) == NULL )
                        {
                                perror( *argv );
                                SHIFT( argc, argv );
                                continue;
                        }

                        wc( fh );
                        fclose( fh );
                        printf ("\t%s\n", *argv );
                        SHIFT( argc, argv );
                }
                if ( tflg )
                {
                        if ( lflg ) printf(" %10lu", sumlines );
                        if ( wflg ) printf(" %10lu", sumwords );
                        if ( cflg ) printf(" %10lu", sumchars );
                        printf("\tTotals\n");
                }
        }
        return (EXIT_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\client\sendquit.c ===
/*
 * basic client for sumserve remote checksum server
 *
 *
 * sends the program exit command to the server named on the cmd line
 */

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <sumserve.h>
#include "ssclient.h"

extern int __argc;
extern char ** __argv;

/* program entry point
 *
 */
int PASCAL
WinMain (HANDLE hInstance, HANDLE hPrevInstance, LPSTR lpszCmdParam,
 		int nCmdShow)
{
	HANDLE hpipe;

	/* we expect one arg: the server name */

	if (__argc != 2) {

		printf("usage: sendquit <servername>");
		return(1);
	}

	hpipe = ss_connect(__argv[1]);
	if (hpipe == INVALID_HANDLE_VALUE) {
		printf("cannot connect to %s", __argv[1]);
		return(2);
	}

	ss_sendrequest(hpipe, SSREQ_EXIT, NULL, strlen(__argv[1])+1);

	CloseHandle(hpipe);
	return(0);
}

/* error output functions - called by the ssclient library functions
 *
 * defined here so the library can be called from cmdline and windows
 * programs.
 *
 */
BOOL
Trace_Error(LPSTR str, BOOL fCancel)
{
	printf("%s\n", str);
	return(TRUE);
}

/*
 * status update (eg retrying...)
 */
void
Trace_Status(LPSTR str)
{
	printf("%s\n", str);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\where\where.c ===
/* find where the various command arguments are from
 *
 * HISTORY:
 *	25-Jan-2000	a-anurag in the 'found' function changed the printf format of the year in the date from
 *				%d to %02d and did ptm->tm_year%100 to display the right year in 2 digits.
 *  06-Aug-1990    davegi  Added check for no arguments
 *  03-Mar-1987    danl    Update usage
 *  17-Feb-1987 BW  Move strExeType to TOOLS.LIB
 *  18-Jul-1986 DL  Add /t
 *  18-Jun-1986 DL  handle *. properly
 *                  Search current directory if no env specified
 *  17-Jun-1986 DL  Do look4match on Recurse and wildcards
 *  16-Jun-1986 DL  Add wild cards to $FOO:BAR, added /q
 *   1-Jun-1986 DL  Add /r, fix Match to handle pat ending with '*'
 *  27-May-1986 MZ  Add *NIX searching.
 *  30-Jan-1998 ravisp Add /Q
 *
 */

#define INCL_DOSMISC


#include <sys/types.h>
#include <sys\stat.h>
#include <ctype.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <stdio.h>
#include <windows.h>
#include <tools.h>
#include <stdarg.h>


// Function Forward Declarations...
void     __cdecl Usage( char *, ... );
int      found( char * );
int      Match( char *, char * );
void     look4match( char *, struct findType *, void * );
flagType chkdir( char *, va_list );

char const rgstrUsage[] = {
    "Usage: WHERE [/r dir] [/qte] pattern ...\n"
    "    /r - recurse starting with directory dir\n"
    "    /q - quiet, use exit code\n"
    "    /t - times, display size and time\n"
    "    /e - .EXE, display .EXE type\n"
    "    /Q - double quote the output\n"
    "    WHERE bar                 Find ALL bar along path\n"
    "    WHERE $foo:bar            Find ALL bar along foo\n"
    "    WHERE /r \\ bar            Find ALL bar on current drive\n"
    "    WHERE /r . bar            Find ALL bar recursing on current directory\n"
    "    WHERE /r d:\\foo\\foo bar   Find ALL bar recursing on d:\\foo\\foo\n"
    "        Wildcards, * ?, allowed in bar in all of above.\n"
};


flagType fQuiet   = FALSE;  /* TRUE, use exit code, no print out */
flagType fQuote   = FALSE;  /* TRUE, double quote the output */
flagType fAnyFound = FALSE;
flagType fRecurse = FALSE;
flagType fTimes = FALSE;
flagType fExe = FALSE;
flagType fFound;
flagType fWildCards;
flagType fHasDot;
struct _stat sbuf;
char *pPattern;                 /* arg to look4match, contains * or ?   */
char strDirFileExtBuf[MAX_PATH]; /* fully qualified file name            */
char *strDirFileExt = strDirFileExtBuf;
char strBuf[MAX_PATH];        /* hold curdir or env var expansion     */

/*  Usage takes a variable number of strings, terminated by zero,
    e.g. Usage ("first ", "second ", 0);
*/
void
__cdecl
Usage(
     char *p,
     ...
     )
{
    if (p) {
        va_list args;
        char *rgstr;
        va_start(args, p);
        rgstr = p;
        fputs("WHERE: ", stdout);
        while (rgstr) {
            fputs (rgstr, stdout);
            rgstr = va_arg(args, char *);
        }
        fputs ("\n", stdout);
        va_end(args);
    }
    puts(rgstrUsage);

    exit (1);
}

int
found (
      char *p
      )
{
    struct _stat sbuf;
    struct tm *ptm;

    fAnyFound = fFound = TRUE;
    if (!fQuiet) {
        if (fTimes) {
            if ( ( _stat(p, &sbuf) == 0 ) &&
                 ( ptm = localtime (&sbuf.st_mtime) ) ) {
                printf ("% 9ld  %2d-%02d-%02d  %2d:%02d%c  ", sbuf.st_size,
                        ptm->tm_mon+1, ptm->tm_mday, ptm->tm_year%100,
                        ( ptm->tm_hour > 12 ? ptm->tm_hour-12 : ptm->tm_hour ),
                        ptm->tm_min,
                        ( ptm->tm_hour >= 12 ? 'p' : 'a' ));
            } else {
                printf("        ?         ?       ?  " );
            }
        }
        if (fExe) {
            printf ("%-10s", strExeType(exeType(p)) );
        }
        if (fQuote) {
            printf ("\"%s\"\n",  p);
        } else {
            printf ("%s\n",  p );
        }
    }
    return( 0 );
}

int
Match (
      char *pat,
      char *text
      )
{
    switch (*pat) {
        case '\0':
            return *text == '\0';
        case '?':
            return *text != '\0' && Match (pat + 1, text + 1);
        case '*':
            do {
                if (Match (pat + 1, text))
                    return TRUE;
            } while (*text++);
            return FALSE;
        default:
            return toupper (*text) == toupper (*pat) && Match (pat + 1, text + 1);
    }
}


void
look4match (
           char *pFile,
           struct findType *b,
           void *dummy
           )
{
    char *p = b->fbuf.cFileName;

    if (!strcmp (p, ".") || !strcmp (p, "..") || !_strcmpi (p, "deleted"))
        return;

    /* if pattern has dot and filename does NOT ..., this handles case of
       where *. to look for files with no extensions */
    if (fHasDot && !*strbscan (p, ".")) {
        strcpy (strBuf, p);
        strcat (strBuf, ".");
        p = strBuf;
    }
    if (Match (pPattern, p))
        found (pFile);

    p = b->fbuf.cFileName;
    if (fRecurse && TESTFLAG (b->fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
        p = strend (pFile);
        strcat (p, "\\*.*");
        forfile (pFile, FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM, look4match, NULL);
        *p = '\0';
    }
}

flagType
chkdir (
       char *pDir,
       va_list pa
       )
/*
    pDir == dir name
    pa   == fileext
*/
{
    char *pFileExt = va_arg( pa, char* );

    if ( strDirFileExt == strDirFileExtBuf &&
         strlen(pDir) > sizeof(strDirFileExtBuf) ) {
        strDirFileExt = (char *)malloc(strlen(pDir)+1);
        if (!strDirFileExt) {
            strDirFileExt = strDirFileExtBuf;
            return FALSE;
        }
    }
    strcpy (strDirFileExt, pDir);
    /* if prefix does not have trailing path char */
    if (!fPathChr (strend(strDirFileExt)[-1]))
        strcat (strDirFileExt, PSEPSTR);
    if (fRecurse || fWildCards) {
        pPattern = pFileExt;    /* implicit arg to look4match */
        strcat (strDirFileExt, "*.*");
        forfile(strDirFileExt, FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM, look4match, NULL);
    } else {
        /* if file name has leading path char */
        if (fPathChr (*pFileExt))
            strcat (strDirFileExt, pFileExt+1);
        else
            strcat (strDirFileExt, pFileExt);
        if (_stat (strDirFileExt, &sbuf) != -1)
            found (strDirFileExt);
    }
    return FALSE;
}

int
__cdecl
main (
     int c,
     char *v[]
     )
{
    char *p, *p1, *p2;
    char *strDir;

    strDir = (char *)malloc(MAX_PATH);
    if (!strDir) {
        printf("Out of memory\n");
        exit(1);
    }

    ConvertAppToOem( c, v );
    SHIFT (c, v);

    while (c != 0 && fSwitChr (*(p = *v))) {
        while (*++p) {
            switch (*p) {
                case 'r':
                    fRecurse = TRUE;
                    SHIFT (c, v);
                    if (c) {
                        if ( rootpath (*v, strDir) ||
                             GetFileAttributes( strDir ) == -1 ) {
                            Usage ("Could not find directory ", *v, 0);
                        }
                    } else {
                        Usage ("No directory specified.", 0);
                    }
                    break;
                case 'q':
                    fQuiet = TRUE;
                    break;
                case 'Q':
                    fQuote = TRUE;
                    break;
                case 't':
                    fTimes = TRUE;
                    break;
                case 'e':
                    fExe = TRUE;
                    break;
                case '?':
                    Usage (0);
                    break;
                default:
                    Usage ("Bad switch: ", p, 0);
            }
        }
        SHIFT (c, v);
    }

    if (!c)
        Usage ("No pattern(s).", 0);

    while (c) {
        fFound = FALSE;
        p = _strlwr (*v);
        if (*p == '$') {
            if (fRecurse)
                Usage ("$FOO not allowed with /r", 0);
            if (*(p1=strbscan (*v, ":")) == '\0')
                Usage ("Missing \":\" in ", *v, 0);
            *p1 = 0;
            if ((p2 = getenvOem (_strupr (p+1))) == NULL) {
                rootpath (".", strDir);
                printf ("WHERE: Warning env variable \"%s\" is NULL, using current dir %s\n",
                        p+1, strDir);
            } else
                strcpy (strDir, p2);
            *p1++ = ':';
            p = p1;
        } else if (!fRecurse) {
            if ((p2 = getenvOem ("PATH")) == NULL)
                rootpath (".", strDir);
            else {

                //
                // if the path is longer than the allocated space for it, make more space
                // this is safe, it does not collide with the recurse case where strDir
                // is already set to something else
                //

                unsigned int length = strlen(p2) + 3;   // including .; and null
                if (length > MAX_PATH) {
                    strDir = (char *)realloc(strDir, length);
                }
                strcpy (strDir, ".;");
                strcat (strDir, p2);
            }
        }
        /* N.B. if fRecurse, then strDir was set in case 'r' above */

        if (!*p)
            Usage ("No pattern in ", *v, 0);

        /* strDir == cur dir or a FOO expansion */
        /* p    == filename, may have wild cards */
        /* does p contain wild cards */
        fWildCards = *strbscan (p, "*?");
        fHasDot    = *strbscan (p, ".");
        if (*(p2 = (strend (strDir) - 1)) == ';')
            /* prevents forsemi from doing enum with null str as last enum */
            *p2 = '\0';
        if (*strDir)
            forsemi (strDir, chkdir, p);

        if (!fFound && !fQuiet)
            printf ("Could not find %s\n", *v);
        SHIFT (c, v);
    }

    return( fAnyFound ? 0 : 1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\client\ssclient.c ===
#define trace
/*
 *
 * client library for remote checksum server
 *
 * functions for connecting to the server pipe, and reading
 * and writing messages.
 *
 *                !! DEBUG HINT: !!
 *
 * - ENABLE Trace_Stat and Trace_Fil about 30 lines below here
 *          so that they generate file output.
 *          F11 from Windiff will do the trick on a debug build version!
 *
 * expects Trace_Error() to be defined in the client program.
 */

#include <windows.h>
#include <lzexpand.h>
#include <stdio.h>
#include <string.h>
#include <gutils.h>
#include <list.h>
#include "..\server\sumserve.h"
#include "..\windiff\windiff.h"           // for TRACE_ERROR and Windiff_UI which it calls
#include "ssclient.h"

/* need to sort out header files                      !!! */
void SetNames(LPSTR names);           /* from Windiff !!! */
void SetStatus(LPSTR cmd);

ULONG ss_checksum_block(PSTR block, int size);
DWORD WINAPI ReceiveFiles(LPVOID handle);
#ifdef SOCKETS
BOOL GetFile(SOCKET hpipe, PSTR localpath, PSSNEWRESP  presp);
#else
BOOL GetFile(HANDLE hpipe, PSTR localpath, PSSNEWRESP  presp);
#endif
HANDLE ConnectPipe(PSTR pipename);

extern BOOL bTrace;      /* in Windiff.c */

int CountRetries = 5;


/* SOCKETS / NAMED PIPES macros
 */
#ifdef SOCKETS
#define CLOSEHANDLE( handle )   closesocket( handle )
#else
#define CLOSEHANDLE( handle )   CloseHandle( handle )
#endif


/*--------------------------- DEBUG FUNCTIONS ----------------------------*/
void Trace_Stat(LPSTR str)
{
        if (bTrace) {
                Trace_File(str);
                Trace_File("\n");
        }
        Trace_Status(str);
}/* Trace_Stat */


void Trace_Fil(LPSTR str)
{
        if (bTrace) {
                Trace_File(str);
        }
} /* Trace_Fil */

/*------------------------------------------------------------------------*/

static char MainPipeName[400];           /* pipe name for requests to server */
extern BOOL bAbort;                     /* abort flag from Windiff */

/* set up pipename for main pipe */
void InitPipeName(PSTR result, PSTR server, PSTR name)
{       sprintf(result, "\\\\%s\\pipe\\%s", server, name);
} /* InitPipeName */


/* ss_connect:
 * make a connection to the server.
 *
 * create the correct pipe name \\server\pipe\NPNAME,
 * connect to the pipe and set the pipe to message mode.
 *
 * return INVALID_HANDLE_VALUE if failure
 */
HANDLE
ss_connect(PSTR server)
{       char pipename[400];
        InitPipeName(pipename, server, NPNAME);
        return ConnectPipe(pipename);

} /* ss_connect */

VOID
ss_setretries(int retries)
{
    CountRetries = retries;
}


/* ss_connect:
 * make a connection to the pipe named.
 *
 * connect to the pipe and set the pipe to message mode.
 *
 * return INVALID_HANDLE_VALUE if failure
 */
HANDLE ConnectPipe(PSTR pipename)
{
        HANDLE hpipe;
        DWORD dwState;
        int i;
        BOOL haderror = FALSE;

        {       char msg[400];
                wsprintf(msg, "ConnectPipe to %s\n", pipename);
                Trace_Fil(msg);
        }

        for (; ; ){  /* repeat if user asks */
                int MsgBoxId;

                /* repeat connect attempt up to 5 times without asking. */
                for (i= 0; i < CountRetries; i++) {

                        if (bAbort) return INVALID_HANDLE_VALUE;

                        /* connect to the named pipe */
                        hpipe = CreateFile(pipename,
                                        GENERIC_READ|GENERIC_WRITE,
                                        FILE_SHARE_READ|FILE_SHARE_WRITE,
                                        NULL,
                                        OPEN_EXISTING,
                                        FILE_ATTRIBUTE_NORMAL,
                                        0);

                        if (hpipe != INVALID_HANDLE_VALUE) {
                                /* switch the pipe to message mode */
                                dwState = PIPE_WAIT | PIPE_READMODE_MESSAGE;

                                SetNamedPipeHandleState(hpipe, &dwState, NULL, NULL);

                                if (haderror) {
                                        Trace_Stat("connection ok");
                                }
                                {       char msg[80];
                                        wsprintf(msg, "ConnectedPipe hpipe %x\n", hpipe);
                                        Trace_Fil(msg);
                                }
                                return(hpipe);
                        }
                        else {
                                DWORD errorcode = GetLastError();
                                char msg[400];
                                wsprintf(msg, "Error %d on Create Pipe %s", errorcode, pipename);
                                Trace_Stat(msg);
                        }

                        /* connect failed - wait one seconds before retrying */
                        if (CountRetries > 1) {
                            Sleep(1000);
                        }

                        /*
                         * only report success with Trace_Stat if we also
                         * reported an error (don't disturb the user
                         * unnecessarily - he just see nothing unusual if all goes well
                         */
                        haderror = TRUE;
                        Trace_Stat("Retrying pipe connection...");

                } /* retry 5 loop */

                if (CountRetries > 1) {
                    windiff_UI(TRUE);
                    MsgBoxId = MessageBox( hwndClient
                                     , "Pipe connection failed 5 times.  Retry some more?"
                                     , "Windiff: Network connection error"
                                     , MB_RETRYCANCEL
                                     );
                    windiff_UI(FALSE);
                    if (MsgBoxId != IDRETRY)
                            break;
                } else {
                    break;
                }
        } /* ask loop */

        Trace_Fil("ConnectPipe failed");
        return(INVALID_HANDLE_VALUE);
} /* ConnectPipe */

/* build and send a request message to the server. Check for network
 * errors, and retry (unless the pipe is broken) up to 10 times.
 *
 * if write succeeds - return TRUE.
 * if failure - return FALSE to indicate connection is dropped.
 */
BOOL
ss_sendrequest(HANDLE hpipe, long lCode, PSTR szPath, int lenpath, DWORD dwFlags)
{
        SSNEWREQ req;
        int size, count, errorcode;

        Trace_Fil("ss_sendrequest\n");
        req.lCode = -lCode;   /* negative code for versions greater than 0 */
        req.lVersion = SS_VERSION;
        req.lRequest = LREQUEST;
        req.lFlags = dwFlags;
        if (szPath != NULL) {
                /* szPath may be more than one null-term string,
                 * so copy the bytes rather than a strcpy().
                 */
                for (size = 0; size < lenpath; size++) {
                        req.szPath[size] = szPath[size];
                }
        } else {
                req.szPath[0] = '\0';
        }

        /* trace stuff */
        {       char msg[80];
                wsprintf(msg, "Sending request: %d on pipe %x\n", req.lCode, hpipe);
                Trace_Fil(msg);
        }

        /* loop retrying the send until it goes ok */
        for (count = 0; count < CountRetries; count++) {

                if (bAbort) {
                        CloseHandle(hpipe);
                        return FALSE;
                }
#ifdef trace
        {       char msg[80];
                wsprintf(msg, "Actually sending on pipe %x... ", hpipe);
                Trace_Fil(msg);
        }
#endif
                if (WriteFile(hpipe, &req, sizeof(req), (LPDWORD)(&size), NULL)) {
#ifdef trace
                        {       char msg[80];
                                wsprintf(msg, "Sent req %d OK,  pipe %x\n", req.lCode, hpipe);
                                Trace_Fil(msg);
                        }
#endif

                        /* no error reported - was everything written?*/
                        if (size != sizeof(req)) {

                                /* write was NOT ok - report and retry */
                                if (!TRACE_ERROR("pipe write size differs... Retry?", TRUE)) {
                                    return(FALSE);
                                }

                                continue;
                        } else {
                                /* all ok */
                                char msg[80];
                                wsprintf(msg, "Request %d sent on %x\n", req.lCode, hpipe);
                                Trace_Fil(msg);
                                return(TRUE);
                        }
                }
#ifdef trace
                {       char msg[80];
                        wsprintf(msg, "!!Bad send pipe %x\n", hpipe);
                        Trace_Fil(msg);
                }
#endif

                /* an error occurred */
                switch( (errorcode = (int)GetLastError())) {

                case ERROR_NO_DATA:
                case ERROR_BROKEN_PIPE:
                        /* pipe connection lost - forget it */
                        Trace_Stat("pipe broken on write");
                        return(FALSE);

                default:
                        {       char msg[120];
                                wsprintf(msg, "pipe write error %d on pipe %x.  Retrying..."
                                        , errorcode, hpipe);
                                Trace_Stat(msg);
                        }
                        Sleep(count*1000);     /* total sleep possible is 45 sec */
                        break; /* from switch, not loop */
                }
        }

        /* retry count reached - abandon this attempt */
        TRACE_ERROR("retry count reached on pipe write error.", FALSE);
        return(FALSE);
} /* ss_sendrequest */

/* read a message from a pipe, allowing for network errors
 *
 * if error occurs, retry up to 10 times unless error code
 * indicates that pipe is broken - in which case, give up.
 *
 * return size read if all ok, -1 to mean the connection is broken,
 * abort this client, 0 to mean other error.
 */
int
ss_getblock(HANDLE hpipe, PSTR block, int blocksize)
{
        int count;
        int size;
        int errorcode;
        static BOOL PipeError = FALSE;
        char msg[80];

        wsprintf(msg, "ss_getblock.  hpipe=%x\n", hpipe);
        Trace_Fil(msg);
        /* retry up to 10 times */
        for (count = 0; count < CountRetries; count++ ) {

                if (bAbort) {
                        CloseHandle(hpipe);
                        return -1;
                }

#ifdef trace
                {       char msg[80];
                        wsprintf(msg, "Actual receive pipe %x...", hpipe);
                        Trace_Fil(msg);
                }
#endif
                if (ReadFile(hpipe, block, blocksize, (LPDWORD)(&size), NULL)) {
#ifdef trace
                        {       char msg[80];
                                wsprintf(msg, "Good receive pipe %x\n", hpipe);
                                Trace_Fil(msg);
                        }
#endif

                        /* check size of message */
                        if (size == 0) {
                                Trace_Fil("zero length message\r\n");
                                continue;
                        }

                        /* everything ok */
                        {       SSNEWRESP * ssp;
                                char msg[120];
                                ssp = (PSSNEWRESP) block;
                                wsprintf( msg, "ss_getblock got block OK pipe %x: %x %x %x %x %x\n"
                                        , hpipe
                                        , ssp->lVersion, ssp->lResponse, ssp->lCode, ssp->ulSize
                                        , ssp->fileattribs
                                        );
                                Trace_Fil ( msg );
                        }
                        if (PipeError) {
                           PipeError = FALSE;
                           SetStatus("Pipe recovered");
                        }
                        return size;
                }
#ifdef trace
                {       char msg[80];
                        wsprintf(msg, "!!Bad receive pipe %x\n", hpipe);
                        Trace_Fil(msg);
                }
#endif

                /* error occurred - check code */
                switch((errorcode = (int)GetLastError())) {

                case ERROR_BROKEN_PIPE:
                        /* connection broken. no point in retrying */
                        {   char Msg[200];
                            wsprintf( Msg, "pipe %x broken on read.", hpipe);
                            TRACE_ERROR(Msg, FALSE);
                        }
                        return(-1);

                case ERROR_MORE_DATA:
                        /* the message sent is larger than our buffer.
                         * this is an internal error - report it and carry on
                         */
                        {       char msg[100];
                                SSNEWRESP * ssp;

                                wsprintf( msg, "message too large on pipe %x blocksize=%d data="
                                        , hpipe, blocksize
                                        );
                                Trace_Fil(msg);
                                ssp = (PSSNEWRESP) block;
                                wsprintf( msg, "%8x %8x %8x %8x %8x\n"
                                        , ssp->lVersion, ssp->lResponse, ssp->lCode, ssp->ulSize
                                        , ssp->fileattribs
                                        );
                                Trace_Fil(msg);

                        }
                        /* Too low a level for message to user.  Recoverable at higher level
                        ** TRACE_ERROR("internal error- message too large", FALSE);
                        */
                        return -2;

                default:
                        {       char msg[100];
                                wsprintf(msg, "read error %d on pipe %x", errorcode, hpipe);
                                Trace_Stat(msg);

                        }
                        Sleep(count*1000);
                        break;
                }
        }
        SetStatus("Pipe error");
        PipeError = TRUE;
        TRACE_ERROR("retry count reached on pipe read error.", FALSE);
        return 0;
} /* ss_getblock */


/*
 * read a standard response from the net, retrying if necessary. return
 * size if ok or <=0 if not.  -1 means pipe broken.
 */
int
ss_getresponse(HANDLE hpipe, PSSNEWRESP presp)
{
        Trace_Fil("ss_getresponse\n");
        return(ss_getblock(hpipe, (PSTR) presp, sizeof(SSNEWRESP)));
} /* ss_getresponse */


/*
 * terminate the connection to the server. send an END message and
 * close the pipe
 */
void
ss_terminate(HANDLE hpipe)
{
        Trace_Fil("ss_terminate\n");
        ss_sendrequest(hpipe, SSREQ_END, NULL, 0,0);
        CloseHandle(hpipe);
} /* ss_terminate */


/* send a unc & password request. the password and the server strings
 * are both held in the buffer as two consecutive null-terminated strings
 */
BOOL
ss_sendunc(HANDLE hpipe, PSTR password, PSTR server)
{
        char buffer[MAX_PATH];
        char * cp;
        int len;

        Trace_Fil("ss_sendunc\n");
        strcpy(buffer, password);

        cp = &buffer[strlen(buffer) + 1];
        strcpy(cp,server);

        len = (int)((cp - buffer) + strlen(cp) + 1);

        return(ss_sendrequest(hpipe, SSREQ_UNC, buffer, len, 0));
}

/*
 * checksum a single file using the checksum server
 */
BOOL
ss_checksum_remote( HANDLE hpipe, PSTR path
                  , ULONG * psum, FILETIME * pft, LONG * pSize, DWORD *pAttr )
{
        SSNEWRESP resp;
        char msg[400];

        *psum = 0;
        if (!ss_sendrequest(hpipe, SSREQ_SCAN, path, strlen(path)+1, 0)) {

                return(FALSE);
        }

        if (0>=ss_getresponse(hpipe, &resp)) {
                return(FALSE);
        }

        if (resp.lResponse != LRESPONSE) {
                return(FALSE);
        }


        switch(resp.lCode) {

        case SSRESP_END:
                TRACE_ERROR("No remote files found", FALSE);
                return(FALSE);

        case SSRESP_ERROR:
                if (resp.ulSize!=0) {
                    wsprintf( msg, "Checksum server could not read %s win32 code %d"
                            , resp.szFile, resp.ulSize
                            );
                }
                else
                    wsprintf(msg, "Checksum server could not read %s", resp.szFile);
                TRACE_ERROR(msg, FALSE);
                return(FALSE);

        case SSRESP_CANTOPEN:
                wsprintf(msg, "Checksum server could not open %s", resp.szFile);
                TRACE_ERROR(msg, FALSE);
                return(FALSE);

        case SSRESP_FILE:
                *psum = resp.ulSum;
                *pSize = resp.ulSize;
                *pft = resp.ft_lastwrite;
                *pAttr = resp.fileattribs;

                /* read and discard any further packets until SSRESP_END */
                while(0<ss_getresponse(hpipe, &resp)) {
                        if (resp.lCode == SSRESP_END) {
                                break;
                        }
                }

                return(TRUE);

        case SSRESP_DIR:
                wsprintf(msg, "Checksum server thinks %s is a directory", resp.szFile);
                TRACE_ERROR(msg, FALSE);
                return(FALSE);
        default:
                wsprintf(msg, "Bad code from checksum server:%d", resp.lCode);
                TRACE_ERROR(msg, FALSE);
                return(FALSE);
        }

} /* ss_checksum_remote */


/*****************************************************************************
  Bulk copying of files:
  Our caller should call ss_startcopy to set things up and then
  call ss_bulkcopy as many times as necessary to transmit the
  file names and then ss_endcopy to wait for the spawned threads
  to finish.  It is also possible to copy a single file by
  ss_copy_reliable.  For multiple files, bulkcopy should be
  much faster.

  Overall organisation, threads etc:
  There are multiple threads in the server.  Read the writeup
  in ..\server\files.c if you want to understand those.  Read
  that writeup ANYWAY to understand the link protocols (i.e.
  which messages are sent in which order between client and server).

  ss_startcopy kicks off a thread to do the actual receiving.
  It exits when it receives a SSRESP_END.

  Within this thread we do most of the processing synchronously.  We
  rely on a file system that does lazy writing to disk to give
  us effectively a pipeline that gets the file written to disk
  in parallel with reading the pipe so that with luck we can always
  be waiting for the data to arrive through the pipe and never have
  the pipe waiting for us.

  The decompression of a file is a lengthy business, so we spawn threads
  to do that.  We need to check the return codes of the decompression,
  so we get that via GetExitCodeThread.  We put the hThreads that we
  create onto a LIST and periodically (after every file) run down this
  list trying to get exit codes.  When we get a code other than STILL_ACTIVE
  we interpret it as good or bad, add to the counts of nGoodFiles or
  nBadFiles and delete it from the list.  ss_endcopy will wait for all
  the decompression to finish by running down the list WAITing for the
  hThreads.  Because we purge the list regularly it should never get
  very long.  We are worried about the prospect of having 1000 dead
  threads lying around if we don't purge it.

  If a copy fails (i.e. the checksum on arrival after unpacking is different
  from that sent in the SSNEWRESP header for the file) then we call
  ss_copy_reliable to have it re-sent.  If we just call that right away, it
  seems to cause confusion.  As far as I can tell the attempt to open up
  a new pipe doesn't seem to work properly (the two processes interfere).
  The symptom is that we promptly get out of step on the data pipe (??!) with
  data packets arriving when we expected response packets.

  So we keep a list of things to be retried and retry them by serially doing
  a ss_copy_reliable for each one after the rest of the copying has finished.
****************************************************************************/

/* The following are remembered across startcopy..bulkcopy..endcopy
   They correspond to the all-lower-case versions given as
   parameters to ss_copy_reliable
   Note that this is per-process storage, so multiple windiffs should be OK.
*/
static  char Server[MAX_PATH];          /* machine running sumserve */
static  char UNCName[MAX_PATH];         /* \\server\share for remote files */
static  char Password[MAX_PATH];        /* for remote share */

static  BOOL BulkCopy = FALSE;          /* to prevent simple copy during bulk*/
static  int  nGoodFiles = 0;            /* number received OK */
static  int  nBadFiles = 0;             /* number received with errors */
static  int  nFiles = 0;                /* number requested */
static  HANDLE hThread = INVALID_HANDLE_VALUE;  /* the receiving thread */

static  HANDLE hpipe = INVALID_HANDLE_VALUE;    /* the main pipe to send names*/
#ifdef SOCKETS
static  SOCKET hpData = (SOCKET)INVALID_HANDLE_VALUE;   /* the data pipe to get files*/
#else
static  HANDLE hpData = INVALID_HANDLE_VALUE;   /* the data pipe to get files*/
#endif

static LIST Decomps = NULL;                     /* hThreads of decompressers */
static LIST Retries = NULL;                     /* DECOMPARGS to retry */

/* Thread arguments for the decompress thread */
typedef struct{
        DWORD fileattribs;
        FILETIME ft_create;
        FILETIME ft_lastaccess;
        FILETIME ft_lastwrite;
        long  lCode;            /* success code from file xfer so far */
        ULONG ulSum;            /* checksum for file */
        BOOL bSumValid;         /* TRUE iff there was a checksum for file */
        char Temp[MAX_PATH];    /* temp path == source */
        char Real[MAX_PATH];    /* real path == target */
        char Remote[MAX_PATH];  /* remote path to allow retry */
} DECOMPARGS;

/* forward declarations */
int  Decompress(DECOMPARGS * da);
void SpawnDecompress(PSTR TempPath, PSTR RealPath, PSSNEWRESP  presp);
void PurgeDecomps(LIST Decs);

/* ss_startcopy
   Set things up for bulkcopy

   Because we expect to send a list of names off and get a list of
   files back, we need to keep track of the local names so that we can
   associate the file with the right name.  This means either sending our
   local name across the link and back or else keeping a list of
   them here.  The list could be long (typically 1000 for an NT build).
   MAX_PATH is 260 or 520 bytes if unicoded.
   and so long as this involves no extra line turnarounds, this might take
   as long as 520 /8K secs *2 (there and back) or about 130mSec.
   (We have seen 8K bytes/sec sustained over a period).  Probably the
   true burst data rate is 32Kbytes/sec giving about 30msec.
   Either way this is only 30 secs to 2 mins per build overhead.
   Of course it's much shorter for normal paths, especially as we pack
   the data end to end (like a superstring but without the 00 at the end).

   So for the above reasons the local (client) name is transmitted with the
   file request and sent back with the file in a SSNEWRESP.
*/
BOOL ss_startcopy(PSTR server,  PSTR uncname, PSTR password)
{       int retry;
        SSNEWRESP resp;         /* buffer for messages received */
        DWORD ThreadId;         /* to keep CreateThread happy */
#ifdef SOCKETS
        static BOOL SocketsInitialized = FALSE;
#endif

        Trace_Fil("ss_startcopy\n");
        nFiles = 0; nGoodFiles = 0; nBadFiles = 0;

        /* don't need a crit sect here because this runs on the main thread */
        if (BulkCopy) return FALSE;     /* already running! */
        BulkCopy = TRUE;

        if (server!=NULL) strcpy(Server, server); else Server[0] = '\0';
        if (uncname!=NULL) strcpy(UNCName, uncname); else UNCName[0] = '\0';
        if (password!=NULL) strcpy(Password, password); else Password[0] = '\0';

        {       char msg[400];
                wsprintf(msg, "Server '%s' UNC '%s' pass '%s'\n", Server, UNCName, Password);
                Trace_Fil(msg);
        }
        /* create the list of decompressor hThreads */
        Decomps = List_Create();
        Retries = List_Create();

        for (retry = 0; retry < 10; retry++) {
                if (hpipe!=INVALID_HANDLE_VALUE) {
                        Trace_Fil("ss_startcopy closing pipe for retry");
                        CloseHandle(hpipe);
                        hpipe = INVALID_HANDLE_VALUE;
                }
                if (bAbort) {
                        CloseHandle(hpipe);
                        hpipe = INVALID_HANDLE_VALUE;
                        return FALSE;
                }

                /* connect to main pipe */
                {       char pipename[400];
                        InitPipeName(pipename, server, NPNAME);
                        hpipe = ConnectPipe(pipename);
                }

                if (hpipe == INVALID_HANDLE_VALUE) {
                        /* next retry in two seconds */
                        Trace_Stat("connect failed - retrying");
                        Sleep(1000);
                        continue;
                }

                {       char msg[80];
                        wsprintf(msg, "ConnectedPipe to pipe number %x\n",hpipe);
                        Trace_Fil(msg);
                }

                if ((uncname != NULL) && (password != NULL)) {
                        /* send the password request */
                        if (!ss_sendunc(hpipe, password, uncname)) {
                                Trace_Fil("Server connection lost (1)\n");
                                TRACE_ERROR("Server connection lost", FALSE);
                                CloseHandle(hpipe);
                                hpipe = INVALID_HANDLE_VALUE;
                                continue;
                        }

                        /* wait for password response */
                        if (0>=ss_getresponse(hpipe, &resp)) {
                                Trace_Fil("Server connection lost (2)\n");
                                TRACE_ERROR("Server connection lost", FALSE);
                                continue;
                        }
                        if (resp.lResponse != LRESPONSE) {
                                Trace_Fil("Password - bad response\n");
                                TRACE_ERROR("Password - bad response", FALSE);
                                return(FALSE);
                        }
                        if (resp.lCode != SSRESP_END) {
                                Trace_Fil("Password attempt failed\n");
                                TRACE_ERROR("Password attempt failed", FALSE);
                                return(FALSE);
                        }
                }
                break;

        } /* retry loop */
        if (hpipe == INVALID_HANDLE_VALUE) {
                return FALSE;
        }

#ifdef SOCKETS
        if( !SocketsInitialized )
        {
                WSADATA WSAData;

                if( ( WSAStartup( MAKEWORD( 1, 1 ), &WSAData ) ) == 0 )
                {
                        SocketsInitialized = TRUE;
                }
                else
                {
                        TRACE_ERROR("WSAStartup failed", FALSE);
                }
        }
#endif

        /* Tell server we want to send a file list */
        if(!ss_sendrequest( hpipe, SSREQ_FILES, NULL, 0, 0)){
                return FALSE;
        }

        /* expect a reply which names a data pipe */
        {       SSNEWRESP resp;

                if ( 0>=ss_getresponse(hpipe, &resp) ){
                        Trace_Fil("Couldn't get data pipe name\n");
                        TRACE_ERROR("Couldn't get data pipe name", FALSE);
                        CloseHandle(hpipe);
                        hpipe = INVALID_HANDLE_VALUE;
                        return FALSE;
                }
                if ( resp.lResponse!=LRESPONSE){
                        Trace_Fil("Bad RESPONSE when expecting data pipe name\n");
                        TRACE_ERROR("Bad RESPONSE when expecting data pipe name", FALSE);
                        CloseHandle(hpipe);
                        hpipe = INVALID_HANDLE_VALUE;
                        return FALSE;
                }
                if ( resp.lCode!=SSRESP_PIPENAME){
                        char msg[80];
                        TRACE_ERROR("Wrong response when expecting data pipe name", FALSE);
                        wsprintf(msg
                                ,"Wrong response (%d) when expecting data pipe name\n"
                                , resp.lCode);
                        Trace_Fil(msg);
                        CloseHandle(hpipe);
                        hpipe = INVALID_HANDLE_VALUE;
                        return FALSE;
                }

                {       char msg[400];
                        wsprintf(msg, "data pipe name = '%s'\n", resp.szFile);
                        Trace_Fil(msg);
                }

#ifdef SOCKETS
        /* We put the TCP port in the high date time slot just for now:
         */
                if( SOCKET_ERROR == SocketConnect( server, resp.ft_lastwrite.dwHighDateTime, &hpData ) )
                {
                        Trace_Fil("Couldn't connect to socket\n");
                        TRACE_ERROR("Couldn't connect to socket", FALSE);
                        CLOSEHANDLE(hpData);
                        hpData = (SOCKET)INVALID_HANDLE_VALUE;
                        return FALSE;
                }
#else
                if (resp.szFile[0]=='\\') {
                        /* hack to fix bug.  Replace "." by server name */
                        char buff[70];
                        PSTR temp;
                        temp = strtok(resp.szFile,".");
                        temp = strtok(NULL,".");
                        strcpy(buff, temp);
                        strcat(resp.szFile, server);
                        strcat(resp.szFile, buff);
                        wsprintf(buff, "fixed data pipe name = %s\n", resp.szFile);
                        Trace_Fil(buff);
                }

                hpData = ConnectPipe(resp.szFile);
                if (hpData == INVALID_HANDLE_VALUE) {
                        Trace_Fil("Couldn't connect to data pipe\n");
                        TRACE_ERROR("Couldn't connect to data pipe", FALSE);
                        CloseHandle(hpData);
                        hpData = INVALID_HANDLE_VALUE;
                        return FALSE;
                }
#endif /* SOCKETS */
        }

        /* Start a thread to listen for the SSRESPs that will come through */
        Trace_Fil("Starting ReceiveFiles thread\n");
        hThread = CreateThread( NULL, 0, ReceiveFiles, (LPVOID)hpData, 0, &ThreadId);
        Trace_Fil("End of ss_startCopy\n");
        return TRUE;
} /* ss_startcopy */

/* Collect files from hpData.
   See ..\server\files.c for the protocol.
*/
DWORD WINAPI ReceiveFiles(LPVOID handle)
{
        LPSTR lname;
        BOOL Recovering = FALSE;

        SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_HIGHEST);

#ifdef SOCKETS
        hpData = (SOCKET)handle;
#else
        hpData = (HANDLE)handle;
#endif
        {       char msg[80];
                wsprintf(msg, "Receiving Files on pipe %x\n", hpData);
                Trace_Fil(msg);
        }

        /* for each file... */
        for (; ; ) {  /* loop getting files until we get END (or error) */
                SSNEWRESP Resp;
                char Guard = '\0';      /* to protect scanning for \0 in Resp */
                int BuffSize;

#ifdef SOCKETS
                BuffSize = recv(hpData, (PSTR) &Resp, sizeof(Resp), 0);
                if (BuffSize==SOCKET_ERROR) {
                        /* We're out of step - almost certainly got a data packet
                        ** when we expected a response block
                        ** Try to recover by reading until we DO get a resp.
                        */
                        if (Resp.lResponse==LRESPONSE) {
                                
                                CLOSEHANDLE(hpData);    /* tough */
                                hpData = (SOCKET)INVALID_HANDLE_VALUE;
                                return (DWORD)(-1);
                        }
                        if (!Recovering){
                                Recovering = TRUE;
                                TRACE_ERROR("Network protocol error.  OK to Resync? (else abort)", TRUE);
                        }
                        continue;
                }
#else
                BuffSize = ss_getblock(hpData, (PSTR) &Resp, sizeof(Resp));
                if (BuffSize==-2) {
                        /* We're out of step - almost certainly got a data packet
                        ** when we expected a response block
                        ** Try to recover by reading until we DO get a resp.
                        */
                        if (Resp.lResponse==LRESPONSE) {
                                
                                CloseHandle(hpData);    /* tough */
                                hpData = INVALID_HANDLE_VALUE;
                                return (DWORD)(-1);
                        }
                        if (!Recovering){
                                Recovering = TRUE;
                                TRACE_ERROR("Network protocol error.  OK to Resync? (else abort)", TRUE);
                        }
                        continue;
                }
#endif /* SOCKETS */
                if (Recovering && Resp.lResponse!=LRESPONSE) continue;

                Recovering = FALSE;

                if (BuffSize<=0) {
                        Trace_Fil("Couldn't read pipe to get file header.\n");
                        CLOSEHANDLE(hpData);    /* tough */
                        hpData = INVALID_HANDLE_VALUE;
                        return BuffSize;
                }

                Trace_Fil("ReceiveFiles got resp\n");
                if (Resp.lResponse!=LRESPONSE) {
                        Trace_Fil("Network protocol error. Not RESP block\n");
                        TRACE_ERROR("Network protocol error. Not RESP block", FALSE);
                        continue;
                }

                if (Resp.lVersion!=SS_VERSION) {
                        Trace_Fil("Network protocol error.  Bad VERSION\n");
                        TRACE_ERROR("Network protocol error.  Bad VERSION", FALSE);
                        continue;       /* maybe it will resync */
                }
                if (Resp.lCode==SSRESP_END)
                        /* normal ending. */
                        break;

                if (  Resp.lCode!=SSRESP_FILE
                   && Resp.lCode!=SSRESP_NOTEMPPATH
                   && Resp.lCode!=SSRESP_COMPRESSEXCEPT
                   && Resp.lCode!=SSRESP_NOREADCOMP
                   && Resp.lCode!=SSRESP_NOCOMPRESS
                   && Resp.lCode!=SSRESP_COMPRESSFAIL
                   ) {
                        /// want a try finally here to protect the filename???!!!
                        char msg[400];
                        wsprintf( msg, "Error code received: %d file:%s"
                                , Resp.lCode
                                , (Resp.szFile ? Resp.szFile : "NULL") );
                        Trace_Fil(msg);
                        ++nBadFiles;
                        if (!TRACE_ERROR(msg, TRUE)) {
                            /* abort operation */
                            bAbort = TRUE;

                            CLOSEHANDLE(hpData);        /* tough */
                            hpData = INVALID_HANDLE_VALUE;
                            return (DWORD)-1;
                        }

                        continue;
                }

                /* Find the local name */
                lname = &(Resp.szFile[0]) + strlen(Resp.szFile) +1;
                /* memmove(Resp.szLocal, lname, strlen(lname)+1); */

                /* Assume Resp.(ulSize, ft, ulSum, bSumValid, szFile, szLocal
                   are all valid */
                if (!GetFile( hpData, lname, &Resp))
                        ++nBadFiles;
                /* If it's good it gets counted when decompressed */

        } /* files loop */
        return 0;
} /* ReceiveFiles */


/* Read the file from hpipe as a series of SSNEWPACKs.
   Write them into a temporary file.  Stop writing when
   a short one comes in.  Spawn a thread to decompress it into localpath.
   check existing decompress threads for status and count
   the number of good/bad files.
*/
BOOL
#ifdef SOCKETS
GetFile(SOCKET hpipe, PSTR localpath, PSSNEWRESP  presp)
#else
GetFile(HANDLE hpipe, PSTR localpath, PSSNEWRESP  presp)
#endif
{
        HANDLE hfile;
        int sequence;
        ULONG size;
        SSNEWPACK packet;
        BOOL bOK = TRUE;
        BOOL bOKFile = TRUE;   /* FALSE means output file nbg, but keep running along
                                  to stay in step with the pipe protocol
                               */
        char szTempname[MAX_PATH];
        DWORD rc;
        {       char msg[50+MAX_PATH];
                wsprintf(msg, "GetFile %s\n", localpath);
                Trace_Fil(msg);
        }

        /* create a temporary name */
        rc = GetTempPath(sizeof(szTempname), szTempname);
        if (rc==0) {
                char Msg[100];
                wsprintf(Msg, "GetTempPath failed, error code=%ld", GetLastError());
                TRACE_ERROR(Msg, FALSE);
                bOKFile = FALSE;
        }

        if (bOKFile){
                rc = GetTempFileName(szTempname, "ssb", 0, szTempname);
                if (rc==0) {
                        char Msg[100];
                        wsprintf(Msg, "GetTempFileName failed, error code=%ld", GetLastError());
                        TRACE_ERROR(Msg, FALSE);
                        return FALSE;
                }
        }

        if (bOKFile){
        /* try to create the temp file */
        hfile = CreateFile(szTempname,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

                if (hfile == INVALID_HANDLE_VALUE) {
                        char Msg[500];
                        wsprintf(Msg, "GetFile: could not create temp file %s", szTempname);
                        TRACE_ERROR(Msg, FALSE);
                        bOKFile = FALSE;
                }
        }
        else hfile = INVALID_HANDLE_VALUE;

        for (sequence = 1; ; sequence++) {

                int SizeGotten;
#ifdef SOCKETS
                SizeGotten = recv(hpipe, (PSTR) &packet, sizeof(packet), 0);
#else
                SizeGotten = ss_getblock(hpipe, (PSTR) &packet, sizeof(packet));
#endif

                if (SizeGotten<=0) {
                        /* error - could be an Abort request */
                        char msg[80];
                        wsprintf( msg, "Network error.  Size received=%d\n", SizeGotten);
                        Trace_Fil(msg);
                        bOK = FALSE;
                        break;
                }

                if (packet.lPacket!=LPACKET) {
                        {       char msg[200];
                                wsprintf( msg
                                        , "Network protocol error. Not PACKET: %x %x %x %x %x"
                                        , packet.lVersion
                                        , packet.lPacket
                                        , packet.lSequence
                                        , packet.ulSize
                                        , packet.ulSum
                                        );
                                /* and maybe someone will recognise what on earth it is */
                                Trace_Fil(msg);
                        }
                        TRACE_ERROR("Network protocol error. Not PACKET.", FALSE);
                        bOK = FALSE;
                        break;
                }

                if (sequence != packet.lSequence) {
                        /* error or out of sequence */
                        char msg[200];
                        wsprintf( msg, "Packet out of sequence. Got %d expected %d\n"
                                , packet.lSequence, sequence);
                        Trace_Fil(msg);
                        TRACE_ERROR("Packet sequence error.", FALSE);
                        bOK = FALSE;
                        break;
                }

                if (packet.ulSize ==0) {
                        /*
                         * this is really the last block (end of file).
                         *
                         * LATER
                         * do SSATTRIBS on the end to support NTFS properly !!!
                         */
                        Trace_Fil("End of file marker (0 length)\n");
                        break;
                }
#if 1
                /* check the block checksums */
                if (  (  SS_VERSION==0 /* which it isn't */
                      && ss_checksum_block(packet.Data, packet.ulSize) != packet.ulSum
                      )
                   || (  SS_VERSION>0  /* which it is */
                      && packet.ulSum!=0
                      )
                   ) {
                        TRACE_ERROR("packet checksum error", FALSE);
                        bOK = FALSE;
                        break;
                }
#else           // Debug version.  (Remember to enable server checksums too)
                // Also ensure that Trace_Fil is actually tracing.
                {       ULONG PackSum;
                        /* check the block checksums */
                        if (  (PackSum = ss_checksum_block(packet.Data, packet.ulSize))
                              != packet.ulSum
                           ) {
                                char msg[80];
                                wsprintf( msg, "Packet checksum error was %x should be %x\n"
                                          , PackSum, packet.ulSum );
                                Trace_Fil(msg);
                                // but don't break;
                        }
                }
#endif

                if ( packet.ulSize==(ULONG)(-1) || packet.ulSize==(ULONG)(-2) )  {
                        TRACE_ERROR("Error from server end", FALSE);
                        bOK = FALSE;
                        break;
                }

                if (bOKFile) {
                        bOK = WriteFile(hfile, packet.Data, packet.ulSize, &size, NULL);
                        {       char msg[80];
                                wsprintf( msg,"Writing block to disk - size= %d\n", size);
                                Trace_Fil(msg);
                        }
                        if (!bOK || (size != packet.ulSize)) {
                                TRACE_ERROR("File write error", FALSE);
                                bOK = FALSE;
                                break;
                        }
                }
                else bOK = FALSE;

                if (packet.ulSize < PACKDATALENGTH)
                {
                        /* this is the last block (end of file) */
                        Trace_Fil("End of file marker (short packet)\n");
                        break;
                }

        } /* for each block */

        CloseHandle(hfile);
        if (!bOK) {
                DeleteFile(szTempname);
                return FALSE;
        }


        SpawnDecompress(szTempname, localpath, presp);
        PurgeDecomps(Decomps);

        return bOK;

} /* GetFile */


/* Spawn a thread to decompress TempPath into RealPath on a new thread
   Add the thread handle to the LIST Decomps.
   If presp->lCode is one of SSRESP_NOTEMPPATH
                             SSRESP_COMPRESSEXCEPT
                             SSRESP_NOREADCOMP
                             SSRESP_NOCOMPRESS
   Then the file should just be copied, not decompressed.
*/
void SpawnDecompress(PSTR TempPath, PSTR RealPath, PSSNEWRESP  presp)
{
        DECOMPARGS * DecompArgs;
        HANDLE hThread;
        DWORD ThreadId;

        {       char msg[MAX_PATH+60];
                wsprintf(msg, "Spawning decompress of %s", TempPath);
                Trace_Fil(msg);
        }
        DecompArgs = (DECOMPARGS *)GlobalAlloc(GMEM_FIXED, sizeof(DECOMPARGS));
        if (DecompArgs)
        {
            DecompArgs->fileattribs = presp->fileattribs;
            DecompArgs->ft_create = presp->ft_create;
            DecompArgs->ft_lastaccess = presp->ft_lastaccess;
            DecompArgs->ft_lastwrite =  presp->ft_lastwrite;
            DecompArgs->ulSum =  presp->ulSum;
            DecompArgs->lCode =  presp->lCode;
            DecompArgs->bSumValid =  presp->bSumValid;
            strcpy(DecompArgs->Temp, TempPath);
            strcpy(DecompArgs->Real, RealPath);
            strcpy(DecompArgs->Remote, presp->szFile);
            hThread = CreateThread( NULL, 0, (LPTHREAD_START_ROUTINE)Decompress, DecompArgs, 0, &ThreadId);
            List_AddLast( Decomps, (LPVOID)&hThread, sizeof(hThread));
        }
        else
        {
            // shut up Prefix.  no idea what is the right thing to do here,
            // without spending a lot of time to understand how this whole
            // add-on to windiff works.  in some other product this would be
            // worth investing time on.  but not this add-on to windiff that
            // most people don't even know exists, much less how to set up
            // the server it needs to talk to.
        }
} /* SpawnDecompress */

/* Decompress da->Temp into da->Real
   Free the storage da->DECOMPARGS
   Return 1 (TRUE) if it worked
   Return 0 (FALSE) if it didn't work
   This return code acts as the exit code for the thread.
*/

int Decompress(DECOMPARGS * da)
{

        OFSTRUCT os;
        int fh1, fh2;
        BOOL bOK = TRUE;

        /* Decompress the file to the original name
           If da->lCode is one of SSRESP_NOTEMPPATH
                                  SSRESP_COMPRESSEXCEPT
                                  SSRESP_NOREADCOMP
                                  SSRESP_NOCOMPRESS
           Then the file is just copied, not decompressed.

        */
        {       char msg[2*MAX_PATH+50];
                wsprintf( msg, "Decompressing %s => %s\n"
                        , da->Temp, da->Real);
                Trace_Fil(msg);
                wsprintf( msg, "%d done. Getting %s\n"
                        , nGoodFiles, da->Real);
                SetNames(msg);
        }

        if (  da->lCode==SSRESP_NOTEMPPATH
           || da->lCode==SSRESP_COMPRESSEXCEPT
           || da->lCode==SSRESP_NOREADCOMP
           || da->lCode==SSRESP_NOCOMPRESS
           ) {     /* Just copy, don't compress */
                bOK = CopyFile(da->Temp, da->Real, FALSE);
                if (bOK) Trace_Fil("Uncompressed file copied.\n");
                else Trace_Fil("Uncompressed file failed final copy.\n");
        } else {

            fh1 = LZOpenFile(da->Temp, &os, OF_READ|OF_SHARE_DENY_WRITE);
            if (fh1 == -1) {
                    char msg[500];
                    wsprintf( msg, "Packed temp file %s did not open for decompression into %s. Error code %d"
                            , da->Temp, da->Real, GetLastError()
                            );
                    TRACE_ERROR(msg, FALSE);
                    bOK = FALSE;
            } else {


                fh2 = LZOpenFile(da->Real, &os, OF_CREATE|OF_READWRITE|OF_SHARE_DENY_NONE);
                if (fh2 == -1) {
                    char msg[MAX_PATH];

                    Trace_Fil("Could not create target file\n");

                    wsprintf(msg, "Could not create target file %s", da->Real);

                    if (!TRACE_ERROR(msg, TRUE)) {

                        /* user hit cancel - abort operation */
                        bAbort = TRUE;

                    }
                    bOK = FALSE;
                    LZClose(fh1);

                } else {
                    long retcode;
                    retcode = LZCopy(fh1, fh2);
                    if (retcode<0){
                        bOK = FALSE;
                    }

                    LZClose(fh1);
                    LZClose(fh2);
                }
            }
        }

        /* May want to keep it for debugging...? */
#ifndef LAURIE
        DeleteFile(da->Temp);
#endif //LAURIE

        if (bOK) {
                HANDLE hfile;
                BOOL bChecked;
                LONG err;
                /*
                * check the file's checksum (end-to-end check) and size and
                * set file attributes and times according to the attribs
                * struct we received. Remember to set file times BEFORE
                * setting attributes in case the attributes include read-only!
                */

                bChecked = ( da->ulSum == checksum_file(da->Real, &err) );
                if (err!=0) bChecked = FALSE;

                if (!bChecked){
                        if (!bAbort){
                                char msg[200];
                                if (err>0) {
                                    /* negative error codes are internal errors,
                                       positive ones are meaningful to outsiders.
                                    */
                                    wsprintf( msg
                                            , "error %ld, Will retry file %s."
                                            , err
                                            , da->Real
                                            );
                                }
                                else {
#if defined(LAURIE)
                                    wsprintf( msg
                                            , "Checksum error %ld on file %s. Sum should be %8x, temp file %s"
                                            , err
                                            , da->Real
                                            , da->ulSum
                                            , da->Temp
                                            );
                                    TRACE_ERROR(msg, FALSE);
#endif
                                    wsprintf( msg
                                            , "Checksum error.  Will retry file %s."
                                            , da->Real
                                            );
                                }
                                SetNames(msg);
                                List_AddLast(Retries, (LPVOID)da, (UINT)sizeof(DECOMPARGS));
                                return(FALSE);   /* Hm - kind of a lie correct later */
                        }
                        else return FALSE;
                }

                hfile = CreateFile(da->Real, GENERIC_WRITE, 0, NULL,
                               OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);


                if (!SetFileTime(hfile, &(da->ft_create),
                                  &(da->ft_lastaccess),
                                  &(da->ft_lastwrite)) ) {
                       TRACE_ERROR("could not set file times", FALSE);
                }

                CloseHandle(hfile);

                if (!SetFileAttributes(da->Real, da->fileattribs)) {
                        TRACE_ERROR("could not set attributes", FALSE);
                }
        }
        GlobalFree((HGLOBAL)da);
        return bOK;
} /* Decompress */



/* safe strcmp of PTR against array, protecting against NULL PTR
   b is an array and had better NOT be null
   a NULL pointer is taken to match an empty arrray.
*/
int safecmp(LPSTR a, LPSTR b)
{       if (a==NULL)
                return (b[0]!='\0'); /* returns 0 if ==, else 1 */
        else return strcmp(a,b);
} /* safecmp */


/*
 * request to copy a file.  Sends the request on (static global) hpipe
 *
 * returns TRUE if it succeeded or FALSE if the connection was lost
 * TRUE only means the REQUEST was sent.
 */
BOOL
ss_bulkcopy(PSTR server, PSTR serverpath, PSTR clientpath, PSTR uncname,
                PSTR password)
{       char buffer[MAX_PATH*2];
        LPSTR pstr;

        ++nFiles;
        Trace_Fil("ss_bulkcopy\n");
        if (safecmp(server,Server)) {
                char msg[400];
                wsprintf( msg, "Protocol error.  Server change was %s is %s"
                        , Server, (server?server:"NULL")
                        );
                Trace_Fil(msg);
                TRACE_ERROR("Protocol error.  Server change", FALSE);
                return FALSE;
        }
        if (safecmp(uncname,UNCName)) {
                char msg[400];
                wsprintf( msg, "Protocol error.  UNCName change was %s is %s"
                        , UNCName, (uncname?uncname:"NULL")
                        );
                Trace_Fil(msg);
                TRACE_ERROR("Protocol error.  UNCName change", FALSE);
                return FALSE;
        }
        if (safecmp(password,Password)) {
                char msg[400];
                wsprintf( msg, "Protocol error.  Password change was %s is %s"
                        , Password, (password?password:"NULL")
                        );
                Trace_Fil(msg);
                TRACE_ERROR("Protocol error.  Password change", FALSE);
                return FALSE;
        }

        /* pack local and remote paths into buffer */
        strcpy(buffer,serverpath);
        pstr = buffer+strlen(serverpath)+1;
        strcpy(pstr,clientpath);

        return ss_sendrequest( hpipe
                             , SSREQ_NEXTFILE
                             , buffer
                             , strlen(serverpath)+strlen(clientpath)+2
                             , 0
                             );
} /* ss_bulkcopy */

/* Remove from the decompressers list those that have finished.
   Don't hang about waiting.  Leave the rest on the list
   Updating nGoodFiles and/or nBadFiles for those that finished.
*/
void PurgeDecomps(LIST Decs)
{
        HANDLE * phThread, * Temp;
        DWORD ExitCode;

        phThread = List_First(Decs);
        while (phThread!=NULL) {
                if (GetExitCodeThread(*phThread, &ExitCode)) {
                        Temp = phThread;
                        phThread = List_Next((LPVOID)phThread);
                        if (ExitCode==1) {
                                ++nGoodFiles;
                                CloseHandle(*Temp);
                                Trace_Fil("Purged a good decomp\n");
                                List_Delete((LPVOID)Temp);
                        }
                        else if(ExitCode==0) {
                                ++nBadFiles;
                                CloseHandle(*Temp);
                                Trace_Fil("Purged a bad decomp\n");
                                List_Delete((LPVOID)Temp);
                        }
                        else /* still active? */ ;
                }
        } /* traverse */
} /* PurgeDecomps */


/* WAIT for each of the hThreads on Decomps and report its status by
   updating nGoodFiles and/or nBadFiles
   This thread must be run on the receive thread or else after
   the receive thread has terminated (or else we need a critical section).
*/
void WaitForDecomps(LIST Decs)
{
        HANDLE * phThread;
        DWORD ExitCode;

        List_TRAVERSE(Decs, phThread) {
                if (bAbort) return;
                Trace_Fil("Waiting for a decomp...");
                for (; ; ){
                        DWORD rc;
                        rc = WaitForSingleObject(*phThread, 5000);
                        if (rc==0) break;   /* timeout complete */
                        if (bAbort) {
                                // This WILL leave a garbage thread and a temp file lying around!!!???
                                Trace_Fil("Aborting wait for decomp.");
                                return;
                        }
                }
                Trace_Fil(" Done waiting.\n");
                GetExitCodeThread(*phThread, &ExitCode);
                if (ExitCode==1)
                        ++nGoodFiles;
                else
                        ++nBadFiles;
                CloseHandle(*phThread);
        } /* traverse */

        Trace_Fil("All decompression finished.");
        List_Destroy(&Decs);
} /* WaitForDecomps */


static void Retry(LIST Rets)
{
        DECOMPARGS * da;

        if (List_IsEmpty(Rets)) return;

        List_TRAVERSE(Rets, da) {
             if (ss_copy_reliable( Server, da->Remote, da->Real, UNCName, Password))
             {   /* correct the lie we told when Decompress returned FALSE */
                 ++nGoodFiles; --nBadFiles;
             }
        }
        List_Destroy(&Rets);
        SetNames("All errors recovered");
}/* Retry */


/* end of bulk copy.  Tidy everything up */
int ss_endcopy(void)
{
        Trace_Fil("ss_endcopy\n");
        ss_sendrequest( hpipe, SSREQ_ENDFILES, "", 1, 0);
        /* wait for receiving thread to complete (could be long) */
        for (; ; ){
                DWORD rc;
                rc = WaitForSingleObject( hThread, 5000);
                if (rc==0) break;   /* thread complete */
                if (bAbort) {
                        if (hpData!=INVALID_HANDLE_VALUE){
                                CLOSEHANDLE(hpData);
                                hpData = INVALID_HANDLE_VALUE;
                        }
                        break;
                }
        }

        // don't close the connection until we've finished, otherwise
        // someone might think it's ok to reboot the server
        ss_sendrequest( hpipe, SSREQ_END, "", 1, 0);
        CloseHandle(hpipe);
        hpipe = INVALID_HANDLE_VALUE;

        WaitForDecomps(Decomps);
        Decomps = NULL;
        SetNames(NULL);
        Retry(Retries);
        Retries = NULL;

        BulkCopy = FALSE;
        if (nBadFiles+nGoodFiles > nFiles) return -99999; /* !!? */
        if (nBadFiles+nGoodFiles < nFiles) nBadFiles = nFiles-nGoodFiles;

        if (nBadFiles>0)
                return -nBadFiles;
        else    return nGoodFiles;

} /* ss_endcopy */


#if 0
/* A SSREQ_FILES has been sent and possibly one or more files,
   but we have changed our minds.  We try to send an Abort request.
*/
int ss_abortcopy(void)
{
        Trace_Fil("ss_abortcopy\n");
        ss_sendrequest( hpipe, SSREQ_ABORT, "", 1);

        {       DWORD code;
                TerminateThread(hThread, &code);  /* storage leak */
                hThread = INVALID_HANDLE_VALUE;
        }

        Server[0] = '\0';

        CloseHandle(hpipe);
        hpipe = INVALID_HANDLE_VALUE;

        CLOSEHANDLE(hpData);
        hpData = INVALID_HANDLE_VALUE;

        if (Decomps!=NULL){
                HANDLE * phThread;
                List_TRAVERSE(Decomps, phThread){
                        DWORD code;
                        TerminateThread(*phThread, &code);  /* storage leak */
                }
        }
        Decomps = NULL;

        BulkCopy = FALSE;
} /* ss_abortcopy */
#endif // 0


/*
 * reliably copy a file (repeat (upto N times) until checksums match)
 *
 * returns TRUE if it succeeded or FALSE if the connection was lost
 */
BOOL
ss_copy_reliable(PSTR server, PSTR remotepath, PSTR localpath, PSTR uncname,
                PSTR password)
{
        ULONG sum_local, sum_remote;
        int retry;
        SSNEWRESP resp;
        HANDLE hpCopy = INVALID_HANDLE_VALUE;    /* N.B. NOT the static global pipe! */
        LONG err;

        FILETIME ft;
        LONG sz;
        DWORD attr;


        Trace_Fil("ss_copy_reliable\n");
//      if (BulkCopy) {
//              TRACE_ERROR("Cannot do simple copy as bulk copy is in progress", FALSE);
//              return FALSE;
//      }

        for (retry = 0; retry < 10; retry++) {

                if (bAbort) return FALSE;        /* abort requested from WINDIFF */

                if (hpCopy!=INVALID_HANDLE_VALUE) {
                        CloseHandle(hpCopy);
                        hpCopy = INVALID_HANDLE_VALUE;
                }

                {       char pipename[400];
                        InitPipeName(pipename, server, NPNAME);
                        hpCopy = ConnectPipe(pipename);
                }

                if (hpCopy == INVALID_HANDLE_VALUE) {
                        /* next retry in two seconds */
                        Trace_Stat("connect failed - retrying");
                        Sleep(1000);
                        continue;
                }

                if ((uncname != NULL) && (uncname[0]!='\0')
                &&  (password != NULL) && (password[0]!='\0')) {

                        /* send the password request */
                        if (!ss_sendunc(hpCopy, password, uncname)) {
                                TRACE_ERROR("Server connection lost", FALSE);
                                continue;
                        }

                        /* wait for password response */
                        if (0>=ss_getresponse(hpCopy, &resp)) {
                                TRACE_ERROR("Server connection lost", FALSE);
                                continue;
                        }
                        if (resp.lCode != SSRESP_END) {
                                TRACE_ERROR("Password attempt failed", FALSE);
                                return(FALSE);
                        }
                }

                /* try to copy the file */
                ss_copy_file(hpCopy, remotepath, localpath);

                /* whether or not he thinks he failed, we should look
                 * to see if the file is really there.
                 */

                sum_local = checksum_file(localpath, &err);
                if (err!=0) continue;

                sum_remote = 0;
                if (!ss_checksum_remote(hpCopy, remotepath, &sum_remote, &ft, &sz, &attr)) {
                        /* no remote checksum - better retry */
                        if (!TRACE_ERROR("remote checksum failed - retry?", TRUE)) {
                            CloseHandle(hpCopy);
                            return(FALSE);
                        }
                        continue;
                }

                if (sum_local == sum_remote) {
                        /* copy succeeded */
                        ss_terminate(hpCopy);
                        return(TRUE);
                }
                TRACE_ERROR("files different after apparently successful copy!!?", FALSE);

        } /*retry loop */

        /* too many retries */
        CloseHandle(hpCopy);
        return(FALSE);
} /* ss_copy_reliable */


/*
 * copy one file using checksum server
 *
 * send a SSREQ_FILE for the file, and then loop reading
 * blocks until we get an error (sequence count is wrong or -1),
 * or the end of file (0-length block)
 *
 * File sent may be compressed. We write it to a temporary file, and
 * then decompress it using LZCopy. This will work even if the
 * file was sent uncompressed (eg because compress.exe could not be
 * executed on the server).
 */
BOOL
ss_copy_file(HANDLE hpipe, PSTR remotepath, PSTR localpath)
{
        HANDLE hfile;
        int sequence;
        ULONG size;
        SSPACKET packet;
        BOOL bOK;
        char szTempname[MAX_PATH];
        OFSTRUCT os;
        int fh1, fh2;
        PSSATTRIBS attribs;

        Trace_Fil("ss_copy_file\n");
        /* create a temporary name */
        *szTempname = 0;
        GetTempPath(sizeof(szTempname), szTempname);
        GetTempFileName(szTempname, "ssc", 0, szTempname);

        /* try to create the temp file */
        hfile = CreateFile(szTempname,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

        if (hfile == INVALID_HANDLE_VALUE) {
                TRACE_ERROR("ss_copy: could not create temp file", FALSE);
                return(FALSE);
        }

        if (!ss_sendrequest(hpipe, SSREQ_FILE, remotepath, strlen(remotepath)+1, 0)){
                CloseHandle(hfile);
                return(FALSE);
        }

        for (sequence = 0; ; sequence++) {

                bOK = 0 <= ss_getblock(hpipe, (PSTR) &packet, sizeof(packet));

                if (!bOK || (sequence != packet.lSequence)) {
                        /* error or out of sequence */
                        TRACE_ERROR("packet error", FALSE);
                        CloseHandle(hfile);
                        DeleteFile(szTempname);
                        return(FALSE);
                }

                if (packet.ulSize == 0) {
                        /*
                         * this is the last block (end of file).
                         *
                         * the data field for this block contains a
                         * SSATTRIBS struct that we can use to set the
                         * file times and attributes (after decompression).
                         */
                        attribs = (PSSATTRIBS) packet.Data;


                        break;
                }

                /* check the block checksums */
                if (  (  SS_VERSION==0 /* which it isn't */
                      && ss_checksum_block(packet.Data, packet.ulSize) != packet.ulSum
                      )
                   || (  SS_VERSION>0  /* which it is */
                      && packet.ulSum!=0
                      )
                   ) {
                        TRACE_ERROR("packet checksum error", FALSE);
                        CloseHandle(hfile);
                        DeleteFile(szTempname);
                        return(FALSE);
                }


                bOK = WriteFile(hfile, packet.Data, packet.ulSize, &size, NULL);
                if (!bOK || (size != packet.ulSize)) {
                        CloseHandle(hfile);
                        DeleteFile(szTempname);
                        return(FALSE);
                }

        }
        CloseHandle(hfile);


        /* decompress the file to the original name */
        fh1 = LZOpenFile(szTempname, &os, OF_READ|OF_SHARE_DENY_WRITE);
        if (fh1 < 0) {
                TRACE_ERROR("Failed to open file for decompression", FALSE);
        } else {


                fh2 = LZOpenFile(localpath, &os, OF_CREATE|OF_READWRITE|OF_SHARE_DENY_NONE);
                if (fh2 < 0) {
                        char msg[MAX_PATH+40];

                        wsprintf(msg, "Could not create target file %s", localpath);

                        if (!TRACE_ERROR(msg, TRUE)) {
                            bAbort = TRUE;
                        }

                        return(FALSE);

                } else {
                        LZCopy(fh1, fh2);
                        LZClose(fh1);
                        LZClose(fh2);
                }
        }

        DeleteFile(szTempname);

        /*
         * now set file attributes and times according to the attribs
         * struct we received. Remember to set file times BEFORE
         * setting attributes in case the attributes include read-only!
         */
        hfile = CreateFile(localpath, GENERIC_WRITE, 0, NULL,
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

        if (!SetFileTime(hfile, &attribs->ft_create,
                           &attribs->ft_lastaccess,
                           &attribs->ft_lastwrite) ) {
                TRACE_ERROR("could not set file times", FALSE);
        }

        CloseHandle(hfile);

        if (!SetFileAttributes(localpath, attribs->fileattribs)) {
                TRACE_ERROR("could not set attributes", FALSE);
        }


        return(TRUE);

} /* ss_copy_file */


/* produce a checksum of a block of data.
 *
 * This algorithm is compute bound.  It's probably overkill anyway and for
 * version 1 is not used.  It must match the one in server.
 *
 * Generate checksum by the formula
 *      checksum = SUM( rnd(i)*(1+byte[i]) )
 * where byte[i] is the i-th byte in the file, counting from 1
 *       rnd(x) is a pseudo-random number generated from the seed x.
 *
 * Adding 1 to byte ensures that all null bytes contribute, rather than
 * being ignored. Multiplying each such byte by a pseudo-random
 * function of its position ensures that "anagrams" of each other come
 * to different sums. The pseudorandom function chosen is successive
 * powers of 1664525 modulo 2**32. 1664525 is a magic number taken
 * from Donald Knuth's "The Art Of Computer Programming"
 */

ULONG
ss_checksum_block(PSTR block, int size)
{
        unsigned long lCheckSum = 0;            /* grows into the checksum */
        const unsigned long lSeed = 1664525;    /* seed for random Knuth */
        unsigned long lRand = 1;                /* seed**n */
        unsigned long lIndex = 1;               /* byte number in block */
        unsigned Byte;                          /* next byte to process in buffer */
        unsigned length;                        /* unsigned copy of size */

        Trace_Fil("ss_checksum_block\n");
        length = size;
        for (Byte = 0; Byte < length ;++Byte, ++lIndex) {

                lRand = lRand*lSeed;
                lCheckSum += lIndex*(1+block[Byte])*lRand;
        }

        return(lCheckSum);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\client\sum.c ===
/*
 * basic client for sumserve remote checksum server
 *
 *
 * sends a request over a named pipe for a list of files and checksums,
 * and printf's the returned list
 */

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include "..\server\sumserve.h"
#include "ssclient.h"


extern int __argc;
extern char ** __argv;


/* program entry point
 *
 * creates the named pipe, and loops waiting for client connections and
 * calling ss_handleclient for each connection. only exits when told
 * to by a client.
 *
 * currently permits only one client connection at once.
 */
int PASCAL
WinMain (HANDLE hInstance, HANDLE hPrevInstance, LPSTR lpszCmdParam,
 		int nCmdShow)
{
	HANDLE hpipe;
	SSRESPONSE resp;
	PSTR tag;

	/* we expect two args: the server name, and the pathname */

	if (__argc != 3) {

		printf("usage: client <servername> <pathname>");
		return(1);
	}

 	hpipe = ss_connect(__argv[1]);
	if (hpipe == INVALID_HANDLE_VALUE) {
		printf("cannot connect to server %s\n", __argv[1]);
		return(2);
	}

	/* make a packet to send */
	if (!ss_sendrequest(hpipe, SSREQ_SCAN, __argv[2], strlen(__argv[2])+1)) {
		printf("pipe write error %d\n", GetLastError());
		return(3);
	}


	/* loop reading responses */
	for (; ;) {
		
		if (!ss_getresponse(hpipe, &resp)) {
			printf("pipe read error %d\n", GetLastError());
			return(4);
		}
		

		if (resp.lCode == SSRESP_END) {
			printf("-----------------end of list");
			break;
		}
		
		switch(resp.lCode) {
		case SSRESP_ERROR:
			tag = "ERROR";	
			printf("%s\t\t\t%s\n", tag, resp.szFile);
			break;

		case SSRESP_DIR:
			tag = "dir";	
			printf("%s\t\t\t%s\n", tag, resp.szFile);
			break;

		case SSRESP_FILE:
			tag = "file";
			printf("%s\t%08lx\t%d bytes\t%s\n", tag, resp.ulSum, resp.ulSize, resp.szFile);
			break;
		}
	}
	ss_terminate(hpipe);
	return(0);

}


/* error output functions - called by the ssclient library functions
 *
 * defined here so the library can be called from cmdline and windows
 * programs.
 *
 */
BOOL
Trace_Error(LPSTR str, BOOL fCancel)
{
	printf("%s\n", str);
	return(TRUE);
}


/*
 * status update messages
 */
void
Trace_Status(LPSTR str)
{
	printf("%s\n", str);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\server\errlog.h ===
/*
 * error text and time logging
 *
 * Functions to log a text string and the system time to a buffer that can
 * be sent to a log-reader application.
 */

/*
 * Log_Create returns this handle. You don't need to know the
 * structure layout or size.
 */
typedef struct error_log * HLOG;


/* create an empty log */
HLOG Log_Create(void);

/* delete a log */
VOID Log_Delete(HLOG);

/* write a text string (and current time) to the log - printf format */
VOID Log_Write(HLOG, char * szFormat, ...);

/* write a previous formatted string and a time to the log */
VOID Log_WriteData(HLOG, LPFILETIME, LPSTR);

/* send a log to a named-pipe client */
VOID Log_Send(HANDLE hpipe, HLOG hlog);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\client\sumcopy.c ===
/*
 * basic client for sumserve remote checksum server
 *
 *
 * sends a request over a named pipe for a list of files and checksums,
 * and printf's the returned list
 */

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include "..\server\sumserve.h"
#include "ssclient.h"


extern int __argc;
extern char ** __argv;


/* program entry point
 *
 */
int PASCAL
WinMain (HANDLE hInstance, HANDLE hPrevInstance, LPSTR lpszCmdParam,
 		int nCmdShow)
{

	/* we expect two args: the server name, and the pathname */

	if (__argc != 4) {

		printf("usage: client <servername> <remotefile> <localfile>");
		return(1);
	}

	if (!ss_copy_reliable(__argv[1], __argv[2], __argv[3], NULL, NULL)) {
		printf("copy failed\n");
		return(1);
	} else {

		printf("copy succeeded\n");
		return(0);
	}


}


/* error output functions - called by the ssclient library functions
 *
 * defined here so the library can be called from cmdline and windows
 * programs.
 *
 */
BOOL
Trace_Error(LPSTR str, fCancel)
{
	printf("%s\n", str);

	return(TRUE);
}


/*
 * output status messages
 */
void
Trace_Status(LPSTR str)
{
	printf("%s\n", str);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\server\errlog.c ===
/*
 * logs system time and a text string to a log buffer
 */

#include "windows.h"
#include <stdarg.h>
#include <stdio.h>

#include "sumserve.h"
#include "errlog.h"
#include "server.h"




/*
 * users HLOG handle is a pointer to one of these structures
 *
 * core is the section we send to him on request.
 */
struct error_log {

    CRITICAL_SECTION critsec;

    struct corelog core;
};

/* create an empty log */
HLOG Log_Create(void)
{
    HLOG hlog;

    hlog = GlobalLock(GlobalAlloc(GHND, sizeof(struct error_log)));
    if (hlog == NULL) {
	return(NULL);
    }

    InitializeCriticalSection(&hlog->critsec);
    hlog->core.lcode = LRESPONSE;
    hlog->core.bWrapped = FALSE;
    hlog->core.dwRevCount = 1;
    hlog->core.length = 0;

    return(hlog);
}



/* delete a log */
VOID Log_Delete(HLOG hlog)
{
    DeleteCriticalSection(&hlog->critsec);

    GlobalFree(GlobalHandle(hlog));
}

/*
 * private function to delete the first log item in order to
 * make space. Critsec already held
 */
VOID Log_DeleteFirstItem(HLOG hlog)
{
    int length;
    PBYTE pData;

    /* note that we have lost data */
    hlog->core.bWrapped = TRUE;

    if (hlog->core.length <= 0) {
	return;
    }

    pData = hlog->core.Data;
    /*
     * we need to erase one entry - that is, one FILETIME struct,
     * plus a null-terminated string (including the null).
     */
    length = sizeof(FILETIME) + lstrlen (pData + sizeof(FILETIME)) + 1;

    MoveMemory(pData, pData + length, hlog->core.length - length);
    hlog->core.length -= length;

}




/* write a previous formatted string and a time to the log */
VOID Log_WriteData(HLOG hlog, LPFILETIME ptime, LPSTR pstr)
{
    int length;
    LPBYTE pData;

    EnterCriticalSection(&hlog->critsec);


    /* every change changes the revision number */
    hlog->core.dwRevCount++;

    /*
     * we will insert the string plus null plus a filetime struct
     */
    length = lstrlen(pstr) + 1 + sizeof(FILETIME);


    /*
     * make space in log for this item by deleting earlier items
     */
    while ( (int)(sizeof(hlog->core.Data) - hlog->core.length) < length) {

	Log_DeleteFirstItem(hlog);
    }

    pData = &hlog->core.Data[hlog->core.length];

    /*
     * first part of the item is the time as a FILETIME struct
     */
    * (FILETIME UNALIGNED *)pData = *ptime;
    pData += sizeof(FILETIME);

    /* followed by the ansi string */
    lstrcpy(pData, pstr);
    pData[lstrlen(pstr)] = '\0';

    /* update current log length */
    hlog->core.length += length;

    LeaveCriticalSection(&hlog->critsec);
}


/* send a log to a named-pipe client */
VOID Log_Send(HANDLE hpipe, HLOG hlog)
{

    ss_sendblock(hpipe, (PSTR) &hlog->core, sizeof(hlog->core));

}

VOID
Log_Write(HLOG hlog, char * szFormat, ...)
{
    char buf[512];
    va_list va;
    FILETIME ft;
    SYSTEMTIME systime;

    va_start(va, szFormat);
    wvsprintfA(buf, szFormat, va);
    va_end(va);

    dprintf1((buf));

    GetSystemTime(&systime);
    SystemTimeToFileTime(&systime, &ft);

    Log_WriteData(hlog, &ft, buf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\server\debug.c ===
/* Debug.c
 *
 * Debug printf and assertion functions
 */


#include <windows.h>
#include <stdarg.h>
#include <stdio.h>


#if DBG

/* _Assert(fExpr, szFile, iLine)
 *
 * If <fExpr> is TRUE, then do nothing.  If <fExpr> is FALSE, then display
 * an "assertion failed" message box allowing the user to abort the program,
 * enter the debugger (the "Retry" button), or igore the error.
 *
 * <szFile> is the name of the source file; <iLine> is the line number
 * containing the _Assert() call.
 */
#ifdef I386
#pragma optimize("", off)
#endif

BOOL FAR PASCAL
_Assert(BOOL fExpr, LPSTR szFile, int iLine)
{
	static char	ach[300];	// debug output (avoid stack overflow)
	int		id;

	/* check if assertion failed */
	if (fExpr)
		return fExpr;

	/* display error message */
	wsprintfA(ach, "File %s, line %d", (LPSTR) szFile, iLine);
	MessageBeep(MB_ICONHAND);
	id = MessageBoxA(NULL, ach, "Assertion Failed",
		MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE);

	/* abort, debug, or ignore */
	switch (id)
	{

	case IDABORT:

		/* kill this application */
		ExitProcess(1);
		break;

	case IDRETRY:

		/* break into the debugger */
		DebugBreak();
		break;

	case IDIGNORE:

		/* ignore the assertion failure */
		break;

	}
	
	return FALSE;
}

#ifdef I386
#pragma optimize("", on)
#endif

int ssDebugLevel = 1;

void
dbgPrintf(char * szFormat, ...)
{
    char buf[256];
    va_list va;

    va_start(va, szFormat);
    wvsprintfA(buf, szFormat, va);
    va_end(va);

    OutputDebugStringA("SUMSERVE:");
    OutputDebugStringA(buf);
    OutputDebugStringA("\r\n");

}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\client\ssclient.h ===
/*
 * declaration of client library functions for
 * remote checksum server.
 *
 * statically linked to the calling program.
 */

/* -- functions defined in library -------------------------------  */

/* connect to the remote server */
HANDLE ss_connect(PSTR server);

/* send a request */
BOOL ss_sendrequest(HANDLE hpipe, long lCode, PSTR szPath, int lenpath, DWORD dwFlags);

/* receive a standard response block */
int ss_getresponse(HANDLE hpipe, PSSNEWRESP presp);

/* cleanly close a correctly-finished conversation */
void ss_terminate(HANDLE hpipe);

/* send a SSREQ_UNC */
BOOL ss_sendunc(HANDLE hpipe, PSTR password, PSTR server);

// I think this is obsolete - let's see if it still links without error.
// if so, please delete me!
// /* return a checksum for a file */
// ULONG ss_checksum(HANDLE hFile);

/* return a checksum for a block of data */
ULONG ss_checksum_block(PSTR block, int size);

/* checksum a single file using the checksum server */
BOOL ss_checksum_remote( HANDLE hpipe, PSTR path, ULONG * psum, FILETIME * pft, LONG * pSize,
                            DWORD *pAttr );

/* Call this before a sequence of ss_bulkcopy calls.  This should be
   considerably faster than calls to ss_copy_reliable.
   Call ss_endcopy afterwards (the copying is not complete until endcopy
   has completed.
*/
BOOL ss_startcopy(PSTR server,  PSTR uncname, PSTR password);

/* negative retcode = number of bad files,
   else number of files copied (none bad)
*/
int ss_endcopy(void);

/*
 * request to copy a file
 *
 * returns TRUE if it succeeded or FALSE if the connection was lost
 * TRUE only means the REQUEST was sent.
 */
BOOL ss_bulkcopy(PSTR server, PSTR remotepath, PSTR localpath, PSTR uncname,
                PSTR password);

/*
 * reliably copy a file (repeat (upto N times) until checksums match)
 * unc connection is made first if uncname and password are non-null
 */
BOOL ss_copy_reliable(PSTR server, PSTR remotepath, PSTR localpath, PSTR uncname,
                        PSTR password);

/* copy one file using checksum server */
BOOL ss_copy_file(HANDLE hpipe, PSTR remotepath, PSTR localpath);


VOID ss_setretries(int retries);

/* get a block of unspecified type */
int ss_getblock(HANDLE hpipe, PSTR block, int blocksize);

/* --- functions called from library - defined in calling program ------ */

/*
 * print a fatal error; allow 'cancel' button if fCancel TRUE. Returns
 * TRUE for OK.
 */
BOOL APIENTRY Trace_Error(HWND hwnd, LPSTR str, BOOL fCancel);

/*
 * print a status report on non-fatal error (eg 'retrying...').
 * can be no-op if status not desired.
 */
void Trace_Status(LPSTR str);

/*
 * client app must define this (can be set to NULL - used for MessageBox)
 */
extern HWND hwndClient;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\server\files.c ===
// !!! PipeCount needs a critical section?
/* Send a list of files across the named pipe as fast as possible
*
* The overall organisation:
*
* Sumserve receives requests over a named pipe.  (See sumserve.h)
* The requests can be for details of files or for the files
* themselves.  File details involve sending relatively small
* quantities of data and therefore no attempt is made to
* double-buffer or overlap execution.
*
* For a send-files request (SSREQ_FILES), the data is typically large,
* and can be a whole NT build which means sending hundreds
* of megabytes.  Such a transfer can take literally days and
* so optimisation to achieve maximum throughput is essential.
*
* To maximise throughput
* 1. The data is packed before sending
* 2. One thread per pipe does almost nothing except send data through
*    its pipe with all other work being done on other threads.
*
* Because we have had trouble with bad files being transmitted over
* the network, we checksum each file.  Windiff requires that we
* do a scan first before doing a copy, so we already have checksums.
* All we need to do is to check the newly received files.
* LATER: We should not require checksums in advance.  The checksuming
*        could be done by (yet another) pass, created if need be.  An extra
*         flag could be added to the request to indicate "send checksums".
*
* The packing is done by a separate program that reads from a file and
* writes to a file.  This means that we get three lots of file I/O
* (read; write; read) before the file is sent.  For a small
* file the disk cacheing may eliminate this, for a large file we
* probably pay the price.  A possible future enhancement is therefore
* to rewrite the packing to do it in-storage so that the file is read
* once only.  In the meantime we run threads to overlap the packing
* with the sending of the previous file(s).
*
* The main program sets up a named pipe which a client connects to.
* This is necessary because pipes are only half-duplex. i.e. the
* following hangs:
*   client read; server read; client write;
* The write hangs waiting for the client read.  We broadly speaking have one
* pipe running in each direction.
*
* To eliminate the overhead of setting up a virtual circuit for each
* file request there is a request code to send a list of files.
* The protocol (for the control pipe) is then as follows:
* 1. Typical session:
*    CLIENT                                      SERVER
*         ----<SSREQ_FILES------------------>
*         <------(SSRESP_PIPENAME,pipename)--
*         ----<SSREQ_NEXTFILE,filename>----->
*         ----<SSREQ_NEXTFILE,filename>----->
*               ...
*         --------<SSREQ_ENDFILES>---------->
*
* Meanwhile, asynchronously with this, the data goes back the other way like
*
*    CLIENT                                      SERVER
*         <-----<SSNEWRESP>----------
*         <---<1 or more SSNEWPACK>--
                ...
*         <-----<SSNEWRESP>----------
*         <---<1 or more SSNEWPACK>--
*               ...
*         <-----<End>----------------
*
* Even a zero length file gets 1 SSNEWPACK record.
* An Erroneous file (can't read etc) gets no SSNEWPACKs and a negative lCode
* in its SSNEWRESP.
* A file that goes wrong during read-in gets a packet length code of -1 or -2.
* The end of the sequence of SSNEWPACKs is signalled by a shorter
* than maximum length one.  If the file is EXACTLY n buffers long
* then an extra SSNEWPACK with zero bytes of data comes on the end.
*
* The work is broken into the following threads:
* Control thread (ss_sendfiles):
*       Receives lists of files to be sent
*       Creates pipes for the actual transmission
*       Creates queues (see below. Queue parameters must match pipes)
*       Puts filenames onto first queue
*       Destroys first queue at end.
* Packing thread
*       Takes file details from the packing queue
*       Packs the file (to create a temporary file)
*       Puts the file details (including the temp name) onto the reading queue
*       Destroys the reading queue at the end
* Reading thread
*       Takes the file details from the reading queue
*       Splits the file into a header and a list of data packets
*       and enqueues each of these on the Sending thread.
*       (Note this means no more than one reading thread to be running).
*       Erases the temp file
*       Destroys the sending queue at the end
* Sending thread
*       Takes the things from the sending thread and sends them
*
*  This whole scheme can be running for multiple clients, so we
*  need some instance data that defines which pipeline we are
*  running.  This is held in the instance data of the QUEUEs that
*  are created (retrieved by the queue emptiers by Queue_GetInstanceData).
*  The instance data at each stage is the handle of the following stage
*  i.e. the next QUEUE, or the hpipe of the data pipe for the last stage.
*  The current design only allows for one data pipe.  If we have
*  multiple data pipes then we need to solve the following problems:
*    1. Communication of the number and names of the data pipes
*       to the client (presumably across the control thread.
*    2. Error handling
*    3. Balancing the load between the pipes
*
* NORMAL SHUTDOWN:
* After the last element has been Put to the first Queue the main thread
* calls Queue_Destroy to destroy the first queue.  This will result in
* the queue being destroyed BUT NOT UNTIL THE LAST ELEMENT HAS BEEN GOT.
* When the last packing thread gets its ENDQUEUE it calls Queue_Destroy
* to destroy the next queue, and so on down the line.
*
* ERROR RECOVERY
* Errors can occur at almost any stage.
* The obvious implementation of having a global BOOL that tells
* whether a disaster has happened won't work because there
* could be multiple clients and only one of them with a disaster.
*
* An error in a single file is propagated forwards to the client end.
* An error in the whole mechanism (net blown away) can mean that the
* whole thing needs to be shut down.  In this case the error must
* be propagated backwards.  That works as follows:
* The Sending thread Queue_Aborts the SendQueue which it was Getting from.
* This results in Puts to this queue returning FALSE.
* Case 1. There are no more Puts anyway:
*    We are on the last file, the filling thread was about to Destroy the
*    queue anyway.  It does so.
* Case 2. The next Put gets a FALSE return code.
*    The thread attempting the Put does a Queue_Destroy on its output
*    queue and a Queue_Abort on its input queue.
*    This propagates all the way back until either the first queue
*    is aborted or it reaches a queue that was being destroyed anyway.
*    See Queue.h
* Once the Putting thread has done a Destroy on its output queue,
* the threads Getting from it (which are still running, even if
* they did the Abort) get STOPTHREAD/ENDQUEUE back from a Get.  The last Get
* to a queue that has had a Queue_Destroy done on it has a side effect
* of actually deallocating the queue.  In our case we only have one
* Getting thread, so what happens is that it Queue_Aborts the queue
* and then does a Queue_Get which WAITs.  When the Queue_Destroy comes in
* from the Putting thread, this releases the WAITing Getting thread which
* then actually deallocates the Queue.
*
* You can also get shutdown happening from both ends at once.  This happens
* when the control thread's pipe goes down getting names and the sending pipe
* also breaks.  (e.g. general net collapse or client aborted).
*/

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <gutils.h>
#include "sumserve.h"
#include "errlog.h"
#include "server.h"
#include "queue.h"

#if DBG
#define STATIC                  // allow for debug.
#else
#define STATIC static
#endif

/* SOCKETS / NAMED PIPES macros
 */
#ifdef SOCKETS
#define CLOSEHANDLE( handle )   closesocket( handle )
#define TCPPORT 1024
#else
#define CLOSEHANDLE( handle )   CloseHandle( handle )
#endif


//////////////ULONG ss_checksum_block(PSTR block, int size);

#define PIPEPREFIX "Sdpx"       // for making an unlikely pipe name
static PipeCount = 0;           // for making pipe names unique.


/* structure for recording all we need to know about a file as it
 * progresses along the chain of pipes                               */
typedef struct {
        FILETIME ft_create;
        FILETIME ft_lastaccess;
        FILETIME ft_lastwrite;
        DWORD    fileattribs;
        DWORD    SizeHi;        /* Anticipating files larger that 4GB! */
        DWORD    SizeLo;        /* Anticipating files larger that 4GB! */
        int      ErrorCode;
        long     Checksum;      /* Uunused except for debug. */
        char     TempName[MAX_PATH];    /* name of packed file at server */
        char     Path[MAX_PATH];        /* name of file to fetch */
        char     LocalName[MAX_PATH];   /* name of file at client end */
} FILEDETAILS;

/* forward declarations for procedures */
STATIC int PackFile(QUEUE Queue);
STATIC int ReadInFile(QUEUE Queue);
STATIC int SendData(QUEUE Queue);
STATIC void PurgePackedFiles(PSTR Ptr, int Len);
STATIC BOOL EnqueueName(QUEUE Queue, LPSTR Path, UINT BuffLen);
STATIC BOOL AddFileAttributes(FILEDETAILS * fd);

static void Error(PSTR Title)
{
        dprintf1(("Error %d from %s when creating data pipe.\n", GetLastError(), Title));
}

/* ss_sendfiles:
   Send a response naming the data pipe, collect further names
   from further client messages, all according to the protocol above.
   Start the data pipe and arrange that all the files are sent
   by getting them all enqueued on the first queue.
   Destroy PackQueue at the end.  Arrange for the other queues
   to be destroyed by the usual Queue mechanism, or destroy them
   explicitly if they never get started.
*/
BOOL
ss_sendfiles(HANDLE hPipe, long lVersion)
{       /* Create the queues and set about filling the first one */

        QUEUE PackQueue, ReadQueue, SendQueue;

#ifdef SOCKETS
        SOCKET hpSend;
        static BOOL SocketsInitialized = FALSE;
#else
        HANDLE hpSend;          /* the data pipe */
#endif /* SOCKETS */

        char PipeName[80];      /* The name of the new data pipe */
        BOOL Started = FALSE;   /* TRUE if something enqueued */


#ifdef SOCKETS
        if( !SocketsInitialized )
        {
                WSADATA WSAData;

                if( ( WSAStartup( MAKEWORD( 1, 1 ), &WSAData ) ) == 0 )
                {
                        SocketsInitialized = TRUE;
                }
                else
                {
                        printf("WSAStartup failed");
                }
        }
#endif

        {
                /****************************************
                We need security attributes for the pipe to let anyone other than the
                current user log on to it.
                ***************************************/

                /* Allocate DWORDs for the ACL to get them aligned.  Round up to next DWORD above */
                DWORD Acl[(sizeof(ACL)+sizeof(ACCESS_ALLOWED_ACE)+3)/4+4];    // + 4 by experiment!!
                SECURITY_DESCRIPTOR sd;
                PSECURITY_DESCRIPTOR psd = &sd;
                PSID psid;
                SID_IDENTIFIER_AUTHORITY SidWorld = SECURITY_WORLD_SID_AUTHORITY;
                PACL pacl = (PACL)(&(Acl[0]));
                SECURITY_ATTRIBUTES sa;

                if (!AllocateAndInitializeSid( &SidWorld, 1, SECURITY_WORLD_RID
                                              , 1, 2, 3, 4, 5, 6, 7
                                              , &psid
                                              )
                   ) {
                        Error("AllocateAndInitializeSid");
                        return FALSE;
                   }

                if (!InitializeAcl(pacl, sizeof(Acl), ACL_REVISION)){
                        Error("InitializeAcl");
                        return FALSE;
                }
                if (!AddAccessAllowedAce(pacl, ACL_REVISION, GENERIC_WRITE|GENERIC_READ, psid)){
                        Error("AddAccessAllowedAce");
                        return FALSE;
                }
                if (!InitializeSecurityDescriptor(psd, SECURITY_DESCRIPTOR_REVISION)){
                        Error("InitializeSecurityDescriptor");
                        return FALSE;
                }
                if (!SetSecurityDescriptorDacl(psd, TRUE, pacl, FALSE)){
                        Error("SetSecurityDescriptorDacl");
                        return FALSE;
                }
                sa.nLength = sizeof(sa);
                sa.lpSecurityDescriptor = psd;
                sa.bInheritHandle = TRUE;

                /* We now have a good security descriptor!  */

                /* Create the (new, unique) name of the pipe and then create the pipe */

                /* I am finding it hard to decide whether the following line (++PpipeCount)
                   actually needs a critical section or not.  The worst that could happen
                   would be that we got an attempt to create a pipe with an existing name.
                */
                ++PipeCount;
                sprintf(PipeName, "\\\\.\\pipe\\%s%d", PIPEPREFIX, PipeCount);

#ifdef SOCKETS
                if (!ss_sendnewresp( hPipe, SS_VERSION, SSRESP_PIPENAME
                                   , 0, 0, 0, TCPPORT, "")) {
                        dprintf1(( "Failed to send response on pipe %x naming new pipe.\n"
                              , hPipe));
                        return FALSE;           /* Caller will close hPipe */
                }

                if( !SocketListen( TCPPORT, &hpSend ) )
                {
                    dprintf1(("Could not create socket\n"));
                    return FALSE;
                }

                FreeSid(psid);
#else
                hpSend = CreateNamedPipe(PipeName,              /* pipe name */
                                PIPE_ACCESS_DUPLEX,     /* both read and write */
                                PIPE_WAIT|PIPE_TYPE_MESSAGE|PIPE_READMODE_MESSAGE,
                                1,              /* at most one instance */
                                10000,          /* sizeof(SSNEWPACK) + some for luck */
                                0,              /* dynamic inbound buffer allocation */
                                5000,           /* def. timeout 5 seconds */
                                &sa             /* security descriptor */
                                );
                FreeSid(psid);

                if (hpSend == INVALID_HANDLE_VALUE) {
                        dprintf1(("Could not create named data pipe\n"));
                        return FALSE;
                }
                dprintf1(("Data pipe %x called '%s' created for main pipe %x.\n", hpSend, PipeName, hPipe));

#endif /* SOCKETS */

        }




        /* Send the response which names the data pipe */

#ifndef SOCKETS
        if (!ss_sendnewresp( hPipe, SS_VERSION, SSRESP_PIPENAME
                           , 0, 0, 0, 0, PipeName)) {
                dprintf1(( "Failed to send response on pipe %x naming new pipe.\n"
                      , hPipe));
                CLOSEHANDLE(hpSend);
                return FALSE;           /* Caller will close hPipe */
        }

        if (!ConnectNamedPipe(hpSend, NULL)) {
                CLOSEHANDLE(hpSend);
                return FALSE;
        }
#endif /* NOT SOCKETS */
        //dprintf1(("Client connected to data pipe -- here we go...\n"));

        /* Create all the queues: Allow up to 10K file names to be queued
           up to 10 files to be packed in advance and 6 buffers of data to be
           read into main storage in advance:
                                  proc  MxMT MnQS MxQ Event   InstData   Name*/
        SendQueue = Queue_Create(SendData, 1, 0,  6, NULL, (DWORD)hpSend, "SendQueue");
        ReadQueue = Queue_Create(ReadInFile, 1, 0, 10, NULL, (DWORD)SendQueue, "ReadQueue");
        PackQueue = Queue_Create(PackFile, 3, 0, 99999, NULL, (DWORD)ReadQueue, "PackQueue");

        /* Abort unless it all worked */
        if (PackQueue==NULL || ReadQueue==NULL || SendQueue==NULL) {
                dprintf1(("Queues for pipe %x failed to Create.  Aborting...\n", hPipe));
                if (PackQueue) Queue_Destroy(PackQueue);
                if (ReadQueue) Queue_Destroy(ReadQueue);
                if (SendQueue) Queue_Destroy(SendQueue);
                CLOSEHANDLE(hpSend);
                return FALSE;           /* Caller will close hPipe */
        }


        /* Collect names from client and enqueue each one */
        for (; ; )
        {       SSNEWREQ Request;       /* message from client */
                DWORD    ActSize;       /* bytes read from (main) pipe */

                if (ReadFile(hPipe, &Request, sizeof(Request), &ActSize, NULL)){
                        if (Request.lVersion>SS_VERSION) {
                                dprintf1(("Bad version %d in file list request on pipe %x\n"
                                , Request.lVersion, hPipe));

                                break;

                        }
                        if (Request.lRequest!=LREQUEST) {
                                dprintf1(("Bad LREQUEST from pipe %x\n", hPipe));

                                break;
                        }
                        if (Request.lCode == -SSREQ_ENDFILES) {
                                dprintf1(("End of client's files list on pipe %x\n", hPipe));

                                /* This is the clean way to end */
                                Queue_Destroy(PackQueue);
                                if (!Started) {
                                        /* OK - so the clever clogs requested zero files */
                                        Queue_Destroy(ReadQueue);
                                        Queue_Destroy(SendQueue);
                                        /* Send a No More Files response */
#ifdef SOCKETS
                                        {
                                            SSNEWRESP resp;

                                            resp.lVersion = SS_VERSION;
                                            resp.lResponse = LRESPONSE;
                                            resp.lCode = SSRESP_END;
                                            resp.ulSize = 0;
                                            resp.ulSum = 0;
                                            resp.ft_lastwrite.dwLowDateTime = 0;
                                            resp.ft_lastwrite.dwHighDateTime = 0;

                                            send(hpSend, (PSTR) &resp, sizeof(resp), 0);
                                        }
#else
                                        ss_sendnewresp( hpSend, SS_VERSION, SSRESP_END
                                                , 0,0, 0,0, NULL);
#endif /* SOCKETS */
                                        CLOSEHANDLE(hpSend);
                                }
                                return TRUE;
                        }
                        if (Request.lCode != -SSREQ_NEXTFILE) {

                                dprintf1(( "Bad code (%d) in files list from pipe %x\n"
                                      , Request.lCode, hPipe));

                                break;
                        }
                }
                else {  DWORD errorcode = GetLastError();
                        switch(errorcode) {

                                case ERROR_NO_DATA:
                                case ERROR_BROKEN_PIPE:
                                        /* pipe connection lost - forget it */
                                        dprintf1(("main pipe %x broken on read\n", hPipe));
                                        break;
                                default:
                                        dprintf1(("read error %d on main pipe %x\n", errorcode, hPipe));
                                        break;
                        }
                        break;
                }
                if (!EnqueueName( PackQueue, Request.szPath
                                , (UINT)((LPBYTE)(&Request) + ActSize - (LPBYTE)(&Request.szPath))
                                )
                   ){
                        break;
                }
                Started = TRUE;
        } /* loop */

        /* only exit this way on error */
        /* Close the queues down.  Allow what's in them to run through */
        Queue_Destroy(PackQueue);
        if (!Started) {
                Queue_Destroy(ReadQueue);
                Queue_Destroy(SendQueue);

        }
        return FALSE;
} /* ss_sendfiles */


/* Attempt to Queue.Put Path onto Queue as a FILEDETAILS
   with default values for all other fields.
   Return TRUE or FALSE according as it succeeded.
*/
STATIC BOOL EnqueueName(QUEUE Queue, LPSTR Path, UINT BuffLen)
{
        FILEDETAILS fd;

        /* unpack Path and LocalName from "superstring" */
        strcpy(fd.Path, Path);
        BuffLen -= (strlen(Path)+1);
        if (BuffLen<0) return FALSE;  // Uh oh! strlen just looked at garbage.
        Path += strlen(Path)+1;
        BuffLen -= (strlen(Path)+1);
        if (BuffLen<0) return FALSE;  // Uh oh! strlen just looked at garbage.
        strcpy(fd.LocalName, Path);

        /* set defaults for every field */
        fd.ErrorCode = 0;
        fd.ft_lastwrite.dwLowDateTime = 0;
        fd.ft_lastwrite.dwHighDateTime = 0;
        fd.ft_create.dwLowDateTime = 0;
        fd.ft_create.dwHighDateTime = 0;
        fd.ft_lastaccess.dwLowDateTime = 0;
        fd.ft_lastaccess.dwHighDateTime = 0;
        fd.fileattribs = 0;
        fd.SizeHi = 0;
        fd.SizeLo = 0;
        fd.Checksum = 0;
        fd.TempName[0] = '\0';

        if(!Queue_Put(Queue, (LPBYTE)&fd, sizeof(fd))){
                dprintf1(("Put to pack queue failed\n"));
                return FALSE;
        }
        return TRUE;
} /* EnqueueName */


/* Dequeue elements from Queue, pack them and enqueue them on the next
   queue whose queue handle is the InstanceData of Queue.
   The ErrorCode in fd when Dequeued must be 0.                    ??? Incautious?
   Destroy the output queue at the end.
   On a serious error, Queue_Abort Queue and Queue_Destroy the output queue.
*/
STATIC int PackFile(QUEUE Queue)
{
        FILEDETAILS fd;         /* the queue element processed */
        QUEUE OutQueue;
        BOOL Aborting = FALSE;  /* TRUE means input has been aborted (probably output is sick) */
        DWORD ThreadId;
        ThreadId = GetCurrentThreadId();

        dprintf1(("File packer %d starting \n", ThreadId));         // can't quote hPipe, don't know it
        OutQueue = (QUEUE)Queue_GetInstanceData(Queue);

        for (; ; )
        {       int rc; /* return code from Queue_Get */

                rc = Queue_Get(Queue, (LPBYTE)&fd, sizeof(fd));
                if (rc==ENDQUEUE) {
                        dprintf1(("Packing thread %d ending.\n", ThreadId));
                        Queue_Destroy(OutQueue);
                        // dprintf1(("%d has done Queue_Destroy on ReadQueue.\n", ThreadId));
                        ExitThread(0);
                }
                if (rc==STOPTHREAD) {
                        dprintf1(("%d, a packing thread ending.\n", ThreadId));
                        ExitThread(0);
                }
                else if (rc<0) {
                        dprintf1(( "Packing thread %d aborting.  Bad return code %d from Get.\n"
                              , ThreadId, rc));
                        if (Aborting) break;    /* Touch nothing, just quit! */
                        Queue_Abort(Queue, NULL);
                        continue;               /* Next Queue_Get destroys Queue */
                }


                /* First add the file attributes to fd */
                AddFileAttributes(&fd);
                /* no need to look at return code fd.ErrorCode tells all */

                /* create temp filename */
                if (  0 != fd.ErrorCode
                   || 0==GetTempPath(sizeof(fd.TempName), fd.TempName)
                   || 0==GetTempFileName(fd.TempName, "sum", 0, fd.TempName)
                   )
                        fd.ErrorCode = SSRESP_NOTEMPPATH;

                /* Pack into temp file */
                if (fd.ErrorCode==0) {
                        BOOL bOK = FALSE;

                        //dprintf1(("%d Compressing file '%s' => '%s'\n", ThreadId, fd.Path, fd.TempName));

                        /* compress the file into this temporary file
                           Maybe it will behave badly if there's a large file or
                           no temp space or something...
                        */
                        try{
                            if (!ss_compress(fd.Path, fd.TempName)) {
                                fd.ErrorCode = SSRESP_COMPRESSFAIL;
                                dprintf1(("Compress failure on %d for %s\n", ThreadId, fd.Path));
                            }
                            else bOK = TRUE;
                        } except(EXCEPTION_EXECUTE_HANDLER) {
                            if (!bOK){
                                fd.ErrorCode = SSRESP_COMPRESSEXCEPT;
                                dprintf1(("Compress failure on %d for %s\n", ThreadId, fd.Path));
#ifdef trace
                                {       char msg[80];
                                        wsprintf( msg, "Compress failure on %d for %s\n"
                                                , ThreadId, fd.Path);
                                        Trace_File(msg);
                                }
#endif
                            }
                        }

                }

                //dprintf1(("%d Putting file '%s' onto Read Queue\n", ThreadId, fd.Path));
                if (!Queue_Put(OutQueue, (LPBYTE)&fd, sizeof(fd))) {
                        dprintf1(("%d Put to ReadQueue failed for %s.\n", ThreadId, fd.Path));
                        Queue_Abort(Queue, NULL);
                        DeleteFile(fd.TempName);

                        Aborting = TRUE;
                        /* bug:  If this Queue_Put fails on the very first Put,
                           then the next queue in the chain after OutQueue will
                           never come alive and so will never get Destroyed.
                           Worst it could cause is a memory leak. ???
                        */
                        continue; /* next Queue_Get destroys Queue */
                }
        }
        return 0;
} /* PackFile */



/* Use the file name in *fd and get its attributes (size, time etc)
   Add these to fd.  If it fails, set the ErrorCode in *fd
   to an appropriate non-zero value.
*/
STATIC BOOL AddFileAttributes(FILEDETAILS * fd)
{
        HANDLE hFile;
        BY_HANDLE_FILE_INFORMATION bhfi;

        hFile = CreateFile(fd->Path, GENERIC_READ, FILE_SHARE_READ,
                        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
        if (hFile == INVALID_HANDLE_VALUE) {

                fd->ErrorCode = SSRESP_CANTOPEN;
                return FALSE;

        }

        /* bug in GetFileInformationByHandle if file not on local
         * machine? Avoid it!
         */
        bhfi.dwFileAttributes = GetFileAttributes(fd->Path);
        if (bhfi.dwFileAttributes == 0xFFFFFFFF) {
                fd->ErrorCode = SSRESP_NOATTRIBS;
                CloseHandle(hFile);
                return FALSE;
        }

        if (!GetFileTime(hFile, &bhfi.ftCreationTime,
                         &bhfi.ftLastAccessTime, &bhfi.ftLastWriteTime)){

                fd->ErrorCode = SSRESP_NOATTRIBS;
                dprintf1(("Can't get file attributes for %s\n"
                      , (fd->Path?fd->Path : "NULL")));
                CloseHandle(hFile);
                return FALSE;
        }


        CloseHandle(hFile);

        {
                LONG err;
                fd->Checksum = checksum_file(fd->Path, &err);
                if (err!=0) {
                        fd->ErrorCode = SSRESP_CANTOPEN;
                        return FALSE;
                }
        }

        fd->ft_lastwrite = bhfi.ftLastWriteTime;
        fd->ft_lastaccess = bhfi.ftLastAccessTime;
        fd->ft_create = bhfi.ftCreationTime;
        fd->SizeHi = bhfi.nFileSizeHigh;
        fd->SizeLo = bhfi.nFileSizeLow;
        fd->fileattribs = bhfi.dwFileAttributes;
        return TRUE;

} /* AddFileAttributes */


/* Dequeue elements from Queue, Create on the output queue a SSNEWRESP
   followed by 1 or more SSNEWPACK structures, the last of which will be
   shorter than full length (zero length data if need be) to mark end-of-file.
   Files with errors already get zero SSNEWPACKs but bad code in SSNEWRESP.
   The output queue is the instance data of Queue.
*/
STATIC int ReadInFile(QUEUE Queue)
{       FILEDETAILS fd;                 /* The queue element processed */
        QUEUE OutQueue;
        HANDLE hFile;                   /* The packed file */
        SSNEWPACK Pack;                 /* output message */
        BOOL    ShortBlockSent;         /* no need to send another SSNEWPACK
                                           Client knows the file has ended */
        BOOL    Aborting = FALSE;       /* Input has been aborted. e.g. because output sick */


        dprintf1(("File reader starting \n"));
        OutQueue = (QUEUE)Queue_GetInstanceData(Queue);
        for (; ; )   /* for each file */
        {       int rc;         /* return code from Queue_Get */

                rc = Queue_Get(Queue, (LPBYTE)&fd, sizeof(fd));
                if (rc==STOPTHREAD || rc==ENDQUEUE) {
                        if (!Aborting) {
                                /* Enqueue a No More Files response */
                                SSNEWRESP resp;
                                resp.lVersion = SS_VERSION;
                                resp.lResponse = LRESPONSE;
                                resp.lCode = SSRESP_END;
                                if (!Queue_Put( OutQueue, (LPBYTE)&resp , RESPHEADSIZE)) {
                                        dprintf1(("Failed to Put SSRESP_END on SendQueue\n"));
                                }
                                //// dprintf1(( "Qued SSRESP_END:  %x %x %x %x...\n"
                                ////       , resp.lVersion, resp.lResponse, resp.lCode, resp.ulSize));
                        }
                        if (rc==ENDQUEUE)
                                Queue_Destroy(OutQueue);
                        dprintf1(("File reader ending\n"));
                        ExitThread(0);
                }
                else if (rc<0){
                        dprintf1(("ReadIn aborting.  Bad return code %d from Queue_Get.\n", rc));
                        if (Aborting) break;   /* All gone wrong.  Just quit! */
                        Queue_Abort(Queue, PurgePackedFiles);
                        CloseHandle(hFile);
                        Aborting = TRUE;
                        continue;               /* next Get gets STOPTHREAD */
                }

                //dprintf1(( "Reading file '%s' Error code %d\n"
                //      , (fd.TempName?fd.TempName:"NULL"), fd.ErrorCode
                //      ));

                if (fd.ErrorCode==0) {
                        /* open temp (compressed) file */
                        hFile = CreateFile(fd.TempName, GENERIC_READ, 0, NULL,
                                     OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
                        if (hFile == INVALID_HANDLE_VALUE) {
                                /* report that we could not read the file */
                                fd.ErrorCode = SSRESP_NOREADCOMP;
                                dprintf1(( "Couldn't open compressed file for %s %s\n"
                                      , fd.Path, fd.TempName));
                        }
                }
                if (  fd.ErrorCode==SSRESP_COMPRESSFAIL
                   || fd.ErrorCode==SSRESP_NOREADCOMP
                   || fd.ErrorCode==SSRESP_NOTEMPPATH
                   || fd.ErrorCode==SSRESP_COMPRESSEXCEPT
                   ) {
                        /* open original uncompressed file */
                        hFile = CreateFile(fd.Path, GENERIC_READ, 0, NULL,
                                     OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
                        if (hFile == INVALID_HANDLE_VALUE) {
                                /* report that we could not read the file */
                                fd.ErrorCode = SSRESP_NOREAD;
                                dprintf1(( "Couldn't open file %s \n", fd.Path));
                        }
                }

                /* Put the file name etc on the output queue as a SSNEWRESP */
                {       SSNEWRESP resp;
                        LPSTR LocalName;
                        resp.lVersion = SS_VERSION;
                        resp.lResponse = LRESPONSE;
                        resp.lCode = (fd.ErrorCode ? fd.ErrorCode: SSRESP_FILE);
                        resp.ulSize = fd.SizeLo;  /* file size  <= 4GB !!! */
                        resp.fileattribs = fd.fileattribs;
                        resp.ft_create = fd.ft_create;
                        resp.ft_lastwrite = fd.ft_lastwrite;
                        resp.ft_lastaccess = fd.ft_lastaccess;
                        resp.ulSum = fd.Checksum;
                        resp.bSumValid = FALSE;
                        strcpy(resp.szFile, fd.Path);
                        LocalName = resp.szFile+strlen(resp.szFile)+1;
                        strcpy(LocalName, fd.LocalName);

                        if(!Queue_Put( OutQueue, (LPBYTE)&resp
                                 , RESPHEADSIZE + strlen(resp.szFile)
                                                +strlen(LocalName)+2)
                          ) {
                                dprintf1(("Put to SendQueue failed.\n"));
                                Queue_Abort(Queue, PurgePackedFiles);
                                Aborting = TRUE;
                                CloseHandle(hFile);
                                continue;       /* next Get gets STOPTHREAD */
                        }
                        // dprintf1(( "Qued SSRESP_FILE: %x %x %x %x...\n"
                        //       , resp.lVersion, resp.lResponse, resp.lCode, resp.ulSize));
                }

                Pack.lSequence = 0;
                /* Loop reading blocks of the file and queueing them
                   Set fd.ErrorCode for failures.

                   I'm worried about file systems that give me short blocks in the
                   middles of files!!!
                */
                ShortBlockSent = FALSE;
                if (  fd.ErrorCode==SSRESP_COMPRESSFAIL
                   || fd.ErrorCode==SSRESP_NOREADCOMP
                   || fd.ErrorCode==SSRESP_NOTEMPPATH
                   || fd.ErrorCode==SSRESP_COMPRESSEXCEPT
                   || fd.ErrorCode==0
                   ) {
                    for(;;)   /* for each block */
                    {
                        DWORD ActSize;  /* bytes read */

                        if( !ReadFile( hFile, &(Pack.Data), sizeof(Pack.Data)
                                     , &ActSize, NULL) ) {
                                /* error reading temp file. */
                                if (ShortBlockSent) {
                                        /* Fine. End reached */
                                        /* Should check error was end of file !!! */
                                        CloseHandle(hFile);
                                        break; /* blocks loop */
                                }
                                dprintf1(( "Error reading temp file %s.\n"
                                      , (fd.TempName?fd.TempName:"NULL")));
                                CloseHandle(hFile);
                                dprintf1(("deleting bad file: %s\n", fd.TempName));
                                DeleteFile(fd.TempName);
                                Pack.ulSize = (ULONG)(-2);   /* tell client */
                                break; /* blocks loop */
                        }
                        else if (ActSize > sizeof(Pack.Data)) {
                                dprintf1(( "!!? Read too long! %d %d\n"
                                      , ActSize, sizeof(Pack.Data)));
                                Pack.ulSize = (ULONG)(-1);   /* tell client */
                        }
                        else Pack.ulSize = ActSize;

                        if (ActSize==0 && ShortBlockSent) {
                                /* This is normal! */
                                CloseHandle(hFile);
                                break;
                        }
                        else ++Pack.lSequence;


                        Pack.lPacket = LPACKET;
                        Pack.lVersion = SS_VERSION;
                        Pack.ulSum = 0;
////////////////////    Pack.ulSum = ss_checksum_block(Pack.Data, ActSize);    ///////////
                        if(!Queue_Put( OutQueue, (LPBYTE)&Pack
                                     ,  PACKHEADSIZE+ActSize)){
                                dprintf1(("Put to SendQueue failed.\n"));
                                Queue_Abort(Queue, PurgePackedFiles);
                                CloseHandle(hFile);
                                Aborting = TRUE;
                                break;  /* from blocks loop */
                        }
                        // dprintf1(( "Qued SSNEWPACK:  %x %x %x %x %x...\n"
                        //       , Pack.lVersion, Pack.lPacket, Pack.lSequence, Pack.ulSize
                        //       , Pack.ulSum));

                        if (ActSize<PACKDATALENGTH) {   /* Success. Finished */
                                ShortBlockSent = TRUE;
                        }

                    }
                } /* blocks */

                /* The data is all in storage now.  Delete the temp file
                   If there was no temp file (due to error) this still should be harmless.
                */
#ifndef LAURIE
                DeleteFile(fd.TempName);
#endif // LAURIE
                // dprintf1(("deleting file: %s\n", fd.TempName));

        } /* files */

        return 0;
} /* ReadInFile */


/* Dequeue elements from Queue, send them down the pipe whose
   handle is the instance data of Queue.
   On error Abort Queue.
*/
STATIC int SendData(QUEUE Queue)
{
        SSNEWPACK ssp;    /* relies on this being no shorter than a SSRESP */
#ifdef SOCKETS
        SOCKET OutPipe;
#else
        HANDLE OutPipe;
#endif /* SOCKETS */

        BOOL Aborting = FALSE;  /* TRUE means input has been aborted */

        dprintf1(("File sender starting \n"));
        if (!SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_HIGHEST))
            dprintf1(("Failed to set thread priority\n"));

#ifdef SOCKETS
        OutPipe = (SOCKET)Queue_GetInstanceData(Queue);
#else
        OutPipe = (HANDLE)Queue_GetInstanceData(Queue);
#endif
        try{
            for (; ; ) {
                int rc;         /* return code of Queue_Get */

                rc = Queue_Get(Queue, (LPBYTE)&ssp, sizeof(ssp));
                if (rc==STOPTHREAD || rc==ENDQUEUE)
                {
                        break;
                }
                else if (rc<0) {
                        dprintf1(("Send thread aborting.  Bad rc %d from Get_Queue.\n", rc));
                        if (Aborting) break;    /* All gone wrong. Just quit! */
                        Queue_Abort(Queue, NULL);
                        Aborting = TRUE;
                        continue; /* next Queue_Get destroys Queue */
                }

//      //      {       ULONG Sum;
//      //              if (ssp.lPacket==LPACKET) {
//      //                      if (ssp.ulSum != (Sum =ss_checksum_block(ssp.Data, ssp.ulSize))) {
//      //                              dprintf1(( "!!Checksum error at send.  Was %x should be %x\n"
//      //                                    , Sum, ssp.ulSum));
//      //                      }
//      //              }
//      //      }

#ifdef SOCKETS
                if(SOCKET_ERROR != send(OutPipe, (char far *)&ssp, ssp.ulSize+PACKHEADSIZE, 0) )

#else
                if (!ss_sendblock(OutPipe, (PSTR) &ssp, rc))
#endif /* SOCKETS */
                {
                        dprintf1(("Connection on pipe %x lost during send\n", OutPipe));
                        Queue_Abort(Queue, NULL);
                        Aborting = TRUE;
                        continue;  /* next Queue_Get destroys Queue */

                }
                ////dprintf1(( "Sent %x %x %x %x %x...\n"
                ////      , ssp.lVersion, ssp.lPacket, ssp.lSequence, ssp.ulSize, ssp.ulSum));
            } /* packets */
        }
        finally{
                /* kill the data pipe cleanly */
#ifndef SOCKETS
                FlushFileBuffers(OutPipe);
                DisconnectNamedPipe(OutPipe);
#endif /* NOT SOCKETS */
                CLOSEHANDLE(OutPipe);
                dprintf1(("Data send thread ending.\n"));
        }

        return 0;       /* exit thread */
} /* SendData */


/* This gets called once for every FILEDETAILS on the ReadInQueue
   to delete the temp files.
*/
STATIC void PurgePackedFiles(PSTR Ptr, int Len)
{       FILEDETAILS * pfd;

        pfd = (FILEDETAILS *)Ptr;
        // dprintf1(("purging file: %s\n", pfd->TempName));
        DeleteFile(pfd->TempName);

} /* PurgePackedFiles */

#if 0
/* produce a checksum of a block of data.
 *
 * This is undoubtedly a good checksum algorithm, but it's also compute bound.
 * For version 1 we turn it off.  If we decide in version 2 to turn it back
 * on again then we will use a faster algorithm (e.g. the one used to checksum
 * a whole file.
 *
 * Generate checksum by the formula
 *      checksum = SUM( rnd(i)*(1+byte[i]) )
 * where byte[i] is the i-th byte in the file, counting from 1
 *       rnd(x) is a pseudo-random number generated from the seed x.
 *
 * Adding 1 to byte ensures that all null bytes contribute, rather than
 * being ignored. Multiplying each such byte by a pseudo-random
 * function of its position ensures that "anagrams" of each other come
 * to different sums. The pseudorandom function chosen is successive
 * powers of 1664525 modulo 2**32. 1664525 is a magic number taken
 * from Donald Knuth's "The Art Of Computer Programming"
 */

ULONG
ss_checksum_block(PSTR block, int size)
{
        unsigned long lCheckSum = 0;            /* grows into the checksum */
        const unsigned long lSeed = 1664525;    /* seed for random Knuth */
        unsigned long lRand = 1;                /* seed**n */
        unsigned long lIndex = 1;               /* byte number in block */
        unsigned Byte;                          /* next byte to process in buffer */
        unsigned length;                        /* unsigned copy of size */

        length = size;
        for (Byte = 0; Byte < length ;++Byte, ++lIndex) {

                lRand = lRand*lSeed;
                lCheckSum += lIndex*(1+block[Byte])*lRand;
        }

        return(lCheckSum);
} /* ss_checksum_block */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\server\queue.h ===
/*
* A queue is (roughly speaking) a Monitor in the sense of Hoare's paper.
* It is an Object that includes synchronisation.
*
* It has the following methods:
* Create:  Create the queue and set it up ready for use.
* Destroy: Input to the queue is finished (it will deallocate itself later).
* Put:     Put an element on the queue (and release a Get thread)
* Get:     Take an element off the queue (but wait if queue was empty).
* Abort:   Everything on the queue, now or later is useless.  Shut down.
* GetInstanceData: Retrieve one DWORD which was set on Create.
* All the method names are prefixed with Queue_  e.g. Queue_Create.
*
* The Queue is designed to be filled by one (or more) thread(s) and emptied
* by other(s).  The queue itself creates the emptying threads.  The Create
* method specifies a procedure which will be used to empty it.
* Elements on the queue are strictly first-in first-out, but bear in
* mind that IF there are multiple emptying threads then although one thread
* may get its element before another in strict order, what happens next
* is not defined by the QUEUE mechanism.
*
* The QUEUE starts an emptying thread when
*       An element is put and the number of emptier threads started is fewer
*       than MaxEmptiers
* AND   the number of emptiers running is currently zero
*       OR  the queue has more than (MinQueueToStart elements times the number
*           of emptier threads already running)
*
* What this means is that the queue will start emptier threads as needed up
* to a limit of MaxEmptiers in such a way as to try to keep the queue down
* to no more than MinQueueToStart per running emptier thread.
*
* Emptier threads should stop themselves when they try to get an element but
* get the return code STOPTHREAD or ENDQUEUE.  These return codes are issued
* when
*       The queue is empty and there are already enough emptier threads waiting
* or    The queue is empty and has received a destroy request.
*
* If the thread receiving it is the last or only thread which has been started
* to empty this queue, it will get a ENDQUEUE return code, i.e. all the other
* emptying threads have already received a STOPTHREAD.  Otherwise it will
* just get STOPTHREAD.  The queue de-allocates itself when it returns ENDQUEUE.
* (No queue operation should be attempted after that).
* This happens when the queue has received a destroy request
* and the queue is empty and there are no emptier threads running (only
* occurs if there has never been a Put) or when the last emptier thread
* gets its ENDQUEUE.
*
* Queue_Create has an Event parameter. If this is not NULL then this event
* is Set when the queue is destroyed.  This Event is created by the calling
* process.  The caller must not Close it until the queue signals it.
*
* Information can be passed from the creator of the queue to the emptiers
* via the InstanceData parameter.  The value passed to Queue_Create can
* be retrieved by the emptiers by calling Queue_GetInstanceData.
*
* If the instance data is in fact a pointer, the queue is unaware of this
* and will never access or free the data pointed to.
*
* As well as controlling the emptier threads (starting more and more
* in response to a growing queue) we also need to control the filler,
* slowing it down if we are getting over-runs.  For instance if we
* have a broken output (say broken network connection) and a job which
* is sending 200MB of data, we don't want to have a 200MB queue build up!
*
* To fix this, we have an absolute limit on the size of the queue (yet
* another Create parameter).
*
* Error handling is tricky.  Errors which only affect individual elements
* should be handled by the Getters and Putters (e.g. by including in the
* data of an element a code which indicates that the item is in error).
* Errors which mean that the whole thing should be taken down can be handled
* as follows.  The QUEUE has a method Abort which works much as Destroy,
* but will purge the queue of any held elements first.
* As a QUEUE element may have storage chained off it which needs to be
* freed, there is a parameter on Abort which is the ABORTPROC.
* This is called once for each element on the queue to dispose of the element.
* The storage of the element itself is then freed.
* If the ABORTPROC is NULL then the storage of the element is just freed.
*
* If the queue were to be deallocated by the Getter then the next Put would
* trap, so the queue is left in existence, but the Putting threads
* get a FALSE return code when they try to Put after an Abort.  They should
* then do a Queue_Destroy (they may also want to Abort any queue they are
* themselves reading from). The Getting threads should meanwhile keep running.
* All except one will promptly get a STOPTHREAD.  The last one will block on
* the Get.  When the Destroy comes in, indicating that the Putting side has
* completely finished with the queue, the Get will be released with a final
* ENDQUEUE and the queue itself will be deallocated.
* Any attempt to use it after that will probably trap!
*
* Typical usage for a pipeline of queues where a thread is potentially one
* of several which are getting from one queue and putting to another is:
*
* for (; ; ){
*       len = Queue_Get(inqueue, data, maxlen);
*       if (len==STOPTHREAD){
*               tidy up;
*               ExitThread(0);
*       }
*       if (len=ENDQUEUE){
*               tidy up;
*               Queue_Destroy(outqueue);
*               ExitThread(0);
*       }
*       if (len<0) {
*               ASSERT you have a bug!
*       }
*
*       process(&data, &len);
*
*       if (!Queue_Put(outqueue, data, len)){
*               Queue_Abort(inqueue, InQueueAbortProc);
*       }
*
* }
*
*
* Note that there is a partial ordering in time of actions performed by the
* various parallel threads all running this loop which ensures that outqueue
* is handled properly, i.e. all the puts complete before the Destroy.
* This partial ordering is:
*
* Put_by_thread_A(outqueue)    Put_by_thread_B(outqueue)
*      |                             |
*      |                             |
*      v                             v
* Get_by_thread_A(inqueue)      Get_by_thread_A(inqueue)
*      |                             |
*      |                             |
*      v                             v
* STOPTHREAD_for_thread_A ----> ENDQUEUE_for_thread_B--> Queue_Destroy(outqueue)
*
* Which threads get the STOPTHREAD is indeterminate, but they all happen BEFORE
* the other thread gets the ENDQUEUE.
*
*/



/* Return codes from Queue_Get.  All non-successful return codes are <0 */

#define STOPTHREAD -1           /* Please tidy up and then ExitThread(0)
                                ** There is no queue element for you.
                                */
#define TOOLONG    -2           /* Your buffer was too short.  This was a no-op
                                ** the data is still on the queue.
                                */
#define ENDQUEUE   -3           /* This queue is now closing.  You are the last
                                ** thread active.  All the others (if any) have
                                ** had STOPTHREAD.
                                ** There is no queue element for you.
                                */
#define NEGTHREADS -4           /* Bug in queue.  Apparently negative number of
                                ** threads running!
                                */
#define SICKQUEUE  -5           /* Bug in queue.  Trying to get from an empty
                                ** queue.
                                */

typedef struct queue_tag * QUEUE;

typedef int (* EMPTYPROC)(QUEUE Queue);

/* Queue_Create:
** Return a queue handle for a newly created empty queue
** NULL returned means it failed.
*/
QUEUE Queue_Create( EMPTYPROC Emptier
                  , int MaxEmptiers
                  , int MinQueueToStart
                  , int MaxQueue
                  , HANDLE Event
                  , DWORD InstanceData
                  , PSZ Name            // of the queue
                  );


/* Queue_Put:
** Put an element from buffer Data of length Len bytes onto the queue.
** Will wait until the queue has room
** FALSE returned means the queue has been aborted and no
** put will ever succeed again.
** This operation may NOT be performed after a Queue_Destroy on Queue
*/
BOOL Queue_Put(QUEUE Queue, LPBYTE Data, UINT Len);


/* Queue_Get:
** Get an element from the queue.  (Waits until there is one)
** The element is copied into Data.  MaxLen is buffer length in bytes.
** Negative return codes imply no element is gotten.
** A negative return code is STOPTHREAD or ENDQUEUE or an error.
** On receiving STOPTHREAD or ENDQUEUE the caller should clean up and
** then ExitThread(0);
** If the caller is the last active thread getting from this queue, it
** will get ENDQUEUE rather than STOPTHREAD.
** Positive return code = length of data gotten in bytes.
*/
int Queue_Get(QUEUE Queue, LPBYTE Data, int MaxLen);


/* Queue_Destroy:
** Mark the queue as completed.  No further data may ever by Put on it.
** When the last element has been gotten, it will return ENDTHREAD to
** a Queue_Get and deallocate itself.  If it has an Event it will signal
** the event at that point.
** The Queue_Destroy operation returns promptly.  It does not wait for
** further Gets or for the deallocation.
*/
void Queue_Destroy(QUEUE Queue);

/* Queue_GetInstanceData:
** Retrieve the DWORD of instance data that was given on Create
*/
DWORD Queue_GetInstanceData(QUEUE Queue);

/* QUEUEABORTPROC:
*  Data points to the element to be aborted.  Len is its length in bytes.
*  See Queue_Abort.
*/
typedef void (* QUEUEABORTPROC)(LPSTR Data, int Len);

/* Queue_Abort:
** Abort the queue.  Normally called by the Getter.
** Discard all elements on the queue,
** If the queue has already been aborted this will be a no-op.
** It purges all the data elements.  If the Abort parameter is non-NULL
** then it is called for each element before deallocating it.  This
** allows storage which is hung off the element to be freed.
** After this, all Put operations will return FALSE.  If they were
** waiting they will promptly complete.  The queue is NOT deallocated.
** That only happens when the last Get completes after the queue has been
** Queue_Destroyed.  This means the normal sequence is:
**    Getter discovers that the queue is now pointless and does Queue_Abort
**    Getter does another Get (which blocks)
**    Putter gets FALSE return code on next (or any outstanding) Put
**    (Putter may want to propagates the error back to his source)
**    Putter does Queue_Destroy
**    The blocked Get is released and the queue is deallocated.
*/
void Queue_Abort(QUEUE Queue, QUEUEABORTPROC Abort);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\server\file.c ===
/*
 * file.c
 *
 * send files on request over a named pipe.
 *
 * supports requests to package up a file and send it over a named pipe.
 *
 * Geraint Davies, August 92
 */

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include "sumserve.h"
#include "errlog.h"
#include "server.h"



BOOL ss_compress(PSTR original, PSTR compressed);
ULONG ss_checksum_block(PSTR block, int size);

extern BOOL bNoCompression;   /* imported from sumserve.c  Read only here */

/*
 * given a pathname to a file, read the file, compress it  package it up
 * into SSPACKETs and send these via ss_sendblock to the named pipe.
 *
 *
 * each packet has a sequence number. if we can't read the file, we send
 * a single packet with sequence -1. otherwise, we carry on until we run out
 * of data, then we send a packet with 0 size.
 */
void
ss_sendfile(HANDLE hpipe, LPSTR file, LONG lVersion)
{
	SSPACKET packet;
	HANDLE hfile;
	int size;
	char szTempname[MAX_PATH];
	PSSATTRIBS attribs;
	BY_HANDLE_FILE_INFORMATION bhfi;

	dprintf1(("getting '%s' for %8x\n", file, hpipe));

	/*
	 * get the file attributes first
	 */
	hfile = CreateFile(file, GENERIC_READ, FILE_SHARE_READ,
				NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
	if (hfile == INVALID_HANDLE_VALUE) {

		/* report that we could not read the file */
		packet.lSequence = -1;
		ss_sendblock(hpipe, (PSTR) &packet, sizeof(packet));

		DeleteFile(szTempname);
		return;
	}
	/*
	 * seems to be a bug in GetFileInformationByHandle if the
	 * file is not on local machine - so avoid it.
	 */
	bhfi.dwFileAttributes = GetFileAttributes(file);
	GetFileTime(hfile, &bhfi.ftCreationTime,
			&bhfi.ftLastAccessTime, &bhfi.ftLastWriteTime);

	CloseHandle(hfile);

	/* create temp filename */
	GetTempPath(sizeof(szTempname), szTempname);
	GetTempFileName(szTempname, "sum", 0, szTempname);

	/* compress the file into this temporary file */
	if (bNoCompression || (!ss_compress(file, szTempname))) {

		/* try to open the original file */
		hfile = CreateFile(file, GENERIC_READ, FILE_SHARE_READ,
				NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

		dprintf1(("sending original file to %8x\n", hpipe));
	} else {
		/* open temp (compressed) file and send this */
		hfile = CreateFile(szTempname, GENERIC_READ, 0, NULL, OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL, 0);
		dprintf1(("sending compressed file to %8x\n", hpipe));
	}	

	if (hfile == INVALID_HANDLE_VALUE) {

		/* report that we could not read the file */
		packet.lSequence = -1;
		ss_sendblock(hpipe, (PSTR) &packet, sizeof(packet));

		DeleteFile(szTempname);
		return;
	}


	/* loop reading blocks of the file */
	for (packet.lSequence = 0;  ; packet.lSequence++) {

        	if(!ReadFile(hfile, packet.Data, sizeof(packet.Data), (LPDWORD)(&size), NULL)) {
			/* error reading file. send a -1 packet to
			 * indicate this
			 */
			packet.lSequence = -1;
			ss_sendblock(hpipe, (PSTR) &packet, sizeof(packet));
			break;
		}


		packet.ulSize = size;

		if (lVersion==0)
	        	packet.ulSum = ss_checksum_block(packet.Data, size);
		else
	        	packet.ulSum = 0;  /* checksum was compute-bound and overkill */

		if (size == 0) {
			/*
			 * in the last block, in the Data[] field,
			 * we place a SSATTRIBS struct with the file
			 * times and attribs
			 */
			attribs = (PSSATTRIBS) packet.Data;

			attribs->fileattribs = bhfi.dwFileAttributes;
			attribs->ft_create = bhfi.ftCreationTime;
			attribs->ft_lastaccess = bhfi.ftLastAccessTime;
			attribs->ft_lastwrite = bhfi.ftLastWriteTime;

		}


		if (!ss_sendblock(hpipe, (PSTR) &packet, sizeof(packet))) {
			dprintf1(("connection to %8x lost during copy\n", hpipe));
			break;
		}

		if (size == 0) {
			/* end of file */
			break;
		}
	}

	CloseHandle(hfile);
	DeleteFile(szTempname);

	return;
}

/*
 * compress a file. original is the pathname of the original file,
 * compressed is the pathname of the output compressed file.
 *
 * spawns a copy of compress.exe to compress the file, and waits for
 * it to complete successfully.
 */
BOOL
ss_compress(PSTR original, PSTR compressed)
{
   	char szCmdLine[MAX_PATH * 2];
	STARTUPINFO si;
	PROCESS_INFORMATION pi;
	DWORD exitcode;


	si.cb = sizeof(STARTUPINFO);
	si.lpDesktop = NULL;
	si.lpReserved = NULL;
	si.lpReserved2 = NULL;
	si.cbReserved2 = 0;
	si.lpTitle = "Sumserve Compression";
	si.dwFlags = STARTF_FORCEOFFFEEDBACK;

	sprintf(szCmdLine, "compress %s %s", original, compressed);


	if (!CreateProcess(NULL,
			szCmdLine,	
			NULL,
			NULL,
			FALSE,
			DETACHED_PROCESS |
			NORMAL_PRIORITY_CLASS,   //??? Can't we silence the console?
			NULL,
			NULL,
			&si,
			&pi)) {

		return(FALSE);
	}

	/* wait for completion. */
	WaitForSingleObject(pi.hProcess, INFINITE);
	if (!GetExitCodeProcess(pi.hProcess, &exitcode)) {
		return(FALSE);
	}

	/* close process and thread handles */
	CloseHandle(pi.hProcess);
	CloseHandle(pi.hThread);

	if (exitcode != 0) {
		dprintf1(("compress exit code %ld\n", exitcode));
		return(FALSE);
	} else {
		return(TRUE);
	}
} /* ss_compress */

/* produce a checksum of a block of data.
 *
 * This is undoubtedly a good checksum algorithm, but it's also compute bound.
 * For version 1 we turn it off.  If we decide in version 2 to turn it back
 * on again then we will use a faster algorithm (e.g. the one used to checksum
 * a whole file.
 *
 * Generate checksum by the formula
 *	checksum = SUM( rnd(i)*(1+byte[i]) )
 * where byte[i] is the i-th byte in the file, counting from 1
 *       rnd(x) is a pseudo-random number generated from the seed x.
 *
 * Adding 1 to byte ensures that all null bytes contribute, rather than
 * being ignored. Multiplying each such byte by a pseudo-random
 * function of its position ensures that "anagrams" of each other come
 * to different sums. The pseudorandom function chosen is successive
 * powers of 1664525 modulo 2**32. 1664525 is a magic number taken
 * from Donald Knuth's "The Art Of Computer Programming"
 */

ULONG
ss_checksum_block(PSTR block, int size)
{
	unsigned long lCheckSum = 0;         	/* grows into the checksum */
	const unsigned long lSeed = 1664525; 	/* seed for random Knuth */
	unsigned long lRand = 1;             	/* seed**n */
	unsigned long lIndex = 1;             	/* byte number in block */
	unsigned Byte;	                   	/* next byte to process in buffer */
	unsigned length;			/* unsigned copy of size */	
	
	length = size;
	for (Byte = 0; Byte < length ;++Byte, ++lIndex) {

		lRand = lRand*lSeed;
		lCheckSum += lIndex*(1+block[Byte])*lRand;
	}

	return(lCheckSum);
} /* ss_checksum_block */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\server\scan.c ===
/*
 * remote checksum server
 *
 * scan.c       file scanning and checksum module
 *
 * server creates a named pipe and waits for connections. a client connects,
 * and sends request packets to the server. One such request packet is
 * the SSREQ_SCAN request: we are given a pathname, and we are to checksum
 * every file below that point in the directory tree. We pass each
 * filename and checksum back individually in a separate response packet,
 * and finally a response packet saying that there are no more files.
 *
 * We sort everything into case-insensitive alphabetic order. In a given
 * directory, we pass out a sorted list of the files before we process
 * the subdirectories.
 *
 * Geraint, July 92
 */

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <gutils.h>
#include "sumserve.h"
#include "errlog.h"
#include "server.h"

/* module-internal type defns ---------------------------------------------*/

/* sorted list of file names in current dir is in a chained list of these */

typedef struct fnamelist {
        char szFile[MAX_PATH];
        struct fnamelist * next;
} FNAMELIST;    /* and PFNAMELIST already declared in server.h */


/* forward declaration of functions ---------------------------------------*/
PFNAMELIST ss_addtolist(PFNAMELIST head, PSTR name);
BOOL ss_processfile(HANDLE hpipe, long lVersion, LPSTR pAbsName, LPSTR pRelName
                  , BOOL bChecksum);
BOOL ss_processdir( HANDLE hpipe, long lVersion, LPSTR pAbsName, LPSTR pRelName
                  , BOOL bChecksum, BOOL fDeep);


/*--- externally called functions ----------------------------------------*/


/* ss_scan
 *
 * called from ss_handleclient on receipt of a SCAN request. scan the
 * directory passed in, and pass the files found back to the named pipe
 * one at a time. filenames returned should be relative to the
 * starting point (pRoot) and not absolute.
 *
 * returns TRUE if all ok; FALSE if an error occured and the connection
 * is lost.
 */
BOOL
ss_scan(HANDLE hpipe, LPSTR pRoot, LONG lVersion, BOOL bChecksum, BOOL fDeep)
{
        DWORD dwAttrib;
        LPSTR file;
        char buffer[MAX_PATH];

        /* check whether this is a directory or a file */
        dwAttrib = GetFileAttributes(pRoot);
        if (dwAttrib == -1) {
                /* file does not exist or is not visible */
                if (GetLastError() == ERROR_INVALID_PASSWORD) {
                        dprintf1(("password error\n"));
			Log_Write(hlogErrors, "password error on %s", pRoot);
                        if (!ss_sendnewresp( hpipe, lVersion, SSRESP_BADPASS
                                           , 0,  0, 0, 0, NULL)) {
                                return(FALSE);
                        }
                } else {
                        dprintf1(("file access error %d\n", GetLastError()));
			Log_Write(hlogErrors, "file error %d for %s", GetLastError(), pRoot);
                        if (!ss_sendnewresp( hpipe, lVersion, SSRESP_ERROR
                                           , GetLastError(), 0, 0, 0, pRoot)) {
                                return(FALSE);
                        }
                        if (!ss_sendnewresp( hpipe, lVersion, SSRESP_END
                                           , 0, 0, 0, 0, NULL)) {
                                return(FALSE);
                        }
                }
                return TRUE;
        }

        if (dwAttrib & FILE_ATTRIBUTE_DIRECTORY) {

                /* it is a directory - read all entries and
                 * then process the entries */


                /*
                 * create a "." directory and scan that
                 */
                if (!ss_sendnewresp( hpipe, lVersion, SSRESP_DIR
                                   , 0 , 0, 0, 0, ".")) {
                        return(FALSE);
                }

                if (!ss_processdir(hpipe, lVersion, pRoot, ".", bChecksum, fDeep) ) {
                        return(FALSE);
                }

        } else {
                /* pRoot is a file. we should just return the
                 * checksum and name, and then end.
                 *
                 * note that we should send a filename relative
                 * to pRoot for this file. Since pRoot is this file,
                 * it is not clear what we should send as the file name.
                 * in this case we split off the last component of the
                 * file name and return that
                 */
                if ( (file = strrchr(pRoot, '\\')) == NULL) {
                        /* there are no slashes in pRoot - so
                         * there is only one component: use that
                         */
                        file = pRoot;
                } else {
                        /* we found a / - skip it so we point at the
                         * final elem
                         */
                        file++;
                }
                /*
                 * make a copy of the filename, prepended with .\ so that
                 * it matches the normal format
                 */
                lstrcpy(buffer, ".\\");
                lstrcat(buffer, file);

                if (!ss_processfile(hpipe, lVersion, pRoot, buffer, bChecksum) ) {
                        return(FALSE);
                }

        }

        return(ss_sendnewresp( hpipe, lVersion, SSRESP_END
                             , 0, 0, 0, 0, NULL));
} /* ss_scan */



/* module-internal functions --------------------------------------------*/

/* read all entries in a directory, and create a sorted list of files
 * in that directory, and a sorted list of subdirs.
 *
 * for each file found, call ss_process_file to checksum and report on
 * the file.
 * for each subdir, report the name of the new dir and then
 * recursively call this function to scan it.
 *
 * We have two names for the dir- the absolute name (which we use to
 * scan it) and the name relative to the pRoot starting point - which
 * pass on to the client
 *
 * return TRUE if all ok, or FALSE if the connection has been lost
 */
BOOL
ss_processdir(  HANDLE hpipe,
                long lVersion,
                LPSTR pAbsName,         /* absolute name of dir (to open) */
                LPSTR pRelName,         /* relative name of dir (to report) */
                BOOL bChecksum,         /* TRUE iff checksums are wanted */
                BOOL fDeep              /* TRUE iff subdirs to be included */
                )
{
        PFNAMELIST pfiles = NULL;
        PFNAMELIST pdirs = NULL;
        PFNAMELIST pnext;
        HANDLE hFind;
        WIN32_FIND_DATA finddata;
        BOOL bMore;
        char szNewAbs[MAX_PATH], szNewRel[MAX_PATH];

        /* initiate a search of the directory - append
         * *.* to the directory name
         */
        lstrcpy(szNewAbs, pAbsName);
        lstrcat(szNewAbs, "\\*.*");

        hFind = FindFirstFile(szNewAbs, &finddata);

        if (hFind == INVALID_HANDLE_VALUE) {
                bMore = FALSE;
        } else {
                bMore = TRUE;
        }

        /* loop reading all entries in the directory */
        while (bMore) {

                /* was it a directory or a file ? */
                if (finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

                        /* ignore . and .. */
                        if ((strcmp(finddata.cFileName, ".") != 0)  &&
                           (strcmp(finddata.cFileName, "..") != 0)) {

                                /* insert in sorted list of dir names */
                                pdirs = ss_addtolist(pdirs, finddata.cFileName);
                        }

                } else {
                        /* insert in sorted list of file names */
                        pfiles = ss_addtolist(pfiles, finddata.cFileName);
                }

                /* get next entry in directory if there are any */
                bMore = FindNextFile(hFind, &finddata);
        }
        FindClose(hFind);

        /* we have now built the sorted lists.
         * go through the file list first and process each entry */
        for (pnext = pfiles; pnext != NULL; ) {

                /* build a new abs and relative name for this file */
                lstrcpy(szNewAbs, pAbsName);
                lstrcat(szNewAbs, "\\");
                lstrcat(szNewAbs, pnext->szFile);

                lstrcpy(szNewRel, pRelName);
                lstrcat(szNewRel, "\\");
                lstrcat(szNewRel, pnext->szFile);

                /* checksum the file and send response */
                if (!ss_processfile(hpipe, lVersion, szNewAbs, szNewRel, bChecksum)) {
                        return(FALSE);
                }

                /* free up the list entry */
                pfiles = pnext->next;
                LocalUnlock(LocalHandle( (PSTR) pnext));
                LocalFree(LocalHandle( (PSTR) pnext));
                pnext = pfiles;
        }
        if (!fDeep) return TRUE;

        /* loop through the subdirs and recursively scan those */
        for (pnext = pdirs; pnext != NULL; ) {

                /* build a new abs and relative name for this dir */
                lstrcpy(szNewAbs, pAbsName);
                lstrcat(szNewAbs, "\\");
                lstrcat(szNewAbs, pnext->szFile);

                lstrcpy(szNewRel, pRelName);
                lstrcat(szNewRel, "\\");
                lstrcat(szNewRel, pnext->szFile);

                /* send the name of the new dir to the client */
                if (!ss_sendnewresp( hpipe, lVersion, SSRESP_DIR
                                   , 0, 0, 0, 0, szNewRel)) {
                        return(FALSE);
                }

                if (!ss_processdir(hpipe, lVersion, szNewAbs, szNewRel, bChecksum, TRUE) ) {
                        return(FALSE);
                }

                /* free up the list entry */
                pdirs = pnext->next;
                LocalUnlock(LocalHandle( (PSTR) pnext));
                LocalFree(LocalHandle( (PSTR) pnext));
                pnext = pdirs;
        }
        return(TRUE);
} /* ss_processdir */


/* checksum a file and send the response to the client.
 *
 * return FALSE if the connection failed, TRUE otherwise
 */
BOOL
ss_processfile( HANDLE hpipe,
                long lVersion,
                LPSTR pAbsName,         /* absolute name of file (to open) */
                LPSTR pRelName,         /* relative name (to report) */
                BOOL bChecksum
                )
{
        HANDLE hfile;           /* file handle from CreateFile() */
        DWORD sum, size;
        FILETIME ft;

        hfile = CreateFile(pAbsName, GENERIC_READ, FILE_SHARE_READ,
                        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
        if (hfile == INVALID_HANDLE_VALUE) {
                /* We can't read the file, but we can still probably report some
                   properties because FindFirst / FindNext must have found it
                */

                WIN32_FIND_DATA finddata;
                HANDLE hFind;


                hFind = FindFirstFile(pAbsName, &finddata);
                if (hFind!=INVALID_HANDLE_VALUE){
                    FindClose(hFind);
		    Log_Write(hlogErrors, "Cannot read file %s", pAbsName);
                    /* report that we could not read the file */
                    return(ss_sendnewresp( hpipe, lVersion, SSRESP_CANTOPEN
                                         , finddata.nFileSizeLow, 0
                                         , finddata.ftLastWriteTime.dwLowDateTime
                                         , finddata.ftLastWriteTime.dwHighDateTime
                                         , pRelName));
                } else {
                    /* report that this file is cracked */
		    Log_Write(hlogErrors, "Cannot find file %s", pAbsName);
                    return(ss_sendnewresp( hpipe, lVersion, SSRESP_ERROR
                                         , GetLastError(), 0, 0, 0, pRelName));

                }

        } else {
                size = GetFileSize(hfile, NULL);
                if (!GetFileTime(hfile, NULL, NULL, &ft)) {
                        ft.dwLowDateTime = 0;
                        ft.dwHighDateTime = 0;
                }

                CloseHandle(hfile);
                if (bChecksum) {
                        LONG err;
                        sum = checksum_file(pAbsName, &err);
                        if (err!=0) {
                                return(ss_sendnewresp( hpipe, lVersion, SSRESP_ERROR
                                                      , GetLastError(),  0, 0, 0, pRelName));
                        }
                }
                else sum = 0;           /* no checksum wanted */

                return (ss_sendnewresp( hpipe, lVersion, SSRESP_FILE
                                      , size, sum
                                      , ft.dwLowDateTime, ft.dwHighDateTime
                                      , pRelName));
        }
}/* ss_processfile */

/* add a file or directory into a sorted single-linked list. alloc memory for
 * the new element from LocalAlloc
 *
 * we sort using utils_CompPath for a case-insensitive canonical sort,
 * but to match what goes on in the client world, we actually lower-case
 * everything first!
 *
 * return the new head of the list;
 */
PFNAMELIST
ss_addtolist(PFNAMELIST head, PSTR name)
{
        PFNAMELIST pnew, prev, pnext;

        /* alloc and fill a new entry */
        pnew = LocalLock(LocalAlloc(LHND, sizeof (FNAMELIST)));
        lstrcpy(pnew->szFile, name);

        /* always lower-case the names, or the comparison (utils_comppath)
         * will fail. even if we don't do the compare this time, this name
         * will be what we are compared against next time round...
         */
        AnsiLowerBuff(pnew->szFile, strlen(pnew->szFile));

        /* is the list empty ? */
        if (head == NULL) {
                /* yes, so return new head */
                return(pnew);
        }

        /* find place in list */
        prev = NULL;
        pnext = head;
        while ((pnext) && (utils_CompPath(pnext->szFile, pnew->szFile) <= 0)) {
                prev = pnext;
                pnext = pnext->next;
        }

        /* place found: we come between *prev and *pnext */
        pnew->next = pnext;
        if (prev == NULL) {
                /* we are new head of list */
                return(pnew);

        } else {
                prev->next = pnew;

                /* head of list still the same */
                return(head);
        }
}

/* UNC handling
 *
 * client can pass us a SSREQ_UNC: this contains both a password and a server
 * name (in the form \\server\share). We make a connection to it here and
 * remember the connection so that we can remove it (in ss_cleanconnections)
 * when the client session terminates.
 *
 * We are passed the head of a FNAMELIST in which we should store the connect
 * name for later cleanup. We return the new head of this list.
 *
 * the client will send this request if a unc-style named scan fails
 * with the SSRESP_BADPASS error.
 */
PFNAMELIST
ss_handleUNC( HANDLE hpipe, long lVersion
            , LPSTR password, LPSTR server, PFNAMELIST connects)
{
        NETRESOURCE resource;
        int errorcode;

        resource.lpRemoteName = server;
        resource.lpLocalName = NULL;
        resource.dwType = RESOURCETYPE_DISK;
        resource.lpProvider = NULL;

        errorcode = (int)WNetAddConnection2(&resource, password, NULL, 0);
        if (errorcode == NO_ERROR) {

                /* remember the connection name */
                connects = ss_addtolist(connects, server);

                /* report success */
                ss_sendnewresp( hpipe, lVersion, SSRESP_END
                              , 0, 0, 0, 0, NULL);
        } else {
    		Log_Write(hlogErrors, "Connect error %d for server %s", GetLastError(), server);
                dprintf1(("connect error %d for server %s\n", GetLastError(), server));
                /* report error */
                ss_sendnewresp( hpipe, lVersion, SSRESP_ERROR
                              , 0, 0, 0, 0, NULL);
        }
        return(connects);
} /* ss_handleUNC */

/* disconnect from all the sessions that this client asked us to make */
void
ss_cleanconnections(PFNAMELIST connects)
{
        PFNAMELIST server, next;

        for (server = connects; server != NULL; ) {

                WNetCancelConnection2(server->szFile, 0, 0);

                /* free block of memory */
                next = server->next;
                LocalUnlock(LocalHandle( (PSTR) server));
                LocalFree(LocalHandle( (PSTR) server));
                server = next;
        }
        connects = NULL;
} /* ss_cleanconnections */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\server\queue.c ===
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include "gutils.h"
#include "list.h"
#include "queue.h"

#define NAMELENGTH 20

typedef struct queue_tag{
        CRITICAL_SECTION CritSect;      /* to single-thread queue operations */
        HANDLE          Event;          /* Event to set when finished */
        HANDLE          Sem;            /* semaphore for Get to wait on */
        HANDLE          MaxSem;         /* semaphore for Put to wait on */
        int             Waiting;        /* num tasks waiting ~= -(Sem count) */
        LIST            List;           /* the queue itself */
        BOOL            Alive;          /* TRUE => no destroy request yet */
        BOOL            Aborted;        /* TRUE => the queue has been aborted */
        EMPTYPROC       Emptier;        /* the thread proc for emptying */
        int             MaxEmptiers;    /* max number of emptying threads */
        int             MinQueueToStart;/* start another emptier Q this long */
        int             MaxQueue;       /* absolute maximum size of queue
                                         * (for debug only)                  */
        int             Running;        /* number of emptiers in existence
                                         * Once an emptier is created this
                                         * stays positive until Queue_Destroy */
        DWORD           InstanceData;   /* instance data for emptier */
        char            Name[NAMELENGTH+1]; /* Name for the queue (for debug) */
} QUEUEDATA;

/* DOGMA:
   Any Wait must occur outside the critical section.

   Any update to the queue must occur inside the critical section.
   Any peeking from outside the critical section must be taken with salt.

   The queue has between 0 and MaxQueue elements on its list.  The Maximum
   is policed by MaxSem which is initialised to MaxQueue and Waited for by
   Put before adding an element and Released by Get whenever it takes an element
   off. MaxQueue itself is just kept around for debug purposes.

   Put must Wait before entering the critical section, therefore a failed Put
   (e.g. Put to an Aborted queue) will have already upset the semaphore and so
   must back it out.

   Abort clears the queue and so must adequately simulate the elements being
   gotten.  In fact it just does a single Release on MaxSem which ensures that
   a Put can complete.  Any blocked Puts will then succeed one at a time as
   each one backs out.

   Abort is primarily intended for use by the Getter.  Caling it before any
   element has ever been put is peculiar, but harmless.

   The minumum is policed by Sem which is initialised to 0, is Waited for by
   Get before getting an element and Released by Put whenever it puts one.
   Queue_Destroy neds to ensure that no thread will block on the Get but all
   threads will run into the empty queue and get STOPTHREAD or ENDQUEUE.  It
   therefore releases the semaphore as many times as there are threads running.

   Abort clears the queue and simulates the elements being gotten so that
   a single Get is left blocked waiting for the Destroy.  Whether there is a
   Get actually waiting at the moment is not interesting.  Even if there were
   not, one could be by the time the abort is done. There are the following
   cases (Not Alive means the Queue_Destroy is already in):
       Not empty  Alive      -> empty it, let all but 1 run.
       Not empty  Not Alive  -> empty it, let all run.
       Empty      Alive      ->           let all but 1 run.
       Empty      Not Alive  ->           let all run.
   Since Queue_Destroy has already released everything, the Not Alive cases
   need no further releasing.
*/


/* Queue_Create:
** Return a queue handle for a newly created empty queue
** NULL returned means it failed.
*/
QUEUE Queue_Create( EMPTYPROC Emptier           /* thread proc to start */
                  , int MaxEmptiers             /* max Getting threads */
                  , int MinQueueToStart         /* elements per thread */
                  , int MaxQueue                /* max elements on q */
                  , HANDLE Event                /* signal on deallocation */
                  , DWORD InstanceData
                  , PSZ Name
                  )
{       QUEUE Queue;

        Queue = (QUEUE)GlobalAlloc(GMEM_FIXED, sizeof(QUEUEDATA));
        if (Queue==NULL) {
                char msg[80];
                wsprintf(msg, "Could not allocate storage for queue %s", Name);
                /* Trace_Error(msg, FALSE); */
                return NULL;
        }
        InitializeCriticalSection(&Queue->CritSect);
        //??? should allow for failure!!!
        /* the value of about 10 million is chosen to be effectively infinite */
        Queue->Sem = CreateSemaphore(NULL, 0, 99999999, NULL);
        //??? should allow for failure!!!
        Queue->MaxSem = CreateSemaphore(NULL, MaxQueue, 99999999, NULL);
        //??? should allow for failure!!!
        Queue->Waiting = 0;
        Queue->List = List_Create();
        Queue->Alive = TRUE;
        Queue->Aborted = FALSE;
        Queue->Emptier = Emptier;
        Queue->MaxEmptiers = MaxEmptiers;
        Queue->MinQueueToStart = MinQueueToStart;
        Queue->MaxQueue = MaxQueue;
        Queue->Running = 0;
        Queue->Event = Event;
        Queue->InstanceData = InstanceData;
        strncpy(Queue->Name, Name, NAMELENGTH);
        Queue->Name[NAMELENGTH]='\0';   /* guardian */
        return Queue;
} /* Queue_Create */


/* Destroy:
** Internal procedure.
** Actually deallocate the queue and signal its event (if any)
** Must have already left the critical section
*/
static void Destroy(QUEUE Queue)
{
        //dprintf1(("Actual Destroy of queue '%s'\n", Queue->Name));
        DeleteCriticalSection(&(Queue->CritSect));
        CloseHandle(Queue->Sem);
        CloseHandle(Queue->MaxSem);
        List_Destroy(&(Queue->List));
        if (Queue->Event!=NULL) {
                SetEvent(Queue->Event);
        }
        GlobalFree( (HGLOBAL)Queue);
} /* Destroy */


/* Queue_Put:
** Put an element from buffer Data of length Len bytes onto the queue.
** Will wait until the queue has room
** FALSE returned means the queue has been aborted and no
** put will ever succeed again.
** This operation may NOT be performed after a Queue_Destroy on Queue
*/
BOOL Queue_Put(QUEUE Queue, LPBYTE Data, UINT Len)
{
        DWORD ThreadId;
        //dprintf1(("Put to queue '%s'\n", Queue->Name));
        WaitForSingleObject(Queue->MaxSem, INFINITE);
        EnterCriticalSection(&Queue->CritSect);
        //dprintf1(("Put running to queue '%s'\n", Queue->Name));
        if ((Queue->Aborted) || (!Queue->Alive)) {
                //dprintf1(("(legal) Queue_Put to Aborted queue '%s'\n", Queue->Name));
                LeaveCriticalSection(&Queue->CritSect);
                ReleaseSemaphore(Queue->MaxSem, 1, NULL); /* let next in */
                return FALSE;  /* Caller should soon please Queue_Destroy */
        }
        List_AddFirst(Queue->List, Data, Len);
        ReleaseSemaphore(Queue->Sem, 1, NULL);
        --Queue->Waiting;
        if (  Queue->Running < Queue->MaxEmptiers
           && (  Queue->Running<=0
              || List_Card(Queue->List) > Queue->MinQueueToStart*Queue->Running
              )
           ) {
                ++Queue->Running;
                LeaveCriticalSection(&Queue->CritSect);
                return ( (BOOL)CreateThread( NULL
                                           , 0
                                           , (LPTHREAD_START_ROUTINE)
                                                                Queue->Emptier
                                           , (LPVOID)Queue
                                           , 0
                                           , &ThreadId
                                           )
                       );
        }
        LeaveCriticalSection(&Queue->CritSect);
        return TRUE;
} /* Queue_Put */

/* Queue_Get:
** Get an element from the queue.  (Waits until there is one)
** The elemeent is copied into Data.  MaxLen is buffer length in bytes.
** Negative return codes imply no element is gotten.
** A negative return code is STOPTHREAD or ENDQUEUE or an error.
** On receiving STOPTHREAD or ENDQUEUE the caller should clean up and
** then ExitThread(0);
** If the caller is the last active thread getting from this queue, it
** will get ENDQUEUE rather than STOPTHREAD.
** Positive return code = length of data gotten in bytes.
*/
int Queue_Get(QUEUE Queue, LPBYTE Data, int MaxLen)
{       LPBYTE ListData;
        int Len;
        //dprintf1(("Get from queue '%s'\n", Queue->Name));
        EnterCriticalSection(&Queue->CritSect);
        //dprintf1(("Get running from queue '%s'\n", Queue->Name));
        if (List_IsEmpty(Queue->List)) {
                if (!Queue->Alive) {
                        --(Queue->Running);
                        if (Queue->Running<=0 ) {
                                if (Queue->Running<0 ) {
                                        char msg[80];
                                        wsprintf( msg
                                                , "Negative threads running on queue %s"
                                                , Queue->Name
                                                );
                                        // Trace_Error(msg, FALSE);
                                        // return NEGTHREADS; ???
                                }
                                LeaveCriticalSection(&Queue->CritSect);
                                Destroy(Queue);
                                return ENDQUEUE;
                        }
                        LeaveCriticalSection(&Queue->CritSect);
                        return STOPTHREAD;
                }
                if (Queue->Waiting>0) {
                        /* already another thread waiting, besides us */
                        --(Queue->Running);
                        LeaveCriticalSection(&(Queue->CritSect));
                        return STOPTHREAD;
                }
        }

        ++(Queue->Waiting);
        LeaveCriticalSection(&(Queue->CritSect));
        WaitForSingleObject(Queue->Sem, INFINITE);
        EnterCriticalSection(&(Queue->CritSect));

        /* If the queue is empty now it must be dead */
        if (List_IsEmpty(Queue->List)) {
                if (Queue->Alive && (!Queue->Aborted)) {
                        char msg[80];
                        wsprintf( msg
                                , "Queue %s empty but not dead during Get!"
                                , Queue->Name
                                );
                        // Trace_Error(msg, FALSE);
                        return SICKQUEUE;
                }
                else {
                        --(Queue->Running);
                        if (Queue->Running==0) {
                                LeaveCriticalSection(&(Queue->CritSect));
                                Destroy(Queue);
                                return ENDQUEUE;
                        }
                        LeaveCriticalSection(&(Queue->CritSect));
                        return STOPTHREAD;
                }
        }

        /* The queue is not empty and we are in the critical section. */
        ListData = List_Last(Queue->List);
        Len = List_ItemLength(ListData);
        if (Len>MaxLen) {
                ReleaseSemaphore(Queue->Sem, 1, NULL);
                --Queue->Waiting;
                LeaveCriticalSection(&Queue->CritSect);
                return TOOLONG;
        }
        memcpy(Data, ListData, Len);
        List_DeleteLast(Queue->List);
        LeaveCriticalSection(&Queue->CritSect);
        ReleaseSemaphore(Queue->MaxSem, 1, NULL);
        return Len;
} /* Queue_Get */


/* Queue_Destroy:
** Mark the queue as completed.  No further data may ever by Put on it.
** When the last element has been gotten, it will return ENDTHREAD to
** a Queue_Get and deallocate itself.  If it has an Event it will signal
** the event at that point.
** The Queue_Destroy operation returns promptly.  It does not wait for
** further Gets or for the deallocation.
*/
void Queue_Destroy(QUEUE Queue)
{
        EnterCriticalSection(&(Queue->CritSect));
        //dprintf1(("Queue_Destroy %s\n", Queue->Name));
        Queue->Alive = FALSE;
        if (  List_IsEmpty(Queue->List)) {
                if (Queue->Running==0) {
                        /* Only possible if nobody ever got started */
                        LeaveCriticalSection(&(Queue->CritSect));
                        Destroy(Queue);
                        return;
                }
                else {  int i;
                        /* The list is empty, but some threads could be
                           blocked on the Get (or about to block) so
                           release every thread that might ever wait on Get */
                        for (i=0; i<Queue->Running; ++i) {
                                ReleaseSemaphore(Queue->Sem, 1, NULL);
                                --(Queue->Waiting);
                        }
                        LeaveCriticalSection(&(Queue->CritSect));
                }
        }
        else LeaveCriticalSection(&(Queue->CritSect));
        return;
} /* Queue_Destroy */

/* Queue_GetInstanceData:
** Retrieve the DWORD of instance data that was given on Create
*/
DWORD Queue_GetInstanceData(QUEUE Queue)
{       return Queue->InstanceData;
} /* Queue_GetInstanceData */

/* Queue_Abort:
** Abort the queue.  Normally called by the Getter.
** Discard all elements on the queue,
** If the queue has already been aborted this will be a no-op.
** It purges all the data elements.  If the Abort parameter is non-NULL
** then it is called for each element before deallocating it.  This
** allows storage which is hung off the element to be freed.
** After this, all Put operations will return FALSE.  If they were
** waiting they will promptly complete.  The queue is NOT deallocated.
** That only happens when the last Get completes after the queue has been
** Queue_Destroyed.  This means the normal sequence is:
**    Getter discovers that the queue is now pointless and does Queue_Abort
**    Getter does another Get (which blocks)
**    Putter gets FALSE return code on next (or any outstanding) Put
**    (Putter may want to propagates the error back to his source)
**    Putter does Queue_Destroy
**    The blocked Get is released and the queue is deallocated.
*/

void Queue_Abort(QUEUE Queue, QUEUEABORTPROC Abort)
{
        /* This is similar to Destroy, but we call the Abort proc and
           free the storage of the elements.  Destroy allows them to run down.

           It is essential that the last Get must block until the sender does a
           Queue_Destroy (if it has not been done already).   The Alive flag
           tells whether the Queue_Destroy has been done.  All Getters except
           the last should be released.
        */
        //dprintf1(("Queue_Abort '%s'\n", Queue->Name));
        EnterCriticalSection(&(Queue->CritSect));
        //dprintf1(("Queue_Abort running for queue '%s'\n", Queue->Name));
        for (; ; ) {
                LPSTR Cursor = List_First(Queue->List);
                int Len;
                if (Cursor==NULL) break;
                Len = List_ItemLength(Cursor);
                if (Abort!=NULL) {
                        Abort(Cursor, Len);
                }
                List_DeleteFirst(Queue->List);
        }
        /* Queue is now empty.  Do not destroy.  That's for the Putters */
        Queue->Aborted = TRUE;

        /* make sure the next Queue_Get blocks unless Queue_Destroy already done */
        //dprintf1(("Queue_Abort '%s' fixing semaphore to block\n", Queue->Name));
        if (Queue->Alive){
                while(Queue->Waiting<0) {
                        WaitForSingleObject(Queue->Sem, INFINITE);
                        ++(Queue->Waiting);
                }
        }
        //dprintf1(("Queue_Abort '%s' semaphore now set to block\n", Queue->Name));

        LeaveCriticalSection(&(Queue->CritSect));
        ReleaseSemaphore(Queue->MaxSem, 1, NULL);
        return;
} /* Queue_Abort */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\server\sumserve.c ===
/*

 * remote checksum server
 *
 * sumserve.c           main module
 *
 * program to supply lists of files and checksums from a remote server.
 * This program runs remotely, and is queried over a named pipe: a client
 * connects to us, and gives us a pathname. We then send him one at a time,
 * the names of all the files in the file tree starting at that path, together
 * with a checksum for the files.
 * Useful for comparing file trees that are separated by a slow link.
 *
 * outline:
 *      this module:    named pipe creation and connects - main loop
 *
 * 	service.c	service control manager interface (start/stop)
 *
 *      scan.c:         service code that scans and checksums
 *
 *
 * Geraint Davies, july 92
 */

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include "sumserve.h"
#include "errlog.h"
#include "server.h"

#include "list.h"


BOOL bNoCompression = FALSE;
BOOL bTracing = FALSE;


/*
 * error and activity log
 */
HLOG hlogErrors;
HLOG hlogEvents;


/*
 * we keep one of these on the listConnections for each current
 * connection. It is created by a call to ss_logon, and should be
 * removed by a call to ss_logoff when the connection terminates.
 */
typedef struct _connect {
    FILETIME ftLogon;
    char Username[256];
} CONNECT, * PCONNECT;

/*
 * list of current connections - protect by critsecConnects;
 */
CRITICAL_SECTION critsecConnects;
LIST listConnects;

PCONNECT ss_logon(HANDLE hpipe);
VOID ss_logoff(PCONNECT);
VOID ss_sendconnects(HANDLE hpipe);



/* forward declarations of procedures ----------------------------- */
BOOL ss_handleclient(LPVOID arg);
BOOL ss_readmessage(HANDLE hpipe, LPSTR buffer, int size);
void ParseArgs(DWORD dwArgc, LPTSTR *lpszArgv);

/* functions ------------------------------------------------------- */

#define trace
#ifdef trace

        static HANDLE hTraceFile = INVALID_HANDLE_VALUE;

        void Trace_File(LPSTR msg)
        {
                DWORD nw; /* number of bytes writtten */

                if (!bTracing) return;

                if (hTraceFile==INVALID_HANDLE_VALUE)
                        hTraceFile = CreateFile( "sumserve.trc"
                                               , GENERIC_WRITE
                                               , FILE_SHARE_WRITE
                                               , NULL
                                               , CREATE_ALWAYS
                                               , 0
                                               , NULL
                                               );

                WriteFile(hTraceFile, msg, lstrlen(msg)+1, &nw, NULL);
                FlushFileBuffers(hTraceFile);

        } /* Trace_File */

        void Trace_Close(void)
        {
                if (hTraceFile!=INVALID_HANDLE_VALUE)
                        CloseHandle(hTraceFile);
                hTraceFile = INVALID_HANDLE_VALUE;

        } /* Trace_Close */

typedef struct {
        DWORD dw[5];
} BLOCK;

#endif  //trace

static void Error(PSTR Title)
{
        Log_Write(hlogErrors, "Error %d from %s when creating main pipe", GetLastError(), Title);
}


HANDLE
SS_CreateServerPipe(PSTR pname)
{


    /****************************************
    We need security attributes for the pipe to let anyone other than the
    current user log on to it.
    ***************************************/

    /* Allocate DWORDs for the ACL to get them aligned.  Round up to next DWORD above */
    DWORD Acl[(sizeof(ACL)+sizeof(ACCESS_ALLOWED_ACE)+3)/4+4];  // +4 by experiment!!
    SECURITY_DESCRIPTOR sd;
    PSECURITY_DESCRIPTOR psd = &sd;
    PSID psid;
    SID_IDENTIFIER_AUTHORITY SidWorld = SECURITY_WORLD_SID_AUTHORITY;
    PACL pacl = (PACL)(&(Acl[0]));
    SECURITY_ATTRIBUTES sa;
    HANDLE hpipe;

    if (!AllocateAndInitializeSid( &SidWorld, 1, SECURITY_WORLD_RID
                                  , 1, 2, 3, 4, 5, 6, 7
                                  , &psid
                                  )
       ) {
            Error("AllocateAndInitializeSid");
	    return(INVALID_HANDLE_VALUE);
       }

    if (!InitializeAcl(pacl, sizeof(Acl), ACL_REVISION)){
            Error("InitializeAcl");
	    return(INVALID_HANDLE_VALUE);
    }
    if (!AddAccessAllowedAce(pacl, ACL_REVISION, GENERIC_WRITE|GENERIC_READ, psid)){
            Error("AddAccessAllowedAce");
	    return(INVALID_HANDLE_VALUE);
    }
    if (!InitializeSecurityDescriptor(psd, SECURITY_DESCRIPTOR_REVISION)){
            Error("InitializeSecurityDescriptor");
	    return(INVALID_HANDLE_VALUE);
    }
    if (!SetSecurityDescriptorDacl(psd, TRUE, pacl, FALSE)){
            Error("SetSecurityDescriptorDacl");
	    return(INVALID_HANDLE_VALUE);
    }
    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = psd;
    sa.bInheritHandle = TRUE;

    /* We now have a good security descriptor!  */

    dprintf1(("creating new pipe instance\n"));

    hpipe = CreateNamedPipe(pname,            /* pipe name */
                    PIPE_ACCESS_DUPLEX,     /* both read and write */
                    PIPE_WAIT|PIPE_TYPE_MESSAGE|PIPE_READMODE_MESSAGE,
                    PIPE_UNLIMITED_INSTANCES,
                    0, 0,                   /* dynamic buffer allocation*/
                    5000,                   /* def. timeout 5 seconds */
                    &sa                     /* security descriptor */
            );
    FreeSid(psid);

    if (hpipe == INVALID_HANDLE_VALUE) {
            Error("CreateNamedPipe");
	    return(INVALID_HANDLE_VALUE);
    }

    return(hpipe);
}

/* program main loop
 *
 * creates the named pipe, and loops waiting for client connections and
 * calling ss_handleclient for each connection. only exits when told
 * to by a client.
 *
 * currently permits only one client connection at once.
 */
VOID
MainLoop(DWORD dwArgc, LPTSTR *lpszArgv)
{
        char msg[400];
        HANDLE hpipe;
        DWORD threadid;


        ParseArgs(dwArgc, lpszArgv);


	/*
	 * initialise error and activity logs
	 */
	hlogErrors = Log_Create();
	hlogEvents = Log_Create();
	Log_Write(hlogEvents, "Checksum service started");

	/* initialise connection list and protective critsec */
	InitializeCriticalSection(&critsecConnects);
	List_Init();
	listConnects = List_Create();


        if (bTracing){
                SYSTEMTIME st;
                char msg[120];
                GetSystemTime(&st);
                wsprintf(msg, "Sumserve trace, started %hd:%hd on %hd/%hd/%hd (British notation)\n"
                        , st.wHour, st.wMinute, st.wDay, st.wMonth, st.wYear);
        }


        /* create the named pipe at the known name NPNAME on this server */

        /* build the correct syntax for a named pipe on the local machine,
         * with the pipe name being NPNAME - thus the full name should be
         * \\.\pipe\NPNAME
         */
        sprintf(msg, "\\\\.\\pipe\\%s", NPNAME);

        /*
         * loop creating instances of the named pipe and connecting to
         * clients.
         *
         * When a client connects, we spawn a thread to handle him, and
         * we create another instance of the named pipe to service
         * further clients.
         *
         * if we receive a quit message (TRUE return from handleclient)
         * we exit here so that no new clients will be connected.
         * the process will exit when all the client requests are
         * finished.
         */
        for (;;) {

    		hpipe = SS_CreateServerPipe(msg);
		if (hpipe == INVALID_HANDLE_VALUE) {
		    return;
		}

                dprintf1(("Waiting for client to connect to main pipe %x\n", hpipe));

                if (ConnectNamedPipe(hpipe, NULL)) {


                        /* we have a client connection */
                        dprintf1(("Client has connected\n"));


                        /*
                         * create a thread to service all requests
                         */
                        CreateThread(NULL, 0,
                                     (LPTHREAD_START_ROUTINE) ss_handleclient,
                                     (LPVOID) hpipe, 0, &threadid);

                        dprintf1(("created thread %ld for pipe %x\n", threadid, hpipe));

                }
        }
#ifdef trace
                        Trace_Close();
#endif


	/* free up logs */
	Log_Delete(hlogErrors);
	Log_Delete(hlogEvents);

	List_Destroy(&listConnects);
	DeleteCriticalSection(&critsecConnects);


        return;
}

/* collect arguments: -n means bNoCompression = TRUE, -t means bTracing = TRUE */
void
ParseArgs(DWORD dwArgc, LPTSTR *lpszArgv)
{
	DWORD i;
	PSTR ps;

	for (i = 1; i < dwArgc; i++) {

	    ps = lpszArgv[i];
	

                /* is this an option ? */
                if ((ps[0] == '-') || (ps[0] == '/')) {
                        switch(ps[1]) {

                        case 'n':
                        case 'N':
                                bNoCompression = TRUE;
                                break;
#ifdef trace
                        case 't':
                        case 'T':
                                bTracing = TRUE;
                                break;
#endif //trace
                        default:
                                Log_Write(hlogErrors, "Bad option(s) ignored");
                                return;
                        }
                }
                else {
                        Log_Write(hlogErrors, "Bad argument(s) ignored");
                        return;
                }
        }
} /* ParseArgs */

/*
 * handle a client connection. This routine is called in a separate thread
 * to service a given client.
 *
 * loop reading messages until the client sends a session exit or
 * program exit code, or until the pipe connection goes away.
 *
 * return TRUE if the server is to exit (indicated by a program exit
 * command SSREQ_EXIT from the client)
 */

BOOL
ss_handleclient(LPVOID arg)
{
        HANDLE hpipe = (HANDLE) arg;

        SSREQUEST req;
        SSNEWREQ newreq;
        LPSTR p1, p2;
        PFNAMELIST connects = NULL;
        BOOL bExitServer = FALSE;
        LONG lVersion = 0;
        BOOL bDirty = TRUE;     /* cleared on clean exit */
	PCONNECT pLogon;


   try {

       /* make a logon entry in the connections table*/
       pLogon = ss_logon(hpipe);




        // dprintf1(("Client handler for pipe %x\n", hpipe));
        /* loop indefinitely - exit only from within the loop if
         * the connection goes away or we receive an exit command
         */
        for (; ; ) {

                /* read a message from the pipe  - if false,
                 * connection is dropped.
                 */
                if (!ss_readmessage(hpipe, (LPSTR) &newreq, sizeof(newreq))) {

                        break;
                }
                if (newreq.lCode<0) {
                        lVersion = newreq.lVersion;
                        dprintf1(("Client for pipe %x is at Version %d\n", hpipe, lVersion));
                        newreq.lCode = -newreq.lCode;
                }
                else {  /* juggle the fields to get them right */
                        memcpy(&req, &newreq, sizeof(req));
                        /* lCode is already in the right place */
                        dprintf1(("Version 0 (i.e. down level client) for pipe %x\n", hpipe));
                        newreq.lVersion = 0;
                        memcpy(&newreq.szPath, &req.szPath, MAX_PATH*sizeof(char));
                }

                if (newreq.lVersion>SS_VERSION)   /* WE are down level! */
                {
                        ss_sendnewresp( hpipe, SS_VERSION, SSRESP_BADVERS
                                      , 0,0, 0,0, NULL);
                        /* Sorry - can't help - clean exit */
                        Log_Write(hlogErrors,
			    "server is down level! Please upgrade! Client wants %d"
                              , newreq.lVersion);

                        FlushFileBuffers(hpipe);
                        break;

                }

                if (newreq.lCode == SSREQ_EXIT) {
                        /* exit the program */
                        Log_Write(hlogErrors, "Server exit request from %s - Ignored",
				pLogon->Username);

                        /* clean exit */
                        FlushFileBuffers(hpipe);


                        /*
			 * now exit the server -
			 * returning bExitServer from this function will
			 * cause MainLoop to exit. This will result in
			 * the service being stopped, and the process exiting.
			 */
                        bExitServer = TRUE;
#ifdef trace
                        Trace_Close();
#endif
                        break;




                } else if (newreq.lCode == SSREQ_END) {

                        /* clean exit */
                        dprintf1(("Server end session request for pipe %x\n", hpipe));
                        FlushFileBuffers(hpipe);
                        break;

                } else if (newreq.lCode == SSREQ_SCAN
                        || newreq.lCode == SSREQ_QUICKSCAN) {

                        /* please scan the following file or dir,
                         * and return the list of files and
                         * checksums.
                         */
			Log_Write(hlogEvents, "%s scan for %s",
				pLogon->Username, newreq.szPath);


#ifdef SECURE
                        /* lower security to the client's level */
                        if (!ImpersonateNamedPipeClient(hpipe)) {
                                dprintf1(("Client impersonate failed %d\n",
                                        GetLastError() ));
                        }
#endif
                        if (!ss_scan( hpipe, newreq.szPath, lVersion
                                    , (newreq.lCode == SSREQ_SCAN)
                                    , 0!=(newreq.lFlags&INCLUDESUBS)
                                    )
                           ) {
                                /* return to our own security token */

                                RevertToSelf();

                                dprintf1(("connection lost during scan for pipe %x\n", hpipe));
                                break;
                        }
                        /* return to our own security token */
                        RevertToSelf();

                } else if (newreq.lCode == SSREQ_UNC) {

                        dprintf1(("connect request for pipe %x\n", hpipe));
                        /* this packet has two strings in the buffer, first
                         * is the password, second is the server
                         */
                        p1 = newreq.szPath;
                        p2 = &p1[strlen(p1) + 1];

                        /* remember to add the connect name to our list
                         * of servers to disconnect from at end of client
                         * session
                         */
                        connects = ss_handleUNC (hpipe, lVersion, p1, p2
                                               , connects);

                } else if (newreq.lCode == SSREQ_FILE) {

    			Log_Write(hlogEvents, "%s copy file %s",
	    			    pLogon->Username, newreq.szPath);

                        ss_sendfile(hpipe, newreq.szPath, lVersion);

                } else if (newreq.lCode == SSREQ_FILES) {

    			Log_Write(hlogEvents, "%s bulk copy request",
				pLogon->Username);

                        if (!ss_sendfiles(hpipe, lVersion)) {
                                RevertToSelf();
                                dprintf1(("Sendfiles completed with error on pipe %x\n", hpipe));
                                break;
                        }

                } else if (newreq.lCode == SSREQ_NEXTFILE) {

                        Log_Write(hlogErrors,
			    "file list from %s (pipe %x) request out of sequence! (ignored)",
    				pLogon->Username, hpipe);

		} else if (newreq.lCode == SSREQ_ERRORLOG) {
    			Log_Send(hpipe, hlogErrors);

		} else if (newreq.lCode == SSREQ_EVENTLOG) {
    			Log_Send(hpipe, hlogEvents);

		} else if (newreq.lCode == SSREQ_CONNECTS) {
    			ss_sendconnects(hpipe);

                } else {
                        /* packet error ?  - carry on anyway */
                        Log_Write(hlogErrors,
			    "error in message from %s code: %d",
			    pLogon->Username, newreq.lCode);
                }
        }
        /* we break out of the loop at end of client session */

        /* close this pipe instance */
        DisconnectNamedPipe(hpipe);
        CloseHandle(hpipe);

        /* clean all connections made for this client */
        ss_cleanconnections(connects);

        /* exit this server thread */
        dprintf1(("thread %ld exiting on behalf of pipe %x\n", GetCurrentThreadId(), hpipe));
        bDirty = FALSE;

    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        if (bDirty) {
                Log_Write(hlogErrors,
		    "!!Exception on thread %ld.  Exiting on behalf of %s"
                      , GetCurrentThreadId(), pLogon->Username);
                try {
                        DisconnectNamedPipe(hpipe);
                        CloseHandle(hpipe);

                }
                except (EXCEPTION_EXECUTE_HANDLER) {
                        /* Oh dear - let's just go home! */
                }

        }
        else
                dprintf1(( "Thread %ld  exiting on behalf of pipe %x\n"
                      , GetCurrentThreadId(), hpipe));
    }


    /* note that we have logged off */
    ss_logoff(pLogon);

    return(bExitServer);


} /* ss_handle_client */


/* build and send a response packet to the client. Check for network
 * errors, and retry (unless the pipe is broken) up to 10 times.
 *
 * if write succeeds - return TRUE.
 * if failure - return FALSE to indicate connection is dropped.
 */
BOOL
ss_sendnewresp( HANDLE hpipe
              , long lVersion
              , long lCode
              , ULONG ulSize      /* used for Win32 error code for SSRESP_ERRROR */
              , ULONG ulSum
              , DWORD dwLowTime
              , DWORD dwHighTime
              , PSTR szFile
              )
{
        SSNEWRESP resp;

        if (lVersion==0) {
                return ss_sendresponse(hpipe, lCode, ulSize, ulSum, szFile);
        }
        resp.lVersion = lVersion;
        resp.lResponse = LRESPONSE;
        resp.lCode = lCode;
        resp.ulSize = ulSize;
        resp.ulSum = ulSum;
        resp.ft_lastwrite.dwLowDateTime = dwLowTime;
        resp.ft_lastwrite.dwHighDateTime = dwHighTime;
        if (szFile != NULL) {
                lstrcpy(resp.szFile, szFile);
        }
        return(ss_sendblock(hpipe, (PSTR) &resp, sizeof(resp)));
} /* ss_sendnewresp */


/* build and send a response packet to the client. Check for network
 * errors, and retry (unless the pipe is broken) up to 10 times.
 *
 * if write succeeds - return TRUE.
 * if failure - return FALSE to indicate connection is dropped.
 */
BOOL
ss_sendresponse(HANDLE hpipe, long lCode, ULONG ulSize, ULONG ulSum, PSTR szFile)
{
        SSRESPONSE resp;

        resp.lCode = lCode;
        resp.ulSize = ulSize;
        resp.ulSum = ulSum;
        if (szFile != NULL) {
                lstrcpy(resp.szFile, szFile);
        }

        return(ss_sendblock(hpipe, (PSTR) &resp, sizeof(resp)));
}


/*
 * send a block of data or response packet to the named pipe.
 *
 * return TRUE if ok, or false if connection dropped
 */
BOOL
ss_sendblock(HANDLE hpipe, PSTR buffer, int length)
{
        int size, count, errorcode;

        /* loop retrying the send until it goes ok */
        for (count = 0; count < 10; count++) {

#ifdef trace
                {       char msg[80];
                        BLOCK * pb;
                        pb = (BLOCK *) buffer;
                        wsprintf( msg, "sendblock on %x: %x %x %x %x %x\n"
                                , hpipe, pb->dw[0], pb->dw[1], pb->dw[2], pb->dw[3], pb->dw[4]);
                        Trace_File(msg);
                }
#endif
                if (WriteFile(hpipe, buffer, length, (LPDWORD)(&size), NULL)) {

                        /* no error reported - was everything written?*/
                        if (size != length) {
#ifdef trace
                        {       char msg[80];
                                wsprintf(msg, " !!Bad length send for %x \n", hpipe);
                                Trace_File(msg);
                        }
#endif

                                /* write was NOT ok - report and retry */
                                printf("pipe write size differs for pipe %x\n", hpipe);
                                continue;               // ??? will this confuse client
                        } else {
#ifdef trace
                                {       char msg[80];
                                        wsprintf(msg, " good send for %x \n", hpipe);
                                        Trace_File(msg);
                                }
#endif
                                /* all ok */
                                return(TRUE);
                        }
                }
#ifdef trace
                {       char msg[80];
                        wsprintf(msg, " !!Bad send for %x \n", hpipe);
                        Trace_File(msg);
                }
#endif

                /* an error occurred */
                switch( (errorcode = (int)GetLastError())) {

                case ERROR_NO_DATA:
                case ERROR_BROKEN_PIPE:
                        /* pipe connection lost - forget it */
                        dprintf1(("pipe %x broken on write\n", hpipe));
                        return(FALSE);

                default:
                        Log_Write(hlogErrors, "write error %d on pipe %x",
				errorcode, hpipe);
                        break;
                }
        }

        /* retry count reached - abandon this attempt */
        Log_Write(hlogErrors,
	    "retry count reached on pipe %s - write error", hpipe);
        return(FALSE);
}


/* read a message from a pipe, allowing for network errors
 *
 * if error occurs, retry up to 10 times unless error code
 * indicates that pipe is broken - in which case, give up.
 *
 * return TRUE if all ok, or FALSE to mean the connection is broken,
 * abort this client.
 */
BOOL
ss_readmessage(HANDLE hpipe, LPSTR buffer, int size)
{
        int count;
        int actualsize;
        int errorcode;

        /* retry up to 10 times */
        for (count = 0; count < 10; count++ ) {

                // dprintf1(("waiting for read of pipe %x ...\n", hpipe));
#ifdef trace
                {       char msg[80];
                        wsprintf(msg, "ReadFile for pipe %x ...", hpipe );
                        Trace_File(msg);
                }
#endif
                if (ReadFile(hpipe, buffer, size, (LPDWORD)(&actualsize), NULL)) {
#ifdef trace
                        {       char msg[80];
                                BLOCK * pb;
                                pb = (BLOCK *) buffer;
                                wsprintf(msg, " Good ReadFile for %x: %x %x %x %x %x\n"
                                , hpipe, pb->dw[0], pb->dw[1], pb->dw[2], pb->dw[3], pb->dw[4]);
                                Trace_File(msg);
                        }
#endif
                        /* everything ok */
                        // dprintf1(("                         pipe %x read OK\n", hpipe));
                        return(TRUE);
                }
#ifdef trace
                {       char msg[80];
                        wsprintf(msg, "!!Bad ReadFile for %x\n", hpipe );
                        Trace_File(msg);
                }
#endif

                /* error occurred - check code */
                switch((errorcode = (int)GetLastError())) {

                case ERROR_BROKEN_PIPE:
                        /* connection broken. no point in retrying */
                        dprintf1(("pipe %x broken on read\n", hpipe));
                        return(FALSE);

                case ERROR_MORE_DATA:
                        /* the message sent is larger than our buffer.
                         * this is an internal error - report it and carryon
                         */
                        Log_Write(hlogErrors,
			    "error from pipe %x - message too large", hpipe);
                        return(TRUE);

                default:
                        Log_Write(hlogErrors,
			    "pipe %x read error %d", hpipe, errorcode);
                        break;
                }
        }
        Log_Write(hlogErrors, "retry count reached on pipe %x read error", hpipe);
        return(FALSE);

}



/*
 * note a logon, and return a logon entry that should be removed at
 * logoff time
 */
PCONNECT ss_logon(HANDLE hpipe)
{
    PCONNECT pLogon;
    SYSTEMTIME systime;
    char msg[256];


    EnterCriticalSection(&critsecConnects);
    pLogon = List_NewLast(listConnects, sizeof(CONNECT));
    LeaveCriticalSection(&critsecConnects);


    GetSystemTime(&systime);
    SystemTimeToFileTime(&systime, &pLogon->ftLogon);
    GetNamedPipeHandleState(
	hpipe,
	NULL,
	NULL,
	NULL,
	NULL,
	pLogon->Username,
	sizeof(pLogon->Username));

    /* log the connect event in the main log*/
    wsprintf(msg, "%s connected", pLogon->Username);
    Log_WriteData(hlogEvents, &pLogon->ftLogon, msg);

    return(pLogon);
}


/*
 * remove a current connection from the connections list
 */
VOID ss_logoff(PCONNECT pLogon)
{
   /* note the logoff event in the main log */
   Log_Write(hlogEvents, "%s connection terminated", pLogon->Username);

   /* remove the entry from the list */
   EnterCriticalSection(&critsecConnects);
   List_Delete(pLogon);
   LeaveCriticalSection(&critsecConnects);

}

/*
 * send the current-connections log
 *
 * Current connections are held on a list - we need to build a standard
 * log from the current list and then send that.
 */
VOID ss_sendconnects(HANDLE hpipe)
{
    HLOG hlog;
    PCONNECT pconn;

    hlog = Log_Create();

    EnterCriticalSection(&critsecConnects);

    List_TRAVERSE(listConnects, pconn) {

	Log_WriteData(hlog, &pconn->ftLogon, pconn->Username);
    }

    LeaveCriticalSection(&critsecConnects);

    Log_Send(hpipe, hlog);

    Log_Delete(hlog);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\server\server.h ===
/*
 * server.h
 *
 * inter-module declarations for sumserver
 *
 * Geraint, July 92
 */



/*
 * debug macros
 *
 */

#if DBG
    void dbgPrintf(char * szFormat, ...);
    extern int ssDebugLevel;


#define dprintf(_x_)	dbgPrintf _x_
#define dprintf1(_x_)	if (ssDebugLevel >= 1) dbgPrintf _x_
#define dprintf2(_x_)	if (ssDebugLevel >= 2) dbgPrintf _x_
#define dprintf3(_x_)	if (ssDebugLevel >= 3) dbgPrintf _x_
#define dprintf4(_x_)	if (ssDebugLevel >= 4) dbgPrintf _x_

#else

#define dprintf(_x_)
#define dprintf1(_x_)
#define dprintf2(_x_)
#define dprintf3(_x_)
#define dprintf4(_x_)

#endif

#if DBG
	BOOL FAR PASCAL _Assert(BOOL fExpr, LPSTR szFile, int iLine);

	#define ASSERT(expr)		 _Assert((expr), __FILE__, __LINE__)


#else
	#define ASSERT(expr)		

#endif

/*
 * a list of file names, defined in scan.c
 */
typedef struct fnamelist * PFNAMELIST;



/*
 * logs defined and initialised in sumserve.c
 */
HLOG hlogErrors, hlogEvents;



/* function declarations --------------------------*/

/* in scan.c */
PFNAMELIST ss_addtolist(PFNAMELIST head, PSTR filename);
BOOL ss_scan(HANDLE hpipe, LPSTR pRoot, LONG lVersion, BOOL bChecksum, BOOL fDeep);
void ss_cleanconnections(PFNAMELIST connections);
PFNAMELIST ss_handleUNC(HANDLE hpipe, long lVersion, LPSTR password, LPSTR server, PFNAMELIST);


/* in file.c */
void ss_sendfile(HANDLE hpipe, LPSTR file, LONG lVersion);

BOOL ss_compress(PSTR original, PSTR compressed);

/* in sumserve.c */
BOOL ss_sendresponse(HANDLE hpipe, long lCode, ULONG ulSize,
                ULONG ulSum, PSTR szFile);
BOOL ss_sendnewresp(HANDLE hPipe, long lVersion, long lCode, ULONG ulSize,
                ULONG ulSum, DWORD TimeLo, DWORD TimeHi, PSTR szFile);

BOOL ss_sendblock(HANDLE hpipe, PSTR buffer, int length);


/* in files.c */
BOOL ss_sendfiles(HANDLE hPipe, long lVersion);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\server\sumserve.h ===
/*
 * remote filename and checksum server
 *
 * sumserve.h           packet definitions
 *
 * client attaches to the named pipe \\servername\pipe\NPNAME,
 * and sends one of the request packets below. He then
 * waits for one or more of the reply packets.
 *
 * when he gets a reply packet indicating the end of the reply,
 * he either sends another request, or closes his named pipe handle.
 *
 */

/* Versions...
 * The server must always be at a version at least as great as a client.
 * New versions of the server will handle old clients (at least for a bit?)
 * The client specifies a version number when it connects.  (The original
 * version with no number is version 0).  The server will then respond
 * with structures and protocols for that version.  The version number is
 * included in the response packets to allow me to change this scheme,
 * should it ever be necessary.
 * New version requests can be distinguished from version 0 requests by
 * having NEGATIVE request codes.
 */

/* name of named pipe */
#define NPNAME          "sumserve"

#define SS_VERSION      1       /* latest version number */

/* request packets ---------------------------------- */

typedef struct {
        long lCode;             /* request code (below) */
        char szPath[MAX_PATH];  /* null terminated pathname string */
} SSREQUEST, * PSSREQUEST;

/* If the requst comes in with a NEGATIVE lCode then it means use this
 * structure instead.  This has a version number and so future structures
 * can all be told apart by that.
 */
typedef struct {
        long lCode;             /* request code (below) */
        long lRequest;          /* should be LREQUEST */
        long lVersion;          /* version number */
        DWORD lFlags;           /* options - INCLUDESUBS is only one so far */
        char szPath[MAX_PATH];  /* null terminated pathname string */
        char szLocal[MAX_PATH]; /* for a FILES request, the local name is
                                   appended directly after the terminating
                                   NULL of szPath.  This field ensures
                                   enough space is allocated */
} SSNEWREQ, * PSSNEWREQ;

#define INCLUDESUBS 0x01

#define LREQUEST 33333333

/* values for lCode*/

/* server should exit. no args. will receive no response */
#define SSREQ_EXIT      32895   /* chosen to be an unusual number so that
                                   we will NOT get one of these by mistake.
                                   New version server will fail to respond to
                                   version 0 EXIT requests.  Big deal!
                                */


/* arg is a pathname: please send all files with checksums.
 * will receive either SSRESP_BADPASS or a mixture of 0 or more SSRESP_FILE and
 * SSRESP_ERROR responses, terminated by SSRESP_END.
 */
#define SSREQ_SCAN      2       /* please return list of dirs. arg:path */

/* end of this client's session. no args. will receive no response */
#define SSREQ_END       3       /* end of session - I have no more requests */

/* szPath buffer contains two null-term. strings. first is the password,
 * second is the \\server\share name. please make a connection to this
 * server for the rest of my session.
 * one reply: either SSRESP_ERROR or SSRESP_END
 */
#define SSREQ_UNC       4       /* connect to UNC name passed. szPath contains
                                 * two null-terminated strings; first is
                                 * the password, second is \\server\share
                                 *
                                 * share will be disconnected at end of client
                                 * session.
                                 */

/*
 * please send a file. szPath is the name of the file. response
 * will be a sequence of ssPacket structs, continuing until lSequence is < 1
 * or ulSize is 0
 */
#define SSREQ_FILE      5

/*
 * please send a set of files,  First request does NOT have a file.
 * a series of following NEXTFILE requests do name the files.
 * The NEXTFILE requests expect no response.  After the last
 * files request will come an SSREQ_ENDFILES.
 */
#define SSREQ_FILES     6
#define SSREQ_NEXTFILE  7
#define SSREQ_ENDFILES  8

/* arg is a pathname: please send all files with times, sizes but NO checksums.
 * will receive either SSRESP_BADPASS or a mixture of 0 or more SSRESP_FILE and
 * SSRESP_ERROR responses, terminated by SSRESP_END.
 */
#define SSREQ_QUICKSCAN 9       /* please return list of dirs. arg:path */


/*
 * please send the error log buffer (in one packet)
 */
#define SSREQ_ERRORLOG	10

/*
 * please send the activity log buffer in one packet
 */
#define SSREQ_EVENTLOG	11

/*
 * please send the current connections log in one packet
 */
#define SSREQ_CONNECTS	12


/* response packets ---------------------------------- */

typedef struct {
        long lCode;             /* response code */
        ULONG ulSize;           /* file size */
        ULONG ulSum;            /* checksum for file */
        char szFile[MAX_PATH];  /* null-term. filename relative to orig req. */
} SSRESPONSE, * PSSRESPONSE;

/* for version 1 and later */
typedef struct {                /* files.c knows this is
                                   RESPHEADSIZE+strlen(szFile)+1
                                   + strlen(szLocal)+1 bytes long */
        long lVersion;          /* protocol version (it will be >=1) */
        long lResponse;         /* 22222222 decimal means This is a Response */
        long lCode;             /* response code */
        ULONG ulSize;           /* file size  (Win32 error code for SSRESP_ERROR) */
        DWORD fileattribs;
        FILETIME ft_create;
        FILETIME ft_lastaccess;
        FILETIME ft_lastwrite;
        ULONG ulSum;            /* checksum for file */
        BOOL bSumValid;         /* TRUE iff there was a checksum for file */
        char szFile[MAX_PATH];  /* null-term. filename/pipename
                                   relative to orig req. */
        char szLocal[MAX_PATH]; /* client file name - but the data is actually
                                   concatenated straight on the end of szFile
                                   after the terminating NULL */
} SSNEWRESP, * PSSNEWRESP;

#define RESPHEADSIZE (3*sizeof(long)+2*sizeof(ULONG)+3*sizeof(FILETIME)+sizeof(DWORD)+sizeof(BOOL))

#define LRESPONSE 22222222

/* response codes for lCode */

#define SSRESP_FILE     1        /* file passed: lSum and szFile are valid
                                    This is followed by a series of data Packets
                                    which are the compressed file.
                                 */
#define SSRESP_DIR      2        /* dir passed: szFile ok, lSum not valid */
#define SSRESP_PIPENAME  3       /* files requested.  Here is the pipe name */
#define SSRESP_END      0        /* no more files: lSum and szFile are empty*/
#define SSRESP_ERROR    -1       /* file/dir cannot be read: szFile is valid */
#define SSRESP_BADPASS  -2       /* bad password error (on UNC name) */
#define SSRESP_BADVERS  -3       /* down level server                */
#define SSRESP_CANTOPEN -4       /* Can't open file
                                    In reply to a scan, szFile, date/time and size are valid
                                 */
#define SSRESP_NOATTRIBS -5      /* Can't get file attributes        */
#define SSRESP_NOCOMPRESS -6     /* Can't compress the file (obsolete) */
#define SSRESP_NOREADCOMP -7     /* Can't read the compressed file
                                    Uncompressed file follows as data packets
                                 */
#define SSRESP_NOTEMPPATH -8     /* Can't create a temp path
                                    Uncompressed file follows as data packets
                                 */
#define SSRESP_COMPRESSEXCEPT -9 /* Exception from Compress
                                    Uncompressed file follows as data packets
                                 */
#define SSRESP_NOREAD -10        /* Couldn't read uncompressed file (either)
                                    No file follows.
                                 */
#define SSRESP_COMPRESSFAIL -11  /* COMPRESS reported failure
                                    Uncompressed file follows as data packets
                                 */


#define PACKDATALENGTH 8192
/*
 * response block for FILE request.
 */
typedef struct {
        long lSequence ;        /* packet sequence nr, or -1 if error and end*/
        ULONG ulSize;           /* length of data in this block */
        ULONG ulSum;            /* checksum for this block */
        char Data[PACKDATALENGTH];      /* send in blocks of 8k */
} SSPACKET, * PSSPACKET;

/*
 * response block for FILE request.
 */
typedef struct {                /* files.c knows this starts "long lSequence" */
                                /* and is PACKHEADSIZE+ulSize in length really*/
        long lVersion;          /* server/protocol version number */
        long lPacket;           /* 11111111 decimal means This is a Packet */
        long lSequence ;        /* packet sequence nr, or -1 if error and end*/
        ULONG ulSize;           /* length of data in this block */
        ULONG ulSum;            /* checksum for this block */
        char Data[PACKDATALENGTH];      /* send in blocks of 8k */
} SSNEWPACK, * PSSNEWPACK;

/* size of SSNEWPACK header */
#define PACKHEADSIZE (3*sizeof(long)+2*sizeof(ULONG))

#define LPACKET 11111111
/*
 * in response to a FILE request, we send SSPACKET responses until there
 * is no more data. The final block will have ulSize == 0 to indicate that
 * there is no more data. The Data[] field of this block will then be
 * a SSATTRIBS containing the file attributes and file times.
 */
typedef struct {
        DWORD fileattribs;
        FILETIME ft_create;
        FILETIME ft_lastaccess;
        FILETIME ft_lastwrite;
} SSATTRIBS, * PSSATTRIBS;




/*
 * in response to errorlog, eventlog and connections requests, we send one
 * of these structures.
 *
 * The Data section consists of a FILETIME (64-bit UTC event time), followed
 * by a null-terminated ansi string, for each event logged.
 *
 */
struct corelog {
    DWORD lcode;	/* packet checkcode - should be LRESPONSE */	
    BOOL bWrapped;	/* log overrun - earlier data lost */
    DWORD dwRevCount;	/* revision count of log */
    DWORD length;	/* length of data in log */
    BYTE Data[PACKDATALENGTH];
};









#ifdef trace
/* add msg to the trace file */
void APIENTRY Trace_File(LPSTR msg);
#endif  //trace
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\server\service.c ===
/*
 * Service.c
 *
 *
 * Service control interface to sumserve
 *
 * Geraint Davies, July 93
 */

#include <windows.h>
#include <sumserve.h>	// public header for sumserve
#include "errlog.h"
#include <server.h>	// private header for sumserve


/*
 * this is the function (in some other module) that actually
 * does all the work (probably used to be main or WinMain until
 * we added all the service-control stuff in this file).
 */
extern VOID MainLoop(DWORD dwArgc, LPTSTR *lpszArgv);





// service status handle - used in SetServiceStatus calls.
SERVICE_STATUS_HANDLE sshSumserve;

//signaled when service completed
HANDLE hServiceDoneEvent;

SERVICE_STATUS gssStatus;


/* structure to pass more than one parameter to the worker thread. */
typedef struct _threadinitparams {
    DWORD dwArgc;
    LPTSTR *lpszArgv;
} threadinitparams, * pthreadinitparams;


/*
 * MainLoopCaller
 *
 * This function is called on the worker thread created to do all the
 * real work. It calls the main loop function for the service, and
 * when that exits, signals the completion event to tell the
 * SS_Main thread that it is time to exit the process.
 */
DWORD
MainLoopCaller(LPVOID lpgeneric)
{
    pthreadinitparams pta;

    pta = (pthreadinitparams) lpgeneric;

    dprintf1(("calling main loop"));

    MainLoop(pta->dwArgc, pta->lpszArgv);

    SetEvent(hServiceDoneEvent);

    return(0);
}

/*
 * handler function called to perform start/stop
 * requests.
 */
VOID
SS_ServiceHandler(DWORD dwCtrlCode)
{

    switch(dwCtrlCode) {

    case SERVICE_CONTROL_STOP:

	gssStatus.dwCurrentState = SERVICE_STOP_PENDING;
	gssStatus.dwControlsAccepted = 0;
	gssStatus.dwCheckPoint = 1;
	gssStatus.dwWaitHint = 3000;

        SetServiceStatus(sshSumserve, &gssStatus);
	SetEvent(hServiceDoneEvent);
	break;

    default:
	/*
	 * we must always update the service status every time we are
	 * called.
	 */
        SetServiceStatus(sshSumserve, &gssStatus);
	break;

    }

}



/*
 * service main function - called by service controller
 * during StartServiceCtlDispatcher processing.
 *
 * Register our handler function, and initialise the service.
 * create a thread to do the work, and then wait for someone to
 * signal time to end. When this function exits, the call to
 * StartServiceCtlDispatcher will return, and the process will exit
 *
 * The args are passed from the program that called start service, and
 * are parameters that are passed to the main loop of the program.
 */
VOID
SS_Main(DWORD dwArgc, LPTSTR *lpszArgv)
{
    threadinitparams ta;
    HANDLE thread;
    DWORD threadid;

    dprintf1(("in ss_main"));


    sshSumserve = RegisterServiceCtrlHandler(
		    TEXT("SumServe"),
		    (LPHANDLER_FUNCTION) SS_ServiceHandler);

    gssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    gssStatus.dwServiceSpecificExitCode = 0;

    gssStatus.dwCurrentState = SERVICE_START_PENDING;
    gssStatus.dwControlsAccepted = 0;
    gssStatus.dwWin32ExitCode = NO_ERROR;
    gssStatus.dwCheckPoint = 1;
    gssStatus.dwWaitHint = 3000;
    SetServiceStatus(sshSumserve, &gssStatus);


    hServiceDoneEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    gssStatus.dwCheckPoint = 2;
    SetServiceStatus(sshSumserve, &gssStatus);



    // create a thread to do all the real work

    // init args
    ta.dwArgc = dwArgc;
    ta.lpszArgv = lpszArgv;

    thread = CreateThread(
		NULL,
		0,
		(LPTHREAD_START_ROUTINE) MainLoopCaller,
		(LPVOID)&ta,
		0,
		&threadid);

    if (thread != NULL) {

	CloseHandle(thread);


        gssStatus.dwCurrentState = SERVICE_RUNNING;
        gssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;

        gssStatus.dwCheckPoint = 0;
        gssStatus.dwWaitHint = 0;
        SetServiceStatus(sshSumserve, &gssStatus);


        WaitForSingleObject(hServiceDoneEvent, INFINITE);
    }

    CloseHandle(hServiceDoneEvent);

    gssStatus.dwCurrentState = SERVICE_STOPPED;
    gssStatus.dwControlsAccepted = 0;
    SetServiceStatus(sshSumserve, &gssStatus);

}



/*
 * main entry point.
 *
 * for a service, we need to call the service manager telling it our
 * main init function. It will then do everything. When the service
 * manager returns, it's time to exit.
 */
int WINAPI
WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdParam,
                int nCmdShow)
{
   SERVICE_TABLE_ENTRY steDispatch[] = {

       { TEXT("SumServe"), (LPSERVICE_MAIN_FUNCTION) SS_Main },

       //end of table marker
       { NULL, NULL }
    };


    dprintf1(("in winmain"));

    StartServiceCtrlDispatcher(steDispatch);


    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\windiff\complist.h ===
/*
 *
 * complist -  a list of CompItems
 *
 * build a list of CompItems from various sources. That is to say, build
 * two corresponding lists of filenames (DIRLISTs) and then build a list
 * of CompItems, with one CompItem for each pair of files whose names
 * match, and one CompItem for each unmatched name.
 *
 * when building the complist, a view handle can be given. If this is non-null,
 * the CompList will register with the view (calling view_setcomplist), and
 * will inform the view of each compitem added, during the build
 * process (so that the user can be kept up to date during a lengthy scan).
 *
 * We can return a handle to this list of CompItems on demand.
 *
 * The CompList owns the DIRLISTs and the list of CompItems. If you delete
 * the CompList, you delete all of these.
 */


/* view.h includes the term COMPLIST: we need to use the term VIEW.
 * Alas MIPS doesn't allow duplicate definitions, even harmless ones,
 * so we need to play games.  Whoever declares it first does
 * the real declares and the second one gets no-ops.
 * We don't care what a VIEW  is. Whatever you give us, we will
 * pass to the view_setcomplist function and view_newitem, and that is all.
 */
#ifndef INC_VIEW_COMPLIST
#define INC_VIEW_COMPLIST
typedef struct compitem FAR* COMPITEM;          /* handle to a compitem */
typedef struct view FAR * VIEW;                 /* handle to a VIEW     */
typedef struct complist FAR * COMPLIST;         /* handle to a complist */
#endif // INC_VIEW_COMPLIST


/*
 * build a complist by putting up two dialogs to allow the user to
 * select two files. This will build a Complist with one CompItem (even
 * if the names don't match).
 */
COMPLIST complist_filedialog(VIEW view);

/*
 * build a complist by putting up a dialog in which the user can specify
 * two directories. The directories will then be scanned and a CompItem
 * added to the list for each pair of names that match, and one for each
 * unmatched name
 */
COMPLIST complist_dirdialog(VIEW view);

/* build a complist by putting up a dialog in which the user can
 * specify a remote checksum server name as well as a local and remote
 * directory path.
 *
 * if server is not null, puts up dialog. otherwise uses args as
 * server, remote and local paths
 */
COMPLIST complist_remote(LPSTR server, LPSTR remote, LPSTR local, VIEW view,
                         BOOL fDeep);

/* build a complist from the two pathnames provided */
COMPLIST complist_args(LPSTR path1, LPSTR path2, VIEW view, BOOL fDeep);


/* build/append a complist from the two pathnames provided (either or both is
 * allowed to be null).
 */
void complist_append(COMPLIST *pcl, LPCSTR path1, LPCSTR path2, int *psequence);
BOOL complist_appendfinished(COMPLIST *pcl, LPCSTR pszLeft, LPCSTR pszRight, VIEW view);



/* delete a complist and all associated CompItems and DIRLISTs. Note this
 * does not delete any VIEW - the VIEW owns the COMPLIST and not the other
 * way around.
 */
void complist_delete(COMPLIST cl);

/*
 * get the handle to the list of COMPITEMs. The list continues to be
 * owned by the COMPLIST, so don't delete except by calling complist_delete.
 */
LIST complist_getitems(COMPLIST cl);


/* save the list of files as a series of lines to a file. query the user
 * for the name of the file to write, and the states of lines to be
 * included.
 *
 * if savename is not null, write the list out to savename using listopts.
 * otherwise, prompt by dialog for filename and options.
 */
void complist_savelist(COMPLIST cl, LPSTR savename, UINT listopts);


/*
 * get the description of this complist - a name in the form %s : %s with
 * the dir_getrootdescription() for each side.
 */
LPSTR complist_getdescription(COMPLIST cl);

/* free up memory allocated in a call to complist_getdescription() */
void complist_freedescription(COMPLIST cl, LPSTR path);


/*
 * copy files to a new directory newroot. if newroot is NULL, query the user
 * via a dialog to get the new dir name and options.
 *
 * options are either COPY_FROMLEFT or COPY_FROMRIGHT (indicating which
 * tree is to be the source of the files, plus any or all of
 * INCLUDE_SAME, INCLUDE_DIFFER and INCLUDE_LEFT (INCLUDE_LEFT
 * and INCLUDE_RIGHT are treated the same here since the COPY_FROM* option
 * indicates which side to copy from).
 */

/* option flags */
#define COPY_FROMLEFT       0x100           /* copy files from left tree */
#define COPY_FROMRIGHT      0x200           /* copy files from right tree */
#define COPY_HITREADONLY    0x400           /* overwrite read only files */

void complist_copyfiles(COMPLIST cl, LPSTR newroot, UINT options);


/* return time last operation took in milliseconds */
DWORD complist_querytime(void);


/*
 * complist_togglemark
 *
 * each compitem has a BOOL mark state. This function inverts the value of
 * this state for each compitem in the list.
 */
void complist_togglemark(COMPLIST cl);


/*
 * complist_itemcount
 *
 * return the number of items in the list
 */
UINT
complist_itemcount(COMPLIST cl);


/*
 * query the user for a pattern to match.
 * all compitems with this pattern in their tag string will be
 * marked (the mark state will be set to TRUE);
 *
 * returns TRUE if any states changed
 */
BOOL complist_markpattern(COMPLIST cl);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\windiff\complist.c ===
/*
 * complist.c
 *
 * supports a list of compitems, where each compitem represents
 * a pair of matching files, or an unmatched file.
 *
 * We build lists of filenames from two pathnames (using the
 * scandir module) and then traverse the two lists comparing names.
 * Where the names match, we create a CompItem from the matching
 * names. Where there is an unmatched name, we create a compitem for it.
 *
 * we may also be asked to create a complist for two individual files:
 * here we create a single compitem for them as a matched pair even if
 * the names don't match.
 *
 * Geraint Davies, July 92
 */

#include <windows.h>
#include <stdlib.h>
#include <string.h>
#include <dos.h>
#include <direct.h>
#include <gutils.h>

#include "state.h"
#include "windiff.h"
#include "wdiffrc.h"


#include "list.h"
#include "line.h"
#include "scandir.h"
#include "file.h"
#include "section.h"
#include "compitem.h"
#include "complist.h"
#include "view.h"
#include "slmmgr.h"

extern BOOL bAbort;             /* in windiff.c  Read only here */
#ifdef trace
extern bTrace;                  /* in windiff.c  Read only here */
#endif

/*
 * the COMPLIST handle is typedef-ed to be a pointer to one
 * of these struct complist
 */
struct complist {
    DIRLIST left;           /* left list of files */
    DIRLIST right;          /* right list of files */
    LIST items;             /* list of COMPITEMs */
};

/* ---- module-wide data -------------------------------------*/

/* data for communicating between the SaveList dlg and complist_savelist() */

char dlg_file[MAX_PATH];                /* filename to save to */
BOOL dlg_sums = TRUE;                           /* do we include sums ? */

// have we read the dialog names yet?
BOOL SeenDialogNames = FALSE;

/* checkbox options */
BOOL dlg_identical, dlg_differ, dlg_left, dlg_right;

/* data for Directory, SaveList and Remote dialog box */
char dialog_leftname[MAX_PATH];
char dialog_rightname[MAX_PATH];
char dialog_servername[80];
BOOL dialog_recursive;             // do whole tree
BOOL dialog_fastscan;              // times and sizes only, no checksums
BOOL dialog_autocopy;              // copy to update local directory

BOOL dialog_bothremote;

/*
 * data used by dodlg_copyfiles
 */
UINT dlg_options;
BOOL dlg_IgnoreMarks;
BOOL dlg_IgnoreAttributes;
char dlg_root[MAX_PATH];

/*------------------------timing for performance measurements-----------------*/
static DWORD TickCount;         /* time operation started, then time taken*/


/* --- forward declaration of internal functions ----------------------------*/
int FAR PASCAL complist_dodlg_savelist(HWND hDlg, UINT message,
                                       UINT wParam, long lParam);
int FAR PASCAL complist_dodlg_copyfiles(HWND hDlg, UINT message,
                                        UINT wParam, long lParam);
BOOL complist_match(COMPLIST cl, VIEW view, BOOL fDeep, BOOL fExact);
COMPLIST complist_new(void);
int FAR PASCAL complist_dodlg_dir(HWND hDlg, unsigned message,
                                  UINT wParam, LONG lParam);
int FAR PASCAL complist_dodlg_remote(HWND hDlg, unsigned message,
                                     UINT wParam, LONG lParam);



/* --- external functions ----------------------------------- */


/*
 * query the user to select two files, then build the list from
 * these files.
 */
COMPLIST
complist_filedialog(VIEW view)
{
    COMPLIST cl;
    OFSTRUCT os1, os2;
    char fname[MAX_PATH], FileExt[5], FileOpenSpec[15];

    /* ask for the filenames - using gfile standard dialogs */
    lstrcpy(FileExt, ".c");
    lstrcpy(FileOpenSpec, "*.*");

    if (!gfile_open(hwndClient, LoadRcString(IDS_SELECT_FIRST_FILE), FileExt, FileOpenSpec, &os1, fname) ){
        return(NULL);
    }

    if (!gfile_open(hwndClient, LoadRcString(IDS_SELECT_SECOND_FILE), FileExt, FileOpenSpec, &os2, fname) ){
        return(NULL);
    }

    /* alloc a new structure */
    cl = complist_new();

    cl->left = dir_buildlist(os1.szPathName, FALSE, TRUE);
    cl->right = dir_buildlist(os2.szPathName, FALSE, TRUE);


    /* register with the view (must be done after the list is non-null) */
    view_setcomplist(view, cl);

    complist_match(cl, view, FALSE, TRUE);

    return(cl);
}/* complist_filedialog */


void
complist_setdialogdefault(
                         LPSTR left,
                         LPSTR right,
                         BOOL fDeep)
{
    dialog_recursive = fDeep;
    lstrcpy(dialog_leftname, left);
    lstrcpy(dialog_rightname, right);
    SeenDialogNames = TRUE;
}


/* build a new complist by querying the user for two directory
 * names and scanning those in parallel.
 *
 * names that match in the same directory will be paired. unmatched
 * names will go in a compitem on their own.
 */
COMPLIST
complist_dirdialog(VIEW view)
{
    DLGPROC lpProc;
    BOOL fOK;

    /* put up a dialog for the two pathnames */
    lpProc = (DLGPROC)MakeProcInstance((WINPROCTYPE)complist_dodlg_dir, hInst);
    windiff_UI(TRUE);
    fOK = (BOOL)DialogBox(hInst, "Directory", hwndClient, lpProc);
    windiff_UI(FALSE);
    FreeProcInstance(lpProc);

    if (!fOK) {
        return(NULL);
    }

    return complist_args( dialog_leftname, dialog_rightname
                          , view, dialog_recursive );
} /* complist_dirdialog */


/*
 * check a pathname to see if it is the form \\server!path, and if so,
 * separate out the server and the path portions. returns TRUE if
 * it is \\server!path or FALSE otherwise
 *
 * We assume that no server name contains ! - so if the first characters
 * are \\ and there is a ! before any more \ (ie before the share name),
 * then it must be a checksum server name. Note that the pathname may be
 * a UNC name or relative to the checksum server.
 */
BOOL
IsChecksumServerPath(LPSTR pSrc, LPSTR server, LPSTR serverpath)
{
    LPSTR pPling;
    LPSTR pShareStart;

    /*
     * must be at least \\x!x - ie 5 chars long
     */
    if (lstrlen(pSrc) < 5) {
        return(FALSE);
    }

    /*
     * does it begin \\
     */
    if ( (pSrc[0] != '\\') || (pSrc[1] != '\\')) {
        return(FALSE);
    }

    /*
     * the ! must be part of the server name - ie must be before the third
     * backslash.
     */
    pPling = My_mbschr(pSrc, '!');
    pShareStart = My_mbschr(&pSrc[2], '\\');

    if ((pPling == NULL) || ((pShareStart != NULL) && (pShareStart < pPling))) {

        return(FALSE);
    }

    /*
     * copy over the server and pathname portions into separate strings
     */
    My_mbsncpy(server, &pSrc[2], (int)(pPling - &pSrc[2]));
    server[pPling - &pSrc[2]] = '\0';
    lstrcpy(serverpath, pPling+1);

    return(TRUE);
}

/*
 * given two pathname strings, scan the directories and traverse them
 * in parallel comparing matching names.
 */
COMPLIST
complist_args(LPSTR p1, LPSTR p2, VIEW view, BOOL fDeep)
{
    COMPLIST cl;
    char msg[MAX_PATH+20];
    char server[32];
    char serverpath[MAX_PATH];

    /* alloc a new complist */
    cl = complist_new();

    //
    // accept \\server!path for a checksum server and
    // pathname - assumes no \\server\share names have !
    // within the server name.
    if (IsChecksumServerPath(p1, server, serverpath)) {
        cl->left = dir_buildremote(server, serverpath, TRUE, TRUE, fDeep);
    } else {
        cl->left = dir_buildlist(p1, FALSE, TRUE);
    }
    /* check that we could find the paths, and report if not */
    if (cl->left == NULL) {
        wsprintf(msg, LoadRcString(IDS_COULDNT_FIND), p1);
        TRACE_ERROR(msg, FALSE);
        return(NULL);
    }

    if (IsChecksumServerPath(p2, server, serverpath)) {
        cl->right = dir_buildremote(server, serverpath, TRUE, TRUE, fDeep);
    } else {
        cl->right = dir_buildlist(p2, FALSE, TRUE);
    }
    /* check that we could find the paths, and report if not */
    if (cl->right == NULL) {
        wsprintf(msg, LoadRcString(IDS_COULDNT_FIND), p2);
        TRACE_ERROR(msg, FALSE);
        return(NULL);
    }

    if (!TrackLeftOnly) {
        dir_setotherdirlist(cl->left, cl->right);
    }
    if (!TrackRightOnly) {
        dir_setotherdirlist(cl->right, cl->left);
    }
    {
        // remember these paths as defaults for the next dialog -
        // get the normalised, absolute paths
        LPSTR pleft = dir_getrootdescription(cl->left);
        LPSTR pright = dir_getrootdescription(cl->right);
        complist_setdialogdefault(pleft, pright, fDeep);
        dir_freerootdescription(cl->left, pleft);
        dir_freerootdescription(cl->right, pright);
    }


    /* register with the view (must be done after building lists) */
    view_setcomplist(view, cl);

    complist_match(cl, view, fDeep, TRUE);

    return(cl);
} /* complist_args */

/*
 * given two pathname strings, scan the directories and traverse them
 * in parallel comparing matching names.
 */
void
complist_append(COMPLIST *pcl, LPCSTR p1, LPCSTR p2, int *psequence)
{
    COMPLIST cl;

    if (!*pcl)
    {
        /* alloc a new complist */
        *pcl = complist_new();
    }
    cl = *pcl;

    dir_appendlist(&cl->left, p1, FALSE, psequence);
    dir_appendlist(&cl->right, p2, FALSE, psequence);
} /* complist_append */

/*
 * finished appending files -- set custom descriptions (instead of calculating
 * them based on directory names), register with view, and match the left and
 * right sides of the complist.
 */
BOOL
complist_appendfinished(COMPLIST *pcl, LPCSTR pszLeft, LPCSTR pszRight, VIEW view)
{
    COMPLIST cl;
    char msg[MAX_PATH+20];

    if (!*pcl)
        return FALSE;

    cl = *pcl;
    if (!cl->left || !cl->right)
    {
        wsprintf(msg, LoadRcString(IDS_COULDNT_FIND_ANYTHING));
        TRACE_ERROR(msg, FALSE);
        return FALSE;
    }

    dir_setdescription(cl->left, pszLeft);
    dir_setdescription(cl->right, pszRight);

    if (!TrackLeftOnly)
        dir_setotherdirlist(cl->left, cl->right);
    if (!TrackRightOnly)
        dir_setotherdirlist(cl->right, cl->left);

    /* register with the view (must be done after building lists) */
    view_setcomplist(view, cl);

    complist_match(cl, view, FALSE, TRUE);
    return TRUE;
}

/*
 * complist_remote
 *
 * ask the user for a servername, remote and local paths. Use
 * dir_buildremote to build a list of remote files, and
 * use dir_buildlist to build the local list. Then match up
 * names in the two directories and make compitems for each
 * matching name using complist_match
 *
 * if server is not null, then use server, remote and local instead
 * of putting up the dialog.
 *
 * this functionality is not in the WIN 3.1 version of the code
 * because we use named pipes to communicate to a server.
 */
COMPLIST
complist_remote(LPSTR server, LPSTR remote, LPSTR local, VIEW view, BOOL fDeep)
{
    DLGPROC lpProc;
    BOOL fOK;
    COMPLIST cl;
    char msg[MAX_PATH+20];
    BOOL FastScan= FALSE;
    BOOL AutoCopy= FALSE;
    BOOL fBothRemote = FALSE;

    if (server == NULL) {
        /* put up a dialog for the two pathnames */
        lpProc = (DLGPROC)MakeProcInstance((WINPROCTYPE)complist_dodlg_remote, hInst);
        windiff_UI(TRUE);
        fOK = (BOOL)DialogBox(hInst, "Remote", hwndClient, lpProc);
        windiff_UI(FALSE);
        FreeProcInstance(lpProc);

        if (!fOK) {
            return(NULL);
        }
        server = dialog_servername;
        remote = dialog_leftname;
        local = dialog_rightname;
        fDeep = dialog_recursive;
        FastScan = dialog_fastscan;
        AutoCopy = dialog_autocopy;
        fBothRemote = dialog_bothremote;
    }

    /* alloc a new complist */
    cl = complist_new();

    cl->left = dir_buildremote(server, remote, !FastScan, TRUE, fDeep);
    if (cl->left == NULL) {
        /* dialog already put up by dir_buildremote */
        return(NULL);
    }
    if (fBothRemote) {
        cl->right = dir_buildremote(server, local, !FastScan, TRUE, fDeep);
    } else {
        cl->right = dir_buildlist(local, !FastScan, TRUE);
    }
    if (cl->right == NULL) {
        wsprintf(msg, LoadRcString(IDS_COULDNT_FIND), local);
        TRACE_ERROR(msg, FALSE);
        return(NULL);
    }

    /* register with view */
    view_setcomplist(view, cl);

    compitem_SetCopyPaths( dir_getrootpath(cl->left)
                           , dir_getrootpath(cl->right) );

    complist_match(cl, view, fDeep, !FastScan);

    if (AutoCopy) {
        complist_copyfiles( cl
                            , local
                            , COPY_FROMLEFT|INCLUDE_LEFTONLY|INCLUDE_DIFFER
                            |COPY_HITREADONLY
                          );
    }
    Trace_Unattended(FALSE);

    return(cl);
} /* complist_remote */


/*
 * return a handle to the list of compitems in this complist
 */
LIST
complist_getitems(COMPLIST cl)
{
    if (cl == NULL) {
        return(NULL);
    }

    return(cl->items);
}


/* delete a complist and all associated compitems and dirlists
 */
void
complist_delete(COMPLIST cl)
{
    COMPITEM item;

    if (cl == NULL) {
        return;
    }

    /* delete the two directory scan lists */
    dir_delete(cl->left);
    dir_delete(cl->right);

    /* delete the compitems in the list */
    List_TRAVERSE(cl->items, item) {
        compitem_delete(item);
    }

    /* delete the list itself */
    List_Destroy(&cl->items);

    gmem_free(hHeap, (LPSTR) cl, sizeof(struct complist));

}

/*
 * write out to a text file the list of compitems as relative filenames
 * one per line.
 *
 * if savename is non-null, use this as the filename for output. otherwise
 * query the user via a dialog for the filename and include options.
 *
 * There are hidden parameters (dlg_sums etc) from the dialog.
 * Note that we never attempt to recalculate sums.
 */
void
complist_savelist(COMPLIST cl, LPSTR savename, UINT options)
{
    DLGPROC lpProc;
    static BOOL done_init = FALSE;
    BOOL bOK;
    int fh, state;
    OFSTRUCT os;
    char msg[2*MAX_PATH+100];
    HCURSOR hcurs;
    COMPITEM ci;
    LPSTR pstr, lhead;
    int nFiles = 0;

    if (!done_init) {
        /* init the options once round - but keep the same options
         * for the rest of the session.
         */

        /* first init default options */
        dlg_identical = (outline_include & INCLUDE_SAME);
        dlg_differ = (outline_include & INCLUDE_LEFTONLY);
        dlg_left = (outline_include & INCLUDE_RIGHTONLY);
        dlg_right = (outline_include & INCLUDE_DIFFER);
        dlg_IgnoreMarks = hide_markedfiles;

        dlg_file[0] = '\0';

        done_init = TRUE;
    }

    if (cl == NULL) {
        return;
    }

    if (savename == NULL) {

        /* store the left and right rootnames so that dodlg_savelist
         * can display them in the dialog.
         */
        pstr = dir_getrootdescription(cl->left);
        lstrcpy(dialog_leftname, pstr);
        dir_freerootdescription(cl->left, pstr);

        pstr = dir_getrootdescription(cl->right);
        lstrcpy(dialog_rightname, pstr);
        dir_freerootdescription(cl->right, pstr);


        lpProc = (DLGPROC)MakeProcInstance((WINPROCTYPE)complist_dodlg_savelist, hInst);
        windiff_UI(TRUE);
        bOK = (BOOL)DialogBox(hInst, "SaveList", hwndClient, lpProc);
        windiff_UI(FALSE);
        FreeProcInstance(lpProc);

        if (!bOK) {
            /* user cancelled from dialog box */
            return;
        }
        savename = dlg_file;

    } else {
        dlg_identical = (options & INCLUDE_SAME);
        dlg_differ = (options & INCLUDE_DIFFER);
        dlg_left = (options & INCLUDE_LEFTONLY);
        dlg_right = (options & INCLUDE_RIGHTONLY);

        /* no harm done if the following call fails */
        GetFullPathName(savename, sizeof(dlg_file), dlg_file, NULL);
    }


    /* try to open the file */
    fh = OpenFile(savename, &os, OF_CREATE|OF_WRITE|OF_SHARE_DENY_WRITE);
    if (fh < 0) {
        wsprintf(msg, LoadRcString(IDS_CANT_OPEN), savename);
        windiff_UI(TRUE);
        MessageBox(hwndClient, msg, "Windiff", MB_ICONSTOP|MB_OK);
        windiff_UI(FALSE);
        return;
    }

    hcurs = SetCursor(LoadCursor(NULL, IDC_WAIT));

    /* write out the header line */
    lhead = complist_getdescription(cl);
    {
        TCHAR szBuf1[20],szBuf2[20],szBuf3[20],szBuf4[20];
        lstrcpy(szBuf1,(LPSTR)(dlg_identical ? LoadRcString(IDS_IDENTICAL_COMMA) : ""));
        lstrcpy(szBuf2,(LPSTR)(dlg_left ? LoadRcString(IDS_LEFT_ONLY_COMMA) : ""));
        lstrcpy(szBuf3,(LPSTR)(dlg_right ? LoadRcString(IDS_RIGHT_ONLY_COMMA) : ""));
        lstrcpy(szBuf4,(LPSTR)(dlg_differ ? LoadRcString(IDS_DIFFERING) : ""));
        wsprintf(msg, LoadRcString(IDS_HEADER_LINE_STR),
                lhead, szBuf1, szBuf2, szBuf3, szBuf4);
    }
    _lwrite(fh, msg, lstrlen(msg));
    complist_freedescription(cl, lhead);


    /* traverse the list of compitems looking for the
     * ones we are supposed to include
     */
    List_TRAVERSE(cl->items, ci) {

        /* check if files of this type are to be listed */
        state = compitem_getstate(ci);

        if ((state == STATE_SAME) && (!dlg_identical)) {
            continue;
        } else if ((state == STATE_DIFFER) && (!dlg_differ)) {
            continue;
        } else if ((state == STATE_FILELEFTONLY) && (!dlg_left)) {
            continue;
        } else if ((state == STATE_FILERIGHTONLY) && (!dlg_right)) {
            continue;
        }
        if (dlg_IgnoreMarks && compitem_getmark(ci)) {
            continue;
        }

        nFiles++;

        /* output the list line */
        wsprintf(msg, "%s", compitem_gettext_tag(ci));
        _lwrite(fh, msg, lstrlen(msg));

        /* write out the result of the comparison */
        {       LPSTR p;
            p = compitem_gettext_result(ci);
            wsprintf( msg, "\t%s"
                      , p ? p : "windiff error"
                    );
        }
        _lwrite(fh, msg, lstrlen(msg));

        if (dlg_sums) {
            if (compitem_getleftfile(ci) != NULL) {
                BOOL bValid;
                DWORD cksum;
                cksum = file_retrievechecksum(compitem_getleftfile(ci),&bValid);

                if (bValid) wsprintf(msg, "\t%8lx", cksum);
                else wsprintf(msg, "\t????????");
            } else {
                wsprintf(msg, "\t--------");
            }
            _lwrite(fh, msg, lstrlen(msg));

            if (compitem_getrightfile(ci) != NULL) {
                BOOL bValid;
                DWORD cksum;
                cksum = file_retrievechecksum(compitem_getrightfile(ci),&bValid);
                if (bValid) wsprintf(msg, "\t%8lx", cksum);
                else wsprintf(msg, "\t????????");
            } else {
                wsprintf(msg, "\t--------");
            }
            _lwrite(fh, msg, lstrlen(msg));

        }

        wsprintf(msg, "\r\n");
        _lwrite(fh, msg, strlen(msg));
    }

    /* write tail line */
    wsprintf(msg, LoadRcString(IDS_FILES_LISTED), nFiles);
    _lwrite(fh, msg, lstrlen(msg));

    /* - close file and we are finished */
    _lclose(fh);

    SetCursor(hcurs);
} /* complist_savelist */

/*
 * copy files to a new directory newroot. if newroot is NULL, query the user
 * via a dialog to get the new dir name and options.
 *
 * options are either COPY_FROMLEFT or COPY_FROMRIGHT (indicating which
 * tree is to be the source of the files, plus any or all of
 * INCLUDE_SAME, INCLUDE_DIFFER and INCLUDE_LEFT (INCLUDE_LEFT
 * and INCLUDE_RIGHT are treated the same here since the COPY_FROM* option
 * indicates which side to copy from).
 */
void
complist_copyfiles(COMPLIST cl, LPSTR newroot, UINT options)
{
    int nFiles = 0;
    int nFails = 0;
    static BOOL done_init = FALSE;
    LPSTR pstr;
    char buffer[MAX_PATH+20];
    DIRITEM diritem;
    DLGPROC lpProc;
    BOOL bOK;
    COMPITEM ci;
    int state;
    BOOL HitReadOnly = ((options&COPY_HITREADONLY)==COPY_HITREADONLY);
    BOOL CopyNoAttributes;

    if (!done_init) {
        /*
         * one-time initialisation of dialog defaults
         */
        dlg_options = COPY_FROMLEFT|INCLUDE_LEFTONLY|INCLUDE_DIFFER;
        dlg_root[0] = '\0';

        // set the ignore-marked files option by default the same
        // as the hide mark files menu option. If he doesn't want them
        // visible, he probably doesn't want them copied.
        dlg_IgnoreMarks = hide_markedfiles;

        done_init = TRUE;
    }

    if (cl == NULL) {
        return;
    }


    if (newroot == NULL) {
        /*
         * put up dialog to query rootname and options
         */

        /* store the left and right rootnames so that the dlg proc
         * can display them in the dialog.
         */
        pstr = dir_getrootdescription(cl->left);
        lstrcpy(dialog_leftname, pstr);
        dir_freerootdescription(cl->left, pstr);

        pstr = dir_getrootdescription(cl->right);
        lstrcpy(dialog_rightname, pstr);
        dir_freerootdescription(cl->right, pstr);


        do {
            lpProc = (DLGPROC)MakeProcInstance((WINPROCTYPE)complist_dodlg_copyfiles, hInst);
            windiff_UI(TRUE);
            bOK = (BOOL)DialogBox(hInst, "CopyFiles", hwndClient, lpProc);
            windiff_UI(FALSE);
            FreeProcInstance(lpProc);

            if (!bOK) {
                /* user cancelled from dialog box */
                return;
            }
            if (lstrlen(dlg_root) == 0) {
                windiff_UI(TRUE);
                MessageBox( hwndClient, LoadRcString(IDS_ENTER_DIR_NAME),
                            "Windiff", MB_ICONSTOP|MB_OK);
                windiff_UI(FALSE);
            }
        } while (lstrlen(dlg_root) == 0);

    } else {
        // no dialog - all options passed in (eg from command line).
        // note that in this case the dlg_IgnoreMarks is left as
        // whatever the hide_markedfiles menu option is set to.
        dlg_options = options;
        lstrcpy(dlg_root, newroot);
    }

    TickCount = GetTickCount();

    /* this relies on the sumserver, server and share (if any) being the same for
       all the things on the list.  We set up the first one and then just check
       that it doesn't change (within ss_client).  If it turns out to be a local
       copy these things turn into no-ops somewhere below us.
    */
    if (dlg_options & COPY_FROMLEFT) {
        if (!dir_startcopy(cl->left))
            return;
    } else {
        if (!dir_startcopy(cl->right))
            return;
    }

    CopyNoAttributes = dlg_IgnoreAttributes;

    /*
     * traverse the list of compitems copying files as necessary
     */
    List_TRAVERSE(cl->items, ci) {

        if (bAbort) {
            // buffer[0] = "Copy aborted";
            // SetStatus(buffer);
            // ss_abortcopy(); ???
            break;  /* fall into end_copy processing */
        }

        // ignore marked files totally if the option was
        // set in the dialog.
        if (dlg_IgnoreMarks && compitem_getmark(ci)) {
            continue;
        }

        /* check if files of this type are to be copied */
        state = compitem_getstate(ci);

        if ((state == STATE_SAME) && !(dlg_options & INCLUDE_SAME)) {
            continue;
        } else if ((state == STATE_DIFFER) && !(dlg_options & INCLUDE_DIFFER)) {
            continue;
        } else if (state == STATE_FILELEFTONLY) {
            if (dlg_options & COPY_FROMRIGHT) {
                continue;
            }
            if ((dlg_options & (INCLUDE_LEFTONLY | INCLUDE_RIGHTONLY)) == 0) {
                continue;
            }
        } else if (state == STATE_FILERIGHTONLY) {
            if (dlg_options & COPY_FROMLEFT) {
                continue;
            }
            if ((dlg_options & (INCLUDE_LEFTONLY | INCLUDE_RIGHTONLY)) == 0) {
                continue;
            }
        }

        if (dlg_options & COPY_FROMLEFT) {
            diritem = file_getdiritem(compitem_getleftfile(ci));
        } else {
            diritem = file_getdiritem(compitem_getrightfile(ci));
        }

        /*
         * copy the file to the new root directory
         */
        if (dir_copy(diritem, dlg_root, HitReadOnly, CopyNoAttributes) == FALSE) {
            nFails++;
            pstr = dir_getrelname(diritem);
            wsprintf(buffer, LoadRcString(IDS_FAILED_TO_COPY), pstr);
            dir_freerelname(diritem, pstr);

            if (!TRACE_ERROR(buffer, TRUE)) {
                /* user pressed cancel - abort current operation*/
                /* fall through to end-copy processing */
                break;
            }

        } else {
            nFiles++;
        }

        wsprintf(buffer, LoadRcString(IDS_COPYING), nFiles);
        SetStatus(buffer);


        /*
         * allow user interface to continue
         */
        if (Poll()) {
            /* abort requested */
            TickCount = GetTickCount()-TickCount;
            windiff_UI(TRUE);
            MessageBox(hwndClient, LoadRcString(IDS_COPY_ABORTED),
                       "WinDiff", MB_OK|MB_ICONINFORMATION);
            windiff_UI(FALSE);
            break;
        }

    } /* traverse */
    wsprintf(buffer, LoadRcString(IDS_COPYING_NFILES), nFiles);
    SetStatus(buffer);
    if (dlg_options & COPY_FROMLEFT) {
        nFails = dir_endcopy(cl->left);
    } else {
        nFails = dir_endcopy(cl->right);
    }
    TickCount = GetTickCount()-TickCount;

    if (nFails<0) {
        wsprintf(buffer, LoadRcString(IDS_COPY_FAILED), -nFails);
    } else {
        wsprintf(buffer, LoadRcString(IDS_COPY_COMPLETE), nFails);
    }
    windiff_UI(TRUE);
    MessageBox(hwndClient, buffer, "WinDiff", MB_OK|MB_ICONINFORMATION);
    windiff_UI(FALSE);

    buffer[0] = '\0';
    SetStatus(buffer);
} /* complist_copyfiles */


/*
 * complist_togglemark
 *
 * each compitem has a BOOL mark state. This function inverts the value of
 * this state for each compitem in the list.
 */
void
complist_togglemark(COMPLIST cl)
{
    COMPITEM ci;

    if (cl == NULL) {
        return;
    }


    /*
     * traverse the list of compitems copying files as necessary
     */
    List_TRAVERSE(cl->items, ci) {

        compitem_setmark(ci, !compitem_getmark(ci));

    }
}

/*
 * complist_itemcount
 *
 * return the number of items in the list
 */
UINT
complist_itemcount(COMPLIST cl)
{
    UINT n = 0;

    if (cl == NULL) {
        return 0;
    }

    /*
     * return the number of compitems in the list
     */
    return List_Card(cl->items);
}

#ifdef USE_REGEXP
    #include "regexp.h"

/*
 * query the user for a pattern to match.
 * all compitems with this pattern in their tag string will be
 * marked (the mark state will be set to TRUE);
 *
 * returns TRUE if any states changed
 */
BOOL
complist_markpattern(COMPLIST cl)
{
    COMPITEM ci;
    char achPattern[MAX_PATH];
    BOOL bOK = FALSE;
    LPSTR ptag;

    regexp  *prog;
    static  char    previous_pat[256]; /* allow for a big pattern ! */
    static  BOOL    fInit = TRUE;
    TCHAR   szBuff[40];

    lstrcpy(szBuff,LoadRcString(IDS_MARK_FILES));

    windiff_UI(TRUE);
    if ( fInit ) {
        GetProfileString(APPNAME, "Pattern", "\\.obj$", previous_pat, 256);
        fInit = FALSE;
    }

    bOK = StringInput(achPattern, sizeof(achPattern),
                      LoadRcString(IDS_ENTER_SUBSTRING1),
                      szBuff, previous_pat );
    windiff_UI(FALSE);

    if (!bOK) {
        return(FALSE);
    }

    /*
    ** Compile the specified regular expression
    */
    if ((prog = regcomp(achPattern)) == NULL) {
        // printf("Invalid search string");
        return(FALSE);
    }

    /*
    ** only overwrite previous pattern with a known good pattern
    */
    strcpy( previous_pat, achPattern );
    WriteProfileString(APPNAME, "Pattern", previous_pat);

    bOK = FALSE;

    if (cl) {
        List_TRAVERSE(cl->items, ci) {
            ptag = compitem_gettext_tag(ci);
            if ( regexec( prog, ptag, 0 ) ) {  /* got a match */
                if (!compitem_getmark(ci)) {
                    bOK = TRUE;
                    compitem_setmark(ci, TRUE);
                }
            }
        }
    }

    /*
    ** regcomp allocates storage with malloc, now is a good time to free
    ** this storage as we have finished with the program.
    */
    free( prog );

    return(bOK);
}

/*
 * here would go a message box saying that the regexp fail for some reason.
 *
 */
void regerror( char *err )
{
    // printf( "%s\n", err );
}

#else

/*
 * query the user for a pattern to match.
 * all compitems with this pattern in their tag string will be
 * marked (the mark state will be set to TRUE);
 *
 * returns TRUE if any states changed
 */
BOOL
complist_markpattern(COMPLIST cl)
{
    COMPITEM ci;
    char achPattern[MAX_PATH];
    BOOL bOK = FALSE;
    LPSTR ptag;
    TCHAR   szBuff[40];

    lstrcpy(szBuff,LoadRcString(IDS_MARK_FILES));

    windiff_UI(TRUE);
    bOK = StringInput(achPattern, sizeof(achPattern), LoadRcString(IDS_ENTER_SUBSTRING2),
            szBuff, "obj");
    windiff_UI(FALSE);

    if (!bOK) {
        return(FALSE);
    }

    bOK = FALSE;

    List_TRAVERSE(cl->items, ci) {
        ptag = compitem_gettext_tag(ci);
        if (strstr(ptag, achPattern) != NULL) {
            if (!compitem_getmark(ci)) {
                bOK = TRUE;
                compitem_setmark(ci, TRUE);
            }

        }
    }

    return(bOK);
}
#endif



/*
 * return a description string for this complist, using
 * the rootdescription for each of the two paths
 */
LPSTR
complist_getdescription(COMPLIST cl)
{
    LPSTR pl;
    LPSTR pr;
    LPSTR desc = 0;


    pl = dir_getrootdescription(cl->left);
    pr = dir_getrootdescription(cl->right);

    if (pl && pr)
    {
        /*
         * allow for space-colon-space and null when sizing
         */
        desc = gmem_get(hHeap, lstrlen(pl) + lstrlen(pr) + 4);
        wsprintf(desc, "%s : %s", pl, pr);
    }

    dir_freerootdescription(cl->left, pl);
    dir_freerootdescription(cl->right, pr);

    return(desc);
}


/*
 *  free up a description string obtained from complist_getdescription
 */
void
complist_freedescription(COMPLIST cl, LPSTR desc)
{
    // remember the null
    gmem_free(hHeap, desc, lstrlen(desc)+1);
}





/* --- internal functions --------------------------------------------*/

/*
 * match up two lists of filenames
 *
 * we can find out from the DIRLIST handle whether the original list
 * was a file or a directory name.
 * If the user typed:
 *      two file names  - match these two item even if the names differ
 *
 *      two dirs        - match only those items whose names match
 *
 *      one file and one dir
 *                      - try to find a file of that name in the dir.
 *
 * returns TRUE if the complist_match was ok, or FALSE if it was
 * aborted in some way.
 */
BOOL
complist_match(COMPLIST cl, VIEW view, BOOL fDeep, BOOL fExact)
{
    LPSTR lname;
    LPSTR rname;
    DIRITEM leftitem, rightitem;
    DIRITEM nextitem;
    int cmpvalue;

    TickCount = GetTickCount();

    if (dir_isfile(cl->left) ) {

        if (dir_isfile(cl->right)) {
            /* two files */

            /* there should be one item in each list - make
             * a compitem by matching these two and append it to the
             * list
             */
            compitem_new(dir_firstitem(cl->left),
                         dir_firstitem(cl->right),
                         cl->items, fExact);

            view_newitem(view);

            TickCount = GetTickCount() - TickCount;
            return TRUE;
        }
        /* left is file, right is dir */
        leftitem = dir_firstitem(cl->left);
        rightitem = dir_firstitem(cl->right);
        lname = dir_getrelname(leftitem);
        while (rightitem != NULL) {
            rname = dir_getrelname(rightitem);
            cmpvalue = lstrcmpi(lname, rname);
            dir_freerelname(rightitem, rname);

            if (cmpvalue == 0) {
                /* this is the match */
                compitem_new( leftitem, rightitem
                              , cl->items, fExact);
                view_newitem(view);

                dir_freerelname(leftitem, lname);

                TickCount = GetTickCount() - TickCount;
                return(TRUE);
            }

            rightitem = dir_nextitem(cl->right, rightitem, fDeep);
        }
        /* not found */
        dir_freerelname(leftitem, lname);
        compitem_new(leftitem, NULL, cl->items, fExact);
        view_newitem(view);
        TickCount = GetTickCount() - TickCount;
        return(TRUE);

    } else if (dir_isfile(cl->right)) {

        /* left is dir, right is file */

        /* loop through the left dir, looking for
         * a file that has the same name as rightitem
         */

        leftitem = dir_firstitem(cl->left);
        rightitem = dir_firstitem(cl->right);
        rname = dir_getrelname(rightitem);
        while (leftitem != NULL) {
            lname = dir_getrelname(leftitem);
            cmpvalue = lstrcmpi(lname, rname);
            dir_freerelname(leftitem, lname);

            if (cmpvalue == 0) {
                /* this is the match */
                compitem_new(leftitem, rightitem
                             , cl->items, fExact);
                view_newitem(view);

                dir_freerelname(rightitem, rname);

                TickCount = GetTickCount() - TickCount;
                return(TRUE);
            }

            leftitem = dir_nextitem(cl->left, leftitem, fDeep);
        }
        /* not found */
        dir_freerelname(rightitem, rname);
        compitem_new(NULL, rightitem, cl->items, fExact);
        view_newitem(view);
        TickCount = GetTickCount() - TickCount;
        return(TRUE);
    }

    /* two directories */

    /* traverse the two lists in parallel comparing the relative names*/

    leftitem = dir_firstitem(cl->left);
    rightitem = dir_firstitem(cl->right);
    while ((leftitem != NULL) && (rightitem != NULL)) {

        lname = dir_getrelname(leftitem);
        rname = dir_getrelname(rightitem);
        if (!dir_compsequencenumber(leftitem, rightitem, &cmpvalue))
        {
            if (dir_iswildcard(cl->left) && dir_iswildcard(cl->right))
                cmpvalue = dir_compwildcard(cl->left, cl->right, lname, rname);
            else
                cmpvalue = utils_CompPath(lname, rname);
        }

#ifdef trace
        {       char msg[2*MAX_PATH+30];
            wsprintf( msg, "complist_match: %s %s %s\n"
                      , lname
                      , ( cmpvalue<0 ? "<"
                          : (cmpvalue==0 ? "=" : ">")
                        )
                      , rname
                    );
            if (bTrace) Trace_File(msg);
        }
#endif
        dir_freerelname(leftitem, lname);
        dir_freerelname(rightitem, rname);

        if (cmpvalue == 0) {
            BOOL trackThese = TrackSame || TrackDifferent;
            if (!TrackReadonly) {
                BOOL bothReadonly = (BOOL)((dir_getattr(leftitem) &
                                            dir_getattr(rightitem) &
                                            FILE_ATTRIBUTE_READONLY) != 0);
                if (bothReadonly) {
                    trackThese = FALSE;
                }
            }
            if (trackThese) {
                compitem_new( leftitem, rightitem
                              , cl->items, fExact);
                if (view_newitem(view)) {
                    TickCount = GetTickCount() - TickCount;
                    return(FALSE);
                }
                leftitem = dir_nextitem(cl->left, leftitem, fDeep);
                rightitem = dir_nextitem(cl->right, rightitem, fDeep);
            } else {
                nextitem = dir_nextitem(cl->left, leftitem, fDeep);
                List_Delete(leftitem);
                leftitem = nextitem;
                nextitem = dir_nextitem(cl->right, rightitem, fDeep);
                List_Delete(rightitem);
                rightitem = nextitem;
            }

        } else if (cmpvalue < 0) {
            if (TrackLeftOnly) {
                compitem_new(leftitem, NULL, cl->items, fExact);
                if (view_newitem(view)) {
                    TickCount = GetTickCount() - TickCount;
                    return(FALSE);
                }
                leftitem = dir_nextitem(cl->left, leftitem, fDeep);
            } else {
                nextitem = dir_nextitem(cl->left, leftitem, fDeep);
                List_Delete(leftitem);
                leftitem = nextitem;
            }
        } else {
            if (TrackRightOnly) {
                compitem_new(NULL, rightitem, cl->items, fExact);
                if (view_newitem(view)) {
                    TickCount = GetTickCount() - TickCount;
                    return(FALSE);
                }
                rightitem = dir_nextitem(cl->right, rightitem, fDeep);
            } else {
                nextitem = dir_nextitem(cl->right, rightitem, fDeep);
                List_Delete(rightitem);
                rightitem = nextitem;
            }
        }
    }


    /* any left over are unmatched */
    if (TrackLeftOnly) {
        while (leftitem != NULL) {
            compitem_new(leftitem, NULL, cl->items, fExact);
            if (view_newitem(view)) {
                TickCount = GetTickCount() - TickCount;
                return(FALSE);
            }
            leftitem = dir_nextitem(cl->left, leftitem, fDeep);
        }
    }
    if (TrackRightOnly) {
        while (rightitem != NULL) {
            compitem_new(NULL, rightitem, cl->items, fExact);
            if (view_newitem(view)) {
                TickCount = GetTickCount() - TickCount;
                return(FALSE);
            }
            rightitem = dir_nextitem(cl->right, rightitem, fDeep);
        }
    }
    TickCount = GetTickCount() - TickCount;
    return(TRUE);
} /* complist_match */

/* return time last operation took in milliseconds */
DWORD complist_querytime(void)
{       return TickCount;
}


/* dialog to query about filename and types of files. Init dlg fields from
 * the dlg_* variables, and save state to the dlg_* variables on dialog
 * close. return TRUE for OK, or FALSE for cancel (from the dialogbox()
 * using EndDialog).
 */
int FAR PASCAL
complist_dodlg_savelist(HWND hDlg, UINT message, UINT wParam, long lParam)
{
    static char buffer[MAX_PATH+20];
    static char szBuff[MAX_PATH+20];

    switch (message) {
        case WM_INITDIALOG:
            SendDlgItemMessage(hDlg, IDD_IDENTICAL, BM_SETCHECK,
                               dlg_identical ? 1 : 0, 0);
            SendDlgItemMessage(hDlg, IDD_DIFFER, BM_SETCHECK,
                               dlg_differ ? 1 : 0, 0);
            SendDlgItemMessage(hDlg, IDD_LEFT, BM_SETCHECK,
                               dlg_left ? 1 : 0, 0);
            SendDlgItemMessage(hDlg, IDD_RIGHT, BM_SETCHECK,
                               dlg_right ? 1 : 0, 0);
            SendDlgItemMessage(hDlg, IDD_SUMS, BM_SETCHECK,
                               dlg_sums ? 1 : 0, 0);
            CheckDlgButton(hDlg, IDD_IGNOREMARK, dlg_IgnoreMarks ? 1 : 0);

            SetDlgItemText(hDlg, IDD_FILE, dlg_file);

            /* convert 'left tree' into the right name */
            if(bJapan) {        /* check whether primary language is Japanese */
                // in reverse order for Japanese grammar
                GetDlgItemText(hDlg, IDD_LEFT, szBuff, sizeof(buffer)/sizeof(TCHAR));
                lstrcpy(buffer, dialog_leftname);
                lstrcat(buffer, szBuff);
            } else {
                GetDlgItemText(hDlg, IDD_LEFT, buffer, sizeof(buffer)/sizeof(TCHAR));
                lstrcat(buffer, dialog_leftname);
            }
	    //            SendDlgItemMessage(hDlg, IDD_LEFT, WM_SETTEXT, 0, (LPARAM) buffer);

            /* convert 'right tree' msg into correct path */
            if(bJapan) {        /* check whether primary language is Japanese */
                // in reverse order for Japanese grammar
                GetDlgItemText(hDlg, IDD_RIGHT, szBuff, sizeof(buffer)/sizeof(TCHAR));
                lstrcpy(buffer, dialog_rightname);
                lstrcat(buffer, szBuff);
            } else {
                GetDlgItemText(hDlg, IDD_RIGHT, buffer, sizeof(buffer)/sizeof(TCHAR));
                lstrcat(buffer, dialog_rightname);
            }
	    //            SendDlgItemMessage(hDlg, IDD_RIGHT, WM_SETTEXT, 0, (LPARAM) buffer);

            return(TRUE);

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {

                case IDOK:
                    dlg_identical = (SendDlgItemMessage(hDlg, IDD_IDENTICAL,
                                                        BM_GETCHECK, 0, 0) == 1);
                    dlg_differ = (SendDlgItemMessage(hDlg, IDD_DIFFER,
                                                     BM_GETCHECK, 0, 0) == 1);
                    dlg_left = (SendDlgItemMessage(hDlg, IDD_LEFT,
                                                   BM_GETCHECK, 0, 0) == 1);
                    dlg_right = (SendDlgItemMessage(hDlg, IDD_RIGHT,
                                                    BM_GETCHECK, 0, 0) == 1);
                    dlg_sums = (SendDlgItemMessage(hDlg, IDD_SUMS,
                                                   BM_GETCHECK, 0, 0) == 1);
                    dlg_IgnoreMarks =
                    (SendDlgItemMessage(
                                       hDlg,
                                       IDD_IGNOREMARK,
                                       BM_GETCHECK, 0, 0) == 1);

                    GetDlgItemText(hDlg, IDD_FILE, dlg_file, sizeof(dlg_file));

                    EndDialog(hDlg, TRUE);
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;
            }
    }
    return(FALSE);
} /* complist_dodlg_savelist */

/* dialog to get directory name and inclusion options. Init dlg fields from
 * the dlg_* variables, and save state to the dlg_* variables on dialog
 * close. return TRUE for OK, or FALSE for cancel (from the dialogbox()
 * using EndDialog).
 */
int FAR PASCAL
complist_dodlg_copyfiles(HWND hDlg, UINT message, UINT wParam, long lParam)
{
    static char buffer[MAX_PATH+20];
    static int  default_buffer_length;
    static char szBuff[MAX_PATH+20];

    switch (message) {
        case WM_INITDIALOG:
            /*
             * set checkboxes and directory field to defaults
             */
            CheckDlgButton(hDlg, IDD_IDENTICAL,
                           (dlg_options & INCLUDE_SAME) ? 1 : 0);

            CheckDlgButton(hDlg, IDD_DIFFER,
                           (dlg_options & INCLUDE_DIFFER) ? 1 : 0);

            CheckDlgButton(hDlg, IDD_LEFT,
                           (dlg_options & (INCLUDE_LEFTONLY|INCLUDE_RIGHTONLY)) ? 1 : 0);

            CheckDlgButton(hDlg, IDD_IGNOREMARK, dlg_IgnoreMarks ? 1 : 0);

            CheckDlgButton(hDlg, IDD_ATTRIBUTES, dlg_IgnoreAttributes ? 0 : 1);

	    //            SendDlgItemMessage(hDlg, IDD_DIR1, CB_ADDSTRING, 0, (LPARAM) dialog_leftname);
	    // SendDlgItemMessage(hDlg, IDD_DIR1, CB_ADDSTRING, 0, (LPARAM) dialog_rightname);
            SetDlgItemText(hDlg, IDD_DIR1, dlg_root);

            /*
             * set 'copy from' buttons to have the full pathname
             */
	    //            SetDlgItemText(hDlg, IDD_FROMLEFT, dialog_leftname);
	    //            SetDlgItemText(hDlg, IDD_FROMRIGHT, dialog_rightname);

            /*
             * set default radio button for copy from, and set
             * the text on the 'files only in...' checkbox to
             * indicate which path is being selected
             */

            GetDlgItemText(hDlg, IDD_LEFT, buffer, sizeof(buffer)/sizeof(TCHAR));
            // Remember the length of the default buffer text
            // this (English) is "Files &only in "
            default_buffer_length = lstrlen(buffer);

            if (dlg_options & COPY_FROMLEFT) {
                CheckRadioButton(hDlg, IDD_FROMLEFT, IDD_FROMRIGHT,
                                 IDD_FROMLEFT);

                if(bJapan) {        /* check whether primary language is Japanese */
                    // in reverse order for Japanese grammar
                    lstrcpy(szBuff, dialog_leftname);
                    lstrcat(szBuff, buffer);
                } else {
                    lstrcat(buffer, dialog_leftname);
                }
            } else {
                CheckRadioButton(hDlg, IDD_FROMLEFT, IDD_FROMRIGHT,
                                 IDD_FROMRIGHT);

                if(bJapan) {        /* check whether primary language is Japanese */
                    // in reverse order for Japanese grammar
                    lstrcpy(szBuff, dialog_rightname);
                    lstrcat(szBuff, buffer);
                } else {
                    lstrcat(buffer, dialog_rightname);
                }
            }
	    //            SetDlgItemText(hDlg, IDD_LEFT, bJapan ? szBuff : buffer);

            return(TRUE);

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {

#if 0 	// NOT YET WORKING.  The idea is that when you select the
                // copy TO directory, the copy from is changed to be different.

                case IDD_DIR1:
                    switch (GET_WM_COMMAND_CMD(wParam, lParam)) {
                        case CBN_KILLFOCUS:
                            {
                                // Whenever the "Copy To" selection alters
                                // (and when we enter/leave the list box),
                                // we set the copy from field.  IF we are
                                // copying TO the LEFT directory, then set
                                // the default copy from directory to the
                                // right.
                                GetDlgItemText(hDlg, IDD_DIR1, dlg_root, sizeof(dlg_root));
                                if (dlg_root[0] != 0) {
                                    UINT button = IDD_FROMLEFT;
                                    if (0 == lstrcmpi(dlg_root, dialog_leftname)) {
                                        button = IDD_FROMRIGHT;
                                    }
                                    CheckRadioButton(hDlg, IDD_FROMLEFT, IDD_FROMRIGHT, button);
                                }
                            }
                    }
                    break;
#endif

                case IDD_FROMLEFT:
                    if(bJapan) {        /* check whether primary language is Japanese */
                        // in reverse order for Japanese grammar
                        lstrcpy(szBuff, dialog_leftname);
                        lstrcat(szBuff, buffer);
			//                        SetDlgItemText(hDlg, IDD_LEFT, szBuff);
                    } else {
                        buffer[default_buffer_length] = 0;  // truncate to initial length
                        lstrcat(buffer, dialog_leftname);
			//                        SetDlgItemText(hDlg, IDD_LEFT, buffer);
                    }
                    dlg_options &= ~(COPY_FROMRIGHT);
                    dlg_options |= COPY_FROMLEFT;
                    break;

                case IDD_FROMRIGHT:
                    if(bJapan) {        /* check whether primary language is Japanese */
                        // in reverse order for Japanese grammar
                        lstrcpy(szBuff, dialog_rightname);
                        lstrcat(szBuff, buffer);
			//                        SetDlgItemText(hDlg, IDD_LEFT, szBuff);
                    } else {
                        buffer[default_buffer_length] = 0;  // truncate to initial length
                        lstrcat(buffer, dialog_rightname);
			//                        SetDlgItemText(hDlg, IDD_LEFT, buffer);
                    }
                    dlg_options &= ~(COPY_FROMLEFT);
                    dlg_options |= COPY_FROMRIGHT;
                    break;

                case IDOK:
                    if (SendDlgItemMessage(hDlg, IDD_IDENTICAL,
                                           BM_GETCHECK, 0, 0) == 1) {
                        dlg_options |= INCLUDE_SAME;
                    } else {
                        dlg_options &= ~INCLUDE_SAME;
                    }
                    if (SendDlgItemMessage(hDlg, IDD_DIFFER,
                                           BM_GETCHECK, 0, 0) == 1) {
                        dlg_options |= INCLUDE_DIFFER;
                    } else {
                        dlg_options &= ~INCLUDE_DIFFER;
                    }
                    if (SendDlgItemMessage(hDlg, IDD_LEFT,
                                           BM_GETCHECK, 0, 0) == 1) {
                        dlg_options |= INCLUDE_LEFTONLY;
                    } else {
                        dlg_options &= ~INCLUDE_LEFTONLY;
                    }

                    dlg_IgnoreMarks =
                    (SendDlgItemMessage(
                                       hDlg,
                                       IDD_IGNOREMARK,
                                       BM_GETCHECK, 0, 0) == 1);

                    dlg_IgnoreAttributes =
                    (SendDlgItemMessage(
                                       hDlg,
                                       IDD_ATTRIBUTES,
                                       BM_GETCHECK, 0, 0) == 0);

                    GetDlgItemText(hDlg, IDD_DIR1, dlg_root, sizeof(dlg_root));

                    EndDialog(hDlg, TRUE);
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;
            }
    }
    return(FALSE);
} /* complist_dodlg_copyfiles */

/* allocate a new complist and initialise it */
COMPLIST
complist_new(void)
{
    COMPLIST cl;

    cl = (COMPLIST) gmem_get(hHeap, sizeof(struct complist));
    cl->left = NULL;
    cl->right = NULL;
    cl->items = List_Create();

    return(cl);
} /* complist_new */

static void
FillOtherEdit(HWND hDlg, int idFrom, int idTo)
{
    char buffer[MAX_PATH];
    SLMOBJECT hSlm;

    GetDlgItemText(hDlg, idFrom, buffer, sizeof(buffer));

    if ( (hSlm = SLM_New(buffer, 0)) != NULL) {
        if (IsSourceDepot(hSlm)) {
            LPSTR pTag = pTag = SLM_ParseTag(buffer, TRUE);
            lstrcpy(buffer, "(Source Depot, ");
            if (pTag) {
                lstrcat(buffer, pTag);
                gmem_free(hHeap, pTag, lstrlen(pTag)+1);
            } else {
                lstrcat(buffer, "#have");
            }
            lstrcat(buffer, ")");
            SetDlgItemText(hDlg, idTo, buffer);
        } else {
            SLM_GetMasterPath(hSlm, buffer);
            SetDlgItemText(hDlg, idTo, buffer);
        }
        SLM_Free(hSlm);
    } else {
        // set text to null if no valid slm
        SetDlgItemText(hDlg, idTo, "");
    }
}

/* dialog box function to ask for two directory names.
 * no listing of files etc - just two edit fields  in which the
 * user can type a file or a directory name.
 *
 * initialises the names from win.ini, and stores them to win.ini first.
 */
int FAR PASCAL
complist_dodlg_dir(HWND hDlg, unsigned message, UINT wParam, LONG lParam)
{
    static char path[MAX_PATH];
    static char buffer[MAX_PATH];

    /* We write what we find to the ini file, but we only load from the ini file
    ** once per instance of the app.  So if you start two windiffs, each remembers
    ** what it is doing as long as it is alive
    */

    int id;
    SLMOBJECT hSlm;

    switch (message) {

        case WM_INITDIALOG:

            /* fill the edit fields with the current
             * directory as a good starting point - if there isn't
             * already a saved path.
             *
             * set the current directory as a label so that the
             * user can select relative paths such as ..
             *
             */
            _getcwd(path, sizeof(path));
            AnsiLowerBuff(path, strlen(path));
            SetDlgItemText(hDlg, IDD_LAB3, path);

            if (!SeenDialogNames)
                GetProfileString(APPNAME, "NameLeft", path, dialog_leftname, MAX_PATH);
            SetDlgItemText(hDlg, IDD_DIR1, dialog_leftname);
            if (!SeenDialogNames)
                GetProfileString(APPNAME, "NameRight", path, dialog_rightname, MAX_PATH);
            SetDlgItemText(hDlg, IDD_DIR2, dialog_rightname);
            if (!SeenDialogNames)
                dialog_recursive = GetProfileInt(APPNAME, "Recursive", 1);
            SendDlgItemMessage( hDlg
                                , IDD_RECURSIVE
                                , BM_SETCHECK
                                , (WPARAM)dialog_recursive
                                , 0
                              );

            /* If there's a slm.ini visible, enable the SLM check boxes */
            if (1&IsSLMOK()) {
                ShowWindow(GetDlgItem(hDlg, IDD_SLM), SW_SHOW);
                ShowWindow(GetDlgItem(hDlg, IDD_LOCALSLM), SW_SHOW);
            }
            SeenDialogNames = TRUE;
            return(TRUE);

        case WM_COMMAND:
            id = GET_WM_COMMAND_ID(wParam, lParam);

            switch (id) {
                case IDD_DIR1:
                case IDD_DIR2:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE) {

                        int idother = (id == IDD_DIR1) ? IDD_DIR2 : IDD_DIR1;

                        /* if we are changing the edit field, and the SLM
                         * is checked for the other edit field, then update the
                         * other edit field to the SLM path for this one.
                         */
                        if (IsDlgButtonChecked(hDlg, (id == IDD_DIR1) ? IDD_LOCALSLM : IDD_SLM)) {
                            FillOtherEdit(hDlg, id, idother);
                        }
                    }
                    break;

                case IDD_SLM:
                case IDD_LOCALSLM:
                    {
                        int idthis, idother;


                        if (id == IDD_SLM) {
                            idthis = IDD_DIR1;
                            idother = IDD_DIR2;
                            // ensure that both 'slm' boxes are not set!
                            CheckDlgButton(hDlg, IDD_LOCALSLM, FALSE);
                        } else {
                            idthis = IDD_DIR2;
                            idother = IDD_DIR1;
                            CheckDlgButton(hDlg, IDD_SLM, FALSE);
                        }

                        if (IsDlgButtonChecked(hDlg, id)) {


                            /*
                             * disable edit field and fill
                             * with SLM path for other edit field
                             */
                            EnableWindow(GetDlgItem(hDlg, idthis), FALSE);
                            EnableWindow(GetDlgItem(hDlg,
                                                    (id == IDD_SLM) ? IDD_LAB1 : IDD_LAB2), FALSE);

                            /*
                             * fill the remote box with the slm library
                             * for the local path, if possible.
                             */
                            FillOtherEdit(hDlg, idother, idthis);
                        } else {

                            // re-enable the edit field
                            EnableWindow(GetDlgItem(hDlg, idthis), TRUE);
                            EnableWindow(GetDlgItem(hDlg,
                                                    (id == IDD_SLM) ? IDD_LAB1 : IDD_LAB2), TRUE);
                        }
                        break;
                    }


                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    return(TRUE);

                case IDOK:
                    {
                        LPSTR pszThis = 0;
                        LPSTR pszOther = 0;

                        /* fetch the text from the dialog, and remember
                         * it in win.ini
                         */

                        GetDlgItemText(hDlg, IDD_DIR1,
                                       dialog_leftname, sizeof(dialog_leftname));
                        GetDlgItemText(hDlg, IDD_DIR2,
                                       dialog_rightname, sizeof(dialog_rightname));

                        if (IsDlgButtonChecked(hDlg, IDD_SLM))
                        {
                            pszThis = dialog_rightname;
                            pszOther = dialog_leftname;
                        }
                        else if (IsDlgButtonChecked(hDlg, IDD_LOCALSLM))
                        {
                            pszThis = dialog_leftname;
                            pszOther = dialog_rightname;
                        }

                        if (pszThis)
                        {
                            hSlm = SLM_New(pszThis, 0);
                            if (hSlm)
                            {
                                if (IsSourceDepot(hSlm))
                                {
                                    LPSTR pTag = SLM_ParseTag(pszThis, TRUE);
                                    lstrcpy(pszOther, pszThis);
                                    if (pTag)
                                    {
                                        lstrcat(pszOther, pTag);
                                        gmem_free(hHeap, pTag, lstrlen(pTag)+1);
                                    }
                                    else
                                    {
                                        lstrcat(pszOther, "#have");
                                    }
                                }
                                SLM_Free(hSlm);
                            }
                        }

                        WriteProfileString(APPNAME, "NameLeft", dialog_leftname);
                        WriteProfileString(APPNAME, "NameRight", dialog_rightname);

                        dialog_recursive =  ( 1 == SendDlgItemMessage( hDlg
                                                                       , IDD_RECURSIVE
                                                                       , BM_GETCHECK
                                                                       , 0
                                                                       , 0
                                                                     )
                                            );
                        WriteProfileString( APPNAME
                                            , "Recursive"
                                            , dialog_recursive ? "1" : "0"
                                          );
                        EndDialog(hDlg, TRUE);
                    }
                    return(TRUE);
            }
            break;
    }
    return(FALSE);
} /* complist_dodlg_dir */


/*
 * simple dialog to ask for the name of the checksum server, and
 * the names of the local and remote paths.
 *
 * defaults for all strings are stored in win.ini
 */
int FAR PASCAL
complist_dodlg_remote(HWND hDlg, unsigned message, UINT wParam, LONG lParam)
{
    static char path[MAX_PATH];
    static char buffer[MAX_PATH];
    static char LeftName[MAX_PATH];
    static char RightName[MAX_PATH];
    static BOOL Recursive;
    /* Other options such as FastScan are unique to the remote dialog, so
    ** we don't need to keep our own copy here
    */
    int id;
    static BOOL SeenDialog = FALSE;
    SLMOBJECT hSlm;

    switch (message) {

        case WM_INITDIALOG:
            /* fill the edit fields with the current
             * directory as a good starting point - if there isn't
             * already a saved path.
             *
             * set the current directory as a label so that the
             * user can select relative paths such as ..
             *
             */
            _getcwd(path, sizeof(path));
            AnsiLowerBuff(path, strlen(path));
            SetDlgItemText(hDlg, IDD_LAB3, path);

            if (!SeenDialog)
                GetProfileString(APPNAME, "NameRemote", path, LeftName, MAX_PATH);
            SetDlgItemText(hDlg, IDD_DIR1, LeftName);

            if (!SeenDialog)
                GetProfileString(APPNAME, "NameLocal", path, RightName, MAX_PATH);
            SetDlgItemText(hDlg, IDD_DIR2, RightName);

            if (!SeenDialog)
                dialog_fastscan = GetProfileInt(APPNAME, "Fastscan", 0);
            SendDlgItemMessage( hDlg
                                , IDD_FASTSCAN
                                , BM_SETCHECK
                                , (WPARAM)dialog_fastscan
                                , 0
                              );

            path[0] = '\0';

            path[0] = '\0';
            if (!SeenDialog)
                GetProfileString(APPNAME, "NameServer", path, dialog_servername, MAX_PATH);
            SetDlgItemText(hDlg, IDD_SERVER, dialog_servername);

            if (!SeenDialog)
                Recursive = GetProfileInt(APPNAME, "Recursive", 1);
            SendDlgItemMessage( hDlg
                                , IDD_RECURSIVE
                                , BM_SETCHECK
                                , (WPARAM)Recursive
                                , 0
                              );

            SendDlgItemMessage(hDlg, IDD_BOTHREMOTE, BM_SETCHECK,
                               dialog_bothremote?1:0, 0);

            /* If there's a slm.ini visible, enable the SLM check boxes */
            if (1&IsSLMOK()) {
                ShowWindow(GetDlgItem(hDlg, IDD_SLM), SW_SHOW);
                ShowWindow(GetDlgItem(hDlg, IDD_LOCALSLM), SW_SHOW);
            }
            SeenDialog = TRUE;
            return(TRUE);

        case WM_COMMAND:
            id = GET_WM_COMMAND_ID(wParam, lParam);
            switch (id) {
                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    return(TRUE);

                case IDD_DIR1:
                case IDD_DIR2:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE) {

                        int idother = (id == IDD_DIR1) ? IDD_DIR2 : IDD_DIR1;

                        /* if we are leaving the edit field, and the SLM
                         * is checked for the other edit field, then update the
                         * other edit field to the SLM path for this one.
                         */
                        if (IsDlgButtonChecked(
                                              hDlg,
                                              (id == IDD_DIR1) ? IDD_LOCALSLM : IDD_SLM)) {

                            GetDlgItemText(hDlg, id, path, sizeof(path));

                            if ( (hSlm = SLM_New(path, 0)) != NULL) {
                                SLM_GetMasterPath(hSlm, buffer);
                                SLM_Free(hSlm);
                                SetDlgItemText(hDlg, idother, buffer);
                            } else {
                                // set text to null if no valid slm
                                SetDlgItemText(hDlg, idother, "");
                            }

                        }
                    }
                    break;

                case IDD_SLM:
                case IDD_LOCALSLM:
                    {
                        int idthis, idother;


                        if (id == IDD_SLM) {
                            idthis = IDD_DIR1;
                            idother = IDD_DIR2;
                        } else {
                            idthis = IDD_DIR2;
                            idother = IDD_DIR1;
                        }

                        if (IsDlgButtonChecked(hDlg, id)) {

                            /*
                             * disable edit field and fill
                             * with SLM path for other edit field
                             */
                            EnableWindow(GetDlgItem(hDlg, idthis), FALSE);
                            EnableWindow(GetDlgItem(hDlg,
                                                    (id == IDD_SLM) ? IDD_LAB1 : IDD_LAB2), FALSE);

                            /*
                             * fill the remote box with the slm library
                             * for the local path, if possible.
                             */
                            GetDlgItemText(hDlg, idother, path, sizeof(path));

                            if ( (hSlm = SLM_New(path, 0)) != NULL) {
                                SLM_GetMasterPath(hSlm, buffer);
                                SLM_Free(hSlm);
                                SetDlgItemText(hDlg, idthis, buffer);
                            } else {
                                // set text to null if no valid slm path
                                SetDlgItemText(hDlg, idthis, "");
                            }
                        } else {

                            // re-enable the edit field
                            EnableWindow(GetDlgItem(hDlg, idthis), TRUE);
                            EnableWindow(GetDlgItem(hDlg,
                                                    (id == IDD_SLM) ? IDD_LAB1 : IDD_LAB2), TRUE);
                        }
                        break;
                    }


                case IDOK:
                    GetDlgItemText(hDlg, IDD_DIR1,
                                   dialog_leftname, sizeof(dialog_leftname));
                    WriteProfileString(APPNAME, "NameRemote", dialog_leftname);
                    strcpy(LeftName, dialog_leftname);

                    GetDlgItemText(hDlg, IDD_DIR2,
                                   dialog_rightname, sizeof(dialog_rightname));
                    WriteProfileString(APPNAME, "NameLocal", dialog_rightname);
                    strcpy(RightName, dialog_rightname);

                    GetDlgItemText(hDlg, IDD_SERVER,
                                   dialog_servername, sizeof(dialog_servername));
                    WriteProfileString(APPNAME, "NameServer", dialog_servername);

                    dialog_recursive =  ( 1 == SendDlgItemMessage( hDlg
                                                                   , IDD_RECURSIVE
                                                                   , BM_GETCHECK
                                                                   , 0
                                                                   , 0
                                                                 )
                                        );
                    WriteProfileString( APPNAME
                                        , "Recursive"
                                        , dialog_recursive ? "1" : "0"
                                      );
                    Recursive = dialog_recursive;
                    dialog_fastscan =  ( 1 == SendDlgItemMessage( hDlg
                                                                  , IDD_FASTSCAN
                                                                  , BM_GETCHECK
                                                                  , 0
                                                                  , 0
                                                                )
                                       );
                    WriteProfileString( APPNAME
                                        , "Fastscan"
                                        , dialog_fastscan ? "1" : "0"
                                      );
                    dialog_autocopy =  ( 1 == SendDlgItemMessage( hDlg
                                                                  , IDD_AUTOCOPY
                                                                  , BM_GETCHECK
                                                                  , 0
                                                                  , 0
                                                                )
                                       );
                    /* The autocopy function is DANGEROUS so we do NOT keep it */

                    dialog_bothremote = (SendDlgItemMessage( hDlg
                                                             , IDD_BOTHREMOTE
                                                             , BM_GETCHECK
                                                             , 0
                                                             , 0
                                                           ) == 1);

                    EndDialog(hDlg, TRUE);
                    return(TRUE);
            }
            break;
    }
    return(FALSE);
} /* complist_dodlg_remote */

/* complist_matchnames has become utils_CompPath in gutils\utils.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\windiff\compitem.h ===
/*
 * CompItem
 *
 * a CompItem is a comparison between two files. It keeps track
 * of the two files. It knows how to compare two files, and knows the
 * results of the comparison: the end result is a list of SECTIONs
 * in each of the files, and a composite list of sections.
 *
 * One or other of the files may not exist.
 *
 * a compitem has a state - this indicates whether the two
 * files are the same, or different, or if only one file of that
 * name exists. This state is set on creation of the CompItem
 * and may be queried later.
 *
 */

#ifndef INC_VIEW_COMPLIST
#define INC_VIEW_COMPLIST
typedef struct compitem FAR* COMPITEM;          /* handle to a compitem */
typedef struct view FAR * VIEW;                 /* handle to a VIEW     */
typedef struct complist FAR * COMPLIST;         /* handle to a complist */
#endif // INC_VIEW_COMPLIST

/* build a new compitem from two files. Either (but not both) of the files
 * may be NULL.
 *
 * This operation may cause the files to be read in and compared.
 * In any case, this will be done by the time a call to one of
 * the query*sections functions completes.
 *
 * If the LIST parameter is not NULL, the item will be
 * appended to the list during initialisation - that is, the
 * compitem will do a List_NewLast operation and then initialise the
 * resulting object. If LIST is NULL, the compitem will allocate the
 * structure using some other memory allocation scheme. in either
 * case, the compitem handle will be returned. This also affects
 * behaviour of compitem_delete- we only free the compitem itself if
 * we allocated it ourself and not through List_NewLast.
 */
COMPITEM compitem_new(DIRITEM left, DIRITEM right, LIST list, BOOL fExact);


/* delete a compitem and free all associated data - INCLUDING deleting
 * the two FILEDATAs and all associated list of lines and sections.
 *
 * If the compitem was allocated on a list, it will not be freed, only
 * the memory hanging off it.
 */
void compitem_delete(COMPITEM item);


/* return a handle to a LIST of SECTIONs representing the compared file.
 * this call will cause the list to be created if it hasn't already been.
 *
 * returned handle will be NULL if either of the files is NULL.
 *
 * the list of sections can be traversed using the standard list functions.
 * the list you have a handle to is still owned by the compitem. to delete
 * it, call compitem_delete to delete the whole thing, or
 * compitem_discardsections to throw away all of the results of the compare
 */
LIST compitem_getcomposite(COMPITEM item);


/*
 * discard all compare data - throw away the composite section list and
 * any associated data (including the left and right section lists).
 * retains the two files. This is used either to free up memory when a
 * compitem is no longer being viewed, or to cause a new compare when
 * the global compare options flags (such as ignore_blanks) have changed.
 */
void compitem_discardsections(COMPITEM item);



/* return the handle to the list of sections in the left, right file.
 * These calls will cause the lists to be created if they are not already.
 *
 * the compitem still owns the list. traverse it with the standard list
 * functions, but don't change it or delete it.
 */
LIST compitem_getleftsections(COMPITEM item);
LIST compitem_getrightsections(COMPITEM item);


/* return the handle of the left or right file */
FILEDATA compitem_getleftfile(COMPITEM item);
FILEDATA compitem_getrightfile(COMPITEM item);


/* query the compare state of this compitem */
int compitem_getstate(COMPITEM item);

/* get a pointer to a text string describing the item (normally the
 * file name or filenames if different. The text pointed to should not
 * be changed or freed.
 */
LPSTR compitem_gettext_tag(COMPITEM item);

/* return a pointer to a text string describing the compare result - this
 * will be a text form of the item's state.
 * The text pointed to should not be changed or freed.
 */
LPSTR compitem_gettext_result(COMPITEM item);

/*
 * options for compitem_getfilename, indicating which name is desired
 */
#define CI_LEFT         1       /* name of left file */
#define CI_RIGHT        2       /* name of right file */
#define CI_COMP         3       /* name of composite file */

/*
 * return the name of the file associated with this compitem. The option
 * argument (one of CI_LEFT, CI_RIGHT, CI_COMP) indicates which file
 * is required.
 *
 * The file may be a temporary file, if the file option specifies a remote
 * file, or the composite file.
 *
 * call compitem_freefilename once the file is finished with.
 */
LPSTR compitem_getfilename(VIEW view, COMPITEM item, int option);

/*
 * free memory created by a call to compitem_getfilename. if a temporary
 * file was created, this may cause it to be deleted. The option argument must
 * be the same as passed to the original compitem_getfilename call.
 */
void compitem_freefilename(COMPITEM item, int option, LPSTR filename);


/* save the composite file
 *
 * if savename is not null, write the item out to savename using compopts.
 * otherwise, prompt by dialog for filename and options.
 */
LPSTR compitem_savecomp(VIEW view, COMPITEM ci, LPSTR savename, int listopts);


/*
 * worker function to write the actual composite file
 *
 * if savename is not null, write the list out to savename using compopts.
 * otherwise, prompt by dialog for filename and options.
 */
LPSTR compitem_writefile(VIEW view, COMPITEM ci, LPSTR savename, int compopts);


/*
 * set the mark state of a file. The only use for this is to retrieve it
 * later using compitem_getmark. The state is a bool.
 */
void compitem_setmark(COMPITEM item, BOOL bMark);


/*
 * return the mark state set by compitem_setmark
 */
BOOL compitem_getmark(COMPITEM item);

/* Tell compitem the paths to be used for autocopy.  Copies left to right */
void compitem_SetCopyPaths(LPSTR LeftPath, LPSTR RightPath);

/* Rescan the file, get new checksums etc */
void compitem_rescan(COMPITEM ci);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\windiff\compitem.c ===
/*
 * compitem.c
 *
 * comparison between two files. A compitem is a data type that knows
 * about two files, and can compare them. The result of the comparison
 * is a list of sections for each file, and a composite list of sections
 * representing the comparison of the two files.
 *
 * A compitem has a state (one of the integer values defined in state.h)
 * representing the result of the comparison. It can also be
 * queried for the text result (text equivalent of the state) as well
 * as the tag - or title for this compitem (usually a text string containing
 * the name(s) of the files being compared).
 *
 * a compitem will supply a composite section list even if the files are
 * the same, or if there is only one file. The composite section list will
 * only be built (and the files read in) when the compitem_getcomposite()
 * call is made (and not at compitem_new time).
 *
 * Geraint Davies, July 92
 */

#include <windows.h>
#include <stdlib.h>
#include <string.h>

#include <gutils.h>

#include "state.h"
#include "windiff.h"
#include "wdiffrc.h"

#include "list.h"
#include "line.h"
#include "scandir.h"
#include "file.h"
#include "section.h"
#include "complist.h"
#include "view.h"
#include "compitem.h"


/* --- data structures ------------------------------------------------ */

/*
 * the user has a handle to a compitem, which is in fact a pointer to
 * one of these structs.
 */
struct compitem {

    FILEDATA left;          /* handle for left-hand file */
    FILEDATA right;         /* handle for right-hand file */

    LIST secs_composite;    /* list of sections (composite file)*/
    LIST secs_left;         /* list of sections (left file) */
    LIST secs_right;        /* list of sections (right file) */

    int state;              /* compitem state - result of compare */
    BOOL bDiscard;          /* true if not alloc-ed on list */
    LPSTR tag;              /* text for tag (title of compitem) */
    LPSTR result;           /* text equivalent of state */

    BOOL bMarked;           /* mark-state: used only by get/set mark*/
    char delims[64];        /* null term string of delimiters for lines
                               64 is arbitrary limit (time bomb). Currently use <=4
                            */
};

/* --- forward declaration of internal functions -------------------- */

LPSTR ci_copytext(LPSTR in);
void ci_makecomposite(COMPITEM ci);
void ci_compare(COMPITEM ci);
void FindDelimiters(DIRITEM leftname, DIRITEM rightname, LPSTR delims);
LPSTR ci_AddTimeString(LPSTR in, COMPITEM ci, DIRITEM leftname, DIRITEM rightname);
void SetStateAndTag( COMPITEM ci, DIRITEM leftname, DIRITEM rightname, BOOL fExact);



/* -- externally called functions ---------------------------------- */

/*
 * compitem_new
 *
 * return a handle to a new compitem - given the filenames for the
 * left and right files to be compared. Either left or right or neither
 * (but not both) may be null. In this case we set the state accordingly.
 *
 * The parameters are handles to DIRITEM objects: these allow us to get the
 * the name of the file relative to the compare roots (needed for the tag)
 * and the absolute name of the file (needed for opening the file).
 *
 * if the list parameter is not null, the List_New* functions are used to
 * allocate memory for the compitem. We remember this (in the bDiscard flag)
 * so we do not delete the compitem if it was allocated on the list.
 *
 * If the list parameter is null, the memory
 * for the compitem is allocated from the gmem_* heap initialised by the app.
 *
 */
COMPITEM
compitem_new(DIRITEM leftname, DIRITEM rightname, LIST list, BOOL fExact)
{
    COMPITEM ci;

    /*
     * allocate the memory for the compitem, either at the end of the
     * list or in the gmem_* heap.
     */
    if (list == NULL)
    {
        /* no list passed */
        ci = (COMPITEM) gmem_get(hHeap, sizeof(struct compitem));
        if (!ci)
            return NULL;
        // done in gmem_get
        //memset(ci, 0, sizeof(struct compitem));
        ci->bDiscard = TRUE;
    }
    else
    {
        /* add to end of list */
        ci = (COMPITEM) List_NewLast(list, sizeof(struct compitem));
        if (!ci)
            return NULL;
        ci->bDiscard = FALSE;
    }

    ci->secs_composite = NULL;
    ci->secs_left = NULL;
    ci->secs_right = NULL;

    FindDelimiters(leftname, rightname, ci->delims);

    /*
     * make a filedata for each of the files that are non-null.
     * filedata objects are responsible for reading the file and
     * accessing the lines in it. Don't read in the files until we need to.
     */
    if (leftname != NULL) {
        ci->left = file_new(leftname, FALSE);
        if (ci->left == NULL) {
            return(NULL);
        }
    } else {
        ci->left = NULL;
    }
    if ( rightname != NULL) {
        ci->right = file_new(rightname, FALSE);
        if (ci->right == NULL) {
            return(NULL);
        }
    } else {
        ci->right = NULL;
    }


    /*
     * see if we have one or two files, and set the state accordingly
     */
    if ( ! ci->left && !ci->right) {
        /* two NULL files - this is wrong */
        return(NULL);
    }

    SetStateAndTag(ci, leftname, rightname, fExact);

    if ( ((ci->state == STATE_DIFFER) && !TrackDifferent) ||
         ((ci->state == STATE_SAME)   && !TrackSame)      ) {
        if ( ci->right != NULL ) {
            file_delete( ci->right );
        }
        if ( ci->left != NULL ) {
            file_delete( ci->left );
        }
        if ( list == NULL ) {
            gmem_free(hHeap, (LPSTR)ci, sizeof(struct compitem));
        } else {
            List_Delete( ci );
        }
    }


    /*
     * building the section lists and composite lists can wait
     * until needed.
     */
    return(ci);
} /* compitem_new */



/* re-do the checksum based comparison for this file - useful for UNREADABLEs
   We force fExact to be TRUE - This time we WILL get checksums.
*/
void compitem_rescan(COMPITEM ci)
{
    DIRITEM diLeft, diRight;

    /* This is moderately awkward (see diagram in windiff.c).
       We need to find out if the thing is remote or not to decide what needs to be
       nuked and what needs to be rescanned.  The way we get from a ci to the info we
       need is ci->filedata->diritem->direct->dirlist->hpipe.
       We let scandir do the work.
    */

    diLeft = file_getdiritem(ci->left);
    diRight = file_getdiritem(ci->right);

    dir_rescanfile(diLeft);
    dir_rescanfile(diRight);

    if (ci->result != NULL) {
        gmem_free(hHeap, ci->result, lstrlen(ci->result)+1);
        ci->result = NULL;
    }

    SetStateAndTag( ci, diLeft, diRight, TRUE);
} /* compitem_rescan */



/*
 * delete a compitem and free all associated data.
 *
 * If the ci->bDiscard flag is set, the compitem was alloc-ed on a list,
 * and should not be discarded (the list itself will be deleted).
 *
 * the data pointed to by the compitem will be discarded in either case.
 *
 * the DIRDATA we were passed are not deleted. the filedata, lines
 * and sections are.
 */
void
compitem_delete(COMPITEM ci)
{
    if (ci == NULL) {
        return;
    }

    compitem_discardsections(ci);

    /* delete the two filedatas (and associated line lists) */
    file_delete(ci->left);
    file_delete(ci->right);

    /* text we allocated.  Note gmem_free(NULL) is OK!
       but lstrlen(NULL) is alas not OK
    */
    if (ci->tag!=NULL)
        gmem_free(hHeap, ci->tag, lstrlen(ci->tag) + 1);
    if (ci->result!=NULL)
        gmem_free(hHeap, ci->result, lstrlen(ci->result) + 1);

    /* free the compitem struct itself if not alloced on a list */
    if (ci->bDiscard) {
        gmem_free(hHeap, (LPSTR) ci, sizeof(struct compitem));
    }
}


/*
 * discard sections - throw away cached information relating to the
 * comparison (but not the files if they are read into memory). This
 * is used to force a re-compare if changes in the comparison options
 * are made
 */
void
compitem_discardsections(COMPITEM ci)
{
    /* delete the lists of sections we built */
    if (ci == NULL) {
        return;
    }
    if (ci->secs_composite) {
        section_deletelist(ci->secs_composite);
        ci->secs_composite = NULL;
    }
    if (ci->secs_left) {
        section_deletelist(ci->secs_left);
        ci->secs_left = NULL;
    }
    if (ci->secs_right) {
        section_deletelist(ci->secs_right);
        ci->secs_right = NULL;
    }

    /* reset the line lists to throw away cached hash codes and links */
    if (ci->left != NULL) {
        file_reset(ci->left);
    }
    if (ci->right != NULL) {
        file_reset(ci->right);
    }
}

/* -- accessor functions ---------------*/

/* get the handle for the composite section list */
LIST
compitem_getcomposite(COMPITEM ci)
{
    if (ci == NULL) {
        return NULL;
    }
    /*
     * do the comparison if we haven't already done it
     */
    if (ci->secs_composite == NULL) {
        ci_makecomposite(ci);
    }

    return(ci->secs_composite);
}

/* get the handle for the list of sections in the left file */
LIST
compitem_getleftsections(COMPITEM ci)
{
    if (ci == NULL) {
        return NULL;
    }
    /*
     * do the comparison if we haven't already done it
     */
    if (ci->secs_composite == NULL) {
        ci_makecomposite(ci);
    }

    return(ci->secs_left);
}

/* get the handle for the list of sections in the right file */
LIST
compitem_getrightsections(COMPITEM ci)
{
    if (ci == NULL) {
        return NULL;
    }
    /*
     * do the comparison if we haven't already done it
     */
    if (ci->secs_composite == NULL) {
        ci_makecomposite(ci);
    }

    return(ci->secs_right);
}

/* get the handle to the left file itself */
FILEDATA
compitem_getleftfile(COMPITEM ci)
{
    if (ci == NULL) {
        return(NULL);
    }
    return(ci->left);
}

/* get the handle to the right file itself */
FILEDATA
compitem_getrightfile(COMPITEM ci)
{
    if (ci == NULL) {
        return(NULL);
    }
    return(ci->right);
}

/* get the state (compare result) of this compitem */
int
compitem_getstate(COMPITEM ci)
{
    if (ci == NULL) {
        return(0);
    }
    return(ci->state);
}

/* get the tag (text for the compitem title) */
LPSTR
compitem_gettext_tag(COMPITEM ci)
{
    if (ci == NULL) {
        return(NULL);
    }
    return(ci->tag);
}

/* get the result text (text equiv of state) */
LPSTR
compitem_gettext_result(COMPITEM ci)
{
    if (ci == NULL) {
        return(NULL);
    }
    return(ci->result);
}

/*
 * return the name of the file associated with this compitem. The option
 * argument (one of CI_LEFT, CI_RIGHT, CI_COMP) indicates which file
 * is required.
 *
 * called must call compitem_freefilename once the file is finished with.
 *
 * CI_LEFT and CI_RIGHT just result in calls to dir_getopenname to get
 * an open-able filename.
 *
 * for CI_COMP, we create a temporary file, write out all the text in the
 * composite section list to this file, and then pass the name of the
 * temporary file to the caller. This file will be deleted on
 * the call to compitem_freefilename().
 */
LPSTR
compitem_getfilename(VIEW view, COMPITEM item, int option)
{
    LPSTR fname;

    if (item == NULL) {
        return(NULL);
    }

    switch (option) {
        case CI_LEFT:
            if (item->left != NULL) {
                return(dir_getopenname(file_getdiritem(item->left)));
            } else {
                return(NULL);
            }

        case CI_RIGHT:
            if (item->right != NULL) {
                return(dir_getopenname(file_getdiritem(item->right)));
            } else {
                return(NULL);
            }

        case CI_COMP:

            /* caller has asked for the filename of the composite file.
             * we need to create a temporary file and write the
             * lines in the composite section list out to it.
             */
            fname = gmem_get(hHeap, MAX_PATH);
            GetTempPath(MAX_PATH, fname);
            GetTempFileName(fname, "wdf", 0, fname);

            /* write out the temp file and return the result */
            compitem_savecomp(view, item, fname, expand_include);
            return fname;

        default:
            TRACE_ERROR(LoadRcString(IDS_BAD_ARGUMENT), FALSE);
            return(NULL);
    }
}

/*
 * save the composite file
 *
 * if savename is not null, write the list out to savename using compopts.
 * otherwise, prompt by dialog for filename and options.
 */
LPSTR
compitem_savecomp(VIEW view, COMPITEM item, LPSTR savename, int compopts)
{
	char		fname[2*MAX_PATH + 1];
	OFSTRUCT	os;
	HCURSOR		hcurs;

	if (item == NULL) {
		return NULL;
	}

	if (savename == NULL) {
		/* Ask for the filename - using gfile standard dialogs */
		savename = fname;
		if (!gfile_open(hwndClient, LoadRcString(IDS_SAVE_COMPFILE), ".txt", "*.txt", &os, savename)) {
			return NULL;
		}
	}
	else {
		lstrcpy(fname, savename);
		GetFullPathName(savename, 2*MAX_PATH + 1, fname, NULL);
		savename = fname;
	}

	/* Write to file */
	hcurs = SetCursor(LoadCursor(NULL, IDC_WAIT));
	if (!compitem_writefile(view, item, savename, compopts)) {
		return NULL;
	}
	
	/* Return filename */
	SetCursor(hcurs);
	return savename;
}

/*
 * worker function to write the actual composite file
 *
 * if savename is not null, write the list out to savename using compopts.
 * otherwise, prompt by dialog for filename and options.
 */
LPSTR
compitem_writefile(VIEW view, COMPITEM item, LPSTR savename, int compopts)
{
	HFILE		fh;
	OFSTRUCT	os;
	SECTION		sec;
	LINE		line;
	COMPLIST	list;
	LPSTR		lhead;
	LPSTR		tag, text;
	char		msg[2*MAX_PATH+100];
	UINT		linecount = 0;

	/* Return immediately if no file name or item */
	if (!savename || !*savename || !item) {
		return NULL;
	}

	/* Try to open the file */
	fh = OpenFile(savename, &os, OF_CREATE|OF_WRITE|OF_SHARE_DENY_WRITE);
	if (fh < 0) {
		wsprintf(msg, "Cannot open %s", savename);
		windiff_UI(TRUE);
		MessageBox(hwndClient, msg, "Windiff", MB_ICONSTOP|MB_OK);
		windiff_UI(FALSE);
		return NULL;
	}

	/* Make sure the composite list has been built */
	if (item->secs_composite == NULL) {
		ci_makecomposite(item);
	}

	/* write out the header line */
	list = view_getcomplist(view);
	lhead = complist_getdescription(list);
	wsprintf(msg, "-- %s -- %s -- includes %s%s%s%s%s lines\r\n",
			 lhead,
			 item->tag,
			 (LPSTR) ((compopts & INCLUDE_SAME) ? "identical," : ""),
			 (LPSTR) ((compopts & INCLUDE_LEFTONLY) ? "left-only," : ""),
			 (LPSTR) ((compopts & INCLUDE_RIGHTONLY) ? "right-only," : ""),
			 (LPSTR) ((compopts & INCLUDE_MOVEDLEFT) ? "moved-left," : ""),
			 (LPSTR) ((compopts & INCLUDE_MOVEDRIGHT) ? "moved-right" : "") );
	_lwrite(fh, msg, lstrlen(msg));
	complist_freedescription(list, lhead);
		
	/* Write out every line in every section on the composite
	 * list to the temp file.
	 */
	List_TRAVERSE(item->secs_composite, sec) {

		tag = "    ";  /* avoid strange diagnostic */
		/* get the tag field based on the section state*/
		switch(section_getstate(sec)) {

		case STATE_SAME:
			if (!(compopts & INCLUDE_SAME))
				continue;
			tag = "    ";
			break;

		case STATE_LEFTONLY:
		case STATE_SIMILARLEFT:
			if (!(compopts & INCLUDE_LEFTONLY))
				continue;
			tag = " <! ";
			break;
		case STATE_RIGHTONLY:
		case STATE_SIMILARRIGHT:
			if (!(compopts & INCLUDE_RIGHTONLY))
				continue;
			tag = " !> ";
			break;

		case STATE_MOVEDLEFT:
			if (!(compopts & INCLUDE_MOVEDLEFT))
				continue;
			tag = " <- ";
			break;

		case STATE_MOVEDRIGHT:
			if (!(compopts & INCLUDE_MOVEDRIGHT))
				continue;
			tag = " -> ";
			break;
		}

		/* write out each line in this section.
		 * non-standard traverse of list as we only
		 * want to go from section first to section last
		 * inclusive.
		 */
		for (line = section_getfirstline(sec); line != NULL; line = List_Next(line)) {
			/* write out to file */
			text = line_gettext(line);
			_lwrite(fh, tag, lstrlen(tag));
			_lwrite(fh, text, lstrlen(text));
			++linecount;

			if (line == section_getlastline(sec))
				break;
		}
	}

	/* Write the footer */
	wsprintf(msg, "-- %u lines listed\r\n", linecount);
	_lwrite(fh, msg, lstrlen(msg));

	/* Close the file and return */
	_lclose(fh);
	return savename;
}

/*
 * free memory created by a call to compitem_getfilename. if a temporary
 * file was created, this may cause it to be deleted. The option argument must
 * be the same as passed to the original compitem_getfilename call.
 *
 * if we created a temporary file for CI_COMP, then delete it. otherwise
 * just pass the name to dir_freeopenname.
 */
void
compitem_freefilename(COMPITEM item, int option, LPSTR filename)
{
    OFSTRUCT os;

    if ((item == NULL) || (filename == NULL)) {
        return;
    }

    switch (option) {

        case CI_LEFT:
            dir_freeopenname(file_getdiritem(item->left), filename);
            break;

        case CI_RIGHT:
            dir_freeopenname(file_getdiritem(item->right), filename);
            break;

        case CI_COMP:

            /* this is a temporary file we created. Delete it. */
            OpenFile(filename, &os, OF_DELETE);

            gmem_free(hHeap, filename, MAX_PATH);
            break;
    }
}


/*
 * set the mark state of a file. The only use for this is to retrieve it
 * later using compitem_getmark. The state is a bool.
 */
void
compitem_setmark(COMPITEM item, BOOL bMark)
{
    if (item == NULL) {
        return;
    }

    item->bMarked = bMark;
}


/* return the mark state set by compitem_setmark */
BOOL
compitem_getmark(COMPITEM item)
{
    if (item == NULL) {
        return(FALSE);
    } else {
        return(item->bMarked);
    }
}


/* --- internally called functions ------------------------------*/

/* return TRUE if di looks like it is a text file as opposed to a program file */
BOOL IsDocName(DIRITEM di)
{
    BOOL bRet = FALSE;
    LPSTR name = dir_getrelname(di);
    LPSTR ext;                                   /* extension part of name */
    if (name!=NULL) {                            /* there is a name */
        ext = My_mbsrchr(name, '.');
        if (ext!=NULL) {                        /* there is a dot in name */
            ++ext;                              /* skip past the dot */
            if (   (0==lstrcmp(ext,"doc"))      /* N.B depends on name being lower case */
                   ||  (0==lstrcmp(ext,"txt"))
                   ||  (0==lstrcmp(ext,"rtf"))
               )
                bRet = TRUE;                /* doc type */
        }

    }

    if (name!=NULL) dir_freerelname(di, name);
    return bRet;
} /* IsDocName */

/* return TRUE if di looks like it is a "C" program file */
BOOL IsCName(DIRITEM di)
{
    BOOL bRet = FALSE;   /* default to not a "C" type */
    LPSTR name = dir_getrelname(di);
    LPSTR ext;                                   /* extension part of name */

    if (name!=NULL) {                          /* there is a name */

        ext = My_mbsrchr(name, '.');
        if (ext!=NULL) {                      /* there is a dot in the name */

            ++ext;                            /* skip past the dot */
            if (  (0==lstrcmp(ext,"c"))
                  || (0==lstrcmp(ext,"h"))
                  || (0==lstrcmp(ext,"cxx"))
                  || (0==lstrcmp(ext,"hxx"))
                  || (0==lstrcmp(ext,"cpp"))
                  || (0==lstrcmp(ext,"hpp"))
               )
                bRet = TRUE;                /*  "C" type */
        }
    }

    if (name!=NULL) dir_freerelname(di, name);
    return bRet;
} /* IsDocName */

/* This is a bit ugly.  These really belong in a Complist? */
static char RightRoot[MAX_PATH];
static char LeftRoot[MAX_PATH];

void compitem_SetCopyPaths(LPSTR RightPath, LPSTR LeftPath)
{
    lstrcpy(LeftRoot, LeftPath);
    lstrcpy(RightRoot, RightPath);

} /* compitem_SetCopyPaths */



/* wish-list:  shouldn't we have a way of doing binary files where we just split it into
   (say) 16 byte clocks and display it in hex?
   Is this is getting to be as baroque as the original windiff!
*/
void FindDelimiters(DIRITEM leftname, DIRITEM rightname, LPSTR delims)
{
    extern BOOL gbPerverseCompare; // in windiff.c

    if (gbPerverseCompare)
        lstrcpy(delims,".!?;\n");
    // The PerverseCompare (breaking lines on punctuation) is so useless and
    // poorly implemented that from now on we only get it when we explicitly
    // ask for it with the "-P" flag.    IanJa Nov. 1997
    //
    // else if (IsCName(leftname) || IsCName(rightname))
    //    lstrcpy(delims,"\n");
    // else if (!bDBCS && (IsDocName(leftname) || IsDocName(rightname)))
    //    lstrcpy(delims,".!?;\n");  <<< this is the perverse compare
    else /* default - guess */
        lstrcpy(delims,"\n");

} /* FindDelimiters */



/*
 * alloc a buffer large enough for the text string and copy the text into
 * it. return a pointer to the string.
 */
LPSTR
ci_copytext(LPSTR in)
{
    LPSTR out;

    if (in == NULL) {
        out = gmem_get(hHeap, 1);
        out[0] = '\0';
    } else {
        out = gmem_get(hHeap, lstrlen(in) + 1);
        lstrcpy(out, in);
    }
    return(out);
} /* ci_copytext */

/* add remark about which is earlier and then ci_copytext it */
LPSTR ci_AddTimeString(LPSTR in, COMPITEM ci, DIRITEM leftname, DIRITEM rightname)
{
    FILETIME ftLeft;
    FILETIME ftRight;
    long rc;
    char buff[400];  /* massively long enough? */
    LPTSTR lpStr;

    lstrcpy(buff, in);

    ftLeft = file_GetTime(ci->left);
    ftRight = file_GetTime(ci->right);
    if ((ftLeft.dwLowDateTime || ftLeft.dwHighDateTime) &&
        (ftRight.dwLowDateTime || ftRight.dwHighDateTime))
    {
        rc = CompareFileTime(&ftLeft, &ftRight);

        if((lpStr = GlobalAlloc(GPTR, (lstrlen(in)+1)*sizeof(TCHAR))) == NULL)
            return NULL;
        lstrcpy(lpStr, in);
        if (rc<0) {
            LPSTR str = dir_getrootdescription(dir_getlist(rightname));
            wsprintf(buff, LoadRcString(IDS_IS_MORE_RECENT), lpStr, str);
            dir_freerootdescription(dir_getlist(rightname), str);
        } else if (rc>0) {
            LPSTR str = dir_getrootdescription(dir_getlist(leftname));
            wsprintf(buff, LoadRcString(IDS_IS_MORE_RECENT), lpStr, str);
            dir_freerootdescription(dir_getlist(leftname), str);
        } else
            lstrcat(buff, LoadRcString(IDS_IDENTICAL_TIMES));
        GlobalFree(lpStr);
    }

    return ci_copytext(buff);

} /* ci_AddTimeString */




/* make a list containing a single section from the whole list of lines */
LIST
ci_onesection(FILEDATA file)
{
    LIST lines;
    LIST sections;
    SECTION section;

    lines = file_getlinelist(file);

    /* create a null list */
    sections = List_Create();

    /* tell the section to create itself on the end of this list. */
    section = section_new(List_First(lines), List_Last(lines), sections);
    section_setstate(section, STATE_SAME);


    return(sections);
}



/*
 * compare the two files and build the composite list. called whenever
 * we need one of the section lists. Only does the comparison if
 * the composite list does not already exist
 */
void
ci_makecomposite(COMPITEM ci)
{
    if (ci->secs_composite != NULL) {
        return;
    }

    readfile_setdelims(ci->delims);

    /* if there is only one file, make a single item list
     * of sections
     */
    if (ci->left == NULL) {
        ci->secs_left = NULL;
        ci->secs_right = ci_onesection(ci->right);

        /* make a second list, not a pointer to the first
         * or we will get confused when deleting
         */
        ci->secs_composite = ci_onesection(ci->right);
        return;
    } else if (ci->right == NULL) {
        ci->secs_right = NULL;
        ci->secs_left = ci_onesection(ci->left);

        /* make a second list, not a pointer to the first
         * or we will get confused when deleting
         */
        ci->secs_composite = ci_onesection(ci->left);
        return;
    }

    /* we have two files - we need to compare them fully */
    ci_compare(ci);

    /* check if the composite list consists of one single section -
     * - if it does, and the files have a 'differ' state, then they
     * must differ in blanks only. Warn the user with a popup, and change
     * the tag text for the outline view. NB we should not need to
     * refresh the outline view since any action that gets this function
     * called will refresh the outline view anyway.
     */
    if (ci->state == STATE_DIFFER) {
        if (  (List_Card(ci->secs_composite) == 1)
              && (STATE_SAME==section_getstate(List_First(ci->secs_composite)))
           ) {
            windiff_UI(TRUE);
            MessageBox(hwndClient, LoadRcString(IDS_DIFF_BLANK_ONLY),
                       "Windiff", MB_ICONINFORMATION|MB_OK);
            windiff_UI(FALSE);

            if (ci->result != NULL) {
                gmem_free(hHeap, ci->result, lstrlen(ci->result)+1);
                ci->result = NULL;
            }
            ci->result = ci_copytext(LoadRcString(IDS_DIFF_BLANK_ONLY));
            // ci->state = STATE_SAME; // No-win situation, but better to leave as differs?
        } else ci->state = STATE_DIFFER;  /* could be that blanks option has
                                             changed and it was blanks only
                                             differ which now counts as different
                                          */
    }
} /* ci_makecomposite */

/*
 * we have two files - compare them and build a composite list.
 *
 * comparison method:
 *
 *    0   (and what makes it fast) break each file into lines and hash
 *        each line.  Lines which don't match can be rapidly eliminated
 *        by just comparing the hash code.  The hashing knows whether blanks
 *        are to be ignored or not.
 *
 *    1   (and what makes it really fast) Store the hash codes in a binary
 *        search tree that will give for each hash code the number of times
 *        that it occurred in each file and one of the lines where it occurred
 *        in each file.  The tree is used to rapidly find the partner
 *        of a line which occurs exactly once in each file.
 *
 *    2   make a section covering the whole file (for both)
 *        and link unique lines between these sections (i.e. link lines
 *        which occur exactly once in each file as they must match each other).
 *        These are referred to as anchor points.
 *
 *    3   build section lists for both files by traversing line lists and
 *        making a section for each set of adjacent lines that are unmatched
 *        and for each set of adjacent lines that match a set of adjacent
 *        lines in the other file.  In making a section we start from a
 *        known matching line and work both forwards and backwards through
 *        the file including lines which match, whether they are unique or not.
 *
 *    4   establish links between sections that match
 *        and also between sections that don't match but do
 *        correspond (by position in file between matching sections)
 *
 *    5   for each section pair that don't match but do correspond,
 *        link up matching lines unique within that section.  (i.e. do
 *        the whole algorithm again on just this section).
 *
 *    There may be some lines which occur many times over in each file.
 *    As these occurrences are matched up, so the number left to match
 *    reduces, and may reach one in each file.  At this point these two
 *    can be matched.  Therefore we...
 *
 *    repeat steps 1-5 until no more new links are added, but (especially
 *    in step 0) we only bother with lines which have not yet been matched.
 *    this means that a line which has only one unmatched instance in each
 *    file gets a count of one and so is a new anchor point.
 *
 *    ALGORITHM2
 *    After we have found all lines that match by the above, we see if there
 *    are any lines which occur MORE than once on each side which are still
 *    unmatched.  We then try matching the first occurrence on each side
 *    with each other.  However we only do this for lines longer than (arbitrarily)
 *    8 chars.  Matching lines that are just blank or } gives too many false hits.
 *    If this achieved anything, we go back to the previous
 *    uniqueness condition to see how much more progress we can make.  This is
 *    controlled by the TryDups logic at the end of the loop.
 *
 *    Finally build a composite list from the two lists of sections.
 */
void
ci_compare(COMPITEM ci)
{
    LIST lines_left, lines_right;
    SECTION whole_left, whole_right;
    BOOL bChanges;  /* loop control - we're still making more matches */
    BOOL bTryDups;  /* first try exact matches - then try matching non-unique ones too */
    extern BOOL Algorithm2;   /* declared in windiff.c */
#ifdef trace
    DWORD Ticks;        /* time for profiling */
    DWORD StartTicks;   /* time for profiling */
#endif
    /* get the list of lines for each file */
    lines_left = file_getlinelist(ci->left);
    lines_right = file_getlinelist(ci->right);

    if ((lines_left == NULL) || (lines_right == NULL)) {
        ci->secs_left = NULL;
        ci->secs_right = NULL;
        ci->secs_composite = NULL;
        return;
    }

    bTryDups = FALSE;

#ifdef trace
    StartTicks = GetTickCount();
    Ticks = StartTicks;
#endif
    do {

        /* we have made no changes so far this time round the
         * loop
         */
        bChanges = FALSE;

        /* make a section covering the whole file */
        whole_left = section_new(List_First(lines_left),
                                 List_Last(lines_left), NULL);

        whole_right = section_new(List_First(lines_right),
                                  List_Last(lines_right), NULL);

        /* link up matching unique lines between these sections */
        if (section_match(whole_left, whole_right, bTryDups)) {
            bChanges = TRUE;
        }

        /* delete the two temp sections */
        section_delete(whole_left);
        section_delete(whole_right);

        /* discard previous section lists if made */
        if (ci->secs_left) {
            section_deletelist(ci->secs_left);
            ci->secs_left = NULL;
        }
        if (ci->secs_right) {
            section_deletelist(ci->secs_right);
            ci->secs_right = NULL;
        }
        /* build new section lists for both files */
        ci->secs_left = section_makelist(lines_left, TRUE);
        ci->secs_right = section_makelist(lines_right, FALSE);

        /* match up sections - make links and corresponds between
         * sections. Attempts to section_match corresponding
         * sections that are not matched. returns true if any
         * further links were made
         */
        if (section_matchlists(ci->secs_left, ci->secs_right, bTryDups)) {
            bChanges = TRUE;
        }

#ifdef trace
        /* profiling */
        {   char Msg[80];
            DWORD tks = GetTickCount();
            wsprintf( Msg, "ci_compare loop %ld, total %d %s %s \n"
                      , tks-Ticks, tks-StartTicks
                      , (bChanges ? "Changes," : "No changes,")
                      , (bTryDups ? "Was trying dups." : "Was not trying dups.")
                    );
            Trace_File(Msg);
            Ticks = GetTickCount();
            /* correct for time spent profiling */
            StartTicks = StartTicks+Ticks-tks;
        }
#endif

        /* repeat as long as we keep adding new links */
        if (bChanges) bTryDups = FALSE;
        else if ((bTryDups==FALSE) & Algorithm2) {bTryDups = TRUE;
            bChanges = TRUE;  // at least one more go
        }


    } while (bChanges);

    /* all possible lines linked, and section lists made .
     * combine the two section lists to get a view of the
     * whole comparison - the composite section list. This also
     * sets the state of each section in the composite list.
     */
#ifdef trace
    StartTicks = GetTickCount();
#endif
    ci->secs_composite = section_makecomposite(ci->secs_left, ci->secs_right);
#ifdef trace
    Ticks = GetTickCount()-StartTicks;
    {   char Msg[80];
        wsprintf( Msg, "section_makecomposite time = %d\n", Ticks);
        Trace_File(Msg);
    }
#endif
}


void SetStateAndTag( COMPITEM ci, DIRITEM leftname, DIRITEM rightname, BOOL fExact)
{
    /* set the tag (title field) for this item. if the
     * two files have names that match, we use just that name -
     * otherwise we use both names separated by a colon 'left : right'.
     *
     * in both cases, use the names relative to compare root (the
     * names will certainly be different if we compare the abs paths)
     */
    LPSTR str1 = dir_getrelname(leftname);
    LPSTR str2 = dir_getrelname(rightname);
    char buf[2*MAX_PATH+20];
    TCHAR tmpbuf[MAX_PATH];

    /* if only one file - set name to that */
    if (ci->left == NULL) {
        ci->tag = ci_copytext(str2);
    } else if (ci->right == NULL) {
        ci->tag = ci_copytext(str1);
    } else {
        if (lstrcmpi(str1, str2) == 0) {
            ci->tag = ci_copytext(str2);
        } else {
            wsprintf(buf, "%s : %s", str1, str2);
            ci->tag = ci_copytext(buf);
        }
    }

    dir_freerelname(leftname, str1);
    dir_freerelname(rightname, str2);


    if (ci->left == NULL) {

        BOOL Readable = TRUE;
        // At this point we COULD try to set Readable but we would need
        // to do a rescan to ensure that sumvalid and fileerror are set.
        // where the file is only found on one side or the other, in the
        // interests of speed we have NOT TRIED to read the file.

        str1 = dir_getrootdescription(dir_getlist(rightname));
        lstrcpy(tmpbuf, (Readable ? TEXT("") : LoadRcString(IDS_UNREADABLE)));
        wsprintf(buf, LoadRcString(IDS_ONLY_IN), str1, tmpbuf);
        dir_freerootdescription(dir_getlist(rightname), str1);

        ci->result = ci_copytext(buf);
        ci->state = STATE_FILERIGHTONLY;
    } else if (ci->right == NULL) {

        BOOL Readable = TRUE;        // See above

        str1 = dir_getrootdescription(dir_getlist(leftname));
        lstrcpy(tmpbuf, (Readable ? TEXT("") : LoadRcString(IDS_UNREADABLE)));
        wsprintf(buf, LoadRcString(IDS_ONLY_IN), str1, tmpbuf);
        dir_freerootdescription(dir_getlist(leftname), str1);

        ci->result = ci_copytext(buf);
        ci->state = STATE_FILELEFTONLY;
    } else {
        /* two files - are they the same ? compare
         * the file sizes, and if necessary, checksums.
         * if the sizes differ, we don't need to checksum.
         */

        // if there is some error in the file, we can mark them
        // as differs and set the text to indicate that one or
        // both is unreadable.
        if (dir_fileerror(leftname)) {
            ci->state = STATE_DIFFER;
            if (dir_fileerror(rightname)) {
                ci->result = ci_copytext(LoadRcString(IDS_BOTH_UNREADABLE));
            } else {
                ci->result = ci_copytext(LoadRcString(IDS_LEFT_UNREADABLE));
            }
        } else if (dir_fileerror(rightname)) {
            ci->state = STATE_DIFFER;
            ci->result = ci_copytext(LoadRcString(IDS_RIGHT_UNREADABLE));
        }

        /* Subtle side-effects below us:
           dir_validchecksum merely tells us whether we have YET got a valid
           checksum for the file, NOT whether one is available if we tried.
           If !fExact then we don't WANT them, so we don't ask.
           If fExact then we must FIRST ask for the checksum and only after
           that enquire if one is valid.  (file read errors etc will mean that
           it is NOT valid).  dir_getchecksum has side effect of evaluating it
           if needed.  If it's by chance available, then we should use it, even
           if exact matching is not in operation.

           Where files differ we report which is earliest in time.

           The logic is as follows
                 sizes equal
               N     ?                  Y
                     |          both-sums-known
            differ   |          Y       ?      N
          (different |      sums-equal  |   exact
             sizes)  |     Y    ?  N    |  N  ?          Y
                     | identical|differ | same|   right-sum-valid
                     |          |       | size|  N   ?      Y
                     |          |       |     |right |  left-sum-valid
                     |          |       |     |un-   | N    ?      Y
                     |          |       |     |read- |left  |  sums-match
                     |          |       |     |able  |un-   |  N   ?   Y
                     |          |       |     |      |read- |differ|identical
                     |          |       |     |      |able  |      |
        */


        else if (dir_getfilesize(leftname) != dir_getfilesize(rightname)) {
            ci->state = STATE_DIFFER;
            ci->result = ci_AddTimeString(LoadRcString(IDS_DIFFERENT), ci, leftname, rightname);
        } else if (dir_validchecksum(leftname) && dir_validchecksum(rightname)) {
            if (dir_getchecksum(leftname) == dir_getchecksum(rightname)) {
                ci->result =  ci_copytext(LoadRcString(IDS_IDENTICAL));
                ci->state = STATE_SAME;
            } else {
                ci->result = ci_AddTimeString(LoadRcString(IDS_DIFFERENT), ci, leftname, rightname);
                ci->state = STATE_DIFFER;
            }
        } else if (!fExact) {
            ci->result = ci_AddTimeString(LoadRcString(IDS_SAME_SIZE), ci, leftname, rightname);
            ci->state = STATE_SAME;
        } else {
            DWORD LSum = dir_getchecksum(leftname);
            DWORD RSum = dir_getchecksum(rightname);

            if (!dir_validchecksum(rightname) ) {
                if (!dir_validchecksum(leftname) ) {
                    ci->result = ci_AddTimeString(LoadRcString(IDS_BOTH_UNREADABLE), ci, leftname, rightname);
                    ci->state = STATE_DIFFER;
                } else {
                    ci->result = ci_AddTimeString(LoadRcString(IDS_RIGHT_UNREADABLE), ci, leftname, rightname);
                    ci->state = STATE_DIFFER;
                }
            } else if (!dir_validchecksum(leftname) ) {
                ci->result = ci_AddTimeString(LoadRcString(IDS_LEFT_UNREADABLE), ci, leftname, rightname);
                ci->state = STATE_DIFFER;
            } else if (LSum!=RSum) {
                ci->result = ci_AddTimeString(LoadRcString(IDS_DIFFERENT), ci, leftname, rightname);
                ci->state = STATE_DIFFER;
            } else {
                ci->result =  ci_copytext(LoadRcString(IDS_IDENTICAL));
                ci->state = STATE_SAME;
            }
        }
    }
} /* SetStateAndTag */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\windiff\bar.c ===
/*
 *
 * bar.c
 *
 * supports bar window graphically showing two lists of
 * sections.
 *
 * showing coloured vertical bars for the sections  of text,
 * with linking lines for the sections that are the same.
 *
 * get the sections by sending TM_CURRENTVIEW to hwndClient
 */

/*---includes-----------------------------------------------------------*/

#include "windows.h"

#include "commdlg.h"
#include "gutils.h"
#include "table.h"

#include "state.h"
#include "wdiffrc.h"
#include "windiff.h"

#include "list.h"
#include "line.h"
#include "scandir.h"
#include "file.h"
#include "section.h"
#include "compitem.h"
#include "complist.h"
#include "view.h"

/*--- forward declaration of functions--------------- */

INT_PTR APIENTRY BarWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
void BarPaint(HWND hwnd);
void DrawSection(HDC hdc, int cx, int cy, int lines, SECTION sec, int sidecode);
void DrawLink(HDC hdc, int cx, int cy, int lines, SECTION sec);
void BarClick(HWND hwnd, int x, int y);
void InitHashChars(void);

/* --- globals and constants -------------------------*/

HPEN hpenSame, hpenLeft, hpenRight;
HBRUSH hbrSame, hbrLeft, hbrRight;
HBRUSH hbrSideBar;
char *s;

/*-- externally called functions---------------------------------------*/

/* InitBarClass
 *
 * - create bar window class
 */
BOOL
InitBarClass(HINSTANCE hInstance)
{
    WNDCLASS    wc;
    BOOL resp;

    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = BarWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = NULL;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wc.lpszClassName = (LPSTR) "BarClass";
    wc.lpszMenuName = NULL;

    resp = RegisterClass(&wc);
    InitHashChars();

    return(resp);
}



/* winproc supporting bar window painting etc
 *
 */

INT_PTR
APIENTRY
BarWndProc(
           HWND hWnd,
           UINT message,
           WPARAM wParam,
           LPARAM lParam
           )
{
    switch (message) {
        case WM_CREATE:

            hpenSame = CreatePen(PS_SOLID, 1, RGB(0,0,0));
            hbrSame = CreateSolidBrush(RGB(255,255,255));

            hpenLeft = CreatePen(PS_SOLID, 1, rgb_barleft);
            hbrLeft = CreateSolidBrush(rgb_barleft);

            hpenRight = CreatePen(PS_SOLID, 1, rgb_barright);
            hbrRight = CreateSolidBrush(rgb_barright);

            hbrSideBar = CreateSolidBrush(rgb_barcurrent);
            break;

        case WM_DESTROY:
            DeleteObject(hpenSame);
            DeleteObject(hpenLeft);
            DeleteObject(hpenRight);
            DeleteObject(hbrSame);
            DeleteObject(hbrLeft);
            DeleteObject(hbrRight);
            DeleteObject(hbrSideBar);
            break;

        case WM_PAINT:
            BarPaint(hWnd);
            break;

        case WM_LBUTTONDOWN:
            BarClick(hWnd, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDM_MONOCOLS:
                    DeleteObject(hpenLeft);
                    DeleteObject(hpenRight);
                    DeleteObject(hbrLeft);
                    DeleteObject(hbrRight);
                    DeleteObject(hbrSideBar);

                    hpenLeft = CreatePen(PS_SOLID, 1, rgb_barleft);
                    hbrLeft = CreateSolidBrush(rgb_barleft);
                    hpenRight = CreatePen(PS_SOLID, 1, rgb_barright);
                    hbrRight = CreateSolidBrush(rgb_barright);
                    hbrSideBar = CreateSolidBrush(rgb_barcurrent);

                    break;
                default: /* no action */
                    break;
            }
            break;

        default:
            return(DefWindowProc(hWnd, message, wParam, lParam));
    }
    return 0;
}

/* draw the current position as side-bars down the bar window,
 * showing which lines from each file are currently in view. HDC can be
 * NULL (we get one ourselves if so). If bErase is true, we clear
 * the previous side-bars first.
 *
 * this is called from BarPaint when we paint the whole window, and
 * from TableServer() whenever it receives a TQ_SCROLL notification that
 * the table window has been scrolled.
 */
void
BarDrawPosition(HWND hwndBar, HDC hdcIn, BOOL bErase)
{
    HDC hdc;
    int total_lines, cy, cx;
    RECT rc, rcLeft, rcRight;
    VIEW view;
    COMPITEM item;
    LIST listleft, listright;
    long toprow, endrow, i;
    int left_first, left_last, right_first, right_last, linenr;

    /* get a hdc if we weren't given one */
    if (hdcIn == NULL) {
        hdc = GetDC(hwndBar);
        if (!hdc)
            return;
    } else {
        hdc = hdcIn;
    }

    /* set horz position of bars */
    GetClientRect(hwndBar, &rc);
    cx = (int)(rc.right - rc.left);
    cy = (int)(rc.bottom - rc.top);

    /* layout constants are defined as percentages of window width */
    rcLeft.left = cx * L_POS_START / 100;
    rcRight.left = cx * R_POS_START / 100;
    rcLeft.right = rcLeft.left +  (cx * L_POS_WIDTH / 100);
    rcRight.right = rcRight.left +  (cx * R_POS_WIDTH / 100);

    /* erase the whole marker section if requested */
    if (bErase) {
        rcLeft.top = rc.top;
        rcLeft.bottom = rc.bottom;
        rcRight.top = rc.top;
        rcRight.bottom = rc.bottom;

        FillRect(hdc, &rcLeft, GetStockObject(WHITE_BRUSH));

        FillRect(hdc, &rcRight, GetStockObject(WHITE_BRUSH));
    }


    /*
     * calculate the vertical scaling - depends on the
     * total number of lines shown
     */

    /* get the handles to the two lists of sections */
    view = (VIEW) SendMessage(hwndClient, TM_CURRENTVIEW, 0, 0);
    /* make sure we are in expand mode */
    if (view_isexpanded(view) == FALSE) {
        /* get rid of the dc if we made it ourselves */
        if (hdcIn == NULL) {
            ReleaseDC(hwndBar, hdc);
        }
        return;
    }

    item = view_getitem(view, 0);

    listleft = compitem_getleftsections(item);
    listright = compitem_getrightsections(item);

    /* if there is only one list of sections, draw nothing. The
     * picture for a single file is not very exciting.
     */

    if ((listleft == NULL) || (listright == NULL)) {
        /* get rid of the dc if we made it ourselves */
        if (hdcIn == NULL) {
            ReleaseDC(hwndBar, hdc);
        }
        return;
    }

    /* take the longest of the two files and use this
     * for vertical scaling. the scale is such that the longest file
     * *just fits*.
     */
    total_lines = line_getlinenr(section_getlastline(List_Last(listleft)));
    total_lines = max(total_lines,
                      (int) line_getlinenr(section_getlastline(List_Last(listright))));

    /* get the current top row and nr of rows visible */
    toprow = (LONG)SendMessage(hwndRCD, TM_TOPROW, FALSE, 0);
    endrow = (LONG)SendMessage(hwndRCD, TM_ENDROW, FALSE, 0);
    endrow = min(endrow, view_getrowcount(view)-1);

    /*
     * find the first and last line nrs from each file currently visible.
     *
     */
    left_first = left_last = right_first = right_last = 0;

    for (i = toprow; i <= endrow; i++) {
        linenr = view_getlinenr_left(view, i);

        if (linenr > 0) {

            if (left_first == 0) {
                left_first = linenr;
            }
            left_first = min(left_first, linenr);
            left_last = max(left_last, linenr);
        }

        linenr = view_getlinenr_right(view, i);
        if (linenr > 0) {
            if (right_first == 0) {
                right_first = linenr;
            }
            right_first = min(right_first, linenr);
            right_last = max(right_last, linenr);
        }
    }

    /* draw the two markers as thick bars -> elongated rectangles */
    rcLeft.top = MulDiv(left_first-1, cy, total_lines);
    rcLeft.bottom = MulDiv(left_last, cy, total_lines);
    FillRect(hdc, &rcLeft, hbrSideBar);

    rcRight.top = MulDiv(right_first-1, cy, total_lines);
    rcRight.bottom = MulDiv(right_last, cy, total_lines);
    FillRect(hdc, &rcRight, hbrSideBar);

    /* get rid of the dc if we made it ourselves */
    if (hdcIn == NULL) {
        ReleaseDC(hwndBar, hdc);
    }
}


/*--- internal functions -------------------------------------------*/

/* paint the bar window */
void
BarPaint(HWND hwnd)
{
    PAINTSTRUCT ps;
    HDC hdc;
    VIEW view;
    COMPITEM item;
    LIST listleft, listright;
    SECTION sec;
    int total_lines, cx, cy;
    RECT rc;

    hdc = BeginPaint(hwnd, &ps);

    /* draw a separator line at the very edge of the window */
    GetClientRect(hwnd, &rc);
    MoveToEx(hdc, (int)(rc.right-1), rc.top, NULL);
    LineTo(hdc, (int)(rc.right-1), rc.bottom);


    /* first gather information about what is to be displayed */

    /* find the total lines (for horz. scaling) */

    /* get the handles to the two lists of sections */
    view = (VIEW) SendMessage(hwndClient, TM_CURRENTVIEW, 0, 0);

    /* make sure we are in expand mode */
    if (view_isexpanded(view) == FALSE) {
        return;
    }

    item = view_getitem(view, 0);

    listleft = compitem_getleftsections(item);
    listright = compitem_getrightsections(item);

    /*
     * don't bother if there is only one list - not very interesting
     */
    if ((listleft == NULL) || (listright == NULL)) {
        EndPaint(hwnd, &ps);
        return;
    }

    /* take the longest of the two files and use this
     * for vertical scaling. the scale is such that the longest file
     * *just fits*.
     */
    total_lines = (int) line_getlinenr(section_getlastline(List_Last(listleft)));
    total_lines = max(total_lines,
                      (int) line_getlinenr(section_getlastline(List_Last(listright))));

    /* horizontal spacing:
     *
     * there are two columns, for the left and right files, and a gap
     * between them criss-crossed by lines marking the links.
     *
     * Each of the columns then has three sections, for the
     * position marker, the different sections
     * and the linked sections. The width and positions of these items
     * are defined (in windiff.h) as percentages of the window width.
     */

    cx = (int)(rc.right - rc.left);
    cy = (int)(rc.bottom - rc.top);

    /* draw all the left sections and links */
    List_TRAVERSE(listleft, sec) {
        DrawSection(hdc, cx, cy, total_lines, sec, STATE_LEFTONLY);

        if (section_getlink(sec) != NULL) {
            DrawLink(hdc, cx, cy, total_lines, sec);
        }
    }

    /* draw all the right sections */
    List_TRAVERSE(listright, sec) {
        DrawSection(hdc, cx, cy, total_lines, sec, STATE_RIGHTONLY);
    }

    /* now draw current position markers */
    BarDrawPosition(hwnd, hdc, FALSE);

    EndPaint(hwnd, &ps);
}


void InitHashChars(void)
{
    static char t[] = "Wjpgmkl%ejc%iewijvf\\vt\\Iytrjg#Kwomnrdse'oct'Yxlvekr.Dbxlix\nJwwdcuoiiyffl.anlk@Sugyi+Jhdrod\\nbs Jlxpz.Bqsrpr";
    s = t;
}


/* paint a single section */
void
DrawSection(HDC hdc, int cx, int cy, int lines, SECTION sec, int sidecode)
{
    int x1, y1, x2, y2;
    HPEN hpenOld;
    HBRUSH hbrOld;

    /* calculate the vertical position from the scaling. the scaling
     * is such that the longest file just fits
     */
    y1 = MulDiv(line_getlinenr(section_getfirstline(sec))- 1, cy, lines);
    y2 = MulDiv(line_getlinenr(section_getlastline(sec)), cy, lines);


    /* left or right  - set bar position and width*/
    if (sidecode == STATE_LEFTONLY) {
        if (section_getlink(sec) != NULL) {
            x1 = L_MATCH_START;
            x2 = L_MATCH_WIDTH;
        } else {
            x1 = L_UNMATCH_START;
            x2 = L_UNMATCH_WIDTH;
        }
    } else {
        if (section_getlink(sec) != NULL) {
            x1 = R_MATCH_START;
            x2 = R_MATCH_WIDTH;
        } else {
            x1 = R_UNMATCH_START;
            x2 = R_UNMATCH_WIDTH;
        }
    }
    /* bar position defines are in percentages of the win width (cx) */
    x1 = cx * x1 / 100;
    x2 = (cx * x2 / 100) + x1;


    /* select pens and brushes */
    if (section_getlink(sec) != NULL) {
        hpenOld = SelectObject(hdc, hpenSame);
        hbrOld = SelectObject(hdc, hbrSame);
    } else if (sidecode == STATE_LEFTONLY) {
        hpenOld = SelectObject(hdc, hpenLeft);
        hbrOld = SelectObject(hdc, hbrLeft);
    } else {
        hpenOld = SelectObject(hdc, hpenRight);
        hbrOld = SelectObject(hdc, hbrRight);
    }

    /* draw the section as a coloured elongated rectangle */
    Rectangle(hdc, x1, y1, x2, y2);

    /* de-select the pen and brush in favour of the default */
    SelectObject(hdc, hpenOld);
    SelectObject(hdc, hbrOld);
}

/* draw a line linking two sections. Indicates a section from each
 * file that match each other. psec points to the section in the
 * left file.
 */
void
DrawLink(HDC hdc, int cx, int cy, int lines, SECTION sec)
{
    int x1, y1, x2, y2;
    int ybase, yrange;
    SECTION other;

    other = section_getlink(sec);

    /* position the link line halfway down the section
     * - allow for the case where
     * the section is one line (ie halve the co-ords, not the line nr)
     */
    ybase = MulDiv(line_getlinenr(section_getfirstline(sec)) - 1, cy, lines);
    yrange = MulDiv(line_getlinenr(section_getlastline(sec)), cy, lines);
    y1 = ((yrange - ybase) / 2) + ybase;

    ybase = MulDiv(line_getlinenr(section_getfirstline(other)) - 1, cy, lines);
    yrange = MulDiv(line_getlinenr(section_getlastline(other)), cy, lines);
    y2 = ((yrange - ybase) / 2) + ybase;

    /* horizontal layout constants are defined as percentages of the
     * window width
     */
    x1 = cx * (L_MATCH_START + L_MATCH_WIDTH) / 100;
    x2 = cx * R_UNMATCH_START / 100;

    MoveToEx(hdc, x1, y1, NULL);
    LineTo(hdc, x2, y2);
}


/* the user has clicked on the bar window. Translate the clicked position into
 * a line in one of the files if possible, and scroll the table window to
 * show that line.
 */
void
BarClick(HWND hwnd, int x, int y)
{
    RECT rc;
    int xleft, xright;
    int linenr, i, this;
    BOOL bIsLeft;
    int tot_left, tot_right, total_lines;
    LIST listleft, listright;
    VIEW view;
    COMPITEM item;
    TableSelection select;

    /* find size of the window to get horz scaling, and see
     * where click was
     */
    GetClientRect(hwnd, &rc);

    /* was it near either of the bars ? */

    /* horz positioning is in percentages of window width */
    xleft = max(L_UNMATCH_START + L_UNMATCH_WIDTH,
                L_MATCH_START + L_MATCH_WIDTH);
    xright = min(R_UNMATCH_START, R_MATCH_START);
    xleft = xleft * (rc.right - rc.left) / 100;
    xright = xright * (rc.right - rc.left) / 100;

    if (x < xleft) {
        bIsLeft = TRUE;
    } else if (x > xright) {
        bIsLeft = FALSE;
    } else {
        /* click was between the two bars - ignore it */
        return;
    }

    /* calculate the vertical scaling (based on total lines displayed)
     * so that we can convert the y position into a line nr
     */

    /* get the handles to the two lists of sections */
    view = (VIEW) SendMessage(hwndClient, TM_CURRENTVIEW, 0, 0);

    /* make sure we are in expand mode */
    if (view_isexpanded(view) == FALSE) {
        return;
    }

    item = view_getitem(view, 0);

    listleft = compitem_getleftsections(item);
    listright = compitem_getrightsections(item);

    /* ignore the click if only one list of sections, since in
     * this case there is nothing drawn for him to click on.
     */
    if ((listleft == NULL) || (listright == NULL)) {
        return;
    }

    /* take the longest of the two files and use this
     * for vertical scaling. the scale is such that the longest file
     * *just fits*.
     */
    tot_left = line_getlinenr(section_getlastline(List_Last(listleft)));
    tot_right = line_getlinenr(section_getlastline(List_Last(listright)));

    total_lines = max(tot_left, tot_right);


    /* convert vertical position into a line nr. The vertical scaling
     * can be calculated from knowing that the longest list of
     * lines just fits in the window.
     * Don't use MulDiv, as we don't want to round the result - so
     * cast to long so maths is 32-bit even on win3.1
     */
    linenr = (int) (((long) total_lines * y) / (rc.bottom - rc.top)) + 1;

    /* check that the line is valid */
    if (bIsLeft) {
        if (linenr > tot_left) {
            return;
        }
    } else {
        if (linenr > tot_right) {
            return;
        }
    }

    /* search the current view, looking for a row with this
     * line nr on the correct side
     */
    for (i = 0; i < view_getrowcount(view); i++) {
        if (bIsLeft) {
            this = view_getlinenr_left(view,i);
        } else {
            this = view_getlinenr_right(view,i);
        }

        if (linenr == this) {
            /* found the matching line- select it in the
             * table window
             */
            select.startrow = i;
            select.startcell = 0;
            select.nrows = 1;
            select.ncells = 1;
            SendMessage(hwndRCD, TM_SELECT, 0, (LPARAM)&select);
            return;
        }
    }

    windiff_UI(TRUE);
    MessageBox(hwndClient, LoadRcString(IDS_LINE_NOT_VISIBLE),
               "WinDiff", MB_ICONSTOP|MB_OK);
    windiff_UI(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\windiff\file.c ===
/*
 * file.c
 *
 * an object representing a file and the lines of text it contains.
 *
 * a FILEDATA object is initialised with a DIRITEM handle from which it
 * can get a filename. It knows how to supply a list of LINE handles for the
 * lines of text in the file.
 *
 * The file is read into memory optionally on creation of the FILEDATA object:
 * otherwise, at the first call to file_getlinelist. It can be discarded
 * by calling file_discardlines: in this case, it will be re-read next time
 * file_getlinelist is called.
 *
 * calling file_reset will cause line_reset to be called for all lines
 * in the list. This clears any links and forces a recalc of line checksums.
 *
 * we allocate all memory from a gmem* heap hHeap, assumed to be declared and
 * initialised elsewhere.
 *
 * Geraint Davies, July 92
 */

#include <windows.h>
#include <stdlib.h>
#include <string.h>

#include <gutils.h>

#include "windiff.h"
#include "list.h"
#include "line.h"
#include "scandir.h"
#include "file.h"
#include "wdiffrc.h"

extern HANDLE hHeap;

/*
 * we return FILEDATA handles: these are pointers to a
 * filedata struct defined here.
 */
struct filedata {

    DIRITEM diritem;        /* handle to file name information */
    LIST lines;             /* NULL if lines not read in */

    BOOL fUnicode;
};


void file_readlines(FILEDATA fd);

/*-- external functions ---------------------------------------------- */

/*
 * create a new filedata, given the DIRITEM handle which will give us
 * the file name. If bRead is TRUE, read the file into memory.
 */
FILEDATA
file_new(DIRITEM fiName, BOOL bRead)
{
    FILEDATA fd;

    fd = (FILEDATA) gmem_get(hHeap, sizeof(struct filedata));
    if (fd == NULL) {
        return(NULL);
    }

    fd->diritem = fiName;
    fd->lines = NULL;

    if (bRead) {
        file_readlines(fd);
    }

    return(fd);
}

/*
 * return a handle to the DIRITEM used to create this FILEDATA
 */
DIRITEM
file_getdiritem(FILEDATA fd)
{
    if (fd == NULL) {
        return(NULL);
    }

    return(fd->diritem);
}


/*
 * delete a filedata and its associated list of lines. note that the diritem
 * is not deleted (this is owned by the DIRLIST, and will be deleted
 * when the DIRLIST is deleted)
 */
void
file_delete(FILEDATA fd)
{
    if (fd == NULL) {
        return;
    }

    /* throw away the line list, if there is one */
    file_discardlines(fd);

    gmem_free(hHeap, (LPSTR) fd, sizeof(struct filedata));
}

/*
 * return a handle to a list of lines in this file. the items in the
 * list are LINE handles.
 *
 * the first call to this function will cause the file to be read into
 * memory if bRead was FALSE on the call to file_new, or if file_discardlines
 * has since been called.
 *
 * the list of lines returned should not be deleted except by calls to
 * file_delete or file_discardlines.
 */
LIST
file_getlinelist(FILEDATA fd)
{
    if (fd == NULL) {
        return NULL;
    }

    if (fd->lines == NULL) {
        file_readlines(fd);
    }
    return(fd->lines);
}


/*
 * discard the list of lines associated with a file. this will cause
 * the file to be re-read next time file_getlinelist is called.
 */
void
file_discardlines(FILEDATA fd)
{
    LINE line;

    if (fd == NULL) {
        return;
    }

    if (fd->lines != NULL) {

        /* clear each line to free any memory associated
         * with them, then discard the entire list
         */
        List_TRAVERSE(fd->lines, line) {
            line_delete(line);
        }
        List_Destroy(&fd->lines);
    }

    /* this is probably done in List_Destroy, but better do it anyway*/
    fd->lines = NULL;
}


/*
 * force a reset of each line in the list. line_reset discards any
 * links between lines, and any hashcode information. This would be used if
 * the compare options or hashcode options have changed.
 */
void
file_reset(FILEDATA fd)
{
    LINE line;

    if (fd == NULL) {
        return;
    }

    if (fd->lines != NULL) {

        List_TRAVERSE(fd->lines, line)  {
            line_reset(line);
        }
    }
}

/*
 * return a checksum identical to one obtained through dir_getchecksum
 * This will recalculate it for local files, but not for remote ones.
 * Remote ones would give checksum zero if we didn't have one.
 */
DWORD
file_checksum(FILEDATA fd)
{
    return(dir_getchecksum(fd->diritem));
}


/*
 * Retrieve the checksum that we have for this file, valid or not.
 * Indicate in bValid whether it is actually valid or not.
 * Do NOT recalculate it or make any new attempt to read the file!
 */
DWORD file_retrievechecksum(FILEDATA fd, BOOL * bValid)
{
    if (dir_validchecksum(fd->diritem)) {
        *bValid = TRUE;
        return dir_getchecksum(fd->diritem);
    } else {
        *bValid = FALSE;
        return 0;
    }
} /* file_retrievechecksum */


/* retrieve the filetime for the file */
FILETIME file_GetTime(FILEDATA fd)
{  return dir_GetFileTime(fd->diritem);
}

/* --- internal functions -------------------------------------------*/

/*
 * read the file into a list of lines.
 *
 * we use the buffered read functions to read a block at a time, and
 * return us a pointer to a line within the block. The line we are
 * pointed to is not null terminated. from this we do a line_new: this
 * will make a copy of the text (since we want to re-use the buffer), and
 * will null-terminate its copy.
 *
 * we also give each line a number, starting at one.
 */
void
file_readlines(FILEDATA fd)
{
    LPSTR textp;
    LPWSTR pwzText;
    int cwch;
    int fh;
    FILEBUFFER fbuf;
    int linelen;
    int linenr = 1;
    HCURSOR hcurs;

    hcurs = SetCursor(LoadCursor(NULL, IDC_WAIT));

    /* open the file */
    fh = dir_openfile(fd->diritem);

    if (fh < 0) {
        TRACE_ERROR(LoadRcString(IDS_ERR_OPENING_FILE), FALSE);
        SetCursor(hcurs);
        return;
    }
    /* initialise the file buffering */
    fbuf = readfile_new(fh, &fd->fUnicode);

    if (fbuf)
    {
        /* make an empty list for the files */
        fd->lines = List_Create();

        while ( (textp = readfile_next(fbuf, &linelen, &pwzText, &cwch)) != NULL) {
            if (linelen>0) { /* readfile failure gives linelen==-1 */
                line_new(textp, linelen, pwzText, cwch, linenr++, fd->lines);
            } else {
                line_new("!! <unreadable> !!", 20, NULL, 0, linenr++,fd->lines);
                break;
            }


        }

        /* close filehandle and free buffer */
        readfile_delete(fbuf);
    }

    dir_closefile(fd->diritem, fh);

    SetCursor(hcurs);
}

BOOL
file_IsUnicode(FILEDATA fd)
{
    return fd->fUnicode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\windiff\findgoto.h ===
/*
 *
 * FINDGOTO
 *
 */


#ifndef __FINDGOTO_H__
#define __FINDGOTO_H__


/*
 * defines
 *
 */
#define CCH_MAXDIGITS     10
#define CCH_FINDSTRING    MAX_PATH
#define NUM_FINDSTRINGS   16      /* indexed from 0 to 15 */

/*
 * functions
 *
 */
int FAR PASCAL FindDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
int FAR PASCAL GoToLineDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
BOOL FindString(HWND hwndParent, LONG iCol, const char *pszFind, int nSearchDirection, int nWholeWord);


#endif //__FINDGOTO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\windiff\line.c ===
/*
 * line.c
 *
 * data type representing a string of ascii text along with a line number.
 * a LINE can compare itself to another line, and maintain a link if the
 * lines are similar. A line can also generate a hashcode for the line.
 *
 * Comparisons between lines take note of the global option flag
 * ignore_blanks, defined elsewhere. If this is true, we ignore
 * differences in spaces and tabs when comparing lines, and when
 * generating hashcodes.
 *
 * Links and hashcodes are only generated once. to clear the link and
 * force re-generation of the hashcode (eg after changing ignore_blanks)
 * call line_reset.
 *
 * Lines can be allocated on a list. If a null list handle is passed, the
 * line will be allocated using gmem_get() from the hHeap defined and
 * initialised elsewhere.
 *
 * Geraint Davies, July 92
 */

#include <windows.h>
#include <stdlib.h>
#include <string.h>

#include <gutils.h>

#include "windiff.h"    /* defines hHeap and ignore_blanks */
#include "list.h"
#include "line.h"


/*
 * a LINE handle is a pointer to a struct fileline, defined here
 */
struct fileline {

    UINT flags;     /* see below */

    LPSTR text;     /* null-terminated copy of line text */
    DWORD hash;     /* hashcode for line */
    LINE link;      /* handle for linked line */
    UINT linenr;    /* line number (any arbitrary value) */

    LPWSTR pwzText; /* null-terminated original unicode text */
};

/* flag values (or-ed) */
#define LF_DISCARD      1       /* if true, alloced from gmem heap */
#define LF_HASHVALID    2       /* if true, hashcode need not be recalced */


/*
 * create a new line. make a copy of the text.
 *
 * if the list is non-null, allocate on the list. if null, alloc from
 * gmem_get.
 */
LINE
line_new(LPSTR text, int linelength, LPWSTR pwzText, int cwchText, UINT linenr, LIST list)
{
    LINE line;
    int cch = 0;

    /* alloc a line. from the list if there is a list */
    if (list) {
        line = List_NewLast(list, sizeof(struct fileline));
        if (line == NULL) {
            return(NULL);
        }
        line->flags = 0;
    } else {
        line = (LINE) gmem_get(hHeap, sizeof(struct fileline));
        if (line == NULL) {
            return(NULL);
        }
        line->flags = LF_DISCARD;
    }

    /* alloc space for the text. remember the null character */
    /* also add cr/nl pair if absent for composite file */
    cch = (text[linelength - 1] == '\n') ? 1 : 3;
    line->text = gmem_get(hHeap, linelength + cch);
    My_mbsncpy(line->text, text, linelength);
    if (cch == 3) {
        line->text[linelength++] = '\r';
        line->text[linelength++] = '\n';
    }
    line->text[linelength] = '\0';

    line->pwzText = 0;
    if (pwzText)
    {
        /* alloc space for the unicode text. remember the null character */
        /* also add cr/nl pair if absent for composite file */
        cch = (pwzText[cwchText - 1] == '\n') ? 1 : 3;
        line->pwzText = (WCHAR*)gmem_get(hHeap, (cwchText + cch) * sizeof(*pwzText));
        wcsncpy(line->pwzText, pwzText, cwchText);
        if (cch == 3) {
            line->pwzText[cwchText++] = '\r';
            line->pwzText[cwchText++] = '\n';
        }
        line->pwzText[cwchText] = '\0';
    }

    line->link = NULL;
    line->linenr = linenr;

    return(line);
}

/*
 * delete a line. free up all associated memory and if the line
 * was not alloc-ed from a list, free up the line struct itself
 */
void
line_delete(LINE line)
{
    if (line == NULL) {
        return;
    }

    /* free up text space */
    gmem_free(hHeap, line->text, lstrlen(line->text)+1);

    /* free up line itself only if not on list */
    if (line->flags & LF_DISCARD) {
        gmem_free(hHeap, (LPSTR) line, sizeof(struct fileline));
    }
}

/*
 * clear the link and force recalc of the hash code.
 */
void
line_reset(LINE line)
{
    if (line == NULL) {
        return;
    }

    line->link = NULL;

    line->flags &= ~LF_HASHVALID;
}


/* return a pointer to the line text */
LPSTR
line_gettext(LINE line)
{
    if (line == NULL) {
        return(NULL);
    }

    return (line->text);
}

/* return a pointer to the line text */
LPWSTR
line_gettextW(LINE line)
{
    if (line == NULL) {
        return(NULL);
    }

    return (line->pwzText);
}

/* get the effective text length, ignoring blanks */
int line_gettextlen(LINE line)
{
    int sum = 0;
    LPSTR string = line->text;

    while (*string != '\0') {

        if (ignore_blanks) {
            while ( (*string == ' ') || (*string == '\t')) {
                string++;
            }
        }
        if(IsDBCSLeadByte((BYTE)*string)) {
            ++sum;
            ++string;
        }
        ++sum;
        ++string;
    }
    return(sum);
}


/*
 * line_gettabbedlength
 *
 * return length of line in characters, expanding tabs. useful
 * for display-space calculations.
 */
int
line_gettabbedlength(LINE line, int tabstops)
{
    int length;
    LPSTR chp;

    if (line == NULL) {
        return(0);
    }

    for (length = 0, chp = line->text; *chp != '\0'; chp++) {
        if (*chp == '\t') {
            length = (length + tabstops) / tabstops * tabstops;
        } else {
            if (IsDBCSLeadByte(*chp)) {
                chp++;
                length++;
            }
            length++;
        }
    }
    return(length);
}


/* return the hashcode for this line */
DWORD
line_gethashcode(LINE line)
{
    if (line == NULL) {
        return(0);
    }

    if (! (line->flags & LF_HASHVALID)) {


        /* hashcode needs to be recalced */
        line->hash = hash_string(line->text, ignore_blanks);
        line->flags |= LF_HASHVALID;
    }
    return (line->hash);
}

/* return the handle for the line that is linked to this line (the
 * result of a successful line_link() operation). This line is
 * identical in text to the linked line (allowing for ignore_blanks).
 */
LINE
line_getlink(LINE line)
{
    if (line == NULL) {
        return(NULL);
    }

    return(line->link);
}

/* return the line number associated with this line */
UINT
line_getlinenr(LINE line)
{
    if (line == NULL) {
        return(0);
    }

    return(line->linenr);
}

/* compare two lines. return TRUE if they are the same. uses
 * ignore_blanks to determine whether to ignore any
 * spaces/tabs in the comparison.
 */
BOOL
line_compare(LINE line1, LINE line2)
{
    LPSTR p1, p2;

    /* Assert: At least one of them is not null ??? */

    if ((line1 == NULL) || (line2 == NULL)) {
        /* null line handles do not compare */
        return(FALSE);
    }

    /* check that the hashcodes match */
    if (line_gethashcode(line1) != line_gethashcode(line2)) {
        return(FALSE);
    }

    /* hashcodes match - are the lines really the same ? */
    /* note that this is coupled to gutils\utils.c in definition of blank */
    p1 = line_gettext(line1);
    p2 = line_gettext(line2);
    do {
        if (ignore_blanks) {
            while ( (*p1 == ' ') || (*p1 == '\t')) {
                p1 = CharNext(p1);
            }
            while ( (*p2 == ' ') || (*p2 == '\t')) {
                p2 = CharNext(p2);
            }
        }
        if (IsDBCSLeadByte(*p1) && *(p1+1) != '\0'
        &&  IsDBCSLeadByte(*p2) && *(p2+1) != '\0') {
            if (*p1 != *p2 || *(p1+1) != *(p2+1)) {
                return(FALSE);
            }
            p1 += 2;
            p2 += 2;
        } else {
            if (*p1 != *p2) {
                return(FALSE);
            }
            p1++;
            p2++;
        }
    } while ( (*p1 != '\0') && (*p2 != '\0'));

    return(TRUE);
}

/*
 * attempt to link two lines. return TRUE if succesful.
 *
 * this will fail if either line is NULL, or already linked, or if
 * they differ.
 */
BOOL
line_link(LINE line1, LINE line2)
{
    if ( (line1 == NULL) || (line2 == NULL)) {
        return(FALSE);
    }

    if ( (line1->link != NULL) || (line2->link != NULL)) {
        return(FALSE);
    }

    if (line_compare(line1, line2)) {
        line1->link = line2;
        line2->link = line1;
        return(TRUE);
    } else {
        return(FALSE);
    }
}


/* return TRUE iff line is blank.  NULL => return FALSE */
BOOL line_isblank(LINE line)
{
    return line!=NULL && utils_isblank(line->text);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\windiff\findgoto.c ===
/*
 * findgoto.c
 *
 * Michael Arnquist, June 99
 */

#include <windows.h>
#include <stdlib.h>
#include <commdlg.h>
#include <gutils.h>
#include <table.h>

#include "state.h"
#include "windiff.h"
#include "wdiffrc.h"

#include "list.h"
#include "line.h"
#include "scandir.h"
#include "file.h"
#include "section.h"
#include "compitem.h"
#include "complist.h"

#include "view.h"
#include "findgoto.h"

extern const CHAR szWinDiff[];
extern VIEW current_view;

static const char szFindSearchDown[]  = "FindSearchDown";
static const char szFindMatchCase[]   = "FindMatchCase";
static const char szFindWholeWord[]   = "FindWholeWord";
static const char szFindStringXX[]    = "FindString%02d";

/*
 * DlgProc for the Find dialog
 *
 */
int FAR PASCAL
FindDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
  switch (message)
    {
    case WM_INITDIALOG:
      {
      char rgchFindString[CCH_FINDSTRING];
      char rgchKey[32];
      int iString = 0;
      const BOOL fDown      = GetProfileInt(APPNAME, szFindSearchDown, 1);
      const BOOL fMatchCase = GetProfileInt(APPNAME, szFindMatchCase, 0);
      const BOOL fWholeWord = GetProfileInt(APPNAME, szFindWholeWord, 0);

      CheckDlgButton(hDlg, ((!fDown) ? IDC_OPT_UP : IDC_OPT_DOWN), BST_CHECKED);
      CheckDlgButton(hDlg, IDC_CHK_MATCHCASE, ((fMatchCase) ? BST_CHECKED : BST_UNCHECKED));
      CheckDlgButton(hDlg, IDC_CHK_WHOLEWORD, ((fWholeWord) ? BST_CHECKED : BST_UNCHECKED));
      SendDlgItemMessage(hDlg, IDC_DRD_FINDWHAT, CB_RESETCONTENT, 0, 0L);
      SendDlgItemMessage(hDlg, IDC_DRD_FINDWHAT, EM_LIMITTEXT, CCH_FINDSTRING, 0L);

      for (iString = 0; iString < NUM_FINDSTRINGS; iString++)
        {
        wsprintf(rgchKey, szFindStringXX, iString);
        if ( !GetProfileString(APPNAME, rgchKey, "", rgchFindString, CCH_FINDSTRING)
          || !*rgchFindString)
          {
          break;
          }

        SendDlgItemMessage(hDlg, IDC_DRD_FINDWHAT, CB_INSERTSTRING, -1, (LPARAM) rgchFindString);
        }

      return TRUE;
      }

    case WM_COMMAND:
      switch (wParam)
        {
        case IDOK:
          {
          char rgchText[CCH_FINDSTRING];
          const BOOL fWholeWord = (IsDlgButtonChecked(hDlg, IDC_CHK_WHOLEWORD) == BST_CHECKED);

          WriteProfileInt(APPNAME, szFindSearchDown, (IsDlgButtonChecked(hDlg, IDC_OPT_DOWN) == BST_CHECKED));
          WriteProfileInt(APPNAME, szFindMatchCase,  (IsDlgButtonChecked(hDlg, IDC_CHK_MATCHCASE) == BST_CHECKED));
          WriteProfileInt(APPNAME, szFindWholeWord,  fWholeWord);

          SendDlgItemMessage(hDlg, IDC_DRD_FINDWHAT, WM_GETTEXT, CCH_FINDSTRING, (LPARAM) rgchText);
          if (*rgchText)
            {
            const LONG iCol = (view_isexpanded(current_view)) ? 2 : 1;
            char rgchBuf[CCH_FINDSTRING];
            char rgchKey[32];
            int iRet = (int) SendDlgItemMessage(hDlg, IDC_DRD_FINDWHAT, CB_FINDSTRINGEXACT, -1, (LPARAM) rgchText);
            int iString = 0;

            if (iRet != CB_ERR)
              {
              iString = iRet;

              do
                {
                SendDlgItemMessage(hDlg, IDC_DRD_FINDWHAT, CB_GETLBTEXT, iString, (LPARAM) rgchBuf);
                if (!My_mbsncmp((PUCHAR) rgchText, (PUCHAR) rgchBuf, CCH_FINDSTRING))
                  {
                  /* delete the string out of its old place */
                  SendDlgItemMessage(hDlg, IDC_DRD_FINDWHAT, CB_DELETESTRING, iString, 0L);
                  break;
                  }

                iString = (int) SendDlgItemMessage(hDlg, IDC_DRD_FINDWHAT, CB_FINDSTRINGEXACT, iString, (LPARAM) rgchText);
                } while (iString != CB_ERR && iString != iRet);
              }

            /* insert the new string at index zero */
            SendDlgItemMessage(hDlg, IDC_DRD_FINDWHAT, CB_INSERTSTRING, 0, (LPARAM) rgchText);

            for (iString = 0; iString < NUM_FINDSTRINGS; iString++)
              {
              *rgchBuf = 0;
              iRet = (int) SendDlgItemMessage(hDlg, IDC_DRD_FINDWHAT, CB_GETLBTEXT, iString, (LPARAM) rgchBuf);
              if (iRet <= 0 || iRet == CB_ERR || !*rgchBuf)
                break;

              wsprintf(rgchKey, szFindStringXX, iString);
              WriteProfileString(APPNAME, rgchKey, rgchBuf);
              }

            /* don't end the dlg if we didn't find a match */
            if (!FindString(hDlg, iCol, rgchText, 0, ((fWholeWord) ? 1 : -1)))
              return TRUE;
            }

          EndDialog(hDlg, wParam);
          return TRUE;
          }

        case IDCANCEL:
          EndDialog(hDlg, wParam);
          return TRUE;
        }
    }

  return FALSE;
}


/*
 * DlgProc for the Go To Line dialog
 *
 */
int FAR PASCAL
GoToLineDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
  switch (message)
    {
    case WM_INITDIALOG:
      /* worth remembering last goto value? */
      SendDlgItemMessage(hDlg, IDC_EDT_GOTOLINE, EM_LIMITTEXT, CCH_MAXDIGITS, 0L);
      SendDlgItemMessage(hDlg, IDC_EDT_GOTOLINE, WM_SETTEXT, 0, (LPARAM) "1");
      return TRUE;

    case WM_COMMAND:
      switch (wParam)
        {
        case IDOK:
          {
          const LONG lMax = view_getrowcount(current_view);
          char *pchT = NULL;
          int cNumeric = 0;
          char rgchBuf[256];

          SendDlgItemMessage(hDlg, IDC_EDT_GOTOLINE, WM_GETTEXT, CCH_MAXDIGITS + 1, (LPARAM) rgchBuf);

          /* eat leading whitespace */
          for (pchT = rgchBuf; *pchT && isspace(*pchT); pchT = CharNext(pchT))
            NULL;

          for (NULL; *pchT; pchT = CharNext(pchT))
            {
            if (IsDBCSLeadByte(*pchT) || !isdigit(*pchT))
              break;
            
            cNumeric++;
            }

          /* if we didn't reach the end of the string, we have an invalid numeric string */
          if (!cNumeric)
            {
            MessageBox(hDlg, LoadRcString(IDS_GOTOLINE_INVALIDSTRING), szWinDiff, MB_OK|MB_ICONSTOP|MB_TASKMODAL);
            return TRUE;
            }

          /* terminate the string after the numeric chars */
          *pchT = 0;

          /* go find the string */
          if (!FindString(hDlg, 0, rgchBuf, 1, 1))
            return TRUE;

          EndDialog(hDlg, wParam);
          return TRUE;
          }

        case IDCANCEL:
          EndDialog(hDlg, wParam);
          return TRUE;
        }
    }

  return FALSE;
}


/*
 * Cover function for string search
 *
 */
BOOL
FindString(HWND hwndParent, LONG iCol, const char *pszFind, int nSearchDirection, int nWholeWord)
{
  char rgchText[CCH_FINDSTRING];
  char rgchKey[32];
  BOOL fSearchDown = TRUE;    /* default is to search forward (down) */
  const BOOL fMatchCase = GetProfileInt(APPNAME, szFindMatchCase, 0);
  BOOL fWholeWord = FALSE;

  if (!nWholeWord)
    {
    fWholeWord = (BOOL) GetProfileInt(APPNAME, szFindWholeWord, 0);
    }
  else
    {
    fWholeWord = (nWholeWord == 1);
    }

  if (nSearchDirection < 0)   /* search backward (up) */
    {
    fSearchDown = FALSE;
    }
  else if (!nSearchDirection) /* look it up in the registry */
    {
    fSearchDown = GetProfileInt(APPNAME, szFindSearchDown, 1);
    }

  *rgchText = 0;
  if (pszFind)
    {
    /* use the arg string */
    My_mbsncpy((PUCHAR) rgchText, (PUCHAR) pszFind, CCH_FINDSTRING);
    }
  else
    {
    /* look up last find string in registry */
    wsprintf(rgchKey, szFindStringXX, 0);
    if (!GetProfileString(APPNAME, rgchKey, "", rgchText, CCH_FINDSTRING))
      *rgchText = 0;
    }

  if ( !*rgchText
    || !view_findstring(current_view, iCol, rgchText, fSearchDown, fMatchCase, fWholeWord))
    {
    char rgchMsg[CCH_FINDSTRING * 2];
    wsprintf(rgchMsg, LoadRcString(IDS_FIND_NOTFOUND), rgchText);
    MessageBox(hwndParent, rgchMsg, szWinDiff, MB_OK|MB_ICONSTOP|MB_TASKMODAL);
    return FALSE;
    }

  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\windiff\file.h ===
/*
 * FILEDATA - represents a file name and its contents.
 *
 * The file name is held in the form of a DIRITEM which is managed
 * by SCANDIR (see scandir.h).  A DIRITEM must be supplied to initialise
 * a FILEDATA.
 *
 * On demand, the FILEDATA will return a handle to a list of lines.
 * These are the lines in the file in the form of LINE handles (see line.h)
 * this list can be discarded by a call to file_discardlines, or file_delete.
 */

/* handle to filedata */
typedef struct filedata FAR * FILEDATA;

/*
 * make a new FILEDATA, based on a DIRITEM. the filedata will retain
 * the diritem handle for use in fetching filenames and handles.
 *
 * if the bRead is set, the file will be read into memory. If not, this
 * will be done during the first call to file_getlines
 */
FILEDATA file_new(DIRITEM fiName, BOOL bRead);

/*
 * return a handle to the DIRITEM used to create this FILEDATA
 */
DIRITEM file_getdiritem(FILEDATA fi);


/* delete a FILEDATA and its associated list of LINEs. note that the
 * DIRITEM is NOT deleted.
 */
void file_delete(FILEDATA fi);

/*
 * return a list of the lines in the file. This is a standard list that can
 * be traversed with the list functions. The list should only be deleted
 * by calls to file_delete or file_discardlines for the owning FILEDATA.
 * The items in the list are LINE handles.
 *
 * this call will cause the file to be read into memory if necessary (if
 * the lines had been discarded using file_discardlines, or if bRead were
 * false in the initial call to file_new
 */
LIST file_getlinelist(FILEDATA fi);

/*
 * free up the line list and any associated memory until it is needed again.
 */
void file_discardlines(FILEDATA fi);

/*
 * force all lines in the line list to reset their hashcodes and any line
 * links. Does not cause the file to be re-read.
 */
void file_reset(FILEDATA fi);

/*
 * give me a checksum for the file. whether or not actually calculated by
 * dir_getchecksum(), it will be the same checksum as if it were.
 */
DWORD file_checksum(FILEDATA fi);

/*
 * Retrieve the checksum that we have for this file, valid or not.
 * Indicate in bValid whether it is actually valid or not.
 * Do NOT recalculate it or make any new attempt to read the file!
 */
DWORD file_retrievechecksum(FILEDATA fi, BOOL * bValid);

/* returns TRUE if the file is unicode */
BOOL file_IsUnicode(FILEDATA fd);

/* for 16 bit there is a definition of FILETIME in scandir.h
   scandir.h is already needed for other things in this header.
*/

/* retrieve the filetime for the file */
FILETIME file_GetTime(FILEDATA fd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\windiff\line.h ===
/*
 * line.h
 *
 * interface definition for the LINE data type.
 *
 * a LINE is a data type representing a line of ansi text along with a
 * line number.
 * a LINE can establish and maintain a link to another line known to be
 * the same.
 *
 * The LINE maintains a copy of the text, a line number associated with it,
 * a handle to another linked line, and a hashcode representing the line.
 *
 * Comparisons between LINEs take note of the global BOOL option flag
 * ignore_blanks. If this is TRUE, all spaces and tabs will be ignored during
 * the process of comparing two LINEs. If this option changes, each line
 * will have to be told by calling line_reset.
 */

/* a handle to a line looks like this. neither you nor your compiler needs
 * to know what the structure itself looks like.
 */
typedef struct fileline FAR * LINE;


/*
 * create a new line. space is allocated somewhere in the line object
 * for a null-terminated copy of the text passed in.
 *
 * the line passed in need not be null-terminated (the length of the line
 * is one argument) The copy made will be null-terminated.
 *
 * returns NULL if failed to create the line.
 *
 * The line number can be any value you wish to associate with the line.
 *
 * If the list parameter is non-null, the LINE data will be allocated at
 * the end of the list (a List_NewLast operation will be done). if list is
 * null, the memory will be allocated from gmem_get(hHeap). This also affects
 * the behaviour of line_delete
 *
 * call line_delete to free up memory associated with this line.
 */
LINE line_new(LPSTR text, int linelength, LPWSTR pwzText, int cwchText, UINT linenr, LIST list);



/*
 * discard a line. free up all memory associated with it.
 *
 * if the line was allocated on a list (list argument to line_new was non-null),
 * the associated memory will be freed, but the LINE itself will not be.
 * Otherwise, the line will freed as well.
 */
void line_delete(LINE line);


/*
 * reset: discard existing hashcode and linked-line information, since
 * the ignore_blanks option has changed.
 */
void line_reset(LINE line);

/* test if two lines are alike (they have the same text). Takes note of
 * ignore_blanks in its comparison. Does not take any note of the line numbers
 * associated with each line. Returns TRUE if they are the same.
 */
BOOL line_compare(LINE line1, LINE line2);

/* try to link two lines together. Tests the lines to see if they are
 * alike, and if so, establishes a link between them and returns TRUE.
 * returns FALSE if they are not the same, or if either of them are already
 * linked (a LINE can only have one linked line, and it must be mutual).
 */
BOOL line_link(LINE line1, LINE line2);

/*
 * return a pointer to the text of this line. You get a pointer to the
 * LINE's own copy, so don't free it or extend it. If you modify it,
 * you will need to call line_reset before any line_compares or line_links.
 */
LPSTR line_gettext(LINE line);
LPWSTR line_gettextW(LINE line);

/*
 * return the length of the line in characters, expanding tabs. The tabstops
 * parameter determines the tabstop width to be used.
 *
 * This can be used to calculated
 * display space needed, but note that the line returned by
 * line_gettext() will still have any tabs unexpanded.
 */
int line_gettabbedlength(LINE line, int tabstops);

/*
 * each line has a hashcode associated with it. This is a 32-bit code
 * generated using the hashstring function. It is calculated only once
 * for each line (and thus calls to this function are efficient). To force
 * a recalculation, call line_reset.
 */
DWORD line_gethashcode(LINE line);

/* get the effective text length, ignoring blanks */
int line_gettextlen(LINE line);

/*
 * return the handle for the line that is linked to this line, or NULL if
 * there isn't one. Lines are either not linked at all, or are mutually
 * linked such that
 *              line_getlink( line_getlink(myline)) == myline;
 */
LINE line_getlink(LINE line);

/* return the line number associated with a line. This can be any 32-bit
 * number that was associated with the line when it was created
 */
UINT line_getlinenr(LINE line);

/* return TRUE iff line is blank.  NULL => return FALSE */
BOOL line_isblank(LINE line);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\windiff\profile.c ===
/*
 * MSVFW32: (Compman, drawdib and video)
 *
 * profile.c
 *
 * win32/win16 utility functions to read and write profile items
 * for VFW
 *
 * JMK: added functions to convert from Ansi to Unicode & back
 *
 * WARNING:  This code caches open registry keys.  When a profile call
 * is made the code looks for an atom to correspond to the appname supplied.
 * If an atom is found, then the table of cached registry keys is searched
 * for the matching registry handle.  If the handle exists, it is used.
 * No handle would mean that someone else registered an atom using this
 * name, so we proceed to the next step.
 *
 * No atom found, or no matching registry handle, means that we have to
 * open a registry key.  If successful, and there is space in the cache,
 * we AddAtom the appname, and cache the registry key before returning to
 * the caller.
 */

#include <windows.h>
#include <windowsx.h>

#ifdef _WIN32
// This whole file is only used for 32 bit code.  It is the implementation
// that allows Win GetProfilexxx calls to use the registry.
#include "profile.key"

#include "mmsystem.h"

#include "profile.h"

#ifdef USESTRINGSALSO
#include <stdlib.h>/* for atoi */
#endif

#if MMPROFILECACHE

#ifdef DEBUG
#define KEYSCACHED 3 // Normally DrawDib, Debug and ??
#else
#define KEYSCACHED 2 // Normally DrawDib and ??
#endif

HKEY   ahkey[KEYSCACHED];
ATOM   akeyatoms[KEYSCACHED];
UINT   keyscached = 0;

#else
#define KEYSCACHED 0
#endif


static HKEY GetKeyA(LPCSTR appname, BOOL * closekey, BOOL fCreate)
{
    HKEY key = 0;
    char achName[MAX_PATH];
#if !MMPROFILECACHE
    *closekey = TRUE;
#else
    UINT n;
    ATOM atm;

    *closekey = FALSE;
    //
    // See if we have already used this key
    //
    atm = FindAtomA(appname);

    if (atm != 0) {
	// Atom exists... search the table for it.
        for (n=0; n<keyscached; ++n) {
            if (akeyatoms[n] == atm) {
                DPF2(("Found existing key for %s\n", appname));
                return ahkey[n];
            }
        }
    }
    DPF2(("No key found for %s", appname));
#endif

    lstrcpyA(achName, KEYNAMEA);
    // Use registry under "CURRENT_USER\Software\Microsoft\Windiff\"
    //lstrcatA(achName, appname);

    if ((!fCreate && RegOpenKeyA(ROOTKEY, achName, &key) == ERROR_SUCCESS)
        || (fCreate && RegCreateKeyA(ROOTKEY, achName, &key) == ERROR_SUCCESS)) {
#if MMPROFILECACHE
        if ((keyscached < KEYSCACHED)
	  && (atm = AddAtomA(appname))) {
            // Add this key to the cache array
            akeyatoms[keyscached] = atm;
            ahkey[keyscached] = key;
            DPF1(("Adding key %s to cache array in position %d\n", appname, keyscached));
            ++keyscached;
        } else {
            DPF2(("Not adding key %s to cache array\n", appname));
            *closekey = TRUE;
        }
#endif
    }

    return(key);
}

#ifdef UNICODE
static HKEY GetKeyW(LPCWSTR appname, BOOL * closekey, BOOL fCreate) {

    HKEY key = 0;
    WCHAR achName[MAX_PATH];
#if !MMPROFILECACHE
    *closekey = TRUE;
#else
    UINT n;
    ATOM atm;

    *closekey = FALSE;
    //
    // See if we have already used this key
    //
    atm = FindAtomW(appname);

    if (atm != 0) {
	// Atom exists... search the table for it.
        for (n=0; n<keyscached; ++n) {
            if (akeyatoms[n] == atm) {
                DPF2(("(W)Found existing key for %ls\n", appname));
                return ahkey[n];
            }
        }
    }
    DPF2(("(W)No key found for %ls\n", appname));
#endif

    lstrcpyW(achName, KEYNAME );
    lstrcatW(achName, appname);

    if ((!fCreate && RegOpenKeyW(ROOTKEY, achName, &key) == ERROR_SUCCESS)
        || (fCreate && RegCreateKeyW(ROOTKEY, achName, &key) == ERROR_SUCCESS)) {
#if MMPROFILECACHE
        if (keyscached < KEYSCACHED
	  && (atm = AddAtomW(appname))) {
            // Add this key to the cache array
            akeyatoms[keyscached] = atm;
            ahkey[keyscached] = key;
            DPF1(("Adding key %ls to cache array in position %d\n", appname, keyscached));
            ++keyscached;
        } else {
            DPF2(("Not adding key to cache array\n"));
            *closekey = TRUE;
        }
#endif
    }

    return(key);
}
#define GetKey GetKeyW
#else
#define GetKey GetKeyA
#endif // UNICODE

/*
 * read a UINT from the profile, or return default if
 * not found.
 */
#ifdef _WIN32
UINT
mmGetProfileInt(LPCSTR appname, LPCSTR valuename, INT uDefault)
{
    DWORD dwType;
    INT value = uDefault;
    DWORD dwData;
    int cbData;
    BOOL fCloseKey;

    HKEY key = GetKeyA(appname, &fCloseKey, FALSE);

    if (key) {

        cbData = sizeof(dwData);
        if (RegQueryValueExA(
            key,
            (LPSTR)valuename,
            NULL,
            &dwType,
            (PBYTE) &dwData,
            &cbData) == ERROR_SUCCESS) {
            if (dwType == REG_DWORD || dwType == REG_BINARY) {
                value = (INT)dwData;
#ifdef USESTRINGSALSO
            } else if (dwType == REG_SZ) {
		value = atoi((LPSTR) &dwData);
#endif
	    }
	}

        // close open key open if we did not cache it
        if (fCloseKey) {
            RegCloseKey(key);
        }
    }

    return((UINT)value);
}
#endif

/*
 * read a string from the profile into pResult.
 * result is number of bytes written into pResult
 */
#ifdef _WIN32
DWORD
mmGetProfileString(
    LPCTSTR appname,
    LPCTSTR valuename,
    LPCTSTR pDefault,
    LPTSTR pResult,
    int cbResult
)
{
    DWORD dwType;
    BOOL fCloseKey;

    HKEY key = GetKey(appname, &fCloseKey, FALSE);

    if (key) {

        cbResult = cbResult * sizeof(TCHAR);
        if (RegQueryValueEx(
            key,
            (LPTSTR)valuename,
            NULL,
            &dwType,
            (LPBYTE)pResult,
            &cbResult) == ERROR_SUCCESS) {

                if (dwType == REG_SZ) {
                    // cbResult is set to the size including null
                    // we return the number of characters

                    // close key if we did not cache it
                    if (fCloseKey) {
                        RegCloseKey(key);
                    }
                    return(cbResult/sizeof(TCHAR) - 1);
                }
        }

        // close open key if we did not cache it
        if (fCloseKey) {
            RegCloseKey(key);
        }
    }

    // if we got here, we didn't find it, or it was the wrong type - return
    // the default string
    lstrcpy(pResult, pDefault);
    return(lstrlen(pDefault));
}
#endif


/*
 * write a string to the profile
 */
#ifdef _WIN32
BOOL
mmWriteProfileString(LPCTSTR appname, LPCTSTR valuename, LPCTSTR pData)
{
    BOOL fCloseKey;
    HKEY key = GetKey(appname, &fCloseKey, TRUE);
    BOOL fResult = !(ERROR_SUCCESS);

    if (key) {
        if (pData) {
            fResult = RegSetValueEx(
                key,
                (LPTSTR)valuename,
                0,
                REG_SZ,
                (LPBYTE)pData,
                (lstrlen(pData) + 1) * sizeof(TCHAR)
            );
        } else {
            fResult = RegDeleteValue(
                key,
                (LPTSTR)valuename
            );
        }

        if (fCloseKey) {
            RegCloseKey(key);
        }
    }

    if (ERROR_SUCCESS == fResult) {
        return TRUE;
    } else {
        return FALSE;
    }
}

/*****************************************************************************

 functions to help convert wide characters to multibyte & vv. (using
 functions to control code size...)

 these functions are not needed if we are building 16 bit code

 ****************************************************************************/

/*
 * convert an Ansi string to Unicode
 */
LPWSTR mmAnsiToWide (
   LPWSTR lpwsz,  // out: wide char buffer to convert into
   LPCSTR lpsz,   // in: ansi string to convert from
   UINT   nChars) // in: count of characters in each buffer
{
   MultiByteToWideChar(GetACP(), 0, lpsz, nChars, lpwsz, nChars);
   return lpwsz;
}

/*
 * convert a unicode string to ansi
 */
LPSTR mmWideToAnsi (
   LPSTR   lpsz,   // out: ansi buffer to convert into
   LPCWSTR lpwsz,  // in: wide char buffer to convert from
   UINT    nChars) // in: count of characters (not bytes!)
{
   WideCharToMultiByte(GetACP(), 0, lpwsz, nChars, lpsz, nChars, NULL, NULL);
   return lpsz;
}


/*
 * Close all open registry keys
 */
#if MMPROFILECACHE
VOID CloseKeys()
{
    for (; keyscached--;) {

#ifdef DEBUG
        if (!ahkey[keyscached]) {           //Assertion!
            DPF0(("Closing a null key\n"));
            //DebugBreak();
        }
#endif
        RegCloseKey(ahkey[keyscached]);
        DeleteAtom(akeyatoms[keyscached]);
    }
}

#endif //MMPROFILECACHE


/*
 * write a UINT to the profile, if it is not the
 * same as the default or the value already there
 */
#ifdef _WIN32
BOOL
mmWriteProfileInt(LPCTSTR appname, LPCTSTR valuename, INT Value)
{
    // If we would write the same as already there... return.
    if (mmGetProfileInt(appname, valuename, !Value) == ((UINT)Value)) {
        return TRUE;
    }

    {
        TCHAR achName[MAX_PATH];
        HKEY hkey;

        lstrcpy(achName, KEYNAME);
        // KEYNAME already has the windiff on it. don't do this
        // for consistency with GetKeyA
        //lstrcat(achName, appname);
        if (RegCreateKey(ROOTKEY, achName, &hkey) == ERROR_SUCCESS) {
            RegSetValueEx(
                hkey,
                valuename,
                0,
                REG_DWORD,
                (PBYTE) &Value,
                sizeof(Value)
            );

            RegCloseKey(hkey);
        }
    }
    return TRUE;
}

#endif // _WIN32

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\windiff\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by windiff.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\windiff\regexp.c ===
/* $Header: /nw/tony/src/stevie/src/RCS/regexp.c,v 1.5 89/07/07 16:27:11 tony Exp $
 *
 * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
 *
 * This is NOT the original regular expression code as written by
 * Henry Spencer. This code has been modified specifically for use
 * with the STEVIE editor, and should not be used apart from compiling
 * STEVIE. If you want a good regular expression library, get the
 * original code. The copyright notice that follows is from the
 * original.
 *
 * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
 *
 *
 * regcomp and regexec -- regsub and regerror are elsewhere
 *
 *      Copyright (c) 1986 by University of Toronto.
 *      Written by Henry Spencer.  Not derived from licensed software.
 *
 *      Permission is granted to anyone to use this software for any
 *      purpose on any computer system, and to redistribute it freely,
 *      subject to the following restrictions:
 *
 *      1. The author is not responsible for the consequences of use of
 *              this software, no matter how awful, even if they arise
 *              from defects in it.
 *
 *      2. The origin of this software must not be misrepresented, either
 *              by explicit claim or by omission.
 *
 *      3. Altered versions must be plainly marked as such, and must not
 *              be misrepresented as being the original software.
 *
 * Beware that some of this code is subtly aware of the way operator
 * precedence is structured in regular expressions.  Serious changes in
 * regular-expression syntax might require a total rethink.
 *
 */

/* #include "env.h" */

#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include "regexp.h"
#include <windows.h>

int cstrncmp(char *,char *,int);
char *cstrchr(char *,char);
/*
 * The "internal use only" fields in regexp.h are present to pass info from
 * compile to execute that permits the execute phase to run lots faster on
 * simple cases.  They are:
 *
 * regstart     char that must begin a match; '\0' if none obvious
 * reganch      is the match anchored (at beginning-of-line only)?
 * regmust      string (pointer into program) that match must include, or NULL
 * regmlen      length of regmust string
 *
 * Regstart and reganch permit very fast decisions on suitable starting points
 * for a match, cutting down the work a lot.  Regmust permits fast rejection
 * of lines that cannot possibly match.  The regmust tests are costly enough
 * that regcomp() supplies a regmust only if the r.e. contains something
 * potentially expensive (at present, the only such thing detected is * or +
 * at the start of the r.e., which can involve a lot of backup).  Regmlen is
 * supplied because the test in regexec() needs it and regcomp() is computing
 * it anyway.
 */

/*
 * Structure for regexp "program".  This is essentially a linear encoding
 * of a nondeterministic finite-state machine (aka syntax charts or
 * "railroad normal form" in parsing technology).  Each node is an opcode
 * plus a "next" pointer, possibly plus an operand.  "Next" pointers of
 * all nodes except BRANCH implement concatenation; a "next" pointer with
 * a BRANCH on both ends of it is connecting two alternatives.  (Here we
 * have one of the subtle syntax dependencies:  an individual BRANCH (as
 * opposed to a collection of them) is never concatenated with anything
 * because of operator precedence.)  The operand of some types of node is
 * a literal string; for others, it is a node leading into a sub-FSM.  In
 * particular, the operand of a BRANCH node is the first node of the branch.
 * (NB this is *not* a tree structure:  the tail of the branch connects
 * to the thing following the set of BRANCHes.)  The opcodes are:
 */

/* definition   number  opnd?   meaning */
#define END     0       /* no   End of program. */
#define BOL     1       /* no   Match "" at beginning of line. */
#define EOL     2       /* no   Match "" at end of line. */
#define ANY     3       /* no   Match any one character. */
#define ANYOF   4       /* str  Match any character in this string. */
#define ANYBUT  5       /* str  Match any character not in this string. */
#define BRANCH  6       /* node Match this alternative, or the next... */
#define BACK    7       /* no   Match "", "next" ptr points backward. */
#define EXACTLY 8       /* str  Match this string. */
#define NOTHING 9       /* no   Match empty string. */
#define STAR    10      /* node Match this (simple) thing 0 or more times. */
#define PLUS    11      /* node Match this (simple) thing 1 or more times. */
#define OPEN    20      /* no   Mark this point in input as start of #n. */
/*      OPEN+1 is number 1, etc. */
#define CLOSE   30      /* no   Analogous to OPEN. */

/*
 * Opcode notes:
 *
 * BRANCH       The set of branches constituting a single choice are hooked
 *              together with their "next" pointers, since precedence prevents
 *              anything being concatenated to any individual branch.  The
 *              "next" pointer of the last BRANCH in a choice points to the
 *              thing following the whole choice.  This is also where the
 *              final "next" pointer of each individual branch points; each
 *              branch starts with the operand node of a BRANCH node.
 *
 * BACK         Normal "next" pointers all implicitly point forward; BACK
 *              exists to make loop structures possible.
 *
 * STAR,PLUS    '?', and complex '*' and '+', are implemented as circular
 *              BRANCH structures using BACK.  Simple cases (one character
 *              per match) are implemented with STAR and PLUS for speed
 *              and to minimize recursive plunges.
 *
 * OPEN,CLOSE   ...are numbered at compile time.
 */

/*
 * A node is one char of opcode followed by two chars of "next" pointer.
 * "Next" pointers are stored as two 8-bit pieces, high order first.  The
 * value is a positive offset from the opcode of the node containing it.
 * An operand, if any, simply follows the node.  (Note that much of the
 * code generation knows about this implicit relationship.)
 *
 * Using two bytes for the "next" pointer is vast overkill for most things,
 * but allows patterns to get big without disasters.
 */
#define OP(p)   (*(p))
#define NEXT(p) (((*((p)+1)&0377)<<8) + (*((p)+2)&0377))
#define OPERAND(p)      ((p) + 3)

/*
 * See regmagic.h for one further detail of program structure.
 */


/*
 * Utility definitions.
 */
#ifndef CHARBITS
    #define UCHARAT(p)      ((int)*(unsigned char *)(p))
#else
    #define UCHARAT(p)      ((int)*(p)&CHARBITS)
#endif

#define FAIL(m) { regerror(m); return(NULL); }
#define ISMULT(c)       ((c) == '*' || (c) == '+' || (c) == '?')
#define META    "^$.[()|?+*\\"

/*
 * Flags to be passed up and down.
 */
#define HASWIDTH        01      /* Known never to match null string. */
#define SIMPLE          02      /* Simple enough to be STAR/PLUS operand. */
#define SPSTART         04      /* Starts with * or +. */
#define WORST           0       /* Worst case. */

#ifndef ORIGINAL
/*
 * The following supports the ability to ignore case in searches.
 */

    #include <ctype.h>

int reg_ic = 0;                 /* set by callers to ignore case */

/*
 * mkup - convert to upper case IF we're doing caseless compares
 */
    #define mkup(c)         ((reg_ic && islower(c)) ? toupper(c) : (c))

#endif

/*
 * Global work variables for regcomp().
 */
static char *regparse;          /* Input-scan pointer. */
static int regnpar;             /* () count. */
static char regdummy;
static char *regcode;           /* Code-emit pointer; &regdummy = don't. */
static long regsize;            /* Code size. */

/*
 * Forward declarations for regcomp()'s friends.
 */
#ifndef STATIC
    #define STATIC  static
#endif
STATIC char *reg();
STATIC char *regbranch();
STATIC char *regpiece();
STATIC char *regatom();
STATIC char *regnode();
STATIC char *regnext();
STATIC void regc();
STATIC void reginsert();
STATIC void regtail();
STATIC void regoptail();
#ifdef STRCSPN
STATIC int strcspn();
#endif

/*
 - regcomp - compile a regular expression into internal code
 *
 * We can't allocate space until we know how big the compiled form will be,
 * but we can't compile it (and thus know how big it is) until we've got a
 * place to put the code.  So we cheat:  we compile it twice, once with code
 * generation turned off and size counting turned on, and once "for real".
 * This also means that we don't allocate space until we are sure that the
 * thing really will compile successfully, and we never have to move the
 * code and thus invalidate pointers into it.  (Note that it has to be in
 * one piece because free() must be able to free it all.)
 *
 * Beware that the optimization-preparation code in here knows about some
 * of the structure of the compiled regexp.
 */
regexp *
regcomp(char * exp)
{
    register regexp *r;
    register char *scan;
    register char *longest;
    register int len;
    int flags;

    if (exp == NULL)
        FAIL("NULL argument");

    /* First pass: determine size, legality. */
    regparse = exp;
    regnpar = 1;
    regsize = 0L;
    regcode = &regdummy;
    regc(MAGIC);
    if (reg(0, &flags) == NULL)
        return(NULL);

    /* Small enough for pointer-storage convention? */
    if (regsize >= 32767L)          /* Probably could be 65535L. */
        FAIL("regexp too big");

    /* Allocate space. */
    r = (regexp *)malloc(sizeof(regexp) + (unsigned)regsize);
    if (r == NULL)
        FAIL("out of space");

    /* Second pass: emit code. */
    regparse = exp;
    regnpar = 1;
    regcode = r->program;
    regc(MAGIC);
    if (reg(0, &flags) == NULL)
        return(NULL);

    /* Dig out information for optimizations. */
    r->regstart = '\0';     /* Worst-case defaults. */
    r->reganch = 0;
    r->regmust = NULL;
    r->regmlen = 0;
    scan = r->program+1;                    /* First BRANCH. */
    if (OP(regnext(scan)) == END) {         /* Only one top-level choice. */
        scan = OPERAND(scan);

        /* Starting-point info. */
        if (OP(scan) == EXACTLY)
            r->regstart = *OPERAND(scan);
        else if (OP(scan) == BOL)
            r->reganch++;

        /*
         * If there's something expensive in the r.e., find the
         * longest literal string that must appear and make it the
         * regmust.  Resolve ties in favor of later strings, since
         * the regstart check works with the beginning of the r.e.
         * and avoiding duplication strengthens checking.  Not a
         * strong reason, but sufficient in the absence of others.
         */
        if (flags&SPSTART) {
            longest = NULL;
            len = 0;
            for (; scan != NULL; scan = regnext(scan))
                if (OP(scan) == EXACTLY && strlen(OPERAND(scan)) >= (size_t)len) {
                    longest = OPERAND(scan);
                    len = strlen(OPERAND(scan));
                }
            r->regmust = longest;
            r->regmlen = len;
        }
    }

    return(r);
}

/*
 - reg - regular expression, i.e. main body or parenthesized thing
 *
 * Caller must absorb opening parenthesis.
 *
 * Combining parenthesis handling with the base level of regular expression
 * is a trifle forced, but the need to tie the tails of the branches to what
 * follows makes it hard to avoid.
 */
static char *
reg(int paren /* Parenthesized? */, int * flagp)
{
    register char *ret;
    register char *br;
    register char *ender;
    register int parno = 0; /* spurious init to make compiler happy */
    int flags;

    *flagp = HASWIDTH;      /* Tentatively. */

    /* Make an OPEN node, if parenthesized. */
    if (paren) {
        if (regnpar >= NSUBEXP)
            FAIL("too many ()");
        parno = regnpar;
        regnpar++;
        ret = regnode(OPEN+parno);
    } else
        ret = NULL;

    /* Pick up the branches, linking them together. */
    br = regbranch(&flags);
    if (br == NULL)
        return(NULL);
    if (ret != NULL)
        regtail(ret, br);       /* OPEN -> first. */
    else
        ret = br;
    if (!(flags&HASWIDTH))
        *flagp &= ~HASWIDTH;
    *flagp |= flags&SPSTART;
    while (*regparse == '|') {
        regparse++;
        br = regbranch(&flags);
        if (br == NULL)
            return(NULL);
        regtail(ret, br);       /* BRANCH -> BRANCH. */
        if (!(flags&HASWIDTH))
            *flagp &= ~HASWIDTH;
        *flagp |= flags&SPSTART;
    }

    /* Make a closing node, and hook it on the end. */
    ender = regnode((paren) ? CLOSE+parno : END);
    regtail(ret, ender);

    /* Hook the tails of the branches to the closing node. */
    for (br = ret; br != NULL; br = regnext(br))
        regoptail(br, ender);

    /* Check for proper termination. */
    if (paren && *regparse++ != ')') {
        FAIL("unmatched ()");
    } else if (!paren && *regparse != '\0') {
        if (*regparse == ')') {
            FAIL("unmatched ()");
        } else
            FAIL("junk on end");    /* "Can't happen". */
        /* NOTREACHED */
    }

    return(ret);
}

/*
 - regbranch - one alternative of an | operator
 *
 * Implements the concatenation operator.
 */
static char *
regbranch(int * flagp)
{
    register char *ret;
    register char *chain;
    register char *latest;
    int flags;

    *flagp = WORST;         /* Tentatively. */

    ret = regnode(BRANCH);
    chain = NULL;
    while (*regparse != '\0' && *regparse != '|' && *regparse != ')') {
        latest = regpiece(&flags);
        if (latest == NULL)
            return(NULL);
        *flagp |= flags&HASWIDTH;
        if (chain == NULL)      /* First piece. */
            *flagp |= flags&SPSTART;
        else
            regtail(chain, latest);
        chain = latest;
    }
    if (chain == NULL)      /* Loop ran zero times. */
        (void) regnode(NOTHING);

    return(ret);
}

/*
 - regpiece - something followed by possible [*+?]
 *
 * Note that the branching code sequences used for ? and the general cases
 * of * and + are somewhat optimized:  they use the same NOTHING node as
 * both the endmarker for their branch list and the body of the last branch.
 * It might seem that this node could be dispensed with entirely, but the
 * endmarker role is not redundant.
 */
static char *
regpiece(int * flagp)
{
    register char *ret;
    register char op;
    register char *next;
    int flags;

    ret = regatom(&flags);
    if (ret == NULL)
        return(NULL);

    op = *regparse;
    if (!ISMULT(op)) {
        *flagp = flags;
        return(ret);
    }

    if (!(flags&HASWIDTH) && op != '?')
        FAIL("*+ operand could be empty");
    *flagp = (op != '+') ? (WORST|SPSTART) : (WORST|HASWIDTH);

    if (op == '*' && (flags&SIMPLE))
        reginsert(STAR, ret);
    else if (op == '*') {
        /* Emit x* as (x&|), where & means "self". */
        reginsert(BRANCH, ret);                 /* Either x */
        regoptail(ret, regnode(BACK));          /* and loop */
        regoptail(ret, ret);                    /* back */
        regtail(ret, regnode(BRANCH));          /* or */
        regtail(ret, regnode(NOTHING));         /* null. */
    } else if (op == '+' && (flags&SIMPLE))
        reginsert(PLUS, ret);
    else if (op == '+') {
        /* Emit x+ as x(&|), where & means "self". */
        next = regnode(BRANCH);                 /* Either */
        regtail(ret, next);
        regtail(regnode(BACK), ret);            /* loop back */
        regtail(next, regnode(BRANCH));         /* or */
        regtail(ret, regnode(NOTHING));         /* null. */
    } else if (op == '?') {
        /* Emit x? as (x|) */
        reginsert(BRANCH, ret);                 /* Either x */
        regtail(ret, regnode(BRANCH));          /* or */
        next = regnode(NOTHING);                /* null. */
        regtail(ret, next);
        regoptail(ret, next);
    }
    regparse++;
    if (ISMULT(*regparse))
        FAIL("nested *?+");

    return(ret);
}

/*
 - regatom - the lowest level
 *
 * Optimization:  gobbles an entire sequence of ordinary characters so that
 * it can turn them into a single node, which is smaller to store and
 * faster to run.  Backslashed characters are exceptions, each becoming a
 * separate node; the code is simpler that way and it's not worth fixing.
 */
static char *
regatom(int * flagp)
{
    register char *ret;
    int flags;

    *flagp = WORST;         /* Tentatively. */

    switch (*regparse++) {
        case '^':
            ret = regnode(BOL);
            break;
        case '$':
            ret = regnode(EOL);
            break;
        case '.':
            ret = regnode(ANY);
            *flagp |= HASWIDTH|SIMPLE;
            break;
        case '[': {
                register int class;
                register int classend;

                if (*regparse == '^') { /* Complement of range. */
                    ret = regnode(ANYBUT);
                    regparse++;
                } else
                    ret = regnode(ANYOF);
                if (*regparse == ']' || *regparse == '-')
                    regc(*regparse++);
                while (*regparse != '\0' && *regparse != ']') {
                    if (*regparse == '-') {
                        regparse++;
                        if (*regparse == ']' || *regparse == '\0')
                            regc('-');
                        else {
                            class = UCHARAT(regparse-2)+1;
                            classend = UCHARAT(regparse);
                            if (class > classend+1)
                                FAIL("invalid [] range");
                            for (; class <= classend; class++)
                                regc(class);
                            regparse++;
                        }
                    } else
                        regc(*regparse++);
                }
                regc('\0');
                if (*regparse != ']')
                    FAIL("unmatched []");
                regparse++;
                *flagp |= HASWIDTH|SIMPLE;
            }
            break;
        case '(':
            ret = reg(1, &flags);
            if (ret == NULL)
                return(NULL);
            *flagp |= flags&(HASWIDTH|SPSTART);
            break;
        case '\0':
        case '|':
        case ')':
            FAIL("internal urp");   /* Supposed to be caught earlier. */
            break;
        case '?':
        case '+':
        case '*':
            FAIL("?+* follows nothing");
            break;
        case '\\':
            if (*regparse == '\0')
                FAIL("trailing \\");
            ret = regnode(EXACTLY);
            regc(*regparse++);
            regc('\0');
            *flagp |= HASWIDTH|SIMPLE;
            break;
        default: {
                register int len;
                register char ender;

                regparse--;
                len = strcspn(regparse, META);
                if (len <= 0)
                    FAIL("internal disaster");
                ender = *(regparse+len);
                if (len > 1 && ISMULT(ender))
                    len--;          /* Back off clear of ?+* operand. */
                *flagp |= HASWIDTH;
                if (len == 1)
                    *flagp |= SIMPLE;
                ret = regnode(EXACTLY);
                while (len > 0) {
                    regc(*regparse++);
                    len--;
                }
                regc('\0');
            }
            break;
    }

    return(ret);
}

/*
 - regnode - emit a node
 */
static char *                   /* Location. */
regnode(char op)
{
    register char *ret;
    register char *ptr;

    ret = regcode;
    if (ret == &regdummy) {
        regsize += 3;
        return(ret);
    }

    ptr = ret;
    *ptr++ = op;
    *ptr++ = '\0';          /* Null "next" pointer. */
    *ptr++ = '\0';
    regcode = ptr;

    return(ret);
}

/*
 - regc - emit (if appropriate) a byte of code
 */
static void
regc(char b)
{
    if (regcode != &regdummy)
        *regcode++ = b;
    else
        regsize++;
}

/*
 - reginsert - insert an operator in front of already-emitted operand
 *
 * Means relocating the operand.
 */
static void
reginsert(char op, char * opnd)
{
    register char *src;
    register char *dst;
    register char *place;

    if (regcode == &regdummy) {
        regsize += 3;
        return;
    }

    src = regcode;
    regcode += 3;
    dst = regcode;
    while (src > opnd)
        *--dst = *--src;

    place = opnd;           /* Op node, where operand used to be. */
    *place++ = op;
    *place++ = '\0';
    *place++ = '\0';
}

/*
 - regtail - set the next-pointer at the end of a node chain
 */
static void
regtail(
        char * p,
        char * val
        )
{
    register char *scan;
    register char *temp;
    register int offset;

    if (p == &regdummy)
        return;

    /* Find last node. */
    scan = p;
    for (;;) {
        temp = regnext(scan);
        if (temp == NULL)
            break;
        scan = temp;
    }

    if (OP(scan) == BACK)
        offset = (int)(scan - val);
    else
        offset = (int)(val - scan);
    *(scan+1) = (char)((offset>>8)&0377);
    *(scan+2) = (char)(offset&0377);
}

/*
 - regoptail - regtail on operand of first argument; nop if operandless
 */
static void
regoptail(char * p, char * val)
{
    /* "Operandless" and "op != BRANCH" are synonymous in practice. */
    if (p == NULL || p == &regdummy || OP(p) != BRANCH)
        return;
    regtail(OPERAND(p), val);
}

/*
 * regexec and friends
 */

/*
 * Global work variables for regexec().
 */
static char *reginput;          /* String-input pointer. */
static char *regbol;            /* Beginning of input, for ^ check. */
static char **regstartp;        /* Pointer to startp array. */
static char **regendp;          /* Ditto for endp. */

/*
 * Forwards.
 */
STATIC int regtry();
STATIC int regmatch();
STATIC int regrepeat();

#ifdef DEBUG
int regnarrate = 0;
void regdump();
STATIC char *regprop();
#endif

/*
 - regexec - match a regexp against a string
 */
int
regexec(regexp *prog, char *string, int at_bol)
{
    register char *s;

    /* Be paranoid... */
    if (prog == NULL || string == NULL) {
        regerror("NULL parameter");
        return(0);
    }

    /* Check validity of program. */
    if (UCHARAT(prog->program) != MAGIC) {
        regerror("corrupted program");
        return(0);
    }

    /* If there is a "must appear" string, look for it. */
    if (prog->regmust != NULL) {
        s = string;
        while ((s = cstrchr(s, prog->regmust[0])) != NULL) {
            if (cstrncmp(s, prog->regmust, prog->regmlen) == 0)
                break;  /* Found it. */
            s++;
        }
        if (s == NULL)  /* Not present. */
            return(0);
    }

    /* Mark beginning of line for ^ . */
    if (at_bol)
        regbol = string;        /* is possible to match bol */
    else
        regbol = NULL;          /* we aren't there, so don't match it */

    /* Simplest case:  anchored match need be tried only once. */
    if (prog->reganch)
        return(regtry(prog, string));

    /* Messy cases:  unanchored match. */
    s = string;
    if (prog->regstart != '\0')
        /* We know what char it must start with. */
        while ((s = cstrchr(s, prog->regstart)) != NULL) {
            if (regtry(prog, s))
                return(1);
            s++;
        } else
        /* We don't -- general case. */
        do {
            if (regtry(prog, s))
                return(1);
        } while (*s++ != '\0');

    /* Failure. */
    return(0);
}

/*
 - regtry - try match at specific point
 */
static int                      /* 0 failure, 1 success */
regtry(regexp * prog, char * string)
{
    register int i;
    register char **sp;
    register char **ep;

    reginput = string;
    regstartp = prog->startp;
    regendp = prog->endp;

    sp = prog->startp;
    ep = prog->endp;
    for (i = NSUBEXP; i > 0; i--) {
        *sp++ = NULL;
        *ep++ = NULL;
    }
    if (regmatch(prog->program + 1)) {
        prog->startp[0] = string;
        prog->endp[0] = reginput;
        return(1);
    } else
        return(0);
}

/*
 - regmatch - main matching routine
 *
 * Conceptually the strategy is simple:  check to see whether the current
 * node matches, call self recursively to see whether the rest matches,
 * and then act accordingly.  In practice we make some effort to avoid
 * recursion, in particular by going through "ordinary" nodes (that don't
 * need to know whether the rest of the match failed) by a loop instead of
 * by recursion.
 */
static int                      /* 0 failure, 1 success */
regmatch(char * prog)
{
    register char *scan;    /* Current node. */
    char *next;             /* Next node. */
    //      extern char *strchr();

    scan = prog;
#ifdef DEBUG
    if (scan != NULL && regnarrate)
        fprintf(stderr, "%s(\n", regprop(scan));
#endif
    while (scan != NULL) {
#ifdef DEBUG
        if (regnarrate)
            fprintf(stderr, "%s...\n", regprop(scan));
#endif
        next = regnext(scan);

        switch (OP(scan)) {
            case BOL:
                if (reginput != regbol)
                    return(0);
                break;
            case EOL:
                if (*reginput != '\0')
                    return(0);
                break;
            case ANY:
                if (*reginput == '\0')
                    return(0);
                reginput++;
                break;
            case EXACTLY: {
                    register int len;
                    register char *opnd;

                    opnd = OPERAND(scan);
                    /* Inline the first character, for speed. */
                    if (mkup(*opnd) != mkup(*reginput))
                        return(0);
                    len = strlen(opnd);
                    if (len > 1 && cstrncmp(opnd,reginput,len) != 0)
                        return(0);
                    reginput += len;
                }
                break;
            case ANYOF:
                if (*reginput == '\0' || strchr(OPERAND(scan), *reginput) == NULL)
                    return(0);
                reginput++;
                break;
            case ANYBUT:
                if (*reginput == '\0' || strchr(OPERAND(scan), *reginput) != NULL)
                    return(0);
                reginput++;
                break;
            case NOTHING:
                break;
            case BACK:
                break;
            case OPEN+1:
            case OPEN+2:
            case OPEN+3:
            case OPEN+4:
            case OPEN+5:
            case OPEN+6:
            case OPEN+7:
            case OPEN+8:
            case OPEN+9: {
                    register int no;
                    register char *save;

                    no = OP(scan) - OPEN;
                    save = reginput;

                    if (regmatch(next)) {
                        /*
                         * Don't set startp if some later
                         * invocation of the same parentheses
                         * already has.
                         */
                        if (regstartp[no] == NULL)
                            regstartp[no] = save;
                        return(1);
                    } else
                        return(0);
                }
                break;
            case CLOSE+1:
            case CLOSE+2:
            case CLOSE+3:
            case CLOSE+4:
            case CLOSE+5:
            case CLOSE+6:
            case CLOSE+7:
            case CLOSE+8:
            case CLOSE+9: {
                    register int no;
                    register char *save;

                    no = OP(scan) - CLOSE;
                    save = reginput;

                    if (regmatch(next)) {
                        /*
                         * Don't set endp if some later
                         * invocation of the same parentheses
                         * already has.
                         */
                        if (regendp[no] == NULL)
                            regendp[no] = save;
                        return(1);
                    } else
                        return(0);
                }
                break;
            case BRANCH: {
                    register char *save;

                    if (OP(next) != BRANCH)         /* No choice. */
                        next = OPERAND(scan);   /* Avoid recursion. */
                    else {
                        do {
                            save = reginput;
                            if (regmatch(OPERAND(scan)))
                                return(1);
                            reginput = save;
                            scan = regnext(scan);
                        } while (scan != NULL && OP(scan) == BRANCH);
                        return(0);
                        /* NOTREACHED */
                    }
                }
                break;
            case STAR:
            case PLUS: {
                    register char nextch;
                    register int no;
                    register char *save;
                    register int min;

                    /*
                     * Lookahead to avoid useless match attempts
                     * when we know what character comes next.
                     */
                    nextch = '\0';
                    if (OP(next) == EXACTLY)
                        nextch = *OPERAND(next);
                    min = (OP(scan) == STAR) ? 0 : 1;
                    save = reginput;
                    no = regrepeat(OPERAND(scan));
                    while (no >= min) {
                        /* If it could work, try it. */
                        if (nextch == '\0' || *reginput == nextch)
                            if (regmatch(next))
                                return(1);
                            /* Couldn't or didn't -- back up. */
                        no--;
                        reginput = save + no;
                    }
                    return(0);
                }
                break;
            case END:
                return(1);      /* Success! */
                break;
            default:
                regerror("memory corruption");
                return(0);
                break;
        }

        scan = next;
    }

    /*
     * We get here only if there's trouble -- normally "case END" is
     * the terminating point.
     */
    regerror("corrupted pointers");
    return(0);
}

/*
 - regrepeat - repeatedly match something simple, report how many
 */
static int
regrepeat(char * p)
{
    register int count = 0;
    register char *scan;
    register char *opnd;

    scan = reginput;
    opnd = OPERAND(p);
    switch (OP(p)) {
        case ANY:
            count = strlen(scan);
            scan += count;
            break;
        case EXACTLY:
            while (mkup(*opnd) == mkup(*scan)) {
                count++;
                scan++;
            }
            break;
        case ANYOF:
            while (*scan != '\0' && strchr(opnd, *scan) != NULL) {
                count++;
                scan++;
            }
            break;
        case ANYBUT:
            while (*scan != '\0' && strchr(opnd, *scan) == NULL) {
                count++;
                scan++;
            }
            break;
        default:                /* Oh dear.  Called inappropriately. */
            regerror("internal foulup");
            count = 0;      /* Best compromise. */
            break;
    }
    reginput = scan;

    return(count);
}

/*
 - regnext - dig the "next" pointer out of a node
 */
static char *
regnext(register char * p)
{
    register int offset;

    if (p == &regdummy)
        return(NULL);

    offset = NEXT(p);
    if (offset == 0)
        return(NULL);

    if (OP(p) == BACK)
        return(p-offset);
    else
        return(p+offset);
}

#ifdef DEBUG

STATIC char *regprop();

/*
 - regdump - dump a regexp onto stdout in vaguely comprehensible form
 */
void
regdump(regexp * r)
{
    register char *s;
    register char op = EXACTLY;     /* Arbitrary non-END op. */
    register char *next;
    extern char *strchr();


    s = r->program + 1;
    while (op != END) {     /* While that wasn't END last time... */
        op = OP(s);
        printf("%2d%s", s-r->program, regprop(s));      /* Where, what. */
        next = regnext(s);
        if (next == NULL)               /* Next ptr. */
            printf("(0)");
        else
            printf("(%d)", (s-r->program)+(next-s));
        s += 3;
        if (op == ANYOF || op == ANYBUT || op == EXACTLY) {
            /* Literal string, where present. */
            while (*s != '\0') {
                putchar(*s);
                s++;
            }
            s++;
        }
        putchar('\n');
    }

    /* Header fields of interest. */
    if (r->regstart != '\0')
        printf("start `%c' ", r->regstart);
    if (r->reganch)
        printf("anchored ");
    if (r->regmust != NULL)
        printf("must have \"%s\"", r->regmust);
    printf("\n");
}

/*
 - regprop - printable representation of opcode
 */
static char *
regprop(char * op)
{
    register char *p;
    static char buf[50];

    (void) strcpy(buf, ":");

    switch (OP(op)) {
        case BOL:
            p = "BOL";
            break;
        case EOL:
            p = "EOL";
            break;
        case ANY:
            p = "ANY";
            break;
        case ANYOF:
            p = "ANYOF";
            break;
        case ANYBUT:
            p = "ANYBUT";
            break;
        case BRANCH:
            p = "BRANCH";
            break;
        case EXACTLY:
            p = "EXACTLY";
            break;
        case NOTHING:
            p = "NOTHING";
            break;
        case BACK:
            p = "BACK";
            break;
        case END:
            p = "END";
            break;
        case OPEN+1:
        case OPEN+2:
        case OPEN+3:
        case OPEN+4:
        case OPEN+5:
        case OPEN+6:
        case OPEN+7:
        case OPEN+8:
        case OPEN+9:
            sprintf(buf+strlen(buf), "OPEN%d", OP(op)-OPEN);
            p = NULL;
            break;
        case CLOSE+1:
        case CLOSE+2:
        case CLOSE+3:
        case CLOSE+4:
        case CLOSE+5:
        case CLOSE+6:
        case CLOSE+7:
        case CLOSE+8:
        case CLOSE+9:
            sprintf(buf+strlen(buf), "CLOSE%d", OP(op)-CLOSE);
            p = NULL;
            break;
        case STAR:
            p = "STAR";
            break;
        case PLUS:
            p = "PLUS";
            break;
        default:
            regerror("corrupted opcode");
            break;
    }
    if (p != NULL)
        (void) strcat(buf, p);
    return(buf);
}
#endif

/*
 * The following is provided for those people who do not have strcspn() in
 * their C libraries.  They should get off their butts and do something
 * about it; at least one public-domain implementation of those (highly
 * useful) string routines has been published on Usenet.
 */
#ifdef STRCSPN
/*
 * strcspn - find length of initial segment of s1 consisting entirely
 * of characters not from s2
 */

static int
strcspn(char * s1, char * s2)
{
    register char *scan1;
    register char *scan2;
    register int count;

    count = 0;
    for (scan1 = s1; *scan1 != '\0'; scan1++) {
        for (scan2 = s2; *scan2 != '\0';)       /* ++ moved down. */
            if (*scan1 == *scan2++)
                return(count);
        count++;
    }
    return(count);
}
#endif

int
cstrncmp(char * s1, char * s2, int n)
{
    char    *p, *S1, *S2;
    int     rval;

    if (!reg_ic)
        return (strncmp(s1, s2, n));

    S1 = _strdup(s1);
    S2 = _strdup(s2);

    if (S1 && S2)
    {
        for (p = S1; *p ;p = CharNext(p))
            if (islower(*p))
                *p = (char)toupper(*p);

        for (p = S2; *p ;p = CharNext(p))
            if (islower(*p))
                *p = (char)toupper(*p);

        rval = strncmp(S1, S2, n);
    }
    else
    {
        // just call them equal.  if we get here, we've got bigger problems.
        rval = 0;
    }

    free(S1);
    free(S2);

    return rval;
}

char *
cstrchr(
       char  *s,
       char  c)
{
    char    *p;

    for (p = s; *p ;p = CharNext(p)) {
        if (mkup(*p) == mkup(c))
            return p;
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\windiff\regexp.h ===
/*
 * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
 *
 * This is NOT the original regular expression code as written by
 * Henry Spencer. This code has been modified specifically for use
 * with the STEVIE editor, and should not be used apart from compiling
 * STEVIE. If you want a good regular expression library, get the
 * original code. The copyright notice that follows is from the
 * original.
 *
 * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
 *
 * Definitions etc. for regexp(3) routines.
 *
 * Caveat:  this is V8 regexp(3) [actually, a reimplementation thereof],
 * not the System V one.
 *
 * The first byte of the regexp internal "program" is actually this magic
 * number; the start node begins in the second byte.
 */
#define     MAGIC   0234

#define     NSUBEXP  10
typedef struct regexp {
        char *startp[NSUBEXP];
        char *endp[NSUBEXP];
        char regstart;          /* Internal use only. */
        char reganch;           /* Internal use only. */
        char *regmust;          /* Internal use only. */
        int regmlen;            /* Internal use only. */
        char program[1];        /* Unwarranted chumminess with compiler. */
} regexp;

extern regexp   *regcomp(char *exp);
extern int      regexec(regexp *prog, char *string, int at_bol);
extern void     regsub( regexp *prog, char *source, char *dest );
extern void     regerror(char *);

#ifndef ORIGINAL
extern int reg_ic;              /* set non-zero to ignore case in searches */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\windiff\profile.h ===
/*
 * utility functions to read and write values to the profile,
 * using win.ini for Win16 or HKEY_CURRENT_USER\software\microsoft\windiff\...
 * in the registry for Win32
 */

#ifndef _PROFILE_REG_H
#define _PROFILE_REG_H

#define MMPROFILECACHE 0  // Set to 1 to cache keys, 0 otherwise
#define USESTRINGSALSO 1

#ifndef _WIN32

#define mmGetProfileIntA(app, value, default) \
          GetProfileInt(app, value, default)

#define mmWriteProfileString(appname, valuename, pData) \
          WriteProfileString(appname, valuename, pData)

#define mmGetProfileString(appname, valuename, pDefault, pResult, cbResult) \
          GetProfileString(appname, valuename, pDefault, pResult, cbResult)

#define CloseKeys()

#else


/*
 * read a UINT from the profile, or return default if
 * not found.
 */
UINT mmGetProfileIntA(LPCSTR appname, LPCSTR valuename, INT uDefault);

/*
 * read a string from the profile into pResult.
 * result is number of characters written into pResult
 */
DWORD mmGetProfileString(LPCTSTR appname, LPCTSTR valuename, LPCTSTR pDefault,
                    LPTSTR pResult, int cbResult
);

/*
 * write a string/integer to the profile
 */
BOOL mmWriteProfileString(LPCTSTR appname, LPCTSTR valuename, LPCTSTR pData);

BOOL mmWriteProfileInt(LPCTSTR appname, LPCTSTR valuename, INT value);

UINT mmGetProfileInt(LPCTSTR appname, LPCTSTR valuename, INT value);

#undef WriteProfileString
#undef GetProfileString
#undef GetProfileInt

#define WriteProfileString  mmWriteProfileString
#define WriteProfileInt     mmWriteProfileInt
#define GetProfileString    mmGetProfileString
#define GetProfileInt       mmGetProfileInt


#if MMPROFILECACHE
VOID CloseKeys(VOID);
#else
#define CloseKeys()
#endif

/*
 * convert an Ansi string to Wide characters
 */
LPWSTR mmAnsiToWide (
   LPWSTR lpwsz,   // out: wide char buffer to convert into
   LPCSTR  lpsz,   // in: ansi string to convert from
   UINT   nChars); // in: count of characters in each buffer

/*
 * convert a Wide char string to Ansi
 */
LPSTR mmWideToAnsi (
   LPSTR  lpsz,    // out: ansi buffer to convert into
   LPCWSTR lpwsz,  // in: wide char buffer to convert from
   UINT   nChars); // in: count of characters (not bytes!)

#if !defined NUMELMS
 #define NUMELMS(aa) (sizeof(aa)/sizeof((aa)[0]))
#endif

#endif
#endif // _PROFILE_REG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\windiff\scandir.c ===
/*
 * scandir.c
 *
 * build lists of filenames given a pathname.
 *
 * dir_buildlist takes a pathname and returns a handle. Subsequent
 * calls to dir_firstitem and dir_nextitem return handles to
 * items within the list, from which you can get the name of the
 * file (relative to the original pathname, or complete), and a checksum
 * and filesize.
 *
 * lists can also be built using dir_buildremote (WIN32 only) and
 * the same functions used to traverse the list and obtain checksums and
 * filenames.
 *
 * The list can be either built entirely during the build call, or
 * built one directory at a time as required by dir_nextitem calls. This
 * option affects only relative performance, and is taken as a
 * recommendation only (ie some of the time we will ignore the flag).
 *
 * the list is ordered alphabetically (case-insensitive using lstrcmpi).
 * within any one directory, we list filenames before going on
 * to subdirectory contents.
 *
 * All memory is allocated from a gmem_* heap hHeap declared
 * and initialised elsewhere.
 *
 * Geraint Davies, July 92
 * Laurie Griffiths
 */

#include <windows.h>
#include <stdlib.h>
#include <string.h>
#include <dos.h>
#include <direct.h>
#include <gutils.h>

#include "sumserve.h"
#include "ssclient.h"

#include "list.h"
#include "scandir.h"

#include "windiff.h"
#include "wdiffrc.h"

#include "slmmgr.h"

#ifdef trace
extern BOOL bTrace;  /* in windiff.c.  Read only here */
#endif //trace

/*
 * The caller gets handles to two things: a DIRLIST, representing the
 * entire list of filenames, and a DIRITEM: one item within the list.
 *
 * from the DIRITEM he can get the filename relative to tree root
 * passed to dir_build*) - and also he can get to the next
 * DIRITEM (and back to the DIRLIST).
 *
 * We permit lazy building of the tree (usually so the caller can keep
 * the user-interface uptodate as we go along). In this case,
 * we need to store information about how far we have scanned and
 * what is next to do. We need to scan an entire directory at a time and then
 * sort it so we can return files in the correct order.
 *
 *
 * We scan an entire directory and store it in a DIRECT struct. This contains
 * a list of DIRITEMs for the files in the current directory, and a list of
 * DIRECTs for the subdirectories (possible un-scanned).
 *
 * dir_nextitem will use the list functions to get the next DIRITEM on the list.
 * When the end of the list is reached, it will use the backpointer back to the
 * DIRECT struct to find the next directory to scan.
 *
 *
 * For REMOTE scans, we do not parse the names and store them by directory,
 * since they are already sorted. The DIRLIST will have only one DIRECT
 * (dot), and all files are on this one dot->diritems list, including the
 * relname of the directory in the name field (ie for remote files, we
 * don't need to prepend the directory relname when doing dir_getrelname -
 * we can pass a pointer to the diritem->name[] itself.
 *
 */

/*
 * hold name and information about a given file (one ITEM in a DIRectory)
 * caller's DIRITEM handle is a pointer to one of these structures
 */
struct diritem {
    LPSTR name;             /* ptr to filename (final element only) */
    LPSTR pSlmTag;          /* ptr to version string - for SLM "@v.-1", etc; or for SD "#head", etc; or NULL */
    long size;              /* filesize */
    DWORD checksum;         /* checksum of file */
    DWORD attr;             /* file attributes */
    FILETIME ft_lastwrite;  /* last write time, set whenever size is set */
    BOOL sumvalid;          /* TRUE if checksum calculated */
    BOOL fileerror;         // true if some file error occurred
    struct direct * direct; /* containing directory */
    LPSTR localname;        /* name of temp copy of file */
    BOOL bLocalIsTemp;      /* true if localname is tempfile. not
                             * defined if localname is NULL
                             */
    int sequence;           /* sequence number, for dir_compsequencenumber */
};


/* DIRECT: hold state about directory and current position in list of filenames.
 */
typedef struct direct {
    LPSTR relname;          /* name of dir relative to DIRLIST root */
    DIRLIST head;           /* back ptr (to get fullname and server) */
    struct direct * parent; /* parent directory (NULL if above tree root)*/

    BOOL bScanned;          /* TRUE if scanned -for Remote, T if completed*/
    LIST diritems;          /* list of DIRITEMs for files in cur. dir */
    LIST directs;           /* list of DIRECTs for child dirs */

    int pos;                /* where are we? begin, files, dirs */
    struct direct * curdir; /* subdir being scanned (ptr to list element)*/
} * DIRECT;

/* values for direct.pos */
#define DL_FILES        1       /* reading files from the diritems */
#define DL_DIRS         2       /* in the dirs: List_Next on curdir */


/*
 * the DIRLIST handle returned from a build function is in fact
 * a pointer to one of these. Although this is not built from a LIST object,
 * it behaves like a list to the caller.
 */
struct dirlist {

    char rootname[MAX_PATH];        /* name of root of tree */
    BOOL bFile;             /* TRUE if root of tree is file, not dir */
    BOOL bRemote;           /* TRUE if list built from remote server */
    BOOL bSum;              /* TRUE if checksums required */
    DIRECT dot;             /* dir  for '.' - for tree root dir */

    LPSTR pPattern;         /* wildcard pattern or NULL */
    LPSTR pSlmTag;          /* Slm version info "@v.-1" or NULL */
    LPSTR pDescription;     /* description */

    DIRLIST pOtherDirList;

    LPSTR server;           /* name of server if remote, NULL otherwise */
    HANDLE hpipe;           /* pipe to checksum server */
    LPSTR uncname;          /* name of server&share if password req'd */
    LPSTR password;         /* password for UNC connection if needed */
};

extern BOOL bAbort;             /* from windiff.c (read only here). */

/* file times are completely different under DOS and NT.
   On NT they are FILETIMEs with a 2 DWORD structure.
   Under DOS they are single long.  We emulate the NT
   thing under DOS by providing CompareFileTime and a
   definition of FILETIME
*/

/* ------ memory allocation ---------------------------------------------*/

/* all memory is allocated from a heap created by the application */
extern HANDLE hHeap;

/*-- forward declaration of internal functions ---------------------------*/

BOOL iswildpath(LPCSTR pszPath);
LPSTR dir_finalelem(LPSTR path);
void dir_cleardirect(DIRECT dir);
void dir_adddirect(DIRECT dir, LPSTR path);
BOOL dir_addfile(DIRECT dir, LPSTR path, LPSTR version, DWORD size, FILETIME ft, DWORD attr, int *psequence);
void dir_scan(DIRECT dir, BOOL bRecurse);
BOOL dir_isvalidfile(LPSTR path);
BOOL dir_fileinit(DIRITEM pfile, DIRECT dir, LPSTR path, LPSTR version, long size, FILETIME ft, DWORD attr, int *psequence);
void dir_dirinit(DIRECT dir, DIRLIST head, DIRECT parent, LPSTR name);
long dir_getpathsizeetc(LPSTR path, FILETIME FAR*ft, DWORD FAR*attr);
DIRITEM dir_findnextfile(DIRLIST dl, DIRECT curdir);
BOOL dir_remoteinit(DIRLIST dl, LPSTR server, LPSTR path, BOOL fDeep);
DIRITEM dir_remotenext(DIRLIST dl, DIRITEM cur);



/* --- external functions ------------------------------------------------*/


/* ----- list initialisation/cleanup --------------------------------------*/


/*
 * build a list of filenames
 *
 * optionally build the list on demand, in which case we scan the
 * entire directory but don't recurse into subdirs until needed
 *
 * if bSum is true, checksum each file as we build the list. checksums can
 * be obtained from the DIRITEM (dir_getchecksum(DIRITEM)). If bSum is FALSE,
 * checksums will be calculated on request (the first call to dir_getchecksum
 * for a given DIRITEM).
 */

DIRLIST
dir_buildlist(
              LPSTR path,
              BOOL bSum,
              BOOL bOnDemand
              )
{
    DIRLIST dlOut = 0;
    DIRLIST dl = 0;
    BOOL bFile;
    char tmppath[MAX_PATH];
    LPSTR pstr;
    LPSTR pPat = NULL;
    LPSTR pTag = NULL;

    /*
     * copy the path so we can modify it
     */
    lstrcpy(tmppath, path);

    /* look for SLM tags, strip them and return them in pTag
     * look for SLM tags beginning @ and separate if there.
     */
    pTag = SLM_ParseTag(tmppath, TRUE);

    /* look for wildcards and separate out pattern if there */
    if (My_mbschr(tmppath, '*') || My_mbschr(tmppath, '?'))
    {
        pstr = dir_finalelem(tmppath);
        pPat = gmem_get(hHeap, lstrlen(pstr) +1);
        lstrcpy(pPat, pstr);
        *pstr = '\0';
    }

    /* we may have reduced the path to nothing - replace with . if so */
    if (lstrlen(tmppath) == 0)
    {
        lstrcpy(tmppath, ".");
    }
    else
    {
        /*
         * remove the trailing slash if unnecessary (\, c:\ need it)
         */
        pstr = &tmppath[lstrlen(tmppath) -1];
        if ((*pstr == '\\') && (pstr > tmppath) && (pstr[-1] != ':')
            && !IsDBCSLeadByte((BYTE)*(pstr-1)))
        {
            *pstr = '\0';
        }
    }


    /* check if the path is valid */
    if ((pTag && !iswildpath(tmppath)) || (tmppath[0] == '/' && tmppath[1] == '/'))
    {
        bFile = TRUE;
    }
    else if (dir_isvaliddir(tmppath))
    {
        bFile = FALSE;
    }
    else if (dir_isvalidfile(tmppath))
    {
        bFile = TRUE;
    }
    else
    {
        /* not valid */
        goto LError;
    }


    /* alloc and init the DIRLIST head */

    dl = (DIRLIST) gmem_get(hHeap, sizeof(struct dirlist));

    // done in gmem_get
    //memset(dl, 0, sizeof(struct dirlist));

    dl->pOtherDirList = NULL;

    /* convert the pathname to an absolute path */
    // (but don't mess with depot paths)
    if (!IsDepotPath(tmppath))
        _fullpath(dl->rootname, tmppath, sizeof(dl->rootname));

    dl->server = NULL;

    dl->bSum = bSum;
    dl->bSum = FALSE;  // to speed things up. even if we do want checksums,
                       // let's get them on demand, not right now.
    dl->bFile = bFile;
    dl->bRemote = FALSE;

    if (pTag)
    {
        dl->pSlmTag = pTag;
        pTag = 0;
    }
    if (pPat)
    {
        dl->pPattern = pPat;
        pPat = 0;
    }


    /* make a '.' directory for the tree root directory -
     * all files and subdirs will be listed from here
     */
    {    /* Do NOT chain on anything with garbage pointers in it */
        DIRECT temp;
        temp = (DIRECT) gmem_get(hHeap, sizeof(struct direct));

        //done in gmem_get
        //if (temp!=NULL) memset(temp, 0, sizeof(struct direct));

        dl->dot = temp;
    }

    dir_dirinit(dl->dot, dl, NULL, ".");

    /* were we given a file or a directory ? */
    if (bFile)
    {
        /* its a file. create a single file entry
         * and set the state accordingly
         */
        long fsize;
        FILETIME ft;
        DWORD attr;
        fsize = dir_getpathsizeetc(tmppath, &ft, &attr);

        dl->dot->bScanned = TRUE;

        /*
         * addfile will extract the slm version, if
         * required. It will recalc file size based on
         * the slm-extraction if necessary.
         */
        if (!dir_addfile(dl->dot, dir_finalelem(tmppath), dl->pSlmTag, fsize, ft, attr, 0))
            goto LError;
    }
    else
    {
        /* scan the root directory and return. if we are asked
         * to scan the whole thing, this will cause a recursive
         * scan all the way down the tree
         */
        dir_scan(dl->dot, (!bOnDemand) );
    }

    dlOut = dl;
    dl = 0;

LError:
    if (pTag)
        gmem_free(hHeap, pTag, lstrlen(pTag) + 1);
    if (pPat)
        gmem_free(hHeap, pPat, lstrlen(pPat) + 1);
    dir_delete(dl);
    return dlOut;
} /* dir_buildlist */

/*
 * build/append a list of filenames
 *
 * if bSum is true, checksum each file as we build the list. checksums can
 * be obtained from the DIRITEM (dir_getchecksum(DIRITEM)). If bSum is FALSE,
 * checksums will be calculated on request (the first call to dir_getchecksum
 * for a given DIRITEM).
 */

BOOL
dir_appendlist(
               DIRLIST *pdl,
               LPCSTR path,
               BOOL bSum,
               int *psequence
               )
{
    DIRLIST dl;
    BOOL bFile;
    char tmppath[MAX_PATH];
    LPSTR pstr;
    LPSTR pTag = NULL;
    BOOL fSuccess = FALSE;

    if (path)
    {
        // copy the path so we can modify it
        lstrcpy(tmppath, path);

        // look for SLM tags, strip them and return them in pTag
        pTag = SLM_ParseTag(tmppath, TRUE);

        // remove the trailing slash if unnecessary (\, c:\ need it)
        pstr = &tmppath[lstrlen(tmppath) -1];
        if ((*pstr == '\\') && (pstr > tmppath) && (pstr[-1] != ':')
            && !IsDBCSLeadByte((BYTE)*(pstr-1)))
        {
            *pstr = '\0';
        }


        /* check if the path is valid */
        if ((pTag && !iswildpath(tmppath))|| (tmppath[0] == '/' && tmppath[1] == '/'))
        {
            // assume valid if under source control
            bFile = TRUE;
        }
        else if (dir_isvaliddir(tmppath))
        {
            bFile = FALSE;
        }
        else if (dir_isvalidfile(tmppath))
        {
            bFile = TRUE;
        }
        else
        {
            /* not valid */
            goto LError;
        }
    }

    if (!*pdl)
    {
        DIRECT temp;

        /* alloc and init the DIRLIST head */
        *pdl = (DIRLIST) gmem_get(hHeap, sizeof(struct dirlist));
        // done in gmem_get
        //memset(dl, 0, sizeof(struct dirlist));

        (*pdl)->pOtherDirList = NULL;

        /* convert the pathname to an absolute path */

        //_fullpath((*pdl)->rootname, tmppath, sizeof((*pdl)->rootname));

        (*pdl)->server = NULL;

        (*pdl)->bSum = bSum;
        (*pdl)->bSum = FALSE;   // to speed things up. even if we do want
                                // checksums, let's get them on demand, not
                                // right now.
        (*pdl)->bFile = FALSE;
        (*pdl)->bRemote = FALSE;

        /* make a null directory for the tree root directory -
         * all files and subdirs will be listed from here
         */
        /* Do NOT chain on anything with garbage pointers in it */
        temp = (DIRECT) gmem_get(hHeap, sizeof(struct direct));
        //done in gmem_get
        //if (temp!=NULL) memset(temp, 0, sizeof(struct direct));
        (*pdl)->dot = temp;

        dir_dirinit((*pdl)->dot, (*pdl), NULL, "");
        (*pdl)->dot->relname[0] = 0;
        (*pdl)->dot->bScanned = TRUE;
    }
    dl = *pdl;

    if (pTag && !dl->pSlmTag)
    {
        dl->pSlmTag = gmem_get(hHeap, lstrlen(pTag) + 1);
        lstrcpy(dl->pSlmTag, pTag);
    }

    if (path)
    {
        /* were we given a file or a directory ? */
        if (bFile)
        {
            /* its a file. create a single file entry
             * and set the state accordingly
             */
            long fsize;
            FILETIME ft;
            DWORD attr;

            if (pTag || dl->pSlmTag)
            {
                fsize = 0;
                attr = 0;
                ZeroMemory(&ft, sizeof(ft));
            }
            else
                fsize = dir_getpathsizeetc(tmppath, &ft, &attr);

            /*
             * addfile will extract the slm version, if
             * required. It will recalc file size based on
             * the slm-extraction if necessary.
             */
            if (!dir_addfile(dl->dot, tmppath, pTag, fsize, ft, attr, psequence))
                goto LError;
        }
    }

    fSuccess = TRUE;

LError:
    if (pTag)
        gmem_free(hHeap, pTag, lstrlen(pTag) + 1);
    return fSuccess;
} /* dir_appendlist */

void
dir_setotherdirlist(
                    DIRLIST dl,
                    DIRLIST otherdl
                    )
{
    dl->pOtherDirList = otherdl;
}

/* free up the DIRLIST and all associated memory */
void
dir_delete(
           DIRLIST dl
           )
{
    if (dl == NULL) {
        return;
    }

    if (dl->bRemote) {
        gmem_free(hHeap, dl->server, lstrlen(dl->server)+1);

        /* if remote, and dl->dot is not scanned (ie scan is not
         * complete), then the pipe handle is still open
         */
        if (!dl->dot->bScanned) {
            CloseHandle(dl->hpipe);
        }

        if (dl->uncname) {
            gmem_free(hHeap, dl->uncname, strlen(dl->uncname)+1);
        }
        if (dl->password) {
            gmem_free(hHeap, dl->password, strlen(dl->password)+1);
        }

    }

    dir_cleardirect(dl->dot);
    gmem_free(hHeap, (LPSTR) dl->dot, sizeof(struct direct));

    if (dl->pPattern) {
        gmem_free(hHeap, dl->pPattern, lstrlen(dl->pPattern)+1);
    }
    if (dl->pSlmTag) {
        gmem_free(hHeap, dl->pSlmTag, lstrlen(dl->pSlmTag)+1);
    }

    gmem_free(hHeap, (LPSTR) dl, sizeof(struct dirlist));
}



/*
 * build a list by accessing a remote checksum server.
 */
DIRLIST
dir_buildremote(
                LPSTR server,
                LPSTR path,
                BOOL bSum,
                BOOL bOnDemand,
                BOOL fDeep
                )
{
    DIRLIST dl;

    /* alloc and init the DIRLIST head */

    dl = (DIRLIST) gmem_get(hHeap, sizeof(struct dirlist));
    //done in gmem_get
    //memset(dl, 0, sizeof(struct dirlist));

    /* alloc space for the pathname */
    lstrcpy(dl->rootname, path);

    /* and for the server name */
    dl->server = gmem_get(hHeap, lstrlen(server) + 1);
    lstrcpy(dl->server, server);

    dl->bSum = bSum;
    /* bFile is set to TRUE - meaning we have just one file.
     * if we ever see a DIR response from the remote end, we will
     * set this to false.
     */
    dl->bFile = TRUE;
    dl->bRemote = TRUE;

    /* make a '.' directory for the current directory -
     * all files and subdirs will be listed from here
     */
    {    /* Do NOT chain on anmything with garbage pointers in it */
        DIRECT temp;
        temp = (DIRECT) gmem_get(hHeap, sizeof(struct direct));
        // done in gmem_get
        //if (temp!=NULL) memset(temp, 0, sizeof(struct direct));
        dl->dot = temp;
    }
    dir_dirinit(dl->dot, dl, NULL, ".");

    if (dir_remoteinit(dl, server, path, fDeep) == FALSE) {
        /* didn't find any files, so remove the directory */
        dir_delete(dl);
        return(NULL);
    }
    return(dl);
} /* dir_buildremote */


/* ----- DIRLIST functions ------------------------------------------------*/

/* was the original build request a file or a directory ? */
BOOL
dir_isfile(
           DIRLIST dl
           )
{
    if (dl == NULL) {
        return(FALSE);
    }

    return(dl->bFile);
}


/* return the first file in the list, or NULL if no files found.
 * returns a DIRITEM. This can be used to get filename, size and chcksum.
 * if there are no files in the root, we recurse down until we find a file
 */
DIRITEM
dir_firstitem(
              DIRLIST dl
              )
{
    if (dl == NULL) {
        return(NULL);
    }
    /*
     * is this a remote list or a local scan ?
     */
    if (dl->bRemote) {
        return(dir_remotenext(dl, NULL));
    }

    /*
     * reset the state to indicate that no files have been read yet
     */
    dl->dot->pos = DL_FILES;
    dl->dot->curdir = NULL;

    /* now get the next filename */
    return(dir_findnextfile(dl, dl->dot));
} /* dir_firstitem */


/*
 * get the next filename after the one given.
 *
 * The List_Next function can give us the next element on the list of files.
 * If this is null, we need to go back to the DIRECT and find the
 * next list of files to traverse (in the next subdir).
 *
 * after scanning all the subdirs, return to the parent to scan further
 * dirs that are peers of this, if there are any. If we have reached the end of
 * the tree (no more dirs in dl->dot to scan), return NULL.
 *
 * Don't recurse to lower levels unless fDeep is TRUE
 */
DIRITEM
dir_nextitem(
             DIRLIST dl,
             DIRITEM cur,
             BOOL fDeep
             )
{
    DIRITEM next;

    if ((dl == NULL) || (cur == NULL)) {
        TRACE_ERROR("DIR: null arguments to dir_nextitem", FALSE);
        return(NULL);
    }

    /*
     * is this a remote list or a local scan ?
     */
    if (dl->bRemote) {
        return(dir_remotenext(dl, cur));
    }

    if (bAbort) return NULL;  /* user requested abort */

    /* local list */

    if ( (next = List_Next(cur)) != NULL) {
        /* there was another file on this list */
        return(next);
    }
    if (!fDeep) return NULL;

    /* get the head of the next list of filenames from the directory */
    cur->direct->pos = DL_DIRS;
    cur->direct->curdir = NULL;
    return(dir_findnextfile(dl, cur->direct));
} /* dir_nextitem */

DIRITEM
dir_findnextfile(
                 DIRLIST dl,
                 DIRECT curdir
                 )
{
    DIRITEM curfile;

    if (bAbort) return NULL;  /* user requested abort */

    if ((dl == NULL) || (curdir == NULL)) {
        return(NULL);
    }

    /* scan the subdir if necessary */
    if (!curdir->bScanned) {
        dir_scan(curdir, FALSE);
    }

    /* have we already read the files in this directory ? */
    if (curdir->pos == DL_FILES) {
        /* no - return head of file list */
        curfile = (DIRITEM) List_First(curdir->diritems);
        if (curfile != NULL) {
            return(curfile);
        }

        /* no more files - try the subdirs */
        curdir->pos = DL_DIRS;
    }

    /* try the next subdir on the list, if any */
    /* is this the first or the next */
    if (curdir->curdir == NULL) {
        curdir->curdir = (DIRECT) List_First(curdir->directs);
    } else {
        curdir->curdir = (DIRECT) List_Next(curdir->curdir);
    }
    /* did we find a subdir ? */
    if (curdir->curdir == NULL) {

        /* no more dirs - go back to parent if there is one */
        if (curdir->parent == NULL) {
            /* no parent - we have exhausted the tree */
            return(NULL);
        }

        /* reset parent state to indicate this is the current
         * directory - so that next gets the next after this.
         * this ensures that multiple callers of dir_nextitem()
         * to the same tree work.
         */
        curdir->parent->pos = DL_DIRS;
        curdir->parent->curdir = curdir;

        return(dir_findnextfile(dl, curdir->parent));
    }

    /* there is a next directory - set it to the
     * beginning and get the first file from it
     */
    curdir->curdir->pos = DL_FILES;
    curdir->curdir->curdir = NULL;
    return(dir_findnextfile(dl, curdir->curdir));

} /* dir_findnextfile */


/*
 * get a description of this DIRLIST - this is essentially the
 * rootname with any wildcard specifier at the end. For remote
 * lists, we prepend the checksum server name as \\server!path.
 *
 * NOTE that this is not a valid path to the tree root - for that you
 * need dir_getrootpath().
 */
LPSTR
dir_getrootdescription(
                       DIRLIST dl
                       )
{
    LPSTR pname;

    // allow enough space for \\servername! + MAX_PATH
    pname = gmem_get(hHeap, MAX_PATH + 15);
    if (pname == NULL) {
        return(NULL);
    }

    if (dl->pDescription) {
        lstrcpy(pname, dl->pDescription);
    } else if (dl->bRemote) {
        wsprintf(pname, "\\\\%s!%s", dl->server, dl->rootname);
    } else {
        lstrcpy(pname, dl->rootname);

        if (dl->pPattern) {
            lstrcat(pname, "\\");
            lstrcat(pname, dl->pPattern);
        }

        if (dl->pSlmTag) {
            lstrcat(pname, dl->pSlmTag);
        }
    }

    return(pname);
}

/*
 * free up a string returned from dir_getrootdescription
 */
VOID
dir_freerootdescription(
                        DIRLIST dl,
                        LPSTR string
                        )
{
    gmem_free(hHeap, string, MAX_PATH+15);
}


/*
 * dir_getrootpath
 *
 * return the path to the DIRLIST root. This will be a valid path, not
 * including the checksum server name or pPattern or pSlmTag etc
 */
LPSTR
dir_getrootpath(
                DIRLIST dl
                )
{
    return(dl->rootname);
}



/*
 * free up a path created by dir_getrootpath
 */
void
dir_freerootpath(
                 DIRLIST dl,
                 LPSTR path
                 )
{
    return;
}


/*
 * set custom description for dirlist
 */
void
dir_setdescription(DIRLIST dl, LPCSTR psz)
{
    dl->pDescription = gmem_get(hHeap, lstrlen(psz) + 1);
    if (dl->pDescription)
        lstrcpy(dl->pDescription, psz);
}




/*
 * returns TRUE if the DIRLIST parameter has a wildcard specified
 */
BOOL
dir_iswildcard(
               DIRLIST dl
               )
{
    return (dl->pPattern != NULL);
}




/* --- DIRITEM functions ----------------------------------------------- */


/*
 * Return a handle to the DIRLIST given a handle to the DIRITEM within it.
 *
 */
DIRLIST
dir_getlist(
            DIRITEM item
            )
{
    if (item == NULL) {
        return(NULL);
    } else {
        return(item->direct->head);
    }
}


/*
 * return the name of the current file relative to tree root
 * This allocates storage.  Call dir_freerelname to release it.
 */
LPSTR
dir_getrelname(
               DIRITEM cur
               )
{
    LPSTR name;

    /* check this is a valid item */
    if (cur == NULL) {
        return(NULL);
    }

    /* the entire relname is already in the name[] field for
     * remote lists
     */
    if (cur->direct->head->bRemote) {
        return(cur->name);
    }

    name = gmem_get(hHeap, MAX_PATH);
    if (!IsDepotPath(cur->name))
        lstrcpy(name, cur->direct->relname);
    lstrcat(name, cur->name);

//$ review: (chrisant) what is this here for?  seems totally broken
// even for SLM, and for SD it screws everything up.
#if 0
    if (cur->direct->head->pSlmTag) {
        lstrcat(name, cur->direct->head->pSlmTag);
    }
#endif

    return(name);
} /* dir_getrelname */


/* free up a relname that we allocated. This interface allows us
 * some flexibility in how we store relative and complete names
 *
 * remote lists already have the relname and name combined, so in these
 * cases we did not alloc memory - so don't free it.
 */
void
dir_freerelname(
                DIRITEM cur,
                LPSTR name
                )
{
    if ((cur != NULL) && (!cur->direct->head->bRemote)) {
        if (name != NULL) {
            gmem_free(hHeap, name, MAX_PATH);
        }
    }
} /* dir_freerelname */


/*
 * get an open-able name for the file. This is the complete pathname
 * of the item (DIRLIST rootpath + DIRITEM relname)
 * except for remote files and slm early-version files,
 * in which case a temporary local copy of the file
 * will be made. call dir_freeopenname when finished with this name.
 */
LPSTR
dir_getopenname(
                DIRITEM item
                )
{
    LPSTR fname;
    DIRLIST phead;

    if (item == NULL) {
        return(NULL);
    }

    phead = item->direct->head;

    if (item->localname != NULL) {
        return(item->localname);
    }

    if (phead->bFile) {
        return(phead->rootname);
    }

    // build up the file name from rootname+relname
    // start with the root portion - rest is different in remote case
    fname = gmem_get(hHeap, MAX_PATH);
    if (!fname)
        return NULL;
    lstrcpy(fname, phead->rootname);


    if (phead->bRemote) {

        // relname is empty for remote names - just add
        // the rootname and the name to make a complete
        // remote name, and then make a local copy of this.

        /* avoid the . or .\ at the start of the relname */
        if (*CharPrev(fname, fname+lstrlen(fname)) == '\\') {
            lstrcat(fname, &item->name[2]);
        } else {
            lstrcat(fname, &item->name[1]);
        }

        item->localname = gmem_get(hHeap, MAX_PATH);
        if (item->localname)
        {
            GetTempPath(MAX_PATH, item->localname);
            GetTempFileName(item->localname, "wdf", 0, item->localname);
            item->bLocalIsTemp = TRUE;


            if (!ss_copy_reliable(
                                 item->direct->head->server,
                                 fname,
                                 item->localname,
                                 item->direct->head->uncname,
                                 item->direct->head->password)) {

                TRACE_ERROR("Could not copy remote file", FALSE);
                DeleteFile(item->localname);
                gmem_free(hHeap, item->localname, MAX_PATH);
                item->localname = NULL;
            }
        }

        // finished with the rootname+relname
        gmem_free(hHeap, fname, MAX_PATH);

        return(item->localname);
    }

    /*
     * it's a simple local name - add both relname and name to make
     * the complete filename
     */
    /* avoid the . or .\ at the end of the relname */
    if (*CharPrev(fname, fname+lstrlen(fname)) == '\\') {
        lstrcat(fname, &item->direct->relname[2]);
    } else {
        lstrcat(fname, &item->direct->relname[1]);
    }
    lstrcat(fname, item->name);

    return(fname);
}



/*
 * free up memory created by a call to dir_getopenname(). This *may*
 * cause the file to be deleted if it was a temporary copy.
 */
void
dir_freeopenname(
                 DIRITEM item,
                 LPSTR openname
                 )
{
    if ((item == NULL) || (openname == NULL)) {
        return;
    }

    if (item->localname != NULL) {
        /* freed in dir_cleardirect */
        return;
    }
    if (item->direct->head->bFile) {
        /* we used the rootname */
        return;
    }

    gmem_free(hHeap, openname, MAX_PATH);

} /* dir_freeopenname */


/*
 * return an open file handle to the file. if it is local,
 * just open the file. if remote, copy the file to a
 * local temp. file and open that
 */
int
dir_openfile(
             DIRITEM item
             )
{
    LPSTR fname;
    int fh;


    fname = dir_getopenname(item);
    if (fname == NULL) {
        /* can not make remote copy */
        return(-1);
    }

    fh = HandleToLong(CreateFile(fname, GENERIC_READ,
                         FILE_SHARE_READ|FILE_SHARE_WRITE,
                         0, OPEN_EXISTING, 0, 0));

    dir_freeopenname(item, fname);

    return(fh);
} /* dir_openfile */




/*
 * close a file opened with dir_openfile.
 */
void
dir_closefile(
              DIRITEM item,
              int fh
              )
{
    CloseHandle(LongToHandle(fh));

} /* dir_closefile */



/* Recreate all the checksums and status for di as though
   it had never been looked at before
*/
void
dir_rescanfile(
               DIRITEM di
               )
{
    LPSTR fullname;

    if (di==NULL) return;

    /* start with it invalid, erroneous and zero */
    di->sumvalid = FALSE;
    di->fileerror = TRUE;
    di->checksum = 0;

    fullname = dir_getopenname(di);
    if ( di->direct->head->bRemote) {
        LPSTR fname;

        fname = gmem_get(hHeap, MAX_PATH);
        lstrcpy(fname, di->direct->head->rootname);
        // relname is empty for remote names - just add
        // the rootname and the name to make a complete
        // remote name, and then make a local copy of this.

        /* avoid the . or .\ at the start of the relname */
        if (*CharPrev(fname, fname+lstrlen(fname)) == '\\') {
            lstrcat(fname, &di->name[2]);
        } else {
            lstrcat(fname, &di->name[1]);
        }
        di->direct->head->hpipe = ss_connect( di->direct->head->server);
        di->fileerror = !ss_checksum_remote( di->direct->head->hpipe, fname
                                             , &(di->checksum), &(di->ft_lastwrite), &(di->size),
                                             &(di->attr));
    } else {
        di->size = dir_getpathsizeetc(fullname, &(di->ft_lastwrite), &(di->attr));
        di->checksum = dir_getchecksum(di);
    }

    dir_freeopenname(di, fullname);

    di->sumvalid = !(di->fileerror);

} /* dir_rescanfile */


/* return a TRUE iff item has a valid checksum */
BOOL
dir_validchecksum(
                  DIRITEM item
                  )
{
    return (item!=NULL) && (item->sumvalid);
}


BOOL
dir_fileerror(
              DIRITEM item
              )
{
    return (item == NULL) || (item->fileerror);
}


/* return the current file checksum. Open the file and
 * calculate the checksum if it has not already been done.
 */
DWORD
dir_getchecksum(
                DIRITEM cur
                )
{
    LPSTR fullname;

    /* check this is a valid item */
    if (cur == NULL) {
        return(0);
    }

    if (!cur->sumvalid) {
        /*
         * need to calculate checksum
         */
        if (cur->direct->head->bRemote) {
            /* complex case - leave till later - for
             * now the protocol always passes checksums to
             * the client.
             */
            cur->checksum = 0; /* which it probably was anyway */
        } else {

            LONG err;

            fullname = dir_getopenname(cur);
            cur->checksum = checksum_file(fullname, &err);
            if (err==0) {
                cur->sumvalid = TRUE;
                cur->fileerror = FALSE;
            } else {
                cur->fileerror = TRUE;
                return 0;
            }

            dir_freeopenname(cur, fullname);

        }
    }

    return(cur->checksum);
} /* dir_getchecksum */



/* return the file size (set during scanning) - returns 0 if invalid */
long
dir_getfilesize(
                DIRITEM cur
                )
{
    /* check this is a valid item */
    if (cur == NULL) {
        return(0);
    }


    return(cur->size);
} /* dir_getfilesize */

/* return the file attributes (set during scanning) - returns 0 if invalid */
DWORD
dir_getattr(
            DIRITEM cur
            )
{
    /* check this is a valid item */
    if (cur == NULL) {
        return(0);
    }


    return(cur->attr);
} /* dir_getattr */

/* return the file time (last write time) (set during scanning), (0,0) if invalid */
FILETIME
dir_GetFileTime(
                DIRITEM cur
                )
{
    /* return time of (0,0) if this is an invalid item */
    if (cur == NULL) {
        FILETIME ft;
        ft.dwLowDateTime = 0;
        ft.dwHighDateTime = 0;
        return ft;
    }

    return(cur->ft_lastwrite);

} /* dir_GetFileTime */

/*
 * extract the portions of a name that match wildcards - for now,
 * we only support wildcards at start and end.
 * if pTag is non-null, then the source will have a tag matching it that
 * can also be ignored.
 */
void
dir_extractwildportions(
                       LPSTR pDest,
                       LPSTR pSource,
                       LPSTR pPattern,
                       LPSTR pTag
                       )
{
    int size;

    /*
     * for now, just support the easy cases where there is a * at beginning or
     * end
     */

    if (pPattern[0] == '*') {
        size = lstrlen(pSource) - (lstrlen(pPattern) -1);

    } else if (pPattern[lstrlen(pPattern) -1] == '*') {
        pSource += lstrlen(pPattern) -1;
        size = lstrlen(pSource);
    } else {
        size = lstrlen(pSource);
    }

    if (pTag != NULL) {
        size -= lstrlen(pTag);
    }

    My_mbsncpy(pDest, pSource, size);
    pDest[size] = '\0';
}

/*
 * compares two DIRITEM paths that are both based on wildcards. if the
 * directories match, then the filenames are compared after removing
 * the fixed portion of the name - thus comparing only the
 * wildcard portion.
 */
int
dir_compwildcard(
                DIRLIST dleft,
                DIRLIST dright,
                LPSTR lname,
                LPSTR rname
                )
{
    LPSTR pfinal1, pfinal2;
    char final1[MAX_PATH], final2[MAX_PATH];
    int res;

    /*
     * relnames always have at least one backslash
     */
    pfinal1 = My_mbsrchr(lname, '\\');
    pfinal2 = My_mbsrchr(rname, '\\');

    My_mbsncpy(final1, lname, (size_t)(pfinal1 - lname));
    final1[pfinal1 - lname] = '\0';
    My_mbsncpy(final2, rname, (size_t)(pfinal2 - rname));
    final2[pfinal2 - rname] = '\0';


    /*
     * compare all but the final component - if not the same, then
     * all done.
     */
    res = utils_CompPath(final1,final2);
    if (res != 0) {
        return(res);
    }

    // extract just the wildcard-matching portions of the final elements
    dir_extractwildportions(final1, &pfinal1[1], dleft->pPattern, 0);
    dir_extractwildportions(final2, &pfinal2[1], dright->pPattern, 0);

    return(utils_CompPath(final1, final2));
}

/*
 * compares two DIRLIST items, based on a sequence number rather than filenames.
 */
BOOL dir_compsequencenumber(DIRITEM dleft, DIRITEM dright, int *pcmpvalue)
{
    if (!dleft->sequence && !dright->sequence)
        return FALSE;

    if (!dleft->sequence)
        *pcmpvalue = -1;
    else if (!dright->sequence)
        *pcmpvalue = 1;
    else
        *pcmpvalue = dleft->sequence - dright->sequence;

    return TRUE;
}






/* --- file copying ---------------------------------------------------*/



/* copying files can be done several ways.  The interesting one is
   bulk copy from remote server.  In this case before calling
   dir_copy, call dir_startcopy and after calling dir_copy some
   number of times call dir_endcopy.

   Read client and server to see the shenanigans that then go on there.
   Over here, we just call call ss_startcopy with the server name
   and ss_endcopy.

   dir_startcopy will kick off a dialog with the sumserver, dir_copy
   will send the next filename and dir_endcopy will wait for all the
   files to come through before returning.

*/

/* ss_endcopy returns a number indicating the number of files copied,
   but we may have some local copies too.  We need to count these
   ourselves and add them in
*/

static int nLocalCopies;        /* cleared in startcopy, ++d in copy
                                ** inspected in endcopy
                                */

/* start a bulk copy */
BOOL
dir_startcopy(
              DIRLIST dl
              )
{
    nLocalCopies = 0;

    if (dl->bRemote) {
        return  ss_startcopy( dl->server,dl->uncname,dl->password);
    } else {
        return(TRUE);
    }

} /* dir_startcopy */

int
dir_endcopy(
            DIRLIST dl
            )
{
    int nCopied;

    if (dl->bRemote) {
        nCopied =  ss_endcopy();
        if (nCopied<0) return nCopied;              /* failure count */
        else return  nCopied+nLocalCopies;  /* success count */
    } else {
        return(nLocalCopies);
    }

} /* dir_endcopy */

/* Build the real path from item and newroot into newpath.
 * Create directories as needed so that it is valid.
 * If mkdir fails, return FALSE, but return the full path that we were
 * trying to make anyway.
 */
BOOL
dir_MakeValidPath(
                  LPSTR newpath,
                  DIRITEM item,
                  LPSTR newroot
                  )
{
    LPSTR relname;
    LPSTR pstart, pdest, pel;
    BOOL bOK = TRUE;

    /*
     * name of file relative to the tree root
     */
    relname = dir_getrelname(item);

    /*
     * build the new pathname by concatenating the new root and
     * the old relative name. add one path element at a time and
     * ensure that the directory exists, creating it if necessary.
     */
    lstrcpy(newpath, newroot);

    /* add separating slash if not already there */
    if (*CharPrev(newpath, newpath+lstrlen(newpath)) != '\\') {
        lstrcat(newpath, "\\");
    }

    pstart = relname;
    while ( (pel = My_mbschr(pstart, '\\')) != NULL) {

        /*
         * ignore .
         */
        if (My_mbsncmp(pstart, ".\\", 2) != 0) {

            pdest = &newpath[lstrlen(newpath)];

            // copy all but the backslash
            // on NT you can create a dir 'fred\'
            // on dos you have to pass 'fred' to _mkdir()
            My_mbsncpy(pdest, pstart, (size_t)(pel - pstart));
            pdest[pel - pstart] = '\0';

            /* create subdir if necessary */
            if (!dir_isvaliddir(newpath)) {
                if (_mkdir(newpath) != 0) {
                    /* note error, but keep going */
                    bOK = FALSE;
                }
            }

            // now insert the backslash
            lstrcat(pdest, "\\");
        }

        /* found another element ending in slash. incr past the \\ */
        pel++;

        pstart = pel;
    }

    /*
     * there are no more slashes, so pstart points at the final
     * element
     */
    lstrcat(newpath, pstart);
    dir_freerelname(item, relname);
    return bOK;
}



/*
 * create a copy of the file, in the new root directory. creates sub-dirs as
 * necessary. Works for local and remote files. For remote files, uses
 * ss_copy_reliable to ensure that the copy succeeds if possible.
 * (Actually does bulk_copy which retries with copy_reliable if need be).
 *
 * returns TRUE for success and FALSE for failure.
 */
BOOL
dir_copy(
         DIRITEM item,
         LPSTR newroot,
         BOOL HitReadOnly,
         BOOL CopyNoAttributes
         )
{
    /*
     * newpath must be static for Win 3.1 so that it is in the
     * data segment (near) and not on the stack (far).
     */
    static char newpath[MAX_PATH];
    BOOL bOK;

    char msg[MAX_PATH+40];
    BY_HANDLE_FILE_INFORMATION bhfi;
    HANDLE hfile;
    DWORD fa;

    /*
     * check that the newroot directory itself exists
     */
    if ((item == NULL) || !dir_isvaliddir(newroot)) {
        return(FALSE);
    }

    if (!dir_MakeValidPath(newpath, item, newroot)) return FALSE;

    if (item->direct->head->bRemote) {
        /* if the target file already exists and is readonly,
         * warn the user, and delete if ok (remembering to clear
         * the read-only flag
         */
        fa = GetFileAttributes(newpath);
        if ( (fa != -1) &&  (fa & FILE_ATTRIBUTE_READONLY)) {
            wsprintf(msg, LoadRcString(IDS_IS_READONLY),
                     (LPSTR) newpath);

            windiff_UI(TRUE);
            if ((HitReadOnly)
			    || (MessageBox(hwndClient, msg, LoadRcString(IDS_COPY_FILES),
                               MB_OKCANCEL|MB_ICONSTOP) == IDOK)) {
                windiff_UI(FALSE);
                SetFileAttributes(newpath, fa & ~FILE_ATTRIBUTE_READONLY);
                DeleteFile(newpath);
            } else {
                windiff_UI(FALSE);
                return FALSE; /* don't overwrite */
            }
        }

        /*
         * we make local copies of the file (item->localname)
         * when the user wants to expand a remotely-compared
         * file. If this has happened, then we can copy the
         * local temp copy rather than the remote.
         */
        bOK = FALSE;
        if (item->localname != NULL) {
            bOK = CopyFile(item->localname, newpath, FALSE);
        }
        if (bOK) {
            ++nLocalCopies;
            if (CopyNoAttributes) {
                // kill the attributes preserved by CopyFile
                SetFileAttributes(newpath, FILE_ATTRIBUTE_NORMAL);
            }
        } else {
            char fullname[MAX_PATH];

            /*
             * in this case we need the full name of the
             * file as it appears to the remote server
             */
            lstrcpy(fullname, item->direct->head->rootname);
            if (!item->direct->head->bFile) {
                /*
                 * append the desired filename only if the
                 * original root was a dir or pattern, not a
                 * file.
                 */
                if (*CharPrev(fullname, fullname+lstrlen(fullname)) == '\\') {
                    lstrcat(fullname, &item->name[2]);
                } else {
                    lstrcat(fullname, &item->name[1]);
                }
            }

            bOK = ss_bulkcopy(item->direct->head->server,
                              fullname, newpath,
                              item->direct->head->uncname,
                              item->direct->head->password);

            /*
             * remember the local copy name so that he can
             * now rapidly expand the file also.
             * It is more difficult to clear the remotely
             * copied attributes as we do not know here
             * when the file copy has completed.
             */
            item->localname = gmem_get(hHeap, MAX_PATH);
            lstrcpy(item->localname, newpath);
            item->bLocalIsTemp = FALSE;
        }
    } else {
        /* local copy of file */
        LPSTR pOpenName;

        pOpenName = dir_getopenname(item);

        /* if the target file already exists and is readonly,
         * warn the user, and delete if ok (remembering to clear
         * the read-only flag
         */
        bOK = TRUE;
        fa = GetFileAttributes(newpath);
        if ( (fa != -1) &&  (fa & FILE_ATTRIBUTE_READONLY)) {
            wsprintf(msg, LoadRcString(IDS_IS_READONLY),
                     (LPSTR) newpath);

            windiff_UI(TRUE);
            if ((HitReadOnly)
			    || (MessageBox(hwndClient, msg, LoadRcString(IDS_COPY_FILES),
                               MB_OKCANCEL|MB_ICONSTOP) == IDOK)) {
                windiff_UI(FALSE);
                SetFileAttributes(newpath, fa & ~FILE_ATTRIBUTE_READONLY);
                DeleteFile(newpath);
                // This of course is an unsafe copy...
                // we have deleted the target file before
                // we copy the new one over the top.
                // Should we omit the DeleteFile ??
            } else {
                windiff_UI(FALSE);
                bOK = FALSE; /* don't overwrite */
                // abort the copy... go and release resources
            }
        }

        if (bOK) {
            bOK = CopyFile(pOpenName, newpath, FALSE);
        }
        // The attributes are copied by CopyFile
        if (bOK) {

            /* having copied the file, now copy the times */
            hfile = CreateFile(pOpenName, GENERIC_READ, 0, NULL,
                               OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
            /*
             * bug in GetFileInformationByHandle causes trap if
             * file is not on local machine (in build 297).
             * code around:
             */
            //NOT NEEDED
            //bhfi.dwFileAttributes = GetFileAttributes(pOpenName);

            GetFileTime(hfile, &bhfi.ftCreationTime,
                        &bhfi.ftLastAccessTime, &bhfi.ftLastWriteTime);
            CloseHandle(hfile);

            // Note: CopyFile does not preserve all the file times...
            hfile = CreateFile(newpath, GENERIC_WRITE, 0, NULL,
                               OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
            SetFileTime(hfile, &bhfi.ftCreationTime,
                        &bhfi.ftLastAccessTime,
                        &bhfi.ftLastWriteTime);
            CloseHandle(hfile);

            if (CopyNoAttributes) {
                // Prepare to kill the attributes...
                SetFileAttributes(newpath, FILE_ATTRIBUTE_NORMAL);
            } else {
                // Attributes were preserved by CopyFile
                //SetFileAttributes(newpath, bhfi.dwFileAttributes);
            }
        }
        if (bOK)
            ++nLocalCopies;

        dir_freeopenname(item, pOpenName);
    }

    return(bOK);
} /* dir_copy */



/*--- internal functions ---------------------------------------- */

/* fill out a new DIRECT for a subdirectory (pre-allocated).
 * init files and dirs lists to empty (List_Create). set the relname
 * of the directory by pre-pending the parent relname if there
 * is a parent, and appending a trailing slash (if there isn't one).
 */
void
dir_dirinit(
            DIRECT dir,
            DIRLIST head,
            DIRECT parent,
            LPSTR name
            )
{
    int size;

    dir->head = head;
    dir->parent = parent;

    /* add on one for the null and one for the trailing slash */
    size = lstrlen(name) + 2;
    if (parent != NULL) {
        size += lstrlen(parent->relname);
    }

    /* build the relname from the parent and the current name
     * with a terminating slash
     */
    dir->relname = gmem_get(hHeap, size);
    if (parent != NULL) {
        lstrcpy(dir->relname, parent->relname);
    } else {
        dir->relname[0] = '\0';
    }

    lstrcat(dir->relname, name);

    if (*CharPrev(dir->relname, dir->relname+lstrlen(dir->relname)) != '\\')
    {
        lstrcat(dir->relname, "\\");
    }

    /* force name to lowercase */
    AnsiLowerBuff(dir->relname, lstrlen(dir->relname));

    dir->diritems = List_Create();
    dir->directs = List_Create();
    dir->bScanned = FALSE;
    dir->pos = DL_FILES;

} /* dir_dirinit */

/* initialise the contents of an (allocated) DIRITEM struct. checksum
 * the file if dir->head->bSum is true
 *
 * if the pSlmTag field is set in the DIRLIST, then we need to extract
 * a particular version of this file. If this is the case, then we
 * need to re-do the size calc as well.
 *
 */
BOOL
dir_fileinit(
             DIRITEM pfile,
             DIRECT dir,
             LPSTR path,
             LPSTR version,
             long size,
             FILETIME ft,
             DWORD attr,
             int *psequence
             )
{
    BOOL bFileOk = TRUE;

    pfile->name = gmem_get(hHeap, lstrlen(path) + 1);
    lstrcpy(pfile->name, path);

    if (version)
    {
        pfile->pSlmTag = gmem_get(hHeap, lstrlen(version) + 1);
        lstrcpy(pfile->pSlmTag, version);
    }

    /* force name to lower case */
    AnsiLowerBuff(pfile->name, lstrlen(path));

    pfile->direct = dir;
    pfile->size = size;
    pfile->ft_lastwrite = ft;
    pfile->attr = attr;

    pfile->sequence = psequence ? *psequence : 0;

    pfile->localname = NULL;
    /*
     * if we requested slm versions of this file, create
     * a temp file containing the version required.
     */
    if (pfile->pSlmTag != NULL) {
        SLMOBJECT hslm;
        LPSTR pName;

        /*
         * get the complete filename and create a slm object for that directory
         */
        pName = dir_getopenname(pfile);


        hslm = SLM_New(pName, 0);
        if (hslm != NULL) {

            char chVersion[MAX_PATH];

            lstrcpy(chVersion, pfile->name);
            lstrcat(chVersion, pfile->pSlmTag);

            pfile->localname = gmem_get(hHeap, MAX_PATH);
            pfile->bLocalIsTemp  = TRUE;

            bFileOk = SLM_GetVersion(hslm, chVersion, pfile->localname);
            SLM_Free(hslm);

            if (!bFileOk)
                return bFileOk;

            if (IsSourceDepot(hslm))
                pfile->size = dir_getpathsizeetc(pfile->localname, NULL, NULL);
            else
                pfile->size = dir_getpathsizeetc(pfile->localname, &(pfile->ft_lastwrite), NULL);
        }
    }


    if (dir->head->bSum) {
        LONG err;
        LPSTR openname;

        openname = dir_getopenname(pfile);
        pfile->checksum = checksum_file(openname, &err);

        if (err!=0) {
            pfile->sumvalid = FALSE;
        } else {
            pfile->sumvalid = TRUE;
        }
        dir_freeopenname(pfile, openname);

    } else {
        pfile->sumvalid = FALSE;
    }

    return bFileOk;
} /* dir_fileinit */



/* is this a valid file or not */
BOOL
dir_isvalidfile(
                LPSTR path
                )
{
    DWORD dwAttrib;

    dwAttrib = GetFileAttributes(path);
    if (dwAttrib == -1) {
        return(FALSE);
    }
    if (dwAttrib & FILE_ATTRIBUTE_DIRECTORY) {
        return(FALSE);
    }
    return(TRUE);
} /* dir_isvalidfile */


/* is this a valid directory ? */
BOOL
dir_isvaliddir(
               LPCSTR path
               )
{
    DWORD dwAttrib;

    dwAttrib = GetFileAttributes(path);
    if (dwAttrib == -1) {
        return(FALSE);
    }
    if (dwAttrib & FILE_ATTRIBUTE_DIRECTORY) {
        return(TRUE);
    }
    return(FALSE);
} /* dir_isvaliddir */



/*
 * scan the directory given. add all files to the list
 * in alphabetic order, and add all directories in alphabetic
 * order to the list of child DIRITEMs. If bRecurse is true, go on to
 * recursive call dir_scan for each of the child DIRITEMs
 */
void
dir_scan(
         DIRECT dir,
         BOOL bRecurse
         )
{
    PSTR path, completepath;
    int size;
    DIRECT child;
    BOOL bMore;
    long filesize;
    FILETIME ft;
    BOOL bIsDir;
    LPSTR name;
    HANDLE hFind;
    WIN32_FIND_DATA finddata;

    /* make the complete search string including *.* */
    size = lstrlen(dir->head->rootname);
    size += lstrlen(dir->relname);

    /* add on one null and \*.* */
    // in fact, we need space for pPattern instead of *.* but add an
    // extra few in case pPattern is less than *.*
    if (dir->head->pPattern != NULL) {
        size += lstrlen(dir->head->pPattern);
    }
    size += 5;

    path = LocalLock(LocalAlloc(LHND, size));
    completepath = LocalLock(LocalAlloc(LHND, size));

    if (!path || !completepath)
        goto LSkip;

    /*
     * fill out path with all but the *.*
     */
    lstrcpy(path, dir->head->rootname);

    /* omit the . at the beginning of the relname, and the
     * .\ if there is a trailing \ on the rootname
     */
    if (*CharPrev(path, path+lstrlen(path)) == '\\') {
        lstrcat(path, &dir->relname[2]);
    } else {
        lstrcat(path, &dir->relname[1]);
    }


    if (dir->head->pSlmTag && !SLM_FServerPathExists(path))
    {
        // if server path for source control does not exist, then skip this
        // directory.
        bRecurse = FALSE;
        goto LSkip;
    }



    /*
     * do this scan twice, once for subdirectories
     * (using *.* as the final element)
     * and the other for files (using the pattern or *.* if none)
     */

    lstrcpy(completepath, path);
    lstrcat(completepath, "*.*");


    /*
     * scan for all subdirectories
     */

    hFind = FindFirstFile(completepath, &finddata);
    bMore = (hFind != INVALID_HANDLE_VALUE);

    while (bMore) {

        bIsDir = (finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
        name = (LPSTR) &finddata.cFileName;
        filesize = finddata.nFileSizeLow;     // dead code - ???
        if (bIsDir) {
            if ( (lstrcmp(name, ".") != 0) &&
                 (lstrcmp(name, "..") != 0) &&
                 (TrackSlmFiles || (_stricmp(name, "slm.dif") != 0)) ) {

                if (dir->head->pOtherDirList == NULL) {
                    dir_adddirect(dir, name);
                } else {
                    char otherName[MAX_PATH+1];
                    strcpy(otherName, dir_getrootpath(dir->head->pOtherDirList));
                    if (otherName[strlen(otherName)-1] == '\\') {
                        strcat(otherName, &dir->relname[2]);
                    } else {
                        strcat(otherName, &dir->relname[1]);
                    }
                    strcat(otherName, name);
                    if (dir_isvaliddir(otherName)) {
                        dir_adddirect(dir, name);
                    }
                }
            }
        }
        if (bAbort) break;  /* User requested abort */

        bMore = FindNextFile(hFind, &finddata);
    }

    FindClose(hFind);

    /*
     * now do it a second time looking for files
     */
    lstrcpy(completepath, path);
    lstrcat(completepath,
            dir->head->pPattern == NULL ? "*.*" : dir->head->pPattern);

    /* read all file entries in the directory */
    hFind = FindFirstFile(completepath, &finddata);
    bMore = (hFind != INVALID_HANDLE_VALUE);

    while (bMore) {
        if (bAbort) break;  /* user requested abort */

        bIsDir = (finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
        name = (LPSTR) &finddata.cFileName;
        filesize = finddata.nFileSizeLow;
        ft = finddata.ftLastWriteTime;
        if (!bIsDir) {
            if ( TrackSlmFiles ||
                 ( (_stricmp(name,"slm.ini") != 0) &&
                   (_stricmp(name,"iedcache.slm") != 0) &&
                   (_stricmp(name,"iedcache.slm.v6") != 0) ) ) {
                dir_addfile(dir, name, dir->head->pSlmTag, filesize, ft, finddata.dwFileAttributes, 0);
            }
        }

        bMore = FindNextFile(hFind, &finddata);
    }

    FindClose(hFind);

LSkip:
    if (path)
        //$ review: (chrisant) is PREfix confused, or is LocalUnlock really
        // unable to deal with NULL?
        LocalUnlock(LocalHandle ( (PSTR) path));
    LocalFree(LocalHandle ( (PSTR) path));
    if (completepath)
        //$ review: (chrisant) is PREfix confused, or is LocalUnlock really
        // unable to deal with NULL?
        LocalUnlock(LocalHandle ( (PSTR) completepath));
    LocalFree(LocalHandle ( (PSTR) completepath));

    dir->bScanned = TRUE;
    dir->pos = DL_FILES;

    if (bRecurse) {
        List_TRAVERSE(dir->directs, child) {
            if (bAbort) break;  /* user requested abort */
            dir_scan(child, TRUE);
        }
    }

} /* dir_scan */


/*
 * add the file 'path' to the list of files in dir, in order.
 *
 * checksum the file if dir->head->bSum  is true
 *
 * (On NT I think the filenames are normally delivered to us in alphabetic order,
 * so it might be quicker to scan the list in reverse order.  Don't change unless
 * and until it's been measured and seen to be significant)
 */
BOOL
dir_addfile(
            DIRECT dir,
            LPSTR path,
            LPSTR version,
            DWORD size,
            FILETIME ft,
            DWORD attr,
            int *psequence
            )
{
    DIRITEM pfile;

    AnsiLowerBuff(path, lstrlen(path));  // needless?



    /* The names are often (always?) handed to us in alphabetical order.
       It therefore is traversing the list from the start.  MikeTri
       noticed a marked slowing down after the first few thousand files
       of a large (remote) diff.  Did over 4000 in the first hour, but only
       1500 in the second hour.  Reverse scan seems to fix it.
    */
#define SCANREVERSEORDER
#if defined(SCANREVERSEORDER)
    List_REVERSETRAVERSE(dir->diritems, pfile) {
        if (utils_CompPath(pfile->name, path) <= 0) {
            break;     /* goes after this one */
        }
    }
    /* goes after pfile, NULL => goes at start */
    pfile = List_NewAfter(dir->diritems, pfile, sizeof(struct diritem));
#else
    List_TRAVERSE(dir->diritems, pfile) {
        if (utils_CompPath(pfile->name, path) > 0) {
            break;    /* goes before this one */
        }
    }
    /* goes before pfile, NULL => goes at end */
    pfile = List_NewBefore(dir->diritems, pfile, sizeof(struct diritem));
#endif
    if (!dir_fileinit(pfile, dir, path, version, size, ft, attr, psequence))
    {
        List_Delete(pfile);
        return FALSE;
    }
    return TRUE;
} /* dir_addfile */


/* add a new directory in alphabetic order on
 * the list dir->directs
 *
 */
void
dir_adddirect(
              DIRECT dir,
              LPSTR path
              )
{
    DIRECT child;
    LPSTR finalel;
    char achTempName[MAX_PATH];

    AnsiLowerBuff(path, lstrlen(path));
    List_TRAVERSE(dir->directs, child) {

        int cmpval;

        /* we need to compare the child name with the new name.
         * the child name is a relname with a trailing
         * slash - so compare only the name up to but
         * not including the final slash.
         */
        finalel = dir_finalelem(child->relname);

        /*
         * we cannot use strnicmp since this uses a different
         * collating sequence to lstrcmpi. So copy the portion
         * we are interested in to a null-term. buffer.
         */
        My_mbsncpy(achTempName, finalel, lstrlen(finalel)-1);
        achTempName[lstrlen(finalel)-1] = '\0';

        cmpval = utils_CompPath(achTempName, path);

#ifdef trace
        {       char msg[600];
            wsprintf( msg, "dir_adddirect: %s %s %s\n"
                      , achTempName
                      , ( cmpval<0 ? "<"
                          : (cmpval==0 ? "=" : ">")
                        )
                      , path
                    );
            if (bTrace) Trace_File(msg);
        }
#endif
        if (cmpval > 0) {

            /* goes before this one */
            child = List_NewBefore(dir->directs, child, sizeof(struct direct));
            dir_dirinit(child, dir->head, dir, path);
            return;
        }
    }
    /* goes at end */
    child = List_NewLast(dir->directs, sizeof(struct direct));
    dir_dirinit(child, dir->head, dir, path);
} /* dir_adddirect */


/* free all memory associated with a DIRECT (including freeing
 * child lists). Don't de-alloc the direct itself (allocated on a list)
 */
void
dir_cleardirect(
                DIRECT dir
                )
{
    DIRITEM pfile;
    DIRECT child;

    /* clear contents of files list */
    List_TRAVERSE(dir->diritems, pfile) {
        gmem_free(hHeap, pfile->name, lstrlen(pfile->name));

        if (pfile->localname) {
            if (pfile->bLocalIsTemp) {
                /*
                 * the copy will have copied the attributes,
                 * including read-only. We should unset this bit
                 * so we can delete the temp file.
                 */
                SetFileAttributes(pfile->localname,
                                  GetFileAttributes(pfile->localname)
                                  & ~FILE_ATTRIBUTE_READONLY);
                DeleteFile(pfile->localname);
            }

            gmem_free(hHeap, pfile->localname, MAX_PATH);
            pfile->localname = NULL;

            if (pfile->pSlmTag)
            {
                gmem_free(hHeap, pfile->pSlmTag, lstrlen(pfile->pSlmTag) + 1);
                pfile->pSlmTag = NULL;
            }
        }
    }
    List_Destroy(&dir->diritems);

    /* clear contents of dirs list (recursively) */
    List_TRAVERSE(dir->directs, child) {
        dir_cleardirect(child);
    }
    List_Destroy(&dir->directs);

    gmem_free(hHeap, dir->relname, lstrlen(dir->relname) + 1);

} /* dir_cleardirect */



/*
 * return a pointer to the final element in a path. note that
 * we may be passed relnames with a trailing final slash - ignore this
 * and return the element before that final slash.
 */
LPSTR
dir_finalelem(
              LPSTR path
              )
{
    LPSTR chp;
    int size;

    /* is the final character a slash ? */
    size = lstrlen(path) - 1;
    if (*(chp = CharPrev(path, path+lstrlen(path))) == '\\') {
            /* find the slash before this */
            while (chp > path) {
                    if (*(chp = CharPrev(path, chp)) == '\\') {
                            /* skip the slash itself */
                            chp++;
                            break;
                    }
            }
            return(chp);
    }
    /* look for final slash */
    chp = My_mbsrchr(path, '\\');
    if (chp != NULL) {
        return(chp+1);
    }

    /* no slash - is there a drive letter ? */
    chp = My_mbsrchr(path, ':');
    if (chp != NULL) {
        return(chp+1);
    }

    /* this is a final-element anyway */
    return(path);

} /* dir_finalelem */



/* find the size of a file given a pathname to it */
long
dir_getpathsizeetc(
                   LPSTR path,
                   FILETIME *pft,
                   DWORD *pattr
                   )
{
    int fh;
    OFSTRUCT os;
    long size;

    // Don't accidentally treat //depot paths as UNCs
    if (IsDepotPath(path)) return 0;

    fh = OpenFile(path, &os, OF_READ|OF_SHARE_DENY_NONE);
    if (fh == -1)
    {
        HANDLE hFind;
        WIN32_FIND_DATA finddata;

        hFind = FindFirstFile(path, &finddata);
        if (hFind == INVALID_HANDLE_VALUE)
        {
            return 0;                       // would -1 be better?
        }
        else
        {
            FindClose(hFind);
            if (pft)
                *pft = finddata.ftLastWriteTime;
            if (pattr != NULL)
                *pattr = finddata.dwFileAttributes;
            return finddata.nFileSizeLow;
        }
    }

    size = GetFileSize( (HANDLE) IntToPtr(fh), NULL);
    if (pft)
        GetFileTime( (HANDLE) IntToPtr(fh), NULL, NULL, pft);
    if (pattr != NULL)
        *pattr = GetFileAttributes(path);
    _lclose(fh);
    return(size);
} /* dir_getpathsize */

/*--- remote functions ---------------------------------------*/

/* separate out the \\server\share name from the beginning of
 * the source path and store in dest. return false if there was
 * no server\share name.
 */
BOOL
dir_parseunc(
             LPSTR source,
             LPSTR dest
             )
{
    LPSTR cp;

    if ((source[0] != '\\') || (source[1] != '\\')) {
        return(FALSE);
    }

    /* find the second slash (between server and share) */
    cp = My_mbschr(&source[2], '\\');
    if (cp == NULL) {
        /* no second slash -> no share name-> error */
        return(FALSE);
    }

    /* find the third slash or end of name */
    cp = My_mbschr(++cp,'\\');
    if (cp == NULL) {
        /* no third slash -> whole string is what we need */
        strcpy(dest, source);
    } else {
        /* copy only up to the slash */
        My_mbsncpy(dest, source, (size_t)(cp - source));
        dest[cp-source] = '\0';
    }
    return(TRUE);
} /* dir_parseunc */

/*
 * communication between remote dialog, password dialog and dir_buildremote
 *
 */
char dialog_server[256];
char dialog_password[256];


/*
 * DialogProc for the dialog that
 * gets the password for a network server.
 *
 * the server name is stored in the module-wide dialog_server,
 * and the password is to be put in dialog_password
 */
INT_PTR
dir_dodlg_passwd(
                 HWND hDlg,
                 UINT message,
                 WPARAM wParam,
                 LPARAM lParam
                 )
{
    static char msg[256];

    switch (message) {

        case WM_INITDIALOG:
            /* set the prompt to ask for the password for
             * the given server
             */
            wsprintf(msg, LoadRcString(IDS_ENTER_PASSWORD), dialog_server);
            SetDlgItemText(hDlg, IDD_LABEL, msg);

            return(TRUE);

        case WM_COMMAND:
            switch (wParam) {
                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    return(TRUE);

                case IDOK:
                    GetDlgItemText(hDlg, IDD_PASSWORD,
                                   dialog_password, sizeof(dialog_password));
                    EndDialog(hDlg, TRUE);
                    return(TRUE);
            }
            break;
    }
    return(FALSE);
} /* dir_dodlg_passwd */


/* we have had a 'bad password' error.
 * If the path was a UNC name, then ask the user for the password and
 * try a SSREQ_UNC to make the connection with this password first, then
 * retry the scan.
 *
 * return TRUE if we have re-done the scan and *resp contains a response
 * other than BADPASS.
 *
 * return FALSE if we had any errors, or the user cancelled the password
 * dialog, or it was not a UNC name.
 */
BOOL
dir_makeunc(
            DIRLIST dl,
            HANDLE hpipe,
            LPSTR path,
            LONG lCode,
            PSSNEWRESP resp,
            BOOL fDeep
            )
{
    int sz;

    /* separate out the \\server\share name into server */
    if (dir_parseunc(path, dialog_server) == FALSE) {
        /* was not a valid UNC name - sorry */
        return(FALSE);
    }

    windiff_UI(TRUE);
    if (!DialogBox(hInst, "UNC", hwndClient, dir_dodlg_passwd)) {
        windiff_UI(FALSE);
        /* user cancelled dialog box */
        return(FALSE);
    }
    windiff_UI(FALSE);

    /* send the password request */
    if (!ss_sendunc(hpipe, dialog_password, dialog_server)) {
        TRACE_ERROR("Server connection lost", FALSE);
        return(FALSE);
    }
    /* wait for password response */
    if (!ss_getresponse(hpipe, resp)) {
        TRACE_ERROR("Server connection lost", FALSE);
        return(FALSE);
    }
    if (resp->lCode != SSRESP_END) {
        TRACE_ERROR("Connection failed", FALSE);
        return(FALSE);
    }

    /*
     * save the UNC name and password for future queries to this
     * DIRLIST (eg dir_copy)
     */
    sz = strlen(dialog_server);
    dl->uncname = gmem_get(hHeap, sz+1);
    strcpy(dl->uncname, dialog_server);
    sz = strlen(dialog_password);
    dl->password = gmem_get(hHeap, sz+1);
    strcpy(dl->password, dialog_password);


    /* ok - UNC went ok. now re-do the scan request and get the
     * first response.
     */
    if (!ss_sendrequest(hpipe, lCode, path, strlen(path) +1,
                        (fDeep ? INCLUDESUBS:0) ) ) {
        TRACE_ERROR("Server connection lost", FALSE);
        return(FALSE);
    }

    if (!ss_getresponse(hpipe, resp)) {
        TRACE_ERROR("Server connection lost", FALSE);
        return(FALSE);
    }

    if (resp->lCode == SSRESP_BADPASS) {
        TRACE_ERROR("Cannot access remote files", FALSE);
        return(FALSE);
    }
    return(TRUE);
} /* dir_makeunc */

/*
 * start a scan to a remote server, and put the first item on the list
 *
 * We establish a connection to a remote checksum server, and then
 * request a scan of the path given. If this path requires a password
 * (because it is a UNC path) we prompt for a password.
 *
 * We take the first response (mainly to check the return code to indicate
 * the scan is started ok). We place this as the first file in the list
 * dl->dot->diritems, and return. dl->dot->bScanned is only set to TRUE
 * when the list is completed.  Further responses are picked up in
 * calls to dir_remotenext.
 *
 * return TRUE if we successfully picked up the first file
 */
BOOL
dir_remoteinit(
               DIRLIST dl,
               LPSTR server,
               LPSTR path,
               BOOL fDeep
               )
{
    SSNEWRESP resp;
    int nFiles = 0;
    HANDLE hpipe;
    char msg[MAX_PATH+60];
    DIRITEM pfile;
    LONG lCode;

    /* connect to the server and make the request */
    hpipe = ss_connect(server);
    dl->hpipe = hpipe;

    if (hpipe == INVALID_HANDLE_VALUE) {
        wsprintf(msg, "Cannot connect to %s", server);
        TRACE_ERROR(msg, FALSE);
        return(FALSE);
    }
    lCode = (dl->bSum) ? SSREQ_SCAN : SSREQ_QUICKSCAN;

    if (!ss_sendrequest( hpipe, lCode, path, strlen(path)+1,
                         (fDeep ? INCLUDESUBS:0) ) ) {
        TRACE_ERROR("Server connection lost", FALSE);
        return(FALSE);
    }

    /* get the first response to see if the request is ok */
    if (!ss_getresponse(hpipe, &resp)) {
        TRACE_ERROR("Server connection lost", FALSE);
        return(FALSE);
    }
    if (resp.lCode == SSRESP_BADPASS) {
        /* check for UNC name and make connection first
         * with user-supplied password
         */
        if (dir_makeunc(dl, hpipe, path, lCode, &resp, fDeep) == FALSE) {
            /* password failed or was not UNC anyway */
            ss_terminate(hpipe);
            return(FALSE);
        }
    }


    switch (resp.lCode) {

        case SSRESP_END:
            /* null list - ok ? */
            TRACE_ERROR("No remote files found", FALSE);
            ss_terminate(dl->hpipe);
            dl->dot->bScanned = TRUE;
            return(FALSE);

        case SSRESP_ERROR:
            if (resp.ulSize!=0) {
                wsprintf( msg, "Checksum server could not read %s win32 code %d"
                          , resp.szFile, resp.ulSize
                        );
            } else
                wsprintf(msg, "Checksum server could not read %s", resp.szFile);
            TRACE_ERROR(msg, FALSE);

            /* error as first response means we are getting a null list -
             * close the pipe (without waiting for completion)
             * and abort this scan.
             */
            CloseHandle(dl->hpipe);
            dl->dot->bScanned = TRUE;
            return(FALSE);


        case SSRESP_CANTOPEN:
            /* Can see a file, but it's unreadable */
            /* alloc a new item at end of list */
            pfile = List_NewLast(dl->dot->diritems, sizeof(struct diritem));

            /* make copy of lowercased filename */
            pfile->name = gmem_get(hHeap, lstrlen(resp.szFile)+1);
            lstrcpy(pfile->name, resp.szFile);
            AnsiLowerBuff(pfile->name, lstrlen(pfile->name));

            // mark the file as having an error
            pfile->fileerror = TRUE;

            pfile->direct = dl->dot;
            pfile->size = resp.ulSize;
            pfile->ft_lastwrite = resp.ft_lastwrite;
            pfile->checksum = resp.ulSum;
            pfile->sumvalid = FALSE;
            pfile->localname = NULL;

            break;

        case SSRESP_FILE:
            /* alloc a new item at end of list */
            pfile = List_NewLast(dl->dot->diritems, sizeof(struct diritem));

            /* make copy of lowercased filename */
            pfile->name = gmem_get(hHeap, lstrlen(resp.szFile)+1);
            lstrcpy(pfile->name, resp.szFile);
            AnsiLowerBuff(pfile->name, lstrlen(pfile->name));

            pfile->direct = dl->dot;
            pfile->size = resp.ulSize;
            pfile->ft_lastwrite = resp.ft_lastwrite;
            pfile->checksum = resp.ulSum;
            pfile->sumvalid = dl->bSum;

            // no errors yet
            pfile->fileerror = FALSE;
            pfile->localname = NULL;

            break;

        case SSRESP_DIR:
            dl->bFile = FALSE;
            break;
        default:
            wsprintf(msg, "Bad code from checksum server:%d", resp.lCode);
            TRACE_ERROR(msg, FALSE);

            /* error as first response means we are getting a null list -
             * close the pipe (without waiting for completion)
             * and abort this scan.
             */
            CloseHandle(dl->hpipe);
            dl->dot->bScanned = TRUE;
            return(FALSE);

    }
    return(TRUE);
} /* dir_remoteinit */

/*
 * return the next diritem on the list, for a remote list.
 *
 * if there are any on the list, pass the next after cur (or the first if
 * cur is NULL). If at end of list, and bScanned is not true, try to
 * get another response from the remote server.
 */
DIRITEM
dir_remotenext(
               DIRLIST dl,
               DIRITEM cur
               )
{
    DIRITEM pfile;
    SSNEWRESP resp;

    if (dl == NULL) {
        return(NULL);
    }

    /* are there any more on the list ? */
    if (cur == NULL) {
        pfile = List_First(dl->dot->diritems);
    } else {
        pfile = List_Next(cur);
    }
    if (pfile != NULL) {
        return(pfile);
    }

    if (dl->dot->bScanned) {
        /* we have completed the scan - no more to give */
        return(NULL);
    }

    for (;;) {
        /* repeat until  we get a file that is interesting or
         * hit the end of the list
         */
        if (bAbort) return NULL;  /* user requested abort */

        if (!ss_getresponse(dl->hpipe, &resp)) {
            TRACE_ERROR("checksum server connection lost", FALSE);
            dl->dot->bScanned = TRUE;
            return(NULL);
        }

        switch (resp.lCode) {

            case SSRESP_END:
                /* end of scan */
                ss_terminate(dl->hpipe);
                dl->dot->bScanned = TRUE;
                return(NULL);

            case SSRESP_ERROR:
            case SSRESP_CANTOPEN:
                /* alloc a new item at end of list */
                /* same as next case now except sumvalid is FALSE
                 * and fileerror is true
                 */
                pfile = List_NewLast(dl->dot->diritems, sizeof(struct diritem));

                /* make copy of lowercased filename */
                pfile->name = gmem_get(hHeap, lstrlen(resp.szFile)+1);
                lstrcpy(pfile->name, resp.szFile);
                AnsiLowerBuff(pfile->name, lstrlen(pfile->name));

                pfile->direct = dl->dot;
                pfile->size = resp.ulSize;
                pfile->ft_lastwrite = resp.ft_lastwrite;
                pfile->checksum = resp.ulSum;
                pfile->sumvalid = FALSE;
                pfile->fileerror = TRUE;
                pfile->localname = NULL;

                return(pfile);
            case SSRESP_FILE:
                /* alloc a new item at end of list */
                pfile = List_NewLast(dl->dot->diritems, sizeof(struct diritem));

                /* make copy of lowercased filename */
                pfile->name = gmem_get(hHeap, lstrlen(resp.szFile)+1);
                lstrcpy(pfile->name, resp.szFile);
                AnsiLowerBuff(pfile->name, lstrlen(pfile->name));

                pfile->direct = dl->dot;
                pfile->size = resp.ulSize;
                pfile->ft_lastwrite = resp.ft_lastwrite;
                pfile->checksum = resp.ulSum;
                pfile->sumvalid = dl->bSum;
                pfile->fileerror = FALSE;
                pfile->localname = NULL;

                return(pfile);

            case SSRESP_DIR:
                dl->bFile = FALSE;
                break;
        }
    }
    // return(NULL); - unreachable!
} /* dir_remotenext */


/* ---- helpers ----------------------------------------------------------- */

BOOL iswildpath(LPCSTR pszPath)
{
    if (strchr(pszPath, '*') || strchr(pszPath, '?'))
        return TRUE;

    if (!(pszPath[0] && pszPath[0] == '/' && pszPath[1] && pszPath[1] == '/'))
    {
        DWORD dw;

        dw = GetFileAttributes(pszPath);
        if (dw != (DWORD)-1 && (dw & FILE_ATTRIBUTE_DIRECTORY))
            return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\windiff\section.c ===
/*
 * section.c
 *
 * manage sections of lines, and lists of sections.
 *
 * a section is a data type that represents a contiguous block of lines
 * of the same state (all unmatched, or all matched to a contiguous block of
 * lines). A section can link up matching lines within the section.
 *
 * section list functions can make and match lists of sections from lists of
 * lines, and create a composite list by combining sections from two lists
 * to create a list that 'best represents' the similarities and differences
 * between the two lists of lines.
 *
 * Assumptions: the lines passed in are on a list (can be traversed with
 *   List_Next() etc. Line numbering using the section_get*basenr()
 *   functions work only if lines are numbered sequentially in ascending order.
 *
 * Geraint Davies, July 92
 */

#include <windows.h>
#include <stdlib.h>
#include <string.h>

#include <gutils.h>
#include <tree.h>

#include "state.h"
#include "windiff.h"
#include "wdiffrc.h"

#include "list.h"
#include "line.h"
#include "section.h"

#ifdef trace
extern BOOL bTrace;  /* in windiff.c.  Read only here */
#endif //trace

/*
 * a section handle (SECTION) is a pointer to one of these structures
 */
struct section {
        LINE first;             /* first line in section */
        LINE last;              /* last line in section */

        BOOL bDiscard;          /* true if not alloc-ed on list */

        SECTION link;           /* we match this section */
        SECTION correspond;     /* we correspond to this section, but
                                 * don't match it
                                 */

        int state;              /* compare state for section */

        int leftbase;           /* nr in original left list of first line*/
        int rightbase;          /* nr in original right list of first line*/
};

/* --- function prototypes ------------------------------------------*/

TREE section_makectree(SECTION sec);
BOOL section_expandanchor(SECTION sec1, LINE line1, SECTION sec2, LINE line2);



/*-- external functions ------------------------------------------------- */

/*
 * make a new section, given handles to a first and last line.
 *
 * a section must be at least one line long. The lines passed in must be
 * on a list in order.
 *
 * if the list parameter is non-null, we will allocate the section struct
 * on the list. otherwise we will alloc it from gmem_get(hHeap). We remember
 * this in the bDiscard flag for section_delete, so that we only
 * hand back to gmem_free memory that we got.
 */
SECTION
section_new(LINE first, LINE last, LIST list)
{
        SECTION sec;

        /* alloc the sec and remember where we alloc-ed it */
        if (list)
        {
            sec = (SECTION) List_NewLast(list, sizeof(struct section));
            if (!sec)
                return NULL;
            sec->bDiscard = TRUE;
        }
        else
        {
            sec = (SECTION) gmem_get(hHeap, sizeof(struct section));
            if (!sec)
                return NULL;
            sec->bDiscard = FALSE;
        }

        sec->first = first;
        sec->last = last;
        sec->link = NULL;
        sec->correspond = NULL;
        sec->state = 0;
        sec->leftbase = 1;
        sec->rightbase = 1;

        return(sec);
}

/*
 * discard a section. free all associated memory (not the line list).
 * free up the section itself if it was not alloc-ed on a list.
 */
void
section_delete(SECTION section)
{
        if (section->bDiscard) {
                gmem_free(hHeap, (LPSTR) section, sizeof(struct section));
        }
}




/*
 * match up two sections: match all lines that
 * are unique and identical between the two sections.
 *
 * we use a tree of line handles, keyed by the line hash code. We use a
 * ctree, which keeps a count for multiple identical keys. This allows
 * us to rapidly find lines that are unique within this section.
 * We build two of these trees (one for each line list). For each line
 * that is unique in both trees, we attempt to link the lines.
 *
 * we also attempt to link the first and last line of the section.
 *
 * for each line we successfully link, we spread up and down from
 * this anchor point attempting to link lines.
 *
 * we return true if we linked any lines
 *
 * This routine may be called more than once on the same list of lines.
 * In matching lines we want to find unique, *unmatched* lines: so we only
 * insert lines into the ctree if they are currently unlinked.
 *
 * ReSynch means accept lines which occur AT LEAST once on each side rather than
 * EXACTLY once on each side.  In this case we associate the first occurrence
 * on one side with the first occurrence onthe other.
 *
 * We might ideally keep track of which sections match dubiously and use
 * this to resolve which sections we treat as matched and which as moved
 * when we are forced to make a choice.  Here we are only making links
 * between LINES, not sections, so it makes it a bit tricky.
 */
BOOL
section_match(SECTION sec1, SECTION sec2, BOOL ReSynch)
{
        TREE ctleft, ctright;
        LINE line, line2;
        BOOL bLinked = FALSE;


        if ((sec1 == NULL) || (sec2 == NULL)) {
                return(FALSE);
        }

        if ((sec1->first == NULL) || (sec2->first == NULL)) {
                return(FALSE);
        }
        /* ASSERT if first is non-null, so is last */

        /* attempt to link the first line of each file, and
         * if matched, expand as long as we keep matching
         */
        bLinked |= section_expandanchor(sec1, sec1->first, sec2, sec2->first);


        /* build a tree of lines, indexed by the line hashcode.
         * a ctree will hold only the first value of any given key, but
         * it will keep track of the number of items inserted on this key.
         * thus we can keep count of the number of times this line
         * (or at least this hashcode) appears.
         */
        ctleft = section_makectree(sec1);
        ctright = section_makectree(sec2);

        /* for each unlinked line in one list (doesn't matter which), find if
         * it appears once only in each list. if so, link, and expand
         * the link to link lines before and after the matching line
         * as long as they continue to match.
         *
         * If ReSynch is set then accept lines which occur more than once in
         * each file (this matches the first copy in each file of lines which
         * are the same, but are non unique.  Heuristic: if the lines are short
         * (8 chars or fewer) then don't accept them.  It can waste a lot
         * of time matching spurious {, } or blank lines.
         * Ideally we could do with at least 8 non-blank chars.
         * "       }" is still not a good candidate.  Later.  Maybe.
         */
        for (line = sec1->first; line != NULL; line = List_Next(line)) {

                if (  (line_getlink(line) == NULL)
                   && (  ReSynch
                      ?  (  (ctree_getcount(ctleft, line_gethashcode(line)) >= 1)
                         && (ctree_getcount(ctright, line_gethashcode(line)) >= 1)
                         && (line_gettextlen(line) > 8)
                         )
                      :  (  (ctree_getcount(ctleft, line_gethashcode(line)) == 1)
                         && (ctree_getcount(ctright, line_gethashcode(line)) == 1)
                         )
                      )
                   ){

                        /* lines match */
                        line2 = * ((LINE FAR *)ctree_find(ctright,
                                        line_gethashcode(line)));
                        bLinked |= section_expandanchor(sec1, line, sec2, line2);
                }

                if (line == sec1->last) {
                        break;
                }
        }

        /* delete the ctrees */
        ctree_delete(ctleft);
        ctree_delete(ctright);


        /* attempt to link the last lines of each file and
         * expand upwards
         */
        bLinked |= section_expandanchor(sec1, sec1->last, sec2, sec2->last);

        return(bLinked);
} /* section_match */

/* -- accessor functions --------------*/

/*
 * get a handle to the first line in this section
 */
LINE
section_getfirstline(SECTION section)
{
        if (section == NULL) {
                return(NULL);
        }
        return(section->first);
}

/*
 * return a handle to the last line in a section
 */
LINE
section_getlastline(SECTION section)
{
        if (section == NULL) {
                return(NULL);
        }
        return(section->last);
}

/*
 * return a handle to the linked section, if any. A linked section
 * is a section whose lines all match the lines in this section
 */
SECTION
section_getlink(SECTION section)
{
        if (section == NULL) {
                return NULL;
        }
        return(section->link);
}

/*
 * return a handle to the corresponding section (a section which
 * corresponds in position to this one, but whose lines do not match).
 */
SECTION
section_getcorrespond(SECTION section)
{
        if (section == NULL) {
                return(NULL);
        }
        return(section->correspond);
}

/* get the state for this section */
int
section_getstate(SECTION section)
{
        if (section == NULL) {
                TRACE_ERROR("SECTION: null section in getstate call", FALSE);
                return(0);
        }
        return(section->state);
}

/* set the state for this section */
void
section_setstate(SECTION section, int state)
{
        section->state = state;
}

/* return the number of lines in the section. Here we assume that
 * lines in the section are number sequentially in ascending order, and we
 * simply look at the first and last line numbers.
 */
int
section_getlinecount(SECTION section)
{
        if (section->last==NULL && section->first==NULL)
                return 0;   /* the thing below would return 1! */
        if (section->first==NULL || section->last==NULL)
                TRACE_ERROR("SECTION: null first or last (but not both) in getlinecount call", FALSE);

        return(line_getlinenr(section->last) -
                        line_getlinenr(section->first)) + 1;
}

/*
 * -- base line numbers --
 *
 * these functions only apply to sections in the composite list. When creating
 * a composite section, we record the line number of the first line in each
 * of the two sections we built it from. Thus we can calculate the
 * line number of any line in the section in either file it appeared in,
 * by adding the index of the line within the section to the base line
 * number.
 */
int
section_getleftbasenr(SECTION section)
{
        return(section->leftbase);
}

void
section_setleftbasenr(SECTION section, int base)
{
        section->leftbase = base;
}

int
section_getrightbasenr(SECTION section)
{
        return(section->rightbase);
}

void
section_setrightbasenr(SECTION section, int base)
{
        section->rightbase = base;
}


/* --- section list functions -------------------------------------*/

/* Theory of handling blank lines:
|                                      ??? WHERE IS THE BEST PLACE FOR THIS COMMENT ???
|  If ignore_blanks is FALSE then a blank is just another character.
|  If it is TRUE then we will normally include unmatched blanks in whatever
|  section is surrounding them.  It would be nice if we could arrange to
|  never have a section that is only unmatched blanks, but (at least at
|  the start of the file) it can happen.  Tough.
|
|  Note that there are two DIFFERENT blank handling techniques:
|  In the first phase of the comparison when we are just trying to match up
|  lines, we skip over blank lines both forwards and backwards from an anchor.
|  When we are making real sections for display we only go forwards.
|  This results in a possible anomaly at the top of the whole file where
|  there could be some blanks which do not match and which can only possibly
|  be described as the start of a section.
|  For this reason, we label the sections with their state as early as possible
|  and go by that rather than by the presence or absence of link fields.
|  (It takes some scanning to find a link.  The first line in the section
|  could be a blank).
*/


/* return a LINE which is the last line in an unmatched section
   containing (probably starting with) Line.
   Note that it does not necessarily make progress.

   As noted above, even if blank lines are being ignored, we don't
   mind tagging them onto the end of an already unmatching section.
   This means we carry on until we find the first real link
*/
LINE FindEndOfUnmatched(LINE line)
{
        LINE next;

        for (; ; )
        {       next = List_Next(line);
                if (next==NULL) return line;
                if (line_getlink(next)!=NULL) return line;
                line = next;
        }
} /* FindEndOfUnmatched */


/* An ignorable line is a blank line with no link and ignore_blanks set

   Given that line is initially not NULL and not ignorable:
   If line is the last line in the list then return NULL
   Else If ignore_blanks is FALSE then return the next line after line
   else return next line which has a link or which is non-blank.
   If there is no such line then return the last line in the list.

   Note that this does always make progress (at the cost of
   sometimes returning NULL).
*/
LINE NextNonIgnorable(LINE line)
{       LINE next;
        if (  line_getlink(line)==NULL
           && ! (ignore_blanks && line_isblank(line))
           )
                TRACE_ERROR("!!Bad call to NextNonIgnorable!!", FALSE);

        next = List_Next(line);
        if (next==NULL) return NULL;
        for (; ; ) {
                line = next;
                if (  line_getlink(line)!=NULL) return line;
                if (! ignore_blanks)            return line;
                if (! line_isblank(line))       return line;
                next = List_Next(line);
                if (next==NULL) return line;
        }
} /* NextNonIgnorable */


/* Given that line is either linked or an ignorable blank:
   Return a LINE which is the last line in a matched section
   containing (probably starting with) line.
   This could mean returning the line we were given.

   If the lines linked to are not consecutive then the section ends.
   If blanks are being ignored, then any blank line is deemed
   to match (even if it doesn't match).  In this case we need the
   links of the lines before and after the blanks to be consecutive
   in order to carry on.  There could be blank lines on either or both
   ends of the links.
*/
LINE FindEndOfMatched(LINE line)
{
        LINE next;              /* next non-ignored or linked line */
        LINE nextlink;          /* next in other file */

        /* The basic algorithm is to set up next and nextlink to point to
           candidate lines.  Examine them.  If they are good then step
           on to them, else return the line one before.
           There are confusion factors associated with the beginning and
           end of the file.
        */


        if (line==NULL) TRACE_ERROR("FindEndOfMatched called with NULL", FALSE);

        /* ASSERT( line is either an ignorable blank or else is linked) */

        /* As a section (at least at the start of the file) might start
           with an ignored non-linked blank line, first step over any such
        */
        if( line_getlink(line)==NULL && line_isblank(line) ) {
                next = NextNonIgnorable(line);

                /* There are unfortunately 6 cases to deal with
                   * marks where next will be. * against eof means next==NULL
                   blank(s) refer to ignorable unlinked blanks.
                          A         B        C        D        E        F
                   line-> xxxxx     xxxxx    xxxxx    xxxxx    xxxxx    xxxxx
                         *unlinked  blanks  *linked   blanks  *eof     *blanks
                                   *unlinked         *linked            eof

                   next could be:

                      null - case E => return line
                      unlinked ignorable blank - case F => return that blank line
                      unlinked other - cases A,B return prev(that unlinked line)
                      linked - cases C,D continue from that linked line
                */
                if (next==NULL) return line;
                if (line_getlink(next)==NULL) {
                        if (ignore_blanks && line_isblank(next)) {
                                /*TRACE_ERROR("FindEndOfMatched found an all blank section", FALSE);*/
                                return next;
                        }
                        return List_Prev(next);
                }

                line = next;
        }

        /* we have stepped over inital blanks and now do have a link */
        if (line_getlink(line)==NULL)
                TRACE_ERROR("!!FindEndOfMatched -- no link!!", FALSE);

        for ( ; ; ) {

                next = NextNonIgnorable(line);
                /* Same 6 cases - basically same again */
                if (next==NULL) return line;
                if (line_getlink(next)==NULL) {
                        if (ignore_blanks && line_isblank(next)) {
                                /*TRACE_ERROR("FindEndOfMatched found an all blank section.", FALSE);*/
                                return next;
                        }
                        return List_Prev(next);
                }

                nextlink = NextNonIgnorable(line_getlink(line));

                /* WEAK LOOP INVARIANT
                   line is linked.
                   next is the next non-ignorable line in this list after line.
                   nextlink is the next non-ignorable line after link(line)
                                        in the other list (could be NULL etc).
                */
                if (line_getlink(next) != nextlink) return List_Prev(next);

                line = next;
        }
} /* FindEndOfMatched */


/*
 * make a list of sections by traversing a list of lines. consecutive
 * linked lines that are linked to consecutive lines are put in a single
 * section. blocks of unlinked lines are placed in a section.
 * If ignore_blanks is set then we first try to link them as normal.
 * but if they won't link then we just skip over them and keep them
 * in the same section.
 *
 * left must be set TRUE iff the list of lines is a left hand section.
 * returns a handle to a list of sections
 */
LIST
section_makelist(LIST linelist, BOOL left)
{
        LINE line1, line2;
        LIST sections;
        BOOL matched;
        SECTION sect;

        /* make an empty list of sections */
        sections = List_Create();

        /* for each line in the list */

        List_TRAVERSE(linelist, line1) {

                /* is it linked ? */

                if( line_getlink(line1) != NULL
                  || ( ignore_blanks && line_isblank(line1))
                  ) {
                        line2 = FindEndOfMatched(line1);
                        matched = TRUE;
                } else {
                        line2 = FindEndOfUnmatched(line1);
                        matched = FALSE;
                }

                /* create the section and add to list */
                sect = section_new(line1, line2, sections);
                sect->state = (matched ? STATE_SAME
                                       : left ? STATE_LEFTONLY
                                              : STATE_RIGHTONLY
                              );

#ifdef trace
                {       char msg[80];
                        wsprintf( msg
                                , "Created section: lines %d..%d of %s %s\r\n"
                                , line_getlinenr(line1)
                                , line_getlinenr(line2)
                                , (left ? "left" : "right")
                                , (matched ? "matching" : "non-matched")
                                );
                        if (bTrace) Trace_File(msg);
                }
#endif

                /* advance to end of section (no-op if 1 line section) */
                line1 = line2;
        }

        return(sections);
} /* section_makelist */



/*
 * delete a list of sections
 *
 * sections have no dangling pointers, so all we do is delete the list
 */
void
section_deletelist(LIST sections)
{
        List_Destroy(&sections);
}

/* Return the first line in the range first..last
   which has a link.  Return last if none of them have a link.
   List_Next must lead from first to last eventually.
   It is legit for last to be NULL.
*/
LINE FindFirstWithLink(LINE first, LINE last)
{
        /* The strategy of including blanks on the ENDS of sections rather
           than the start of new sections will mean that this function
           usually strikes gold immediately.  A file with a leading
           blank section is its raison d'etre.
        */
#ifdef trace
        LINE hold = first;
#endif
        while (line_getlink(first)==NULL && first!=last)
                first = List_Next(first);

        if (line_getlink(first)==NULL) {
#ifdef trace
                char msg[80];
                wsprintf( msg
                        , "???FindFirstWithLink found an unlinked section: %d..%d\r\n"
                        , line_getlinenr(hold)
                        , line_getlinenr(first)
                        );
                if (bTrace) Trace_File(msg);
#endif
        }
        return first;
} /* FindFirstWithLink */


/*
 * match up two lists of sections. establish links between sections
 * that match, and establish 'correspondence' between sections that
 * are in the same place, but don't match.
 *
 * for each pair of corresponding sections, we also call section_match
 * to try and link up more lines.
 *
 * we return TRUE if we made any more links between lines, or false
 * otherwise.
 *
 */
BOOL
section_matchlists(LIST secsleft, LIST secsright, BOOL bDups)
{
        BOOL bLinked = FALSE;
        SECTION sec1, sec2;

        /* match up linked sections - We know whether a section is
           supposed to link from its state, but we don't know what section
           it links to.  Also we can have sections which are defined to
           be matching but actually contain nothing but ignorable
           blank lines
        */

        /*  for each linked section try to find the section  linked to it. */
        List_TRAVERSE(secsleft, sec1) {
                if (sec1->state==STATE_SAME) {
                        LINE FirstWithLink = FindFirstWithLink(sec1->first, sec1->last);
#ifdef trace
                        {       char msg[80];
                                wsprintf( msg
                                        , "matchlists left matching section %d..%d \r\n"
                                        , line_getlinenr(sec1->first)
                                        , line_getlinenr(sec1->last)
                                        );
                                if (bTrace) Trace_File(msg);
                        }
#endif
                        List_TRAVERSE(secsright, sec2) {
                                if ( sec2->state==STATE_SAME
                                   && line_getlink(FirstWithLink)
                                        == FindFirstWithLink(sec2->first, sec2->last)) {
                                            break;
                                }
                        }
                        /* sec2 could be NULL if sec1 is all allowable blanks */
                        if (sec2!=NULL) {
                                sec1->link = sec2;
                                sec2->link = sec1;
#ifdef trace
                                {       char msg[80];
                                        wsprintf( msg
                                                , "matchlists right matching section is %d..%d \r\n"
                                                , line_getlinenr(sec2->first)
                                                , line_getlinenr(sec2->last)
                                                );
                                        if (bTrace) Trace_File(msg);
                                }
#endif
                        }
                }
        }

        /* go through all unmatched sections. Note that we need to complete
         * the link-up of matching sections before this, since we need
         * all the links in place for this to work.
         */

        List_TRAVERSE(secsleft, sec1) {
                SECTION secTemp;

                if (sec1->state == STATE_SAME) {
                        /* skip the linked sections */
                        continue;
                }

                /* check that the previous and next sections, if
                 * they exist, are linked. this should not fail since
                 * two consecutive unlinked sections should be made into
                 * one section
                 */
                secTemp = List_Prev(sec1);
                if (secTemp && secTemp->state!= STATE_SAME) {
                        TRACE_ERROR("consecutive unlinked sections", FALSE);
                        continue;
                }
                secTemp = List_Next(sec1);
                if (secTemp && secTemp->state!= STATE_SAME) {
                        TRACE_ERROR("consecutive unlinked sections.", FALSE);
                        continue;
                }

                /* find the section that corresponds to this - that is, the
                 * section following the section linked to our previous section.
                 * we could be at beginning or end of list.
                 */
                if (List_Prev(sec1) != NULL) {
                        SECTION secOther;
                        secOther = section_getlink(List_Prev(sec1));
                        if (secOther==NULL)
                                continue;

                        sec2 = List_Next(secOther);

                        /* check this section is not linked */
                        if ((sec2 == NULL) || (section_getlink(sec2) != NULL)) {
                                continue;
                        }

                        /* check that the section after these are linked
                         * to each other (or both are at end of list).
                         */
                        if (List_Next(sec1) != NULL) {

                                if (section_getlink(List_Next(sec1)) !=
                                    List_Next(sec2)) {
                                        continue;
                                }
                        } else {
                                if (List_Next(sec2) != NULL) {
                                        continue;
                                }
                        }

                } else if (List_Next(sec1) != NULL) {
                        SECTION secOther;
                        secOther = section_getlink(List_Next(sec1));
                        if (secOther==NULL)
                                continue;

                        sec2 = List_Prev(secOther);

                        /* check this section is not linked */
                        if ((sec2 == NULL) || (section_getlink(sec2) != NULL)) {
                                continue;
                        }

                        /* check that the section before these are linked
                         * to each other (or both are at start of list).
                         */
                        if (List_Prev(sec1) != NULL) {

                                if (section_getlink(List_Prev(sec1)) !=
                                    List_Prev(sec2)) {
                                        continue;
                                }
                        } else {
                                if (List_Prev(sec2) != NULL) {
                                        continue;
                                }
                        }
                } else {
                        /* there must be at most one section in each
                         * file, and they are unmatched. make these correspond.
                         * (Though I don't think this would ever do anything except
                         * waste time by trying to link that which has already failed)
                         * ???
                         */
                        sec2 = List_First(secsright);
                }


                /* make the correspondence links
                 * we will want these for  zebra striping
                 */
                if ((sec1 != NULL) && (sec2 != NULL)) {
                        sec1->correspond = sec2;
                        sec2->correspond = sec1;
                }

#ifdef trace
                {       // This is commented out because it CAN trap (and will
                        // on the EMPTY test case in test.a and test.b
                        //char msg[80];
                        //wsprintf( msg
                        //      , "recursive section_match %d..%d <-> %d..%d\r\n"
                        //      , line_getlinenr(sec1->first)
                        //      , line_getlinenr(sec1->last)
                        //      , line_getlinenr(sec2->first)
                        //      , line_getlinenr(sec2->last)
                        //      );
                        //if (bTrace) Trace_File(msg);
                }
#endif

                /* attempt to link up lines */
                if (section_match(sec1, sec2, bDups)) {
                        bLinked = TRUE;
                }
        }

        return(bLinked);
} /* section_matchlists */

/*
 * add a section to the composite list. called from makecomposites
 * to copy a section, add it to the composite list and set the state,
 * leftbase and rightbase.   Note that the state could be STATE_SAME
 * with a NULL section on the left.  May NOT call with STATE_SAME and
 * a NULL right section!
 *
 */
void
section_takesection(LIST compo, SECTION left, SECTION right, int state)
{
        SECTION newsec;
        SECTION sec = NULL;

        /* select which section is being output, and change the state
         * to indicate it has been output
         */
        switch(state) {
        case STATE_SAME:
                /* both the same. we mark both as output, and
                 * take the right one.  It is possible that the
                 * left one could be NULL (an ignorable blank section)
                 */
                if (left!=NULL) left->state = STATE_MARKED;
                right->state = STATE_MARKED;
                sec = right;
                break;

        case STATE_LEFTONLY:
        case STATE_MOVEDLEFT:
                sec = left;
                left->state = STATE_MARKED;
                break;

        case STATE_RIGHTONLY:
        case STATE_MOVEDRIGHT:
                sec = right;
                right->state = STATE_MARKED;
                break;
        /* other cases e.g. SIMILARLEFT should not occur! */
        }


        /* create a new section on the list */
        newsec = section_new(sec->first, sec->last, compo);

        newsec->state = state;


        if (left != NULL) {
                newsec->leftbase = line_getlinenr(left->first);
        } else {
                newsec->leftbase = 0;
        }

        if (right != NULL) {
                newsec->rightbase = line_getlinenr(right->first);
        } else {
                newsec->rightbase = 0;
        }

} /* section_takesection */

/********************************************************************/
/* Zebra striping                                                   */
/********************************************************************/
#ifdef trace
static DWORD ZebraTicks = 0; /* total tick count spent hunting for zebras */
#endif

typedef BYTE bitmap[32];   /* 256 bits.  address the ith bit as m[i/8] & (1<<i%8) */

/* MakeMap
   Turn a string into a bitmap showing its character usage.  ANSI only!
   The bit in the map is set if the corresponding character occurs
   at least once anywhere in the string.
*/
void MakeMap(bitmap bm, LPSTR str)
{   int i;
    for (i=0; i<32; ++i)  bm[i] = 0;   /* clear it (yeah, could use memset) */
    for (i=0; str[i]!='\0'; ++i)       /* for each char */
    {   UINT v = ((UINT)str[i]) & 0x000000ff;   /* 0..256, No negatives! */
        bm[v/8] = bm[v/8] | (1<<v%8);
    }
} /* MakeMap */

/* AndMaps
   Set the bit in res whenever the corresponding bit is set
   in both a and b
*/
void AndMaps(bitmap res, bitmap a, bitmap b)
{   int i;
    for (i=0; i<32; ++i)
        res[i] = (char)(a[i] & b[i]);
}

/* OrMaps
   Set the bit in res whenever the corresponding bit is set
   in either a or b
*/
void OrMaps(bitmap res, bitmap a, bitmap b)
{   int i;
    for (i=0; i<32; ++i)
        res[i] = (char)(a[i] | b[i]);
}

/* BitsInMap
   return the number of bits set on in bm
*/
int BitsInMap(bitmap bm)
{   int i;
    int j;
    int cb = 0;                  /* bit count */

    for (i=0; i<32; ++i)         /* for each byte in bm */
    {  for( j=0; j<8; ++j)       /*    for each bit in byte */
       {  if (bm[i] & (1<<j))    /*    if the bit is set  */
              ++cb;
       }
    }
    return cb;
} /* BitsInMap */

/*------------------------------------------------------------------------------
|  Return TRUE iff left and right match fuzzily.
|  Fuzzy matching is implemented as follows.
|
|  Create a bitmap with one bit for each character in the ANSI set.
|  (This is 32 bytes long).  Clear it, and then OR in bits for each
|  character actually found in string one and then do the same again
|  for string two.
|  AND the two bit maps to get the characters which occur in both lines and
|  OR them to get the total number of different characters in either line.
|  Count the number of bits in each and work off the ratio common/total.
|  If this ratio exceeds a magic number of 3/4 then say they fuzzily match.
|
|  You've probably noticed that this is an application for
|           COUNTING THE BITS IN A BYTE!
 -------------------------------------------------------------------------------*/
BOOL LinesMatch(LINE Left, LINE Right)
{   LPSTR LText = line_gettext(Left);
    LPSTR RText = line_gettext(Right);
    bitmap bmLeft;
    bitmap bmRight;
    bitmap bmBoth;
    bitmap bmEither;
    int nBoth;
    int nEither;

    MakeMap(bmLeft, LText);
    MakeMap(bmRight, RText);
    AndMaps(bmBoth, bmLeft, bmRight);
    OrMaps(bmEither, bmLeft, bmRight);
    nBoth = BitsInMap(bmBoth);
    nEither = BitsInMap(bmEither);

    return  (nBoth*4 >= nEither*3);    /* magic ratio is 3/4 */
} /* LinesMatch */


/*
 * add left and right sections to the comnposite list.  These sections
 * do not contain any matching lines, but do correspond, so here is
 * where we can do a fuzzy comparison and decide whether to zebra
 * them or not.
 *
 * If we retain the current structure of the composite list being a
 * list of sections rather than lines, then we might get rather a lot
 * of sections.  Do we care?  We need to build a new section here
 * for every line that we zebra, unpicking the old sections as we do it.
 *
 * At the moment it zebra stripes the lines as long as they keep
 * (fuzzily) matching.  Once there is a mismatch it takes the rest
 * as a block with no attempt to resynch until the next exact match.
 * We could be craftier, but I think we are already getting most of the
 * value from zebra striping.
 */
void TakeTwoSections(LIST compo, SECTION left, SECTION right)
{
        /* Algorithm:
           While there is something on each side,
              if the next lines match
              then take one line from each and make them into sections.
              else take everything that's left
           Finally take everything that's left (occurs if all matched until
                                                one side ran out)
        */

        SECTION NewL;
        SECTION NewR;
        LINE LLine = left->first;      /* first line left to process in left */
        LINE RLine = right->first;     /*   "    "    "   "   "      " right */

#ifdef trace
        DWORD Ticks = GetTickCount();  /* profiling */
#endif

        left->state = STATE_MARKED;
        right->state = STATE_MARKED;

        while(left!=NULL && right !=NULL) {

            if (LinesMatch(LLine, RLine)) {
                    NewL = section_new(LLine, LLine, compo);
                    NewL->state = STATE_SIMILARLEFT;
                    NewL->leftbase = line_getlinenr(LLine);
                    NewL->rightbase = line_getlinenr(RLine);

                    NewR = section_new(RLine, RLine, compo);
                    NewR->state = STATE_SIMILARRIGHT;
                    NewR->leftbase = line_getlinenr(LLine);
                    NewR->rightbase = line_getlinenr(RLine);

                    if (LLine == left->last) left = NULL;  /* done */
                    else LLine = List_Next(LLine);
                    if (RLine == right->last) right = NULL;  /* done */
                    else RLine = List_Next(RLine);
            } else {
                   /* lost synch - take all the rest with no more zebra stuff */
                    NewL = section_new(LLine, left->last, compo);
                    NewL->state = STATE_LEFTONLY;
                    NewL->leftbase = line_getlinenr(LLine);
                    NewL->rightbase = 0;
                    left = NULL;  /* done */

                    NewR = section_new(RLine, right->last, compo);
                    NewR->state = STATE_RIGHTONLY;
                    NewR->rightbase = line_getlinenr(RLine);
                    NewR->leftbase = 0;
                    right = NULL;  /* done */
            }
        }

        if (left!=NULL) {
            NewL = section_new(LLine, left->last, compo);
            NewL->state = STATE_LEFTONLY;
            NewL->leftbase = line_getlinenr(LLine);
            NewL->rightbase = 0;
        }
        if (right!=NULL) {
            NewR = section_new(RLine, right->last, compo);
            NewR->state = STATE_RIGHTONLY;
            NewR->rightbase = line_getlinenr(RLine);
            NewR->leftbase = 0;
        }

#ifdef trace
        Ticks = GetTickCount()-Ticks;
        ZebraTicks += Ticks;
        {   char Msg[80];
            wsprintf(Msg, "Zebra time %d, total zebra time %d\n", Ticks, ZebraTicks);
            Trace_File(Msg);
        }
#endif

} /* TakeTwoSections */

/*
 * make a composite list of sections by traversing a list of sections.
 *
 * return a handle to a list of sections.
 *
 * during this, set state, leftbase and rightbase for sections.
 *
 * This function creates a list that corresponds to the 'best' view
 * of the differences between the two lists. We place sections from the
 * two lists into one composite list. sections that match each other are only
 * inserted once (from the right list). sections that match, but in different
 * positions in the two lists are inserted twice, once in each position, with
 * status to indicate this. unmatched sections are inserted in the correct
 * position.
 *
 * - take sections from the left list until the section is linked to one not
 *   already taken.
 * - then take sections from right until we find a section linked to one not
 *   already taken.
 * - if the two sections waiting are linked to each other, take them both
 *   (once- we take the right one and advance past both).
 *
 * - now we have to decide which to take in place and which to declare
 *   'moved'. consider the case where the only change is that the first line
 *   has been moved to the end. We should take the first line (as a move),
 *   then the bulk of the file (SAME) then the last line (as a move). Hence,
 *   in difficult cases, we take the smaller section first, to ensure that
 *   the larger section is taken as SAME.
 *
 *   to indicate which section has been output, we set the state field
 *   to STATE_MARKED once we have taken it.   States in left and right
 *   lists are of no further interest once we have built the composite.
 *
 *   Up to this point we have worked off the STATE of a section.  By now
 *   all the section links are in place, so we can use them too.
 */
LIST
section_makecomposite(LIST secsleft, LIST secsright)
{
        SECTION left, right;
        LIST compo;

        /* make an empty list for the composite */
        compo = List_Create();

        left = List_First(secsleft);
        right = List_First(secsright);

        while ( (left != NULL) || (right != NULL)) {

                if (left == NULL) {
                        /* no more in left list - take right section */
                        /* is it moved or just unmatched ? */
                        if (right->link == NULL) {
                                section_takesection(compo, NULL, right, STATE_RIGHTONLY);
                                right = List_Next(right);
                        } else {
                                section_takesection(compo, right->link, right, STATE_MOVEDRIGHT);
                                right = List_Next(right);
                        }
                } else if (right == NULL) {
                        /* right list empty - must be left next */

                        /* is it moved or just unmatched ? */
                        if (left->link == NULL) {
                                section_takesection(compo, left, NULL, STATE_LEFTONLY);
                                left = List_Next(left);
                        } else {
                                section_takesection(compo, left, left->link, STATE_MOVEDLEFT);
                                left = List_Next(left);
                        }

                } else if (left->state == STATE_LEFTONLY) {
                        /* unlinked section on left */
                        if (left->correspond==right) {
                            TakeTwoSections( compo, left, left->correspond );
                            left = List_Next(left);
                            right = List_Next(right);
                        } else {
                            /* see picture below for when this might occur */
                            section_takesection(compo, left, NULL, STATE_LEFTONLY);
                            left = List_Next(left);
                        }

                } else if (left->link==NULL) {
                        /* This is an ignorable blank section on the left.
                         * We ignore it. (We will take any such from the right)
                         */
                        left = List_Next(left);

                } else if (left->link->state==STATE_MARKED) {
                        /* left is linked to section that is already taken*/
                        section_takesection(compo, left, left->link, STATE_MOVEDLEFT);
                        left = List_Next(left);

                } else  if (right->link == NULL) {
                        /* take unlinked section on right
                         * Either unmatched or ignorable blanks
                         */
                        section_takesection(compo, NULL, right, right->state);
                        right = List_Next(right);

                } else if (right->link->state==STATE_MARKED) {
                        /* right is linked to section that's already taken */
                        section_takesection(compo, right->link, right, STATE_MOVEDRIGHT);
                        right = List_Next(right);

                } else if (left->link == right) {
                        /* sections match */
                        section_takesection(compo, left, right, STATE_SAME);
                        right = List_Next(right);
                        left = List_Next(left);
                } else {
                        /* both sections linked to forward sections
                         * Original idea was to go by section size and
                         * take smallest first as a move so that larger one is
                         * unchanged.  Counter example is test file blanks2
                         *
                         *   Files     Good version    Not so good
                         *  A     A       A---A          A---A
                         *  B-   -A         ->A RR    LL B->
                         *  C | | A         ->A RR    LL C
                         *  D  -+-B       B---B       LL D
                         *  E   | c       C   c       LL E->
                         *  A---  d       D   d          A---A
                         *  A     E       E---E          A---A
                         *  A     A       A->              ->B
                         *  A             A->                c
                         *                A---A              d
                         *                A                ->E
                         *                               A---A
                         *                               A
                         *
                         * A better scheme looks at the distances marked
                         * above as RR and LL and take as moved the block that results
                         * in the shortest such distance.
                         * Let LeftDist = linenr(right->link) - linenr(left)
                         *       i.e. 5 in the example above  (the LL lines)
                         * Let RightDist = linenr(left->link) - linenr(right)
                         *       i.e. 3 in the example above  (the RR lines)
                         *
                         * if LeftDist > RightDist then treat right as moved
                         * and take it first.
                         */
                        if ( line_getlinenr(right->link->first) - line_getlinenr(left->first)
                           > line_getlinenr(left->link->first)  - line_getlinenr(right->first)
                           )
                        {
                                section_takesection(compo, right->link, right, STATE_MOVEDRIGHT);
                                right = List_Next(right);
                        } else {
                                section_takesection(compo, left, left->link, STATE_MOVEDLEFT);
                                left = List_Next(left);
                        }

                }
        }

        return(compo);
} /* section_makecomposite */

typedef LINE (APIENTRY * MOVEPROC)(LINE);

/* Update PLINE by making it point to the first non-blank
   at-or-after from but not after limit.
   If they are all blank then make it point to limit
   If from is non-blank then leave it alone.
   Return TRUE iff PLINE was updated.
   It is legit for limit to be NULL (meaning end of file).
*/
BOOL AbsorbAnyBlanks(LINE * from, LINE limit, MOVEPROC Move)
{       BOOL progress = FALSE;

        while ( (from!=NULL)
              && (line_isblank(*from))
              && (*from!=limit)
              ) {
                *from = Move(*from);
                progress = TRUE;
        }
        return progress;
} /* AbsorbAnyBlanks */


/* given an anchor point (two lines that we think should match),
 * try to link them, and the lines above and below them for as long
 * as the lines can be linked (are the same, are unlinked).
 *
 * return TRUE if we make any links.
 *
 */
BOOL
section_expandanchor(SECTION sec1, LINE line1, SECTION sec2, LINE line2)
{
        /* when a line is matched we set bChanges.  If we notice some
         * blank lines, but do NOT link any new non-blank lines, we
         * do NOT set bChanges.  (If we did it would cause a closed
         * loop as they would get noticed again next time.  line_link
         * only returns TRUE if it is a NEW link).
         * At this stage we are only interested in making links, not in
         * the size of the section that results (that fun comes later).
         * therefore trailing blanks at the end of a section are not
         * interesting and we don't look for them.
         */
        BOOL bChanges = FALSE;
        LINE left, right;

        /* We handle the section limits by using a sentinel which is one
         * past the end of the section.  (If the section ends at the end
         * of the list then the sentinel is NULL).
         */
        LINE leftend, rightend;
        leftend = List_Next(sec1->last);
        rightend = List_Next(sec2->last);

#ifdef trace
        {       char msg[120];
                wsprintf( msg, "expanding anchor at %d<->%d in sections %d..%d <-> %d..%d\r\n"
                        , line_getlinenr(line1)
                        , line_getlinenr(line2)
                        , line_getlinenr(sec1->first)
                        , line_getlinenr(sec1->last)
                        , line_getlinenr(sec2->first)
                        , line_getlinenr(sec2->last)
                        );
                if (bTrace) Trace_File(msg);
        }
#endif

        /* null lines shall not match */
        if ((line1 == NULL) || (line2 == NULL)) {
                return(FALSE);
        }

        /* check all lines forward until fail to link (because null,
         * not matching, or already linked).
         * include the passed in anchor point since this has not
         * yet been linked.
         * If blanks are ignorable then skip over any number of whole
         * blank lines.
         */
        left = line1;
        right = line2;
        for (; ; ) {
                if (line_link(left, right) ) {

                        bChanges = TRUE;
                        left = List_Next(left);
                        right = List_Next(right);
                        if (left==leftend || right==rightend) break;
                }
                else if (ignore_blanks){
                        /* even though no match, maybe an ignorable blank? */

                        BOOL moved = FALSE;
                        moved |= AbsorbAnyBlanks(&left, leftend, (MOVEPROC)List_Next);
                        moved |= AbsorbAnyBlanks(&right, rightend, (MOVEPROC)List_Next);
                        if (!moved) break; /* it didn't match and we didn't move on */
                        if (left==leftend || right==rightend) break;
                }
                else break;
        }

#ifdef trace
        {       char msg[120];
                wsprintf( msg, "marched forwards to (the line before) %d<->%d\r\n"
                        , (left==NULL ? 9999 : line_getlinenr(left))
                        , (right==NULL ? 9999 : line_getlinenr(right))
                        );
                if (bTrace) Trace_File(msg);
        }
#endif

        /* check all matches going backwards from anchor point
           but only if it was a real anchor  (could have been
           end-of-section/end-of-file and non-matching).
        */
        if (line_getlink(line1)==NULL) return bChanges;

        left = List_Prev(line1);
        right = List_Prev(line2);
        if (left==NULL || right==NULL) return bChanges;

        leftend = List_Prev(sec1->first);
        rightend = List_Prev(sec2->first);

        for (; ; ) {
                if (line_link(left, right)) {

                        bChanges = TRUE;
                        left = List_Prev(left);
                        right = List_Prev(right);
                        if (left == leftend || right == rightend) break;

                }
                else if (ignore_blanks){
                        /* even though no match, maybe an ignorable blank? */

                        BOOL moved = FALSE;
                        moved |= AbsorbAnyBlanks(&left, leftend, (MOVEPROC)List_Prev);
                        moved |= AbsorbAnyBlanks(&right, rightend, (MOVEPROC)List_Prev);
                        if (!moved) break; /* it didn't match and we didn't move on */
                        if (left==leftend || right==rightend) break;

                }
                else break;
        }

#ifdef trace
        {       char msg[120];
                wsprintf( msg, "marched backwards to (the line after) %d<->%d\r\n"
                        , (left==NULL ? 0 : line_getlinenr(left))
                        , (right==NULL ? 0 : line_getlinenr(right))
                        );
                if (bTrace) Trace_File(msg);
        }
#endif

        return(bChanges);
}


/*
 * build a ctree from the lines in the section given
 *
 * remember that we are only interested in the lines that are
 * not already linked.
 *
 * the value we store in the tree is the handle of the line. the key
 * is the line hash code
 */
TREE
section_makectree(SECTION sec)
{
        TREE tree;
        LINE line;

        /* make an empty tree */
        tree = ctree_create(hHeap);

        for (line = sec->first; line != NULL; line = List_Next(line)) {
                if (line_getlink(line) == NULL) {
                        ctree_update(tree, line_gethashcode(line),
                                        &line, sizeof(LINE));
                }
                if (line == sec->last) {
                        break;
                }
        }
        return(tree);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\windiff\section.h ===
/*
 *
 * section.h
 *
 *
 * manage sections of lines. These are contiguous blocks of lines that either
 * all match a contiguous block in another file, or are unmatched.
 *
 * a section can maintain a link to a corresponding section in another
 * file, and can establish links between matching lines in the two sections.
 *
 * a section also knows its compare state (defined in state.h). This says
 * whether it matches another section, or is matched but out of
 * sequence, or is unmatched. These are set during section_makecomposite.
 *
 * sections are held in LISTs. A list of sections can be built by functions
 * here that traverse a LIST of LINEs, or that traverse a list of
 * SECTIONs (to produce a composite list). In both cases, the lists used
 * are managed by the standard list package
 *
 *
 *
 * Geraint Davies, July 92
 */

/* handle to a section */
typedef struct section FAR * SECTION;


/* make a section, given a first and last line. We return a handle to
 * a section. If the LIST parameter is non-null, we create the section
 * at the end of the list. if list is null, we allocate the memory ourselves.
 * This affects behaviour of section_delete (we only free memory we alloc
 * ourselves).
 *
 * The first and last lines must be on a LIST, with first coming before last.
 */
SECTION section_new(LINE first, LINE last, LIST list);


/* delete a section. free up all associated memory. does NOT delete the
 * associated list of lines.
 *
 *
 * If the section was allocated on a list, it will not be deleted here,
 * only the memory hanging off it will be freed.
 */
void section_delete(SECTION section);


/* match two sections: try to match as many lines as possible between
 * the two sections
 *
 * returns TRUE if any new links between LINEs were made, or FALSE if not.
 */
BOOL section_match(SECTION section1, SECTION section2, BOOL ReSynch);

/* return the handle to the first or last line in the section. If the section
 * is one line long, these will be the same. they should never be NULL
 */
LINE section_getfirstline(SECTION section);
LINE section_getlastline(SECTION section);

/* return the handle to the linked section, if any, or NULL if not linked */
SECTION section_getlink(SECTION section);

/* return a handle to a section that corresponds to this section, but
 * does not match. corresponding sections are found in the same
 * relative position of the file, but are not identical. At least
 * one of section_getlink and section_getcorrespond will return NULL for any
 * given section
 */
SECTION section_getcorrespond(SECTION section);

/* set the compare state for this section */
void section_setstate(SECTION section, int state);


/* return the compare state for this section. This will be 0 unless
 * set by section_getstate, or if the section was built by a call
 * to section_makecomposite.
 */
int section_getstate(SECTION section);


/* return a count of the number of lines in this section */
int section_getlinecount(SECTION section);


/* return the base line number for this section in the left or
 * right files. Base line number is the line number of the
 * first line in this section. Return 0 if the line was not in
 * the left(or right) file.
 *
 * This will only be set for sections created in section_makecomposites.
 *
 * Assumes that lines are numbered incrementally in ascending order.
 */
int section_getleftbasenr(SECTION section);
int section_getrightbasenr(SECTION section);



/*--  section list functions -------------------------------------*/


/* make a list of sections by traversing a list of lines. Contiguous
 * lines that are all linked to contiguous lines are put in the same section.
 * contiguous blocks of lines that are unmatched are put in the same section.
 * sections are kept in order in the list such that the first line of
 * the first section is the first line of the list of lines.
 * left must be TRUE iff the linelist represents a left hand file
 */
LIST section_makelist(LIST linelist, BOOL left);

/* free up a list of sections and all data associated with it */
void section_deletelist(LIST sections);


/* make a composite list of sections by traversing two lists of sections.
 *
 * section are placed in the same order: thus if sec1 is before sec2 in
 * list1, it will be before sec2 in the composite list. Sections that
 * match and are in the same order in both lists, are inserted only once
 * - only one of the two sections will be in the composite list, and the
 * section state will be set to SAME.
 * sections that match but are different places in the two original
 * lists will be inserted twice and the section state will be set to MOVED
 * (MOVED_LEFT and MOVED_RIGHT). Sections that are unmatched will be
 * inserted in order (relative to sections from the same list) with the
 * state set to ONLY_LEFT or ONLY_RIGHT
 */

LIST section_makecomposite(LIST secsleft, LIST secsright);


/* match up sections in the two lists. link sections that are the same,
 * (whose lines are linked), and make correspondence links for sections
 * that are in the same relative position, but not identical.
 * when making correspondence links, we attempt to link lines that
 * match between the two correponding sections. We return TRUE if at any
 * point we increase the number of links - this means that the section
 * lists will have to be rebuilt and rematched. This is *not* done here -
 * it must be done by caller.
 * bDups means allow matching the first occurrence of lines which are not unique.
 */
BOOL section_matchlists(LIST secsleft, LIST secsright, BOOL bDups);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\windiff\scandir.h ===
/*
 *
 * scandir
 *
 *
 * scan a directory tree and build a sorted list of filenames within that
 * tree.
 *
 * the dir_buildlist function will scan the directories and files
 * and return DIRLIST handle.
 *
 * calls to dir_firstitem and dir_nextitem will traverse the files in the
 * listing in alphabetic order, returning a DIRITEM handle. This handle
 * can be queried for the associated filename, filesize and checksum.
 *
 * calls to dir_firstitem and dir_nextitem will only show files, not
 * directories, and will traverse the list in alphabetic order
 * within a directory, and contents of subdirectories in
 * alphabetic order within a directory. Within one directory, we traverse the
 * files before listing the contents of the subdirectories.
 *
 * if the bSum argument is true, we checksum each readable file during the
 * initial scan. If this is false, we will checksum the file on demand (during
 * the first call to  dir_getchecksum). if the file is not readable, the
 * checksum will be 0.
 *
 */

 /* handle to the list of files scanned */
typedef struct dirlist FAR * DIRLIST;

/* handle to one item within the list of files */
typedef struct diritem FAR * DIRITEM;


/*
 * scan the given directory for files, and return NULL if unsuccessful,
 * or a DIRLIST handle to the items if successful. If bSums is true,
 * checksum each file found.
 *
 * if pathname is not a directory, we return NULL. if it is a directory, but
 * contains no files, we return a valid handle to an empty list.
 *
 * If bOnDemand is TRUE, the list will scanned as necessary to fulfil
 * dir_firstitem/dir_nextitem requests. If this is false, the
 * list will be fully built before the dir_buildlist function returns.
 */
DIRLIST dir_buildlist(LPSTR pathname, BOOL bSum, BOOL bOnDemand);

void dir_setotherdirlist(DIRLIST dl, DIRLIST otherdl);

/*
 * build/append a directory list.
 *
 * If bSums is true, checksum each file found.
 *
 * if pathname is not a directory, we add it to the list.
 * if it is a directory, it gets ignored.
 */
BOOL dir_appendlist(DIRLIST *pdl, LPCSTR pathname, BOOL bSum, int *psequence);

/*
 * build a list of files by calling a remote checksum server. The result is
 * a handle to a DIRLIST that behaves the same as one returned from
 * dir_buildlist. if bSums is true, we checksum the files
 * during scanning. if bOnDemand is true, we only build the list as necessary
 * during calls to dir_first/nextitem. if this is false, the
 * entire list will be build before the function completes.
 */
DIRLIST dir_buildremote(LPSTR server, LPSTR path, BOOL bSum, BOOL bOnDemand, BOOL fDeep);


/* call this to delete this list, all the items in it and all the
 * associated memory
 */
void dir_delete(DIRLIST list);


/* was this list built from a filename or a directory ? This function
 * will return TRUE if the initial argument to the dir_buildlist()
 * function or dir_buildremote() function specified an individual filename
 * rather than a directory.
 */
BOOL dir_isfile(DIRLIST list);


/* return the first file in the list in alphabetic order. will return
 * null if no files found
 */
DIRITEM dir_firstitem(DIRLIST list);

/* return the next file in the list in alphabetic order, or null if no
 * more files
 */
DIRITEM dir_nextitem(DIRLIST list, DIRITEM previtem, BOOL fDeep);

/*
 * Return a handle to the DIRLIST given a handle to the DIRITEM within it.
 *
 */
DIRLIST dir_getlist(DIRITEM item);


// get the name of this file, relative to the DIRLIST root.
LPSTR dir_getrelname(DIRITEM item);

// get the absolute path to the dirlist root directory
LPSTR dir_getrootpath(DIRLIST dl);

// get a description text for this dirlist
LPSTR dir_getrootdescription(DIRLIST dl);

// set custom description (instead of using calculated one)
void dir_setdescription(DIRLIST dl, LPCSTR psz);



/* free memory created by a previous call to dir_getrelname */
void dir_freerelname(DIRITEM item, LPSTR relname);

/* free memory possibly created by a call to dir_getroot_*  */
void dir_freerootpath(DIRLIST dl, LPSTR rootname);
void dir_freerootdescription(DIRLIST dl, LPSTR rootname);

/*
 * get an open-able name for the file. This will be the same as the fullname,
 * except for remote files, in which case a temporary local copy of the file
 * will be made. call dir_freeopenname when finished with this name.
 */
LPSTR dir_getopenname(DIRITEM item);

/*
 * free up memory created by a call to dir_getopenname(). This *may*
 * cause the file to be deleted if it was a temporary copy.
 */
void dir_freeopenname(DIRITEM item, LPSTR openname);


/*
 * open the file and return a read-only handle to it.
 * will work even for remote files (causes a copy to a temporary local
 * file). close file using dir_closefile
 */
int dir_openfile(DIRITEM item);

/*
 * close a file opened by dir_openfile. This *may* cause the file to be
 * deleted if it was a temporary local copy
 */
void dir_closefile(DIRITEM item, int fh);


/* return a checksum for this file. If one has not yet been calculated
 * for this file, open the file and calculate it.
 * if the file was unreadable, this returns 0.
 */
DWORD dir_getchecksum(DIRITEM item);

/* Redo everything to do with checksums, size, etc */
void dir_rescanfile(DIRITEM di);

/* return a TRUE iff item has a valid checksum */
BOOL dir_validchecksum(DIRITEM item);

// return false if there is some error accessing this file
BOOL dir_fileerror(DIRITEM item);

/* return the (lower 32 bits) of the file size, as scanned at the
 * call to dir_buildlist
 */
long dir_getfilesize(DIRITEM item);

/* return the file attributes, as scanned at the call to dir_buildlist
 */
DWORD dir_getattr(DIRITEM item);

/* MUST CALL dir_startcopy first and dir_endcopy after.
 * create a copy of the file, in the new root directory. creates sub-dirs as
 * necessary. Works for local and remote files. For remote files, uses
 * ss_copy_reliable to ensure that the copy succeeds if possible.
 *
 * returns TRUE for success and FALSE for failure.
 */
BOOL dir_copy(DIRITEM item, LPSTR newroot, BOOL HitReadOnly, BOOL IgnoreAttributes);

/* Call this before starting copying */
BOOL dir_startcopy(DIRLIST dl);


/* call this after copying.  Negative retcode = number of bad files
   else retcode = number of file copied (all good).
*/
int dir_endcopy(DIRLIST dl);

/* Build the real path from item and newroot into newpath.
 * Create directories as needed so that it is valid.
 */
BOOL dir_MakeValidPath(LPSTR newpath, DIRITEM item, LPSTR newroot);

/*
 * useful routine exported for other users
 * returns TRUE if path is a valid directory
 */
BOOL dir_isvaliddir(LPCSTR path);

/*
 * returns TRUE if the DIRLIST parameter has a wildcard specified
 */
BOOL dir_iswildcard(DIRLIST);

/*
 * compares two relnames that are both based on wildcard DIRLISTs. if the
 * directories match, then the filenames are compared after removing
 * the fixed portion of the name - thus comparing only the
 * wildcard portion.
 */
int dir_compwildcard(DIRLIST dleft, DIRLIST dright, LPSTR lname, LPSTR rname);

/*
 * compares two DIRITEMs, based on a sequence number rather than filenames.
 */
BOOL dir_compsequencenumber(DIRITEM dleft, DIRITEM dright, int *pcmpvalue);

#ifndef WIN32
    /* FILETIME structure from WIN32 */
    typedef struct _FILETIME { /* ft */
        DWORD dwLowDateTime;
        DWORD dwHighDateTime;
    } FILETIME;
#define CONST const

long CompareFileTime( CONST FILETIME * lpft1,  /* address of first file time */
                      CONST FILETIME * lpft2  /* address of second file time */
                    );
#endif

/* return the file time (last write time) (set during scanning), (0,0) if invalid */
FILETIME dir_GetFileTime(DIRITEM cur);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\windiff\slmmgr.h ===
/*
 * slmmgr.h
 *
 * interface to SLM
 *
 * provides an interface to SLM libraries that will return the
 * SLM master library for a given directory, or extract into temp files
 * earlier versions of a SLM-controlled file
 *
 * Create a slmobject by passing SLM_New() the name of a file or directory
 * path. SLM_New will look for the slm.ini file in that directory, and then
 * extract information about the master source library. SLM_GetMasterPath()
 * will then return the pathname of the master source library for a given
 * slm.ini, and SLM_GetVersion (Win32 only) will execute one of the slm
 * applications to extract a previous version of one of the slm-controlled
 * files in that directory.
 */

/*
 * handle to a SLM object. you do not need to know the structure layout.
 */
typedef struct _slmobject FAR * SLMOBJECT;

/* handle to pair of filenames */
typedef struct _leftrightpair FAR * LEFTRIGHTPAIR;


/*
 * Forces the SLMMGR to assume Source Depot mode, without ever searching for
 * an SD.INI file.
 */
void SLM_ForceSourceDepot(void);


void SLM_SetSDPort(LPCSTR pszPort);
void SLM_SetSDClient(LPCSTR pszClient);
void SLM_SetSDChangeNumber(LPCSTR pszChangeNumber);


/*
 * Initialize the SLMMGR to do a Source Depot 'describe' command (implemented
 * via an ugly hack -- sorry!  time constraints and all; you understand).
 */
void SLM_Describe(LPCSTR pszChangeNumber);

/*
 * Initialize the SLMMGR to use the indicated input file.
 */
LPCSTR SLM_SetInputFile(LPCSTR pszInputFile);

/*
 * create a slm object for the given directory. The pathname may include
 * a filename component.
 * If the directory is not enlisted in a SLM library, this will return NULL.
 */
SLMOBJECT SLM_New(LPCSTR pathname, UINT *pidsError);


/*
 * free up all resources associated with a slm object. The SLMOBJECT is invalid
 * after this call.
 */
void SLM_Free(SLMOBJECT hSlm);

/*
 * get the pathname of the master source library for this slmobject. The
 * path (UNC format) is copied to masterpath, which must be at least
 * MAX_PATH in length.
 */
BOOL SLM_GetMasterPath(SLMOBJECT hslm, LPSTR masterpath);


BOOL SLM_FServerPathExists(LPCSTR pszPath);


LEFTRIGHTPAIR SLM_GetOpenedFiles();
LEFTRIGHTPAIR SLM_GetDescribeFiles();
LEFTRIGHTPAIR SLM_ReadInputFile(LPCSTR pszLeftArg, LPCSTR pszRightArg, BOOL fSingle, BOOL fVersionControl);
BOOL PerformReplacement(LPCSTR pszTemplate, LPCSTR pszReplacement, LPSTR pszDest, int cchDest);


LPCSTR LEFTRIGHTPAIR_Left(LEFTRIGHTPAIR ppair);
LPCSTR LEFTRIGHTPAIR_Right(LEFTRIGHTPAIR ppair);
LEFTRIGHTPAIR LEFTRIGHTPAIR_Next(LEFTRIGHTPAIR ppair);


/*
 * extract a previous version of the file to a temp file. Returns in tempfile
 * the name of a temp file containing the requested file version. The 'version'
 * parameter should contain a SLM file & version in the format file.c@vN.
 * eg
 *    file.c@v1		is the first version
 *    file.c@v-1	is the previous version
 *    file.c@v.-1	is yesterdays version
 */
BOOL SLM_GetVersion(SLMOBJECT hslm, LPSTR version, LPSTR tempfile);

/*
 * We don't offer SLM options unless we have seen a correct slm.ini file.
 *
 * Once we have seen a slm.ini, we log this in the profile and will permit
 * slm operations from then on. This function is called by the UI portions
 * of windiff: it returns TRUE if it is ok to offer SLM options.
 * Return 0 - This user hasn't touched SLM,
 *        1 - They have used SLM at some point (show SLM options)
 *        2 - They're one of us, so tell them everything
 *        3 - (1 + 2).
 */
int IsSLMOK(void);

/*
 * In adding support for Source Depot, I have not refactored the original
 * abstraction for the SLM support.  The original abstraction unfortunately
 * makes some assumptions based on knowledge of SLM (dirscan assumes it has a
 * SLM share that it can directly access).  Therefore, instead of altering
 * the underlying design, dirscan explicitly checks to see whether Source
 * Depot is in use, and alters its algorithm appropriately.
 */
int IsSourceDepot(SLMOBJECT hSlm);


/*
 * More than one place needed to parse SLM/SD revision marks, which gave me
 * an excuse to factor out the code and put it in slmmgr.
 *
 * Args:
 *
 *      pszInput   [in] - input string to examine for revision marks
 *      fStrip     [in] - TRUE: copy and strip mark, return allocated memory
 *                        containing the mark;  FALSE: return pointer to mark
 *                        within pszInput.
 *
 * Return NULL - no revision mark found
 *        non-NULL - revision mark found:
 *                    - memory is allocated via gmem_get, and the revision
 *                      tag is copied there.
 *                    - the revision tag is stripped from pszInput.
 *                    - return value is pointer to the allocated memory
 *                      (hint: free it!).
 */
LPSTR SLM_ParseTag(LPSTR pszInput, BOOL fStrip);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\windiff\state.h ===
/*
 * windiff - windows file and directory comparisons
 *
 * state.h
 *
 * definition of the results of comparisons for files and for lines
 * within files.
 *
 * These need to be globally declared so that the UI code in windiff.c can
 * map states to the colour scheme (to correctly highlight changed lines).
 *
 * They apply to files (compitem_getstate() ) and to sections in the
 * composite list (section_getstate). All lines within a section have the
 * same state. The UI code will use the view_getstate() function to find the
 * state for a given line on the screen.
 *
 */

/* applies to both lines or files: they are the same */
#define STATE_SAME		1

/* applies to files.  Same size, date, time */
#define STATE_COMPARABLE	2

/* applies to files.  Different, but only in blanks
 * This state only turns up after the file has been expanded.
 */
#define STATE_SIMILAR		3

/* applies only to files */

/* - files differ (and can be expanded) */
#define STATE_DIFFER		4

/* they are only in the left or right tree */
#define STATE_FILELEFTONLY	5
#define STATE_FILERIGHTONLY	6


/* applies to lines only */

/* the line only exists in one of the lists */
#define STATE_LEFTONLY		7	/* line only in left file */
#define STATE_RIGHTONLY 	8	/* line only in right file */


/* the line is the same in both files, but in
 * different places (thus the line will appear twice in the composite list,
 * once with each of these two states
 */
#define STATE_MOVEDLEFT		9	/* this is the left file version */
#define STATE_MOVEDRIGHT	10	/* this is the right file version*/


#define STATE_SIMILARLEFT	11      /* this is the left file zebra version */
#define STATE_SIMILARRIGHT      12	/* this is the right file zebra version*/

/* In processing the sections to build the composite list, we need to
 * track which sections have been processed.  After this the left and
 * right lists of sections are of no further interest
 */
#define STATE_MARKED		99
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\windiff\slmmgr.c ===
/*
 * slmmgr.c
 *
 * interface to SLM
 *
 * provides an interface to SLM libraries that will return the
 * SLM master library for a given directory, or extract into temp files
 * earlier versions of a SLM-controlled file
 *
 * Geraint Davies, August 93
 */

#include <windows.h>
#include <string.h>
#include <process.h>
#include <stdlib.h>
#include "scandir.h"
#include "slmmgr.h"
#include "gutils.h"

#include "windiff.h"
#include "wdiffrc.h"

/*
 * The SLMOBJECT is a pointer to one of these structures
 */
struct _slmobject {

    // shared, SD and SLM
    char CurDir[MAX_PATH];
    char SlmRoot[MAX_PATH];

    // only SLM
    char MasterPath[MAX_PATH];
    char SubDir[MAX_PATH];
    char SlmProject[MAX_PATH];

    // only SD
    BOOL fSourceDepot;
    BOOL fUNC;
    char ClientRelative[MAX_PATH];
};


/*
 * The LEFTRIGHTPAIR is a pointer to one of these structures
 */
struct _leftrightpair
{
    char m_szLeft[512];
    char m_szRight[512];
    struct _leftrightpair *m_pNext;
};



BOOL SLM_ReadIni(SLMOBJECT pslm, HFILE fh);

// all memory allocated from gmem_get, using a heap declared and
// initialised elsewhere
extern HANDLE hHeap;


// windiff -l! forces us to assume SD without looking for SLM.INI or SD.INI
static BOOL s_fForceSD = FALSE;
static BOOL s_fDescribe = FALSE;        // -ld was used
static char s_szSDPort[MAX_PATH] = "";
static char s_szSDClient[MAX_PATH] = "";
static char s_szSDClientRelative[MAX_PATH] = "";
static char s_szSDChangeNumber[32] = "";
static char s_szInputFile[MAX_PATH] = "";


static LPSTR DirUpOneLevel(LPSTR pszDir)
{
    LPSTR psz;
    LPSTR pszSlash = 0;

    for (psz = pszDir; *psz; ++psz) {
        if (*psz == '\\') {
            if (*(psz + 1) && *(psz + 1) != '\\') {
                pszSlash = psz;
            }
        }
    }
    if (pszSlash) {
        *pszSlash = 0;
    }
    return pszSlash;
}


void
SLM_ForceSourceDepot(void)
{
    s_fForceSD = TRUE;
}


void
SLM_Describe(LPCSTR pszChangeNumber)
{
    s_fForceSD = TRUE;
    s_fDescribe = TRUE;
    *s_szSDChangeNumber = 0;
    if (pszChangeNumber && *pszChangeNumber)
        lstrcpyn(s_szSDChangeNumber, pszChangeNumber, NUMELMS(s_szSDChangeNumber));
}


LPCSTR
SLM_SetInputFile(LPCSTR pszInputFile)
{
    *s_szInputFile = 0;
    if (pszInputFile)
        lstrcpyn(s_szInputFile, pszInputFile, NUMELMS(s_szInputFile));
    return s_szInputFile;
}


void
SLM_SetSDPort(LPCSTR pszPort)
{
    lstrcpy(s_szSDPort, " -p ");
    lstrcat(s_szSDPort, pszPort);
}


void
SLM_SetSDClient(LPCSTR pszClient)
{
    lstrcpy(s_szSDClient, " -c ");
    lstrcat(s_szSDClient, pszClient);

    lstrcpy(s_szSDClientRelative, "//");
    lstrcat(s_szSDClientRelative, pszClient);
    lstrcat(s_szSDClientRelative, "/");
}


void
SLM_SetSDChangeNumber(LPCSTR pszChangeNumber)
{
    *s_szSDChangeNumber = 0;
    if (pszChangeNumber && *pszChangeNumber)
    {
        lstrcpy(s_szSDChangeNumber, " -c ");
        lstrcat(s_szSDChangeNumber, pszChangeNumber);
    }
}


/*
 * create a slm object for the given directory. The pathname may include
 * a filename component.
 * If the directory is not enlisted in a SLM library, this will return NULL.
 *
 * Check that the directory is valid, and that we can open slm.ini, and
 * build a UNC path to the master source library before declaring everything
 * valid.
 *
 * *pidsError is set to 0 on success, or the recommended error string on failure.
 */
SLMOBJECT
SLM_New(LPCSTR pathname, UINT *pidsError)
{
    SLMOBJECT pslm;
    char tmppath[MAX_PATH];
    char slmpath[MAX_PATH];
    LPSTR pszFilenamePart;
    HFILE fh = -1;
    BOOL bOK = FALSE;
    LPCSTR pfinal = NULL;
    UINT idsDummy;
    BOOL fDepotSyntax = (s_fDescribe || (pathname && pathname[0] == '/' && pathname[1] == '/'));

    if (!pidsError)
        pidsError = &idsDummy;
    *pidsError = IDS_BAD_SLM_INI;

    pslm = (SLMOBJECT) gmem_get(hHeap, sizeof(struct _slmobject));

    if (pslm == NULL)
        // could give a better error string here, but out of memory is pretty
        // unlikely...
        return(NULL);

    // init to zero (must set fSourceDepot false)
    memset(pslm, 0, sizeof(*pslm));

    if (pathname == NULL)
        pathname = ".";

    /*
     * find the directory portion of the path.
     */
    if (fDepotSyntax)
    {
        lstrcpy(pslm->CurDir, pathname);
        pszFilenamePart = My_mbsrchr(pslm->CurDir, '/');
        if (!pszFilenamePart)
            goto LError;
        *pszFilenamePart = 0;
    }
    else if (dir_isvaliddir(pathname))
    {
        /*
         * its a valid directory as it is.
         */
        lstrcpy(pslm->CurDir, pathname);
    }
    else
    {
        /* it's not a valid directory, perhaps because it has a filename on
         * the end. remove the final element and try again.
         */

        pfinal = My_mbsrchr(pathname, '\\');
        if (pfinal == NULL)
        {
            /*
             * there is no backslash in this name and it is not a directory
             * - it can only be valid if it is a file in the current dir.
             * so create a current dir of '.'
             */
            lstrcpy(pslm->CurDir, ".");

            // remember the final element in case it was a wild card
            pfinal = pathname;
        }
        else
        {
            /*
             * pfinal points to the final backslash.
             */
            My_mbsncpy(pslm->CurDir, pathname, (size_t)(pfinal - pathname));
        }
    }

    // is this a UNC path?
    if (memcmp("\\\\", pslm->CurDir, 2) == 0)
        pslm->fUNC = TRUE;

    // initialize path variables so we can search for slm.ini and/or sd.ini
    if (!fDepotSyntax)
    {
        lstrcpy(tmppath, pslm->CurDir);
        if (pslm->CurDir[lstrlen(pslm->CurDir) -1] != '\\')
            lstrcat(tmppath, "\\");
        if (!_fullpath(slmpath, tmppath, sizeof(slmpath)))
            goto LError;
        pszFilenamePart = slmpath + lstrlen(slmpath);
    }

    if (!s_fForceSD && !fDepotSyntax)
    {
        // look for slm.ini in the specified directory
        lstrcpy(pszFilenamePart, "slm.ini");
        fh = _lopen(slmpath, 0);
    }

    if (fh == -1)
    {
        // (1) if user isn't forcing SD, we need to find an sd.ini file so we
        // know to use SD mode.  (2) if user has specified an SD client, then
        // we need to find an sd.ini file in order to know how to build
        // client-relative path names.  (3) depot syntax (//depot/foo/bar.c)
        // implies we're forcing SD mode and we don't need a client name.
        if (!fDepotSyntax && (!s_fForceSD || *s_szSDClient))
        {
            // look for SD.INI in the specified directory, moving upwards
            *pszFilenamePart = 0;
            while (pszFilenamePart > slmpath)
            {
                lstrcpy(pszFilenamePart, "sd.ini");
                fh = _lopen(slmpath, 0);
                if (fh != -1)
                {
                    int ii;

                    // found one
                    pslm->fSourceDepot = TRUE;
                    // assume that the sd.ini file is in the client root path
                    lstrcpy(pslm->SlmRoot, slmpath);
                    ii = (int)(pszFilenamePart - slmpath);
                    pslm->SlmRoot[ii] = 0;
                    if (ii >= 0 && pslm->SlmRoot[ii - 1] != '\\')
                    {
                        pslm->SlmRoot[ii++] = '\\';
                        pslm->SlmRoot[ii] = 0;
                    }
                    break;
                }

                // walk up the directory hierarchy and try again
                *pszFilenamePart = 0;
                pszFilenamePart = DirUpOneLevel(slmpath);
                if (!pszFilenamePart || GetFileAttributes(slmpath) == 0xffffffff)
                    break;
                *(pszFilenamePart++) = '\\';
                *pszFilenamePart = 0;
            }
        }
        else
        {
            // user is forcing SD, but hasn't specified a client, so we can
            // safely assume SD mode.  or depot syntax was used.
            pslm->fSourceDepot = TRUE;
            bOK = TRUE;
        }
    }

    if (fh != -1)
    {
        bOK = SLM_ReadIni(pslm, fh);

        /*
         * if pfinal is not null, then it might be a *.* wildcard pattern
         * at the end of the path - if so, we should append it to the masterpath.
         */
        if (pfinal && (My_mbschr(pfinal, '*') || My_mbschr(pfinal, '?')))
        {
            if ( (pslm->MasterPath[lstrlen(pslm->MasterPath)-1] != '\\') &&
                 (pfinal[0] != '\\'))
            {
                lstrcat(pslm->MasterPath, "\\");
            }
            lstrcat(pslm->MasterPath, pfinal);
        }

        _lclose(fh);
    }

LError:
    if (!bOK)
    {
        if (pslm && pslm->fSourceDepot)
            *pidsError = IDS_BAD_SD_INI;
        gmem_free(hHeap, (LPSTR) pslm, sizeof(struct _slmobject));
        pslm = 0;
    }
    else
        *pidsError = 0;
    return(pslm);
}



/*
 * read slm.ini data from a file handle and
 * fill in the master path field of a slm object. return TRUE if
 * successful.
 * Read slm.ini in the current directory.  Its syntax is
 * project = pname
 * slm root = //server/share/path or //drive:disklabel/path (note forward /'s)
 * user root = //drive:disklabel/path
 * subdir = /subdirpath
 * e.g.
 *
 * project = media
 * slm root = //RASTAMAN/NTWIN
 * user root = //D:LAURIEGR6D/NT/PRIVATE/WINDOWS/MEDIA
 * sub dir = /
 *
 * and what we copy to pslm->MasterPath is
 * \\server\share\src\pname\subdirpath
 */
BOOL
SLM_ReadIni(SLMOBJECT pslm, HFILE fh)
{
    BYTE buffer[3 * MAX_PATH];   // slm.ini is usually about 120 bytes
    int cBytes;
    PSTR tok, project, slmroot, subdir;

    if (pslm->fSourceDepot)
    {
        if (pslm->fUNC)
        {
            cBytes = _lread(fh, (LPSTR) buffer, sizeof(buffer) -1);
            if (cBytes > 0)
            {
                if (cBytes == sizeof(buffer))
                    cBytes--;
                buffer[cBytes] = 0;

                for (tok = strtok(buffer, "="); tok;)
                {
                    char *pszStrip = 0;
                    char *pszWalk;

                    slmroot = strtok(NULL, "\r\n");
                    if (!slmroot)
                        break;

                    while (*tok == '\r' || *tok == '\n' || *tok == ' ')
                        tok++;

                    for (pszWalk = tok; *pszWalk; pszWalk++)
                        if (*pszWalk != ' ')
                            pszStrip = pszWalk + 1;
                    if (pszStrip)
                        *pszStrip = 0;

                    if (lstrcmpi(tok, "SDCLIENT") == 0)
                    {
                        while (*slmroot == ' ')
                            ++slmroot;

                        for (pszWalk = slmroot; *pszWalk; pszWalk++)
                            if (*pszWalk != ' ')
                                pszStrip = pszWalk + 1;
                        if (pszStrip)
                            *pszStrip = 0;

                        if (!*s_szSDClient)
                            SLM_SetSDClient(slmroot);
                        wsprintf(pslm->ClientRelative, "//%s/", slmroot);
                        break;
                    }
                    tok = strtok(NULL, "=");
                }
            }
        }
        if (!*pslm->ClientRelative)
        {
            lstrcpy(pslm->ClientRelative, s_szSDClientRelative);
        }
        return(TRUE);
    }

    cBytes = _lread(fh, (LPSTR) buffer, sizeof(buffer) -1);

    if (cBytes<=0) {
        return(FALSE);
    }
    if (cBytes == sizeof(buffer)) {
        cBytes--;       // make room for sentinel
    }
    buffer[cBytes] = 0;   /* add a sentinel */

    tok = strtok(buffer, "=");  /* project = (boring) */
    if (tok==NULL) {
        return(FALSE);
    }

    project = strtok(NULL, " \r\n");  /* project name (remember) */
    
    lstrcpy( pslm->SlmProject, project );

    tok = strtok(NULL, "=");  /* slm root */
    if (tok==NULL) {
        return(FALSE);
    }

    slmroot = strtok(NULL, " \r\n");  /* PATH!! (but with / for \ */
    lstrcpy( pslm->SlmRoot, slmroot );

    /* start to build up what we want */

    if ('/' == slmroot[0] &&
        '/' == slmroot[1] &&
        (('A' <= slmroot[2] && 'Z' >= slmroot[2]) ||
         ('a' <= slmroot[2] && 'z' >= slmroot[2])) &&
        ':' == slmroot[3])
    {
        // Convert slm root from //drive:disklabel/path to drive:/path

        pslm->MasterPath[0] = slmroot[2];
        pslm->MasterPath[1] = ':';
        tok = strchr(&slmroot[4], '/');
        if (NULL == tok)
        {
            return(FALSE);
        }
        lstrcpy(&pslm->MasterPath[2], tok);
    }
    else
    {
        lstrcpy(pslm->MasterPath, slmroot);
    }

    lstrcat(pslm->MasterPath,"\\src\\");
    lstrcat(pslm->MasterPath, project);

    tok = strtok(NULL, "=");  /* ensure get into next line */
    if (tok==NULL) {
        return(FALSE);
    }
    tok = strtok(NULL, "=");
    if (tok==NULL) {
        return(FALSE);
    }

    if (*tok == '\"')
        tok++;

    subdir = strtok(NULL, " \"\r\n");  /* PATH!! (but with / for \*/
    if (subdir==NULL) {
        return(FALSE);
    }

    lstrcpy( pslm->SubDir, subdir );

    lstrcat(pslm->MasterPath, subdir);

    /* convert all / to \  */
    {
        int ith;
        for (ith=0; pslm->MasterPath[ith]; ith++) {
            if (pslm->MasterPath[ith]=='/') {
                pslm->MasterPath[ith] = '\\';
            }
        }
    }

    return(TRUE);
}


/*
 * free up all resources associated with a slm object. The SLMOBJECT is invalid
 * after this call.
 */
void
SLM_Free(SLMOBJECT pSlm)
{
    if (pSlm != NULL) {
        gmem_free(hHeap, (LPSTR) pSlm, sizeof(struct _slmobject));
    }
}



/*
 * get the pathname of the master source library for this slmobject. The
 * path (UNC format) is copied to masterpath, which must be at least
 * MAX_PATH in length.
 */
BOOL
SLM_GetMasterPath(SLMOBJECT pslm, LPSTR masterpath)
{
    if (pslm == NULL) {
        return(FALSE);
    } else {
        lstrcpy(masterpath, pslm->MasterPath);
        return(TRUE);
    }
}


BOOL SLM_FServerPathExists(LPCSTR pszPath)
{
    BOOL fExists = FALSE;
    SLMOBJECT pslm;

    pslm = SLM_New(pszPath, 0);
    if (pslm)
    {
        if (pslm->fSourceDepot)
        {
            char commandpath[MAX_PATH * 2];
            char szRelative[MAX_PATH * 2];
            STARTUPINFO si;
            PROCESS_INFORMATION pi;
            LPCSTR pszRelative;
            LPSTR psz;

            // run SD FILES * and see if it finds anything
            FillMemory(&si, sizeof(si), 0);
            si.cb = sizeof(si);
            si.dwFlags = STARTF_USESHOWWINDOW;
            si.wShowWindow = SW_HIDE;

            if (*pslm->ClientRelative)
            {
                pszRelative = pszPath;
                pszRelative += lstrlen(pslm->SlmRoot);
                // convert all backslashes to forward slashes, since
                // client-relative pathnames don't work otherwise
                lstrcpy(szRelative, pszRelative);
                for (psz = szRelative; *psz; psz++)
                    if (*psz == '\\')
                        *psz = '/';

                wsprintf(commandpath, "sd.exe%s%s files %s%s...", s_szSDPort, s_szSDClient, pslm->ClientRelative, szRelative);
            }
            else
            {
                int cch;
                lstrcpy(szRelative, pszPath);
                cch = lstrlen(szRelative);
                if (cch && szRelative[cch - 1] != '\\')
                    lstrcpy(szRelative + cch, "\\");
                wsprintf(commandpath, "sd.exe%s%s files %s...", s_szSDPort, s_szSDClient, szRelative);
            }

            if (CreateProcess(0, commandpath, 0, 0, TRUE,
                              NORMAL_PRIORITY_CLASS, 0, pszPath, &si, &pi))
            {
                DWORD dw;

                WaitForSingleObject(pi.hProcess, INFINITE);

                fExists = (GetExitCodeProcess(pi.hProcess, &dw) && !dw);

                CloseHandle(pi.hProcess);
                CloseHandle(pi.hThread);
            }
        }
        else
        {
            DWORD dw;

            dw = GetFileAttributes(pslm->MasterPath);
            fExists = (dw != (DWORD)-1) && (dw & FILE_ATTRIBUTE_DIRECTORY);
        }

        SLM_Free(pslm);
    }

    return fExists;
}



/*
 * extract a previous version of the file to a temp file. Returns in tempfile
 * the name of a temp file containing the requested file version. The 'version'
 * parameter should contain a SLM file & version in the format file.c@vN.
 * eg
 *    file.c@v1         is the first version
 *    file.c@v-1        is the previous version
 *    file.c@v.-1       is yesterdays version
 *
 * we use catsrc to create the previous version.
 */
BOOL
SLM_GetVersion(SLMOBJECT pslm, LPSTR version, LPSTR tempfile)
{
    char commandpath[MAX_PATH * 2];
    char szPath[MAX_PATH];
    char *pszDir = 0;
    BOOL fDepotSyntax = (s_fDescribe || (version && version[0] == '/' && version[1] == '/'));

    HANDLE hfile = INVALID_HANDLE_VALUE;
    BOOL bOK = FALSE;
    PROCESS_INFORMATION pi;
    STARTUPINFO si;
    SECURITY_ATTRIBUTES sa;

    GetTempPath(MAX_PATH, tempfile);
    GetTempFileName(tempfile, "slm", 0, tempfile);

    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle = TRUE;

    hfile = CreateFile(
                      tempfile,
                      GENERIC_WRITE,
                      FILE_SHARE_WRITE,
                      &sa,
                      CREATE_ALWAYS,
                      FILE_ATTRIBUTE_TEMPORARY,
                      NULL);
    if (hfile == INVALID_HANDLE_VALUE) {
        return(FALSE);
    }

    // create a process to run catsrc
    if (pslm->fSourceDepot) {
        if (*pslm->ClientRelative)
        {
            int cchRoot = lstrlen(pslm->SlmRoot);
            LPSTR psz;

            *szPath = 0;
            if (cchRoot >= 0 && cchRoot < lstrlen(pslm->CurDir))
            {
                const char *pszFilename = version;
                const char *pszWalk;

                lstrcpy(szPath, pslm->CurDir + cchRoot);
                lstrcat(szPath, "\\");

                for (pszWalk = version; *pszWalk; ++pszWalk)
                    if (*pszWalk == '/' || *pszWalk == '\\')
                        pszFilename = pszWalk + 1;

                lstrcat(szPath, pszFilename);
            }
            else
            {
                lstrcat(szPath, version);
            }

            // convert all backslashes to forward slashes, since
            // client-relative pathnames don't work otherwise
            for (psz = szPath; *psz; psz++)
                if (*psz == '\\')
                    *psz = '/';

            wsprintf(commandpath, "sd.exe%s%s print -q \"%s%s\"", s_szSDPort, s_szSDClient, pslm->ClientRelative, szPath);
            pszDir = pslm->CurDir;
        }
        else if (fDepotSyntax)
        {
            wsprintf(commandpath, "sd.exe%s%s print -q \"%s\"", s_szSDPort, s_szSDClient, version);
        }
        else
        {
            lstrcpy(szPath, pslm->CurDir);
            if (strchr(version, '\\'))
            {
                wsprintf(commandpath,
                         "sd.exe%s%s print -q \"%s\"",
                         s_szSDPort,
                         s_szSDClient,
                         version);
            }
            else
            {
                wsprintf(commandpath,
                         "sd.exe%s%s print -q \"%s\\%s\"",
                         s_szSDPort,
                         s_szSDClient,
                         pslm->CurDir,
                         version);
            }
            pszDir = pslm->CurDir;
        }
    } else {
        wsprintf(commandpath, "catsrc -s \"%s\" -p \"%s%s\" \"%s\"", pslm->SlmRoot, pslm->SlmProject, pslm->SubDir, version);
    }

    FillMemory(&si, sizeof(si), 0);
    si.cb = sizeof(si);
    si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
    si.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
    si.hStdOutput = hfile;
    si.hStdError = GetStdHandle(STD_ERROR_HANDLE);
    si.wShowWindow = SW_HIDE;

    bOK = CreateProcess(
                       NULL,
                       commandpath,
                       NULL,
                       NULL,
                       TRUE,
                       NORMAL_PRIORITY_CLASS,
                       NULL,
                       pszDir,
                       &si,
                       &pi);

    if (bOK) {
        DWORD dw;

        WaitForSingleObject(pi.hProcess, INFINITE);

        if (pslm->fSourceDepot && GetExitCodeProcess(pi.hProcess, &dw) && dw > 0)
            bOK = FALSE;

        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
    }

    if (hfile != INVALID_HANDLE_VALUE)
        CloseHandle(hfile);

    if (!bOK) {
        DeleteFile(tempfile);
        tempfile[0] = '\0';
    }

    return(bOK);
}


/*
 * We don't offer SLM options unless we have seen a correct slm.ini file.
 *
 * Once we have seen a slm.ini, we log this in the profile and will permit
 * slm operations from then on. This function is called by the UI portions
 * of windiff: it returns TRUE if it is ok to offer SLM options.
 * Return 0 - This user hasn't touched SLM,
 *        1 - They have used SLM at some point (show basic SLM options)
 *        2 - They're one of us, so tell them the truth
 *        3 - (= 1 + 2).
 */
int
IsSLMOK(void)
{
    int Res = 0;;
    if (GetProfileInt(APPNAME, "SLMSeen", FALSE)) {
        // we've seen slm  - ok
        ++Res;
    } else {

        // haven't seen SLM yet - is there a valid slm enlistment in curdir?
        SLMOBJECT hslm;

        hslm = SLM_New(".", 0);
        if (hslm != NULL) {

            // yes - current dir is enlisted. log this in profile
            SLM_Free(hslm);
            WriteProfileString(APPNAME, "SLMSeen", "1");
            ++Res;
        } else {
            // aparently not a SLM user.
        }
    }

    if (GetProfileInt(APPNAME, "SYSUK", FALSE)) {
        Res+=2;
    }
    return Res;
}


int
IsSourceDepot(SLMOBJECT hSlm)
{
    if (hSlm)
        return hSlm->fSourceDepot;
    return s_fForceSD;
}

const char c_szSharpHead[] = "#head";

LPSTR SLM_ParseTag(LPSTR pszInput, BOOL fStrip)
{
    LPSTR psz;
    LPSTR pTag;

    psz = My_mbschr(pszInput, '@');
    if (!psz)
    {
        psz = My_mbschr(pszInput, '#');
        if (psz)
        {
            /*
             * look for SD tags beginning # and separate if there.
             */
            LPCSTR pszRev = psz + 1;
            if (memcmp(pszRev, "none", 5) != 0 &&
                memcmp(pszRev, "head", 5) != 0 &&
                memcmp(pszRev, "have", 5) != 0)
            {
                for (; *pszRev; ++pszRev)
                    if (*pszRev < '0' || *pszRev > '9')
                    {
                        psz = 0;
                        break;
                    }
            }
        }
    }

    // If no explicit tag but this is in depot syntax, then default to #head
    if (!psz && IsDepotPath(pszInput))
    {
        psz = (LPSTR)c_szSharpHead;
    }

    if (psz && fStrip)
    {
        pTag = gmem_get(hHeap, lstrlen(psz) + 1);
        lstrcpy(pTag, psz);
        // insert NULL to blank out the tag in the string
        if (psz != c_szSharpHead) *psz = '\0';
    }
    else
    {
        pTag = psz;
    }

    return pTag;
}


/*----------------------------------------------------------------------------
    ::SLM_GetOpenedFiles
        sorry for the duplicated code here.  SLM_GetOpenedFiles,
        SLM_GetDescribeFiles, and SLM_ReadInputFile are very similar and could
        be factored.  this is all a hack though, and we're under tight time
        constraints.

    Author: chrisant
----------------------------------------------------------------------------*/
LEFTRIGHTPAIR SLM_GetOpenedFiles()
{
    char commandpath[MAX_PATH * 2];
    char tempfile[MAX_PATH];
    char *pszDir = 0;
    LEFTRIGHTPAIR pReturn = 0;
    LEFTRIGHTPAIR pHead = 0;
    LEFTRIGHTPAIR pTail = 0;
    LEFTRIGHTPAIR popened = 0;
    HANDLE h = INVALID_HANDLE_VALUE;
    FILEBUFFER file = 0;
    HFILE hfile = HFILE_ERROR;
    PROCESS_INFORMATION pi;
    STARTUPINFO si;
    SECURITY_ATTRIBUTES sa;
    DWORD dw;

    tempfile[0] = 0;
    GetTempPath(NUMELMS(tempfile), tempfile);
    GetTempFileName(tempfile, "slm", 0, tempfile);

    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle = TRUE;

    h = CreateFile(tempfile, GENERIC_WRITE, FILE_SHARE_WRITE|FILE_SHARE_READ,
                   &sa, CREATE_ALWAYS, FILE_ATTRIBUTE_TEMPORARY, NULL);
    if (h == INVALID_HANDLE_VALUE)
        goto LError;

    // create a process to run "sd opened -l"

    wsprintf(commandpath, "sd.exe%s%s opened%s -l", s_szSDPort, s_szSDClient, s_szSDChangeNumber);

    FillMemory(&si, sizeof(si), 0);
    si.cb = sizeof(si);
    si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
    si.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
    si.hStdOutput = h;
    si.hStdError = GetStdHandle(STD_ERROR_HANDLE);
    si.wShowWindow = SW_HIDE;

    if (!CreateProcess(NULL, commandpath, NULL, NULL, TRUE,
                       NORMAL_PRIORITY_CLASS, NULL, NULL, &si, &pi))
        goto LError;

    WaitForSingleObject(pi.hProcess, INFINITE);

    if (GetExitCodeProcess(pi.hProcess, &dw) && dw == 0)
    {
        OFSTRUCT os;
        LPSTR psz;
        int cch;
        BOOL fUnicode;                  // dummy, since SD opened -l will never write out a unicode file
        LPWSTR pwz;                     // dummy, since SD opened -l will never write out a unicode file
        int cwch;                       // dummy, since SD opened -l will never write out a unicode file

        hfile = OpenFile(tempfile, &os, OF_READ);
        if (hfile == HFILE_ERROR)
            goto LError;

        file = readfile_new(hfile, &fUnicode);
        if (file)
        {
            readfile_setdelims("\n");
            while (TRUE)
            {
                psz = readfile_next(file, &cch, &pwz, &cwch);
                if (!psz)
                    break;

                if (*psz)
                {
                    if (cch >= NUMELMS(popened->m_szLeft))
                        goto LError;

                    popened = (LEFTRIGHTPAIR)gmem_get(hHeap, sizeof(*popened));
                    if (!popened)
                        goto LError;
                    memcpy(popened->m_szLeft, psz, cch);
                    popened->m_szLeft[cch] = 0;
                    memcpy(popened->m_szRight, psz, cch);
                    popened->m_szRight[cch] = 0;

                    // strip revision from right file (valid to not find '#',
                    // e.g. opened for add).
                    psz = strchr(popened->m_szRight, '#');
                    if (psz)
                        *psz = 0;

                    // keep revision for left file, but strip everything
                    // following it.
                    psz = strchr(popened->m_szLeft, '#');
                    if (psz)
                    {
                        while (*psz && !isspace(*psz))
                            ++psz;
                        *psz = 0;
                    }

                    if (!pHead)
                    {
                        pHead = popened;
                        pTail = popened;
                    }
                    else
                    {
                        pTail->m_pNext = popened;
                        pTail = popened;
                    }
                    popened = 0;
                }
            }
            readfile_delete(file);
            file = 0;
        }
    }

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    pReturn = pHead;
    pHead = 0;

LError:
    gmem_free(hHeap, (LPSTR)popened, sizeof(*popened));
    while (pHead)
    {
        popened = pHead;
        pHead = pHead->m_pNext;
        gmem_free(hHeap, (LPSTR)popened, sizeof(*popened));
    }
    if (file)
        readfile_delete(file);
    if (hfile != HFILE_ERROR)
        _lclose(hfile);
    if (h != INVALID_HANDLE_VALUE)
    {
        CloseHandle(h);
        DeleteFile(tempfile);
    }
    return pReturn;
}


/*----------------------------------------------------------------------------
    ::SLM_GetDescribeFiles
        sorry for the duplicated code here.  SLM_GetOpenedFiles,
        SLM_GetDescribeFiles, and SLM_ReadInputFile are very similar and could
        be factored.  this is all a hack though, and we're under tight time
        constraints.

    Author: chrisant
----------------------------------------------------------------------------*/
LEFTRIGHTPAIR SLM_GetDescribeFiles()
{
    int nChange;
    char commandpath[MAX_PATH * 2];
    char tempfile[MAX_PATH];
    char *pszDir = 0;
    LEFTRIGHTPAIR pReturn = 0;
    LEFTRIGHTPAIR pHead = 0;
    LEFTRIGHTPAIR pTail = 0;
    LEFTRIGHTPAIR ppair = 0;
    HANDLE h = INVALID_HANDLE_VALUE;
    FILEBUFFER file = 0;
    HFILE hfile = HFILE_ERROR;
    PROCESS_INFORMATION pi;
    STARTUPINFO si;
    SECURITY_ATTRIBUTES sa;
    DWORD dw;

    GetTempPath(NUMELMS(tempfile), tempfile);
    GetTempFileName(tempfile, "slm", 0, tempfile);

    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle = TRUE;

    h = CreateFile(tempfile, GENERIC_WRITE, FILE_SHARE_WRITE|FILE_SHARE_READ,
                   &sa, CREATE_ALWAYS, FILE_ATTRIBUTE_TEMPORARY, NULL);
    if (h == INVALID_HANDLE_VALUE)
        goto LError;

    // create a process to run "sd describe -s"

    nChange = atoi(s_szSDChangeNumber);
    wsprintf(commandpath, "sd.exe%s%s describe -s %s", s_szSDPort, s_szSDClient, s_szSDChangeNumber);

    FillMemory(&si, sizeof(si), 0);
    si.cb = sizeof(si);
    si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
    si.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
    si.hStdOutput = h;
    si.hStdError = GetStdHandle(STD_ERROR_HANDLE);
    si.wShowWindow = SW_HIDE;

    if (!CreateProcess(NULL, commandpath, NULL, NULL, TRUE,
                       NORMAL_PRIORITY_CLASS, NULL, NULL, &si, &pi))
        goto LError;

    WaitForSingleObject(pi.hProcess, INFINITE);

    if (GetExitCodeProcess(pi.hProcess, &dw) && dw == 0)
    {
        OFSTRUCT os;
        LPSTR psz;
        int cch;
        BOOL fUnicode;                  // dummy, since SD describe will never write out a unicode file
        LPWSTR pwz;                     // dummy, since SD describe will never write out a unicode file
        int cwch;                       // dummy, since SD describe will never write out a unicode file

        hfile = OpenFile(tempfile, &os, OF_READ);
        if (hfile == HFILE_ERROR)
            goto LError;

        file = readfile_new(hfile, &fUnicode);
        if (file)
        {
            BOOL fAffectedFiles = FALSE;

            readfile_setdelims("\n");
            while (TRUE)
            {
                psz = readfile_next(file, &cch, &pwz, &cwch);
                if (!psz)
                    break;

                if (*psz)
                {
                    // look for the filenames
                    if (!fAffectedFiles)
                    {
                        if (strncmp(psz, "Affected files ...", 18) == 0)
                            fAffectedFiles = TRUE;
                        continue;
                    }

                    // if it isn't a filename, ignore it
                    if (strncmp(psz, "... ", 4) != 0)
                        continue;

                    psz += 4;
                    cch -= 4;

                    // avoid memory overrun
                    if (cch >= NUMELMS(ppair->m_szLeft))
                        goto LError;

                    // create node
                    ppair = (LEFTRIGHTPAIR)gmem_get(hHeap, sizeof(*ppair));
                    if (!ppair)
                        goto LError;

                    // build right filename
                    memcpy(ppair->m_szRight, psz, cch);
                    ppair->m_szRight[cch] = 0;
                    psz = strchr(ppair->m_szRight, '#');
                    if (!psz)
                    {
                        gmem_free(hHeap, (LPSTR)ppair, sizeof(*ppair));
                        goto LError;
                    }
                    wsprintf(psz, "@%d", nChange);

                    // build left filename
                    lstrcpy(ppair->m_szLeft, ppair->m_szRight);
                    psz = strchr(ppair->m_szLeft, '@') + 1;
                    wsprintf(psz, "%d", nChange - 1);

                    // link this node
                    if (!pHead)
                    {
                        pHead = ppair;
                        pTail = ppair;
                    }
                    else
                    {
                        pTail->m_pNext = ppair;
                        pTail = ppair;
                    }
                    ppair = 0;
                }
            }
            readfile_delete(file);
            file = 0;
        }
    }

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    pReturn = pHead;
    pHead = 0;

LError:
    gmem_free(hHeap, (LPSTR)ppair, sizeof(*ppair));
    while (pHead)
    {
        ppair = pHead;
        pHead = pHead->m_pNext;
        gmem_free(hHeap, (LPSTR)ppair, sizeof(*ppair));
    }
    if (file)
        readfile_delete(file);
    if (hfile != HFILE_ERROR)
        _lclose(hfile);
    if (h != INVALID_HANDLE_VALUE)
    {
        CloseHandle(h);
        DeleteFile(tempfile);
    }
    return pReturn;
}


/*----------------------------------------------------------------------------
    ::PerformReplacement
        Call with pszReplacement == NULL to ask if pszTemplate is replaceable.
        Otherwise, replaces {} in pszTemplate with pszReplacement.

    Author: JeffRose, ChrisAnt
----------------------------------------------------------------------------*/
BOOL PerformReplacement(LPCSTR pszTemplate, LPCSTR pszReplacement, LPSTR pszDest, int cchDest)
{
    BOOL fReplacing = FALSE;
    LPSTR pszNew;
    int cchReplacement;
    int cch;
    LPSTR psz;

    if (!pszTemplate)
        return FALSE;

    cch = lstrlen(pszTemplate) + 1;
    cchReplacement = pszReplacement ? lstrlen(pszReplacement) : 0;

    psz = (LPSTR)pszTemplate;
    while ((psz = strchr(psz, '{')) && psz[1] == '}')
    {
        fReplacing = TRUE;
        cch += cchReplacement - 2;
    }

    if (!pszReplacement)
        return fReplacing;

    pszNew = gmem_get(hHeap, cch);
    if (!pszNew)
        return FALSE;

    psz = pszNew;
    while (*pszTemplate)
    {
        if (pszTemplate[0] == '{' && pszTemplate[1] == '}')
        {
            lstrcpy(psz, pszReplacement);
            psz += cchReplacement;
            pszTemplate += 2;
        }
        else
            *(psz++) = *(pszTemplate++);
    }
    *psz = '\0';

    cch = lstrlen(pszNew);
    if (cch >= cchDest)
        cch = cchDest - 1;
    memcpy(pszDest, pszNew, cch);
    pszDest[cch] = '\0';

    gmem_free(hHeap, pszNew, lstrlen(pszNew));
    return TRUE;
}


static BOOL ParseFilename(const char **ppszSrc, int *pcchSrc, char *pszDest, int cchDest)
{
    BOOL fRet = FALSE;

    if (pcchSrc && *pcchSrc > 0 && ppszSrc && *ppszSrc && **ppszSrc && cchDest > 0)
    {
        BOOL fQuote = FALSE;

        // skip leading whitespace
        while (*pcchSrc > 0 && isspace(**ppszSrc))
        {
            ++(*ppszSrc);
            --(*pcchSrc);
        }

        // parse space delimited filename, with quoting support
        while (*pcchSrc > 0 && (fQuote || !isspace(**ppszSrc)) && **ppszSrc)
        {
            LPSTR pszNext = CharNext(*ppszSrc);
            int cch = (int)(pszNext - *ppszSrc);

            fRet = TRUE;

            if (**ppszSrc == '\"')
                fQuote = !fQuote;
            else
            {
                cchDest -= cch;
                if (cchDest < 1)
                    break;
                memcpy(pszDest, *ppszSrc, cch);
                pszDest += cch;
            }

            *ppszSrc = pszNext;
            *pcchSrc -= cch;
        }

        *pszDest = 0;
    }

    return fRet;
}


/*----------------------------------------------------------------------------
    ::SLM_ReadInputFile
        sorry for the duplicated code here.  SLM_GetOpenedFiles,
        SLM_GetDescribeFiles, and SLM_ReadInputFile are very similar and could
        be factored.  this is all a hack though, and we're under tight time
        constraints.

    Author: chrisant
----------------------------------------------------------------------------*/
LEFTRIGHTPAIR SLM_ReadInputFile(LPCSTR pszLeftArg,
                                LPCSTR pszRightArg,
                                BOOL fSingle,
                                BOOL fVersionControl)
{
    LEFTRIGHTPAIR pReturn = 0;
    LEFTRIGHTPAIR pHead = 0;
    LEFTRIGHTPAIR pTail = 0;
    LEFTRIGHTPAIR ppair = 0;
    HFILE hfile = HFILE_ERROR;
    FILEBUFFER file;
    OFSTRUCT os;
    LPSTR psz;
    int cch;
    BOOL fUnicode;                      // dummy, we don't support unicode input file
    LPWSTR pwz;                         // dummy, we don't support unicode input file
    int cwch;                           // dummy, we don't support unicode input file

    hfile = OpenFile(s_szInputFile, &os, OF_READ);
    if (hfile == HFILE_ERROR)
        goto LError;

    file = readfile_new(hfile, &fUnicode);
    if (file && !fUnicode)
    {
        readfile_setdelims("\n");
        while (TRUE)
        {
            psz = readfile_next(file, &cch, &pwz, &cwch);
            if (!psz)
                break;

            while (cch && (psz[cch - 1] == '\r' || psz[cch - 1] == '\n'))
                --cch;

            if (cch && *psz)
            {
                int cFiles = 0;

                if (cch >= NUMELMS(ppair->m_szLeft))
                    goto LError;

                ppair = (LEFTRIGHTPAIR)gmem_get(hHeap, sizeof(*ppair));
                if (!ppair)
                    goto LError;

                if (fSingle)
                {
                    memcpy(ppair->m_szLeft, psz, cch);
                    ppair->m_szLeft[cch] = 0;
                    ++cFiles;
                }
                else
                {
                    LPCSTR pszParse = psz;

                    // get first filename
                    if (ParseFilename(&pszParse, &cch, ppair->m_szLeft, NUMELMS(ppair->m_szLeft)))
                        ++cFiles;
                    else
                        goto LContinue;

                    // get second filename
                    if (ParseFilename(&pszParse, &cch, ppair->m_szRight, NUMELMS(ppair->m_szRight)))
                        ++cFiles;
                }

                if (cFiles == 1)
                {
                    lstrcpy(ppair->m_szRight, ppair->m_szLeft);

                    if (fVersionControl)
                    {
                        psz = SLM_ParseTag(ppair->m_szRight, FALSE);
                        if (psz)
                            *psz = 0;
                        else
                            lstrcat(ppair->m_szLeft, "#have");
                    }
                }

                PerformReplacement(pszLeftArg, ppair->m_szLeft, ppair->m_szLeft, NUMELMS(ppair->m_szLeft));
                PerformReplacement(pszRightArg, ppair->m_szRight, ppair->m_szRight, NUMELMS(ppair->m_szRight));

                if (!pHead)
                {
                    pHead = ppair;
                    pTail = ppair;
                }
                else
                {
                    pTail->m_pNext = ppair;
                    pTail = ppair;
                }
                ppair = 0;

LContinue:
                gmem_free(hHeap, (LPSTR)ppair, sizeof(*ppair));
                ppair = 0;
            }
        }
        readfile_delete(file);
        file = 0;
    }

    pReturn = pHead;
    pHead = 0;

LError:
    gmem_free(hHeap, (LPSTR)ppair, sizeof(*ppair));
    while (pHead)
    {
        ppair = pHead;
        pHead = pHead->m_pNext;
        gmem_free(hHeap, (LPSTR)ppair, sizeof(*ppair));
    }
    if (file)
        readfile_delete(file);
    if (hfile != HFILE_ERROR)
        _lclose(hfile);
    return pReturn;
}


LPCSTR LEFTRIGHTPAIR_Left(LEFTRIGHTPAIR ppair)
{
    return ppair->m_szLeft;
}


LPCSTR LEFTRIGHTPAIR_Right(LEFTRIGHTPAIR ppair)
{
    return ppair->m_szRight;
}


LEFTRIGHTPAIR LEFTRIGHTPAIR_Next(LEFTRIGHTPAIR ppair)
{
    LEFTRIGHTPAIR pNext = ppair->m_pNext;
    gmem_free(hHeap, (LPSTR)ppair, sizeof(*ppair));
    return pNext;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\windiff\view.h ===
/*
 *
 * VIEW
 *
 * provide a map between lines in the displayed table, and items in the
 * COMPLIST associated with this view.
 *
 * a view owns a complist: given the request for the text of a particular
 * line number in the displayed table, it will map it to either the
 * name/result of a CompItem in the COMPLIST (one of the files compared),
 * or to a line in the compare output (a line in one of the sections in
 * the composite section list for the selected CompItem).
 *
 * the view thus maintains a mode: OUTLINE mode is when one row is one COMPITEM,
 * and EXPAND mode is when one row is a line in the selected COMPITEM. Within
 * either of these modes, global option flags can select whether to show all
 * rows or only certain rows (eg only COMPITEMs that have a state other than
 * STATE_SAME, or only lines that are in the LEFT file).
 *
 * The view is given the handle to the table window. It will send messages
 * to the table window as appropriate when the view changes for any reason.
 *
 * The view owns the COMPLIST. When the view is deleted, the complist will
 * also be deleted.
 *
 * The table class is using this view. So to get rid of a view, call
 * view_close. This will notify the table window. Only call view_delete
 * when you have received the TQ_CLOSE notification indicating that the
 * table class has finished with this view.
 */




/* view.h includes the term COMPLIST: complist.h uses the term VIEW.
 * Alas MIPS doesn't allow duplicate definitions, even harmless ones,
 * so we need to play games.  Whoever declares it first does
 * the real declares and the second one gets no-ops.
 */
#ifndef INC_VIEW_COMPLIST
#define INC_VIEW_COMPLIST
typedef struct compitem FAR* COMPITEM;          /* handle to a compitem */
typedef struct view FAR * VIEW;                 /* handle to a VIEW     */
typedef struct complist FAR * COMPLIST;         /* handle to a complist */
#endif // INC_VIEW_COMPLIST

/* create a new view. It is told the handle for the associated
 * table window. We don't know yet the COMPLIST.
 */
VIEW view_new(HWND hwndTable);

/* tell the view the handle of its COMPLIST. This is an error if this
 * function has already been called for this view. This will init the
 * view to OUTLINE mode. We return FALSE if an error occured.
 */
BOOL view_setcomplist(VIEW view, COMPLIST cl);

/* get the handle of the COMPLIST for this view */
COMPLIST view_getcomplist(VIEW view);

/*
 * close a view. This causes the table window to be told to close
 * this view. When the table window has finished with the view, it will
 * send a TQ_CLOSE notification to its owner window. On receipt of
 * that, call view_delete
 */
void view_close(VIEW view);

/* delete a view and all data associated with it, including the COMPLIST.
 *
 * DON'T call this function except on receiving a TQ_CLOSE notification
 * from the table window. In other cases, call view_close to notify the
 * table window.
 */
void view_delete(VIEW view);

/*
 * each line has three columns - a line number, a tag and the main text.
 * this function returns the text for the given row in the
 * given view. The pointer is to a text string in the
 * view or in the complist somewhere - it should not be changed, and
 * may be overwritten by the next call to gettext.
 */

LPSTR view_gettext(VIEW view, long row, int col);
LPWSTR view_gettextW(VIEW view, long row, int col);

/*
 * return the line number that this line had in the original left or
 * right list. returns 0 if we are not in expanded mode, or if the
 * line was not in the original list. returns -(linenr) if the
 * line is MOVED and this is the other copy
 */
int view_getlinenr_left(VIEW view, long row);
int view_getlinenr_right(VIEW view, long row);


/* find the max width of the given column, in characters */
int view_getwidth(VIEW view, int col);


/* return the number of visible rows in this view */
long view_getrowcount(VIEW view);


/* get the state for this row. This is one of the STATE_* properties
 * defined in state.h, and is mapped to colour settings by the caller.
 */
int view_getstate(VIEW view, long row);


/* switch to expanded view of the given row. FALSE if row not
 * expandable or no such row. Switch the mapping so that each row
 * maps to one line in the composite section list for the given
 * compitem (the one selected by row in outline mode), and notify
 * the table window to redraw.
 * It is legal (and a no-op) to have rows==-1
 */
BOOL view_expand(VIEW view, long row);

/* return to outline mode. switch the mapping back so that each
 * row maps to one CompItem, and notify the table window so that it
 * is redrawn
 */
void view_outline(VIEW);

/* return a handle to the current CompItem. if the view is currently in
 * expand mode, this will return the handle for the CompItem that is
 * being expanded (regardless of the row parameter). If the mapping is
 * currently outline mode, the handle for the CompItem representing row
 * will be returned, or NULL if that is not valid
 */
COMPITEM view_getitem(VIEW view, long row);

/*
 * return TRUE if the current mapping is expanded mode
 */
BOOL view_isexpanded(VIEW view); 	

/* return a text string describing the current compitem. Only valid
 * if in expand mode. This will be normally the file name
 */
LPSTR view_getcurrenttag(VIEW view);


/* a CompItem has been added to the list. This will cause the
 * table to be notified of the change.
 *
 * This causes a Poll() to take place, and returns TRUE if an abort
 * has been requested. The caller should arrange to abort the current
 * scan operation.
 */
BOOL view_newitem(VIEW view);


/*
 * change view mode. the options affecting view selection have changed -
 * change the mapping if necessary, and redraw if it affects this mode
 *
 * retain current line if possible
 */
void view_changeviewoptions(VIEW view);

/* the compare options have changed - discard all compares and redo
 * as necessary.
 * retain current line if possible
 */
void view_changediffoptions(VIEW view);


/* find the next highlighted line in the given direction: forward if
 * bForward. returns the row number.
 */
long view_findchange(VIEW view, long startrow, BOOL bForward);

/* return the STATE_ value for the indicated row in the view.
 */
int view_getrowstate(VIEW view, long row);

/*
 * return the marked state for a given row. Only compitems can be marked,
 * so it will be FALSE unless it is a compitem on which view_setmark or
 * compitem_setmark have previously set the mark state to TRUE.
 */
BOOL view_getmarkstate(VIEW view, long row);

/*
 * set the mark state for a given row. This is only possible for compitem rows.
 * The mark set can be retrieved by view_getmarkstate or compitem_getmark.
 *
 * We return FALSE if the state could not be set - eg because the
 * row to set is not a compitem row.
 */
BOOL view_setmarkstate(VIEW view, long row, BOOL bMark);

/*
 * the WIN32 multithread version can try view_expand and view_outline
 * (or view_newitem) at the same time. This is not correctly protected by
 * the critical section, since there are major restrictions about holding
 * critsecs when sending messages from the worker thread.
 *
 * To avoid contention, we call this function to notify that we are
 * starting expanding. view_newitem and ToOutline will return without
 * doing anything if this function has been called and view_expand has not
 * completed.
 */
void view_expandstart(VIEW);

// are we in the middle of expansion ?
BOOL view_expanding(VIEW);

HWND view_gethwnd(VIEW view);

void view_gototableline(VIEW view, LONG iLine);

BOOL view_findstring(VIEW view, LONG iCol, LPCSTR pszFind, BOOL fSearchDown, BOOL fMatchCase, BOOL fWholeWord);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\windiff\wdiffrc.h ===
#define IDC_STATIC      -1

#define IDM_FILE        111
#define IDM_DIR         112
#define IDM_PRINT       113
#define IDM_REMOTE      114
#define IDM_EXIT        115
#define IDM_TIME        116
#define IDM_TRACE       117
#define IDM_TRACEOFF    118
#define IDM_OPEN        121
#define IDM_SAVELIST    122
#define IDM_EDITLEFT    123
#define IDM_EDITRIGHT   124
#define IDM_EDITCOMP    125
#define IDM_SETEDIT     126
#define IDM_COPYFILES   127
#define IDM_EDITCOPY    128

#define IDM_CONTENTS    130
#define IDM_ABOUT       131
#define IDD_ICON        132
#define IDD_VERSION     133
#define IDD_LABEL       136
#define IDD_DIR1        137
#define IDD_DIR2        138
#define IDD_LAB1        139
#define IDD_LAB2        140
#define IDD_LAB3        141
#define IDD_SLM         142
#define IDD_RECURSIVE   143
#define IDD_LOCALSLM    144
#define IDD_SERVER      145
#define IDD_PASSWORD    146
#define IDD_SUMS        147
#define IDD_FASTSCAN    148
#define IDD_AUTOCOPY    149
#define IDD_BOTHREMOTE  150
#define IDD_LOGFILE     151
#define IDD_LOGTEXT     152
#define IDD_FIND        153
#define IDC_DRD_FINDWHAT  154
#define IDC_OPT_UP        155
#define IDC_OPT_DOWN      156
#define IDC_CHK_MATCHCASE 157
#define IDC_CHK_WHOLEWORD 158

#define IDD_GOTOLINE    159
#define IDC_EDT_GOTOLINE 160

#define IDM_CLOSE       161

#define IDD_USAGE       170
#define IDC_USAGE_TEXT  171

#define IDM_OUTLINE     180
#define IDM_EXPAND      181
#define IDM_FCHANGE     182
#define IDM_LNRS        185
#define IDM_RNRS        186
#define IDM_NONRS       187
#define IDM_LONLY       188
#define IDM_RONLY       189
#define IDM_BOTHFILES   190
#define IDM_UPDATE      194
#define IDM_FPCHANGE    195
#define IDM_IGNBLANKS   196
#define IDM_PICTURE     197
#define IDM_LAZY        198
#define IDM_ALG2        199
#define IDM_OUTLINE_INCSAME     201
#define IDM_OUTLINE_INCLEFT     202
#define IDM_OUTLINE_INCRIGHT    203
#define IDM_OUTLINE_INCDIFFER   204
#define IDM_EXPAND_INCSAME     205
#define IDM_EXPAND_INCLEFT     206
#define IDM_EXPAND_INCRIGHT    207
#define IDM_EXPAND_INCMOVEDLEFT   208
#define IDM_EXPAND_INCMOVEDRIGHT  209
#define IDM_EXPAND_INCSIMILARLEFT   210
#define IDM_EXPAND_INCSIMILARRIGHT  211
#define IDM_MONOCOLS    212
#define IDM_RESCAN      213
#define IDM_SHOWWHITESPACE  214
#define IDM_FIND        215
#define IDM_FINDNEXT    216
#define IDM_FINDPREV    217
#define IDM_GOTOLINE    218
#define IDM_SETTABWIDTH	219
#define IDM_SETFONT		220
#define IDM_FCHANGE_LAURIE		221
#define IDM_FPCHANGE_LAURIE		222
#define IDM_TABWIDTH4   223
#define IDM_TABWIDTH8   224

#define IDM_MARK        300
#define IDM_MARKPATTERN 301
#define IDM_HIDEMARK    302
#define IDM_TOGGLEMARK  303
#define IDD_IGNOREMARK  304
#define IDD_ATTRIBUTES  305
#define IDM_TOMOVED     310

#define IDC_RCDISP1     501
#define IDC_BAR         510
#define IDC_STATUS      550
#define IDM_ABORT       551
#define IDL_STATLAB     552
#define IDL_NAMES       553

#define IDD_FILE        601
#define IDD_IDENTICAL   602
#define IDD_DIFFER      603
#define IDD_LEFT        604
#define IDD_RIGHT       605

#define IDD_FROMGROUP   610
#define IDD_FROMLEFT    611
#define IDD_FROMRIGHT   612

#define IDS_LINE_NOT_VISIBLE        650
#define IDS_ONLY_IN                 651
#define IDS_DIFFERENT               652
#define IDS_IDENTICAL               653
#define IDS_SAME_SIZE               654
#define IDS_CANT_OPEN_TMP_FILE      655
#define IDS_BAD_ARGUMENT            656
#define IDS_SELECT_FIRST_FILE       657
#define IDS_SELECT_SECOND_FILE      658
#define IDS_COULDNT_FIND            659
#define IDS_CANT_OPEN               660
#define IDS_IDENTICAL_COMMA         661
#define IDS_LEFT_ONLY_COMMA         662
#define IDS_RIGHT_ONLY_COMMA        663
#define IDS_DIFFERING               664
#define IDS_FILES_LISTED            665
#define IDS_ENTER_DIR_NAME          666
#define IDS_FAILED_TO_COPY          667
#define IDS_COPYING                 668
#define IDS_COPY_ABORTED            669
#define IDS_COPY_FAILED             670
#define IDS_COPY_COMPLETE           671
#define IDS_EXIT                    672
#define IDS_COULDNT_FIND_ANYTHING   673
#define IDS_WINDIFF_USAGE           689
#define IDS_ERROR_L_OPTION          690
#define IDS_BAD_SLM_INI             691
#define IDS_PAGE                    692
#define IDS_SENT_TO_PRINTER         693
#define IDS_UNABLE_TO_PRINT         694
#define IDS_WINDIFF_ERROR           695
#define IDS_NO_MORE_CHANGES         696
#define IDS_NO_PREV_CHANGES         697
#define IDS_OUTLINE                 698
#define IDS_EXPAND                  699
#define IDS_FILE_DOESNT_EXIST       700
#define IDS_FAILED_TO_LAUNCH_EDT    701
#define IDS_COMPARING               702
#define IDS_SCANNING                703
#define IDS_ABORT                   704
#define IDS_PLEASE_WAIT             705
#define IDS_ABORT_PENDING           706
#define IDS_SECONDS                 707
#define IDS_TRACING_ENABLED         708
#define IDS_TRACING_DISABLED        709
#define IDS_CREATE_DIFF_LIST        710
#define IDS_TOOL_DESCRIPTION        711
#define IDS_EDITOR_COMMAND          712
#define IDS_HEADER_LINE_STR         713
#define IDS_IDENTICAL_TIMES         714
#define IDS_DIFF_BLANK_ONLY         715
#define IDS_ENTER_SUBSTRING1        716
#define IDS_ENTER_SUBSTRING2        717
#define IDS_MARK_FILES              718
#define IDS_ENTER_PASSWORD          719
#define IDS_COPYING_NFILES          720
#define IDS_BOTH_UNREADABLE         721
#define IDS_LEFT_UNREADABLE         722
#define IDS_RIGHT_UNREADABLE        723
#define IDS_UNREADABLE              724
#define IDS_IS_MORE_RECENT          725
#define IDS_IS_READONLY             726
#define IDS_COPY_FILES              727
#define IDS_NOTHING_RESCANNED       728
#define IDS_NOTHING_TO_EDIT         729
#define IDS_ERR_OPENING_FILE        730
#define IDS_SAVE_COMPFILE           731

#define IDS_USAGE_STR00             732
#define IDS_USAGE_STR01             733
#define IDS_USAGE_STR02             734
#define IDS_USAGE_STR03             735
#define IDS_USAGE_STR04             736
#define IDS_USAGE_STR05             737
#define IDS_USAGE_STR06             738
#define IDS_USAGE_STR07             739
#define IDS_USAGE_STR08             740
#define IDS_USAGE_STR08B            741
#define IDS_USAGE_STR09             742
#define IDS_USAGE_STR10             743
#define IDS_USAGE_STR11             744
#define IDS_USAGE_STR12             745
#define IDS_USAGE_STR13             746
#define IDS_USAGE_STR14             747
#define IDS_USAGE_STR15             748
#define IDS_USAGE_STR16             749
#define IDS_USAGE_STR17             750
#define IDS_USAGE_STR18             751
#define IDS_USAGE_STR19             752
#define IDS_USAGE_STR20             753
#define IDS_USAGE_STR21             754
#define IDS_USAGE_STR22             755
#define IDS_USAGE_STR23             756
#define IDS_USAGE_STR24             757
#define IDS_USAGE_STR25             758
#define IDS_USAGE_STR26             759

#define IDS_GOTOLINE_INVALIDSTRING  800
#define IDS_GOTOLINE_NOLINES        801
#define IDS_FIND_NOTFOUND           802
#define IDS_TABWIDTH				803
#define IDS_BAD_TABWIDTH			804
#define IDS_BAD_SD_INI				805
#define IDS_NOCOMPUNICODE			806
#define IDS_ERROR_LO_OPTION			807
#define IDS_ERROR_OVSD_OPTION		808
#define IDS_ERROR_LD_OPTION			809
// --- UNUSED - RECYCLE ME ---          810
#define IDS_ERROR_IARGS				811
#define IDS_ERROR_IARGS_OPENFILE	812
#define IDS_ERROR_CANTLOADRICHEDIT	813
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\windiff\view.c ===
/*
 * view.c
 *
 *       map rows in window to items in COMPLIST
 *
 *
 * A view owns a COMPLIST, and talks to a table window. The table window
 * shows 3 columns: line nr, tag and text. We also need to supply a state
 * for each row (used to select colour scheme).
 *
 * The COMPLIST can give us a list of its COMPITEMs. Each of these can give
 * us a tag (eg the filenames compared) and the text (usually the compare
 * result), and the state. We make the line number from the
 * COMPITEM's place in the list.
 *
 * If we are asked to switch to 'expand' mode, we ask the selected COMPITEM
 * for its composite section list. We can then get the state (and thus
 * the tag) from each SECTION, and the line nr and text from the LINEs within
 * each section.
 *
 * When moving between expand and outline, and when refreshing the view
 * for some option change, we have to be careful to keep the current row
 * and the selected row in the table what the user would expect (!)
 *
 *
 * WIN32: Functions in this module can be called from the UI thread (to refresh
 * the display) and simultaneously from a worker thread to update the
 * view mapping (view_setcomplist, view_newitem). We use a critical section
 * to manage the synchronisation. We need to protect all access/modification
 * to the view structure elements (particularly bExpand, rows, pLines and
 * pItems), BUT we must not hold the critical section over any calls
 * to SendMessage.
 *
 * we use the global options in windiff.h, and we allocate memory from the
 * heap hHeap which has been initialised elsewhere. Points in time-intensive
 * loops call Poll() defined elsewhere.
 *
 * Geraint Davies, July 92
 */

#include <windows.h>
#include <stdlib.h>
#include <commdlg.h>
#include <gutils.h>
#include <table.h>

#include "state.h"
#include "windiff.h"
#include "wdiffrc.h"

#include "list.h"
#include "line.h"
#include "scandir.h"
#include "file.h"
#include "section.h"
#include "compitem.h"
#include "complist.h"
#include "findgoto.h"

#include "view.h"

/*
 * data structures
 */
#ifdef WIN32
#define huge
#endif

/* in expand mode, we keep an array of one of these per screen line. */
typedef struct viewline {
        LINE line;              /* handle to LINE for this row */
        SECTION section;        /* handle to section containing this line */
        int nr_left;            /* line nr in left file */
        int nr_right;           /* line nr in right file */
} VIEWLINE, FAR * PVIEWLINE;


/*
 * The users VIEW handle is in fact a pointer to this structure
 */
struct view {

        HWND     hwnd;          /* the table window to send notifies to */

        COMPLIST cl;            /* the complist that we own */

        BOOL     bExpand;       /* true if we are in expand mode */
        BOOL     bExpanding;    /* set by view_expandstart, reset by view_expand
                                   interrogated in windiff.c, causes keystrokes
                                   to be ignored.  Protects against mappings being
                                   messed up by another thread.
                                   (I have doubts about this - Laurie).
                                */
        BOOL     bExpandGuard;  /* Protects against two threads both trying to
                                   expand the same item.
                                */

        COMPITEM ciSelect;      /* selected compitem (in expand mode) */

        int      rows;          /* number of rows in this view */

        char     nrtext[12];    /* we use this in view_gettext for the line
                                 * number column. overwritten on each call
                                 */
        int      maxtag, maxrest;/* column widths in characters for cols 1, 2 */

        /* if we are in outline mode, we map the row number to one entry
         * in this array of COMPITEM handles. this pointer will
         * be NULL in expand mode
         */
        COMPITEM FAR * pItems;

        /* in expand mode we use this array of line and section handles */
        PVIEWLINE pLines;
};

#ifdef WIN32

CRITICAL_SECTION CSView;       /* also known to Windiff.c WM_EXIT processing */
static BOOL bDoneInit = FALSE;

#define ViewEnter()     EnterCriticalSection(&CSView);
#define ViewLeave()     LeaveCriticalSection(&CSView);

#else //WIN32

#define ViewEnter()
#define ViewLeave()

#endif //WIN32


extern long selection;
extern long selection_nrows;

/*------- forward declaration of internal functions ----------------*/

void view_outline_opt(VIEW view, BOOL bRedraw, COMPITEM ci, int* prow);
void view_freemappings(VIEW view);
int view_findrow(VIEW view, int number, BOOL bRight);
BOOL view_expand_item(VIEW view, COMPITEM ci);


/* -----  externally-called functions---------------------------*/
/* view_new
 *
 * create a new view. at this point, we are told the table window handle,
 * and nothing else.
 *
 */
VIEW
view_new(HWND hwndTable)
{
        VIEW view;

#ifdef WIN32
        if (!bDoneInit) {
                InitializeCriticalSection(&CSView);
                bDoneInit = TRUE;
        }
#endif

        /* alloc the view from the heap */
        view = (VIEW) gmem_get(hHeap, sizeof(struct view));

        /* set the default fields */
        view->hwnd = hwndTable;
        view->cl = NULL;
        view->bExpand = FALSE;
        view->bExpandGuard = FALSE;
        view->ciSelect = NULL;
        view->rows = 0;
        view->pItems = NULL;
        view->pLines = NULL;

        return(view);
}


/*
 * view_setcomplist.
 *
 * We have to separate view_new and view_setcomplist because we need
 * to give the view handle to the complist and the complist handle to the
 * view. So do a view_new to create a null view; then complist_new() to
 * which you pass a view handle. The complist will then register itself
 * with the view by calling this function. During the build of the complist,
 * it will also update us by calling view_additem, so that we can refresh
 * the display.
 *
 * Here we should initialise an outline view of the complist.
 *
 * We also talk to the status bar using SetNames to set the names of
 * the two items.
 */
BOOL
view_setcomplist(VIEW view, COMPLIST cl)
{
        LPSTR both;

        if (view == NULL) {
                return(FALSE);
        }

        /* there can be only one call to this per VIEW */
        if (view->cl != NULL) {
                return (FALSE);
        }

        ViewEnter();

        view->cl = cl;

        /* set names on status bar to root names of left and right trees */
        both = complist_getdescription(cl);
        ViewLeave();                      // LKGHACK
        SetNames(both);
        ViewEnter();                      // LKGHACK
        complist_freedescription(cl, both);

        ViewLeave();

        view_outline(view);
        return TRUE;
}


/*
 * return a handle to the complist owned by this view
 */
COMPLIST
view_getcomplist(VIEW view)
{
        if (view == NULL) {
                return(NULL);
        }

        return(view->cl);
}


/*
 * close a view. notify the table window that this view should be
 * closed. When the table window has finished with it, it will send
 * a TQ_CLOSE notify that should result in view_delete being called
 * and the memory being freed.
 */
void
view_close(VIEW view)
{
        if (view == NULL) {
                return;
        }

        SendMessage(view->hwnd, TM_NEWID, 0, 0);
}


/*
 * delete a view and all associated data.
 *
 * This function should only be called in response to the table window
 * sending a TQ_CLOSE message. To close the view, call view_close and
 * wait for the TQ_CLOSE before calling this.
 *
 * We delete the associated COMPLIST and all its associated structures.
 */
void
view_delete(VIEW view)
{
        if (view == NULL) {
                return;
        }

        /* we have two arrays that are used for the mapping - an array
         * of compitem handles in outline mode, and an array of
         * VIEWLINE structures in expand mode
         */

        view_freemappings(view);

        complist_delete(view->cl);

        gmem_free(hHeap, (LPSTR) view, sizeof(struct view));
}


/*
 * view_outline
 *
 * build an outline mode mapping where one row represents one COMPITEM in
 * the list. check the global option flag outline_include to see which items
 * we should include.
 *
 * If we were in expand mode, then set as the selection the row in outline mode
 * that we were expanding. Also remember to free up the expand mode mapping
 * array
 *
 * once we have built the new mapping, notify the table window to
 * redraw itself.
 */
void
view_outline(VIEW view)
{
        if (view == NULL) {
                return;
        }

        /* all work done by view_outline_opt - this function
         * gives us the option of not updating the display
         */
        view_outline_opt(view, TRUE, NULL, NULL);
}



/*
 * switch to expand mode, expanding the given row into a view
 * of the differences in that file.
 *
 * map the given row nr into a compitem handle, and then
 * call the internal function with that.
 *
 * It is legal (and a no-op) if this function is called with
 * row==-1.
 */
BOOL
view_expand(VIEW view, long row)
{
        COMPITEM ci;
        BOOL bRet;

   if (row<0) return FALSE;

        ViewEnter();

        if ((view == NULL) || (view->bExpand)) {
                /* no view, or already expanded */
                ViewLeave();
                return(FALSE);
        }

        if (row >= view->rows) {
                /* no such row */
                ViewLeave();
                return FALSE;
        }

        /* remember the compitem we are expanding */
        ci = view->pItems[row];

        bRet = view_expand_item(view, ci);
        // view_expand_item does the...
        // ViewLeave();
        return(bRet);
}


/*
 * return the text associated with a given column of a given row.
 * Return a pointer that does not need to be freed after use - ie
 * a pointer into our data somewhere, not a copy
 */
LPSTR
view_gettext(VIEW view, long row, int col)
{
        int line;
        int state;
        LPSTR pstr;

        pstr = NULL;   /* kill spurious diagnostic */
        if (view == NULL) {
                return (NULL);
        }

        ViewEnter();

        if (row >= view->rows) {
                ViewLeave();
                return(NULL);
        }

        if (view->bExpand) {
                /* we are in expand mode */

                state = section_getstate(view->pLines[row].section);

                switch(col) {
                case 0:
                        /* row nr */

                        /* line numbers can be from either original file
                         * this is a menu-selectable option
                         */
                        line = 0;
                        switch(line_numbers) {
                        case IDM_NONRS:
                                pstr = NULL;
                                break;

                        case IDM_LNRS:
                                line = view->pLines[row].nr_left;
                                if (state == STATE_MOVEDRIGHT
                                    || state == STATE_SIMILARRIGHT) {
                                        line = -line;
                                }
                                break;

                        case IDM_RNRS:
                                line = view->pLines[row].nr_right;
                                if (state == STATE_MOVEDLEFT
                                    || state == STATE_SIMILARLEFT) {
                                        line = -line;
                                }
                                break;
                        }
                        if (line == 0) {
                                ViewLeave();
                                return(NULL);
                        }

                        if (line < 0) {
                                /* lines that are moved appear twice.
                                 * show the correct-sequence line nr
                                 * for the out-of-seq. copy in brackets.
                                 */
                                wsprintf(view->nrtext, "(%d)", abs(line));
                        } else  {
                                wsprintf(view->nrtext, "%d", line);
                        }
                        pstr = view->nrtext;
                        break;

                case 1:
                        /* tag text - represents the state of the line */


                        switch(state) {
                        case STATE_SAME:
                                pstr = "    ";
                                break;

                        case STATE_LEFTONLY:
                        case STATE_SIMILARLEFT:
                                pstr = " <! ";
                                break;

                        case STATE_RIGHTONLY:
                        case STATE_SIMILARRIGHT:
                                pstr = " !> ";
                                break;

                        case STATE_MOVEDLEFT:
                                pstr = " <- ";
                                break;

                        case STATE_MOVEDRIGHT:
                                pstr = " -> ";
                                break;
                        }
                        break;

                case 2:
                        /* main text - line */
                        pstr = line_gettext(view->pLines[row].line);
                        break;
                }
        } else {
                /* outline mode */
                switch(col) {
                case 0:
                        /* row number - just the line number */
                        wsprintf(view->nrtext, "%d", row+1);
                        pstr = view->nrtext;
                        break;

                case 1:
                        /* tag */
                        pstr = compitem_gettext_tag(view->pItems[row]);
                        break;

                case 2:
                        /* result text */
                        pstr = compitem_gettext_result(view->pItems[row]);
                        break;
                }
        }
        ViewLeave();
        return(pstr);
}


/*
 * return the text associated with a given column of a given row.
 * Return a pointer that does not need to be freed after use - ie
 * a pointer into our data somewhere, not a copy
 */
LPWSTR
view_gettextW(VIEW view, long row, int col)
{
        int state;
        LPWSTR pwz;

        pwz = NULL;   /* kill spurious diagnostic */
        if (view == NULL) {
                return (NULL);
        }

        ViewEnter();

        if (row >= view->rows) {
                ViewLeave();
                return(NULL);
        }

        if (view->bExpand) {
                /* we are in expand mode */

                state = section_getstate(view->pLines[row].section);

                switch(col) {
                case 2:
                        /* main text - line */
                        pwz = line_gettextW(view->pLines[row].line);
                        break;
                }
        }
        ViewLeave();
        return(pwz);
}

/*
 * return the line number that this row had in the original left
 * file. 0 if not in expand mode. 0 if this row was not in the left file.
 * -(linenr) if this row is a MOVED line, and this is the right file
 * copy
 */
int
view_getlinenr_left(VIEW view, long row)
{
        int state, line;

        if ((view == NULL) || (row >= view->rows) || !view->bExpand) {
                return 0;
        }

        ViewEnter();
        state = section_getstate(view->pLines[row].section);
        line = view->pLines[row].nr_left;
        if (state == STATE_MOVEDRIGHT || state == STATE_SIMILARRIGHT) {
                line = -line;
        }
        ViewLeave();

        return(line);
}

/*
 * return the line number that this row had in the original right
 * file. 0 if not in expand mode. 0 if this row was not in the right file.
 * -(linenr) if this row is a MOVED line, and this is the left file
 * copy
 */
int
view_getlinenr_right(VIEW view, long row)
{
        int state, line;

        if ((view == NULL) || (row > view->rows) || !view->bExpand) {
                return 0;
        }

        ViewEnter();

        state = section_getstate(view->pLines[row].section);
        line = view->pLines[row].nr_right;
        if (state == STATE_MOVEDLEFT || state == STATE_SIMILARLEFT) {
                line = -line;
        }
        ViewLeave();

        return(line);
}



/* find the maximum width in characters for the given column */
int
view_getwidth(VIEW view, int col)
{
        if (view == NULL) {
                return(0);
        }

        switch(col) {
        case 0:
                /* line nr column - always 5 characters wide */
                return(5);

        case 1:
                /* this is a proportional font field, so add on a margin
                 * for error
                 */
                return(view->maxtag + (view->maxtag / 20));
        case 2:
                /* this now includes the tab expansion allowance */
                return(view->maxrest);
        default:
                return(0);
        }
}

/* how many rows are there in this view ? */
long
view_getrowcount(VIEW view)
{
        if (view == NULL) {
                return(0);
        }

        return(view->rows);
}

/* return the state for the current row. This is used
 * to select the text colour for the row
 *
 * states for sections are obtained from section_getstate (and apply, and
 * to all lines in that section. States for compitems are obtained
 * from compitem_getstate.
 */
int
view_getstate(VIEW view, long row)
{
        int state;

        if (view == NULL) {
                return(0);
        }

        ViewEnter();
        if (row >= view->rows) {
                state = 0;
        } else if (view->bExpand) {
                /* its a line state that's needed */
                state = section_getstate(view->pLines[row].section);
        } else {

                /* its a compitem state */
                state = compitem_getstate(view->pItems[row]);
        }
        ViewLeave();
        return(state);
}

/*
 * return the marked state for a given row. Only compitems can be marked,
 * so it will be FALSE unless it is a compitem on which view_setmark or
 * compitem_setmark have previously set the mark state to TRUE.
 */
BOOL
view_getmarkstate(VIEW view, long row)
{
    BOOL bMark = FALSE;

    if (view != NULL) {
   ViewEnter();
   if ( (row < view->rows) && (!view->bExpand)) {
       bMark = compitem_getmark(view->pItems[row]);
   }
   ViewLeave();
    }
    return(bMark);
}

/*
 * set the mark state for a given row. This is only possible for compitem rows.
 * The mark set can be retrieved by view_getmarkstate or compitem_getmark.
 *
 * We return FALSE if the state could not be set - eg because the
 * row to set is not a compitem row.
 */
BOOL
view_setmarkstate(VIEW view, long row, BOOL bMark)
{
    BOOL bOK = FALSE;

    if (view != NULL) {
   ViewEnter();
   if ( (row < view->rows) && !view->bExpand) {
       compitem_setmark(view->pItems[row], bMark);
       bOK = TRUE;
   }
   ViewLeave();
    }
    return (bOK);
}


/* return a handle to the current compitem. in expand mode,
 * returns the handle to the compitem we are expanding. In outline
 * mode, returns the handle to the compitem for the given row, if valid,
 * or NULL otherwise. row is only used if not in expand mode.
 */
COMPITEM
view_getitem(VIEW view, long row)
{
        COMPITEM ci;

        if (view == NULL) {
                return(NULL);
        }

        ViewEnter();

        if (!view->bExpand) {
                if ((row >= 0) && (row < view->rows)) {
                        ci = view->pItems[row];
                } else {
                        ci = NULL;
                }
        } else {
                ci = view->ciSelect;
        }

        ViewLeave();
        return(ci);
}

/*
 * return TRUE if the current mapping is expanded mode
 */
BOOL
view_isexpanded(VIEW view)
{
        if (view == NULL) {
                return(FALSE);
        }
        return(view->bExpand);
}


/*
 * return a text string describing the view. This is NULL in outline mode,
 * or the tag text for the current compitem in expanded mode
 */
LPSTR
view_getcurrenttag(VIEW view)
{
        LPSTR str;

        if ((view == NULL) || (!view->bExpand)) {
                return(NULL);
        } else {
                ViewEnter();

                str = compitem_gettext_tag(view->ciSelect);

                ViewLeave();
                return(str);

        }
}


/* notify that CompItems have been added to the complist.
 *
 * rebuild the view (if in outline mode), and refresh the table. Use
 * the table message TM_APPEND if possible (if column widths have not
 * change). If we have to do TM_NEWLAYOUT, then ensure we scroll
 * back to the right row afterwards.
 *
 * This causes a Poll() to take place. We return TRUE if an abort is
 * pending - in this case, the caller should abandon the scan loop.
 *
 * WIN32: enter the critical section for this function since this can be
 * called from the worker thread while the UI thread is using the
 * view that we are about to change.
 *
 * EXCEPT THAT WE DON'T DARE.  We cannot ever call SendMessage from the
 * worker thread within CSView.  If there is conflict, it will hang.
 *
 * 7 feb 96: restructure to hold critical during crucial parts without holding
 * over a SendMessage. This should fix the popular bug when a view_newitem on
 * the scanning thread co-incides with a view_outline caused by a menu
 * selection.
 */
BOOL
view_newitem(VIEW view)
{
        int maxtag, maxrest;
        long rownr;
        TableSelection Select;
        BOOL bSelect;
        COMPITEM ciTop = NULL;
        BOOL bRedraw = FALSE;
        BOOL bAppend = FALSE;

        // get the top row before remapping in case we need it
        /* find the row at the top of the window */
        rownr = (long) SendMessage(view->hwnd, TM_TOPROW, FALSE, 0);
        // also remember the selection
        bSelect = (BOOL) SendMessage(view->hwnd, TM_GETSELECTION, 0, (LPARAM) &Select);

        // *important*:no critsec over SendMessage
        ViewEnter();

        if ((view != NULL) &&
            !(view->bExpand) &&
            !(view->bExpanding)) {

            /* save some state about the present mapping */
            maxtag = view->maxtag;
            maxrest = view->maxrest;


            // remember the compitem this corresponds to
            if (view->pItems && (rownr >= 0) && (rownr < view->rows)) {
                ciTop = view->pItems[rownr];
            }


            // re-do the outline mapping, but don't tell the table class.
            // ask it to check for the visible row closest to ciTop in case
            // we need to refresh the display
            //
            // since we are holding the critsec, the redraw param
            // *must* be false.
            view_outline_opt(view, FALSE, ciTop, &rownr);

            /* have the column widths changed ? */
            if ((maxtag < view->maxtag) || (maxrest < view->maxrest)) {
                /* yes - need complete redraw */
                bRedraw = TRUE;
            } else {
                bAppend = TRUE;
            }
        }

        ViewLeave();


        if (bRedraw) {

            /* switch to new mapping */
            SendMessage(view->hwnd, TM_NEWLAYOUT, 0, (LPARAM) view);

            // go to the visible row closest to the old top row
            if ((rownr >= 0) && (rownr < view->rows)) {
                SendMessage(view->hwnd, TM_TOPROW, TRUE, rownr);
            }

            // select the old selection too (if the table class allowed
            // us to get it)
            if (bSelect) {
                SendMessage(view->hwnd, TM_SELECT,0, (LPARAM) &Select);
            }

        } else if (bAppend) {
            /* we can just append */

            /*
             * in the WIN32 multiple threads case, the mapping may have
             * changed since we released the critsec. however we are still
             * safe. The table will not allow us to reduce the number of
             * rows, so the worst that can happen is that the table will
             * think there are too many rows, and the table message handler
             * will handle this correctly (return null for the text).
             * The only visible effect is therefore that the scrollbar
             * position is wrong.
             */

            SendMessage(view->hwnd, TM_APPEND, view->rows, (LPARAM) view);
        }


        /* Poll to allow multi-tasking on Win3.1, and to keep the UI
         * updated on both 3.1 and NT. Returns true if abort pending.
         */
        return(Poll());
}

/*
 * the view mapping options (eg outline_include, expand_mode) have changed -
 * re-do the mapping and then scroll back to the same position in the window
 * if possible.
 */
void
view_changeviewoptions(VIEW view)
{
        long row;
        int state, number;
        BOOL bRight;

        if (view == NULL) {
                return;
        }

        /* find what row we are currently on. Do this BEFORE we enter CSView */
        row = (long) SendMessage(view->hwnd, TM_TOPROW, FALSE, 0);

        ViewEnter();

        if (!view->bExpand) {


            // view_outline_opt allows us to find the first visible row
            // after a given COMPITEM. Do this to look for the old top-row
            // compitem, so that even if it is no longer visible, we can
            // still go to just after it.

            INT newrow = -1;
            if (row < view->rows) {

                COMPITEM ciTop = view->pItems[row];

                view_outline_opt(view, TRUE, ciTop, &newrow);
            } else {
                view_outline_opt(view, TRUE, NULL, NULL);
            }
            ViewLeave();

            // row now has the visible row that corresponds to
            // ciTop or where it would have been
            if ((newrow >=0) && (newrow < view->rows)) {
                SendMessage(view->hwnd, TM_TOPROW, TRUE, newrow);
            }
            return;
        }

        /* expanded mode */


        bRight = FALSE;  /* arbitrarily - avoid strange diagnostic */
        /* save the line number on one side (and remember which side) */
        if (row >= view->rows) {
                number = -1;
        } else {
                state = section_getstate(view->pLines[row].section);
                if ((state == STATE_MOVEDRIGHT) ||
                    (state == STATE_RIGHTONLY)) {
                            bRight = TRUE;
                            number = view->pLines[row].nr_right;
                } else {
                        bRight = FALSE;
                        number = view->pLines[row].nr_left;
                }
        }

        /* make the new mapping */
        view_expand_item(view, view->ciSelect);
        // view_expand does the
        // ViewLeave();

        /* things may happen now due to simultaneous scrolling from
         * two threads.  At least we won't deadlock.
         */
        /* find the nearest row in the new view */
        if (number >= 0) {

                ViewEnter();
                row = view_findrow(view, number, bRight);
                ViewLeave();

                /* scroll this row to top of window */
                if (row >= 0) {

                        /* things may happen now due to simultaneous scrolling from
                         * two threads.  At least we won't deadlock.
                         */
                        SendMessage(view->hwnd, TM_TOPROW, TRUE, row);
                        return;
                }
        }
}

/* the compare options have changed - re-do the compare completely
 * and make the new mapping. Retain current position in the file.
 */
void
view_changediffoptions(VIEW view)
{
        int state, number;
        long row;
        BOOL bRight = FALSE;
        LIST li;
        COMPITEM ci;

        number = 0;
        if (view == NULL) {
                return;
        }

        /*
         * get current row before entering critsec.
         */
        row = (long) SendMessage(view->hwnd, TM_TOPROW, FALSE, 0);

        ViewEnter();

        /* find the current line number so we can go back to it
         * (only if we are in expanded mode
         */
        if (view->bExpand) {

                state = section_getstate(view->pLines[row].section);
                if ((state == STATE_MOVEDRIGHT) ||
                    (state == STATE_SIMILARRIGHT) ||
                    (state == STATE_RIGHTONLY)) {
                            bRight = TRUE;
                            number = view->pLines[row].nr_right;
                } else {
                        bRight = FALSE;
                        number = view->pLines[row].nr_left;
                }
        }

        /* to force a recompare using the new options, we must
         * tell each compitem to discard its current compare result.
         * we need to traverse the list of compitems calling this
         * for each compare.
         */
        li = complist_getitems(view->cl);

        for (ci = (COMPITEM) List_First(li); ci != NULL; ci = (COMPITEM) List_Next(ci)) {
                compitem_discardsections(ci);
        }

        if (!view->bExpand) {
                ViewLeave();

                // we are in outline mode. Refreshing the outline view
                // will pick up any tag and tag width changes
                view_outline(view);

                // now scroll to the previous position if still there
                if (row < view->rows) {
                    SendMessage(view->hwnd, TM_TOPROW, TRUE, row);
                }

                return;
        }

        view_expand_item(view, view->ciSelect);
        // view_expand will have done a...
        // ViewLeave();

        /* find the nearest row in the new view */
        ViewEnter();
        row = view_findrow(view, number, bRight);
        ViewLeave();

        /* scroll this row to top of window */
        if (row >= 0) {
                SendMessage(view->hwnd, TM_TOPROW, TRUE, row);
        }
}


/* find the next changed - ie non-same - row in a given direction.
 * for outline mode we find the next STATE_DIFFER. for expand mode, we
 * find the next section
 */
long
view_findchange(VIEW view, long startrow, BOOL bForward)
{
        long i;

        if (view == NULL) {
                return(0);
        }

        if (view->rows <= 0) {
            return (-1);
        }

        ViewEnter();

        if (bForward) {

                if (startrow >= view->rows) {
                        ViewLeave();
                        return(-1);
                }

                if (!view->bExpand) {

                        /* look for next compitem with an expandable state*/
                        for (i = startrow; i < view->rows; i++) {
                                if (compitem_getstate(view->pItems[i]) == STATE_DIFFER) {
                                        ViewLeave();
                                        return(i);
                                }
                        }
                        /* none found */
                        ViewLeave();
                        return(-1);
                } else {
                        /*
                         * find the next line that matches, then go on to the
                         * next line that does not match
                         *
                         */
                        for (i= startrow; i < view->rows; i++) {
                                if (section_getstate(view->pLines[i].section)
                                        == STATE_SAME) {
                                                break;
                                }
                        }
                        for ( ; i < view->rows; i++) {
                                if (section_getstate(view->pLines[i].section)
                                        != STATE_SAME) {
                                                ViewLeave();
                                                return(i);
                                }
                        }

                        ViewLeave();

                        return(-1);
                }
        } else {
                /* same search backwards */
                if (startrow < 0) {
                        ViewLeave();
                        return(-1);
                }
                if (view->bExpand) {
                        /* search backwards for first row that is not
                         * changed (has state SAME). then carry on for
                         * the next changed row.
                         */
                        for (i = startrow; i >= 0; i--) {
                                if (section_getstate(view->pLines[i].section)
                                        == STATE_SAME) {
                                                break;
                                }
                        }
                        for ( ; i >= 0; i--) {
                                if (section_getstate(view->pLines[i].section)
                                        != STATE_SAME) {
                                                ViewLeave();
                                                return(i);
                                }
                        }
                        ViewLeave();
                        return(-1);
                } else {
                        for (i = startrow; i >= 0; i--) {
                                if(compitem_getstate(view->pItems[i]) == STATE_DIFFER) {
                                        ViewLeave();
                                        return(i);
                                }
                        }
                        ViewLeave();
                        return(-1);
                }
        }
}


int view_getrowstate(VIEW view, long row)
{
        int state;

        if (view == NULL) {
                return(0);
        }

        if (view->rows <= 0 || row >= view->rows) {
            return (STATE_SAME);
        }

        ViewEnter();

        state = section_getstate(view->pLines[row].section);

        ViewLeave();

        return state;
}

/*
 * the WIN32 multithread version can try view_expand and view_outline
 * (or view_newitem) at the same time. This is not correctly protected by
 * the critical section, since there are major restrictions about holding
 * critsecs when sending messages from the worker thread.
 *
 * To avoid contention, we call this function to notify that we are
 * starting expanding. view_newitem and ToOutline will return without
 * doing anything if this function has been called and view_expand has not
 * completed.
 */
void
view_expandstart(VIEW view)
{
    view->bExpanding = TRUE;
}

// are we in the middle of expansion ?
BOOL
view_expanding(VIEW view)
{
    return(view->bExpanding);

}



/* ---- internal functions ------------------------------------------ */


/* find the new row number for the line numbered 'number'
 * or the nearest line if possible. if bRight is true, number is
 * a right file number; otherwise it is a left file number.
 *
 * we must be in expand mode
 */
int
view_findrow(
             VIEW view,
             int number,
             BOOL bRight
             )
{
        int i;

        if (!view->bExpand) {
                return(0);
        }

        for (i = 0; i < view->rows; i++) {

                if (bRight) {
                        if (view->pLines[i].nr_right == number) {

                                /* found the exact number */
                                return(i);

                        } else if (view->pLines[i].nr_right > number) {

                                /* passed our line -stop here */
                                return(i);
                        }
                } else {
                        if (view->pLines[i].nr_left == number) {

                                /* found the exact number */
                                return(i);

                        } else if (view->pLines[i].nr_left > number) {

                                /* passed our line -stop here */
                                return(i);
                        }
                }
        }
        return(-1);
}

/* free memory associated with the expand mode or outline mode mappings
 * called whenever we rebuild the mapping, and on deletion
 */
void
view_freemappings(
                  VIEW view
                  )
{

        if (view->pLines) {
#ifndef WIN32
      GlobalFree(LOWORD(GlobalHandle(SELECTOROF(view->pLines))));
      view->pLines = NULL;
#else
                gmem_free(hHeap, (LPSTR) view->pLines,
                        view->rows * sizeof(VIEWLINE));
                view->pLines = NULL;
#endif
        } else if (view->pItems) {

                /* previous outline mapping array is still there - free it
                 * before we build a new one
                 */

                gmem_free(hHeap, (LPSTR) view->pItems,
                        view->rows * sizeof(COMPLIST));
                view->pItems = NULL;
        }
        view->rows = 0;   // Johny Lee's fix for MIPS
}

/* build a view outline to map one row to a COMPITEM handle by traversing
 * the list of COMPITEMs obtained from our complist.
 * optionally tell the table class to redraw (if bRedraw), and if so,
 * scroll the new table to select the row that represents the
 * file we were expanding, if possible
 *
 * *important*: if you are holding the view critsec when you call this, you
 * must pass bRedraw as FALSE or you could deadlock
 *
 * if a COMPITEM ci is passed in, then return in *prow the row number that
 * corresponds to this item in the new view, or if not visible, the first
 * visible row after it (to retain current scroll position)
 */
void
view_outline_opt(
                 VIEW view,
                 BOOL bRedraw,
                 COMPITEM ciFind,
                 int * prow
                 )
{
        int prev_row = -1;      /* the row nr of the previously-expanded row*/
        int i;                  /* nr of includable items */
        LIST li;
        COMPITEM ci;
        int state;
        TableSelection select;

        /*
         * check that view_setcomplist has already been called. if not,
         * nothing to do
         */
        if (view->cl == NULL) {
                return;
        }

        ViewEnter();

        /* clear the mode flag and free up memory associated with expand mode */
        view->bExpand = FALSE;
        view_freemappings(view);

        /* traverse the list of compitems counting up the number of
         * includable items
         */
        li = complist_getitems(view->cl);

        ci = (COMPITEM) List_First(li);
        for (i = 0; ci != NULL; ci = (COMPITEM) List_Next(ci)) {

                if ((ciFind != NULL) && (prow != NULL)) {
                    if (ci == ciFind) {
                        // now that we have found the requested item,
                        // the next visible row is the one we want,
                        // whether it is ci or a later one
                        *prow = i;
                    }
                }

                state = compitem_getstate(ci);

                if (((outline_include & INCLUDE_SAME) && (state == STATE_SAME)) ||
                    ((outline_include & INCLUDE_DIFFER) && (state == STATE_DIFFER)) ||
                    ((outline_include & INCLUDE_LEFTONLY) && (state == STATE_FILELEFTONLY)) ||
                    ((outline_include & INCLUDE_RIGHTONLY) && (state == STATE_FILERIGHTONLY))) {
                    if (!compitem_getmark(ci) || !hide_markedfiles) {
                        i++;
                    }
                }
        }


        /* allocate an array big enough for all of these */
        { /* DO NOT link in any storage with garbage pointers in it */
            COMPITEM FAR * temp;
            temp = (COMPITEM FAR *)gmem_get(hHeap, i * sizeof(COMPITEM));
       // done by gmem get
            //memset(temp, 0, i * sizeof(COMPITEM));
            view->pItems = temp;
        }
        view->rows = i;

        /* keep track of the column widths */
        view->maxtag = 0;
        view->maxrest = 0;

        /* loop through again filling the array, and at the same time looking
         * out for the handle of the previously expanded item
         */
        ci = (COMPITEM) List_First(li);
        for (i = 0; ci != NULL; ci = (COMPITEM) List_Next(ci)) {

                state = compitem_getstate(ci);

                if (((outline_include & INCLUDE_SAME) && (state == STATE_SAME)) ||
                    ((outline_include & INCLUDE_DIFFER) && (state == STATE_DIFFER)) ||
                    ((outline_include & INCLUDE_LEFTONLY) && (state == STATE_FILELEFTONLY)) ||
                    ((outline_include & INCLUDE_RIGHTONLY) && (state == STATE_FILERIGHTONLY))) {

         if (!compitem_getmark(ci) || !hide_markedfiles) {

                            view->pItems[i] = ci;

                            if (ci == view->ciSelect) {
                                    prev_row = i;
                            }

                            /* check the column widths in characters */
                            view->maxtag = max(view->maxtag,
                                               lstrlen(compitem_gettext_tag(ci)));
                            view->maxrest = max(view->maxrest,
                                                lstrlen(compitem_gettext_result(ci)));


                            i++;
         }

                }
        }
        ViewLeave();

        /* inform table of new layout of table - force refresh */
        if (bRedraw) {
                SendMessage(view->hwnd, TM_NEWLAYOUT, 0, (LPARAM) view);

                /* scroll to and highlight the row that represents the file
                 * we were previously expanding
                 */
                if (prev_row != -1) {
                        select.startrow = prev_row;
                        select.startcell = 0;
                        select.nrows = 1;
                        select.ncells = 1;
                        SendMessage(view->hwnd, TM_SELECT, 0, (LPARAM) &select);
                }
        }
}


/* expand a view - given the handle to the compitem to expand.
 *
 * called from view_expand, and also to re-do an expanded view
 * after options change in view_changediffoptions and _changeviewoptions
 *
 * we get the composite section list from the compitem,
 * and pick out all the sections that are includable (according
 * to the global option expand_mode: we include all sections, or
 * just those in one side left or right). Once we know the count of rows,
 * allocate the mapping array: in each element of the array we keep
 * a handle to the section for that row (to get the state and hence the
 * tag text), and a handle to the line within that section (for the line text).
 *
 * We no longer insist on only expanding text files that differ - if the
 * compitem can give us a composite section list, we will map it.
 *
 * We need to be able to give a line number for a line, in either of
 * the original files according to which option is in force. Each section
 * can give us its base line number (number of first line in section) in
 * each of the two files or 0 if not present, and we track these here.
 *
 * MUST BE INSIDE CSView BEFORE CALLING HERE.
 */
BOOL
view_expand_item(
                 VIEW view,
                 COMPITEM ci
                 )
{
        LIST li;
        SECTION sh;
        LINE line1, line2;
        int i, base_left, base_right, state;

        // We could be on a second thread trying to expand while it's
        // already going on.  That ain't clever!
        if (view->bExpandGuard) {
            Trace_Error(NULL, "Expansion in progress.  Please wait.", FALSE);
            ViewLeave();
            return FALSE;
        }

        // Ensure that the world knows that we are expanding
        // before we leave the critical section.
        // This is the only way into getcomposite.
        view->bExpandGuard = TRUE;

	// the compitem_getcomposite could take a long time
	// if the file is large and remote. We need to
	// release the critsec during this operation.

	ViewLeave();
        /* get the composite section list */
        li = compitem_getcomposite(ci);
        if (li == NULL) {
            view->bExpanding = FALSE;
            view->bExpandGuard = FALSE;
            return FALSE;
        }

	ViewEnter();

        /* remember the compitem we are expanding */
        view->ciSelect = ci;

        /* switch modes and free the current mapping
         *
         * NOTE: must do this AFTER the compitem_getcomposite,
         * since that can fail: if it fails it could put up a
         * message box, and that could cause a queued paint message
         * to be processed, which would cause us to use these mappings
         * and gpfault if they had been cleared first.
         */
        view->bExpand = TRUE;
        view->bExpanding = FALSE;
        view->bExpandGuard = FALSE;
        view_freemappings(view);


        /* loop through totalling the lines in sections
         * that we should include
         */
        view->rows = 0;
        for ( sh = (SECTION) List_First(li); sh != NULL;
            sh = (SECTION) List_Next(sh)) {

                state = section_getstate(sh);

                if (expand_mode == IDM_RONLY) {
                        if ((state == STATE_LEFTONLY) ||
                            (state == STATE_SIMILARLEFT) ||
                            (state == STATE_MOVEDLEFT)) {
                                    continue;
                        }
                } else if (expand_mode == IDM_LONLY) {
                        if ((state == STATE_RIGHTONLY) ||
                            (state == STATE_SIMILARRIGHT) ||
                            (state == STATE_MOVEDRIGHT)) {
                                    continue;
                        }
                }

                /* include all lines in this section
                   if the section meets the include criteria */
                if ( ((state == STATE_SAME)         && (expand_include & INCLUDE_SAME))
                  || ((state == STATE_LEFTONLY)     && (expand_include & INCLUDE_LEFTONLY))
                  || ((state == STATE_RIGHTONLY)    && (expand_include & INCLUDE_RIGHTONLY))
                  || ((state == STATE_MOVEDLEFT)    && (expand_include & INCLUDE_MOVEDLEFT))
                  || ((state == STATE_MOVEDRIGHT)   && (expand_include & INCLUDE_MOVEDRIGHT))
                  || ((state == STATE_SIMILARLEFT)  && (expand_include & INCLUDE_SIMILARLEFT))
                  || ((state == STATE_SIMILARRIGHT) && (expand_include & INCLUDE_SIMILARRIGHT))) {
                         view->rows += section_getlinecount(sh);
                }
        }
#ifndef WIN32
        if ( ((long) view->rows * sizeof(VIEWLINE)) > 65535L) {
                // careful here- putting up a dialog box can
                // cause the view to be redrawn
                view->rows = 0;

                MessageBox(hwndClient,
                  "Diff info too large for 16-bit version - truncating",
                  "Windiff", MB_ICONSTOP|MB_OK);

                view->rows = (int) (65535L / sizeof(VIEWLINE));
        }
#endif

        /* allocate the memory for the mapping array */
        {    /* DO NOT chain in any storage with garbage pointers in it */
            PVIEWLINE temp;
#ifdef WIN32
            temp = (PVIEWLINE)gmem_get(hHeap, view->rows * sizeof(VIEWLINE));
       // done in gmem_get
            //memset(temp, 0, view->rows * sizeof(VIEWLINE));
#else
       temp = (PVIEWLINE) GlobalLock(GlobalAlloc(GPTR, view->rows * (long)sizeof(VIEWLINE)));
#endif
            view->pLines = temp;
        }

        /* loop through the sections again filling in the mapping array */
        i = 0;
        view->maxtag = 5;
        view->maxrest = 0;
        for (sh = (SECTION) List_First(li); sh != NULL;
            sh = (SECTION) List_Next(sh)) {

                state = section_getstate(sh);

                if (expand_mode == IDM_RONLY) {
                        if ((state == STATE_LEFTONLY) ||
                            (state == STATE_SIMILARLEFT) ||
                            (state == STATE_MOVEDLEFT)) {
                                    continue;
                        }
                } else if (expand_mode == IDM_LONLY) {
                        if ((state == STATE_RIGHTONLY) ||
                            (state == STATE_SIMILARRIGHT) ||
                            (state == STATE_MOVEDRIGHT)) {
                                    continue;
                        }
                }

                /* include all lines in this section
                   if the section meets the include criteria */
                if ( ((state == STATE_SAME)         && (expand_include & INCLUDE_SAME))
                  || ((state == STATE_LEFTONLY)     && (expand_include & INCLUDE_LEFTONLY))
                  || ((state == STATE_RIGHTONLY)    && (expand_include & INCLUDE_RIGHTONLY))
                  || ((state == STATE_MOVEDLEFT)    && (expand_include & INCLUDE_MOVEDLEFT))
                  || ((state == STATE_MOVEDRIGHT)   && (expand_include & INCLUDE_MOVEDRIGHT))
                  || ((state == STATE_SIMILARLEFT)  && (expand_include & INCLUDE_SIMILARLEFT))
                  || ((state == STATE_SIMILARRIGHT) && (expand_include & INCLUDE_SIMILARRIGHT))) {

                        /* find the base line number in each file */
                        base_left = section_getleftbasenr(sh);
                        base_right = section_getrightbasenr(sh);

                        /* add each line in section to the view. section_getfirst()
                         * returns us to a handle that is in a list. We can
                         * call List_Next and will eventually get to the
                         * line returned by section_getlast(). Sections always have
                         * at least one line
                         */
                        line1 = section_getfirstline(sh);
                        line2 = section_getlastline(sh);

                        for (; line1 != NULL; line1 = (LINE) List_Next(line1)) {

                                view->pLines[i].line = line1;
                                view->pLines[i].section = sh;

                                /* calculate the line number for this line by
                                 * incrementing the base nr for this section.
                                 * Note SIMILAR_RIGHT (or LEFT) lines DO have
                                 * left (or right) numbers, but they are dummies.
                                 */

                                view->pLines[i].nr_left = base_left;
                                if (state!=STATE_SIMILARRIGHT && base_left != 0) {
                                        base_left++;
                                }

                                view->pLines[i].nr_right = base_right;
                                if (state!=STATE_SIMILARLEFT && base_right != 0) {
                                        base_right++;
                                }

                                /* increment index into view */
                                i++;

                                /* check the column widths */
                                view->maxrest = max(view->maxrest,
                                                    (line_gettabbedlength(line1, g_tabwidth)));
#ifndef WIN32
                               // check for truncation (if VIEWLINE array too large)
                               if (i >= view->rows) {
                                   break;
                               }
#endif

                                /* end of section ? */
                                if (line1 == line2) {
                                        break;
                                }
                        }
#ifndef WIN32
                        // check for truncation (if VIEWLINE array too large)
                        if (i >= view->rows) {
                            break;
                        }
#endif
                }
        }

        /* We must NOT hold a critical section here as SendMessage may hang */
        ViewLeave();

        /*inform table window of revised mapping */
        SendMessage(view->hwnd, TM_NEWLAYOUT, 0, (LPARAM) view);

        return(TRUE);
}


/*
 *  view_gethwnd
 *
 */
HWND
view_gethwnd(VIEW view)
{
  return (view) ? view->hwnd : NULL;
}


/*
 *  view_gototableline
 *
 */
void
view_gototableline(VIEW view, LONG iLine)
{
  if (view)
    {
    const LONG cLines = view_getrowcount(view);
    if (iLine >= 0 && iLine < cLines)
      {
      TableSelection select;
      memset(&select, 0, sizeof(TableSelection));
      select.startrow = iLine;
      select.nrows    = 1L;
      select.ncells   = 1L;

      SendMessage(view_gethwnd(view), TM_SELECT, 0, (LPARAM) &select);
      }
    }
}


typedef PUCHAR (*STRSUBFUNC)(PUCHAR, PUCHAR, PUCHAR*);
extern PUCHAR My_mbsistr(PUCHAR, PUCHAR, PUCHAR*);
extern PUCHAR My_mbsstr(PUCHAR, PUCHAR, PUCHAR*);

BOOL
view_findstring(VIEW view, LONG iCol, LPCSTR pszFind, BOOL fSearchDown, BOOL fMatchCase, BOOL fWholeWord)
{
  const LONG cRows = view_getrowcount(view);
  BOOL fFound = FALSE;

  if (cRows > 0)
    {
    STRSUBFUNC pfnSub = (fMatchCase) ? My_mbsstr : My_mbsistr;
    const char *pszRow = NULL;
    const char *pszFound = NULL;
    char *pszEnd = NULL;
    LONG iEnd    = 0;
    LONG iRow    = 0;
    LONG nStep   = 0;
    LONG iWrapAt = 0;
    LONG iWrapTo = 0;

    if (fSearchDown)
      {
      nStep = 1;
      iRow = selection + selection_nrows - 1;
      iWrapAt = cRows;
      iWrapTo = 0;
      }
    else
      {
      nStep = -1;
      iRow = selection;
      iWrapAt = -1;
      iWrapTo = cRows - 1;
      }

    iRow += nStep;
    if (iRow < 0 || iRow >= cRows)
      iRow = iWrapTo;

    iEnd = iRow;

    for (;;)
      {
      pszRow = view_gettext(view, iRow, iCol);
      if (pszRow)
        {
        pszEnd = NULL;
        pszFound = pfnSub((PUCHAR)pszRow, (PUCHAR)pszFind, (PUCHAR*)&pszEnd);
        if (pszFound)
          {
          if (!fWholeWord)
            {
            fFound = TRUE;
            }
          else
            {
            /* check end of string */
            if (!pszEnd || !*pszEnd || (!IsDBCSLeadByte(*pszEnd) && !isalpha(*pszEnd) && !isdigit(*pszEnd)))
              {
              /* check beginning of string */
              if (pszFound == pszRow)
                {
                fFound = TRUE;
                }
              else
                {
                const char *pchT = CharPrev(pszRow, pszFound);
                if (!pchT || !*pchT || (!IsDBCSLeadByte(*pchT) && !isalpha(*pchT) && !isdigit(*pchT)))
                  {
                  fFound = TRUE;
                  }
                }
              }
            }

          if (fFound)
            {
            view_gototableline(view, iRow);
            break;
            }
          }
        }

      iRow += nStep;
      if (iRow == iWrapAt)
        iRow = iWrapTo;

      if (iRow == iEnd)
        break;
      }
    }

  return fFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\windiff\windiff\windiff.c ===
/*
 * Windiff
 *
 * file and directory comparisons.
 *
 *
 * Geraint Davies, July 1991 - July 1992.
 * Laurie Griffiths Nov 91 ("contrast"), July 92 (windiff/contrast merge)
 *
 * Compare two directories (including all files and subdirs). Look for names
 * that are present in both (report all that are not). For files that
 * are present in both, produce a line-by-line comparison of the differences
 * between the two files (if any).
 *
 * Overview of Windiff internals - the whole program.
 *
 * Windiff is built from several modules (a "module" has a .h file
 * which describes its interface and a .c file which implements it)
 * Apart from THIS comment which tries to give an overview of the whole
 * scheme of things, each module is as self-contained as possible.
 * This is enforced by the use of opaque data types.  Modules cannot
 * see each others' internal data structures.  Modules are abstract
 * data types.  The term "Module" (from Modula2) and "Class" (from C++)
 * are used synonymously.
 *
 *    Windiff  - main program - parse arguments, put up main window,
 *               handle input, calling other modules as needed
 *               invoke table class to create the main display and
 *               service callbacks from the table class.
 *               Contains global flags for options (e.g. ignore_blanks)
 *    list     - (in gutils) a generalised LIST of anything data type
 *               has full set of operations for insert, delete, join etc.
 *    line     - a LINE is a numbered line of text.  Information is kept to
 *               allow fast comparisons of LINEs.  A LINE can hold a
 *               link to another LINE.  The links are used to connect
 *               lines in one file to matching lines in the other file.
 *    file     - a FILEDATA represents a file as a file name in the form
 *               of a DIRITEM and a LIST of LINEs
 *    scandir  - a DIRITEM represents information about a file.  (for
 *               instance its name, whether it has a known checksum whether
 *               it has a local copy).
 *               a DIRLIST represents a directory, has information on how to
 *               get to it (remote? pipename? password? UNC name etc) and
 *               (within an imbedded DIRECT structure) a LIST of DIRITEMs
 *               representing the files in the directory and a LIST of
 *               DIRECTs representing its subdirectories.
 *    compitem - a COMPITEM is a pair of files together with information
 *               on how they compare in the form of a breakdown of the
 *               files into a LIST of matching or non-matching sections.
 *               Either file can be absent.  This module contains the
 *               file "contrast" algorithm used for the actual comparison
 *               (Algorithm people see ci_compare then talk to Laurie).
 *    tree       (in gutils) A binary tree.  Important because it is what
 *               gives the file comparison its speed as it makes it
 *               an "N log N" algorithm rather than "N squared"
 *    complist - a COMPLIST is the master data structure.  It has a DIRLIST
 *               of the left hand files, a DIRLIST of the right hand files
 *               and a LIST of COMPITEMs. The left and right hand DIRLISTs
 *               are working data used to produce the COMPLIST.  The LIST
 *               is displayed as the outline table.  Any given COMPITEM can
 *               be displayed as an expanded item.
 *    section  - a SECTION is a section of a file (first line, last line)
 *               and information as to what it matches in the other file.
 *    bar.c    - the picture down the left of the screen
 *               has a WNDPROC.  There is no bar.h, neither is there much
 *               of writeup! ???
 *    view     - Although the COMPLIST is the master state, it doesn't do
 *               all the work itself.  The data is actually displayed by
 *               the table class which is highly generalised.  View
 *               owns a COMPLIST (and therefore calls upon the functions
 *               in complist to fill it and interrogate it) and calls
 *               upon (and is called back by) the functions in table to
 *               actually display it.  Read about table in gutils.h
 *    table.c    (in gutils) a highly generalised system for displaying
 *               data in rows and columns.  The interface is in gutils.h
 *               read it if you hope to understand view!
 *    status.c   (in gutils) the status line at the top. See gutils.h
 *
 * The data structures:
 * Each "module" owns storage which is an encapsulated data type, inaccessable
 * from the outside.  Thus COMPLIST holds a list of COMPITEMs, but they are
 * pointers to structures whose definitions are out of scope, thus they are
 * "just opaque pointers".  To access anything in the COMPITEM you have to
 * call functions in COMPITEM.C.  And so on.  The overall scheme of how they
 * link together is below.  Some things are identified by field name, some by
 * type name, some both, some abbreviations.  Many connecting arrows omitted.
 * Look in the C files for details.
 *
 * COMPLIST
 * > left   -----------> DIRLIST    <--------------------
 * > right  -----------> > rootname                       |
 * > LIST of items--     > bFile                          |
 *                  |    > bRemote                        |
 *                  |    > bSum                           |
 *  ----------------     > dot--------> DIRECT     <------+-------------------------
 * |                     > server       > relname         |                         |
 * |                     > hpipe        > DIRLIST head ---                          |
 * |                     > uncname      > DIRECT parent                             |
 * |                     > password     > bScanned                                  |
 * |                                    > LIST of diritems-----> DIRITEM            |
 * |                                    > LIST OF directs     -> > name             |
 * |                                    > enum pos           |   > int size         |
 * |                                    > DIRECT curdir      |   > int checksum     |
 * |                                                         |   > bool sumvalid    |
 * |                                                         |   > DIRECT direct ---
 * |                                                         |   > localname
 *  --->COMPITEM                                             |   > bLocalIsTemp
 *      > left-------------------> FILEDATA                  |
 *      > right------------------> > DIRITEM-----------------
 *      > LIST of CompSecs---      > LIST of lines--> LINE
 *      > LIST of LeftSecs---|                    --> > flags
 *      > LIST of RightSecs--|                   |    > text
 *                           |                   |    > hash
 *                           |                   |    > link
 *                           |                   |    > linenr
 *                            --> SECTION        |
 *                                > first--------|
 *                                > last---------
 *                                > bDiscard
 *                                > SECTION link
 *                                > SECTION correspond
 *                                > int state
 *                                > int leftbase
 *                                > int rightbase
 *
 *
 *************************************************************************
 *
 * Overview of THIS file's business:
 *
 *   we create a table window (gutils.dll) to show the files and the
 *   results of their comparisons. We create a COMPLIST object representing
 *   a list of files and their differences, and a VIEW object to map between
 *   the rows of the table window and the COMPLIST.
 *
 *   This module is responsible for creating and managing the main window,
 *   placing the child windows (table, status window etc) within it, and
 *   handling all menu items. We maintain global option flags set by
 *   menu commands.
 *
 *   Creating a COMPLIST creates a list of unmatched files, and of matching
 *   files that are compared with each other (these are COMPITEMS).
 *   The VIEW provides a mapping between rows on the screen, and items in
 *   the COMPLIST.
 *
 * Something about threads:  (See also thread DOGMA, below)
 *
 *   The win32 version tries to maintain a responsive user interface by
 *   creating worker threads to do long jobs.  This potentially creates
 *   conflicts between the threads as they will both want to update common
 *   variables (for instance the UI thread may be changing the options to
 *   exclude identical files while the worker thread is adding in the
 *   results of new comparisons).  Critical sections are used to manage
 *   the conflicts (as you'd expect).
 *
 *   The Edit options invoke an editor on a separate thread.  This allows
 *   us to repaint our window and thereby allow the user to refer back to
 *   what he saw before invoking the editor.  When he's finished editing,
 *   we would of course like to refresh things and if this is still on the
 *   separate thread it might clash. We avoid this clash by POSTing ourselves
 *   a (WM_COMMAND, IDM_UPDATE) message.
 */

#include <windows.h>
#include <shellapi.h>
#include <stdlib.h>

#include <commdlg.h>            /* needed for table.h */
#include <gutils.h>
#include <table.h>
#include <string.h>
#include <richedit.h>           /* needed for usage dialog */

#include "list.h"               /* needed for compitem.h */
#include "scandir.h"            /* needed for file.h     */
#include "file.h"               /* needed for compitem.h */
#include "compitem.h"           /* needed for view.h     */
#include "complist.h"
#include "view.h"
#include "findgoto.h"

#include "state.h"
#include "windiff.h"
#include "wdiffrc.h"

#include "slmmgr.h"



/*--constants and data types--------------------------------------------*/

int Version = 2;
int SubVersion = 01;

/* When we print the current table, we pass this id as the table id
 * When we are queried for the properties of this table, we know they
 * want the printing properties for the current view. We use this to
 * select different fonts and colours for the printer.
 */
#define TABID_PRINTER   1



/*
 * structure containing args passed to worker thread in initial
 * case (executing command line instructions) (in WIN16 case,
 * the worker thread function is called synchronously with these args).
 */
typedef struct {

    LPSTR server;
    LPSTR first;
    LPSTR second;
    LPSTR savelist;
    LPSTR savecomp;
    LPSTR notify;
    UINT listopts;
    UINT compopts;
    VIEW view;
    BOOL fDeep;
    BOOL fExit;
    BOOL fVersionControl;               // TRUE means use SLM or Source Depot
    BOOL fOpenedFiles;                  // TRUE means use output from 'sd opened'
    BOOL fDescribeFiles;                // TRUE means use output from 'sd describe ####'
    BOOL fInputFile;                    // TRUE means read file list from input file
    BOOL fInputFileSingle;              // TRUE means input file has one filename per line
    char slmpath[MAX_PATH];
} THREADARGS, FAR * PTHREADARGS;


/* structure containing all the arguments we'd like to give to do_editfile
   Need a structure because CreateThread only allows for one argument.
*/
typedef struct {
    VIEW view;
    int option;
    long selection;
} EDITARGS, FAR * PEDITARGS;

/*---- string constants --------------------------- */

const CHAR szWinDiff[]                = "WinDiff";
static const char szD[]                      = "%d";
static const char szBlanks[]                 = "Blanks";
static const char szAlgorithm2[]             = "Algorithm2";
static const char szPicture[]                = "Picture";
static const char szMonoColours[]            = "MonoColours";
static const char szHideMark[]               = "HideMark";
static const char szWinDiffViewerClass[]     = "WinDiffViewerClass";
static const char szWinDiffMenu[]            = "WinDiffMenu";
static const char szOutlineMenu[]            = "OutlineFloatMenu";
static const char szExpandMenu[]             = "ExpandFloatMenu";
static const char szWinDiffAccel[]           = "WinDiffAccel";
static const char szBarClass[]               = "BarClass";
static const char szLineNumbers[]            = "LineNumbers";
static const char szFileInclude[]            = "FileInclude";
static const char szLineInclude[]            = "LineInclude";
static const char szOutlineSaved[]           = "OutlineSaved";
static const char szOutlineShowCmd[]         = "OutlineShowCmd";
static const char szOutlineMaxX[]            = "OutlineMaxX";
static const char szOutlineMaxY[]            = "OutlineMaxY";
static const char szOutlineNormLeft[]        = "OutlineNormLeft";
static const char szOutlineNormTop[]         = "OutlineNormTop";
static const char szOutlineNormRight[]       = "OutlineNormRight";
static const char szOutlineNormBottom[]      = "OutlineNormBottom";
static const char szEditor[]                 = "Editor";
static const char szFontFaceName[]           = "FontFaceName";
static const char szFontHeight[]             = "FontHeight";
static const char szFontBold[]               = "FontBold";
static const char szFontCharSet[]            = "FontCharSet";
static const char szExpandedSaved[]          = "ExpandedSaved";
static const char szExpandShowCmd[]          = "ExpandShowCmd";
static const char szExpandMaxX[]             = "ExpandMaxX";
static const char szExpandMaxY[]             = "ExpandMaxY";
static const char szExpandNormLeft[]         = "ExpandNormLeft";
static const char szExpandNormTop[]          = "ExpandNormTop";
static const char szExpandNormRight[]        = "ExpandNormRight";
static const char szExpandNormBottom[]       = "ExpandNormBottom";
static const char szColourPrinting[]         = "ColourPrinting";
static const char szTabWidth[]               = "TabWidth";
static const char szShowWhitespace[]         = "ShowWhitespace";
static const char szrgb_outlinehi[]          = "RGBOutlineHi";
static const char szrgb_leftfore[]           = "RGBLeftFore";
static const char szrgb_leftback[]           = "RGBLeftBack";
static const char szrgb_rightfore[]          = "RGBRightFore";
static const char szrgb_rightback[]          = "RGBRightBack";
static const char szrgb_similarleft[]        = "RGBSimilarLeft";
static const char szrgb_similarright[]       = "RGBSimilarRight";
static const char szrgb_similar[]            = "RGBSimilar";
static const char szrgb_mleftfore[]          = "RGBMLeftFore";
static const char szrgb_mleftback[]          = "RGBMLeftBack";
static const char szrgb_mrightfore[]         = "RGBMRightFore";
static const char szrgb_mrightback[]         = "RGBMRightBack";
static const char szrgb_barleft[]            = "RGBBarLeft";
static const char szrgb_barright[]           = "RGBBarRight";
static const char szrgb_barcurrent[]         = "RGBBarCurrent";
static const char szrgb_defaultfore[]        = "RGBDefaultFore";
static const char szrgb_defaultforews[]      = "RGBDefaultForeWS";
static const char szrgb_defaultback[]        = "RGBDefaultBack";

static const char szrgb_fileleftfore[]       = "RGBFileLeftFore";
static const char szrgb_fileleftback[]       = "RGBFileLeftBack";
static const char szrgb_filerightfore[]      = "RGBFileRightFore";
static const char szrgb_filerightback[]      = "RGBFileRightBack";

/*---- colour scheme------------------------------- */

DWORD rgb_outlinehi = RGB(255, 0, 0);   /* hilighted files in outline mode  */

/* expand view */
DWORD rgb_leftfore;          /* foregrnd for left lines */
DWORD rgb_leftback;          /* backgrnd for left lines */
DWORD rgb_rightfore;         /* foregrnd for right lines*/
DWORD rgb_rightback;         /* backgrnd for right lines*/

/* temp hack */
DWORD rgb_similarleft;       /* forground zebra         */
DWORD rgb_similarright;      /* foreground zebra        */
DWORD rgb_similar;           /* unused                  */

/* moved lines */
DWORD rgb_mleftfore;         /* foregrnd for moved-left */
DWORD rgb_mleftback;         /* backgrnd for moved-left */
DWORD rgb_mrightfore;        /* foregrnd for moved-right*/
DWORD rgb_mrightback;        /* backgrnd for moved-right*/

/* bar window */
DWORD rgb_barleft;           /* bar sections in left only  */
DWORD rgb_barright;          /* bar sections in right only */
DWORD rgb_barcurrent;        /* current pos markers in bar */

DWORD rgb_defaultfore;       /* default foreground */
DWORD rgb_defaultforews;     /* default foreground whitespace */
DWORD rgb_defaultback;       /* default background */

DWORD rgb_fileleftfore;       /* outline mode left only file */
DWORD rgb_fileleftback;       /* outline mode left only file */
DWORD rgb_filerightfore;      /* outline mode right only file */
DWORD rgb_filerightback;      /* outline mode right only file */

BOOL gbPerverseCompare = FALSE; // break lines on punctuation (broken & useless)

/* PickUpProfile */
void PickUpProfile( DWORD * pfoo, LPCSTR szfoo)
{
    *pfoo = GetProfileInt(APPNAME, szfoo, *pfoo);
}


void SetColours(void)
{
    /* outline */

    rgb_outlinehi = (DWORD)RGB(255, 0, 0);   /* hilighted files in outline mode  */
    PickUpProfile(&rgb_outlinehi, szrgb_outlinehi);

    rgb_fileleftfore = (DWORD)RGB(0, 0, 0);   /* left only outline mode  */
    PickUpProfile(&rgb_fileleftfore, szrgb_fileleftfore);
    rgb_fileleftback = (DWORD)RGB(255, 255, 255);
    PickUpProfile(&rgb_fileleftback, szrgb_fileleftback);

    rgb_filerightfore = (DWORD)RGB(0, 0, 0);  /* right only outline mode  */
    PickUpProfile(&rgb_filerightfore, szrgb_filerightfore);
    rgb_filerightback = (DWORD)RGB(255, 255, 255);
    PickUpProfile(&rgb_filerightback, szrgb_filerightback);

    /* expand view */
    rgb_leftfore =   (DWORD)RGB(  0,   0,   0);         /* foregrnd for left lines */
    PickUpProfile(&rgb_leftfore, szrgb_leftfore);
    rgb_leftback  =  (DWORD)RGB(255,   0,   0);         /* backgrnd for left lines */
    PickUpProfile(&rgb_leftback, szrgb_leftback);
    rgb_rightfore =  (DWORD)RGB(  0,   0,   0);         /* foregrnd for right lines*/
    PickUpProfile(&rgb_rightfore, szrgb_rightfore);
    rgb_rightback =  (DWORD)RGB(255, 255,   0);         /* backgrnd for right lines*/
    PickUpProfile(&rgb_rightback, szrgb_rightback);

    rgb_similarleft= (DWORD)RGB(  0, 255, 255);         /* foreground zebra        */
    PickUpProfile(&rgb_similarleft, szrgb_similarleft);
    rgb_similarright=(DWORD)RGB(  0, 127, 127);         /* forground zebra         */
    PickUpProfile(&rgb_similarright, szrgb_similarright);
    rgb_similar   =  (DWORD)RGB(  127, 127, 255);       /* same within comp options*/
    PickUpProfile(&rgb_similar, szrgb_similar);

    /* moved lines */
    rgb_mleftfore =  (DWORD)RGB(  0,   0, 128);         /* foregrnd for moved-left */
    PickUpProfile(&rgb_mleftfore, szrgb_mleftfore);
    rgb_mleftback =  (DWORD)RGB(255,   0,   0);         /* backgrnd for moved-left */
    PickUpProfile(&rgb_mleftback, szrgb_mleftback);
    rgb_mrightfore = (DWORD)RGB(  0,   0, 255);         /* foregrnd for moved-right*/
    PickUpProfile(&rgb_mrightfore, szrgb_mrightfore);
    rgb_mrightback = (DWORD)RGB(255, 255,   0);         /* backgrnd for moved-right*/
    PickUpProfile(&rgb_mrightback, szrgb_mrightback);

    /* bar window */
    rgb_barleft =    (DWORD)RGB(255,   0,   0);         /* bar sections in left only  */
    PickUpProfile(&rgb_barleft, szrgb_barleft);
    rgb_barright =   (DWORD)RGB(255, 255,   0);         /* bar sections in right only */
    PickUpProfile(&rgb_barright, szrgb_barright);
    rgb_barcurrent = (DWORD)RGB(  0,   0, 255);         /* current pos markers in bar */
    PickUpProfile(&rgb_barcurrent, szrgb_barcurrent);

    /* defaults */
    rgb_defaultfore = (DWORD)RGB(   0,   0,   0);       /* default foreground colour */
    PickUpProfile(&rgb_defaultfore, szrgb_defaultfore);
    rgb_defaultforews = (DWORD)RGB(192, 192, 192);      /* default foreground whitespace colour */
    PickUpProfile(&rgb_defaultforews, szrgb_defaultforews);
    rgb_defaultback = (DWORD)RGB(255, 255, 255);        /* default background colour */
    PickUpProfile(&rgb_defaultback, szrgb_defaultback);

} /* SetColours */

void SetMonoColours(void)
{
    rgb_outlinehi = GetSysColor(COLOR_WINDOW);   /* hilighted files in outline mode  */

    /* expand view - all changed or moved lines are white on black */
    rgb_leftfore =   GetSysColor(COLOR_WINDOW);         /* foregrnd for left lines */
    rgb_leftback  =  GetSysColor(COLOR_WINDOWTEXT);         /* backgrnd for left lines */
    rgb_rightfore =  GetSysColor(COLOR_WINDOW);         /* foregrnd for right lines*/
    rgb_rightback =  GetSysColor(COLOR_WINDOWTEXT);         /* backgrnd for right lines*/

    rgb_similarleft= GetSysColor(COLOR_WINDOW);         /* foreground zebra        */
    rgb_similarright=GetSysColor(COLOR_WINDOW);         /* foreground zebra        */
    rgb_similar   =  GetSysColor(COLOR_WINDOWTEXT);         /* same within comp options*/

    /* moved lines - black on white */
    rgb_mleftfore =  GetSysColor(COLOR_WINDOWTEXT);        /* foregrnd for moved-left */
    rgb_mleftback =  GetSysColor(COLOR_WINDOW);	           /* backgrnd for moved-left */
    rgb_mrightfore = GetSysColor(COLOR_WINDOWTEXT);        /* foregrnd for moved-right*/
    rgb_mrightback = GetSysColor(COLOR_WINDOW);            /* backgrnd for moved-right*/

    /* bar WINDOWTEXT */
    rgb_barleft =    GetSysColor(COLOR_WINDOWTEXT);         /* bar sections in left only  */
    rgb_barright =   GetSysColor(COLOR_WINDOWTEXT);         /* bar sections in right only */
    rgb_barcurrent = GetSysColor(COLOR_WINDOWTEXT);         /* current pos markers in bar */


    rgb_defaultfore = GetSysColor(COLOR_WINDOWTEXT);       /* default foreground colour */
    rgb_defaultforews = GetSysColor(COLOR_WINDOWTEXT);      /* default foreground whitespace colour */
    rgb_defaultback = GetSysColor(COLOR_WINDOW);        /* default background colour */

#if 0
    rgb_outlinehi = (DWORD)RGB(  0,   0,   0);   /* hilighted files in outline mode  */

    /* expand view - all changed or moved lines are white on black */
    rgb_leftfore =   (DWORD)RGB(255, 255, 255);         /* foregrnd for left lines */
    rgb_leftback  =  (DWORD)RGB(  0,   0,   0);         /* backgrnd for left lines */
    rgb_rightfore =  (DWORD)RGB(255, 255, 255);         /* foregrnd for right lines*/
    rgb_rightback =  (DWORD)RGB(  0,   0,   0);         /* backgrnd for right lines*/

    rgb_similarleft= (DWORD)RGB(255, 255, 255);         /* foreground zebra        */
    rgb_similarright=(DWORD)RGB(255, 255, 255);         /* foreground zebra        */
    rgb_similar   =  (DWORD)RGB(  0,   0,   0);         /* same within comp options*/

    /* moved lines - black on grey */
    rgb_mleftfore =  (DWORD)RGB(255, 255, 255);         /* foregrnd for moved-left */
    rgb_mleftback =  (DWORD)RGB(  0,   0,   0);         /* backgrnd for moved-left */
    rgb_mrightfore = (DWORD)RGB(255, 255, 255);         /* foregrnd for moved-right*/
    rgb_mrightback = (DWORD)RGB(  0,   0,   0);         /* backgrnd for moved-right*/

    /* bar window */
    rgb_barleft =    (DWORD)RGB(  0,   0,   0);         /* bar sections in left only  */
    rgb_barright =   (DWORD)RGB(  0,   0,   0);         /* bar sections in right only */
    rgb_barcurrent = (DWORD)RGB(  0,   0,   0);         /* current pos markers in bar */



#endif
} /* SetMonoColours */

/* -------------------------------------------------- */

/* module static data -------------------------------------------------*/


/* current value of window title */
char AppTitle[256];


HWND hwndClient;        /* main window */
HWND hwndRCD;           /* table window */
HWND hwndStatus;        /* status bar across top */
HWND hwndBar;           /* graphic of sections as vertical bars */

HACCEL haccel;

/* the status bar told us it should be this high. Rest of client area
 * goes to the hwndBar and hwndRCD.
 */
int status_height;

#if 0
    #ifndef HINSTANCE
        #define HINSTANCE HANDLE
    #endif
#endif

HINSTANCE hInst;   /* handle to current app instance */
HMENU hMenu;    /* handle to menu for hwndClient */

int nMinMax = SW_SHOWNORMAL;         /* default state of window normal */

/* the message sent to us as a callback by the table window needs to be
 * registered - table_msgcode is the result of the RegisterMessage call
 */
UINT table_msgcode;

/* true if we are currently doing some scan or comparison.
 * WIN32: must get critical section before checking/changing this (call
 * SetBusy.
 */
BOOL fBusy = FALSE;


long     selection      =       -1;     /* selected row in table*/
long selection_nrows    =       0;      /* number of rows in selection */

/* options for DisplayMode field indicating what is currently shown.
 * we use this to know whether or not to show the graphic bar window.
 */
#define MODE_NULL       0       /* nothing displayed */
#define MODE_OUTLINE    1       /* a list of files displayed */
#define MODE_EXPAND     2       /* view is expanded view of one file */

int DisplayMode = MODE_NULL;    /* indicates whether we are in expand mode */

VIEW current_view = NULL;

BOOL fAutoExpand = TRUE;        /* Should we auto expand ? */

/* These two flags are peeked at by lots of other modules */
BOOL bAbort;            /* set to request abort of current operation */
BOOL bTrace;            /* set if tracing is to be enabled */
BOOL bJapan;            /* set if primary language is Japanese */
BOOL bDBCS;             /* set if primary language is Japanese/Korean/Chinese */

extern char*s;

char editor_cmdline[256] = "notepad %p";  /* editor cmdline */
/* slick version is "s %p -#%l" */

char g_szFontFaceName[LF_FACESIZE];
int g_nFontHeight;
BOOL g_fFontBold;
BYTE g_bFontCharSet;
HFONT g_hFont = 0;

/* app-wide global data --------------------------------------------- */

/* handle returned from gmem_init - we use this for all memory allocations */
HANDLE hHeap;

/* current state of menu options */
int line_numbers = IDM_LNRS;
int expand_mode = IDM_BOTHFILES;
int outline_include = INCLUDE_ALL;
int expand_include = INCLUDE_ALL;
BOOL ignore_blanks = TRUE;
BOOL show_whitespace = FALSE;
BOOL Algorithm2 = TRUE;  /* Try duplicates - used in compitem.c */
BOOL picture_mode = TRUE;
BOOL hide_markedfiles = FALSE;
BOOL mono_colours = FALSE;       /* monochrome display */

// tab width - set from TabWidth entry in registry
int g_tabwidth = TABWIDTH_DEFAULT;

BOOL TrackLeftOnly = TRUE;
BOOL TrackRightOnly = TRUE;
BOOL TrackSame = TRUE;
BOOL TrackDifferent = TRUE;
BOOL TrackReadonly = TRUE;
BOOL TrackSlmFiles = TRUE;

/* function prototypes ---------------------------------------------*/

BOOL InitApplication(HINSTANCE hInstance);
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow);
void CreateTools(void);
void DeleteTools(void);
INT_PTR APIENTRY MainWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL SetBusy(void);
void SetNotBusy(void);
void SetSelection(long rownr, long nrows, long dyRowsFromTop);
void SetButtonText(LPSTR cmd);
BOOL ToExpand(HWND hwnd);
void ParseArgs(char * lpCmdLine);
void Trace_Status(LPSTR str);

DWORD WINAPI wd_initial(LPVOID arg);

static HANDLE ghThread = NULL;
/* Some DOGMA about threads:
   When we spin off threads and then while they are still running, try to Exit
   we get race conditions with one thread allocating and the other freeing the
   storage.  gutils\gmem has dogma about NULL pointers, but this is not enough.
   It might be that given a final structure of A->B->C we have A->B with NULL
   pointers in B when the Exit comes in.  The cleanup thread will clear out
   B and A and THEN the worker thread might try to attach C to B which is no
   longer there.  This means that the worker thread must be Stopped.  To allow
   this to happen quickly, we TerminateThread it.  This will leave the initial
   stack around, but presumably that gets cleaned up on app exit anyway.
   There is only at most one worker thread running, and ghThread is its handle.
*/

static DWORD gdwMainThreadId;     /* threadid of main (user interface) thread
                                     initialised in winmain(), thereafter constant.
                                     See windiff_UI()
                                  */

/* if you are about to put up a dialog box or in fact process input in any way
   on any thread other than the main thread - or if you MIGHT be on a thread other
   than the main thread, then you must call this function with TRUE before doing
   it and with FALSE immediately afterwards.  Otherwise you will get one of a
   number of flavours of not-very-responsiveness
*/
void windiff_UI(BOOL bAttach)
{
    DWORD dwThreadId = GetCurrentThreadId();
    if (dwThreadId==gdwMainThreadId) return;

    if (bAttach) GetDesktopWindow();
    AttachThreadInput(dwThreadId, gdwMainThreadId, bAttach);
} /* windiff_UI */

/*-functions----------------------------------------------------------*/

/* main entry point. register window classes, create windows,
 * parse command line arguments and then perform a message loop
 */
int WINAPI
WinMain(
        HINSTANCE hInstance,
        HINSTANCE hPrevInstance,
        LPSTR lpCmdLine,
        int nCmdShow
        )
{
    MSG msg;

    gdwMainThreadId = GetCurrentThreadId();

    /* create any pens/brushes etc and read in profile defaults */
    CreateTools();

    /* init window class unless other instances running */
    if (!hPrevInstance)
        if (!InitApplication(hInstance))
            return(FALSE);


    /* init this instance - create all the windows */
    if (!InitInstance(hInstance, nCmdShow))
        return(FALSE);

    ParseArgs(lpCmdLine);

    /* message loop */
    while (GetMessage(&msg, NULL, 0, 0)) {
        if (!TranslateAccelerator(hwndClient, haccel, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    // List_Term();
    Trace_Close();       // harmless, even if never opened
    return (msg.wParam ? 1 : 0);
}

/* InitApplication
 *
 * - register window class for the main window and the bar window.
 */
BOOL
InitApplication(
                HINSTANCE hInstance
                )
{
    WNDCLASS    wc;
    BOOL resp;

    LCID lcid = GetThreadLocale();

    // set the boolean value for bJapan variable
    bJapan = (PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_JAPANESE);
    bDBCS = ((PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_JAPANESE) ||
             (PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_KOREAN)   ||
             (PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_CHINESE));

    /* register the bar window class */
    InitBarClass(hInstance);

    wc.style = 0;
    wc.lpfnWndProc = MainWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon(hInstance, szWinDiff);
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = NULL;
    wc.lpszClassName = (LPSTR) szWinDiffViewerClass;
    wc.lpszMenuName = NULL;

    resp = RegisterClass(&wc);

    return(resp);
}

/*
 * create and show the windows
 */
BOOL
InitInstance(
             HINSTANCE hInstance,
             int nCmdShow
             )
{
    RECT rect;
    HANDLE hstatus;
    int bar_width;
    RECT childrc;
    HIGHCONTRAST hc;

    hInst = hInstance;

    /* initialise a heap. we use this one heap throughout
     * the app. for all memory requirements
     */
    hHeap = gmem_init();
    /* initialise the list package */
    List_Init();


    hMenu = LoadMenu(hInstance, szWinDiffMenu);
    haccel = LoadAccelerators(hInstance, szWinDiffAccel);

    /* create the main window */
    hwndClient = CreateWindow(szWinDiffViewerClass,
                              szWinDiff,
                              WS_OVERLAPPEDWINDOW,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              NULL,
                              hMenu,
                              hInstance,
                              NULL
                             );



    if (!hwndClient) {
        return(FALSE);
    }


    /* create 3 child windows, one status, one table and one bar
     * Initially, the bar window is hidden and covered by the table.
     */

    /* create a status bar window as
     * a child of the main window.
     */

    /* build a status struct for two labels and an abort button */
    hstatus = StatusAlloc(3);
    StatusAddItem(hstatus, 0, SF_STATIC, SF_LEFT|SF_VAR|SF_SZMIN, IDL_STATLAB, 14, NULL);
    StatusAddItem(hstatus, 1, SF_BUTTON, SF_RIGHT|SF_RAISE, IDM_ABORT, 8,
                LoadRcString(IDS_EXIT));
    StatusAddItem(hstatus, 2, SF_STATIC, SF_LOWER|SF_LEFT|SF_VAR,
                  IDL_NAMES, 60, NULL);

    /* ask the status bar how high it should be for the controls
     * we have chosen, and save this value for re-sizing.
     */
    status_height = StatusHeight(hstatus);

    /* create a window of this height */
    GetClientRect(hwndClient, &rect);
    childrc = rect;
    childrc.bottom = status_height;
    hwndStatus = StatusCreate(hInst, hwndClient, IDC_STATUS, &childrc,
                              hstatus);

    /* layout constants are stated as percentages of the window width */
    bar_width = (rect.right - rect.left) * BAR_WIN_WIDTH / 100;

    /* create the table class covering all the remaining part of
     * the main window
     */
    hwndRCD = CreateWindow(TableClassName,
                           NULL,
                           WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL,
                           0,
                           status_height,
                           (int)(rect.right - rect.left),
                           (int)(rect.bottom - status_height),
                           hwndClient,
                           (HANDLE) IDC_RCDISP1,
                           hInst,
                           NULL);

    /* create a bar window as a child of the main window.
     * this window remains hidden until we switch into MODE_EXPAND
     */
    hwndBar = CreateWindow(szBarClass,
                           NULL,
                           WS_CHILD | WS_VISIBLE,
                           0,
                           status_height,
                           bar_width,
                           (int)(rect.bottom - status_height),
                           hwndClient,
                           (HANDLE) IDC_BAR,
                           hInst,
                           NULL);

    /* nMinMax indicates whether we are to be minimised on startup,
     * on command line parameters
     */
    ShowWindow(hwndBar, SW_HIDE);

    if (GetProfileInt(APPNAME, szOutlineSaved, 0)) {
        WINDOWPLACEMENT wp;
        /* restore the previous expanded size and position */
        wp.length = sizeof(wp);
        wp.flags                   = 0;
        wp.showCmd                 = GetProfileInt( APPNAME, szOutlineShowCmd,
                                                    SW_SHOWNORMAL);
        wp.ptMaxPosition.x         = GetProfileInt( APPNAME, szOutlineMaxX,       0);
        wp.ptMaxPosition.y         = GetProfileInt( APPNAME, szOutlineMaxY,       0);
        wp.rcNormalPosition.left   = (int)GetProfileInt( APPNAME, szOutlineNormLeft,  (UINT)(-1));
        wp.rcNormalPosition.top    = (int)GetProfileInt( APPNAME, szOutlineNormTop,   (UINT)(-1));
        wp.rcNormalPosition.right  = (int)GetProfileInt( APPNAME, szOutlineNormRight, (UINT)(-1));
        wp.rcNormalPosition.bottom = (int)GetProfileInt( APPNAME, szOutlineNormBottom,(UINT)(-1));

        if (!SetWindowPlacement(hwndClient,&wp)) {
            ShowWindow(hwndClient, nMinMax);
        }
    } else ShowWindow(hwndClient, nMinMax);



    /* initialise busy flag and status line to show we are idle
     * (ie not comparing or scanning)
     */
    SetNotBusy();
    /* initialise the colour globals */
    hc.cbSize = sizeof(hc);
    SystemParametersInfo(SPI_GETHIGHCONTRAST,0 ,&hc, 0);
    mono_colours = (hc.dwFlags & HCF_HIGHCONTRASTON);
    if (mono_colours) {
      SetMonoColours();
    } else {
      SetColours();
    }
    PostMessage(hwndClient, WM_SYSCOLORCHANGE, 0 , 0);
    UpdateWindow(hwndClient);

    return(TRUE);

} /* InitInstance */



/*
 * complain to command line users about poor syntax,
 * (there's a proper help file too).
 *
 * (yeah, but the help file doesn't cover the MS-internal stuff).
 */

typedef struct
{
    UINT m_ids;
    BOOL m_fInternalOnly;
    BOOL m_fExternalOnly;
    int m_cIndent;
} UsageStringInfo;

static const UsageStringInfo c_rg[] =
{
    { -1,                   0, 0, 0 },
    { IDS_USAGE_STR00,      0, 0, 0 },
    { IDS_USAGE_STR01,      0, 0, 0 },
    { IDS_USAGE_STR02,      0, 0, 1 },
    { IDS_USAGE_STR03,      0, 0, 1 },
    { IDS_USAGE_STR04,      0, 0, 3 },
    { IDS_USAGE_STR05,      0, 0, 1 },
    { IDS_USAGE_STR06,      0, 1, 1 },
    { IDS_USAGE_STR07,      1, 0, 1 },
    { IDS_USAGE_STR08,      1, 0, 1 },
    { IDS_USAGE_STR08B,     0, 0, 1 },
    { IDS_USAGE_STR09,      1, 0, 1 },
    { IDS_USAGE_STR10,      1, 0, 1 },
    { IDS_USAGE_STR11,      1, 0, 1 },
    { IDS_USAGE_STR12,      1, 0, 1 },
    { IDS_USAGE_STR13,      1, 0, 1 },
    { IDS_USAGE_STR14,      1, 0, 1 },
    { IDS_USAGE_STR15,      0, 0, 1 },
    { IDS_USAGE_STR16,      0, 0, 1 },
    { IDS_USAGE_STR17,      0, 0, 1 },
    { IDS_USAGE_STR18,      0, 0, 1 },
    { IDS_USAGE_STR19,      0, 0, 3 },
    { IDS_USAGE_STR20,      0, 0, 1 },
    { IDS_USAGE_STR21,      1, 0, 1 },
    { IDS_USAGE_STR22,      1, 0, 3 },
    { IDS_USAGE_STR23,      1, 0, 0 },
    { IDS_USAGE_STR24,      1, 0, -1 },
    { IDS_USAGE_STR25,      1, 0, -1 },
    { IDS_USAGE_STR26,      1, 0, -1 },
};

INT_PTR FAR PASCAL UsageDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_INITDIALOG:
        {
            HWND hwnd = GetDlgItem(hDlg, IDC_USAGE_TEXT);
            if (hwnd)
            {
                const UsageStringInfo *p;
                int c;
                char sz[256];
                PARAFORMAT pf;
                CHARFORMAT cf;
                int pos;

                pf.cbSize = sizeof(pf);

                SendMessage(hwnd, EM_SETBKGNDCOLOR, 0, GetSysColor(COLOR_BTNFACE));
                SendMessage(hwnd, EM_SETMARGINS, EC_LEFTMARGIN|EC_RIGHTMARGIN, MAKELONG(4, 4));

                for (p = c_rg, c = NUMELMS(c_rg); c--; p++)
                {
                    LPCSTR psz;

                    if (p->m_fExternalOnly && (1 & IsSLMOK()))
                        continue;
                    if (p->m_fInternalOnly && !(1 & IsSLMOK()))
                        continue;

                    if (p->m_ids == -1)
                    {
                        if (2 & IsSLMOK())
                        {
                            Format(sz, s);
                            lstrcat(sz,"\n\n");
                            psz = sz;
                        }
                        else
                            continue;
                    }
                    else
                        psz = LoadRcString(p->m_ids);

                    pos = LOWORD(SendMessage(hwnd, EM_GETSEL, 0, 0));
                    SendMessage(hwnd, EM_REPLACESEL, FALSE, (LPARAM)psz);
                    SendMessage(hwnd, EM_SETSEL, pos, -1);

                    SendMessage(hwnd, EM_GETPARAFORMAT, 0, (LPARAM)&pf);
                    if (p->m_cIndent >= 0)
                    {
                        static const int c_rgIndents[] = { 320*1, 320*5, 320*6 };
                        static const int c_rgOffsets[] = { 320*4, 0, 0 };

                        pf.dwMask |= PFM_STARTINDENT|PFM_OFFSET|PFM_TABSTOPS;
                        pf.dxStartIndent = 0;
                        pf.dxOffset = 0;
                        if (p->m_cIndent)
                        {
                            pf.dxStartIndent = c_rgIndents[p->m_cIndent - 1];
                            pf.dxOffset = c_rgOffsets[p->m_cIndent - 1];
                        }
                        pf.cTabCount = 2;
                        pf.rgxTabs[0] = c_rgIndents[0];
                        pf.rgxTabs[1] = c_rgIndents[1];
                    }
                    else
                    {
                        pf.dwMask |= PFM_STARTINDENT|PFM_OFFSET|PFM_NUMBERING;
                        pf.dxStartIndent = 320;
                        pf.dxOffset = 180;
                        pf.wNumbering = PFN_BULLET;
                    }
                    SendMessage(hwnd, EM_SETPARAFORMAT, 0, (LPARAM)&pf);

                    SendMessage(hwnd, EM_SETSEL, -1, -1);
                }

                cf.cbSize = sizeof(cf);
                cf.dwMask = CFM_COLOR;
                cf.dwEffects = 0;
                cf.crTextColor = GetSysColor(COLOR_BTNTEXT);
                SendMessage(hwnd, EM_SETSEL, 0, -1);
                SendMessage(hwnd, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);
                SendMessage(hwnd, EM_SETSEL, -1, -1);
                pos = LOWORD(SendMessage(hwnd, EM_GETSEL, 0, 0));
                SendMessage(hwnd, EM_SETSEL, pos - 1, pos);
                SendMessage(hwnd, EM_REPLACESEL, 0, (LPARAM)"");
                SendMessage(hwnd, EM_SETSEL, 0, 0);
            }
        }
        break;


    case WM_COMMAND:
        switch (wParam)
        {
        case IDOK:
        case IDCANCEL:
            EndDialog(hDlg, wParam);
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

void
windiff_usage(
              LPSTR msg
              )
{
    INT_PTR retval;
    UINT fuStyle =  MB_ICONINFORMATION|MB_OKCANCEL;


    if (msg)
    {
        char Usage[4096];

        // since msg may be a pointer returned by LoadRcString, copy it off so
        // we don't stomp on the string when we load IDS_WINDIFF_USAGE.
        lstrcpy(Usage, msg);
        msg = Usage;

        retval = MessageBox(hwndClient,
                            msg,
                            LoadRcString(IDS_WINDIFF_USAGE),
                            fuStyle);
    }
    else
    {
        HINSTANCE h;

        h = LoadLibrary("riched20.dll");
        if (!h)
            h = LoadLibrary("riched32.dll");
        if (h)
        {
            retval = DialogBox(hInst, (LPCSTR)IDD_USAGE, hwndClient, UsageDlgProc);
            FreeLibrary(h);
        }
        else
        {
            windiff_usage(LoadRcString(IDS_ERROR_CANTLOADRICHEDIT));
            retval = IDOK;
        }
    }

    if (retval == IDCANCEL)
        exit(1);
}


/*  Functionally similar to strtok except that " ... " is a token, even if
    it contains spaces and the delimiters are built in (no second parameter)
    GetNextToken(foo) delivers the first token in foo (or NULL if foo is empty)
    and caches foo so that GetNextToken(NULL) then gives the next token.  When there
    are no more tokens left it returns NULL
    It mangles the original by peppering it with NULLs as it chops the tokens
    off.  Each time except the last it inserts a new NULL.
    Obviously not thread safe!
    Command line is limited to 512 chars.

*/
char *
GetNextToken(
             char * Tok
             )
{
    static char * Source;     // The address of the original source string
                              // which gets progressively mangled

    static char RetBuff[512]; // We will build results in here
    static char *Ret;         // We build the results here (in RetBuff)
                              // but moved along each time.

    static char * p;       // the next char to parse in Source
                           // NULL if none left.

    // Quotes are a damned nuisance (they are the whole reason why strtok
    // wouldn't work).  If the string starts with quotes then we potentially
    // need to pull together fragments of the string "foo""ba"r => foobar
    // We want to pull these together into storage that we can safely write
    // into and return (can't be stack).  Mangling the original parameter
    // gets very messy so we cache a pointer to the original source that
    // we work through and we build up output tokens in a static
    // and therefore permanently wasted buffer of (arbitrarily) 512 bytes.
    // then we can set Ret to \0 and concatenate bits on as we find them.
    // The rule is that we split at the first space outside quotes.


    // cache the Source if a "first time" call.  Kill the "finished" case.
    if (Tok!=NULL) {
        Source = Tok;
        Ret = RetBuff;
        RetBuff[0] = '\0';
        p = Source;
    } else if (p==NULL) {
        return NULL;          // finished
    } else {
        Ret +=strlen(Ret)+1;  // slide it past last time's stuff
    }

    *Ret = '\0';              // empty string to concatenate onto

    // from here on Tok is used as a temporary.

    // keep taking sections and adding them to the start of Source
    for (; ; ) {

        // for each possibility we grow Ret and move p on.
        if (*p=='\"') {
            ++p;
            Tok = My_mbschr(p, '"');
            if (Tok==NULL) {
                strcat(Ret, p);
                p = NULL;
                return Ret;
            } else {
                *Tok = '\0';    // split the section off, replaceing the "
                strcat(Ret, p); // add it to the result
                p = Tok+1;      // move past the quote
            }
        } else {
            int i = strcspn(p," \"");   // search for space or quote
            if (p[i]=='\0') {
                // It's fallen off the end
                strcat(Ret, p);
                p = NULL;
                return Ret;
            } else if (p[i]==' ') {
                // We've hit a genuine delimiting space
                p[i] = '\0';
                strcat(Ret, p);
                p +=i+1;

                // strip trailing spaces (leading spaces for next time)
                while (*p==' ')
                    ++p;
                if (*p=='\0')
                    p = NULL;

                return Ret;
            } else {
                // we've hit a quote
                p[i] = '\0';
                strcat(Ret, p);
                p[i] = '\"';     // put it back so that we can find it again
                p +=i;           // aim at it and iterate
            }
        }

    } // for

} // GetNextToken





/*
 * parse command line arguments
 *
 * The user can give one or two paths. if only one, we assume the second
 * is '.' for the current directory. if one of the two paths is a directory
 * and the other a file, we compare a file of the same name in the two dirs.
 *
 * the command -s filename causes the outline list to be written to a file
 * -s{slrd} filename allows selection of which files are written out;
 * by default, we assume -sld for files left and different.
 * -s{slrd}x causes the program to exit after the list has been written out
 *
 * -r server uses server as a remote checksum server, and will also mark the
 * first of the two names as a remote path.
 * Note that this is undocumented.
 *
 * -L means that the first argument is the path from slm.ini
 * You can use -L and -R together for a remote library.
 * -LPfoo specifies the Source Depot port "foo".
 * -LCbar specifies the Source Depot client "bar".
 * -L! forces Source Depot mode without checking for slm.ini or sd.ini.
 *
 * -T means tree.  Go deep.
 * -D means Directory or Don't go deep.
 * -O means Stay in outline mode.  No auto expand.
 * -N means Notify on completion - try a NET SEND.
 *
 * The default is Deep, -L overrides and implies shallow.
 * A deep library compare requires -L and -T
 */
void
ParseArgs(
          char * lpCmdLine
          )
{
    PTHREADARGS ta;
    BOOL fMaybeVersionControl = FALSE;  // TRUE means we saw an ambiguous switch and we're not sure whether to do diff argument1 against its matching source library revisions
    BOOL fSDOpened = FALSE;             // TRUE means call SD to get list of opened files, and ONLY diff those files
    BOOL fSDDescribe = FALSE;           // TRUE means call SD to get list of files in specified change number, and ONLY diff those files
    BOOL fAllowTwoPaths = TRUE;         // FALSE means -l or -lr was used
    BOOL fReverse = FALSE;              // -lr means reverse
    BOOL fDeepDefault = TRUE;
    char * tok;         /* token from lpCmdLine */

    DWORD threadid;
    UINT idsError = 0;

    /* thread args can't be on the stack since the stack will change
     * before the thread completes execution
     */
    ta = (PTHREADARGS) gmem_get(hHeap, sizeof(THREADARGS));
    ta->server = NULL;
    ta->first = NULL;
    ta->second = NULL;
    ta->savelist = NULL;
    ta->savecomp = NULL;
    ta->listopts = 0;
    ta->compopts = 0;
    ta->notify = NULL;
    ta->fExit = FALSE;
    ta->fDeep = FALSE;  /* No -T option seen yet */

    tok = GetNextToken(lpCmdLine);

    while ((tok!=NULL) && (lstrlen(tok) > 0)) {

        if (tok[0] == '/' && tok[1] == '/')
        {
            SLM_ForceSourceDepot();
            goto LFile;
        }

        /* is this an option ? */
        if ((tok[0] == '-') || (tok[0] == '/')) {
            switch (tok[1]) {

                case 'r':
                case 'R':
                    ta->server = GetNextToken(NULL);
                    break;
                case 's':
                case 'S':
                    /* read letters for the save option: s,l,r,d */
                    for (tok+=2; *tok != '\0'; ++tok) {
                        switch (*tok) {
                            case 's':
                            case 'S':
                                ta->listopts |= INCLUDE_SAME;
                                break;
                            case 'l':
                            case 'L':
                                ta->listopts |= INCLUDE_LEFTONLY;
                                break;
                            case 'r':
                            case 'R':
                                ta->listopts |= INCLUDE_RIGHTONLY;
                                break;
                            case 'd':
                            case 'D':
                                ta->listopts |= INCLUDE_DIFFER;
                                break;
                            case 'x':
                            case 'X':
                                ta->fExit = TRUE;
                                break;
                            default:
                                idsError = 0;
                                goto LUsage;
                        }
                    }

                    if (ta->listopts == 0) {
                        /* default to left and differ */
                        ta->listopts = (INCLUDE_LEFTONLY) | (INCLUDE_DIFFER);
                    }
                    ta->savelist = GetNextToken(NULL);
                    break;
                case 'f':
                case 'F':
					/* read letters for the save option: s,l,r,d,e,i */
                    for(tok = &tok[2]; *tok != '\0'; ++tok) {
                        switch(*tok) {
                        case 'i':
                        case 'I':
                                ta->compopts |= INCLUDE_SAME;
                                break;
                        case 'l':
                        case 'L':
                                ta->compopts |= INCLUDE_LEFTONLY;
                                break;
                        case 'r':
                        case 'R':
                                ta->compopts |= INCLUDE_RIGHTONLY;
                                break;
                        case 'f':
                        case 'F':
                                ta->compopts |= INCLUDE_MOVEDLEFT;
                                break;
                        case 'g':
                        case 'G':
                                ta->compopts |= INCLUDE_MOVEDRIGHT;
                                break;
                        case 's':
                        case 'S':
                                ta->compopts |= INCLUDE_SIMILARLEFT;
                                break;
                        case 'a':
                        case 'A':
                                ta->compopts |= INCLUDE_SIMILARRIGHT;
                                break;
                        case 'x':
                        case 'X':
                                ta->fExit = TRUE;
                                break;
                        default:
                                idsError = 0;
                                goto LUsage;
                        }
                    }

                    if (ta->compopts == 0) {
                            /* default to showing all diffs (everything but same) */
                            ta->compopts = INCLUDE_LEFTONLY | INCLUDE_RIGHTONLY
                                         | INCLUDE_DIFFER | INCLUDE_MOVEDLEFT
                                         | INCLUDE_MOVEDRIGHT;
                    }
                    ta->savecomp = GetNextToken(NULL);
                    break;
                case 'i':
                case 'I':
                    ta->fInputFile = TRUE;
                    if (tok[2] == '1')
                    {
                        ta->fInputFileSingle = TRUE;
                        tok++;
                    }
                    tok += 2;
                    // allow (but don't require) a space between '-I' and the
                    // 'inputfilename' argument.
                    if (!*tok)
                        tok = GetNextToken(NULL);
                    if (!tok || !*tok)
                    {
                        idsError = IDS_ERROR_IARGS;
                        goto LUsage;
                    }
                    SLM_SetInputFile(tok);
                    break;
                case 'l':
                case 'L':
                    {
                        if (!tok[2])
                        {
                            // "-l" by itself forces version control mode
                            ta->fVersionControl = TRUE;
                            fMaybeVersionControl = FALSE;
                        }

                        /* read letters for the library option: r,! */
                        for (tok+=2; *tok != '\0'; ++tok)
                        {
                            switch (*tok)
                            {
                            case 'r':
                            case 'R':
                                fReverse = TRUE;            // reverse compare
                                // "-lr" forces version control mode
                                ta->fVersionControl = TRUE;
                                fMaybeVersionControl = FALSE;
                                break;
                            case 'p':
                            case 'P':
                                // allow (but don't require) a space between
                                // '-LP' and the 'server:port' argument.
                                if (tok[1])
                                    tok++;
                                else
                                    tok = GetNextToken(NULL);
                                if (tok)
                                {
                                    SLM_SetSDPort(tok);
                                    tok += lstrlen(tok);
                                }
                                goto LForceSD;
                            case 'c':
                            case 'C':
                                // allow (but don't require) a space between
                                // '-LC' and the 'clientname' argument.
                                if (tok[1])
                                    tok++;
                                else
                                    tok = GetNextToken(NULL);
                                if (tok)
                                {
                                    SLM_SetSDClient(tok);
                                    tok += lstrlen(tok);
                                }
                                goto LForceSD;

                            case 'o':
                            case 'O':
                                if (fSDDescribe)
                                {
                                    idsError = IDS_ERROR_OVSD_OPTION;
                                    goto LUsage;
                                }
                                fSDOpened = TRUE;
                                // don't allow a space between '-LO' and the
                                // 'changenum' argument, because the argument
                                // is optional.
                                if (tok)
                                {
                                    SLM_SetSDChangeNumber(tok + 1);
                                    tok += lstrlen(tok);
                                }
                                goto LForceSD;

                            case 'd':
                            case 'D':
                                if (fSDOpened)
                                {
                                    idsError = IDS_ERROR_OVSD_OPTION;
                                    goto LUsage;
                                }
                                fSDDescribe = TRUE;
                                // allow (but don't require) a space between
                                // '-LD' and the 'changenum' argument.
                                if (tok[1])
                                    tok++;
                                else
                                    tok = GetNextToken(NULL);
                                if (tok)
                                {
                                    SLM_Describe(tok);
                                    tok += lstrlen(tok);
                                }
                                goto LForceSD;

                            case '!':
LForceSD:
                                // force SD mode without checking for any
                                // slm.ini or sd.ini files.
                                if (!ta->fVersionControl)
                                    fMaybeVersionControl = TRUE;
                                SLM_ForceSourceDepot();
                                break;
                            default:
                                idsError = 0;
                                goto LUsage;
                            }

                            if (!tok)
                                break;
                        }

                        if (!fMaybeVersionControl)
                        {
                            fMaybeVersionControl = FALSE;
                            ta->fVersionControl = TRUE;
                        }
                    }
                    break;
                case 'n':
                case 'N':
                    ta->notify = GetNextToken(NULL);
                    break;
                case 't':
                case 'T':
                    ta->fDeep = TRUE;
                    break;
                case 'd':
                case 'D':
                    ta->fDeep = FALSE;     // This directory only
                    fDeepDefault = FALSE;
                    break;
                case 'o':
                case 'O':
                    fAutoExpand = FALSE;
                    break;
                case 'p':
                case 'P':
                    gbPerverseCompare = TRUE;
                    break;
                case 'x':
                case 'X':
                    {
                        BOOL track;
                        char *c = &tok[2];
                        if (*c == '\0') {
                            TrackLeftOnly = FALSE;
                            TrackRightOnly = FALSE;
                            TrackSame = FALSE;
                            TrackDifferent = TRUE;
                            TrackReadonly = TRUE;
                            TrackSlmFiles = FALSE;
                            break;
                        }
                        track = FALSE;
                        while (*c != '\0') {
                            if (toupper(*c) == 'L') {
                                TrackLeftOnly = track;
                                track = FALSE;
                            } else if (toupper(*c) == 'R') {
                                TrackRightOnly = track;
                                track = FALSE;
                            } else if (toupper(*c) == 'S') {
                                TrackSame = track;
                                track = FALSE;
                            } else if (toupper(*c) == 'D') {
                                TrackDifferent = track;
                                track = FALSE;
                            } else if (toupper(*c) == 'O') {
                                TrackReadonly = track;
                                track = FALSE;
                            } else if (toupper(*c) == 'I') {
                                TrackSlmFiles = track;
                                track = FALSE;
                            } else if (toupper(*c) == '-') {
                                track = TRUE;
                            } else {
                                idsError = 0;
                                goto LUsage;
                            }
                            c++;
                        }
                        break;
                    }
                case '?':
                    {
                        int j = 0;
                        windiff_usage(NULL);
                        for (++tok; tok[1] != '\0'; ++tok)
                            if ('?'==*tok) ++j;

                        if (2==j) {
                            WriteProfileString(APPNAME, "SYSUK", "1");
                        }
                        return;
                    }
                default:
                    idsError = 0;
                    goto LUsage;
            }
        } else {
        LFile:
            if (ta->first == NULL) {
                ta->first = tok;
            } else {
                ta->second = tok;
            }
        }
        tok = GetNextToken(NULL);
    }

    // maybe version control
    if (fMaybeVersionControl)
    {
        if (!ta->second)
        {
            // if user didn't specify two paths, then kick us into version
            // control mode, where we'll compare the specified directory
            // against its matching server revisions.
            ta->fVersionControl = TRUE;
        }
    }

    if (ta->fInputFile && ta->first && !PerformReplacement(ta->first, 0, 0, 0))
    {
        idsError = IDS_ERROR_IARGS;
        goto LUsage;
    }

    // version control
    if (ta->fVersionControl && !ta->fInputFile)
    {
        if (ta->second != NULL)
        {
            idsError = IDS_ERROR_L_OPTION;
            goto LUsage;
        }
        else
        {
            SLMOBJECT hslm;
            LPSTR srcdir, slmpath;

            if (fSDOpened || fSDDescribe)
            {
                if (ta->first || ta->second)
                {
                    idsError = fSDOpened ? IDS_ERROR_LO_OPTION : IDS_ERROR_LD_OPTION;
                    goto LUsage;
                }
                ta->fOpenedFiles = fSDOpened;
                ta->fDescribeFiles = fSDDescribe;
            }
            else
            {
                if (ta->first == NULL)
                {
                    ta->first = ".";
                }

                if (!fReverse)
                {
                    ta->second = ta->first;
                    ta->first = ta->slmpath;    /* point at buffer */
                    srcdir = ta->second;
                    slmpath = ta->first;
                }
                else
                {
                    ta->second = ta->slmpath;
                    srcdir = ta->first;
                    slmpath = ta->second;
                }

                /*
                 * look for the slm enlistment dir in
                 * the other argument (NULL means current dir).
                 */
                if ((hslm = SLM_New(srcdir, &idsError)) == NULL)
                    goto LUsage;

                if (IsSourceDepot(hslm))
                {
                    LPSTR pTag;

                    // copy source path to the server path
                    lstrcpy(slmpath, srcdir);

                    // check if the source path specified a revision tag
                    pTag = SLM_ParseTag(srcdir, TRUE);
                    if (pTag)
                    {
                        // revision tag was specified, so now that
                        // SLM_ParseTag stripped it off of srcdir, both
                        // slmpath and srcdir contain exactly what we want
                        // them to.  now we just free pTag and we're golden.
                        gmem_free(hHeap, pTag, lstrlen(pTag)+1);
                    }
                    else
                    {
                        // no revision tag specified, so let's go against the
                        // #have revisions.  SLM goes against head revisions,
                        // but that's just because SLM happens to have those
                        // on a share.  since SD doesn't use a share, we have
                        // to query the server for specific versions anyway.
                        // use "windiff * *#head" to mimic the SLM behavior.
                        lstrcat(slmpath, "#have");
                    }
                }
                else
                {
                    SLM_GetMasterPath(hslm, slmpath);
                }
                SLM_Free(hslm);
            }
        }
    }

    /* set the correct depth */
    if (ta->fDeep)
        ;                       /* explicitly set -- leave it alone */
    else if (ta->fVersionControl)
        ;                       /* default to shallow for SLM or SD */
    else ta->fDeep = fDeepDefault;  /* global default */

    if (!fSDOpened && !fSDDescribe && !ta->fInputFile)
    {
        /* any paths to scan ? */
        if (ta->first == NULL)
            return;

        if (ta->second == NULL)
            ta->second = ".";
    }
    else
    {
        ta->fDeep = FALSE;
    }

    SetBusy();

    /* minimise the window if -s flag given */
    if (ta->savelist != NULL || ta->savecomp != NULL) {
        ShowWindow(hwndClient, SW_MINIMIZE);
    }

    /* make an empty view */
    current_view = view_new(hwndRCD);
    DisplayMode = MODE_OUTLINE;

    ta->view = current_view;

    /* attempt to create a worker thread */

    ghThread = CreateThread(NULL, 0, wd_initial, (LPVOID) ta,
                            0, &threadid);
    if (ghThread == NULL)
    {

        /* either the createthread failed, or we are
         * in WIN16 - so do without the extra thread - just
         * call the function synchronously
         */

        wd_initial( (LPVOID) ta);

    }

    return;

LUsage:
    windiff_usage(idsError ? LoadRcString(idsError) : NULL);
} /* ParseArgs */


void
GetFontPref(void)
{
    DeleteObject(g_hFont);
    g_hFont = 0;

    GetProfileString(APPNAME, szFontFaceName, "FixedSys", g_szFontFaceName, sizeof(g_szFontFaceName));
    g_nFontHeight = GetProfileInt(APPNAME, szFontHeight, 12);
    g_fFontBold = GetProfileInt(APPNAME, szFontBold, FALSE);
    g_bFontCharSet = (BYTE)GetProfileInt(APPNAME, szFontCharSet, 0);

    g_hFont = CreateFont(g_nFontHeight, 0, 0, 0,
                         g_fFontBold ? FW_BOLD : FW_DONTCARE,
                         FALSE, FALSE, FALSE,
                         g_bFontCharSet,
                         OUT_DEFAULT_PRECIS,
                         CLIP_LH_ANGLES|CLIP_STROKE_PRECIS,
                         DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE,
                         g_szFontFaceName);
}


/* create any pens/brushes, and read defaults
 * from the profile file for menu settings etc.
 */
void
CreateTools(void)
{

    /* standard message that table class sends us for
     * notifications and queries.
     */
    table_msgcode = RegisterWindowMessage(TableMessage);

    line_numbers = GetProfileInt(APPNAME, szLineNumbers, line_numbers);
    outline_include = GetProfileInt(APPNAME, szFileInclude, outline_include);
    expand_include = GetProfileInt(APPNAME, szLineInclude, expand_include);
    ignore_blanks = GetProfileInt(APPNAME, szBlanks, ignore_blanks);
    Algorithm2 = GetProfileInt(APPNAME, szAlgorithm2, Algorithm2);
    mono_colours = GetProfileInt(APPNAME, szMonoColours, mono_colours);
    picture_mode = GetProfileInt(APPNAME, szPicture, picture_mode);
    hide_markedfiles = GetProfileInt(APPNAME, szHideMark, hide_markedfiles);

    GetProfileString(APPNAME, szEditor, editor_cmdline, editor_cmdline,
                     sizeof(editor_cmdline));

    g_tabwidth = GetProfileInt(APPNAME, szTabWidth, g_tabwidth);

    InitializeCriticalSection(&CSWindiff);

    GetFontPref();
}

/* delete any pens or brushes that were created in CreateTools */
void
DeleteTools(void)
{
    DeleteCriticalSection(&CSWindiff);
    DeleteObject(g_hFont);
}


/* check for messages to keep the UI working. Also check whether
 * we have had an abort request (IDM_ABORT), and
 * return TRUE if abort requested, otherwise FALSE
 */
BOOL
Poll(void)
{
    MSG msg;

    /* don't do the message loop in the WIN32 version since we
     * have multiple threads to handle that, and this is being called
     * on a worker thread, not the UI thread.
     *
     * in the WIN32 case, just check for abort requests
     */

    /* message loop */
    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
        if (!TranslateAccelerator(hwndClient, haccel, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    return(bAbort);
}

/* position child windows on a resize of the main window */

void
DoResize(
         HWND hWnd
         )
{
    RECT rc;
    int bar_width;

    GetClientRect(hWnd, &rc);
    MoveWindow(hwndStatus, 0, 0, rc.right - rc.left, status_height, TRUE);

    bar_width = (rc.right - rc.left) * BAR_WIN_WIDTH / 100;

    /* bar window is hidden unless in expand mode */
    if ((DisplayMode == MODE_EXPAND) && (picture_mode)) {
        MoveWindow(hwndBar, 0, status_height,
                   bar_width, rc.bottom - status_height, TRUE);
        MoveWindow(hwndRCD, bar_width, status_height,
                   (rc.right - rc.left) - bar_width,
                   rc.bottom - status_height, TRUE);
        ShowWindow(hwndBar, SW_SHOW);
    } else {
        MoveWindow(hwndRCD, 0, status_height, (rc.right - rc.left),
                   rc.bottom - status_height, TRUE);
        ShowWindow(hwndBar, SW_HIDE);
    }

}

INT_PTR
APIENTRY
AboutBox(
         HWND hDlg,
         unsigned message,
         WPARAM wParam,
         LPARAM lParam
         )
{
    char ch[256];

    switch (message) {

        case WM_INITDIALOG:
            wsprintf(ch, "%d.%02d", Version, SubVersion);
            SetDlgItemText(hDlg, IDD_VERSION, ch);
            return(TRUE);

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDOK:
                    EndDialog(hDlg, 0);
                    return(TRUE);
            }
            break;
    }
    return(FALSE);
}


/* -- menu commands ---------------------------------------------------*/

/* print the current view */
void
DoPrint(void)
{
    Title head, foot;
    PrintContext context;
    TCHAR szPage[50];
    TCHAR szTitle[20];

    /* print context contains the header and footer. Use the
     * default margins and printer selection
     */

    /* we set the table id to be TABID_PRINTER. When the table calls
     * back to get text and properties, we use this to indicate
     * that the table refered to is the 'current_view', but in print
     * mode, and thus we will use different colours/fonts.
     */
    context.head = &head;
    context.foot = &foot;
    context.margin = NULL;
    context.pd = NULL;
    context.id = TABID_PRINTER;

    /* header is filenames or just WinDiff if no names known*/
    if (strlen(AppTitle) > 0) {
        head.ptext = AppTitle;
    } else {
        head.ptext = (LPSTR)szWinDiff;
    }

    /* header is centred, footer is right-aligned and
     * consists of the page number
     */
    head.props.valid = P_ALIGN;
    head.props.alignment = P_CENTRE;
    lstrcpy(szPage,LoadRcString(IDS_PAGE));
    foot.ptext = (LPSTR)szPage;
    foot.props.valid = P_ALIGN;
    foot.props.alignment = P_RIGHT;

    if ( SendMessage(hwndRCD, TM_PRINT, 0, (LPARAM) &context)) {
        Trace_Status(LoadRcString(IDS_SENT_TO_PRINTER));
    } else {
        windiff_UI(TRUE);
        lstrcpy(szTitle,LoadRcString(IDS_WINDIFF_ERROR));
        MessageBox(hwndClient, LoadRcString(IDS_UNABLE_TO_PRINT),
                szTitle, MB_ICONEXCLAMATION);
        windiff_UI(FALSE);
    }
}

/* find the next line in the current view that is
 * not STATE_SAME. Start from the current selection, if valid, or
 * from the top of the window if no selection.
 *
 */
#define FindNextChange()    _FindNextChange(TRUE, TRUE)
#define FindPrevChange()    _FindPrevChange(TRUE, TRUE)

BOOL
_FindNextChange(BOOL fErrorPopup, BOOL fForceAutoCenter)
{
    long row;
    long dyRowsFromTop = -1;
    long top = (int)SendMessage(hwndRCD, TM_TOPROW, FALSE, 0);

    /* start from the selection or top of the window if no selection */
    if (selection >= 0)
    {
        row = selection + 1;
        if (!fForceAutoCenter)
            dyRowsFromTop = selection - top;
    }
    else
    {
        row = top;
    }


    /* find the next 'interesting' line */
    row = view_findchange(current_view, row, TRUE);
    if (row >= 0) {
        SetSelection(row, 1, dyRowsFromTop);
        return(TRUE);
    } else if (fErrorPopup) {
        windiff_UI(TRUE);
        MessageBox(hwndClient, LoadRcString(IDS_NO_MORE_CHANGES), szWinDiff,
                   MB_ICONINFORMATION|MB_OK);
        windiff_UI(FALSE);

    }
    return(FALSE);
}

/* find the previous line in the current view that is not STATE_SAME
 */
BOOL
_FindPrevChange(BOOL fErrorPopup, BOOL fForceAutoCenter)
{
    long row;
    long dyRowsFromTop = -1;
    long top = (int)SendMessage(hwndRCD, TM_TOPROW, FALSE, 0);

    /* start from the selection or top of window if no selection */
    if (selection >= 0)
    {
        row = selection - 1;
        if (!fForceAutoCenter)
            dyRowsFromTop = selection - top;
    }
    else
    {
        row = top;
    }

    /* find the previous 'interesting' line */
    row = view_findchange(current_view, row, FALSE);
    if (row >= 0) {
        SetSelection(row, 1, dyRowsFromTop);
        return(TRUE);
    } else if (fErrorPopup) {
        windiff_UI(TRUE);
        MessageBox(hwndClient, LoadRcString(IDS_NO_PREV_CHANGES), szWinDiff,
                   MB_ICONINFORMATION|MB_OK);
        windiff_UI(FALSE);

    }
    return(FALSE);
}

#ifndef WriteProfileInt // Only needed if the profile->registry
// mapping is not in use
BOOL
WriteProfileInt(
                LPSTR AppName,
                LPSTR Key,
                int Int
                )
{       char Str[40];
    wsprintf(Str, szD, Int);
    return WriteProfileString(AppName, Key, Str);

} /* WriteProfileInt */
#endif


/* switch to expand view of the selected line */
BOOL
ToExpand(
         HWND hwnd
         )
{


    if (selection < 0) {
        return(FALSE);
    }

    // nothing to do if already expanded
    if (view_isexpanded(current_view)) {
        return(FALSE);
    }

    /*
     * note that we are starting expansion
     */
    view_expandstart(current_view);


    if (!view_isexpanded(current_view)) {
        /* save the current outline size and position */
        WINDOWPLACEMENT wp;

        wp.length = sizeof(wp);

        if (GetWindowPlacement(hwndClient,&wp)) {
            WriteProfileInt(APPNAME, szOutlineShowCmd, wp.showCmd);
            WriteProfileInt(APPNAME, szOutlineMaxX, wp.ptMaxPosition.x);
            WriteProfileInt(APPNAME, szOutlineMaxY, wp.ptMaxPosition.y);
            WriteProfileInt(APPNAME, szOutlineNormLeft, wp.rcNormalPosition.left);
            WriteProfileInt(APPNAME, szOutlineNormTop, wp.rcNormalPosition.top);
            WriteProfileInt(APPNAME, szOutlineNormRight, wp.rcNormalPosition.right);
            WriteProfileInt(APPNAME, szOutlineNormBottom, wp.rcNormalPosition.bottom);
            WriteProfileInt(APPNAME, szOutlineSaved, 1);
        }

        /* restore the previous expanded size and position, if any */
        if (GetProfileInt(APPNAME, szExpandedSaved, 0)) {
            wp.flags                   = 0;
            wp.showCmd
            = GetProfileInt( APPNAME, szExpandShowCmd
                             , SW_SHOWMAXIMIZED);
            wp.ptMaxPosition.x
            = GetProfileInt( APPNAME, szExpandMaxX, 0);
            wp.ptMaxPosition.y
            = GetProfileInt( APPNAME, szExpandMaxY, 0);
            wp.rcNormalPosition.left
            = GetProfileInt( APPNAME, szExpandNormLeft
                             , wp.rcNormalPosition.left);
            wp.rcNormalPosition.top
            = GetProfileInt( APPNAME, szExpandNormTop
                             , wp.rcNormalPosition.top);
            wp.rcNormalPosition.right
            = GetProfileInt( APPNAME, szExpandNormRight
                             , wp.rcNormalPosition.right);
            wp.rcNormalPosition.bottom
            = GetProfileInt( APPNAME, szExpandNormBottom
                             , wp.rcNormalPosition.bottom);
            SetWindowPlacement(hwndClient,&wp);
        } else ShowWindow(hwndClient, SW_SHOWMAXIMIZED);
    }

    /*change the view mapping to expand mode */
    if (view_expand(current_view, selection)) {

        /* ok - we now have an expanded view - change status
         * to show this
         */

        DisplayMode = MODE_EXPAND;

        /* resize to show the graphic bar picture */
        DoResize(hwndClient);


        /* change button,status text-if we are not still busy*/
        if (!fBusy) {
            TCHAR szBuf[10];
            /* the status field when we are expanded shows the
             * tag field (normally the file name) for the
             * item we are expanding
             */
            SetStatus(view_getcurrenttag(current_view) );
            lstrcpy(szBuf,LoadRcString(IDS_OUTLINE));
            SetButtonText(szBuf);
        }

        // Skip to the first change.  (But don't do this if the first
        // line of the file itself has changed; otherwise we would skip
        // over it!)
        if (view_getrowstate(current_view, 0) == STATE_SAME) {
            _FindNextChange(FALSE, TRUE);
        }

        return(TRUE);
    }
    return(FALSE);
} /* ToExpand */

/* switch back to outline view - showing just the list of file names.
 */
void
ToOutline(
          HWND hwnd
          )
{
    // if current_view is NULL, don't access it with view_xxx functions.
    if (!current_view)
        return;

    /*
     * if we are in the middle of expanding, ignore the
     * key stroke - user can try again later
     */
    if (view_expanding(current_view)) {
        return;
    }

    if (view_isexpanded(current_view)) {
        /* save the current expanded size and position */
        WINDOWPLACEMENT wp;

        wp.length = sizeof(wp);
        if (GetWindowPlacement(hwndClient,&wp)) {
            WriteProfileInt(APPNAME, szExpandShowCmd, wp.showCmd);
            WriteProfileInt(APPNAME, szExpandMaxX, wp.ptMaxPosition.x);
            WriteProfileInt(APPNAME, szExpandMaxY, wp.ptMaxPosition.y);
            WriteProfileInt(APPNAME, szExpandNormLeft, wp.rcNormalPosition.left);
            WriteProfileInt(APPNAME, szExpandNormTop, wp.rcNormalPosition.top);
            WriteProfileInt(APPNAME, szExpandNormRight, wp.rcNormalPosition.right);
            WriteProfileInt(APPNAME, szExpandNormBottom, wp.rcNormalPosition.bottom);
            WriteProfileInt(APPNAME, szExpandedSaved, 1);
        }

        /* restore the previous expanded size and position, if any */
        if (GetProfileInt(APPNAME, szOutlineSaved, 0)) {
            wp.flags = 0;
            wp.showCmd
            = GetProfileInt( APPNAME, szOutlineShowCmd
                             , SW_SHOWNORMAL);
            wp.ptMaxPosition.x
            = GetProfileInt( APPNAME, szOutlineMaxX, 0);
            wp.ptMaxPosition.y
            = GetProfileInt( APPNAME, szOutlineMaxY, 0);
            wp.rcNormalPosition.left
            = GetProfileInt( APPNAME, szOutlineNormLeft
                             , wp.rcNormalPosition.left);
            wp.rcNormalPosition.top
            = GetProfileInt( APPNAME, szOutlineNormTop
                             , wp.rcNormalPosition.top);
            wp.rcNormalPosition.right
            = GetProfileInt( APPNAME, szOutlineNormRight
                             , wp.rcNormalPosition.right);
            wp.rcNormalPosition.bottom
            = GetProfileInt( APPNAME, szOutlineNormBottom
                             , wp.rcNormalPosition.bottom);
            SetWindowPlacement(hwndClient,&wp);
        } else {
            ShowWindow(hwndClient, SW_SHOWNORMAL);
        }
    }

    DisplayMode = MODE_OUTLINE;

    /* switch mapping back to outline view */
    view_outline(current_view);

    /* hide bar window and resize to cover */
    DoResize(hwndClient);


    /* change label on button */
    if (!fBusy) {
        TCHAR szBuf[8];
        lstrcpy(szBuf,LoadRcString(IDS_EXPAND));
        SetButtonText(szBuf);
        SetStatus(NULL);
    }
} /* ToOutline */

/*
 * if the user clicks on a MOVED line in expand mode, we jump to the
 * other line. We return TRUE if this was possible,  or FALSE otherwise.
 * If bMove is not true, then just test to see if it is possible to move
 * and don't actually make the selection change. (I was going to have
 * an IsMoved function but there seemed to be so much in common).
 */
BOOL
ToMoved(
        HWND hwnd,
        BOOL bMove
        )
{
    BOOL bIsLeft;
    int linenr, state;
    long i, total;

    if (DisplayMode != MODE_EXPAND) {
        return(FALSE);
    }
    if (selection < 0) {
        return(FALSE);
    }

    state = view_getstate(current_view, selection);
    if (state == STATE_MOVEDLEFT || state == STATE_SIMILARLEFT) {
        bIsLeft = TRUE;
        /* get the linenr of the other copy */
        linenr = abs(view_getlinenr_right(current_view, selection));
    } else if (state == STATE_MOVEDRIGHT || state == STATE_SIMILARRIGHT) {
        bIsLeft = FALSE;
        /* get the linenr of the other copy */
        linenr = abs(view_getlinenr_left(current_view, selection));
    } else {
        /* not a moved line - so we can't find another copy */
        return(FALSE);
    }

    /* search the view for this line nr */
    total = view_getrowcount(current_view);
    for (i = 0; i < total; i++) {
        if (bIsLeft) {
            if (linenr == view_getlinenr_right(current_view, i)) {
                /* found it */
                if (bMove) {
                    SetSelection(i, 1, -1);
                }
                return(TRUE);
            }
        } else {
            if (linenr == view_getlinenr_left(current_view, i)) {
                if (bMove) {
                    SetSelection(i, 1, -1);
                }
                return(TRUE);
            }
        }
    }
    return(FALSE);
} /* ToMoved */


void
RescanFile(
           HWND hwnd
           )
{
    COMPITEM ci;
    int iStart;
    int iEnd;
    int i;

    /* N.B.  This should work in both expanded and outline mode.
     * (used to work only in outline mode)
     */
    if (selection_nrows > 0 || DisplayMode == MODE_EXPAND) {
        if (DisplayMode == MODE_EXPAND) {
            iStart = 0;
            iEnd = 1;
        } else {
            iStart = selection;
            iEnd = iStart + selection_nrows;
        }
        for (i = iStart; i < iEnd; i++) {
            ci = view_getitem(current_view, i);
            if (ci != NULL) {
                compitem_rescan(ci);
            }
        }
    } else {
        windiff_UI(TRUE);
        MessageBox(hwndClient, LoadRcString(IDS_NOTHING_RESCANNED),
                   szWinDiff, MB_ICONSTOP|MB_OK);
        windiff_UI(FALSE);

        return;
    }
    PostMessage(hwndClient, WM_COMMAND, IDM_UPDATE, (LPARAM) ci);
} /* RescanFile */


/*
 * launch an editor on the current file (the file we are expanding, or
 * in outline mode the selected row. Option allows selection of the
 * left file, the right file or the composite view of this item.
 * pe points to a packet of parameters that must be freed before returning.
 * The return value is meaningless (just to conform to CreateThread).
 */
LONG WINAPI
do_editfile(
            PEDITARGS pe
            )
{
    VIEW view = pe->view;
    int option = pe->option;
    long selection = pe->selection;

    COMPITEM item;
    LPSTR fname;
    char cmdline[MAX_PATH] = {'\0'};
    long selline, currentline;
    char * pOut = cmdline;
    char * pIn = editor_cmdline;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    item = view_getitem(view, selection);
    if (item == NULL) {
        windiff_UI(TRUE);
        MessageBox(hwndClient, LoadRcString(IDS_NOTHING_TO_EDIT),
                   szWinDiff, MB_ICONSTOP|MB_OK);
        windiff_UI(FALSE);

        return -1;
    }

    fname = compitem_getfilename(view, item, option);

    if ( 0 == fname ) {
        windiff_UI(TRUE);
        MessageBox(hwndClient, LoadRcString(IDS_FILE_DOESNT_EXIST),
                   szWinDiff, MB_ICONSTOP|MB_OK);
        windiff_UI(FALSE);
        goto error;
    }

    // convert the selected line into a line number within the file
    if (selection > 0) {
        selline = selection;
    } else {
        // if no current selection, look for the line at top of window
        selline = (long) SendMessage(hwndRCD, TM_TOPROW, FALSE, 0);
    }

    switch ( option ) {
        case CI_LEFT:
            do {
                currentline = view_getlinenr_left( view, selline);

                // if the selected line is not in the left file,
                // backup one line and try again until we hit the top of
                // file or find a line that is within the left file

                if (selline > 0) {
                    selline--;
                }
            } while ((currentline <= 0) && (selline > 0));

            break;

        case CI_RIGHT:
            do {
                currentline = view_getlinenr_right( view, selline);
                if (selline > 0) {
                    selline--;
                }
            } while ((currentline <= 0) && (selline > 0));
            break;

        default:
            currentline = 1;
            break;
    }

    if (currentline <=0) {
        currentline = 1;
    }


    while ( *pIn ) {
        switch ( *pIn ) {
            case '%':
                pIn++;
                switch ( *pIn ) {
                    case 'p':
                        lstrcpy( pOut, fname );
                        while ( *pOut )
                            pOut++;
                        break;

                    case 'l':
                        _ltoa( currentline, pOut, 10 );
                        while ( *pOut )
                            pOut++;
                        break;

                    default:
                        if (IsDBCSLeadByte(*pIn) && *(pIn+1)) {
                            *pOut++ = *pIn++;
                        }
                        *pOut++ = *pIn;
                        break;
                }
                pIn++;
                break;

            default:
                if (IsDBCSLeadByte(*pIn) && *(pIn+1)) {
                    *pOut++ = *pIn++;
                }
                *pOut++ = *pIn++;
                break;
        }
    }

    *pOut = '\0';

    /* WIN32 version launches the process and waits for it to
     * complete
     */

    // note - make title of window same each time since if this is
    // a command-window editor (eg slick) NT will only apply window
    // property changes to all subsequent editor windows if they
    // have the same title. If you include the full command line in the
    // window title, it will differ each time. Win95 seems not to use
    // this field.
    si.lpTitle = "Edit File";
    si.cb = sizeof(STARTUPINFO);
    si.lpReserved = NULL;
    si.lpReserved2 = NULL;
    si.cbReserved2 = 0;
    si.lpDesktop = NULL;
    // si.dwXCountChars = 100;            // didn't work.
    // si.dwYCountChars = 60;             // dunno why not.
    si.dwFlags = STARTF_FORCEONFEEDBACK;  // |STARTF_USECOUNTCHARS; didn't work.


    if (!CreateProcess(NULL,
                       cmdline,
                       NULL,
                       NULL,
                       FALSE,
                       NORMAL_PRIORITY_CLASS,
                       NULL,
                       NULL,
                       &si,
                       &pi)) {
        windiff_UI(TRUE);
        MessageBox(hwndClient, LoadRcString(IDS_FAILED_TO_LAUNCH_EDT),
                   szWinDiff, MB_ICONSTOP|MB_OK);
        windiff_UI(FALSE);
        goto error;
    }

    /* wait for completion. */
    WaitForSingleObject(pi.hProcess, INFINITE);

    /* close process and thread handles */
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);

    /* finished with the filename. deletes it if it was a temp. */
    compitem_freefilename(item, option, fname);

    /*
     * refresh cached view always .  A common trick is to edit the
     * composite file and then save it as a new left or right file.
     * Equally the user can edit the left and save as a new right.
     */

    /* We want to force both files to be re-read, but it's not a terribly
     * good idea to throw the lines away on this thread.  Someone might
     * be reading them on another thread! (e.g. user tries to expand
     * file, seems to be taking a long time, so user decides to edit it
     * to have a look!
     * DO NOT file_discardlines(compitem_getleftfile(item))
     * DO NOT file_discardlines(compitem_getrightfile(item))
     */

    /* We don't discard the lines (well, not on this thread) but we do discard
     * status information.  (Used to work only in expanded mode, relying on
     * status being reset when we go back to outline).
     */


    /* force the compare to be re-done */
    compitem_rescan(item);
    PostMessage(hwndClient, WM_COMMAND, IDM_UPDATE, (LPARAM)item);

    error:
    gmem_free(hHeap, (LPSTR) pe, sizeof(EDITARGS));

    return 0;

} /* do_editfile */


/* Launch an editor on a separate thread.  It will actually get a separate
   process, but we want our own thread in this process.  This thread will
   wait until it's finished and then order up a refresh of the UI.
   Need to give it its parameters as a gmem allocated packet because
   it IS on a separate thread.
*/
void
do_editthread(
              VIEW view,
              int option
              )
{
    PEDITARGS pe;
    HANDLE thread;
    DWORD threadid;

    pe = (PEDITARGS) gmem_get(hHeap, sizeof(EDITARGS));
    pe->view = view;
    pe->option = option;
    pe->selection = selection;

    thread = CreateThread( NULL
                           , 0
                           , (LPTHREAD_START_ROUTINE)do_editfile
                           , (LPVOID) pe
                           , 0
                           , &threadid
                         );
    if (thread == NULL)
    {
        /* either the createthread failed, or we are
         * in WIN16 - so do without the extra thread - just
         * call the function synchronously
         */
        do_editfile(pe);
    }
    else CloseHandle(thread);

    // new layout not needed as do_editfile sends IDM_UPDATE

} /* do_editthread */


// we are called when the right mouse button is pressed. Before we are
// called, the row clicked on has been selected. We need to put up
// a context menu.
void
OnRightClick(
            HWND hWnd,
            int x,
            int y)
{
    HMENU hMenu, hSubMenu;
    POINT point;
    UINT uEnable;

    if (DisplayMode == MODE_OUTLINE) {
        hMenu = LoadMenu(hInst, szOutlineMenu);
    } else if (DisplayMode == MODE_EXPAND) {
        hMenu = LoadMenu(hInst, szExpandMenu);
    } else {
        return;
    }


    hSubMenu = GetSubMenu(hMenu, 0);

    // -- lots of stuff to disable inappropriate menu items --

    // enable IDM_TOMOVED only if it is a moved line that we can
    // see the other copy of in this view (and only if there is a single
    // selected line)

    if (DisplayMode == MODE_EXPAND) {
        if (ToMoved(hWnd, FALSE) && (1 == selection_nrows)) {
            uEnable = MF_ENABLED;
        } else {
            uEnable = MF_GRAYED;
        }
        EnableMenuItem(hMenu, IDM_TOMOVED, MF_BYCOMMAND | uEnable);
    }


    // disable next/prev buttons if no more changes in that direction
    if (view_findchange(current_view, selection+1, TRUE) >=0) {
        uEnable = MF_ENABLED;
    } else {
        uEnable = MF_GRAYED;
    }
    EnableMenuItem(hSubMenu, IDM_FCHANGE, MF_BYCOMMAND | uEnable);

    if (view_findchange(current_view, selection-1, FALSE) >=0) {
        uEnable = MF_ENABLED;
    } else {
        uEnable = MF_GRAYED;
    }
    EnableMenuItem(hSubMenu, IDM_FPCHANGE, MF_BYCOMMAND | uEnable);

    // check for left-only and right-only files and disable the appropriate
    // menu item
    // disable all editxxx and Expand if multiple files selected
    if ((DisplayMode == MODE_OUTLINE) && (selection_nrows > 1)) {
        EnableMenuItem(hSubMenu, IDM_EDITLEFT, MF_BYCOMMAND|MF_GRAYED);
        EnableMenuItem(hSubMenu, IDM_EDITRIGHT, MF_BYCOMMAND|MF_GRAYED);
        EnableMenuItem(hSubMenu, IDM_EDITCOMP, MF_BYCOMMAND|MF_GRAYED);
        EnableMenuItem(hSubMenu, IDM_EXPAND, MF_BYCOMMAND|MF_GRAYED);
    } else {
        COMPITEM item = view_getitem(current_view, selection);
        UINT uEnableLeft = MF_ENABLED;
        UINT uEnableRight = MF_ENABLED;
        UINT uEnableComp = MF_ENABLED;
        int state;
        FILEDATA fd;

        state = compitem_getstate(item);

        if (state == STATE_FILERIGHTONLY) {
            uEnableLeft = MF_GRAYED;
        } else if (state == STATE_FILELEFTONLY) {
            uEnableRight = MF_GRAYED;
        }

        fd = compitem_getleftfile(item);
        if (fd && file_IsUnicode(fd)) {
            uEnableComp = MF_GRAYED;
        }
        fd = compitem_getrightfile(item);
        if (fd && file_IsUnicode(fd)) {
            uEnableComp = MF_GRAYED;
        }

        EnableMenuItem(hSubMenu, IDM_EDITLEFT, MF_BYCOMMAND | uEnableLeft);
        EnableMenuItem(hSubMenu, IDM_EDITRIGHT, MF_BYCOMMAND | uEnableRight);
        EnableMenuItem(hSubMenu, IDM_EDITCOMP, MF_BYCOMMAND | uEnableComp);

        if (DisplayMode == MODE_OUTLINE) {
            EnableMenuItem(hSubMenu, IDM_EXPAND, MF_BYCOMMAND|MF_ENABLED);
        }
    }


    // convert the window-based co-ord to a screen co-ord
    point.x = x;
    point.y = y;
    ClientToScreen(hwndRCD, &point);

    TrackPopupMenu(
                  hSubMenu,
                  TPM_LEFTALIGN|TPM_RIGHTBUTTON,
                  point.x, point.y,
                  0,
                  hWnd,
                  NULL);

    DestroyMenu(hMenu);
}

//
// refresh the display after a rescan of a given line.
// try to maintain existing scroll position and selection.
void
OnUpdate(
         COMPITEM item
         )
{

    // save current scroll position
    long row = (long) SendMessage(hwndRCD, TM_TOPROW, FALSE, 0);

    // ... and current selection
    long lSel = selection;
    long cSel = selection_nrows;

    /* update the display.  Options or files may have changed */
    /* discard lines  (thereby forcing re-read).
     */
    file_discardlines(compitem_getleftfile(item));
    file_discardlines(compitem_getrightfile(item));

    view_changediffoptions(current_view);

    // tell the table view to recalculate its
    // idea of the width of each col etc

    SendMessage(hwndRCD, TM_NEWLAYOUT, 0, (LPARAM) current_view);

    // set old scroll position
    SendMessage(hwndRCD, TM_TOPROW, TRUE, row);

    // set back old selection
    SetSelection(lSel, cSel, lSel - row);


    /* force repaint of bar window */
    InvalidateRect(hwndBar, NULL, TRUE);
}

/* status bar and busy flags --------------------------------------------*/


/* set the Text on the statusbar button to reflect the current state */
void
SetButtonText(
              LPSTR cmd
              )
{
    SendMessage(hwndStatus, SM_SETTEXT, IDM_ABORT, (LPARAM) cmd);
}

/* set the status field (left-hand part) of the status bar. */
void
SetStatus(
          LPSTR cmd
          )
{
    SendMessage(hwndStatus, SM_SETTEXT, IDL_STATLAB, (LPARAM) cmd);
}

/*
 * Trace_Status is called from the ssclient.lib functions to report
 * non-fatal errors - put them on the status line
 */
void
Trace_Status(
             LPSTR str
             )
{
    SetStatus(str);
}


/* set the names field - the central box in the status bar */
void
SetNames(
         LPSTR names
         )
{
    SendMessage(hwndStatus, SM_SETTEXT, IDL_NAMES, (LPARAM) names);
    if (names == NULL) {
        AppTitle[0] = '\0';
    } else {
        My_mbsncpy(AppTitle, names, sizeof(AppTitle));
    }
}

/*
 * if we are not already busy, set the busy flag.
 *
 * WIN32: enter critical section first.
 */
BOOL
SetBusy(void)
{
    HMENU hmenu;


    WDEnter();

    if (fBusy) {
        WDLeave();
        return(FALSE);
    }


    fBusy = TRUE;

    SetStatus(LoadRcString(IDS_COMPARING));
    /* status also on window text, so that you can see even from
     * the icon when the scan has finished
     */
    SetWindowText(hwndClient, LoadRcString(IDS_SCANNING));

    /* disable appropriate parts of menu */
    hmenu = GetMenu(hwndClient);
    EnableMenuItem(hmenu, IDM_FILE,MF_DISABLED|MF_GRAYED|MF_BYCOMMAND);
    EnableMenuItem(hmenu, IDM_DIR,MF_DISABLED|MF_GRAYED|MF_BYCOMMAND);
    EnableMenuItem(hmenu, IDM_PRINT,MF_DISABLED|MF_GRAYED|MF_BYCOMMAND);
    EnableMenuItem(hmenu, IDM_SAVELIST,MF_DISABLED|MF_GRAYED|MF_BYCOMMAND);
    EnableMenuItem(hmenu, IDM_COPYFILES,MF_DISABLED|MF_GRAYED|MF_BYCOMMAND);

    /* enable abort only when busy */
    EnableMenuItem(hmenu, IDM_ABORT,MF_ENABLED|MF_BYCOMMAND);
    SetButtonText(LoadRcString(IDS_ABORT));  /* leave DisplayMode unchanged */

    WDLeave();
    return(TRUE);
} /* SetBusy */

void
SetNotBusy(void)
{
    HMENU hmenu;

    /*
     * this function can be called from the worker thread.
     * Thus we must not cause any SendMessage calls to windows
     * owned by the main thread while holding the CritSec or we
     * could cause deadlock.
     *
     * the critsec is only needed to protect the fBusy flag - so
     * clear the busy flag last, and only get the crit sec as needed.
     */

    /* reset button and status bar (clearing out busy flags) */
    if (current_view == NULL) {
        SetButtonText(LoadRcString(IDS_EXIT));
        SetStatus(NULL);
        DisplayMode = MODE_NULL;
    } else if (view_isexpanded(current_view)) {
        TCHAR szBuf[10];
        lstrcpy(szBuf,LoadRcString(IDS_OUTLINE));
        SetButtonText(szBuf);
        SetStatus(view_getcurrenttag(current_view) );
        DisplayMode = MODE_EXPAND;
    } else {
        TCHAR szBuf[8];
        lstrcpy(szBuf,LoadRcString(IDS_EXPAND));
        SetButtonText(szBuf);
        SetStatus(NULL);
        DisplayMode = MODE_OUTLINE;
    }

    SetWindowText(hwndClient, szWinDiff);

    /* re-enable appropriate parts of menu */
    hmenu = GetMenu(hwndClient);
    EnableMenuItem(hmenu, IDM_FILE,MF_ENABLED|MF_BYCOMMAND);
    EnableMenuItem(hmenu, IDM_DIR,MF_ENABLED|MF_BYCOMMAND);
    EnableMenuItem(hmenu, IDM_PRINT,MF_ENABLED|MF_BYCOMMAND);
    EnableMenuItem(hmenu, IDM_SAVELIST,MF_ENABLED|MF_BYCOMMAND);
    EnableMenuItem(hmenu, IDM_COPYFILES,MF_ENABLED|MF_BYCOMMAND);

    /* disable abort now no longer busy */
    EnableMenuItem(hmenu, IDM_ABORT,MF_DISABLED|MF_GRAYED|MF_BYCOMMAND);

    /* clear the busy flag, protected by critical section */
    WDEnter();

    fBusy = FALSE;
    bAbort = FALSE;

    if (ghThread!=NULL) {
        CloseHandle(ghThread);
        ghThread = NULL;
    }
    WDLeave();
} /* SetNotBusy */


BOOL
IsBusy()
{
    BOOL bOK;

    WDEnter();
    bOK = fBusy;
    WDLeave();
    return(bOK);
} /* IsBusy */

void
BusyError(void)
{
    windiff_UI(TRUE);
    MessageBox(hwndClient,
               LoadRcString(IDS_PLEASE_WAIT),
               szWinDiff, MB_OK|MB_ICONSTOP);
    windiff_UI(FALSE);
} /* BusyError */

/* --- colour scheme --------------------------------------------------- */

/*
 * map the state given into a foreground and a background colour
 * for states that are highlighted. Return P_FCOLOUR if the foreground
 * colour (put in *foreground) is to be used, return P_FCOLOUR|P_BCOLOUR if
 * both *foreground and *background are to be used, or 0 if the default
 * colours are to be used.
 */
UINT
StateToColour(
              int state,
              BOOL bMarked,
              int col,
              DWORD * foreground,
              DWORD * foregroundws,
              DWORD * background
              )
{

    /* we always set both colours - allows all the colours to
       be controlled from the profile.  Important for the
       visually impaired.  So we first set the dafaults.
    */
    *foreground = rgb_defaultfore;
    *foregroundws = rgb_defaultforews;
    *background = rgb_defaultback;

    // marked compitems are highlighted specially - for now, use the
    // colour scheme used for different lines in expand mode
    if (bMarked) {
        *foreground = rgb_rightfore;
        *background = rgb_rightback;
        return(P_FCOLOUR|P_FCOLOURWS|P_BCOLOUR);
    }


    switch (state) {

        case STATE_DIFFER:
            /* files that differ are picked out in a foreground highlight,
             * with the default background
             */
            *foreground = rgb_outlinehi;
            return(P_FCOLOUR|P_FCOLOURWS|P_BCOLOUR);

        case STATE_FILELEFTONLY:
            /* zebra lines in both files - right file version */
            *foreground = rgb_fileleftfore;
            *background = rgb_fileleftback;
            return(P_FCOLOUR|P_FCOLOURWS|P_BCOLOUR);

        case STATE_FILERIGHTONLY:
            /* zebra lines in both files - right file version */
            *foreground = rgb_filerightfore;
            *background = rgb_filerightback;
            return(P_FCOLOUR|P_FCOLOURWS|P_BCOLOUR);

        case STATE_SIMILAR:
            /* for files that are same within expand compare options
             * e.g. differ only in ignorable blanks  (NYI)
            */
            *foreground = rgb_similar;
            return(P_FCOLOUR|P_FCOLOURWS|P_BCOLOUR);

        case STATE_LEFTONLY:
            /* lines only in the left file */
            *foreground = rgb_leftfore;
            *background = rgb_leftback;
            return(P_FCOLOUR|P_FCOLOURWS|P_BCOLOUR);

        case STATE_RIGHTONLY:
            /* lines only in the right file */
            *foreground = rgb_rightfore;
            *background = rgb_rightback;
            return(P_FCOLOUR|P_FCOLOURWS|P_BCOLOUR);

        case STATE_MOVEDLEFT:
            /* displaced lines in both files - left file version */
            *foreground = rgb_mleftfore;
            *background = rgb_mleftback;
            return(P_FCOLOUR|P_FCOLOURWS|P_BCOLOUR);

        case STATE_MOVEDRIGHT:
            /* displaced lines in both files - right file version */
            *foreground = rgb_mrightfore;
            *background = rgb_mrightback;
            return(P_FCOLOUR|P_FCOLOURWS|P_BCOLOUR);

        case STATE_SIMILARLEFT:
            /* zebra lines in both files - left file version */
            *foreground = rgb_similarleft;
            *background = rgb_leftback;
            return(P_FCOLOUR|P_FCOLOURWS|P_BCOLOUR);

        case STATE_SIMILARRIGHT:
            /* zebra lines in both files - right file version */
            *foreground = rgb_similarright;
            *background = rgb_rightback;
            return(P_FCOLOUR|P_FCOLOURWS|P_BCOLOUR);

        default:

            /* no highlighting - default colours */
            return(P_FCOLOUR|P_FCOLOURWS|P_BCOLOUR);
    }

}

/* table window communication routines ---------------------------------*/

/* set a given row as the selected row in the table window */
void
SetSelection(
             long rownr,
             long nrows,
             long dyRowsFromTop
             )
{
    TableSelection select;

    select.startrow = rownr;
    select.startcell = 0;
    select.nrows = nrows;
    select.ncells = 1;
    select.dyRowsFromTop = dyRowsFromTop;
    SendMessage(hwndRCD, TM_SELECT, 0, (LPARAM)&select);
}


/* handle table class call back to get nr of rows and columns,
 * and properties for the whole table.
 * the 'table id' is either TABID_PRINTER - meaning we are
 * printing the current_view, or it is the view to
 * use for row/column nr information
 */
long
do_gethdr(
          HWND hwnd,
          lpTableHdr phdr
          )
{
    VIEW view;
    BOOL bIsPrinter = FALSE;

    if (phdr->id == TABID_PRINTER) {
        view = current_view;
        bIsPrinter = TRUE;
    } else {
        view = (VIEW) phdr->id;
    }
    if (view == NULL) {
        return(FALSE);
    }

    phdr->nrows = view_getrowcount(view);

    /*  three columns: line nr, tag and rest of line */

    /*
     * if IDM_NONRS (no line numbers) is selected, suppress the
     * line-nr column entirely to save screen space
     */
    if (line_numbers == IDM_NONRS) {
        phdr->ncols = 2;
        phdr->fixedcols = 0;
    } else {
        phdr->ncols = 3;
        phdr->fixedcols = 1;
    }

    phdr->fixedrows = 0;
    phdr->fixedselectable = FALSE;
    phdr->hseparator = TRUE;
    phdr->vseparator = TRUE;

    phdr->selectmode = TM_ROW | TM_MANY;
    /*
     * find if we are in expand mode - ask for the item we are expanding.
     */
    if (view_isexpanded(view) == TRUE) {

        /* use focus rect as selection mode in expand mode
         * so as not to interfere with background colours.
         */
        phdr->selectmode |= TM_FOCUS;
    } else {
        /* use default solid inversion when possible as it is clearer.*/
        phdr->selectmode |= TM_SOLID;
    }

    /* please send TQ_SCROLL notifications when the table is scrolled */
    phdr->sendscroll = TRUE;
    if (g_hFont) {
        phdr->props.valid = P_FONT;
        phdr->props.hFont = g_hFont;
    }

    return TRUE;
}

/* respond to table callback asking for the size and properties
 * of each column. table id is either TABID_PRINTER (meaning the
 * current_view, for printing) or it is the view to be used.
 */
long
do_getprops(
            HWND hwnd,
            lpColPropsList propslist
            )
{
    int i, cell;
    BOOL bIsPrinter = FALSE;
    VIEW view;
    HFONT hfontSystem = GetStockObject(SYSTEM_FONT);
    HFONT hfontFixed = g_hFont ? g_hFont : GetStockObject(SYSTEM_FIXED_FONT);

    if (propslist->id == TABID_PRINTER) {
        view = current_view;
        bIsPrinter = TRUE;
    } else {
        view = (VIEW) propslist->id;
    }
    if (view == NULL) {
        return(FALSE);
    }

    if (g_hFont)
    {
        HDC hdc;
        TEXTMETRIC tmSystem;
        TEXTMETRIC tmFixed;
        HFONT hfont;

        hdc = GetDC(hwnd);
        if (hdc)
        {
            hfont = SelectObject(hdc, hfontSystem);
            GetTextMetrics(hdc, &tmSystem);
            SelectObject(hdc, hfontFixed);
            GetTextMetrics(hdc, &tmFixed);
            SelectObject(hdc, hfont);
            ReleaseDC(hwnd, hdc);

            if (tmFixed.tmHeight + 1 < tmSystem.tmHeight)
                hfontSystem = hfontFixed;
        }
    }

    /* the table inteface is slightly confused here. we are not
     * guaranteed which columns we are being asked about, so instead
     * of just setting each column cols[0], cols[1] etc, we need
     * to loop through, looking at each column in the table and
     * seeing which it is.
     */
    for (i = 0; i < propslist->ncols; i++) {
        cell = i + propslist->startcol;
        propslist->plist[i].props.valid = 0;

        /* for all column widths, add on 1 for the NULL char. */

        /*
         * skip the line nr column if IDM_NONRS
         */
        if (line_numbers == IDM_NONRS) {
            cell++;
        }

        if (cell == 0) {
            /* properties for line nr column */

            propslist->plist[i].nchars = view_getwidth(view, 0)+1;
            propslist->plist[i].props.valid |= P_ALIGN | P_FONT;
            propslist->plist[i].props.alignment = P_CENTRE;
            propslist->plist[i].props.hFont = hfontSystem;
        } else if (cell == 1) {

            /* properties for tag field */
            propslist->plist[i].nchars = view_getwidth(view, 1)+1;
            propslist->plist[i].props.valid |= P_ALIGN | P_FONT;
            propslist->plist[i].props.alignment = P_LEFT;
            propslist->plist[i].props.hFont = hfontSystem;
        } else {
            /* properties for main text column -
             * use a fixed font unless printing (if
             * printing, best to use the default font, because
             * of resolution differences.
             * add on 8 chars to the width to ensure that
             * the width of lines beginning with tabs
             * works out ok
             */
            propslist->plist[i].nchars = view_getwidth(view, 2)+1;
            propslist->plist[i].props.valid |= P_ALIGN;
            propslist->plist[i].props.alignment = P_LEFT;
            if (!bIsPrinter) {
                propslist->plist[i].props.valid |= P_FONT;
                propslist->plist[i].props.hFont = hfontFixed;
            }
        }
    }
    return (TRUE);
}

/* respond to a table callback asking for the contents of individual cells.
 * table id is either TABID_PRINTER, or it is a pointer to the view
 * to use for data. If going to the printer, don't set the
 * colours (stick to black and white).
 */
long
do_getdata(
           HWND hwnd,
           lpCellDataList cdlist
           )
{
    int start, endcell, col, i;
    int state, markedstate;
    lpCellData cd;
    VIEW view;
    LPSTR textp;
    LPWSTR pwzText;
    BOOL bIsPrinter = FALSE;

    if (cdlist->id == TABID_PRINTER) {
        view = current_view;
        bIsPrinter = TRUE;
    } else {
        view = (VIEW) cdlist->id;
    }

    /* set state data */
    state = view_getstate(view, cdlist->row);
    markedstate = view_getmarkstate(view, cdlist->row);
    start = cdlist->startcell;
    endcell = cdlist->ncells + start;
    if (cdlist->row >= view_getrowcount(view)) {
        return(FALSE);
    }
    for (i = start; i < endcell; i++) {
        cd = &cdlist->plist[i - start];


        /* skip the line number column if IDM_NONRS */
        if (line_numbers == IDM_NONRS) {
            col = i+1;
        } else {
            col = i;
        }

        /* set colour of text to mark out
         * lines that are changed, if not printer - for the
         * printer everything should stay in the default colours
         * or it will be grayed out and look ugly
         */

        if ( !bIsPrinter
          || (GetProfileInt(APPNAME, szColourPrinting, 0) > 0)) {

            /* convert the state of the requested row into a
             * colour scheme. returns P_FCOLOUR and/or
             * P_BCOLOUR if it sets either of the colours
             */
            cd->props.valid |=
            StateToColour(
                         state,
                         markedstate,
                         col,
                         &cd->props.forecolour,
                         &cd->props.forecolourws,
                         &cd->props.backcolour);
        }

        textp = view_gettext(view, cdlist->row, col);
        if (cd->nchars != 0) {
            if (textp == NULL) {
                cd->ptext[0] = '\0';
            } else {
                My_mbsncpy(cd->ptext, textp, cd->nchars -1);
                cd->ptext[cd->nchars - 1] = '\0';
            }
        }

        //$ review: (chrisant) YUCK.  this is ugly, but i'll fix it when i
        // rewrite windiff to be 100% unicode for the file contents, should be
        // about Oct00 or Nov99.
        pwzText = view_gettextW(view, cdlist->row, col);
        if (pwzText && cd->nchars)
        {
            cd->pwzText = (WCHAR*)gmem_get(hHeap, cd->nchars * sizeof(*cd->pwzText));
            wcsncpy(cd->pwzText, pwzText, cd->nchars -1);
            cd->pwzText[cd->nchars - 1] = 0;
        }
        else
        {
            gmem_free(hHeap, (LPSTR) cd->pwzText, cd->nchars * sizeof(*cd->pwzText));
            cd->pwzText = 0;
        }

    }
    return(TRUE);
}

/* table window has finished with this view. it can be deleted.
 */
void
SvrClose(void)
{
    view_delete(current_view);
    current_view = NULL;

    /* hide picture - only visible when we are in MODE_EXPAND */
    DisplayMode = MODE_NULL;
    DoResize(hwndClient);

    /* if we already busy when closing this view (ie
     * we are in the process of starting a new scan,
     * then leave the status bar alone, otherwise
     * we should clean up the state of the status bar
     */
    if (!fBusy) {
        SetButtonText(LoadRcString(IDS_EXIT));
        SetNames(NULL);
        SetStatus(NULL);

    }

} /* SvrClose */


/* handle callbacks and notifications from the table class */
long
TableServer(
            HWND hwnd,
            WPARAM cmd,
            LPARAM lParam
            )
{
    lpTableHdr phdr;
    lpColPropsList proplist;
    lpCellDataList cdlist;
    lpTableSelection pselect;

    switch (cmd) {
        case TQ_GETSIZE:
            /* get the nr of rows and cols in this table */
            phdr = (lpTableHdr) lParam;
            return(do_gethdr(hwnd, phdr));

        case TQ_GETCOLPROPS:
            /* get the size and properties of each column */
            proplist = (lpColPropsList) lParam;
            return (do_getprops(hwnd, proplist));

        case TQ_GETDATA:
            /* get the contents of individual cells */
            cdlist = (lpCellDataList) lParam;
            return (do_getdata(hwnd, cdlist));


        case TQ_SELECT:
            /* selection has changed */
        case TQ_ENTER:
            /* user has double-clicked or pressed enter */

            pselect = (lpTableSelection) lParam;

            /* store location for use in later search (IDM_FCHANGE) */

            /*
             * convert selection so that it always runs forward - we
             * do not need to know where the anchor vs endpoint is
             */
            if (pselect->nrows == 0) {
                selection = -1;
                selection_nrows = 0;
            } else {
                if (pselect->nrows < 0) {
                    selection = pselect->startrow + pselect->nrows + 1;
                    selection_nrows = -pselect->nrows;
                } else {
                    selection = (int) pselect->startrow;
                    selection_nrows = pselect->nrows;
                }
                if (cmd == TQ_ENTER) {
                    /* try to expand this row */
                    if (!ToExpand(hwnd)) {
                        /* expand failed - maybe this
                         * is a moved line- show the other
                         * copy
                         */
                        ToMoved(hwnd, TRUE);
                    }

                }
            }
            break;

        case TQ_CLOSE:
            /* close this table - table class no longer needs data*/
            SvrClose();
            break;

        case TQ_SCROLL:
            /* notification that the rows visible in the window
             * have changed -change the current position lines in
             * the graphic bar view (the sections picture)
             */
            if (picture_mode) {
                BarDrawPosition(hwndBar, NULL, TRUE);
            }
            break;

        case TQ_TABS:
            if (lParam != 0) {
                LONG * pTabs = (LONG *) lParam;
                *pTabs = g_tabwidth;
            }
            return TRUE;

        case TQ_SHOWWHITESPACE:
            if (lParam != 0) {
                LONG * pbShowWhitespace = (LONG *) lParam;
                *pbShowWhitespace = (show_whitespace && view_isexpanded(current_view));
            }
            return TRUE;

        default:
            return(FALSE);
    }
    return(TRUE);
}

/* --- thread worker routines (called synchoronously in WIN16)--------------*/

/*
 * called on worker thread (not UI thread) to handle the work
 * requested on the command line. called directly from UI thread if
 * WIN16.
 *
 * arg is a pointer to a THREADARGS block allocated from gmem_get(hHeap). This
 * needs to be freed before exiting.
 */
DWORD WINAPI
wd_initial(
           LPVOID arg
           )
{
    PTHREADARGS pta = (PTHREADARGS) arg;
    COMPLIST cl = 0;
    COMPITEM ci = NULL;
    BOOL fOK = TRUE;
    LEFTRIGHTPAIR ppairs = 0;
    LPCSTR pszLeftHdr;
    LPCSTR pszRightHdr;

    /* build a complist from these args,
     * and register with the view we have made
     */
    if (pta->fInputFile)
    {
        ppairs = SLM_ReadInputFile(pta->first, pta->second, pta->fInputFileSingle, pta->fVersionControl);
        pszLeftHdr = "Left";
        pszRightHdr = "Right";

        if (!ppairs)
        {
            SetNotBusy();
            MessageBox(hwndClient, LoadRcString(IDS_ERROR_IARGS_OPENFILE), szWinDiff, MB_OK);
            exit(1);
        }
    }
    else if (pta->fOpenedFiles)
    {
        ppairs = SLM_GetOpenedFiles();
        pszLeftHdr = "depot#have";
        pszRightHdr = "client";
    }
    else if (pta->fDescribeFiles)
    {
        ppairs = SLM_GetDescribeFiles();
        pszLeftHdr = "before";
        pszRightHdr = "after";
    }

    if (ppairs)
    {
        int sequence = 0;

        while (ppairs)
        {
	    ++sequence;
            complist_append(&cl, LEFTRIGHTPAIR_Left(ppairs),
                            LEFTRIGHTPAIR_Right(ppairs), &sequence);
            ppairs = LEFTRIGHTPAIR_Next(ppairs);
        }

        fOK = complist_appendfinished(&cl, pszLeftHdr, pszRightHdr, pta->view);
    }
    else
    {
        if (pta->server != NULL)
        {
            cl = complist_remote(pta->server, pta->first, pta->second,
                                 pta->view, pta->fDeep);
        }
        else
        {
            cl = complist_args(pta->first, pta->second, pta->view, pta->fDeep);
        }
    }

    /*
     * the app can be closed during execution of this routine if
     * we don't retain BUSY. This means we can be expanding structures
     * while the main thread is freeing them.
     *
     * SetNotBusy();
     */

    if (cl == NULL || !fOK) {
        view_close(pta->view);
        gmem_free(hHeap, (LPSTR) pta, sizeof(THREADARGS));
        SetNotBusy();
        return 0;
    }

    /* Comparison complete.  Should we tell anybody? */
    if (pta->notify!=NULL) {
        char cmdline[512];
        lstrcpy(cmdline, "NET SEND ");
        lstrcat(cmdline, pta->notify);
        lstrcat(cmdline, " Finished Windiff ");
        lstrcat(cmdline, pta->first);
        lstrcat(cmdline, " ");
        lstrcat(cmdline, pta->second);
        WinExec(cmdline, SW_SHOWNORMAL);
        /* Don't check retcode.  If it fails too bad.  What would we do?  Net send a msg? */
    }


    /* if savelist or savecomp was selected, write out the list or comp file */
    if (pta->savelist != NULL || pta->savecomp != NULL) {
        if (pta->savelist != NULL) {
            complist_savelist(cl, pta->savelist, pta->listopts);
        }

        if (pta->savecomp != NULL) {
            /* if list item was selected, use that */
            if (selection >= 0) {
                ci = view_getitem(pta->view, selection);
          }
          else {
              /* default to first visible item, if any */
              if (view_getrowcount(pta->view) > 0) {
                  ci = view_getitem(pta->view, 0);
              }
          }
          compitem_savecomp(pta->view, ci, pta->savecomp, pta->compopts);
        }
        gmem_free(hHeap, (LPSTR) pta, sizeof(THREADARGS));
        SetNotBusy();

        /* exit if -x was set */
        if (pta->fExit) {
            exit(0);
        }
    }


    /* if savelist was selected, write out the list and exit if -x was set */
    if (pta->savelist != NULL) {
        complist_savelist(cl, pta->savelist, pta->listopts);
        gmem_free(hHeap, (LPSTR) pta, sizeof(THREADARGS));
        SetNotBusy();
        if (pta->fExit) exit(0);
    }

    /* if there was only one file, expand it, unless... */
    if (view_getrowcount(pta->view) == 1) {
        /* The interesting case is where there are a bunch of files
           but only one of them is Different.  In this case we do
           NOT expand it even though it is the only one showing.
        */
//        UINT nItems = complist_itemcount(view_getcomplist(pta->view));
        UINT nItems = complist_itemcount(cl);
        /* And even then, don't expand if the option said don't.
           Imagine just one HUGE REMOTE FILE.  Painful.
        */
        if (nItems==1 && fAutoExpand) {
            SetSelection(0, 1, -1);
            ToExpand(hwndClient);
        }
    }


    gmem_free(hHeap, (LPSTR) pta, sizeof(THREADARGS));
    SetNotBusy();
    return(0);
} /* wd_initial */


/*
 * called on worker thread (not UI thread) to handle a Dir request
 * (called synchronously if WIN16).
 */
DWORD WINAPI
wd_dirdialog(LPVOID arg)
{

    VIEW view = (VIEW) arg;

    /* make a COMPLIST using the directory dialog,
     * and notify the view
     */
    if (complist_dirdialog(view) == NULL) {
        view_close(view);
    }

    /* all done! */
    SetNotBusy();
    return(0);
}


/*
 * called on worker thread to do a remote diff
 */
DWORD WINAPI
wd_remote(
          LPVOID arg
          )
{
    VIEW view = (VIEW) arg;

    /* make a COMPLIST using the remote dialog,
     * and remote checksum server, and notify
     * the new view of this complist.
     */
    if (complist_remote(NULL, NULL, NULL, view, TRUE) == NULL) {
        view_close(view);
    }

    /* all done! */
    SetNotBusy();

    return(0);
} /* wd_remote */

/*
 * called on worker thread to do a copy-files operation
 * (called synchronously if WIN16).
 */
DWORD WINAPI
wd_copy(
        LPVOID arg
        )
{

    VIEW view = (VIEW) arg;

    complist_copyfiles(view_getcomplist(view), NULL, 0);

    SetNotBusy();

    return(0);
}


/*----- winproc for main window ---------------------------------
 *
 */

INT_PTR
APIENTRY
MainWndProc(
            HWND hWnd,
            UINT message,
            WPARAM wParam,
            LPARAM lParam
            )
{
    char str[32];
    long ret;
    DWORD threadid;

    switch (message) {

        case WM_CREATE:

            /* initialise menu options to default/saved
             * option settings
             */

#define CHECKMENU(id, fChecked)  \
          CheckMenuItem(hMenu, (id), (fChecked) ? MF_CHECKED:MF_UNCHECKED)

            /* outline_include options */
            CHECKMENU(IDM_OUTLINE_INCSAME,   (outline_include & INCLUDE_SAME));
            CHECKMENU(IDM_OUTLINE_INCLEFT,   (outline_include & INCLUDE_LEFTONLY));
            CHECKMENU(IDM_OUTLINE_INCRIGHT,  (outline_include & INCLUDE_RIGHTONLY));
            CHECKMENU(IDM_OUTLINE_INCDIFFER, (outline_include & INCLUDE_DIFFER));

            /* expand_include options */
            CHECKMENU(IDM_EXPAND_INCSAME,         (expand_include & INCLUDE_SAME));
            CHECKMENU(IDM_EXPAND_INCLEFT,         (expand_include & INCLUDE_LEFTONLY));
            CHECKMENU(IDM_EXPAND_INCRIGHT,        (expand_include & INCLUDE_RIGHTONLY));
            CHECKMENU(IDM_EXPAND_INCMOVEDLEFT,    (expand_include & INCLUDE_MOVEDLEFT));
            CHECKMENU(IDM_EXPAND_INCMOVEDRIGHT,   (expand_include & INCLUDE_MOVEDRIGHT));
            CHECKMENU(IDM_EXPAND_INCSIMILARLEFT,  (expand_include & INCLUDE_SIMILARLEFT));
            CHECKMENU(IDM_EXPAND_INCSIMILARRIGHT, (expand_include & INCLUDE_SIMILARRIGHT));

            /* other options */
            CHECKMENU(line_numbers, TRUE);
            CHECKMENU(expand_mode, TRUE);
            CHECKMENU(IDM_IGNBLANKS, ignore_blanks);
            CHECKMENU(IDM_SHOWWHITESPACE, show_whitespace);
            CHECKMENU(IDM_ALG2, Algorithm2);
            CHECKMENU(IDM_MONOCOLS, mono_colours);
            CHECKMENU(IDM_PICTURE, picture_mode);
            CHECKMENU(IDM_HIDEMARK, hide_markedfiles);
#undef CHECKMENU

            /* nothing currently displayed */
            DisplayMode = MODE_NULL;

            break;

    case WM_SYSCOLORCHANGE:
      {
	 HIGHCONTRAST hc;
	 hc.cbSize = sizeof(hc);
	 SystemParametersInfo(SPI_GETHIGHCONTRAST,0 ,&hc, 0);
	 mono_colours = (hc.dwFlags & HCF_HIGHCONTRASTON);
	 if (mono_colours) {
	   SetMonoColours();
	 } else {
	   SetColours();	
	 }
	 CheckMenuItem(hMenu, IDM_MONOCOLS,
		       mono_colours? MF_CHECKED:MF_UNCHECKED);
	 wsprintf(str, szD, mono_colours);
	 WriteProfileString(APPNAME, szMonoColours, str);
	 SendMessage(hwndRCD, message, wParam, lParam);
	 SendMessage(hwndStatus, message, wParam, lParam);
	 SendMessage(hwndBar, message, wParam, lParam);
	 /* The diffs are still valid, but force a re-display
	  * of bar window and main table.
	  */
	 SendMessage(hwndBar, WM_COMMAND, IDM_MONOCOLS, 0);
	 InvalidateRect(hwndBar, NULL, TRUE);
	 view_changeviewoptions(current_view);

      }
      break;


        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDM_EXIT:
                    if (ghThread!=NULL) {
                        // First idea was to TerminateThread.
                        // This idea didn't work.  Terminating the thread may terminate it inside
                        // a critical section below us (e.g. in heap manager) and this means that
                        // next time we try to use the heap (probably in WriteProfile) we hang!
                        //
                        // Next idea was to let the worker thread keep running and just ExitProcess.
                        // This doesn't work because it fails to clean up temp files which get left
                        // lying around - and some of these may even be read only.
                        //
                        // Next idea is just to do ABORT and let the fellow try again.
                        //
                        // This still isn't good because sometimes it just doesn't want to abort (always
                        // to do with some sort of i/o, usually network not necessarily remote server)
                        //
                        // Fourth idea (not yet implemented as I write this is to keep a separate
                        // list of temp files which should be cleaned up, spawn a separate PROCESS
                        // (n.b. NOT thread) which will clean them, and then ExitProcess.
                        // This means that whenever a temp file is created we keep track of it.
                        // The obvious way is to have a TempFile class (in the C++ sense).
                        //
                        // grep for GetTempFileName to find places where temps are created.

                        bAbort = TRUE;
                        SetStatus(LoadRcString(IDS_ABORT_PENDING));
                        break;
                    }
                    if (!view_isexpanded(current_view)) {
                        /* save the current outline size and position */
                        WINDOWPLACEMENT wp;
                        wp.length = sizeof(wp);
                        if (GetWindowPlacement(hwndClient,&wp)) {
                            WriteProfileInt(APPNAME, szOutlineShowCmd, wp.showCmd);
                            WriteProfileInt(APPNAME, szOutlineMaxX, wp.ptMaxPosition.x);
                            WriteProfileInt(APPNAME, szOutlineMaxY, wp.ptMaxPosition.y);
                            WriteProfileInt(APPNAME, szOutlineNormLeft, wp.rcNormalPosition.left);
                            WriteProfileInt(APPNAME, szOutlineNormTop, wp.rcNormalPosition.top);
                            WriteProfileInt(APPNAME, szOutlineNormRight, wp.rcNormalPosition.right);
                            WriteProfileInt(APPNAME, szOutlineNormBottom, wp.rcNormalPosition.bottom);
                            WriteProfileInt(APPNAME, szOutlineSaved, 1);
                        }
                    } else {
                        /* save the current expanded size and position */
                        WINDOWPLACEMENT wp;
                        wp.length = sizeof(wp);
                        if (GetWindowPlacement(hwndClient,&wp)) {
                            WriteProfileInt(APPNAME, szExpandShowCmd, wp.showCmd);
                            WriteProfileInt(APPNAME, szExpandMaxX, wp.ptMaxPosition.x);
                            WriteProfileInt(APPNAME, szExpandMaxY, wp.ptMaxPosition.y);
                            WriteProfileInt(APPNAME, szExpandNormLeft, wp.rcNormalPosition.left);
                            WriteProfileInt(APPNAME, szExpandNormTop, wp.rcNormalPosition.top);
                            WriteProfileInt(APPNAME, szExpandNormRight, wp.rcNormalPosition.right);
                            WriteProfileInt(APPNAME, szExpandNormBottom, wp.rcNormalPosition.bottom);
                            WriteProfileInt(APPNAME, szExpandedSaved, 1);
                        }
                    }
                    DestroyWindow(hWnd);
                    break;

                case IDM_ABORT:
                    /* abort menu item, or status bar button.
                     * the status bar button text gives the appropriate
                     * action depending on our state - abort, outline
                     * or expand. But the command sent is always
                     * IDM_ABORT. Thus we need to check the state
                     * to see what to do. If we are busy, set the abort
                     * flag. If there is nothing to view,
                     * exit, otherwise switch outline<->expand
                     */
                    if (IsBusy()) {
                        bAbort = TRUE;
                        SetStatus(LoadRcString(IDS_ABORT_PENDING));
                    } else if (DisplayMode == MODE_NULL) {
                        DestroyWindow(hWnd);
                    } else if (DisplayMode == MODE_EXPAND) {
                        ToOutline(hWnd);
                    } else {
                        ToExpand(hWnd);
                    }
                    break;

                case IDM_FILE:
                    /* select two files and compare them */
                    if (SetBusy()) {


                        /* close the current view */
                        view_close(current_view);

                        /* make a new empty view */
                        current_view = view_new(hwndRCD);

                        /* make a COMPLIST using the files dialog,
                         * and notify the view
                         */
                        if (complist_filedialog(current_view) == NULL) {
                            view_close(current_view);
                        }

                        /* all done! */
                        SetNotBusy();
                    } else {
                        BusyError();
                    }
                    break;

                case IDM_DIR:

                    /* read two directory names, scan them and
                     * compare all the files and subdirs.
                     */
                    if (SetBusy()) {

                        /* close the current view */
                        view_close(current_view);

                        /* make a new empty view */
                        current_view = view_new(hwndRCD);

                        ghThread = CreateThread(NULL, 0, wd_dirdialog,
                                                (LPVOID) current_view, 0, &threadid);

                        if (ghThread == NULL)
                        {

                            /*
                             * either we are on WIN16, or the
                             * thread call failed. continue
                             * single-threaded.
                             */
                            wd_dirdialog( (LPVOID) current_view);


                        }

                    } else {
                        BusyError();
                    }
                    break;

                case IDM_REMOTE:

                    /* compare dir against remote dir */
                    if (SetBusy()) {

                        /* close the current view */
                        view_close(current_view);

                        /* make a new empty view */
                        current_view = view_new(hwndRCD);

                        ghThread = CreateThread(NULL, 0, wd_remote,
                                                (LPVOID) current_view, 0, &threadid);

                        if (ghThread == NULL) {

                            /* thread creation failed -
                             * continue single-threaded
                             */

                            wd_remote( (LPVOID) current_view);
                        }
                    } else {
                        BusyError();
                    }

                    break;

                case IDM_CLOSE:
                    /* close the output list -
                     * discard all results so far
                     */
                    if (!IsBusy()) {
                        view_close(current_view);
                    }
                    break;

                case IDM_PRINT:
                    /* print the current view -
                     * either the outline list of filenames,
                     * or the currently expanded file.
                     */
                    if (!IsBusy()) {
                        DoPrint();
                    } else {
                        BusyError();
                    }
                    break;

                case IDM_TIME:
                    /* show time it took */
                    {       char msg[50];
                        DWORD tim;
                        if (IsBusy()) {
                            BusyError();
                        } else {
                            tim = complist_querytime();
                            wsprintf(msg, LoadRcString(IDS_SECONDS), tim/1000, tim%1000);
                            Trace_Status(msg);
                        }
                    }
                    break;

                case IDM_TRACE:
                    /* enable tracing */
                    bTrace = TRUE;
                    Trace_Status(LoadRcString(IDS_TRACING_ENABLED));
                    break;

                case IDM_TRACEOFF:
                    /* enable tracing */
                    bTrace = FALSE;
                    Trace_Status(LoadRcString(IDS_TRACING_DISABLED));
                    break;

                case IDM_SAVELIST:
                    /* allow user to save list of same/different files
                     * to a text file. dialog box to give filename
                     * and select which types of file to include
                     */
                    if (current_view == NULL) {
                        MessageBox(hWnd,
                                   LoadRcString(IDS_CREATE_DIFF_LIST),
                                   szWinDiff, MB_OK|MB_ICONSTOP);
                        break;
                    }

                    complist_savelist(view_getcomplist(current_view), NULL, outline_include);
                    break;

                case IDM_COPYFILES:
                    /*
                     * copy files that are same/different to a new
                     * root directory. dialog box allows user
                     * to select new root and inclusion options
                     */
                    if (current_view == NULL) {
                        MessageBox(hWnd,
                                   LoadRcString(IDS_CREATE_DIFF_LIST),
                                   szWinDiff, MB_OK|MB_ICONSTOP);
                        break;
                    }

                    if (SetBusy()) {
                        ghThread = CreateThread(NULL, 0, wd_copy,
                                                (LPVOID) current_view, 0, &threadid);
                        if (ghThread == NULL)
                        {

                            /* either we are on WIN16, or
                             * the thread call failed -
                             * either way, continue
                             * single threaded.
                             */

                            wd_copy( (LPVOID) current_view);
                        }

                    } else {
                        BusyError();
                    }

                    break;

                case IDM_ABOUT:
                    ShellAbout( hWnd,
                                (LPTSTR)szWinDiff,
                                LoadRcString(IDS_TOOL_DESCRIPTION),
                                LoadIcon(hInst, szWinDiff)
                              );
                    break;

                case IDM_CONTENTS:
                    /* Help contents */
                    WinHelp(hWnd, "windiff.hlp", HELP_INDEX, 0);
                    break;

                    /* launch an editor on the current item - left, right or
                     * composite view
                     */
                case IDM_EDITLEFT:
                    do_editthread(current_view, CI_LEFT);
                    break;

                case IDM_EDITRIGHT:
                    do_editthread(current_view, CI_RIGHT);
                    break;

                case IDM_EDITCOMP:
                    {
                        COMPITEM item = view_getitem(current_view, selection);
                        FILEDATA fdLeft;
                        FILEDATA fdRight;

                        fdLeft = compitem_getleftfile(item);
                        fdRight = compitem_getrightfile(item);
                        if ((fdLeft && file_IsUnicode(fdLeft)) || (fdRight && file_IsUnicode(fdRight))) {
                            MessageBox(hWnd, LoadRcString(IDS_NOCOMPUNICODE),
                                       szWinDiff, MB_OK);
                        } else {
                            do_editthread(current_view, CI_COMP);
                        }
                    }
                    break;

                    /* allow customisation of the editor command line */
                case IDM_SETEDIT:
                    if (StringInput(editor_cmdline, sizeof(editor_cmdline),
                                    LoadRcString(IDS_EDITOR_COMMAND),
                                    (LPSTR)szWinDiff, editor_cmdline)) {
                        WriteProfileString(APPNAME, szEditor,
                                           editor_cmdline);
                    }
                    break;

                case IDM_SETTABWIDTH:
                    {
                        char sz[32];
                        int n;

LTabWidth_tryagain:
                        wsprintf(sz, "%d", g_tabwidth);
                        if (StringInput(sz, sizeof(sz),
                                        LoadRcString(IDS_TABWIDTH),
                                        (LPSTR)szWinDiff, sz))
                        {
                            n = atoi(sz);
                            if (n <= 0 || n > 100)
                            {
                                MessageBox(hWnd,
                                           LoadRcString(IDS_BAD_TABWIDTH),
                                           szWinDiff, MB_OK);
                                goto LTabWidth_tryagain;
                            }
                            WriteProfileInt(APPNAME, szTabWidth, n);
                            g_tabwidth = n;
                            SendMessage(hwndRCD, TM_SETTABWIDTH, 0, n);
                        }
                    }
                    break;

                case IDM_TABWIDTH4:
                case IDM_TABWIDTH8:
                    g_tabwidth = (GET_WM_COMMAND_ID(wParam, lParam) == IDM_TABWIDTH8) ? 8 : 4;
                    SendMessage(hwndRCD, TM_SETTABWIDTH, 0, g_tabwidth);
                    break;

                case IDM_SETFONT:
                    {
                        CHOOSEFONT cf;
                        LOGFONT lf;
                        char szFace[LF_FACESIZE];

                        lstrcpy(szFace, g_szFontFaceName);

                        memset(&lf, 0, sizeof(lf));
                        lstrcpy(lf.lfFaceName, szFace);
                        lf.lfWeight = g_fFontBold ? FW_BOLD : FW_DONTCARE;
                        lf.lfHeight = g_nFontHeight;
                        lf.lfCharSet = g_bFontCharSet;

                        memset(&cf, 0, sizeof(cf));
                        cf.lStructSize = sizeof(CHOOSEFONT);
                        cf.hwndOwner = hWnd;
                        cf.lpLogFont = &lf;
                        cf.Flags = CF_INITTOLOGFONTSTRUCT|CF_FORCEFONTEXIST|
                                CF_SCREENFONTS|CF_LIMITSIZE;
                        cf.nSizeMin = 8;
                        cf.nSizeMax = 36;
                        cf.lpszStyle = szFace;
                        if (ChooseFont(&cf))
                            {
                            lstrcpy(g_szFontFaceName, lf.lfFaceName);
                            g_fFontBold = (lf.lfWeight == FW_BOLD);
                            g_nFontHeight = lf.lfHeight;
                            g_bFontCharSet = lf.lfCharSet;

                            WriteProfileString(APPNAME, szFontFaceName, g_szFontFaceName);
                            WriteProfileInt(APPNAME, szFontHeight, g_nFontHeight);
                            WriteProfileInt(APPNAME, szFontBold, g_fFontBold);
                            WriteProfileInt(APPNAME, szFontCharSet, g_bFontCharSet);

                            GetFontPref();

                            view_changeviewoptions(current_view);
                            }
                    }
                    break;



                case IDM_LNRS:
                case IDM_RNRS:
                case IDM_NONRS:

                    /* option selects whether the line nrs displayed
                     * in expand mode are the line nrs in the left
                     * file, the right file or none
                     */

                    CheckMenuItem(GetMenu(hWnd),
                                  line_numbers, MF_UNCHECKED);
                    line_numbers = GET_WM_COMMAND_ID(wParam, lParam);
                    CheckMenuItem(GetMenu(hWnd), line_numbers, MF_CHECKED);
                    wsprintf(str, szD, line_numbers);
                    WriteProfileString(APPNAME, szLineNumbers, str);

                    /* change the display to show the line nr style
                     * chosen
                     */

                    view_changeviewoptions(current_view);
                    break;

                /*
                 * options selecting which lines to include in the
                 * expand listing, based on their state
                 */
                case IDM_EXPAND_INCSAME:
                        /* toggle flag in expand_include options */
                        expand_include ^= INCLUDE_SAME;

                        /* check/uncheck as necessary */
                        CheckMenuItem(hMenu, IDM_EXPAND_INCSAME,
                              (expand_include & INCLUDE_SAME) ?
                                        MF_CHECKED:MF_UNCHECKED);
                        wsprintf(str, szD, expand_include);
                        WriteProfileString(APPNAME, szLineInclude, str);
                        view_changeviewoptions(current_view);
                        break;

                case IDM_EXPAND_INCLEFT:
                        /* toggle flag in expand_include options */
                        expand_include ^= INCLUDE_LEFTONLY;

                        /* check/uncheck as necessary */
                        CheckMenuItem(hMenu, IDM_EXPAND_INCLEFT,
                              (expand_include & INCLUDE_LEFTONLY) ?
                                        MF_CHECKED:MF_UNCHECKED);
                        wsprintf(str, szD, expand_include);
                        WriteProfileString(APPNAME, szLineInclude, str);
                        view_changeviewoptions(current_view);
                        break;

                case IDM_EXPAND_INCRIGHT:
                        /* toggle flag in expand_include options */
                        expand_include ^= INCLUDE_RIGHTONLY;

                        /* check/uncheck as necessary */
                        CheckMenuItem(hMenu, IDM_EXPAND_INCRIGHT,
                              (expand_include & INCLUDE_RIGHTONLY) ?
                                        MF_CHECKED:MF_UNCHECKED);
                        wsprintf(str, szD, expand_include);
                        WriteProfileString(APPNAME, szLineInclude, str);
                        view_changeviewoptions(current_view);
                        break;

                case IDM_EXPAND_INCMOVEDLEFT:
                        /* toggle flag in expand_include options */
                        expand_include ^= INCLUDE_MOVEDLEFT;

                        /* check/uncheck as necessary */
                        CheckMenuItem(hMenu, IDM_EXPAND_INCMOVEDLEFT,
                              (expand_include & INCLUDE_MOVEDLEFT) ?
                                        MF_CHECKED:MF_UNCHECKED);
                        wsprintf(str, szD, expand_include);
                        WriteProfileString(APPNAME, szLineInclude, str);
                        view_changeviewoptions(current_view);
                        break;

                case IDM_EXPAND_INCMOVEDRIGHT:
                        /* toggle flag in expand_include options */
                        expand_include ^= INCLUDE_MOVEDRIGHT;

                        /* check/uncheck as necessary */
                        CheckMenuItem(hMenu, IDM_EXPAND_INCMOVEDRIGHT,
                              (expand_include & INCLUDE_MOVEDRIGHT) ?
                                        MF_CHECKED:MF_UNCHECKED);
                        wsprintf(str, szD, expand_include);
                        WriteProfileString(APPNAME, szLineInclude, str);
                        view_changeviewoptions(current_view);
                        break;

                case IDM_EXPAND_INCSIMILARLEFT:
                        /* toggle flag in expand_include options */
                        expand_include ^= INCLUDE_SIMILARLEFT;

                        /* check/uncheck as necessary */
                        CheckMenuItem(hMenu, IDM_EXPAND_INCSIMILARLEFT,
                              (expand_include & INCLUDE_SIMILARLEFT) ?
                                        MF_CHECKED:MF_UNCHECKED);
                        wsprintf(str, szD, expand_include);
                        WriteProfileString(APPNAME, szLineInclude, str);
                        view_changeviewoptions(current_view);
                        break;

                case IDM_EXPAND_INCSIMILARRIGHT:
                        /* toggle flag in expand_include options */
                        expand_include ^= INCLUDE_SIMILARRIGHT;

                        /* check/uncheck as necessary */
                        CheckMenuItem(hMenu, IDM_EXPAND_INCSIMILARRIGHT,
                              (expand_include & INCLUDE_SIMILARRIGHT) ?
                                        MF_CHECKED:MF_UNCHECKED);
                        wsprintf(str, szD, expand_include);
                        WriteProfileString(APPNAME, szLineInclude, str);
                        view_changeviewoptions(current_view);
                        break;

                    /*
                     * options selecting which files to include in the
                     * outline listing, based on their state
                     */
                case IDM_OUTLINE_INCLEFT:


                    /* toggle flag in outline_include options */
                    outline_include ^= INCLUDE_LEFTONLY;

                    /* check/uncheck as necessary */
                    CheckMenuItem(hMenu, IDM_OUTLINE_INCLEFT,
                                  (outline_include & INCLUDE_LEFTONLY) ?
                                  MF_CHECKED:MF_UNCHECKED);

                    wsprintf(str, szD, outline_include);
                    WriteProfileString(APPNAME, szFileInclude, str);
                    view_changeviewoptions(current_view);


                    break;

                case IDM_OUTLINE_INCRIGHT:


                    outline_include ^= INCLUDE_RIGHTONLY;

                    CheckMenuItem(hMenu, IDM_OUTLINE_INCRIGHT,
                                  (outline_include & INCLUDE_RIGHTONLY) ?
                                  MF_CHECKED:MF_UNCHECKED);
                    wsprintf(str, szD, outline_include);
                    WriteProfileString(APPNAME, szFileInclude, str);
                    view_changeviewoptions(current_view);

                    break;

                case IDM_OUTLINE_INCSAME:


                    outline_include ^= INCLUDE_SAME;

                    CheckMenuItem(hMenu, IDM_OUTLINE_INCSAME,
                                  (outline_include & INCLUDE_SAME) ?
                                  MF_CHECKED:MF_UNCHECKED);
                    wsprintf(str, szD, outline_include);
                    WriteProfileString(APPNAME, szFileInclude, str);
                    view_changeviewoptions(current_view);


                    break;


                case IDM_OUTLINE_INCDIFFER:



                    outline_include ^= INCLUDE_DIFFER;

                    CheckMenuItem(hMenu, IDM_OUTLINE_INCDIFFER,
                                  (outline_include & INCLUDE_DIFFER) ?
                                  MF_CHECKED:MF_UNCHECKED);

                    wsprintf(str, szD, outline_include);
                    WriteProfileString(APPNAME, szFileInclude, str);
                    view_changeviewoptions(current_view);


                    break;

                case IDM_UPDATE:
                    OnUpdate( (COMPITEM) lParam);
                    break;


                case IDM_RESCAN:
                    RescanFile(hWnd);

                    /* do we need to force any repaints? */
                    // - no, as RescanFile sends a IDM_UPDATE
                    break;


                case IDM_LONLY:
                case IDM_RONLY:
                case IDM_BOTHFILES:
                    /* option selects whether the expanded file
                     * show is the combined file, or just one
                     * or other of the input files.
                     *
                     * if we are not in expand mode, this also
                     * causes us to expand the selection
                     */


                    CheckMenuItem(GetMenu(hWnd), expand_mode, MF_UNCHECKED);
                    expand_mode = GET_WM_COMMAND_ID(wParam, lParam);
                    CheckMenuItem(GetMenu(hWnd), expand_mode, MF_CHECKED);

                    /* change the current view to show only the lines
                     * of the selected type.
                     */
                    if (DisplayMode == MODE_OUTLINE) {
                        ToExpand(hWnd);
                    } else {
                        view_changeviewoptions(current_view);
                    }


                    break;


                case IDM_IGNBLANKS:

                    /* if selected, ignore all spaces and tabs on
                     * comparison - expand view only: outline view
                     * will still show that 'text files differ'
                     */

                    ignore_blanks = !ignore_blanks;
                    CheckMenuItem(hMenu, IDM_IGNBLANKS,
                                  ignore_blanks? MF_CHECKED:MF_UNCHECKED);
                    wsprintf(str, szD, ignore_blanks);
                    WriteProfileString(APPNAME, szBlanks, str);

                    /* invalidate all diffs since we have
                     * changed diff options, and re-do and display the
                     * current diff if we are in expand mode.
                     */
                    view_changediffoptions(current_view);

                    /* force repaint of bar window */
                    InvalidateRect(hwndBar, NULL, TRUE);

                    break;

                case IDM_SHOWWHITESPACE:

                        /* if selected, display all spaces and tabs in
                           the expanded text view */
                        show_whitespace = !show_whitespace;
                        CheckMenuItem(hMenu, IDM_SHOWWHITESPACE,
                                show_whitespace ? MF_CHECKED:MF_UNCHECKED);
                        wsprintf(str, szD, show_whitespace);
                        WriteProfileString(APPNAME, szShowWhitespace, str);

                        // change the current view to show only the lines
                        // of the selected type.
                        if (DisplayMode == MODE_EXPAND) {
                                view_changeviewoptions(current_view);
                        }

                        break;

                case IDM_ALG2:

                    /* if selected, do algorithm2 which does not accept
                     * unsafe matches.
                     */

                    Algorithm2 = !Algorithm2;
                    CheckMenuItem(hMenu, IDM_ALG2,
                                  Algorithm2? MF_CHECKED:MF_UNCHECKED);
                    wsprintf(str, szD, Algorithm2);
                    WriteProfileString(APPNAME, szAlgorithm2, str);

                    /* invalidate all diffs since we have
                     * changed diff options, and re-do and display the
                     * current diff if we are in expand mode.
                     */
                    view_changediffoptions(current_view);

                    /* force repaint of bar window */
                    InvalidateRect(hwndBar, NULL, TRUE);

                    break;

                case IDM_MONOCOLS:

                    /* Use monochrome colours - toggle */

                    mono_colours = !mono_colours;
                    CheckMenuItem(hMenu, IDM_MONOCOLS,
                                  mono_colours? MF_CHECKED:MF_UNCHECKED);
                    wsprintf(str, szD, mono_colours);
                    WriteProfileString(APPNAME, szMonoColours, str);
                    if (mono_colours)
                        SetMonoColours();
                    else
                        SetColours();

                    /* The diffs are still valid, but force a re-display
                     * of bar window and main table.
                     */
                    SendMessage(hwndBar, WM_COMMAND, IDM_MONOCOLS, 0);
                    InvalidateRect(hwndBar, NULL, TRUE);
                    view_changeviewoptions(current_view);

                    break;

                case IDM_PICTURE:
                    /* do we show the bar picture in expand mode ? */
                    picture_mode = !picture_mode;
                    CheckMenuItem(hMenu, IDM_PICTURE,
                                  picture_mode? MF_CHECKED:MF_UNCHECKED);
                    wsprintf(str, szD, picture_mode);
                    WriteProfileString(APPNAME, szPicture, str);
                    DoResize(hWnd);
                    break;

                case IDM_HIDEMARK:
                    // toggle state of marked files hidden or not
                    hide_markedfiles = !hide_markedfiles;
                    CheckMenuItem(hMenu, IDM_HIDEMARK,
                                  hide_markedfiles? MF_CHECKED : MF_UNCHECKED);
                    wsprintf(str, szD, hide_markedfiles);
                    WriteProfileString(APPNAME, szHideMark, str);

                    // rebuild view with new global option
                    // - note that marks only affect outline views
                    if (!view_isexpanded(current_view)) {
                        view_changeviewoptions(current_view);
                    }
                    break;

                case IDM_FIND:
                  {
                  int nRet = IDCANCE