 look at this DWORD part if it's
		// non-zero or we've already put chars in our buffer.
		if (dwQwPart || pszCurrent != pszString)
		{
			// <j> is the zero-based index of the low bit of the four-bit
			// range on which we're operating.
			int j;
			DWORD dwMask;

			for (j = BITS_PER_HEX_CHAR * (CCH_HEX_DWORD - 1),
					dwMask = 0xFL << j;
				 j >= 0;
				 j -= BITS_PER_HEX_CHAR,
					dwMask >>= BITS_PER_HEX_CHAR)
			{
				DWORD iDigit = (dwQwPart & dwMask) >> j;

				ASSERT(0xF >= iDigit);

				// We use this test to skip leading zeros
				if (pszCurrent != pszString || iDigit)
				{
					*pszCurrent++ = rgchHexNumMap[iDigit];
				}
			}
		}
	}

	// If the number was zero, we need to set it explicitly
	if (pszCurrent == pszString)
	{
		*pszCurrent++ = '0';
	}

	// Null terminate the string
	*pszCurrent = '\0';

	// Return the number of chars, not counting the null terminator
	return (int)(pszCurrent - pszString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\intlutil.cpp ===
// File: intlutil.cpp

#include <precomp.h>
#include <shlwapi.h>

#include <confreg.h>
#include <regentry.h>
#include <oprahcom.h>

#include "intlutil.h"

static const TCHAR g_szSHLWAPI[] = TEXT("shlwapi.dll");
const LPCSTR c_szMLLoadLibraryA = (LPCSTR)377;
const LPCSTR c_szMLLoadLibraryW = (LPCSTR)378;
const LPCSTR c_szDllGetVersion = "DllGetVersion";
const LPCSTR c_szPathRemoveFileSpecA = "PathRemoveFileSpecA";
const LPCSTR c_szPathRemoveFileSpecW = "PathRemoveFileSpecW";

const DWORD SHLWAPI_MAJOR_VERSION = 5;
const DWORD SHLWAPI_MINOR_VERSION = 0;
const DWORD SHLWAPI_BUILD_NUMBER = 1000;

typedef HINSTANCE (STDAPICALLTYPE * PFN_MLLoadLibraryA)(LPCSTR lpLibFileName, HMODULE hModule, DWORD dwCrossCodePage);
typedef HINSTANCE (STDAPICALLTYPE * PFN_MLLoadLibraryW)(LPCWSTR lpLibFileName, HMODULE hModule, DWORD dwCrossCodePage);
typedef BOOL (STDAPICALLTYPE * PFN_PathRemoveFileSpecA)(LPSTR pszPath);
typedef BOOL (STDAPICALLTYPE * PFN_PathRemoveFileSpecW)(LPWSTR pszPath);

#ifdef UNICODE
#define c_szMLLoadLibrary c_szMLLoadLibraryW
#define PFN_MLLoadLibrary PFN_MLLoadLibraryW
#define c_szPathRemoveFileSpec c_szPathRemoveFileSpecW
#define PFN_PathRemoveFileSpec PFN_PathRemoveFileSpecW
#else
#define c_szMLLoadLibrary c_szMLLoadLibraryA
#define PFN_MLLoadLibrary PFN_MLLoadLibraryA
#define c_szPathRemoveFileSpec c_szPathRemoveFileSpecA
#define PFN_PathRemoveFileSpec PFN_PathRemoveFileSpecA
#endif

BOOL g_fUseMLHelp = FALSE;


inline BOOL CheckShlwapiVersion(HINSTANCE hShlwapiDll)
{
	BOOL fVersionOk = FALSE;

	DLLGETVERSIONPROC pfnDllGetVersion = (DLLGETVERSIONPROC)GetProcAddress(hShlwapiDll, c_szDllGetVersion);
	if(pfnDllGetVersion)
	{
		DLLVERSIONINFO    dvi;
		HRESULT           hr;

		ZeroMemory(&dvi, sizeof(dvi));
		dvi.cbSize = sizeof(dvi);

		hr = (*pfnDllGetVersion)(&dvi);
		if (SUCCEEDED(hr))
		{
			if (dvi.dwMajorVersion > SHLWAPI_MAJOR_VERSION)
			{
				fVersionOk = TRUE;
			}
			else if (dvi.dwMajorVersion == SHLWAPI_MAJOR_VERSION)
			{
				if (dvi.dwMinorVersion > SHLWAPI_MINOR_VERSION)
				{
					fVersionOk = TRUE;
				}
				else if (dvi.dwMinorVersion == SHLWAPI_MINOR_VERSION)
				{
					if (dvi.dwBuildNumber >= SHLWAPI_BUILD_NUMBER)
					{
						fVersionOk = TRUE;
					}
				}
			}
		}
	}
	return fVersionOk;
}



/*  L O A D  N M  R E S  */
/*-------------------------------------------------------------------------
    %%Function: LoadNmRes

    Load the international resource dll.
-------------------------------------------------------------------------*/
HINSTANCE NMINTERNAL LoadNmRes(LPCTSTR pszFile)
{
	HINSTANCE hInst = NULL;

	if (NULL == pszFile)
	{
		// Use the default file name
		pszFile = TEXT("nmres.dll");
	}

	RegEntry reConf(CONFERENCING_KEY, HKEY_LOCAL_MACHINE);
	if (!reConf.GetNumber(REGVAL_DISABLE_PLUGGABLE_UI, 0))
	{
		HINSTANCE hLib = LoadLibrary(g_szSHLWAPI);
		if (hLib)
		{
			if (CheckShlwapiVersion(hLib))
			{
				PFN_MLLoadLibrary pfnMLLoadLibrary =
						(PFN_MLLoadLibrary)GetProcAddress(hLib, c_szMLLoadLibrary);
				PFN_PathRemoveFileSpec pfnPathRemoveFileSpec =
						(PFN_PathRemoveFileSpec)GetProcAddress(hLib, c_szPathRemoveFileSpec);
				if ((NULL != pfnMLLoadLibrary) && (NULL != pfnPathRemoveFileSpec))
				{
					hInst = pfnMLLoadLibrary(pszFile, GetModuleHandle(NULL), 0);
					if (hInst)
					{
						// check to see if the Resource DLL was loaded from the ML Satellite
						// if not, don't use ML for Help

						TCHAR szThis[MAX_PATH];
						TCHAR szResource[MAX_PATH];

						if (GetModuleFileName(NULL, szThis, CCHMAX(szThis)) &&
							pfnPathRemoveFileSpec(szThis) &&
							GetModuleFileName(hInst, szResource, CCHMAX(szThis)) &&
							pfnPathRemoveFileSpec(szResource) &&
							(0 != lstrcmp(szThis, szResource)) )
						{
							g_fUseMLHelp = TRUE;
						}
					}
				}
			}
		}
	}

	if (!hInst)
	{
		TCHAR szDll[MAX_PATH];

		if (GetInstallDirectory(szDll))
		{
			if ((lstrlen(pszFile) + lstrlen(szDll)) < CCHMAX(szDll))
			{
				lstrcat(szDll, pszFile);
				//  It would be best to load the dll as a resource, unfortunately
				//  CreateWindow and PropertySheet code fails unless this is a
				//  real, active module handle
				//
				//	hInst = LoadLibraryEx(szDll, NULL, LOAD_LIBRARY_AS_DATAFILE);
				//
				hInst = LoadLibrary(szDll);

				if (NULL == hInst)
				{
					ERROR_OUT(("Unable to load resource file [%s]", szDll));
				}
			}
		}
	}

	return hInst;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\genwindow.cpp ===
// File: GenWindow.cpp

#include "precomp.h"

#include "GenWindow.h"
#include "GenContainers.h"

#include <windowsx.h>

// We need a different tooltip window for each top level window, or the tooltip
// will get hidden behind the window
struct TT_TopWindow
{
	HWND hwndTop;
	HWND hwndTooltip;
} ;

class CTopWindowArray
{
private:
	enum { InitSize = 4 } ;

	TT_TopWindow *m_pArray;
	UINT m_nArrayLen;

	int FindIndex(HWND hwndTop)
	{
		if (NULL == m_pArray)
		{
			return(-1);
		}

		// Just a linear search
		int i;
		for (i=m_nArrayLen-1; i>=0; --i)
		{
			if (m_pArray[i].hwndTop == hwndTop)
			{
				break;
			}
		}

		return(i);
	}

public:
	CTopWindowArray() :
		m_pArray(NULL)
	{
	}

	~CTopWindowArray()
	{
		delete[] m_pArray;
	}

	static HWND GetTopFrame(HWND hwnd)
	{
		HWND hwndParent;
		while (NULL != (hwndParent = GetParent(hwnd)))
		{
			hwnd = hwndParent;
		}

		return(hwnd);
	}

	void GrowArray()
	{
		if (NULL == m_pArray)
		{
			m_nArrayLen = InitSize;
			m_pArray = new TT_TopWindow[m_nArrayLen];
			ZeroMemory(m_pArray, m_nArrayLen*sizeof(TT_TopWindow));
			return;
		}

		// Grow exponentially
		TT_TopWindow *pArray = new TT_TopWindow[m_nArrayLen*2];
		if (NULL == pArray)
		{
			// very bad
			return;
		}

		CopyMemory(pArray, m_pArray, m_nArrayLen*sizeof(TT_TopWindow));
		ZeroMemory(pArray+m_nArrayLen, m_nArrayLen*sizeof(TT_TopWindow));

		delete[] m_pArray;
		m_pArray = pArray;
		m_nArrayLen *= 2;
	}

	void Add(HWND hwndTop, HWND hwndTooltip)
	{
		hwndTop = GetTopFrame(hwndTop);

		// I'm going to allow multiple adds of the same thing, but then you
		// must have the corresponding number of removes

		int i = FindIndex(NULL);
		if (i < 0)
		{
			GrowArray();
			i = FindIndex(NULL);

			if (i < 0)
			{
				// Very bad
				return;
			}
		}

		m_pArray[i].hwndTop = hwndTop;
		m_pArray[i].hwndTooltip = hwndTooltip;
	}

	void Remove(HWND hwndTop)
	{
		hwndTop = GetTopFrame(hwndTop);

		int i = FindIndex(hwndTop);
		if (i >= 0)
		{
			// LAZYLAZY  georgep: I'm never going to shrink the array
			m_pArray[i].hwndTop = NULL;
			m_pArray[i].hwndTooltip = NULL;
		}
	}

	HWND Find(HWND hwndTop)
	{
		hwndTop = GetTopFrame(hwndTop);

		int i = FindIndex(hwndTop);
		if (i >= 0)
		{
			return(m_pArray[i].hwndTooltip);
		}
		return(NULL);
	}

	int GetCount()
	{
		if (NULL == m_pArray)
		{
			return(0);
		}

		int c = 0;
		for (int i=m_nArrayLen-1; i>=0; --i)
		{
			if (NULL != m_pArray[i].hwndTop)
			{
				++c;
			}
		}

		return(c);
	}
} ;

static inline BOOL TT_AddToolInfo(HWND hwnd, TOOLINFO *pti)
{
	return (BOOL)(SendMessage(hwnd, TTM_ADDTOOL, 0, reinterpret_cast<LPARAM>(pti)) != 0);
}

static inline void TT_DelToolInfo(HWND hwnd, TOOLINFO *pti)
{
	SendMessage(hwnd, TTM_DELTOOL, 0, reinterpret_cast<LPARAM>(pti));
}

static inline BOOL TT_GetToolInfo(HWND hwnd, TOOLINFO *pti)
{
	return (BOOL)(SendMessage(hwnd, TTM_GETTOOLINFO, 0, reinterpret_cast<LPARAM>(pti)) != 0);
}

static inline void TT_SetToolInfo(HWND hwnd, TOOLINFO *pti)
{
	SendMessage(hwnd, TTM_SETTOOLINFO, 0, reinterpret_cast<LPARAM>(pti));
}

static inline int TT_GetToolCount(HWND hwnd)
{
	return (int)(SendMessage(hwnd, TTM_GETTOOLCOUNT, 0, 0));
}

CGenWindow *CGenWindow::g_pCurHot = NULL;

const DWORD IGenWindow::c_msgFromHandle = RegisterWindowMessage(_TEXT("NetMeeting::FromHandle"));

IGenWindow *IGenWindow::FromHandle(HWND hwnd)
{
	return(reinterpret_cast<IGenWindow*>(SendMessage(hwnd, c_msgFromHandle, 0, 0)));
}

// HACKHACK georgep: Need to make this larger than the largest DM_ message
enum
{
	GWM_LAYOUT = WM_USER + 111,
	GWM_CUSTOM,
} ;

CGenWindow::CGenWindow()
: m_hwnd(NULL), m_lUserData(0)
{
	// Init the ref count to 1
	REFCOUNT::AddRef();
	// This marks this object for deletion when the ref count goes to 0.
	REFCOUNT::Delete();
}

CGenWindow::~CGenWindow()
{
	// I don't think the HWND can still exist, since the window proc does an AddRef
	ASSERT(!m_hwnd);
}

HRESULT STDMETHODCALLTYPE CGenWindow::QueryInterface(REFGUID riid, LPVOID *ppv)
{
	HRESULT hr = S_OK;

	if ((__uuidof(IGenWindow) == riid) || (IID_IUnknown == riid))
	{
		*ppv = dynamic_cast<IGenWindow *>(this);
	}
	else if (__uuidof(CGenWindow) == riid)
	{
		*ppv = this;
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}

BOOL CGenWindow::Create(
	HWND hWndParent,		// Window parent
	LPCTSTR szWindowName,	// Window name
	DWORD dwStyle,			// Window style
	DWORD dwEXStyle,		// Extended window style
	int x,					// Window pos: x
	int y,					// Window pos: y
	int nWidth,				// Window size: width
	int nHeight,			// Window size: height
	HINSTANCE hInst,		// The hInstance to create the window on
	HMENU hmMain,			// Window menu
	LPCTSTR szClassName		// The class name to use
	)
{
	if (NULL != m_hwnd)
	{
		// Alread created
		return(FALSE);
	}

	if (NULL == szClassName)
	{
		szClassName = TEXT("NMGenWindowClass");
	}

	if (!InitWindowClass(szClassName, hInst))
	{
		// Couldn't init the window class
		return(FALSE);
	}

	BOOL ret = (NULL != CreateWindowEx(dwEXStyle, szClassName, szWindowName, dwStyle,
		x, y, nWidth, nHeight, hWndParent, hmMain,
		hInst, (LPVOID)this));

#ifdef DEBUG
	if (!ret)
	{
		GetLastError();
	}
#endif // DEBUG

	return(ret);
}

BOOL CGenWindow::Create(
	HWND hWndParent,		// Window parent
	INT_PTR nId,				// ID of the child window
	LPCTSTR szWindowName,	// Window name
	DWORD dwStyle,			// Window style; WS_CHILD|WS_VISIBLE will be added to this
	DWORD dwEXStyle			// Extended window style
	)
{
	ASSERT(NULL != hWndParent);

	// Child windows should default to visible
	return(Create(
		hWndParent,		// Window parent
		szWindowName,	// Window name
		dwStyle|WS_CHILD|WS_VISIBLE,			// Window style
		dwEXStyle,		// Extended window style
		0,					// Window pos: x
		0,					// Window pos: y
		10,				// Window size: width
		10,			// Window size: height
		reinterpret_cast<HINSTANCE>(GetWindowLongPtr(hWndParent, GWLP_HINSTANCE)),
		reinterpret_cast<HMENU>(nId)			// Window menu
	));
}

BOOL CGenWindow::InitWindowClass(LPCTSTR szClassName, HINSTANCE hThis)
{
	WNDCLASS wc;

	// See if the class is already registered
	if (GetClassInfo(hThis, szClassName, &wc))
	{
		ASSERT(RealWindowProc == wc.lpfnWndProc);

		// Already registered
		return(TRUE);
	}

	// If not, attempt to register it
	wc.cbClsExtra = 0;
	wc.cbWndExtra = 0;
	// BUGBUG georgep: Hard-coding the background color for now
	// wc.hbrBackground = (HBRUSH) (COLOR_BTNFACE + 1);
	// wc.hbrBackground = CreateSolidBrush(RGB(0xA9, 0xA9, 0xA9));
	wc.hbrBackground = NULL;
	wc.hCursor = LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW));
	wc.hIcon = NULL;
	wc.hInstance = hThis;
	wc.lpfnWndProc = RealWindowProc;
	wc.lpszClassName = szClassName;
	wc.lpszMenuName = NULL;
	wc.style = CS_DBLCLKS;

	return(RegisterClass(&wc));
}

LRESULT CALLBACK CGenWindow::RealWindowProc(
	HWND hWnd,
	UINT message,
	WPARAM wParam,
	LPARAM lParam
	)
{
	// Handle the WM_CREATE message
	if (WM_NCCREATE == message)
	{
		HANDLE_WM_NCCREATE(hWnd, wParam, lParam, OnNCCreate);
	}

	// Get the "this" pointer and call the ProcessMessage virtual method
	LRESULT ret = 0;
	CGenWindow* pWnd = reinterpret_cast<CGenWindow*>(GetWindowLongPtr(hWnd, GWLP_USERDATA));

	// 'pWnd' won't be valid for any messages that come before WM_NCCREATE or after WM_NCDESTROY
	if(NULL != pWnd)
	{
		// Messages after WM_NCCREATE:
		ret = pWnd->ProcessMessage(hWnd, message, wParam, lParam);
	}
	else
	{
		// Messages before WM_CREATE:
		ret = DefWindowProc(hWnd, message, wParam, lParam);
	}

	// Clean up on WM_NCDESTROY
	if (WM_NCDESTROY == message && NULL != pWnd)
	{
		SetWindowLongPtr(hWnd, GWLP_USERDATA, 0);
		pWnd->m_hwnd = NULL;

		pWnd->OnMouseLeave();
		pWnd->Release();
	}

	return(ret);
}

void CGenWindow::OnShowWindow(HWND hwnd, BOOL fShow, int fnStatus)
{
	OnDesiredSizeChanged();
}

LRESULT CGenWindow::ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		HANDLE_MSG(hwnd, WM_SIZE      , OnSize);
		HANDLE_MSG(hwnd, WM_ERASEBKGND, OnEraseBkgnd);
		HANDLE_MSG(hwnd, WM_MOUSEMOVE , OnMouseMove);
		HANDLE_MSG(hwnd, WM_SHOWWINDOW, OnShowWindow);

	case WM_MOUSELEAVE:
		OnMouseLeave();
		break;

	case GWM_LAYOUT:
		Layout();
		break;

	case GWM_CUSTOM:
		reinterpret_cast<InvokeProc>(lParam)(this, wParam);
		break;

	case WM_DESTROY:
		RemoveTooltip();
		break;

	default:
		if (c_msgFromHandle == message)
		{
			// Return the IGenWindow* for this object, as specified by the
			// IGenWindow interface
			return(reinterpret_cast<LRESULT>(dynamic_cast<IGenWindow*>(this)));
		}
	}

	return(DefWindowProc(hwnd, message, wParam, lParam));
}

void CGenWindow::ScheduleLayout()
{
	HWND hwnd = GetWindow();

	MSG msg;
	// I don't know why we are getting messages for windows other than our own,
	// but it seems to happen for top level windows
	if (PeekMessage(&msg, hwnd, GWM_LAYOUT, GWM_LAYOUT, PM_NOREMOVE|PM_NOYIELD)
		&& (msg.hwnd == hwnd))
	{
		// Message already posted
		return;
	}

	if (!PostMessage(hwnd, GWM_LAYOUT, 0, 0))
	{
		Layout();
	}
}

BOOL CGenWindow::AsyncInvoke(InvokeProc proc, WPARAM wParam)
{
	return(!PostMessage(GetWindow(), GWM_CUSTOM, wParam, reinterpret_cast<LPARAM>(proc)));
}

void CGenWindow::OnSize(HWND hwnd, UINT state, int cx, int cy)
{
	// Call the virtual Layout, and then forward to DefWindowProc
	ScheduleLayout();

	// Update the Tooltip info
	TOOLINFO ti;
	TCHAR szTip[MAX_PATH];
	BOOL bExist = InitToolInfo(&ti, szTip);
	if (bExist)
	{
		GetClientRect(hwnd, &ti.rect);

		HWND hwndTooltip = g_pTopArray->Find(hwnd);
		TT_SetToolInfo(hwndTooltip, &ti);
	}

	FORWARD_WM_SIZE(hwnd, state, cx, cy, DefWindowProc);
}

BOOL CGenWindow::OnEraseBkgnd(HWND hwnd, HDC hdc)
{
	HBRUSH hErase = GetBackgroundBrush();
	if (NULL == hErase)
	{
		return(FORWARD_WM_ERASEBKGND(hwnd, hdc, DefWindowProc));
	}

	HPALETTE hOldPal = NULL;
	HPALETTE hPal = GetPalette();
	if (NULL != hPal)
	{
		hOldPal = SelectPalette(hdc, hPal, TRUE);
		RealizePalette(hdc);
	}

	RECT rc;
	GetClientRect(hwnd, &rc);

	HBRUSH hOld = (HBRUSH)SelectObject(hdc, hErase);
	PatBlt(hdc, 0, 0, rc.right, rc.bottom, PATCOPY);
	SelectObject(hdc, hOld);

	if (NULL != hOldPal)
	{
		SelectPalette(hdc, hOldPal, TRUE);
	}

	return(TRUE);
}

void CGenWindow::OnMouseLeave()
{
	if (dynamic_cast<IGenWindow*>(this) == g_pCurHot)
	{
		SetHotControl(NULL);
	}
}

void CGenWindow::OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags)
{
	SetHotControl(this);
	FORWARD_WM_MOUSEMOVE(hwnd, x, y, keyFlags, DefWindowProc);
}

// REVIEW georgep: Should this loop until it gets an IGenWindow?
HBRUSH CGenWindow::GetBackgroundBrush()
{
	HWND parent = GetParent(GetWindow());
	if (NULL == parent)
	{
		return(GetStandardBrush());
	}

	IGenWindow *pParent = FromHandle(parent);
	if (pParent == NULL)
	{
		return(GetStandardBrush());
	}
	return(pParent->GetBackgroundBrush());
}

// REVIEW georgep: Should this loop until it gets an IGenWindow?
HPALETTE CGenWindow::GetPalette()
{
	HWND parent = GetParent(GetWindow());
	if (NULL == parent)
	{
		return(GetStandardPalette());
	}

	IGenWindow *pParent = FromHandle(parent);
	if (pParent == NULL)
	{
		return(GetStandardPalette());
	}
	return(pParent->GetPalette());
}

BOOL CGenWindow::OnNCCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
{
	// Store away the "this" pointer ahnd save off the window handle
	CGenWindow* pWnd = NULL;
	
	pWnd = (CGenWindow*) lpCreateStruct->lpCreateParams;
	ASSERT(pWnd);

	SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) pWnd);
	pWnd->AddRef();

	TRACE_OUT(("CGenWindow::OnNCCreate"));

	ASSERT(NULL == pWnd->m_hwnd);
	pWnd->m_hwnd = hwnd;

	return(TRUE);
}

void CGenWindow::GetDesiredSize(SIZE *ppt)
{
	HWND hwnd = GetWindow();

	RECT rcTemp = { 0, 0, 0, 0 };
	AdjustWindowRectEx(&rcTemp, GetWindowLong(hwnd, GWL_STYLE), FALSE,
		GetWindowLong(hwnd, GWL_EXSTYLE));

	ppt->cx = rcTemp.right  - rcTemp.left;
	ppt->cy = rcTemp.bottom - rcTemp.top;
}

void CGenWindow::OnDesiredSizeChanged()
{
	HWND parent = GetParent(GetWindow());
	if (NULL != parent)
	{
		IGenWindow *pParent = FromHandle(parent);
		if (NULL != pParent)
		{
			pParent->OnDesiredSizeChanged();
		}
	}

	// Do this after telling the parents about the change, so their layouts
	// will happen before this one
	ScheduleLayout();
}

class GWTrackMouseLeave
{
private:
	enum { DefIdTimer = 100 };
	enum { DefTimeout = 500 };

	static HWND m_hwnd;
	static UINT_PTR m_idTimer;
	static DWORD m_dwWhere;

	static void CALLBACK OnTimer(HWND hwnd, UINT uMsg, UINT_PTR idTimer, DWORD dwTime)
	{
		RECT rc;
		GetWindowRect(m_hwnd, &rc);

		DWORD dwPos = GetMessagePos();

		// If the mouse has not moved since this timer started, then leave it hot
		// This allows a reasonable keyboard-only interface
		if (m_dwWhere == dwPos)
		{
			return;
		}

		POINT ptPos = { GET_X_LPARAM(dwPos), GET_Y_LPARAM(dwPos) };

		if (!PtInRect(&rc, ptPos))
		{
			PostMessage(m_hwnd, WM_MOUSELEAVE, 0, 0);
		}
	}

public:
	GWTrackMouseLeave() {}

	static void Track(HWND hwnd, BOOL bTrack)
	{
		if (!bTrack)
		{
			if (NULL != m_hwnd && hwnd == m_hwnd)
			{
				KillTimer(NULL, m_idTimer);
				m_hwnd = NULL;
			}

			return;
		}

		// Stop any previous tracking
		Track(m_hwnd, FALSE);

		m_hwnd = hwnd;
		m_dwWhere = GetMessagePos();
		m_idTimer = SetTimer(NULL, DefIdTimer, DefTimeout, OnTimer);
	}
} ;

HWND GWTrackMouseLeave::m_hwnd = NULL;
DWORD GWTrackMouseLeave::m_dwWhere = 0;
UINT_PTR GWTrackMouseLeave::m_idTimer;

static void GWTrackMouseEvent(HWND hwnd, BOOL bTrack)
{
	// I need to set up a timer to handle this
	GWTrackMouseLeave::Track(hwnd, bTrack);
}

// Set the global Hot control
void CGenWindow::SetHotControl(CGenWindow *pHot)
{
	CGenWindow *pGenWindow = NULL;

	if (NULL != pHot)
	{
		for (HWND hwndHot=pHot->GetWindow(); ; hwndHot=GetParent(hwndHot))
		{
			if (NULL == hwndHot)
			{
				break;
			}

			IGenWindow *pWindow = FromHandle(hwndHot);
			if (NULL == pWindow)
			{
				continue;
			}

			if (SUCCEEDED(pWindow->QueryInterface(__uuidof(CGenWindow),
				reinterpret_cast<LPVOID*>(&pGenWindow)))
				&& NULL != pGenWindow)
			{
				pGenWindow->SetHot(TRUE);

				// Not all windows may care about the hot state
				BOOL bIsHot = pGenWindow->IsHot();
				pGenWindow->Release();

				if (bIsHot)
				{
					break;
				}
			}

			pGenWindow = NULL;
		}
	}

	if (g_pCurHot != pGenWindow)
	{
		if (NULL != g_pCurHot)
		{
			g_pCurHot->SetHot(FALSE);
			GWTrackMouseEvent(g_pCurHot->GetWindow(), FALSE);

			ULONG uRef = g_pCurHot->Release();
		}

		g_pCurHot = pGenWindow;
		if (NULL!= g_pCurHot)
		{
			ULONG uRef = g_pCurHot->AddRef();

			// Now we need to track the mouse leaving
			GWTrackMouseEvent(g_pCurHot->GetWindow(), TRUE);
		}
	}
}

// Set this control to be hot
void CGenWindow::SetHot(BOOL bHot)
{
}

// Is this control currently hot
BOOL CGenWindow::IsHot()
{
	return(FALSE);
}

LPARAM CGenWindow::GetUserData()
{
	return(m_lUserData);
}

HPALETTE CGenWindow::g_hPal = NULL;
BOOL     CGenWindow::g_bNeedPalette = TRUE;
HBRUSH   CGenWindow::g_hBrush = NULL;
CTopWindowArray *CGenWindow::g_pTopArray = NULL;

// Not particularly robust: we give out our internal palette and trust everybody
// not to delete it
HPALETTE CGenWindow::GetStandardPalette()
{
	#include "indeopal.h"

	if (!g_bNeedPalette || NULL != g_hPal)
	{
		return(g_hPal);
	}

	HDC hDC = ::GetDC(NULL);
	if (NULL != hDC)
	{
		// Use the Indeo palette
		// Check out the video mode. We only care about 8 bit mode.
		if (8 == ::GetDeviceCaps(hDC, BITSPIXEL) * ::GetDeviceCaps(hDC, PLANES))
		{
#ifndef HALFTONE_PALETTE
			LOGPALETTE_NM gIndeoPalette = gcLogPaletteIndeo;
			if (SYSPAL_NOSTATIC != ::GetSystemPaletteUse(hDC))
			{
				// Preserve the static colors
				int nStaticColors = ::GetDeviceCaps(hDC, NUMCOLORS) >> 1;

				if (nStaticColors <= 128)
				{
					// Get the 10 first entries
					::GetSystemPaletteEntries(      hDC,
												0,
												nStaticColors,
												&gIndeoPalette.aEntries[0]);

					// Get the 10 last entries
					::GetSystemPaletteEntries(      hDC,
												256 - nStaticColors,
												nStaticColors,
												&gIndeoPalette.aEntries[256 - nStaticColors]);

					// Hammer the peFlags
					for (; --nStaticColors + 1;)
					{
						gIndeoPalette.aEntries[nStaticColors].peFlags = 0;
						gIndeoPalette.aEntries[255 - nStaticColors].peFlags = 0;
					}
				}
			}

			// Build a palette
			g_hPal = ::CreatePalette((LOGPALETTE *)&gIndeoPalette);

#else  // HALFTONE_PALETTE
			g_hPal = ::CreateHalftonePalette(hDC);
#endif // HALFTONE_PALETTE
		}
		::ReleaseDC(NULL, hDC);
	}

	g_bNeedPalette = (NULL != g_hPal);
	return(g_hPal);
}

void CGenWindow::DeleteStandardPalette()
{
	if (NULL != g_hPal)
	{
		DeleteObject(g_hPal);
		g_hPal = NULL;
	}
}

// Get the standard palette for drawing
HBRUSH CGenWindow::GetStandardBrush()
{
	return(GetSysColorBrush(COLOR_3DFACE));
}

// Delete the standard palette for drawing
void CGenWindow::DeleteStandardBrush()
{
}

// Returns TRUE if the TT exists
BOOL CGenWindow::InitToolInfo(TOOLINFO *pti, LPTSTR pszText)
{
	TCHAR szText[MAX_PATH];
	if (NULL == pszText)
	{
		pszText = szText;
	}

	HWND hwnd = GetWindow();
	HWND hwndTooltip = NULL == g_pTopArray ? NULL : g_pTopArray->Find(hwnd);

	TOOLINFO &ti = *pti;

	ti.cbSize = sizeof(TOOLINFO);
	ti.hwnd = hwnd;
	ti.hinst = GetWindowInstance(hwnd);
	ti.lpszText = pszText;

	GetClientRect(hwnd, &ti.rect);

	ti.uId = reinterpret_cast<UINT_PTR>(hwnd);
	ti.uFlags = TTF_SUBCLASS;

	GetSharedTooltipInfo(&ti);

	// HACKHACK georgep: The flags keep getting messed up by the tooltip window
	UINT uFlags = ti.uFlags;

	BOOL bExist = NULL == hwndTooltip ? FALSE : TT_GetToolInfo(hwndTooltip, &ti);

	ti.uFlags = uFlags;
	if (ti.lpszText == szText)
	{
		ti.lpszText = NULL;
	}

	return(bExist);
}

// Set the tooltip for this window
void CGenWindow::SetTooltip(LPCTSTR pszTip)
{
	HWND hwnd = GetWindow();

	if (NULL == g_pTopArray)
	{
		g_pTopArray = new CTopWindowArray;
		if (NULL == g_pTopArray)
		{
			return;
		}
	}

	HWND hwndTop = CTopWindowArray::GetTopFrame(hwnd);
	HWND hwndTooltip = g_pTopArray->Find(hwndTop);

	if (NULL == hwndTooltip)
	{
		hwndTooltip = CreateWindowEx(0,
											TOOLTIPS_CLASS,
											NULL,
											0, // styles
											CW_USEDEFAULT,
											CW_USEDEFAULT,
											CW_USEDEFAULT,
											CW_USEDEFAULT,
											hwndTop,
											(HMENU) NULL,
											GetWindowInstance(hwnd),
											NULL);
		if (NULL == hwndTooltip)
		{
			// Couldn't create the tooltip window
			return;
		}

		g_pTopArray->Add(hwndTop, hwndTooltip);
	}

	TOOLINFO ti;
	BOOL bExist = InitToolInfo(&ti);

	ti.lpszText = const_cast<LPTSTR>(pszTip);

	if (bExist)
	{
		TT_SetToolInfo(hwndTooltip, &ti);
	}
	else
	{
		TT_AddToolInfo(hwndTooltip, &ti);
	}
}

// Remove the tooltip for this window
void CGenWindow::RemoveTooltip()
{
	if  (NULL == g_pTopArray)
	{
		// Nothing to do
		return;
	}

	HWND hwndTop = CTopWindowArray::GetTopFrame(GetWindow());
	HWND hwndTooltip = g_pTopArray->Find(hwndTop);

	BOOL bIsWindow = NULL != hwndTooltip && IsWindow(hwndTooltip);

	TOOLINFO ti;
	BOOL bExist = bIsWindow && InitToolInfo(&ti);

	if (bExist)
	{
		TT_DelToolInfo(hwndTooltip, &ti);
	}

	if (NULL != hwndTooltip && (!bIsWindow || 0 == TT_GetToolCount(hwndTooltip)))
	{
		if (bIsWindow)
		{
			DestroyWindow(hwndTooltip);
		}
		g_pTopArray->Remove(hwndTop);

		if (0 == g_pTopArray->GetCount())
		{
			delete g_pTopArray;
			g_pTopArray = NULL;
		}
	}
}

// Get the info necessary for displaying a tooltip
void CGenWindow::GetSharedTooltipInfo(TOOLINFO *pti)
{
}

// Just makes the first child fill the client area
void CFillWindow::Layout()
{
	HWND child = GetChild();
	if (NULL != child)
	{
		RECT rc;
		GetClientRect(GetWindow(), &rc);
		SetWindowPos(child, NULL, 0, 0, rc.right, rc.bottom, SWP_NOZORDER);
	}
}

void CFillWindow::GetDesiredSize(SIZE *psize)
{
	CGenWindow::GetDesiredSize(psize);
	HWND child = GetChild();

	if (NULL != child)
	{
		IGenWindow *pChild = FromHandle(child);
		if (NULL != pChild)
		{
			SIZE sizeTemp;
			pChild->GetDesiredSize(&sizeTemp);
			psize->cx += sizeTemp.cx;
			psize->cy += sizeTemp.cy;
		}
	}
}

// Get the info necessary for displaying a tooltip
void CFillWindow::GetSharedTooltipInfo(TOOLINFO *pti)
{
	CGenWindow::GetSharedTooltipInfo(pti);

	// Since the child covers this whole area, we need to change the HWND to
	// hook
	pti->hwnd = GetChild();
}

CEdgedWindow::CEdgedWindow() :
	m_hMargin(0),
	m_vMargin(0),
	m_pHeader(NULL)
{
}

CEdgedWindow::~CEdgedWindow()
{
	SetHeader(NULL);
}

BOOL CEdgedWindow::Create(HWND hwndParent)
{
	return(CGenWindow::Create(
		hwndParent,		// Window parent
		0,				// ID of the child window
		TEXT("NMEdgedWindow"),	// Window name
		WS_CLIPCHILDREN,			// Window style; WS_CHILD|WS_VISIBLE will be added to this
		WS_EX_CONTROLPARENT		// Extended window style
	));
}

HWND CEdgedWindow::GetContentWindow()
{
	// If we are hosting an IGenWindow, add on its desired size
	HWND child = GetFirstChild(GetWindow());
	if (NULL == child)
	{
		return(NULL);
	}
	if (NULL != m_pHeader && child == m_pHeader->GetWindow())
	{
		child = ::GetWindow(child, GW_HWNDNEXT);
	}

	return(child);
}

static const int LeftIndent = 20;

// Just makes the first child fill the client area - the border
void CEdgedWindow::Layout()
{
	int nBorder = GetBorderWidth();

	int hBorder = m_hMargin + nBorder;
	int vBorder = m_vMargin + nBorder;

	HWND hwnd = GetWindow();
	RECT rc;
	GetClientRect(hwnd, &rc);

	CGenWindow *pHeader = GetHeader();
	if (NULL != pHeader)
	{
		SIZE sizeTemp;
		pHeader->GetDesiredSize(&sizeTemp);

		SetWindowPos(pHeader->GetWindow(), NULL, rc.left+LeftIndent, rc.top,
			sizeTemp.cx, sizeTemp.cy, SWP_NOZORDER|SWP_NOACTIVATE);

		rc.top += sizeTemp.cy;
	}

	HWND child = GetContentWindow();
	if (NULL != child)
	{
		SetWindowPos(child, NULL, rc.left+hBorder, rc.top+vBorder,
			rc.right-rc.left-2*hBorder, rc.bottom-rc.top-2*vBorder, SWP_NOZORDER|SWP_NOACTIVATE);
	}
}

void CEdgedWindow::GetDesiredSize(SIZE *psize)
{
	int nBorder = GetBorderWidth();

	int hBorder = m_hMargin + nBorder;
	int vBorder = m_vMargin + nBorder;

	CGenWindow::GetDesiredSize(psize);
	psize->cx += 2*hBorder;
	psize->cy += 2*vBorder;

	// If we are hosting an IGenWindow, add on its desired size
	HWND child = GetContentWindow();
	if (NULL == child)
	{
		return;
	}
	IGenWindow *pChild = FromHandle(child);
	if (NULL == pChild)
	{
		return;
	}

	SIZE size;
	pChild->GetDesiredSize(&size);
	psize->cx += size.cx;
	psize->cy += size.cy;

	CGenWindow *pHeader = GetHeader();
	if (NULL != pHeader)
	{
		SIZE sizeTemp;
		pHeader->GetDesiredSize(&sizeTemp);
		psize->cy += sizeTemp.cy;
		psize->cx = max(psize->cx, sizeTemp.cx+LeftIndent+hBorder);
	}
}

void CEdgedWindow::OnPaint(HWND hwnd)
{
	PAINTSTRUCT ps;
	HDC hdc = BeginPaint(hwnd, &ps);

	RECT rc;
	GetClientRect(hwnd, &rc);

	CGenWindow *pHeader = GetHeader();
	if (NULL != pHeader)
	{
		SIZE sizeTemp;
		pHeader->GetDesiredSize(&sizeTemp);

		// Make the etch go through the middle of the header
		rc.top += (sizeTemp.cy-GetBorderWidth()) / 2;
	}

	DrawEdge(hdc, &rc, EDGE_ETCHED, BF_RECT);

	EndPaint(hwnd, &ps);
}

LRESULT CEdgedWindow::ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		HANDLE_MSG(hwnd, WM_PAINT, OnPaint);

	case WM_DESTROY:
		SetHeader(NULL);
		break;

	case WM_SIZE:
		// Need to invalidate if we bacame larger to redraw the border in the
		// right place
		InvalidateRect(hwnd, NULL, TRUE);
		break;
	}

	return(CGenWindow::ProcessMessage(hwnd, message, wParam, lParam));
}

void CEdgedWindow::SetHeader(CGenWindow *pHeader)
{
	if (NULL != m_pHeader)
	{
		m_pHeader->Release();
	}

	m_pHeader = pHeader;
	if (NULL != m_pHeader)
	{
		m_pHeader->AddRef();
	}
}

BOOL CFrame::Create(
	HWND hWndOwner,			// Window owner
	LPCTSTR szWindowName,	// Window name
	DWORD dwStyle,			// Window style
	DWORD dwEXStyle,		// Extended window style
	int x,					// Window pos: x
	int y,					// Window pos: y
	int nWidth,				// Window size: width
	int nHeight,			// Window size: height
	HINSTANCE hInst,		// The hInstance to create the window on
	HICON hIcon,		// The icon for the window
	HMENU hmMain,		// Window menu
	LPCTSTR szClassName	// The class name to use
	)
{
	if (!CFillWindow::Create(hWndOwner, szWindowName, dwStyle, dwEXStyle,
		x, y, nWidth, nHeight, hInst, hmMain, szClassName))
	{
		return(FALSE);
	}

	if (NULL != hIcon)
	{
		SendMessage(GetWindow(), WM_SETICON, ICON_BIG, reinterpret_cast<LPARAM>(hIcon));
	}

	return(TRUE);
}

void CFrame::Resize()
{
	Resize(this, 0);
}

void CFrame::Resize(CGenWindow *pThis, WPARAM wParam)
{
	SIZE size;
	pThis->GetDesiredSize(&size);
	SetWindowPos(pThis->GetWindow(), NULL, 0, 0, size.cx, size.cy,
		SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);
}

void CFrame::OnDesiredSizeChanged()
{
	// I should probably look at the window style and only do this if it is
	// not resizable. But then that would be wrong sometimes too, so just
	// override this if you want different behavior.
	AsyncInvoke(Resize, 0);
}

LRESULT CFrame::ProcessMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
		HANDLE_MSG(hwnd, WM_PALETTECHANGED , OnPaletteChanged);
		HANDLE_MSG(hwnd, WM_QUERYNEWPALETTE, OnQueryNewPalette);
	}

	return(CFillWindow::ProcessMessage(hwnd, uMsg, wParam, lParam));
}

void CFrame::OnPaletteChanged(HWND hwnd, HWND hwndPaletteChange)
{
	SelAndRealizePalette(TRUE);
	::RedrawWindow(GetWindow(), NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN);
}

BOOL CFrame::SelAndRealizePalette(BOOL bBackground)
{
	BOOL bRet = FALSE;

	HPALETTE hPal = GetPalette();
	if (NULL == hPal)
	{
		return(bRet);
	}

	HWND hwnd = GetWindow();

	HDC hdc = ::GetDC(hwnd);
	if (NULL != hdc)
	{
		::SelectPalette(hdc, hPal, bBackground);
		bRet = (GDI_ERROR != ::RealizePalette(hdc));

		::ReleaseDC(hwnd, hdc);
	}

	return bRet;
}

BOOL CFrame::OnQueryNewPalette(HWND hwnd)
{
	return(SelAndRealizePalette(FALSE));
}

BOOL CFrame::SetForeground()
{
	BOOL bRet = FALSE;

	HWND hwnd = GetWindow();

	if (NULL != hwnd)
	{
		WINDOWPLACEMENT wp;
		wp.length = sizeof(wp);

		if (::GetWindowPlacement(hwnd, &wp) &&
			((SW_MINIMIZE == wp.showCmd) || (SW_SHOWMINIMIZED == wp.showCmd)))
		{
			// The window is minimized - restore it:
			::ShowWindow(hwnd, SW_RESTORE);
		}
		else
		{
			::ShowWindow(hwnd, SW_SHOW);
		}

		// Bring it to the foreground
		SetForegroundWindow(hwnd);
		bRet = TRUE;
	}

	return bRet;
}

void CFrame::MoveEnsureVisible(int x, int y)
{
	static const int MinVis = 16;

	RECT rcThis;
	GetWindowRect(GetWindow(), &rcThis);
	// Change to width and height
	rcThis.right -= rcThis.left;
	rcThis.bottom -= rcThis.top;

	RECT rcDesktop;
	SystemParametersInfo(SPI_GETWORKAREA, 0, &rcDesktop, 0);

	if ((x+rcThis.right < rcDesktop.left+MinVis) || (x > rcDesktop.right-MinVis))
	{
		x = (rcDesktop.left + rcDesktop.right - rcThis.right) / 2;
	}

	if ((y+rcThis.bottom < rcDesktop.top+MinVis) || (y > rcDesktop.bottom-MinVis))
	{
		y = (rcDesktop.top + rcDesktop.bottom - rcThis.bottom) / 2;
	}

	SetWindowPos(GetWindow(), NULL, x, y, 0, 0, SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\mlzdbg.cpp ===
#include "precomp.h"

#if defined(_DEBUG) && ! defined(_UNICODE)

#define MULTI_LEVEL_ZONES
#include <mlzdbg.h>

HDBGZONE g_hDbgZones;

void WINAPI MLZ_DbgInit(PSTR *apszZones, UINT cZones)
{
    // if registry is empty, set warning flag as default
    DbgInitEx(&g_hDbgZones, apszZones, cZones, ZONE_WARNING_FLAG);

    // if the warning flag is not set, then set it as default
    if (g_hDbgZones != NULL)
    {
        ((PZONEINFO) g_hDbgZones)->ulZoneMask |= ZONE_WARNING_FLAG;
    }
}

void WINAPI MLZ_DbgDeInit(void)
{
    DbgDeInit(&g_hDbgZones);
}

void WINAPIV MLZ_WarningOut(PSTR pszFormat, ...)
{
	if (g_hDbgZones != NULL &&
        IS_ZONE_ENABLED(g_hDbgZones, ZONE_WARNING_FLAG))
	{
		va_list args;
		va_start(args, pszFormat);
		DbgPrintf(NULL, pszFormat, args);
		va_end(args);
	}
}

BOOL WINAPI MLZ_TraceZoneEnabled(int iZone)
{
	return (g_hDbgZones != NULL &&
            IS_ZONE_ENABLED(g_hDbgZones, ZONE_TRACE_FLAG) &&
	        IS_ZONE_ENABLED(g_hDbgZones, ZONE_FLAG(iZone)));
}

void WINAPIV MLZ_TraceOut(PSTR pszFormat, ...)
{
	va_list args;
	va_start(args, pszFormat);
	DbgPrintf(NULL, pszFormat, args);
	va_end(args);
}

void WINAPI MLZ_EntryOut(int iZone, PSTR pszFunName)
{
	if (g_hDbgZones != NULL &&
        IS_ZONE_ENABLED(g_hDbgZones, ZONE_FUNCTION_FLAG) &&
	    IS_ZONE_ENABLED(g_hDbgZones, ZONE_FLAG(iZone)))
	{
        MLZ_TraceOut("%s() entered.", pszFunName);
    }
}

void WINAPI MLZ_ExitOut(int iZone, PSTR pszFunName, RCTYPE eRetCodeType, DWORD_PTR dwRetCode)
{
	if (g_hDbgZones != NULL &&
        IS_ZONE_ENABLED(g_hDbgZones, ZONE_FUNCTION_FLAG) &&
	    IS_ZONE_ENABLED(g_hDbgZones, ZONE_FLAG(iZone)))
	{
        PSTR pszRetCode;
        char szFormat[64];

        lstrcpyA(&szFormat[0], "%s() exiting...");
        pszRetCode = &szFormat[0] + lstrlenA(&szFormat[0]);

        if (eRetCodeType != RCTYPE_VOID)
        {
            lstrcpyA(pszRetCode, " rc=");
            pszRetCode += lstrlenA(pszRetCode);

    	    switch (eRetCodeType)
    	    {
    	    case RCTYPE_BOOL:
    	        lstrcpyA(pszRetCode, dwRetCode ? "TRUE" : "FALSE");
    	        break;
    	    case RCTYPE_DWORD:
    	    case RCTYPE_HRESULT:
    	        wsprintf(pszRetCode, "0x%lx", (DWORD)dwRetCode);
    	        break;
    	    case RCTYPE_INT:
    	        wsprintf(pszRetCode, "%ld", (LONG) dwRetCode);
    	        break;
    	    case RCTYPE_ULONG:
    	        wsprintf(pszRetCode, "%lu", (ULONG) dwRetCode);
    	        break;
    	    case RCTYPE_PTR:
    	        wsprintf(pszRetCode, "%p", dwRetCode);
    	        break;
    	    default:
    	        ASSERT(0);
    	        break;
    	    }
        }
        MLZ_TraceOut(&szFormat[0], pszFunName);
    }
}

#endif // _DEBUG && ! _UNICODE


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\memory.cpp ===
//
// File: memory.cpp
//
// Debug memory tracking per-module

#include "precomp.h"


static BOOL   s_fZeroInit = FALSE;




#if defined(DEBUG)

#define DBG_NAME_LENGTH     16
typedef struct tagMemTag
{
    DWORD       dwSignature;
    BOOL        fActive;
    LPVOID      callerAddress;
    CHAR        szFileName[DBG_NAME_LENGTH];
    UINT        nLineNumber;
    UINT        cbSize;
    struct tagMemTag *next;
}
MEM_TAG;

static MEM_TAG *s_pDbgActiveMemPool = NULL;
#define CLEAN_BYTE  ((BYTE) 0xCD)

static UINT   s_cDbgActiveMemAlloc = 0;
static UINT   s_cbDbgActiveMem = 0;
const DWORD MEM_TAG_SIGNATURE = 0x12345678UL;

static CRITICAL_SECTION s_DbgCritSect;
static char  s_szDbgModuleName[DBG_NAME_LENGTH] = { 0 };
static void _GetFileName(LPSTR pszTarget, LPSTR pszSrc);
static void _DbgGetFileLine(LPSTR *, UINT *);

#define DBG_MEM_TRACK_DUMP_ALL      ((UINT) -1)





//
// DbgMemTrackReverseList()
//
void WINAPI DbgMemTrackReverseList(void)
{
    EnterCriticalSection(&s_DbgCritSect);
    if (NULL != s_pDbgActiveMemPool && NULL != s_pDbgActiveMemPool->next)
    {
        MEM_TAG *p, *q, *r;;

        for (q = (p = s_pDbgActiveMemPool)->next, r = q; // make sure r is not null in the beginning
             NULL != r;
             p = q, q = r)
        {
            r = q->next;
            q->next = p;
        }

        s_pDbgActiveMemPool->next = NULL;
        s_pDbgActiveMemPool = p;
    }
    LeaveCriticalSection(&s_DbgCritSect);
}


//
// DbgMemTrackDumpCurrent()
//
void WINAPI DbgMemTrackDumpCurrent(void)
{
    MEM_TAG *p;
    int i;
    char szBuf[128];

    EnterCriticalSection(&s_DbgCritSect);
    for (p = s_pDbgActiveMemPool, i = 0; p; p = p->next, i++)
    {
        if (p->callerAddress)
        {
            // No file/line, just caller
            wsprintfA(szBuf, "%s: mem leak [%u]: caller address=0x%p, size=%u, ptr=0x%p\r\n",
                s_szDbgModuleName, i,
                p->callerAddress, p->cbSize, (p+1));
        }
        else
        {
            // File & line number
            wsprintfA(szBuf, "%s: mem leak [%u]: file=%s, line=%u, size=%u, ptr=0x%p\r\n",
                s_szDbgModuleName, i,
                p->szFileName, p->nLineNumber, p->cbSize, (p+1));
        }
        OutputDebugStringA(szBuf);
    }
    LeaveCriticalSection(&s_DbgCritSect);
}


//
// DbgMemTrackFinalCheck()
//
// Dumps any left-around (leaked) memory blocks.  Call this on
// DLL_PROCESS_DETACH from your .DLL or at the end of WinMain of your .EXE
//
void WINAPI DbgMemTrackFinalCheck(void)
{
    DbgMemTrackReverseList();
    DbgMemTrackDumpCurrent();
    if (NULL != s_pDbgActiveMemPool ||
        NULL != s_cDbgActiveMemAlloc ||
        NULL != s_cbDbgActiveMem)
    {
        DebugBreak();
    }

    DeleteCriticalSection(&s_DbgCritSect);
}


//
// _GetFileName()
//
static void _GetFileName(LPSTR pszTarget, LPSTR pszSrc)
{
    LPSTR psz = pszSrc;
    while (*psz != '\0')
    {
        if (*psz++ == '\\')
        {
            pszSrc = psz;
        }
    }
    lstrcpynA(pszTarget, pszSrc, DBG_NAME_LENGTH);
}


//
// DbgMemAlloc()
//
// Debug memory allocation
//
LPVOID WINAPI DbgMemAlloc
(
    UINT    cbSize,
    LPVOID  callerAddress,
    LPSTR   pszFileName,
    UINT    nLineNumber
)
{
    MEM_TAG *p;
    UINT cbToAlloc;

    cbToAlloc = sizeof(MEM_TAG) + cbSize;

    EnterCriticalSection(&s_DbgCritSect);

    p = (MEM_TAG *) LocalAlloc(LPTR, cbToAlloc);
    if (p != NULL)
    {
        p->dwSignature = MEM_TAG_SIGNATURE;
        p->fActive = TRUE;
        p->callerAddress = callerAddress;

        if (pszFileName)
        {
            _GetFileName(p->szFileName, pszFileName);
            p->nLineNumber = nLineNumber;
        }

        p->cbSize = cbSize;
        p->next = s_pDbgActiveMemPool;
        s_pDbgActiveMemPool = p;
        s_cDbgActiveMemAlloc++;
        s_cbDbgActiveMem += p->cbSize;
        p++;

        //
        // If no zero-init, fill with clean byte
        //
        if (!s_fZeroInit)
        {
            FillMemory(p, cbSize, CLEAN_BYTE);
        }
    }

    LeaveCriticalSection(&s_DbgCritSect);

    return (LPVOID) p;
}


//
// DbgMemFree()
//
// Debug memory free
//
void WINAPI DbgMemFree(LPVOID ptr)
{
    if (ptr != NULL)
    {
        MEM_TAG *p = (MEM_TAG *) ptr;
        p--;
        if (! IsBadWritePtr(p, sizeof(MEM_TAG)) &&
            (p->dwSignature == MEM_TAG_SIGNATURE))
        {
            if (! p->fActive)
            {
                //
                // This memory has been freed already.
                //
                ERROR_OUT(("DbgMemFree called with invalid pointer 0x%08x", p));
                return;
            }

            MEM_TAG *q, *q0;
            EnterCriticalSection(&s_DbgCritSect);
            for (q = s_pDbgActiveMemPool; q != NULL; q = (q0 = q)->next)
            {
                if (q == p)
                {
                    if (q == s_pDbgActiveMemPool)
                    {
                        s_pDbgActiveMemPool = p->next;
                    }
                    else
                    {
                        q0->next = p->next;
                    }
                    s_cDbgActiveMemAlloc--;
                    s_cbDbgActiveMem -= p->cbSize;
                    p->fActive = FALSE;

                    //
                    // Fill app pointer data with CLEAN_BYTE, to see if
                    // anybody tries later to access it after it's been
                    // freed.
                    //
                    FillMemory(p+1, p->cbSize, CLEAN_BYTE);
                    break;
                }
            }
            LeaveCriticalSection(&s_DbgCritSect);
        }
        else
        {
            ERROR_OUT(("DbgMemFree called with invalid pointer 0x%08x", p));
            return;
        }

        LocalFree(p);
    }
}


//
// DbgMemReAlloc()
//
// Debug memory reallocate
//
LPVOID WINAPI DbgMemReAlloc(LPVOID ptr, UINT cbSize, UINT uFlags, LPSTR pszFileName, UINT nLineNumber)
{
    MEM_TAG *p;
    void *q;

    if (ptr == NULL)
        return DbgMemAlloc(cbSize, 0, pszFileName, nLineNumber);

    p = (MEM_TAG *) ptr;
    p--;

    if (IsBadWritePtr(p, sizeof(MEM_TAG)) ||
        p->dwSignature != MEM_TAG_SIGNATURE)
    {
        DebugBreak();
        return LocalReAlloc(ptr, cbSize, uFlags);
    }

    q = DbgMemAlloc(cbSize, 0, pszFileName, nLineNumber);
    if (q != NULL)
    {
        CopyMemory(q, ptr, p->cbSize);
        DbgMemFree(ptr);
    }

    return q;
}


typedef struct
{
    DWORD    dwThreadID;
    LPSTR    pszFileName;
    UINT    nLineNumber;
}
DBG_THREAD_FILE_LINE;

#define DBG_MAX_THREADS     32
static DBG_THREAD_FILE_LINE s_aThreadFileLine[DBG_MAX_THREADS] = { 0 };

void WINAPI DbgSaveFileLine(LPSTR pszFileName, UINT nLineNumber)
{
    DWORD dwThreadID = GetCurrentThreadId();

    EnterCriticalSection(&s_DbgCritSect);
    UINT c = DBG_MAX_THREADS;
    DBG_THREAD_FILE_LINE *p;
    for (p = s_aThreadFileLine; c--; p++)
    {
        if (p->dwThreadID == 0)
        {
            p->dwThreadID = dwThreadID;
            p->pszFileName = pszFileName;
            p->nLineNumber = nLineNumber;
            break;
        }
        else
        if (p->dwThreadID == dwThreadID)
        {
            p->pszFileName = pszFileName;
            p->nLineNumber = nLineNumber;
            break;
        }
    }
    LeaveCriticalSection(&s_DbgCritSect);
}

void WINAPI DbgGetFileLine(LPSTR *ppszFileName, UINT *pnLineNumber)
{
    *ppszFileName = NULL;
    *pnLineNumber = 0;

    DWORD dwThreadID = GetCurrentThreadId();

    EnterCriticalSection(&s_DbgCritSect);
    UINT c = DBG_MAX_THREADS;
    DBG_THREAD_FILE_LINE *p;
    for (p = s_aThreadFileLine; c--; p++)
    {
        if (p->dwThreadID == 0)
        {
            break;
        }
        else if (p->dwThreadID == dwThreadID)
        {
            *ppszFileName = p->pszFileName;
            *pnLineNumber = p->nLineNumber;
            p->pszFileName = NULL;
            p->nLineNumber = 0;
            break;
        }
    }
    LeaveCriticalSection(&s_DbgCritSect);
}



LPVOID __cdecl ::operator new(size_t uObjSize)
{
    LPVOID  callerAddress;
    LPSTR   pszFileName;
    UINT    nLineNumber;

    DbgGetFileLine(&pszFileName, &nLineNumber);

    if (pszFileName)
    {
        callerAddress = NULL;
    }
    else
    {
#ifdef _X86_
        LPVOID * lpParams;

        //
        // LAURABU HACK:  This doesn't work for alpha.  But it's not bad
        // for normal debugging.  We're going to grab the return address
        // of whomever called new()
        //
        lpParams = (LPVOID *)&uObjSize;
        callerAddress = *(lpParams - 1);
#else
        callerAddress = NULL;
#endif // _X86_
    }

    return(DbgMemAlloc(uObjSize, callerAddress, pszFileName, nLineNumber));
}

#else       // RETAIL


LPVOID __cdecl ::operator new(size_t uObjSize)
{
    if (s_fZeroInit)
    {
        return(LocalAlloc(LPTR, uObjSize));
    }
    else
    {
        return(LocalAlloc(LMEM_FIXED, uObjSize));
    }
}

#endif // defined(DEBUG)



//
// delete() is the same for both debug and retail
//
void __cdecl  ::operator delete(LPVOID pObj)
{
    MemFree(pObj);
}


//
// DbgInitMemTrack()
//
// Initialize debug memory tracking.  Call this on DLL_PROCESS_ATTACH in
// your .DLL or at beginning of WinMain of your .EXE
//
void WINAPI DbgInitMemTrack(HINSTANCE hDllInst, BOOL fZeroInit)
{
    s_fZeroInit = fZeroInit;

#if defined(DEBUG)
    InitializeCriticalSection(&s_DbgCritSect);

    char szPath[MAX_PATH];
    if (0 != GetModuleFileNameA(hDllInst, szPath, MAX_PATH))
    {
        _GetFileName(s_szDbgModuleName, szPath);
        LPSTR psz = s_szDbgModuleName;
        while (*psz != '\0')
        {
            if (*psz == '.')
            {
                *psz = '\0';
                break;
            }
            psz++;
        }
    }
    else
    {
        lstrcpyA(s_szDbgModuleName, "unknown");
    }
#endif // DEBUG
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\nmdsprv.cpp ===
// Utility code for Mapping a WAVE device ID to a DirectSound GUID
// Added - August 24, 1998

// original code in \av\utils\wav2ds

// this code will return an error on Win95
// (although it may work for a future version of DX)



/***************************************************************************
 *
 *  Copyright (C) 1995,1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsprvobj.c
 *  Content:    DirectSound Private Object wrapper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/12/98    dereks  Created.
 *  08/24/98    jselbie	Streamlined up for lightweight use in NetMeeting
 *
 ***************************************************************************/


#include "precomp.h"

#include <objbase.h>
#include <initguid.h>
#include <mmsystem.h>
#include <dsound.h>

// DirectSound Private Component GUID {11AB3EC0-25EC-11d1-A4D8-00C04FC28ACA}
DEFINE_GUID(CLSID_DirectSoundPrivate, 0x11ab3ec0, 0x25ec, 0x11d1, 0xa4, 0xd8, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);


//
// Property Sets
//

// DirectSound Device Properties {84624F82-25EC-11d1-A4D8-00C04FC28ACA}
DEFINE_GUID(DSPROPSETID_DirectSoundDevice, 0x84624f82, 0x25ec, 0x11d1, 0xa4, 0xd8, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);


typedef enum
{
    DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE,
    DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING,
    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION,
    DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE,
} DSPROPERTY_DIRECTSOUNDDEVICE;


typedef enum
{
    DIRECTSOUNDDEVICE_DATAFLOW_RENDER,
    DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE
} DIRECTSOUNDDEVICE_DATAFLOW;

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA
{
    LPSTR                       DeviceName; // waveIn/waveOut device name
    DIRECTSOUNDDEVICE_DATAFLOW  DataFlow;   // Data flow (i.e. waveIn or waveOut)
    GUID                        DeviceId;   // DirectSound device id
} DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA;



/***************************************************************************
 *
 *  DirectSoundPrivateCreate
 *
 *  Description:
 *      Creates and initializes a DirectSoundPrivate object.
 *
 *  Arguments:
 *      LPKSPROPERTYSET * [out]: receives IKsPropertySet interface to the
 *                               object.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT 
DirectSoundPrivateCreate
(
    LPKSPROPERTYSET *       ppKsPropertySet
)
{
    typedef HRESULT (STDAPICALLTYPE *LPFNDLLGETCLASSOBJECT)(REFCLSID, REFIID, LPVOID *);

    HINSTANCE               hLibDsound              = NULL;
    LPFNGETCLASSOBJECT      pfnDllGetClassObject    = NULL;
    LPCLASSFACTORY          pClassFactory           = NULL;
    LPKSPROPERTYSET         pKsPropertySet          = NULL;
    HRESULT                 hr                      = DS_OK;

    hLibDsound = 
        GetModuleHandle
        (
            TEXT("dsound.dll")
        );


    if(!hLibDsound)
    {
        hr = DSERR_GENERIC;
    }

    // Find DllGetClassObject
    if(SUCCEEDED(hr))
    {
        pfnDllGetClassObject = (LPFNDLLGETCLASSOBJECT)
            GetProcAddress
            (
                hLibDsound, 
                "DllGetClassObject"
            );

        if(!pfnDllGetClassObject)
        {
            hr = DSERR_GENERIC;
        }
    }

    // Create a class factory object    
    if(SUCCEEDED(hr))
    {
        hr = 
            pfnDllGetClassObject
            (
                CLSID_DirectSoundPrivate, 
                IID_IClassFactory, 
                (LPVOID *)&pClassFactory
            );
    }

    // Create the DirectSoundPrivate object and query for an IKsPropertySet
    // interface
    if(SUCCEEDED(hr))
    {
        hr = 
            pClassFactory->CreateInstance
            (
                NULL, 
                IID_IKsPropertySet, 
                (LPVOID *)&pKsPropertySet
            );
    }

    // Release the class factory
    if(pClassFactory)
    {
        pClassFactory->Release();
    }

    // Success
    if(SUCCEEDED(hr))
    {
        *ppKsPropertySet = pKsPropertySet;
    }

    return hr;
}


/***************************************************************************
 *
 *  DsprvGetWaveDeviceMapping
 *
 *  Description:
 *      Gets the DirectSound device id (if any) for a given waveIn or
 *      waveOut device description.  This is the description given by
 *      waveIn/OutGetDevCaps (szPname).
 *
 *  Arguments:
 *      LPCSTR [in]: wave device description.  (WAVEOUTCAPS.szPname or WAVEINCAPS.szPname)
 *      BOOL [in]: TRUE if the device description refers to a waveIn device.
 *      LPGUID [out]: receives DirectSound device GUID.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

extern "C" HRESULT __stdcall
DsprvGetWaveDeviceMapping
(
	LPCSTR                                              pszWaveDevice,
    BOOL                                                fCapture,
    LPGUID                                              pguidDeviceId
)
{
    DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA Data;
    HRESULT                                             hr;
    IKsPropertySet                                      *pKsPropertySet=NULL;
    HINSTANCE                                           hLibDsound= NULL;


	hLibDsound = LoadLibrary(TEXT("dsound.dll"));
	if (hLibDsound == NULL)
	{
		return E_FAIL;
	}


	hr = DirectSoundPrivateCreate(&pKsPropertySet);
	if (SUCCEEDED(hr))
	{

	    Data.DeviceName = (LPSTR)pszWaveDevice;
		Data.DataFlow = fCapture ? DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE : DIRECTSOUNDDEVICE_DATAFLOW_RENDER;

	    hr =
		    pKsPropertySet->Get
			(
				DSPROPSETID_DirectSoundDevice,
	            DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING,
		        NULL,
			    0,
				&Data,
	            sizeof(Data),
		        NULL
			);

	    if(SUCCEEDED(hr))
		{
			*pguidDeviceId = Data.DeviceId;
	    }
		else
		{
			ZeroMemory(pguidDeviceId, sizeof(GUID));
		}

	}

	if (pKsPropertySet)
		pKsPropertySet->Release();

	FreeLibrary(hLibDsound);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\precomp.h ===
#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#include <windows.h>
#include <tchar.h>
#include <limits.h>
#include <shlobj.h>
#include <wincrypt.h>

#include "memtrack.h"

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#include "stock.h"
#include "olestock.h"

#ifdef DEBUG

#include "inifile.h"
#include "resstr.h"

#endif /* DEBUG */

#include "confdbg.h"
#include "debspew.h"
#include "valid.h"
#include "olevalid.h"


#ifdef __cplusplus
}
#endif /* __cplusplus */


#endif /* _PRECOMP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\procutil.cpp ===
#include "precomp.h"
#include <oprahcom.h>
#include <regentry.h>
#include "mperror.h"
#include <sehcall.h>
#define LEGACY_DIVISOR	8

extern "C" WORD _cdecl is_cyrix(void);
extern "C" DWORD _cdecl get_nxcpu_type(void);


#ifndef _M_IX86
DWORD WINAPI CallWithSEH(EXCEPTPROC pfn, void *pv, INEXCEPTION InException)
{
	// we don't have a native version of SEH for the alpha,
	// use __try and __except
	pfn(pv);
    return 0;
}
#endif



#ifdef _M_IX86

DWORD NMINTERNAL FindTSC (LPVOID pvRefData)
{
	   _asm
	   {
		   mov     eax,1
		   _emit   00Fh     ;; CPUID
		   _emit   0A2h

    // The ref data is 2 DWORDS, the first is the flags,
    // the second the family
		   mov     ecx,pvRefData
		   mov     [ecx],edx
		   mov	   [ecx][4],eax
	   }

	   return 1;
}

DWORD NMINTERNAL NoCPUID (LPEXCEPTION_RECORD per,PCONTEXT pctx)
{
    return 0;
}
//
//  GetProcessorSpeed(dwFamily)
//
//  get the processor speed in MHz, only works on Pentium or better
//  machines.
//
//  Will put 3, or 4 in dwFamily for 386/486, but no speed.
//  returns speed and family for 586+
//
//  - thanks to toddla, modified by mikeg
//

int NMINTERNAL GetProcessorSpeed(int *pdwFamily)
{
    SYSTEM_INFO si;
    __int64	start, end, freq;
    int 	flags,family;
    int 	time;
    int 	clocks;
    DWORD	oldclass;
    HANDLE      hprocess;
    int     pRef[2];

    ZeroMemory(&si, sizeof(si));
    GetSystemInfo(&si);

    //Set the family. If wProcessorLevel is not specified, dig it out of dwProcessorType
    //Because wProcessor level is not implemented on Win95
    if (si.wProcessorLevel) {
	*pdwFamily=si.wProcessorLevel;
    }else {
    	//Ok, we're on Win95
    	switch (si.dwProcessorType) {
    	       case PROCESSOR_INTEL_386:
    		   *pdwFamily=3;
    		   break;

    	       case PROCESSOR_INTEL_486:
    		   *pdwFamily=4;
    		   break;
    	       default:
    		   *pdwFamily=0;
    		   break;
    	}
    		
    }

    //
    // make sure this is a INTEL Pentium (or clone) or higher.
    //
    if (si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL)
        return 0;

    if (si.dwProcessorType < PROCESSOR_INTEL_PENTIUM)
        return 0;

    //
    // see if this chip supports rdtsc before using it.
    //
    if (!CallWithSEH (FindTSC,&pRef,NoCPUID))     {
        flags=0;
    } else {
    // The ref data is 2 DWORDS, the first is the flags,
    // the second the family. Pull them out and use them
        flags=pRef[0];
        family=pRef[1];
    }

    if (!(flags & 0x10))
        return 0;


    //If we don't have a family, set it now
    //Family is bits 11:8 of eax from CPU, with eax=1
    if (!(*pdwFamily)) {
       *pdwFamily=(family& 0x0F00) >> 8;
    }


    hprocess = GetCurrentProcess();
    oldclass = GetPriorityClass(hprocess);
    SetPriorityClass(hprocess, REALTIME_PRIORITY_CLASS);
    Sleep(10);

    QueryPerformanceFrequency((LARGE_INTEGER*)&freq);
    QueryPerformanceCounter((LARGE_INTEGER*)&start);
    _asm
    {
        _emit   0Fh     ;; RDTSC
        _emit   31h
        mov     ecx,100000
x:      dec     ecx
        jnz     x
        mov     ebx,eax
        _emit   0Fh     ;; RDTSC
        _emit   31h
        sub     eax,ebx
        mov     dword ptr clocks[0],eax
    }
    QueryPerformanceCounter((LARGE_INTEGER*)&end);
    SetPriorityClass(hprocess, oldclass);

    time = MulDiv((int)(end-start),1000000,(int)freq);

    return (clocks + time/2) / time;
}



HRESULT NMINTERNAL GetNormalizedCPUSpeed (int *pdwNormalizedSpeed, int *dwFamily)
{
   int dwProcessorSpeed;

   dwProcessorSpeed=GetProcessorSpeed (dwFamily);

   *pdwNormalizedSpeed=dwProcessorSpeed;

   if (*dwFamily > 5) {
       //Ok, TWO things.
       // ONE DO NOT DO FP!
       // Two for the same Mhz assume a 686 is 1.3 times as fast as a 586 and a 786 is 1.6 times, etc.
       *pdwNormalizedSpeed=(ULONG) (((10+3*(*dwFamily-5))*dwProcessorSpeed)/10);
   }

   if (*dwFamily < 5) {
	  //bugbug until we have 386/486 timing code, assume
	  //486=50,386=37
      if (*dwFamily > 3) {
           //Cyrix, (5x86)? check before making default assignment
           if (is_cyrix()) {
               if (*pdwNormalizedSpeed==0) {
                   *dwFamily=5;
                   *pdwNormalizedSpeed=100;
                   return hrSuccess;
               }
           }
      }

	  *pdwNormalizedSpeed= (*dwFamily*100)/LEGACY_DIVISOR;

      if (get_nxcpu_type ()) {
        //Double the perceived value on a NexGen
        *pdwNormalizedSpeed *=2;
      }


   }



   return hrSuccess;
}
#endif //_M_IX86





BOOL WINAPI IsFloatingPointEmulated(void)
{
	long lRegValue;
	SYSTEM_INFO si;
	OSVERSIONINFO osi;
	BOOL fEmulation, bNT;
	

	// are we a Pentium
	ZeroMemory(&si, sizeof(si));
	GetSystemInfo(&si);
	if (si.dwProcessorType != PROCESSOR_INTEL_PENTIUM) 
	{
		return FALSE;
	}

	// Which OS: NT or 95 ?
	ZeroMemory(&osi, sizeof(osi));
	osi.dwOSVersionInfoSize = sizeof(osi);
	GetVersionEx(&osi);
	bNT = (osi.dwPlatformId == VER_PLATFORM_WIN32_NT);

	// Windows NT
	if (bNT)
	{
		RegEntry re(TEXT("System\\CurrentControlSet\\Control\\Session Manager"),
		            HKEY_LOCAL_MACHINE, FALSE);

		// try to get a definitive answer from the registry
		lRegValue = re.GetNumber(TEXT("ForceNpxEmulation"), -1);

		// registry: 0: no 
		//           1: conditional (not definitive!)
		//           2: yes

		if (lRegValue == 2)
		{
			return TRUE;
		}

		// we could load "IsProcessorFeaturePresent from kernel32.dll,
		// but the version that shipped with NT 4 has a bug in it that
		// returns the exact opposite of what it should be.  It was
		// fixed in NT 5. Since this API isn't the same across platforms,
		// we won't use it.

		return FALSE;
	}

	// Windows 95 - to be added later
	return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\ping.cpp ===
#include "precomp.h"
#include "ping.h"
#include "avutil.h"	// for RtStrToInt


const CHAR  g_cszPingData[] = "NetMeetingPing";
const int   PING_BUFFERSIZE = 1024;
const DWORD PING_TIMEOUT    = 4000; // 4 seconds
const DWORD PING_RETRIES    = 4;
const TCHAR g_cszICMPDLLName[] = _TEXT("icmp.dll");

//
// CPing::Ping()
//
// Return value:
//   E_FAIL:   Function failed
//   S_FALSE:  Function succeeded, ping failed
//   S_OK:     Function succeeded, ping succeeded
//

HRESULT CPing::Ping(DWORD dwAddr, DWORD dwTimeout, DWORD dwRetries)
{
	DebugEntry(CPing::Ping);
	HRESULT hr = E_FAIL;

	if (0 != dwAddr)
	{
		if (NULL == m_hICMPDLL)
		{
			m_hICMPDLL = ::LoadLibrary(g_cszICMPDLLName);
		}
		if (NULL != m_hICMPDLL)
		{
			m_pfnCreateFile = (PFNIcmpCreateFile)
								::GetProcAddress(m_hICMPDLL, "IcmpCreateFile");
			m_pfnCloseHandle = (PFNIcmpCloseHandle)
								::GetProcAddress(m_hICMPDLL, "IcmpCloseHandle");
			m_pfnSendEcho = (PFNIcmpSendEcho)
								::GetProcAddress(m_hICMPDLL, "IcmpSendEcho");
			if ((NULL != m_pfnCreateFile) &&
				(NULL != m_pfnCloseHandle) &&
				(NULL != m_pfnSendEcho))
			{
				HANDLE hPing = m_pfnCreateFile();
				if (NULL != hPing)
				{
					BYTE buffer[PING_BUFFERSIZE];
					for (DWORD dwTry = 0; dwTry < dwRetries; dwTry++)
					{
						DWORD dwStatus = m_pfnSendEcho(	hPing,
														dwAddr,
														(LPVOID) g_cszPingData,
														(WORD) CCHMAX(g_cszPingData),
														NULL,
														buffer,
														sizeof(buffer),
														dwTimeout);
						if (0 != dwStatus)
						{
							if (((PICMP_ECHO_REPLY)buffer)->Status == IP_SUCCESS)
							{
								TRACE_OUT(("ping: %d.%d.%d.%d succeeded",
											((LPBYTE)&dwAddr)[0],
											((LPBYTE)&dwAddr)[1],
											((LPBYTE)&dwAddr)[2],
											((LPBYTE)&dwAddr)[3]));
								hr = S_OK;    // function succeeded - ping succeeded
							}
							else
							{
								TRACE_OUT(("ping: %d.%d.%d.%d failed",
											((LPBYTE)&dwAddr)[0],
											((LPBYTE)&dwAddr)[1],
											((LPBYTE)&dwAddr)[2],
											((LPBYTE)&dwAddr)[3]));
								hr = S_FALSE; // function succeeded - ping failed
							}
							break;
						}
						else
						{
							TRACE_OUT(("ping: %d.%d.%d.%d did not respond",
										((LPBYTE)&dwAddr)[0],
										((LPBYTE)&dwAddr)[1],
										((LPBYTE)&dwAddr)[2],
										((LPBYTE)&dwAddr)[3]));
						}
					}
					m_pfnCloseHandle(hPing);
				}
				else
				{
					ERROR_OUT(("IcmpCreateFile() failed"));
				}
			}
			else
			{
				ERROR_OUT(("Could not find icmp.dll entry points"));
			}
		}
		else
		{
			ERROR_OUT(("Could not load icmp.dll"));
		}
	}

	DebugExitHRESULT(CPing::Ping, hr);
	return hr;
}



BOOL CPing::IsAutodialEnabled ( VOID )
{
	// Figure out the os platform if not done so
	//
	if (m_dwPlatformId == PLATFORM_UNKNOWN)
	{
		OSVERSIONINFO osvi;
		ZeroMemory (&osvi, sizeof (osvi));
		osvi.dwOSVersionInfoSize = sizeof (osvi);
		if (GetVersionEx (&osvi))
		{
			m_dwPlatformId = osvi.dwPlatformId;
		}
		else
		{
			return FALSE;
		}
	}

	// Check autodial enabling for either platform
	//
	BOOL fEnabled;
	switch (m_dwPlatformId)
	{
	case VER_PLATFORM_WIN32_WINDOWS: // 1, Windows 95
		fEnabled = IsWin95AutodialEnabled ();
		break;
	case VER_PLATFORM_WIN32_NT: // 2, Windows NT
		fEnabled = IsWinNTAutodialEnabled ();
		break;
	case VER_PLATFORM_WIN32s: // 0, Windows 3.1
	default: // unknown
		ASSERT (FALSE);
		fEnabled = FALSE;
		break;
	}

	return fEnabled;
}


#define c_szWin95AutodialRegFolder		TEXT ("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings")
#define c_szWin95AutodialRegKey			TEXT ("EnableAutodial")

BOOL CPing::IsWin95AutodialEnabled ( VOID )
{
	// Always check the registry
	//
	BOOL fEnabled = FALSE;

	// Need to check the registry setting.
	// In case of error, report no autodial.
	//
	HKEY hKey;
	if (RegOpenKeyEx (	HKEY_CURRENT_USER,
						c_szWin95AutodialRegFolder,
						0,
						KEY_READ,
						&hKey) == NOERROR)
	{
		TCHAR szValue[16];
		ZeroMemory (&szValue[0], sizeof (DWORD));

		ULONG cb = sizeof (szValue);
		DWORD dwType;
		if (RegQueryValueEx (hKey, c_szWin95AutodialRegKey, NULL,
							&dwType, (BYTE *) &szValue[0], &cb)
			== NOERROR)
		{
			switch (dwType)
			{
			case REG_DWORD:
			case REG_BINARY:
				fEnabled = (BOOL) *(LONG *) &szValue[0];
				break;
#if 0 // do not need to worry about this case, IE must maintain backward compatibility
			case REG_SZ:
				fEnabled = (BOOL) RtStrToInt (&szValue[0]);
				break;
#endif // 0
			default:
				ASSERT (FALSE);
				break;
			}
		}

		RegCloseKey (hKey);
	}

	return fEnabled;
}


// RAS only runs on NT 4.0 or later, as a result, WINVER must be 0x401 or larger
//
#if (WINVER < 0x401)
#undef WINVER
#define WINVER 0x401
#endif

#include <ras.h>

// DWORD APIENTRY RasGetAutodialParamA( DWORD, LPVOID, LPDWORD );	// defined in <ras.h>
// DWORD APIENTRY RasGetAutodialParamW( DWORD, LPVOID, LPDWORD );	// defined in <ras.h>
typedef DWORD (APIENTRY *PFN_RasGetAutodialParam) ( DWORD, LPVOID, LPDWORD );
#define c_szRasGetAutodialParam		"RasGetAutodialParamW"
#define c_szRasApi32Dll				TEXT ("rasapi32.dll")


BOOL CPing::IsWinNTAutodialEnabled ( VOID )
{
	// Decide if we want to check autodial registry setting
	//
	BOOL fEnabled = FALSE;
	if (m_fWinNTAutodialEnabled == AUTODIAL_UNKNOWN)
	{
		// We do not want to have initialization error
		//
		UINT uErrMode = SetErrorMode (SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

		// Load the library rasapi32.dll from the system directory
		//
		HINSTANCE hRasApi32Dll = LoadLibrary (c_szRasApi32Dll);
		if (hRasApi32Dll != NULL)
		{
			// Get the proc address for RasGetAutodialParam()
			//
			PFN_RasGetAutodialParam pfn = (PFN_RasGetAutodialParam)
						GetProcAddress (hRasApi32Dll, c_szRasGetAutodialParam);
			if (pfn != NULL)
			{
				// Query RAS if it disables autodial
				//
				DWORD dwVal, dwSize = sizeof (DWORD);
				DWORD dwErr = (*pfn) (RASADP_LoginSessionDisable, &dwVal, &dwSize);
				if (dwErr == 0)
				{
					// Set the autodial flag only when everything succeeds
					//
					fEnabled = (dwVal == 0);
				}
			}

			FreeLibrary (hRasApi32Dll);
		}

		// Restore error mode
		//
		SetErrorMode (uErrMode);

		m_fWinNTAutodialEnabled = fEnabled;
	}
	else
	{
		// Do not need to check the registry setting.
		// Simply use the cached one.
		//
		fEnabled = m_fWinNTAutodialEnabled;
	}

	return fEnabled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\olevalid.c ===
/*
 * olevalid.c - OLE validation functions module.
 *
 * Taken from URL code 
 *
 * Created: ChrisPi 9-11-95
 *
 */


/* Headers
 **********/

#include "precomp.h"


/****************************** Public Functions *****************************/


#ifdef DEBUG

BOOL IsValidPCGUID(PCGUID pcguid)
{
   /* All values are valid GUIDs. */

   return(IS_VALID_READ_PTR(pcguid, CGUID));
}


BOOL IsValidPCCLSID(PCCLSID pcclsid)
{
   return(IS_VALID_STRUCT_PTR(pcclsid, CGUID));
}


BOOL IsValidPCIID(PCIID pciid)
{
   return(IS_VALID_STRUCT_PTR(pciid, CGUID));
}


BOOL IsValidPCDVTARGETDEVICE(PCDVTARGETDEVICE pcdvtd)
{
   /* BUGBUG: Validate remaining fields here. */

   return(IS_VALID_READ_PTR(&(pcdvtd->tdSize), DWORD) &&
          IS_VALID_READ_BUFFER_PTR(pcdvtd, DVTARGETDEVICE, pcdvtd->tdSize));
}


BOOL IsValidPCFORMATETC(PCFORMATETC pcfe)
{
   /* BUGBUG: Validate structure fields. */

   return(IS_VALID_READ_PTR(pcfe, CFORMATETC));
}


BOOL IsValidStgMediumType(DWORD tymed)
{
   BOOL bResult;

   switch (tymed)
   {
      case TYMED_HGLOBAL:
      case TYMED_FILE:
      case TYMED_ISTREAM:
      case TYMED_ISTORAGE:
      case TYMED_GDI:
      case TYMED_MFPICT:
      case TYMED_ENHMF:
      case TYMED_NULL:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         ERROR_OUT(("IsValidStgMediumType(): Invalid storage medium type %lu.",
                    tymed));
         break;
   }

   return(bResult);
}


BOOL IsValidPCSTGMEDIUM(PCSTGMEDIUM pcstgmed)
{
   /* BUGBUG: Validate u union field. */

   return(IS_VALID_READ_PTR(pcstgmed, CSTGMEDIUM) &&
          IsValidStgMediumType(pcstgmed->tymed) &&
          (! pcstgmed->pUnkForRelease ||
           IS_VALID_INTERFACE_PTR(pcstgmed->pUnkForRelease, IUnknown)));
}


BOOL IsValidREFIID(REFIID riid)
{
   return(IS_VALID_STRUCT_PTR(riid, CIID));
}


BOOL IsValidREFCLSID(REFCLSID rclsid)
{
   return(IS_VALID_STRUCT_PTR(rclsid, CCLSID));
}


BOOL IsValidPCINTERFACE(PCVOID pcvi)
{
   return(IS_VALID_READ_PTR((FARPROC *)pcvi, FARPROC) &&
          IS_VALID_CODE_PTR(*((FARPROC *)pcvi), Method));
}


BOOL IsValidPCIAdviseSink(PCIAdviseSink pcias)
{
   return(IS_VALID_READ_PTR(pcias, CIAdviseSink) &&
          IS_VALID_READ_PTR(pcias->lpVtbl, sizeof(*(pcias->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pcias, IUnknown) &&
          IS_VALID_METHOD(pcias, OnDataChange) &&
          IS_VALID_METHOD(pcias, OnViewChange) &&
          IS_VALID_METHOD(pcias, OnRename) &&
          IS_VALID_METHOD(pcias, OnSave) &&
          IS_VALID_METHOD(pcias, OnClose));
}


BOOL IsValidPCIClassFactory(PCIClassFactory pcicf)
{
   return(IS_VALID_READ_PTR(pcicf, CIClassFactory) &&
          IS_VALID_READ_PTR(pcicf->lpVtbl, sizeof(*(pcicf->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pcicf, IUnknown) &&
          IS_VALID_METHOD(pcicf, CreateInstance) &&
          IS_VALID_METHOD(pcicf, LockServer));
}


BOOL IsValidPCIDataObject(PCIDataObject pcido)
{
   return(IS_VALID_READ_PTR(pcido, CIDataObject) &&
          IS_VALID_READ_PTR(pcido->lpVtbl, sizeof(*(pcido->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pcido, IUnknown) &&
          IS_VALID_METHOD(pcido, GetData) &&
          IS_VALID_METHOD(pcido, GetDataHere) &&
          IS_VALID_METHOD(pcido, QueryGetData) &&
          IS_VALID_METHOD(pcido, GetCanonicalFormatEtc) &&
          IS_VALID_METHOD(pcido, SetData) &&
          IS_VALID_METHOD(pcido, EnumFormatEtc) &&
          IS_VALID_METHOD(pcido, DAdvise) &&
          IS_VALID_METHOD(pcido, DUnadvise) &&
          IS_VALID_METHOD(pcido, EnumDAdvise));
}


BOOL IsValidPCIDropSource(PCIDropSource pcids)
{
   return(IS_VALID_READ_PTR(pcids, CIDataObject) &&
          IS_VALID_READ_PTR(pcids->lpVtbl, sizeof(*(pcids->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pcids, IUnknown) &&
          IS_VALID_METHOD(pcids, QueryContinueDrag) &&
          IS_VALID_METHOD(pcids, GiveFeedback));
}


BOOL IsValidPCIDropTarget(PCIDropTarget pcidt)
{
   return(IS_VALID_READ_PTR(pcidt, CIDataObject) &&
          IS_VALID_READ_PTR(pcidt->lpVtbl, sizeof(*(pcidt->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pcidt, IUnknown) &&
          IS_VALID_METHOD(pcidt, DragEnter) &&
          IS_VALID_METHOD(pcidt, DragOver) &&
          IS_VALID_METHOD(pcidt, DragLeave) &&
          IS_VALID_METHOD(pcidt, Drop));
}


BOOL IsValidPCIEnumFORMATETC(PCIEnumFORMATETC pciefe)
{
   return(IS_VALID_READ_PTR(pciefe, CIEnumFORMATETC) &&
          IS_VALID_READ_PTR(pciefe->lpVtbl, sizeof(*(pciefe->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pciefe, IUnknown) &&
          IS_VALID_METHOD(pciefe, Next) &&
          IS_VALID_METHOD(pciefe, Skip) &&
          IS_VALID_METHOD(pciefe, Reset) &&
          IS_VALID_METHOD(pciefe, Clone));
}


BOOL IsValidPCIEnumSTATDATA(PCIEnumSTATDATA pciesd)
{
   return(IS_VALID_READ_PTR(pciesd, CIDataObject) &&
          IS_VALID_READ_PTR(pciesd->lpVtbl, sizeof(*(pciesd->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pciesd, IUnknown) &&
          IS_VALID_METHOD(pciesd, Next) &&
          IS_VALID_METHOD(pciesd, Skip) &&
          IS_VALID_METHOD(pciesd, Reset) &&
          IS_VALID_METHOD(pciesd, Clone));
}


BOOL IsValidPCIMalloc(PCIMalloc pcimalloc)
{
   return(IS_VALID_READ_PTR(pcimalloc, CIMalloc) &&
          IS_VALID_READ_PTR(pcimalloc->lpVtbl, sizeof(*(pcimalloc->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pcimalloc, IUnknown) &&
          IS_VALID_METHOD(pcimalloc, Alloc) &&
          IS_VALID_METHOD(pcimalloc, Realloc) &&
          IS_VALID_METHOD(pcimalloc, Free) &&
          IS_VALID_METHOD(pcimalloc, GetSize) &&
          IS_VALID_METHOD(pcimalloc, DidAlloc) &&
          IS_VALID_METHOD(pcimalloc, HeapMinimize));
}


BOOL IsValidPCIMoniker(PCIMoniker pcimk)
{
   return(IS_VALID_READ_PTR(pcimk, CIMoniker) &&
          IS_VALID_READ_PTR(pcimk->lpVtbl, sizeof(*(pcimk->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIPersistStream)pcimk, IPersistStream) &&
          IS_VALID_METHOD(pcimk, BindToObject) &&
          IS_VALID_METHOD(pcimk, BindToStorage) &&
          IS_VALID_METHOD(pcimk, Reduce) &&
          IS_VALID_METHOD(pcimk, ComposeWith) &&
          IS_VALID_METHOD(pcimk, Enum) &&
          IS_VALID_METHOD(pcimk, IsEqual) &&
          IS_VALID_METHOD(pcimk, Hash) &&
          IS_VALID_METHOD(pcimk, IsRunning) &&
          IS_VALID_METHOD(pcimk, GetTimeOfLastChange) &&
          IS_VALID_METHOD(pcimk, Inverse) &&
          IS_VALID_METHOD(pcimk, CommonPrefixWith) &&
          IS_VALID_METHOD(pcimk, RelativePathTo) &&
          IS_VALID_METHOD(pcimk, GetDisplayName) &&
          IS_VALID_METHOD(pcimk, ParseDisplayName) &&
          IS_VALID_METHOD(pcimk, IsSystemMoniker));
}


BOOL IsValidPCIPersist(PCIPersist pcip)
{
   return(IS_VALID_READ_PTR(pcip, CIUnknown) &&
          IS_VALID_READ_PTR(pcip->lpVtbl, sizeof(*(pcip->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pcip, IUnknown) &&
          IS_VALID_METHOD(pcip, GetClassID));
}


BOOL IsValidPCIPersistFile(PCIPersistFile pcipfile)
{
   return(IS_VALID_READ_PTR(pcipfile, CIPersistFile) &&
          IS_VALID_READ_PTR(pcipfile->lpVtbl, sizeof(*(pcipfile->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIPersist)pcipfile, IPersist) &&
          IS_VALID_METHOD(pcipfile, IsDirty) &&
          IS_VALID_METHOD(pcipfile, Load) &&
          IS_VALID_METHOD(pcipfile, Save) &&
          IS_VALID_METHOD(pcipfile, SaveCompleted) &&
          IS_VALID_METHOD(pcipfile, GetCurFile));
}


BOOL IsValidPCIPersistStorage(PCIPersistStorage pcipstg)
{
   return(IS_VALID_READ_PTR(pcipstg, CIPersistStorage) &&
          IS_VALID_READ_PTR(pcipstg->lpVtbl, sizeof(*(pcipstg->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIPersist)pcipstg, IPersist) &&
          IS_VALID_METHOD(pcipstg, IsDirty) &&
          IS_VALID_METHOD(pcipstg, InitNew) &&
          IS_VALID_METHOD(pcipstg, Load) &&
          IS_VALID_METHOD(pcipstg, Save) &&
          IS_VALID_METHOD(pcipstg, SaveCompleted) &&
          IS_VALID_METHOD(pcipstg, HandsOffStorage));
}


BOOL IsValidPCIPersistStream(PCIPersistStream pcipstr)
{
   return(IS_VALID_READ_PTR(pcipstr, CIPersistStream) &&
          IS_VALID_READ_PTR(pcipstr->lpVtbl, sizeof(*(pcipstr->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIPersist)pcipstr, IPersist) &&
          IS_VALID_METHOD(pcipstr, IsDirty) &&
          IS_VALID_METHOD(pcipstr, Load) &&
          IS_VALID_METHOD(pcipstr, Save) &&
          IS_VALID_METHOD(pcipstr, GetSizeMax));
}


BOOL IsValidPCIStorage(PCIStorage pcistg)
{
   return(IS_VALID_READ_PTR(pcistg, CIStorage) &&
          IS_VALID_READ_PTR(pcistg->lpVtbl, sizeof(*(pcistg->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pcistg, IUnknown) &&
          IS_VALID_METHOD(pcistg, CreateStream) &&
          IS_VALID_METHOD(pcistg, OpenStream) &&
          IS_VALID_METHOD(pcistg, CreateStorage) &&
          IS_VALID_METHOD(pcistg, OpenStorage) &&
          IS_VALID_METHOD(pcistg, CopyTo) &&
          IS_VALID_METHOD(pcistg, MoveElementTo) &&
          IS_VALID_METHOD(pcistg, Commit) &&
          IS_VALID_METHOD(pcistg, Revert) &&
          IS_VALID_METHOD(pcistg, EnumElements) &&
          IS_VALID_METHOD(pcistg, DestroyElement) &&
          IS_VALID_METHOD(pcistg, RenameElement) &&
          IS_VALID_METHOD(pcistg, SetElementTimes) &&
          IS_VALID_METHOD(pcistg, SetClass) &&
          IS_VALID_METHOD(pcistg, SetStateBits) &&
          IS_VALID_METHOD(pcistg, Stat));
}


BOOL IsValidPCIStream(PCIStream pcistr)
{
   return(IS_VALID_READ_PTR(pcistr, CIStorage) &&
          IS_VALID_READ_PTR(pcistr->lpVtbl, sizeof(*(pcistr->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pcistr, IUnknown) &&
          IS_VALID_METHOD(pcistr, Read) &&
          IS_VALID_METHOD(pcistr, Write) &&
          IS_VALID_METHOD(pcistr, Seek) &&
          IS_VALID_METHOD(pcistr, SetSize) &&
          IS_VALID_METHOD(pcistr, CopyTo) &&
          IS_VALID_METHOD(pcistr, Commit) &&
          IS_VALID_METHOD(pcistr, Revert) &&
          IS_VALID_METHOD(pcistr, LockRegion) &&
          IS_VALID_METHOD(pcistr, UnlockRegion) &&
          IS_VALID_METHOD(pcistr, Stat) &&
          IS_VALID_METHOD(pcistr, Clone));
}


BOOL IsValidPCIUnknown(PCIUnknown pciunk)
{
   return(IS_VALID_READ_PTR(pciunk, CIUnknown) &&
          IS_VALID_READ_PTR(pciunk->lpVtbl, sizeof(*(pciunk->lpVtbl))) &&
          IS_VALID_METHOD(pciunk, QueryInterface) &&
          IS_VALID_METHOD(pciunk, AddRef) &&
          IS_VALID_METHOD(pciunk, Release));
}


#ifdef __INTSHCUT_H__

BOOL IsValidPCIUniformResourceLocator(
                                             PCIUniformResourceLocator pciurl)
{
   return(IS_VALID_READ_PTR(pciurl, CIUniformResourceLocator) &&
          IS_VALID_READ_PTR(pciurl->lpVtbl, sizeof(*(pciurl->lpVtbl))) &&
          IS_VALID_INTERFACE_PTR((PCIUnknown)pciurl, IUnknown) &&
          IS_VALID_METHOD(pciurl, SetURL) &&
          IS_VALID_METHOD(pciurl, GetURL) &&
          IS_VALID_METHOD(pciurl, InvokeCommand));
}

#endif   /* __INTSHCUT_H__ */

#endif   /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\nmhelp.cpp ===
// File: nmhelp.cpp

#include <precomp.h>

#ifndef UNICODE

#include <nmhelp.h>
#include <htmlhelp.h>
#include <strutil.h>
#include <intlutil.h>

extern BOOL g_fUseMLHelp;

// The main NetMeeting Help file
static const TCHAR s_cszWinHelpFile[]  = TEXT("conf.hlp");

static const TCHAR g_pszHHCtrl[] = TEXT("hhctrl.ocx");

static const TCHAR g_szSHLWAPI[] = TEXT("shlwapi.dll");
const LPCSTR szMLWinHelpA = (LPCSTR)395;
const LPCSTR szMLHtmlHelpA = (LPCSTR)396;
const LPCSTR szMLWinHelpW = (LPCSTR)397;
const LPCSTR szMLHtmlHelpW = (LPCSTR)398;

typedef BOOL (WINAPI * PFN_MLWinHelpA)(HWND hwndCaller, LPCSTR lpszHelp, UINT uCommand, DWORD_PTR dwData);
typedef HWND (WINAPI * PFN_MLHtmlHelpA)(HWND hwndCaller, LPCSTR pszFile, UINT uCommand, DWORD_PTR dwData, DWORD dwCrossCodePage);
typedef BOOL (WINAPI * PFN_MLWinHelpW)(HWND hwndCaller, LPCWSTR lpszHelp, UINT uCommand, DWORD_PTR dwData);
typedef HWND (WINAPI * PFN_MLHtmlHelpW)(HWND hwndCaller, LPCWSTR pszFile, UINT uCommand, DWORD_PTR dwData, DWORD dwCrossCodePage);

#ifdef UNICODE
#define szMLWinHelp szMLWinHelpW
#define szMLHtmlHelp szMLHtmlHelpW
#define PFN_MLWinHelp PFN_MLWinHelpW
#define PFN_MLHtmlHelp PFN_MLHtmlHelpW
#else
#define szMLWinHelp szMLWinHelpA
#define szMLHtmlHelp szMLHtmlHelpA
#define PFN_MLWinHelp PFN_MLWinHelpA
#define PFN_MLHtmlHelp PFN_MLHtmlHelpA
#endif

extern "C"
HWND HtmlHelpA(HWND hwndCaller, LPCSTR pszFile, UINT uCommand, DWORD_PTR dwData)
{
	static HMODULE g_hmodHHCtrl = NULL;
	static HWND (WINAPI *g_pHtmlHelpA)(HWND hwndCaller, LPCSTR pszFile, UINT uCommand, DWORD_PTR dwData);

	if (NULL == g_hmodHHCtrl)
	{
		g_hmodHHCtrl = LoadLibrary(g_pszHHCtrl);
		if (NULL == g_hmodHHCtrl)
		{
			return NULL;
		}
	}

#ifndef _WIN64
	if (NULL == g_pHtmlHelpA)
	{
		(FARPROC&)g_pHtmlHelpA = GetProcAddress(g_hmodHHCtrl, ATOM_HTMLHELP_API_ANSI);
		if (NULL == g_pHtmlHelpA)
		{
			return NULL;
		}
	}

	return g_pHtmlHelpA(hwndCaller, pszFile, uCommand, dwData);
#else
	return NULL;
#endif
}


/*  N M  W I N  H E L P  */
/*-------------------------------------------------------------------------
    %%Function: NmWinHelp

-------------------------------------------------------------------------*/
BOOL NmWinHelp(HWND hWndMain, LPCTSTR lpszHelp, UINT uCommand, DWORD_PTR dwData)
{
	static PFN_MLWinHelp s_pfnMLWinHelp = NULL;

	if (g_fUseMLHelp && (NULL == s_pfnMLWinHelp))
	{
		HINSTANCE hLib = LoadLibrary(g_szSHLWAPI);
		if (hLib)
		{
			s_pfnMLWinHelp = (PFN_MLWinHelp)GetProcAddress(hLib, szMLWinHelp);
			if (NULL == s_pfnMLWinHelp)
			{
				// must be wrong version of shlwapi.dll
				FreeLibrary(hLib);
				g_fUseMLHelp = FALSE;
			}
		}
		else
		{
			// cannot find shlwapi.dll
			g_fUseMLHelp = FALSE;
		}
	}

	if (NULL != s_pfnMLWinHelp)
	{
		return s_pfnMLWinHelp(hWndMain, lpszHelp, uCommand, dwData);
	}
	else
	{
		return ::WinHelp(hWndMain, lpszHelp, uCommand, dwData);
	}
}


/*  N M  H T M L  H E L P  */
/*-------------------------------------------------------------------------
    %%Function: NmHtmlHelp

-------------------------------------------------------------------------*/
HWND NmHtmlHelp(HWND hwndCaller, LPCSTR pszFile, UINT uCommand, DWORD_PTR dwData)
{
	static PFN_MLHtmlHelp s_pfnMLHtmlHelp = NULL;

	if (g_fUseMLHelp && (NULL == s_pfnMLHtmlHelp))
	{
		HINSTANCE hLib = LoadLibrary(g_szSHLWAPI);
		if (hLib)
		{
			s_pfnMLHtmlHelp = (PFN_MLHtmlHelp)GetProcAddress(hLib, szMLHtmlHelp);
			if (NULL == s_pfnMLHtmlHelp)
			{
				// must be wrong version of shlwapi.dll
				FreeLibrary(hLib);
				g_fUseMLHelp = FALSE;
			}
		}
		else
		{
			// cannot find shlwapi.dll
			g_fUseMLHelp = FALSE;
		}
	}

	if (NULL != s_pfnMLHtmlHelp)
	{
		return s_pfnMLHtmlHelp(hwndCaller, pszFile, uCommand, dwData, 0);
	}
	else
	{
		return ::HtmlHelp(hwndCaller, pszFile, uCommand, dwData);
	}
}



static const TCHAR s_cszHtmlHelpApiMarshalerWndClass[] = TEXT("NmUtil_HtmlHelpMarshalWnd");


	// HtmlHelp api cannot be called from multiple threads... that is, HtmlHelp must be
	// called from the same thread in which the DLL is loaded... This is the non-threadsafe
	// entry point to HtmlHelp... this must allways be called in the same thread that
	// InitHtmlHelpMarshaller was called....

	// This is the window procedure that we use to marshall calls to
	// HtmlHelp via calls to ShowNmHelp from arbitrary threads
static LRESULT CALLBACK HtmlHelpWndProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
	switch( uMsg )
	{
		case WM_USER:
		{
			LPCTSTR lpcszHelpFile = reinterpret_cast<LPCTSTR>(lParam);
			NmHtmlHelp(NULL, lpcszHelpFile, HH_DISPLAY_TOPIC, 0);
			return(TRUE);
		}
	}

	return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

	// the html help Apis are not threadsafe...
	// In fact, they call CoInitialize in the DLLProcessAttatch...
	// So essentially we are going to marshal all calls to HtmlHelp
	// Into the context of the first thread to call InitHtmlHelpMarshaller
HRESULT InitHtmlHelpMarshaler(HINSTANCE hInst)
{
	HRESULT hr = S_OK;

	WNDCLASS wc;
	ZeroMemory( &wc, sizeof( wc ) );

	wc.lpfnWndProc = HtmlHelpWndProc;
	wc.hInstance = hInst;
	wc.lpszClassName = s_cszHtmlHelpApiMarshalerWndClass;

	if( RegisterClass( &wc ) )
	{
		HWND hWnd = CreateWindow(s_cszHtmlHelpApiMarshalerWndClass, NULL, 0, 0, 0, 0, NULL, NULL, NULL, hInst, 0 );
		if( NULL == hWnd )
		{
			ERROR_OUT(("CreateWindow failed in InitHtmlHelpMarshaler"));
			hr = HRESULT_FROM_WIN32(GetLastError());
		}
	}
	else
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
	}

	return hr;
}


VOID ShowNmHelp(LPCTSTR lpcszHtmlHelpFile)
{
	HWND hWnd = FindWindow( s_cszHtmlHelpApiMarshalerWndClass, NULL );
	if( hWnd )
	{
		SendMessage( hWnd, WM_USER, 0, reinterpret_cast<LPARAM>(lpcszHtmlHelpFile) );
	}
	else
	{
		ERROR_OUT(("Could not find the Help Marshaller Window... Has InitHtmlHelpMarshaller been called yet?"));
	}
}


/*  D O  N M  H E L P  */
/*-------------------------------------------------------------------------
    %%Function: DoNmHelp

    Generic routine to display the normal WinHelp information.
-------------------------------------------------------------------------*/
VOID DoNmHelp(HWND hwnd, UINT uCommand, DWORD_PTR dwData)
{
	NmWinHelp(hwnd, s_cszWinHelpFile, uCommand, dwData);
}

// "WM_HELP" context menu handler (requires HIDC_* entry on the controls)
VOID DoHelp(LPARAM lParam)
{
	LPHELPINFO phi = (LPHELPINFO) lParam;
	ASSERT(phi->iContextType == HELPINFO_WINDOW);
	DoNmHelp((HWND) phi->hItemHandle, HELP_CONTEXTPOPUP, phi->dwContextId);
}

// "WM_HELP" handler (with control-to-help id map)
VOID DoHelp(LPARAM lParam, const DWORD * rgId)
{
	HWND hwnd = (HWND)(((LPHELPINFO)lParam)->hItemHandle);
	DoNmHelp(hwnd, HELP_WM_HELP, (DWORD_PTR) rgId);
}

// "WM_CONTEXTMENU" handler (with control-to-help id map)
VOID DoHelpWhatsThis(WPARAM wParam, const DWORD * rgId)
{
	HWND hwnd = (HWND)wParam;
	DoNmHelp(hwnd, HELP_CONTEXTMENU, (DWORD_PTR) rgId);
}


VOID ShutDownHelp(void)
{
	DoNmHelp(NULL, HELP_QUIT, 0);
	// REVIEW: Do we shut down HTML help as well?
}


#endif /* UNICODE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\oblist.cpp ===
// ChrisPi: This is a quick attempt to create a list class that uses the
// same member functions and parameters as MFC's CObList.  Only the members
// used in DCL's master objects are implemented.

#include "precomp.h"
#include <oblist.h>

#ifdef DEBUG
VOID* COBLIST::GetHead()
{
	ASSERT(m_pHead);

	return m_pHead->pItem;
}
#endif // ifdef DEBUG
   
VOID* COBLIST::GetTail()
{
	ASSERT(m_pTail);

	return m_pTail->pItem;
}

VOID* COBLIST::GetNext(POSITION& rPos)
{
	ASSERT(rPos);
	
	VOID* pReturn = rPos->pItem;
	rPos = rPos->pNext;

	return pReturn;
}

VOID* COBLIST::RemoveAt(POSITION Pos)
{
	VOID* pReturn = NULL;

	if (m_pHead)
	{
		if (m_pHead == Pos)
		{
			// Removing the first element in the list
			
			m_pHead = Pos->pNext;
			pReturn = Pos->pItem;
			delete Pos;

			if (NULL == m_pHead)
			{
				// Removing the only element!
				m_pTail = NULL;
			}
		}
		else
		{
			POSITION pCur = m_pHead;

			while (pCur && pCur->pNext)
			{
				if (pCur->pNext == Pos)
				{
					// Removing 
					
					pCur->pNext = Pos->pNext;
					if (m_pTail == Pos)
					{
						m_pTail = pCur;
					}
					pReturn = Pos->pItem;
					delete Pos;
				}

				pCur = pCur->pNext;
			}
		}
	}

	return pReturn;
}

POSITION COBLIST::AddTail(VOID* pItem)
{
	POSITION posRet = NULL;

	if (m_pTail)
	{
		if (m_pTail->pNext = new COBNODE)
		{
			m_pTail = m_pTail->pNext;
			m_pTail->pItem = pItem;
			m_pTail->pNext = NULL;
		}
	}
	else
	{
		ASSERT(!m_pHead);
		if (m_pHead = new COBNODE)
		{
			m_pTail = m_pHead;
			m_pTail->pItem = pItem;
			m_pTail->pNext = NULL;
		}
	}

	return m_pTail;
}

void COBLIST::EmptyList()
{
    while (!IsEmpty()) {
        RemoveAt(GetHeadPosition());
    }
}

COBLIST::~COBLIST()
{
    ASSERT(IsEmpty());
}

#ifdef DEBUG

#if 0
VOID* COBLIST::RemoveTail()
{
	ASSERT(m_pHead);
	ASSERT(m_pTail);
	
	return RemoveAt(m_pTail);
}
#endif

VOID* COBLIST::RemoveHead()
{
	ASSERT(m_pHead);
	ASSERT(m_pTail);
	
	return RemoveAt(m_pHead);
}

void * COBLIST::GetFromPosition(POSITION Pos)
{
    void * Result = SafeGetFromPosition(Pos);
	ASSERT(Result);
	return Result;
}
#endif /* if DEBUG */

POSITION COBLIST::GetPosition(void* _pItem)
{
    // For potential efficiency of lookup (if we switched to 
    // a doubly linked list), users should really store the POSITION
    // of an item. For those that don't, this method is provided.

    POSITION    Position = m_pHead;

    while (Position) {
        if (Position->pItem == _pItem) {
            break;
        }
		GetNext(Position);
    }
    return Position;
}

POSITION COBLIST::Lookup(void* pComparator)
{
    POSITION    Position = m_pHead;

    while (Position) {
        if (Compare(Position->pItem, pComparator)) {
            break;
        }
		GetNext(Position);
    }
    return Position;
}

void * COBLIST::SafeGetFromPosition(POSITION Pos)
{
	// Safe way to validate that an entry is still in the list,
	// which ensures bugs that would reference deleted memory,
	// reference a NULL pointer instead
	// (e.g. an event handler fires late/twice).
	// Note that versioning on entries would provide an additional 
	// safeguard against re-use of a position.
	// Walk	list to find entry.

	POSITION PosWork = m_pHead;
	
	while (PosWork) {
		if (PosWork == Pos) {
			return Pos->pItem;
		}
		GetNext(PosWork);
	}
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\oprahcom.cpp ===
#include "precomp.h"
#include <RegEntry.h>
#include <ConfReg.h>
#include <oprahcom.h>


BOOL NMINTERNAL CanShellExecHttp()
{
	RegEntry re(CLASSES_HTTP_KEY, HKEY_LOCAL_MACHINE, FALSE);
	return (re.GetError() == ERROR_SUCCESS);
}

BOOL NMINTERNAL CanShellExecMailto()
{
	RegEntry re(CLASSES_MAILTO_KEY, HKEY_LOCAL_MACHINE, FALSE);
	return (re.GetError() == ERROR_SUCCESS);
}



/*  G E T  I N S T A L L  D I R E C T O R Y */
/*----------------------------------------------------------------------------
    %%Function: GetInstallDirectory
 
	Return TRUE if the installation directory was read from the registry.
	The string is set empty if the function fails and returns FALSE.
	The buffer pointed to by psz is assumed to be at least MAX_PATH characters.
	Note that the name is always terminated with a final backslash.
----------------------------------------------------------------------------*/
BOOL NMINTERNAL GetInstallDirectory(LPTSTR psz)
{
	RegEntry reInstall(CONFERENCING_KEY, HKEY_LOCAL_MACHINE);

	ASSERT(NULL != psz);
	lstrcpyn(psz, reInstall.GetString(REGVAL_INSTALL_DIR), MAX_PATH);
	if (_T('\0') == *psz)
		return FALSE; // No registry entry was found

	// Make sure the directory name has a trailing '\'
	// BUGBUG - Don't call CharNext twice in each iteration
	for ( ; _T('\0') != *psz; psz = CharNext(psz))
	{
		if ((_T('\\') == *psz) && (_T('\0') == *CharNext(psz)) )
		{
			// The path already ends with a backslash
			return TRUE;
		}
	}

	// Append a trailing backslash
	// BUGBUG - Can't we just append the char in place with an assignment?
	lstrcat(psz, _TEXT("\\"));
	return TRUE;
}



/*  F  F I L E  E X I S T S */
/*-------------------------------------------------------------------------
	%%Function: FFileExists

	Return TRUE if the file exists and can be read & written.
-------------------------------------------------------------------------*/
BOOL NMINTERNAL FFileExists(LPCTSTR szFile)
{
	HANDLE hFile;

	if ((NULL == szFile) || (_T('\0') == *szFile))
		return FALSE;

	UINT uErrorMode = SetErrorMode(SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS);
	hFile = CreateFile(szFile, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	SetErrorMode(uErrorMode); // Restore error mode

	if (hFile == INVALID_HANDLE_VALUE)
		return FALSE;

	CloseHandle(hFile);
	return TRUE;
}


/*  F  D I R  E X I S T S  */
/*-------------------------------------------------------------------------
    %%Function: FDirExists

    Return TRUE if the directory exists.
-------------------------------------------------------------------------*/
BOOL NMINTERNAL FDirExists(LPCTSTR szDir)
{
	UINT uErrorMode = SetErrorMode(SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS);
	DWORD dwFa = GetFileAttributes(szDir);
	SetErrorMode(uErrorMode); // Restore error mode

	if (0xFFFFFFFF == dwFa)
		return FALSE;

	return (0 != (dwFa & FILE_ATTRIBUTE_DIRECTORY));
}


/*  F  E N S U R E  D I R  E X I S T S */
/*-------------------------------------------------------------------------
	%%Function: FEnsureDirExists

	Ensure the Directory exists, creating the entire path if necessary.
	Returns FALSE if there was a problem.
-------------------------------------------------------------------------*/
BOOL NMINTERNAL FEnsureDirExists(LPCTSTR szDir)
{
	TCHAR   szPath[MAX_PATH+1];
	TCHAR * pszDirEnd;
	TCHAR * pszDirT;

	ASSERT(lstrlen(szDir) < MAX_PATH);

	if (FDirExists(szDir))
		return TRUE;  // Nothing to do - already exists

	// Work with a copy of the path
	lstrcpy(szPath, szDir);

	for(pszDirT = szPath, pszDirEnd = &szPath[lstrlen(szPath)];
		pszDirT <= pszDirEnd;
		pszDirT = CharNext(pszDirT))
	{
		if ((*pszDirT == _T('\\')) || (pszDirT == pszDirEnd))
		{
			*pszDirT = _T('\0');
			if (!FDirExists(szPath))
			{
				UINT uErrorMode = SetErrorMode(SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS);
				BOOL fOk = CreateDirectory(szPath, NULL);
				SetErrorMode(uErrorMode); // Restore error mode
				if (!fOk)
					return FALSE;
			}
			*pszDirT = _T('\\');
		}
	}

	TRACE_OUT(("Created Directory [%s]", szDir));
	return TRUE;
}



/*  E X T R A C T  F I L E  N A M E  */
/*-------------------------------------------------------------------------
    %%Function: ExtractFileName, ExtractFileNameA

	Extracts the file name from a path name.
	Returns a pointer to file name in path string.
-------------------------------------------------------------------------*/
LPCTSTR NMINTERNAL ExtractFileName(LPCTSTR pcszPathName)
{
	LPCTSTR pcszLastComponent;
	LPCTSTR pcsz;

	ASSERT(IS_VALID_STRING_PTR(pcszPathName, CSTR));

	for (pcszLastComponent = pcsz = pcszPathName;
		*pcsz;
		pcsz = CharNext(pcsz))
	{
		if (IS_SLASH(*pcsz) || *pcsz == COLON)
			pcszLastComponent = CharNext(pcsz);
	}

	ASSERT(IsValidPath(pcszLastComponent));

	return(pcszLastComponent);
}

#if defined(UNICODE)
LPCSTR NMINTERNAL ExtractFileNameA(LPCSTR pcszPathName)
{
	LPCSTR pcszLastComponent;
	LPCSTR pcsz;

	ASSERT(IS_VALID_STRING_PTR_A(pcszPathName, CSTR));

	for (pcszLastComponent = pcsz = pcszPathName;
		*pcsz;
		pcsz = CharNextA(pcsz))
	{
		if (IS_SLASH(*pcsz) || *pcsz == COLON)
			pcszLastComponent = CharNextA(pcsz);
	}

	ASSERT(IsValidPathA(pcszLastComponent));

	return(pcszLastComponent);
}
#endif // defined(UNICODE)

/*  S A N I T I Z E  F I L E  N A M E  */
/*-------------------------------------------------------------------------
    %%Function: SanitizeFileName

-------------------------------------------------------------------------*/
BOOL NMINTERNAL SanitizeFileName(LPTSTR psz)
{
	if (NULL == psz)
		return FALSE;

	while (*psz)
	{
		switch (*psz)
			{
		case _T('\\'):
		case _T('\"'):
		case _T('/'):
		case _T(':'):
		case _T('*'):
		case _T('?'):
		case _T('<'):
		case _T('>'):
		case _T('|'):
			*psz = _T('_');
		default:
			break;
			}

		psz = ::CharNext(psz);
	}

	return TRUE;
}
///////////////////////////////////////////////////////////////////////////

/*  C R E A T E  N E W  F I L E */
/*----------------------------------------------------------------------------
    %%Function: CreateNewFile

	Attempt to create a new file.
	Note this returns either 0 (success)
	or the result from GetLastError (usually ERROR_FILE_EXISTS)
----------------------------------------------------------------------------*/
DWORD CreateNewFile(LPTSTR pszFile)
{
	DWORD  errRet;
	HANDLE hFile;

	if (lstrlen(pszFile) >= MAX_PATH)
	{
		// don't allow long path/filenames
		return 1;
	}

	SetLastError(0);

	UINT uErrorMode = SetErrorMode(SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS);
	hFile = CreateFile(pszFile, GENERIC_READ | GENERIC_WRITE, 0,
		NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
	SetErrorMode(uErrorMode); // Restore error mode

	errRet = GetLastError();

	if (hFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(hFile);
	}

	return errRet;
}



/*  F  C R E A T E  N E W  F I L E  */
/*-------------------------------------------------------------------------
    %%Function: FCreateNewFile

    Create a new file in a directory, with a name and extension.
   	Returns the full path name in the buffer.
-------------------------------------------------------------------------*/
BOOL FCreateNewFile(LPCTSTR pcszPath, LPCTSTR pcszName, LPCTSTR pcszExt, LPTSTR pszResult, int cchMax)
{
	TCHAR szFile[MAX_PATH*2];

	lstrcpy(szFile, pcszPath);
	if (!FEnsureDirName(szFile))
		return FALSE;
	
	LPTSTR psz = szFile + lstrlen(szFile);
	lstrcpy(psz, pcszName);
	SanitizeFileName(psz);
	lstrcat(psz, pcszExt);

	DWORD dwErr = CreateNewFile(szFile);
	if (0 != dwErr)
	{
		// Create a duplicate filename
		psz += lstrlen(pcszName);
		for (int iFile = 2; iFile < 999; iFile++)
		{
			wsprintf(psz, TEXT(" (%d).%s"), iFile, pcszExt);
			if (ERROR_FILE_EXISTS != (dwErr = CreateNewFile(szFile)) )
				break;
		}

		if (0 != dwErr)
		{
			WARNING_OUT(("Unable to create duplicate filename (err=%d)", dwErr));
			return FALSE;
		}
	}

	if (cchMax > lstrlen(szFile))
	{
		lstrcpy(pszResult, szFile);
	}
	else
	{
		// try and make the full name fit within the buffer
		dwErr = GetShortPathName(szFile, pszResult, cchMax);
		if ((0 == dwErr) || (dwErr >= MAX_PATH))
			return FALSE;
	}

	return TRUE;
}


/*  F  E N S U R E  D I R  N A M E  */
/*-------------------------------------------------------------------------
    %%Function: FEnsureDirName
    
-------------------------------------------------------------------------*/
BOOL FEnsureDirName(LPTSTR pszPath)
{
	if (NULL == pszPath)
		return FALSE;

	LPTSTR pszCurr = pszPath;

	// Make sure the directory name has a trailing '\'
	for ( ; ; )
	{
		LPTSTR pszNext = CharNext(pszCurr);
		if (*pszNext == _T('\0'))
		{
			if (_T('\\') != *pszCurr)
			{
				*pszNext++ = _T('\\');
				*pszNext = _T('\0');
			}
			break;
		}
		pszCurr = pszNext;
	}

	return FEnsureDirExists(pszPath);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\purecall.cpp ===
#include "precomp.h"

// Handle errors referencing an object's virtual function table.
// This should never happen!

int _cdecl _purecall(void)
{
	ASSERT(FALSE);
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\referenc.cpp ===
#include "precomp.h"
#include "referenc.h"

REFCOUNT::REFCOUNT() :
	NumRefs(0),
	bMarkedForDelete(FALSE),
	bOnStack(FALSE)
{
}

REFCOUNT::~REFCOUNT()
{
	// Objects being destroyed should have no
	// outstanding references to them and should
	// have been explicitly deleted.

	ASSERT(NumRefs == 0);
	ASSERT(bOnStack || bMarkedForDelete);
}

DWORD REFCOUNT::AddRef()
{
	NumRefs++;
	return(NumRefs);
}

DWORD REFCOUNT::Release()
{
	ASSERT(NumRefs);

    DWORD   CurrentNumRefs = --NumRefs; // Save because object may be deleted

	if(!CurrentNumRefs) {
		if(bMarkedForDelete) {
            if (!bOnStack) {
			    delete this;
            }
		}
	}
    return CurrentNumRefs;
}

DWORD REFCOUNT::Delete()
{
    DWORD   CurrentNumRefs = NumRefs; // Save because object may be deleted
	REFERENCE	r(this);

	bMarkedForDelete = TRUE;
    return(CurrentNumRefs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\strtohex.cpp ===
// STRTOHEX.CPP
//
// Utility functions to convert string representations of hexadecimal numbers
// into the numbers themselves.
//
// Note:  These functions are in their own file, rather than in STRUTIL.CPP, 
// because they use a const array.  The current implementation of the linker
// pulls this array into binaries if they use any function in the source file,
// not just the functions which reference this array.

#include "precomp.h"
#include <strutil.h>


// This array maps ASCII chars in the range '0' - 'f' to their hex equivalent.
// INVALID_CHAR_ID is used to mark slots that don't correspond to a valid
// hex char.
const BYTE INVALID_CHAR_ID = (BYTE) -1;

const BYTE rgbHexCharMap[] =
{	
	// ASCII 0x30 - 0x3f
	0, 1, 2, 3, 
	4, 5, 6, 7, 
	8, 9, INVALID_CHAR_ID, INVALID_CHAR_ID,
	INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID,
	// ASCII 0x40 - 0x4f
	INVALID_CHAR_ID, 0xA, 0xB, 0xC, 
	0xD, 0xE, 0xF, INVALID_CHAR_ID, 
	INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID,
	INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID,
	// ASCII 0x50 - 0x5f
	INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID,
	INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID,
	INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID,
	INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID, INVALID_CHAR_ID,
	// ASCII 0x60 - 0x67
	INVALID_CHAR_ID, 0xa, 0xb, 0xc, 
	0xd, 0xe, 0xf, INVALID_CHAR_ID
};

const int cbHexCharMap = ARRAY_ELEMENTS(rgbHexCharMap);


//
// HexStringToQWordA()
//
// Converts a hex ANSI string (without 0x or 0X prefix) to a ULARGE_INTEGER
//
// NOTE: The a-f characters can be lowercase or uppercase
//
// Returns TRUE if successful (the string contained all valid characters)
// Returns FALSE otherwise
//

BOOL NMINTERNAL HexStringToQWordA(LPCSTR pcszString, ULARGE_INTEGER* pqw)
{
	BOOL bRet;
	ASSERT(pcszString);
	ASSERT(pqw);
	pqw->QuadPart = 0ui64;
	int cchStr = lstrlenA(pcszString);
	if (cchStr <= CCH_HEX_QWORD)
	{
		bRet = TRUE;
		PDWORD pdwCur = (cchStr < CCH_HEX_DWORD) ? &(pqw->LowPart) : &(pqw->HighPart);
		for (int i = 0; i < cchStr; i++)
		{
			// NOTE: DBCS characters are not allowed
			ASSERT(! IsDBCSLeadByte(pcszString[i]));

			if (CCH_HEX_DWORD == (cchStr - i))
			{
				pdwCur = &(pqw->LowPart);
			}
			DWORD dwDigit = (DWORD) INVALID_CHAR_ID;
			int iDigit = pcszString[i] - '0';

			if (iDigit >= 0 && iDigit < cbHexCharMap)
			{
				dwDigit = (DWORD) rgbHexCharMap[iDigit];
			}

			if (INVALID_CHAR_ID != dwDigit)
			{
				*pdwCur = ((*pdwCur) << BITS_PER_HEX_CHAR) + dwDigit;
			}
			else
			{
				bRet = FALSE;
				break;
			}
		}
	}
	else
	{
		bRet = FALSE;
	}
	return bRet;
}


/*  D W  F R O M  H E X  */
/*-------------------------------------------------------------------------
    %%Function: DwFromHex

    Return the DWORD from the hex string.
-------------------------------------------------------------------------*/
DWORD DwFromHex(LPCTSTR pchHex)
{
	TCHAR ch;
	DWORD dw = 0;

	while (_T('\0') != (ch = *pchHex++))
	{

		DWORD dwDigit = (DWORD) INVALID_CHAR_ID;
		int iDigit = ch - _T('0');

		if (iDigit >= 0 && iDigit < cbHexCharMap)
		{
			dwDigit = (DWORD) rgbHexCharMap[iDigit];
		}

		if (INVALID_CHAR_ID != dwDigit)
		{
			dw = (dw << 4) + dwDigit;
		}
		else
			break;
	}

	return dw;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\toolbar.cpp ===
// File: Toolbar.cpp

#include "precomp.h"

#include "GenContainers.h"
#include "GenControls.h"

#include <windowsx.h>

// Minimum size for children;
// BUGBUG georgep; Should probably set this to 0 after debugging
const static int MinSize = 10;

// Default m_gap
const static int HGapSize = 4;
// Default m_hMargin
const static int HMargin = 0;
// Default m_vMargin
const static int VMargin = 0;

// Init m_uRightIndex and m_uCenterIndex to very large numbers
CToolbar::CToolbar() :
	m_gap(HGapSize),
	m_hMargin(HMargin),
	m_vMargin(VMargin),
	m_nAlignment(TopLeft),
	m_uRightIndex(static_cast<UINT>(-1)),
	m_bHasCenterChild(FALSE),
	m_bReverseOrder(FALSE),
	m_bMinDesiredSize(FALSE),
	m_bVertical(FALSE)
{
}

BOOL CToolbar::Create(
	HWND hWndParent,	// The parent of the toolbar window
	DWORD dwExStyle		// The extended style of the toolbar window
	)
{
	return(CGenWindow::Create(
		hWndParent,		// Window parent
		0,				// ID of the child window
		TEXT("NMToolbar"),	// Window name
		WS_CLIPCHILDREN,			// Window style; WS_CHILD|WS_VISIBLE will be added to this
		dwExStyle|WS_EX_CONTROLPARENT		// Extended window style
		));
}

// Get the desired size for a child, and make sure it is big enough
static void GetWindowDesiredSize(HWND hwnd, SIZE *ppt)
{
	ppt->cx = ppt->cy = 0;

	IGenWindow *pWnd = CGenWindow::FromHandle(hwnd);
	if (NULL != pWnd)
	{
		pWnd->GetDesiredSize(ppt);
	}

	ppt->cx = max(ppt->cx, MinSize);
	ppt->cy = max(ppt->cy, MinSize);
}

BOOL IsChildVisible(HWND hwndChild)
{
	return((GetWindowLong(hwndChild, GWL_STYLE)&WS_VISIBLE) == WS_VISIBLE);
}

/** Get the total desired size of the child windows: max of heights and sum of
 * widths or vice versa for vertical windows.
 * @param hwndParent The window whose children are to be examined
 * @param size The returned total size
 * @param bVertical Whether to flow vertical or horizontal
 * @returns The number of visible child windows
 */
static int GetChildTotals(HWND hwndParent, SIZE *size, BOOL bVertical)
{
	int nChildren = 0;
	int xMax=0, xTot=0;
	int yMax=0, yTot=0;

	for (HWND hwndChild=::GetWindow(hwndParent, GW_CHILD); NULL!=hwndChild;
		hwndChild=::GetWindow(hwndChild, GW_HWNDNEXT))
	{
		if (!IsChildVisible(hwndChild))
		{
			continue;
		}
		++nChildren;

		SIZE pt;
		GetWindowDesiredSize(hwndChild, &pt);

		xTot += pt.cx;
		yTot += pt.cy;
		if (xMax < pt.cx) xMax = pt.cx;
		if (yMax < pt.cy) yMax = pt.cy;
	}

	if (bVertical)
	{
		size->cx = xMax;
		size->cy = yTot;
	}
	else
	{
		size->cx = xTot;
		size->cy = yMax;
	}

	return(nChildren);
}

// Returns the total children desired size, plus the gaps and margins.
void CToolbar::GetDesiredSize(SIZE *ppt)
{
	int nChildren = GetChildTotals(GetWindow(), ppt, m_bVertical);

	if (nChildren > 1 && !m_bMinDesiredSize)
	{
		if (m_bVertical)
		{
			ppt->cy += (nChildren-1) * m_gap;
		}
		else
		{
			ppt->cx += (nChildren-1) * m_gap;
		}
	}

	ppt->cx += m_hMargin * 2;
	ppt->cy += m_vMargin * 2;

	SIZE sizeTemp;
	CGenWindow::GetDesiredSize(&sizeTemp);
	ppt->cx += sizeTemp.cx;
	ppt->cy += sizeTemp.cy;
}

void CToolbar::AdjustPos(POINT *pPos, SIZE *pSize, UINT width)
{
	pPos->x = pPos->y = 0;

	switch (m_nAlignment)
	{
	default:
	case TopLeft:
		// Nothing to do
		break;

	case Center:
		if (m_bVertical)
		{
			pPos->x = (width - pSize->cx)/2;
		}
		else
		{
			pPos->y = (width - pSize->cy)/2;
		}
		break;

	case BottomRight:
		if (m_bVertical)
		{
			pPos->x = (width - pSize->cx);
		}
		else
		{
			pPos->y = (width - pSize->cy);
		}
		break;

	case Fill:
		if (m_bVertical)
		{
			pSize->cx = width;
		}
		else
		{
			pSize->cy = width;
		}
		break;
	}
}

// Get the first child to layout
HWND CToolbar::GetFirstKid()
{
	HWND ret = ::GetWindow(GetWindow(), GW_CHILD);
	if (m_bReverseOrder && NULL != ret)
	{
		ret = ::GetWindow(ret, GW_HWNDLAST);
	}

	return(ret);
}

// Get the next child to layout
HWND CToolbar::GetNextKid(HWND hwndCurrent)
{
	return(::GetWindow(hwndCurrent, m_bReverseOrder ? GW_HWNDPREV : GW_HWNDNEXT));
}

extern HDWP SetWindowPosI(HDWP hdwp, HWND hwndChild, int left, int top, int width, int height);

// Flow child windows according to the fields
void CToolbar::Layout()
{
	RECT rc;
	GetClientRect(GetWindow(), &rc);

	// First see how much extra space we have
	SIZE sizeTotal;
	int nChildren = GetChildTotals(GetWindow(), &sizeTotal, m_bVertical);
	if (0 == nChildren)
	{
		// No children, so nothing to layout
		return;
	}

	// Add on the margins
	sizeTotal.cx += 2*m_hMargin;
	sizeTotal.cy += 2*m_vMargin;

	if (nChildren > 1 || !m_bHasCenterChild)
	{
		// Don't layout with children overlapping
		rc.right  = max(rc.right , sizeTotal.cx);
		rc.bottom = max(rc.bottom, sizeTotal.cy);
	}

	// Calculate the total gaps between children
	int tGap = m_bVertical ? rc.bottom - sizeTotal.cy : rc.right - sizeTotal.cx;
	int maxGap = (nChildren-1)*m_gap;
	if (tGap > maxGap) tGap = maxGap;
	tGap = max(tGap, 0); // This can happen if only a center child

	// If we fill, then children in a vertical toolbar go from the left to the
	// right margin, and similar for a horizontal toolbar
	int fill = m_bVertical ? rc.right-2*m_hMargin : rc.bottom-2*m_vMargin;

	// Speed up layout by deferring it
	HDWP hdwp = BeginDeferWindowPos(nChildren);

	HWND hwndChild;
	UINT nChild = 0;

	// Iterate through the children
	UINT uCenterIndex = m_bHasCenterChild ? m_uRightIndex-1 : static_cast<UINT>(-1);
	// We need to keep track of whether the middle was skipped in case the
	// center control or the first right-aligned control is hidden
	BOOL bMiddleSkipped = FALSE;

	// Do left/top-aligned children
	// The starting point for laying out children
	int left = m_hMargin;
	int top  = m_vMargin;

	for (hwndChild=GetFirstKid(); NULL!=hwndChild;
		hwndChild=GetNextKid(hwndChild), ++nChild)
	{
		if (!IsChildVisible(hwndChild))
		{
			continue;
		}

		SIZE size;
		GetWindowDesiredSize(hwndChild, &size);

		if (nChild == uCenterIndex)
		{
			// Take the window size, subtract all the gaps, and subtract the
			// desired size of everybody but this control. That should give
			// the "extra" area in the middle
			if (m_bVertical)
			{
				size.cy = rc.bottom - tGap - (sizeTotal.cy - size.cy);
			}
			else
			{
				size.cx = rc.right  - tGap - (sizeTotal.cx - size.cx);
			}

			bMiddleSkipped = TRUE;
		}
		else if (nChild >= m_uRightIndex && !bMiddleSkipped)
		{
			// Skip the "extra" room in the middle; if there is a centered
			// control, then we have already done this
			if (m_bVertical)
			{
				top += rc.bottom - tGap - sizeTotal.cy;
			}
			else
			{
				left += rc.right - tGap - sizeTotal.cx;
			}

			bMiddleSkipped = TRUE;
		}

		POINT pos;
		AdjustPos(&pos, &size, fill);

		// Move the window
		hdwp = SetWindowPosI(hdwp, hwndChild, pos.x+left, pos.y+top, size.cx, size.cy);

		// calculate the gap; don't just use a "fixed" gap, since children
		// would move in chunks
		int gap = (nChildren<=1) ? 0 : ((tGap * (nChild+1))/(nChildren-1) - (tGap * nChild)/(nChildren-1));

		// Update the pos of the next child
		if (m_bVertical)
		{
			top += gap + size.cy;
		}
		else
		{
			left += gap + size.cx;
		}
	}

	// Actually move all the windows now
	EndDeferWindowPos(hdwp);
}

LRESULT CToolbar::ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
	}

	return(CGenWindow::ProcessMessage(hwnd, message, wParam, lParam));
}

void CToolbar::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
	FORWARD_WM_COMMAND(GetParent(hwnd), id, hwndCtl, codeNotify, SendMessage);
}

static HWND FindControl(HWND hwndParent, int nID)
{
	if (GetWindowLong(hwndParent, GWL_ID) == nID)
	{
		return(hwndParent);
	}

	for (hwndParent=GetWindow(hwndParent, GW_CHILD); NULL!=hwndParent;
		hwndParent=GetWindow(hwndParent, GW_HWNDNEXT))
	{
		HWND ret = FindControl(hwndParent, nID);
		if (NULL != ret)
		{
			return(ret);
		}
	}

	return(NULL);
}

IGenWindow *CToolbar::FindControl(int nID)
{
	HWND hwndRet = ::FindControl(GetWindow(), nID);
	if (NULL == hwndRet)
	{
		return(NULL);
	}

	return(FromHandle(hwndRet));
}

CSeparator::CSeparator() :
	m_iStyle(Normal)
{
	m_desSize.cx = m_desSize.cy = 2;
}

BOOL CSeparator::Create(
	HWND hwndParent, UINT iStyle
	)
{
	m_iStyle = iStyle;
	return(CGenWindow::Create(
		hwndParent,		// Window parent
		0,				// ID of the child window
		TEXT("NMSeparator"),	// Window name
		WS_CLIPCHILDREN,			// Window style; WS_CHILD|WS_VISIBLE will be added to this
		WS_EX_CONTROLPARENT		// Extended window style
	));
}

void CSeparator::GetDesiredSize(SIZE *ppt)
{
	*ppt = m_desSize;

	// Make sure there's room for the child
	HWND child = GetFirstChild(GetWindow());
	if (NULL == child)
	{
		// Nothing to do
		return;
	}
	IGenWindow *pChild = FromHandle(child);
	if (NULL == pChild)
	{
		// Don't know what to do
		return;
	}

	SIZE size;
	pChild->GetDesiredSize(&size);

	ppt->cx = max(ppt->cx, size.cx);
	ppt->cy = max(ppt->cy, size.cy);
}

void CSeparator::SetDesiredSize(SIZE *psize)
{
	m_desSize = *psize;
	OnDesiredSizeChanged();
}

void CSeparator::Layout()
{
	HWND hwnd = GetWindow();

	HWND child = GetFirstChild(hwnd);
	if (NULL == child)
	{
		// Nothing to do
		return;
	}
	IGenWindow *pChild = FromHandle(child);
	if (NULL == pChild)
	{
		// Don't know what to do
		return;
	}

	// Center the child horizontally and vertically
	SIZE size;
	pChild->GetDesiredSize(&size);

	RECT rcClient;
	GetClientRect(hwnd, &rcClient);

	rcClient.left += (rcClient.right-rcClient.left-size.cx)/2;
	rcClient.top  += (rcClient.bottom-rcClient.top-size.cy)/2;

	SetWindowPos(child, NULL, rcClient.left, rcClient.top, size.cx, size.cy,
		SWP_NOZORDER|SWP_NOACTIVATE);
}

void CSeparator::OnPaint(HWND hwnd)
{
	PAINTSTRUCT ps;
	HDC hdc = BeginPaint(hwnd, &ps);

	RECT rc;
	GetClientRect(hwnd, &rc);

	int nFlags = BF_LEFT;
	if (rc.right < rc.bottom)
	{
		// this is a vertical separator
		// center the drawing
		rc.left  += (rc.right-rc.left)/2 - 1;
		rc.right = 4;
	}
	else
	{
		// this is a horizontal separator
		nFlags = BF_TOP;
		// center the drawing
		rc.top    += (rc.bottom-rc.top)/2 - 1;
		rc.bottom = 4;
	}

	if (Normal == m_iStyle)
	{
		DrawEdge(hdc, &rc, EDGE_ETCHED, nFlags);
	}

	EndPaint(hwnd, &ps);
}

LRESULT CSeparator::ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		HANDLE_MSG(hwnd, WM_PAINT, OnPaint);
	}

	return(CGenWindow::ProcessMessage(hwnd, message, wParam, lParam));
}

BOOL CLayeredView::Create(
	HWND hwndParent,	// The parent of this window
	DWORD dwExStyle		// The extended style
	)
{
	return(CGenWindow::Create(
        hwndParent,
        0,
        TEXT("NMLayeredView"),
        WS_CLIPCHILDREN,
        dwExStyle));
}

void CLayeredView::GetDesiredSize(SIZE *psize)
{
	CGenWindow::GetDesiredSize(psize);

	HWND child = GetFirstChild(GetWindow());
	if (NULL == child)
	{
		return;
	}

	SIZE sizeContent;

	IGenWindow *pChild;
	pChild = FromHandle(child);
	if (NULL != pChild)
	{
		// Make sure we can always handle the first window
		pChild->GetDesiredSize(&sizeContent);
	}

	for (child=::GetWindow(child, GW_HWNDNEXT); NULL!=child;
		child=::GetWindow(child, GW_HWNDNEXT))
	{
		if (IsChildVisible(child))
		{
			pChild = FromHandle(child);
			if (NULL != pChild)
			{
				SIZE sizeTemp;
				pChild->GetDesiredSize(&sizeTemp);

				sizeContent.cx = max(sizeContent.cx, sizeTemp.cx);
				sizeContent.cy = max(sizeContent.cy, sizeTemp.cy);

				break;
			}
		}
	}

	psize->cx += sizeContent.cx;
	psize->cy += sizeContent.cy;
}

void CLayeredView::Layout()
{
	HWND hwndThis = GetWindow();

	RECT rcClient;
	GetClientRect(hwndThis, &rcClient);

	// Just move all the children
	for (HWND child=GetFirstChild(hwndThis); NULL!=child;
		child=::GetWindow(child, GW_HWNDNEXT))
	{
		switch (m_lStyle)
		{
		case Center:
		{
			IGenWindow *pChild = FromHandle(child);
			if (NULL != pChild)
			{
				SIZE size;
				pChild->GetDesiredSize(&size);
				SetWindowPos(child, NULL,
					(rcClient.left+rcClient.right-size.cx)/2,
					(rcClient.top+rcClient.bottom-size.cy)/2,
					size.cx, size.cy, SWP_NOZORDER|SWP_NOACTIVATE);
				break;
			}
		}

		// Fall through
		case Fill:
		default:
			SetWindowPos(child, NULL,
				rcClient.left, rcClient.top,
				rcClient.right-rcClient.left,
				rcClient.bottom-rcClient.top,
				SWP_NOZORDER|SWP_NOACTIVATE);
			break;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\sources.inc ===
# SOURCES.INC
#
# Common portions of SOURCES files used in both the Ansi and Unicode
# subdirectories of NMUTIL.
#
# The SOURCES_SUBDIR variable must be defined in the including SOURCES
# file for this INC file to work.

!ifndef SOURCES_SUBDIR
!error Your .\sources. file must define the SOURCES_SUBDIR= macro
!endif

!include $(DEVROOT)\common.inc

MAJORCOMP=common
MINORCOMP=$(SOURCES_SUBDIR)

TARGETNAME=$(SOURCES_SUBDIR)
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=LIBRARY

C_DEFINES=$(C_DEFINES) -DOS_WIN95
ASM_DEFINES=$(ASM_DEFINES)

386_STDCALL=1

# Always enable intrinsics
USER_C_FLAGS=/Oi

#
# MIDL-generated header file
#

USER_INCLUDES=uls2.h

#
# Parameters for MIDL
#

IDL_TYPE=ole
PASS0_HEADERDIR = $(ROOT)\nmutil\$(SOURCES_SUBDIR)\$(O)
PASS0_SOURCEDIR = $(ROOT)\nmutil\$(SOURCES_SUBDIR)\$(O)
MIDL_UUIDDIR    = $(ROOT)\nmutil\$(SOURCES_SUBDIR)\$(O)

#
# List of sources
#

SOURCES=uls2.idl        \
        ..\bstring.cpp  \
		..\borderwindow.cpp \
		..\button.cpp   \
        ..\centwnd.cpp  \
		..\combobox.cpp \
        ..\cstring.cpp  \
        ..\custring.cpp \
        ..\dbg.cpp      \
        ..\debspew.cpp  \
        ..\dllutil.cpp  \
		..\edittext.cpp \
		..\genwindow.cpp \
		..\intlutil.cpp \
        ..\memory.cpp   \
        ..\nmdsprv.cpp  \
        ..\nmhelp.cpp   \
        ..\oblist.cpp   \
        ..\olevalid.c   \
        ..\oprahcom.cpp \
        ..\ping.cpp     \
        ..\procutil.cpp \
        ..\purecall.cpp \
        ..\referenc.cpp \
        ..\regentry.cpp \
        ..\resstr.cpp   \
        ..\strutil.cpp  \
        ..\strtohex.cpp \
		..\toolbar.cpp  \
        ..\hextostr.cpp \
        ..\utf8str.cpp  \
        ..\valid.cpp    \
        ..\mlzdbg.cpp   \
        ..\evtlog.cpp   \
        ..\hash.cpp     \
	..\bestintf.cpp

i386_SOURCES=\
        ..\i386\procid.asm \
        ..\i386\seh.c

#
# Precompiled specs
#

PRECOMPILED_INCLUDE = ..\precomp.h
PRECOMPILED_PCH = precomp.pch
PRECOMPILED_OBJ = precomp.obj
PRECOMPILED_CXX = 1

CONDITIONAL_INCLUDES = \
subwtype.h	\
macocidl.h	\
macwin32.h	\
rpcerr.h	\
rpcmac.h	\
winwlm.h	\
macname1.h	\
macname2.h	\
macpub.h	\
macapi.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\utf8str.cpp ===
#include "precomp.h"
#include "utf8str.h"

CUTF8String::~CUTF8String()
{
	if (ALLOC_UNICODE & m_eAlloc)
	{
		delete m_pwszUnicode;
	}
	else if (ALLOC_UTF8 & m_eAlloc)
	{
		delete m_pszUTF8;
	}
}

CUTF8String::operator LPWSTR()
{ 
	if ((NULL == m_pwszUnicode) && (NULL != m_pszUTF8))
	{
		DecodeUTF8();
	}
	return m_pwszUnicode;
}

CUTF8String::operator LPSTR()
{ 
	if ((NULL == m_pszUTF8) && (NULL != m_pwszUnicode))
	{
		EncodeUTF8();
	}
	return m_pszUTF8;
}

VOID CUTF8String::EncodeUTF8()
{
	DebugEntry(CUTF8String::EncodeUTF8);
	m_hr = S_OK;
	ASSERT(NULL != m_pwszUnicode);
	int cchUTF8 = 1; // always include a NULL terminator

	// First make a pass to see how many characters we will be converting.
	LPWSTR pwsz = m_pwszUnicode;
	while (L'\0' != *pwsz)
	{
		WCHAR wch = *pwsz++;
		if (wch < 0x80)
		{
			cchUTF8 += 1;
		}
		else if (wch < 0x800)
		{
			cchUTF8 += 2;
		}
		else
		{
			cchUTF8 += 3;
		}
	}

	ASSERT(NULL == m_pszUTF8);
	m_pszUTF8 = new CHAR[cchUTF8];
	if (NULL != m_pszUTF8)
	{
		ASSERT(ALLOC_NONE == m_eAlloc);
		m_eAlloc = ALLOC_UTF8;
		// Start encoding here:
		const BYTE cUtf8FirstSignal[4] = {0x00, 0x00, 0xC0, 0xE0};
		const BYTE cMask   = 0xBF;
		const BYTE cSignal = 0x80;
		LPSTR pszStop = m_pszUTF8 + cchUTF8;
		LPSTR pszDst = m_pszUTF8;
		pwsz = m_pwszUnicode;
		while (pszDst < pszStop)
		{
			WCHAR wch = *pwsz++;
#ifdef DEBUG
			if (L'\0' == wch)
			{
				ASSERT(pszDst == pszStop - 1);
			}
#endif // DEBUG
			int cchTotal;
			if (wch < 0x80)
			{
				cchTotal = 1;
			}
			else if (wch < 0x800)
			{
				cchTotal = 2;
			}
			else
			{
				cchTotal = 3;
			}

			pszDst += cchTotal;
			switch (cchTotal)
			{
				case 3:
					*--pszDst = (wch | cSignal) & cMask;
					wch >>= 6;
					// FALL THROUGH
				case 2:
					*--pszDst = (wch | cSignal) & cMask;
					wch >>= 6;
					// FALL THROUGH
				case 1:
					*--pszDst = (wch | cUtf8FirstSignal[cchTotal]);
			}
			pszDst += cchTotal;
		}
		m_hr = S_OK;
	}
	else
	{
		m_hr = E_OUTOFMEMORY;
	}
	DebugExitVOID(CUTF8String::EncodeUTF8);
}

VOID CUTF8String::DecodeUTF8()
{
	DebugEntry(CUTF8String::DecodeUTF8);
	m_hr = S_OK;
	ASSERT(NULL != m_pszUTF8);
	int cchUnicode = 1; // always include a NULL terminator

	LPSTR psz = m_pszUTF8;
	// First determine the destination size (cchUnicode)
	while ('\0' != *psz)
	{
		int cbChar = 0;
		BYTE bFirst = (BYTE) *psz;
		while (bFirst & 0x80)
		{
			cbChar++;
			ASSERT(cbChar < 8);
			bFirst <<= 1;
		}

		cbChar = max(1, cbChar);
		psz += cbChar;
		cchUnicode++;
	}

	ASSERT(NULL == m_pwszUnicode);
	m_pwszUnicode = new WCHAR[cchUnicode];
	if (NULL != m_pwszUnicode)
	{
		ASSERT(ALLOC_NONE == m_eAlloc);
		m_eAlloc = ALLOC_UNICODE;
		// Start decoding here:
		LPWSTR pwszStop = m_pwszUnicode + cchUnicode;
		LPWSTR pwszDst = m_pwszUnicode;
		psz = m_pszUTF8;
		while (pwszDst < pwszStop)
		{
			int cbChar = 0;
			BYTE bFirst = (BYTE) *psz;
			while (bFirst & 0x80)
			{
				cbChar++;
				ASSERT(cbChar < 8);
				bFirst <<= 1;
			}

			BOOL fValid = TRUE;
			WCHAR wch = L'\0';
			switch (cbChar)
			{
				case 6: psz++; // FALLTHROUGH               // we don't handle
				case 5: psz++; // FALLTHROUGH               // UCS-4; skip first
				case 4: psz++; // FALLTHROUGH               // three bytes
				case 3:
					wch = WCHAR(*psz++ & 0x0f) << 12;      // 0x0800 - 0xffff
					fValid = fValid && ((*psz & 0xc0) == 0x80);
					// FALLTHROUGH
				case 2:
					wch |= WCHAR(*psz++ & 0x3f) << 6;       // 0x0080 - 0x07ff
					fValid = fValid && ((*psz & 0xc0) == 0x80);
					wch |= WCHAR(*psz++ & 0x3f);
					break;

				case 0:
					wch = WCHAR(*psz++);                    // 0x0000 - 0x007f
					break;

				default:
					ERROR_OUT(("CUTF8String::DecodeUTF8 found invalid UTF-8 lead byte"));
					wch = L'?';
					psz += cbChar;
					break;
			}

			if (FALSE == fValid)
			{
				ERROR_OUT(("CUTF8String::DecodeUTF8 found bad UTF-8 sequence"));
				*pwszDst = L'\0';
				m_hr = E_FAIL;
				break;
			}
#ifdef DEBUG
			cchUnicode--;
#endif // DEBUG

			*pwszDst++ = wch;
		}
		ASSERT(0 == cchUnicode);
	}
	else
	{
		m_hr = E_OUTOFMEMORY;
	}
	DebugExitVOID(CUTF8String::DecodeUTF8);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\regentry.cpp ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1995-1996			**/
/*****************************************************************/

/*
	regentry.cpp
	registry access classes

	This file contains classes which enable
    convenient access the registry for entries.

	FILE HISTORY:
		lens	10/15/95	Created
		ChrisPi	6/21/96		Added GetBinary(), SetValue() for binary
*/

#include "precomp.h"
#include <regentry.h>
#include <strutil.h>

RegEntry::RegEntry(LPCTSTR pszSubKey, HKEY hkey, BOOL fCreate, REGSAM samDesired)
 : m_pbValueBuffer(NULL),
   m_cbValueBuffer(0),
   m_fValuesWritten(FALSE),
   m_szNULL('\0')
{
	// Open with desired access if it is specified explicitly; otherwise, use
	// the default access.
	if (samDesired) {
		if (fCreate) {
			DWORD dwDisposition;

			m_error = ::RegCreateKeyEx(hkey, 
									pszSubKey, 
									0, 
									NULL, 
									REG_OPTION_NON_VOLATILE,
									samDesired, 
									NULL, 
									&m_hkey, 
									&dwDisposition);
		}
		else {
			m_error = ::RegOpenKeyEx(hkey, pszSubKey, 0, samDesired, &m_hkey);
		}
	}
	else {
		if (fCreate) {
			m_error = ::RegCreateKey(hkey, pszSubKey, &m_hkey);
		}
		else {
			m_error = ::RegOpenKey(hkey, pszSubKey, &m_hkey);
		}
	}

	m_fhkeyValid = (m_error == ERROR_SUCCESS);
}


RegEntry::~RegEntry()
{
	ChangeKey(NULL);
	delete [] m_pbValueBuffer;
}


VOID RegEntry::ChangeKey(HKEY hNewKey)
{
	// hNewKey assumed to be valid or never used
	// (as in destructor).

	if (m_fValuesWritten) {
		FlushKey();		
	}
    if (m_fhkeyValid) {
        ::RegCloseKey(m_hkey); 
    }
	m_hkey = hNewKey;	
}

VOID RegEntry::UpdateWrittenStatus()
{
	if (m_error == ERROR_SUCCESS) {
		m_fValuesWritten = TRUE;
	}
}

long RegEntry::SetValue(LPCTSTR pszValue, LPCTSTR string)
{
    if (m_fhkeyValid) {
    	m_error = ::RegSetValueEx(m_hkey, pszValue, 0, REG_SZ,
    				(LPBYTE)string, (lstrlen(string)+1) * sizeof(*string));
		UpdateWrittenStatus();
    }
	return m_error;
}

long RegEntry::SetValue(LPCTSTR pszValue, unsigned long dwNumber)
{
    if (m_fhkeyValid) {
    	m_error = ::RegSetValueEx(m_hkey, pszValue, 0, REG_BINARY,
    				(LPBYTE)&dwNumber, sizeof(dwNumber));
		UpdateWrittenStatus();
    }
	return m_error;
}

long RegEntry::SetValue(LPCTSTR pszValue,
						void* pData,
						DWORD cbLength)
{
    if (m_fhkeyValid) {
    	m_error = ::RegSetValueEx(	m_hkey,
								pszValue,
								0,
								REG_BINARY,
    							(LPBYTE) pData,
								cbLength);
		UpdateWrittenStatus();
    }
	return m_error;
}

long RegEntry::DeleteValue(LPCTSTR pszValue)
{
    if (m_fhkeyValid) {
    	m_error = ::RegDeleteValue(m_hkey, pszValue);
		UpdateWrittenStatus();
	}
	return m_error;
}

long RegEntry::GetNumber(LPCTSTR pszValue, long dwDefault)
{
 	DWORD 	dwType = REG_BINARY;
 	long	dwNumber = 0L;
 	DWORD	dwSize = sizeof(dwNumber);

    if (m_fhkeyValid) {
    	m_error = ::RegQueryValueEx(m_hkey, pszValue, 0, &dwType, (LPBYTE)&dwNumber,
    				&dwSize);
	}
	
	// If the call succeeded, make sure that the returned data matches our
	// expectations.
	ASSERT(m_error != ERROR_SUCCESS || 
			(REG_BINARY == dwType && sizeof(dwNumber) == dwSize) ||
			REG_DWORD == dwType);

	if (m_error != ERROR_SUCCESS)
		dwNumber = dwDefault;
	
	return dwNumber;
}


// The GetNumberIniStyle method performs the same function as GetNumber,
// but in a style compatible with the old GetPrivateProfileInt API.
// Specfically it means:
// - If the value is stored in the registry as a string, it attempts to
//   convert it to an integer.
// - If the value is negative, it returns 0.

ULONG RegEntry::GetNumberIniStyle(LPCTSTR pszValueName, ULONG dwDefault)
{
	DWORD 	dwType = REG_BINARY;
 	ULONG	dwNumber = 0L;
    DWORD   cbLength = m_cbValueBuffer;

    if (m_fhkeyValid) {
    	m_error = ::RegQueryValueEx(m_hkey, 
								pszValueName, 
								0, 
								&dwType, 
								m_pbValueBuffer,
								&cbLength);

		// Try again with a larger buffer if the first one is too small,
		// or if there wasn't already a buffer allocated.
		if ((ERROR_SUCCESS == m_error && NULL == m_pbValueBuffer)
			|| ERROR_MORE_DATA == m_error) {
			
			ASSERT(cbLength > m_cbValueBuffer);

			ResizeValueBuffer(cbLength);

        	m_error = RegQueryValueEx( m_hkey,
									  pszValueName,
									  0,
									  &dwType,
									  m_pbValueBuffer,
									  &cbLength );
		}

		if (ERROR_SUCCESS == m_error) {
			switch(dwType) {
				case REG_DWORD:
				case REG_BINARY:
					ASSERT(sizeof(dwNumber) == cbLength);

					dwNumber = * (LPDWORD) m_pbValueBuffer;
					break;

				case REG_SZ:
				{
					LONG lNumber = RtStrToInt((LPCTSTR) m_pbValueBuffer);

					// Convert negative numbers to zero, to match 
					// GetPrivateProfileInt's behavior.
					dwNumber = lNumber < 0 ? 0 : lNumber;
				}

					break;

				default:
					ERROR_OUT(("Invalid value type (%lu) returned by RegQueryValueEx()",
								dwType));
					break;
			}
		}
	}

	if (m_error != ERROR_SUCCESS) {
		dwNumber = dwDefault;
	}
	
	return dwNumber;
}


LPTSTR RegEntry::GetString(LPCTSTR pszValueName)
{
	DWORD 	dwType = REG_SZ;
    DWORD   length = m_cbValueBuffer;

    if (m_fhkeyValid) {
        m_error = ::RegQueryValueEx( m_hkey,
                                  pszValueName,
                                  0,
                                  &dwType,
                                  m_pbValueBuffer,
                                  &length );
		// Try again with a larger buffer if the first one is too small,
		// or if there wasn't already a buffer allocated.
		if ((ERROR_SUCCESS == m_error && NULL == m_pbValueBuffer)
			|| ERROR_MORE_DATA == m_error) {
			
			ASSERT(length > m_cbValueBuffer);

			ResizeValueBuffer(length);

        	m_error = ::RegQueryValueEx( m_hkey,
									  pszValueName,
									  0,
									  &dwType,
									  m_pbValueBuffer,
									  &length );
		}
		if (m_error == ERROR_SUCCESS) {
			if ((dwType != REG_SZ) && (dwType != REG_EXPAND_SZ)) {
				m_error = ERROR_INVALID_PARAMETER;
			}
		}
	}
    if ((m_error != ERROR_SUCCESS) || (length == 0)) {
		return &m_szNULL;
    }
	return (LPTSTR) m_pbValueBuffer;
}

DWORD RegEntry::GetBinary(	LPCTSTR pszValueName,
							void** ppvData)
{
	ASSERT(ppvData);
	DWORD 	dwType = REG_BINARY;
    DWORD   length = m_cbValueBuffer;

    if (m_fhkeyValid) {
        m_error = ::RegQueryValueEx( m_hkey,
                                  pszValueName,
                                  0,
                                  &dwType,
                                  m_pbValueBuffer,
                                  &length );
		// Try again with a larger buffer if the first one is too small,
		// or if there wasn't already a buffer allocated.
		if ((ERROR_SUCCESS == m_error && NULL == m_pbValueBuffer)
			|| ERROR_MORE_DATA == m_error) {
			
			ASSERT(length > m_cbValueBuffer);

			ResizeValueBuffer(length);

        	m_error = ::RegQueryValueEx( m_hkey,
									  pszValueName,
									  0,
									  &dwType,
									  m_pbValueBuffer,
									  &length );
		}
		if (m_error == ERROR_SUCCESS) {
			if (dwType != REG_BINARY) {
				m_error = ERROR_INVALID_PARAMETER;
			}
		}
	}
    if ((m_error != ERROR_SUCCESS) || (length == 0)) {
		*ppvData = NULL;
		length = 0;
    }
	else
	{
		*ppvData = m_pbValueBuffer;
	}
	return length;
}

// BUGBUG - Use LocalReAlloc instead of new/delete?
VOID RegEntry::ResizeValueBuffer(DWORD length)
{
	LPBYTE pbNewBuffer;

    if ((m_error == ERROR_SUCCESS || m_error == ERROR_MORE_DATA)
		&& (length > m_cbValueBuffer)) {
        pbNewBuffer = new BYTE[length];
        if (pbNewBuffer) {
			delete [] m_pbValueBuffer;
			m_pbValueBuffer = pbNewBuffer;
			m_cbValueBuffer = length;
		}
		else {
            m_error = ERROR_NOT_ENOUGH_MEMORY;
        }
	}
}

// BUGBUG - Support other OpenKey switches from constructor
VOID RegEntry::MoveToSubKey(LPCTSTR pszSubKeyName)
{
    HKEY	_hNewKey;

    if (m_fhkeyValid) {
        m_error = ::RegOpenKey ( m_hkey,
                              pszSubKeyName,
                              &_hNewKey );
        if (m_error == ERROR_SUCCESS) {
			ChangeKey(_hNewKey);
        }
    }
}

RegEnumValues::RegEnumValues(RegEntry *pReqRegEntry)
 : m_pRegEntry(pReqRegEntry),
   m_iEnum(0),
   m_pchName(NULL),
   m_pbValue(NULL)
{
    m_error = m_pRegEntry->GetError();
    if (m_error == ERROR_SUCCESS) {
        m_error = ::RegQueryInfoKey (m_pRegEntry->GetKey(), // Key
                                   NULL,                // Buffer for class string
                                   NULL,                // Size of class string buffer
                                   NULL,                // Reserved
                                   NULL,                // Number of subkeys
                                   NULL,                // Longest subkey name
                                   NULL,                // Longest class string
                                   &m_cEntries,         // Number of value entries
                                   &m_cMaxValueName,    // Longest value name
                                   &m_cMaxData,         // Longest value data
                                   NULL,                // Security descriptor
                                   NULL );              // Last write time
    }
    if (m_error == ERROR_SUCCESS) {
        if (m_cEntries != 0) {
            m_cMaxValueName++;	// REG_SZ needs one more for null
            m_cMaxData++;		// REG_SZ needs one more for null
            m_pchName = new TCHAR[m_cMaxValueName];
            if (!m_pchName) {
                m_error = ERROR_NOT_ENOUGH_MEMORY;
            }
            else {
                if (m_cMaxData) {
                    m_pbValue = new BYTE[m_cMaxData];
                    if (!m_pbValue) {
                        m_error = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
            }
        }
    }
}

RegEnumValues::~RegEnumValues()
{
    delete m_pchName;
    delete m_pbValue;
}

long RegEnumValues::Next()
{
    if (m_error != ERROR_SUCCESS) {
        return m_error;
    }
    if (m_cEntries == m_iEnum) {
        return ERROR_NO_MORE_ITEMS;
    }

    DWORD   cchName = m_cMaxValueName;

    m_dwDataLength = m_cMaxData;
    m_error = ::RegEnumValue ( m_pRegEntry->GetKey(), // Key
                            m_iEnum,               // Index of value
                            m_pchName,             // Address of buffer for value name
                            &cchName,            // Address for size of buffer
                            NULL,                // Reserved
                            &m_dwType,             // Data type
                            m_pbValue,             // Address of buffer for value data
                            &m_dwDataLength );     // Address for size of data
    m_iEnum++;
    return m_error;
}

RegEnumSubKeys::RegEnumSubKeys(RegEntry *pReqRegEntry)
 : m_pRegEntry(pReqRegEntry),
   m_iEnum(0),
   m_pchName(NULL)
{
    m_error = m_pRegEntry->GetError();
    if (m_error == ERROR_SUCCESS) {
        m_error = ::RegQueryInfoKey ( m_pRegEntry->GetKey(), // Key
                                   NULL,                // Buffer for class string
                                   NULL,                // Size of class string buffer
                                   NULL,                // Reserved
                                   &m_cEntries,           // Number of subkeys
                                   &m_cMaxKeyName,        // Longest subkey name
                                   NULL,                // Longest class string
                                   NULL,                // Number of value entries
                                   NULL,                // Longest value name
                                   NULL,                // Longest value data
                                   NULL,                // Security descriptor
                                   NULL );              // Last write time
    }
    if (m_error == ERROR_SUCCESS) {
        if (m_cEntries != 0) {
            m_cMaxKeyName = m_cMaxKeyName + 1; // needs one more for null
            m_pchName = new TCHAR[m_cMaxKeyName];
            if (!m_pchName) {
                m_error = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }
}

RegEnumSubKeys::~RegEnumSubKeys()
{
    delete m_pchName;
}

long RegEnumSubKeys::Next()
{
    if (m_error != ERROR_SUCCESS) {
        return m_error;
    }
    if (m_cEntries == m_iEnum) {
        return ERROR_NO_MORE_ITEMS;
    }

    DWORD   cchName = m_cMaxKeyName;

    m_error = ::RegEnumKey ( m_pRegEntry->GetKey(), // Key
                          m_iEnum,               // Index of value
                          m_pchName,             // Address of buffer for subkey name
                          cchName);            // Size of buffer
    m_iEnum++;
    return m_error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\strutil.cpp ===
// STRUTIL.CPP
//
// Assorted string utility functions for use in NetMeeting components.
// Derived from STRCORE.CPP.

#include "precomp.h"
#include <oprahcom.h>
#include <cstring.hpp>

// global helper functions for Unicode support in a DBCS environment

int NMINTERNAL UnicodeCompare(PCWSTR s, PCWSTR t)
{ 
	// Treat NULL pointers like empty strings
	// at the bottom of the collating order.

	if (IsEmptyStringW(t)) {
		if (IsEmptyStringW(s)) {
			return 0;
		}
		else {
			return 1;
		}
	}

	// Done with empty string cases, 
	// so now do real compare.

	for ( ; *s == *t; s++, t++) {
		if (!*s) {
			return 0;
		}
	}
	return (*s > *t) ? 1 : -1;
}

PWSTR NMINTERNAL NewUnicodeString(PCWSTR _wszText)
{
	PWSTR wszText = NULL;
	UINT nChar;

	if (_wszText) {
		nChar = lstrlenW(_wszText) + 1;
		wszText = new WCHAR[nChar];
		if (wszText) {
			CopyMemory((void *)wszText, 
						_wszText, 
						nChar * sizeof(WCHAR));
		}
	}
	return wszText;
}

PWSTR NMINTERNAL DBCSToUnicode(UINT uCodePage, PCSTR szText)
{
	int		nChar;
	PWSTR	wszText = NULL;

	if (szText) {
		nChar = MultiByteToWideChar(uCodePage,
									0,		// character-type options
									szText,
									-1,		// NULL terminated string
									NULL,	// return buffer (not used)
									0);		// getting length of Unicode string
		if (nChar) {
			wszText = new WCHAR[nChar];
			if (wszText) {
				nChar = MultiByteToWideChar(uCodePage,
											0,			// character-type options
											szText,
											-1,			// NULL terminated string
											wszText,	// return buffer
											nChar);		// length of return buffer
				if (!nChar) {
					delete wszText;
					wszText = NULL;
				}
			}
		}
	}
	return wszText;
}

PSTR NMINTERNAL UnicodeToDBCS(UINT uCodePage, PCWSTR wszText)
{
	int		nChar;
	PSTR	szText = NULL;

	if (wszText) {
		nChar = WideCharToMultiByte(uCodePage,
									0,		// character-type options
									wszText,
									-1,		// NULL terminated string
									NULL,	// return buffer (not used)
									0,		// getting length of DBCS string
									NULL,
									NULL);
		if (nChar) {
			szText = new CHAR[nChar];
			if (szText) {
				nChar = WideCharToMultiByte(uCodePage,
											0,			// character-type options
											wszText,
											-1,			// NULL terminated string
											szText,		// return buffer
											nChar,		// length of return buffer
											NULL,
											NULL);
				if (!nChar) {
					delete szText;
					szText = NULL;
				}
			}
		}
	}
	return szText;
}


BOOL NMINTERNAL UnicodeIsNumber(PCWSTR wszText)
{
	// If there are no characters, then treat it as not being a number.

	if (!wszText || !*wszText) {
		return FALSE;
	}

	// If any characters are not digits, then return FALSE.

	do {
		if ((*wszText < L'0') || (*wszText > L'9')) {
			return FALSE;
		}
	} while(*++wszText);

	// Got here so all characters are digits.

	return TRUE;
}


/*  G U I D  T O  S Z */
/*----------------------------------------------------------------------------
    %%Function: GuidToSz

	Convert the guid to a special hex string.
	Assumes lpchDest has space for at least sizeof(GUID)*2 +6 chars.
	LENGTH_SZGUID_FORMATTED is 30 and includes space for the null terminator.

	Note the difference between this and UuidToString (or StringFromGUID2)

	GUID Format: {12345678-1234-1234-1234567890123456}
----------------------------------------------------------------------------*/
VOID NMINTERNAL GuidToSz(GUID * pguid, LPTSTR lpchDest)
{
	ASSERT(NULL != pguid);
	ASSERT(NULL != lpchDest);

	wsprintf(lpchDest, TEXT("{%08X-%04X-%04X-%02X%02X-"),
		pguid->Data1, pguid->Data2, pguid->Data3, pguid->Data4[0], pguid->Data4[1]);
	lpchDest += 1+8+1+4+1+4+1+2+2+1;

	for (int i = 2; i < 8; i++)
	{
		wsprintf(lpchDest, TEXT("%02X"), pguid->Data4[i]);
		lpchDest += 2;
	}
	lstrcpy(lpchDest, TEXT("}") );
}


/*  S Z  F I N D  L A S T  C H */
/*----------------------------------------------------------------------------
    %%Function: SzFindLastCh

	Returns a pointer to the ch within the lpsz or NULL if not found
----------------------------------------------------------------------------*/
LPTSTR NMINTERNAL SzFindLastCh(LPTSTR lpsz, TCHAR ch)
{
	LPTSTR lpchRet;

	for (lpchRet = NULL; *lpsz; lpsz = CharNext(lpsz))
	{
		if (ch == *lpsz)
			lpchRet = lpsz;
	}

	return lpchRet;
}



/*  T R I M  S Z  */
/*-------------------------------------------------------------------------
    %%Function: TrimSz

    Trim the whitespace around string.
    Returns the number of characters in the string.
    (chars/bytes in ANSI and DBCS, WCHARs/words in UNICODE)
-------------------------------------------------------------------------*/
UINT NMINTERNAL TrimSz(PTCHAR psz)
{
    UINT   ich;        // character index into rgwCharType
    PTCHAR pchFirst;
    PTCHAR pchLast;
    PTCHAR pchCurr;
    WORD   rgwCharType[MAX_PATH];

	if ((NULL == psz) || (0 == lstrlen(psz)))
	{
		return 0;
	}

	if (!GetStringTypeEx(LOCALE_SYSTEM_DEFAULT, CT_CTYPE1, psz, -1, rgwCharType))
	{
		WARNING_OUT(("TrimSz: Problem with GetStringTypeEx"));
		return 0;
	}

	// search for first non-space
	pchFirst = psz;
	ich = 0;
	while (_T('\0') != *pchFirst)
	{
		if (!(C1_SPACE & rgwCharType[ich]))
			break;
		pchFirst = CharNext(pchFirst);
		ich++;
	}

	if (_T('\0') == *pchFirst)
	{
		// The entire string is empty!
		*psz = _T('\0');
		return 0;
	}
	
	// search for last non-space
	pchCurr = pchFirst;
	pchLast = pchCurr;
	while (_T('\0') != *pchCurr)
	{
		if (!(C1_SPACE & rgwCharType[ich]))
		{
			pchLast = pchCurr;
		}
		pchCurr = CharNext(pchCurr);
		ich++;
	}

	ASSERT(_T('\0') != *pchLast);
	// Null terminate the string
	pchLast = CharNext(pchLast);
	*pchLast = _T('\0');

	// Update the original string
	lstrcpy(psz, pchFirst);

	// Return the new length
	return lstrlen(psz);
}


// Implement lstrcpyW when not on a Unicode platform

#if !defined(UNICODE)
/*  L  S T R  C P Y  W  */
/*-------------------------------------------------------------------------
    %%Function: LStrCpyW
    
-------------------------------------------------------------------------*/
LPWSTR NMINTERNAL LStrCpyW(LPWSTR pszDest, LPWSTR pszSrc)
{
	ASSERT(NULL != pszDest);
	ASSERT(NULL != pszSrc);

	if ((NULL != pszDest) && (NULL != pszSrc))
	{
		LPWSTR pszT = pszDest;
		while (0 != (*pszT++ = *pszSrc++))
			;

	}
	return pszDest;
}


/*  L  S T R  C P Y N W  */
/*-------------------------------------------------------------------------
    %%Function: LStrCpyNW
    
-------------------------------------------------------------------------*/
LPWSTR NMINTERNAL LStrCpyNW(LPWSTR pszDest, LPCWSTR pszSrc, INT iMaxLength)
{
	ASSERT(NULL != pszDest);
	ASSERT(NULL != pszSrc);

	if ((NULL != pszDest) && (NULL != pszSrc))
	{
		LPWSTR pszT = pszDest;
		while ((--iMaxLength > 0) && 
				(0 != (*pszT++ = *pszSrc++)))
		{
			/*EXPLICIT */ ;
		}

		if (0 == iMaxLength)
		{
			*pszT = L'\0';
		}
	}
	return pszDest;
}

#endif // !defined(UNICODE)

/*  _ S T R C H R  */
/*-------------------------------------------------------------------------
    %%Function: _StrChr
    
-------------------------------------------------------------------------*/
LPCTSTR NMINTERNAL _StrChr ( LPCTSTR pcsz, TCHAR c )
{
    LPCTSTR pcszFound = NULL;

    if (pcsz)
    {
        while (*pcsz)
        {
            if (*pcsz == c)
            {
                pcszFound = pcsz;
                break;
            }

            pcsz = CharNext(pcsz);
        }
    }

    return pcszFound;
}


/*  _ S T R C M P N  */
/*-------------------------------------------------------------------------
    %%Function: _StrCmpN
    This does a case-sensitive compare of two strings, pcsz1 and pcsz2, of
    at most cchMax characters.  If we reach the end of either string, we
    also stop, and the strings match if the other string is also at its end.

    This function is NOT DBCS safe.
    
-------------------------------------------------------------------------*/
int NMINTERNAL _StrCmpN(LPCTSTR pcsz1, LPCTSTR pcsz2, UINT cchMax)
{
    UINT ich;

    for (ich = 0; ich < cchMax; ich++)
    {
        if (*pcsz1 != *pcsz2)
        {
            // No match.
            return((*pcsz1 > *pcsz2) ? 1 : -1);
        }

        //
        // Are we at the end (if we're here, both strings are at the
        // end.  If only one is, the above compare code kicks in.
        //
        if ('\0' == *pcsz1)
            return 0;

        pcsz1++;
        pcsz2++;
    }

    // If we get here, cchMax characters matched, so success.
    return 0;
}

/*  _ S T R S T R  */
/*-------------------------------------------------------------------------
    %%Function: _StrStr
    
-------------------------------------------------------------------------*/
// BUGBUG - This function is *not* DBCS-safe
LPCTSTR NMINTERNAL _StrStr (LPCTSTR pcsz1, LPCTSTR pcsz2)
{
	PTSTR pszcp = (PTSTR) pcsz1;
	PTSTR pszs1, pszs2;

	if ( !*pcsz2 )
		return pcsz1;

	while (*pszcp)
	{
		pszs1 = pszcp;
		pszs2 = (PTSTR) pcsz2;

		while ( *pszs1 && *pszs2 && !(*pszs1-*pszs2) )
			pszs1++, pszs2++;

		if (!*pszs2)
			return pszcp;

		pszcp++;
	}

	return NULL;
}

/*  _ S T R S T R  */
/*-------------------------------------------------------------------------
    %%Function: _StrStr
    
-------------------------------------------------------------------------*/
// BUGBUG - This function is *not* DBCS-safe
LPCWSTR _StrStrW(LPCWSTR pcsz1, LPCWSTR pcsz2)
{
	PWSTR pszcp = (PWSTR) pcsz1;

	while (*pszcp)
	{
		PWSTR psz1 = pszcp;
		PWSTR psz2 = (PWSTR) pcsz2;

		while ( *psz1 && *psz2 && !(*psz1-*psz2) )
		{
			psz1++;
			psz2++;
		}

		if (!*psz2)
			return pszcp;

		pszcp++;
	}

	return NULL;
}

/*  _ S T R P B R K  */
/*-------------------------------------------------------------------------
    %%Function: _StrPbrkA, _StrPbrkW

    Private, DBCS-safe version of CRT strpbrk function.  Like strchr but 
	accepts more than one character for which to search.  The ANSI version 
	does not support searching for DBCS chars.

	In the Unicode version, we do a nested search.  In the ANSI version,
	we build up a table of chars and use this to scan the string.
-------------------------------------------------------------------------*/
LPSTR NMINTERNAL _StrPbrkA(LPCSTR pcszString, LPCSTR pcszSearch)
{
	ASSERT(NULL != pcszString && NULL != pcszSearch);

	BYTE rgbSearch[(UCHAR_MAX + 1) / CHAR_BIT];

	ZeroMemory(rgbSearch, sizeof(rgbSearch));

	// Scan the search string
	while ('\0' != *pcszSearch)
	{
		ASSERT(!IsDBCSLeadByte(*pcszSearch));

		// Set the appropriate bit in the appropriate byte
		rgbSearch[*pcszSearch / CHAR_BIT] |= (1 << (*pcszSearch % CHAR_BIT));

		pcszSearch++;
	}

	// Scan the source string, compare to the bits in the search array
	while ('\0' != *pcszString)
	{
		if (rgbSearch[*pcszString / CHAR_BIT] & (1 << (*pcszString % CHAR_BIT)))
		{
			// We have a match
			return (LPSTR) pcszString;
		}

		pcszString = CharNextA(pcszString);
	}

	// If we get here, there was no match
	return NULL;
}


LPWSTR NMINTERNAL _StrPbrkW(LPCWSTR pcszString, LPCWSTR pcszSearch)
{
	ASSERT(NULL != pcszString && NULL != pcszSearch);

	// Scan the string, matching each character against those in the search string
	while (L'\0' != *pcszString)
	{
		LPCWSTR pcszCurrent = pcszSearch;

		while (L'\0' != *pcszCurrent)
		{
			if (*pcszString == *pcszCurrent)
			{
				// We have a match
				return (LPWSTR) pcszString;
			}

			// pcszCurrent = CharNextW(pcszCurrent);
			pcszCurrent++;
		}

		// pcszString = CharNextW(pcszString);
		pcszString++;
	}

	// If we get here, there was no match
	return NULL;
}


// BUGBUG - Are DecimalStringToUINT and StrToInt the same?

/*  D E C I M A L  S T R I N G  T O  U  I  N  T  */
/*-------------------------------------------------------------------------
    %%Function: DecimalStringToUINT
    
-------------------------------------------------------------------------*/
UINT NMINTERNAL DecimalStringToUINT(LPCTSTR pcszString)
{
	ASSERT(pcszString);
	UINT uRet = 0;
	LPTSTR pszStr = (LPTSTR) pcszString;
	while (_T('\0') != pszStr[0])
	{
		ASSERT((pszStr[0] >= _T('0')) &&
				(pszStr[0] <= _T('9')));
		uRet = (10 * uRet) + (BYTE) (pszStr[0] - _T('0'));
		pszStr++; // NOTE: DBCS characters are not allowed!
	}
	return uRet;
}


/****************************************************************************
    
	FUNCTION:	StrToInt

    PURPOSE:	The atoi equivalent, to avoid using the C runtime lib

	PARAMETERS: lpSrc - pointer to a source string to convert to integer

	RETURNS:	0 for failure, the integer otherwise
				(what if the string was converted to 0 ?)

****************************************************************************/
int WINAPI RtStrToInt(LPCTSTR lpSrc)       // atoi()
{
    int n = 0;
    BOOL bNeg = FALSE;

    if (*lpSrc == _T('-')) {
        bNeg = TRUE;
        lpSrc++;
    }

    while (((*lpSrc) >= _T('0') && (*lpSrc) <= _T('9')))
    {
        n *= 10;
        n += *lpSrc - _T('0');
        lpSrc++;
    }
    return bNeg ? -n : n;
}

/*  _ S T R L W R W  */
/*-------------------------------------------------------------------------
    %%Function: _StrLwrW
    
-------------------------------------------------------------------------*/
// BUGBUG - This function does *not* handle all UNICODE character sets

LPWSTR NMINTERNAL _StrLwrW(LPWSTR pwszSrc)
{
	for (PWSTR pwszCur = pwszSrc; (L'\0' != *pwszCur); pwszCur++)
	{
		if ( (*pwszCur >= L'A') && (*pwszCur <= L'Z') )
		{
			*pwszCur = *pwszCur - L'A' + L'a';
		}
	}
	return pwszSrc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\resstr.cpp ===
/*
 * resstr.c - Return code to string translation routines.
 *
 * Taken from URL code
 *
 * Created: ChrisPi 9-11-95
 *
 */


/* Headers
 **********/

#include "precomp.h"

#include "uls2.h"

/* Macros
 *********/

/*
 * macro for simplifying result to string translation, assumes result string
 * pointer pcsz
 */

#define STRING_CASE(val)               case val: pcsz = #val; break


/****************************** Public Functions *****************************/


#ifdef DEBUG

PCSTR GetINTString(int n)
{
   static char s_rgchINT[] = "-2147483646";

   wsprintfA(s_rgchINT, "%d", n);

   ASSERT(IS_VALID_STRING_PTR_A(s_rgchINT, CSTR));

   return(s_rgchINT);
}


PCSTR GetINT_PTRString(INT_PTR n)
{
   static char s_rgchINT[] = "-2147483646xxxxxxxxxx";

   wsprintfA(s_rgchINT, "%Id", n);

   ASSERT(IS_VALID_STRING_PTR_A(s_rgchINT, CSTR));

   return(s_rgchINT);
}


PCSTR GetULONGString(ULONG ul)
{
   static char s_rgchULONG[] = "4294967295";

   wsprintfA(s_rgchULONG, "%lx", ul);

   ASSERT(IS_VALID_STRING_PTR_A(s_rgchULONG, CSTR));

   return(s_rgchULONG);
}


PCSTR GetBOOLString(BOOL bResult)
{
   PCSTR pcsz;

   pcsz = bResult ? "TRUE" : "FALSE";

   ASSERT(IS_VALID_STRING_PTR_A(pcsz, CSTR));

   return(pcsz);
}


PCSTR GetPVOIDString(PVOID ptr)
{
   static char s_rgchPVOID[] = "0xffff0000ffff0000";

   wsprintfA(s_rgchPVOID, "0x%p", ptr);

   ASSERT(IS_VALID_STRING_PTR_A(s_rgchPVOID, CSTR));

   return(s_rgchPVOID);
}

PCSTR GetClipboardFormatNameString(UINT ucf)
{
   PCSTR pcsz;
   static char s_szCFName[MAX_PATH];

   switch (ucf)
   {
      STRING_CASE(CF_TEXT);
      STRING_CASE(CF_BITMAP);
      STRING_CASE(CF_METAFILEPICT);
      STRING_CASE(CF_SYLK);
      STRING_CASE(CF_DIF);
      STRING_CASE(CF_TIFF);
      STRING_CASE(CF_OEMTEXT);
      STRING_CASE(CF_DIB);
      STRING_CASE(CF_PALETTE);
      STRING_CASE(CF_PENDATA);
      STRING_CASE(CF_RIFF);
      STRING_CASE(CF_WAVE);
      STRING_CASE(CF_UNICODETEXT);
      STRING_CASE(CF_ENHMETAFILE);
      STRING_CASE(CF_HDROP);
      STRING_CASE(CF_LOCALE);
      STRING_CASE(CF_MAX);
      STRING_CASE(CF_OWNERDISPLAY);
      STRING_CASE(CF_DSPTEXT);
      STRING_CASE(CF_DSPBITMAP);
      STRING_CASE(CF_DSPMETAFILEPICT);
      STRING_CASE(CF_DSPENHMETAFILE);

      default:
         if (! GetClipboardFormatNameA(ucf, s_szCFName, sizeof(s_szCFName)))
            lstrcpyA(s_szCFName, "UNKNOWN CLIPBOARD FORMAT");
         pcsz = s_szCFName;
         break;
   }

   ASSERT(IS_VALID_STRING_PTR_A(pcsz, CSTR));

   return(pcsz);
}


PCSTR GetCOMPARISONRESULTString(COMPARISONRESULT cr)
{
   PCSTR pcsz;

   switch (cr)
   {
      STRING_CASE(CR_FIRST_SMALLER);
      STRING_CASE(CR_FIRST_LARGER);
      STRING_CASE(CR_EQUAL);

      default:
         ERROR_OUT(("GetCOMPARISONRESULTString() called on unknown COMPARISONRESULT %d.",
                    cr));
         pcsz = "UNKNOWN COMPARISONRESULT";
         break;
   }

   ASSERT(IS_VALID_STRING_PTR_A(pcsz, CSTR));

   return(pcsz);
}

PCSTR GetHRESULTString(HRESULT hr)
{
   PCSTR pcsz;
   static char s_rgchHRESULT[] = "0x12345678";

   switch (hr)
   {
      STRING_CASE(S_OK);
      STRING_CASE(S_FALSE);

      STRING_CASE(DRAGDROP_S_CANCEL);
      STRING_CASE(DRAGDROP_S_DROP);
      STRING_CASE(DRAGDROP_S_USEDEFAULTCURSORS);

      STRING_CASE(E_UNEXPECTED);
      STRING_CASE(E_NOTIMPL);
      STRING_CASE(E_OUTOFMEMORY);
      STRING_CASE(E_INVALIDARG);
      STRING_CASE(E_NOINTERFACE);
      STRING_CASE(E_POINTER);
      STRING_CASE(E_HANDLE);
      STRING_CASE(E_ABORT);
      STRING_CASE(E_FAIL);
      STRING_CASE(E_ACCESSDENIED);

      STRING_CASE(CLASS_E_NOAGGREGATION);

      STRING_CASE(CO_E_NOTINITIALIZED);
      STRING_CASE(CO_E_ALREADYINITIALIZED);
      STRING_CASE(CO_E_INIT_ONLY_SINGLE_THREADED);

      STRING_CASE(DV_E_DVASPECT);
      STRING_CASE(DV_E_LINDEX);
      STRING_CASE(DV_E_TYMED);
      STRING_CASE(DV_E_FORMATETC);

#ifdef __INTSHCUT_H__

      STRING_CASE(E_FLAGS);

      STRING_CASE(URL_E_INVALID_SYNTAX);
      STRING_CASE(URL_E_UNREGISTERED_PROTOCOL);

      STRING_CASE(IS_E_EXEC_FAILED);

      STRING_CASE(E_FILE_NOT_FOUND);
      STRING_CASE(E_PATH_NOT_FOUND);

#endif

		//  ULS error codes
		//
		STRING_CASE(ILS_E_SERVER_SERVICE);
		STRING_CASE(ILS_E_SERVER_NAME);
		STRING_CASE(ILS_E_TIMEOUT);
		STRING_CASE(ILS_E_BIND);
		STRING_CASE(ILS_E_THREAD);
		STRING_CASE(ILS_E_SERVER_EXEC);
		STRING_CASE(ILS_E_WINSOCK);
		STRING_CASE(ILS_E_NO_MORE);
		STRING_CASE(ILS_E_NOT_INITIALIZED);
		STRING_CASE(ILS_E_NOTIFY_ID);
		STRING_CASE(ILS_E_NO_SUCH_OBJECT);
		STRING_CASE(ILS_E_NEED_RELOGON);
		STRING_CASE(ILS_E_NAME_CONFLICTS);

		//  LDAP specific error codes
		//
		STRING_CASE(ILS_E_LDAP_OPERATIONS_ERROR);
		STRING_CASE(ILS_E_LDAP_PROTOCOL_ERROR);
		STRING_CASE(ILS_E_LDAP_TIMELIMIT_EXCEEDED);
		STRING_CASE(ILS_E_LDAP_SIZELIMIT_EXCEEDED);
		STRING_CASE(ILS_E_LDAP_COMPARE_FALSE);
		STRING_CASE(ILS_E_LDAP_COMPARE_TRUE);
		STRING_CASE(ILS_E_LDAP_AUTH_METHOD_NOT_SUPPORTED);
		STRING_CASE(ILS_E_LDAP_STRONG_AUTH_REQUIRED);
		STRING_CASE(ILS_E_LDAP_REFERRAL_V2);
		STRING_CASE(ILS_E_LDAP_PARTIAL_RESULTS);
		STRING_CASE(ILS_E_LDAP_REFERRAL);
		STRING_CASE(ILS_E_LDAP_ADMIN_LIMIT_EXCEEDED);
		STRING_CASE(ILS_E_LDAP_UNAVAILABLE_CRIT_EXTENSION);
		STRING_CASE(ILS_E_LDAP_NO_SUCH_ATTRIBUTE);
		STRING_CASE(ILS_E_LDAP_UNDEFINED_TYPE);
		STRING_CASE(ILS_E_LDAP_INAPPROPRIATE_MATCHING);
		STRING_CASE(ILS_E_LDAP_CONSTRAINT_VIOLATION);
		STRING_CASE(ILS_E_LDAP_ATTRIBUTE_OR_VALUE_EXISTS);
		STRING_CASE(ILS_E_LDAP_INVALID_SYNTAX);
		STRING_CASE(ILS_E_LDAP_ALIAS_PROBLEM);
		STRING_CASE(ILS_E_LDAP_INVALID_DN_SYNTAX);
		STRING_CASE(ILS_E_LDAP_IS_LEAF);
		STRING_CASE(ILS_E_LDAP_ALIAS_DEREF_PROBLEM);
		STRING_CASE(ILS_E_LDAP_INAPPROPRIATE_AUTH);
		STRING_CASE(ILS_E_LDAP_INVALID_CREDENTIALS);
		STRING_CASE(ILS_E_LDAP_INSUFFICIENT_RIGHTS);
		STRING_CASE(ILS_E_LDAP_BUSY);
		STRING_CASE(ILS_E_LDAP_UNAVAILABLE);
		STRING_CASE(ILS_E_LDAP_UNWILLING_TO_PERFORM);
		STRING_CASE(ILS_E_LDAP_LOOP_DETECT);
		STRING_CASE(ILS_E_LDAP_NAMING_VIOLATION);
		STRING_CASE(ILS_E_LDAP_OBJECT_CLASS_VIOLATION);
		STRING_CASE(ILS_E_LDAP_NOT_ALLOWED_ON_NONLEAF);
		STRING_CASE(ILS_E_LDAP_NOT_ALLOWED_ON_RDN);
		STRING_CASE(ILS_E_LDAP_NO_OBJECT_CLASS_MODS);
		STRING_CASE(ILS_E_LDAP_RESULTS_TOO_LARGE);
		STRING_CASE(ILS_E_LDAP_AFFECTS_MULTIPLE_DSAS);
		STRING_CASE(ILS_E_LDAP_OTHER);
		STRING_CASE(ILS_E_LDAP_SERVER_DOWN);
		STRING_CASE(ILS_E_LDAP_LOCAL_ERROR);
		STRING_CASE(ILS_E_LDAP_ENCODING_ERROR);
		STRING_CASE(ILS_E_LDAP_DECODING_ERROR);
		STRING_CASE(ILS_E_LDAP_TIMEOUT);
		STRING_CASE(ILS_E_LDAP_AUTH_UNKNOWN);
		STRING_CASE(ILS_E_LDAP_FILTER_ERROR);
		STRING_CASE(ILS_E_LDAP_USER_CANCELLED);
		STRING_CASE(ILS_E_LDAP_NO_MEMORY);

      default:
         wsprintfA(s_rgchHRESULT, "%#lx", hr);
         pcsz = s_rgchHRESULT;
         break;
   }

   ASSERT(IS_VALID_STRING_PTR_A(pcsz, CSTR));

   return(pcsz);
}

#endif   /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\i386\procid.asm ===
;*  Procdi.asm - Processor Identification routines
;*
;*      (C) Copyright Microsoft Corp., 1995
;*
;*      Processor ID
;*
;*  Origin:
;*
;*  Change history:
;*
;*  Date       Who        Description
;*  ---------  ---------  -------------------------------------------------
;*  12-Oct-95  MikeG      Created
;*

.386p
.387

.model  flat


;************************** Include Files ************************

;    include winbase.inc
;    include winerror.inc
;    include kernel32.inc
;    include segs.inc
;    include regstr.inc
;******************** Data Declerations **************************

.data
_DATA SEGMENT
CPU_ID  macro
        db      0fh, 0a2h
        endm

NONE            equ     0
PRESENT         equ     1
Nx586           equ     5
UNKNOWN         equ     0


_nxcpu          db      NONE                    ;default to none
_cputype        db      UNKNOWN                 ;default to unknown
_cpuid_flag     db      NONE                    ;default to no CPUID
_vendor_id      db      "************"
_cpu_signature  dd      0
_features_ecx   dd      0
_features_edx   dd      0
_features_ebx   dd      0
NexGen_id       db      "NexGenDriven"



;*********************** Prototypes ******************************


;************************** Code *********************************

.code

_TEXT	SEGMENT
;==========================================================================
; _get_nxcpu_type
;       This routine identifies NexGen's processor type in following steps:
;
;       if (no AC flag) {       //current Nx586 does not support AC flag
;               set ZF=1;
;               execute DIV to result a none zero value;
;               if (ZF=0) {     //ZF is changed
;                       not a NexGen processor;
;                       exit;
;               } else {        //Nx586 does not change ZF on DIV instruction
;                       if (ID bit not writeable) {
;                               CPU is Nx586 with no CPUID support
;                       } else {                //Nx586 with CPUID support
;                               execute CPUID instruction;
;                               save CPU information;
;                       }
;               }
;       } else {
;               if (ID bit not writeable) {
;                       not a NexGen processor;
;               } else {        //NexGen future processors support CPUID
;                       execute CPUID instruction;
;                       save CPU information;
;               }
;       }
;
;==========================================================================
get_nxcpu_type proc  C cdecl:DWORD
        push    ebx
        push    esi
        push    edi
        mov     byte ptr _nxcpu,PRESENT ; default to present

; test AC bit on EFLAGS register
        mov     bx,sp           ; save the current stack pointer
        and     sp,not 3        ; align the stack to avoid AC fault
        pushfd                  ;
        pop     eax             ; get the original EFLAGS
        mov     ecx,eax         ; save original flag
        xor     eax,40000h      ; flip AC bit in EFLAGS
        push    eax             ; save for EFLAGS
        popfd                   ; copy it to EFLAGS
        pushfd                  ;
        pop     eax             ; get the new EFLAGS value
        mov     sp,bx           ; restore stack pointer
        xor     eax,ecx         ; if the AC bit is unchanged
        je      test_zf         ;       goto second step
        jmp     nx_future_cpu

test_zf:
; test ZF on DIV instruction
        mov     ax,5555h        ; init AX with a non-zero value
        xor     dx,dx           ; set ZF=1
        mov     cx,2
        div     cx              ; Nx586 processor does not modify ZF on DIV
        jnz     not_nx_cpu      ; not a NexGen processor if ZF=0 (modified)

test_cpuid:
; test if CPUID instruction is available
; new Nx586 or future CPU supports CPUID instruction
        pushfd                  ; get EFLAGs
        pop     eax
        mov     ecx,eax         ; save it
        xor     eax,200000h     ; modify ID bit
        push    eax
        popfd                   ; save it in new EFLAGS
        pushfd                  ; get new EFLAGS
        pop     eax             ;
        xor     eax,ecx         ; is ID bit changed?
        jnz     cpuid_present   ; yes

        mov     byte ptr _cputype,Nx586 ; no, current Nx586
	mov	eax,1		; set return code == true
        jz      cpuid_exit      ; stop testing

nx_future_cpu:
; all NexGen's future processors feature a CPUID instruction
        mov     eax,ecx         ; get original EFLAGS
        xor     eax,200000h     ; modify ID bit
        push    eax
        popfd                   ; save it in new EFLAGS
        pushfd                  ; get new EFLAGS
        pop     eax             ;
        xor     eax,ecx         ; is ID bit changed?
        jz      not_nx_cpu      ; no, not a NexGen processor

cpuid_present:
; execute CPUID instruction to get vendor name, stepping and feature info
        xor     eax,eax
        CPU_ID
        mov     dword ptr _vendor_id,ebx
        mov     dword ptr _vendor_id[+4],edx
        mov     dword ptr _vendor_id[+8],ecx

        mov     bx,ds
        mov     es,bx
        mov     esi,offset _vendor_id
        mov     edi,offset NexGen_id
        mov     cx,12
        cld
        repe    cmpsb           ; compare vendor ID string
        jne     not_nx_cpu

        mov     byte ptr _cpuid_flag,PRESENT
        cmp     eax,1           ; check highest level
        jl      cpuid_exit

        mov     eax,1
        CPU_ID
        mov     _cpu_signature,eax
        mov     _features_ecx,ecx
        mov     _features_edx,edx
        mov     _features_ebx,ebx
        shr     eax,8
        and     al,0fh
        mov     _cputype,al
        jmp     cpuid_exit
not_nx_cpu:
        mov     byte ptr _nxcpu,NONE
        xor     eax,eax
cpuid_exit:
        pop     edi
        pop     esi
        pop     ebx
        ret
get_nxcpu_type endp

;**************************************************************************
;       Function:       int is_cyrix ()
;
;       Purpose:        Determine if Cyrix CPU is present
;       Technique:      Cyrix CPUs do not change flags where flags change
;                        in an undefined manner on other CPUs
;       Inputs:         none
;       Output:         ax == 1 Cyrix present, 0 if not
;**************************************************************************
is_cyrix proc C __cdecl:WORD
           .486
           push  bx
           xor   ax, ax         ; clear ax
           sahf                 ; clear flags, bit 1 is always 1 in flags
           mov   ax, 5
           mov   bx, 2
           div   bl             ; do an operation that does not change flags
           lahf                 ; get flags
           cmp   ah, 2          ; check for change in flags
           jne   not_cyrix      ; flags changed not Cyrix
           mov   ax, 1          ; TRUE Cyrix CPU
           jmp   done

not_cyrix:
           mov  ax, 0           ; FALSE NON-Cyrix CPU
done:
           pop  bx
           ret
is_cyrix   endp
_TEXT ends
      end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\setup\inf\sources.inc ===
!ifndef SOURCES_SUBDIR
!error Your .\sources. file must define the SOURCES_SUBDIR= macro
!endif

!ifndef ROOT
ROOT=$(MAKEDIR:\setup\inf=)
!endif

!include $(DEVROOT)\common.inc

MAJORCOMP=common
MINORCOMP=$(SOURCES_SUBDIR)

MAJORCOMP=common
MINORCOMP=setup

TARGETNAME=$(SOURCES_SUBDIR)
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=LIBRARY

SOURCES=

NTTARGETFILE0=$(O)\msnetmtg.inf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\i386\seh.c ===
/*****************************************************************************
 *
 *  Seh.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Structured exception handling.
 *
 *****************************************************************************/
#ifdef _M_IX86
#include <windows.h>
#include <sehcall.h>

typedef void *PV;

/*****************************************************************************
 *
 *      SEHFRAME
 *
 *      Special stack frame used by lightweight structured exception
 *      handling.
 *
 *****************************************************************************/

typedef struct SEHFRAME {

    PV      pvSEH;              /* Link to previous frame   */
    FARPROC Handler;            /* MyExceptionFilter        */
    FARPROC sehTarget;          /* Where to jump on error   */
    INEXCEPTION InException;    /* In-exception handler     */

} SEHFRAME, *PSEHFRAME;

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | _MyExceptionFilter |
 *
 *          My tiny exception filter.
 *
 *  @parm   LPEXCEPTION_RECORD | pExceptionRecord |
 *
 *          Exception record describing why we were called.
 *
 *  @parm   PV | EstablisherFrame |
 *
 *          The exception frame (pNext, pHandler)
 *          on the stack which is being handled.  This is used so that
 *          the handler can access its local variables and knows how
 *          far to smash the stack if the exception is being eaten.
 *
 *  @parm   PCONTEXT | pContextRecord |
 *
 *          Client context at time of exception.
 *
 *  @parm   PV | DispatcherContext |
 *
 *          Not used.  Which is good, because I don't know what it means.
 *
 ***************************************************************************/

#define EXCEPTION_UNWINDING     0x00000002
#define EXCEPTION_EXIT_UNWIND   0x00000004

WINBASEAPI void WINAPI
RtlUnwind(PV TargetFrame, PV TargetIp, PEXCEPTION_RECORD per, PV ReturnValue);

EXCEPTION_DISPOSITION
__cdecl
_MyExceptionFilter(
    LPEXCEPTION_RECORD pExceptionRecord,
    PV EstablisherFrame,
    PCONTEXT pContextRecord,
    PV DispatcherContext
)
{
    DispatcherContext;
    pContextRecord;

    /* Don't interfere with an unwind */
    if ((pExceptionRecord->ExceptionFlags &
            (EXCEPTION_UNWINDING | EXCEPTION_EXIT_UNWIND)) == 0) {
        PSEHFRAME pseh = EstablisherFrame;
        BOOL fRc = pseh->InException(pExceptionRecord, pContextRecord);

        /*
         *  RtlUnwind will tell all exception frames that may have
         *  been created underneath us that they are about to be
         *  blown away and should do their __finally handling.
         *
         *  On return, the nested frames have been unlinked.
         */
        RtlUnwind(EstablisherFrame, 0, 0, 0);

        /*
         *  And jump back to the caller.  It is the caller's
         *  responsibility to restore nonvolatile registers!
         *
         *  We also assume that the caller has nothing on the
         *  stack beneath the exception record!
         *
         *  And the handler address is right after the exception
         *  record!
         */
        __asm {
            mov     eax, fRc;               /* Get return value */
            mov     esp, EstablisherFrame;  /* Restore ESP */
//            jmp     [esp].sehTarget;        /* Back to CallWithSEH */

//We should be doing the above, but it faults VC4.2. Gotta love it.

            jmp     DWORD ptr [esp+8]
        }

    }

    /*
     *  We are unwinding.  Don't interfere.
     */
    return EXCEPTION_CONTINUE_SEARCH;
}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | CallWithSEH |
 *
 *          Call the function with an exception frame active.
 *
 *          If the procedure raises an exception, then call
 *          InException and propagate whatever InException returns.
 *
 ***************************************************************************/

#pragma warning(disable:4035)           /* no return value (duh) */

__declspec(naked) DWORD WINAPI
CallWithSEH(EXCEPTPROC pfn, PV pv, INEXCEPTION InException)
{
    __asm {

        /* Function prologue */
        push    ebp;
        mov     ebp, esp;                       /* To keep C compiler happy */
        push    ebx;
        push    edi;
        push    esi;

        /*
         *  Build a SEHFRAME.
         */
        push    InException;                    /* What to handle */
        push    offset Exit;                    /* Where to go on error */

        xor     edx, edx;                       /* Keep zero handy */
        push    offset _MyExceptionFilter;      /* My handler */
        push    dword ptr fs:[edx];             /* Build frame */
        mov     fs:[edx], esp;                  /* Link in */
    }

        pfn(pv);                                /* Call the victim */

    __asm {
        /*
         *  The validation layer jumps here (all registers in a random
         *  state except for ESP) if something went wrong.
         *
         *  We don't need to restore nonvolatile registers now;
         *  that will be done as part of the procedure exit.
         */
Exit:;

        xor     edx, edx;                       /* Keep zero handy */
        pop     dword ptr fs:[edx];             /* Remove frame */

        /*
         *  Discard MyExceptionFilter, Exit, and InException.
         */
        add     esp, 12;

        pop     esi;
        pop     edi;
        pop     ebx;
        pop     ebp;
        ret     12;
    }

}

#pragma warning(default:4035)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\setup\inf\en\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\setup\inf\makefile.inc ===
# Makefile for NetMeeting Setup INF files
#
# Generates different INF files for different installations of NetMeeting
#     FULL - Standalone, web-based installation of NetMeeting.
#     ADD-ON - Web-based, IE add-on release of NetMeeting.
#     MEMPHIS - Release of NetMeeting to be released as part of Windows 98 (MEMPHIS)
#     NT5 - Release of NetMeeting to be released as part of NT5
#
#     Separate targets are available to build the debug and retail versions
#     of these components.
#
# HISTORY:
#     20Jun96 dannygl   Created
#     24Sep96 dannygl   Renamed IE3 and IE4 to "FULL" and "ADD-ON",
#                           respectively.
#                       Condense install and remove into a single INF.
#      2Oct96 dannygl   Add NT add-on INF support
#     13Dec96 dannygl   Add temporary support for a Windows 95 version with
#                           32-bit application sharing components.
#     06May97 laurabu   Make 32-bit app sharing components the Win95 default.
#     03Jun97 dannygl   Condense Win95 and NT/x86 targets
#     07Aug97 hammer    Rename "osr2" to "memphis"
#     05Feb98 hammer    Added NT5
#


# Suffixes used by this makefile
.SUFFIXES : .inx .inf

!if "$(BUILD_PRODUCT)" == "NT"
!include $(NTMAKEENV)\makefile.plt
!include $(NTMAKEENV)\$(TARGET_DIRECTORY)mk.inc
CPU=$(TARGET_DIRECTORY)
!endif

# Definitions
# Target directories for INF files
MEMPHISDIR=memphis
NT5DIR=nt5
FULLDIR=full
ADDONDIR=addon

# Base switches for C preprocessor
#
# /EP - Run through the preprocessor only
# /W4 - Warning level 4
# /nologo - Don't display compiler logo
# /c - Don't build an EXE
CFLAGS_BASE=/EP /W4 /nologo /c

# add /DCHAT_MSCHAT to build w/ Microsoft Chat instead of CB32
CFLAGS_FULL=/DIEX_INSTALL
CFLAGS_ADDON=/DIEX_INSTALL /DIE_ADDON

CFLAGS_MEMPHIS=/DWIN_OPTION
CFLAGS_NT5=/DWINNT_INSTALL

CFLAGS_FAREAST=/DFAREAST

CFLAGS_DEBUG=/DDEBUG
CFLAGS_RETAIL=
!if $(FREEBUILD)
CFLAGS_EXTRA=$(CFLAGS_RETAIL)
!else
CFLAGS_EXTRA=$(CFLAGS_DEBUG)
!endif

# All of the INF files that are built in this makefile
ALLINFS= \
!if "$(CPU)"=="I386"
    $(FULLDIR)\$(CPU)\retail\cc32.inf \
    $(FULLDIR)\$(CPU)\debug\cc32.inf \
    $(FULLDIR)\$(CPU)\fareast\cc32.inf \
    $(FULLDIR)\$(CPU)\fareast\msnetmtg.inf \
    $(MEMPHISDIR)\retail\msnetmtg.inf \
    $(MEMPHISDIR)\debug\msnetmtg.inf \
!endif
    $(NT5DIR)\$(CPU)\retail\msnetmtg.inf \
    $(NT5DIR)\$(CPU)\debug\msnetmtg.inf \
    $(FULLDIR)\$(CPU)\retail\msnetmtg.inf \
    $(FULLDIR)\$(CPU)\debug\msnetmtg.inf \
    $(FULLDIR)\$(CPU)\retail\nmrk.inf \
    $(FULLDIR)\$(CPU)\debug\nmrk.inf \
    $(ADDONDIR)\$(CPU)\retail\msnetmtg.inf \
    $(ADDONDIR)\$(CPU)\debug\msnetmtg.inf

# Inference rules
$(O)\msnetmtg.inf: msnetmtg.inx
    $(C_PREPROCESSOR_NAME) $(CFLAGS_NT5) $(CFLAGS_EXTRA) $(C_PREPROCESSOR_FLAGS) $** > $(O)\$**.tmp
    cleaninf -w $(O)\$**.tmp $@
    del $(O)\$**.tmp

{.}.inx{$(FULLDIR)\$(CPU)\retail}.inf:
	 $(CC) $(CFLAGS_BASE) $(CFLAGS_FULL) $(CFLAGS_RETAIL) $< > $*.tmp
    uniq -u $*.tmp > $@
    del $*.tmp

{.}.inx{$(FULLDIR)\$(CPU)\debug}.inf:
	 $(CC) $(CFLAGS_BASE) $(CFLAGS_FULL) $(CFLAGS_DEBUG) $< > $*.tmp
    uniq -u $*.tmp > $@
    del $*.tmp

{.}.inx{$(ADDONDIR)\$(CPU)\retail}.inf:
	 $(CC) $(CFLAGS_BASE) $(CFLAGS_ADDON) $(CFLAGS_RETAIL) $< > $*.tmp
    uniq -u $*.tmp > $@
    del $*.tmp

{.}.inx{$(ADDONDIR)\$(CPU)\debug}.inf:
	 $(CC) $(CFLAGS_BASE) $(CFLAGS_ADDON) $(CFLAGS_DEBUG) $< > $*.tmp
    uniq -u $*.tmp > $@
    del $*.tmp

{.}.inx{$(MEMPHISDIR)\retail}.inf:
	 $(CC) $(CFLAGS_BASE) $(CFLAGS_MEMPHIS) $(CFLAGS_RETAIL) $< > $*.tmp
    uniq -u $*.tmp > $@
    del $*.tmp

{.}.inx{$(MEMPHISDIR)\debug}.inf:
	 $(CC) $(CFLAGS_BASE) $(CFLAGS_MEMPHIS) $(CFLAGS_DEBUG) $< > $*.tmp
    uniq -u $*.tmp > $@
    del $*.tmp

{.}.inx{$(NT5DIR)\$(CPU)\retail}.inf:
!if "$(BUILD_PRODUCT)" == "NT"
         $(C_PREPROCESSOR_NAME) $(CFLAGS_NT5) $(CFLAGS_RETAIL) $(C_PREPROCESSOR_FLAGS) $< > $*.tmp
    cleaninf -w $*.tmp $@
!else
         $(CC) $(CFLAGS_BASE) $(CFLAGS_NT5) $(CFLAGS_RETAIL) $< > $*.tmp
    uniq -u $*.tmp > $@
!endif
    del $*.tmp

{.}.inx{$(NT5DIR)\$(CPU)\debug}.inf:
!if "$(BUILD_PRODUCT)" == "NT"
	 $(C_PREPROCESSOR_NAME) $(CFLAGS_NT5) $(CFLAGS_DEBUG) $(C_PREPROCESSOR_FLAGS) $< > $*.tmp
    cleaninf -w $*.tmp $@
!else
         $(CC) $(CFLAGS_BASE) $(CFLAGS_NT5) $(CFLAGS_DEBUG) $< > $*.tmp
    uniq -u $*.tmp > $@
!endif
    del $*.tmp

!if "$(CPU)"=="I386"
{.}.inx{$(FULLDIR)\$(CPU)\fareast}.inf:
	 $(CC) $(CFLAGS_BASE) $(CFLAGS_FULL) $(CFLAGS_RETAIL) $(CFLAGS_FAREAST) $< >$*.tmp
    uniq -u $*.tmp > $@
    del $*.tmp
!endif

# BUILD TARGETS

# Default build target -- MUST BE FIRST
default: all

$(ALLINFS): ..\..\..\h\version.h ..\common.inx

all: \
!if "$(BUILD_PRODUCT)" != "NT"
    full \
    addon \
    memphis \
!endif

full: fulldirs fullretail fulldebug

addon: addondirs addonretail addondebug

!if "$(CPU)"=="I386"
memphis: memphisdirs memphisretail memphisdebug
!else
memphis:
!endif

alldirs: fulldirs addondirs memphisdirs nt5dirs

retail: alldirs fullretail addonretail memphisretail

debug: alldirs fulldebug addondebug memphisdebug

nt5: nt5dirs nt5retail nt5debug

fulldirs:
    -md $(FULLDIR)
    -md $(FULLDIR)\$(CPU)
!if "$(CPU)"=="I386"
    -md $(FULLDIR)\$(CPU)\fareast
!endif
    -md $(FULLDIR)\$(CPU)\retail
    -md $(FULLDIR)\$(CPU)\debug

addondirs:
    -md $(ADDONDIR)
    -md $(ADDONDIR)\$(CPU)
    -md $(ADDONDIR)\$(CPU)\retail
    -md $(ADDONDIR)\$(CPU)\debug

memphisdirs:
	-md $(MEMPHISDIR)
	-md $(MEMPHISDIR)\retail
	-md $(MEMPHISDIR)\debug

nt5dirs:
	-md $(NT5DIR)
	-md $(NT5DIR)\$(CPU)
	-md $(NT5DIR)\$(CPU)\retail
	-md $(NT5DIR)\$(CPU)\debug

fullretail: fulldirs \
!if "$(CPU)"=="I386"
    $(FULLDIR)\$(CPU)\fareast\msnetmtg.inf \
    $(FULLDIR)\$(CPU)\fareast\cc32.inf \
    $(FULLDIR)\$(CPU)\retail\cc32.inf \
!endif
    $(FULLDIR)\$(CPU)\retail\msnetmtg.inf \
    $(FULLDIR)\$(CPU)\retail\nmrk.inf

fulldebug: fulldirs \
!if "$(CPU)"=="I386"
    $(FULLDIR)\$(CPU)\debug\cc32.inf \
!endif
    $(FULLDIR)\$(CPU)\debug\msnetmtg.inf \
    $(FULLDIR)\$(CPU)\debug\nmrk.inf

addonretail: addondirs $(ADDONDIR)\$(CPU)\retail\msnetmtg.inf

addondebug: addondirs $(ADDONDIR)\$(CPU)\debug\msnetmtg.inf

memphisretail: memphisdirs $(MEMPHISDIR)\retail\msnetmtg.inf

memphisdebug: memphisdirs $(MEMPHISDIR)\debug\msnetmtg.inf

nt5retail: nt5dirs $(NT5DIR)\$(CPU)\retail\msnetmtg.inf

nt5debug: nt5dirs $(NT5DIR)\$(CPU)\debug\msnetmtg.inf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\nmutil\valid.cpp ===
/*
 * valid.c - Validation functions module.
 *
 * Taken from URL code 
 *
 * Created: ChrisPi 9-11-95
 *
 */


/* Headers
 **********/

#include "precomp.h"


/****************************** Public Functions *****************************/


BOOL IsValidHWND(HWND hwnd)
{
   /* Ask User if this is a valid window. */

   return(IsWindow(hwnd));
}


#ifdef DEBUG

BOOL IsValidHANDLE(HANDLE hnd)
{
   return(EVAL(hnd != INVALID_HANDLE_VALUE));
}


BOOL IsValidHEVENT(HANDLE hevent)
{
   return(IsValidHANDLE(hevent));
}


BOOL IsValidHFILE(HANDLE hf)
{
   return(IsValidHANDLE(hf));
}


BOOL IsValidHGLOBAL(HGLOBAL hg)
{
   return(IsValidHANDLE(hg));
}


BOOL IsValidHMENU(HMENU hmenu)
{
   return(IsValidHANDLE(hmenu));
}


BOOL IsValidHINSTANCE(HINSTANCE hinst)
{
   return(IsValidHANDLE(hinst));
}


BOOL IsValidHICON(HICON hicon)
{
   return(IsValidHANDLE(hicon));
}


BOOL IsValidHKEY(HKEY hkey)
{
   return(IsValidHANDLE(hkey));
}


BOOL IsValidHMODULE(HMODULE hmod)
{
   return(IsValidHANDLE(hmod));
}


BOOL IsValidHPROCESS(HANDLE hprocess)
{
   return(IsValidHANDLE(hprocess));
}


BOOL IsValidPCSECURITY_ATTRIBUTES(PCSECURITY_ATTRIBUTES pcsa)
{
   /* BUGBUG: Fill me in. */

   return(IS_VALID_READ_PTR(pcsa, CSECURITY_ATTRIBUTES));
}


BOOL IsValidFileCreationMode(DWORD dwMode)
{
   BOOL bResult;

   switch (dwMode)
   {
      case CREATE_NEW:
      case CREATE_ALWAYS:
      case OPEN_EXISTING:
      case OPEN_ALWAYS:
      case TRUNCATE_EXISTING:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         ERROR_OUT(("IsValidFileCreationMode(): Invalid file creation mode %#lx.",
                    dwMode));
         break;
   }

   return(bResult);
}


BOOL IsValidHTEMPLATEFILE(HANDLE htf)
{
   return(IsValidHANDLE(htf));
}


BOOL IsValidPCFILETIME(PCFILETIME pcft)
{
   /* dwLowDateTime may be any value. */
   /* dwHighDateTime may be any value. */

   return(IS_VALID_READ_PTR(pcft, CFILETIME));
}


BOOL IsValidPCPOINT(PCPOINT pcpt)
{

   /* x may be any value. */
   /* y may be any value. */

   return(IS_VALID_READ_PTR(pcpt, CPOINT));
}


BOOL IsValidPCPOINTL(PCPOINTL pcptl)
{

   /* x may be any value. */
   /* y may be any value. */

   return(IS_VALID_READ_PTR(pcptl, CPOINTL));
}


BOOL IsValidPCWIN32_FIND_DATA(PCWIN32_FIND_DATA pcwfd)
{
   /* BUGBUG: Fill me in. */

   return(IS_VALID_READ_PTR(pcwfd, CWIN32_FIND_DATA));
}


BOOL IsValidShowCmd(int nShow)
{
   BOOL bResult;

   switch (nShow)
   {
      case SW_HIDE:
      case SW_SHOWNORMAL:
      case SW_SHOWMINIMIZED:
      case SW_SHOWMAXIMIZED:
      case SW_SHOWNOACTIVATE:
      case SW_SHOW:
      case SW_MINIMIZE:
      case SW_SHOWMINNOACTIVE:
      case SW_SHOWNA:
      case SW_RESTORE:
      case SW_SHOWDEFAULT:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         ERROR_OUT(("IsValidShowCmd(): Invalid show command %d.",
                    nShow));
         break;
   }

   return(bResult);
}


BOOL IsValidPath(LPCTSTR pcszPath)
{
   /* BUGBUG: Beef up path validation. */

   return(IS_VALID_STRING_PTR(pcszPath, CSTR) &&
          EVAL((UINT)lstrlen(pcszPath) < MAX_PATH));
}

#if defined(UNICODE)
BOOL IsValidPathA(PCSTR pcszPath)
{
   /* BUGBUG: Beef up path validation. */

   return(IS_VALID_STRING_PTR_A(pcszPath, CSTR) &&
          EVAL((UINT)lstrlenA(pcszPath) < MAX_PATH));
}
#endif // defined(UNICODE)

BOOL IsValidPathResult(HRESULT hr, LPCTSTR pcszPath,
                                   UINT ucbPathBufLen)
{
   return((hr == S_OK &&
           EVAL(IsValidPath(pcszPath)) &&
           EVAL((UINT)lstrlen(pcszPath) < ucbPathBufLen)) ||
          (hr != S_OK &&
           EVAL(! ucbPathBufLen ||
                ! pcszPath ||
                ! *pcszPath)));
}


BOOL IsValidExtension(LPCTSTR pcszExt)
{
   return(IS_VALID_STRING_PTR(pcszExt, CSTR) &&
          EVAL(lstrlen(pcszExt) < MAX_PATH) &&
          EVAL(*pcszExt == PERIOD));
}


BOOL IsValidIconIndex(HRESULT hr, LPCTSTR pcszIconFile,
                                  UINT ucbIconFileBufLen, int niIcon)
{
   return(EVAL(IsValidPathResult(hr, pcszIconFile, ucbIconFileBufLen)) &&
          EVAL(hr == S_OK ||
               ! niIcon));
}


BOOL IsValidRegistryValueType(DWORD dwType)
{
   BOOL bResult;

   switch (dwType)
   {
      case REG_NONE:
      case REG_SZ:
      case REG_EXPAND_SZ:
      case REG_BINARY:
      case REG_DWORD:
      case REG_DWORD_BIG_ENDIAN:
      case REG_LINK:
      case REG_MULTI_SZ:
      case REG_RESOURCE_LIST:
      case REG_FULL_RESOURCE_DESCRIPTOR:
      case REG_RESOURCE_REQUIREMENTS_LIST:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         ERROR_OUT(("IsValidRegistryValueType(): Invalid registry value type %lu.",
                    dwType));
         break;
   }

   return(bResult);
}


BOOL IsValidHotkey(WORD wHotkey)
{
   /* BUGBUG: Beef up hotkey validation. */

   return(wHotkey != 0);
}


#ifdef _COMPARISONRESULT_DEFINED_

BOOL IsValidCOMPARISONRESULT(COMPARISONRESULT cr)
{
   BOOL bResult;

   switch (cr)
   {
      case CR_FIRST_SMALLER:
      case CR_EQUAL:
      case CR_FIRST_LARGER:
         bResult = TRUE;
         break;

      default:
         WARNING_OUT(("IsValidCOMPARISONRESULT(): Unknown COMPARISONRESULT %d.",
                      cr));
         bResult = FALSE;
         break;
   }

   return(bResult);
}

#endif   /* _COMPARISONRESULT_DEFINED_ */

#endif   /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\setup\nmmigrat\nmmigrat.c ===
// File: NmMigrat.c
//
// 16-bit Windows 98 Migration DLL for NetMeeting 3.0

#include "NmMigrat.h"
#include "stdio.h"

// Win98 ships with NM 2.1 build 2203 and will force it to be installed
static const char * g_pcszInfNm   =  "msnetmtg.inf";
static const char * g_pcszVersion = "; Version 4,3,0,2203";
static const char * g_pcszHeader  = ";msnetmtg.inf (removed by NmMigrat.dll)\r\n[Version]\r\nsignature=\"$CHICAGO$\"\r\nSetupClass=Base\r\nLayoutFile=layout.inf, layout1.inf, layout2.inf\r\n";


// In Win98's subase.inf, under [winother.oldlinks] there is a bogus line
static const char * g_pcszInfSubase = "subase.inf";
static const char * g_pcszWinOther  = "[winother.oldlinks]";
static const char * g_pcszNukeLink  = "setup.ini, groupPrograms,, \"\"\"%Old_NetMeeting_DESC%\"\"\"";


///////////////////////////////////////////////////////////////////////

typedef struct {
	HFILE hf;             // File Handle
	LONG  lPos;           // current position in the file
	int   ichCurr;        // current character position in rgch
	int   cchRemain;      // number of remaining chars in rgch
	char  rgch[8*1024];   // a really large buffer!
} FD; // File Data


///////////////////////////////////////////////////////////////////////
// Debug Utilities

#ifdef DEBUG
VOID ErrMsg2(LPCSTR pszFormat, LPVOID p1, LPVOID p2)
{
	char szMsg[1024];
	OutputDebugString("NmMigration: ");
	wsprintf(szMsg, pszFormat, p1, p2);
	OutputDebugString(szMsg);
	OutputDebugString("\r\n");
}
VOID ErrMsg1(LPCSTR pszFormat, LPVOID p1)
{
	ErrMsg2(pszFormat, p1, NULL);
}
#else
#define ErrMsg1(psz, p1)
#define ErrMsg2(psz, p1, p2)
#endif /* DEBUG */

///////////////////////////////////////////////////////////////////////


/*  L I B  M A I N  */
/*-------------------------------------------------------------------------
    %%Function: LibMain
    
-------------------------------------------------------------------------*/
int FAR PASCAL LibMain(HANDLE hInst, WORD wDataseg, WORD wHeapsize, LPSTR lpszcmdl)
{
	Reference(hInst);
	Reference(wDataseg);
	Reference(wHeapsize);
	Reference(lpszcmdl);

    return 1;
}



/*  F  O P E N  F I L E  */
/*-------------------------------------------------------------------------
    %%Function: FOpenFile

    Open the file from the temporary Win98 INF directory.
-------------------------------------------------------------------------*/
BOOL FOpenFile(LPCSTR pszFile, FD * pFd, BOOL fCreate)
{
	char szPath[MAX_PATH];

	// LDID_SETUPTEMP = temp INF directory "C:\WININST0.400"
	UINT retVal = CtlGetLddPath(LDID_SETUPTEMP, szPath);
	if (0 != retVal)
	{
		ErrMsg1("CtlGetLddPath(TEMP) failed. Err=%d", (LPVOID) retVal);
		return FALSE;
	}

	// Nuke the temporary 2.1 inf so it doesn't get installed
	lstrcat(szPath, "\\");
	lstrcat(szPath, pszFile);

	if (fCreate)
	{
		pFd->hf = _lcreat(szPath, 0); // read/write
	}
	else
	{
		pFd->hf = _lopen(szPath, OF_READWRITE);
	}
	
	if (HFILE_ERROR == pFd->hf)
	{
		ErrMsg2("Unable to open [%s]  Error=%d", szPath, (LPVOID) GetLastError());
		return FALSE;
	}

	pFd->lPos = 0;
	pFd->ichCurr = 0;
	pFd->cchRemain = 0;

	ErrMsg1("Opened [%s]", szPath);
	return TRUE;
}


/*  R E A D  L I N E  */
/*-------------------------------------------------------------------------
    %%Function: ReadLine

    Read a line (up to MAX_PATH chars) from the buffered file.
    Returns the number of characters read.
-------------------------------------------------------------------------*/
int ReadLine(char * pchDest, FD * pFd)
{
	int cch;

	for (cch = 0; cch < MAX_PATH; cch++)
	{
		if (0 == pFd->cchRemain)
		{
			pFd->cchRemain = _lread(pFd->hf, pFd->rgch, sizeof(pFd->rgch));
			if (HFILE_ERROR == pFd->cchRemain)
			{
				ErrMsg1("End of file reached at pos=%d", (LPVOID) pFd->lPos);
				break;
			}
			pFd->ichCurr = 0;
		}

		pFd->lPos++;
		pFd->cchRemain--;
		*pchDest = pFd->rgch[pFd->ichCurr++];
		if ('\n' == *pchDest)
		{
			break;
		}
		if ('\r' != *pchDest)
		{
			 pchDest++;
		}
	}

	*pchDest = '\0';  // Always null terminate the string
	return cch;
}

	

/*  R E M O V E  I N F  */
/*-------------------------------------------------------------------------
    %%Function: RemoveInf

    Remove the NM2.1 inf from Win98's list of inf's
-------------------------------------------------------------------------*/
void RemoveInf(void)
{
	FD fd;

	if (!FOpenFile(g_pcszInfNm, &fd, FALSE))
	{
		return;
	}

	for ( ; ; )  // Find the version comment before the first section
	{
		char szLine[MAX_PATH];
		if (0 == ReadLine(szLine, &fd))
		{
			break;
		}

		if ('[' == szLine[0])
		{
			ErrMsg1("No version number found?", 0);
			break;
		}

		// Must match build 2203 since a Win98 update or an OEM
		// could ship a newer version than NM 2.11, which we would
		// want to upgrade us.
		if (0 == lstrcmp(szLine, g_pcszVersion))
		{
			// Re-write the older MSNETMTG.INF with a empty header
			_lclose(fd.hf);

			if (FOpenFile(g_pcszInfNm, &fd, TRUE))
			{
				_llseek(fd.hf, 0, 0);
				_lwrite(fd.hf, (LPCSTR) g_pcszHeader, lstrlen(g_pcszHeader)+1);
				ErrMsg1("Removed older NetMeeting INF", 0);
			}
			break;
		}
	}

	_lclose(fd.hf);
}



/*  F I X  S U B A S E  */
/*-------------------------------------------------------------------------
    %%Function: FixSubase

    Delete the line from subase.inf that deletes the NetMeeting link.
    See NM4DB bug 5937, Win98 bug 65154.
    This code shouldn't be necessary with Win98 SP1 and later.
-------------------------------------------------------------------------*/
void FixSubase(void)
{
	FD    fd;
	char  szLine[MAX_PATH];

	if (!FOpenFile(g_pcszInfSubase, &fd, FALSE))
		return;

	for ( ; ; )  // Find the section 
	{
		if (0 == ReadLine(szLine, &fd))
		{
			break;
		}

		if (('[' == szLine[0]) && (0 == lstrcmp(szLine, g_pcszWinOther)))
		{
			ErrMsg1("Found the section at pos=%d", (LPVOID) fd.lPos);
			break;
		}
	}

	for ( ; ; )  // Find the line
	{
		LONG lPosPrev = fd.lPos; // Remember the start of the line

		if (0 == ReadLine(szLine, &fd))
		{
			break;
		}

		if (0 == lstrcmp(szLine, g_pcszNukeLink))
		{
			// comment out the line
			_llseek(fd.hf, lPosPrev, 0 /* FILE_BEGIN */);
			_lwrite(fd.hf, (LPCSTR) ";", 1);
			ErrMsg1("Commented out line at pos=%d", (LPVOID) lPosPrev);
			break;				
		}

		if ('[' == szLine[0])
		{
			ErrMsg1("End of section? at pos=%d", (LPVOID) lPosPrev);
			break;
		}
	}

	_lclose(fd.hf);
}



/*  N M  M I G R A T I O N  */
/*-------------------------------------------------------------------------
    %%Function: NmMigration

    This is called by the Windows 98 setup system.
-------------------------------------------------------------------------*/
DWORD FAR PASCAL NmMigration(DWORD dwStage, LPSTR lpszParams, LPARAM lParam)
{
	Reference(lpszParams);
	Reference(lParam);

	ErrMsg2("NM Build=[%s] stage=%08X", lpszParams, (LPVOID) dwStage);

	switch (dwStage)
	{
	case SU_MIGRATE_PREINFLOAD:
	{
		RemoveInf();
		FixSubase();
		break;
	}

	default:
		break;
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\setup\nmmigrat\nmmigrat.h ===
// File: nmmigrat.h

#include <windows.h>

// from windows.h
UINT    WINAPI DeletePathname(LPCSTR);      /* ;Internal */

// From setupx.h

// Migration DLLs
#define SU_MIGRATE_PREINFLOAD    0x00000001	// before the setup INFs are loaded
#define SU_MIGRATE_POSTINFLOAD   0x00000002	// after the setup INFs are loaded
#define SU_MIGRATE_DISKSPACE     0x00000010	// request for the amount of additional diskspace needed
#define SU_MIGRATE_PREQUEUE      0x00000100	// before the INFs are processed and files are queued
#define SU_MIGRATE_POSTQUEUE     0x00000200	// after INFs are processed
#define SU_MIGRATE_REBOOT        0x00000400	// just before we are going to reboot for the 1st time
#define SU_MIGRATE_PRERUNONCE    0x00010000	// before any runonce items are processed
#define SU_MIGRATE_POSTRUNONCE   0x00020000	// after all runonce items are processed

// temporary setup directory used by setup, this is only valid durring
// regular install and contains the INF and other binary files.  May be
// read-only location.
#define LDID_SETUPTEMP  2   // temporary setup dir for install

#define LDID_INF        17  // destination Windows *.INF dir.

// RETERR WINAPI CtlGetLddPath ( LOGDISKID, LPSTR );
UINT WINAPI CtlGetLddPath(UINT, LPSTR);

#define Reference(x)      { if (x) ; }

// Prototype for exported function
DWORD FAR PASCAL NmMigration(DWORD dwStage, LPSTR lpszParams, LPARAM lParam);

#ifndef MAX_PATH
#define MAX_PATH  260
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\setup\nmmigrat\makefile.inc ===
#
# makefile.inc for 16-bit components
#

C16_NAME = $(DEVROOT)\bin\c816\i386\cl -nologo
C16_FLAGS = $(C16_FLAGS) -I$(DEVROOT)\inc16 -I$(DEVROOT)\inc -Fd$(MAKEDIR)\$(_OBJ_DIR)\i386^\
ASM_NAME = $(DEVROOT)\bin\masm611\ml
ASM_FLAGS = -c -W2 $(ASM_FLAGS)

!IF "$(BUILD_ALT_DIR)" == "d"
C16_FLAGS = $(C16_FLAGS) -Zi -DDEBUG
ASM_FLAGS = $(ASM_FLAGS) -Zi -DDEBUG=1
LINK16_FLAGS = $(LINK16_FLAGS) /LI
!ENDIF

{}.asm{$(O)\}.obj:
    @type <<$(ECHO_RSP)
$(ASM_NAME) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$(<F) $(ASM_FLAGS)
<<NOKEEP
    @$(ASM_NAME) @<<$(CL_RSP) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$(<F)
$(ASM_FLAGS)
<<NOKEEP

{}.c{$(O)\}.obj:
    @type <<$(ECHO_RSP)
$(C16_NAME) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$(<F) $(C16_FLAGS)
<<NOKEEP
    @$(C16_NAME) @<<$(CL_RSP) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$(<F)
$(C16_FLAGS: =
)
<<NOKEEP


$(O)\$(TARGETNAME).res: $(TARGETNAME).rc
    $(DEVROOT)\bin\c816\i386\rc -r -I $(DEVROOT)\inc16 -I $(ROOT)\h -fo $@ $(TARGETNAME).rc

$(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).lib:	$(TARGETNAME).def
	@echo skipping creation of $(TARGETNAME).lib

$(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).exp:	$(TARGETNAME).def
	@echo skipping createion of $(TARGETNAME).exp

$(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).dll: $(OBJECTS) $(LINKLIBS) $(CRTLIBS) $(MACHINE_TARGETLIBS) $(O)\$(TARGETNAME).res
	$(DEVROOT)\bin\c816\i386\link @<<
	$(OBJECTS) /align:0x1000 /nodefaultlib /NOE/MAP/NOD/AL:16/NOPACKC/ONERROR:NOEXE $(LINK16_FLAGS),
	$(TARGET),
	$(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).map,
	$(TARGETLIBS),
	$(TARGETNAME).def
<<
    $(DEVROOT)\bin\c816\i386\rc $(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).res $(TARGET)
    $(SPLITSYM_CMD)
    $(TARGETCOPY_CMD)
    $(PDBCOPY_CMD)
    $(DBGCOPY_CMD)
    $(MAPSYM_CMD)
    $(MAPCOPY_CMD)
    $(SYMCOPY_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\setup\nmmigrat\setupx.h ===
//**********************************************************************
//
// SETUPX.H
//
//  Copyright (c) 1993 - Microsoft Corp.
//  All rights reserved.
//  Microsoft Confidential
//
// Public include file for Chicago Setup services.
//
// 12/1/93      DONALDM     Added LPCLASS_INFO, and function protos for         ;Internal
//                          exports in SETUP4.DLL                               ;Internal
// 12/4/943     DONALDM     Moved SHELL.H include and Chicago specific          ;Internal
//                          helper functions to SETUP4.H                        ;Internal
// 1/11/94      DONALDM     Added members to DEVICE_INFO to better handle       ;Internal
//                          ClassInstaller load/unload.                         ;Internal
// 1/11/94      DONALDM     Added some new DIF_ messages for Net guys.          ;Internal
// 2/25/94      DONALDM     Fixed a bug with the DIREG_ flags                   ;Internal
//**********************************************************************

#ifndef SETUPX_INC
#define SETUPX_INC   1                   // SETUPX.H signature

/***************************************************************************/
// setup PropertySheet support
// NOTE:  Always include PRST.H because it is needed later for Class Installer
// stuff, and optionally define the SU prop sheet stuff.
/***************************************************************************/
#include <prsht.h>
#ifndef NOPRSHT
HPROPSHEETPAGE  WINAPI SUCreatePropertySheetPage(LPCPROPSHEETPAGE lppsp);
BOOL            WINAPI SUDestroyPropertySheetPage(HPROPSHEETPAGE hPage);
int             WINAPI SUPropertySheet(LPCPROPSHEETHEADER lppsh);
#endif // NOPRSHT

typedef UINT RETERR;             // Return Error code type.

#define OK 0                     // success error code

#define IP_ERROR       (100)    // Inf parsing
#define TP_ERROR       (200)    // Text processing module
#define VCP_ERROR      (300)    // Virtual copy module
#define GEN_ERROR      (400)    // Generic Installer
#define DI_ERROR       (500)    // Device Installer

// err2ids mappings
enum ERR_MAPPINGS {
    E2I_VCPM,           // Maps VCPM to strings
    E2I_SETUPX,         // Maps setupx returns to strings
    E2I_SETUPX_MODULE,  // Maps setupx returns to appropriate module
    E2I_DOS_SOLUTION,   // Maps DOS Extended errors to solutions
    E2I_DOS_REASON,     // Maps DOS extended errors to strings.
    E2I_DOS_MEDIA,      // Maps DOS extended errors to media icon.
};

#ifndef NOVCP

/***************************************************************************/
//
// Logical Disk ID definitions
//
/***************************************************************************/

// DECLARE_HANDLE(VHSTR);           /* VHSTR = VirtCopy Handle to STRing */
typedef UINT VHSTR;         /* VirtCopy Handle to String */

VHSTR   WINAPI vsmStringAdd(LPCSTR lpszName);
int WINAPI vsmStringDelete(VHSTR vhstr);
VHSTR   WINAPI vsmStringFind(LPCSTR lpszName);
int WINAPI vsmGetStringName(VHSTR vhstr, LPSTR lpszBuffer, int cbBuffer);
int WINAPI vsmStringCompare(VHSTR vhstrA, VHSTR vhstrB);
LPCSTR  WINAPI vsmGetStringRawName(VHSTR vhstr);
void    WINAPI vsmStringCompact(void);

typedef UINT LOGDISKID;          /* ldid */

// Logical Disk Descriptor: Structure which describes the physical attributes
// of a logical disk. Every logical disk is assigned a logical disk
// identifier (LDID), and is described by a logical disk descriptor (LDD).
//
// The cbSize structure member must always be set to sizeof(LOGDISKDESC_S),
// but all other unused structure members should be NULL or 0. No validation
// is performed on the size of string arrays; all string pointers, if
// non-NULL and they are to receive a string, must point at string arrays
// whose sizes are as follows:
//      sizeof( szPath )    = MAX_PATH_LEN
//      sizeof( szVolLabel) = MAX_FILENAME_LEN
//      sizeof( szName )    = MAX_STRING_LEN
#define MAX_PATH_LEN        260     // Max. path length.
#define MAX_FILENAME_LEN    20      // Max. filename length. ( > sizeof( "x:\\12345678.123" )


typedef struct _LOGDISKDESC_S { /* ldd */
    WORD        cbSize;                 // Size of this structure (bytes)
    LOGDISKID   ldid;                   // Logical Disk ID.
    LPSTR       pszPath;                // Ptr. to associated Path string.
    LPSTR       pszVolLabel;            // Ptr. to Volume Label string.
    LPSTR       pszDiskName;            // Ptr. to Disk Name string.
    WORD        wVolTime;               // Volume label modification time.
    WORD        wVolDate;               // Volume label modification date.
    DWORD       dwSerNum;               // Disk serial number.
    WORD        wFlags;                 // Flags.
} LOGDISKDESC_S, FAR *LPLOGDISKDESC;



// Range for pre-defined LDIDs.
#define LDID_PREDEF_START   0x0001  // Start of range
#define LDID_PREDEF_END     0x7FFF  // End of range

// Range for registry-assigned LDIDs
#define LDID_VAR_START  0x7000
#define LDID_VAR_END    0x7FFF

// Range for dynamically-assigned LDIDs.
#define LDID_ASSIGN_START   0x8000  // Start of range
#define LDID_ASSIGN_END     0xBFFF  // End of range

// Pre-defined Logical Disk Identifiers (LDID).
//
#define LDID_NULL       0               // Null (undefined) LDID.
#define LDID_ABSOLUTE   ((UINT)-1)      // Absolute path

// source path of windows install, this is typically A:\ or a net drive
#define LDID_SRCPATH    1   // source of instilation
// temporary setup directory used by setup, this is only valid durring
// regular install and contains the INF and other binary files.  May be
// read-only location.
#define LDID_SETUPTEMP  2   // temporary setup dir for install
// path to uninstall location, this is where we backup files that will
// be overwritten
#define LDID_UNINSTALL  3   // uninstall (backup) dir.
// backup path for the copy engine, this should not be used
#define LDID_BACKUP     4   // BUGBUG: backup dir for the copy engine, not used
// temporary setup directory used by setup, this is only valid durring
// regular install and is guarenteed to be a read/write location for
// scratch space.
#define LDID_SETUPSCRATCH  5   // temporary setup dir for scratch space.

// windows directory, this is the destinatio of the insallation
#define LDID_WIN        10  // destination Windows dir (just user files).
#define LDID_SYS        11  // destination Windows System dir.
#define LDID_IOS        12  // destination Windows Iosubsys dir.
#define LDID_CMD        13  // destination Windows Command (DOS) dir.
#define LDID_CPL        14  // destination Windows Control Panel dir.
#define LDID_PRINT      15  // destination Windows Printer dir.
#define LDID_MAIL       16  // destination Mail dir.
#define LDID_INF        17  // destination Windows *.INF dir.
#define LDID_HELP       18  // destination Windows Help dir.
#define LDID_WINADMIN   19  // admin stuff.

#define LDID_FONTS      20  // destination Windows Font dir.
#define LDID_VIEWERS    21  // destination Windows Viewers dir.
#define LDID_VMM32      22  // destination Windows VMM32 dir.
#define LDID_COLOR      23  // destination Windows Color dir.

#define LDID_APPS       24  // Applications folder location.

// Shared dirs for net install.
#define LDID_SHARED     25  // Bulk of windows files.
#define LDID_WINBOOT    26  // guarenteed boot device for windows.
#define LDID_MACHINE    27  // machine specific files.
#define LDID_HOST_WINBOOT   28

// boot and old win and dos dirs.
#define LDID_BOOT       30  // Root dir of boot drive
#define LDID_BOOT_HOST  31  // Root dir of boot drive host
#define LDID_OLD_WINBOOT    32  // Subdir off of Root (optional)
#define LDID_OLD_WIN    33  // old windows directory (if it exists)
#define LDID_OLD_DOS    34  // old dos directory (if it exists)

#define LDID_OLD_NET    35  // old network root directory, only valid during
                            // network GenUpgrade

#define LDID_MOUSE      36  // path to MOUSE env. variable if set or same as LDID_WIN
                            // only valid after mouse class installer.
#define LDID_PATCH      37  // path to Patch related files
#define LDID_WIN3XIE    38  // install path of Internet Explorer on Windows 3.1
                            // Only defined during system install

// Convert Ascii drive letter to Integer drive number ('A'=1, 'B'=2, ...).
#define DriveAtoI( chDrv )      ((int)(chDrv & 31))

// Convert Integer drive number to Ascii drive letter (1='A', 2='B', ...).
#define DriveItoA( iDrv )       ((char) (iDrv - 1 + 'A'))


// BUGBUG: change the names of these

RETERR WINAPI CtlSetLdd     ( LPLOGDISKDESC );
RETERR WINAPI CtlGetLdd     ( LPLOGDISKDESC );
RETERR WINAPI CtlFindLdd    ( LPLOGDISKDESC );
RETERR WINAPI CtlAddLdd     ( LPLOGDISKDESC );
RETERR WINAPI CtlDelLdd     ( LOGDISKID  );
RETERR WINAPI CtlGetLddPath ( LOGDISKID, LPSTR );
RETERR WINAPI CtlSetLddPath ( LOGDISKID, LPSTR );


// Constants that determine ranking of device compatibility
#define FIRST_CID_RANK_FROM_INF		1000
#define FIRST_CID_RANK_FROM_DEVICE	2000
#define BAD_DRIVER_RANK             4000

/***************************************************************************/
//
// Virtual File Copy definitions
//
/***************************************************************************/


typedef DWORD LPEXPANDVTBL;         /* BUGBUG -- clean this up */

enum _ERR_VCP
{
    ERR_VCP_IOFAIL = (VCP_ERROR + 1),       // File I/O failure
    ERR_VCP_STRINGTOOLONG,                  // String length limit exceeded
    ERR_VCP_NOMEM,                          // Insufficient memory to comply
    ERR_VCP_QUEUEFULL,                      // Trying to add a node to a maxed-out queue
    ERR_VCP_NOVHSTR,                        // No string handles available
    ERR_VCP_OVERFLOW,                       // Reference count would overflow
    ERR_VCP_BADARG,                         // Invalid argument to function
    ERR_VCP_UNINIT,                         // String library not initialized
    ERR_VCP_NOTFOUND ,                      // String not found in string table
    ERR_VCP_BUSY,                           // Can't do that now
    ERR_VCP_INTERRUPTED,                    // User interrupted operation
    ERR_VCP_BADDEST,                        // Invalid destination directory
    ERR_VCP_SKIPPED,                        // User skipped operation
    ERR_VCP_IO,                             // Hardware error encountered
    ERR_VCP_LOCKED,                         // List is locked
    ERR_VCP_WRONGDISK,                      // The wrong disk is in the drive
    ERR_VCP_CHANGEMODE,                     //
    ERR_VCP_LDDINVALID,                     // Logical Disk ID Invalid.
    ERR_VCP_LDDFIND,                        // Logical Disk ID not found.
    ERR_VCP_LDDUNINIT,                      // Logical Disk Descriptor Uninitialized.
    ERR_VCP_LDDPATH_INVALID,
    ERR_VCP_NOEXPANSION,                    // Failed to load expansion dll
    ERR_VCP_NOTOPEN,                        // Copy session not open
    ERR_VCP_NO_DIGITAL_SIGNATURE_CATALOG,   // Catalog is not digitally signed
    ERR_VCP_NO_DIGITAL_SIGNATURE_FILE,      // A file is not digitally signed
};


/*****************************************************************************
 *              Structures
 *****************************************************************************/

/*---------------------------------------------------------------------------*
 *                  VCPPROGRESS
 *---------------------------------------------------------------------------*/

typedef struct tagVCPPROGRESS { /* prg */
    DWORD   dwSoFar;            /* Number of units copied so far */
    DWORD   dwTotal;            /* Number of units to copy */
} VCPPROGRESS, FAR *LPVCPPROGRESS;

/*---------------------------------------------------------------------------*
 *                  VCPDISKINFO
 *---------------------------------------------------------------------------*/

/* BUGBUG -- I currently don't use wVolumeTime, wVolumeDate or     ;Internal
 *  dwSerialNumber.  We may not want to use dwSerialNumber because ;Internal
 *  it means that any disk other than the factory originals will be;Internal
 *  suspected of being tampered with, since the serial number      ;Internal
 *  won't match.  Similar with the time/date stamp on the          ;Internal
 *  volume label.  Or maybe that's what we want to do.             ;Internal
 */                                                             /* ;Internal */
                                                                /* ;Internal */

typedef struct tagVCPDISKINFO {
    WORD        cbSize;         /* Size of this structure in bytes */
    LOGDISKID   ldid;           /* Logical disk ID */
    VHSTR       vhstrRoot;      /* Location of root directory */
    VHSTR       vhstrVolumeLabel;/* Volume label */
    VHSTR       vhstrDiskName;  // Printed name on the disk.
    WORD        wVolumeTime;    /* Volume label modification time */
    WORD        wVolumeDate;    /* Volume label modification date */
    DWORD       dwSerialNumber; /* Disk serial number */
    WORD        fl;             /* Flags */
    LPARAM      lparamRef;      /* Reference data for client */

    VCPPROGRESS prgFileRead;    /* Progress info */
    VCPPROGRESS prgByteRead;

    VCPPROGRESS prgFileWrite;
    VCPPROGRESS prgByteWrite;

} VCPDISKINFO, FAR *LPVCPDISKINFO;

#define VDIFL_VALID     0x0001  /* Fields are valid from a prev. call */
#define VDIFL_EXISTS    0x0002  /* Disk exists; do not format */

RETERR WINAPI DiskInfoFromLdid(LOGDISKID ldid, LPVCPDISKINFO lpdi);


/*---------------------------------------------------------------------------*
 *                  VCPFILESPEC
 *---------------------------------------------------------------------------*/

typedef struct tagVCPFILESPEC { /* vfs */
    LOGDISKID   ldid;           /* Logical disk */
    VHSTR       vhstrDir;       /* Directory withing logical disk */
    VHSTR       vhstrFileName;  /* Filename within directory */
} VCPFILESPEC, FAR *LPVCPFILESPEC;

/*---------------------------------------------------------------------------*
 *              VCPFATTR
 *---------------------------------------------------------------------------*/

/*
 * BUGBUG -- explain diffce between llenIn and llenOut wrt compression.
 */
typedef struct tagVCPFATTR {
    UINT    uiMDate;            /* Modification date */
    UINT    uiMTime;            /* Modification time */
    UINT    uiADate;            /* Access date */
    UINT    uiATime;            /* Access time */
    UINT    uiAttr;             /* File attribute bits */
    DWORD   llenIn;             /* Original file length */
    DWORD   llenOut;            /* Final file length */
                                /* (after decompression) */
} VCPFATTR, FAR *LPVCPFATTR;

typedef struct tagVCPFILESTAT
{
    UINT    uDate;
    UINT    uTime;
    DWORD   dwSize;
} VCPFILESTAT, FAR *LPVCPFILESTAT;

/*---------------------------------------------------------------------------*
 *                  VIRTNODEEX
 *---------------------------------------------------------------------------*/
typedef struct tagVIRTNODEEX
{    /* vnex */
    HFILE           hFileSrc;
    HFILE           hFileDst;
    VCPFATTR        fAttr;
    WORD            dosError;   // The first/last error encountered
    VHSTR           vhstrFileName;  // The original destination name.
    WPARAM          vcpm;   // The message that was being processed.
} VIRTNODEEX, FAR *LPCVIRTNODEEX, FAR *LPVIRTNODEEX ;


/*---------------------------------------------------------------------------*
 *                  VIRTNODE
 *---------------------------------------------------------------------------*/

/* WARNING!                                                        ;Internal
 *  All fields through but not including                           ;Internal
 *  fl are memcmp'd to determine if we have a duplicate copy       ;Internal
 *  request.                                                       ;Internal
 *                                                                 ;Internal
 *  Do not insert fields before fl unless you want them to be      ;Internal
 *  compared; conversely, if you add a new field that needs to     ;Internal
 *  be compared, make sure it goes before fl.                      ;Internal
 *                                                                 ;Internal
 *  And don't change any of the fields once Windows 4.0 ships.     ;Internal
 *                                                                 ;Internal
 *  The vFileStat and vhstrCatalogFile fields were added at the    ;Internal
 *  end of the structure after Windows 95 shipped to support driver;Internal
 *  cetification.  Offsets of pre-Win95 fields remain the same.    ;Internal
 *  vFileStat duplicates information in lpvnex, but lpvnex was left;Internal
 *  alone for backcompatibility's sake.                            ;Internal
 *                                                                 ;Internal
 */                                                             /* ;Internal */
                                                                /* ;Internal */
typedef struct tagVIRTNODE {    /* vn */
    WORD            cbSize;
    VCPFILESPEC     vfsSrc;
    VCPFILESPEC     vfsDst;
    WORD            fl;
    LPARAM          lParam;
    LPEXPANDVTBL    lpExpandVtbl;
    LPVIRTNODEEX    lpvnex;
    VHSTR           vhstrDstFinalName;
    VCPFILESTAT     vFileStat;
} VIRTNODE, FAR *LPCVIRTNODE, FAR *LPVIRTNODE ;


/*---------------------------------------------------------------------------*
 *              VCPDESTINFO
 *---------------------------------------------------------------------------*/

typedef struct tagVCPDESTINFO { /* destinfo */
    WORD    flDevAttr;          /* Device attributes */
    LONG    cbCapacity;         /* Disk capacity */
    WORD    cbCluster;          /* Bytes per cluster */
    WORD    cRootDir;           /* Size of root directory */
} VCPDESTINFO, FAR *LPVCPDESTINFO;

#define DIFL_FIXED      0x0001  /* Nonremoveable media */
#define DIFL_CHANGELINE 0x0002  /* Change line support */

// Now also used by the virtnode as we dont have copy nodes any more.
// #define CNFL_BACKUP             0x0001  /* This is a backup node */
#define CNFL_DELETEONFAILURE    0x0002  /* Dest should be deleted on failure */
#define CNFL_RENAMEONSUCCESS    0x0004  /* Dest needs to be renamed */
#define CNFL_CONTINUATION       0x0008  /* Dest is continued onto difft disk */
#define CNFL_SKIPPED            0x0010  /* User asked to skip file */
#define CNFL_IGNOREERRORS       0x0020  // An error has occured on this file already
#define CNFL_RETRYFILE          0x0040  // Retry the file (error ocurred)
#define CNFL_COPIED             0x0080  // Node has already been copied.

// BUGBUG: verify the use and usefullness of these flags
// #define VNFL_UNIQUE          0x0000  /* Default */
#define VNFL_MULTIPLEOK         0x0100  /* Do not search PATH for duplicates */
#define VNFL_DESTROYOLD         0x0200  /* Do not back up files */
// #define VNFL_NOW             0x0400  /* Use by vcp Flush */
// To deternime what kind of node it is.
#define VNFL_COPY               0x0000  // A simple copy node.
#define VNFL_DELETE             0x0800  // A delete node
#define VNFL_RENAME             0x1000  // A rename node
#define VNFL_NODE_TYPE          ( VNFL_RENAME|VNFL_DELETE|VNFL_COPY )
    /* Read-only flag bits */
#define VNFL_CREATED            0x2000  /* VCPM_NODECREATE has been sent */
#define VNFL_REJECTED           0x4000  /* Node has been rejected */

#define VNFL_DEVICEINSTALLER    0x8000     /* Node was added by the Device Installer */

#define VNFL_VALIDVQCFLAGS      0xff00  /* ;Internal */

/*---------------------------------------------------------------------------*
 *                  VCPSTATUS
 *---------------------------------------------------------------------------*/

typedef struct tagVCPSTATUS {   /* vstat */
    WORD    cbSize;             /* Size of this structure */

    VCPPROGRESS prgDiskRead;
    VCPPROGRESS prgFileRead;
    VCPPROGRESS prgByteRead;

    VCPPROGRESS prgDiskWrite;
    VCPPROGRESS prgFileWrite;
    VCPPROGRESS prgByteWrite;

    LPVCPDISKINFO lpvdiIn;      /* Current input disk */
    LPVCPDISKINFO lpvdiOut;     /* Current output disk */
    LPVIRTNODE    lpvn;            /* Current file */

} VCPSTATUS, FAR *LPVCPSTATUS;

/*---------------------------------------------------------------------------*
 *                  VCPVERCONFLICT
 *---------------------------------------------------------------------------*/

typedef struct tagVCPVERCONFLICT {

    LPCSTR  lpszOldFileName;
    LPCSTR  lpszNewFileName;
    DWORD   dwConflictType;     /* Same values as VerInstallFiles */
    LPVOID  lpvinfoOld;         /* Version information resources */
    LPVOID  lpvinfoNew;
    WORD    wAttribOld;         /* File attributes for original */
    LPARAM  lparamRef;          /* Reference data for callback */

} VCPVERCONFLICT, FAR *LPVCPVERCONFLICT;

/*****************************************************************************
 *              Callback functions
 *****************************************************************************/

typedef LRESULT (CALLBACK *VIFPROC)(LPVOID lpvObj, UINT uMsg, WPARAM wParam, LPARAM lParam, LPARAM lparamRef);

LRESULT CALLBACK vcpDefCallbackProc(LPVOID lpvObj, UINT uMsg, WPARAM wParam, LPARAM lParam, LPARAM lparamRef);

// callback for default UI.
// lparamRef --> a VCPUIINFO structure
LRESULT CALLBACK vcpUICallbackProc(LPVOID lpvObj, UINT uMsg, WPARAM wParam, LPARAM lParam, LPARAM lparamRef);


/*---------------------------------------------------------------------------*
 *                  VCPUIINFO
 *
 * This structure is passed in as the lparamRef of vcpUICallbackProc.
 *
 * on using vcpUICallbackProc:
 * - to use, have vcpUICallbackProc as the callback for vcpOpen with
 *   an appropriately filled in VCPUIINFO structure as the lparamRef.
 *
 * - based on flags, hwndProgress is created and maintained
 * - lpfnStatCallback is called with only status messages
 *     returning VCPM_ABORT indicates that the copy should be aborted
 * - if hwndProgress is non-NULL, the control with idProgress will
 *     receive progress gauge messages as appropriate
 *
 *---------------------------------------------------------------------------*/
#define VCPUI_CREATEPROGRESS 0x0001 // callback should create and manage progress gauge dialog
#define VCPUI_NOBROWSE       0x0002 // no browse button in InsertDisk
#define VCPUI_RENAMEREQUIRED 0x0004 // as a result of a file being in use at copy, reboot required
#define VCPUI_BACKUPVER      0x0008 // backup version conflicts instead of displaying UI

typedef struct {
    UINT flags;
    HWND hwndParent;            // window of parent
    HWND hwndProgress;          // window to get progress updates (nonzero ids)
    UINT idPGauge;              // id for progress gauge
    VIFPROC lpfnStatCallback;   // callback for status info (or NULL)
    LPARAM lUserData;           // caller definable data
    LOGDISKID ldidCurrent;      // reserved.  do not touch.
} VCPUIINFO, FAR *LPVCPUIINFO;

/******************************************************************************
 *          Callback notification codes
 *****************************************************************************/

    /* BUGBUG -- VCPN_ABORT should match VCPERROR_INTERRUPTED */

#define VCPN_OK         0       /* All is hunky-dory */
#define VCPN_PROCEED        0   /* The same as VCPN_OK */

#define VCPN_ABORT      (-1)    /* Cancel current operation */
#define VCPN_RETRY      (-2)    /* Retry current operation */
#define VCPN_IGNORE     (-3)    /* Ignore error and continue */
#define VCPN_SKIP       (-4)    /* Skip this file and continue */
#define VCPN_FORCE      (-5)    /* Force an action */
#define VCPN_DEFER      (-6)    /* Save the action for later */
#define VCPN_FAIL       (-7)    /* Return failure back to caller */
#define VCPN_RETRYFILE  (-8)    // An error ocurred during file copy, do it again.

/*****************************************************************************
 *          Callback message numbers
 *****************************************************************************/

#define VCPM_CLASSOF(uMsg)  HIBYTE(uMsg)
#define VCPM_TYPEOF(uMsg)   (0x00FF & (uMsg))   // LOBYTE(uMsg)

/*---------------------------------------------------------------------------*
 *          ERRORs
 *---------------------------------------------------------------------------*/

#define VCPM_ERRORCLASSDELTA    0x80
#define VCPM_ERRORDELTA         0x8000      /* Where the errors go */

/*---------------------------------------------------------------------------*
 *          Disk information callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_DISKCLASS      0x01
#define VCPM_DISKFIRST      0x0100
#define VCPM_DISKLAST       0x01FF

enum tagVCPM_DISK {

    VCPM_DISKCREATEINFO = VCPM_DISKFIRST,
    VCPM_DISKGETINFO,
    VCPM_DISKDESTROYINFO,
    VCPM_DISKPREPINFO,

    VCPM_DISKENSURE,
    VCPM_DISKPROMPT,

    VCPM_DISKFORMATBEGIN,
    VCPM_DISKFORMATTING,
    VCPM_DISKFORMATEND,

    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          File copy callbacks
 *---------------------------------------------------------------------------*/

// BUGBUG: this needs to be merged back with other internal errors
#define VCPERROR_IO         (VCP_ERROR - ERR_VCP_IO)            /* Hardware error encountered */

#define VCPM_FILEINCLASS    0x02
#define VCPM_FILEOUTCLASS   0x03
#define VCPM_FILEFIRSTIN    0x0200
#define VCPM_FILEFIRSTOUT   0x0300
#define VCPM_FILELAST       0x03FF

enum tagVCPM_FILE {
    VCPM_FILEOPENIN = VCPM_FILEFIRSTIN,
    VCPM_FILEGETFATTR,
    VCPM_FILECLOSEIN,
    VCPM_FILECOPY,
    VCPM_FILENEEDED,

    VCPM_FILEOPENOUT = VCPM_FILEFIRSTOUT,
    VCPM_FILESETFATTR,
    VCPM_FILECLOSEOUT,
    VCPM_FILEFINALIZE,
    VCPM_FILEDELETE,
    VCPM_FILERENAME,
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          VIRTNODE callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_NODECLASS  0x04
#define VCPM_NODEFIRST  0x0400
#define VCPM_NODELAST   0x04FF

enum tagVCPM_NODE {
    VCPM_NODECREATE = VCPM_NODEFIRST,
    VCPM_NODEACCEPT,
    VCPM_NODEREJECT,
    VCPM_NODEDESTROY,
    VCPM_NODECHANGEDESTDIR,
    VCPM_NODECOMPARE,
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          TALLY callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_TALLYCLASS     0x05
#define VCPM_TALLYFIRST     0x0500
#define VCPM_TALLYLAST      0x05FF

enum tagVCPM_TALLY {
    VCPM_TALLYSTART = VCPM_TALLYFIRST,
    VCPM_TALLYEND,
    VCPM_TALLYFILE,
    VCPM_TALLYDISK,
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          VER callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_VERCLASS       0x06
#define VCPM_VERFIRST       0x0600
#define VCPM_VERLAST        0x06FF

enum tagVCPM_VER {
    VCPM_VERCHECK = VCPM_VERFIRST,
    VCPM_VERCHECKDONE,
    VCPM_VERRESOLVECONFLICT,
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          VSTAT callbacks
 *---------------------------------------------------------------------------*/

#define VCPM_VSTATCLASS     0x07
#define VCPM_VSTATFIRST     0x0700
#define VCPM_VSTATLAST      0x07FF

enum tagVCPM_VSTAT {
    VCPM_VSTATSTART = VCPM_VSTATFIRST,
    VCPM_VSTATEND,
    VCPM_VSTATREAD,
    VCPM_VSTATWRITE,
    VCPM_VSTATNEWDISK,

    VCPM_VSTATCLOSESTART,       // Start of VCP close
    VCPM_VSTATCLOSEEND,         // upon leaving VCP close
    VCPM_VSTATBACKUPSTART,      // Backup is beginning
    VCPM_VSTATBACKUPEND,        // Backup is finished
    VCPM_VSTATRENAMESTART,      // Rename phase start/end
    VCPM_VSTATRENAMEEND,
    VCPM_VSTATCOPYSTART,        // Acutal copy phase
    VCPM_VSTATCOPYEND,
    VCPM_VSTATDELETESTART,      // Delete phase
    VCPM_VSTATDELETEEND,
    VCPM_VSTATPATHCHECKSTART,   // Check for valid paths
    VCPM_VSTATPATHCHECKEND,
    VCPM_VSTATCERTIFYSTART,     // Certify phase
    VCPM_VSTATCERTIFYEND,
    VCPM_VSTATUSERABORT,        // User wants to quit.
    VCPM_VSTATYIELD,            // Do a yield.
    /* Remaining messages reserved for future use */
};

/*---------------------------------------------------------------------------*
 *          Destination info callbacks
 *---------------------------------------------------------------------------*/

/* BUGBUG -- find a reasonable message range for this */
#define VCPM_PATHCLASS      0x08
#define VCPM_PATHFIRST      0x0800
#define VCPM_PATHLAST       0x08FF

enum tagVCPM_PATH{
    VCPM_BUILDPATH = VCPM_PATHFIRST,
    VCPM_UNIQUEPATH,
    VCPM_CHECKPATH,
};

// #define VCPM_BUILDPATH      0x83

/*--------------------------------------------------------------------------*
 *          Patch processing callbacks
 *---------------------------------------------------------------------------*/

/* BUGBUG -- find a reasonable message range for this */
#define VCPM_PATCHCLASS      0x09
#define VCPM_PATCHFIRST      0x0900
#define VCPM_PATCHLAST       0x09FF

// filepatchbefore -- try to patch before the copy action
// filepatchafter  -- try to patch after the copy action

enum tagVCPM_PATCH{

    VCPM_FILEPATCHBEFORECPY = VCPM_PATCHFIRST,
    VCPM_FILEPATCHAFTERCPY,
    VCPM_FILEPATCHINFOPEN,
    VCPM_FILEPATCHINFCLOSE,
};

/*--------------------------------------------------------------------------*
 *         Certificate processing callbacks
 *---------------------------------------------------------------------------*/

/* BUGBUG -- find a reasonable message range for this */
#define VCPM_CERTCLASS      0x0A
#define VCPM_CERTFIRST      0x0A00
#define VCPM_CERTLAST       0x0AFF

// filepatchbefore -- try to patch before the copy action
// filepatchafter  -- try to patch after the copy action

enum tagVCPM_CERT{

    VCPM_FILECERTIFY = VCPM_CERTFIRST,
    VCPM_FILECERTIFYWARN,
};

/*****************************************************************************/
void WINAPI VcpAddMRUPath( LPCSTR lpszPath );
#define SZ_INSTALL_LOCATIONS "InstallLocationsMRU"


RETERR WINAPI VcpOpen(VIFPROC vifproc, LPARAM lparamMsgRef);

RETERR WINAPI VcpClose(WORD fl, LPCSTR lpszBackupDest);

RETERR WINAPI VcpFlush(WORD fl, LPCSTR lpszBackupDest);

#define VCPFL_ABANDON           0x0000  /* Abandon all pending file copies */
#define VCPFL_BACKUP            0x0001  /* Perform backup */
#define VCPFL_COPY              0x0002  /* Copy files */
#define VCPFL_BACKUPANDCOPY     (VCPFL_BACKUP | VCPFL_COPY)
#define VCPFL_INSPECIFIEDORDER  0x0004  /* Do not sort before copying */
#define VCPFL_DELETE            0x0008
#define VCPFL_RENAME            0x0010
#define VCPFL_ALL               (VCPFL_COPY | VCPFL_DELETE | VCPFL_RENAME )

typedef int (CALLBACK *VCPENUMPROC)(LPVIRTNODE lpvn, LPARAM lparamRef);

int WINAPI vcpEnumFiles(VCPENUMPROC vep, LPARAM lparamRef);

enum tag_VCPM_EXPLAIN{
    VCPEX_SRC_DISK,
    VCPEX_SRC_CABINET,
    VCPEX_SRC_LOCN,
    VCPEX_DST_LOCN,
    VCPEX_SRC_FILE,
    VCPEX_DST_FILE,
    VCPEX_DST_FILE_FINAL,
    VCPEX_DOS_ERROR,
    VCPEX_MESSAGE,
    VCPEX_DOS_SOLUTION,
    VCPEX_SRC_FULL,
    VCPEX_DST_FULL,
    VCPEX_DST_FULL_FINAL
};

LPCSTR WINAPI VcpExplain( LPVIRTNODE lpVn, DWORD dwWhat );

/* Flag bits that can be set via VcpQueueCopy */
// Various Lparams for files
#define VNLP_SYSCRITICAL    0x0001  // This file should not be skipped
#define VNLP_SETUPCRITICAL  0x0002  // This file cannot be skipped
#define VNLP_NOVERCHECK     0x0004  // This file must not be VerResolved.
#define VNLP_FORCETEMP      0x0008  // This file must left as a temp name
#define VNLP_IFEXISTS       0x0010  // File skipped if already on machine
#define VNLP_KEEPNEWER      0x0020  // If the dest file is newer - keep it (frosting)
#define VNLP_PATCHIFEXIST   0x0040  // patch only the file exists, if file not there,
#define VNLP_NOPATCH        0x0080  // per file base turn on/off patch option (default patch on)
#define VNLP_CATALOGCERT    0x0100  // This file is a catalog certificate.
#define VNLP_NEEDCERTIFY    0x0200  // This file need to be certified.
#define VNLP_COPYIFEXISTS   0x0400  // if dest file exists, copy it.

// VcpEnumFiles Flags.

#define VEN_OP      0x00ff      /* Operation field */

#define VEN_NOP     0x0000      /* Do nothing */
#define VEN_DELETE  0x0001      /* Delete current item */
#define VEN_SET     0x0002      /* Change value of current item */
#define VEN_ADVANCE 0x0003      /* Move to head of list */      /* ;Internal */

#define VEN_FL      0xff00      /* Flags field */

#define VEN_STOP    0x0100      /* Stop enumeration after this item */
#define VEN_ERROR   0x8000      /* Stop enumeration after this item
                                 * and ignore the OP field */

// BUGBUG: add the other VCP stuff necessary to use this

// BUGBUG: remove the lpsz*Dir fields, make overload the LDID with them

RETERR WINAPI VcpQueueCopy(LPCSTR lpszSrcFileName, LPCSTR lpszDstFileName,
                LPCSTR lpszSrcDir, LPCSTR lpszDstDir,
                LOGDISKID ldidSrc, LOGDISKID ldidDst,
                LPEXPANDVTBL lpExpandVtbl, WORD fl,
                LPARAM lParam);

RETERR WINAPI VcpQueueDelete( LPCSTR lpszDstFileName,
                              LPCSTR lpszDstDir,
                              LOGDISKID ldidDst,
                              LPARAM lParamRef );

RETERR WINAPI VcpQueueRename( LPCSTR      lpszSrcFileName,
                            LPCSTR      lpszDstFileName,
                            LPCSTR      lpszSrcDir,
                            LPCSTR      lpszDstDir,
                            LOGDISKID   ldidSrc,
                            LOGDISKID   ldidDst,
                            LPARAM      lParam );
                            
RETERR WINAPI vcpRegisterSourcePath( LPCSTR lpszKey, LPARAM lpExtra,
                                                LPCSTR lpszPath );
RETERR WINAPI vcpGetSourcePath( LPCSTR lpszKey, LPARAM lpExtra,
                                        LPSTR lpszBuf, UINT uBufSize );
                                        
#endif // NOVCP

#ifndef NOINF
/***************************************************************************/
//
// Inf Parser API declaration and definitions
//
/***************************************************************************/

enum _ERR_IP
{
    ERR_IP_INVALID_FILENAME = (IP_ERROR + 1),
    ERR_IP_ALLOC_ERR,
    ERR_IP_INVALID_SECT_NAME,
    ERR_IP_OUT_OF_HANDLES,
    ERR_IP_INF_NOT_FOUND,
    ERR_IP_INVALID_INFFILE,
    ERR_IP_INVALID_HINF,
    ERR_IP_INVALID_FIELD,
    ERR_IP_SECT_NOT_FOUND,
    ERR_IP_END_OF_SECTION,
    ERR_IP_PROFILE_NOT_FOUND,
    ERR_IP_LINE_NOT_FOUND,
    ERR_IP_FILEREAD,
    ERR_IP_TOOMANYINFFILES,
    ERR_IP_INVALID_SAVERESTORE,
    ERR_IP_INVALID_INFTYPE
};

#define INFTYPE_TEXT                0
#define INFTYPE_EXECUTABLE          1

#define MAX_SECT_NAME_LEN    32

typedef struct _INF NEAR * HINF;
typedef struct _INFLINE FAR * HINFLINE;            // tolken to inf line

RETERR  WINAPI IpOpen(LPCSTR pszFileSpec, HINF FAR * lphInf);
RETERR  WINAPI IpOpenEx(LPCSTR pszFileSpec, HINF FAR * lphInf, UINT InfType);
RETERR  WINAPI IpOpenAppend(LPCSTR pszFileSpec, HINF hInf);
RETERR  WINAPI IpOpenAppendEx(LPCSTR pszFileSpec, HINF hInf, UINT InfType);
RETERR  WINAPI IpSaveRestorePosition(HINF hInf, BOOL bSave);
RETERR  WINAPI IpClose(HINF hInf);
RETERR  WINAPI IpGetLineCount(HINF hInf, LPCSTR lpszSection, int FAR * lpCount);
RETERR  WINAPI IpFindFirstLine(HINF hInf, LPCSTR lpszSect, LPCSTR lpszKey, HINFLINE FAR * lphRet);
RETERR  WINAPI IpFindNextLine(HINF hInf, HINFLINE FAR * lphRet);
RETERR  WINAPI IpFindNextMatchLine(HINF hInf, LPCSTR lpszKey, HINFLINE FAR * lphRet);
RETERR  WINAPI IpGetProfileString(HINF hInf, LPCSTR lpszSec, LPCSTR lpszKey, LPSTR lpszBuf, int iBufSize);
RETERR  WINAPI IpGetFieldCount(HINF hInf, HINFLINE hInfLine, int FAR * lpCount);
RETERR  WINAPI IpGetFileName(HINF hInf, LPSTR lpszBuf, int iBufSize);
RETERR  WINAPI IpGetIntField(HINF hInf, HINFLINE hInfLine, int iField, int FAR * lpVal);
RETERR  WINAPI IpGetLongField(HINF hInf, HINFLINE hInfLine, int iField, long FAR * lpVal);
RETERR  WINAPI IpGetStringField(HINF hInf, HINFLINE hInfLine, int iField, LPSTR lpBuf, int iBufSize, int FAR * lpuCount);
RETERR  WINAPI IpGetVersionString(LPSTR lpszInfFile, LPSTR lpszValue, LPSTR lpszBuf, int cbBuf, LPSTR lpszDefaultValue);
RETERR  WINAPI IpOpenValidate( LPCSTR lpszInfFile, HINF FAR * lphInf,
                                 DWORD dwVer, DWORD dwFlags) ;
RETERR WINAPI IpGetDriverDate
(
    LPSTR       lpszInfName,
    UINT        infType,
    LPSTR       lpszSectionName,
    LPWORD      lpwDate
);

RETERR WINAPI IpGetDriverVersion
(
    LPSTR       lpszInfName,
    UINT        infType,
    LPSTR       lpszSectionName,
    LPSTR       lpszVersion,
    WORD        cbVersion
);

#endif // NOINF



#ifndef NOTEXTPROC
/***************************************************************************/
//
// Text processing API declaration and definitions
//
/***************************************************************************/

/* Relative/absolute positioning */
#define SEC_SET 1       // Absolute positioning (relative to the start)
#define SEC_END 2       // Realtive to the end
#define SEC_CUR 3       // Relative to the current line.

#define SEC_OPENALWAYS          1   // Always open a section, no error if it does not exist
#define SEC_OPENEXISTING        2   // Open an existing section, an error given if it does not exist.
#define SEC_OPENNEWALWAYS       3   // Open a section (present or not) and discard its contents.
#define SEC_OPENNEWEXISTING     4   // Open an existing section (discarding its contents). Error if not existing

// Flags for TP_OpenFile().
//
  // Use autoexec/config.sys key delimiters
  //
#define TP_WS_KEEP      1

  // If TP code running under SETUP, the foll. flag specifies whether
  // to cache this file or not! Use this, if you want to read a whole
  // file in when doing the TpOpenSection()!
  //
#define TP_WS_DONTCACHE 2

// The following are simple errors
enum {
    ERR_TP_NOT_FOUND = (TP_ERROR + 1),  // line, section, file etc.
                    // not necessarily terminal
    ERR_TP_NO_MEM,      // couldn't perform request - generally terminal
    ERR_TP_READ,        // could not read the disc - terminal
    ERR_TP_WRITE,       // could not write the data - terminal.
    ERR_TP_INVALID_REQUEST, // Multitude of sins - not necessarily terminal.
    ERR_TP_INVALID_LINE         // Invalid line from DELETE_LINE etc.
};

/* Data handles */
DECLARE_HANDLE(HTP);
typedef HTP FAR * LPHTP;

/* File handles */
DECLARE_HANDLE(HFN);
typedef HFN FAR * LPHFN;

typedef UINT TFLAG;
typedef UINT LINENUM, FAR * LPLINENUM;

#define MAX_REGPATH     256     // Max Registry Path Length
#define LINE_LEN        256     // BUGBUG: max line length?
#define SECTION_LEN     32      // BUGBUG: max length of a section name?
#define MAX_STRING_LEN  512     // BUGBUG: review this

/* Function prototypes */
RETERR  WINAPI TpOpenFile(LPCSTR Filename, LPHFN phFile, TFLAG Flag);
RETERR  WINAPI TpCloseFile(HFN hFile);
RETERR  WINAPI TpOpenSection(HFN hfile, LPHTP phSection, LPCSTR Section, TFLAG flag);
RETERR  WINAPI TpCloseSection(HTP Section);
RETERR  WINAPI TpCommitSection(HFN hFile, HTP hSection, LPCSTR Section, TFLAG flag);
LINENUM WINAPI TpGetLine(HTP hSection, LPCSTR key, LPCSTR value, int rel, int orig, LPLINENUM lpLineNum );
LINENUM WINAPI TpGetNextLine(HTP hSection, LPCSTR key, LPCSTR value, LPLINENUM lpLineNum );
RETERR  WINAPI TpInsertLine(HTP hSection, LPCSTR key, LPCSTR value, int rel, int orig, TFLAG flag);
RETERR  WINAPI TpReplaceLine(HTP hSection, LPCSTR key, LPCSTR value, int rel, int orig, TFLAG flag);
RETERR  WINAPI TpDeleteLine(HTP hSection, int rel, int orig,TFLAG flag);
RETERR  WINAPI TpMoveLine(HTP hSection, int src_rel, int src_orig, int dest_rel, int dest_orig, TFLAG flag);
RETERR  WINAPI TpGetLineContents(HTP hSection, LPSTR buffer, UINT bufsize, UINT FAR * lpActualSize,int rel, int orig, TFLAG flag);

// UINT    WINAPI TpGetWindowsDirectory(LPSTR lpDest, UINT size);
// UINT    WINAPI TpGetSystemDirectory(LPSTR lpDest, UINT size);

int  WINAPI TpGetPrivateProfileString(LPCSTR lpszSect, LPCSTR lpszKey, LPCSTR lpszDefault, LPSTR lpszReturn, int nSize, LPCSTR lpszFile);
int  WINAPI TpWritePrivateProfileString(LPCSTR lpszSect, LPCSTR lpszKey, LPCSTR lpszString, LPCSTR lpszFile);
int  WINAPI TpGetProfileString(LPCSTR lpszSect, LPCSTR lpszKey, LPCSTR lpszDefault, LPSTR lpszReturn, int nSize);
BOOL WINAPI TpWriteProfileString(LPCSTR lpszSect , LPCSTR lpszKey , LPCSTR lpszString);

#endif // NOTEXTPROC



#ifndef NOGENINSTALL
/***************************************************************************/
//
// Generic Installer prototypes and definitions
//
/***************************************************************************/

enum _ERR_GENERIC
{
    ERR_GEN_LOW_MEM = GEN_ERROR+1,  // Insufficient memory.
    ERR_GEN_INVALID_FILE,           // Invalid INF file.
    ERR_GEN_LOGCONFIG,              // Can't process LogConfig=.
    ERR_GEN_CFGAUTO,                // Can't process CONFIG.SYS/AUTOEXEC.BAT
    ERR_GEN_UPDINI,                 // Can't process UpdateInis=.
    ERR_GEN_UPDINIFIELDS,           // Can't process UpdateIniFields=.
    ERR_GEN_ADDREG,                 // Can't process AddReg=.
    ERR_GEN_DELREG,                 // Can't process DelReg=.
    ERR_GEN_INI2REG,                // Can't process Ini2Reg=.
    ERR_GEN_FILE_COPY,              // Can't process CopyFiles=.
    ERR_GEN_FILE_DEL,               // Can't process DelFiles=.
    ERR_GEN_FILE_REN,               // Can't process RenFiles=.
    ERR_GEN_REG_API,                // Error returned by Reg API.
    ERR_GEN_DO_FILES,               // can't do Copy, Del or RenFiles.
    ERR_GEN_ADDIME,                 // Can't process AddIme=.
    ERR_GEN_DELIME,                 // Can't process DelIme=.
    ERR_GEN_PERUSER,                // Can't process PerUserInstall=.
    ERR_GEN_BITREG,                 // Can't process BitReg=.
};

// The cbSize field will always be set to sizeof(GENCALLBACKINFO_S).
// All unused fields (for the operation) will be not be initialized.
// For example, when the operation is GENO_DELFILE, the Src fields will
// not have any sensible values (Dst fields will be set correctly) as
// VcpQueueDelete only accepts Dst parameters.
//
/***************************************************************************
 * GenCallbackINFO structure passed to GenInstall CallBack functions.
 ***************************************************************************/
typedef struct _GENCALLBACKINFO_S { /* gen-callback struc */
    WORD         cbSize;                 // Size of this structure (bytes).
    WORD         wOperation;             // Operation being performed.
    LOGDISKID    ldidSrc;                // Logical Disk ID for Source.
    LPCSTR       pszSrcSubDir;           // Source sub-dir off of the LDID.
    LPCSTR       pszSrcFileName;         // Source file name (base name).
    LOGDISKID    ldidDst;                // Logical Disk ID for Dest.
    LPCSTR       pszDstSubDir;           // Dest. sub-dir off of the LDID.
    LPCSTR       pszDstFileName;         // Dest. file name (base name).
    LPEXPANDVTBL lpExpandVtbl;           // BUGBUG needed? NULL right now!
    WORD         wflags;                 // flags for VcpQueueCopy.
    LPARAM       lParam;                 // LPARAM to the Vcp API.
} GENCALLBACKINFO_S, FAR *LPGENCALLBACKINFO;

/***************************************************************************
 * GenCallback notification codes -- callback proc returns 1 of foll. values.
 ***************************************************************************/
#define GENN_OK         0       /* All is hunky-dory. Do the VCP operation */
#define GENN_PROCEED    0       /* The same as GENN_OK */

#define GENN_ABORT      (-1)    /* Cancel current GenInstall altogether */
#define GENN_SKIP       (-2)    /* Skip this file and continue */

/***************************************************************************
 * VCP Operation being performed by GenInstall() -- wOperation values in
 * GENCALLBACKINFO structure above.
 ***************************************************************************/
#define GENO_COPYFILE   1       /* VCP copyfile being done */
#define GENO_DELFILE    2       /* VCP delfile being done */
#define GENO_RENFILE    3       /* VCP renfile being done */
#define GENO_WININITRENAME 4    /* VCP wininit rename being added */

typedef LRESULT (CALLBACK *GENCALLBACKPROC)(LPGENCALLBACKINFO lpGenInfo,
                                                            LPARAM lparamRef);

RETERR WINAPI GenInstall( HINF hinfFile, LPCSTR szInstallSection, WORD wFlags );
RETERR WINAPI GenInstallEx( HINF hInf, LPCSTR szInstallSection, WORD wFlags,
                                HKEY hRegKey, GENCALLBACKPROC CallbackProc,
                                LPARAM lparam);

RETERR WINAPI GenWinInitRename(LPCSTR szNew, LPSTR szOld, LOGDISKID ldid);
RETERR WINAPI GenCopyLogConfig2Reg(HINF hInf, HKEY hRegKey,
                                                LPCSTR szLogConfigSection);
void   WINAPI GenFormStrWithoutPlaceHolders( LPSTR szDst, LPCSTR szSrc,
                                                                HINF hInf ) ;
RETERR WINAPI GenInitSrcPathsInReg(HINF hInf);

// Flags for GenAddReg() from INf /GenSURegSetValueEx()
//
// (updated from setupapi.h, with unsupported features commented out)
//
#define FLG_ADDREG_BINVALUETYPE         ( 0x00000001 )
#define FLG_ADDREG_NOCLOBBER            ( 0x00000002 )
#define FLG_ADDREG_DELVAL               ( 0x00000004 )
//#define FLG_ADDREG_APPEND             ( 0x00000008 ) // Currently supported only
//                                                     // for REG_MULTI_SZ values.
#define FLG_ADDREG_KEYONLY              ( 0x00000010 ) // Just create the key, ignore value
#define FLG_ADDREG_OVERWRITEONLY        ( 0x00000020 ) // Set only if value already exists
#define FLG_ADDREG_TYPE_REPLACEIFEXISTS ( 0x00000040 )

#define FLG_ADDREG_TYPE_MASK            ( 0xFFFF0000 | FLG_ADDREG_BINVALUETYPE )
#define FLG_ADDREG_TYPE_SZ              ( 0x00000000                           )
//#define FLG_ADDREG_TYPE_MULTI_SZ      ( 0x00010000                           )
//#define FLG_ADDREG_TYPE_EXPAND_SZ     ( 0x00020000                           )
#define FLG_ADDREG_TYPE_BINARY          ( 0x00000000 | FLG_ADDREG_BINVALUETYPE )
#define FLG_ADDREG_TYPE_DWORD           ( 0x00010000 | FLG_ADDREG_BINVALUETYPE )
//#define FLG_ADDREG_TYPE_NONE          ( 0x00020000 | FLG_ADDREG_BINVALUETYPE )

// Flags for GenBitReg()
//
#define FLG_BITREG_CLEAR            ( 0x00000000 )
#define FLG_BITREG_SET              ( 0x00000001 )
#define FLG_BITREG_TYPE_BINARY      ( 0x00000000 )
#define FLG_BITREG_TYPE_DWORD       ( 0x00000002 )


RETERR WINAPI GenSURegSetValueEx(HKEY hkeyRoot, LPCSTR szSubKey,
                         LPCSTR lpszValueName, DWORD dwValType,
                         LPBYTE lpszValue, DWORD dwValSize, UINT uFlags );

// A devnode is just a DWORD and this is easier than
// having to include configmg.h for everybody
RETERR WINAPI GenInfLCToDevNode(ATOM atInfFileName, LPSTR lpszSectionName,
                                BOOL bInstallSec, UINT InfType,
                                DWORD dnDevNode);

// Bit fields for GenInstall() (for wFlags parameter) -- these can be OR-ed!

#define GENINSTALL_DO_REGSRCPATH    64

// Remove temporarily because of incompatibilities with INET16.DLL #define GENINSTALL_DO_FILES    (1 | GENINSTALL_DO_REGSRCPATH)
#define GENINSTALL_DO_FILES     1
#define GENINSTALL_DO_INI       2
#define GENINSTALL_DO_REG       4
#define GENINSTALL_DO_INI2REG   8
#define GENINSTALL_DO_CFGAUTO   16
#define GENINSTALL_DO_LOGCONFIG 32
//
// careful:  64 is already used above
//
#define GENINSTALL_DO_IME       128
#define GENINSTALL_DO_PERUSER   256

#define GENINSTALL_DO_INIREG    (GENINSTALL_DO_INI | \
                                 GENINSTALL_DO_REG | \
                                 GENINSTALL_DO_INI2REG)

#define GENINSTALL_DO_ALL       (GENINSTALL_DO_FILES | \
                                    GENINSTALL_DO_INIREG | \
                                    GENINSTALL_DO_CFGAUTO | \
                                    GENINSTALL_DO_LOGCONFIG | \
                                    GENINSTALL_DO_REGSRCPATH | \
                                    GENINSTALL_DO_IME | \
                                    GENINSTALL_DO_PERUSER)

#endif // NOGENINSTALL



#ifndef NODEVICENSTALL
/***************************************************************************/
//
// Device Installer prototypes and definitions
//
/***************************************************************************/

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @typee    _ERR_DEVICE_INSTALL | Error return codes for Device Installation
*   APIs.
*
*   @emem ERR_DI_INVALID_DEVICE_ID | Incorrectly formed device ID.
*
*   @emem ERR_DI_INVALID_COMPATIBLE_DEVICE_LIST | Invalid compatible device list.
*
*   @emem ERR_DI_REG_API | Error returned by one of the registry API.
*
*   @emem ERR_DI_LOW_MEM | Insufficient memory to complete.
*
*   @emem ERR_DI_BAD_DEV_INFO | A passed in DEVICE_INFO struct is invalid.
*
*   @emem ERR_DI_INVALID_CLASS_INSTALLER | The class installer is listed incorrecrly
*   in the registry, or points to an invalid class installer.
*
*   @emem ERR_DI_DO_DEFAULT | Do the default action for the requested operation.
*
*   @emem ERR_DI_USER_CANCEL | The user cancelled the operation.
*
*   @emem ERR_DI_NOFILECOPY | No need to copy files (in install).
*
*   @emem ERR_DI_BAD_CLASS_INFO | A passed in CLASS_INFO struct is invalid.
*
*   @emem ERR_DI_BAD_INF | An invalid INF file was encountered.
*
*   @emem ERR_DI_BAD_MOVEDEV_PARAMS | A passed in MOVEDEVICE_PARAMS struct was
*   invalid.
*
*   @emem ERR_DI_NO_INF | No INF found on supplied OEM path.
*
*   @emem ERR_DI_BAD_PROPCHANGE_PARAMS | A passed in PROPCHANGE_PARMS struct was
*   invalid.
*
*   @emem ERR_DI_BAD_SELECTDEVICE_PARAMS | A passed in SELECTEDEVICE_PARAMS struct
*   was invalid.
*
*   @emem ERR_DI_BAD_REMOVEDEVICE_PARAMS | A passed in REMOVEDEVICE_PARAMS struct
*   was invalid.
*
*   @emem ERR_DI_BAD_UNREMOVEDEVICE_PARAMS | A passed in UNREMOVEDEVICE_PARAMS struct
*   was invalid.
*
*   @emem ERR_DI_BAD_ENABLECLASS_PARAMS | A passed in ENABLECLASS_PARAMS struct
*   was invalid.
*
*   @emem ERR_DI_FAIL_QUERY | The queried action should not take place.
*
*   @emem ERR_DI_API_ERROR | One of the Device installation APIs was called
*   incorrectly or with invalid parameters.
*
*   @emem ERR_DI_BAD_PATH | An OEM path was specified incorrectly.
*
*   @emem ERR_DI_NOUPDATE | No Drivers Were updated
*
*   @emem ERR_DI_NODATE    | A driver's date/time stamp in the INF could not be found
*
*   @emem ERR_DI_NOVERSION | A driver's version the INF could not be found
*
*
*******************************************************************************/
enum _ERR_DEVICE_INSTALL
{
    ERR_DI_INVALID_DEVICE_ID = DI_ERROR,    // Incorrectly formed device IDF
    ERR_DI_INVALID_COMPATIBLE_DEVICE_LIST,  // Invalid compatible device list
    ERR_DI_REG_API,                         // Error returned by Reg API.
    ERR_DI_LOW_MEM,                         // Insufficient memory to complete
    ERR_DI_BAD_DEV_INFO,                    // Device Info struct invalid
    ERR_DI_INVALID_CLASS_INSTALLER,         // Registry entry / DLL invalid
    ERR_DI_DO_DEFAULT,                      // Take default action
    ERR_DI_USER_CANCEL,                     // the user cancelled the operation
    ERR_DI_NOFILECOPY,                      // No need to copy files (in install)
    ERR_DI_BAD_CLASS_INFO,                  // Class Info Struct invalid
    ERR_DI_BAD_INF,                         // Bad INF file encountered
    ERR_DI_BAD_MOVEDEV_PARAMS,              // Bad Move Device Params struct
    ERR_DI_NO_INF,                          // No INF found on OEM disk
    ERR_DI_BAD_PROPCHANGE_PARAMS,           // Bad property change param struct
    ERR_DI_BAD_SELECTDEVICE_PARAMS,         // Bad Select Device Parameters
    ERR_DI_BAD_REMOVEDEVICE_PARAMS,         // Bad Remove Device Parameters
    ERR_DI_BAD_ENABLECLASS_PARAMS,          // Bad Enable Class Parameters
    ERR_DI_FAIL_QUERY,                      // Fail the Enable Class query
    ERR_DI_API_ERROR,                       // DI API called incorrectly
    ERR_DI_BAD_PATH,                        // An OEM path was specified incorrectly
    ERR_DI_BAD_UNREMOVEDEVICE_PARAMS,       // Bad Unremove Device Parameters
    ERR_DI_NOUPDATE,                        // No Drivers Were updated
    ERR_DI_NODATE,                          // The driver does not have a Date stamp in the INF
    ERR_DI_NOVERSION,                       // There is not version string in the INF
    ERR_DI_DONT_INSTALL,                    // Don't upgrade the current driver
    ERR_DI_NO_DIGITAL_SIGNATURE_CATALOG,    // Catalog is not digitally signed
    ERR_DI_NO_DIGITAL_SIGNATURE_INF,        // Inf is not digitally signed
    ERR_DI_NO_DIGITAL_SIGNATURE_FILE,       // A file is not digitally signed
};

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    DRIVER_INFO | This structure contains the information necessary
*   to present the user with a select device dialog.
*
*   @field WORD | cbSize | Size of this structure in bytes.
*
*   @field struct _DRIVER_INFO FAR | *lpNextInfo | Pointer to the next DRIVER_INFO
*   struct in a linked list.
*
*   @field LPSTR | lpszDescription | Pointer to the description of the device being
*   supported by this driver.
*
*   @field LPSTR | lpszMfgName | Pointer to the name of the manufacture of this
*   driver.
*
*   @field LPSTR | lpszProviderName | Pointer to provider of this driver if the
*   lpdi->Flags has the DI_MULTMFGS flag set.
*
*   @field WORD | Rank | The Rank match of this driver.  Ranks go from 0 to n, where 0
*   is the most compatible.
*
*   @field DWORD | dwFlags | Flags that control the use of this driver node.  These
*   are the same as the flags defined for a DRIVER_NODE.
*       @flag DNF_DUPDESC           | This driver has the same device description
*       from by more than one provider.
*       @flag DNF_OLDDRIVER         | Driver node specifies old/current driver
*       @flag DNF_EXCLUDEFROMLIST   | If set, this driver node will not be displayed
*       in any driver select dialogs.
*       @flag DNF_NODRIVER          | Set if we want to install no driver e.g no mouse drv
*       @flag DNF_CLASS_DRIVER      | Set if this driver is in the class driver list
*       @flag DNF_COMPATIBLE_DRIVER | Set if this driver is in the compatible driver list
*       @flag DNF_INET_DRIVER       | Set if this driver is being installed from the Internet
*       @flag DNF_CURRENT_DRIVER    | Set if this driver is the one currently being used.
*       @flag DNF_CLASS_DRIVER      | Set if this driver is in the class driver list
*       @flag DNF_COMPATIBLE_DRIVER | Set if this driver is in the compatible driver list
*       @flag DNF_INET_DRIVER       | Set if this driver is being installed from the Internet
*       @flag DNF_CURRENT_DRIVER    | Set if this driver is the one currently being used.
*
*   @field LPARAM | lpReserved | Reserved for use by the Device Installer.
*
*   @field DWORD | dwPrivateData | Reserved for use by the Device Installer.
*
*******************************************************************************/
typedef struct _DRIVER_INFO
{
    WORD                        cbSize;                     // Size of this structure in bytes
    struct _DRIVER_INFO FAR*    lpNextInfo;
    LPSTR                       lpszDescription;
    LPSTR                       lpszMfgName;
    LPSTR                       lpszProviderName;           // ONLY valid if DI_MULTMFGS is set in the LPDI
    WORD                        Rank;
    DWORD                       dwFlags;
    LPARAM                      lpReserved;
    DWORD                       dwPrivateData;
    WORD                        wDate;                      // Driver Date
    LPSTR                       lpszVersion;
} DRIVER_INFO, *PDRIVER_INFO, FAR *LPDRIVER_INFO;

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    DRIVER_NODE | This strucure represents a driver which can be
*   installed for a specific device.
*
*   @field struct _DRIVER_NODE FAR* | lpNextDN | Pointer to the next driver node
*   in a list.
*
*   @field UINT | Rank | The Rank match of this driver.  Ranks go from 0 to n, where 0
*   is the most compatible.
*
*   @field UINT | InfType | Type of INF this driver cam from.  This will
*   be either INFTYPE_TEXT or INFTYPE_EXECUTABLE
*
*   @field unsigned | InfDate | DOS date stamp of the INF file.
*
*   @field LPSTR | lpszDescription | Pointer to a the descriptrion of the device being
*   supported by this driver.
*
*   @field LPSTR | lpszSectionName | Pointer to the name of INF install section for
*   this driver.
*
*   @field ATOM  | atInfFileName | Global ATOM containing the name of the INF file.
*
*   @field ATOM  | atMfgName | Global ATOM containing the name of this driver's
*   manufacture.
*
*   @field ATOM  | atProviderName | Global ATOM containing the name of this driver's
*   provider.
*
*   @field DWORD | Flags | Flags that control functions using this DRIVER_NODE
*       @flag DNF_DUPDESC           | This driver has the same device description
*       from by more than one provider.
*       @flag DNF_OLDDRIVER         | Driver node specifies old/current driver
*       @flag DNF_EXCLUDEFROMLIST   | If set, this driver node will not be displayed
*       in any driver select dialogs.
*       @flag DNF_NODRIVER          | Set if we want to install no driver e.g no mouse drv
*       @flag DNF_CONVERTEDLPINFO   | Set if this Driver Node was converted from an Info Node.
*       Setting this flag will cause the cleanup functions to explicitly delete it.
*
*   @field DWORD | dwPrivateData | Reserved
*
*   @field LPSTR | lpszDrvDescription | Pointer to a driver description.
*
*   @field LPSTR | lpszHardwareID | Pointer to a list of Plug-and-Play hardware IDs for
*   this driver.
*
*   @field LPSTR | lpszCompatIDs | Pointer to a list of Plug-and-Play compatible IDs for
*   this driver.
*
*******************************************************************************/
typedef struct _DRIVER_NODE {
    struct _DRIVER_NODE FAR* lpNextDN;
    UINT    Rank;
    UINT    InfType;
    unsigned    InfDate;
    LPSTR   lpszDescription;        // Compatibility: Contains the Device Desc.
    LPSTR   lpszSectionName;
    ATOM    atInfFileName;
    ATOM    atMfgName;
    ATOM    atProviderName;
    DWORD   Flags;
    DWORD   dwPrivateData;
    LPSTR   lpszDrvDescription;     // New contains an driver description
    LPSTR   lpszHardwareID;
    LPSTR   lpszCompatIDs;
    unsigned    DriverDate;
    LPSTR   lpszInfPath;
    LPARAM  lpReserved;
}   DRIVER_NODE, NEAR* PDRIVER_NODE, FAR* LPDRIVER_NODE, FAR* FAR* LPLPDRIVER_NODE;

#define DNF_DUPDESC             0x00000001   // Multiple providers have same desc
#define DNF_OLDDRIVER           0x00000002   // Driver node specifies old/current driver
#define DNF_EXCLUDEFROMLIST     0x00000004
#define DNF_NODRIVER            0x00000008   // if we want to install no driver e.g no mouse drv

#define DNF_CONVERTEDLPINFO     0x00000010  // Set if the Driver Node is a Converted Info Node

#define DNF_CLASS_DRIVER        0x00000020  // Driver node represents a class driver
#define DNF_COMPATIBLE_DRIVER   0x00000040  // Driver node represents a compatible driver
#define DNF_INET_DRIVER         0x00000080  // Driver comes from an Inetnet source
#define DNF_CURRENT_DRIVER      0x00000100  // Driver is the current one for a device
#define DNF_INDEXED_DRIVER      0x00000200  // Driver is specified in the Windows Driver Index file

// possible types of "INF" files
#define INFTYPE_WIN4        1
#define INFTYPE_WIN3        2
#define INFTYPE_COMBIDRV    3
#define INFTYPE_PPD         4
#define INFTYPE_WPD     5
#define INFTYPE_CLASS_SPEC1 6
#define INFTYPE_CLASS_SPEC2 7
#define INFTYPE_CLASS_SPEC3 8
#define INFTYPE_CLASS_SPEC4 9


#define MAX_CLASS_NAME_LEN   32
#define MAX_DRIVER_INST_LEN  10
#define MAX_GUID_STR 50                     // Big enough to hold a GUID string

// NOTE:  Keep this in sync with confimg.h in \DDK\INC
#define MAX_DEVNODE_ID_LEN  256

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    DEVICE_INFO | This is the basic data structure for most Device
*   installation APIs.  A DEVICE_INFO represents a device that is being installed
*   on the system, or an installed device that is being modified in some way.
*
*   @field UINT | cbSize | Size of the DEVICE_INFO struct.
*
*   @field struct _DEVICE_INFO FAR | *lpNextDi | Pointer to the next DEVICE_INFO struct
*   in a linked list.
*
*   @field char | szDescription[LINE_LEN] | Buffer containing the description of the
*   device.
*
*   @field DWORD | dnDevnode | If set, this contains the address of the DevNode associated
*   with the device.
*
*   @field HKEY | hRegKey | An opened registry key that contains the device's registry
*   subkey.  This is usually HKEY_LOCAL_MACHINE.
*
*   @field char | szRegSubkey[MAX_DEVNODE_ID_LEN] | Buffer containing the device's
*   hardware registry subkey.  This is key is rooted in hRegKey, and is ususally some
*   place in the \\ENUM branch.
*
*   @field char | szClassName[MAX_CLASS_NAME_LEN] | Buffer containing the device's
*   class name. (Can be a GUID str)
*
*   @field DWORD | Flags | Flags for controlling installation and U/I functions. Some
*   flags can be set prior to calling device installer APIs, and other are set
*   automatically during the processing of some APIs.
*       @flag DI_SHOWOEM                  | Set if OEM disk support should be allowed
*       @flag DI_SHOWCOMPAT               | Will be set if only a compatible driver list
*       is being displayed by DiSelectDevice.
*       @flag DI_SHOWCLASS                | Will be set if only a Class driver list is
*       is being displayed by DiSelectDevice.
*       @flag DI_SHOWALL                  | Will be set if both a compatible driver list
*       and a class driver list are being shown by DiSelectDevice.
*       @flag DI_NOVCP                    | Set if no VCP (Virtual Copy Procedure) is
*       desired during DiInstallDevice.
*       @flag DI_DIDCOMPAT                | Will be set if DiBuildCompatDrvList has been
*       done, and lpCompatDrvList points to this device's compatible driver list.
*       @flag DI_DIDCLASS                 | Will be set if DiBuildClassDrvList has been
*       done, and lpClassDrvList points to this device's class driver list.
*       @flag DI_AUTOASSIGNRES            | Unused.
*       @flag DI_NEEDRESTART              | Will be set if the device requires a restart
*       of Windows after installation or a state change.
*       @flag DI_NEEDREBOOT               | Will be set if the device requires a reboot
*       of the machine after installation or a state change.
*       @flag DI_NOBROWSE                 | Set to diable browsing when selecting an OEM
*       disk path.
*       @flag DI_MULTMFGS                 | Will be set if a class driver list, or class
*       info list contains multiple manufactures.
*       @flag DI_DISABLED                 | Unused.
*       @flag DI_GENERALPAGE_ADDED        | Set by a property page provider if a general
*       properties page has been added to the device's property sheet.
*       @flag DI_RESOURCEPAGE_ADDED       | Set by a property page provider if a resource
*       properties page has been added to the device's property sheet.
*       @flag DI_PROPERTIES_CHANGE        | Set if a device's properties have been changed
*       and require an update of the Device Manager's U/I.
*       @flag DI_INF_IS_SORTED            | Set if the INF containing drivers for this
*       device is in sorted order.
*       @flag DI_ENUMSINGLEINF            | Set if DiBuildCompatDrvList and
*       DiBuildlassDrvList should only search the INF file specificed by atDriverPath.
*       @flag DI_DONOTCALLCONFIGMG        | Set if the configuration manager should not
*       be called during DiInstallDevice.
*       @flag DI_INSTALLDISABLED          | Set if the device should be installed in a
*       disabled state by default.
*       @flag DI_CLASSONLY                | Set if this DEVICE_INFO struct contains only
*       a class name.
*       @flag DI_CLASSINSTALLPARAMS       | Set if the lpClassIntallParams field points to
*       a class install parameter block.
*       @flag DI_NODI_DEFAULTACTION       | Set if DiCallClassInstaller should not
*       perform any default action if the class installer return ERR_DI_DO_DEFAULT, or
*       there is not class installer.
*       @flag DI_QUIETINSTALL             | Set if device install API should be as
*       silent as possible using default choices whereever possible.
*       @flag DI_NOFILECOPY               | Set if DiInstallDevice should skip file
*       copying.
*       @flag DI_FORCECOPY                | Set if DiInstallDevice should always
*       copy file, even if they are present on the system.
*       @flag DI_DRIVERPAGE_ADDED         | Set by a property page provider if a driver
*       properties page has been added to the device's property sheet.
*       @flag DI_USECI_SELECTSTRINGS      | Set if class installer provided strings
*       should be used during DiSelectDevice.
*       @flag DI_OVERRIDE_INFFLAGS        | Unused.
*       @flag DI_PROPS_NOCHANGEUSAGE      | Set if there should be no Enable/Disable
*       capability on the device's general property page.
*       @flag DI_NOSELECTICONS            | Set if no small icons should be used during
*       DiSelectDevice.
*       @flag DI_NOWRITE_IDS              | Set if DiInstallDevice should not write
*       the device's hardware and compatible IDs to the registry.
*
*   @field HWND | hwndParent | Window handle that will own U/I dialogs related to this
*   device.
*
*   @field LPDRIVER_NODE | lpCompatDrvList | Pointer to a linked list of DRIVER_NODES
*   representing the compatible drivers for this device.
*
*   @field LPDRIVER_NODE | lpClassDrvList | Pointer to a linked list of DRIVER_NODES
*   representing all drivers of this device's class.
*
*   @field LPDRIVER_NODE | lpSelectedDriver | Pointer to a single DRIVER_NODE that
*   has been selected as the driver for this device.
*
*   @field ATOM | atDriverPath | Global ATOM containing the path to this device's INF
*   file.  This is set only of the driver came from an OEM INF file.  This will be
*   0 if the INF is a standard Windows INF file.
*
*   @field ATOM | atTempInfFile | Global ATOM containing the name of a temporary INF
*   file for this device's drivers.  This is set if the drivers came from an old style
*   INF file and have been converted.
*
*   @field HINSTANCE | hinstClassInstaller | Class installer module instance.
*
*   @field HINSTANCE | hinstClassPropProvidor | Class Property Providor module instance.
*
*   @field HINSTANCE | hinstDevicePropProvidor | Device Property Providor module instance.
*
*   @field HINSTANCE | hinstBasicPropProvidor | Basic Property Providor module instance.
*
*   @field FARPROC | fpClassInstaller | Procedure address of class install function.
*
*   @field FARPROC | fpClassEnumPropPages | Procedure address of the Class property
*   provider page enumeration function.
*
*   @field FARPROC | fpDeviceEnumPropPages | Procedure address of the Device property
*   provider page enumeration function.
*
*   @field FARPROC | fpEnumBasicProperties | Procedure address of the Basic device
*   property provider page enumeration function.
*
*   @field DWORD | dwSetupReserved | Reserved for use by Setup.
*
*   @field DWORD | dwClassInstallReserved | Reserved for use by Class Installers.
*
*   @field GENCALLBACKPROC | gicpGenInstallCallBack | Procedure address of a GenInstall
*   call back function.  This would be set if the class installer wanted to handle
*   GenInstall callbacks during DiInstallDevice.
*
*   @field LPARAM | gicplParam | lParam for the GenInstall Callback.
*
*   @field UINT | InfType | The type of INF file being used.  This will be INFTYPE_TEXT
*   or INFTYPE_EXECUTABLE.
*
*   @field HINSTANCE | hinstPrivateProblemHandler | Module handle for the device's
*   private problem procedure.
*
*   @field FARPROC | fpPrivateProblemHandler | Procedure address of the device's
*   private problem handler.
*
*   @field LPARAM | lpClassInstallParams | Pointer to a class install parameter block.
*   Class installer parameters are specific to the class install functions.
*
*   @field struct _DEVICE_INFO FAR | *lpdiChildList | Pointer to a linked list of
*   DRIVER_INFO structs representing children of this device.
*
*   @field DWORD | dwFlagsEx | Additional control flags.
*       @flag DI_FLAGSEX_USEOLDINFSEARCH  | Set if INF Search functions should not use
*       indexed searching.
*       @flag DI_FLAGSEX_AUTOSELECTRANK0  | Set if DiSelectDevice should automatically
*       select rank 0 match drivers.
*       @flag DI_FLAGSEX_CI_FAILED        | Will be set internally if there was a
*       failure to load or call a class installer.
*       @flag DI_FLAGSEX_DIDINFOLIST      | Will be set if DiBuildCompatDrvInfoList has
*       been called, and this device's compatible driver Info list has been built.
*       @flag DI_FLAGSEX_DIDCOMPATINFO    | Will be set if DiBuildClassDrvInfoList has
*       been called, and this device's class driver Info list has been built.
*       @flag DI_FLAGSEX_FILTERCLASSES    | If set, DiBuildClassDrvList, and
*       DiBuildClassDrvInfoList will check for Class inclusion filters.  This means
*       devices will not be included in the list, if their class is marked as a
*       NoInstallClass class.
*       @flag DI_FLAGSEX_SETFAILEDINSTALL | If set, then if DiInstallDevice installs
*       a NULL driver, it will also set the FAILEDINSTALL config flag
*       @flag DI_FLAGSEX_DEVICECHANGE | If set, the device manager will rebuild it
*       tree of devices after the device property sheet is closed.
*       @flag DI_FLAGSEX_ALWAYSWRITEIDS | If set, and the flag, DI_NOWRITE_ID is clear
*       (ie that flag takes higher precedance) then always write Hardare and Compat
*       ids, even if they allready exist
*       @flag DI_FLAGSEX_ALLOWEXCLUDEDDRVS | If set, DiSelectDevice will display drivers
*       that have the Exlude From Select state
*       @flag DI_FLAGSEX_NOUIONQUERYREMOVE | If setup, DiInstallDevice will prevent
*       U/I warnings during a query removal.  Any U/I wanings that would have been
*       displayed will be silently failed.
*   @field LPDRIVER_INFO | lpCompatDrvInfoList | Pointer to a linked list of
*   DRIVER_INFO structs that are compatible with this device.
*
*   @field LPDRIVER_INFO | lpClassDrvInfoList | Pointer to a linked list of
*   DRIVER_INFO structs representing all drivers for this device's class.
*
*******************************************************************************/
typedef struct _DEVICE_INFO
{
    UINT                        cbSize;
    struct _DEVICE_INFO FAR     *lpNextDi;
    char                        szDescription[LINE_LEN];
    DWORD                       dnDevnode;
    HKEY                        hRegKey;
    char                        szRegSubkey[MAX_DEVNODE_ID_LEN];
    char                        szClassName[MAX_CLASS_NAME_LEN];
    DWORD                       Flags;
    HWND                        hwndParent;
    LPDRIVER_NODE               lpCompatDrvList;
    LPDRIVER_NODE               lpClassDrvList;
    LPDRIVER_NODE               lpSelectedDriver;
    ATOM                        atDriverPath;
    ATOM                        atTempInfFile;
    HINSTANCE                   hinstClassInstaller;
    HINSTANCE                   hinstClassPropProvidor;
    HINSTANCE                   hinstDevicePropProvidor;
    HINSTANCE                   hinstBasicPropProvidor;
    FARPROC                     fpClassInstaller;
    FARPROC                     fpClassEnumPropPages;
    FARPROC                     fpDeviceEnumPropPages;
    FARPROC                     fpEnumBasicProperties;
    DWORD                       dwSetupReserved;
    DWORD                       dwClassInstallReserved;
    GENCALLBACKPROC             gicpGenInstallCallBack;

    LPARAM                      gicplParam;
    UINT                        InfType;

    HINSTANCE                   hinstPrivateProblemHandler;
    FARPROC                     fpPrivateProblemHandler;
    LPARAM                      lpClassInstallParams;
    struct _DEVICE_INFO FAR     *lpdiChildList;
    DWORD                       dwFlagsEx;
    LPDRIVER_INFO               lpCompatDrvInfoList;
    LPDRIVER_INFO               lpClassDrvInfoList;
    char                        szClassGUID[MAX_GUID_STR];
} DEVICE_INFO, FAR * LPDEVICE_INFO, FAR * FAR * LPLPDEVICE_INFO;

#define ASSERT_DI_STRUC(lpdi) if (lpdi->cbSize != sizeof(DEVICE_INFO)) return (ERR_DI_BAD_DEV_INFO)

typedef struct _CLASS_INFO
{
    UINT        cbSize;
    struct _CLASS_INFO FAR* lpNextCi;
    LPDEVICE_INFO   lpdi;
    char                szDescription[LINE_LEN];
    char        szClassName[MAX_CLASS_NAME_LEN];
} CLASS_INFO, FAR * LPCLASS_INFO, FAR * FAR * LPLPCLASS_INFO;
#define ASSERT_CI_STRUC(lpci) if (lpci->cbSize != sizeof(CLASS_INFO)) return (ERR_DI_BAD_CLASS_INFO)


// flags for device choosing (InFlags)
#define DI_SHOWOEM                  0x00000001L     // support Other... button
#define DI_SHOWCOMPAT               0x00000002L     // show compatibility list
#define DI_SHOWCLASS                0x00000004L     // show class list
#define DI_SHOWALL                  0x00000007L
#define DI_NOVCP                    0x00000008L     // Don't do vcpOpen/vcpClose.
#define DI_DIDCOMPAT                0x00000010L     // Searched for compatible devices
#define DI_DIDCLASS                 0x00000020L     // Searched for class devices
#define DI_AUTOASSIGNRES            0x00000040L    // No UI for resources if possible

// flags returned by DiInstallDevice to indicate need to reboot/restart
#define DI_NEEDRESTART              0x00000080L     // Restart required to take effect
#define DI_NEEDREBOOT               0x00000100L     // Reboot required to take effect

// flags for device installation
#define DI_NOBROWSE                 0x00000200L     // no Browse... in InsertDisk

// Flags set by DiBuildClassDrvList
#define DI_MULTMFGS                 0x00000400L     // Set if multiple manufacturers in
                                                    // class driver list
// Flag indicates that device is disabled
#define DI_DISABLED                 0x00000800L     // Set if device disabled

// Flags for Device/Class Properties
#define DI_GENERALPAGE_ADDED        0x00001000L
#define DI_RESOURCEPAGE_ADDED       0x00002000L

// Flag to indicate the setting properties for this Device (or class) caused a change
// so the Dev Mgr UI probably needs to be updatd.
#define DI_PROPERTIES_CHANGE        0x00004000L

// Flag to indicate that the sorting from the INF file should be used.
#define DI_INF_IS_SORTED            0x00008000L

#define DI_ENUMSINGLEINF            0x00010000L

// The following flags can be used to install a device disabled
// and to prevent CONFIGMG being called when a device is installed
#define DI_DONOTCALLCONFIGMG        0x00020000L
#define DI_INSTALLDISABLED          0x00040000L

// This flag is set of this LPDI is really just an LPCI, ie
// it only contains class info, NO DRIVER/DEVICE INFO
#define DI_CLASSONLY                0x00080000L

// This flag is set if the Class Install params are valid
#define DI_CLASSINSTALLPARAMS       0x00100000L

// This flag is set if the caller of DiCallClassInstaller does NOT
// want the internal default action performed if the Class installer
// return ERR_DI_DO_DEFAULT
#define DI_NODI_DEFAULTACTION       0x00200000L

// BUGBUG. This is a hack for M6 Net setup.  Net Setup does not work correctly
// if we process devnode syncronously.  This WILL be removed for M7 when
// Net setup is fixed to work with DiInstallDevice
#define DI_NOSYNCPROCESSING         0x00400000L

// flags for device installation
#define DI_QUIETINSTALL             0x00800000L     // don't confuse the user with
                                                    // questions or excess info
#define DI_NOFILECOPY               0x01000000L     // No file Copy necessary
#define DI_FORCECOPY                0x02000000L     // Force files to be copied from install path
#define DI_DRIVERPAGE_ADDED         0x04000000L     // Prop providor added Driver page.
#define DI_USECI_SELECTSTRINGS      0x08000000L     // Use Class Installer Provided strings in the Select Device Dlg
#define DI_OVERRIDE_INFFLAGS        0x10000000L     // Override INF flags
#define DI_PROPS_NOCHANGEUSAGE      0x20000000L     // No Enable/Disable in General Props

#define DI_NOSELECTICONS        0x40000000L     // No small icons in select device dialogs

#define DI_NOWRITE_IDS          0x80000000L     // Don't write HW & Compat IDs on install

#define DI_FLAGSEX_USEOLDINFSEARCH  0x00000001L  // Inf Search functions should not use Index Search
#define DI_FLAGSEX_AUTOSELECTRANK0  0x00000002L  // DiSelectDevice doesn't propmt user if rank 0 match
#define DI_FLAGSEX_CI_FAILED        0x00000004L  // Failed to Load/Call class installer

#define DI_FLAGSEX_DIDINFOLIST      0x00000010L  // Did the Class Info List
#define DI_FLAGSEX_DIDCOMPATINFO    0x00000020L  // Did the Compat Info List

#define DI_FLAGSEX_FILTERCLASSES        0x00000040L
#define DI_FLAGSEX_SETFAILEDINSTALL     0x00000080L
#define DI_FLAGSEX_DEVICECHANGE         0x00000100L
#define DI_FLAGSEX_ALWAYSWRITEIDS       0x00000200L
#define DI_FLAGSEX_ALLOWEXCLUDEDDRVS    0x00000800L
#define DI_FLAGSEX_NOUIONQUERYREMOVE    0x00001000L
#define DI_FLAGSEX_RESERVED1            0x00002000L // Reserved for setupapi
#define DI_FLAGSEX_RESERVED2            0x00004000L // Reserved for setupapi
#define DI_FLAGSEX_RESERVED3            0x00008000L // Reserved for setupapi
#define DI_FLAGSEX_RESERVED4            0x00010000L // Reserved for setupapi
#define DI_FLAGSEX_INET_DRIVER          0x00020000L
#define DI_FLAGSEX_RESERVED5            0x00040000L // Reserved for setupapi

// Defines for class installer functions
#define DIF_SELECTDEVICE            0x0001
#define DIF_INSTALLDEVICE           0x0002
#define DIF_ASSIGNRESOURCES         0x0003
#define DIF_PROPERTIES              0x0004
#define DIF_REMOVE                  0x0005
#define DIF_FIRSTTIMESETUP          0x0006
#define DIF_FOUNDDEVICE             0x0007
#define DIF_SELECTCLASSDRIVERS      0x0008
#define DIF_VALIDATECLASSDRIVERS    0x0009
#define DIF_INSTALLCLASSDRIVERS     0x000A
#define DIF_CALCDISKSPACE           0x000B
#define DIF_DESTROYPRIVATEDATA      0x000C
#define DIF_VALIDATEDRIVER          0x000D
#define DIF_MOVEDEVICE              0x000E
#define DIF_DETECT                  0x000F
#define DIF_INSTALLWIZARD           0x0010
#define DIF_DESTROYWIZARDDATA       0x0011
#define DIF_PROPERTYCHANGE          0x0012
#define DIF_ENABLECLASS             0x0013
#define DIF_DETECTVERIFY            0x0014
#define DIF_INSTALLDEVICEFILES      0x0015
#define DIF_UNREMOVE                0x0016
#define DIF_SELECTBESTCOMPATDRV     0x0017
#define DIF_ALLOW_INSTALL           0x0018

typedef UINT        DI_FUNCTION;    // Function type for device installer

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    ENABLECLASS_PARAMS | DIF_ENABLECLASS class install parameters
*
*   @field UINT | cbSize | Size of the ENABLECLASS_PARAMS struct.
*
*   @field LPSTR | szClass | The class that is being enabled.
*
*   @field WORD | wEnableMsg | Specifies the stage of enabling.
*   Can be one of:
*
*   @const ENABLECLASS_QUERY | The class is about to be enabled.  Return
*   ERR_DI_DO_DEFAULT to allow the class to be enabled, or ERR_DI_FAIL_QUERY
*   to prevent the class from being enabled.
*
*   @const ENABLECLASS_SUCCESS | The enabling of the class has succeeded,
*   return ERR_DI_DO_DEFAULT.
*
*   @const ENABLECLASS_FAILURE | The enabling of the class has failed,
*   return ERR_DI_DO_DEFAULT.
*
*******************************************************************************/
// DIF_ENABLECLASS parameter struct.
typedef struct _ENABLECLASS_PARAMS
{
    UINT            cbSize;
    LPSTR           szClass;
    WORD            wEnableMsg;
} ENABLECLASS_PARAMS, FAR * LPENABLECLASS_PARAMS;
#define ASSERT_ENABLECLASSPARAMS_STRUC(lpecp) if (lpecp->cbSize != sizeof(ENABLECLASS_PARAMS)) return (ERR_DI_BAD_ENABLECLASS_PARAMS)

#define ENABLECLASS_QUERY   0
#define ENABLECLASS_SUCCESS 1
#define ENABLECLASS_FAILURE 2

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    MOVEDEV_PARAMS | DIF_MOVEDEVICE class install parameters
*
*   @field UINT | cbSize | Size of the MOVDEV_PARAMS struct.
*
*   @field LPDEVICE_INFO | lpdiOldDev  | Pointer to the device that is being
*   moved.
*
*******************************************************************************/
typedef struct _MOVEDEV_PARAMS
{
    UINT            cbSize;
    LPDEVICE_INFO   lpdiOldDev;     // References the Device Begin Moved
} MOVEDEV_PARAMS, FAR * LPMOVEDEV_PARAMS;
#define ASSERT_MOVEDEVPARAMS_STRUC(lpmdp) if (lpmdp->cbSize != sizeof(MOVEDEV_PARAMS)) return (ERR_DI_BAD_MOVEDEV_PARAMS)

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    PROPCHANGE_PARAMS | DIF_PROPCHANGE class install parameters
*
*   @field UINT | cbSize | Size of the PROPCHANGE_PARAMS struct.
*
*   @field DWORD | dwStateChange | State change action. See DiChangeState for details.
*
*   @field DWORD | dwFlags | Flags specific to the type of state change.
*
*   @field DWORD | dwConfigID | Configuration ID for config specific changes.
*
*   @xref DiChangeState.
*
*******************************************************************************/
typedef struct _PROPCHANGE_PARAMS
{
    UINT            cbSize;
    DWORD           dwStateChange;
    DWORD           dwFlags;
    DWORD           dwConfigID;
} PROPCHANGE_PARAMS, FAR * LPPROPCHANGE_PARAMS;
#define ASSERT_PROPCHANGEPARAMS_STRUC(lpmdp) if (lpmdp->cbSize != sizeof(PROPCHANGE_PARAMS)) return (ERR_DI_BAD_PROPCHANGE_PARAMS)

#define MAX_TITLE_LEN           60
#define MAX_INSTRUCTION_LEN     256
#define MAX_LABEL_LEN           30
/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    SELECTDEVICE_PARAMS | DIF_SELECTDEVICE class install parameters
*
*   @field UINT | cbSize | Size of the SELECTDEVICE_PARAMS struct.
*
*   @field char | szTitle[MAX_TITLE_LEN] | Buffer containing a class installer
*   provided title for the Select Device dialogs.
*
*   @field char | szInstructions[MAX_INSTRUCTION_LEN] |  Buffer containing
*   class installer provided Select Device instructions.
*
*   @field char | szListLabel[MAX_LABEL_LEN] | Buffer containing a lable
*   of the Select Device list of drivers.
*
*******************************************************************************/
typedef struct _SELECTDEVICE_PARAMS
{
    UINT            cbSize;
    char            szTitle[MAX_TITLE_LEN];
    char            szInstructions[MAX_INSTRUCTION_LEN];
    char            szListLabel[MAX_LABEL_LEN];
} SELECTDEVICE_PARAMS, FAR * LPSELECTDEVICE_PARAMS;
#define ASSERT_SELECTDEVICEPARAMS_STRUC(p) if (p->cbSize != sizeof(SELECTDEVICE_PARAMS)) return (ERR_DI_BAD_SELECTDEVICE_PARAMS)

#define DI_REMOVEDEVICE_GLOBAL                  0x00000001
#define DI_REMOVEDEVICE_CONFIGSPECIFIC          0x00000002
/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    REMOVEDEVICE_PARAMS | DIF_REMOVE class install parameters
*
*   @field UINT | cbSize | Size of the REMOVEDEVICE_PARAMS struct.
*
*   @field DWORD | dwFlags | Flags indicating the type of removal to perform.
*       @flag DI_REMOVEDEVICE_GLOBAL         | The device will be removed globally.
*       @flag DI_REMOVEDEVICE_CONFIGSPECIFIC | The device will be removed from only
*       the specified configuration.
*
*   @field DWORD | dwConfigID |  If DI_REMOVEDEVICE_CONFIGSPECIFIC is set, then
*   this is the configuration the device will be removed from. 0 means the current
*   config.
*
*******************************************************************************/
typedef struct _REMOVEDEVICE_PARAMS
{
    UINT            cbSize;
    DWORD           dwFlags;
    DWORD           dwConfigID;
} REMOVEDEVICE_PARAMS, FAR * LPREMOVEDEVICE_PARAMS;
#define ASSERT_REMOVEDPARAMS_STRUC(p) if (p->cbSize != sizeof(REMOVEDEVICE_PARAMS)) return (ERR_DI_BAD_REMOVEDEVICE_PARAMS)

#define DI_UNREMOVEDEVICE_CONFIGSPECIFIC        0x00000002
/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    UNREMOVEDEVICE_PARAMS | DIF_UNREMOVE class install parameters
*
*   @field UINT | cbSize | Size of the UNREMOVEDEVICE_PARAMS struct.
*
*   @field DWORD | dwFlags | Flags indicating the type of removal to perform.
*       @flag DI_UNREMOVEDEVICE_CONFIGSPECIFIC | The device will be unremoved from only
*       the specified configuration.
*
*   @field DWORD | dwConfigID |  If DI_UNREMOVEDEVICE_CONFIGSPECIFIC is set, then
*   this is the configuration the device will be removed from. 0 means the current
*   config.
*
*******************************************************************************/
typedef struct _UNREMOVEDEVICE_PARAMS
{
    UINT            cbSize;
    DWORD           dwFlags;
    DWORD           dwConfigID;
} UNREMOVEDEVICE_PARAMS, FAR * LPUNREMOVEDEVICE_PARAMS;
#define ASSERT_UNREMOVEDPARAMS_STRUC(p) if (p->cbSize != sizeof(UNREMOVEDEVICE_PARAMS)) return (ERR_DI_BAD_UNREMOVEDEVICE_PARAMS)

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @type NONE | Dynamic Hardware Install Wizard Constants | Constants that are
*   used when adding custom pages to the hardware install wizard.
*
*   @const MAX_INSTALLWIZARD_DYNAPAGES | The maximum number of dynamic hardware
*   installation wizard pages that can be added by a class installer.
*
*   @const IDD_DYNAWIZ_FIRSTPAGE | Resource ID for the first page that the install
*   wizard will go to after adding the class installer pages.
*
*   @const IDD_DYNAWIZ_SELECT_PREVPAGE | Resource ID for the page that the Select
*   Device page will go back to.
*
*   @const IDD_DYNAWIZ_SELECT_NEXTPAGE | Resource ID for the page that the Select
*   Device page will go forward to.
*
*   @const IDD_DYNAWIZ_ANALYZE_PREVPAGE | Resource ID for the page that the Analyze
*   page will go back to. This will only be used in the event that there is a
*   problem (i.e a conflict), and the user selects Back from the analyze page.
*
*   @const IDD_DYNAWIZ_ANALYZE_NEXTPAGE | Resource ID for the page that the Analyze
*   page will go to if it continues forward.  The wAnalyzeResult in the
*   INSTALLWIZARDDATA struct will contain the anaysis results.
*
*   @const IDD_DYNAWIZ_INSTALLDETECTED_PREVPAGE | Resource ID for that page that the
*   Install detected devices page will go back to.
*
*   @const IDD_DYNAWIZ_INSTALLDETECTED_NEXTPAGE | Resource ID for the page that the
*   Install detected devices page will go forward to.
*
*   @const IDD_DYNAWIZ_INSTALLDETECTED_NODEVS | Resource ID for the page that the
*   Install detected devices page will go to in the event that no devices are
*   detected.
*
*   @const IDD_DYNAWIZ_SELECTDEV_PAGE | Resource ID of the hardware install wizard's
*   select device page.  This ID can be used to go directly to the hardware install
*   wizard's select device page.
*
*   @const IDD_DYNAWIZ_ANALYZEDEV_PAGE | Resource ID of the hardware install wizard's
*   device analysis page.  This ID can be use to go directly to the hardware install
*   wizard's analysis page.
*
*   @const IDD_DYNAWIZ_INSTALLDETECTEDDEVS_PAGE | Resource ID of the hardware install
*   wizard's install detected devices page.  This ID can be use to go directly to
*   the hardware install wizard's install detected devices page.
*
*   @const IDD_DYNAWIZ_SELECTCLASS_PAGE | Resource ID of the hardware install wizard's
*   select class page.  This ID can be use to go directly to the hardware install
*   wizard's select class page.
*
*******************************************************************************/
// DIF_INSTALLWIZARD  Wizard Data
#define MAX_INSTALLWIZARD_DYNAPAGES             20

// Use this ID for the first page that the install wizard should dynamically jump to.
#define IDD_DYNAWIZ_FIRSTPAGE                   10000

// Use this ID for the page that the Select Device dialog should go back to
#define IDD_DYNAWIZ_SELECT_PREVPAGE             10001

// Use this ID for the page that the Select Device dialog should go to next
#define IDD_DYNAWIZ_SELECT_NEXTPAGE             10002

// Use this ID for the page that the Analyze dialog should go back to
// This will only be used in the event that there is a problem, and the user
// selects Back from the analyze proc.
#define IDD_DYNAWIZ_ANALYZE_PREVPAGE            10003

// Use this ID for the page that the Analyze dialog should go to if it continue from
// the analyze proc.  the wAnalyzeResult in the INSTALLDATA struct will
// contain the anaysis results.
#define IDD_DYNAWIZ_ANALYZE_NEXTPAGE            10004

// This dialog will be selected if the user chooses back from the
// Install Detected Devices dialog.
#define IDD_DYNAWIZ_INSTALLDETECTED_PREVPAGE    10006

// This dialog will be selected if the user chooses Next from the
// Install Detected Devices dialog.
#define IDD_DYNAWIZ_INSTALLDETECTED_NEXTPAGE    10007

// This is the ID of the dialog to select if detection does not
// find any new devices
#define IDD_DYNAWIZ_INSTALLDETECTED_NODEVS      10008

// This is the ID of the Select Device Wizard page.
#define IDD_DYNAWIZ_SELECTDEV_PAGE              10009

// This is the ID of the Analyze Device Wizard page.
#define IDD_DYNAWIZ_ANALYZEDEV_PAGE             10010

// This is the ID of the Install Detected Devs Wizard page.
#define IDD_DYNAWIZ_INSTALLDETECTEDDEVS_PAGE    10011

// This is the ID of the Select Class Wizard page.
#define IDD_DYNAWIZ_SELECTCLASS_PAGE            10012

// This flag is set if a Class installer has added pages to the
// install wizard.
#define DYNAWIZ_FLAG_PAGESADDED             0x00000001

// The following flags will control the button states when displaying
// the InstallDetectedDevs dialog.
#define DYNAWIZ_FLAG_INSTALLDET_NEXT        0x00000002
#define DYNAWIZ_FLAG_INSTALLDET_PREV        0x00000004

// Set this flag if you jump to the analyze page, and want it to
// handle conflicts for you.  NOTE.  You will not get control back
// in the event of a conflict if you set this flag.
#define DYNAWIZ_FLAG_ANALYZE_HANDLECONFLICT 0x00000008

#define ANALYZE_FACTDEF_OK      1
#define ANALYZE_STDCFG_OK       2
#define ANALYZE_CONFLICT        3
#define ANALYZE_NORESOURCES     4
#define ANALYZE_ERROR           5
#define ANALYZE_PNP_DEV         6
#define ANALYZE_PCMCIA_DEV      7

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    INSTALLWIZARDDATA | DIF_INSTALLWIZARD class install parameters. This
*   struct is used by class installers to extend the operation of the hardware
*   installation wizard by adding custom pages.
*
*   @field UINT | cbSize | Size of the INSTALLWIZARDDATA struct.
*
*   @field LPDEVICE_INFO | lpdiOriginal | Pointer to the Original DEVICE_INFO
*   struct at the start of the manual installation.
*
*   @field LPDEVICE_INFO | lpdiSelected | Pointer to the current DEVICE_INFO struct
*   that is being manually selected.
*
*   @field DWORD | dwFlags | Flags that control the operation of the hardware
*   installation wizard.  There are currently none defined.
*
*   @field LPVOID | lpConfigData | Pointer to configuration data for analysis to
*   determine if the selected device can be installed with no conflicts.
*
*   @field WORD | wAnalyzeResult | Results of analysis to determine if the device
*   can be installed with no problems.  The following values are defined:
*       @flag ANALYZE_FACTDEF_OK    | The device can be installed using its factory
*       default settings.
*       @flag ANALYZE_STDCFG_OK     | The device can be installed using a configuration
*       specified in one if its basic logical configurations.  The user will probably
*       have to set jumpers or switches on the hardware to match the settings determined
*       by the install wizard.
*       @flag ANALYZE_CONFLICT      | The device cannot be installed without causing a
*       conflict with another device.
*       @flag ANALYZE_NORESOURCES   | The device does not require any resources, so it
*       can be installed witth no conflicts.
*       @flag ANALYZE_ERROR         | There was an error during analysis.
*       @flag ANALYZE_PNP_DEV       | The device has a least one softsettable logical
*       configurations, allowing it to be automatically configured.  Additionally the
*       device will be enumerated by one of the standard bus enumerators, so it does
*       not require manual installation, except to pre-copy driver files.
*
*   @field HPROPSHEETPAGE | hpsDynamicPages[MAX_INSTALLWIZARD_DYNAPAGES] | An
*   array of property sheet page handles.  The class installer would use this array
*   to create custom wizard pages, and insert their handles into this array.
*
*   @field WORD | wNumDynaPages | The number of pages inserted into the hpsDynamicPages
*   array.
*
*   @field DWORD | dwDynaWizFlags | Flags that control the behavior of the
*   installation wizard whtn dynamic pages have been added.
*       @flag DYNAWIZ_FLAG_PAGESADDED | Will be set by the install wizard if the
*       class installer adds custom pages.
*       @flag DYNAWIZ_FLAG_INSTALLDET_NEXT | If set, the install wizard will allow
*       going forward from the detected devices page, otherwise finish will
*       be the default option for the detected devices page.
*       @flag DYNAWIZ_FLAG_INSTALLDET_PREV | If set, the install wizard will allow
*       going back from the detected devices page.
*       @flag DYNAWIZ_FLAG_ANALYZE_HANDLECONFLICT | If set, the class installer will
*       handle the case where the selected device cannot be installed because of
*       a conflict.
*
*   @field DWORD | dwPrivateFlags | Flags that may be defined and used by the class
*   installer.
*
*   @field LPARAM | lpPrivateData | Pointer to private reference data defined and
*   set by the class installer.
*
*   @field LPSTR | lpExtraRunDllParams | Pointer to a string containing extra
*   parameters passed to the hardware install rundll function.
*
*   @field HWND | hwndWizardDlg | Window handle of the install wizard top level
*   window.
*
*******************************************************************************/
typedef struct InstallWizardData_tag
{
    UINT                    cbSize;

    LPDEVICE_INFO           lpdiOriginal;
    LPDEVICE_INFO           lpdiSelected;
    DWORD                   dwFlags;
    LPVOID                  lpConfigData;
    WORD                    wAnalyzeResult;

    // The following fields are used when a Class Installer Extends the Install Wizard
    HPROPSHEETPAGE          hpsDynamicPages[MAX_INSTALLWIZARD_DYNAPAGES];
    WORD                    wNumDynaPages;
    DWORD                   dwDynaWizFlags;
    DWORD                   dwPrivateFlags;
    LPARAM                  lpPrivateData;
    LPSTR                   lpExtraRunDllParams;
    HWND                    hwndWizardDlg;
} INSTALLWIZDATA, * PINSTALLWIZDATA , FAR *LPINSTALLWIZDATA;

RETERR WINAPI DiCreateDeviceInfo(
    LPLPDEVICE_INFO lplpdi,     // Ptr to ptr to dev info
    LPCSTR      lpszDescription,    // If non-null then description string
    DWORD       hDevnode,       // BUGBUG -- MAKE A DEVNODE
    HKEY        hkey,       // Registry hkey for dev info
    LPCSTR      lpszRegsubkey,  // If non-null then reg subkey string
    LPCSTR      lpszClassName,  // If non-null then class name string
    HWND        hwndParent);    // If non-null then hwnd of parent

RETERR WINAPI DiGetClassDevs(
    LPLPDEVICE_INFO lplpdi,     // Ptr to ptr to dev info
    LPCSTR      lpszClassName,  // Must be name of class
    HWND        hwndParent,     // If non-null then hwnd of parent
    int         iFlags);        // Options

RETERR WINAPI DiGetClassDevsEx(
    LPLPDEVICE_INFO lplpdi,     // Ptr to ptr to dev info
    LPCSTR      lpszClassName,  // Must be name of class
    LPCSTR      lpszEnumerator, // Must be name of enumerator, or NULL
    HWND        hwndParent,     // If non-null then hwnd of parent
    int         iFlags);        // Options

#define DIGCF_DEFAULT           0x0001  // NOT IMPLEMENTED!
#define DIGCF_PRESENT           0x0002
#define DIGCF_ALLCLASSES        0x0004
#define DIGCF_PROFILE           0x0008

// API to return the Class name of an INF File
RETERR WINAPI DiGetINFClass(LPSTR lpszMWDPath, UINT InfType, LPSTR lpszClassName, DWORD dwcbClassName);

RETERR WINAPI PASCAL DiCreateDevRegKey(
    LPDEVICE_INFO   lpdi,
    LPHKEY      lphk,
    HINF        hinf,
    LPCSTR      lpszInfSection,
    int         iFlags);

RETERR WINAPI PASCAL DiDeleteDevRegKey(LPDEVICE_INFO lpdi, int  iFlags);


RETERR WINAPI PASCAL DiOpenDevRegKey(
    LPDEVICE_INFO   lpdi,
    LPHKEY      lphk,
    int         iFlags);

#define DIREG_DEV   0x0001      // Open/Create/Delete device key
#define DIREG_DRV   0x0002      // Open/Create/Delete driver key
#define DIREG_BOTH  0x0004      // Delete both driver and Device key

RETERR WINAPI DiReadRegLogConf
(
    LPDEVICE_INFO       lpdi,
    LPSTR               lpszConfigName,
    LPBYTE FAR          *lplpbLogConf,
    LPDWORD             lpdwSize
);

RETERR WINAPI DiReadRegConf
(
    LPDEVICE_INFO       lpdi,
    LPBYTE FAR          *lplpbLogConf,
    LPDWORD             lpdwSize,
    DWORD               dwFlags
);

#define DIREGLC_FORCEDCONFIG        0x00000001
#define DIREGLC_BOOTCONFIG          0x00000002

RETERR WINAPI DiCopyRegSubKeyValue
(
    HKEY    hkKey,
    LPSTR   lpszFromSubKey,
    LPSTR   lpszToSubKey,
    LPSTR   lpszValueToCopy
);

RETERR WINAPI DiDestroyClassInfoList(LPCLASS_INFO lpci);
RETERR WINAPI DiBuildClassInfoList(LPLPCLASS_INFO lplpci);

#define DIBCI_NOINSTALLCLASS        0x000000001
#define DIBCI_NODISPLAYCLASS        0x000000002

RETERR WINAPI DiBuildClassInfoListEx(LPLPCLASS_INFO lplpci, DWORD dwFlags);
RETERR WINAPI DiGetDeviceClassInfo(LPLPCLASS_INFO lplpci, LPDEVICE_INFO lpdi);

RETERR WINAPI DiDestroyDeviceInfoList(LPDEVICE_INFO lpdi);
RETERR WINAPI DiSelectDevice( LPDEVICE_INFO lpdi );
RETERR WINAPI DiSelectOEMDrv(HWND hDlg, LPDEVICE_INFO lpdi);

// Callback for diInstallDevice vcpOpen.  Basically calls vcpUICallback for everthing
// except when DI_FORCECOPY is active, in which case copies get defaulted to
// VCPN_FORCE
LRESULT CALLBACK diInstallDeviceUICallbackProc(LPVOID lpvObj, UINT uMsg, WPARAM wParam, LPARAM lParam, LPARAM lparamRef);
RETERR WINAPI DiInstallDevice( LPDEVICE_INFO lpdi );
RETERR WINAPI DiInstallDriverFiles(LPDEVICE_INFO lpdi);

RETERR WINAPI DiRemoveDevice( LPDEVICE_INFO lpdi );
RETERR WINAPI DiUnremoveDevice( LPDEVICE_INFO lpdi );
RETERR WINAPI DiAskForOEMDisk(LPDEVICE_INFO lpdi);

RETERR WINAPI DiCallClassInstaller(DI_FUNCTION diFctn, LPDEVICE_INFO lpdi);

BOOL WINAPI DiBuildDriverIndex(BOOL bUI);
BOOL WINAPI DiAddSingleInfToDrvIdx(LPSTR lpszInfName, WORD InfType, BOOL bCreate);
BOOL WINAPI DiDeleteSingleInfFromDrvIdx(LPSTR lpszInfPath);

RETERR WINAPI DiBuildCompatDrvList(LPDEVICE_INFO lpdi);
LPDRIVER_NODE   WINAPI DiSelectBestCompatDrv(LPDEVICE_INFO lpdi, LPDRIVER_NODE lpdnCurrent);

// Given list of drivers returns the newest, may be used by class installers when 
// called by DiSelectBestCompatDrv.
LPDRIVER_NODE WINAPI DiPickBestDriver(LPDRIVER_NODE lpdnList); 

RETERR WINAPI DiBuildClassDrvList(LPDEVICE_INFO lpdi);
RETERR WINAPI DiBuildCompatDrvInfoList(LPDEVICE_INFO lpdi);
RETERR WINAPI DiBuildClassDrvInfoList(LPDEVICE_INFO lpdi);
RETERR WINAPI DiDestroyDrvInfoList(LPDRIVER_INFO lpInfo);
LPDRIVER_NODE WINAPI DiConvertDriverInfoToDriverNode(LPDEVICE_INFO lpdi, LPDRIVER_INFO lpInfo);

typedef RETERR (CALLBACK *OLDINFPROC)(HINF hinf, LPCSTR lpszNewInf, LPARAM lParam);
RETERR WINAPI DiBuildClassDrvListFromOldInf(LPDEVICE_INFO lpdi, LPCSTR lpszSection, OLDINFPROC lpfnOldInfProc, LPARAM lParam);

RETERR WINAPI DiDestroyDriverNodeList(LPDRIVER_NODE lpdn);

RETERR  WINAPI  DiMoveDuplicateDevNode(LPDEVICE_INFO lpdiNewDev);

// The following export will load a dll and find the specified proc name
typedef RETERR (FAR PASCAL *DIINSTALLERPROPERTIES)(LPDEVICE_INFO);

RETERR WINAPI GetFctn(HKEY hk, LPSTR lpszRegVal, LPSTR lpszDefProcName,
                      HINSTANCE FAR * lphinst, FARPROC FAR *lplpfn);

RETERR
WINAPI
DiCreateDriverNode(
    LPLPDRIVER_NODE lplpdn,
    UINT    Rank,
    UINT    InfType,
    unsigned    InfDate,
    LPCSTR  lpszDevDescription,
    LPCSTR  lpszDrvDescription,
    LPCSTR  lpszProviderName,
    LPCSTR  lpszMfgName,
    LPCSTR  lpszInfFileName,
    LPCSTR  lpszSectionName,
    DWORD   dwPrivateData);

RETERR WINAPI DiLoadClassIcon(
    LPCSTR  szClassName,
    HICON FAR *lphiLargeIcon,
    int FAR *lpiMiniIconIndex);


RETERR WINAPI DiInstallDrvSection(
    LPCSTR  lpszInfFileName,
    LPCSTR  lpszSection,
    LPCSTR  lpszClassName,
    LPCSTR  lpszDescription,
    DWORD   dwFlags);


RETERR WINAPI DiChangeState(LPDEVICE_INFO lpdi, DWORD dwStateChange, DWORD dwFlags, LPARAM lParam);

#define DICS_ENABLE                 0x00000001
#define DICS_DISABLE                0x00000002
#define DICS_PROPCHANGE         0x00000003
#define DICS_START          0x00000004
#define DICS_STOP           0x00000005

#define DICS_FLAG_GLOBAL            0x00000001
#define DICS_FLAG_CONFIGSPECIFIC    0x00000002
#define DICS_FLAG_CONFIGGENERAL     0x00000004

RETERR WINAPI DiInstallClass(LPCSTR lpszInfFileName, DWORD dwFlags);

RETERR WINAPI DiOpenClassRegKey(LPHKEY lphk, LPCSTR lpszClassName);

// support routine for dealing with class mini icons
#define DMI_MASK            0x0001
#define DMI_BKCOLOR         0x0002
#define DMI_USERECT         0x0004
int WINAPI PASCAL DiDrawMiniIcon(HDC hdc, RECT rcLine, int iMiniIcon, DWORD flags);
BOOL WINAPI DiGetClassBitmapIndex(LPCSTR lpszClass, int FAR *lpiMiniIconIndex);

// internal calls for display class
#define DISPLAY_SETMODE_SUCCESS     0x0001
#define DISPLAY_SETMODE_DRVCHANGE   0x0002
#define DISPLAY_SETMODE_FONTCHANGE  0x0004

UINT WINAPI Display_SetMode(LPDEVICE_INFO lpdi, UINT uColorRes, int iXRes, int iYRes);
RETERR WINAPI Display_ClassInstaller(DI_FUNCTION diFctn, LPDEVICE_INFO lpdi);
RETERR WINAPI Display_OpenFontSizeKey(LPHKEY lphkFontSize);
BOOL WINAPI Display_SetFontSize(LPCSTR lpszFontSize);

RETERR WINAPI DiIsThereNeedToCopy(HWND hwnd, DWORD dwFlags);

#define DINTC_NOCOPYDEFAULT     0x00000001

// API for the mouse class installer
RETERR WINAPI Mouse_ClassInstaller(DI_FUNCTION diFctn, LPDEVICE_INFO lpdi);
#endif // NODEVICEINSTALL

// API for determining if a Driver file is currently part of VMM32.VxD
BOOL WINAPI bIsFileInVMM32
(
    LPSTR   lpszFileName
);

// API for determining if a display is a primary or secondary
BOOL WINAPI Display_IsSecondDisplay(
    LPDEVICE_INFO lpdi
    );

// Japanese Keyboard Support
LONG _export WINAPI GetJapaneseKeyboardType();
#define JP_101KBD       0
#define JP_AXKBD        1
#define JP_106KBD       2
#define JP_003KBD       3
#define JP_001KBD       4
#define JP_TB_DESKTOP   5
#define JP_TB_LAPTOP    6
#define JP_TB_NOTEBOOK  7


#ifndef NOUSERINTERFACE
/***************************************************************************/
//
// User Interface prototypes and definitions
//
/***************************************************************************/

BOOL WINAPI UiMakeDlgNonBold(HWND hDlg);
VOID WINAPI UiDeleteNonBoldFont(HWND hDlg);

#endif

/***************************************************************************/
//
// setup reg DB calls, use just like those in kernel
//
/***************************************************************************/

DWORD WINAPI SURegOpenKey(HKEY hKey, LPCSTR lpszSubKey, HKEY FAR *lphkResult);
DWORD WINAPI SURegCloseKey(HKEY hKey);
DWORD WINAPI SURegCreateKey(HKEY hKey, LPCSTR lpszSubKey, HKEY FAR *lphkResult);
DWORD WINAPI SURegDeleteKey(HKEY hKey, LPCSTR lpszSubKey);
DWORD WINAPI SURegEnumKey(HKEY hKey, DWORD dwIdx, LPSTR lpszBuffer, DWORD dwBufSize);
DWORD WINAPI SURegQueryValue16(HKEY hKey, LPCSTR lpszSubKey, LPSTR lpValueBuf, DWORD FAR *ldwBufSize);
DWORD WINAPI SURegSetValue16(HKEY hKey, LPCSTR lpszSubKey, DWORD dwType, LPCBYTE lpszValue, DWORD dwValSize);
DWORD WINAPI SURegDeleteValue(HKEY hKey,LPCSTR lpszValue);
DWORD WINAPI SURegEnumValue(HKEY hKey,DWORD dwIdx, LPCSTR lpszValue, DWORD FAR *lpcbValue, DWORD FAR *lpdwReserved, DWORD FAR *lpdwType, LPBYTE lpbData, DWORD FAR *lpcbData);
DWORD WINAPI SURegQueryValueEx(HKEY hKey,LPCSTR lpszValueName, DWORD FAR *lpdwReserved,DWORD FAR *lpdwType,LPSTR lpValueBuf, DWORD FAR *ldwBufSize);
DWORD WINAPI SURegSetValueEx(HKEY hKey,LPCSTR lpszValueName, DWORD dwReserved, DWORD dwType, LPBYTE lpszValue, DWORD dwValSize);
DWORD WINAPI SURegSaveKey(HKEY hKey, LPCSTR lpszFileName, LPVOID lpsa);
DWORD WINAPI SURegLoadKey(HKEY hKey, LPCSTR lpszSubKey, LPCSTR lpszFileName);
DWORD WINAPI SURegUnLoadKey(HKEY hKey, LPCSTR lpszSubKey);

DWORD WINAPI SURegFlush(VOID);
DWORD WINAPI SURegInit(VOID);    // should be called before any other Reg APIs

/***************************************************************************/
// setup FormatMessage support
/***************************************************************************/
#define MB_LOG  (UINT)-1
#define MB_DBG  (UINT)-2

UINT FAR CDECL suFormatMessage(HINSTANCE hAppInst, LPCSTR lpcFormat, LPSTR szMessage, UINT uSize,
    ...);
UINT WINAPI suvFormatMessage(HINSTANCE hAppInst, LPCSTR lpcFormat, LPSTR szMessage, UINT uSize,
    LPVOID FAR * lpArgs);
int WINCAPI _loadds suFormatMessageBox(HINSTANCE hAppInst, HWND hwndParent, LPCSTR lpcText, LPCSTR lpcTitle,
    UINT uStyle, ...);

WORD WINAPI suErrorToIds( WORD Value, WORD Class );

/***************************************************************************/
// setup Version Conflict support
/***************************************************************************/

LPVOID WINAPI suVerConflictInit(BOOL fYesToLangMismatch);
void WINAPI suVerConflictTerm(LPVOID lpvData);
LRESULT WINAPI suVerConflict(HWND hwnd, LPVCPVERCONFLICT lpvc, BOOL bBackup, LPVOID lpvData);
int WINAPI sxCompareDosAppVer( LPCSTR lpszOldFileSpec, LPCSTR lpszNewFileSpec);


/***************************************************************************/
// setup Help support
/***************************************************************************/

BOOL WINAPI suHelp( HWND hwndApp, HWND hwndDlg );

//***************************************************************************/
// setup Emergency Boot Disk (EBD) creation fn.
//***************************************************************************/

RETERR WINAPI suCreateEBD( HWND hWnd, VIFPROC CopyCallbackProc, LPARAM lpuii );

//***************************************************************************
// Misc SETUPX.DLL support functions.
//***************************************************************************
enum  SU_ACTIONS                        // Actions msgs for Setupx()    /* ;Internal */
{                                                                       /* ;Internal */
    SUX_REGINIT,                        // Intialize registry           /* ;Internal */
    SUX_DBGLEVEL,                       // Set debug level              /* ;Internal */
    SUX_SETUPFLG,                       // Set fIsSetup flag            /* ;Internal */
    SUX_FASTSETUP,                      // Setupx => checking less mode /* ;Internal */
    SUX_FORCEREGFLUSH,                  // Call kRegFlush               /* ;Internal */
    SUX_TPSFLUSH,                       // Call TPS_Flush() fns.        /* ;Internal */
    SUX_DBGHFILE,                       // File to write messages to    /* ;Internal */
    SUX_LOADSTORELDIDS,                 // Load/store setup's LDID's    /* ;Internal */
    SUX_ENABLEREGFLUSH,                 // Enable/Disable SURegFlush() if fIsSetup  /* ;Internal */
    SUX_SETUNCPATHFUNC,                 // NOW UNUSED!!                   /* ;Internal */
    SUX_SETTRUEDISKFREEFUNC,            // Set TRUE disk free func      /* ;Internal */
    SUX_ISFLOPPYBOOT,                   // Set TRUE if floppy boot disk /* ;Internal */
    SUX_BISVER4,                        // returns bIsVer4(CHICAGO) flag/* ;Internal */
    SUX_SETCTLCALLBACKFUNC,             // Set ctlCopyCallBackProc Func /* ;Internal */
    SUX_GETCTLCALLBACKFUNC,             // Get ctlCopyCallBackProc Func /* ;Internal */
    SUX_BISMULTICFG,                    // returns SETUPX's gfMultiCfg  /* ;Internal */
    SUX_DUMPDSINFO,                     // Dumps diskspace info         /* ;Internal */
    SUX_INFCACHEOFF,                    // Turns INF file caching on/off/* ;Internal */
    SUX_SETFCDROMDRIVEEXISTS,           // Set CDRomDriveExists func    /* ;Internal */
    SUX_ALLOCRMBUFFERS,                 // Allocate real mode buffers   /* ;Internal */
    SUX_FREERMBUFFERS,                  // Free real mode buffers       /* ;Internal */
    SUX_DODOSEBDWORK                    // Do DOS EBD Work              /* ;Internal */
};                                                                      /* ;Internal */

RETERR WINAPI Setupx( UINT uMsg, WPARAM wParam, LPARAM lParam );        /* ;Internal */

RETERR WINAPI SUStoreLdidPath( LOGDISKID ldid, LPSTR lpszPath );        /* ;Internal */

BOOL WINAPI sxIsSBSServerFile( LPVIRTNODE lpVn );                       /* ;Internal */

BOOL WINAPI sxMakeUNCPath( LPSTR lpszPath );                            /* ;Internal */

typedef RETERR (CALLBACK* FBFPROC)(LPCSTR lpszFileName, LPVOID lpVoid); /* ;Internal */
RETERR WINAPI sxFindBatchFiles(HTP,int,FBFPROC,LPVOID);         /* ;Internal */

RETERR WINAPI SUGetSetSetupFlags(LPDWORD lpdwFlags, BOOL bSet);

RETERR WINAPI CfgSetupMerge( int uFlags );
BOOL WINAPI sxIsMSDOS7Running();
BOOL WINAPI IsPanEuropean();

// structure for the LPARAM argument to Setupx() for SUX_REGINIT action.    ;Internal
typedef struct _REGINIT_S { /* setupx - reg_init */                     /* ;Internal */
    LPSTR       lpszSystemFile;         // reg's base SYSTEM filename   /* ;Internal */
    LOGDISKID   ldidSystemFile;         // ldid for SYSTEM filename     /* ;Internal */
    LPSTR       lpszUserFile;           // reg's base USER filename     /* ;Internal */
    LOGDISKID   ldidUserFile;           // ldid for USER filename       /* ;Internal */
} REGINIT_S, FAR *LPREGINIT;                                            /* ;Internal */

#ifndef LPLPSTR
    typedef LPSTR (FAR *LPLPSTR);
#endif


#define         CFG_PARSE_BUFLEN 1024    // Buf sized passed line obj funcs      /* ;Internal */

LPLPSTR WINAPI  CfgParseLine( LPCSTR szLine, LPSTR Buf );                       /* ;Internal */
BOOL    WINAPI  CfgSetAutoProcess( int TrueFalse );                             /* ;Internal */
void    WINAPI  CfgObjToStr( LPLPSTR apszObj, LPSTR szLine );                   /* ;Internal */
LPLPSTR WINAPI  CfgLnToObj( HTP hSection, int Offset, int Origin, LPSTR Buf );  /* ;Internal */
LPLPSTR WINAPI  CfgObjFindKeyCmd( HTP hSec, LPCSTR szKey, LPCSTR szCmd,         /* ;Internal */
                                  int Offset, int Origin, LPSTR Buf );          /* ;Internal */
LPCSTR WINAPI   WildCardStrCmpi( LPCSTR szKey, LPCSTR szLine, LPCSTR szDelims ); /* ;Internal */
RETERR WINAPI   GenMapRootRegStr2Key( LPCSTR szRegRoot, HKEY hRegRelKey,        /* ;Internal */
                                                        HKEY FAR *lphkeyRoot ); /* ;Internal */


//***************************************************************************
//
// ENUMS for accessing config.sys/autoexec.bat line objects using the
// array returned by ParseConfigLine()..
//
//***************************************************************************

enum    CFGLINE_STRINGS                     // Config.sys/autoexec.bat objects
{
    CFG_KEYLEAD,                            // Keyword leading whitespaces
    CFG_KEYWORD,                            // Keyword
    CFG_KEYTRAIL,                           // Keyword trailing delimiters
    CFG_UMBINFO,                            // Load high info
    CFG_DRVLETTER,                          // Drive letter for cmd path
    CFG_PATH,                               // Command path
    CFG_COMMAND,                            // Command base name
    CFG_EXT,                                // Command extension including '.'
    CFG_ARGS,                               // Command arguments
    CFG_FREE,                               // Free area at end of buffer
    CFG_END
};

/*---------------------------------------------------------------------------*
 *                  SUB String Data
 *---------------------------------------------------------------------------*/

/*******************************************************************************
*   AUTODOC
*   @doc    EXTERNAL SETUPX DEVICE_INSTALLER
*
*   @types    SUBSTR_DATA | Data structure used to manage substrings.
*   struct is used by class installers to extend the operation of the hardware
*   installation wizard by adding custom pages.
*
*   @field LPSTR | lpFirstSubstr | Pointer to the first substring in the list.
*
*   @field LPSTR | lpCurSubstr | Pointer to the current substring in the list.
*
*   @field LPSTR | lpLastSubstr | Pointer to the last substring in the list.
*
*   @xref InitSubstrData
*   @xref GetFirstSubstr
*   @xref GetNextSubstr
*
*******************************************************************************/
typedef struct _SUBSTR_DATA {
    LPSTR lpFirstSubstr;
    LPSTR lpCurSubstr;
    LPSTR lpLastSubstr;
}   SUBSTR_DATA;


typedef SUBSTR_DATA*        PSUBSTR_DATA;
typedef SUBSTR_DATA NEAR*   NPSUBSTR_DATA;
typedef SUBSTR_DATA FAR*    LPSUBSTR_DATA;

BOOL WINAPI InitSubstrData(LPSUBSTR_DATA lpSubstrData, LPSTR lpStr);
BOOL WINAPI GetFirstSubstr(LPSUBSTR_DATA lpSubstrData);
BOOL WINAPI GetNextSubstr(LPSUBSTR_DATA lpSubStrData);
BOOL WINAPI InitSubstrDataEx(LPSUBSTR_DATA lpssd, LPSTR lpString, char chDelim);  /* ;Internal */

BOOL WINAPI FirstBootMoveToDOSSTART(LPSTR lpszCmd, BOOL fRemark);
BOOL WINAPI DOSOptEnableCurCfg(LPCSTR lpszOptKey);

/*---------------------------------------------------------------------------*
 *                  Misc. Di functions
 *---------------------------------------------------------------------------*/
BOOL WINAPI DiBuildPotentialDuplicatesList
(
    LPDEVICE_INFO   lpdi,
    LPSTR           lpDuplicateList,
    DWORD           cbSize,
    LPDWORD         lpcbData,
    LPSTR           lpstrDupType
);

BOOL _loadds WINAPI WalkSubtree(DWORD dnRoot, LPSTR szDrvLet);

// PID
BOOL _loadds WINAPI PidConstruct( LPSTR lpszProductType, LPSTR lpszPID, LPSTR lpszUPI, int iAction);
BOOL _loadds WINAPI PidValidate( LPSTR lpszProductType, LPSTR lpszPID);
int _loadds WINAPI WriteDMFBootData(int iDrive, LPSTR pData, int cb);

// FirstRunScreens
RETERR WINAPI DoFirstRunScreens();

// Migration DLLs
#define SU_MIGRATE_PREINFLOAD    0x00000001	// before the setup INFs are loaded
#define SU_MIGRATE_POSTINFLOAD   0x00000002	// after the setup INFs are loaded
#define SU_MIGRATE_DISKSPACE     0x00000010	// request for the amount of additional diskspace needed
#define SU_MIGRATE_PREQUEUE      0x00000100	// before the INFs are processed and files are queued
#define SU_MIGRATE_POSTQUEUE     0x00000200	// after INFs are processed
#define SU_MIGRATE_REBOOT        0x00000400	// just before we are going to reboot for the 1st time
#define SU_MIGRATE_PRERUNONCE    0x00010000	// before any runonce items are processed
#define SU_MIGRATE_POSTRUNONCE   0x00020000	// after all runonce items are processed
DWORD WINAPI sxCallMigrationDLLs( DWORD dwStage, LPARAM lParam );
void WINAPI _loadds sxCallMigrationDLLs_RunDll(HWND, HINSTANCE, LPSTR, int);

//Count Down Dlg
int WINAPI SxShowRebootDlg(UINT, HWND);
void WINAPI _loadds SxShowRebootDlg_RunDll(HWND, HINSTANCE, LPSTR, int);

BOOL WINAPI CopyInfFile( LPSTR, LPSTR, UINT );

BOOL WINAPI IsWindowsFile( LPSTR lpszFile );

RETERR WINAPI VerifySelectedDriver(LPDEVICE_INFO lpdi, BOOL *pbYesToAll);

//Dialog positioning function and defn's(wPosFlags)
#define DLG_CENTERV         0x01
#define DLG_CENTERH         0x02
#define DLG_CENTER          DLG_CENTERV | DLG_CENTERH
#define DLG_TOP             0x04
#define DLG_BOTTOM          0x08
#define DLG_RIGHT           0x10
#define DLG_LEFT            0x20
BOOL WINAPI uiPositionDialog( HWND hwndDlg, WORD wPosFlags );

//***************************************************************************
#endif      // SETUPX_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\setup\pgmgrp\precomp.h ===
#include <windows.h>
#include <shlobj.h>
#include <stock.h>
#include <oprahcom.h>
#include <confdbg.h>
#include <regentry.h>
#include <confreg.h>
#include <cstring.hpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\setup\pgmgrp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by pgmgrp.rc
//
#define IDS_SETUP_RUNNING               1
#define IDS_SETUP_INCOMPATIBLE          2
#define IDS_SETUP_SUCCESS               3
#define IDS_SETUP_WIN2K                 4
#define IDS_SETUP_IE4                   5

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\setup\pgmgrp\pgmgrp.cpp ===
/*
 * NMPGMGRP - Tiny program to add and remove items from the program group.  
 * Its initial purpose is to support Windows NT common program groups, 
 * which are not supported by GRPCONV.
 *
 * Usage:
 *
 *  NMPGMGRP /add [/common] [/g:"<group name>"] /n:"<program name>" 
 *		/p:"<program path>"
 *  NMPGMGRP /delete [/common] [/g:"<group name>"] /n:"<program name>"
 *
 *  NMPGMGRP /i /n:"<src mnmdd.dll>" /p:"<dst mnmdd.dll>"   INSTALL NT DD
 *  NMPGMGRP /u /n:"<src mnmdd.dll>"                        UNINSTALL NT DD
 *
 *  NMPGMGRP /s [/q] /n:"<inf file>" /f"<friendly name>"			SETUP
 *
 *	/add is used to add a new program item.
 *	/delete is used to remove an existing program item.
 *
 *	/common indicates that this item belong in the common (as opposed to 
 *		per-user) program groups.
 *
 *	<group name> is the name of the program group, expressed as a pathname 
 *		relative to the Programs group.  For items in the Programs group, 
 *		this parameter should be omitted.
 *
 *	<program name> is the name of the program, and is also used as the name
 *		of the shortcut file itself.
 *
 *	<program path> is the full path name of the program.
 *
 *	<inf file> is the name of the installation inf.
 *
 *	<friendly name> is the text to be used for any message box title.
 *
 * Limitations:
 *
 *	Because some of these strings may contain spaces, the group name, program
 *	name, and program path MUST be enclosed in quotes.  Currently we do not
 *	support strings with quotes in them.
 *
 *	Some of the system functions used in this program are Unicode
 *	specific, so this program will require some modifications to run on
 *	Windows 95.
 *
 * Author:
 *	DannyGl, 23 Mar 97
 */

#include "precomp.h"
#include "resource.h"

#include <nmremote.h>

#pragma intrinsic(memset)

// DEBUG only -- Define debug zone
#ifdef DEBUG
HDBGZONE ghZone = NULL;  // Node Controller Zones
static PTCHAR rgZones[] = {
	TEXT("NMPgmGrp")
};
#endif // DEBUG


// PROGRAM_ITEM_INFO structure:
//
// Intended to be passed as input to the CreateProgramItem and 
// DeleteProgramItem functions.  Fields are:
//		
//		pszProgramGroup - The full path of the program group in which the
//			item is to be stored.
//		pszProgramName - The name of the program item.
//		pszProgramPath - The full path of the program.

typedef
struct tagProgramItemInfo
{
	PTSTR pszProgramGroup;
	PTSTR pszProgramName;
	PTSTR pszProgramPath;
} PROGRAM_ITEM_INFO, *PPROGRAM_ITEM_INFO;


// Command line option data
enum tagGroupOperation
{
	GRPOP_NONE = 0,
	GRPOP_ADD,
	GRPOP_DEL,
    GRPOP_NTDDINSTALL,
    GRPOP_NTDDUNINSTALL,
    GRPOP_SETUP
} g_goAction;

BOOL g_fCommonGroup = FALSE;
PTSTR g_pszGroupName = NULL;
PTSTR g_pszProgramName = NULL;
PTSTR g_pszProgramPath = NULL;
PTSTR g_pszFriendlyName = NULL;
BOOL g_fQuietInstall = FALSE;

const TCHAR g_cszSetupDll[] = TEXT("advpack.dll");
const TCHAR g_cszSetupEntry[] = TEXT("LaunchINFSection");
typedef int (CALLBACK * PFNSETUPENTRY)(HWND hwnd, HINSTANCE hinst, LPTSTR lpszCmdLine, int nCmdShow);


// ProcessCommandLineArgs: 
//
// Get the command line and parse it into individual parameters using the
// above global variables.
//
// Return: TRUE on success, FALSE if it could not parse the command line.
BOOL
ProcessCommandLineArgs(void)
{
	PTSTR pszTemp;

	pszTemp = GetCommandLine();

	// Search for forward slashes
	pszTemp = (PTSTR) _StrChr(pszTemp, TEXT('/'));

	while (NULL != pszTemp)
	{
		PTSTR *ppszCurrentArg = NULL;

		switch(*++pszTemp)
		{
		case TEXT('S'):
		case TEXT('s'):
			ASSERT(GRPOP_NONE == g_goAction); // Check for duplicate parameter
			g_goAction = GRPOP_SETUP;
			break;

        case TEXT('I'):
        case TEXT('i'):
            //
            // Install NT-specific display driver stuff
            //
            ASSERT(GRPOP_NONE == g_goAction); // Check for duplicate parameter
            g_goAction = GRPOP_NTDDINSTALL;
            break;

        case TEXT('U'):
        case TEXT('u'):
            //
            // Uninstall NT-specific display driver stuff
            //
            ASSERT(GRPOP_NONE == g_goAction); // Check for duplicate parameter
            g_goAction = GRPOP_NTDDUNINSTALL;
            break;

		case TEXT('A'):
		case TEXT('a'):
			ASSERT(GRPOP_NONE == g_goAction); // Check for duplicate parameter
			g_goAction = GRPOP_ADD;
			break;

		case TEXT('D'):
		case TEXT('d'):
			ASSERT(GRPOP_NONE == g_goAction); // Check for duplicate parameter
			g_goAction = GRPOP_DEL;
			break;

		case TEXT('C'):
		case TEXT('c'):
			ASSERT(! g_fCommonGroup); // Check for duplicate parameter
			g_fCommonGroup = TRUE;
			break;

		case TEXT('Q'):
		case TEXT('q'):
			g_fQuietInstall = TRUE;
			break;

		case TEXT('G'):
		case TEXT('g'):
			if (NULL == ppszCurrentArg)
			{
				ppszCurrentArg = &g_pszGroupName;
			}

			// NO break HERE -- fall through

		case TEXT('N'):
		case TEXT('n'):
			if (NULL == ppszCurrentArg)
			{
				ppszCurrentArg = &g_pszProgramName;
			}

			// NO break HERE -- fall through

		case TEXT('P'):
		case TEXT('p'):
			if (NULL == ppszCurrentArg)
			{
				ppszCurrentArg = &g_pszProgramPath;
			}

			// NO break HERE -- fall through

		case TEXT('F'):
		case TEXT('f'):
			if (NULL == ppszCurrentArg)
			{
				ppszCurrentArg = &g_pszFriendlyName;
			}

			// ***** Processing for all string parameters *****

			ASSERT(NULL == *ppszCurrentArg); // Check for duplicate parameter

			// Save the string pointer after skipping past the colon and open quote
			ASSERT(TEXT(':') == pszTemp[1] && TEXT('\"') == pszTemp[2]);
			*ppszCurrentArg = pszTemp += 3;

			// Find the closing quote and set it to null, then skip past it
			// Note that we don't handle strings with quotes in them.
			pszTemp = (PTSTR) _StrChr(pszTemp, TEXT('\"'));
			ASSERT(NULL != pszTemp);
			if (NULL != pszTemp)
			{
				*pszTemp++ = TEXT('\0');
			}
			else
			{
				return FALSE;
			}

			break;

		default:
			ERROR_OUT(("Unknown parameter begins at %s", pszTemp));
			return FALSE;

			break;
		}

		// Find the next option flag
		ASSERT(NULL != pszTemp);
		pszTemp = (PTSTR) _StrChr(pszTemp, TEXT('/'));
	}

	// Return based on minimal parameter validation:
	// 1) The program name must be specified.
	// 2) Either add or delete must be specified.
	// 3) If add is specified, the program path must be specified
    switch (g_goAction)
    {
        case GRPOP_ADD:
        case GRPOP_NTDDINSTALL:
            return((NULL != g_pszProgramName) && (NULL != g_pszProgramPath));

        case GRPOP_DEL:
        case GRPOP_NTDDUNINSTALL:
            return(NULL != g_pszProgramName);

        case GRPOP_SETUP:
            return((NULL != g_pszProgramName) && (NULL != g_pszFriendlyName));

        default:
            return(FALSE);
    }
}

// GetFolderPathname:
//
// Use the official shell interfaces to retrieve the full pathname of a
// a programs folder.
//
// Input: 
//		ptstrPath, ccPath - The pointer to a size of the buffer in
//			which to store the path.
//		nFolder - The folder to locate, expressed as a CSIDL constant.  
//			See SHGetSpecialFolderLocation for details.
//		pctstrSubFolder - A specific subfolder, can be NULL if not specified.
//			If specified, this is appended (after a backslash) to the path.
//
// Returns:
//		An HRESULT to indicate success or failure of the Shell methods.
//		The path is returned in <ptstrPath>.

HRESULT 
GetFolderPathname(
	PTSTR ptstrPath,
	UINT cchPath,
	int nFolder,
	LPCTSTR pctstrSubFolder)
{
	HRESULT hr;
	LPMALLOC pMalloc = NULL;
	LPSHELLFOLDER pDesktopFolder = NULL;
	LPITEMIDLIST pidlSpecialFolder = NULL;

	// Get the allocator object
	hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);

	// Get the desktop object
	if (SUCCEEDED(hr))
	{
		hr = SHGetDesktopFolder(&pDesktopFolder);
	}

	// Get the special folder item ID
	if (SUCCEEDED(hr))
	{
		hr = SHGetSpecialFolderLocation(
				GetDesktopWindow(),
				nFolder,
				&pidlSpecialFolder);
	}

	// Retrieve the folder name
	STRRET strFolder;

	if (SUCCEEDED(hr))
	{
		strFolder.uType = STRRET_WSTR;

		hr = pDesktopFolder->GetDisplayNameOf(
				pidlSpecialFolder,
				SHGDN_FORPARSING,
				&strFolder);
	}

	if (SUCCEEDED(hr))
	{
		CUSTRING custrPath;

		switch(strFolder.uType)
		{
		case STRRET_WSTR:
			custrPath.AssignString(strFolder.pOleStr);

			break;

		case STRRET_OFFSET:
			custrPath.AssignString(((LPSTR) pidlSpecialFolder) + strFolder.uOffset);

			break;

		case STRRET_CSTR:
			custrPath.AssignString(strFolder.cStr);

			break;
		}

		ASSERT(NULL != (PTSTR) custrPath);

		lstrcpyn(ptstrPath, custrPath, cchPath);

		if (STRRET_WSTR == strFolder.uType)
		{
			pMalloc->Free(strFolder.pOleStr);
		}

	}

	// Append subgroup name, if it's specified
	if (SUCCEEDED(hr) && NULL != pctstrSubFolder)
	{
		// BUGBUG - We don't create this folder if it doesn't already exist

		int cchLen = lstrlen(ptstrPath);

		ASSERT((UINT) cchLen < cchPath);

		// Insert a path separator
		ptstrPath[cchLen++] = TEXT('\\');

		// Copy the subgroup
		lstrcpyn(ptstrPath + cchLen, pctstrSubFolder, cchPath - cchLen);
	}

	// Release resources
	if (pDesktopFolder)
	{
		pDesktopFolder->Release();
	}

	if (pMalloc)
	{
		if (pidlSpecialFolder)
		{
			pMalloc->Free(pidlSpecialFolder);
		}

		pMalloc->Release();
	}

	return hr;
}

// BuildLinkFileName:
//
// Inline utility function to construct the full file name of a link given its
// directory name and item name.
inline void
BuildLinkFileName(
	OUT LPWSTR wszOutputPath,
	IN LPCTSTR pcszDirectory,
	IN LPCTSTR pcszFile)
{
	// The file name is of the form <directory>\<file>.LNK

#ifdef UNICODE
	static const WCHAR wszFileFormat[] = L"%s\\%s.LNK";
#else // UNICODE
	static const WCHAR wszFileFormat[] = L"%hs\\%hs.LNK";
#endif // UNICODE
	int cchSize;

	cchSize = wsprintfW(
				wszOutputPath, 
				wszFileFormat,
				pcszDirectory,
				pcszFile);

	ASSERT(cchSize > ARRAY_ELEMENTS(wszFileFormat) - 1 && cchSize < MAX_PATH);
}


// CreateProgramItem:
//
// Use the official shell interfaces to create a shortcut to a program.
//
// Input: A pointer to a PROGRAM_ITEM_INFO structure, defined above.
//
// Returns:
//		An HRESULT to indicate success or failure of the Shell methods.

HRESULT
CreateProgramItem(
	PPROGRAM_ITEM_INFO ppii)
{
	HRESULT hr;
	IShellLink *psl = NULL;
	IPersistFile *ppf = NULL;

	// Get the shell link object
	hr = CoCreateInstance(
			CLSID_ShellLink,
			NULL,
			CLSCTX_INPROC,
			IID_IShellLink,
			(LPVOID *) &psl);

	// Fill in the fields of the program group item
	if (SUCCEEDED(hr))
	{
		hr = psl->SetDescription(ppii->pszProgramName);
	}

	if (SUCCEEDED(hr))
	{
		hr = psl->SetPath(ppii->pszProgramPath);
	}

	// Save the link as a file
	if (SUCCEEDED(hr))
	{
		hr = psl->QueryInterface(IID_IPersistFile, (LPVOID *) &ppf);
	}

	if (SUCCEEDED(hr))
	{
		WCHAR wszFileName[MAX_PATH];

		BuildLinkFileName(
			wszFileName,
			ppii->pszProgramGroup,
			ppii->pszProgramName);

		hr = ppf->Save(wszFileName, TRUE);
	}

	// Release the objects we used
	if (ppf)
	{
		ppf->Release();
	}		

	if (psl)
	{
		psl->Release();
	}

	return hr;
}


// DeleteProgramItem:
//
// Delete a shortcut to a program.
//
// Input: A pointer to a PROGRAM_ITEM_INFO structure, defined above.
//
// Returns:
//		An HRESULT to indicate success or failure of the Shell methods.

HRESULT
DeleteProgramItem(
	PPROGRAM_ITEM_INFO ppii)
{
	HRESULT hr = S_OK;

	WCHAR wszFileName[MAX_PATH];

	BuildLinkFileName(
		wszFileName,
		ppii->pszProgramGroup,
		ppii->pszProgramName);

	if (! DeleteFileW(wszFileName))
	{
		WARNING_OUT(("DeleteFile failed"));
		hr = E_FAIL;
	}

	return hr;
}


//
// NtDDInstall()
// This does NT-specific display driver install stuff, which depends on 
// whether it's NT4 or NT5
//
//
HRESULT NtDDInstall(LPTSTR pszOrigDd, LPTSTR pszNewDd)
{
    HRESULT         hr = E_FAIL;
    OSVERSIONINFO   osvi;
    RegEntry        re(NM_NT_DISPLAY_DRIVER_KEY, HKEY_LOCAL_MACHINE, FALSE);

    //
    // If NT4, set service key to disabled
    // If NT5, copy mnmdd.dll from NM dir to cur (system32) dir
    //
    osvi.dwOSVersionInfoSize = sizeof(osvi);

    if (!GetVersionEx(&osvi))
    {
        ERROR_OUT(("GetVersionEx() failed"));
        goto AllDone;        
    }

    if ((osvi.dwPlatformId == VER_PLATFORM_WIN32s) ||
        (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS))
    {
        WARNING_OUT(("NT setup running on non-NT platform!"));
        goto AllDone;
    }

    if (osvi.dwMajorVersion >= 5)
    {
        //
        // This is NT5.  Always set the service key to enabled (in case
        // the end user managed to munge it) and copy mnmdd.dll to the 
        // current (system) directory.  For example, if somebody had a
        // stand-alone version of a beta, uninstalled it, then installed
        // NM 3.0 proper--or same for 2.11.
        //
        re.SetValue(REGVAL_NM_NT_DISPLAY_DRIVER_ENABLED, NT_DRIVER_START_SYSTEM);

        if (!CopyFile(pszOrigDd, pszNewDd, FALSE))
        {
            WARNING_OUT(("CopyFile from %s to %s failed", pszOrigDd, pszNewDd));
            goto AllDone;
        }
    }
    else
    {
        // This is NT4.  Set the disabled service key
        re.SetValue(REGVAL_NM_NT_DISPLAY_DRIVER_ENABLED, NT_DRIVER_START_DISABLED);
    }

    hr = S_OK;

AllDone:
    return(hr);
}



//
// NtDDUninstall()
// This does NT-specific display driver uninstall stuff, which depends
// on whether it's NT4 or NT5
//
HRESULT NtDDUninstall(LPTSTR pszOrigFile)
{
    HRESULT         hr = E_FAIL;
    OSVERSIONINFO   osvi;

    //
    // If NT4, set service key to disabled
    // If NT5, delete mnmdd.dll from cur (system32) dir
    //
    osvi.dwOSVersionInfoSize = sizeof(osvi);

    if (!GetVersionEx(&osvi))
    {
        ERROR_OUT(("GetVersionEx() failed"));
        goto AllDone;
    }

    if ((osvi.dwPlatformId == VER_PLATFORM_WIN32s) ||
        (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS))
    {
        ERROR_OUT(("NT setup running on non-NT platform!"));
        goto AllDone;
    }

    if (osvi.dwMajorVersion >= 5)
    {
        // This is NT5.  Delete mnmdd.dll from the current (system) directory
        if (!DeleteFile(pszOrigFile))
        {
            WARNING_OUT(("DeleteFile of %s failed", pszOrigFile));
            goto AllDone;
        }
    }
    else
    {
        // This is NT4.  Set the disabled service key
		RegEntry re(NM_NT_DISPLAY_DRIVER_KEY, HKEY_LOCAL_MACHINE, FALSE);

        re.SetValue(REGVAL_NM_NT_DISPLAY_DRIVER_ENABLED,
            NT_DRIVER_START_DISABLED);
    }

    hr = S_OK;

AllDone:
    return(hr);
}

UINT _MessageBox(HINSTANCE hInst, UINT uID, LPCTSTR lpCaption, UINT uType)
{
	TCHAR szText[512];

	if (0 != LoadString(hInst, uID, szText, CCHMAX(szText)))
	{
		return MessageBox(NULL, szText, lpCaption, uType);
	}

	return IDCANCEL;
}

#define CONF_INIT_EVENT     TEXT("CONF:Init")

BOOL FIsNetMeetingRunning()
{
    HANDLE hEvent;

    hEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, SERVICE_STOP_EVENT);
	if (hEvent)
	{
		CloseHandle(hEvent);
		return TRUE;
	}

    hEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, CONF_INIT_EVENT);
	if (hEvent)
	{
		CloseHandle(hEvent);
		return TRUE;
	}

	return FALSE;
}

BOOL FIsNT5()
{
    OSVERSIONINFO   osvi;

    osvi.dwOSVersionInfoSize = sizeof(osvi);

    if (GetVersionEx(&osvi))
	{
		if ((osvi.dwPlatformId != VER_PLATFORM_WIN32s) &&
			(osvi.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS))
		{
			if (osvi.dwMajorVersion >= 5)
			{
				return TRUE;
			}
		}
	}
	else
    {
        ERROR_OUT(("GetVersionEx() failed"));
    }
	return FALSE;
}

#define IE4_KEY				TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Last Update\\IEXPLOREV4")

BOOL FIsIE4Installed()
{
    RegEntry re(IE4_KEY, HKEY_LOCAL_MACHINE, FALSE);
	if (ERROR_SUCCESS != re.GetError())
	{
		return FALSE;
	}

	return TRUE;
}

#define INTEL_KEY1			TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\vphone.exe")
#define INTEL_KEY2			TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\rvp.exe")
#define INTEL_KEY3			TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\vp30.exe")
#define INTEL_NM_VERSION_SZ	TEXT("NetMeeting")
#define INTEL_NM_VERSION_DW	3

#define PANTHER_KEY				TEXT("CLSID\\{690968D0-418C-11D1-8E0B-00A0C95A83DA}\\Version")
#define PANTHER_VERSION_VALUE	TEXT("1.0")

#define	TRANSPORTS_KEY	TEXT("SOFTWARE\\Microsoft\\Conferencing\\Transports")

#define	REGKEY_PSTN		TEXT("PSTN")
#define	REGKEY_TCPIP	TEXT("TCPIP")
#define	REGKEY_IPX		TEXT("IPX")
#define	REGKEY_NETBIOS	TEXT("NETBIOS")
#define	REGKEY_DIRCB	TEXT("DIRCB")


long GetIntelVersion(LPCTSTR pszKey)
{
    RegEntry re(pszKey, HKEY_LOCAL_MACHINE, FALSE);
	if (ERROR_SUCCESS != re.GetError())
	{
		return -1;
	}

	return re.GetNumber(INTEL_NM_VERSION_SZ, 0);
}

BOOL FAnyBadIntelApps()
{
	long lVersion;

	lVersion = GetIntelVersion(INTEL_KEY1);
	if (0 > lVersion)
	{
		lVersion = GetIntelVersion(INTEL_KEY2);
		if (0 > lVersion)
		{
			lVersion = GetIntelVersion(INTEL_KEY3);
		}
	}

	return ((0 <= lVersion) && (3 > lVersion));
}

BOOL FAnyBadPantherApps()
{
    RegEntry re(PANTHER_KEY, HKEY_CLASSES_ROOT, FALSE);
	if (ERROR_SUCCESS != re.GetError())
	{
		return FALSE;
	}

	LPCTSTR pszVersion = re.GetString(TEXT(""));

	return 0 == lstrcmp(pszVersion, PANTHER_VERSION_VALUE);
}

BOOL FAnyUnknownTransports()
{
    RegEntry        TransportsKey(TRANSPORTS_KEY, HKEY_LOCAL_MACHINE, FALSE);
    RegEnumSubKeys  EnumTransports(&TransportsKey);

    while( 0 == EnumTransports.Next() )
	{
		LPCTSTR pszName = EnumTransports.GetName();

		if ((0 != lstrcmpi(pszName, REGKEY_PSTN)) &&
			(0 != lstrcmpi(pszName, REGKEY_TCPIP)) &&
			(0 != lstrcmpi(pszName, REGKEY_IPX)) &&
			(0 != lstrcmpi(pszName, REGKEY_NETBIOS)) &&
			(0 != lstrcmpi(pszName, REGKEY_DIRCB)))
		{
			return TRUE;
		}
    }

	return FALSE;
}

BOOL FAnyIncompatibleApps()
{
	return FAnyUnknownTransports() || FAnyBadIntelApps() || FAnyBadPantherApps();
}

HRESULT Setup(HINSTANCE hInst, LPTSTR pszInfFile, LPTSTR pszFriendlyName, BOOL fQuietInstall)
{
	if (FIsNT5())
	{
		_MessageBox(hInst, IDS_SETUP_WIN2K, pszFriendlyName, MB_OK);
		// if the SHFT-CTRL was pressed continue with the install, else exit
		if ((0 == GetAsyncKeyState(VK_CONTROL)) ||
			(0 == GetAsyncKeyState(VK_SHIFT)))
		{
			return S_FALSE;
		}
	}


	if (!FIsIE4Installed())
	{
		_MessageBox(hInst, IDS_SETUP_IE4, pszFriendlyName, MB_OK);
		return S_FALSE;
	}
	
	while (FIsNetMeetingRunning())
	{
		if (IDCANCEL == _MessageBox(hInst, IDS_SETUP_RUNNING, pszFriendlyName, MB_OKCANCEL))
		{
			return S_FALSE;
		}
	}

	if (!fQuietInstall)
	{
		if (FAnyIncompatibleApps())
		{
			if (IDNO == _MessageBox(hInst, IDS_SETUP_INCOMPATIBLE, pszFriendlyName, MB_YESNO))
			{
				return S_FALSE;
			}
		}
	}

	HRESULT hr = S_FALSE;

	HINSTANCE hLib = LoadLibrary(g_cszSetupDll);
	if (NULL != hLib)
	{
		PFNSETUPENTRY pfnEntry = (PFNSETUPENTRY)GetProcAddress(hLib, g_cszSetupEntry);
		if (pfnEntry)
		{
			TCHAR szArgs[MAX_PATH];
			lstrcpy(szArgs, pszInfFile);
			if (fQuietInstall)
			{
				lstrcat(szArgs, TEXT(",,1,N"));
			}
			else
			{
				lstrcat(szArgs, TEXT(",,,N"));
			}

			int iRet = pfnEntry(NULL, GetModuleHandle(NULL), szArgs, SW_SHOWNORMAL);
			if (0 == iRet)
			{
				if (!fQuietInstall)
				{
					_MessageBox(hInst, IDS_SETUP_SUCCESS, pszFriendlyName, MB_OK);
				}

				hr = S_OK;
			}
		}
		else
		{
			ERROR_OUT(("Could not find setup DLL entry point"));
		}
		FreeLibrary(hLib);
	}
	else
	{
		ERROR_OUT(("Could not load setup DLL"));
	}

	return hr;
}


// main:
//
// The entry point of the program, it pulls everything together using the
// above utility functions.

void __cdecl
main(
    void)
{
	HRESULT hr;
    HINSTANCE hInstance;
	BOOL fErrorReported = FALSE;
	TCHAR szFolderPath[MAX_PATH];

	// Initialization
    hInstance = GetModuleHandle(NULL);
	DBGINIT(&ghZone, rgZones);
    DBG_INIT_MEMORY_TRACKING(hInstance);

	hr = CoInitialize(NULL);

	// Process the command line.
	if (SUCCEEDED(hr))
	{
		hr = ProcessCommandLineArgs() ? S_OK : E_INVALIDARG;
	}
	else if (!fErrorReported)
	{
		ERROR_OUT(("CoInitialize fails"));
		fErrorReported = TRUE;
	}

	// Retreive the path of the Programs folder
	if (SUCCEEDED(hr))
	{
        if ((g_goAction != GRPOP_NTDDINSTALL) &&
			(g_goAction != GRPOP_NTDDUNINSTALL) &&
			(g_goAction != GRPOP_SETUP))
        {
    		hr = GetFolderPathname(
	    		szFolderPath, 
		    	CCHMAX(szFolderPath), 
			    g_fCommonGroup ? CSIDL_COMMON_PROGRAMS : CSIDL_PROGRAMS,
    			g_pszGroupName);
        }
	}
	else if (!fErrorReported)
	{
		ERROR_OUT(("Invalid command line parameters specified."));
		fErrorReported = TRUE;
	}

	// Add or delete the program item, as appropriate
	if (SUCCEEDED(hr))
	{
		PROGRAM_ITEM_INFO pii;

		switch(g_goAction)
		{
        case GRPOP_NTDDINSTALL:
            //
            // Hack:  Use program name for source mnmdd.dll
            //        Use program path for dest mnmdd.dll
            //
            hr = NtDDInstall(g_pszProgramName, g_pszProgramPath);
            break;

        case GRPOP_NTDDUNINSTALL:
            //
            // Hack:  Use program name for source mnmdd.dll
            //
            hr = NtDDUninstall(g_pszProgramName);
            break;

		case GRPOP_ADD:
			pii.pszProgramGroup = szFolderPath;
			pii.pszProgramName = g_pszProgramName;
			pii.pszProgramPath = g_pszProgramPath;

			hr = CreateProgramItem(&pii);

			break;

		case GRPOP_DEL:
			pii.pszProgramGroup = szFolderPath;
			pii.pszProgramName = g_pszProgramName;

			hr = DeleteProgramItem(&pii);

			break;

        case GRPOP_SETUP:
            hr = Setup(hInstance, g_pszProgramName, g_pszFriendlyName, g_fQuietInstall);
            break;

		default:
			ERROR_OUT(("No operation type specified"));
			hr = E_INVALIDARG;

			break;
		}			
	}
	else if (!fErrorReported)
	{
		ERROR_OUT(("GetFolderPathname returns %lu", hr));
		fErrorReported = TRUE;
	}


	// Process cleanup
	CoUninitialize();
	 
	DBG_CHECK_MEMORY_TRACKING(hInstance);	   
	DBGDEINIT(&ghZone);

	ExitProcess(SUCCEEDED(hr) ? 0 : 2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\srvc\cconf.cpp ===
//****************************************************************************
//  File:       CCONF.CPP
//  Content:    
//              
//
//  Copyright (c) Microsoft Corporation 1997
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//****************************************************************************

#include <precomp.h>
#include "srvccall.h"
#include "cstring.hpp"

#define ZERO_DELAY "0"

const int SERVICE_IN_CALL = 1001;
const int SERVICE_NOT_IN_CALL = 1000;

// Global Variables
INmManager2 * g_pMgr  = NULL;             // The Conference Manager
CMgrNotify * g_pMgrNotify = NULL;        // Notifications for the Manager
INmConference * g_pConference = NULL;    // The Current Conference
CConfNotify * g_pConferenceNotify =NULL; // Notifications for the Conference
INmSysInfo2 * g_pNmSysInfo     = NULL;   // Interface to SysInfo
IAppSharing * g_pAS = NULL;             // Interface to AppSharing
int g_cPersonsInConf = 0;
int g_cPersonsInShare = 0;
extern BOOL g_fInShutdown;

// UI integration
HANDLE g_hCallEvent = NULL;                // Event which is created when service is in a call

CHAR szConfName[64];
static BOOL RunScrSaver(void);

/*  I N I T  C O N F  M G R  */
/*-------------------------------------------------------------------------
    %%Function: InitConfMgr

-------------------------------------------------------------------------*/
HRESULT InitConfMgr(void)
{
    HRESULT hr;
    LPCLASSFACTORY pcf;

    RegEntry reLM( REMOTECONTROL_KEY, HKEY_LOCAL_MACHINE);
    PBYTE pbPassword = NULL;
    DWORD cbPassword = 0;
    BSTR bstrPassword = NULL;

    if (!IS_NT)
    {
        cbPassword = reLM.GetBinary(REMOTE_REG_PASSWORD, (void **) &pbPassword);
        // Require a password
        if ( !cbPassword )
        {
            ERROR_OUT(("Attempt to launch service with no password."));
            return E_ACCESSDENIED;
        }
        
        bstrPassword = SysAllocStringByteLen((char *)pbPassword, cbPassword);
        if (NULL == bstrPassword)
        {
            ERROR_OUT(("Out of memory."));
            return E_OUTOFMEMORY;
        }
    }
        

    TRACE_OUT(("InitConfMgr"));

    // Add local atom to indicate alternate-desktop services are needed
    AddAtom("NMSRV_ATOM");

    // Parts of the CLSID_NmManager2 interface are not path-independent
    // and depend on the netmeeting install directory being on the
    // module load path. If this .exe is not in that dir, there may be
    // problems (loadlib, thunk connect, etc.) so set the current dir
    // to the netmeeting install dir.

    TCHAR szInstallDir[MAX_PATH];
    if ( GetInstallDirectory(szInstallDir))
    {
        if ( !SetCurrentDirectory(szInstallDir) )
        {
            ERROR_OUT(("Could not set current directory to %s", szInstallDir));
        }
    }
    else
    {
        ERROR_OUT(("Could not get netmeeting install directory"));
    }

    ASSERT(!g_pMgr);

    // Notify the system we want to use the conferencing services
    // by creating a conference manager object
    hr = CoGetClassObject(CLSID_NmManager2,
                          CLSCTX_INPROC,
                          NULL,
                          IID_IClassFactory,
                          (void**)&pcf);
    if (SUCCEEDED(hr))
    {
        // Get the conference manager object
        hr = pcf->CreateInstance(NULL, IID_INmManager2, (void**)&g_pMgr);
        if (SUCCEEDED(hr))
        {
            // Connect to the conference manager object
            g_pMgrNotify = new CMgrNotify();

            if (NULL != g_pMgrNotify)
            {
                hr = g_pMgrNotify->Connect(g_pMgr);
                if (SUCCEEDED(hr))
                {
                    ULONG uchCaps = CAPFLAG_DATA | CAPFLAG_H323_CC;

                    hr = g_pMgr->Initialize(NULL, &uchCaps);

                    if (FAILED(hr))
                    {
                        ERROR_OUT(("g_pMgr->Initialize failed"));
                    }
                }
                else
                    ERROR_OUT(("g_pMgrNotify->Connect failed"));
            }
            else
                ERROR_OUT(("new CMgrNotify failed"));

            // Get the INmSysInfo2
            INmSysInfo * pSysInfo = NULL;
            if (SUCCEEDED(g_pMgr->GetSysInfo(&pSysInfo)))
            {
                if (FAILED(pSysInfo->QueryInterface(IID_INmSysInfo2, (void **)&g_pNmSysInfo)))
                {
                    ERROR_OUT(("Could not get INmSysInfo3"));
                }

                pSysInfo->Release();
            }
        }
        else
            ERROR_OUT(("CreateInstance(IID_INmManager2) failed"));

        pcf->Release();
    }

    if (!g_pMgr)
    {
        ERROR_OUT(("Failed to init conference manager"));
        return hr;
    }

    // Set up INmSysInfo options
    SvcSetOptions();

    //
    // Init app sharing
    //
    //
    hr = g_pMgr->CreateASObject((IAppSharingNotify *)g_pMgrNotify, AS_SERVICE | AS_UNATTENDED, (IUnknown**)&g_pAS);
    if (FAILED(hr))
    {
        ERROR_OUT(("Failed to start AppSharing"));
        return(hr);
    }

    //
    // Make sure that sharing is enabled
    //

    if ( !g_pAS->IsSharingAvailable() )
    {
        WARNING_OUT(("MNMSRVC: sharing not enabled"));
        return E_FAIL;
    }

    // Create conference
    ASSERT(g_pConference == NULL);

    //
    // Only allow remotes to send files, they can't initiate anything else
    // themselves.

    LoadString(GetModuleHandle(NULL), IDS_MNMSRVC_TITLE,
        szConfName, CCHMAX(szConfName));
	BSTRING bstrConfName(szConfName);

    hr = g_pMgr->CreateConferenceEx(&g_pConference, bstrConfName, bstrPassword,
        NMCH_DATA | NMCH_SHARE | NMCH_SRVC | NMCH_SECURE,
        NM_PERMIT_SENDFILES, 2);

    SysFreeString(bstrPassword);
    if (FAILED(hr))
    {
        ERROR_OUT(("Conference could not be created"));
        return hr;
    }

    hr = g_pConference->Host();

    if (FAILED(hr))
    {
        ERROR_OUT(("Could not host conference"));
        return hr;
    }

    return hr;
}


/*  F R E E  C O N F  M G R  */
/*-------------------------------------------------------------------------
    %%Function: FreeConfMgr
    
-------------------------------------------------------------------------*/
VOID FreeConfMgr(void)
{
    DebugEntry(FreeConfMgr);
    // Release conference manager notify
    if (NULL != g_pMgrNotify)
    {
        g_pMgrNotify->Disconnect();

        UINT ref = g_pMgrNotify->Release();
        TRACE_OUT(("g_pMgrNotify after Release: refcount: %d", ref));
        g_pMgrNotify = NULL;
    }

    // Release conference manager
    if (NULL != g_pMgr)
    {
        UINT ref;
        ref = g_pMgr->Release();
        TRACE_OUT(("g_pMgr after Release: refcount: %d", ref));
        g_pMgr = NULL;
    }
    DebugExitVOID(FreeConfMgr);
}


/*  F R E E  C O N F E R E N C E  */
/*-------------------------------------------------------------------------
    %%Function: FreeConference
    
-------------------------------------------------------------------------*/
VOID FreeConference(void)
{
    DebugEntry(FreeConference);
    if (NULL != g_pConferenceNotify)
    {
        g_pConferenceNotify->Disconnect();
        g_pConferenceNotify->Release();
        g_pConferenceNotify = NULL;
    }

    if (NULL != g_pNmSysInfo )
    {
        UINT ref = g_pNmSysInfo->Release();
        TRACE_OUT(("g_pNmSysInfo refcount %d after release", ref));
        g_pNmSysInfo = NULL;
    }

    if (NULL != g_pConference)
    {
        UINT ref = g_pConference->Release();

        ASSERT(1 == ref); // The confmgr holds last reference

        g_pConference = NULL;
    }
    else
    {
        WARNING_OUT(("FreeConference: no conference???"));
    }

    DebugExitVOID(FreeConference);
}



//////////////////////////////////////////////////////////////////////////
//  C  C N F  M G R  N O T I F Y

CMgrNotify::CMgrNotify() : RefCount(), CNotify()
{
    TRACE_OUT(("CMgrNotify created"));
}

CMgrNotify::~CMgrNotify()
{
    TRACE_OUT(("CMgrNotify destroyed"));
}


///////////////////////////
//  CMgrNotify:IUnknown

ULONG STDMETHODCALLTYPE CMgrNotify::AddRef(void)
{
    return RefCount::AddRef();
}


ULONG STDMETHODCALLTYPE CMgrNotify::Release(void)
{
    return RefCount::Release();
}

HRESULT STDMETHODCALLTYPE CMgrNotify::QueryInterface(REFIID riid, PVOID *ppvObject)
{
    HRESULT hr = S_OK;

    TRACE_OUT(("CMgrNotify QI'd"));

    if (riid == IID_IUnknown || riid == IID_INmManagerNotify)
    {
        *ppvObject = (INmManagerNotify *)this;
    }
    else
    {
        hr = E_NOINTERFACE;
        *ppvObject = NULL;
    }

    if (S_OK == hr)
    {
        AddRef();
    }

    return hr;
}



////////////////////////////
//  CMgrNotify:ICNotify

HRESULT STDMETHODCALLTYPE CMgrNotify::Connect(IUnknown *pUnk)
{
    TRACE_OUT(("CMgrNotify::Connect"));
    return CNotify::Connect(pUnk, IID_INmManagerNotify, (INmManagerNotify *)this);
}

HRESULT STDMETHODCALLTYPE CMgrNotify::Disconnect(void)
{
    TRACE_OUT(("CMgrNotify::Disconnect"));
    return CNotify::Disconnect();
}



//////////////////////////////////
//  CMgrNotify:INmManagerNotify

HRESULT STDMETHODCALLTYPE CMgrNotify::NmUI(CONFN confn)
{
    TRACE_OUT(("CMgrNotify::NmUI"));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::CallCreated(INmCall *pNmCall)
{
    
    new CSrvcCall(pNmCall);

    TRACE_OUT(("CMgrNotify::CallCreated"));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::ConferenceCreated(INmConference *pConference)
{
    g_cPersonsInConf = 0;
    g_cPersonsInShare = 0;

    if (NULL == g_pConference)
    {
        TRACE_OUT(("CMgrNotify::ConferenceCreated"));
        HookConference(pConference);
    }
    else
    {
        ERROR_OUT(("Second conference created???"));
    }
    return S_OK;
}

// CMgrNotify::IAppSharingNotify
HRESULT STDMETHODCALLTYPE CMgrNotify::OnReadyToShare(BOOL fReady)
{
    TRACE_OUT(("CMgrNotify::OnReadyToShare"));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnShareStarted()
{
    TRACE_OUT(("CMgrNotify::OnShareStarted"));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnSharingStarted()
{
    TRACE_OUT(("CMgrNotify::OnSharingStarted"));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnShareEnded()
{
    TRACE_OUT(("CMgrNotify::OnShareEnded"));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnPersonJoined(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnPersonJoined"));

    ASSERT(g_pAS);
    ASSERT(g_cPersonsInShare >= 0);
    g_cPersonsInShare++;

    //
    // Once we are no longer alone in the share, invite the remote party to
    // take control of us.
    //
    if ( 2 == g_cPersonsInShare && g_pAS)
    {
        HRESULT hr;
        TRACE_OUT(("OnPersonJoined: giving control to 2nd dude %d",
            gccID));

        //
        // Give control to the remote party
        //
        hr = g_pAS->GiveControl(gccID);
        if ( S_OK != hr )
        {
            ERROR_OUT(("OnPersonJoined: GiveControl to %d failed: %x",
                gccID, hr));
        }
    }

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnPersonLeft(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnPersonLeft"));

    ASSERT(g_pAS);

    g_cPersonsInShare--;
    ASSERT(g_cPersonsInShare >= 0);

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnStartInControl(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnStartInControl"));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnStopInControl(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnStopInControl"));
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CMgrNotify::OnPausedInControl(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnPausedInControl"));
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CMgrNotify::OnUnpausedInControl(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnUnpausedInControl"));
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CMgrNotify::OnControllable(BOOL fControllable)
{
    TRACE_OUT(("CMgrNotify::OnControllable"));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnStartControlled(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnStartControlled"));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnStopControlled(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnStopControlled"));
    ::RunScrSaver();
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMgrNotify::OnPausedControlled(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnPausedControlled"));
    return(S_OK);
}


HRESULT STDMETHODCALLTYPE CMgrNotify::OnUnpausedControlled(IAS_GCC_ID gccID)
{
    TRACE_OUT(("CMgrNotify::OnUnpausedControlled"));
    return(S_OK);
}

/*  H O O K  C O N F E R E N C E  */
/*-------------------------------------------------------------------------
    %%Function: HookConference
    
-------------------------------------------------------------------------*/
HRESULT HookConference(INmConference * pConference)
{
    HRESULT hr;

    DebugEntry(HookConference);

    TRACE_OUT(("HookConference"));
    ASSERT(NULL != pConference);
    ASSERT(NULL == g_pConference);

    TRACE_OUT(("Set g_pConference in HookConference"));
    g_pConference = pConference;

    pConference->AddRef();

    // Connect to the conference object
    ASSERT(NULL == g_pConferenceNotify);
    g_pConferenceNotify = new CConfNotify();
    if (NULL == g_pConferenceNotify)
    {
        ERROR_OUT(("failed to new CConfNotify"));
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = g_pConferenceNotify->Connect(pConference);
        if (FAILED(hr))
        {
            ERROR_OUT(("Failed to connect to g_pConferenceNotify"));
            g_pConferenceNotify->Release();
            g_pConferenceNotify = NULL;
        }
    }

    DebugExitHRESULT(HookConference,hr);

    return hr;
}


//////////////////////////////////////////////////////////////////////////
//  C  C N F  N O T I F Y

CConfNotify::CConfNotify() : RefCount(), CNotify()
{
    TRACE_OUT(("CConfNotify created"));
}

CConfNotify::~CConfNotify()
{
    TRACE_OUT(("CConfNotify destroyed"));
}


///////////////////////////
//  CConfNotify:IUknown

ULONG STDMETHODCALLTYPE CConfNotify::AddRef(void)
{
    TRACE_OUT(("CConfNotify::AddRef"));
    return RefCount::AddRef();
}


ULONG STDMETHODCALLTYPE CConfNotify::Release(void)
{
    TRACE_OUT(("CConfNotify::Release"));
    return RefCount::Release();
}

HRESULT STDMETHODCALLTYPE CConfNotify::QueryInterface(REFIID riid, PVOID *ppvObject)
{
    HRESULT hr = S_OK;

    TRACE_OUT(("CConfNotify::QueryInterface"));

    if (riid == IID_IUnknown)
    {
        TRACE_OUT(("CConfNotify::QueryInterface IID_IUnknown"));
        *ppvObject = (IUnknown *)this;
    }
    else if (riid == IID_INmConferenceNotify)
    {
        TRACE_OUT(("CConfNotify::QueryInterface IID_INmConferenceNotify"));
        *ppvObject = (INmConferenceNotify *)this;
    }
    else
    {
        WARNING_OUT(("CConfNotify::QueryInterface bogus"));
        hr = E_NOINTERFACE;
        *ppvObject = NULL;
    }

    if (S_OK == hr)
    {
        AddRef();
    }

    return hr;
}



////////////////////////////
//  CConfNotify:ICNotify

HRESULT STDMETHODCALLTYPE CConfNotify::Connect(IUnknown *pUnk)
{
    TRACE_OUT(("CConfNotify::Connect"));
    return CNotify::Connect(pUnk,IID_INmConferenceNotify,(IUnknown *)this);
}

HRESULT STDMETHODCALLTYPE CConfNotify::Disconnect(void)
{
    TRACE_OUT(("CConfNotify::Disconnect"));

    //
    // Release for Addref in HookConference before CConfNotify::Connect
    //

    if ( g_pConference )
        g_pConference->Release();

    return CNotify::Disconnect();
}


//////////////////////////////////
//  CConfNotify:IConfNotify

HRESULT STDMETHODCALLTYPE CConfNotify::NmUI(CONFN uNotify)
{
    TRACE_OUT(("CConfNotify::NmUI"));
    TRACE_OUT(("NmUI called."));
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CConfNotify::StateChanged(NM_CONFERENCE_STATE uState)
{
    TRACE_OUT(("CConfNotify::StateChanged"));

    if (NULL == g_pConference)
        return S_OK; // weird

    switch (uState)
    {
    case NM_CONFERENCE_ACTIVE:
        if (IS_NT) {
            ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_PAUSE_CONTINUE | SERVICE_ACCEPT_SHUTDOWN;
            SetServiceStatus(sshStatusHandle,&ssStatus);
        }
        else {        // Windows 95
            g_hCallEvent = CreateEvent(NULL,FALSE,FALSE,SERVICE_CALL_EVENT);
        }
        break;

    case NM_CONFERENCE_INITIALIZING:
        break; // can't do anything just yet

    case NM_CONFERENCE_WAITING:
        if (IS_NT) {
            ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_PAUSE_CONTINUE;
            SetServiceStatus(sshStatusHandle,&ssStatus);
        }
        else {        // Windows 95
            CloseHandle(g_hCallEvent);
        }
        break;

    case NM_CONFERENCE_IDLE:
        break;
    }

    return S_OK;
}


HRESULT STDMETHODCALLTYPE CConfNotify::MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember)
{
    switch (uNotify)
    {
    case NM_MEMBER_ADDED:
    {
        TRACE_OUT(("CConfNotify::MemberChanged() Member added"));

        ASSERT( g_cPersonsInConf >= 0 );

        g_cPersonsInConf++;

        //
        // Once we are no longer alone in the conference, share the desktop
        // and allow control:
        //

        if ( 2 == g_cPersonsInConf && g_pAS )
        {
            HRESULT hr;
            TRACE_OUT(("%d parties in conf, Sharing the desktop",
                g_cPersonsInConf));

            //
            // Share out the desktop
            //
            hr = g_pAS->Share ( GetDesktopWindow(), IAS_SHARE_DEFAULT );
            if ( S_OK != hr )
            {
                ERROR_OUT(("OnPersonJoined: sharing desktop failed: %x",hr));
            }

            //
            // Allow control
            //
            hr = g_pAS->AllowControl ( TRUE );
            if ( S_OK != hr )
            {
                ERROR_OUT(("OnPersonJoined: allowing control failed: %x",hr));
            }
        }
        break;
    }
    case NM_MEMBER_REMOVED:
    {
        TRACE_OUT(("CConfNotify::MemberChanged() Member removed"));
        g_cPersonsInConf--;
        ASSERT( g_cPersonsInConf >= 0 );

        if ( 1 == g_cPersonsInConf && g_pAS )
        {
            HRESULT hr;
            TRACE_OUT(("%d parties in conf, Unsharing the desktop",
                g_cPersonsInConf));

            //
            // Disallow control
            //
            hr = g_pAS->AllowControl ( FALSE );
            if ( S_OK != hr )
            {
                ERROR_OUT(("Disallowing control failed: %x",hr));
            }

            //
            // Unshare the desktop
            //
            hr = g_pAS->Unshare ( GetDesktopWindow() );
            if ( S_OK != hr )
            {
                ERROR_OUT(("Unsharing desktop failed: %x",hr));
            }
        }
        break;
    }
    case NM_MEMBER_UPDATED:
    {
        TRACE_OUT(("CConfNotify::MemberChanged() Member updated"));
        break;
    }
    default:
        break;
    }
    
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CConfNotify::ChannelChanged(NM_CHANNEL_NOTIFY uNotify, INmChannel *pChannel)
{
    return S_OK;
}


VOID SvcSetOptions(VOID)
{
    DebugEntry(SvcSetOptions);

    //
    // We must set the bandwidth & computer name properties.
    //
    if (NULL != g_pNmSysInfo)
    {
        RegEntry reAudio(AUDIO_KEY, HKEY_LOCAL_MACHINE);
        UINT uBandwidth = reAudio.GetNumber(REGVAL_TYPICALBANDWIDTH,
                                                BW_DEFAULT);

        g_pNmSysInfo->SetOption(NM_SYSOPT_BANDWIDTH, uBandwidth);

        TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH+1];
        DWORD dwComputerNameLength = sizeof(szComputerName);
        if ( !GetComputerName( szComputerName, &dwComputerNameLength))
        {
            lstrcpy(szComputerName,TEXT("?"));
            ERROR_OUT(("GetComputerName failed"));
        }

        g_pNmSysInfo->SetProperty(NM_SYSPROP_USER_NAME,BSTRING(szComputerName));
    }
    
    DebugExitVOID(SvcSetOptions);
}

BOOL ServiceCtrlHandler(DWORD dwCtrlType)
{
    HRESULT hr = S_OK;

    TRACE_OUT(("ServiceCtrlHandler received %d",dwCtrlType));
    switch (dwCtrlType)
    {
    case CTRL_SHUTDOWN_EVENT:
        if (g_pConference != NULL)
        {
            TRACE_OUT(("Leaving conference in CTRL_SHUTDOWN_EVENT"));
            hr = g_pConference->Leave();

            if (FAILED(hr))
            {
                WARNING_OUT(("Service Ctrl Handler failed to leave"));
            }
        }
        else
        {
            WARNING_OUT(("g_pConference NULL in CTRL_SHUTDOWN_EVENT"));
        }

        break;
    default:
        break;
    }
    return FALSE;
}

static BOOL RunScrSaver(void)
{
    BOOL fIsScrSaverActive = FALSE;
    if (g_fInShutdown)
    {
        return FALSE;
    }
    if (!SystemParametersInfo(SPI_GETSCREENSAVEACTIVE, 0, &fIsScrSaverActive, 0))
    {
        ERROR_OUT(("RunScrSaver: SystemParametersInfo failed"));
        return FALSE;
    }
    if (fIsScrSaverActive)
    {
        RegEntry reWinlogon(IS_NT ? WINNT_WINLOGON_KEY : WIN95_WINLOGON_KEY, HKEY_LOCAL_MACHINE);
        CSTRING strGracePeriod = reWinlogon.GetString(REGVAL_SCREENSAVER_GRACEPERIOD);
        reWinlogon.SetValue(REGVAL_SCREENSAVER_GRACEPERIOD, ZERO_DELAY);
        reWinlogon.FlushKey();
        DefWindowProc(GetDesktopWindow(), WM_SYSCOMMAND, SC_SCREENSAVE, 0);
        if (lstrlen(strGracePeriod))
        {
            int cSeconds = RtStrToInt(strGracePeriod);
            if (cSeconds > 0 && cSeconds <= 20)
            {
                Sleep(1000*cSeconds);
                reWinlogon.SetValue(REGVAL_SCREENSAVER_GRACEPERIOD, strGracePeriod);
                reWinlogon.FlushKey();
                return TRUE;
            }
        }

        Sleep(5000);
        reWinlogon.DeleteValue(REGVAL_SCREENSAVER_GRACEPERIOD);        
        reWinlogon.FlushKey();
        return TRUE;
    }
    else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\srvc\dbg.cpp ===
#include "precomp.h"
#pragma hdrstop

#ifdef DEBUG /*** THIS WHOLE FILE ***/

unsigned long g_BreakAlloc = (unsigned long)-1;

/*  U P D A T E  C R T  D B G  S E T T I N G S  */
/*-------------------------------------------------------------------------
    %%Function: UpdateCrtDbgSettings

    Update the C runtime debug memory settings
-------------------------------------------------------------------------*/
VOID UpdateCrtDbgSettings(void)
{
#if 0
	// This depends on the use of the debug c runtime library
	int tmpFlag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);

	// Always enable memory leak checking debug spew
	// tmpFlag |= _CRTDBG_LEAK_CHECK_DF;

	// Release memory just like the retail version
	tmpFlag &= ~_CRTDBG_DELAY_FREE_MEM_DF;

	// Don't bother checking the entire heap
	tmpFlag &= ~_CRTDBG_CHECK_ALWAYS_DF;
	
	_CrtSetDbgFlag(tmpFlag);
#endif // 0
}

#if 0
int _cdecl MyAllocHook ( int allocType, void *userData,
			size_t size, int blockType,
			long requestNumber, const char *filename, int lineNumber )
{
	char buf[256];
	wsprintf(buf, "%s {%d}: %d bytes on line %d file %s\n\r",
					allocType == _HOOK_ALLOC ? "ALLOC" :
					( allocType == _HOOK_REALLOC ? "REALLOC" : "FREE" ),
					requestNumber,
					size, lineNumber, filename );
	OutputDebugString(buf);
	return TRUE;
}
#endif // 0 

/*  I N I T  D E B U G  M E M O R Y  O P T I O N S  */
/*-------------------------------------------------------------------------
    %%Function: InitDebugMemoryOptions

    Initilize the runtime memory
-------------------------------------------------------------------------*/
BOOL InitDebugMemoryOptions(void)
{
#if 0
	// _asm int 3; chance to set _crtBreakAlloc - use debugger or uncomment
	_CrtSetBreakAlloc(g_BreakAlloc);

	UpdateCrtDbgSettings();

	_CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_WNDW); // create a message box on errors

	{	//  To track down memory leaks, set cAlloc to the allocation number
		LONG cAlloc = 0; // Allocation number
		if (0 != cAlloc)
			_CrtSetBreakAlloc(cAlloc);
	}

	#ifdef MNMSRVC_SETALLOCHOOK
	_CrtSetAllocHook ( MyAllocHook );
	#endif // MNMSRVC_SETALLOCHOOK
#endif // 0
	return TRUE;
}

VOID DumpMemoryLeaksAndBreak(void)
{
#if 0
	if ( _CrtDumpMemoryLeaks() )
	{
		// _asm int 3; Uncomment to break after leak spew
	}
#endif // 0
}

#endif /* DEBUG - whole file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\srvc\cconf.h ===
//****************************************************************************
//  Module:     NMCHAT.EXE
//  File:       CCONF.H
//  Content:    
//              
//
//  Copyright (c) Microsoft Corporation 1997
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//****************************************************************************

class CMgrNotify : public RefCount, public CNotify, public INmManagerNotify, public IAppSharingNotify
{
public:
	CMgrNotify();
	~CMgrNotify();

        // IUnknown methods
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppvObj);

 	// ICNotify methods
	STDMETHODIMP Connect (IUnknown *pUnk);
	STDMETHODIMP Disconnect(void);

	// INmManagerNotify
	STDMETHODIMP NmUI(CONFN confn);
	STDMETHODIMP ConferenceCreated(INmConference *pConference);
	STDMETHODIMP CallCreated(INmCall *pNmCall);

        // IAppSharingNotify
        STDMETHODIMP OnReadyToShare(BOOL fReady);
        STDMETHODIMP OnShareStarted();
        STDMETHODIMP OnSharingStarted();
        STDMETHODIMP OnShareEnded();
        STDMETHODIMP OnPersonJoined(IAS_GCC_ID gccID);
        STDMETHODIMP OnPersonLeft(IAS_GCC_ID gccID);
        STDMETHODIMP OnStartInControl(IAS_GCC_ID gccInControlOf);
        STDMETHODIMP OnStopInControl(IAS_GCC_ID gccInControlOf);
        STDMETHODIMP OnPausedInControl(IAS_GCC_ID gccInControlOf);
        STDMETHODIMP OnUnpausedInControl(IAS_GCC_ID gccInControlOf);
        STDMETHODIMP OnControllable(BOOL fControllable);
        STDMETHODIMP OnStartControlled(IAS_GCC_ID gccControlledBy);
        STDMETHODIMP OnStopControlled(IAS_GCC_ID gccControlledBy);
        STDMETHODIMP OnPausedControlled(IAS_GCC_ID gccControlledBy);
        STDMETHODIMP OnUnpausedControlled(IAS_GCC_ID gccControlledBy);
};


class CConfNotify : public RefCount, public CNotify, public INmConferenceNotify
{
public:
	CConfNotify();
	~CConfNotify();

	// INmConferenceNotify
	HRESULT STDMETHODCALLTYPE NmUI(CONFN uNotify);
	HRESULT STDMETHODCALLTYPE StateChanged(NM_CONFERENCE_STATE uState);
	HRESULT STDMETHODCALLTYPE MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pfMember);
	HRESULT STDMETHODCALLTYPE ChannelChanged(NM_CHANNEL_NOTIFY uNotify, INmChannel *pChannel);

	// ICNotify methods
	HRESULT STDMETHODCALLTYPE Connect (IUnknown *pUnk);
	HRESULT STDMETHODCALLTYPE Disconnect(void);

	// IUnknown methods
	ULONG STDMETHODCALLTYPE AddRef(void);
	ULONG STDMETHODCALLTYPE Release(void);
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *ppvObj);
};


const WM_CREATEDATA = 0x07181975;

// Global Variables
extern INmManager2 * g_pMgr;
extern INmConference * g_pConference;
extern IAppSharing * g_pAS;


// Global Functions
HRESULT InitConfMgr(void);
VOID FreeConfMgr(void);
VOID FreeConference(void);
HRESULT HookConference(INmConference * pConference);
VOID SvcSetOptions(VOID);
BOOL ServiceCtrlHandler(DWORD dwCtrlType);

#define IS_NT (g_osvi.dwPlatformId == VER_PLATFORM_WIN32_NT)
extern OSVERSIONINFO g_osvi;  					// The os version info structure global
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\srvc\clutil.cpp ===
//****************************************************************************
//  Module:     NMCHAT.EXE
//  File:       CLUTIL.CPP
//  Content:    
//              
//
//  Copyright (c) Microsoft Corporation 1997
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//****************************************************************************

#include "precomp.h"


///////////////////////////////////////////////////////////////////////////
// RefCount

/*  R E F  C O U N T  */
/*-------------------------------------------------------------------------
    %%Function: RefCount
    
-------------------------------------------------------------------------*/
RefCount::RefCount(void)
{
	m_cRef = 1;
}


RefCount::~RefCount(void)
{
}


ULONG STDMETHODCALLTYPE RefCount::AddRef(void)
{
   ASSERT(m_cRef >= 0);

   InterlockedIncrement(&m_cRef);

   return (ULONG) m_cRef;
}


ULONG STDMETHODCALLTYPE RefCount::Release(void)
{
	if (0 == InterlockedDecrement(&m_cRef))
	{
		delete this;
		return 0;
	}

	ASSERT(m_cRef > 0);
	return (ULONG) m_cRef;
}



///////////////////////////////////////////////////////////////////////////
// CNotify

/*  C  N O T I F Y  */
/*-------------------------------------------------------------------------
    %%Function: CNotify
    
-------------------------------------------------------------------------*/
CNotify::CNotify() :
	m_pcnpcnt(NULL),
    m_pcnp(NULL),
    m_dwCookie(0),
    m_pUnk(NULL)
{
}

CNotify::~CNotify()
{
	Disconnect(); // Make sure we're disconnected
}


/*  C O N N E C T  */
/*-------------------------------------------------------------------------
    %%Function: Connect

-------------------------------------------------------------------------*/
HRESULT CNotify::Connect(IUnknown *pUnk, REFIID riid, IUnknown *pUnkN)
{
	HRESULT hr;

	ASSERT(0 == m_dwCookie);

	// Get the connection container
	hr = pUnk->QueryInterface(IID_IConnectionPointContainer, (void **)&m_pcnpcnt);
	if (SUCCEEDED(hr))
	{
		// Find an appropriate connection point
		hr = m_pcnpcnt->FindConnectionPoint(riid, &m_pcnp);
		if (SUCCEEDED(hr))
		{
			ASSERT(NULL != m_pcnp);
			// Connect the sink object
			hr = m_pcnp->Advise((IUnknown *)pUnkN, &m_dwCookie);
		}
	}

	if (FAILED(hr))
	{
		ERROR_OUT(("MNMSRVC: CNotify::Connect failed: %x", hr));
		m_dwCookie = 0;
	}
	else
	{
    	m_pUnk = pUnk; // keep around for caller
    }

	return hr;
}



/*  D I S C O N N E C T  */
/*-------------------------------------------------------------------------
    %%Function: Disconnect
    
-------------------------------------------------------------------------*/
HRESULT CNotify::Disconnect (void)
{
    if (0 != m_dwCookie)
    {
        // Disconnect the sink object
        m_pcnp->Unadvise(m_dwCookie);
        m_dwCookie = 0;

        m_pcnp->Release();
        m_pcnp = NULL;

        m_pcnpcnt->Release();
        m_pcnpcnt = NULL;

        m_pUnk = NULL;
    }

    return S_OK;
}



///////////////////////////////////////////////////////////////////////////
// COBLIST


COBLIST::~COBLIST()
{
    ASSERT(IsEmpty());
}


#ifdef DEBUG
VOID* COBLIST::GetHead()
{
	ASSERT(m_pHead);

	return m_pHead->pItem;
}
   
VOID* COBLIST::GetTail()
{
	ASSERT(m_pTail);

	return m_pTail->pItem;
}
#endif /* DEBUG */

VOID* COBLIST::GetNext(POSITION& rPos)
{
	ASSERT(rPos);
	
	VOID* pReturn = rPos->pItem;
	rPos = rPos->pNext;

	return pReturn;
}

VOID* COBLIST::RemoveAt(POSITION Pos)
{
	VOID* pReturn = NULL;

	if (m_pHead)
	{
		if (m_pHead == Pos)
		{
			// Removing the first element in the list
			
			m_pHead = Pos->pNext;
			pReturn = Pos->pItem;
			delete Pos;
			m_cItem--;
			ASSERT(0 <= m_cItem);

			if (NULL == m_pHead)
			{
				// Removing the only element!
				m_pTail = NULL;
			}
		}
		else
		{
			POSITION pCur = m_pHead;

			while (pCur && pCur->pNext)
			{
				if (pCur->pNext == Pos)
				{
					// Removing 
					
					pCur->pNext = Pos->pNext;
					if (m_pTail == Pos)
					{
						m_pTail = pCur;
					}
					pReturn = Pos->pItem;
					delete Pos;

					m_cItem--;
					ASSERT(0 <= m_cItem);
				}

				pCur = pCur->pNext;
			}
		}
	}

	return pReturn;
}

POSITION COBLIST::AddTail(VOID* pItem)
{
	POSITION posRet = NULL;

	if (m_pTail)
	{
		if (m_pTail->pNext = new COBNODE)
		{
			m_pTail = m_pTail->pNext;
			m_pTail->pItem = pItem;
			m_pTail->pNext = NULL;
			m_cItem++;
		}
	}
	else
	{
		ASSERT(!m_pHead);
		if (m_pHead = new COBNODE)
		{
			m_pTail = m_pHead;
			m_pTail->pItem = pItem;
			m_pTail->pNext = NULL;
			m_cItem++;
		}
	}

	return m_pTail;
}

void COBLIST::EmptyList()
{
    while (!IsEmpty()) {
        RemoveAt(GetHeadPosition());
    }
}


#ifdef DEBUG
VOID* COBLIST::RemoveTail()
{
	ASSERT(m_pHead);
	ASSERT(m_pTail);
	
	return RemoveAt(m_pTail);
}

VOID* COBLIST::RemoveHead()
{
	ASSERT(m_pHead);
	ASSERT(m_pTail);
	
	return RemoveAt(m_pHead);
}

void * COBLIST::GetFromPosition(POSITION Pos)
{
    void * Result = SafeGetFromPosition(Pos);
	ASSERT(Result);
	return Result;
}
#endif /* DEBUG */

POSITION COBLIST::GetPosition(void* _pItem)
{
    POSITION    Position = m_pHead;

    while (Position) {
        if (Position->pItem == _pItem) {
            break;
        }
		GetNext(Position);
    }
    return Position;
}

POSITION COBLIST::Lookup(void* pComparator)
{
    POSITION    Position = m_pHead;

    while (Position) {
        if (Compare(Position->pItem, pComparator)) {
            break;
        }
		GetNext(Position);
    }
    return Position;
}

void * COBLIST::SafeGetFromPosition(POSITION Pos)
{
	// Safe way to validate that an entry is still in the list,
	// which ensures bugs that would reference deleted memory,
	// reference a NULL pointer instead
	// (e.g. an event handler fires late/twice).
	// Note that versioning on entries would provide an additional 
	// safeguard against re-use of a position.
	// Walk	list to find entry.

	POSITION PosWork = m_pHead;
	
	while (PosWork) {
		if (PosWork == Pos) {
			return Pos->pItem;
		}
		GetNext(PosWork);
	}
	return NULL;
}

/////////////////////////////
// COBLIST Utility routines

/*  A D D  N O D E  */
/*-------------------------------------------------------------------------
    %%Function: AddNode

    Add a node to a list.
    Initializes the ObList, if necessary.
    Returns the position in the list or NULL if there was a problem.
-------------------------------------------------------------------------*/
POSITION AddNode(PVOID pv, COBLIST ** ppList)
{
	ASSERT(NULL != ppList);
	if (NULL == *ppList)
	{
		*ppList = new COBLIST();
		if (NULL == *ppList)
			return NULL;
	}

	return (*ppList)->AddTail(pv);
}


/*  R E M O V E  N O D E  */
/*-------------------------------------------------------------------------
    %%Function: RemoveNode

    Remove a node from a list.
    Sets pPos to NULL
-------------------------------------------------------------------------*/
PVOID RemoveNode(POSITION * pPos, COBLIST *pList)
{
	if ((NULL == pList) || (NULL == pPos))
		return NULL;

	PVOID pv = pList->RemoveAt(*pPos);
	*pPos = NULL;
	return pv;
}


////////////////////////////////////////////////////////////////////////////
// BSTRING

// We don't support construction from an ANSI string in the Unicode build.
#if !defined(UNICODE)

BSTRING::BSTRING(LPCSTR lpcString)
{
	m_bstr = NULL;

	// Compute the length of the required BSTR, including the null
	int cWC =  MultiByteToWideChar(CP_ACP, 0, lpcString, -1, NULL, 0);
	if (cWC <= 0)
		return;

	// Allocate the BSTR, including the null
	m_bstr = SysAllocStringLen(NULL, cWC - 1); // SysAllocStringLen adds another 1

	ASSERT(NULL != m_bstr);
	if (NULL == m_bstr)
	{
		return;
	}

	// Copy the string
	MultiByteToWideChar(CP_ACP, 0, lpcString, -1, (LPWSTR) m_bstr, cWC);

	// Verify that the string is null terminated
	ASSERT(0 == m_bstr[cWC - 1]);
}

#endif // !defined(UNICODE)


///////////////////////////
// BTSTR

BTSTR::BTSTR(BSTR bstr)
{
	m_psz = PszFromBstr(bstr);
}

BTSTR::~BTSTR()
{
	if (NULL != m_psz)
		LocalFree(m_psz);
}

LPTSTR PszFromBstr(BSTR bstr)
{
	if (NULL == bstr)
		return NULL;
	int cch =  WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, NULL, 0, NULL, NULL);
	if (cch <= 0)
		return NULL;

	LPTSTR psz = (LPTSTR)LocalAlloc(LMEM_FIXED, sizeof(TCHAR) * (cch+1) );
	if (NULL == psz)
		return NULL;

	WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, psz, cch+1, NULL, NULL);
	return psz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\srvc\nmmgr.cpp ===
// 
// Copyright (C) 1993-1997  Microsoft Corporation.  All Rights Reserved. 
// 
//  MODULE:  nmmgr.cpp 
// 
//  PURPOSE:  Implements the body of the service. 
// 
//  FUNCTIONS: 
//            MNMServiceStart(DWORD dwArgc, LPTSTR *lpszArgv); 
//            MNMServiceStop( ); 
// 
//  COMMENTS: The functions implemented in nmmgr.c are 
//            prototyped in nmmgr.h 
//              
// 
//  AUTHOR: Claus Giloi
// 
 
#include <precomp.h>
#include <tsecctrl.h>

#define NMSRVC_TEXT "NMSrvc"

// DEBUG only -- Define debug zone
#ifdef DEBUG
HDBGZONE ghZone = NULL;
static PTCHAR rgZones[] = {
    NMSRVC_TEXT,
    "Warning",
    "Trace",
    "Function"
};
#endif // DEBUG

extern INmSysInfo2 * g_pNmSysInfo;   // Interface to SysInfo
extern BOOL InitT120Credentials(VOID);

// this event is signaled when the 
// service should end 

const int STOP_EVENT = 0;
HANDLE  hServerStopEvent = NULL; 

// this event is signaled when the 
// service should be paused or continued

const int PAUSE_EVENT = 1;
HANDLE  hServerPauseEvent = NULL; 

const int CONTINUE_EVENT = 2;
HANDLE hServerContinueEvent = NULL;

const int numEventHandles = 3;

HANDLE hServerActiveEvent = NULL;

DWORD g_dwActiveState = STATE_INACTIVE;


// 
//  FUNCTION: CreateWatcherProcess 
// 
//  PURPOSE: This launches a rundll32.exe which loads msconf.dll which will then wait for 
//           us to terminate and make sure that the mnmdd display driver was properly deactivated.
// 
//  PARAMETERS: 
// 
//  RETURN VALUE: 
// 
//  COMMENTS: 
// 
BOOL CreateWatcherProcess()
{
    BOOL bRet = FALSE;
    HANDLE hProcess;

    // open a handle to ourselves that the watcher process can inherit
    hProcess = OpenProcess(SYNCHRONIZE,
                           TRUE,
                           GetCurrentProcessId());
    if (hProcess)
    {
        TCHAR szWindir[MAX_PATH];

        if (GetSystemDirectory(szWindir, sizeof(szWindir)/sizeof(szWindir[0])))
        {
            TCHAR szCmdLine[MAX_PATH * 2];
            PROCESS_INFORMATION pi = {0};
            STARTUPINFO si = {0};

            si.cb = sizeof(si);
            
            wsprintf(szCmdLine, "\"%s\\rundll32.exe\" msconf.dll,CleanupNetMeetingDispDriver %ld", szWindir, hProcess);

            if (CreateProcess(NULL,
                              szCmdLine,
                              NULL,
                              NULL,
                              TRUE, // we want the watcher to inherit hProcess, so we must set bInheritHandles = TRUE
                              0,
                              NULL,
                              NULL,
                              &si,
                              &pi))
            {
                bRet = TRUE;

                CloseHandle(pi.hThread);
                CloseHandle(pi.hProcess);
            }
        }

        CloseHandle(hProcess);
    }

    return bRet;
}


// 
//  FUNCTION: MNMServiceStart 
// 
//  PURPOSE: Actual code of the service 
//          that does the work. 
// 
//  PARAMETERS: 
//    dwArgc  - number of command line arguments 
//    lpszArgv - array of command line arguments 
// 
//  RETURN VALUE: 
//    none 
// 
//  COMMENTS: 
// 
VOID MNMServiceStart (DWORD dwArgc, LPTSTR *lpszArgv) 
{ 
    HRESULT hRet;
    BOOL fWaitForEvent = TRUE;
    DWORD dwResult;
    MSG msg;
    LPCTSTR lpServiceStopEvent = TEXT("ServiceStopEvent");
    LPCTSTR lpServiceBusyEvent = TEXT("ServiceBusyEvent");
    const int MaxWaitTime = 5;
    HANDLE hConfEvent; 
    DWORD dwError = NO_ERROR;
    HANDLE hShuttingDown;
    int i;
    RegEntry Re( REMOTECONTROL_KEY, HKEY_LOCAL_MACHINE );

    // Initialization
    DBGINIT(&ghZone, rgZones);
    InitDebugModule(NMSRVC_TEXT);

    DebugEntry(MNMServiceStart);

    if (!Re.GetNumber(REMOTE_REG_RUNSERVICE, DEFAULT_REMOTE_RUNSERVICE))
    {
        TRACE_OUT(("Try to start mnmsrvc without no registry setting"));
        goto cleanup;
    }
    /////////////////////////////////////////////////// 
    // 
    // Service initialization 
    // 

    // report the status to the service control manager. 
    //
    if (!ReportStatusToSCMgr( SERVICE_START_PENDING, NO_ERROR, 30000))
    {
        ERROR_OUT(("ReportStatusToSCMgr failed"));
        dwError = GetLastError();
        goto cleanup; 
    }
    HANDLE pEventHandles[numEventHandles];
    
    // create the event object. The control handler function signals 
    // this event when it receives the "stop" control code. 
    // 
    hServerStopEvent = CreateEvent( 
        NULL,    // no security attributes 
        TRUE,    // manual reset event 
        FALSE,  // not-signalled 
        SERVICE_STOP_EVENT);  // no name 
 
    if ( hServerStopEvent == NULL) 
    {
        ERROR_OUT(("CreateEvent failed"));
        dwError = GetLastError();
        goto cleanup; 
    }
 
    pEventHandles[STOP_EVENT] = hServerStopEvent;

    hServerPauseEvent = CreateEvent(
        NULL,
        FALSE,
        FALSE,
        SERVICE_PAUSE_EVENT);

    if (hServerPauseEvent == NULL)
    {
        ERROR_OUT(("CreateEvent failed"));
        dwError = GetLastError();
        goto cleanup; 
    }

    pEventHandles[PAUSE_EVENT] = hServerPauseEvent;

    hServerContinueEvent = CreateEvent(
        NULL,
        FALSE,
        FALSE,
        SERVICE_CONTINUE_EVENT);

    if (hServerContinueEvent == NULL)
    {
        ERROR_OUT(("CreateEvent failed"));
        dwError = GetLastError();
        goto cleanup; 
    }

    pEventHandles[CONTINUE_EVENT] = hServerContinueEvent;
 
    CoInitialize(NULL);

    // 
    // End of initialization 
    // 
    //////////////////////////////////////////////////////// 
 
    // report the status to the service control manager. 
    //
    if (!ReportStatusToSCMgr( 
        SERVICE_RUNNING,        // service state 
        NO_ERROR,              // exit code 
        0))                    // wait hint 
    {
        ERROR_OUT(("ReportStatusToSCMgr failed"));
        goto cleanup; 
    }
    SetConsoleCtrlHandler(ServiceCtrlHandler, TRUE);

    CreateWatcherProcess();

    AddTaskbarIcon();

    //////////////////////////////////////////////////////// 
    // 
    // Service is now running, perform work until shutdown 
    //
    if (IS_NT)
    {
        AddToMessageLog(EVENTLOG_INFORMATION_TYPE,
                        0,
                        MSG_INF_START,
                        NULL);
    }

    //
    // Check if the service should start up activated
    //

    if ( Re.GetNumber(REMOTE_REG_ACTIVATESERVICE,
                    DEFAULT_REMOTE_ACTIVATESERVICE))
    {
        MNMServiceActivate();
    }
    else
    {
        if (!ReportStatusToSCMgr( 
            SERVICE_PAUSED,        // service state 
            NO_ERROR,              // exit code 
            0))                    // wait hint 
        {
            ERROR_OUT(("ReportStatusToSCMgr failed"));
            goto cleanup; 
        }
    }

    while (fWaitForEvent)
    {
        dwResult = MsgWaitForMultipleObjects( numEventHandles,
                                              pEventHandles,
                                              FALSE,
                                              INFINITE,
                                              QS_ALLINPUT);

        switch (dwResult)
        {
            case WAIT_OBJECT_0 + numEventHandles:
            {
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    if (WM_QUIT != msg.message)
                    {
                    
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    
                    }
                    else
                    {
                        TRACE_OUT(("received WM_QUIT"));
                        fWaitForEvent = FALSE;
                        break;
                    }
                }
                break;
            }
            case WAIT_OBJECT_0 + PAUSE_EVENT:
            {
                if (STATE_ACTIVE == g_dwActiveState)
                {
                    MNMServiceDeActivate();
                }
                ReportStatusToSCMgr( SERVICE_PAUSED, NO_ERROR, 0);
                break;
            }
            case WAIT_OBJECT_0 + CONTINUE_EVENT:
            {
                HANDLE hInit = OpenEvent(EVENT_ALL_ACCESS, FALSE, _TEXT("CONF:Init"));
                if (STATE_INACTIVE == g_dwActiveState && NULL == hInit)
                {
                    MNMServiceActivate();
                }
                CloseHandle(hInit);
                ReportStatusToSCMgr( SERVICE_RUNNING, NO_ERROR, 0);
                break;
            }
            case WAIT_OBJECT_0 + STOP_EVENT:
            {
                RemoveTaskbarIcon();
                if (STATE_ACTIVE == g_dwActiveState)
                {
                    MNMServiceDeActivate();
                }
                fWaitForEvent = FALSE;
                break;
            }
        }
    }

cleanup: 

    if ( STATE_ACTIVE == g_dwActiveState )
    {
        MNMServiceDeActivate();
    }
 
    if (hServerStopEvent) 
        CloseHandle(hServerStopEvent); 
    if (hServerPauseEvent) 
        CloseHandle(hServerPauseEvent); 
    if (hServerContinueEvent) 
        CloseHandle(hServerContinueEvent); 

    TRACE_OUT(("Reporting SERVICE_STOPPED"));
    ReportStatusToSCMgr( SERVICE_STOPPED, dwError, 0);

    DebugExitVOID(MNMServiceStart);

    CoUninitialize();

    DBGDEINIT(&ghZone);
    ExitDebugModule();
}
 
 
BOOL MNMServiceActivate ( VOID )
{
    DebugEntry(MNMServiceActivate);

    if ( STATE_INACTIVE != g_dwActiveState )
    {
        WARNING_OUT(("MNMServiceActivate: g_dwActiveState:%d",
                                g_dwActiveState));
        return FALSE;
    }

    g_dwActiveState = STATE_BUSY;

    if (!IS_NT)
    {
        ASSERT(NULL == hServerActiveEvent);
        hServerActiveEvent = CreateEvent(NULL, FALSE, FALSE, SERVICE_ACTIVE_EVENT);
    }
    HRESULT hRet = InitConfMgr();
    if (FAILED(hRet))
    {
        ERROR_OUT(("ERROR %x initializing nmmanger", hRet));
        FreeConfMgr();
        g_dwActiveState = STATE_INACTIVE;
        if (!IS_NT)
        {
            CloseHandle ( hServerActiveEvent );
        }
        DebugExitBOOL(MNMServiceActivate,FALSE);
        return FALSE;
    }

    if ( g_pNmSysInfo )
    {
        //
        // Attempt to initialize T.120 security, if this fails
        // bail out since we won't be able to receive any calls
        //

        if ( !InitT120Credentials() )
        {
            FreeConfMgr();
            g_dwActiveState = STATE_INACTIVE;
            if (!IS_NT)
            {
                CloseHandle ( hServerActiveEvent );
            }
            DebugExitBOOL(MNMServiceActivate,FALSE);
            return FALSE;
        }
    }
    g_dwActiveState = STATE_ACTIVE;
    DebugExitBOOL(MNMServiceActivate,TRUE);
    return TRUE;
}


BOOL MNMServiceDeActivate ( VOID )
{
    DebugEntry(MNMServiceDeActivate);

    if (STATE_ACTIVE != g_dwActiveState)
    {
        WARNING_OUT(("MNMServiceDeActivate: g_dwActiveState:%d",
                                g_dwActiveState));
        DebugExitBOOL(MNMServiceDeActivate,FALSE);
        return FALSE;
    }

    g_dwActiveState = STATE_BUSY;

    //
    // Leave Conference
    //

    if (NULL != g_pConference)
    {
        if (g_pNmSysInfo)
        {
            g_pNmSysInfo->ProcessSecurityData(UNLOADFTAPPLET,0,0,NULL);
        }
        if ( FAILED(g_pConference->Leave()))
        {
            ERROR_OUT(("Conference Leave failed"));;
        }
    }

    //
    // Free the conference
    //

    FreeConference();

    //
    // Free the AS interface
    //

    ASSERT(g_pAS);
    UINT ret = g_pAS->Release();
    g_pAS = NULL;
    TRACE_OUT(("AS interface freed, ref %d after Release", ret));

    // can we have a way not to create this event?
    HANDLE hevt = ::CreateEvent(NULL, FALSE, FALSE, NULL);
    ASSERT(NULL != hevt);
    const DWORD dwTimeout = 1000;
    DWORD dwStartTime = ::GetTickCount();
    DWORD dwCurrTimeout = dwTimeout;
    DWORD dwRet;
    BOOL fContinue = TRUE;

    while (fContinue && WAIT_OBJECT_0 != (dwRet = ::MsgWaitForMultipleObjects(1, &hevt, FALSE, dwCurrTimeout, QS_ALLINPUT)))
    {
        if (WAIT_TIMEOUT != dwRet)
        {
            DWORD dwCurrTime = ::GetTickCount();
            if (dwCurrTime < dwStartTime + dwTimeout)
            {
                dwCurrTimeout = dwStartTime + dwTimeout - dwCurrTime;

                MSG msg;
                while (::PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    if (WM_QUIT != msg.message)
                    {
                        ::TranslateMessage(&msg);
                        ::DispatchMessage(&msg);
                    }
                    else
                    {
                        ::PostQuitMessage(0);
                        fContinue = FALSE;
                    }
                }
                continue;
            }
            // timeout here
        }
        // exit the loop
        break;
    }
    ::CloseHandle(hevt);

    // not to call FreeConfMfr imediately after FreeConference to avoid
    // a bug in t120 will remove this sleep call after fix the bug in t120
    FreeConfMgr();

    // BUGBUG remove h323cc.dll should be done in nmcom. Once the bug in nmcom is fixed, this part will be removed.
    HMODULE hmodH323CC = GetModuleHandle("h323cc.dll");    
    if (hmodH323CC)
    {
        if (FreeLibrary(hmodH323CC))
        {
            TRACE_OUT(("CmdInActivate -- Unloaded h323cc.dll"));
        }
        else
        {
            WARNING_OUT(("CmdInActivate -- Failed to unload h323cc.dll %d", GetLastError()));
        }
    }
    if (!IS_NT)
    {
        ASSERT(hServerActiveEvent);
        if (hServerActiveEvent)
        {
            CloseHandle(hServerActiveEvent);
            hServerActiveEvent = NULL;
        }
    }
    g_dwActiveState = STATE_INACTIVE;
    DebugExitBOOL(MNMServiceDeActivate,TRUE);
    return TRUE;
}

// 
//  FUNCTION: MNMServiceStop 
// 
//  PURPOSE: Stops the service 
// 
//  PARAMETERS: 
//    none 
// 
//  RETURN VALUE: 
//    none 
// 
//  COMMENTS: 
//    If a ServiceStop procedure is going to 
//    take longer than 3 seconds to execute, 
//    it should spawn a thread to execute the 
//    stop code, and return.  Otherwise, the 
//    ServiceControlManager will believe that 
//    the service has stopped responding. 
//     
VOID MNMServiceStop() 
{ 
    DebugEntry(MNMServiceStop);

    RemoveTaskbarIcon();

    if ( hServerStopEvent ) 
    {
        TRACE_OUT(("MNMServiceStop: setting server stop event"));
        SetEvent(hServerStopEvent); 
    }

    if (IS_NT)
    {
        AddToMessageLog(EVENTLOG_INFORMATION_TYPE,
                        0,
                        MSG_INF_STOP,
                        NULL);
    }

    DebugExitVOID(MNMServiceStop);
}


VOID MNMServicePause()
{
    DebugEntry(MNMServicePause);

    if ( hServerPauseEvent ) 
        SetEvent(hServerPauseEvent); 

    DebugExitVOID(MNMServicePause);
}

VOID MNMServiceContinue()
{
    DebugEntry(MNMServiceContinue);

    if ( hServerContinueEvent )
        SetEvent(hServerContinueEvent);

    DebugExitVOID(MNMServiceContinue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\srvc\clutil.h ===
//****************************************************************************
//  Module:     NMCHAT.EXE
//  File:       CLUTIL.H
//  Content:    
//              
//
//  Copyright (c) Microsoft Corporation 1997
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//****************************************************************************

#ifndef _CL_UTIL_H_
#define _CL_UTIL_H_


////////////////////
// Reference Count
class RefCount
{
private:
   LONG m_cRef;

public:
   RefCount();
   // Virtual destructor defers to destructor of derived class.
   virtual ~RefCount();

   // IUnknown methods

   ULONG STDMETHODCALLTYPE AddRef(void);
   ULONG STDMETHODCALLTYPE Release(void);
};



//////////////////////
// Notification Sink
class CNotify
{
private:
    DWORD  m_dwCookie;
	IUnknown * m_pUnk;
    IConnectionPoint           * m_pcnp;
    IConnectionPointContainer  * m_pcnpcnt;
public:
    CNotify(void);
    ~CNotify();

    HRESULT Connect(IUnknown *pUnk, REFIID riid, IUnknown *pUnkN);
    HRESULT Disconnect(void);

    IUnknown * GetPunk() {return m_pUnk;}
};


///////////
// OBLIST

#define POSITION COBNODE*

struct COBNODE
{
	POSITION	pNext;
	void*		pItem;
};

class COBLIST
{
protected:
	POSITION m_pHead;
	POSITION m_pTail;
	int      m_cItem;
    virtual BOOL Compare(void* pItemToCompare, void* pComparator) 
                       { return(pItemToCompare == pComparator); }
public:
	COBLIST() : m_pHead(NULL), m_pTail(NULL), m_cItem(0) { }
    virtual         ~COBLIST();
	
	virtual void *  RemoveAt(POSITION rPos);
    void            EmptyList();
	POSITION	    AddTail(void* pItem);
	void *		    GetNext(POSITION& rPos);
    void *          SafeGetFromPosition(POSITION rPos);
    POSITION        GetPosition(void* pItem);
    POSITION        Lookup(void* pComparator);
	POSITION	    GetHeadPosition()  { return (m_pHead); }
	POSITION	    GetTailPosition()  { return (m_pTail); }
	BOOL		    IsEmpty()          { return (!m_pHead); }
	int             GetItemCount()     { return (m_cItem); }
#ifdef DEBUG
	void *		    GetHead();
	void *		    GetTail();
	void *		    RemoveHead();
	void *	        RemoveTail();
	void *		    GetFromPosition(POSITION rPos);
#else
	void *		    GetHead()          { return GetFromPosition(GetHeadPosition());}
	void *          GetTail()          { return m_pTail->pItem;}
	void *		    RemoveHead()       { return RemoveAt(m_pHead); }
	void *	        RemoveTail()       { return RemoveAt(m_pTail); }
	void *		    GetFromPosition(POSITION rPos){return(rPos->pItem);}
#endif
};

// Utility Functions
POSITION AddNode(PVOID pv, COBLIST ** ppList);
PVOID RemoveNode(POSITION * pPos, COBLIST *pList);



////////////
// BSTRING

class BSTRING
{
private:
	BSTR   m_bstr;

public:
	// Constructors
	BSTRING() {m_bstr = NULL;}

	inline BSTRING(LPCWSTR lpcwString);

#if !defined(UNICODE)
	// We don't support construction from an ANSI string in the Unicode build.
	BSTRING(LPCSTR lpcString);
#endif // !defined(UNICODE)

	// Destructor
	inline ~BSTRING();

	// Cast to BSTR
	operator BSTR() {return m_bstr;}
	inline LPBSTR GetLPBSTR(void);
};


BSTRING::BSTRING(LPCWSTR lpcwString)
{
	if (NULL != lpcwString)
	{
		m_bstr = SysAllocString(lpcwString);
		//ASSERT(NULL != m_bstr);
	}
	else
	{
		m_bstr = NULL;
	}
}

BSTRING::~BSTRING()
{
	if (NULL != m_bstr)
	{
		SysFreeString(m_bstr);
	}
}

inline LPBSTR BSTRING::GetLPBSTR(void)
{
	//ASSERT(NULL == m_bstr);

	return &m_bstr;
}

class BTSTR
{
private:
	LPTSTR m_psz;

public:
	BTSTR(BSTR bstr);
	~BTSTR();

	// Cast to BSTR
	operator LPTSTR() {return (NULL == m_psz) ? TEXT("<null>") : m_psz;}
};

LPTSTR PszFromBstr(BSTR bst);


#endif  // _CL_UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\srvc\nmmgr.h ===
// Copyright (C) 1993-1998  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE: nmmgr.h
//
//  AUTHOR: claus giloi
//
//  COMMENTS: Based on Service sample in NT SDK
//            Code will have the following command line interface
//
//  <service exe> -?                to display this list
//  <service exe> -install          to install the service
//  <service exe> -remove           to remove the service
//  <service exe> -debug <params>   to run as a console app for debugging
//
//  Note: This code also implements Ctrl+C and Ctrl+Break handlers
//        when using the debug option.  These console events cause
//        your ServiceStop routine to be called
//
//        Also, this code only handles the OWN_SERVICE service type
//        running in the LOCAL_SYSTEM security context.
//
//        To control your service ( start, stop, etc ) you may use the
//        Services control panel applet or the NET.EXE program.
//
//        To aid in writing/debugging service, the
//        SDK contains a utility (MSTOOLS\BIN\SC.EXE) that
//        can be used to control, configure, or obtain service status.
//        SC displays complete status for any service/driver
//        in the service database, and allows any of the configuration
//        parameters to be easily changed at the command line.
//        For more information on SC.EXE, type SC at the command line.
//

#ifndef __NTSRVC_H__
#define __NTSRVC_H__


#ifdef __cplusplus
extern "C" {
#endif

extern SERVICE_STATUS          ssStatus;       // current status of the service 
extern SERVICE_STATUS_HANDLE   sshStatusHandle;
//////////////////////////////////////////////////////////////////////////////
//// todo: change to desired strings
////
// name of the executable
#define SZAPPNAME            REMOTE_CONTROL_NAME
// internal name of the service
#define SZSERVICENAME        REMOTE_CONTROL_NAME
// displayed name of the service
#define SZSERVICEDISPLAYNAME REMOTE_CONTROL_DISPLAY_NAME
// list of service dependencies - "dep1\0dep2\0\0"
#define SZDEPENDENCIES       ""
//////////////////////////////////////////////////////////////////////////////

#define	STATE_INACTIVE  0
#define STATE_BUSY	 	1
#define STATE_ACTIVE  	2

extern DWORD g_dwActiveState;



//////////////////////////////////////////////////////////////////////////////
////       The service should use ReportStatusToSCMgr to indicate
////       progress.  This routine must also be used by StartService()
////       to report to the SCM when the service is running.
////
////       If a ServiceStop procedure is going to take longer than
////       3 seconds to execute, it should spawn a thread to
////       execute the stop code, and return.  Otherwise, the
////       ServiceControlManager will believe that the service has
////       stopped responding
////
VOID MNMServiceStart(DWORD dwArgc, LPTSTR *lpszArgv);
VOID MNMServiceStop();
VOID MNMServicePause();
VOID MNMServiceContinue();
BOOL MNMServiceActivate();
BOOL MNMServiceDeActivate();
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//// The following are procedures which
//// may be useful to call within the above procedures,
//// but require no implementation by the user.
//// They are implemented in service.c

//
//  FUNCTION: ReportStatusToSCMgr()
//
//  PURPOSE: Sets the current status of the service and
//           reports it to the Service Control Manager
//
//  PARAMETERS:
//    dwCurrentState - the state of the service
//    dwWin32ExitCode - error code to report
//    dwWaitHint - worst case estimate to next checkpoint
//
//  RETURN VALUE:
//    TRUE  - success 
//    FALSE - failure
//
BOOL ReportStatusToSCMgr(DWORD dwCurrentState, DWORD dwWin32ExitCode, DWORD dwWaitHint);


#ifdef __cplusplus
}
#endif

#endif __NTSRVC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\srvc\precomp.h ===
#ifdef DEBUG
#define _CRTDBG_MAP_ALLOC
#endif

#include <windows.h> 
#include <stdio.h> 
#include <stdlib.h> 
#include <shellapi.h>
#include <process.h> 
#include <tchar.h> 
#include <stock.h>
#include <ConfDbg.h>
#include <debspew.h>
#include "nmmgr.h" 
#include <RegEntry.h>
#include <ConfReg.h>
#include <nmremote.h>
#include <resource.h>
#include <oprahcom.h>
#include <ias.h>
#include <evtlog.h>
#include <mtgset.h>

#include "capflags.h"
#include "objidl.h"
#include "oleidl.h"
#include "ocidl.h"
#include "oaidl.h"
#include "SDKInternal.h"
#include "clutil.h"
#include "cconf.h"
#include "taskbar.h"
#include "nmevtmsg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\srvc\rdscred.cpp ===
//
// Copyright (C) 1993-1999  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:  rdscred.cpp
//
//  PURPOSE:  Implements RDS credential management
//
//  FUNCTIONS:
//            InitT120Credentials(VOID)
//
//  COMMENTS:
//
//
//  AUTHOR: Claus Giloi
//


#include <precomp.h>
#include <wincrypt.h>
#include <tsecctrl.h>
#include <nmmkcert.h>

extern INmSysInfo2 * g_pNmSysInfo;   // Interface to SysInfo

BOOL InitT120Credentials(VOID)
{
    HCERTSTORE hStore;
    PCCERT_CONTEXT pCertContext = NULL;
    BOOL bRet = FALSE;

    // Open the "MY" local machine certificate store. This one will be
    // used when we're running as a service
    hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,
                                        X509_ASN_ENCODING,
                                        0,
                                        CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                        L"MY" );

    if ( NULL != hStore )
    {
        #ifdef DUMPCERTS
        DumpCertStore(this, "Local Machine Store MY", hStore);
        #endif // DUMPCERTS

        // Check the local machine store for a certificate - any!
        pCertContext = CertFindCertificateInStore(hStore,
                                              X509_ASN_ENCODING,
                                              0,
                                              CERT_FIND_ANY,
                                              NULL,
                                              NULL);

        CertCloseStore( hStore, 0);
    }

    if ( NULL == pCertContext )
    {
        // Open the "_NMSTR" local machine certificate store.
        hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,
                                            X509_ASN_ENCODING,
                                            0,
                                            CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                            WSZNMSTORE );
        if ( NULL != hStore )
        {
            #ifdef DUMPCERTS
            DumpCertStore(this, "Local Machine Store _NMSTR", hStore);
            #endif // DUMPCERTS

            // Check the local machine store for a certificate - any!
            pCertContext = CertFindCertificateInStore(hStore,
                                                  X509_ASN_ENCODING,
                                                  0,
                                                  CERT_FIND_ANY,
                                                  NULL,
                                                  NULL);

            CertCloseStore( hStore, 0);
        }
    }

    if ( NULL == pCertContext )
    {
        WARNING_OUT(("No service context cert found!"));
        return bRet;
    }


    DWORD dwResult = -1;

    g_pNmSysInfo->ProcessSecurityData(
                            TPRTCTRL_SETX509CREDENTIALS,
                            (DWORD_PTR)pCertContext, 0,
                            &dwResult);
    if ( !dwResult )
    {
        bRet = TRUE;
    }
    else
    {
        ERROR_OUT(("InitT120Credentials - failed in T.120"));
    }
    CertFreeCertificateContext ( pCertContext );

    return bRet;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\srvc\resource.h ===
#define IDI_SM_WORLD 100
#define IDS_MNMSRVC_TITLE 101
#define IDS_MNMSRVC_DESCRIPTION 102
#define IDC_STOP_ICON	103
#define IDR_TASKBAR_POPUP 200
#define IDM_TBPOPUP_STOP 201
#define IDM_TBPOPUP_ACTIVATE 202
#define IDM_TBPOPUP_INACTIVATE 203
#define IDM_TBPOPUP_SENDFILES 204
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\srvc\srvccall.h ===
// File: srvccall.h

#ifndef _SRVCCALL_H_
#define _SRVCCALL_H_

class CSrvcCall : public INmCallNotify2
{
private:
	INmCall * m_pCall;
	BOOL      m_fIncoming;
	LPTSTR    m_pszName;
	LPTSTR    m_pszAddr;
	NM_ADDR_TYPE  m_addrType;
	NM_CALL_STATE m_State;
	BOOL      m_fSelectedConference;

	POSITION  m_pos;           // position in g_pCallList
	DWORD     m_dwTick;        // tick count at call start
	ULONG     m_cRef;
	DWORD     m_dwCookie;

public:
	CSrvcCall(INmCall * pCall);
	~CSrvcCall();

	// IUnknown methods
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppv);

	// INmCallNotify methods
	STDMETHODIMP NmUI(CONFN uNotify);
	STDMETHODIMP StateChanged(NM_CALL_STATE uState);
	STDMETHODIMP Failed(ULONG uError);
	STDMETHODIMP Accepted(INmConference *pConference);

	// INmCallNotify2 methods
	STDMETHODIMP CallError(UINT cns);
	STDMETHODIMP VersionConflict(HRESULT Status, BOOL *pfContinue);
	STDMETHODIMP RemoteConference(BOOL fMCU, BSTR *pwszConfNames, BSTR *pbstrConfToJoin);
	STDMETHODIMP RemotePassword(BSTR bstrConference, BSTR *pbstrPassword, BYTE *pb, DWORD cb, BOOL fIsService);

	// Internal methods
	VOID    Update(void);
	VOID	RemoveCall(void);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\srvc\service.cpp ===
//
// Copyright (C) 1993-1997  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   service.c
//
//  PURPOSE:  Implements functions required by all services
//            windows.
//
//  FUNCTIONS:
//    main(int argc, char **argv);
//    NTmain(int argc, char **argv);
//    W95main(int argc, char **argv);
//    service_ctrl(DWORD dwCtrlCode);
//    service_main(DWORD dwArgc, LPTSTR *lpszArgv);
//    CmdInstallService();
//    CmdRemoveService();
//    CmdDebugService(int argc, char **argv);  // DEBUG only
//    ControlHandler ( DWORD dwCtrlType );  // DEBUG only
//    GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize );  // DEBUG only
//
//  COMMENTS:
//
//  AUTHOR: Claus Giloi (based on SDK sample)
//


#include "precomp.h"

#ifndef DEBUG
#undef _tprintf
#define _tprintf force_compile_error
#endif // !DEBUG

// internal variables
SERVICE_STATUS          ssStatus;       // current status of the service
SERVICE_STATUS_HANDLE   sshStatusHandle;
DWORD                   dwErr = 0;
OSVERSIONINFO g_osvi;                      // The os version info structure global
BOOL          g_fInShutdown = FALSE;

// internal function prototypes
VOID WINAPI service_ctrl(DWORD dwCtrlCode);
VOID WINAPI service_main(DWORD dwArgc, LPTSTR *lpszArgv);
VOID CmdInstallService();
VOID CmdRemoveService();
void __cdecl NTmain(int argc, char **argv);
void __cdecl W95main(int argc, char **argv);


// Debug only functionality
#ifdef DEBUG
TCHAR                   szErr[256];
BOOL                    bDebug = FALSE;
VOID CmdDebugService(int argc, char **argv);
BOOL WINAPI ControlHandler ( DWORD dwCtrlType );
LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize );
extern BOOL InitDebugMemoryOptions(void);
extern VOID DumpMemoryLeaksAndBreak(void);
#endif // DEBUG

typedef BOOL (WINAPI *PFNCHANGESERVICECONFIG2)(SC_HANDLE, DWORD, LPVOID);

//
//  FUNCTION: main
//
//  PURPOSE: entrypoint for service
//
//  PARAMETERS:
//    argc - number of command line arguments
//    argv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//      Get Platform type and
//    call appropriate main for platform (NT or Win95)
//
void __cdecl main(int argc, char **argv)
{
    #ifdef DEBUG
    InitDebugMemoryOptions();
    #endif // DEBUG

    // Store OS version info
    g_osvi.dwOSVersionInfoSize = sizeof(g_osvi);
    if (FALSE == ::GetVersionEx(&g_osvi))
    {
        ERROR_OUT(("GetVersionEx() failed!"));
        return;
    }

    RegEntry rePol(POLICIES_KEY, HKEY_LOCAL_MACHINE);
    if ( rePol.GetNumber( REGVAL_POL_NO_RDS, DEFAULT_POL_NO_RDS) )
    {
        WARNING_OUT(("RDS launch prevented by policy"));
        return;
    }

    if ( IS_NT )
    {
        NTmain( argc, argv );
    }
    else
    {
        W95main( argc, argv );
    }

    #ifdef DEBUG
    DumpMemoryLeaksAndBreak();
    #endif // DEBUG
}


//
//  FUNCTION: NTmain
//
//  PURPOSE: entrypoint for service
//
//  PARAMETERS:
//    argc - number of command line arguments
//    argv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    NTmain() either performs the command line task, or
//    call StartServiceCtrlDispatcher to register the
//    main service thread.  When the this call returns,
//    the service has stopped, so exit.
//
void __cdecl NTmain(int argc, char **argv)
{
    SERVICE_TABLE_ENTRY dispatchTable[] =
    {
        { TEXT(SZSERVICENAME), (LPSERVICE_MAIN_FUNCTION)service_main },
        { NULL, NULL }
    };

    if ( (argc > 1) &&
         ((*argv[1] == '-') || (*argv[1] == '/')) )
    {
        if ( lstrcmpi( "install", argv[1]+1 ) == 0 )
        {
            CmdInstallService();
        }
        else if ( lstrcmpi( "remove", argv[1]+1 ) == 0 )
        {
            CmdRemoveService();
        }
#ifdef DEBUG
        else if ( lstrcmpi( "debug", argv[1]+1 ) == 0 )
        {
            bDebug = TRUE;
            CmdDebugService(argc, argv);
        }
#endif // DEBUG
        else
        {
            goto dispatch;
        }
        exit(0);
    }

    // if it doesn't match any of the above parameters
    // the service control manager may be starting the service
    // so we must call StartServiceCtrlDispatcher
    dispatch:

        #ifdef DEBUG
        // this is just to be friendly
        printf( "%s -install          to install the service\n", SZAPPNAME );
        printf( "%s -remove           to remove the service\n", SZAPPNAME );
        printf( "%s -debug <params>   to run as a console app for debugging\n", SZAPPNAME );
        printf( "\nStartServiceCtrlDispatcher being called.\n" );
        printf( "This may take several seconds.  Please wait.\n" );
        #endif // DEBUG

        if (!StartServiceCtrlDispatcher(dispatchTable)) {
            AddToMessageLog(EVENTLOG_ERROR_TYPE,
                            0,
                            MSG_ERR_SERVICE,
                            TEXT("StartServiceCtrlDispatcher failed."));
        }
}

//
//  FUNCTION: W95main
//
//  PURPOSE: entrypoint for pseudo-service on Win95
//
//  PARAMETERS:
//    argc - number of command line arguments
//    argv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    W95main() registers as Win95 service and calls Init routine directly
//
typedef DWORD (WINAPI * REGISTERSERVICEPROC)(DWORD, DWORD);
#ifndef RSP_SIMPLE_SERVICE
#define RSP_SIMPLE_SERVICE    0x00000001
#endif

void __cdecl W95main(int argc, char **argv)
{
    HMODULE hKernel;
    REGISTERSERVICEPROC lpfnRegisterServiceProcess;
    HANDLE hServiceEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, SERVICE_PAUSE_EVENT);
    if (hServiceEvent != NULL) // Service is already running
    {
        return;
    }

    if ( hKernel = GetModuleHandle("KERNEL32.DLL") )
    {
        if ( lpfnRegisterServiceProcess =
            (REGISTERSERVICEPROC)GetProcAddress ( hKernel,
                                    "RegisterServiceProcess" ))
        {
            if (!lpfnRegisterServiceProcess(NULL, RSP_SIMPLE_SERVICE))
            {
                ERROR_OUT(("RegisterServiceProcess failed"));
            }
        }
        else
        {
            ERROR_OUT(("GetProcAddr of RegisterServiceProcess failed"));
        }
    }
    else
    {
        ERROR_OUT(("GetModuleHandle of KERNEL32.DLL failed"));
    }

    MNMServiceStart(argc, argv);
    CloseHandle(hServiceEvent);
}

//
//  FUNCTION: service_main
//
//  PURPOSE: To perform actual initialization of the service
//
//  PARAMETERS:
//    dwArgc   - number of command line arguments
//    lpszArgv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    This routine performs the service initialization and then calls
//    the user defined MNMServiceStart() routine to perform majority
//    of the work.
//
void WINAPI service_main(DWORD dwArgc, LPTSTR *lpszArgv)
{

    // register our service control handler:
    //
    sshStatusHandle = RegisterServiceCtrlHandler( TEXT(SZSERVICENAME), service_ctrl);

    if (!sshStatusHandle)
        goto cleanup;

    // SERVICE_STATUS members that don't change
    //
    ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    ssStatus.dwServiceSpecificExitCode = 0;

    TRACE_OUT(("starting service\n\r"));

    MNMServiceStart( dwArgc, lpszArgv );

cleanup:

    return;
}



//
//  FUNCTION: service_ctrl
//
//  PURPOSE: This function is called by the SCM whenever
//           ControlService() is called on this service.
//
//  PARAMETERS:
//    dwCtrlCode - type of control requested
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
VOID WINAPI service_ctrl(DWORD dwCtrlCode)
{
    // Handle the requested control code.
    //
    switch(dwCtrlCode)
    {
        // Stop the service.
        //
        // SERVICE_STOP_PENDING should be reported before
        // setting the Stop Event - hServerStopEvent - in
        // MNMServiceStop().  This avoids a race condition
        // which may result in a 1053 - The Service did not respond...
        // error.
        case SERVICE_CONTROL_STOP:
            ReportStatusToSCMgr(SERVICE_STOP_PENDING, NO_ERROR, 30000);
            MNMServiceStop();
            return;

        case SERVICE_CONTROL_SHUTDOWN:
            g_fInShutdown = TRUE;
            break;

        // Update the service status.
        //
        case SERVICE_CONTROL_INTERROGATE:
            break;

        case SERVICE_CONTROL_PAUSE:
            ReportStatusToSCMgr(SERVICE_PAUSE_PENDING, NO_ERROR, 30000);
            MNMServicePause();
            return;

        case SERVICE_CONTROL_CONTINUE:
            ReportStatusToSCMgr(SERVICE_CONTINUE_PENDING, NO_ERROR, 30000);
            MNMServiceContinue();
            return;

        default:
            break;

    }
}



//
//  FUNCTION: ReportStatusToSCMgr()
//
//  PURPOSE: Sets the current status of the service and
//           reports it to the Service Control Manager
//
//  PARAMETERS:
//    dwCurrentState - the state of the service
//    dwWin32ExitCode - error code to report
//    dwWaitHint - worst case estimate to next checkpoint
//
//  RETURN VALUE:
//    TRUE  - success
//    FALSE - failure
//
//  COMMENTS:
//
BOOL ReportStatusToSCMgr(DWORD dwCurrentState,
                         DWORD dwWin32ExitCode,
                         DWORD dwWaitHint)
{
    static DWORD dwCheckPoint = 1;
    BOOL fResult = TRUE;

    #ifdef DEBUG
    if ( bDebug )
        return TRUE;
    #endif

    if ( IS_NT ) // when debugging we don't report to the SCM
    {
        switch ( dwCurrentState )
        {
            case SERVICE_START_PENDING:
            case SERVICE_STOP_PENDING:
            case SERVICE_CONTINUE_PENDING:
            case SERVICE_PAUSE_PENDING:
                break;

            case SERVICE_PAUSED:
            case SERVICE_STOPPED:
            case SERVICE_RUNNING:
                ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
                                              SERVICE_ACCEPT_PAUSE_CONTINUE ;

                break;
        }

        ssStatus.dwCurrentState = dwCurrentState;
        ssStatus.dwWin32ExitCode = dwWin32ExitCode;
        ssStatus.dwWaitHint = dwWaitHint;

        if ( ( dwCurrentState == SERVICE_RUNNING ) ||
             ( dwCurrentState == SERVICE_STOPPED ) ||
             ( dwCurrentState == SERVICE_PAUSED  ))
            ssStatus.dwCheckPoint = 0;
        else
            ssStatus.dwCheckPoint = dwCheckPoint++;

        // Report the status of the service to the service control manager.
        //
        if (!(fResult = SetServiceStatus( sshStatusHandle, &ssStatus))) {
            AddToMessageLog(EVENTLOG_ERROR_TYPE,
                            0,
                            MSG_ERR_SERVICE,
                            TEXT("SetServiceStatus"));
        }
    }
    return fResult;
}


///////////////////////////////////////////////////////////////////
//
//  The following code handles service installation and removal
//


//
//  FUNCTION: CmdInstallService()
//
//  PURPOSE: Installs the service
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
void CmdInstallService()
{
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;

    TCHAR szPath[MAX_PATH];
    TCHAR szSrvcDisplayName[MAX_PATH];
    if ( GetModuleFileName( NULL, szPath, MAX_PATH ) == 0 )
    {
        #ifdef DEBUG
        _tprintf(TEXT("Unable to install %s - %s\n"),
            TEXT(SZSERVICEDISPLAYNAME), GetLastErrorText(szErr, 256));
        #endif // DEBUG
        return;
    }

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        LoadString(GetModuleHandle(NULL), IDS_MNMSRVC_TITLE,
                   szSrvcDisplayName, CCHMAX(szSrvcDisplayName));
        schService = CreateService(
            schSCManager,               // SCManager database
            TEXT(SZSERVICENAME),        // name of service
            szSrvcDisplayName, // name to display
            SERVICE_ALL_ACCESS,         // desired access
            SERVICE_WIN32_OWN_PROCESS | SERVICE_INTERACTIVE_PROCESS, 
                                        // service type -- allow interaction with desktop
            SERVICE_DEMAND_START,       // start type
            SERVICE_ERROR_NORMAL,       // error control type
            szPath,                     // service's binary
            NULL,                       // no load ordering group
            NULL,                       // no tag identifier
            TEXT(SZDEPENDENCIES),       // dependencies
            NULL,                       // LocalSystem account
            NULL);                     // no password

        if ( schService )
        {
            HINSTANCE hAdvApi;

            if ( IS_NT && ( hAdvApi = LoadLibrary ( "ADVAPI32.DLL" )))
            {
                #ifdef UNICODE
                #error "non-unicode assumption - entry point name"
                #endif // UNICODE

                if ( PFNCHANGESERVICECONFIG2 lpCSC = 
                    (PFNCHANGESERVICECONFIG2)GetProcAddress ( hAdvApi,
                                                "ChangeServiceConfig2A" ))
                {
                    SERVICE_DESCRIPTION ServiceDescription;
                    CHAR szDescription[1024]; // Calling A variant below

                    LoadString(GetModuleHandle(NULL), IDS_MNMSRVC_DESCRIPTION,
                        szDescription, CCHMAX(szDescription));
                    ServiceDescription.lpDescription = szDescription;

                    (*lpCSC) ( schService,
                        SERVICE_CONFIG_DESCRIPTION,
                        (LPVOID) &ServiceDescription );
                }
                FreeLibrary ( hAdvApi );
            }

            #ifdef DEBUG
            _tprintf(TEXT("%s installed.\n"), TEXT(SZSERVICEDISPLAYNAME) );
            #endif // DEBUG

            CloseServiceHandle(schService);
        }
        else
        {
            if ( GetLastError() == ERROR_SERVICE_EXISTS )
            {
                schService = OpenService(schSCManager, TEXT(SZSERVICENAME),
                                                        SERVICE_ALL_ACCESS);
                if (schService)
                {
                    // try to stop the service
                    if ( ControlService( schService, SERVICE_CONTROL_STOP, &ssStatus ) )
                    {
                        #ifdef DEBUG
                        _tprintf(TEXT("Stopping %s."), TEXT(SZSERVICEDISPLAYNAME));
                        #endif // DEBUG

                        Sleep( 1000 );

                        while( QueryServiceStatus( schService, &ssStatus ) )
                        {
                            if ( ssStatus.dwCurrentState == SERVICE_STOP_PENDING )
                            {
                                #ifdef DEBUG
                                _tprintf(TEXT("."));
                                #endif // DEBUG

                                Sleep( 1000 );
                            }
                            else
                                break;
                        }

                        if ( ssStatus.dwCurrentState == SERVICE_STOPPED )
                        {
                            #ifdef DEBUG
                            _tprintf(TEXT("\n%s stopped.\n"),
                                    TEXT(SZSERVICEDISPLAYNAME) );
                            #endif // DEBUG
                        }
                        else
                        {
                            #ifdef DEBUG
                            _tprintf(TEXT("\n%s failed to stop.\n"),
                                    TEXT(SZSERVICEDISPLAYNAME) );
                            #endif // DEBUG
                        }
                    }

                    // now set manual startup
                    if ( ChangeServiceConfig( schService, SERVICE_NO_CHANGE,
                                SERVICE_DEMAND_START, SERVICE_NO_CHANGE,
                                NULL, NULL, NULL, NULL, NULL, NULL, NULL))
                    {
                        #ifdef DEBUG
                        _tprintf(TEXT("%s set to manual start.\n"), TEXT(SZSERVICEDISPLAYNAME) );
                        #endif //DEBUG
                    }
                    else
                    {
                        #ifdef DEBUG
                        _tprintf(TEXT("ChangeServiceConfig failed - %s\n"), GetLastErrorText(szErr,256));
                        #endif //DEBUG
                    }

                    CloseServiceHandle(schService);
                }
                else
                {
                    #ifdef DEBUG
                    _tprintf(TEXT("OpenService failed - %s\n"), GetLastErrorText(szErr,256));
                    #endif //DEBUG
                }
            }
            else
            {
                #ifdef DEBUG
                _tprintf(TEXT("CreateService failed - %s\n"),
                                GetLastErrorText(szErr, 256));
                #endif // DEBUG
            }
        }

        CloseServiceHandle(schSCManager);
    }
    else
    {
        #ifdef DEBUG
        _tprintf(TEXT("OpenSCManager failed - %s\n"), GetLastErrorText(szErr,256));
        #endif //DEBUG
    }
}



//
//  FUNCTION: CmdRemoveService()
//
//  PURPOSE: Stops and removes the service
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
void CmdRemoveService()
{
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = OpenService(schSCManager, TEXT(SZSERVICENAME),
                                                SERVICE_ALL_ACCESS);

        if (schService)
        {
            // try to stop the service
            if ( ControlService( schService, SERVICE_CONTROL_STOP, &ssStatus ) )
            {
                #ifdef DEBUG
                _tprintf(TEXT("Stopping %s."), TEXT(SZSERVICEDISPLAYNAME));
                #endif // DEBUG

                Sleep( 1000 );

                while( QueryServiceStatus( schService, &ssStatus ) )
                {
                    if ( ssStatus.dwCurrentState == SERVICE_STOP_PENDING )
                    {
                        #ifdef DEBUG
                        _tprintf(TEXT("."));
                        #endif // DEBUG

                        Sleep( 1000 );
                    }
                    else
                        break;
                }

                if ( ssStatus.dwCurrentState == SERVICE_STOPPED )
                {
                    #ifdef DEBUG
                    _tprintf(TEXT("\n%s stopped.\n"),
                            TEXT(SZSERVICEDISPLAYNAME) );
                    #endif // DEBUG
                }
                else
                {
                    #ifdef DEBUG
                    _tprintf(TEXT("\n%s failed to stop.\n"),
                            TEXT(SZSERVICEDISPLAYNAME) );
                    #endif // DEBUG
                }
            }

            // now remove the service
            if( DeleteService(schService) )
            {
                #ifdef DEBUG
                _tprintf(TEXT("%s removed.\n"), TEXT(SZSERVICEDISPLAYNAME) );
                #endif //DEBUG
            }
            else
            {
                #ifdef DEBUG
                _tprintf(TEXT("DeleteService failed - %s\n"), GetLastErrorText(szErr,256));
                #endif //DEBUG
            }


            CloseServiceHandle(schService);
        }
        else
        {
            #ifdef DEBUG
            _tprintf(TEXT("OpenService failed - %s\n"), GetLastErrorText(szErr,256));
            #endif //DEBUG
        }

        CloseServiceHandle(schSCManager);
    }
    else
    {
        #ifdef DEBUG
        _tprintf(TEXT("OpenSCManager failed - %s\n"), GetLastErrorText(szErr,256));
        #endif //DEBUG
    }
}

#ifdef DEBUG

///////////////////////////////////////////////////////////////////
//
//  The following code is for running the service as a console app
//


//
//  FUNCTION: CmdDebugService(int argc, char ** argv)
//
//  PURPOSE: Runs the service as a console application
//
//  PARAMETERS:
//    argc - number of command line arguments
//    argv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
void CmdDebugService(int argc, char ** argv)
{
    DWORD dwArgc;
    LPTSTR *lpszArgv;

#ifdef UNICODE
    lpszArgv = CommandLineToArgvW(GetCommandLineW(), &(dwArgc) );
#else
    dwArgc   = (DWORD) argc;
    lpszArgv = argv;
#endif

    _tprintf(TEXT("Debugging %s.\n"), TEXT(SZSERVICEDISPLAYNAME));

    SetConsoleCtrlHandler( ControlHandler, TRUE );

    MNMServiceStart( dwArgc, lpszArgv );
}

//
//  FUNCTION: ControlHandler ( DWORD dwCtrlType )
//
//  PURPOSE: Handled console control events
//
//  PARAMETERS:
//    dwCtrlType - type of control event
//
//  RETURN VALUE:
//    True - handled
//    False - unhandled
//
//  COMMENTS:
//
BOOL WINAPI ControlHandler ( DWORD dwCtrlType )
{
    switch( dwCtrlType )
    {
        case CTRL_BREAK_EVENT:  // use Ctrl+C or Ctrl+Break to simulate
        case CTRL_C_EVENT:      // SERVICE_CONTROL_STOP in debug mode
            _tprintf(TEXT("Stopping %s.\n"), TEXT(SZSERVICEDISPLAYNAME));
            MNMServiceStop();
            return TRUE;
            break;

    }
    return FALSE;
}

//
//  FUNCTION: GetLastErrorText
//
//  PURPOSE: copies error message text to string
//
//  PARAMETERS:
//    lpszBuf - destination buffer
//    dwSize - size of buffer
//
//  RETURN VALUE:
//    destination buffer
//
//  COMMENTS:
//
LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize )
{
    DWORD dwRet;
    LPTSTR lpszTemp = NULL;

    dwRet = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |FORMAT_MESSAGE_ARGUMENT_ARRAY,
                           NULL,
                           GetLastError(),
                           LANG_NEUTRAL,
                           (LPTSTR)&lpszTemp,
                           0,
                           NULL );

    // supplied buffer is not long enough
    if ( !dwRet || ( (long)dwSize < (long)dwRet+14 ) )
        lpszBuf[0] = TEXT('\0');
    else
    {
        lpszTemp[lstrlen(lpszTemp)-2] = TEXT('\0');  //remove cr and newline character
        _stprintf( lpszBuf, TEXT("%s (0x%x)"), lpszTemp, GetLastError() );
    }

    if ( lpszTemp )
        LocalFree((HLOCAL) lpszTemp );

    return lpszBuf;
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\srvc\srvccall.cpp ===
// SrvcCall.cpp
// Code to implement the INmCallNotify interface for the remote control service

#include "precomp.h"
#include "srvcutil.h"
#include "srvccall.h"

CSrvcCall::CSrvcCall(INmCall * pNmCall) :
	m_pCall  (pNmCall),
	m_pszName  (NULL),
	m_pszAddr  (NULL),
	m_addrType (NM_ADDR_UNKNOWN),
	m_fSelectedConference (FALSE),
	m_pos      (NULL),
	m_cRef     (1),
	m_dwCookie (0)
{
	HRESULT hr;

	TRACE_OUT(("CSrvcCall: Created %08X (INmCall=%08X)", this, pNmCall));

	ASSERT(NULL != m_pCall);
	m_pCall->AddRef();

	// Get the display name
	BSTR  bstr;
	hr = m_pCall->GetName(&bstr);
	if (SUCCEEDED(hr))
	{
		hr = BSTR_to_LPTSTR(&m_pszName, bstr);
		SysFreeString(bstr);
	}
	if (FEmptySz(m_pszName))
	{
		// Default to "another person" if no name available in the call data
		m_pszName = TEXT("Somebody");
	}

	hr = m_pCall->GetAddr(&bstr, &m_addrType);
	if (SUCCEEDED(hr))
	{
		hr = BSTR_to_LPTSTR(&m_pszAddr, bstr);
		SysFreeString(bstr);
	}

	// These should never change
	m_fIncoming = (m_pCall->IsIncoming() == S_OK);
	m_dwTick = ::GetTickCount();

	Update();

	NmAdvise(m_pCall, this, IID_INmCallNotify, &m_dwCookie);
}

VOID CSrvcCall::RemoveCall(void)
{
	NmUnadvise(m_pCall, IID_INmCallNotify, m_dwCookie);
}

CSrvcCall::~CSrvcCall()
{
	delete m_pszName;
	delete m_pszAddr;

	ASSERT(NULL != m_pCall);
	m_pCall->Release();
}

// IUnknown methods
STDMETHODIMP_(ULONG) CSrvcCall::AddRef(void)
{
	return ++m_cRef;
}

STDMETHODIMP_(ULONG) CSrvcCall::Release(void)
{
	ASSERT(m_cRef > 0);
	if (m_cRef > 0)
	{
		m_cRef--;
	}

	ULONG cRef = m_cRef;

	if (0 == cRef)
	{
		delete this;
	}

	return cRef;
}

STDMETHODIMP CSrvcCall::QueryInterface(REFIID riid, PVOID *ppv)
{
	HRESULT hr = S_OK;

	if ((riid == IID_INmCallNotify) || (riid == IID_IUnknown))
	{
		*ppv = (INmCallNotify *)this;
//		ApiDebugMsg(("CCall::QueryInterface()"));
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
//		ApiDebugMsg(("CCall::QueryInterface(): Called on unknown interface."));
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}

// INmCallNotify methods
STDMETHODIMP CSrvcCall::NmUI(CONFN uNotify)
{
	return S_OK;
}

STDMETHODIMP CSrvcCall::StateChanged(NM_CALL_STATE uState)
{
	// REVIEW: This check should be done outside of this routine
	if (uState == m_State)
	{
		// Don't bother the UI when nothing changes!
		return S_OK;
	}

	Update();

	return S_OK;
}

STDMETHODIMP CSrvcCall::Failed(ULONG uError)
{
	return S_OK;
}

STDMETHODIMP CSrvcCall::Accepted(INmConference *pConference)
{
	return S_OK;
}

// INmCallNotify3 methods
STDMETHODIMP CSrvcCall::CallError(UINT cns)
{
	return S_OK;
}

STDMETHODIMP CSrvcCall::VersionConflict(HRESULT Status, BOOL *pfContinue)
{
	return S_OK;
}

STDMETHODIMP CSrvcCall::RemoteConference(BOOL fMCU, BSTR *pwszConfNames, BSTR *pbstrConfToJoin)
{
	return S_OK;
}

STDMETHODIMP CSrvcCall::RemotePassword(BSTR bstrConference, BSTR *pbstrPassword, BYTE *pb, DWORD cb, BOOL fIsService)
{
	return S_OK;
}

/*  U P D A T E  */
/*-------------------------------------------------------------------------
    %%Function: Update

    Update the cached information about the call
-------------------------------------------------------------------------*/
VOID CSrvcCall::Update(void)
{
	m_pCall->GetState(&m_State);
	// TRACE_OUT(("CCall: New State=%0d for call=%08X", m_State, this));

	switch (m_State)
	{
	case NM_CALL_ACCEPTED:
	case NM_CALL_REJECTED:
	case NM_CALL_CANCELED:

		RemoveCall();
		Release();
		break;

	case NM_CALL_RING:
		m_pCall->Accept();
		break;

	default:
		ERROR_OUT(("CCall::Update: Unknown state %08X", m_State));

	case NM_CALL_INVALID:
	case NM_CALL_INIT:
	case NM_CALL_SEARCH:
	case NM_CALL_WAIT:
		break;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\srvc\srvcutil.cpp ===
// srvcutil.cpp

#include "precomp.h"

/*  B  S  T  R _ T O _  L  P  T  S  T  R  */
/*-------------------------------------------------------------------------
    %%Function: BSTR_to_LPTSTR
    
-------------------------------------------------------------------------*/
HRESULT BSTR_to_LPTSTR(LPTSTR *ppsz, BSTR bstr)
{
#ifndef UNICODE
	// compute the length of the required BSTR
	int cch =  WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, NULL, 0, NULL, NULL);
	if (cch <= 0)
	{
		ERROR_OUT(("WideCharToMultiByte failed"));
		return E_FAIL;
	}

	// cch is the number of BYTES required, including the null terminator
	*ppsz = (LPTSTR) new char[cch];
	if (*ppsz == NULL)
	{
		ERROR_OUT(("WideCharToMultiByte out of memory"));
		return E_OUTOFMEMORY;
	}

	WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, *ppsz, cch, NULL, NULL);
	return S_OK;
#else
	return E_NOTIMPL;
#endif // UNICODE
}

/////////////////////////////////////////////////////////////////////////////
// Connection Point Helpers

HRESULT NmAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw)
{
	IConnectionPointContainer *pCPC;
	IConnectionPoint *pCP;
	HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
	if (SUCCEEDED(hRes))
	{
		hRes = pCPC->FindConnectionPoint(iid, &pCP);
		pCPC->Release();
	}
	if (SUCCEEDED(hRes))
	{
		hRes = pCP->Advise(pUnk, pdw);
		pCP->Release();
	}
	return hRes;
}

HRESULT NmUnadvise(IUnknown* pUnkCP, const IID& iid, DWORD dw)
{
	IConnectionPointContainer *pCPC;
	IConnectionPoint *pCP;
	HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
	if (SUCCEEDED(hRes))
	{
		hRes = pCPC->FindConnectionPoint(iid, &pCP);
		pCPC->Release();
	}
	if (SUCCEEDED(hRes))
	{
		hRes = pCP->Unadvise(dw);
		pCP->Release();
	}
	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\srvc\taskbar.h ===
#ifndef _TASKBAR_H_
#define _TASKBAR_H_

#define ID_TASKBAR_ICON	1000
const UINT WM_TASKBAR_NOTIFY =          WM_USER + 200;

BOOL AddTaskbarIcon(VOID);
BOOL RemoveTaskbarIcon(VOID);
BOOL OnRightClickTaskbar(VOID);
BOOL CmdActivate(VOID);
VOID CmdInActivate(VOID);
#endif // _TASKBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\srvc\taskbar.cpp ===
// File: taskbar.cpp

#include "precomp.h"
#include "taskbar.h"
#include <iappldr.h>
#include <tsecctrl.h>

static HWND g_hwndHidden = NULL;
const TCHAR g_cszHiddenWndClassName[] = _TEXT("MnmSrvcHiddenWindow");
BOOL g_fTaskBarIconAdded = FALSE;
BOOL g_fTimerRunning = FALSE;
extern INmSysInfo2 * g_pNmSysInfo;
extern int g_cPersonsInConf;

// This routine starts a timer to periodically retry adding the taskbar icon.
// This is necessary in case the taskbar is not showing at the time the
// service is launched, or the taskbar is destroyed by a logoff-logon sequence.

VOID StartTaskbarTimer(VOID)
{
    if ( !g_fTimerRunning)
    {
        ASSERT(g_hwndHidden);
        SetTimer(g_hwndHidden, 0, 5000, NULL);
        g_fTimerRunning = TRUE;
    }
}

VOID KillTaskbarTimer(VOID)
{
    if ( g_fTimerRunning )
    {
        KillTimer ( g_hwndHidden, 0 );
        g_fTimerRunning = FALSE;
    }
}

LRESULT CALLBACK HiddenWndProc(    HWND hwnd, UINT uMsg,
                                WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
        case WM_USERCHANGED:
        case WM_ENDSESSION:
            // A user is logging on or off... We don't know which but
            // since the desktop is changing we assume our taskbar icon
            // is toast. Start a timer to periodically try to add it back
            // until it succeeds.
            g_fTaskBarIconAdded = FALSE;
            StartTaskbarTimer();
            break;
            
        case WM_TASKBAR_NOTIFY:
        {
            if (WM_RBUTTONUP == lParam)
            {
                ::OnRightClickTaskbar();
            }
            break;
        }

        case WM_TIMER:
            AddTaskbarIcon();
            break;
        
        case WM_DESTROY:
        {
            // NULL the global variable:
            g_hwndHidden = NULL;
            return 0;
        }

        default:
            return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return FALSE;
}

BOOL CmdActivate(VOID)
{
    RegEntry Re( REMOTECONTROL_KEY, HKEY_LOCAL_MACHINE );
    Re.SetValue ( REMOTE_REG_ACTIVATESERVICE, (DWORD)1 );
    if (MNMServiceActivate())
    { 
        ReportStatusToSCMgr( SERVICE_RUNNING, NO_ERROR, 0);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

VOID CmdInActivate(VOID)
{
    RegEntry Re( REMOTECONTROL_KEY, HKEY_LOCAL_MACHINE );
    Re.SetValue ( REMOTE_REG_ACTIVATESERVICE, (DWORD)0 );
    if (MNMServiceDeActivate())
        ReportStatusToSCMgr( SERVICE_PAUSED, NO_ERROR, 0);
}

VOID CmdSendFiles(VOID)
{
    ASSERT(g_pNmSysInfo);
    if (g_pNmSysInfo)
    {
        g_pNmSysInfo->ProcessSecurityData(LOADFTAPPLET, 0, 0, NULL);
    }
}

VOID CmdShutdown(VOID)
{
    if (STATE_ACTIVE == g_dwActiveState)
    {
        CmdInActivate();
    }
    MNMServiceStop();
    DestroyWindow(g_hwndHidden);
}

BOOL AddTaskbarIcon(VOID)
{
    BOOL bRet = FALSE;
    
    if ( NULL == g_hwndHidden )
    {
        // Register hidden window class:
        WNDCLASS wcHidden =
        {
            0L,
            HiddenWndProc,
            0,
            0,
            GetModuleHandle(NULL),
            NULL,
            NULL,
            NULL,
            NULL,
            g_cszHiddenWndClassName
        };
        
        if (!RegisterClass(&wcHidden))
        {
            ERROR_OUT(("Could not register hidden wnd classes"));
            return FALSE;
        }

        // Create a hidden window for event processing:
        g_hwndHidden = ::CreateWindow(    g_cszHiddenWndClassName,
                                        _TEXT(""),
                                        WS_POPUP, // not visible!
                                        0, 0, 0, 0,
                                        NULL,
                                        NULL,
                                        GetModuleHandle(NULL),
                                        NULL);
    }

    if (NULL == g_hwndHidden)
    {
        ERROR_OUT(("Could not create hidden windows"));
        return FALSE;
    }

    // Place a 16x16 icon in the taskbar notification area:    
    NOTIFYICONDATA tnid;

    tnid.cbSize = sizeof(NOTIFYICONDATA);
    tnid.hWnd = g_hwndHidden;
    tnid.uID = ID_TASKBAR_ICON;
    tnid.uFlags = NIF_MESSAGE | NIF_ICON | NIF_TIP;
    tnid.uCallbackMessage = WM_TASKBAR_NOTIFY;
    tnid.hIcon = LoadIcon(GetModuleHandle(NULL), MAKEINTRESOURCE(IDI_SM_WORLD));

    ::LoadString(GetModuleHandle(NULL), IDS_MNMSRVC_TITLE,
        tnid.szTip, CCHMAX(tnid.szTip));

    // Attempt to add the icon. This may fail because there is no taskbar
    // (no user desktop shown). Warn if this is so... We will retry on
    // a periodic timer.

    if (FALSE == (bRet = Shell_NotifyIcon(NIM_ADD, &tnid)))
    {
        #ifdef DEBUG
        if ( !g_fTimerRunning )
           WARNING_OUT(("Could not add notify icon!"));
        #endif // DEBUG

        // Start the taskbar timer to periodically retry until this succeeds
        StartTaskbarTimer();
    }
    else
    {
        g_fTaskBarIconAdded = TRUE;
        KillTaskbarTimer(); // Kill timer if necessary
    }

    if (NULL != tnid.hIcon)
    {
        DestroyIcon(tnid.hIcon);
    }

    return bRet;
}

BOOL RemoveTaskbarIcon(VOID)
{
    NOTIFYICONDATA tnid;
    BOOL ret;

    if ( !g_fTaskBarIconAdded || NULL == g_hwndHidden )
    {
        return FALSE;
    }

    tnid.cbSize = sizeof(NOTIFYICONDATA);
    tnid.hWnd = g_hwndHidden;
    tnid.uID = ID_TASKBAR_ICON;

    ret = Shell_NotifyIcon(NIM_DELETE, &tnid);

    g_fTaskBarIconAdded = FALSE;
    return ret;
}

BOOL OnRightClickTaskbar()
{
    TRACE_OUT(("OnRightClickTaskbar called"));

    POINT ptClick;
    if (FALSE == ::GetCursorPos(&ptClick))
    {
        ptClick.x = ptClick.y = 0;
    }
    
    // Get the menu for the popup from the resource file.
    HMENU hMenu = ::LoadMenu(GetModuleHandle(NULL), MAKEINTRESOURCE(IDR_TASKBAR_POPUP));
    if (NULL == hMenu)
    {
        return FALSE;
    }

    // Get the first menu in it which we will use for the call to
    // TrackPopup(). This could also have been created on the fly using
    // CreatePopupMenu and then we could have used InsertMenu() or
    // AppendMenu.
    HMENU hMenuTrackPopup = ::GetSubMenu(hMenu, 0);

    RegEntry reLM( REMOTECONTROL_KEY, HKEY_LOCAL_MACHINE);
    BOOL fNoExit = reLM.GetNumber(REMOTE_REG_NOEXIT, DEFAULT_REMOTE_NOEXIT);
    
    ::EnableMenuItem(hMenuTrackPopup, IDM_TBPOPUP_STOP, fNoExit ? MF_GRAYED : MF_ENABLED);
    
    if (STATE_ACTIVE == g_dwActiveState)
    {
        ::EnableMenuItem(hMenuTrackPopup, IDM_TBPOPUP_INACTIVATE, fNoExit ? MF_GRAYED : MF_ENABLED);
        ::EnableMenuItem(hMenuTrackPopup, IDM_TBPOPUP_SENDFILES, (2 == g_cPersonsInConf) ? MF_ENABLED : MF_GRAYED);
    }
    else if (STATE_INACTIVE == g_dwActiveState)
    {
        HANDLE hInit = ::OpenEvent(EVENT_ALL_ACCESS, FALSE, _TEXT("CONF:Init"));

        ::EnableMenuItem(hMenuTrackPopup, IDM_TBPOPUP_ACTIVATE, hInit ?
                                                    MF_GRAYED : MF_ENABLED);
        ::CloseHandle(hInit);
    }
    else
    {
        // Leave all menus grayed
    }

    // Draw and track the "floating" popup 
    // According to the font view code, there is a bug in USER which causes
    // TrackPopupMenu to work incorrectly when the window doesn't have the
    // focus.  The work-around is to temporarily create a hidden window and
    // make it the foreground and focus window.

    HWND hwndDummy = ::CreateWindow(_TEXT("STATIC"), NULL, 0, 
                                    ptClick.x, 
                                    ptClick.y,
                                    1, 1, HWND_DESKTOP,
                                    NULL, GetModuleHandle(NULL), NULL);
    if (NULL != hwndDummy)
    {
        HWND hwndPrev = ::GetForegroundWindow();    // to restore

        TPMPARAMS tpmp;
        tpmp.cbSize = sizeof(tpmp);
        tpmp.rcExclude.right = 1 + (tpmp.rcExclude.left = ptClick.x);
        tpmp.rcExclude.bottom = 1 + (tpmp.rcExclude.top = ptClick.y);
        
        ::SetForegroundWindow(hwndDummy);
        ::SetFocus(hwndDummy);

        int iRet = ::TrackPopupMenuEx(    hMenuTrackPopup, 
                                                TPM_RETURNCMD | TPM_HORIZONTAL | TPM_RIGHTALIGN | 
                                                TPM_RIGHTBUTTON | TPM_LEFTBUTTON,
                                                ptClick.x, 
                                                ptClick.y,
                                                hwndDummy, 
                                                &tpmp);

        // Restore the previous foreground window (before destroying hwndDummy).
        if (hwndPrev)
        {
            ::SetForegroundWindow(hwndPrev);
        }

        ::DestroyWindow(hwndDummy);

        switch (iRet)
        {
                    case IDM_TBPOPUP_ACTIVATE:
                    {
                        CmdActivate();
                        break;
                    }
                    case IDM_TBPOPUP_INACTIVATE:
                    {
                        CmdInActivate();
                        break;
                    }
                    case IDM_TBPOPUP_SENDFILES:
                    {
                        CmdSendFiles();
                        break;
                    }
                    case IDM_TBPOPUP_STOP:
                    {
                        CmdShutdown();
                        break;
                    }
                    default:
                        break;
        }
    }

    // We are finished with the menu now, so destroy it
    ::RemoveMenu(hMenu, 0, MF_BYPOSITION);
    ::DestroyMenu(hMenuTrackPopup);
    ::DestroyMenu(hMenu);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\srvc\srvcutil.h ===
// srvcutil.h

HRESULT BSTR_to_LPTSTR(LPTSTR *ppsz, BSTR bstr);

HRESULT NmAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw);
HRESULT NmUnadvise(IUnknown* pUnkCP, const IID& iid, DWORD dw);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\common\appcap.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_UTILITY);

/* 
 *	appcap.cpp
 *
 *	Copyright (c) 1994 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the class CAppCap. 
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */

#include "appcap.h"
#include "clists.h"


/*
 *	CAppCap ()
 *
 *	Public Function Description:
 *		This constructor is used to create a AppCapabilityData object 
 * 		from an "API" GCCApplicationCapability list.
 */
CAppCap::CAppCap(UINT   						number_of_capabilities,
				PGCCApplicationCapability		*	capabilities_list,
				PGCCError							pRetCode)
:
    CRefCount(MAKE_STAMP_ID('A','C','a','p')),
    m_AppCapItemList(DESIRED_MAX_CAPS),
    m_cbDataSize(0)
{
	APP_CAP_ITEM    *pAppCapItem;
	UINT			i;
	GCCError        rc;

	rc = GCC_NO_ERROR;

	for (i = 0; i < number_of_capabilities; i++)
	{
		DBG_SAVE_FILE_LINE
		pAppCapItem = new APP_CAP_ITEM((GCCCapabilityType) capabilities_list[i]->capability_class.eType);
		if (pAppCapItem != NULL)
		{
			DBG_SAVE_FILE_LINE
			pAppCapItem->pCapID = new CCapIDContainer(
			                                &capabilities_list[i]->capability_id,
			                                &rc);
			if ((pAppCapItem->pCapID != NULL) && (rc == GCC_NO_ERROR))
			{
				if (capabilities_list[i]->capability_class.eType ==
										GCC_UNSIGNED_MINIMUM_CAPABILITY)
				{
					pAppCapItem->nUnsignedMinimum =
							capabilities_list[i]->capability_class.nMinOrMax;
				}
				else if	(capabilities_list[i]->capability_class.eType 
									== GCC_UNSIGNED_MAXIMUM_CAPABILITY)
				{
					pAppCapItem->nUnsignedMaximum =
							capabilities_list[i]->capability_class.nMinOrMax;
				}

				pAppCapItem->cEntries = 1;

				/*
				 * Add this capability to the list.
				 */
				m_AppCapItemList.Append(pAppCapItem);
			}
			else if (pAppCapItem->pCapID == NULL)
			{
				rc = GCC_ALLOCATION_FAILURE;
			}
			else
			{
				delete pAppCapItem;
			}
		}
		else
		{
			rc = GCC_ALLOCATION_FAILURE;
		}

		if (rc != GCC_NO_ERROR)
			break;
	}

    *pRetCode = rc;
}

/*
 *	~CAppCap()
 *
 *	Public Function Description
 *		The CAppCap destructor is responsible for freeing 
 *		any memory allocated to hold the capability data.
 *
 */
CAppCap::~CAppCap(void)
{
	m_AppCapItemList.DeleteList();
}

/*
 *	LockCapabilityData ()
 *
 *	Public Function Description:
 *		This routine locks the capability data and determines the amount of
 *		memory referenced by the "API" non-collapsing capability data structure.
 */
UINT CAppCap::LockCapabilityData(void)
{
	/*
	 * If this is the first time this routine is called, determine the size of 
	 * the memory required to hold the data referenced by the list of
	 * capabilities.  Otherwise, just increment the lock count.
	 */
	if (Lock() == 1)
	{
		APP_CAP_ITEM    *pAppCapItem;
		/*
		 * Add the amount of memory necessary to hold the string data associated
		 * with each capability ID.
		 */
		m_AppCapItemList.Reset();

		/*
		 * Lock the data for each capability ID.  The lock call	returns the 
		 * length of the data referenced by each capability ID rounded to occupy
		 * an even multiple of four-bytes.
		 */
		while (NULL != (pAppCapItem = m_AppCapItemList.Iterate()))
		{
			m_cbDataSize += pAppCapItem->pCapID->LockCapabilityIdentifierData();
		}

		/*
		 * Add the memory to hold the application capability pointers
		 * and structures.
		 */
		m_cbDataSize += m_AppCapItemList.GetCount() * 
				(sizeof (PGCCApplicationCapability) +
				ROUNDTOBOUNDARY( sizeof(GCCApplicationCapability)) );
	}

	return m_cbDataSize;
}

/*
 *	GetGCCApplicationCapabilityList ()
 *
 *	Public Function Description:
 *		This routine retrieves the application capabilities list in the form of
 * 		a list of PGCCApplicationCapability's.	This routine is called after 
 * 		"locking" the capability data.
 */
UINT CAppCap::GetGCCApplicationCapabilityList(
						PUShort							number_of_capabilities,
						PGCCApplicationCapability  * *	capabilities_list,
						LPBYTE							memory)
{
	UINT cbDataSizeToRet = 0;

	/*
	 * If the capability data has been locked, fill in the output structure and
	 * the data referenced by the structure.
	 */ 
	if (GetLockCount() > 0)
	{
    	UINT								data_length = 0;
    	UINT								capability_id_data_length = 0;
    	USHORT								capability_count;
    	PGCCApplicationCapability			gcc_capability;
    	PGCCApplicationCapability		*	gcc_capability_list;
    	APP_CAP_ITEM                        *pAppCapItem;

		/*
		 * Fill in the output length parameter which indicates how much data
		 * referenced outside the structure will be written.
		 */
		cbDataSizeToRet = m_cbDataSize;

		/*
		 * Retrieve the number of capabilities and fill in any that are present.
		 */
		*number_of_capabilities = (USHORT) m_AppCapItemList.GetCount();

		if (*number_of_capabilities != 0)
		{
			/*
			 * Fill in the pointer to the list of application capability
			 * pointers.  The pointer list will begin at the memory location 
			 * passed into this routine.  Save the list pointer in a local 
			 * variable for convenience.
			 */
			*capabilities_list = (PGCCApplicationCapability *)memory;
			gcc_capability_list = *capabilities_list;

			/*
			 * Move the memory pointer past the list of capability pointers.
			 * This	is where the first application capability structure will be
			 * written.
			 */
			memory += (*number_of_capabilities * sizeof(PGCCApplicationCapability));

			/*
			 * Add to the data length the amount of memory necessary to hold the
			 * application capability pointers.  Go ahead and add the amount of 
			 * memory necessary to hold all of the GCCApplicationCapability 
			 * structures.
			 */
			data_length += *number_of_capabilities *
					(sizeof(PGCCApplicationCapability) + 
					ROUNDTOBOUNDARY ( sizeof(GCCApplicationCapability)) ); 

			/*
			 * Iterate through the capabilities list, building an "API"
			 * capability for each capability in the list.
			 */
			capability_count = 0;
			m_AppCapItemList.Reset();
			while (NULL != (pAppCapItem = m_AppCapItemList.Iterate()))
			{
				/*
				 * Set the application capability pointer equal to the
				 * location in memory where it will be written.
				 */
				gcc_capability = (PGCCApplicationCapability)memory;

				/*
				 * Save the pointer to the application capability in the
				 * list of application capability pointers.
				 */
				gcc_capability_list[capability_count] = gcc_capability;

				/*
				 * Advance the memory pointer past the application capability
				 * structure.  This is where the string data for the capability
				 * ID will be written.  Ensure that the memory pointer falls on 
				 * an even four-byte boundary.
				 */
				memory += ROUNDTOBOUNDARY(sizeof(GCCApplicationCapability));

				/*
				 * Retrieve the capability ID information from the internal 
				 * CapabilityIDData object.  The length returned by this call 
				 * will	have already been rounded to an even multiple of four 
				 * bytes.
				 */
				capability_id_data_length = pAppCapItem->pCapID->
						GetGCCCapabilityIDData(&gcc_capability->capability_id, memory);

				/*
				 * Advance the memory pointer past the string data written into 
				 * memory by the capability ID object.  Add the length of the 
				 * string data to the overall capability length.
				 */
				memory += capability_id_data_length;
				data_length += capability_id_data_length;

				/*
				 * Now fill in the rest of the capability.
				 */
				gcc_capability->capability_class.eType = pAppCapItem->eCapType;

				if (gcc_capability->capability_class.eType ==
										GCC_UNSIGNED_MINIMUM_CAPABILITY)
				{
					gcc_capability->capability_class.nMinOrMax =
						pAppCapItem->nUnsignedMinimum;
				}
				else if (gcc_capability->capability_class.eType ==
										GCC_UNSIGNED_MAXIMUM_CAPABILITY)
				{
					gcc_capability->capability_class.nMinOrMax =
						pAppCapItem->nUnsignedMaximum;
				}

				gcc_capability->number_of_entities = pAppCapItem->cEntries;

				/*
				 * Increment the capability array counter.
				 */
				capability_count++;
			}
		}
		else
		{
			cbDataSizeToRet = 0;
	  		capabilities_list = NULL;
		}
	}
	else
	{
		ERROR_OUT(("CAppCap::GetData: Error: data not locked"));
	}

	return (cbDataSizeToRet);
}

/*
 *	UnLockCapabilityData ()
 *
 *	Public Function Description:
 *		This routine decrements the lock count and frees the memory associated 
 *		with the "API" capability once the lock count reaches zero.
 */
void CAppCap::UnLockCapabilityData(void)
{
	if (Unlock(FALSE) == 0)
	{
		APP_CAP_ITEM    *pAppCapItem;
		/*
		 * Iterate through the list of collapsed capabilities, unlocking the
		 * data for each CapabilityIDData object associated with each 
		 * capability.
		 */
		m_AppCapItemList.Reset();
		while (NULL != (pAppCapItem = m_AppCapItemList.Iterate()))
		{
			pAppCapItem->pCapID->UnLockCapabilityIdentifierData();
		}
	}

    // we have to call Release() because we used Unlock(FALSE)
    Release();
}



APP_CAP_ITEM::APP_CAP_ITEM(GCCCapabilityType eCapType)
:
	pCapID(NULL),
	eCapType(eCapType),
	cEntries(0),
	poszAppData(NULL)
{
}

APP_CAP_ITEM::APP_CAP_ITEM(APP_CAP_ITEM *p, PGCCError pError)
	:	poszAppData(NULL)
{
	//	First set up the capability id
	DBG_SAVE_FILE_LINE
	pCapID = new CCapIDContainer(p->pCapID, pError);
	if (NULL != pCapID)
	{
		//	Initialize the new capability to default values.
		eCapType = p->eCapType;

		if (p->eCapType == GCC_UNSIGNED_MINIMUM_CAPABILITY)
		{
			nUnsignedMinimum = (UINT) -1;
		}
		else if (p->eCapType == GCC_UNSIGNED_MAXIMUM_CAPABILITY)
		{
			nUnsignedMaximum = 0;
		}

		cEntries = p->cEntries;
        //
		// LONCHANC: We do not copy the entries in application data???
        //

		*pError = GCC_NO_ERROR;
	}
	else
	{
		*pError = GCC_ALLOCATION_FAILURE;
	}
}


APP_CAP_ITEM::~APP_CAP_ITEM(void)
{
    if (NULL != pCapID)
    {
        pCapID->Release();
    }

    delete poszAppData;
}


void CAppCapItemList::DeleteList(void)
{
    APP_CAP_ITEM *pAppCapItem;
    while (NULL != (pAppCapItem = Get()))
    {
        delete pAppCapItem;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\common\appenrol.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_UTILITY);
/* 
 *	appenrol.cpp
 *
 *	Copyright (c) 1994 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the class 
 *		ApplicationEnrollRequestData. 
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */

#include "appenrol.h"

/*
 *	ApplicationEnrollRequestData ()
 *
 *	Public Function Description:
 *		This constructor is used to create a ApplicationEnrollRequestData object
 *		from an ApplicationEnrollRequestMessage in preparation for serializing
 *		the application enroll request data.
 */
ApplicationEnrollRequestData::ApplicationEnrollRequestData(
				PApplicationEnrollRequestMessage		enroll_request_message,
				PGCCError								pRetCode)
{
    GCCError rc = GCC_NO_ERROR;
	Session_Key_Data = NULL;
	Non_Collapsing_Caps_Data = NULL;
	Application_Capability_Data = NULL;

	/*
	 * Save the message structure in an instance variable.  This will save all
	 * structure elements except the session key and the lists of non-collapsing
	 * and application capabilities.
	 */
	Enroll_Request_Message = *enroll_request_message;

	/*
	 * Create a CSessKeyContainer object to be used to handle the session key
	 * contained in the enroll request message.
	 */
	if (Enroll_Request_Message.session_key != NULL)
	{
		DBG_SAVE_FILE_LINE
		Session_Key_Data = new CSessKeyContainer(
										Enroll_Request_Message.session_key,
										&rc);
		if ((Session_Key_Data != NULL) && (rc == GCC_NO_ERROR))
		{
			if (Enroll_Request_Message.number_of_non_collapsed_caps != 0)
			{
				/*
				 * Create a CNonCollAppCap object to hold the non-
				 * collapsing capabilities.
				 */
				DBG_SAVE_FILE_LINE
				Non_Collapsing_Caps_Data = new CNonCollAppCap(	
							(ULONG) Enroll_Request_Message.number_of_non_collapsed_caps,
							Enroll_Request_Message.non_collapsed_caps_list,
							&rc);
				if (Non_Collapsing_Caps_Data == NULL)
				{
					rc = GCC_ALLOCATION_FAILURE;
				}
				else if (rc != GCC_NO_ERROR)
				{
				    Non_Collapsing_Caps_Data->Release();
				    Non_Collapsing_Caps_Data = NULL;
				}
			}
			else
			{
				Non_Collapsing_Caps_Data = NULL;
			}

			if ((rc == GCC_NO_ERROR) &&
				(Enroll_Request_Message.number_of_collapsed_caps != 0))
			{
				/*
				 * Create an CAppCap object to hold the
				 * application capabilities.
				 */
				DBG_SAVE_FILE_LINE
				Application_Capability_Data = new CAppCap(
							(ULONG) Enroll_Request_Message.number_of_collapsed_caps,
							Enroll_Request_Message.collapsed_caps_list,
							&rc);
				if (Application_Capability_Data == NULL)
				{
					rc = GCC_ALLOCATION_FAILURE;
				}
				else if (rc != GCC_NO_ERROR)
				{
				    Application_Capability_Data->Release();
				    Application_Capability_Data = NULL;
				}
			}
			else
			{
				Application_Capability_Data = NULL;
			}
		}
		else if (Session_Key_Data == NULL)
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
		else
		{
		    Session_Key_Data->Release();
		    Session_Key_Data = NULL;
		}
	}
	else
	{
		Session_Key_Data = NULL;
		Application_Capability_Data = NULL;
		Non_Collapsing_Caps_Data = NULL;

		/*
		**	Note that if no session key is present there is no need to pass
		**	any capability information.
		*/
		Enroll_Request_Message.number_of_non_collapsed_caps = 0;
		Enroll_Request_Message.non_collapsed_caps_list = NULL;
		Enroll_Request_Message.number_of_collapsed_caps = 0;
		Enroll_Request_Message.collapsed_caps_list = NULL;
	}

    *pRetCode = rc;
}

/*
 *	ApplicationEnrollRequestData ()
 *
 *	Public Function Description:
 *		This constructor is used to create a ApplicationEnrollRequestData object
 *		from an ApplicationEnrollRequestMessage and the memory holding the
 *		enroll request's serialized data in preparation for deserializing
 *		the application enroll request data.
 */
ApplicationEnrollRequestData::ApplicationEnrollRequestData(
				PApplicationEnrollRequestMessage		enroll_request_message)
{
	Session_Key_Data = NULL;
	Non_Collapsing_Caps_Data = NULL;
	Application_Capability_Data = NULL;

	/*
	 * Save the message structure in an instance variable.  This will save all
	 * structure elements but not the data associated with the session key and 
	 * the lists of non-collapsing and application capabilities.
	 */
	Enroll_Request_Message = *enroll_request_message;

}

/*
 *	~ApplicationEnrollRequestData	()
 *
 *	Public Function Description
 *		The ApplicationEnrollRequestData destructor.
 *
 */
ApplicationEnrollRequestData::~ApplicationEnrollRequestData()
{
	/*
	 * Delete any internal data objects which may exist.
	 */
	if (NULL != Session_Key_Data)
	{
	    Session_Key_Data->Release();
	}

	if (NULL != Non_Collapsing_Caps_Data)
	{
	    Non_Collapsing_Caps_Data->Release();
	}

	if (NULL != Application_Capability_Data)
	{
	    Application_Capability_Data->Release();
	}
}

/*
 *	GetDataSize ()
 *
 *	Public Function Description
 *		This routine is used to determine the amount of memory necessary to
 *		hold all of the data associated with an ApplicationEnrollRequestMessage
 *		that is not held within the message strucuture.
 */
ULONG ApplicationEnrollRequestData::GetDataSize(void)
{
	ULONG data_size = 0;

	/*
	 * The first data referenced by the enroll request message is the data for
	 * the session key.  Use the internal CSessKeyContainer object to determine
	 * the length of the data referenced by the session key.  Also add the size
	 * of the actual session key structure.
	 */
	if (Session_Key_Data != NULL)
	{
		data_size += Session_Key_Data->LockSessionKeyData();
		data_size += ROUNDTOBOUNDARY (sizeof(GCCSessionKey));
	}

	/*
	 * Now determine the length of the list of non-collapsing capabilities and
	 * the length of the list of application capabilities.  This is done using
	 * the internal CNonCollAppCap and CAppCap objects.
	 */
	if (Non_Collapsing_Caps_Data != NULL)
	{
		data_size += Non_Collapsing_Caps_Data->LockCapabilityData();
	}

	if (Application_Capability_Data != NULL)
	{
		data_size += Application_Capability_Data->LockCapabilityData();
	}

	return (data_size);
}

/*
 *	Serialize ()
 *
 *	Public Function Description
 *		This routine is used to prepare an ApplicationEnrollRequest message
 *		for passing through shared memory.  The message structure is filled in
 *		and the data referenced by the structure written into the memory
 *		provided.
 */
ULONG ApplicationEnrollRequestData::Serialize(
					PApplicationEnrollRequestMessage	enroll_request_message,
	  				LPSTR								memory)
{
	ULONG	data_length;
	ULONG	total_data_length = 0;
	USHORT	app_capability_data_length;

	/*
	 * Copy the internal message structure into the output structure.  This will
	 * copy all	structure elements except the session key and the lists of 
	 * non-collapsing and application capabilities.
	 */
	*enroll_request_message = Enroll_Request_Message;

	if (Session_Key_Data != NULL)
	{
		/*
		 * Set the pointer to the session key structure.
		 */
		enroll_request_message->session_key = (PGCCSessionKey)memory;

		/*
		 * Move the memory pointer past the session key structure.
		 */
		memory += ROUNDTOBOUNDARY(sizeof(GCCSessionKey));

		/*
		 * Retrieve the session key data from the internal CSessKeyContainer 
		 * object.  It will serialize the necessary data into memory and return 
		 * the amount of data written.
		 */
		data_length = Session_Key_Data->GetGCCSessionKeyData (
								enroll_request_message->session_key, memory);

		total_data_length = data_length + ROUNDTOBOUNDARY(sizeof(GCCSessionKey));

		/*
		 * Move the memory pointer past the session key data.
		 */
		memory += data_length;
		Session_Key_Data->UnLockSessionKeyData();
	}
	else
    {
		enroll_request_message->session_key = NULL;
    }

	/*
	 * Retrieve the non-collapsing capabilities data from the internal
	 * CNonCollAppCap object.  It will serialize the necessary data
	 * into memory and return the amount of memory written.
	 */
	if (Non_Collapsing_Caps_Data != NULL)
	{
		data_length = Non_Collapsing_Caps_Data->GetGCCNonCollapsingCapsList (	
			&enroll_request_message->non_collapsed_caps_list,
			memory);
	
		total_data_length += data_length;

		/*
		 * Move the memory pointer past the non-collapsing capabilities and the
		 * associated data.
		 */
		memory += data_length;
		Non_Collapsing_Caps_Data->UnLockCapabilityData();
	}
	else
    {
		enroll_request_message->non_collapsed_caps_list = NULL;
    }
	
	if (Application_Capability_Data != NULL)
	{
		/*
		 * Retrieve the application capabilities from the internal 
		 * CAppCap object.  It will serialize the necessary data
		 * into memory and return the amount of memory written.
		 */
		total_data_length += Application_Capability_Data->
				GetGCCApplicationCapabilityList(
					&app_capability_data_length,
					&enroll_request_message->collapsed_caps_list,
					memory);
		Application_Capability_Data->UnLockCapabilityData();
	}

	diagprint1("AppEnrollReqData: Serialized %ld bytes", total_data_length);
	return (total_data_length);
}

/*
 *	Deserialize ()
 *
 *	Public Function Description
 *		This routine is used to retrieve an ApplicationEnrollRequest message
 *		after it has been passed through shared memory.
 */
void ApplicationEnrollRequestData::Deserialize(
					PApplicationEnrollRequestMessage	enroll_request_message)
{
	/*
	 * The internal structure contains the enroll request data with the pointers
	 * addressing the correct locations in memory so just copy the structure
	 * into the output parameter.
	 */
	*enroll_request_message = Enroll_Request_Message; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\common\cntlist.cpp ===
#include "precomp.h"
#include "cntlist.h"


CList::CList(void)
:
    m_fQueue(FALSE),
    m_cMaxEntries(CLIST_DEFAULT_MAX_ITEMS)
{
    Init(1);
}


CList::CList(ULONG cMaxItems)
:
    m_fQueue(FALSE),
    m_cMaxEntries(cMaxItems)
{
    Init(1);
}


CList::CList(ULONG cMaxItems, ULONG cSubItems)
:
    m_fQueue(FALSE),
    m_cMaxEntries(cMaxItems)
{
    Init(cSubItems);
}


CList::CList(ULONG cMaxItems, ULONG cSubItems, BOOL fQueue)
:
    m_fQueue(fQueue),
    m_cMaxEntries(cMaxItems)
{
    Init(cSubItems);
}


CList::CList(CList *pSrc)
:
    m_fQueue(pSrc->m_fQueue),
    m_cMaxEntries(pSrc->GetCount())
{

    Init(1);

    LPVOID p;
    pSrc->Reset();
    while (NULL != (p = pSrc->Iterate()))
    {
        Append(p);
    }
}


BOOL CList::Init(ULONG cSubItems)
{
    if (m_cMaxEntries < CLIST_DEFAULT_MAX_ITEMS)
    {
        m_cMaxEntries = CLIST_DEFAULT_MAX_ITEMS;
    }

    m_cEntries = 0;
    m_nHeadOffset = 0;
    m_nCurrOffset = CLIST_END_OF_ARRAY_MARK;
    m_cSubItems = cSubItems;

    // it is kind of bad here because there is no way to return an error.
    // unfortunately it won't fault here and later.
    DBG_SAVE_FILE_LINE
    m_aEntries = (LPVOID *) new char[m_cMaxEntries * m_cSubItems * sizeof(LPVOID)];
    CalcKeyArray();
    return m_aEntries ? TRUE : FALSE;
}


CList::~CList(void)
{
    delete m_aEntries;
}


void CList::CalcKeyArray(void)
{
    if (1 == m_cSubItems)
    {
        m_aKeys = NULL;
    }
    else
    {
        ASSERT(2 == m_cSubItems);
        m_aKeys = (NULL != m_aEntries) ?
                        (UINT_PTR *) &m_aEntries[m_cMaxEntries] :
                        NULL;
    }
}


BOOL CList::Expand(void)
{
    if (NULL == m_aEntries)
    {
        // it is impossible.
        ASSERT(FALSE);
        return Init(m_cSubItems);
    }

    // the current array is full
    ASSERT(m_cEntries == m_cMaxEntries);

    // remember the old array to free or to restore
    LPVOID  *aOldEntries = m_aEntries;

    // we need to allocate a bigger array to hold more data.
    // the new array has twice the size of the old one
    ULONG cNewMaxEntries = m_cMaxEntries << 1;
    DBG_SAVE_FILE_LINE
    m_aEntries = (LPVOID *) new char[cNewMaxEntries * m_cSubItems * sizeof(LPVOID)];
    if (NULL == m_aEntries)
    {
        // we failed; we have to restore the array and return
        m_aEntries = aOldEntries;
        return FALSE;
    }

    // copy the old entries into the new array, starting from the beginning
    ULONG nIdx = m_cMaxEntries - m_nHeadOffset;
    ::CopyMemory(m_aEntries, &aOldEntries[m_nHeadOffset], nIdx * sizeof(LPVOID));
    ::CopyMemory(&m_aEntries[nIdx], aOldEntries, m_nHeadOffset * sizeof(LPVOID));

    // set the new max entries (required for the key array)
    m_cMaxEntries = cNewMaxEntries;

    if (m_cSubItems > 1)
    {
        ASSERT(2 == m_cSubItems);
        UINT_PTR *aOldKeys = m_aKeys;
        CalcKeyArray();
        ::CopyMemory(m_aKeys, &aOldKeys[m_nHeadOffset], nIdx * sizeof(UINT));
        ::CopyMemory(&m_aKeys[nIdx], aOldKeys, m_nHeadOffset * sizeof(UINT));
    }

    // Free the old array of entries
    delete aOldEntries;

    // Set the instance variables
    m_nHeadOffset = 0;
    m_nCurrOffset = CLIST_END_OF_ARRAY_MARK;

    return TRUE;
}


BOOL CList::Append(LPVOID pData)
{
    if (NULL == m_aEntries || m_cEntries >= m_cMaxEntries)
    {
        if (! Expand())
        {
            return FALSE;
        }
    }

    ASSERT(NULL != m_aEntries);
    ASSERT(m_cEntries < m_cMaxEntries);

    m_aEntries[(m_nHeadOffset + (m_cEntries++)) % m_cMaxEntries] = pData;

    return TRUE;
}


BOOL CList::Prepend(LPVOID pData)
{
    if (NULL == m_aEntries || m_cEntries >= m_cMaxEntries)
    {
        if (! Expand())
        {
            return FALSE;
        }
    }

    ASSERT(NULL != m_aEntries);
    ASSERT(m_cEntries < m_cMaxEntries);

    m_cEntries++;
    m_nHeadOffset = (0 == m_nHeadOffset) ? m_cMaxEntries - 1 : m_nHeadOffset - 1;
    m_aEntries[m_nHeadOffset] = pData;

    return TRUE;
}


BOOL CList::Find(LPVOID pData)
{
    for (ULONG i = 0; i < m_cEntries; i++)
    {
        if (pData == m_aEntries[(m_nHeadOffset + i) % m_cMaxEntries])
        {
            return TRUE;
        }
    }
    return FALSE;
}


BOOL CList::Remove(LPVOID pData)
{
    ULONG nIdx, nIdxSrc;
    for (ULONG i = 0; i < m_cEntries; i++)
    {
        nIdx = (m_nHeadOffset + i) % m_cMaxEntries;
        if (pData == m_aEntries[nIdx])
        {
            if (! m_fQueue)
            {
                // to remove the current, we simply move the last to here.
                nIdxSrc = (m_nHeadOffset + (m_cEntries - 1)) % m_cMaxEntries;
                m_aEntries[nIdx] = m_aEntries[nIdxSrc];
                if (m_cSubItems > 1)
                {
                    ASSERT(2 == m_cSubItems);
                    m_aKeys[nIdx] = m_aKeys[nIdxSrc];
                }
            }
            else
            {
                // to preserve the ordering
                if (0 == i)
                {
                    m_nHeadOffset = (m_nHeadOffset + 1) % m_cMaxEntries;
                }
                else
                {
                    for (ULONG j = i + 1; j < m_cEntries; j++)
                    {
                        nIdx = (m_nHeadOffset + j - 1) % m_cMaxEntries;
                        nIdxSrc = (m_nHeadOffset + j) % m_cMaxEntries;
                        m_aEntries[nIdx] = m_aEntries[nIdxSrc];
                        if (m_cSubItems > 1)
                        {
                            ASSERT(2 == m_cSubItems);
                            m_aKeys[nIdx] = m_aKeys[nIdxSrc];
                        }
                    }
                }
            }

            m_cEntries--;
            return TRUE;
        }
    }
    return FALSE;
}


LPVOID CList::Get(void)
{
    LPVOID pRet = NULL;

    if (m_cEntries > 0)
    {
        pRet = m_aEntries[m_nHeadOffset];
        m_cEntries--;
        m_nHeadOffset = (m_nHeadOffset + 1) % m_cMaxEntries;
    }
    else
    {
        pRet = NULL;
    }
    return pRet;
}


LPVOID CList::Iterate(void)
{
    if (0 == m_cEntries)
    {
        return NULL;
    }

    if (m_nCurrOffset == CLIST_END_OF_ARRAY_MARK)
    {
        // start from the beginning
        m_nCurrOffset = 0;
    }
    else
    {
        if (++m_nCurrOffset >= m_cEntries)
        {
            // reset the iterator
            m_nCurrOffset = CLIST_END_OF_ARRAY_MARK;
            return NULL;
        }
    }

    return m_aEntries[(m_nHeadOffset + m_nCurrOffset) % m_cMaxEntries];
}





CList2::CList2(CList2 *pSrc)
:
    CList(pSrc->GetCount(), 2, pSrc->m_fQueue)
{
    CalcKeyArray();

    LPVOID p;
    UINT_PTR n;
    pSrc->Reset();
    while (NULL != (p = pSrc->Iterate(&n)))
    {
        Append(n, p);
    }
}


BOOL CList2::Append(UINT_PTR nKey, LPVOID pData)
{
    if (! CList::Append(pData))
    {
        return FALSE;
    }

    // after CList::append(), m_cEntries has been incremented,
    // therefore, we need decrement it again.
    m_aKeys[(m_nHeadOffset + (m_cEntries - 1)) % m_cMaxEntries] = nKey;
    return TRUE;
}


BOOL CList2::Prepend(UINT_PTR nKey, LPVOID pData)
{
    if (! CList::Prepend(pData))
    {
        return FALSE;
    }

    m_aKeys[m_nHeadOffset] = nKey;
    return TRUE;
}


LPVOID CList2::Find(UINT_PTR nKey)
{
    ULONG nIdx;
    for (ULONG i = 0; i < m_cEntries; i++)
    {
        nIdx = (m_nHeadOffset + i) % m_cMaxEntries;
        if (nKey == m_aKeys[nIdx])
        {
            return m_aEntries[nIdx];
        }
    }
    return NULL;
}


LPVOID CList2::Remove(UINT_PTR nKey)
{
    ULONG nIdx, nIdxSrc;
    for (ULONG i = 0; i < m_cEntries; i++)
    {
        nIdx = (m_nHeadOffset + i) % m_cMaxEntries;
        if (nKey == m_aKeys[nIdx])
        {
            LPVOID pRet = m_aEntries[nIdx];
            if (! m_fQueue)
            {
                // to remove the current, we simply move the last to here.
                nIdxSrc = (m_nHeadOffset + (m_cEntries - 1)) % m_cMaxEntries;
                m_aEntries[nIdx] = m_aEntries[nIdxSrc];
                m_aKeys[nIdx] = m_aKeys[nIdxSrc];
            }
            else
            {
                // to preserve the ordering
                if (0 == i)
                {
                    m_nHeadOffset = (m_nHeadOffset + 1) % m_cMaxEntries;
                }
                else
                {
                    for (ULONG j = i + 1; j < m_cEntries; j++)
                    {
                        nIdx = (m_nHeadOffset + j - 1) % m_cMaxEntries;
                        nIdxSrc = (m_nHeadOffset + j) % m_cMaxEntries;
                        m_aEntries[nIdx] = m_aEntries[nIdxSrc];
                        m_aKeys[nIdx] = m_aKeys[nIdxSrc];
                    }
                }
            }

            m_cEntries--;
            return pRet;
        }
    }
    return NULL;
}


LPVOID CList2::Get(UINT_PTR *pnKey)
{
    LPVOID pRet;
    if (m_cEntries > 0)
    {
        pRet = m_aEntries[m_nHeadOffset];
        *pnKey = m_aKeys[m_nHeadOffset];
        m_cEntries--;
        m_nHeadOffset = (m_nHeadOffset + 1) % m_cMaxEntries;
    }
    else
    {
        pRet = NULL;
        *pnKey = 0;
    }
    return pRet;
}


LPVOID CList2::PeekHead(UINT_PTR *pnKey)
{
    LPVOID pRet;
    if (m_cEntries > 0)
    {
        pRet = m_aEntries[m_nHeadOffset];
        *pnKey = m_aKeys[m_nHeadOffset];
    }
    else
    {
        pRet = NULL;
        *pnKey = 0;
    }
    return pRet;
}


LPVOID CList2::Iterate(UINT_PTR *pnKey)
{
    LPVOID p = CList::Iterate();
    *pnKey = (NULL != p) ? m_aKeys[(m_nHeadOffset + m_nCurrOffset) % m_cMaxEntries] : 0;
    return p;
}





#ifdef ENABLE_HASHED_LIST2

CHashedList2::CHashedList2(ULONG cBuckets, ULONG cInitItemsPerBucket)
:
    m_cBuckets(cBuckets),
    m_cInitItemsPerBucket(cInitItemsPerBucket),
    m_cEntries(0),
    m_nCurrBucket(0)
{
    m_aBuckets = new CList2* [m_cBuckets];
    ASSERT(NULL != m_aBuckets);
    if (NULL != m_aBuckets)
    {
        ::ZeroMemory(m_aBuckets, m_cBuckets * sizeof(CList2*));
    }
}


CHashedList2::CHashedList2(CHashedList2 *pSrc)
:
    m_cBuckets(pSrc->m_cBuckets),
    m_cInitItemsPerBucket(pSrc->m_cInitItemsPerBucket),
    m_cEntries(0),
    m_nCurrBucket(0)
{
    LPVOID p;
    UINT n;

    m_aBuckets = new CList2* [m_cBuckets];
    ASSERT(NULL != m_aBuckets);
    if (NULL != m_aBuckets)
    {
        ::ZeroMemory(m_aBuckets, m_cBuckets * sizeof(CList2*));
        pSrc->Reset();
        while (NULL != (p = pSrc->Iterate(&n)))
        {
            Insert(n, p);
        }
    }
}


CHashedList2::~CHashedList2(void)
{
    if (NULL != m_aBuckets)
    {
        for (ULONG i = 0; i < m_cBuckets; i++)
        {
            delete m_aBuckets[i];
        }
        delete [] m_aBuckets;
    }
}


BOOL CHashedList2::Insert(UINT nKey, LPVOID pData)
{
    if (NULL != m_aBuckets)
    {
        ULONG nBucket = GetHashValue(nKey);
        if (NULL == m_aBuckets[nBucket])
        {
            m_aBuckets[nBucket] = new CList2(m_cInitItemsPerBucket);
        }
        ASSERT(NULL != m_aBuckets[nBucket]);
        if (NULL != m_aBuckets[nBucket])
        {
            if (m_aBuckets[nBucket]->Append(nKey, pData))
            {
                m_cEntries++;
                return TRUE;
            }
        }
    }
    return FALSE;
}


LPVOID CHashedList2::Find(UINT nKey)
{
    if (NULL != m_aBuckets)
    {
        ULONG nBucket = GetHashValue(nKey);
        if (NULL != m_aBuckets[nBucket])
        {
            return m_aBuckets[nBucket]->Find(nKey);
        }
    }
    return NULL;
}


LPVOID CHashedList2::Remove(UINT nKey)
{
    if (NULL != m_aBuckets)
    {
        ULONG nBucket = GetHashValue(nKey);
        if (NULL != m_aBuckets[nBucket])
        {
            LPVOID pRet = m_aBuckets[nBucket]->Remove(nKey);
            if (NULL != pRet)
            {
                m_cEntries--;
                return pRet;
            }
        }
    }
    return NULL;
}


LPVOID CHashedList2::Get(UINT *pnKey)
{
    if (NULL != m_aBuckets)
    {
        if (m_cEntries)
        {
            for (ULONG i = 0; i < m_cBuckets; i++)
            {
                if (NULL != m_aBuckets[i])
                {
                    LPVOID pRet = m_aBuckets[i]->Get(pnKey);
                    if (NULL != pRet)
                    {
                        m_cEntries--;
                        return pRet;
                    }
                }
            }
        }
    }
    return NULL;
}


LPVOID CHashedList2::Iterate(UINT *pnKey)
{
    if (NULL != m_aBuckets)
    {
        for (ULONG i = m_nCurrBucket; i < m_cBuckets; i++)
        {
            if (NULL != m_aBuckets[i])
            {
                LPVOID pRet = m_aBuckets[i]->Iterate(pnKey);
                if (NULL != pRet)
                {
                    m_nCurrBucket = i;
                    return pRet;
                }
            }
        }
    }
    m_nCurrBucket = m_cBuckets; // over
    return NULL;
}


void CHashedList2::Reset(void)
{
    m_nCurrBucket = 0;

    if (NULL != m_aBuckets)
    {
        for (ULONG i = 0; i < m_cBuckets; i++)
        {
            if (NULL != m_aBuckets[i])
            {
                m_aBuckets[i]->Reset();
            }
        }
    }
}


void CHashedList2::Clear(void)
{
    m_cEntries = 0;
    m_nCurrBucket = 0;

    if (NULL != m_aBuckets)
    {
        for (ULONG i = 0; i < m_cBuckets; i++)
        {
            if (NULL != m_aBuckets[i])
            {
                m_aBuckets[i]->Clear();
            }
        }
    }
};


ULONG CHashedList2::GetHashValue(UINT nKey)
{
    const UINT PRIME_NUMBER_1 = 89;
    const UINT PRIME_NUMBER_2 = 13;
    return ((ULONG) (nKey * PRIME_NUMBER_1 + PRIME_NUMBER_2) % m_cBuckets);
}

#endif // ENABLE_HASHED_LIST2


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\common\capid.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_UTILITY);
/* 
 *	capid.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the class CCapIDContainer. 
 *		A CCapIDContainer object is used to maintain information about
 *		a particular capability of an application.  A capability identifier can
 *		be either a standard type or a non-standard type.  When the type is 
 *		standard, the identifier is stored internally as an integer value.  When
 *		the type is non-standard, an CObjectKeyContainer container object is used 
 *		internally to buffer the necessary data.  In this case the identifier 
 *		data may exist as an Object ID which is a series of non-negative 
 *		integers or an H221 non-standard ID which is an octet string of no fewer
 *		than four octets and no more than 255 octets. 
 *
 *	Protected Instance Variables:
 *		m_InternalCapID
 *			Structure used to hold the capability ID data internally.
 *		m_CapIDPDU
 *			Storage for the "PDU" form of the capability ID.
 *		m_fValidCapIDPDU
 *			Flag indicating that memory has been allocated to hold the internal
 *			"PDU" capability ID.
 *		m_cbDataSize
 *			Variable holding the size of the memory which will be required to
 *			hold any data referenced by the "API" GCCCapabilityID structure.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */
#include "capid.h"

/*
 *	CCapIDContainer()
 *
 *	Public Function Description:
 *		This constructor is used to create a CCapIDContainer object 
 *		from an "API" GCCCapabilityID.
 */
CCapIDContainer::
CCapIDContainer(PGCCCapabilityID capability_id, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('C','a','p','I')),
    m_fValidCapIDPDU(FALSE),
    m_cbDataSize(0)
{
	GCCError rc = GCC_NO_ERROR;

	if (capability_id == NULL)
	{
		rc = GCC_INVALID_PARAMETER;
	}
	else
	{
	
		/*
		 * Save the GCCCapabilityID in the internal information structure.
		 */
		m_InternalCapID.capability_id_type = capability_id->capability_id_type;

		if (capability_id->capability_id_type == GCC_STANDARD_CAPABILITY)
		{
			m_InternalCapID.u.standard_capability = (USHORT) capability_id->standard_capability;
		}
		else
		{
			/*
			 * The object key portion of the capability ID is saved in an
			 * CObjectKeyContainer object.
			 */
			DBG_SAVE_FILE_LINE
			m_InternalCapID.u.non_standard_capability = 
					new CObjectKeyContainer(&capability_id->non_standard_capability, &rc);
			if (m_InternalCapID.u.non_standard_capability == NULL)
			{
				rc = GCC_ALLOCATION_FAILURE;
			}
			else if (rc == GCC_BAD_OBJECT_KEY)
		    {
				rc = GCC_BAD_CAPABILITY_ID;
			}
		}
	}

	*pRetCode = rc;
}

/*
 *	CCapIDContainer()
 *
 *	Public Function Description:
 *		This constructor is used to create a  CapabilityIdentifier object from
 *		a "PDU" CapabilityID.
 */
CCapIDContainer::
CCapIDContainer(PCapabilityID capability_id, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('C','a','p','I')),
    m_fValidCapIDPDU(FALSE),
    m_cbDataSize(0)
{
	GCCError rc = GCC_NO_ERROR;

	if (capability_id->choice == STANDARD_CHOSEN)
	{
		m_InternalCapID.capability_id_type = GCC_STANDARD_CAPABILITY;
		m_InternalCapID.u.standard_capability = capability_id->u.standard;
	}
	else
	{
		m_InternalCapID.capability_id_type = GCC_NON_STANDARD_CAPABILITY;
		DBG_SAVE_FILE_LINE
		m_InternalCapID.u.non_standard_capability =
		            new CObjectKeyContainer(&capability_id->u.capability_non_standard, &rc);
		if (m_InternalCapID.u.non_standard_capability == NULL)
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
		else if (rc == GCC_BAD_OBJECT_KEY)
	    {
			rc = GCC_BAD_CAPABILITY_ID;
		}
	}

	*pRetCode = rc;
}

/*
 *	CCapIDContainer()
 *
 *	Public Function Description:
 *		This copy constructor is used to create a new CCapIDContainer 
 *		object from	another CCapIDContainer object.
 */
CCapIDContainer::
CCapIDContainer(CCapIDContainer *capability_id, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('C','a','p','I')),
    m_fValidCapIDPDU(FALSE),
    m_cbDataSize(0)
{
	GCCError rc = GCC_NO_ERROR;

	m_InternalCapID = capability_id->m_InternalCapID;

	if (m_InternalCapID.capability_id_type == GCC_NON_STANDARD_CAPABILITY)
	{
		DBG_SAVE_FILE_LINE
		m_InternalCapID.u.non_standard_capability =
			new CObjectKeyContainer(capability_id->m_InternalCapID.u.non_standard_capability, &rc);
		if (m_InternalCapID.u.non_standard_capability == NULL)
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
		else if (rc == GCC_BAD_OBJECT_KEY)
	    {
			rc = GCC_BAD_CAPABILITY_ID;
		}
	}

	*pRetCode = rc;
}

/*
 *	~CCapIDContainer()
 *
 *	Public Function Description
 *		The CCapIDContainer destructor is responsible for freeing any 
 *		memory allocated to hold the capability ID data for both the "API" and 
 *		"PDU" forms.
 *
 */
CCapIDContainer::~CCapIDContainer(void)
{
	/*
	 * If "PDU" data has been allocated for this object, free it now.
	 */
	if (m_fValidCapIDPDU)
		FreeCapabilityIdentifierDataPDU ();

	/* 
	 * Delete any object key data held internally.
	 */
	if (m_InternalCapID.capability_id_type == GCC_NON_STANDARD_CAPABILITY)
	{
		if (NULL != m_InternalCapID.u.non_standard_capability)
		{
		    m_InternalCapID.u.non_standard_capability->Release();
		}
	}
}

/*
 *	LockCapabilityIdentifierData ()
 *
 *	Public Function Description:
 *		This routine locks the capability ID data and determines the amount of
 *		memory referenced by the "API" capability ID structure.
 */
UINT CCapIDContainer::LockCapabilityIdentifierData(void)
{
	/*
	 * If this is the first time this routine is called, determine the size of 
	 * the memory required to hold the data referenced by the capability ID
	 * structure.  Otherwise, just increment the lock count.
	 */
	if (Lock() == 1)
	{
		m_cbDataSize = 0;

		if (m_InternalCapID.capability_id_type == GCC_NON_STANDARD_CAPABILITY)
		{
			m_cbDataSize = m_InternalCapID.u.non_standard_capability->LockObjectKeyData (); 
		}
	}

	return m_cbDataSize;
}

/*
 *	GetGCCCapabilityIDData ()
 *
 *	Public Function Description:
 *		This routine retrieves capability ID data in the form of a 
 *		GCCCapabilityID.  This routine is called after "locking" the capability
 *		ID data.
 */
UINT CCapIDContainer::GetGCCCapabilityIDData(
							PGCCCapabilityID 		capability_id,
							LPBYTE					memory)
{
	UINT cbDataSizeToRet = 0;

	if (GetLockCount() > 0)
	{
		/*
		 * Fill in the output parameter which indicates the amount of memory
		 * used to hold all of the data associated with the capability ID.
		 */
		cbDataSizeToRet = m_cbDataSize;

		/*
		 * Fill in the "API" capability ID from the internal structure.  If an
		 * object key exists, get the object key data by calling the "Get" 
		 * routine of the internal CObjectKeyContainer object.
		 */
		capability_id->capability_id_type = m_InternalCapID.capability_id_type;

		if (m_InternalCapID.capability_id_type == GCC_STANDARD_CAPABILITY)
		{
			capability_id->standard_capability = m_InternalCapID.u.standard_capability; 
		}
		else
		{
			/*
			 * The call to get the object key data returns the amount of data
			 * written into memory.  We do not need this value right now.
			 */
			m_InternalCapID.u.non_standard_capability->   
					GetGCCObjectKeyData( 
							&capability_id->non_standard_capability,
							memory);
		}
	}
	else
	{
		ERROR_OUT(("CCapIDContainer::GetGCCCapabilityIDData: Error data not locked"));
	}

	return (cbDataSizeToRet);
}

/*
 *	UnlockCapabilityIdentifierData ()
 *
 *	Public Function Description:
 *		This routine decrements the internal lock count and frees the memory 
 *		associated with the "API" capability ID when the lock count hits zero.
 */
void CCapIDContainer::UnLockCapabilityIdentifierData(void)
{
	if (Unlock(FALSE) == 0)
	{
		if (m_InternalCapID.capability_id_type == GCC_NON_STANDARD_CAPABILITY)
		{
			m_InternalCapID.u.non_standard_capability->UnLockObjectKeyData(); 
		}
	}

    // we have to call Release() because we used Unlock(FALSE)
    Release();
}

/*
 *	GetCapabilityIdentifierDataPDU ()
 *
 *	Public Function Description:
 *		This routine converts the capability ID from it's internal form of an
 *		CAP_ID_STRUCT structure into the "PDU" form which can be 
 *		passed in to the ASN.1 encoder.  A pointer to a "PDU" "CapabilityID" 
 *		structure is returned.
 */
GCCError CCapIDContainer::GetCapabilityIdentifierDataPDU(PCapabilityID capability_id)
{
	GCCError rc = GCC_NO_ERROR;

	/*
	 * If this is the first time that PDU data has been requested then we must
	 * fill in the internal PDU structure and copy it into the structure pointed
	 * to by the output parameter.  On subsequent calls to "GetPDU" we can just
	 * copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	if (m_fValidCapIDPDU == FALSE)
	{
		m_fValidCapIDPDU = TRUE;

			if (m_InternalCapID.capability_id_type== GCC_STANDARD_CAPABILITY)
			{
				m_CapIDPDU.choice = STANDARD_CHOSEN;
				m_CapIDPDU.u.standard = m_InternalCapID.u.standard_capability;
			}
			else
			{
				m_CapIDPDU.choice = CAPABILITY_NON_STANDARD_CHOSEN;
				rc = m_InternalCapID.u.non_standard_capability->
							GetObjectKeyDataPDU(&m_CapIDPDU.u.capability_non_standard);
			}
	}

	/*
	 * Copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	*capability_id = m_CapIDPDU;

	return rc;
}

/*
 *	FreeCapabilityIdentifierDataPDU ()
 *
 *	Public Function Description:
 *		This routine is used to free the capability ID data held internally in
 *		the "PDU" form of a "CapabilityID".
 */
void CCapIDContainer::FreeCapabilityIdentifierDataPDU(void)
{
	if (m_fValidCapIDPDU)
	{
		/*
		 * Set the flag indicating that PDU session key data is no longer
		 * allocated.
		 */
		m_fValidCapIDPDU = FALSE;

		if (m_CapIDPDU.choice == CAPABILITY_NON_STANDARD_CHOSEN)
		{
			m_InternalCapID.u.non_standard_capability->FreeObjectKeyDataPDU();
		}
	}
}

/*
 *	operator== ()
 *
 *	Public Function Description:
 *		This routine is used to determine whether or not two Capibility ID's
 *		are equal in value.
 */
BOOL operator==(const CCapIDContainer& capability_id_1, const CCapIDContainer& capability_id_2)
{
	BOOL rc = FALSE;

	if (capability_id_1.m_InternalCapID.capability_id_type == 
						capability_id_2.m_InternalCapID.capability_id_type)
	{
		if (capability_id_1.m_InternalCapID.capability_id_type ==
														GCC_STANDARD_CAPABILITY)
		{
			if (capability_id_1.m_InternalCapID.u.standard_capability == 
					capability_id_2.m_InternalCapID.u.standard_capability)
			{
				rc = TRUE;
			}
		}
		else
		{
			if (*capability_id_1.m_InternalCapID.u.non_standard_capability == 
				*capability_id_2.m_InternalCapID.u.non_standard_capability)
			{
				rc = TRUE;
			}
		}
	}

	return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\common\ms_util.cpp ===
#include "precomp.h"


CRefCount::CRefCount(DWORD dwStampID)
:
#ifndef SHIP_BUILD
    m_dwStampID(dwStampID),
#endif
    m_cRefs(1),
    m_cLocks(0)
{
}


// though it is pure virtual, we still need to have a destructor.
CRefCount::~CRefCount(void)
{
}


LONG CRefCount::AddRef(void)
{
    ASSERT(0 < m_cRefs);
    ::InterlockedIncrement(&m_cRefs);
    return m_cRefs;
}


LONG CRefCount::Release(void)
{
    ASSERT(NULL != this);
    ASSERT(0 < m_cRefs);
    if (0 == ::InterlockedDecrement(&m_cRefs))
    {
        ASSERT(0 == m_cLocks);
        delete this;
        return 0;
    }
    return m_cRefs;
}


void CRefCount::ReleaseNow(void)
{
    ASSERT(NULL != this);
    ASSERT(0 < m_cRefs);
    m_cRefs = 0;
    delete this;
}


LONG CRefCount::Lock(void)
{
    AddRef();
    ASSERT(0 <= m_cLocks);
    ::InterlockedIncrement(&m_cLocks);
    return m_cLocks;
}


LONG CRefCount::Unlock(BOOL fRelease)
{
    ASSERT(0 < m_cLocks);
    ::InterlockedDecrement(&m_cLocks);
    LONG c = m_cLocks; // in case Release() frees the object
    if (fRelease)
    {
        Release();
    }
    return c;
}


UINT My_strlenA(LPCSTR pszSrc)
{
	UINT cch = 0;
	if (NULL != pszSrc)
	{
		cch = lstrlenA(pszSrc);
	}
	return cch;
}

#if defined(_DEBUG)
LPSTR _My_strdupA(LPCSTR pszSrc, LPSTR pszFileName, UINT nLineNumber)
#else
LPSTR My_strdupA(LPCSTR pszSrc)
#endif
{
	if (NULL == pszSrc)
	{
		return NULL;
	}

	UINT cch = lstrlenA(pszSrc) + 1;
#if defined(_DEBUG)
	LPSTR pszDst = (LPSTR) DbgMemAlloc(cch, NULL, pszFileName, nLineNumber);
#else
	LPSTR pszDst = new char[cch];
#endif
	if (NULL != pszDst)
	{
		CopyMemory(pszDst, pszSrc, cch);
	}
	return pszDst;
}

UINT My_strlenW(LPCWSTR pszSrc)
{
	UINT cch = 0;
	if (NULL != pszSrc)
	{
		cch = lstrlenW(pszSrc);
	}
	return cch;
}

#if defined(_DEBUG)
LPWSTR _My_strdupW(LPCWSTR pszSrc, LPSTR pszFileName, UINT nLineNumber)
#else
LPWSTR My_strdupW(LPCWSTR pszSrc)
#endif
{
	if (NULL == pszSrc)
	{
		return NULL;
	}

	UINT cch = lstrlenW(pszSrc) + 1;
#if defined(_DEBUG)
	LPWSTR pszDst = (LPWSTR) DbgMemAlloc(cch * sizeof(WCHAR), NULL, pszFileName, nLineNumber);
#else
	LPWSTR pszDst = new WCHAR[cch];
#endif
	if (NULL != pszDst)
	{
		CopyMemory(pszDst, pszSrc, cch * sizeof(WCHAR));
	}
	return pszDst;
}

//
// LONCHANC: This is to provide backward compatibility to UnicodeString
// in protocol structures. hopefully, we can remove this hack later.
//
#if defined(_DEBUG)
LPWSTR _My_strdupW2(UINT cchSrc, LPCWSTR pszSrc, LPSTR pszFileName, UINT nLineNumber)
#else
LPWSTR My_strdupW2(UINT cchSrc, LPCWSTR pszSrc)
#endif
{
#if defined(_DEBUG)
	LPWSTR pwsz = (LPWSTR) DbgMemAlloc((cchSrc+1) * sizeof(WCHAR), NULL, pszFileName, nLineNumber);
#else
	LPWSTR pwsz = new WCHAR[cchSrc+1];
#endif
	if (NULL != pwsz)
	{
		CopyMemory(pwsz, pszSrc, cchSrc * sizeof(WCHAR));
	}
	pwsz[cchSrc] = 0;
	return pwsz;
}

int My_strcmpW(LPCWSTR pwsz1, LPCWSTR pwsz2)
{
	if (NULL == pwsz1 || NULL == pwsz2)
	{
		return -1;
	}

	WCHAR ch;
	while (0 == (ch = *pwsz1 - *pwsz2) &&
			NULL != *pwsz1++ &&
			NULL != *pwsz2++)
		;

	return (int) ch;
}


#if defined(_DEBUG)
LPOSTR _My_strdupO2(LPBYTE lpbSrc, UINT cOctets, LPSTR pszFileName, UINT nLineNumber)
#else
LPOSTR My_strdupO2(LPBYTE lpbSrc, UINT cOctets)
#endif
{
#if defined(_DEBUG)
	LPOSTR poszDst = (LPOSTR) DbgMemAlloc(sizeof(OSTR) + cOctets + 1, NULL, pszFileName, nLineNumber);
#else
	LPOSTR poszDst = (LPOSTR) new char[sizeof(OSTR) + cOctets + 1];
#endif
	if (NULL != poszDst)
	{
		poszDst->length = cOctets;
		poszDst->value = (LPBYTE) (poszDst + 1);
		::CopyMemory(poszDst->value, lpbSrc, cOctets);
	}
	return poszDst;
}


INT My_strcmpO(LPOSTR posz1, LPOSTR posz2)
{
	if (NULL == posz1 || NULL == posz2)
	{
		return -1;
	}

	if (posz1->length != posz2->length)
	{
		return -1;
	}

	UINT cnt = posz1->length;
	LPBYTE lpb1 = posz1->value, lpb2 = posz2->value;
	BYTE b = 0;
	while (cnt--)
	{
		if (0 != (b = *lpb1++ - *lpb2++))
		{
			break;
		}
	}
	return (INT) b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\common\hash.cpp ===
/*	hash.cpp
 *
 *	Copyright (c) 1996 by Microsoft Corporation
 *
 *  Written by:	 Christos Tsollis
 *
 *  Revisions:
 *		
 *	Abstract:
 *
 *	This is the implementation of a dictionary data structure.  
 *
 */

#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_UTILITY);

#define MyMalloc(size)	new BYTE[size]
#define MyFree(ptr)		(delete [] (BYTE *) (ptr))
#define Max(a,b)		(((a) > (b)) ? (a) : (b))


/*  Function:  Constructor
 *
 *	Parameters:
 *		num_of_buckets:		Number of buckets in the dictionary
 *		dtype:				Dictionary type
 *
 *	Return value:
 *		None
 */

DictionaryClass::DictionaryClass (ULong num_of_buckets, DictionaryType dtype) :
	Type (dtype), NumOfExternItems (0)
{
	DWORD				i;	
	PDICTIONARY_ITEM	p;	// Goes through the initially allocated dictionary items to initialize the stack

	NumOfBuckets = Max (num_of_buckets, DEFAULT_NUMBER_OF_BUCKETS);

	/* Allocate the space needed for the dictionary */
	dwNormalSize = NumOfBuckets * (4 * sizeof (PDICTIONARY_ITEM) + 3 * sizeof (DICTIONARY_ITEM));
	Buckets = (PDICTIONARY_ITEM *) MyMalloc (dwNormalSize);
	if (Buckets == NULL)
		return;

	/* Initialize the Buckets */
	for (i = 0; i < NumOfBuckets; i++)
		Buckets[i] = NULL;

	// Initialize the class iterator
	pCurrent = NULL;

	/* Initialize the Dictionary items array.
	 * This is a stack of pointers to the real dictionary items. The stack is initialized with
	 * the addresses of the dictionary items
	 */ 

	ItemArray = (PDICTIONARY_ITEM *) ((PBYTE) Buckets + NumOfBuckets * sizeof (PDICTIONARY_ITEM));
	ItemCount = 3 * NumOfBuckets;

	p = (PDICTIONARY_ITEM) (ItemArray + ItemCount);
	for (i = 0; i < ItemCount; i++)
		ItemArray[i] = p++;
}


/*  Function:  Copy Constructor
 *
 *	Parameters:
 *		original:	The original dictionary to make a copy of 
 *
 *	Return value:
 *		None
 *
 *	Note:
 *		This copy constructor will work ONLY for DWORD_DICTIONARY dictionaries.
 *		It will NOT work for the string dictionary types.
 */


DictionaryClass::DictionaryClass (const DictionaryClass& original)
{
	DWORD			 i;
	PDICTIONARY_ITEM p, q, r;

	NumOfBuckets = original.NumOfBuckets;
	Type = original.Type;
	NumOfExternItems = original.NumOfExternItems;

	// Allocate the space needed for the dictionary
	dwNormalSize = original.dwNormalSize;
	Buckets = (PDICTIONARY_ITEM *) MyMalloc (dwNormalSize);
	if (Buckets == NULL)
		return;

	// Initialize the class iterator
	pCurrent = NULL;

	/* Initialize the Dictionary items array */
	ItemArray = (PDICTIONARY_ITEM *) ((PBYTE) Buckets + NumOfBuckets * sizeof (PDICTIONARY_ITEM));
	ItemCount = 3 * NumOfBuckets;

	// Traverse the whole original hash sturcture to create the copy
	// p: goes through the original items
	// q: goes through current instance's items and initializes them
	// r: remembers the previous item in the new instance so that its "next" field could be set

	q = (PDICTIONARY_ITEM) (ItemArray + ItemCount);
	for (q--, i = 0; i < NumOfBuckets; i++) {
		for (r = NULL, p = original.Buckets[i]; p != NULL; p = p->next) {
			
			// Check if there are unused items in the current dictionary
			if (ItemCount <= 0) {
				q = (PDICTIONARY_ITEM) MyMalloc (sizeof (DICTIONARY_ITEM));
				if (q == NULL)
					break;
			}
			else {
				ItemCount--;
				q++;
			}

			q->value = p->value;
			q->key = p->key;
			if (p == original.Buckets[i])
				Buckets[i] = q;
			else
				r->next = q;
			r = q;
		}

		// Set the "next" field for the last item in the bucket
		if (r == NULL)
			Buckets[i] = NULL;
		else
			r->next = NULL;
	}

	// Initialize the rest of the ItemArray array
	for (i = 0; i < ItemCount; i++)
		ItemArray[i] = q++;

}


/*  Function:  Destructor
 *
 *	Parameters:
 *		None.
 *
 *	Return value:
 *		None
 *
 */


DictionaryClass::~DictionaryClass ()
{
	DWORD			 i;
	DWORD			 dwOffset;		// Offset of the dictionary item.  If the offset does not indicate
									// that the item is from the initially allocated array, it has to 
									// be freed.
	PDICTIONARY_ITEM p, q;

	if (Buckets != NULL) {

		// Go through the buckets to free the non-native items
		for (i = 0; i < NumOfBuckets; i++)
			for (p = Buckets[i]; p != NULL; ) {
				if (Type >= STRING_DICTIONARY)
					MyFree (p->key);
				dwOffset = (PBYTE) p - (PBYTE) Buckets;
				if (dwOffset >= 0 && dwOffset < dwNormalSize)
					p = p->next;
				else {  
					// if the item was not allocated in the initialization, we should free it.
					q = p;
					p = p->next;	
					MyFree (q);
				}
			}
					
		MyFree (Buckets);
		Buckets = NULL;
	}
}


/*  Function:  hashFunction
 *
 *	Parameters:
 *		key:	The key value
 *
 *	Return value:
 *		An integer in the range [0..NumOfBuckets-1] that indicates the bucket used for the "key".
 *
 */


DWORD DictionaryClass::hashFunction (DWORD key) 
{
	if (Type < STRING_DICTIONARY)
		return (key % NumOfBuckets);
	else
		return (*((unsigned char *) key) % NumOfBuckets);
}


/*  Function:  LengthStrcmp
 *
 *	Parameters:
 *		DictionaryKey:	Pointer to dictionary storage that keeps a length-sensitive string (which
 *						is a length followed by a string of that length.
 *		ChallengeKey:	Pointer to the length-sensitive key that is compared with the "DictionaryKey"
 *		length:			The length of the "ChallengeKey" string
 *
 *	Return value:
 *		0 if the "DictionaryKey" and "ChallengeKey" strings are the same. 1, otherwise.
 *
 *	Note:
 *		This function is only used for dictionaries of type LENGTH_STRING_DICTIONARY.
 */

int DictionaryClass::LengthStrcmp (DWORD DictionaryKey, DWORD ChallengeKey, ULong length)
{
	ULong					 i;
	char					*pDictionaryChar;	// Goes through the dictionary key string
	char					*pChallengeChar;	// Goes through the challenge string

	// Compare the lengths first
	if (length != * (ULong *) DictionaryKey)
		return 1;

	// Now, compare the strings themselves
	pDictionaryChar	= (char *) (DictionaryKey + sizeof (ULong));
	pChallengeChar = (char *) ChallengeKey;
	for (i = 0; i < length; i++)
		if (*pDictionaryChar++ != *pChallengeChar++)
			return 1;

	return 0;
}


/*  Function:  insert
 *		Inserts (key, value) pair in the dictionary
 *
 *	Parameters:
 *		new_key:	The new key that has to be inserted in the dictionary
 *		new_value:	The value associated with the "new_key"
 *		length:		Used only for LENGTH_STRING_DICTIONARY dictionaries; specifies the length of the new key
 *
 *	Return value:
 *		TRUE, if the operation succeeds, FALSE, otherwise.
 *
 *	Note:
 *		If the "new_key" is already in the dictionary, the (new_key, new_value) pair is NOT
 *		inserted (the dictionary remains the same), and the return value is TRUE.
 */


BOOL DictionaryClass::insert (DWORD new_key, DWORD new_value, ULong length)
{
	PDICTIONARY_ITEM	pNewItem;			// Points to the allocated new dictionary item
	PDICTIONARY_ITEM	p;					// Goes through the bucket for the "new_key", searching for "new_key"
	DWORD				hash_val;			// The bucket ID for "new_key"
	BOOL				bIsNative = TRUE;	// TRUE, if the new allocated dictionary item is from the cache, FALSE otherwise

	if (Buckets == NULL)
		return FALSE;

	// Find if the item is already in the bucket, and if it's not, where it will get added.
	p = Buckets[hash_val = hashFunction (new_key)];

	ASSERT (hash_val >= 0 && hash_val < NumOfBuckets);

	if (p != NULL) {
		switch (Type) {
#if 0
		case STRING_DICTIONARY:
			ASSERT (length == 0);
			for (; lstrcmp ((LPCTSTR) p->key, (LPCTSTR) new_key) && p->next != NULL; p = p->next);
			if (0 == lstrcmp ((LPCTSTR) p->key, (LPCTSTR) new_key)) {
				// the key already exists; no need to add it
				return TRUE;
			}
			break;
#endif
		case LENGTH_STRING_DICTIONARY:
			ASSERT (length > 0);
			for (; LengthStrcmp (p->key, new_key, length) && p->next != NULL; p = p->next);
			if (0 == LengthStrcmp (p->key, new_key, length)) {
				// the key already exists; no need to add it
				return TRUE;
			}
			break;
		default:
			ASSERT (length == 0);
			for (; p->key != new_key && p->next != NULL; p = p->next);
			if (p->key == new_key) {
				// the key already exists; no need to add it
				return TRUE;
			}
			break;
		}
	}

	// Allocate the new item
	if (ItemCount > 0)
		pNewItem = ItemArray[--ItemCount];		// from the cache
	else {										// the cache is empty, we have to malloc the new item
		pNewItem = (PDICTIONARY_ITEM) MyMalloc (sizeof (DICTIONARY_ITEM));
		if (pNewItem != NULL) {
			bIsNative = FALSE;
			NumOfExternItems++;
		}
		else {
			return FALSE;
		}
	}

	ASSERT (pNewItem != NULL);

	// Fill in the "key" field of the new item
	switch (Type) {
#if 0
	case STRING_DICTIONARY:
		ASSERT (length == 0);
		pNewItem->key = (DWORD) MyMalloc ((lstrlen ((LPCTSTR) new_key) + 1) * sizeof(TCHAR));
		if (pNewItem->key == (DWORD) NULL) {
			if (bIsNative == FALSE) {
				// We have to free the allocated hash item
				MyFree (pNewItem);
				NumOfExternItems--;
			}
			else
				ItemCount++;
			return FALSE;
		}
		lstrcpy ((LPTSTR) pNewItem->key, (LPCTSTR) new_key);
		break;
#endif

	case LENGTH_STRING_DICTIONARY:
		ASSERT (length > 0);
		pNewItem->key = (DWORD) MyMalloc (sizeof (ULong) + length * sizeof (TCHAR));
		if (pNewItem->key != (DWORD) NULL) {
			* ((ULong *) (pNewItem->key)) = length;
			memcpy ((void *) (pNewItem->key + sizeof (ULong)), (void *) new_key, length * sizeof (TCHAR));
		}
		else {
			if (bIsNative == FALSE) {
				// We have to free the allocated hash item
				MyFree (pNewItem);
				NumOfExternItems--;
			}
			else
				ItemCount++;
			return FALSE;
		}
		break;

	default:
		ASSERT (length == 0);
		pNewItem->key = new_key;
		break;
	}

	// Fill in the rest of the fields of the new item
	pNewItem->value = new_value;
	pNewItem->next = NULL;

	// Insert the item in its bucket
	if (p == NULL)
		Buckets[hash_val] = pNewItem;
	else
		p->next = pNewItem;

	return TRUE;
}


/*  Function:  remove
 *		Removes (key, value) pair from the dictionary
 *
 *	Parameters:
 *		Key:	The key that has to be removed from the dictionary
 *		length:	Used only for LENGTH_STRING_DICTIONARY dictionaries; specifies the length of the "Key"
 *
 *	Return value:
 *		None.
 *
 */

BOOL DictionaryClass::remove (DWORD Key, ULong length)
{
	PDICTIONARY_ITEM	p, q;		// They go through the dictionary items in "Key"'s bucket.
									// p: points to the current dictionary item in the bucket
									// q: points to the previous item
	DWORD				hash_val;	// The bucket ID for "Key"
	
	if (Buckets != NULL) {

		// Find the item in the dictionary
		p = Buckets [hash_val = hashFunction (Key)];

		ASSERT (hash_val >= 0 && hash_val < NumOfBuckets);

		switch (Type) {
#if 0
		case STRING_DICTIONARY:
			ASSERT (length == 0);
			for (q = NULL; p != NULL && lstrcmp ((LPCTSTR) p->key, (LPCTSTR) Key); p = (q = p)->next) ;
			break;
#endif

		case LENGTH_STRING_DICTIONARY:
			ASSERT (length > 0);
			for (q = NULL; p != NULL && LengthStrcmp (p->key, Key, length); p = (q = p)->next) ;
			break;

		default:
			ASSERT (length == 0);
			for (q = NULL; p != NULL && p->key != Key; p = (q = p)->next);
			break;
		}

		// Remove the item 
		if (p != NULL) {
			if (q == NULL) 
				Buckets[hash_val] = p->next;
			else
				q->next = p->next;

			// Free the item found
			ASSERT (p != NULL);

			if (Type >= STRING_DICTIONARY)
				MyFree (p->key);
			hash_val = (PBYTE) p - (PBYTE) Buckets;
			if (hash_val >= 0 && hash_val < dwNormalSize)
				ItemArray[ItemCount++] = p;
			else {
				MyFree (p);
				NumOfExternItems--;
			}
			return TRUE;
		}
	}
	return FALSE;
}


/* Function:  find
 *		Looks up the key in the dictionary
 * 
 * Parameters
 *		Key:	The key to lookup
 *		pValue: Pointer to receive the value associated with "Key"
 *				It can be NULL, if we just try to find whether "Key" is in the dictionary
 *		length:	Used only for LENGTH_STRING_DICTIONARY dictionaries; specifies the length of "Key"
 *
 * Return value: 
 *		FALSE, if "Key" is not found in the dictionary
 *		TRUE, otherwise.
 */

BOOL DictionaryClass::find (DWORD Key, LPDWORD pValue, ULong length)
{
	PDICTIONARY_ITEM	p;		// Goes through the dictionary items in "Key"'s bucket.

	if (Buckets != NULL) {
		// Find the item in the dictionary
		p = Buckets [hashFunction (Key)];

		switch (Type) {
#if 0
		case STRING_DICTIONARY:
			ASSERT (length == 0);
			for (; p != NULL && lstrcmp ((LPCTSTR) p->key, (LPCTSTR) Key); p = p->next) ;
			break;
#endif

		case LENGTH_STRING_DICTIONARY:
			ASSERT (length > 0);
			for (; p != NULL && LengthStrcmp (p->key, Key, length); p = p->next) ;
			break;

		default:
			ASSERT (length == 0);
			for (; p != NULL && p->key != Key; p = p->next);
			break;
		}

		if (p != NULL) {
			// "Key" was found
			if (pValue != NULL)
				*pValue = p->value;
			return TRUE;
		}
	}

	if (pValue != NULL)
		*pValue = 0;
	return FALSE;

}

LPVOID DictionaryClass::Find(DWORD Key, UINT length)
{
	LPVOID Val;
	return find(Key, (LPDWORD) &Val, (ULONG) length) ? Val : NULL; 
}


/* Function:  iterate
 *		Iterates through the items of a dictionary.  It remembers where it has 
 *		stopped during the last call and starts from there.
 * 
 * Parameters
 *		pValue:	Pointer to DWORD that will hold the next value from the dictionary.
 *				It can be NULL.
 *		pKey:	Pointer to DWORD or unsigned short value to receive the key associated with the value.
 *				It can be NULL.
 *
 * Return value: 
 *		FALSE, when we reach the end of the dictionary
 *		TRUE, otherwise.  Then, *pKey and *pValue are valid
 *
 */

BOOL DictionaryClass::iterate (LPDWORD pValue, LPDWORD pKey)
{

	if (Buckets != NULL) {
		if (pCurrent) {
			pCurrent = pCurrent->next;
		}
		else {
			// start from the 1st item in the dictionary
			pCurrent = Buckets[ulCurrentBucket = 0];
		}

		// Advance "pCurrent" until it's not NULL, or we reach the end of the dictionary.
		for (; ulCurrentBucket < NumOfBuckets; pCurrent = Buckets[++ulCurrentBucket]) {
			if (pCurrent != NULL) {
				// we found the next item
				if (pKey)
					*pKey = pCurrent->key;
				if (pValue)
					*pValue = pCurrent->value;
				return TRUE;
			}
		}
	}

	pCurrent = NULL;
	return FALSE;
}

LPVOID DictionaryClass::Iterate(LPDWORD pKey)
{
	LPVOID Val;
	return iterate((LPDWORD) &Val, pKey) ? Val : NULL;
}

/* Function:  isEmpty
 * 
 * Parameters
 *		None.
 *
 * Return value: 
 *		TRUE, if the dictionary is empty.  FALSE, otherwise.
 *
 */

BOOL DictionaryClass::isEmpty (void)
{
	DWORD i;

	if (Buckets != NULL) {
		for (i = 0; i < NumOfBuckets; i++)
			if (Buckets[i] != NULL)
				return FALSE;
	}
	return TRUE;
}


/* Function:  clear
 *		Clears up the dictionary.  No (key, value) pairs are left in the dictionary.
 * 
 * Parameters:
 *		None.
 *
 * Return value: 
 *		None.
 *
 */

void DictionaryClass::clear (void)
{

	DWORD			 i;			// Goes through the "Buckets" array
	DWORD			 dwOffset;	// The offset of a dictionary item is used to determine
								// whether it's a native item (that needs to be returned to the cache),
								// or not (and needs to be freed).
	PDICTIONARY_ITEM p, q;		// Go through the items in a bucket

	if (Buckets != NULL) {
		// Go through the buckets to free the non-native items
		for (i = 0; i < NumOfBuckets; i++) {
			for (p = Buckets[i]; p != NULL; ) {
				if (Type >= STRING_DICTIONARY) 
					MyFree (p->key);

				// Compute the offset of the current dictionary item
				dwOffset = (PBYTE) p - (PBYTE) Buckets;
				if (dwOffset >= 0 && dwOffset < dwNormalSize)
					p = p->next;
				else {  
					// if the item was not allocated in the initialization, we should free it.
					q = p;
					p = p->next;	
					MyFree (q);
				}
			}
			Buckets[i] = NULL;
		}

		// Initialize the class iterator
		pCurrent = NULL;

		/* Initialize the Dictionary items array */
		ItemCount = 3 * NumOfBuckets;
		p = (PDICTIONARY_ITEM) (ItemArray + ItemCount);
		for (i = 0; i < ItemCount; i++)
			ItemArray[i] = p++;

		NumOfExternItems = 0;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\common\memory.cpp ===
#include "precomp.h"
/*
 *	memory.cpp
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the Memory class.  Instances of
 *		this class represent chunks of data that are passed through a system.
 *		This class is particularly useful in cases where a memory buffer
 *		needs to be used in several different places, none of which know
 *		about each other.  This is because this class encapsulates things
 *		like lock counts, which are useful for holding memory until
 *		everyone that needs it is through.
 *
 *		Note that this class does NOT do memory management.  It is told by
 *		a higher level memory manager where its buffers are, etc.  For this
 *		reason, this class does not do any platform specific calls.
 *
 *	IMPORTANT NOTE:
 *		This class SHOULD NEVER contain virtual member functions. This is
 *		because of the Init() member than can be called as the "constructor"
 *		of this class.
 *
 *	Private Instance Variables:
 *		Length
 *			This is the length of the reference buffer.
 *		Copy_Ptr
 *			This is the address of the allocated buffer that this object
 *			uses.
 *
 *	Private Member Functions:
 *		None.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */

const char *MemorySignature = "T120Memr";

/*
 *	Memory ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the constructor for the Memory class.  It just initializes
 *		all instance variable, based on the passed in values.
 */
Memory::Memory (
		PUChar			reference_ptr,
		ULong			length,
		PUChar			copy_ptr) :
Length (length), 
Copy_Ptr (copy_ptr),
lLock (1),
m_priority (HIGHEST_PRIORITY)
{
	SIGNATURE_COPY(MemorySignature);
	
	/*
	 *	If the reference pointer is a valid pointer, then the pointer type
	 *	will be set to reference (indicating that the reference data has not
	 *	yet been copied).  If the reference pointer is NULL, then this is
	 *	a memory allocation with no associated reference data, so set the
	 *	pointer type to copy.
	 */
	if (reference_ptr != NULL)
		memcpy (Copy_Ptr, reference_ptr, (Int) Length);
}


/*
 *	Init ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the initializer for the Memory class, in the cases
 *		where the space for an object has been allocated, without
 *		calling the constructor.  It just initializes
 *		all instance variable, based on the passed in values.
 *
 *	NOTE: Because of this use of the Memory class, it should NOT
 *		contain any virtual functions.
 */
Void Memory::Init (
		PUChar			reference_ptr,
		ULong			length,
		MemoryPriority	priority,
		PUChar			copy_ptr)
{

	Length = length;
	Copy_Ptr = copy_ptr;
	lLock = 1;
	m_priority = priority;
	
	SIGNATURE_COPY(MemorySignature);
	
	/*
	 *	If the reference pointer is a valid pointer, then the pointer type
	 *	will be set to reference (indicating that the reference data has not
	 *	yet been copied).  If the reference pointer is NULL, then this is
	 *	a memory allocation with no associated reference data, so set the
	 *	pointer type to copy.
	 */
	if (reference_ptr != NULL)
		memcpy (Copy_Ptr, reference_ptr, (Int) Length);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\common\precomp.h ===
#define INC_OLE2
#define IDS_NULL_STRING			(0)
#include <windows.h>
#include <tchar.h>

// MCSNC includes
#include <databeam.h>

#include <oprahcom.h>
#include <confdbg.h>
// end MCSNC includes

extern "C"
{
#include <t120.h>
}
#include <memmgr.h>
#include <mcattprt.h>
#include <ncmcs.h>
#include <ConfDbg.h>
#include <debspew.h>
#include <RegEntry.h>
#include <ConfReg.h>
#include <oprahcom.h>
#include <it120nc.h>

#include "fclasses.h"

#include "cntlist.h"
#include "clists.h"
#include "ms_util.h"
#include <fsdiag.h>

#include <spacket.h>
#include <packet.h>
#include <datapkt.h>
#include <cmdtar.h>
#include <attmnt.h>
#include <channel.h>
#include <tptif.h>
#include <domain.h>
#include <connect.h>
#include <user.h>

#include "pdutypes.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\common\t120dbg.cpp ===
// t120dbg.cpp

#include "precomp.h"

#ifdef _DEBUG

#define INIT_DBG_ZONE_DATA
#include "fsdiag.h"


VOID T120DiagnosticCreate(VOID)
{
	MLZ_DbgInit((PSTR *) &c_apszDbgZones[0],
				(sizeof(c_apszDbgZones) / sizeof(c_apszDbgZones[0])) - 1);
}

VOID T120DiagnosticDestroy(VOID)
{
	MLZ_DbgDeInit();
}

#endif /* _DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\common\objkey.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_UTILITY);
/* 
 *	objkey.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the class CObjectKeyContainer.  This class 
 *		manages the data associated with an Object Key.  Object Key's are used 
 *		to identify a particular application protocol, whether it is standard or
 *		non-standard.  When used to identify a standard protocol, the Object Key
 *		takes the form of an Object ID which is a series of non-negative 
 *		integers.  This type of Object Key is maintained internally through the
 *		use of a Memory object.  When used to identify a non-standard 
 *		protocol, the Object Key takes the form of an H221 non-standard ID which
 *		is an octet string of no fewer than four octets and no more than 255 
 *		octets.  In this case the Object Key is maintained internally by using a
 *		Rogue Wave string object. 
 *
 *	Protected Instance Variables:
 *		m_InternalObjectKey
 *			Structure used to hold the object key data internally.
 *		m_ObjectKeyPDU
 *			Storage for the "PDU" form of the object key.
 *		m_fValidObjectKeyPDU
 *			Flag indicating that memory has been allocated to hold the internal
 *			"PDU" object key.
 *		m_cbDataSize
 *			Variable holding the size of the memory which will be required to
 *			hold any data referenced by the "API" GCCObjectKey structure.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */
#include "objkey.h"

/*
 *	CObjectKeyContainer()
 *
 *	Public Function Description:
 *		This constructor is used to create an CObjectKeyContainer object from
 *		an "API" GCCObjectKey.
 */
CObjectKeyContainer::CObjectKeyContainer(PGCCObjectKey		 	object_key,
						                PGCCError				pRetCode)
:
    CRefCount(MAKE_STAMP_ID('O','b','j','K')),
    m_fValidObjectKeyPDU(FALSE),
    m_cbDataSize(0)
{
	GCCError                rc = GCC_NO_ERROR;
	BOOL    				object_key_is_valid = TRUE;
	UINT					object_id_size;

	m_InternalObjectKey.object_id_key = NULL;
	m_InternalObjectKey.poszNonStandardIDKey = NULL;

	/*
	 * Check to see what type of key is contained in the object key.
	 * Object ID keys will be stored internally in a Memory object and
	 * non-standard ID keys will be stored internally as Octet Strings.
	 */
	if (object_key->key_type == GCC_OBJECT_KEY)
	{
		/*
		 * The key is of type object ID.  Perform a parameter check for a legal
		 * object ID by examining the first two arcs in the object ID.
		 */
		if (object_key->object_id.long_string_length >= MINIMUM_OBJECT_ID_ARCS)
		{
			object_key_is_valid = ValidateObjectIdValues(
					object_key->object_id.long_string[0],
					object_key->object_id.long_string[1]);
		}
		else
		{
			object_key_is_valid = FALSE;
		}

		if (object_key_is_valid)
		{
			/*
			 * The key is of type Object ID.  Determine the amount of memory
			 * required to hold the Object ID and allocate it.  Copy the Object
			 * ID values from the object key passed in into the internal
			 * structure. 
			 */
			m_InternalObjectKey.object_id_length = object_key->object_id.long_string_length;
			object_id_size = m_InternalObjectKey.object_id_length * sizeof(UINT);
            DBG_SAVE_FILE_LINE
			m_InternalObjectKey.object_id_key = new BYTE[object_id_size];
			if (m_InternalObjectKey.object_id_key != NULL)
			{
				::CopyMemory(m_InternalObjectKey.object_id_key,
				             object_key->object_id.long_string,
				             object_id_size);
			}
			else
			{
				ERROR_OUT(("CObjectKeyContainer::CObjectKeyContainer: Error allocating memory"));
				rc = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			ERROR_OUT(("CObjectKeyContainer::CObjectKeyContainer: Object ID has illegal values."));
			rc = GCC_BAD_OBJECT_KEY;
		}
	}
	else
	{
		/*
		 * The key is non-standard.  Check to make sure the length of the 
		 * non-standard ID is within the allowable limits.
		 */
		if ((object_key->h221_non_standard_id.length >= 
					MINIMUM_NON_STANDARD_ID_LENGTH) &&
			(object_key->h221_non_standard_id.length <= 
					MAXIMUM_NON_STANDARD_ID_LENGTH))
		{
			/*
			 * The key is of type H221 non-standard ID.  Create a new Rogue
			 * Wave string container to hold the non-standard data.
			 */
			if (NULL == (m_InternalObjectKey.poszNonStandardIDKey = ::My_strdupO2(
				 				object_key->h221_non_standard_id.value,
				 				object_key->h221_non_standard_id.length)))
			{
				ERROR_OUT(("CObjectKeyContainer::CObjectKeyContainer: Error creating non standard id key"));
				rc = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			ERROR_OUT(("CObjectKeyContainer::CObjectKeyContainer:  Non standard ID is outside legal range"));
			rc = GCC_BAD_OBJECT_KEY;
		}
	}

    *pRetCode = rc;
}

/*
 *	CObjectKeyContainer()
 *
 *	Public Function Description:
 *		This constructor is used to create an CObjectKeyContainer object from
 *		a "PDU" Key.
 */
CObjectKeyContainer::CObjectKeyContainer(PKey				object_key,
						                PGCCError			pRetCode)
:
    CRefCount(MAKE_STAMP_ID('O','b','j','K')),
    m_fValidObjectKeyPDU(FALSE),
    m_cbDataSize(0)
{
	GCCError            rc = GCC_NO_ERROR;
	PSetOfObjectID		object_id_set_ptr;
	UINT               *object_id_ptr;
	UINT				object_id_size = 0;
	Int					i = 0;

	m_InternalObjectKey.object_id_key = NULL;
	m_InternalObjectKey.object_id_length = 0;
	m_InternalObjectKey.poszNonStandardIDKey = NULL;

	/*
	 * Check to see what type of key is contained in the object key.
	 * Object ID keys will be stored internally in a Memory object and
	 * non-standard ID keys will be stored internally in Rogue Wave string
	 * containers.
	 */
	if (object_key->choice == OBJECT_CHOSEN)
	{
		/*
		 * Retrieve the first object ID pointer from the "PDU" structure in
		 * preparation for determining how much memory will be needed to hold
		 * the object ID values.
		 */
		object_id_set_ptr = object_key->u.object;

		/*
		 * Loop through the ObjectID structure, adding up the size of the 
		 * string.
		 */
		while (object_id_set_ptr != NULL)
		{
			m_InternalObjectKey.object_id_length++;
			object_id_set_ptr = object_id_set_ptr->next;
		}

		object_id_size = m_InternalObjectKey.object_id_length * sizeof(UINT);

		/*
		 * Allocate the memory to be used to hold the object ID values.
		 */
		DBG_SAVE_FILE_LINE
		m_InternalObjectKey.object_id_key = new BYTE[object_id_size];
		if (m_InternalObjectKey.object_id_key != NULL)
		{
			object_id_ptr = (UINT *) m_InternalObjectKey.object_id_key;

			/*
			 * Again retrieve the first object ID pointer from the "PDU" 
			 * structure in	order to get the values out for saving.
			 */
			object_id_set_ptr = object_key->u.object;

			/*
			 * Loop through the ObjectID structure, getting each object ID
			 * value and saving it in the allocated memory.
			 */
			while (object_id_set_ptr != NULL)
			{
				object_id_ptr[i++] = object_id_set_ptr->value;
				object_id_set_ptr = object_id_set_ptr->next;
			}
		} 
		else
		{
			ERROR_OUT(("CObjectKeyContainer::CObjectKeyContainer: Error allocating memory."));
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		/*
		 * The key is of type H221 non-standard ID so create a new Rogue Wave
		 * string container to hold the data.
		 */
		if (NULL == (m_InternalObjectKey.poszNonStandardIDKey = ::My_strdupO2(
						object_key->u.h221_non_standard.value,
						object_key->u.h221_non_standard.length)))
		{
			ERROR_OUT(("CObjectKeyContainer::CObjectKeyContainer: Error creating non standard id key"));
			rc = GCC_ALLOCATION_FAILURE;
		}
	}

    *pRetCode = rc;
}

/*
 *	CObjectKeyContainer()
 *
 *	Public Function Description:
 *		This copy constructor is used to create a new CObjectKeyContainer object from
 *		another CObjectKeyContainer object.
 */
CObjectKeyContainer::CObjectKeyContainer(CObjectKeyContainer	*object_key,
						                PGCCError				pRetCode)
:
    CRefCount(MAKE_STAMP_ID('O','b','j','K')),
    m_fValidObjectKeyPDU(FALSE),
    m_cbDataSize(0)
{
	GCCError    rc = GCC_NO_ERROR;
	UINT		object_id_size;

	m_InternalObjectKey.object_id_key = NULL;
	m_InternalObjectKey.poszNonStandardIDKey = NULL;

	/*
	 * If an object ID "key" exists for the CObjectKeyContainer to be copied,
	 * allocate memory to hold the object ID "key" information internally.
	 * Check to make sure construction of the object is successful.
	 */
	if (object_key->m_InternalObjectKey.object_id_key != NULL)
	{
		/*
		 * The key is of type Object ID.
		 */
		m_InternalObjectKey.object_id_length = object_key->m_InternalObjectKey.object_id_length;
		object_id_size = m_InternalObjectKey.object_id_length * sizeof(UINT);

        DBG_SAVE_FILE_LINE
		m_InternalObjectKey.object_id_key = new BYTE[object_id_size];
		if (m_InternalObjectKey.object_id_key != NULL)
		{
			::CopyMemory(m_InternalObjectKey.object_id_key,
			             object_key->m_InternalObjectKey.object_id_key,
			             object_id_size);
		}
		else
		{
			ERROR_OUT(("CObjectKeyContainer::CObjectKeyContainer: Error allocating memory"));
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	else if (object_key->m_InternalObjectKey.poszNonStandardIDKey != NULL)
	{
		/*
		 * If a non-standard ID "key" exists for the CObjectKeyContainer to be copied,
		 * create a new Rogue Wave string to hold the non-standard "key" 
		 * information internally.  Check to make sure construction of the
		 * object is successful.
		 */
		if (NULL == (m_InternalObjectKey.poszNonStandardIDKey = ::My_strdupO(
							object_key->m_InternalObjectKey.poszNonStandardIDKey)))
		{
			ERROR_OUT(("CObjectKeyContainer::CObjectKeyContainer: Error creating new non standard id key"));
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		/*
		 * At least one of the internal pointers for the passed in object key 
		 * must be valid.
		 */
		ERROR_OUT(("CObjectKeyContainer::CObjectKeyContainer: Bad input parameters"));
		rc = GCC_BAD_OBJECT_KEY;
	}

    *pRetCode = rc;
}

/*
 *	~CObjectKeyContainer()
 *
 *	Public Function Description
 *		The CObjectKeyContainer destructor is responsible for freeing any memory
 *		allocated to hold the object key data.
 *
 */
CObjectKeyContainer::~CObjectKeyContainer(void)
{
	/*
	 * If "PDU" data has been allocated for this object, free it now.
	 */
	if (m_fValidObjectKeyPDU)
	{
		FreeObjectKeyDataPDU();
	}

	/* 
	 * Delete any object key data held internally.
	 */
	delete m_InternalObjectKey.object_id_key;
	delete m_InternalObjectKey.poszNonStandardIDKey;
}

/*
 *	LockObjectKeyData ()
 *
 *	Public Function Description:
 *		This routine locks the object key data and determines the amount of
 *		memory referenced by the "API" object key data structure.
 */
UINT CObjectKeyContainer::LockObjectKeyData(void)
{
	/*
	 * If this is the first time this routine is called, determine the size of 
	 * the memory required to hold the data referenced by the object key
	 * structure.  Otherwise, just increment the lock count.
	 */
	if (Lock() == 1)
	{
		/*
		 * Determine the amount of space required to hold the data referenced
		 * by the "API" Object Key structure.
		 */
		if (m_InternalObjectKey.object_id_key != NULL)
		{
			/*
			 * Since the object ID is just a series of "longs" without a NULL
			 * terminator, we do not want to include a NULL terminator when 
			 * determining the length.
			 */
			m_cbDataSize = m_InternalObjectKey.object_id_length * sizeof(UINT);
		}
		else
		{
			/*
			 * The data referenced by the non-standard object key is just the
			 * length of the octet string.
			 */
			m_cbDataSize = m_InternalObjectKey.poszNonStandardIDKey->length;
		}

		/*
		 * Force the size to be on a four-byte boundary.
		 */
		m_cbDataSize = ROUNDTOBOUNDARY(m_cbDataSize);
	}

	return m_cbDataSize;
}

/*
 *	GetGCCObjectKeyData ()
 *
 *	Public Function Description:
 *		This routine retrieves object key data in the form of an "API"
 *		GCCObjectKey.  This routine is called after "locking" the object 
 *		key data.
 */
UINT CObjectKeyContainer::GetGCCObjectKeyData(
								PGCCObjectKey 		object_key,
								LPBYTE				memory)
{
	UINT	cbDataSizeToRet = 0;
	UINT   *object_id_ptr;

	/*
	 * If the object key data has been locked, fill in the output structure and
	 * the data referenced by the structure.  Otherwise, report that the object
	 * key has yet to be locked into the "API" form.
	 */ 
	if (GetLockCount() > 0)
	{
		/*
		 * Fill in the output length parameter which indicates how much data
		 * referenced outside the structure will be written.
		 */
		cbDataSizeToRet = m_cbDataSize;

		if (m_InternalObjectKey.object_id_key != NULL)
		{
			/*
			 * The object key is a standard type.  Set the object key type 
			 * and the length of the long string. The length set here does 
			 * not include a NULL terminator.
			 */
			object_key->key_type = GCC_OBJECT_KEY;
			object_key->object_id.long_string_length = (USHORT) m_InternalObjectKey.object_id_length;

			/*
			 * Set the offset for the long string equal to the memory pointer
			 * passed in since it will be the first data referenced by the 
			 * object key structure.
			 */
			object_key->object_id.long_string = (ULONG *) memory;

			/*
			 * Now retrieve the memory pointer and copy the long string data 
			 * from the internal memory object.  
			 */		
			object_id_ptr = (UINT *) m_InternalObjectKey.object_id_key;

			::CopyMemory(memory, object_id_ptr, 
						m_InternalObjectKey.object_id_length * sizeof (UINT));
		}
		else if (m_InternalObjectKey.poszNonStandardIDKey != NULL)
		{
			/*
			 * The object key is a non-standard type.  Set the object key 
			 * type and the length of the octet string.
			 */
			object_key->key_type = GCC_H221_NONSTANDARD_KEY;
			object_key->h221_non_standard_id.length =
						m_InternalObjectKey.poszNonStandardIDKey->length;

			/*
			 * Set the offset for the octet string equal to the memory pointer
			 * passed in since it will be the first data referenced by the 
			 * object key structure.
			 */
			object_key->h221_non_standard_id.value = memory;

			/*
			 * Now copy the octet string data from the internal Rogue Wave
			 * string into the object key structure held in memory.
			 */		
			::CopyMemory(memory, m_InternalObjectKey.poszNonStandardIDKey->value,
									m_InternalObjectKey.poszNonStandardIDKey->length);
		}
		else
		{
			ERROR_OUT(("CObjectKeyContainer::LockObjectKeyData: Error, no valid internal data"));
		}
	}
	else
	{
		object_key = NULL;
		ERROR_OUT(("CObjectKeyContainer::GetGCCObjectKeyData: Error Data Not Locked"));
	}

	return cbDataSizeToRet;
}

/*
 *	UnLockObjectKeyData ()
 *
 *	Public Function Description:
 *		This routine decrements the lock count and frees the memory associated
 *		with the "API" object key once the lock count reaches zero.
 */
void CObjectKeyContainer::UnLockObjectKeyData(void)
{
    Unlock();
}

/*
 *	GetObjectKeyDataPDU ()
 *
 *	Public Function Description:
 *		This routine converts the object key from it's internal form of an
 *		OBJECT_KEY structure into the "PDU" form which can be passed in
 *		to the ASN.1 encoder.  A pointer to a "PDU" "Key" structure is 
 *		returned.
 */
GCCError CObjectKeyContainer::GetObjectKeyDataPDU(PKey object_key)
{
	PSetOfObjectID			new_object_id_ptr;
	PSetOfObjectID			old_object_id_ptr;
	UINT                   *object_id_string;
	GCCError				rc = GCC_NO_ERROR;
	UINT					i;

	/*
	 * Set the loop pointer to NULL to avoid a compiler warning.
	 */
    old_object_id_ptr = NULL;

	/*
	 * If this is the first time that PDU data has been requested then we must
	 * fill in the internal PDU structure and copy it into the structure pointed
	 * to by the output parameter.  On subsequent calls to "GetPDU" we can just
	 * copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	if (m_fValidObjectKeyPDU == FALSE)
	{
		m_fValidObjectKeyPDU = TRUE;

		/*
		 * Fill in the "PDU" object key after checking to see what form of 
		 * key exists in the internal structure.
		 */
		if (m_InternalObjectKey.object_id_key != NULL)
		{
			/*
			 * The key is an object ID so set the choice accordingly and 
			 * initialize the PDU object pointer to NULL.  Get the pointer to
			 * the internal list of object key values stored in the memory
			 * object.
			 */
			m_ObjectKeyPDU.choice = OBJECT_CHOSEN;
			m_ObjectKeyPDU.u.object = NULL;

			object_id_string = (UINT *) m_InternalObjectKey.object_id_key;

			/*
			 * The "PDU" structure "ObjectID" is a linked list of unsigned
			 * longs.  Retrieve the Object ID values from the internal memory
			 * object and fill in the "ObjectID" structure. 
			 */
			for (i=0; i<m_InternalObjectKey.object_id_length; i++)
			{
				DBG_SAVE_FILE_LINE
				new_object_id_ptr = new SetOfObjectID;
				if (new_object_id_ptr != NULL)
				{
					/*
					 * The first time through the new pointer is saved in the
					 * PDU structure.  On subsequent iterations, the previous
					 * "next" pointer is set equal to the new pointer.
					 */
					if (m_ObjectKeyPDU.u.object == NULL)
                    {
						m_ObjectKeyPDU.u.object = new_object_id_ptr;
                    }
					else
                    {
						old_object_id_ptr->next = new_object_id_ptr;
                    }

                    old_object_id_ptr = new_object_id_ptr;

					/*
					 * Save the actual Object ID value.
					 */
					new_object_id_ptr->value = object_id_string[i];
					new_object_id_ptr->next = NULL;
				}
				else
				{
					ERROR_OUT(("CObjectKeyContainer::GetObjectKeyDataPDU: creating new ObjectID"));
					rc = GCC_ALLOCATION_FAILURE;
					break;
				}
			}
		}
		else if (m_InternalObjectKey.poszNonStandardIDKey != NULL)
		{
			/*
			 * The key is a non-standard ID so convert the internal Rogue Wave
			 * string into the "PDU" non-standard ID.
			 */
			m_ObjectKeyPDU.choice = H221_NON_STANDARD_CHOSEN;
			m_ObjectKeyPDU.u.h221_non_standard.length =
					m_InternalObjectKey.poszNonStandardIDKey->length;

			::CopyMemory(m_ObjectKeyPDU.u.h221_non_standard.value,
							m_InternalObjectKey.poszNonStandardIDKey->value,
							m_InternalObjectKey.poszNonStandardIDKey->length);
		}
		else
		{
			/*
			 * The constructors make sure that at least one of the internal
			 * pointers is valid so this should never be encountered.
			 */
			ERROR_OUT(("CObjectKeyContainer::GetObjectKeyDataPDU: No valid m_InternalObjectKey"));
			rc = GCC_ALLOCATION_FAILURE;
		}
	}

	/*
	 * Copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	*object_key = m_ObjectKeyPDU;

	return rc;
}

/*
 *	FreeObjectKeyDataPDU ()
 *
 *	Public Function Description:
 *		This routine is used to free the object key data held internally in
 *		the "PDU" form of a "Key".
 */
void CObjectKeyContainer::FreeObjectKeyDataPDU(void)
{
	PSetOfObjectID		set_of_object_id;
	PSetOfObjectID		next_set_of_object_id;

	if (m_fValidObjectKeyPDU)
	{
		/*
		 * Set the flag indicating that PDU object key data is no longer
		 * allocated.
		 */
		m_fValidObjectKeyPDU = FALSE;

		if (m_ObjectKeyPDU.choice == OBJECT_CHOSEN)
		{
            for (set_of_object_id = m_ObjectKeyPDU.u.object;
                    set_of_object_id != NULL;
					set_of_object_id = next_set_of_object_id)
            {
				next_set_of_object_id = set_of_object_id->next;
				delete set_of_object_id;
			}
		}
	}
}

/*
 *	operator== ()
 *
 *	Public Function Description:
 *		This routine is used to compare two CObjectKeyContainer objects to determine
 *		if they are equal in value.
 */
BOOL operator==(const CObjectKeyContainer& object_key_1, const CObjectKeyContainer& object_key_2)
{
	UINT       *object_id_1, *object_id_2;
	UINT		i;
	BOOL    	rc = FALSE;
	
	/*
	 * Check to make sure that both the object ID key and the non-standard
	 * ID key are equal.
	 */
	if ((object_key_1.m_InternalObjectKey.object_id_key != NULL) && 
			(object_key_2.m_InternalObjectKey.object_id_key != NULL))
	{
		if (object_key_1.m_InternalObjectKey.object_id_length == 
				object_key_2.m_InternalObjectKey.object_id_length)
		{
			object_id_1 = (UINT *) object_key_1.m_InternalObjectKey.object_id_key;
			object_id_2 = (UINT *) object_key_2.m_InternalObjectKey.object_id_key;

			/*
			 * Compare each Object ID value to make sure they are equal.
			 */
			rc = TRUE;
			for (i=0; i<object_key_1.m_InternalObjectKey.object_id_length; i++)
			{
				if (object_id_1[i] != object_id_2[i])
				{
					rc = FALSE;
					break;
				}
			}
		}
	} 
	else
	if (0 == My_strcmpO(object_key_1.m_InternalObjectKey.poszNonStandardIDKey,
						object_key_2.m_InternalObjectKey.poszNonStandardIDKey))
	{
		rc = TRUE;
	} 

	return rc;
}

/*
 *	BOOL    	ValidateObjectIdValues (	UINT		first_arc,
 *											UINT		second_arc);
 *
 *	Private member function of CObjectKeyContainer.
 *
 *	Function Description:
 *		This routine is used to determine whether or not the values for the
 *		object ID component of the object key are valid.
 *
 *	Formal Parameters:
 *		first_arc			(i) The first integer value of the Object ID.
 *		second_arc			(i) The second integer value of the Object ID.
 *
 *	Return Value:
 *		TRUE				-	The first two arcs of the Object ID are valid.
 *		FALSE				- 	The first two arcs of the Object ID are not 
 *									valid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
BOOL CObjectKeyContainer::ValidateObjectIdValues(UINT first_arc, UINT second_arc)
{
	BOOL rc = FALSE;

	if (first_arc == ITUT_IDENTIFIER)
	{
		if (second_arc <= 4)
		{
			rc = TRUE;
		} 
	}
	else if (first_arc == ISO_IDENTIFIER)
	{
		if ((second_arc == 0L) ||
			(second_arc == 2L) ||
			(second_arc == 3L))
		{
			rc = TRUE;
		} 
	}
	else if (first_arc == JOINT_ISO_ITUT_IDENTIFIER)
	{
		/*
		 * Referring to ISO/IEC 8824-1 : 1994 (E) Annex B:
		 * Join assignment of OBJECT IDENTIFIER component values are assigned
		 * and agreed from time to time by ISO and ITU-T to identify areas of
		 * joint ISO/ITU-T standardization activity, in accordance with the
		 * procedures of .... ANSI.  So we just let them all through for now.
		 */
		rc = TRUE;
	}
	else
	{
		ERROR_OUT(("ObjectKeyData::ValidateObjectIdValues: ObjectID is invalid"));
	}

	return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\appcap.h ===
/*
 *	appcap.h
 *
 *	Copyright (c) 1993 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class ApplicationaCapabilityData.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */
#ifndef	_APP_CAPABILITY_DATA_
#define	_APP_CAPABILITY_DATA_

#include "capid.h"
#include "cntlist.h"

/*
**	Below is the definition for all the capabilities related structures and
**	containers.  The ListOfCapabilitiesList definition is used to maintain
**	all of the individual capabilities list at a single node (for multiple
**	protocol entities).
*/
typedef struct APP_CAP_ITEM
{
	APP_CAP_ITEM(GCCCapabilityType eCapType);
	APP_CAP_ITEM(APP_CAP_ITEM *p, GCCError *pError);
	~APP_CAP_ITEM(void);

    // in non-collapsing case, pCapID and poszAppData are used.
    // in appcap case, all but poszAppData are used.
    // in invoklst case, pCapID, eCapType, and the union are used.
	CCapIDContainer             *pCapID;
	GCCCapabilityType			eCapType;
	UINT       					cEntries;
	LPOSTR						poszAppData;	//	For Non-Collapsing only
	union 
	{
		UINT	nUnsignedMinimum;
		UINT	nUnsignedMaximum;
	};
}
    APP_CAP_ITEM;


/*
**	Holds the list of individual capabilities for a single Application Protocol 
**	Entity.  Remember that a single APE can have many capabilities.  
*/
class CAppCapItemList : public CList
{
    DEFINE_CLIST(CAppCapItemList, APP_CAP_ITEM*)
    void DeleteList(void);
};



// LONCHANC: CAppCap and CNonCollAppCap are very similar to each.

class CAppCap : public CRefCount
{
public:

	CAppCap(UINT cCaps, PGCCApplicationCapability *, PGCCError);
	~CAppCap(void);

	UINT		GetGCCApplicationCapabilityList(USHORT *pcCaps, PGCCApplicationCapability **, LPBYTE memory);

	UINT		LockCapabilityData(void);
	void		UnLockCapabilityData(void);

protected:

	UINT			    m_cbDataSize;
	CAppCapItemList     m_AppCapItemList;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\alarm.h ===
/*
 *	alarm.h
 *
 *	Copyright (c) 1994 by DataBeam Corporation, Lexington, Kentucky
 *
 *	Abstract:
 *		
 *	Caveats:
 *		None
 *
 *	Author:
 *		James P. Galvin, Jr.
 *
 *	Revision History:
 *		09JAN95   jpg	Original
 */
#ifndef	_ALARM_
#define	_ALARM_

/*
 *	This is the class definition for the Alarm class.
 */
class CAlarm
{
public:

	CAlarm(UINT nDuration);
	~CAlarm(void) { }

	void			Set(UINT nDuration);
	void			Reset(void);
	void			Expire(void) { m_fExpired = TRUE; }
	BOOL			IsExpired(void);

private:

	UINT			m_nDuration;
	UINT			m_nStartTime;
	BOOL			m_fExpired;
};

typedef		CAlarm		Alarm,	*PAlarm;

/*
 *	Alarm (
 *			Long			duration)
 *	
 *	Function Description
 *
 *	Formal Parameters
 *		
 *	Return value
 *
 *	Side Effects
 *
 *	Caveats
 */

/*
 *	~Alarm ()
 *	
 *	Function Description
 *
 *	Formal Parameters
 *		
 *	Return value
 *
 *	Side Effects
 *
 *	Caveats
 */

/*
 *	Void	Set (
 *					Long			duration)
 *	
 *	Function Description
 *
 *	Formal Parameters
 *		
 *	Return value
 *
 *	Side Effects
 *
 *	Caveats
 */

/*
 *	Void	Reset ()
 *	
 *	Function Description
 *
 *	Formal Parameters
 *		
 *	Return value
 *
 *	Side Effects
 *
 *	Caveats
 */

/*
 *	Long	GetTimeRemaining ()
 *	
 *	Function Description
 *
 *	Formal Parameters
 *		
 *	Return value
 *
 *	Side Effects
 *
 *	Caveats
 */

/*
 *	Void	Expire ()
 *	
 *	Function Description
 *
 *	Formal Parameters
 *		
 *	Return value
 *
 *	Side Effects
 *
 *	Caveats
 */

/*
 *	BOOL		IsExpired ()
 *	
 *	Function Description
 *
 *	Formal Parameters
 *		
 *	Return value
 *
 *	Side Effects
 *
 *	Caveats
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\appldr.h ===
#ifndef  __APPLET_LOADER_H
#define  __APPLET_LOADER_H


#include "iappldr.h"

typedef struct {
	HINSTANCE       hLibApplet;
	IAppletLoader   *pIAppLoader;
	APPLET_STATUS   eStatus;
	int				cLoads;
} AppLoaderInfo;


T120Error AppLdr_Initialize(void);
void AppLdr_Shutdown(void);


#endif // __APPLET_LOADER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\common\sesskey.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_UTILITY);
/* 
 *	sesskey.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the class CSessKeyContainer. This class 
 *		manages the data associated with a Session Key. Session Key's are used
 *		to uniquely identify an Application Protocol Session.  The Application
 *		Protocol is identified by an Object Key and the particular session
 *		identified by an optional session ID.  The CSessKeyContainer class uses an
 *		CObjectKeyContainer container to maintain the object key data internally.  An
 *		unsigned short integer is used to hold the optional session ID. 
 *
 *	Protected Instance Variables:
 *		m_InternalSessKey
 *			Structure used to hold the object key data internally.
 *		m_SessionKeyPDU
 *			Storage for the "PDU" form of the session key.
 *		m_fValidSessionKeyPDU
 *			Flag indicating that memory has been allocated to hold the internal
 *			"PDU" session key.
 *		m_cbDataSize
 *			Variable holding the size of the memory which will be required to
 *			hold any data referenced by the "API" GCCSessionKey structure.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */


#include "sesskey.h"

/*
 *	CSessKeyContainer()
 *
 *	Public Function Description:
 *		This constructor is used to create a CSessKeyContainer object from
 *		an "API" GCCSessionKey.
 */
CSessKeyContainer::
CSessKeyContainer(PGCCSessionKey session_key, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('S','e','s','K')),
    m_fValidSessionKeyPDU(FALSE),
    m_cbDataSize(0)
{
    GCCError rc;

	/*
	 * Save the Object Key portion of the Session Key in the internal structure
	 * by creating a new CObjectKeyContainer object.  Check to make sure the object
	 * is successfully created.
	 */
	DBG_SAVE_FILE_LINE
	m_InternalSessKey.application_protocol_key = new CObjectKeyContainer(
										&session_key->application_protocol_key,
										&rc);
	if (NULL != m_InternalSessKey.application_protocol_key && GCC_NO_ERROR == rc)
	{
    	/*
    	 * Save the session ID if the CObjectKeyContainer was saved correctly.  A zero 
    	 * value of the GCC session ID will indicate that one is not actually
    	 * present.
    	 */
    	m_InternalSessKey.session_id = session_key->session_id;
	}
	else if (GCC_BAD_OBJECT_KEY == rc)
	{
		ERROR_OUT(("CSessKeyContainer::SessionKeyData1: bad session key"));
		rc = GCC_BAD_SESSION_KEY;
	}
	else
	{
		ERROR_OUT(("CSessKeyContainer::SessionKeyData1: Error creating new CObjectKeyContainer"));
		rc = GCC_ALLOCATION_FAILURE;
	}

    *pRetCode = rc;
}

/*
 *	CSessKeyContainer()
 *
 *	Public Function Description:
 *		This constructor is used to create a CSessKeyContainer object from
 *		a "PDU" SessionKey.
 */
CSessKeyContainer::
CSessKeyContainer(PSessionKey session_key, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('S','e','s','K')),
    m_fValidSessionKeyPDU(FALSE),
    m_cbDataSize(0)
{
    GCCError rc;

	/*
	 * Save the Object Key portion of the Session Key in the internal structure
	 * by creating a new CObjectKeyContainer object.  Check to make sure the object
	 * is successfully created.
	 */
	DBG_SAVE_FILE_LINE
	m_InternalSessKey.application_protocol_key = new CObjectKeyContainer(
										&session_key->application_protocol_key,
										&rc);
	if (NULL != m_InternalSessKey.application_protocol_key && GCC_NO_ERROR == rc)
	{
    	/*
    	 * Save the session ID if one is present and the CObjectKeyContainer was saved 
    	 * correctly.  If a session ID is not present, set the internal session ID
    	 * to zero to indicate this.
    	 */
    	if (session_key->bit_mask & SESSION_ID_PRESENT)
    	{
    		m_InternalSessKey.session_id = session_key->session_id;
    	}
    	else
    	{
    		m_InternalSessKey.session_id = 0;
    	}
	}
	else if (GCC_BAD_OBJECT_KEY == rc)
	{
		ERROR_OUT(("CSessKeyContainer::SessionKeyData2: bad session key"));
		rc = GCC_BAD_SESSION_KEY;
	}
	else
	{
		ERROR_OUT(("CSessKeyContainer::SessionKeyData2: Error creating new CObjectKeyContainer"));
		rc = GCC_ALLOCATION_FAILURE;
	}

    *pRetCode = rc;
}

/*
 *	CSessKeyContainer()
 *
 *	Public Function Description:
 *		This copy constructor is used to create a new CSessKeyContainer object from
 *		another CSessKeyContainer object.
 */
CSessKeyContainer::
CSessKeyContainer(CSessKeyContainer *session_key, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('S','e','s','K')),
    m_fValidSessionKeyPDU(FALSE),
    m_cbDataSize(0)
{
    GCCError rc;

	/*
	 * Copy the Object Key portion of the Session Key using the copy constructor
	 * of the CObjectKeyContainer class.  Check to make sure the CObjectKeyContainer object
	 * is successfully created.
	 */
	DBG_SAVE_FILE_LINE
	m_InternalSessKey.application_protocol_key = new CObjectKeyContainer(
							session_key->m_InternalSessKey.application_protocol_key,
							&rc);
	if (NULL != m_InternalSessKey.application_protocol_key && GCC_NO_ERROR == rc)
	{
    	/*
    	 * Save the session ID if the CObjectKeyContainer was saved correctly.  A zero 
    	 * value of the GCC session ID will indicate that one is not actually
    	 * present.
    	 */
    	m_InternalSessKey.session_id = session_key->m_InternalSessKey.session_id;
	}
	else if (GCC_BAD_OBJECT_KEY == rc)
	{
		ERROR_OUT(("CSessKeyContainer::SessionKeyData3: bad session key"));
		rc = GCC_BAD_SESSION_KEY;
	}
	else
	{
		ERROR_OUT(("CSessKeyContainer::SessionKeyData3: Error creating new CObjectKeyContainer"));
		rc = GCC_ALLOCATION_FAILURE;
	}

    *pRetCode = rc;
}

/*
 *	~CSessKeyContainer()
 *
 *	Public Function Description
 *		The CSessKeyContainer destructor is responsible for freeing any memory
 *		allocated to hold the session key data.
 *
 */
CSessKeyContainer::
~CSessKeyContainer(void)
{
	/*
	 * If "PDU" data has been allocated for this object, free it now.
	 */
	if (m_fValidSessionKeyPDU)
	{
		FreeSessionKeyDataPDU();
	}

	/* 
	 * Delete any object key data held internally.
	 */
	if (NULL != m_InternalSessKey.application_protocol_key)
	{
	    m_InternalSessKey.application_protocol_key->Release();
	}
}

/*
 *	LockSessionKeyData ()
 *
 *	Public Function Description:
 *		This routine locks the session key data and determines the amount of
 *		memory referenced by the "API" session key data structure.
 */
UINT CSessKeyContainer::
LockSessionKeyData(void)
{
	/*
	 * If this is the first time this routine is called, determine the size of 
	 * the memory required to hold the data referenced by the session key
	 * structure.  Otherwise, just increment the lock count.
	 */
	if (Lock() == 1)
	{
		/*
		 * Lock the data for the object key held within the session key.  The
		 * pointer to the CObjectKeyContainer object is validated in the constructor.
		 */
		m_cbDataSize = m_InternalSessKey.application_protocol_key->LockObjectKeyData();
	}

	return m_cbDataSize;
}

/*
 *	GetGCCSessionKeyData ()
 *
 *	Public Function Description:
 *		This routine retrieves session key data in the "API" form of a 
 *		GCCSessionKey.  This routine is called after "locking" the session
 *		key data.
 */
UINT CSessKeyContainer::
GetGCCSessionKeyData(PGCCSessionKey session_key, LPBYTE memory)
{
	UINT cbDataSizeToRet = 0;

	/*
	 * If the session key data has been locked, fill in the output structure and
	 * the data referenced by the structure.  Call the "Get" routine for the 
	 * ObjectKey to fill in the object key data.
	 */ 
	if (GetLockCount() > 0)
	{
		/*
		 * Fill in the output length parameter which indicates how much data
		 * referenced outside the structure will be written.
		 */
		cbDataSizeToRet = m_cbDataSize;
        ::ZeroMemory(memory, m_cbDataSize);

		session_key->session_id = m_InternalSessKey.session_id;

		m_InternalSessKey.application_protocol_key->GetGCCObjectKeyData(
				&session_key->application_protocol_key,
				memory);
	}
	else
	{
		ERROR_OUT(("CSessKeyContainer::GetGCCSessionKeyData: Error: data not locked"));
	}

	return cbDataSizeToRet;
}

/*
 *	UnlockSessionKeyData ()
 *
 *	Public Function Description:
 *		This routine decrements the lock count and frees the memory associated 
 *		with the "API" session key once the lock count reaches zero.
 */
void CSessKeyContainer::
UnLockSessionKeyData(void)
{
	if (Unlock(FALSE) == 0)
	{
		/*
		 * Unlock the data associated with the internal CObjectKeyContainer and
		 * delete this object if the "free flag" is set.
		 */
		if (m_InternalSessKey.application_protocol_key != NULL)
		{
			m_InternalSessKey.application_protocol_key->UnLockObjectKeyData(); 
		} 
	}

    // we have to call Release() because we used Unlock(FALSE)
    Release();
}

/*
 *	GetSessionKeyDataPDU ()
 *
 *	Public Function Description:
 *		This routine converts the session key from it's internal form of a
 *		SESSION_KEY structure into the "PDU" form which can be passed in
 *		to the ASN.1 encoder.  A pointer to a "PDU" "SessionKey" structure is 
 *		returned.
 */
GCCError CSessKeyContainer::
GetSessionKeyDataPDU(PSessionKey session_key)
{
	GCCError	rc = GCC_NO_ERROR;

	/*
	 * If this is the first time that PDU data has been requested then we must
	 * fill in the internal PDU structure and copy it into the structure pointed
	 * to by the output parameter.  On subsequent calls to "GetPDU" we can just
	 * copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	if (m_fValidSessionKeyPDU == FALSE)
	{
		m_fValidSessionKeyPDU = TRUE;

		/*
		 * Initialize the "PDU" session key's bit mask to zero.
		 */
		m_SessionKeyPDU.bit_mask = 0;

		/*
		 * Fill in the "PDU" session key from the internal structure.
		 */
		if (m_InternalSessKey.application_protocol_key != NULL)
		{
			/*
			 * Fill in the object key portion of the session key by using the
			 * "GetPDU" routine of the internal CObjectKeyContainer object.
			 */
			rc = m_InternalSessKey.application_protocol_key->
					GetObjectKeyDataPDU(&m_SessionKeyPDU.application_protocol_key);
		}
		else
		{
			rc = GCC_ALLOCATION_FAILURE;
		}

		/*
		 * Fill in the "PDU" session ID if one exists.  A value of zero for the
		 * internal session ID indicates that one really does not exist.
		 */
		if (m_InternalSessKey.session_id != 0)
		{
			m_SessionKeyPDU.bit_mask |= SESSION_ID_PRESENT;
			m_SessionKeyPDU.session_id = m_InternalSessKey.session_id;
		}
	}

	/*
	 * Copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	*session_key = m_SessionKeyPDU;

	return rc;
}

/*
 *	FreeSessionKeyDataPDU ()
 *
 *	Public Function Description:
 *		This routine is used to free the session key data held internally in
 *		the "PDU" form of a "SessionKey".
 */
void CSessKeyContainer::
FreeSessionKeyDataPDU(void)
{
	if (m_fValidSessionKeyPDU)
	{
		/*
		 * Set the flag indicating that PDU session key data is no longer
		 * allocated.
		 */
		m_fValidSessionKeyPDU = FALSE;

		if (m_InternalSessKey.application_protocol_key != NULL)
		{
			m_InternalSessKey.application_protocol_key->FreeObjectKeyDataPDU ();
		}
		else
		{
			ERROR_OUT(("CSessKeyContainer::FreeSessionKeyDataPDU: Bad internal pointer"));
		}
	}
}

/*
 *	IsThisYourApplicationKey()
 *
 *	Public Function Description:
 *		This routine is used to determine whether the specified application
 *		key is held within this session key.
 */
BOOL CSessKeyContainer::
IsThisYourApplicationKey(PGCCObjectKey application_key)
{
	BOOL    		fRet = FALSE;
	CObjectKeyContainer	    *object_key_data;
	GCCError		rc2;

	DBG_SAVE_FILE_LINE
	object_key_data = new CObjectKeyContainer(application_key, &rc2);
	if ((object_key_data != NULL) && (rc2 == GCC_NO_ERROR))
	{
		if (*object_key_data == *m_InternalSessKey.application_protocol_key)
		{
			fRet = TRUE;
		}
	}
	else
	{
		ERROR_OUT(("CSessKeyContainer::IsThisYourApplicationKey: Error creating new CObjectKeyContainer"));
	}

	if (NULL != object_key_data)
	{
	    object_key_data->Release();
	}

	return fRet;
}

/*
 *	IsThisYourApplicationKeyPDU()
 *
 *	Public Function Description:
 *		This routine is used to determine whether the specified application
 *		key is held within this session key.
 */
BOOL CSessKeyContainer::
IsThisYourApplicationKeyPDU(PKey application_key)
{
	BOOL    		fRet = FALSE;
	CObjectKeyContainer	    *object_key_data;
	GCCError		rc2;

	DBG_SAVE_FILE_LINE
	object_key_data = new CObjectKeyContainer(application_key, &rc2);
	if ((object_key_data != NULL) && (rc2 == GCC_NO_ERROR))
	{
		if (*object_key_data == *m_InternalSessKey.application_protocol_key)
		{
			fRet = TRUE;
		}
	}
	else
	{
		ERROR_OUT(("CSessKeyContainer::IsThisYourApplicationKeyPDU: Error creating new CObjectKeyContainer"));
	}

	if (NULL != object_key_data)
	{
	    object_key_data->Release();
	}

	return fRet;
}

/*
 *	IsThisYourSessionKeyPDU ()
 *
 *	Public Function Description:
 *		This routine is used to determine whether the specified session key
 *		is equal in value to this session key.
 */
BOOL CSessKeyContainer::
IsThisYourSessionKeyPDU(PSessionKey session_key)
{
	BOOL    			fRet = FALSE;
	CSessKeyContainer   *session_key_data;
	GCCError			rc2;

	DBG_SAVE_FILE_LINE
	session_key_data = new CSessKeyContainer(session_key, &rc2);
	if ((session_key_data != NULL) && (rc2 == GCC_NO_ERROR))
	{
		if (*session_key_data == *this)
		{
			fRet = TRUE;
		}
	}
	else
	{
		ERROR_OUT(("CSessKeyContainer::IsThisYourSessionKeyPDU: Error creating new CSessKeyContainer"));
	}

	if (NULL != session_key_data)
	{
	    session_key_data->Release();
	}

	return fRet;
}

/*
 *	operator== ()
 *
 *	Public Function Description:
 *		This routine is used to determine whether or not two session keys are
 *		equal in value.
 */
BOOL operator==(const CSessKeyContainer& session_key_1, const CSessKeyContainer& session_key_2)
{
	BOOL fRet = FALSE;

	if ((session_key_1.m_InternalSessKey.application_protocol_key != NULL) &&
		(session_key_2.m_InternalSessKey.application_protocol_key != NULL))
	{
		if (*session_key_1.m_InternalSessKey.application_protocol_key ==
			*session_key_2.m_InternalSessKey.application_protocol_key)
		{
			if (session_key_1.m_InternalSessKey.session_id == 
				session_key_2.m_InternalSessKey.session_id)
			{
				fRet = TRUE;
			}
		}
	}

	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\appenrol.h ===
/*
 *	appenrol.h
 *
 *	Copyright (c) 1993 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the header file for the class ApplicationEnrollRequestData.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */
#ifndef	_APPLICATION_ENROLL_REQUEST_DATA_
#define	_APPLICATION_ENROLL_REQUEST_DATA_

#include "gcctypes.h"
#include "pdutypes.h"
#include "aportmsg.h"
#include "sesskey.h"
#include "appcap.h"
#include "ncollcap.h"

class 	ApplicationEnrollRequestData;
typedef	ApplicationEnrollRequestData 	*	PApplicationEnrollRequestData;

class ApplicationEnrollRequestData
{
public:

    ApplicationEnrollRequestData(PApplicationEnrollRequestMessage, PGCCError);
	ApplicationEnrollRequestData(PApplicationEnrollRequestMessage);
	~ApplicationEnrollRequestData(void);

	ULONG		GetDataSize(void);
	ULONG		Serialize(PApplicationEnrollRequestMessage, LPSTR memory);

	void		Deserialize(PApplicationEnrollRequestMessage);

protected:

	ApplicationEnrollRequestMessage				Enroll_Request_Message;
	CSessKeyContainer   					    *Session_Key_Data;
	CNonCollAppCap				                *Non_Collapsing_Caps_Data;
	CAppCap							            *Application_Capability_Data;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\common\regkey.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_UTILITY);
/* 
 *	regkey.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the class CRegKeyContainer.  This 
 *		class manages the data associated with a Registry Key.  Registry Key's 
 *		are used to identify resources held in the application registry and 
 *		consist of a Session Key and a resource ID octet string.  The 
 *		CRegKeyContainer class uses a CSessKeyContainer container to maintain the 
 *		session key data internally.  A Rogue Wave string object is used to 
 *		hold the resource ID octet string. 
 *
 *	Protected Instance Variables:
 *		m_InternalRegKey
 *			Structure used to hold the registry key data internally.
 *		m_RegKeyPDU
 *			Storage for the "PDU" form of the registry key.
 *		m_fValidRegKeyPDU
 *			Flag indicating that memory has been allocated to hold the internal
 *			"PDU" registry key.
 *		m_cbDataSize
 *			Variable holding the size of the memory which will be required to
 *			hold any data referenced by the "API" GCCRegistryKey structure.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */

#include "regkey.h"


/*
 * This macro is used to ensure that the Resource ID contained in the Registry
 * Key does not violate the imposed ASN.1 constraint.
 */
#define		MAXIMUM_RESOURCE_ID_LENGTH		64


/*
 *	CRegKeyContainer()
 *
 *	Public Function Description:
 *		This constructor is used to create a CRegKeyContainer object from
 *		an "API" GCCRegistryKey.
 */
CRegKeyContainer::
CRegKeyContainer(PGCCRegistryKey registry_key, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('R','e','g','K')),
    m_fValidRegKeyPDU(FALSE),
    m_cbDataSize(0)
{
	GCCError rc = GCC_NO_ERROR;

    /*
	 * Initialize instance variables.
	 */
    ::ZeroMemory(&m_InternalRegKey, sizeof(m_InternalRegKey));
    ::ZeroMemory(&m_RegKeyPDU, sizeof(m_RegKeyPDU));

	/*
	 * Check to make sure the resource ID string does not violate the imposed
	 * ASN.1 constraint.
	 */
	if (registry_key->resource_id.length > MAXIMUM_RESOURCE_ID_LENGTH)
	{
		ERROR_OUT(("CRegKeyContainer::CRegKeyContainer: Error: resource ID exceeds allowable length"));
		rc = GCC_BAD_REGISTRY_KEY;
        goto MyExit;
	}

	/*
	 * Save the Session Key portion of the Registry Key in the internal
	 * structure by creating a new CSessKeyContainer object.  Check to make  
	 * sure the object is successfully created.
	 */
	DBG_SAVE_FILE_LINE
	m_InternalRegKey.session_key = new CSessKeyContainer(&registry_key->session_key, &rc);
	if (m_InternalRegKey.session_key == NULL)
	{
		ERROR_OUT(("CRegKeyContainer::CRegKeyContainer: Error creating new CSessKeyContainer"));
		rc = GCC_ALLOCATION_FAILURE;
        goto MyExit;
	}
	else if (rc == GCC_BAD_SESSION_KEY)
	{
		rc = GCC_BAD_REGISTRY_KEY;
        goto MyExit;
	}

	/*
	 * Save the resource ID if the CSessKeyContainer was successfully created.
	 */
	if (NULL == (m_InternalRegKey.poszResourceID = ::My_strdupO2(
				 		registry_key->resource_id.value,
				 		registry_key->resource_id.length)))
	{
		ERROR_OUT(("CRegKeyContainer::CRegKeyContainer: Error creating resource id"));
		rc = GCC_ALLOCATION_FAILURE;
        // goto MyExit;
	}

MyExit:

    *pRetCode = rc;
}


/*
 *	CRegKeyContainer()
 *
 *	Public Function Description:
 *		This constructor is used to create a CRegKeyContainer object from
 *		a "PDU" RegistryKey.
 */
CRegKeyContainer::
CRegKeyContainer(PRegistryKey registry_key, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('R','e','g','K')),
    m_fValidRegKeyPDU(FALSE),
    m_cbDataSize(0)
{
	GCCError rc = GCC_NO_ERROR;

	/*
	 * Initialize instance variables.
	 */
    ::ZeroMemory(&m_InternalRegKey, sizeof(m_InternalRegKey));
    ::ZeroMemory(&m_RegKeyPDU, sizeof(m_RegKeyPDU));

	/*
	 * Save the Session Key portion of the Registry Key in the internal 
	 * structure by creating a new CSessKeyContainer object.  Check to make sure 
	 * the object is successfully created.
	 */
	DBG_SAVE_FILE_LINE
	m_InternalRegKey.session_key = new CSessKeyContainer(&registry_key->session_key, &rc);
	if ((m_InternalRegKey.session_key == NULL) || (rc != GCC_NO_ERROR))
	{
		ERROR_OUT(("CRegKeyContainer::CRegKeyContainer: Error creating new CSessKeyContainer"));
		rc = GCC_ALLOCATION_FAILURE;
        goto MyExit;
	}

	/*
	 * Save the resource ID if the CSessKeyContainer was successfully created.
	 */
	if (NULL == (m_InternalRegKey.poszResourceID = ::My_strdupO2(
						registry_key->resource_id.value,
						registry_key->resource_id.length)))
	{
		ERROR_OUT(("CRegKeyContainer::CRegKeyContainer: Error creating resource id"));
		rc = GCC_ALLOCATION_FAILURE;
        // goto MyExit;
	}

MyExit:

    *pRetCode = rc;
}


/*
 *	CRegKeyContainer()
 *
 *	Public Function Description:
 *		This copy constructor is used to create a new CRegKeyContainer object
 *		from another CRegKeyContainer object.
 */
CRegKeyContainer::
CRegKeyContainer(CRegKeyContainer *registry_key, PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('R','e','g','K')),
    m_fValidRegKeyPDU(FALSE),
    m_cbDataSize(0)
{
	GCCError rc = GCC_NO_ERROR;

	/*
	 * Initialize instance variables.
	 */
    ::ZeroMemory(&m_InternalRegKey, sizeof(m_InternalRegKey));
    ::ZeroMemory(&m_RegKeyPDU, sizeof(m_RegKeyPDU));

	/*
	 * Copy the Session Key portion of the Registry Key using the copy 
	 * constructor of the CSessKeyContainer class.  Check to make sure the 
	 * CSessKeyContainer object is successfully created.
	 */
	DBG_SAVE_FILE_LINE
	m_InternalRegKey.session_key = new CSessKeyContainer(registry_key->m_InternalRegKey.session_key, &rc);
	if ((m_InternalRegKey.session_key == NULL) || (rc != GCC_NO_ERROR))
	{
		ERROR_OUT(("CRegKeyContainer::CRegKeyContainer: Error creating new CSessKeyContainer"));
		rc = GCC_ALLOCATION_FAILURE;
        goto MyExit;
	}

	/*
	 * Save the resource ID if the CSessKeyContainer was saved correctly.
	 * Store the resource ID in a Rogue Wave string container.
	 */
	if (NULL == (m_InternalRegKey.poszResourceID = ::My_strdupO(
								registry_key->m_InternalRegKey.poszResourceID)))
	{
		ERROR_OUT(("CRegKeyContainer::CRegKeyContainer: Error creating new resource id"));
		rc = GCC_ALLOCATION_FAILURE;
        // goto MyExit;
	}

MyExit:

    *pRetCode = rc;
}


/*
 *	~CRegKeyContainer()
 *
 *	Public Function Description
 *		The CRegKeyContainer destructor is responsible for freeing any memory
 *		allocated to hold the registry key data.
 *
 */
CRegKeyContainer::
~CRegKeyContainer(void)
{
	/*
	 * If "PDU" data has been allocated for this object, free it now.
	 */
	if (m_fValidRegKeyPDU)
	{
		FreeRegistryKeyDataPDU();
	}

	/* 
	 * Delete any registry key data held internally.
	 */
	if (NULL != m_InternalRegKey.session_key)
	{
	    m_InternalRegKey.session_key->Release();
	}
	delete m_InternalRegKey.poszResourceID;
}


/*
 *	LockRegistryKeyData ()
 *
 *	Public Function Description:
 *		This routine locks the registry key data and determines the amount of
 *		memory referenced by the "API" registry key structure.
 */
UINT CRegKeyContainer::
LockRegistryKeyData(void)
{
	/*
	 * If this is the first time this routine is called, determine the size of 
	 * the memory required to hold the data referenced by the registry key
	 * structure.  Otherwise, just increment the lock count.
	 */
	if (Lock() == 1)
	{
		/*
		 * Lock the data for the session key by	using the "Lock" routine of
		 * the internal CSessKeyContainer object.  Determine the amount of memory
		 * necessary to hold the data referenced by the "API" registry key
		 * structure.  The referenced data consists of data for the object key
		 * as well as data for the resource ID octet string.  The sizes for
		 * both of these memory blocks are rounded to occupy an even multiple
		 * of four-byte blocks, with the session key block being rounded at a
		 * lower level.  The pointers to the internal objects were validated in
		 * the constructor.  
		 */
		m_cbDataSize = m_InternalRegKey.session_key->LockSessionKeyData();
		m_cbDataSize += m_InternalRegKey.poszResourceID->length;
		m_cbDataSize = ROUNDTOBOUNDARY(m_cbDataSize);
	}

	return m_cbDataSize;
}


/*
 *	GetGCCRegistryKeyData ()
 *
 *	Public Function Description:
 *		This routine retrieves registry key data in the form of an "API" 
 *		GCCRegistryKey.	 This routine is called after "locking" the registry 
 *		key data.
 */
UINT CRegKeyContainer::
GetGCCRegistryKeyData(PGCCRegistryKey registry_key, LPBYTE memory)
{
	UINT cbDataSizeToRet = 0;

	/*
	 * If the registry key data has been locked, fill in the output structure
	 * and the data referenced by the structure.  Call the "Get" routine for the 
	 * SessionKey to fill in the session key data.
	 */ 
	if (GetLockCount() > 0)
	{
    	UINT		session_key_data_length;
    	LPBYTE		data_memory = memory;

		/*
		 * Fill in the output parameter which indicates the amount of memory
		 * used to hold all of the data associated with the registry key.
		 */
		cbDataSizeToRet = m_cbDataSize;

		session_key_data_length = m_InternalRegKey.session_key->
				GetGCCSessionKeyData(&registry_key->session_key, data_memory);
		data_memory += session_key_data_length;

		/*
		 * Move the memory pointer past the session key data.  The length of
		 * the session key data is rounded to a four-byte boundary by the
		 * lower level routines.  Set the resource ID octet string length
		 * and pointer and copy the octet string data into the memory block
		 * from the internal Rogue Wave string.
		 */
		registry_key->resource_id.value = data_memory;
		registry_key->resource_id.length = m_InternalRegKey.poszResourceID->length;

		::CopyMemory(data_memory, m_InternalRegKey.poszResourceID->value,
					m_InternalRegKey.poszResourceID->length);
	}
	else
	{
		ERROR_OUT(("CRegKeyContainer::GetGCCRegistryKeyData Error Data Not Locked"));
	}

	return cbDataSizeToRet;
}


/*
 *	UnlockRegistryKeyData ()
 *
 *	Public Function Description:
 *		This routine decrements the lock count and frees the memory associated 
 *		with the "API" registry key once the lock count reaches zero.
 */
void CRegKeyContainer::
UnLockRegistryKeyData(void)
{
	if (Unlock(FALSE) == 0)
	{
		/*
		 * Unlock the data associated with the internal CSessKeyContainer.
		 */
		if (m_InternalRegKey.session_key != NULL)
		{
			m_InternalRegKey.session_key->UnLockSessionKeyData();
		} 
	}

    // we have to call Release() because we used Unlock(FALSE)
    Release();
}


/*
 *	GetRegistryKeyDataPDU ()
 *
 *	Public Function Description:
 *		This routine converts the registry key from it's internal form of a
 *		REG_KEY structure into the "PDU" form which can be passed in
 *		to the ASN.1 encoder.  A pointer to a "PDU" "RegistryKey" structure is 
 *		returned.
 */
GCCError CRegKeyContainer::
GetRegistryKeyDataPDU(PRegistryKey registry_key)
{
	GCCError rc = GCC_NO_ERROR;

	/*
	 * If this is the first time that PDU data has been requested then we must
	 * fill in the internal PDU structure and copy it into the structure pointed
	 * to by the output parameter.  On subsequent calls to "GetPDU" we can just
	 * copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	if (m_fValidRegKeyPDU == FALSE)
	{
		m_fValidRegKeyPDU = TRUE;

		/*
		 * Fill in the "PDU" registry key from the internal structure.
		 */
		if (m_InternalRegKey.session_key != NULL)
		{
			/*
			 * Fill in the session key portion of the registry key by using the
			 * "Get" routine of the internal CSessKeyContainer object.
			 */
			rc = m_InternalRegKey.session_key->GetSessionKeyDataPDU(&m_RegKeyPDU.session_key);
		}
		else
		{
			rc = GCC_ALLOCATION_FAILURE;
		}

		if (rc == GCC_NO_ERROR)
		{
			/*
			 * Fill in the "PDU" resource ID if no error has occurred.
			 */
			::CopyMemory(m_RegKeyPDU.resource_id.value,
					m_InternalRegKey.poszResourceID->value,
					m_InternalRegKey.poszResourceID->length);

			m_RegKeyPDU.resource_id.length = m_InternalRegKey.poszResourceID->length;
		}
	}

	/*
	 * Copy the internal PDU structure into the structure pointed to by the
	 * output parameter.
	 */
	*registry_key = m_RegKeyPDU;

	return rc;
}


/*
 *	FreeRegistryKeyDataPDU ()
 *
 *	Public Function Description:
 *		This routine is used to free the registry key data held internally in
 *		the "PDU" form of a "RegistryKey".
 */
void CRegKeyContainer::
FreeRegistryKeyDataPDU(void)
{
	if (m_fValidRegKeyPDU)
	{
		/*
		 * Set the flag indicating that PDU registry key data is no longer
		 * allocated.
		 */
		m_fValidRegKeyPDU = FALSE;

		if (m_InternalRegKey.session_key != NULL)
		{
			m_InternalRegKey.session_key->FreeSessionKeyDataPDU();
		}
		else
		{
			ERROR_OUT(("CRegKeyContainer::FreeRegistryKeyDataPDU: Bad internal pointer"));
		}
	}
}


GCCError CRegKeyContainer::
CreateRegistryKeyData(PGCCRegistryKey *ppRegKey)
{
    GCCError rc;

    DebugEntry(CRegKeyContainer::CreateRegistryKeyData);

    /*
    **	Here we calculate the length of the bulk data.  This
    **	includes the registry key and registry item.  These objects are
    **	"locked" in order to determine how much bulk memory they will
    **	occupy.
    */
    UINT cbKeySize = ROUNDTOBOUNDARY(sizeof(GCCRegistryKey));
    UINT cbDataSize = LockRegistryKeyData() + cbKeySize;
    LPBYTE pData;

    DBG_SAVE_FILE_LINE
    if (NULL != (pData = new BYTE[cbDataSize]))
    {
        *ppRegKey = (PGCCRegistryKey) pData;
        ::ZeroMemory(pData, cbKeySize);

        pData += cbKeySize;
        GetGCCRegistryKeyData(*ppRegKey, pData);

        rc = GCC_NO_ERROR;
    }
    else
    {
        ERROR_OUT(("CRegKeyContainer::CreateRegistryKeyData: can't create GCCRegistryKey"));
        rc = GCC_ALLOCATION_FAILURE;
    }

    //	UnLock the registry key since it is no longer needed
    UnLockRegistryKeyData();

    DebugExitINT(CRegKeyContainer::CreateRegistryKeyData, rc);
    return rc;
}


/*
 *	IsThisYourSessionKey ()
 *
 *	Public Function Description:
 *		This routine determines whether this registry key holds the specified
 *		session key.
 */
BOOL CRegKeyContainer::
IsThisYourSessionKey(CSessKeyContainer *session_key)
{
	BOOL			fRet = FALSE;
	CSessKeyContainer *session_key_data;
	GCCError		rc2;

	DBG_SAVE_FILE_LINE
	session_key_data = new CSessKeyContainer(session_key, &rc2);
	if ((session_key_data != NULL) && (rc2 == GCC_NO_ERROR))
	{
		if (*session_key_data == *m_InternalRegKey.session_key)
		{
			fRet = TRUE;
		}
	}
	else
	{
		ERROR_OUT(("CRegKeyContainer::IsThisYourSessionKey: Error creating new CSessKeyContainer"));
	}

	if (NULL != session_key_data)
	{
	    session_key_data->Release();
	}

	return fRet;
}


/*
 *	GetSessionKey ()
 *
 *	Public Function Description:
 *		This routine is used to retrieve the session key which is held within
 *		this registry key.  The session key is returned in the form of a
 *		CSessKeyContainer container object.
 */


/*
 *	operator== ()
 *
 *	Public Function Description:
 *		This routine is used to determine whether or not two registry keys are
 *		equal in value.
 */
BOOL operator==(const CRegKeyContainer& registry_key_1, const CRegKeyContainer& registry_key_2)
{
	BOOL fRet = FALSE;
	
	if ((registry_key_1.m_InternalRegKey.session_key != NULL) &&
		(registry_key_2.m_InternalRegKey.session_key != NULL))
	{
		if (*registry_key_1.m_InternalRegKey.session_key ==
			*registry_key_2.m_InternalRegKey.session_key)
		{
			if (0 == My_strcmpO(registry_key_1.m_InternalRegKey.poszResourceID,
							registry_key_2.m_InternalRegKey.poszResourceID))
			{
				fRet = TRUE;
			}
		}
	}

	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\arostmsg.h ===
/*
 *	arostmsg.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */
#ifndef	_APPLICATION_ROSTER_MESSAGE_
#define	_APPLICATION_ROSTER_MESSAGE_

#include "arost.h"
#include "clists.h"

class CAppRosterMsg : public CRefCount
{
public:

	CAppRosterMsg(void);
	~CAppRosterMsg(void);

	GCCError		LockApplicationRosterMessage(void);
	void			UnLockApplicationRosterMessage(void);

	GCCError		GetAppRosterMsg(LPBYTE *ppData, ULONG *pcRosters);

    void            AddRosterToMessage(CAppRoster *);

private:

	CAppRosterList		    m_AppRosterList;
	LPBYTE					m_pMsgData;
};

#endif // _APPLICATION_ROSTER_MESSAGE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\arostmgr.h ===
/*
 *	arostmgr.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		A single instance of this class represents the owner of all the 
 *		Application Roster objects for a single "Application Protocol Key". The 
 *		CAppRosterMgr takes care of both the "Local" and "Global" 
 *		rosters for all the Sessions that exists which use the same Application 
 *		Protocol Key (peer applications).  Organizing ApplicationRosters this 
 *		way enables GCC to meet some of the requirements specified by the T.GAT 
 *		recommendation.  Specifically,  it enables GCC to deliver multiple 
 *		application rosters that a particular application might be interested in 
 *		a single application roster update indication.  It also hides much of 
 *		the complexity required to manage application rosters from the 
 *		CConf object.
 *
 *		To understand the responsibilities of the CAppRosterMgr it is 
 *		important to understand the meaning of a "Session" within the context 
 *		of GCC.  A "Session" is a logical entity that is used by a set of peer 
 *		Application Protocol Entities (APEs see T.GAT) to communicate.  When an 
 *		application enrolls with GCC it must specify the session it wishes to 
 *		enroll with by specifying a GCCSessionKey.  This session key includes an 
 *		Application Protocol Key and a session ID.  The enrolling application 
 *		must include an Application Protocol Key that is unique for that 
 *		particular APE (Application Protocol Entity see T.GAT).  When other APEs 
 *		in the conference enroll with the same GCCSessionKey, they all show up 
 *		in the same Application Roster.  This makes it possible for all the APEs 
 *		enrolled in the same session to determine who it is talking to who.
 *
 *		Note that it is possible for the same APE to be enrolled in multiple 
 *		sessions at the same time.  Typically the session that does not include 
 *		a session ID is considered the "Default" session for a particular APE.  
 *		The industry seems to be leaning toward using this default session to do 
 *		administrative task like announcing your capabilities to other APEs or 
 *		as a place to enroll inactively until you have time to join the channels 
 *		associated with the real session you want to enroll with.
 *
 *		An obvious requirement of the CAppRosterMgr is that it must 
 *		have the ability to deliver all the related rosters (the rosters 
 *		associated with all the sessions in existence for a particular APE) to 
 *		the enrolled User Application SAPs and to the Control SAP.  It must also 
 *		be able to manage the flow of PDU traffic to and from the application 
 *		rosters it manages.  Below is a more detailed description of the 
 *		responsibilities of the CAppRosterMgr.
 *
 *		The rules for when an CAppRosterMgr exist in a CConf object are 
 *		quite a bit more complex than with the CConfRosterMgr.  In the 
 *		later case, every node is explicitly required to maintain either a 
 *		single "Global" CConfRoster Manager (if it is a Top Provider node) 
 *		or both a "Local" and "Global" CConfRoster Manager (if it is a 
 *		subordinate node).  The existence of an CAppRosterMgr depends 
 *		entirely on an application being enrolled with the conference.  If no 
 *		applications are enrolled there are no ApplicationRosterManagers.  It 
 *		gets much more complicated if some nodes are servicing enrolled 
 *		applications while others are not.  This is often the case when a 
 *		dedicated MCU is in use.  Since an Application Roster's information base 
 *		is distributed throughout the CConf, this sometimes requires that 
 *		CAppRosterMgr objects exist at nodes that contain no enrolled 
 *		applications.
 *
 *		An CAppRosterMgr maintains both "Global" and "Local" rosters.  
 *		A "Local" CAppRoster consist of all the Application Roster 
 *		Records at its local node and below it in the connection hierarchy.  
 *		The CAppRosterMgr does not communicate any changes made to 
 *		"Local" ApplicationRosters to the CAppSap objects.  Its only input is 
 *		from either primitive calls at the local node or from Roster Update PDUs 
 *		received from subordinate nodes. A "Local" CAppRoster can only 
 *		exist at nodes that are not the Top Provider.  
 *
 *		A "Global" CAppRoster has a dual set of responsibilities 
 *		depending on whether or not it is at a Top Provider.  A "Global" roster 
 *		at a Top Provider is responsible for maintaining an Application Roster 
 *		that includes a record entry for every application in the CConf 
 *		that is enrolled with the same Application Protocol Key.  It is also 
 *		responsible for sending full application roster refreshes to all of its 
 *		subordinate nodes when changes to the roster occur.  All 
 *		ApplicationRosterManagers managing "Global" rosters (regardless of 
 *		location within the connection hierarchy) have the ability to send 
 *		Roster Update indications to their local enrolled CAppSap objects.  
 *		Pointers to CAppSap objects that have enrolled with the conference are 
 *		maintained in a list of enrolled ApplicationSaps.  These pointers are 
 *		passed in to this object whenever a new APE enrolls with an Application 
 *		Roster through a GCC primitive at the local node. Application Rosters 
 *		are propagated up to the enrolled applications through Command Target 
 *		calls to the ApplicationSap object.  The CAppRosterMgr also 
 *		maintains a pointer to the CControlSAP object.  Remember all roster 
 *		updates are directed to both the appropriate application SAPs and to the 
 *		Control SAP.  
 *
 *		ApplicationRosterManagers are also responsible for receiving full 
 *		refreshes of the Application Roster from the Top Provider and passing 
 *		them on to the appropriate "Global" CAppRoster object it 
 *		maintains.  It also sends (as mentioned above) Roster Update indications 
 *		to the enrolled Application SAP objects and the Control SAP via 
 *		CAppRosterMsg objects.
 *
 *		All PDUs and messages are delivered when the CAppRosterMgr is 
 *		flushed.  This is a very important concept in that it allows an 
 *		CAppRosterMgr to process a number of request and PDUs before 
 *		actually being flushed.  The CAppRoster itself will queue up 
 *		changes to a PDU that can consist of either multiple updates or a single 
 *		refresh and will not free it until after it is flushed.  Therefore, when 
 *		processing a roster update PDU that consists of changes to the 
 *		conference roster as well as multiple application rosters, a roster 
 *		refresh PDU can be held back until all the roster managers have had a 
 *		chance to process their portion of the roster update.  Once complete, a 
 *		single PDU can be built by flushing the CConfRosterMgr and all 
 *		the affected ApplicationRosterManagers.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */
#ifndef	_APPLICATION_ROSTER_MANAGER_
#define	_APPLICATION_ROSTER_MANAGER_

#include "gccpdu.h"
#include "mcsuser.h"
// #include "gcmdtar.h"
#include "arost.h"
#include "sesskey.h"
#include "clists.h"


class CAppRosterMgr : public CRefCount
{
public:

	CAppRosterMgr(PGCCSessionKey,
            		PSessionKey, // PDU
            		GCCConfID,
            		PMCSUser,
            		CConf *,
            		PGCCError);

	~CAppRosterMgr(void);

    GCCError    EnrollRequest(GCCEnrollRequest *, GCCEntityID, GCCNodeID, CAppSap *);
	GCCError	UnEnrollRequest(PGCCSessionKey, GCCEntityID);

	GCCError	ProcessRosterUpdateIndicationPDU(PSetOfApplicationInformation, UserID uidSender);

	PSetOfApplicationInformation    FlushRosterUpdateIndication(PSetOfApplicationInformation *, PGCCError);
	PSetOfApplicationInformation    GetFullRosterRefreshPDU(PSetOfApplicationInformation *, PGCCError);
					
	BOOL	IsThisYourSessionKey(PGCCSessionKey pSessKey) { return IsThisSessionKeyValid(pSessKey); }
	BOOL	IsThisYourSessionKeyPDU(PSessionKey pSessKey) { return IsThisSessionKeyPDUValid(pSessKey); }

	GCCError	RemoveEntityReference(GCCEntityID);
	GCCError	RemoveUserReference(UserID uidDetached);
					
	GCCError	ApplicationRosterInquire(PGCCSessionKey, CAppRosterMsg *);

	BOOL		IsEntityEnrolled(GCCEntityID);
	BOOL		IsAPEEnrolled(GCCNodeID, GCCEntityID);
	BOOL		IsAPEEnrolled(CSessKeyContainer *, GCCNodeID, GCCEntityID);
	BOOL		IsEmpty(void);

    void    DeleteRosterRecord(GCCNodeID, GCCEntityID);

private:

	GCCError	SendRosterReportMessage(void);
	
	CAppRoster	*GetApplicationRoster(PGCCSessionKey, CAppRosterList *);
	CAppRoster	*GetApplicationRosterFromPDU(PSessionKey, CAppRosterList *);

	BOOL	IsThisSessionKeyValid(PGCCSessionKey pSessKey)
		{ return m_pSessionKey->IsThisYourApplicationKey(&pSessKey->application_protocol_key); }

	BOOL	IsThisSessionKeyPDUValid(PSessionKey pSessKey)
		{ return m_pSessionKey->IsThisYourApplicationKeyPDU(&pSessKey->application_protocol_key); }

	void				CleanupApplicationRosterLists(void);

private:

	GCCConfID   					m_nConfID;
	BOOL							m_fTopProvider;
	PMCSUser						m_pMcsUserObject;
	CAppSapEidList2 			    m_AppSapEidList2;
	CConf							*m_pConf;
	CAppRosterList					m_GlobalRosterList;
	CAppRosterList					m_LocalRosterList;
	CAppRosterList					m_RosterDeleteList;
	CSessKeyContainer			    *m_pSessionKey;
};


#endif // _APPLICATION_ROSTER_MANAGER_

/*
 *	CAppRosterMgr	(
 *                     	PGCCSessionKey					session_key,
 *						GCCConfID   					conference_id,
 *						PMCSUser						user_object,
 *						UINT        					owner_message_base,
 *						CControlSAP				        *pControlSap,
 *						PGCCError						return_value)
 *
 *	Public Function Description
 *		This is the application roster manager constructor. It is responsible 
 *		for initializing all the instance variables used by this class.
 *		This constructor is used when the initial roster data that is
 *		availble comes from local API data.
 *
 *	Formal Parameters:
 *		session_key			-	(i)	"API" Session Key used to establish the 
 *									application protocol key for this session.
 *		conference_id		-	(i)	Conference ID associated with this roster
 *									maanger.
 *		user_object			-	(i)	Pointer to the user attachment object used
 *									by this class.
 *		owner_object		-	(i)	Pointer to the owner object.
 *		owner_message_base	-	(i)	Message base to add to all the owner 
 *									callbacks.
 *		control_sap			-	(i)	Pointer to the node controller SAP object.
 *		return_value		-	(o)	Pointer to error value to be returned.
 *		
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No resource error occured.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	CAppRosterMgr	(
 *						PSessionKey						session_key,
 *						GCCConfID   					conference_id,
 *						PMCSUser						user_object,
 *						UINT        					owner_message_base,
 *						CControlSAP				        *pControlSap,
 *						PGCCError						return_value)
 *
 *	Public Function Description
 *		This is the application roster manager constructor. It is responsible 
 *		for initializing all the instance variables used by this class.
 *		This constructor is used when the initial roster data that is
 *		availble comes from remote PDU data.
 *
 *		This constructor handles a number of different possiblities:
 *			For Non Top Providers:
 *				1)	A refresh received from the top provider.
 *				2)	An update from a node below this one.
 *
 *			For the Top Provider:
 *				1)	An Update from a lower node
 *
 *	Formal Parameters:
 *		session_key			-	(i)	"PDU" Session Key used to establish the 
 *									application protocol key for this session.
 *		conference_id		-	(i)	Conference ID associated with this roster
 *									maanger.
 *		user_object			-	(i)	Pointer to the user attachment object used
 *									by this class.
 *		owner_object		-	(i)	Pointer to the owner object.
 *		owner_message_base	-	(i)	Message base to add to all the owner 
 *									callbacks.
 *		control_sap			-	(i)	Pointer to the node controller SAP object.
 *		return_value		-	(o)	Pointer to error value to be returned.
 *		
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No resource error occured.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	~ApplicationRosterManager ()
 *
 *	Public Function Description
 *		This is the application roster manager destructor.  It is used to
 *		free up all memory associated with this class.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	EnrollRequest (
 *                      PGCCSessionKey					session_key,
 *	        			PGCCApplicationRecord			application_record,
 *						EntityID						entity_id,
 *						UINT							number_of_capabilities,
 *						PGCCApplicationCapability	*	capabilities_list)
 *
 *	Public Function Description
 *		This routine is called whenever an APE wishes to enroll with the
 *		conference in a specific session.  This routine can be used to
 *		either add a new record or replace a currently existing record.
 *
 *	Formal Parameters:
 *		session_key				-	(i)	Session to enroll with.
 *		application_record		-	(i)	Application record to enroll with.
 *		entity_id				-	(i)	Entity ID of enrolling APE.
 *		number_of_capabilities	-	(i)	Number of capabilities in caps list.
 *		capabilities_list		-	(i)	list of capabilities that the APE is
 *										enrolling with.
 *		command_target			-	(i)	Pointer to APE SAP that is enrolling.
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_BAD_SESSION_KEY				-	Session key passed in is invalid.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_NON_COLLAPSED_CAP	-	Bad non-collapsed capabilities.
 *		GCC_INVALID_PARAMETER			-	Invalid parameter passed in.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	UnEnrollRequest (
 *                     	PGCCSessionKey					session_key,
 *						EntityID						entity_id)
 *
 *	Public Function Description
 *		This routine is called whenever an APE wishes to unenroll from the
 *		conference (or a specific session).
 *
 *	Formal Parameters:
 *		session_key				-	(i)	Session to unenroll from.
 *		entity_id				-	(i)	Entity ID of unenrolling APE.
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_BAD_SESSION_KEY				-	Session key passed in is invalid.
 *		GCC_APP_NOT_ENROLLED			-	APE is not enrolled with this
 *											session..
 *		GCC_INVALID_PARAMETER			-	Invalid parameter passed in.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ProcessRosterUpdateIndicationPDU(
 *						PSetOfApplicationInformation	set_of_application_info,
 *						UserID							sender_id)
 *
 *	Public Function Description
 *		This routine processes an incomming roster update PDU.  It is
 *		responsible for passing the PDU on to the right application roster.
 *
 *	Formal Parameters:
 *		set_of_application_info	-	(i)	PDU data to process
 *		sender_id				-	(i)	Node ID that sent the update.
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_BAD_SESSION_KEY				-	Session key passed in is invalid.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_PARAMETER			-	Invalid parameter passed in.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	PSetOfApplicationInformation	FlushRosterUpdateIndication (
 *						PSetOfApplicationInformation *	set_of_information,
 *						PGCCError						return_value)
 *
 *	Public Function Description
 *		This routine is used to access any PDU data that might currently be
 *		queued inside the application rosters managed by this application
 *		roster manager.  It also is responsible for flushing any queued 
 *		roster update messages if necessary.
 *
 *	Formal Parameters:
 *		set_of_information	-	(o)	Pointer PDU to fill in.
 *		return_value		-	(o)	Error return here.
 *
 *	Return Value
 *		Pointer to the new set of application information.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	PSetOfApplicationInformation	GetFullRosterRefreshPDU (
 *						PSetOfApplicationInformation *	set_of_information,
 *						PGCCError						return_value)
 *
 *	Public Function Description
 *		This routine is used to obtain a complete roster refresh of all the
 *		rosters maintained by this roster manger.
 *
 *	Formal Parameters:
 *		set_of_information	-	(o)	Pointer PDU to fill in.
 *		return_value		-	(o)	Error return here.
 *
 *	Return Value
 *		Pointer to the new set of application information.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL	IsThisYourSessionKey(
 *						PGCCSessionKey					session_key)
 *
 *	Public Function Description
 *		This routine is used to determine if the specified "API" session key is
 *		associated with this application roster manager.
 *
 *	Formal Parameters:
 *		session_key		-	(i)	"API" session key to test.
 *
 *	Return Value
 *		TRUE	-	If session key is associated with this manager.
 *		FALSE	-	If session key is NOT associated with this manager.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL	IsThisYourSessionKeyPDU(
 *						PSessionKey						session_key);
 *
 *	Public Function Description
 *		This routine is used to determine if the specified "PDU" session key is
 *		associated with this application roster manager.
 *
 *	Formal Parameters:
 *		session_key		-	(i)	"PDU" session key to test.
 *
 *	Return Value
 *		TRUE	-	If session key is associated with this manager.
 *		FALSE	-	If session key is NOT associated with this manager.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	RemoveEntityReference(
 *						EntityID						application_entity)
 *
 *	Public Function Description
 *		This routine is used to remove the specified APE entity from the 
 *		session it is enrolled with.  Note that this routine is only used
 *		to remove local entity references.
 *
 *	Formal Parameters:
 *		application_entity	-	(i)	Entity reference to remove.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	Entity was removed.
 *		GCC_INVALID_PARAMETER	-	Entity does not exist here.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	RemoveUserReference(
 *						UserID							detached_user)
 *
 *	Public Function Description
 *		This routine is used to remove all references associated with the
 *		node defined by the detached user.
 *
 *	Formal Parameters:
 *		detached_user	-	(i)	User reference to remove.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	User reference was removed.
 *		GCC_INVALID_PARAMETER	-	No records associated with this node.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL	IsEntityEnrolled(
 *						EntityID						entity_id)
 *
 *	Public Function Description
 *		This routine informs the caller if the specified entity is enrolled
 *		with any sessions managed by this application roster manager.
 *
 *	Formal Parameters:
 *		entity_id	-	(i)	Entity to test.
 *
 *	Return Value
 *		TRUE	-	Entity is enrolled.
 *		FALSE	-	Entity is not enrolled.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ApplicationRosterInquire (
 *						PGCCSessionKey					session_key,
 *						CAppRosterMsg					*roster_message)
 *
 *	Public Function Description
 *		This routine inserts the appropriate application rosters into the
 *		roster message that is passed in.  If the specified session key is set
 *		to NULL or a session ID of zero is passed in, all the global rosters 
 *		managed by this object will be returned.  Otherwise, only the
 *		specified session roster will be returned.
 *
 *	Formal Parameters:
 *		session_key		- (i) Session key defining roster being inquired about.
 *		roster_message 	- (o) Roster message to fill in.	
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL	IsAPEEnrolled(
 *						UserID							node_id,
 *						EntityID						entity_id)
 *
 *	Public Function Description
 *		This routine determines if the specified APE is enrolled with one
 *		of the sessions managed by this application roster manager.
 *
 *	Formal Parameters:
 *		node_id		- (i) Node ID of APE to test.
 *		entity_id 	- (i) Entity ID of APE to test.	
 *
 *	Return Value
 *		TRUE	-	APE is enrolled here.
 *		FALSE	-	APE is not enrolled here.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL	IsAPEEnrolled(
 *						CSessKeyContainer			    *session_key_data,
 *						UserID							node_id,
 *						EntityID						entity_id)
 *
 *	Public Function Description
 *		This routine determines if the specified APE is enrolled with the
 *		specified session.
 *
 *	Formal Parameters:
 *		session_key_data	- (i) Session Key of roster to check.
 *		node_id				- (i) Node ID of APE to test.
 *		entity_id 			- (i) Entity ID of APE to test.	
 *
 *	Return Value
 *		TRUE	-	APE is enrolled with this session.
 *		FALSE	-	APE is not enrolled with this session.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL	IsEmpty(void)
 *
 *	Public Function Description
 *		This routine determines if this application roster managfer contains
 *		any application rosters.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		TRUE	-	Application Roster Manager is empty.
 *		FALSE	-	Application Roster Manager is NOT empty.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\appsap.h ===
/*
 * appsap.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class CAppSap.  CAppSap
 *		objects represent an external user application's Service Access 
 *		Point to GCC.  This object inherits from the CBaseSap class. The CAppSap 
 *		object is instantiated when GCCCreateSap is called.  From that point 
 *		forward all messages to and from that application pass through this 
 *		object.  The object is explicitly deleted when GCCDeleteSap is called 
 *		or it is implicitly deleted when GCCCleanup is called by the Node 
 *		Controller.	 
 *
 *		The primary responsibility of the CAppSap object is to route
 *		incoming GCC primitives to their appropriate destination and to convert
 *		the primitives into a form that is understandable to the objects 
 *		processing them. A secondary responsibility of the CAppSap object is to 
 *		maintain a queue for all indications and confirm messages that are sent
 *		back to the registered application.  Commands can be routed by the 
 *		CAppSap in one of two directions. Either to the controller or to a 
 *		specified conference.  Commands that are passed to the controller, are
 *		done so using owner callbacks.  Commands that are routed to conferences
 *		are done so using command target calls and are routed based on a 
 *		Conference ID.  Note that various User Application commands will only be
 *		routed to the CConf if that application has previously enrolled 
 *		with the conference.  The CAppSap receives all confirms and indications
 *		from either the Controller or a CConf object.  These messages are
 *		formatted into GCCMessages within the CAppSap and queued up for later 
 *		delivery.  Periodically, the CAppSap's message queue is flushed by the 
 *		Controller object and the messages are delivered to the appropriate 
 *		application.
 *
 *	Caveats:
 *		The message structures that are passed back to the node controller
 *		are defined in GCC.H.
 *
 *	Author:
 *		blp
 */

#ifndef _APPSAP_
#define _APPSAP_

/*
 * include files 
 */
#include "igccapp.h"
#include "sap.h"
#include "clists.h"


/*
**	This is the message base that is passed into any SAP objects that use this
**	classes Owner callback.  It will typically be the controller's 
**	responsibility to pass this message on.
*/
#define	APPLICATION_MESSAGE_BASE			0

/*
**	Class definition
*/
class CAppSap : public CBaseSap, public IGCCAppSap 
{
    friend LRESULT CALLBACK SapNotifyWndProc(HWND, UINT, WPARAM, LPARAM);

public:

    CAppSap(LPVOID pAppData, LPFN_APP_SAP_CB, PGCCError);
    ~CAppSap(void);

    GCCAPI_(void)   ReleaseInterface(void);

    /* ------ IGCCAppSap Interface ------ */

    GCCAPI  AppEnroll(GCCConfID, GCCEnrollRequest *, PGCCRequestTag);
    GCCAPI  AppInvoke(GCCConfID, GCCAppProtEntityList *, GCCSimpleNodeList *, PGCCRequestTag);

    GCCAPI  AppRosterInquire(GCCConfID, GCCSessionKey *, GCCAppSapMsg **);
    GCCAPI_(void)  FreeAppSapMsg(GCCAppSapMsg *);

    GCCAPI_(BOOL)  IsThisNodeTopProvider(GCCConfID);
    GCCAPI_(GCCNodeID) GetTopProvider(GCCConfID);
    GCCAPI  ConfRosterInquire(GCCConfID, GCCAppSapMsg **);

    GCCAPI  RegisterChannel(GCCConfID, GCCRegistryKey *, ChannelID);
    GCCAPI  RegistryAssignToken(GCCConfID, GCCRegistryKey *);
    GCCAPI  RegistrySetParameter(GCCConfID, GCCRegistryKey *, LPOSTR, GCCModificationRights);
    GCCAPI  RegistryRetrieveEntry(GCCConfID, GCCRegistryKey *);
    GCCAPI  RegistryDeleteEntry(GCCConfID, GCCRegistryKey *);
    GCCAPI  RegistryMonitor(GCCConfID, BOOL fEnableDelivery, GCCRegistryKey *);
    GCCAPI  RegistryAllocateHandle(GCCConfID, ULONG cHandles);

    GCCAPI  ConductorInquire(GCCConfID);

    /* ------ IGCCAppSapNotify Handler ------ */

    GCCError PermissionToEnrollIndication(GCCConfID, BOOL fGranted);
    GCCError AppEnrollConfirm(GCCAppEnrollConfirm *);

    GCCError RegistryAllocateHandleConfirm(GCCConfID,
                                           ULONG        cHandles,
                                           ULONG        nFirstHandle,
                                           GCCResult);

    GCCError RegistryConfirm(GCCConfID,
                             GCCMessageType,
                             CRegKeyContainer *,
                             CRegItem *,
                             GCCModificationRights,
                             GCCNodeID                  nidOwner,
                             GCCEntityID                eidOwner,
                             BOOL                       fDeliveryEnabled,
                             GCCResult);

    GCCError RegistryMonitorIndication(GCCConfID                nConfID,
                                       CRegKeyContainer         *pRegKey,
                                       CRegItem                 *pRegItem,
                                       GCCModificationRights    eRights,
                                       GCCNodeID                nidOwner,
                                       GCCEntityID              eidOwner)
    {
        return RegistryConfirm(nConfID,
                               GCC_MONITOR_INDICATION,
                               pRegKey,
                               pRegItem,
                               eRights,
                               nidOwner,
                               eidOwner,
                               FALSE,
                               GCC_RESULT_SUCCESSFUL);
    }

    GCCError ConfRosterInquireConfirm(GCCConfID,
                                      PGCCConferenceName,
                                      LPSTR                 pszConfModifier,
                                      LPWSTR                pwszConfDescriptor,
                                      CConfRoster *,
                                      GCCResult,
                                      GCCAppSapMsgEx **);

    GCCError AppRosterInquireConfirm(GCCConfID,
                                     CAppRosterMsg *,
                                     GCCResult,
                                     GCCAppSapMsgEx **);

    GCCError AppRosterReportIndication(GCCConfID, CAppRosterMsg *);

    GCCError AppInvokeConfirm(GCCConfID, CInvokeSpecifierListContainer *, GCCResult, GCCRequestTag);
    GCCError AppInvokeIndication(GCCConfID, CInvokeSpecifierListContainer *, GCCNodeID nidInvoker);

    GCCError ConductorInquireConfirm(GCCNodeID nidConductor, GCCResult, BOOL fGranted, BOOL fConducted, GCCConfID);
    GCCError ConductorPermitGrantIndication(GCCConfID,
                            UINT cGranted, GCCNodeID *aGranted,
                            UINT cWaiting, GCCNodeID *aWaiting,
                            BOOL fThisNodeIsGranted);
    GCCError ConductorAssignIndication(GCCNodeID nidConductor, GCCConfID);
    GCCError ConductorReleaseIndication(GCCConfID);


protected:

    void NotifyProc(GCCAppSapMsgEx *pAppSapMsgEx);

private:

    void PostAppSapMsg(GCCAppSapMsgEx *pAppSapMsgEx);
    void PurgeMessageQueue(void);

private:

    LPVOID              m_pAppData;        // app defined user data
    LPFN_APP_SAP_CB     m_pfnCallback;
};



/*
 *	Comments explaining the public and protected class member functions
 */

/*
 *	CAppSap (
 *				UINT				owner_message_base,
 *				UINT				application_messsage_base)
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This is the constructor for the CAppSap class.  It initializes instance
 *		variables and registers with the new application.
 *
 *	Formal Parameters:
 *		owner_object		(i) A pointer to the owner of this object, namely
 *									the controller.
 *		owner_message_base	(i) The	message base offset for callbacks into the
 *									controller.
 *		application_object	(i)	A pointer to the application requesting service.
 *		application_messsage_base	(i) The message base offset for callbacks
 *											to the application.
 *		sap_handle			(i) The handle registered for this SAP.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	virtual 	~AppSap();
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This is the destructor for the CAppSap class.  It is called when the 
 *		controller marks the CAppSap to be deleted.  This occurs when either
 *		the CAppSap asks to be deleted due to an "unregister request" 
 *		issued from the client application, or when there is an error
 *		condition in the CAppSap.
 *
 *	Formal Parameters:
 *		owner_object		(i) A pointer to the owner of this object, namely
 *									the controller.
 *		owner_message_base	(i) The	message base offset for callbacks into the
 *									controller.
 *		application_object	(i)	A pointer to the application requesting service.
 *		application_messsage_base	(i) The message base offset for callbacks
 *											to the application.
 *		sap_handle			(i) The handle registered for this SAP.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource allocation error occurred.
 *		GCC_BAD_OBJECT_KEY				- An invalid object key passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	AppEnroll(
 *					GCCConfID   			conference_id,
 *					PGCCSessionKey				session_key,
 *					BOOL					enroll_actively,
 *					UserID						application_user_id,
 *					BOOL					is_conducting_capable,
 *					MCSChannelType				startup_channel_type,
 *					UINT						number_of_non_collapsed_caps,
 *					PGCCNonCollapsingCapability *non_collapsed_caps_list,		
 *					UINT						number_of_collapsed_caps,
 *					PGCCApplicationCapability *	collapsed_caps_list,		
 *					BOOL					application_is_enrolled);
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This routine is called when an application wants to enroll in a 
 *		conference.  The controller is notified of the enrollment request.
 *
 *	Formal Parameters:
 *		conference_id					(i) The conference identifier value.
 *		session_key						(i) Key identifying the session.
 *		enroll_actively					(i) Flag indicating whether to enroll
 *												actively or inactively.
 *		application_user_id				(i) The application identifier value.
 *		is_conducting_capable			(i) Flag indicating whether this app
 *												is capable of conducting.
 *		startup_channel_type			(i) The type of channel to use. 
 *		number_of_non_collapsed_caps	(i) Number of non-collapsed capabilities
 *		non_collapsed_caps_list			(i) List of non-collapsed capabilities.
 *		number_of_collapsed_caps		(i) Number of collapsed capabilities.
 *		collapsed_caps_list				(i) List of collapsed capabilities.
 *		application_is_enrolled)		(i) Flag indicating whether or not the
 *												application wishes to enroll.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- No error.
 *		GCC_INVALID_MCS_USER_ID		- The user ID is less than the minimum value
 *		GCC_BAD_SESSION_KEY			- A NULL session key pointer is passed in.
 *		GCC_INVALID_CONFERENCE		- The conference does not exist at this node
 *		GCC_NO_SUCH_APPLICATION		- A SAP has not been registered for this app
 *		GCC_BAD_SESSION_KEY			- An invalid session key was passed in.
 *		GCC_INVALID_PARAMETER		- The node record was not found in the list.
 *		GCC_BAD_CAPABILITY_ID		- An invalid capability ID was passed in.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError		RegisterChannel(
 *								GCCConfID		conference_id,
 *								PGCCRegistryKey		registry_key,
 *								ChannelID			channel_id);	
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This routine is called when an application wishes to register a 
 *		channel.  The call is routed to the appropriate conference object.
 *
 *	Formal Parameters:
 *		conference_id					(i) The conference identifier value.
 *		registry_key					(i) Key identifying the session and
 *												resource ID.
 *		channel_id						(i) ID of channel to register
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_INVALID_CONFERENCE			- Conference not found to exist.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  		enrolled with the conference.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError		RegistryAssignToken(
 *								GCCConfID		conference_id,
 *								PGCCRegistryKey		registry_key);
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This routine is called when an application wishes to assign a 
 *		token.  The call is routed to the appropriate conference object.
 *
 *	Formal Parameters:
 *		conference_id					(i) The conference identifier value.
 *		registry_key					(i) Key identifying the session and
 *												resource ID.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_INVALID_CONFERENCE			- Conference not found to exist.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  		enrolled with the conference.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError   		GCCRegistrySetParameterRequest (
 *								GCCConfID		 	conference_id,
 *								PGCCRegistryKey			registry_key,
 *								LPOSTR      			parameter_value,
 *								GCCModificationRights	modification_rights	);
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This routine is called when an application wishes to set a 
 *		parameter.  The call is routed to the appropriate conference object.
 *
 *	Formal Parameters:
 *		conference_id					(i) The conference identifier value.
 *		registry_key					(i) Key identifying the session and
 *												resource ID.
 *		parameter_value					(i) String identifying the parameter
 *												to set.
 *		modification_rights				(i) Structure specifying the rights
 *												to be allowed for modifying
 *												the registry parameter.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_INVALID_CONFERENCE			- Conference not found to exist.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  		enrolled with the conference.
 *		GCC_INVALID_MODIFICATION_RIGHTS	- The modification rights passed in
 *											were not valid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError		GCCRegistryRetrieveEntryRequest(
 *								GCCConfID		conference_id,
 *								PGCCRegistryKey		registry_key);
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This routine is called when an application wishes to retrieve a registry 
 *		entry.  The call is routed to the appropriate conference object.
 *
 *	Formal Parameters:
 *		conference_id					(i) The conference identifier value.
 *		registry_key					(i) Key identifying the session and
 *												resource ID.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_INVALID_CONFERENCE			- Conference not found to exist.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  		enrolled with the conference.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError		GCCRegistryDeleteEntryRequest(
 *								GCCConfID		conference_id,
 *								PGCCRegistryKey		registry_key);
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This routine is called when an application wishes to delete a registry 
 *		entry.  The call is routed to the appropriate conference object.
 *
 *	Formal Parameters:
 *		conference_id					(i) The conference identifier value.
 *		registry_key					(i) Key identifying the session and
 *												resource ID.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_INVALID_CONFERENCE			- Conference not found to exist.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										 		enrolled with the conference.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError		GCCRegistryMonitorRequest (
 *								GCCConfID		conference_id,
 *								BOOL			enable_delivery,
 *								PGCCRegistryKey		registry_key );
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This routine is called when an application wishes to monitor a 
 *		particular registry entry.  The call is routed to the appropriate 
 *		conference object.
 *
 *	Formal Parameters:
 *		conference_id					(i) The conference identifier value.
 *		enable_delivery					(i) Flag indicating whether to turn
 *												monitoring on or off.
 *		registry_key					(i) Key identifying the session and
 *												resource ID.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_INVALID_CONFERENCE			- Conference not found to exist.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  		enrolled with the conference.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError		GCCRegistryAllocateHandleRequest (
 *								GCCConfID		conference_id,
 *								UINT				number_of_handles );
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This routine is called when an application wishes to allocate one or 
 *		more handles.  The call is routed to the appropriate conference object.
 *
 *	Formal Parameters:
 *		conference_id					(i) The conference identifier value.
 *		number_of_handles				(i) The number of handles to allocate.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_INVALID_CONFERENCE			- Conference not found to exist.
 *		GCC_BAD_NUMBER_OF_HANDLES		- The number of handles requested is
 *												not within the allowable range.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  enrolled with the conference.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError		PermissionToEnrollIndication(
 *								GCCConfID		conference_id,
 *								PGCCConferenceName	conference_name,
 *								GCCNumericString	conference_modifier,
 *								BOOL			permission_is_granted);
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This routine is called from a conference object when it wishes to send 
 *		an indication to the user application notifying it of a "permission to 
 *		enroll" event.  This does not mean that permission to enroll is
 *		necessarily granted to the application.  It may mean that permission is
 *		being revoked.
 *
 *	Formal Parameters:
 *		conference_id					(i) The conference identifier value.
 *		conference_name					(i) The conference name.
 *		conference_modifier				(i) The confererence modifier.
 *		permission_is_granted			(i) Flag indicating whether or not
 *												permission to enroll is granted.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- No error.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */



/*
 *	GCCError	AppEnrollConfirm(GCCAppEnrollConfirm *);
 *								GCCConfID			conference_id,
 *								PGCCSessionKey			session_key,
 *								UINT					entity_id,
 *								UserID					node_id,
 *								GCCResult				result);
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This routine is called by the CConf object when it wishes
 *		to send an enrollment confirmation to the user application.
 *
 *	Formal Parameters:
 *		conference_id				(i) The conference identifier value.
 *		session_key					(i) The key identifying the session.
 *		entity_id					(i) The ID for this instance of the 
 *											application.
 *		node_id						(i) ID for this node.
 *		result						(i) Result code indicating whether or not
 *											the enrollment was successful.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_BAD_SESSION_KEY				- The session key is invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	RegistryConfirm (
 *						GCCConfID			conference_id,
 *						GCCMessageType			message_type,
 *						CRegKeyContainer        *registry_key_data,
 *						CRegItem                *registry_item_data,
 *						GCCModificationRights	modification_rights,
 *						UserID					owner_id,
 *						EntityID				entity_id,
 *						BOOL				enable_monitoring,
 *						GCCResult				result);
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This command target routine is called by the CConf object when it
 *		wishes to send an registry confirmation to the user application.
 *
 *	Formal Parameters:
 *		conference_id				(i) The conference identifier value.
 *		message_type				(i) Indicates what type of registry item
 *											confirm this is.
 *		registry_key_data			(i) Object holding the registry key.
 *		registry_item_data			(i) Object holding the registry item.
 *		modification_rights			(i) Structure specifying the rights
 *											to be allowed for modifying
 *											the registry parameter.
 *		owner_id					(i) The ID of the owner of the registry item
 *		entity_id					(i) The ID for this instance of the 
 *											application.
 *		enable_monitoring			(i) Flag indicating whether the registry
 *											item is to be monitored.
 *		result						(i) Result code indicating whether or not
 *											the registry request was successful.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	RegistryMonitorIndication(	
 *								GCCConfID			conference_id,
 *								CRegKeyContainer        *registry_key_data,
 *								CRegItem                *registry_item_data,
 *								GCCModificationRights	modification_rights,
 *								UserID					owner_id,
 *								EntityID				owner_entity_id);
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This command target routine is called by the CConf object when it
 *		wishes to send a Registry monitor indication to the user application.
 *
 *	Formal Parameters:
 *		conference_id				(i) The conference identifier value.
 *		registry_key_data			(i) Object holding the registry key.
 *		registry_item_data			(i) Object holding the registry item.
 *		modification_rights			(i) Structure specifying the rights
 *											to be allowed for modifying
 *											the registry parameter.
 *		owner_id					(i) The ID of the owner of the registry item
 *		owner_entity_id				(i) The ID for the instance of the 
 *											application owning the registry.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	RegistryAllocateHandleConfirm(	
 *								GCCConfID			conference_id,
 *								UINT					number_of_handles,
 *								UINT					first_handle,
 *								GCCResult				result);
 *
 *	Public member function of CAppSap.
 *
 *	Function Description:
 *		This routine is called by the CConf object when it wishes
 *		to send an enrollment confirmation to the user application.
 *
 *	Formal Parameters:
 *		conference_id				(i) The conference identifier value.
 *		number_of_handles			(i) The number of handles allocated.
 *		first_handle				(i) The first handle allocated.
 *		result						(i) Result code indicating whether or not
 *											the handle allocation was successful
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\arost.h ===
/*
 *	arost.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		Instances of this class represent a single Application Roster's 
 *		information base. This includes both application record information and 
 *		capabilities information.  This is one of the most complex classes in 
 *		all of GCC.  It has a number of responsibilities and must maintain the 
 *		information in a very structured way to preserve the connection 
 *		hierarchy of the records.  This is necessary so that collapsed 
 *		capabilities lists can be calculated as changes to the roster are 
 *		propagated up to the Top Provider.
 *
 *		Similar to the CConfRoster class, the CAppRoster class 
 *		encapsulates all the functionality required to maintain the roster 
 *		information base which includes the ability to add new records, delete 
 *		records and update records. It has the ability to convert its internal 
 *		information base into a list of application records that can be used in 
 *		a GCC_APP_ROSTER_UPDATE_INDICATION callback.  It is also responsible for 
 *		converting its internal information base into Roster Update PDUs.  
 *		Basically,  this class is responsible for all operations that require 
 *		direct access to the records contained in an Application Roster.
 *
 *		The CAppRoster class is also responsible for maintaining the 
 *		capabilities list.  This includes storage as well as calculation of the 
 *		collapsed capabilities list.  This class is also responsible for 
 *		converting the internal capabilities list information base into a list 
 *		that can be used in a GCC_APP_ROSTER_UPDATE_INDICATION callback. It is 
 *		also responsible for converting its internal capabilities list 
 *		information base into the capabilities list portion of a Roster Update 
 *		PDU.  Basically,  this class is responsible for all operations that 
 *		require direct access to the capabilities list.
 *
 *		An Application Roster object has the ability to serialize its roster 
 *		data into a single contiguous memory block when it is required to send a 
 *		message to the application interface.  This serialization process is 
 *		managed externally by the CAppRosterMsg class through calls 
 *		to LockApplicationRoster(), UnLockApplicationRoster() and 
 *		GetAppRoster().  When an Application Roster is to be serialized, 
 *		a call is made to LockApplicationRoster() which causes the 
 *		CAppRoster object to increment an internal lock count and returns 
 *		the number of bytes required to hold the complete roster update.  The 
 *		Application Roster is then serialized into memory through a call to 
 *		GetAppRoster().  The CAppRoster is then unlocked to allow 
 *		it to be deleted when the free flag gets set through the 
 *		FreeApplicationRoster() function.  In the current implementation of GCC, 
 *		FreeApplicationRoster() is not used since the CAppRosterMsg 
 *		maintains the data used to deliver the message (see a more detailed 
 *		description of the lock, free and unlock mechanism in the section 
 *		describing the data containers).
 *
 *		The Application Roster class incorporates a number of Rogue Wave list to 
 *		both hold the roster record information and to maintain the connection 
 *		hierarchy.  In many cases there are lists which contain lists.  The 
 *		details of this get extremely complicated.  The Application Roster 
 *		object also is responsible for maintaining internal PDU data which is 
 *		updated whenever a change occurs to its internal information base.  This 
 *		PDU can be affected by both local request or by processing incoming 
 *		PDUs.  Higher level objects access this PDU data by calling the 
 *		Application Roster's flush routine which in turn causes the PDU to be 
 *		freed on any subsequent request that affects the rosters internal 
 *		information base.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */
#ifndef	_APPLICATION_ROSTER_
#define	_APPLICATION_ROSTER_

#include "gccpdu.h"
#include "capid.h"
#include "sesskey.h"
#include "appcap.h"
#include "igccapp.h"


typedef enum
{
	APP_ADD_RECORD,
	APP_DELETE_RECORD,
	APP_REPLACE_RECORD,
	APP_FULL_REFRESH,
	APP_NO_CHANGE
}
	APP_ROSTER_UPDATE_TYPE;

/*
**	Holds list of capabilities "list" for each protocol entity at a single node.
**	Remember that there can be multiple protocol entities with identical session
**	keys at a single node. Also remember that each of these protocol entities
**	can have multiple capabilities.
*/
class CListOfAppCapItemList2 : public CList2
{
    DEFINE_CLIST2_(CListOfAppCapItemList2, CAppCapItemList*, EntityID)
    void DeleteList(void);
};

/*
**	This is the definition for a single application record.  All the application
**	information (except collapsed capability info) is contained as part of this 
**	record.
*/
typedef struct APP_RECORD
{
	BOOL								is_enrolled_actively;
	BOOL								is_conducting_capable;
	BOOL								was_conducting_capable;
	MCSChannelType						startup_channel_type; 
	UserID								application_user_id;
	CAppCapItemList						non_collapsed_caps_list;
}
	APP_RECORD;

/*
**	This list is used to keep track of the application records at a single node.
**	Since you can have multiple "Protocol Entities" at a single node we use
**	the entity id (which is unique at a node) to index into this list.
*/
class CAppRecordList2 : public CList2
{
    DEFINE_CLIST2_(CAppRecordList2, APP_RECORD*, EntityID)
};


/*
**	This list is used to hold the application record lists for each sub-node
**	of a particular node.
*/
class CSubNodeListOfRecordList2 : public CList2
{
    DEFINE_CLIST2_(CSubNodeListOfRecordList2, CAppRecordList2*, UserID)
};

/*
**	APP_NODE_RECORD
**
**	Below are all the definitions for the application node record. An 
**	application node record holds all the application information for either the
**	local node or a directly connected node.  Note that if the node is the Top 
**	Provider the AppRosterRecordList list will contain information about every
**	"matching" application protocol entity in the entire system.  Matching here
**	means APE's that have the same session key.  
** 
**	An application "roster" record contains all of the following:
**
**	AppRecordList	- 			The list of app records for the protocol 
**								entities at this node.
**
**	ListOfAppCapItemList2 -	    This list holds the list of capabilities for
**								each protocol entity at this node.
**
**	SubNodeList2 -				This list holds the app_record_list for all the
**								nodes below this node in the connection 
**								hierarchy.
**
**	CollapsedCapList -			This holds the collapsed capabilities for
**								all the nodes below this one in the connection
**								hierarchy.  Note that the 
**					   			list_of_capabilities_list is not included in
**								this collapsed list.
**
**	Notice that there is a constructor within this structure. This is
**	needed for the two hash list dictionaries that get instantiated when
**	an AppRosterRecord structure gets instantiated.
*/
typedef struct APP_NODE_RECORD
{
	APP_NODE_RECORD(void);

	CAppRecordList2					AppRecordList;
	CListOfAppCapItemList2		    ListOfAppCapItemList2;
	CSubNodeListOfRecordList2		SubNodeList2;
	CAppCapItemList    				CollapsedCapList;
}
    APP_NODE_RECORD;


/*
**	This list holds all roster records of nodes that are directly connected to 
**	this node.  This list also includes the application records for the local 
**	Application	Protocol entities.  Note that all nodes below this node that
**	are not directly connected to this node are contained in the sub-node list 
**	of the various APP_NODE_RECORD(s) that are contained in this list.
*/
//
// LONCHANC: Can CAppNodeRecordList2 be part of CAppRoster?
// why it is separated from CAppRoster???
//
class CAppNodeRecordList2 : public CList2
{
    DEFINE_CLIST2_(CAppNodeRecordList2, APP_NODE_RECORD*, UserID)
};


class CAppRosterMgr;

class CAppRoster : public CRefCount
{
public:

	CAppRoster(
			PGCCSessionKey,
			PSessionKey,
			CAppRosterMgr *,
			BOOL			fTopProvider,
			BOOL			fLocalRoster,
			BOOL			fMaintainPduBuffer,
			PGCCError);

	~CAppRoster(void);

	/*
	 * Utilities that operate on roster update PDU strucutures.
	 */
	void		FlushRosterUpdateIndicationPDU(PSetOfApplicationInformation *);
	GCCError	BuildFullRefreshPDU(void);
	GCCError	ProcessRosterUpdateIndicationPDU(PSetOfApplicationInformation, UserID);

	/*
	 * Utilities that operate on application records.
	 */
	UINT			LockApplicationRoster(void);
	void			UnLockApplicationRoster(void);
	UINT			GetAppRoster(PGCCApplicationRoster, LPBYTE pData);

	GCCError		AddRecord(GCCEnrollRequest *, GCCNodeID, GCCEntityID);
	GCCError		RemoveRecord(GCCNodeID, GCCEntityID);
	GCCError		ReplaceRecord(GCCEnrollRequest *, GCCNodeID, GCCEntityID);

	GCCError		RemoveUserReference(UserID);

	UINT			GetNumberOfApplicationRecords(void);

	CSessKeyContainer *GetSessionKey(void) { return m_pSessionKey; }

	void			ResetApplicationRoster(void);

	BOOL			DoesRecordExist(UserID, EntityID);

	BOOL			HasRosterChanged(void) { return m_fRosterHasChanged; }

private:

	/*
	 * Utilities used to create a roster update indication PDU.
	 */
	GCCError	BuildApplicationRecordListPDU(APP_ROSTER_UPDATE_TYPE, UserID, EntityID);
	GCCError	BuildSetOfRefreshesPDU(void);
	GCCError	BuildSetOfUpdatesPDU(APP_ROSTER_UPDATE_TYPE, UserID, EntityID);
	GCCError	BuildApplicationRecordPDU(APP_RECORD *, PApplicationRecord);
	GCCError	BuildSetOfCapabilityRefreshesPDU(void);
	GCCError	BuildSetOfNonCollapsingCapabilitiesPDU(PSetOfNonCollapsingCapabilities *, CAppCapItemList *);

	/*
	 * Utilities used to Free a roster update indication PDU.
	 */
	void		FreeRosterUpdateIndicationPDU(void);
	void		FreeSetOfRefreshesPDU(void);
	void		FreeSetOfUpdatesPDU(void);
	void		FreeSetOfCapabilityRefreshesPDU(void);
	void		FreeSetOfNonCollapsingCapabilitiesPDU(PSetOfNonCollapsingCapabilities);
														
	/*
	 * Utilities used to Process roster update indications.
	 */
	GCCError	ProcessSetOfRefreshesPDU(PSetOfApplicationRecordRefreshes, UserID uidSender);
	GCCError	ProcessSetOfUpdatesPDU(PSetOfApplicationRecordUpdates, UserID uidSender);
	GCCError	ProcessApplicationRecordPDU(APP_RECORD *, PApplicationRecord);
	GCCError	ProcessSetOfCapabilityRefreshesPDU(PSetOfApplicationCapabilityRefreshes, UserID uidSender);
	GCCError	ProcessNonCollapsingCapabilitiesPDU(CAppCapItemList *non_collapsed_caps_list,
					                                PSetOfNonCollapsingCapabilities set_of_capabilities);

	/*
	 * Utilities used to operate on conference roster reports.
	 */
	UINT		GetApplicationRecords(PGCCApplicationRoster, LPBYTE memory);
	UINT		GetCapabilitiesList(PGCCApplicationRoster, LPBYTE memory);
	UINT		GetNonCollapsedCapabilitiesList(PGCCApplicationRecord, CAppCapItemList *, LPBYTE memory);
	void		FreeApplicationRosterData(void);
	GCCError	AddCollapsableCapabilities(CAppCapItemList *, UINT cCaps, PGCCApplicationCapability *);
	GCCError	AddNonCollapsedCapabilities(CAppCapItemList *, UINT cCaps, PGCCNonCollapsingCapability *);
	GCCError	ClearNodeRecordFromList(UserID);
	void		ClearNodeRecordList(void);
	GCCError	DeleteRecord(UserID, EntityID, BOOL clear_empty_records);
	void		DeleteApplicationRecordData(APP_RECORD *);
	GCCError	MakeCollapsedCapabilitiesList(void);
	GCCError	AddCapabilityToCollapsedList(APP_CAP_ITEM *);
	BOOL		DoCapabilitiesListMatch(UserID, EntityID, UINT cCapas, PGCCApplicationCapability *);

private:

	UINT							m_nInstance;

	CAppRosterMgr					*m_pAppRosterMgr;
	UINT							m_cbDataMemory;
	BOOL							m_fTopProvider;
	BOOL							m_fLocalRoster;
	CSessKeyContainer			    *m_pSessionKey;

	BOOL							m_fRosterHasChanged;
	BOOL							m_fPeerEntitiesAdded;
	BOOL							m_fPeerEntitiesRemoved;
	BOOL							m_fCapabilitiesHaveChanged;

	CAppNodeRecordList2				m_NodeRecordList2;
//
// LONCHANC: What is the difference between m_NodeRecordList2.CollapsedCapList and
// the following m_CollapsedCapListForAllNodes?
//
// LONCHANC: m_CollapsedCapListForAllNodes is a complete list of collapsed capability list across
// the entire node record list.
//
	CAppCapItemList					m_CollapsedCapListForAllNodes;

	BOOL							m_fMaintainPduBuffer;
	BOOL							m_fPduIsFlushed;
	SetOfApplicationInformation		m_SetOfAppInfo;
	PSetOfApplicationRecordUpdates	m_pSetOfAppRecordUpdates;
};


#endif // _APPLICATION_ROSTER_


/*
 *	CAppRoster(	PGCCSessionKey				session_key,
 *						UINT        				owner_message_base,
 *						BOOL    					is_top_provider,
 *						BOOL    					is_local_roster,
 *						BOOL    					maintain_pdu_buffer,
 *						PGCCError					return_value)
 *
 *	Public Function Description
 *		This is the application roster constructor used when the session key is
 *		made available through local means (not PDU data). It is responsible for
 *		initializing all the instance variables used by this class.
 *
 *	Formal Parameters:
 *		session_key			-	(i) The session key associated with this roster.
 *		owner_object		-	(i)	Pointer to the object that owns this object.
 *		owner_message_base	-	(i) Message base to add to all owner callbacks. 
 *		is_top_provider		-	(i)	Flag indicating if this is a top provider.
 *		is_local_roster		-	(i)	Flag indicating if this is a local roster.
 *		maintain_pdu_buffer	-	(i)	Flag indicating if PDU should be maintained.
 *		return_value		-	(o)	Return value for constructor.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	CAppRoster(	PSessionKey					session_key,
 *						UINT        				owner_message_base,
 *						BOOL    					is_top_provider,
 *						BOOL    					is_local_roster,
 *						BOOL    					maintain_pdu_buffer,
 *						PGCCError					return_value)
 *
 *	Public Function Description
 *		This is the application roster constructor used when the session key is
 *		made available through a PDU. It is responsible for initializing all the 
 *		instance variables used by this class.
 *
 *	Formal Parameters:
 *		session_key			-	(i) The session key associated with this roster.
 *		owner_object		-	(i)	Pointer to the object that owns this object.
 *		owner_message_base	-	(i) Message base to add to all owner callbacks. 
 *		is_top_provider		-	(i)	Flag indicating if this is a top provider.
 *		is_local_roster		-	(i)	Flag indicating if this is a local roster.
 *		maintain_pdu_buffer	-	(i)	Flag indicating if PDU should be maintained.
 *		return_value		-	(o)	Return value for constructor.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	~ApplicationRoster()
 *
 *	Public Function Description
 *		This is the application roster destructor. It is responsible for
 *		freeing up all the internal memory used by this class.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	FlushRosterUpdateIndicationPDU (
 *        				PSetOfApplicationInformation  *		indication_pdu)
 *
 *	Public Function Description
 *		This routine is used to access any PDU data that might currently be
 *		queued inside the application roster.  PDU data is queued whenever
 *		a request is made to the application roster that affects its
 *		internal information base. 
 *
 *	Formal Parameters:
 *		indication_pdu		-	(o) Pointer to the PDU buffer to fill in.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		The PDU data returned by this routine is automatically freed the next 
 *		time a request is made to this roster object that affects its internal
 *		databease.
 */

/*
 *	GCCError	BuildFullRefreshPDU (void)
 *
 *	Public Function Description
 *		This routine is responsible for generating a full application roster 
 *		refresh PDU.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ProcessRosterUpdateIndicationPDU (
 *       					   PSetOfApplicationInformation indication_pdu,
 *       					   UserID						sender_id);
 *
 *	Public Function Description
 *		This routine is responsible for processing the decoded PDU data.
 *		It essentially changes the application roster object's internal database
 *		based on the information in the structure.
 *
 *	Formal Parameters:
 *		indication_pdu		-	(i) This is a pointer to a structure that
 *									holds the decoded PDU data.
 *		sender_id			-	(i)	The user ID of the node that sent the PDU.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	UINT		LockApplicationRoster()
 *
 *	Public Function Description:
 *		This routine is used to "lock" the "API" data for this object.  This
 *		results in the lock count for this object being incremented.  When the
 *		lock count transitions from 0 to 1, a calculation is made to determine
 *		how much memory will be needed to hold any "API" data which will
 *		be referenced by, but not held in, the GCCApplicationRoster structure
 *		which is filled in on a call to GetAppRoster.  This is the
 *		value returned by this routine in order to allow the calling object to
 *		allocate that amount of memory in preparation for the call to 
 *		GetAppRoster.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The amount of memory, if any, which will be needed to hold "API" data
 *		which is referenced by, but not held in, the GetAppRoster 
 *		structure provided as an output parameter to the GetAppRoster 
 *		call.
 *
 *  Side Effects:
 *		The internal lock count is incremented.
 *
 *	Caveats:
 *		The internal lock count is used in conjuction with an internal "free" 
 *		flag as a mechanism for ensuring that this object remains in existance 
 *		until all interested parties are through with it.  The object remains 
 *		valid (unless explicity deleted) until the lock count is zero and the 
 *		"free" flag is set through a call to FreeApplicationRoster.  This allows
 *		other objects to lock this object and be sure that it remains valid 
 *		until they call UnLock which will decrement the internal lock count.  A
 *		typical usage scenerio for this object would be:  An ApplicatonRoster
 *		object is constructed and then passed off to any interested parties
 *		through a function call.  On return from the function call, the
 *		FreeApplicationRoster call is made which will set the internal "free"
 *		flag.  If no other parties have locked the object with a Lock call,
 *		then the CAppRoster object will automatically delete itself when
 *		the FreeApplicationRoster call is made.  If, however, any number of 
 *		other parties has locked the object, it will remain in existence until
 *		each of them has unlocked the object through a call to UnLock.
 */

/*
 *	void			UnLockApplicationRoster ();
 *
 *	Public Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine 
 *		whether the object has been freed through a call to 
 *		FreeApplicationRoster.  If so, the object will automatically delete
 *		itself.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal lock count is decremented.
 *
 *	Caveats:
 *		It is the responsibility of any party which locks an CAppRoster
 *		object by calling Lock to also unlock the object with a call to UnLock.
 *		If the party calling UnLock did not construct the CAppRoster 
 *		object,	it should assume the object to be invalid thereafter.
 */

/*
 *  UINT		GetAppRoster(
 *							PGCCApplicationRoster 		pGccAppRoster,
 *							LPSTR						pData)
 *
 *	Public Function Description:
 *		This routine is used to retrieve the conference roster data from 
 *		the CAppRoster object in the "API" form of a 
 *		GCCApplicationRoster.
 *
 *	Formal Parameters:
 *		application_roster	(o)	The GCCApplicationRoster structure to fill in.
 *		memory				(o)	The memory used to hold any data referenced by,
 *									but not held in, the output structure.
 *
 *	Return Value:
 *		The amount of data, if any, written into the bulk memory block provided.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError		AddRecord(	
 *							PGCCApplicationRecord		application_record,
 *							USHORT						number_of_capabilities,
 *							PGCCApplicationCapability * capabilities_list,
 *							UserID						user_id,
 *							EntityID					entity_id)
 *
 *	Public Function Description:
 *		This routine is used to add a single nodes conference record to the
 *		conference roster object's internal list of records.
 *
 *	Formal Parameters:
 *		application_record		(i)	Pointer to the "API" record	structure to 
 *									add.
 *		number_of_capabilities	(i)	Number of capabilities contained in the
 *									passed in list.
 *		capabilities_list		(i)	List of collapsed capabilities.
 *		user_id					(i)	Node ID associated with record being added.	
 *		entity_id				(i)	Entity ID associated with record being 
 *									added.	
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_NON_COLLAPSED_CAP	-	Bad non-collapsed capabilities.
 *		GCC_INVALID_PARAMETER			-	Invalid parameter passed in.
 *												an invalid object key.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	RemoveRecord(	UserID			node_id)
 *								EntityID		entity_id)
 *
 *	Public Function Description:
 *		This routine is used to remove a single APEs application record from the
 *		application roster object's internal list of records.
 *
 *	Formal Parameters:
 *		node_id				(i)	Node ID of record to be removed.
 *		entity_id			(i)	Entity ID of record to be removed.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_INVALID_PARAMETER			-	Invalid parameter passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ReplaceRecord(		
 *							PGCCApplicationRecord		application_record,
 *							USHORT						number_of_capabilities,
 *							PGCCApplicationCapability * capabilities_list,
 *							UserID						user_id,
 *							EntityID					entity_id)
 *
 *	Public Function Description:
 *		This routine is used to replace a single APEs application record in the
 *		application roster object's internal list of records.
 *
 *	Formal Parameters:
 *		application_record		(i)	Conference record to use as the replacement.
 *		number_of_capabilities	(i)	Number of capabilities contained in the
 *									passed in list.
 *		capabilities_list		(i)	List of collapsed capabilities.
 *		user_id					(i)	Node ID of record to be replaced.
 *		entity_id				(i)	Entity ID of record to be replaced.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_PARAMETER			-	Invalid parameter passed in.
 *		GCC_INVALID_NON_COLLAPSED_CAP	-	Bad non-collapsed capabilities.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	RemoveUserReference (
 *							UserID					detached_node)
 *
 *	Public Function Description:
 *		This routine removes all records associated with the specified node
 *		id.
 *
 *	Formal Parameters:
 *		detached_node		(i)	Node reference to remove.
 *
 *	Return Value:
 *		GCC_NO_ERROR				-	No error occured.
 *		GCC_INVALID_PARAMETER		-	No records associated with this node
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	USHORT	GetNumberOfApplicationRecords ();
 *
 *	Public Function Description:
 *		This routine returns the total number of application roster records
 *		contained in the objects conference roster record list.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The number of records in the application roster list.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	CSessKeyContainer *GetSessionKey ()
 *
 *	Public Function Description:
 *		This routine returns a pointer to the session key associated with this
 *		application roster.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The session key associated with this roster.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	void		ResetApplicationRoster ()
 *
 *	Public Function Description:
 *		This routine takes care of resetting all the internal flags that are
 *		used to convey the current state of the application roster.  Should be
 *		called after the roster is flushed and any roster update messages have
 *		been delivered (after a change to the roster occurs).
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	DBBoolean	DoesRecordExist (
 *							UserID						node_id,
 *							EntityID					entity_id)
 *
 *	Public Function Description:
 *		This routine informs the caller if the specified application record 
 *		exists or not.
 *
 *	Formal Parameters:
 *		node_id			-	(i)	Node ID of APE record to check.
 *		entity_id		-	(i)	Entity ID of APE record to check.
 *
 *	Return Value:
 *		TRUE		-	record exist.
 *		FALSE		-	record does not exist.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	DBBoolean		HasRosterChanged ();
 *
 *	Public Function Description:
 *		This routine informs the caller if the roster has changed since the
 *		last time it was reset.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		TRUE		-	If roster has changed
 *		FALSE		-	If roster has not changed
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\clists.h ===
#ifndef _CLISTS_H_
#define _CLISTS_H_

#define DESIRED_MAX_APP_SAP_ITEMS       6

#define DESIRED_MAX_CONFS               CLIST_DEFAULT_MAX_ITEMS
#define DESIRED_MAX_CONF_ITEMS          DESIRED_MAX_CONFS

#define DESIRED_MAX_CAPS                8
#define DESIRED_MAX_CAP_LISTS           CLIST_DEFAULT_MAX_ITEMS

#define DESIRED_MAX_APP_RECORDS         DESIRED_MAX_APP_SAP_ITEMS
#define DESIRED_MAX_NODES               CLIST_DEFAULT_MAX_ITEMS
#define DESIRED_MAX_NODE_RECORDS        DESIRED_MAX_NODES

#define DESIRED_MAX_CALLBACK_MESSAGES   8

#define DESIRED_MAX_USER_DATA_ITEMS     8

#define DESIRED_MAX_CONN_HANDLES        CLIST_DEFAULT_MAX_ITEMS


// to hold all the non-default session application rosters
class CAppRosterList : public CList
{
    DEFINE_CLIST(CAppRosterList, CAppRoster*)
    void DeleteList(void);
};

// to hold all the application roster managers
class CAppRosterMgrList : public CList
{
    DEFINE_CLIST(CAppRosterMgrList, CAppRosterMgr*)
    void DeleteList(void);
};

// to hold a list of conferences
class CConfList : public CList
{
    DEFINE_CLIST(CConfList, CConf*)
    void DeleteList(void);
};

// to hold all the conferences indexed by conference id
class CConfList2 : public CList2
{
    DEFINE_CLIST2(CConfList2, CConf*, GCCConfID)
    void DeleteList(void);
};

// to hold a list of application sap
class CAppSapList : public CList
{
    DEFINE_CLIST(CAppSapList, CAppSap*)
    void DeleteList(void);
};

// to hold all application sap indexed by entity id
class CAppSapEidList2 : public CList2
{
    DEFINE_CLIST2_(CAppSapEidList2, CAppSap*, GCCEntityID)
    void DeleteList(void);
};

// to hold a list of user id or node id.
class CUidList : public CList
{
    DEFINE_CLIST_(CUidList, UserID)
    void BuildExternalList(PSetOfUserIDs *);
};

// to hold a list of entity id
class CEidList : public CList
{
    DEFINE_CLIST_(CEidList, GCCEntityID)
};

// to hold a list of channel id
class CChannelIDList : public CList
{
    DEFINE_CLIST_(CChannelIDList, ChannelID)
    void BuildExternalList(PSetOfChannelIDs *);
};

// to hold a list of token id
class CTokenIDList : public CList
{
    DEFINE_CLIST_(CTokenIDList, TokenID)
    void BuildExternalList(PSetOfTokenIDs *);
};

// simple packet queue
class CSimplePktQueue : public CQueue
{
    DEFINE_CQUEUE(CSimplePktQueue, PSimplePacket)
};

// remote connection list (aka remote attachment list)
class CConnectionList : public CList
{
    DEFINE_CLIST(CConnectionList, PConnection)
};

class CConnectionQueue : public CQueue
{
    DEFINE_CQUEUE(CConnectionQueue, PConnection)
};

class CTokenList2 : public CList2
{
    DEFINE_CLIST2_(CTokenList2, PToken, TokenID)
};

class CDomainList2 : public CList2
{
    DEFINE_CLIST2(CDomainList2, PDomain, GCCConfID)
};



class CChannelList2 : public CHashedList2
{
    DEFINE_HLIST2_(CChannelList2, PChannel, ChannelID)
};

class CConnectionList2 : public CHashedList2
{
    DEFINE_HLIST2_(CConnectionList2, PConnection, ConnectionHandle)
};

#endif // _CLISTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\channel.h ===
/*
 *	channel.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the Channel class.  This class represents
 *		both static and assigned channels within an MCS domain.  This class is
 *		also the base class for all other types of channels in MCS.  It defines
 *		the default behavior that can be inherited by these other classes.
 *
 *		Instances of the Channel class have three primary responsibilities:
 *		managing the join/leave process; sending data; and issuing merge
 *		requests during a domain merger.
 *
 *		When a user tries to join a channel, the request is sent to the Channel
 *		object that represents the channel.  The Channel object can then decide
 *		whether or not to allow the join.  By overriding the appropriate
 *		member functions, derived classes can change the criteria by which
 *		this decision is made.
 *
 *		All Channel objects maintain an internal list of which attachments are
 *		joined to the channel they represent.  When data is sent on the channel,
 *		the request is sent to the Channel object, who then knows how to route
 *		the data.  The data is sent to all the appropriate attachments.
 *
 *		During a domain information base merger, all Channel objects will be
 *		asked to issue a merge request upward toward the new top provider.  The
 *		merge request will be built using information contained in the Channel
 *		object.
 *
 *		All public member functions of this class are declared as virtual, so
 *		that they can be overridden in case a derived class has to modify the
 *		behavior.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef _CHANNEL_
#define _CHANNEL_


/*
 *	This is a dictionary of channels that exist within the current domain.
 *	The key to the dictionary is the channel ID, by which channels are
 *	identified.  The value is a pointer to an object of class Channel.  By
 *	definition, if a channel is in the list, then it exists and knows how
 *	to respond to channel related activity.  If a channel is not in the
 *	list, then it does not exist (from the point-of-view of this MCS
 *	provider).
 */

/*
 *	This is the class definition for class Channel.
 */
class Channel
{
public:

	Channel (
			ChannelID			channel_id,
			PDomain             local_provider,
			PConnection         top_provider,
			CChannelList2      *channel_list,
			CAttachmentList    *attachment_list);
	Channel (
			ChannelID			channel_id,
			PDomain             local_provider,
			PConnection         top_provider,
			CChannelList2      *channel_list,
			CAttachmentList    *attachment_list,
			PConnection         pConn);
	virtual					~Channel ();

    void    SetTopProvider(PConnection top_provider) { m_pConnToTopProvider = top_provider; }
    BOOL    IsTopProvider(void) { return (NULL == m_pConnToTopProvider); }

	virtual Channel_Type	GetChannelType ();
	virtual	BOOL    		IsValid ();
    virtual CAttachment *GetAttachment(void) { return NULL; }
	virtual	Void			IssueMergeRequest ();
	virtual Void			ChannelJoinRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									ChannelID			channel_id);
	Void			ChannelJoinConfirm (
									CAttachment        *originator,
									Result				result,
									UserID				uidInitiator,
									ChannelID			requested_id,
									ChannelID			channel_id);
	Void			ChannelLeaveRequest (
									CAttachment        *originator,
									CChannelIDList     *channel_id_list);
	virtual Void			SendDataRequest (
									CAttachment        *originator,
									UINT				type,
									PDataPacket			data_packet);
	Void			SendDataIndication (
									PConnection         originator,
									UINT				type,
									PDataPacket			data_packet);

protected:
	ChannelID				Channel_ID;
	PDomain                 m_pDomain;
	PConnection             m_pConnToTopProvider;
	CChannelList2          *m_pChannelList2;
	CAttachmentList        *m_pAttachmentList;
	CAttachmentList         m_JoinedAttachmentList;
};

/*
 *	Channel (
 *			ChannelID			channel_id,
 *			PDomain     		local_provider,
 *			PConnection 		top_provider,
 *			PChannelList		channel_list,
 *			PAttachmentList		attachment_list)
 *
 *	Functional Description:
 *		This is the normal constructor for the Channel class.  It simply
 *		initializes the instance variables that identify the channel, the local
 *		provider, and the top provider.  The attachment list is empty by
 *		default.
 *
 *	Formal Parameters:
 *		channel_id (i)
 *			This is the ID of the channel object.  By keeping track of this
 *			internally, it doesn't have to be passed in for every operation.
 *		local_provider (i)
 *			This is the identity of the local provider.  A Channel object
 *			needs this since it issues MCS commands on behalf of the local
 *			provider.
 *		top_provider (i)
 *			This is a pointer to the top provider.  This is used by the
 *			Channel object when it needs to issue a request to the Top
 *			Provider.  If NULL, then this is the top provider.
 *		channel_list (i)
 *			This is a pointer to the domain's channel list, which identifies
 *			all valid channels in the domain.  This is used by channel objects
 *			to validate user IDs.
 *		attachment_list (i)
 *			This is a pointer to the domain's attachment list, which identifies
 *			all valid attachments in the domain.  This is used by channel
 *			objects to validate joined attachments.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Channel (
 *			ChannelID			channel_id,
 *			PDomain     		local_provider,
 *			PConnection 		top_provider,
 *			PChannelList		channel_list,
 *			PAttachmentList		attachment_list,
 *			PCommandTarget		attachment)
 *
 *	Functional Description:
 *		This is a secondary version of the constructor that is used only during
 *		merge operations.  The only difference between this one and the one
 *		above is that this one allows the specification of an initial
 *		attachment.  This allows a Channel object to be constructed with an
 *		existing attachment, without the transmission of a ChannelJoinConfirm.
 *
 *		Remember that if a Channel object is constructed, and then a join
 *		request is used to add an attachment, a Channel object automatically
 *		issues a join confirm.  This constructor allows that to be bypassed
 *		during a merger when a join confirm is inappropriate.
 *
 *	Formal Parameters:
 *		channel_id (i)
 *			This is the ID of the channel object.  By keeping track of this
 *			internally, it doesn't have to be passed in for every operation.
 *		local_provider (i)
 *			This is the identity of the local provider.  A Channel object
 *			needs this since it issues MCS commands on behalf of the local
 *			provider.
 *		top_provider (i)
 *			This is a pointer to the top provider.  This is used by the
 *			Channel object when it needs to issue a request to the Top
 *			Provider.  If NULL, then this is the top provider.
 *		channel_list (i)
 *			This is a pointer to the domain's channel list, which identifies
 *			all valid channels in the domain.  This is used by channel objects
 *			to validate user IDs.
 *		attachment_list (i)
 *			This is a pointer to the domain's attachment list, which identifies
 *			all valid attachments in the domain.  This is used by channel
 *			objects to validate joined attachments.
 *		attachment (i)
 *			This is the initial attachment for the channel.  A channel join
 *			confirm is NOT issued to the attachment.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~Channel ()
 *
 *	Functional Description:
 *		This is the Channel class destructor.  It clears the joined attachment
 *		list, sending channel leave indications to any user that is locally
 *		attached.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		SetTopProvider (
 *						PConnection		top_provider)
 *
 *	Functional Description:
 *		This member function is used to change the identity of the Top Provider
 *		in an existing channel.  The only time this will really occur is when
 *		a provider that used to be the Top Provider merges into another
 *		domain, and therefore ceases to be the Top Provider.
 *
 *	Formal Parameters:
 *		top_provider (i)
 *			This is a pointer to the new Top Provider.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Channel_Type	GetChannelType ()
 *
 *	Functional Description:
 *		This virtual member function returns the type of the channel.  For this
 *		class it will be either STATIC_CHANNEL or ASSIGNED_CHANNEL, depending
 *		on the value of the channel ID.
 *
 *		This member function should be overridden by all classes that inherit
 *		from this one so that they return a different type.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		STATIC_CHANNEL if the channel ID is 1000 or less.
 *		ASSIGNED_CHANNEL if the channel ID is greater than 1000.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	BOOL	IsValid ()
 *
 *	Functional Description:
 *		This function returns TRUE if the channel is still valid, and FALSE if
 *		it is ready for deletion.  This is a virtual function allowing derived
 *		classes to change the way this decision is made.
 *
 *		This function will use the information in the domain's channel and
 *		attachment lists to validate its own existence.  For example, if a
 *		channel is owned by a user, and that user detaches, the channel will
 *		ask to be deleted.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		TRUE if channel still valid.
 *		FALSE if channel needs to be deleted.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	CAttachment *GetAttachment ()
 *
 *	Functional Description:
 *		This function returns a pointer to the attachment that leads to the
 *		owner of the channel.  Since STATIC and ASSIGNED channels do not have
 *		owners, this function will always return NULL.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		NULL.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		IssueMergeRequest ()
 *
 *	Functional Description:
 *		This member function causes the Channel object to issue a merge request
 *		to the top provider.  It will pack the appropriate local information
 *		into the command.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelJoinRequest (
 *						PCommandTarget		originator,
 *						UserID				uidInitiator,
 *						ChannelID			channel_id)
 *
 *	Functional Description:
 *		This function is invoked when a user tries to join the channel
 *		associated with a Channel object.  The originator will be added to
 *		the attachment list if it is not already there.
 *
 *		If the user ID passed in is valid (not 0), then a channel join confirm
 *		will be issued to the user.  Setting the user ID to 0 (zero), inhibits
 *		this.
 *
 *		Derived classes can override this member function to provide more
 *		stringent rules about who can join a channel.  This class lets anyone
 *		join, as specified in MCS for static and assigned channels.
 *
 *	Formal Parameters:
 *		originator
 *			This is the attachment of the user wishing to join the channel.
 *		uidInitiator
 *			This is the user ID of the user joining the channel.  This can
 *			be used for security checking in derived classes if desired.
 *		channel_id
 *			This is the channel being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelJoinConfirm (
 *						PCommandTarget		originator,
 *						Result				result,
 *						UserID				uidInitiator,
 *						UserID				requested_id,
 *						ChannelID			channel_id)
 *
 *	Functional Description:
 *		This function performs essentially the same operation as JoinRequest
 *		above.  The only difference is that the user ID cannot be set to 0
 *		to inhibit the re-transmission of the join confirm to the user who
 *		is joining the channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment of the user wishing to join the channel.
 *		result (i)
 *			This is the result of the previous join request.
 *		uidInitiator (i)
 *			This is the user ID of the user joining the channel.  This can
 *			be used for security checking in derived classes if desired.
 *		requested_id (i)
 *			This is the ID of the channel that the user originally asked to
 *			join.  The only time this will be different from the channel ID
 *			below is if the user asked for channel 0, which is interpreted as
 *			a request for an assigned channel.
 *		channel_id (i)
 *			This is the channel being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ChannelLeaveRequest (
 *					PCommandTarget		originator,
 *					CChannelIDList     *channel_id_list)
 *
 *	Functional Description:
 *		This member function is used when an attachment needs to be removed
 *		from a channel.  A leave request will only be received from a lower
 *		provider when all attachments at that level have left (this means that
 *		the data for the channel no longer needs to be sent downward).
 *
 *		If this request results in an empty attachment list a
 *		ChannelLeaveRequest will be sent upward to the next higher provider in
 *		the domain (unless this is the Top Provider).
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment to be removed from the channel.
 *		channel_id_list (i)
 *			This is the list of channels being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		SendDataRequest (
 *						PCommandTarget		originator,
 *						UINT				type, 
 *						PDataPacket			data_packet)
 *
 *	Functional Description:
 *		This function is called when it is necessary to send data through the
 *		channel that this Channel object represents.  All rules for
 *		non-uniform data apply.  The data will be forwarded upward toward
 *		the Top Provider (unless this is the Top Provider).  Data will also
 *		be sent immediately downward to all attachments who are joined to
 *		the channel, except for the attachment from which the data came.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the data came.
 *		type (i)
 *			Simple or uniform send data request.
 *		data_packet (i)
 *			This is a pointer to a DataPacket object containing the channel
 *			ID, the User ID of the data sender, segmentation flags, priority of
 *			the data packet and a pointer to the packet to be sent.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		SendDataIndication (
 *						PCommandTarget		originator,
 *						UINT				type,
 *						PDataPacket			data_packet)
 *
 *	Functional Description:
 *		This function is called when it is necessary to send data through the
 *		channel that this Channel object represents.  The data will be sent
 *		downward to all attachments joined to the channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the data came.
 *		type (i)
 *			normal or uniform indication.
 *		data_packet (i)
 *			This is a pointer to a DataPacket object containing the channel
 *			ID, the User ID of the data sender, segmentation flags, priority of
 *			the data packet and a pointer to the packet to be sent.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\attmnt.h ===
#ifndef __MCS_ATTACHMENT_H__
#define __MCS_ATTACHMENT_H__

typedef enum
{
    USER_ATTACHMENT,        // local attachment
    CONNECT_ATTACHMENT      // remote attachment
}
    ATTACHMENT_TYPE;


class CAttachmentList : public CList
{
    DEFINE_CLIST(CAttachmentList, CAttachment*)

    PUser IterateUser(void);
    PConnection IterateConn(void);

    BOOL FindUser(PUser pUser) { return Find((CAttachment *) pUser); }
    BOOL FindConn(PConnection pConn) { return Find((CAttachment *) pConn); }

    BOOL AppendUser(PUser pUser) { return Append((CAttachment *) pUser); }
    BOOL AppendConn(PConnection pConn) { return Append((CAttachment *) pConn); }
};

class CAttachmentQueue : public CQueue
{
    DEFINE_CQUEUE(CAttachmentQueue, CAttachment*)

    PUser IterateUser(void);
    PConnection IterateConn(void);

    BOOL FindUser(PUser pUser) { return Find((CAttachment *) pUser); }
    BOOL FindConn(PConnection pConn) { return Find((CAttachment *) pConn); }

    BOOL AppendUser(PUser pUser) { return Append((CAttachment *) pUser); }
    BOOL AppendConn(PConnection pConn) { return Append((CAttachment *) pConn); }
};



class CAttachment
{
public:

    CAttachment(ATTACHMENT_TYPE eAttmntType) : m_eAttmntType(eAttmntType) { }
    // ~CAttachment(void) { }

    ATTACHMENT_TYPE GetAttachmentType(void) { return m_eAttmntType; }
    BOOL            IsUserAttachment(void) { return (USER_ATTACHMENT == m_eAttmntType); }
    BOOL            IsConnAttachment(void) { return (CONNECT_ATTACHMENT == m_eAttmntType); }


    virtual void PlumbDomainIndication(ULONG height_limit) = 0;
    virtual void PurgeChannelsIndication(CUidList *, CChannelIDList *) = 0;
    virtual void PurgeTokensIndication(PDomain, CTokenIDList *) = 0;
    virtual void DisconnectProviderUltimatum(Reason) = 0;
    virtual void AttachUserConfirm(Result, UserID uidInitiator) = 0;
    virtual void DetachUserIndication(Reason, CUidList *) = 0;
    virtual void ChannelJoinConfirm(Result, UserID uidInitiator, ChannelID requested_id, ChannelID) = 0;
    virtual void ChannelConveneConfirm(Result, UserID uidInitiator, ChannelID) = 0;
    virtual void ChannelDisbandIndication(ChannelID) = 0;
    virtual void ChannelAdmitIndication(UserID uidInitiator, ChannelID, CUidList *) = 0;
    virtual void ChannelExpelIndication(ChannelID, CUidList *) = 0;
    virtual void SendDataIndication(UINT message_type, PDataPacket data_packet) = 0;
    virtual void TokenGrabConfirm(Result, UserID uidInitiator, TokenID, TokenStatus) = 0;
    virtual void TokenInhibitConfirm(Result, UserID uidInitiator, TokenID, TokenStatus) = 0;
    virtual void TokenGiveIndication(PTokenGiveRecord) = 0;
    virtual void TokenGiveConfirm(Result, UserID uidInitiator, TokenID, TokenStatus) = 0;
    virtual void TokenReleaseConfirm(Result, UserID uidInitiator, TokenID, TokenStatus) = 0;
    virtual void TokenPleaseIndication(UserID uidInitiator, TokenID) = 0;
    virtual void TokenTestConfirm(UserID uidInitiator, TokenID, TokenStatus) = 0;
    virtual void MergeDomainIndication(MergeStatus) = 0;

private:

    ATTACHMENT_TYPE     m_eAttmntType;
};



#endif // __MCS_ATTACHMENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\capid.h ===
/*
 *	capid.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class CCapIDContainer.  A
 *		CCapIDContainer object is used to maintain information about
 *		a particular capability of an application.  A capability identifier can
 *		be either a standard type or a non-standard type.  When the type is 
 *		standard, the identifier is stored internally as an integer value.  When
 *		the type is non-standard, an CObjectKeyContainer container object is used 
 *		internally to buffer the necessary data.  In this case the identifier 
 *		data may exist as an Object ID which is a series of non-negative 
 *		integers or an H221 non-standard ID which is an octet string of no fewer
 *		than four octets and no more than 255 octets.   
 * 
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */
#ifndef	_CAPABILITY_IDENTIFIER_DATA_
#define	_CAPABILITY_IDENTIFIER_DATA_

#include "objkey.h"

/*
 * This is the typedef for the structure used to hold the capability identifier
 * data	internally.
 */
typedef struct
{
    GCCCapabilityIDType		capability_id_type;

    union
    {
        USHORT			  	standard_capability;
        CObjectKeyContainer *non_standard_capability;
    } u;
}
    CAP_ID_STRUCT;

/*
 * Class definition:
 */
class CCapIDContainer : public CRefCount
{
public:

	CCapIDContainer(PGCCCapabilityID, PGCCError);
	CCapIDContainer(PCapabilityID, PGCCError);
	CCapIDContainer(CCapIDContainer *, PGCCError);

	~CCapIDContainer(void);

	UINT		LockCapabilityIdentifierData(void);
	void		UnLockCapabilityIdentifierData(void);

	UINT		GetGCCCapabilityIDData(PGCCCapabilityID, LPBYTE memory);
	GCCError	GetCapabilityIdentifierDataPDU(PCapabilityID);
	void		FreeCapabilityIdentifierDataPDU(void);

friend BOOL 	operator== (const CCapIDContainer&, const CCapIDContainer&);

protected:

	CAP_ID_STRUCT	                m_InternalCapID;
	UINT							m_cbDataSize;

	CapabilityID					m_CapIDPDU;
	BOOL    						m_fValidCapIDPDU;
};

/*
 *	Comments explaining the public and protected class member functions
 */

/*
 *	CCapIDContainer (	PGCCCapabilityID	capability_id,
 *								PGCCError			return_value);
 *
 *	Public member function of CCapIDContainer.
 *
 *	Function Description:
 *		This is the constructor for the CCapIDContainer class which 
 *		takes as input the "API" version of capability ID data, GCCCapabilityID.
 *
 *	Formal Parameters:
 *		capability_id		(i)	The capability ID data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_CAPABILITY_ID			-	An invalid capability ID passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	CCapIDContainer (	PCapabilityID		capability_id,
 *								PGCCError			return_value);
 *
 *	Public member function of CCapIDContainer.
 *
 *	Function Description:
 *		This is the constructor for the CCapIDContainer class which 
 *		takes as input the "PDU" version of capability ID data, CapabilityID.
 *
 *	Formal Parameters:
 *		capability_id		(i)	The capability ID data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_CAPABILITY_ID			-	An invalid capability ID passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	CCapIDContainer(CCapIDContainer *capability_id,
 *			PGCCError						return_value);
 *
 *	Public member function of CCapIDContainer.
 *
 *	Function Description:
 *		This is the copy constructor for the CCapIDContainer class 
 *		which takes as input another CCapIDContainer object.
 *
 *	Formal Parameters:
 *		capability_id		(i)	The CCapIDContainer object to copy.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_CAPABILITY_ID			-	An invalid CCapIDContainer
 *												passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	~CapabilityIdentifierData();
 *
 *	Public member function of CCapIDContainer.
 *
 *	Function Description:
 *		This is the destructor for the CCapIDContainer class.  It is 
 *		used to	clean up any memory allocated during the life of this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	UINT			LockCapabilityIdentifierData ();
 *
 *	Public member function of CCapIDContainer.
 *
 *	Function Description:
 *		This routine is used to "lock" the "API" data for this object.  This
 *		results in the lock count for this object being incremented.  When the
 *		lock count transitions from 0 to 1, a calculation is made to determine
 *		how much memory will be needed to hold any "API" data which will
 *		be referenced by, but not held in, the GCCCapabilityID structure
 *		which is filled in on a call to GetGCCCapabilityIDData.  This is the
 *		value returned by this routine in order to allow the calling object to
 *		allocate that amount of memory in preparation for the call to 
 *		GetGCCCapabilityIDData.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The amount of memory, if any, which will be needed to hold "API" data
 *		which is referenced by, but not held in, the GCCCapabilityID structure
 *		provided as an output parameter to the GetGCCCapabilityIDData call.
 *
 *  Side Effects:
 *		The internal lock count is incremented.
 *
 *	Caveats:
 *		The internal lock count is used in conjuction with an internal "free" 
 *		flag as a mechanism for ensuring that this object remains in existance 
 *		until all interested parties are through with it.  The object remains 
 *		valid (unless explicity deleted) until the lock count is zero and the 
 *		"free" flag is set through a call to FreeCapabilityIdentifierData.  This
 *		allows other objects to lock this object and be sure that it remains 
 *		valid until they call UnLock which will decrement the internal lock 
 *		count.  A typical usage scenerio for this object would be:  A
 *		CCapIDContainer object is constructed and then passed off to 
 *		any interested parties through a function call.  On return from the 
 *		function call, the FreeCapabilityIdentifierData call is made which will
 *		set the internal "free"	flag.  If no other parties have locked the 
 *		object with a Lock call, then the CCapIDContainer object will 
 *		automatically delete itself when the FreeCapabilityIdentifierData call
 *		is made.  If, however, any number of other parties has locked the 
 *		object, it will remain in existence until each of them has unlocked the
 *		object through a call to UnLock.
 */


/*
 *	UINT			GetGCCCapabilityIdentifierData (	
 *							PGCCCapabilityID 		capability_id,
 *							LPSTR					memory);
 *
 *	Public member function of CCapIDContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the capability ID data from the
 *		CCapIDContainer object in the "API" form of a GCCCapabilityID.
 *
 *	Formal Parameters:
 *		capability_id		(o)	The GCCCapabilityID structure to fill in.
 *		memory				(o)	The memory used to hold any data referenced by,
 *									but not held in, the output structure.
 *
 *	Return Value:
 *		The amount of data, if any, written into the bulk memory block provided.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void			UnLockCapabilityIdentifierData ();
 *
 *	Public member function of CCapIDContainer.
 *
 *	Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine 
 *		whether the object has been freed through a call to 
 *		FreeCapabilityIdentifierData.  If so, the object will automatically 
 *		delete itself.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal lock count is decremented.
 *
 *	Caveats:
 *		It is the responsibility of any party which locks a 
 *		CCapIDContainer object by calling Lock to also unlock the 
 *		object with a call to UnLock.  If the party calling UnLock did not 
 *		construct the CCapIDContainer object,	it should assume the 
 *		object to be invalid thereafter.
 */


/*
 *	GCCError		GetCapabilityIdentifierDataPDU (	
 *							PCapabilityID 		capability_id);
 *
 *	Public member function of CCapIDContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the capability ID data from the
 *		CCapIDContainer object in the "PDU" form of a CapabilityID.
 *
 *	Formal Parameters:
 *		capability_id		(o)	The CapabilityID structure to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_OBJECT_KEY				-	One of the internal pointers has
 *												been corrupted.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void		FreeCapabilityIdentifierDataPDU ();
 *
 *	Public member function of CCapIDContainer.
 *
 *	Function Description:
 *		This routine is used to "free" the "PDU" data allocated for this object
 *		which is held internally in a CapabilityID structure.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal "free" flag is set.
 *
 *	Caveats:
 *		This object should be assumed invalid after a call to 
 *		FreeCapabilityIdentifierDataPDU has been made.
 */


/*
 *	friend BOOL	operator== (
 *					const CCapIDContainer& 		capability_id_1, 
 *					const CCapIDContainer& 		capability_id_2);
 *
 *	Public member function of CCapIDContainer.
 *
 *	Function Description:
 *		This routine is used to compare two CCapIDContainer objects 
 *		to determine whether or not they are equal in value.
 *
 *	Formal Parameters:
 *		capability_id_1			(i)	The first CCapIDContainer object 
 *										to compare.
 *		capability_id_2			(i)	The other CCapIDContainer object 
 *										to compare.
 *
 *	Return Value:
 *		TRUE				-	The two objects are equal in value.
 *		FALSE				- 	The two objects are not equal in value.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\cmdtar.h ===
/*
 *	cmdtar.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the CommandTarget class.  This
 *		is an abstract base class, meaning that it cannot be directly
 *		instantiated, but rather, exists to be inherited from.  It defines
 *		a set of virtual member functions which will be shared by all classes
 *		that inherit from this one.
 *
 *		These virtual member function can be thought of as a "language" that
 *		is used by CommandTarget objects to communicate with one another
 *		at run-time.  This language contains all "MCS commands" (or just
 *		commands) that are necessary for domain management within an MCS
 *		provider.
 *
 *		The MCS commands that make up this language have a one-to-one
 *		correspondence with the Domain Protocol Data Units (Domain MCSPDUs) that
 *		are defined in T.125.  There are also three additional MCS command that
 *		do not have T.125 counterparts: ChannelLeaveIndication,
 *		TokenReleaseIndication, and MergeDomainIndication.  These are specific
 *		to this implementation, and used for local traffic only (these do NOT
 *		correspond to PDUs that travel over any connection).  See the
 *		description of each command at the end of this interface file to see
 *		what each command does.
 *
 *		The first parameter of all commands is the address of the object
 *		who is sending it (its "this" pointer).  This can be used by the
 *		recipient of the command to track identity of other CommandTargets
 *		in the system.  Since all CommandTarget classes share the same
 *		language, the communication between them is bi-directional.
 *
 *		Any class inheriting from this one that wants to receive and process
 *		a command needs to override the virtual member function corresponding
 *		to that command.  It is only necessary to override those commands that
 *		a given class expects to receive at run-time (for example, the Channel
 *		class would never receive a TokenGrabRequest).
 *
 *		See the description of each class that inherits from this one for a
 *		more complete discussion of how the command language is used.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	_COMMANDTARGET_
#define	_COMMANDTARGET_

#include "clists.h"

/*
 *	This enumeration defines the valid types of attachments.  Note that for
 *	most operations, the domain class does not distinguish between user
 *	attachments and MCS connections.  They are both lumped under the term
 *	attachment.  There are, however, a few cases where this identity is
 *	important, so the type is saved as one of the following:
 *
 *	LOCAL_ATTACHMENT
 *		This attachment type refers to a user attachment.
 *	REMOTE_ATTACHMENT
 *		This attachment type refers to an MCS connection (through one or more
 *		transport connections).
 *
 *	Each attachment in the attachment list is identified as one of these two
 *	types.
 */

/*
 *	This is a set of container definitions using templates. All containers
 *	are based on classes in the Rogue Wave Tools.h++ class library.
 *
 *	Each container that is defined here has an associated iterator which is
 *	not explicitly mentioned.  All iterators simply allow the code to walk
 *	through all items in the container in a very efficient manner.
 *
 *	CAttachmentList
 *		This is a dictionary of attachments that are hierarchically below the
 *		current provider.  The key to the dictionary is a pointer to an object
 *		of class CommandTarget.  The value is the attachment type, which is
 *		either local (for user attachments), or remote (for MCS connections).
 *	CChannelIDList
 *		This is a list of channel IDs.  This is used when it is necessary to
 *		keep a list of channels to perform some action on (such as deletion)
 *		that cannot be performed right away.
 *	CUserIDList (aka CUidList)
 *		This is a list of user IDs.  This is for such things as keeping a list
 *		of admitted users in a private channel, and keeping a list of inhibitors
 *		of a token.
 *	CTokenIDList
 *		This is a list of token IDs.  This is used when it is necessary to
 *		keep a list of tokens to perform some action on (such as deletion)
 *		that cannot be performed right away.
 */

/*
 *	These types are used when dealing with MCS channels.
 *
 *	Channel_Type
 *		This type defines the types of channels that are available in MCS.
 *	StaticChannelAttributes
 *		This structure is used to define those attributes that are specific
 *		to static channels.
 *	UserChannelAttributes
 *		This structure is used to define those attributes that are specific
 *		to user channels.
 *	PrivateChannelAttributes
 *		This structure is used to define those attributes that are specific
 *		to private channels.
 *	AssignedChannelAttributes
 *		This structure is used to define those attributes that are specific
 *		to assigned channels.
 *	ChannelAttributes
 *		This structure is used to define the attributes of ANY type of channel.
 *		It contains a channel type, and a union of the above four types.
 *	CChannelAttributesList
 *		This is an S-list of ChannelAttributes structures.
 */
typedef	enum
{
	STATIC_CHANNEL,
	USER_CHANNEL,
	PRIVATE_CHANNEL,
	ASSIGNED_CHANNEL
} Channel_Type;
typedef	Channel_Type *			PChannelType;

typedef	struct
{
	ChannelID			channel_id;
} StaticChannelAttributes;

typedef	struct
{
	DBBoolean			joined;
	UserID				user_id;
} UserChannelAttributes;

typedef	struct
{
	DBBoolean			joined;
	ChannelID			channel_id;
	UserID				channel_manager;
	CUidList           *admitted_list;
} PrivateChannelAttributes;

typedef	struct
{
	ChannelID			channel_id;
} AssignedChannelAttributes;

typedef	struct
{
	Channel_Type		channel_type;
	union
	{
		StaticChannelAttributes		static_channel_attributes;
		UserChannelAttributes		user_channel_attributes;
		PrivateChannelAttributes	private_channel_attributes;
		AssignedChannelAttributes	assigned_channel_attributes;
	} u;
} ChannelAttributes;
typedef	ChannelAttributes *		PChannelAttributes;

class CChannelAttributesList : public CList
{
    DEFINE_CLIST(CChannelAttributesList, PChannelAttributes)
};

/*
 *	These types are used when dealing with MCS tokens.
 *
 *	TokenState
 *		This type specifies which state the token is in at any given time.
 *	GrabbedTokenAttributes
 *		This structure is used to define those attributes that are specific
 *		to grabbed tokens.
 *	InhibitedTokenAttributes
 *		This structure is used to define those attributes that are specific
 *		to inhibited tokens.
 *	GivingTokenAttributes
 *		This structure is used to define those attributes that are specific
 *		to giving tokens.
 *	GivenTokenAttributes
 *		This structure is used to define those attributes that are specific
 *		to given tokens.
 *	TokenAttributes
 *		This structure is used to define the attributes of ANY token.  It
 *		contains a token state, and a union of the above four types.
 *	CTokenAttributesList
 *		This is an S-list of TokenAttributes structures.
 */
typedef	enum
{
	TOKEN_AVAILABLE,
	TOKEN_GRABBED,
	TOKEN_INHIBITED,
	TOKEN_GIVING,
	TOKEN_GIVEN
} TokenState;
typedef	TokenState *			PTokenState;

typedef	struct
{
	TokenID				token_id;
	UserID				grabber;
} GrabbedTokenAttributes;

typedef	struct
{
	TokenID				token_id;
	CUidList           *inhibitors;
} InhibitedTokenAttributes;

typedef	struct
{
	TokenID				token_id;
	UserID				grabber;
	UserID				recipient;
} GivingTokenAttributes;

typedef	struct
{
	TokenID				token_id;
	UserID				recipient;
} GivenTokenAttributes;

typedef	struct
{
	TokenState			token_state;
	union
	{
		GrabbedTokenAttributes		grabbed_token_attributes;
		InhibitedTokenAttributes	inhibited_token_attributes;
		GivingTokenAttributes		giving_token_attributes;
		GivenTokenAttributes		given_token_attributes;
	} u;
} TokenAttributes;
typedef	TokenAttributes *		PTokenAttributes;

class CTokenAttributesList : public CList
{
    DEFINE_CLIST(CTokenAttributesList, PTokenAttributes)
};

/*
 *	The following structure is passed around between CommandTarget
 *	objects representing TokenGive requests and indications.
 */
typedef struct
{
	UserID				uidInitiator;
	TokenID				token_id;
	UserID				receiver_id;
} TokenGiveRecord;
typedef TokenGiveRecord *	PTokenGiveRecord;


/*
 *	These macros define the values used for domain parameters.  The default
 *	numbers are used upon initialization, to provide valid values.  The
 *	minimum and maximum numbers are used during arbitration, to provide a set
 *	of limits that are specific to this implementation.  Note that because
 *	this implementation does not use a table driven approach that requires
 *	up-front allocation of all resources, we do not impose an artificial limit
 *	on resources.  Resources (channels and tokens) will simply be allocated
 *	as-needed until no more can be allocated (or until arbitrated domain
 *	parameters have been reached).
 */
#define	DEFAULT_MAXIMUM_CHANNELS		1024
#define	DEFAULT_MAXIMUM_USERS			1024
#define	DEFAULT_MAXIMUM_TOKENS			1024
#define	DEFAULT_NUMBER_OF_PRIORITIES	3
#define	DEFAULT_NUM_PLUGXPRT_PRIORITIES	1
#define	DEFAULT_MINIMUM_THROUGHPUT		0
#define	DEFAULT_MAXIMUM_DOMAIN_HEIGHT	16
#define	DEFAULT_MAXIMUM_PDU_SIZE		4128
#define	DEFAULT_PROTOCOL_VERSION		2

#define	MINIMUM_MAXIMUM_CHANNELS		1
#define	MINIMUM_MAXIMUM_USERS			1
#define	MINIMUM_MAXIMUM_TOKENS			1
#define	MINIMUM_NUMBER_OF_PRIORITIES	1
#define	MINIMUM_NUM_PLUGXPRT_PRIORITIES	1
#define	MINIMUM_MINIMUM_THROUGHPUT		0
#define	MINIMUM_MAXIMUM_DOMAIN_HEIGHT	1
#define	MINIMUM_MAXIMUM_PDU_SIZE		1056
#define	MINIMUM_PROTOCOL_VERSION		2

#define	MAXIMUM_MAXIMUM_CHANNELS		65535L
#define	MAXIMUM_MAXIMUM_USERS			64535L
#define	MAXIMUM_MAXIMUM_TOKENS			65535L
#define	MAXIMUM_NUMBER_OF_PRIORITIES	4
#define	MAXIMUM_NUM_PLUGXPRT_PRIORITIES	1
#define	MAXIMUM_MINIMUM_THROUGHPUT		0
#define	MAXIMUM_MAXIMUM_DOMAIN_HEIGHT	100 
#define	MAXIMUM_MAXIMUM_PDU_SIZE		(8192 - PROTOCOL_OVERHEAD_X224 - PROTOCOL_OVERHEAD_SECURITY)
#define	MAXIMUM_PROTOCOL_VERSION		2

#define	PROTOCOL_VERSION_BASIC			1
#define	PROTOCOL_VERSION_PACKED			2

/*
 *	This macro is used to determine how many DataPacket objects to allocate.  This class
 *	is the most often created and destroyed during normal CommandTarget
 *	traffic.
 */
#define	ALLOCATE_DATA_PACKET_OBJECTS	128

/*
 *	~CommandTarget ()
 *
 *	Functional Description:
 *		This is a virtual destructor.  It does not actually do anything in this
 *		class.  By declaring it as virtual, we guarantee that all destructors
 *		in derived classes will be executed properly.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	PlumbDomainIndication (
 *					PCommandTarget		originator,
 *					ULong				height_limit)
 *
 *	Functional Description:
 *		This MCS command is used to insure that a cycle has not been created
 *		in an MCS domain.  It is broadcast downward after the creation of
 *		a new MCS connection.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		height_limit (i)
 *			This is the height limit from the originating domain downward.
 *			It is decremented each time the PDU is forwarded down another
 *			level.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ErectDomainRequest (
 *					PCommandTarget		originator,
 *					ULong				height_in_domain,
 *					ULong				throughput_interval)
 *
 *	Functional Description:
 *		This MCS command is used to communicate information upward to the
 *		Top Provider.  That information consists of the height of the current
 *		provider and the throughput enforcement interval.  Only the former is
 *		supported at this time.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		height_in_domain (i)
 *			This is the height of the originator in the domain.
 *		throughput_interval (i)
 *			This is not currently support, and will always be set to 0.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	MergeChannelsRequest (
 *					PCommandTarget			originator,
 *					CChannelAttributesList *merge_channel_list,
 *					CChannelIDList         *purge_channel_list)
 *
 *	Functional Description:
 *		This command represents a channel being merged upward.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		merge_channel_list (i)
 *			This is list of attributes structures, each of which contains the
 *			attributes of one channel being merged upward.
 *		purge_channel_list (i)
 *			This is a list of channels that are to purged from the lower domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	MergeChannelsConfirm (
 *					PCommandTarget			originator,
 *					CChannelAttributesList *merge_channel_list,
 *					CChannelIDList         *purge_channel_list)
 *
 *	Functional Description:
 *		This command represents the response to a previous request for a
 *		channel to be merged upward.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		merge_channel_list (i)
 *			This is list of attributes structures, each of which contains the
 *			attributes of one channel that was successfully merged upward.
 *		purge_channel_list (i)
 *			This is a list of channels that are to purged from the lower domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	PurgeChannelsIndication (
 *					PCommandTarget		originator,
 *					CUidList           *purge_user_list,
 *					CChannelIDList     *purge_channel_list)
 *
 *	Functional Description:
 *		This command represents a channel being purged from a lower domain
 *		during a merge operation.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		purge_user_list (i)
 *			This is a list of user IDs representing users being purged from
 *			the lower domain during a merge operation.
 *		purge_channel_list (i)
 *			This is a list of channel IDs representing channels being purged
 *			from the lower domain during a merge operation.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	MergeTokensRequest (
 *					PCommandTarget			originator,
 *					CTokenAttributesList   *merge_token_list,
 *					CTokenIDList           *purge_token_list)
 *
 *	Functional Description:
 *		This command represents a token being merged upward.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		merge_token_list (i)
 *			This is list of attributes structures, each of which contains the
 *			attributes of one token being merged upward.
 *		purge_token_list (i)
 *			This is a list of tokens that are to purged from the lower domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	MergeTokensConfirm (
 *					PCommandTarget			originator,
 *					CTokenAttributesList   *merge_token_list,
 *					CTokenIDList           *purge_token_list)
 *
 *	Functional Description:
 *		This command represents the response to a previous request for a
 *		token merge.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		merge_token_list (i)
 *			This is list of attributes structures, each of which contains the
 *			attributes of one token being merged upward.
 *		purge_token_list (i)
 *			This is a list of tokens that are to purged from the lower domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	PurgeTokensIndication (
 *					PCommandTarget			originator,
 *					CTokenIDList           *purge_token_list)
 *
 *	Functional Description:
 *		This command represents a token being purged from the lower domain
 *		during a merge operation.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		purge_token_list (i)
 *			This is a list of tokens that are to purged from the lower domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	DisconnectProviderUltimatum (
 *					PCommandTarget		originator,
 *					Reason				reason)
 *
 *	Functional Description:
 *		This command represents an attachment into a domain being destroyed.
 *		This can be either a user attachment or an MCS connection.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		reason (i)
 *			The reason for the diconnect.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	RejectUltimatum (
 *					PCommandTarget		originator,
 *					Diagnostic			diagnostic,
 *					PUChar				octet_string_address,
 *					ULong				octet_string_length)
 *
 *	Functional Description:
 *		This MCS command is used to indicate illegal traffic on an MCS
 *		connection.  The default response to this message is to disconnect
 *		the connection that conveyed it.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		diagnostic (i)
 *			One of the diagnostic codes elaborating on the cause of the problem.
 *		octet_string_address (i)
 *			The address of an optional user data field.  This will usually
 *			contain a copy of the packet that was received in error.
 *		octet_string_length (i)
 *			Length of the above field.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	AttachUserRequest (
 *					PCommandTarget		originator)
 *
 *	Functional Description:
 *		This command represents a user request to attach to a domain.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	AttachUserConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator)
 *
 *	Functional Description:
 *		This command represents the result of a previous request to attach
 *		to a domain.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		result (i)
 *			The result of the attach request.
 *		uidInitiator (i)
 *			If the result was successful, this will contain the unique user
 *			ID to be associated with this user.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	DetachUserRequest (
 *					PCommandTarget		originator,
 *					Reason				reason,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command represents a request to detach from a domain.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		reason (i)
 *			This is the reason for the detachment.
 *		user_id_list (i)
 *			A list of user IDs of users who are detaching from the domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	DetachUserIndication (
 *					PCommandTarget		originator,
 *					Reason				reason,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command represents a notification that a user has detached from
 *		the domain.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		reason (i)
 *			The reason for the detachment.
 *		user_id_list (i)
 *			A list of user IDs of users who are detaching from the domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelJoinRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command represents a request to join a channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			The ID of the user who initiated the request.
 *		channel_id (i)
 *			The ID of the channel to be joined.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelJoinConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					ChannelID			requested_id,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command represents a response to a previous request to join a
 *		channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		result (i)
 *			The result of the join request.
 *		uidInitiator (i)
 *			The ID of the user who initiated the request.
 *		requested_id (i)
 *			This is the ID of the channel that was originally requested (which
 *			may be 0).
 *		channel_id (i)
 *			The ID of the channel being joined.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelLeaveRequest (
 *					PCommandTarget		originator,
 *					CChannelIDList     *channel_id_list)
 *
 *	Functional Description:
 *		This command represents a request to leave a channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		channel_id_list (i)
 *			A list of channel IDs to be left.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelConveneRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator)
 *
 *	Functional Description:
 *		This command represents a request to form a new private channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			This is the initiator of the request.  If the request is
 *			successful, this wil be the channel manager.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelConveneConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command represents a response to a previous request to create a
 *		new private channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		result (i)
 *			This indicates whether or not the request was successful.
 *		uidInitiator (i)
 *			This is the User ID of the user who requested the creation of the
 *			new private channel.
 *		channel_id (i)
 *			The ID of the new private channel (if the request was successful).
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelDisbandRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command represents a request to destroy an existing private
 *		channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			This is the User ID of the user who is trying to destroy the private
 *			channel.  If this is not the same as the channel manager, the
 *			request will be denied.
 *		channel_id (i)
 *			The ID of the channel to be destroyed.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelDisbandIndication (
 *					PCommandTarget		originator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command represents the destruction of an existing private channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		channel_id (i)
 *			The ID of the channel to be destroyed.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelAdmitRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command represents a request to add new user IDs to an existing
 *		private channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			This is the User ID of the user that is trying to expand the list
 *			of authorized users.  If this is not the channel manager, the
 *			request will fail.
 *		channel_id (i)
 *			The ID of the private channel to be affected.
 *		user_id_list (i)
 *			This is a container holding the User IDs to be added to the
 *			authorized user list.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelAdmitIndication (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command represents the expansion of the authorized user list for a
 *		private channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			This identifies the channel manager.
 *		channel_id (i)
 *			The ID of the private channel to be affected.
 *		user_id_list (i)
 *			This is a container holding the User IDs to be added to the
 *			authorized user list.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelExpelRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command represents a request to remove user IDs from an existing
 *		private channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			This is the User ID of the user that is trying to shrink the list
 *			of authorized users.  If this is not the channel manager, the
 *			request will fail.
 *		channel_id (i)
 *			The ID of the private channel to be affected.
 *		user_id_list (i)
 *			This is a container holding the User IDs to be removed from the
 *			authorized user list.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelExpelIndication (
 *					PCommandTarget		originator,
 *					ChannelID			channel_id,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command represents the shrinkage of the authorized user list for a
 *		private channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		channel_id (i)
 *			The ID of the private channel to be affected.
 *		user_id_list (i)
 *			This is a container holding the User IDs to be removed from the
 *			authorized user list.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	SendDataRequest (
 *					PCommandTarget		originator,
 *					UINT				type,
					PDataPacket			data_packet)
 *
 *	Functional Description:
 *		This command represents non-uniform data travelling upward in the
 *		domain.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		type (i)
 *			Normal or uniform send data request
 *		data_packet (i)
 *			This is a pointer to a DataPacket object containing the channel
 *			ID, the User ID of the data sender, segmentation flags, priority of
 *			the data packet and a pointer to the packet to be sent.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	SendDataIndication (
 *					PCommandTarget		originator,
 *					UINT				type,
 *					PDataPacket			data_packet)
 *
 *	Functional Description:
 *		This command represents non-uniform data travelling downward in the
 *		domain.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		type (i)
 *			normal or uniform data indication
 *		data_packet (i)
 *			This is a pointer to a DataPacket object containing the channel
 *			ID, the User ID of the data sender, segmentation flags, priority of
 *			the data packet and a pointer to the packet to be sent.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	UniformSendDataRequest (
 *					PCommandTarget		originator,
 *					PDataPacket			data_packet)
 *
 *	Functional Description:
 *		This command represents uniform data travelling upward in the domain.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		data_packet (i)
 *			This is a pointer to a DataPacket object containing the channel
 *			ID, the User ID of the data sender, segmentation flags, priority of
 *			the data packet and a pointer to the packet to be sent.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGrabRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command represents a request to grab a token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			The ID of the user attempting to grab the token.
 *		token_id (i)
 *			The ID of the token being grabbed.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGrabConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command represents a response to a previous request to grab a
 *		token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		result (i)
 *			The result of the grab operation.
 *		uidInitiator (i)
 *			The ID of the user attempting to grab the token.
 *		token_id (i)
 *			The ID of the token being grabbed.
 *		token_status (i)
 *			The status of the token after processing the request.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenInhibitRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command represents a request to inhibit a token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			The ID of the user attempting to inhibit the token.
 *		token_id (i)
 *			The ID of the token being inhibited.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenInhibitConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command represents a response to a previous request to inhibit a
 *		token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		result (i)
 *			The result of the inhibit operation.
 *		uidInitiator (i)
 *			The ID of the user attempting to inhibit the token.
 *		token_id (i)
 *			The ID of the token being inhibited.
 *		token_status (i)
 *			The status of the token after processing the request.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGiveRequest (
 *					PCommandTarget		originator,
 *					PTokenGiveRecord	pTokenGiveRec)
 *
 *	Functional Description:
 *		This command represents a request to give a token to another user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		pTokenGiveRec (i)
 *			This is the address of a structure containing the following information:
 *			The ID of the user attempting to give away the token.
 *			The ID of the token being given.
 *			The ID of the user that the token is being given to.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGiveIndication (
 *					PCommandTarget		originator,
 *					PTokenGiveRecord	pTokenGiveRec)
 *
 *	Functional Description:
 *		This command represents notification that a user is trying to give a
 *		token to someone else.  It is issued by the Top Provider and propagates
 *		downward to the recipient.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		pTokenGiveRec (i)
 *			This is the address of a structure containing the following information:
 *			The ID of the user attempting to give away the token.
 *			The ID of the token being given.
 *			The ID of the user that the token is being given to.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGiveResponse (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				receiver_id,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command represents a response to an offer to give away a token.
 *		It is issued by the recipient of a give offer, and moves upward to
 *		the Top Provider.  It contains the result of the give request.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		result (i)
 *			This parameter indicates whether or not the token was accepted.
 *			RESULT_SUCCESSFUL means that it was.
 *		receiver_id (i)
 *			The ID of the user that the token is being given to.
 *		token_id (i)
 *			The ID of the token being given.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGiveConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command represents a response to a previous call to
 *		TokenGiveRequest.  It flows downward to the original giver letting it
 *		know whether or not the token was accepted.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		result (i)
 *			This parameter indicates whether or not the token was accepted.
 *			RESULT_SUCCESSFUL means that it was.
 *		uidInitiator (i)
 *			The ID of the user attempting to give away a token.
 *		token_id (i)
 *			The ID of the token being given.
 *		token_status (i)
 *			The status of the token as a result of the give operation.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenPleaseRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command represents a request to receive a token that is already
 *		owned by one or more other users.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			The ID of the user that wishes to own the token.
 *		token_id (i)
 *			The ID of the token that the user wishes to own.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenPleaseIndication (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command represents a request by another user to own the token.
 *		This is issued by the Top Provider and flows downward to all current
 *		owners of the specified token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			The ID of the user that wishes to own the token.
 *		token_id (i)
 *			The ID of the token that the user wishes to own.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenReleaseRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command represents a request to release a token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			The ID of the user attempting to release the token.
 *		token_id (i)
 *			The ID of the token being released.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenReleaseIndication (
 *					PCommandTarget		originator,
 *					Reason				reason,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command represents an indication that a user has lost ownership
 *		of a token during a merge operation.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		reason (i)
 *			This is the reason that the user's ownership of the token is
 *			being taken away.
 *		token_id (i)
 *			The ID of the token being taken away.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenReleaseConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command represents a response to a previous request to release a
 *		token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		result (i)
 *			The result of the release operation.
 *		uidInitiator (i)
 *			The ID of the user attempting to release the token.
 *		token_id (i)
 *			The ID of the token being released.
 *		token_status (i)
 *			The status of the token after processing the request.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenTestRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command represents a request to test a token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			The ID of the user testing the token.
 *		token_id (i)
 *			The ID of the token being tested.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenTestConfirm (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command represents a response to a previous request to test a
 *		token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			The ID of the user testing the token.
 *		token_id (i)
 *			The ID of the token being tested.
 *		token_status (i)
 *			The status of the token after processing the request.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	MergeDomainIndication (
 *					PCommandTarget		originator,
 *					MergeStatus			merge_status)
 *
 *	Functional Description:
 *		This command indicates that the local provider is either entering or
 *		leaving a domain merge state.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		merge_status (i)
 *			This indicates whether the provider is entering or leaving the merge
 *			state.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		When issued by a domain, it means that no upward traffic should be
 *		sent to the domain until, the merge state is complete.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\cntlist.h ===
#ifndef _CONTAINED_LIST_H_
#define _CONTAINED_LIST_H_


#define CLIST_DEFAULT_MAX_ITEMS   4
#define CLIST_END_OF_ARRAY_MARK   ((UINT) -1)


class CList
{
public:

    CList(void);
    CList(ULONG cMaxItems);
    CList(ULONG cMaxItems, ULONG cSubItems);
    CList(ULONG cMaxItems, ULONG cSubItems, BOOL fQueue);

    CList(CList *pSrc);

    ~CList(void);

    BOOL Append(LPVOID pData);
    BOOL Prepend(LPVOID pData);

    BOOL Find(LPVOID pData);
    BOOL Remove(LPVOID pData);

    LPVOID Get(void);

    LPVOID Iterate(void);

    void Reset(void) { m_nCurrOffset = CLIST_END_OF_ARRAY_MARK; };
    void Clear(void) { m_cEntries = 0; m_nHeadOffset = 0; m_nCurrOffset = CLIST_END_OF_ARRAY_MARK; };

    UINT GetCount(void) { return m_cEntries; };
    BOOL IsEmpty(void) { return (m_cEntries == 0); };

    LPVOID PeekHead(void) { return (0 != m_cEntries) ? m_aEntries[m_nHeadOffset] : NULL; }

protected:

    void CalcKeyArray(void);

protected:

    ULONG      m_cEntries;
    ULONG      m_cMaxEntries;
    ULONG      m_nHeadOffset;
    ULONG      m_nCurrOffset;
    ULONG      m_cSubItems;    // 1 for CList, 2 for CList2
    BOOL       m_fQueue;       // TRUE for CQueue, FALSE for CList

    LPVOID     *m_aEntries;
    UINT_PTR   *m_aKeys;       // for CList2

private:

    BOOL Expand(void);
    BOOL Init(ULONG cSubItems);
};


#define DEFINE_CLIST(_NewClass_,_PtrItemType_) \
            public: \
            _NewClass_(void) : CList() { C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(ULONG cMaxItems) : CList(cMaxItems) { C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CList((CList *) pSrc) { C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CList((CList *) &Src) { C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            BOOL Append(_PtrItemType_ pData) { return CList::Append((LPVOID) pData); } \
            BOOL Prepend(_PtrItemType_ pData) { return CList::Prepend((LPVOID) pData); } \
            BOOL Remove(_PtrItemType_ pData) { return CList::Remove((LPVOID) pData); } \
            BOOL Find(_PtrItemType_ pData) { return CList::Find((LPVOID) pData); } \
            _PtrItemType_ Get(void) { return (_PtrItemType_) CList::Get(); } \
            _PtrItemType_ PeekHead(void) { return (_PtrItemType_) CList::PeekHead(); } \
            _PtrItemType_ Iterate(void) { return (_PtrItemType_) CList::Iterate(); }

#define DEFINE_CLIST_(_NewClass_,_IntItemType_) \
            public: \
            _NewClass_(void) : CList() { C_ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(ULONG cMaxItems) : CList(cMaxItems) { C_ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CList((CList *) pSrc) { C_ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CList((CList *) &Src) { C_ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            BOOL Append(_IntItemType_ nData) { return CList::Append((LPVOID) nData); } \
            BOOL Prepend(_IntItemType_ nData) { return CList::Prepend((LPVOID) nData); } \
            BOOL Remove(_IntItemType_ nData) { return CList::Remove((LPVOID) nData); } \
            BOOL Find(_IntItemType_ nData) { return CList::Find((LPVOID) nData); } \
            _IntItemType_ Get(void) { return (_IntItemType_) (UINT_PTR) CList::Get(); } \
            _IntItemType_ PeekHead(void) { return (_IntItemType_) (UINT_PTR) CList::PeekHead(); } \
            _IntItemType_ Iterate(void) { return (_IntItemType_) (UINT_PTR) CList::Iterate(); }


class CList2 : public CList
{
public:

    CList2(ULONG cMaxItems = CLIST_DEFAULT_MAX_ITEMS) : CList(cMaxItems, 2) { }
    CList2(ULONG cMaxItems, BOOL fQueue)              : CList(cMaxItems, 2, fQueue) { }

    CList2(CList2 *pSrc);

    BOOL Append(UINT_PTR nKey, LPVOID pData);
    BOOL Prepend(UINT_PTR nKey, LPVOID pData);

    // BOOL Remove(LPVOID pData); // inherited from CList
    LPVOID Remove(UINT_PTR nKey);

    // BOOL Find(LPVOID pData); // inherited from CList
    LPVOID Find(UINT_PTR nKey);

    // LPVOID Get(void); // inheirted from CList
    LPVOID Get(UINT_PTR *pnKey);

    // LPVOID Iterate(void); // inherited from CList
    LPVOID Iterate(UINT_PTR *pnKey);

    LPVOID PeekHead(UINT_PTR *pnKey);
};


#define DEFINE_CLIST2(_NewClass_,_PtrItemType_,_IntKeyType_) \
            public: \
            _NewClass_(void) : CList2() { C_ASSERT(sizeof(_IntKeyType_) <= sizeof(UINT_PTR)); C_ASSERT(sizeof(_PtrItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(ULONG cMaxItems) : CList2(cMaxItems) { C_ASSERT(sizeof(_IntKeyType_) <= sizeof(UINT_PTR)); C_ASSERT(sizeof(_PtrItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CList2((CList2 *) pSrc) { C_ASSERT(sizeof(_IntKeyType_) <= sizeof(UINT_PTR)); C_ASSERT(sizeof(_PtrItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CList2((CList2 *) &Src) { C_ASSERT(sizeof(_IntKeyType_) <= sizeof(UINT_PTR)); C_ASSERT(sizeof(_PtrItemType_) <= sizeof(LPVOID)); } \
            BOOL Append(_IntKeyType_ nKey, _PtrItemType_ pData) { return CList2::Append((UINT_PTR) nKey, (LPVOID) pData); } \
            BOOL Prepend(_IntKeyType_ nKey, _PtrItemType_ pData) { return CList2::Prepend((UINT_PTR) nKey, (LPVOID) pData); } \
            BOOL          Remove(_PtrItemType_ pData) { return CList::Remove((LPVOID) pData); } \
            _PtrItemType_ Remove(_IntKeyType_ nKey) { return (_PtrItemType_) (UINT_PTR) CList2::Remove((UINT_PTR) nKey); } \
            BOOL          Find(_PtrItemType_ pData) { return CList::Find((LPVOID) pData); } \
            _PtrItemType_ Find(_IntKeyType_ nKey) { return (_PtrItemType_) (UINT_PTR) CList2::Find((UINT_PTR) nKey); } \
            _PtrItemType_ Get(void) { return (_PtrItemType_) (UINT_PTR) CList::Get(); } \
            _PtrItemType_ Get(_IntKeyType_ *pnKey) { UINT_PTR n; _PtrItemType_ p = (_PtrItemType_) (UINT_PTR) CList2::Get(&n); *pnKey = (_IntKeyType_) n; return p; } \
            _PtrItemType_ PeekHead(void) { return (_PtrItemType_) (UINT_PTR) CList::PeekHead(); } \
            _PtrItemType_ PeekHead(_IntKeyType_ *pnKey) { UINT_PTR n; _PtrItemType_ p = (_PtrItemType_) (UINT_PTR) CList2::PeekHead(&n); *pnKey = (_IntKeyType_) n; return p; } \
            _PtrItemType_ Iterate(void) { return (_PtrItemType_) (UINT_PTR) CList::Iterate(); } \
            _PtrItemType_ Iterate(_IntKeyType_ *pnKey) { UINT_PTR n; _PtrItemType_ p = (_PtrItemType_) (UINT_PTR) CList2::Iterate(&n); *pnKey = (_IntKeyType_) n; return p; }

#define DEFINE_CLIST2_(_NewClass_,_PtrItemType_,_ShortKeyType_) \
            DEFINE_CLIST2(_NewClass_,_PtrItemType_,_ShortKeyType_)

#define DEFINE_CLIST2__(_NewClass_,_IntKeyType_) \
            public: \
            _NewClass_(void) : CList2() { C_ASSERT(sizeof(_IntKeyType_) <= sizeof(UINT_PTR)); C_ASSERT(sizeof(_IntKeyType_) <= sizeof(LPVOID)); } \
            _NewClass_(ULONG cMaxItems) : CList2(cMaxItems) { C_ASSERT(sizeof(_IntKeyType_) <= sizeof(UINT_PTR)); C_ASSERT(sizeof(_IntKeyType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CList2((CList2 *) pSrc) { C_ASSERT(sizeof(_IntKeyType_) <= sizeof(UINT_PTR)); C_ASSERT(sizeof(_IntKeyType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CList2((CList2 *) &Src) { C_ASSERT(sizeof(_IntKeyType_) <= sizeof(UINT_PTR)); C_ASSERT(sizeof(_IntKeyType_) <= sizeof(LPVOID)); } \
            BOOL Append(_IntKeyType_ nKey, _IntKeyType_ nData) { return CList2::Append((UINT_PTR) nKey, (LPVOID) nData); } \
            BOOL Prepend(_IntKeyType_ nKey, _IntKeyType_ nData) { return CList2::Prepend((UINT_PTR) nKey, (LPVOID) nData); } \
            _IntKeyType_ Remove(_IntKeyType_ nKey) { return (_IntKeyType_) (UINT_PTR) CList2::Remove((UINT_PTR) nKey); } \
            _IntKeyType_ Find(_IntKeyType_ nKey) { return (_IntKeyType_) (UINT_PTR) CList2::Find((UINT_PTR) nKey); } \
            _IntKeyType_ Get(void) { return (_IntKeyType_) (UINT_PTR) CList::Get(); } \
            _IntKeyType_ Get(_IntKeyType_ *pnKey) { UINT_PTR n; _IntKeyType_ p = (_IntKeyType_) (UINT_PTR) CList2::Get(&n); *pnKey = (_IntKeyType_) n; return p; } \
            _IntKeyType_ PeekHead(void) { return (_IntKeyType_) (UINT_PTR) CList::PeekHead(); } \
            _IntKeyType_ PeekHead(_IntKeyType_ *pnKey) { UINT_PTR n; _IntKeyType_ p = (_IntKeyType_) (UINT_PTR) CList2::PeekHead(&n); *pnKey = (_IntKeyType_) n; return p; } \
            _IntKeyType_ Iterate(void) { return (_IntKeyType_) (UINT_PTR) CList::Iterate(); } \
            _IntKeyType_ Iterate(_IntKeyType_ *pnKey) { UINT_PTR n; _IntKeyType_ p = (_IntKeyType_) (UINT_PTR) CList2::Iterate(&n); *pnKey = (_IntKeyType_) n; return p; }

#define DEFINE_CLIST2___(_NewClass_,_ShortKeyType_) \
            DEFINE_CLIST2__(_NewClass_,_ShortKeyType_)

class CQueue : public CList
{
public:

    CQueue(ULONG cMaxItems = CLIST_DEFAULT_MAX_ITEMS) : CList(cMaxItems, 1, TRUE) { };
    CQueue(CQueue *pSrc) : CList((CList *) pSrc) { };
};


#define DEFINE_CQUEUE(_NewClass_,_PtrItemType_) \
            public: \
            _NewClass_(void) : CQueue() { C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(ULONG cMaxItems) : CQueue(cMaxItems) { C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CQueue((CQueue *) pSrc) { C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CQueue((CQueue *) &Src) { C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            BOOL Append(_PtrItemType_ pData) { return CList::Append((LPVOID) pData); } \
            BOOL Prepend(_PtrItemType_ pData) { return CList::Prepend((LPVOID) pData); } \
            BOOL Remove(_PtrItemType_ pData) { return CList::Remove((LPVOID) pData); } \
            BOOL Find(_PtrItemType_ pData) { return CList::Find((LPVOID) pData); } \
            _PtrItemType_ Get(void) { return (_PtrItemType_) CList::Get(); } \
            _PtrItemType_ PeekHead(void) { return (_PtrItemType_) CList::PeekHead(); } \
            _PtrItemType_ Iterate(void) { return (_PtrItemType_) CList::Iterate(); }

#define DEFINE_CQUEUE_(_NewClass_,_IntItemType_) \
            public: \
            _NewClass_(void) : CQueue() { C_ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(ULONG cMaxItems) : CQueue(cMaxItems) { C_ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CQueue((CQueue *) pSrc) { C_ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CQueue((CQueue *) &Src) { C_ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            BOOL Append(_IntItemType_ nData) { return CList::Append((LPVOID) nData); } \
            BOOL Prepend(_IntItemType_ nData) { return CList::Prepend((LPVOID) nData); } \
            BOOL Remove(_IntItemType_ nData) { return CList::Remove((LPVOID) nData); } \
            BOOL Find(_IntItemType_ nData) { return CList::Find((LPVOID) nData); } \
            _IntItemType_ Get(void) { return (_IntItemType_) (UINT_PTR) CList::Get(); } \
            _IntItemType_ PeekHead(void) { return (_IntItemType_) (UINT_PTR) CList::PeekHead(); } \
            _IntItemType_ Iterate(void) { return (_IntItemType_) (UINT_PTR) CList::Iterate(); }



class CQueue2 : public CList2
{
public:

    CQueue2(ULONG cMaxItems = CLIST_DEFAULT_MAX_ITEMS) : CList2(cMaxItems, TRUE) { };
    CQueue2(CQueue2 *pSrc) : CList2((CList2 *) pSrc) { };
};


#define DEFINE_CQUEUE2(_NewClass_,_PtrItemType_,_IntKeyType_) \
            public: \
            _NewClass_(void) : CQueue2() { C_ASSERT(sizeof(_IntKeyType_) <= sizeof(UINT_PTR)); C_ASSERT(sizeof(_PtrItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(ULONG cMaxItems) : CQueue2(cMaxItems) { C_ASSERT(sizeof(_IntKeyType_) <= sizeof(UINT_PTR)); C_ASSERT(sizeof(_PtrItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CQueue2((CQueue2 *) pSrc) { C_ASSERT(sizeof(_IntKeyType_) <= sizeof(UINT_PTR)); C_ASSERT(sizeof(_PtrItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CQueue2((CQueue2 *) &Src) { C_ASSERT(sizeof(_IntKeyType_) <= sizeof(UINT_PTR)); C_ASSERT(sizeof(_PtrItemType_) <= sizeof(LPVOID)); } \
            BOOL Append(_IntKeyType_ nKey, _PtrItemType_ pData) { return CList2::Append((UINT_PTR) nKey, (LPVOID) pData); } \
            BOOL Prepend(_IntKeyType_ nKey, _PtrItemType_ pData) { return CList2::Prepend((UINT_PTR) nKey, (LPVOID) pData); } \
            BOOL          Remove(_PtrItemType_ pData) { return CList::Remove((LPVOID) pData); } \
            _PtrItemType_ Remove(_IntKeyType_ nKey) { return (_PtrItemType_) (UINT_PTR) CList2::Remove((UINT_PTR) nKey); } \
            BOOL          Find(_PtrItemType_ pData) { return CList::Find((LPVOID) pData); } \
            _PtrItemType_ Find(_IntKeyType_ nKey) { return (_PtrItemType_) (UINT_PTR) CList2::Find((UINT_PTR) nKey); } \
            _PtrItemType_ Get(void) { return (_PtrItemType_) (UINT_PTR) CList::Get(); } \
            _PtrItemType_ Get(_IntKeyType_ *pnKey) { UINT_PTR n; _PtrItemType_ p = (_PtrItemType_) (UINT_PTR) CList2::Get(&n); *pnKey = (_IntKeyType_) n; return p; } \
            _PtrItemType_ PeekHead(void) { return (_PtrItemType_) (UINT_PTR) CList::PeekHead(); } \
            _PtrItemType_ PeekHead(_IntKeyType_ *pnKey) { UINT_PTR n; _PtrItemType_ p = (_PtrItemType_) (UINT_PTR) CList2::PeekHead(&n); *pnKey = (_IntKeyType_) n; return p; } \
            _PtrItemType_ Iterate(void) { return (_PtrItemType_) (UINT_PTR) CList::Iterate(); } \
            _PtrItemType_ Iterate(_IntKeyType_ *pnKey) { UINT_PTR n; _PtrItemType_ p = (_PtrItemType_) (UINT_PTR) CList2::Iterate(&n); *pnKey = (_IntKeyType_) n; return p; }

#define DEFINE_CQUEUE2_(_NewClass_,_PtrItemType_,_ShortKeyType_) \
            DEFINE_CQUEUE2(_NewClass_,_PtrItemType_,_ShortKeyType_)

// both key and item are of the same type
#define DEFINE_CQUEUE2__(_NewClass_,_IntKeyType_) \
            public: \
            _NewClass_(void) : CQueue2() { C_ASSERT(sizeof(_IntKeyType_) == sizeof(UINT_PTR)); C_ASSERT(sizeof(_IntKeyType_) == sizeof(LPVOID)); } \
            _NewClass_(ULONG cMaxItems) : CQueue2(cMaxItems) { C_ASSERT(sizeof(_IntKeyType_) == sizeof(UINT_PTR)); C_ASSERT(sizeof(_IntKeyType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CQueue2((CQueue2 *) pSrc) { C_ASSERT(sizeof(_IntKeyType_) == sizeof(UINT_PTR)); C_ASSERT(sizeof(_IntKeyType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CQueue2((CQueue2 *) &Src) { C_ASSERT(sizeof(_IntKeyType_) == sizeof(UINT_PTR)); C_ASSERT(sizeof(_IntKeyType_) == sizeof(LPVOID)); } \
            BOOL Append(_IntKeyType_ nKey, _IntKeyType_ nData) { return CList2::Append((UINT_PTR) nKey, (LPVOID) nData); } \
            BOOL Prepend(_IntKeyType_ nKey, _IntKeyType_ nData) { return CList2::Prepend((UINT_PTR) nKey, (LPVOID) nData); } \
            _IntKeyType_ Remove(_IntKeyType_ nKey) { return (_IntKeyType_) CList2::Remove((UINT_PTR) nKey); } \
            _IntKeyType_ Find(_IntKeyType_ nKey) { return (_IntKeyType_) CList2::Find((UINT_PTR) nKey); } \
            _IntKeyType_ Get(void) { return (_IntKeyType_) CList::Get(); } \
            _IntKeyType_ Get(_IntKeyType_ *pnKey) { return (_IntKeyType_) CList2::Get((UINT_PTR *) pnKey); } \
            _IntKeyType_ PeekHead(void) { return (_IntKeyType_) CList::PeekHead(); } \
            _IntKeyType_ PeekHead(_IntKeyType_ *pnKey) { return (_IntKeyType_) CList2::PeekHead((UINT_PTR *) pnKey); } \
            _IntKeyType_ Iterate(void) { return (_IntKeyType_) CList::Iterate(); } \
            _IntKeyType_ Iterate(_IntKeyType_ *pnKey) { return (_IntKeyType_) CList2::Iterate((UINT_PTR *) pnKey); }


#define HASHED_LIST_DEFAULT_BUCKETS             16

#ifdef ENABLE_HASHED_LIST2

class CHashedList2
{
public:

    CHashedList2(ULONG cBuckets = HASHED_LIST_DEFAULT_BUCKETS, ULONG cInitItemsPerBucket = CLIST_DEFAULT_MAX_ITEMS);
    CHashedList2(CHashedList2 *pSrc);
    ~CHashedList2(void);

    BOOL Insert(UINT nKey, LPVOID pData);

    LPVOID Remove(UINT nKey);
    LPVOID Find(UINT nKey);

    LPVOID Get(void);
    LPVOID Get(UINT *pnKey);

    LPVOID Iterate(UINT *pnKey);
    LPVOID Iterate(void) { UINT n; return Iterate(&n); }

    void Reset(void);
    void Clear(void);

    ULONG GetCount(void) { return m_cEntries; };
    BOOL IsEmpty(void) { return (m_cEntries == 0); };

private:

    ULONG GetHashValue(UINT nKey);

    ULONG       m_cBuckets;
    ULONG       m_cInitItemsPerBucket;
    CList2    **m_aBuckets;
    ULONG       m_cEntries;
    ULONG       m_nCurrBucket;
};

#else // ! ENABLE_HASHED_LIST2

class CHashedList2 : public CList2
{
public:

    CHashedList2(ULONG cBuckets = HASHED_LIST_DEFAULT_BUCKETS, ULONG cInitItemsPerBucket = CLIST_DEFAULT_MAX_ITEMS)
                                     : CList2(cInitItemsPerBucket) { }
    CHashedList2(CHashedList2 *pSrc) : CList2((CList2 *) pSrc) { }

    BOOL Insert(UINT_PTR nKey, LPVOID pData) { return CList2::Append(nKey, pData); }

    LPVOID Get(void) { return CList::Get(); }
    LPVOID Get(UINT_PTR *pnKey) { return CList2::Get(pnKey); }

    LPVOID Iterate(void) { return CList::Iterate(); }
    LPVOID Iterate(UINT_PTR *pnKey) { return CList2::Iterate(pnKey); }
};

#endif // ENABLE_HASHED_LIST2

#define DEFINE_HLIST2(_NewClass_,_PtrItemType_,_IntKeyType_) \
            public: \
            _NewClass_(ULONG cBuckets = HASHED_LIST_DEFAULT_BUCKETS, ULONG cInitItemsPerBucket = CLIST_DEFAULT_MAX_ITEMS) \
                : CHashedList2(cBuckets, cInitItemsPerBucket) { C_ASSERT(sizeof(_IntKeyType_) == sizeof(UINT)); C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CHashedList2((CHashedList2 *) pSrc) { C_ASSERT(sizeof(_IntKeyType_) == sizeof(UINT)); C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CHashedList2((CHashedList2 *) &Src) { C_ASSERT(sizeof(_IntKeyType_) == sizeof(UINT)); C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            BOOL Insert(_IntKeyType_ nKey, _PtrItemType_ pData) { return CHashedList2::Insert((UINT) nKey, (LPVOID) pData); } \
            _PtrItemType_ Remove(_IntKeyType_ nKey) { return (_PtrItemType_) CHashedList2::Remove((UINT) nKey); } \
            _PtrItemType_ Find(_IntKeyType_ nKey) { return (_PtrItemType_) CHashedList2::Find((UINT) nKey); } \
            _PtrItemType_ Get(_IntKeyType_ *pnKey) { return (_PtrItemType_) CHashedList2::Get((UINT *) pnKey); } \
            _PtrItemType_ Iterate(void) { return (_PtrItemType_) CHashedList2::Iterate(); } \
            _PtrItemType_ Iterate(_IntKeyType_ *pnKey) { return (_PtrItemType_) CHashedList2::Iterate((UINT *) pnKey); }

#define DEFINE_HLIST2_(_NewClass_,_PtrItemType_,_ShortKeyType_) \
            public: \
            _NewClass_(ULONG cBuckets = HASHED_LIST_DEFAULT_BUCKETS, ULONG cInitItemsPerBucket = CLIST_DEFAULT_MAX_ITEMS) \
                : CHashedList2(cBuckets, cInitItemsPerBucket) { C_ASSERT(sizeof(_ShortKeyType_) < sizeof(UINT_PTR)); C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CHashedList2((CHashedList2 *) pSrc) { C_ASSERT(sizeof(_ShortKeyType_) < sizeof(UINT_PTR)); C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CHashedList2((CHashedList2 *) &Src) { C_ASSERT(sizeof(_ShortKeyType_) < sizeof(UINT_PTR)); C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            BOOL Insert(_ShortKeyType_ nKey, _PtrItemType_ pData) { return CHashedList2::Insert((UINT_PTR) nKey, (LPVOID) pData); } \
            _PtrItemType_ Remove(_ShortKeyType_ nKey) { return (_PtrItemType_) CHashedList2::Remove((UINT_PTR) nKey); } \
            _PtrItemType_ Find(_ShortKeyType_ nKey) { return (_PtrItemType_) CHashedList2::Find((UINT_PTR) nKey); } \
            _PtrItemType_ Get(_ShortKeyType_ *pnKey) { UINT_PTR n; _PtrItemType_ p = (_PtrItemType_) CHashedList2::Get(&n); *pnKey = (_ShortKeyType_) n; return p; } \
            _PtrItemType_ Iterate(void) { return (_PtrItemType_) CHashedList2::Iterate(); } \
            _PtrItemType_ Iterate(_ShortKeyType_ *pnKey) { UINT_PTR n; _PtrItemType_ p = (_PtrItemType_) CHashedList2::Iterate(&n); *pnKey = (_ShortKeyType_) n; return p; }




typedef LPVOID          BOOL_PTR;
#define TRUE_PTR        ((LPVOID) (UINT_PTR)  1)
#define FALSE_PTR       ((LPVOID) (UINT_PTR) -1)

#define LPVOID_NULL     ((LPVOID) (UINT_PTR) -1)


#endif // _CONTAINED_LIST_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\conf.h ===
/*
 *	conf.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the CConf class.  This class
 *		is where most of the inteligence within GCC lies.  The class
 *		manages the GCC databases and routes the messages and PDUs.
 *
 *		CConf objects represent the true heart of GCC.  Each CConf
 *		object represents one logical conference within a GCC provider.  This
 *		class encapsulates the conference information base which is the focal
 *		point for all GCC traffic.  This information base consists of several
 *		Rogue Wave containers, including:
 *		-	a dictionary of enrolled applications (indexed by application SAP
 *			handles).
 *		-	a list of application roster managers.
 *		-	a list of downward MCS connections.
 *		-	a list of outstanding sequence numbers (used during conference
 *			establishment).
 *		-	a list of outstanding join requests.
 *
 *		In order to simplify the CConf class as much as possible, there are
 *		some things that CConf objects do not worry about.  First and
 *		foremost is Conference and Application Roster management.  This is
 *		handled by two separate classes.  Next is the Application Registry.
 *		CConf objects don't maintain the Application Registry information
 *		base.  CConf objects also do not worry about memory management.
 *		They merely pass Packet objects around, which contain the user data
 *		being handled.  A CConf object has absolutely no responsibility
 *		for protocol data associated with an enrolled application. Below is
 *		more detail about what a conference is responsible for.
 *
 *		When a CConf object is first created, its information base is
 *		empty.  It has no enrolled applications, it has not established any MCS
 *		connections and it has no user attachment to MCS.  There is a period of
 *		time that will be referred to as the Conference Establishment Process
 *		where the CConf object is progressing through the steps defined by
 *		the T.124 specification to join or create a conference.  This process
 *		varies depending on the request that initiated the creation of the
 *		conference.  A CConf Object must know if it is a Top Provider.
 *		Many of the establishment procedures and normal operating procedures
 *		vary depending on this.  A CConf object learns of its type through
 *		the initial requests that are made to it.  For example,  if a
 *		CConf receives a ConferenceCreateRequest where the conference is
 *		to be created locally it knows it is the Top Provider.
 *
 *		The establishment process involves three main steps that all nodes go
 *		through when creating a new conference.  The first is establishing the
 *		MCS connection either through a ConnectProviderRequest or a
 *		ConnectProviderResponse call  (note that this step is skipped when
 *		creating a local conference).  If this step is successful, the
 *		CConf object will create an MCSUser object which progresses through
 *		a number of its own internal steps which include creating an MCS User
 *		Attachment and joining the appropriate channels (which are handled by
 *		the MCSUser object). Finally, when the above two steps have successfully
 *		completed, the conference creates an Application Registry and the
 *		CConfRosterMgr objects and informs the Controller that the
 *		conference is established.  A conference cannot respond to any request
 *		during this establishment process.  For instance, a conference will not
 *		show up in a Conference Query descriptor list during the establishment
 *		phase.
 *
 *		A note about the creation of the CConfRosterMgr objects.
 *		A CConf object that is not the Top Provider will instantiate both
 *		a Local and a Global CConfRosterMgr while the Top Provider
 *		only maintains a Global Conference Roster Manager.  A Local manager
 *		maintains a Conference Roster which holds the local nodes conference
 *		record and the conference records for all nodes below it in the
 *		connection hierarchy.  A Global manager maintains a Conference Roster
 *		which includes the conference records for every node that has announced
 *		its presence with the conference.
 *
 *		After the above establishment process is complete the Owner Object is
 *		notified through an owner callback that the conference is ready for
 *		action.  When the node controller receives a
 *		GCC_PERMIT_TO_ANNOUNCE_PRESENCE indication it must respond with a call
 *		to GCCAnnouncePresenceRequest().  This is when the node controller
 *		passes its conference record (which contains all the pertinent
 *		information about the node) to the newly created conference.  This
 *		request travels through the CControlSAP directly to the conference
 *		through a GCCCommandTarget call.  Remember that the CConf class
 *		inherits from the GCCCommandTarget class.  Whenever a call is made
 *		directly to a CConf object from either a CControlSAP or an CAppSap
 *		object, it is made through a command target call.
 *
 *		When an application receives a GCC_PERMIT_TO_ENROLL_INDICATION it must
 *		respond by calling AppEnrollRequest() to inform the
 *		CConf object whether or not it wants to enroll with the conference.
 *		When an application enroll request is received by a CConf
 *		object a number of things happen, some of which depend on whether the
 *		CConf object is a Top Provider or a subordinate node.  First the
 *		CConf determines if the application is enrolling.  If it isn't,  a
 *		GCC_APPLICATION_ENROLL_CONFIRM is sent to the application that made the
 *		request and no further action is taken.  If the application is
 *		enrolling, the CConf object first registers itself with the CAppSap
 *		making the request.  This allows future application requests to travel
 *		directly to the CConf object through command target calls.  The
 *		CConf then establishes the Application Roster Manager
 *		(if necessary) for this particular application.
 *
 *		After the above establishment and enrollment process is completed a
 *		CConf object sits idle waiting to service requests or process
 *		incoming PDUs.  These include RosterUpdateIndications as well as
 *		CRegistry requests.
 *
 *		A CConf object can be deleted in a number of different ways.  If a
 *		resource error occurs, a conference can Terminate itself by sending an
 *		error TERMINATE indication to its owner through an owner callback.
 *		The node controller can terminate a conference object by calling
 *		GCCConferenceDisconnectRequest() or GCCConferenceTerminateRequest().  A
 *		CConf object can also be terminated if it loses its parent
 *		connection or if it is set up to automatically terminate after all its
 *		subordinate nodes disconnect.  These types of Terminates are initiated
 *		through owner callbacks to the Owner Object.
 *
 *	Portable:
 *		Yes
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */
#ifndef	_CONFERENCE_
#define	_CONFERENCE_

#include "arostmgr.h"
#include "sap.h"
#include "pktcoder.h"
#include "mcsdllif.h"
#include "password.h"
#include "netaddr.h"
#include "privlist.h"
#include "crostmgr.h"
#include "registry.h"
#include "appsap.h"
#include "csap.h"

//	Message bases
#define		USER_ATTACHMENT_MESSAGE_BASE	100
#define		APP_ROSTER_MGR_MESSAGE_BASE		200
#define		CONF_ROSTER_MGR_MESSAGE_BASE	300


enum
{
    CONF_FLUSH_ROSTER_DATA      = CONFMSG_BASE + 1,
};


typedef struct
{
	GCCConfID		conference_id;
	GCCReason		reason;
}
    CONF_TERMINATE_INFO;


typedef struct
{
	ConnectionHandle	connection_handle;
	TagNumber			invite_tag;
	CUserDataListContainer *user_data_list;
}
    INVITE_REQ_INFO;


/*	This structure is used to hold all of an APEs enrollment information.
**	Every APE enrolled with a conference will have a single one of these
**	info structures defined for it.
*/
//
// LONCHANC: We should merge the following to another structure or class
// because it has 2 dwords and we need to allocate memory for it.
//
typedef struct
{
	CAppSap             *pAppSap;
	CSessKeyContainer	*session_key;
}
    ENROLLED_APE_INFO;

/*
**	Lists/Dictionaries used by the CConf Object
*/

//	This list is used to keep track of the outstanding join responses
class CJoinRespNamePresentConnHdlList2 : public CList2
{
    // use TRUE_PTR and FALSE_PTR
    DEFINE_CLIST2_(CJoinRespNamePresentConnHdlList2, BOOL_PTR, ConnectionHandle)
};

//	This list is used to keep track of the enrolled APEs
class CEnrolledApeEidList2 : public CList2
{
    DEFINE_CLIST2_(CEnrolledApeEidList2, ENROLLED_APE_INFO*, GCCEntityID)
};

//	This list is keeps up with the child node connection handles
class CConnHandleList : public CList
{
    DEFINE_CLIST_(CConnHandleList, ConnectionHandle)
};

//	This list is used to match outstanding user IDs
typedef	TagNumber	        UserIDTagNumber; // unsigned long
class CConnHdlTagNumberList2 : public CList2
{
    DEFINE_CLIST2(CConnHdlTagNumberList2, ConnectionHandle, UserIDTagNumber)
};

//	This list is used to hold all the outstanding invite request
class CInviteRequestList : public CList
{
    DEFINE_CLIST(CInviteRequestList, INVITE_REQ_INFO*)
};

//	This list is used to hold all the outstanding ejects
class CEjectedNodeConfirmList : public CList
{
    DEFINE_CLIST_(CEjectedNodeConfirmList, GCCNodeID)
};

//	This list is a queue of outstanding conductor token test
class CConductorTestList : public CList
{
    DEFINE_CLIST(CConductorTestList, CBaseSap*)
};

// this list is a queue of outstanding "add" request
class CNetAddrTagNumberList2 : public CList2
{
    DEFINE_CLIST2(CNetAddrTagNumberList2, CNetAddrListContainer*, TagNumber)
};

class CTagNumberTagNumberList2 : public CList2
{
    DEFINE_CLIST2__(CTagNumberTagNumberList2, TagNumber)
};

// this list holds the NetMeeting version numbers of all nodes in the conference
class CNodeVersionList2 : public CList2
{
	DEFINE_CLIST2_(CNodeVersionList2, DWORD_PTR, GCCNodeID)
};


// Conference specification parameters
typedef struct
{
	BOOL						fClearPassword;
	BOOL						fConfLocked;
	BOOL						fConfListed;
	BOOL						fConfConductable;
	GCCTerminationMethod		eTerminationMethod;
	PGCCConferencePrivileges	pConductPrivilege;
	PGCCConferencePrivileges	pConductModePrivilege;
	PGCCConferencePrivileges	pNonConductPrivilege;
	LPWSTR						pwszConfDescriptor;
}
	CONF_SPEC_PARAMS;

//	The class definition
class CConf : public CRefCount
{
    friend class MCSUser;

public:

	CConf
	(
		PGCCConferenceName			conference_name,
		GCCNumericString			conference_modifier,
		GCCConfID				    conference_id,
		CONF_SPEC_PARAMS			*pConfSpecParams,
		UINT						cNetworkAddresses,
		PGCCNetworkAddress 			*pLocalNetworkAddress,
		PGCCError					return_value
	);

	~CConf(void);

	/*
	**	Public Member Functions : should only be called
	**	by the owner object
	*/
	GCCError		ConfCreateRequest(
						TransportAddress		calling_address,
						TransportAddress		called_address,
						BOOL					fSecure,
						CPassword               *convener_password,
						CPassword               *password,
						LPWSTR					pwszCallerID,
						PDomainParameters		domain_parameters,
						CUserDataListContainer  *user_data_list,
						PConnectionHandle		connection_handle);

	GCCError		ConfCreateResponse(
						ConnectionHandle		connection_handle,
						PDomainParameters		domain_parameters,
						CUserDataListContainer  *user_data_list);

	GCCError		ConfJoinRequest
					(
						GCCNumericString		called_node_modifier,
						CPassword               *convener_password,
						CPassword               *password_challenge,
						LPWSTR					pwszCallerID,
						TransportAddress		calling_address,
						TransportAddress		called_address,
						BOOL					fSecure,
						PDomainParameters 		domain_parameters,
						CUserDataListContainer  *user_data_list,
						PConnectionHandle		connection_handle
					);

	GCCError		ForwardConfJoinRequest
					(
						CPassword               *convener_password,
						CPassword               *password_challange,
						LPWSTR					pwszCallerID,
						CUserDataListContainer  *user_data_list,
						BOOL					numeric_name_present,
						ConnectionHandle		connection_handle
					);

	GCCError		ConfJoinIndResponse
					(
						ConnectionHandle		connection_handle,
						CPassword               *password_challenge,
						CUserDataListContainer  *user_data_list,
						BOOL					numeric_name_present,
						BOOL					convener_is_joining,
						GCCResult				result
					);

	GCCError		ConfInviteResponse(
						UserID					parent_user_id,
						UserID					top_user_id,
						TagNumber				tag_number,
						ConnectionHandle		connection_handle,
						BOOL					fSecure,
						PDomainParameters		domain_parameters,
						CUserDataListContainer  *user_data_list);

	GCCError		RegisterAppSap(CAppSap *);
	GCCError		UnRegisterAppSap(CAppSap *);
	GCCError		DisconnectProviderIndication(ConnectionHandle);
	GCCError		ConfRosterInquireRequest(CBaseSap *, GCCAppSapMsgEx **);
	GCCError		AppRosterInquireRequest(GCCSessionKey *, CAppRosterMsg **);
	BOOL			FlushOutgoingPDU(void);

    GCCConfID GetConfID ( void ) { return m_nConfID; }
    ConferenceNodeType GetConfNodeType ( void ) { return m_eNodeType; }

    GCCNodeID GetParentNodeID(void) { return (m_pMcsUserObject ? m_pMcsUserObject->GetParentNodeID() : 0); }

    BOOL IsConfTopProvider ( void )
    {
        return ((m_eNodeType == TOP_PROVIDER_AND_CONVENER_NODE) ||
                (m_eNodeType == TOP_PROVIDER_NODE));
    }

    GCCNodeID GetTopProvider(void) { return (m_pMcsUserObject ? m_pMcsUserObject->GetTopNodeID() : 0); }

    BOOL DoesConvenerExists ( void ) { return (m_nConvenerNodeID != 0); }
    BOOL IsConfListed ( void ) { return m_fConfListed; }
    BOOL IsConfPasswordInTheClear ( void ) { return m_fClearPassword; }
    BOOL IsConfLocked ( void ) { return m_fConfLocked; }
    BOOL IsConfEstablished ( void ) { return m_fConfIsEstablished; }
    BOOL IsConfConductible ( void ) { return m_fConfConductible; }
    BOOL IsConfSecure ( void ) { return m_fSecure; }

    LPSTR GetNumericConfName ( void ) { return m_pszConfNumericName; }
    LPWSTR GetTextConfName ( void ) { return m_pwszConfTextName; }
    LPSTR GetConfModifier ( void ) { return m_pszConfModifier; }
    LPWSTR GetConfDescription ( void ) { return m_pwszConfDescription; }
    CNetAddrListContainer *GetNetworkAddressList ( void ) { return m_pNetworkAddressList; }
    void ConfIsOver ( void ) { m_fConfIsEstablished = FALSE; }

    CRegistry *GetRegistry ( void ) { return m_pAppRegistry; }

	/*
	**	These are Command Targets
	*/

	GCCError			ConfJoinReqResponse(
							UserID				    receiver_id,
							CPassword               *password_challenge,
							CUserDataListContainer  *user_data_list,
							GCCResult			    result);

	GCCError			ConfInviteRequest(
							LPWSTR					pwszCallerID,
							TransportAddress		calling_address,
							TransportAddress		called_address,
							BOOL					fSecure,
							CUserDataListContainer  *user_data_list,
							PConnectionHandle		connection_handle);

	GCCError			ConfLockResponse(UserID uidRequester, GCCResult);

	GCCError 			ConfEjectUserRequest(UserID uidEjected, GCCReason reason);
	GCCError			ConfAnnouncePresenceRequest(PGCCNodeRecord node_record);
	GCCError			ConfDisconnectRequest(void);

	GCCError			AppEnrollRequest(CAppSap *, GCCEnrollRequest *, GCCRequestTag);

#ifdef JASPER
	GCCError			ConfLockRequest(void);
	GCCError			ConfUnlockRequest(void);
	GCCError			ConfUnlockResponse(UserID uidRequester, GCCResult result);
	GCCError			ConfTerminateRequest(GCCReason reason);
#endif // JASPER

	/******************** Registry calls **************************/

	GCCError			RegistryRegisterChannelRequest(
							PGCCRegistryKey			registry_key,
							ChannelID				channel_id,
							CAppSap *);
					
	GCCError			RegistryAssignTokenRequest(
							PGCCRegistryKey			registry_key,
							CAppSap *);

	GCCError			RegistrySetParameterRequest (
							PGCCRegistryKey			registry_key,
							LPOSTR			        parameter_value,
							GCCModificationRights	modification_rights,
							CAppSap *);

	GCCError			RegistryRetrieveEntryRequest(
							PGCCRegistryKey			registry_key,
							CAppSap *);

	GCCError			RegistryDeleteEntryRequest(
							PGCCRegistryKey			registry_key,
							CAppSap *);

	GCCError			RegistryMonitorRequest(
							BOOL					enable_delivery,
							PGCCRegistryKey			registry_key,
							CAppSap *);

	GCCError			RegistryAllocateHandleRequest(
							UINT					number_of_handles,
							CAppSap *);
								
	/******************** Conductorship calls **************************/

	GCCError 			ConductorGiveResponse(GCCResult result);

#ifdef JASPER
	GCCError 			ConductorAssignRequest(void);
	GCCError 			ConductorReleaseRequest(void);
	GCCError 			ConductorPleaseRequest(void);
	GCCError 			ConductorGiveRequest(UserID recipient_node_id);
	GCCError 			ConductorPermitAskRequest(BOOL grant_permission);
    GCCError 			ConductorPermitGrantRequest(
							UINT					number_granted,
							PUserID					granted_node_list,
							UINT					number_waiting,
							PUserID					waiting_node_list);
#endif // JASPER

	GCCError 			ConductorInquireRequest(CBaseSap *);

	/********************************************************************/

	//	Miscelaneous calls
	GCCError		ConferenceTimeRemainingRequest (
							UINT			time_remaining,
							UserID			node_id);

    GCCError 		AppInvokeRequest(
						CInvokeSpecifierListContainer*,
                        GCCSimpleNodeList *,
              			CBaseSap *,
              			GCCRequestTag);

	GCCError		UpdateNodeVersionList(PGCCPDU	roster_update,
										  UserID	sender_id);

	DWORD_PTR	GetNodeVersion(UserID   nodeId) { return m_NodeVersionList2.Find(nodeId); }
						
    BOOL            HasNM2xNode(void);


#ifdef JASPER
	GCCError 		ConfTimeInquireRequest(BOOL time_is_conference_wide);
	GCCError		ConfExtendRequest (
							UINT			extension_time,
							BOOL		 	time_is_conference_wide);
	GCCError		ConfAssistanceRequest(
							UINT			number_of_user_data_members,
							PGCCUserData *	user_data_list);
	GCCError 		TextMessageRequest (
						LPWSTR				pwszTextMsg,
						UserID				destination_node );
	GCCError		ConfTransferRequest (
						PGCCConferenceName	destination_conference_name,
						GCCNumericString	destination_conference_modifier,
						CNetAddrListContainer *network_address_list,
						UINT				number_of_destination_nodes,
						PUserID				destination_node_list,
						CPassword           *password);
	GCCError		ConfAddRequest (	
						CNetAddrListContainer   *network_address_container,
						UserID				    adding_node,
						CUserDataListContainer  *user_data_container);
#endif // JASPER

	GCCError		ConfAddResponse (	
						GCCResponseTag		    add_response_tag,
						UserID				    requesting_node,
						CUserDataListContainer	*user_data_container,
						GCCResult			    result);


    void  WndMsgHandler(UINT);

	//	Routines called from the mcs interface
	void			ProcessConnectProviderConfirm(PConnectProviderConfirm connect_provider_confirm);

    // Callback from conf roster manager

    void ConfRosterReportIndication ( CConfRosterMsg * );

    void CancelInviteRequest(ConnectionHandle);

protected:

    //
    // Routines called from the user object via owner callbacks
    //

	void			ProcessConferenceCreateResponsePDU(
								PConferenceCreateResponse	create_response,
								PConnectProviderConfirm		connect_provider_confirm);

	void			ProcessConferenceJoinResponsePDU(
								PConferenceJoinResponse		join_response,
								PConnectProviderConfirm		connect_provider_confirm);

	void 			ProcessConferenceInviteResponsePDU(
								PConferenceInviteResponse	invite_response,
								PConnectProviderConfirm		connect_provider_confirm);

	void   			ProcessUserIDIndication(
								TagNumber			tag_number,
								UserID				user_id);

	void			ProcessUserCreateConfirm(
								UserResultType		result,
								UserID				user_id);

	void			ProcessRosterUpdatePDU(
								PGCCPDU				roster_update,
								UserID				sender_id);

	void			ProcessRosterRefreshPDU(
								PGCCPDU				roster_update,
								UserID				sender_id);

	GCCError		ProcessAppRosterIndicationPDU(	
								PGCCPDU					roster_update,
								UserID					sender_id);
						
	void			ProcessDetachUserIndication(
								UserID					detached_user,
								GCCReason				reason);

								
	void			ProcessTerminateRequest(
								UserID					requester_id,
								GCCReason				reason);

	void			ProcessTerminateIndication(GCCReason reason);
	void			ProcessEjectUserRequest(PUserEjectNodeRequestInfo eject_node_request);
	void			ProcessEjectUserIndication(GCCReason reason);
  	void			ProcessEjectUserResponse(PUserEjectNodeResponseInfo eject_node_response);
	void			ProcessConferenceLockRequest(UserID requester_id);
	void			ProcessConferenceUnlockRequest(UserID requester_id);
	void			ProcessConferenceLockIndication(UserID source_id);
	void			ProcessConferenceUnlockIndication(UserID source_id);

    void            ProcessConfJoinResponse(PUserJoinResponseInfo);
    void            ProcessAppInvokeIndication(CInvokeSpecifierListContainer *, UserID);
#ifdef JASPER
    void            ProcessConductorPermitAskIndication(PPermitAskIndicationInfo);
#endif // JASPER
    void            ProcessConfAddResponse(PAddResponseInfo);


	/***************** Conductorship calls ***********************/

	void			ProcessConductorGrabConfirm(GCCResult result);
	void			ProcessConductorAssignIndication(UserID uidNewConductor, UserID uidSender);
	void			ProcessConductorReleaseIndication(UserID uidSender);
	void			ProcessConductorGiveIndication(UserID uidGiver);
	void			ProcessConductorGiveConfirm(GCCResult);
	void			ProcessConductorPermitGrantInd(PUserPermissionGrantIndicationInfo, UserID uidSender);
	void			ProcessConductorTestConfirm(GCCResult);

    void			ProcessConferenceTransferRequest(
								UserID				requesting_node_id,
								PGCCConferenceName	destination_conference_name,
								GCCNumericString	destination_conference_modifier,
								CNetAddrListContainer *destination_address_list,
								UINT				number_of_destination_nodes,
 								PUserID				destination_node_list,
								CPassword           *password);
								
	void			ProcessConferenceTransferIndication(
								PGCCConferenceName	destination_conference_name,
								GCCNumericString	destination_conference_modifier,
								CNetAddrListContainer *destination_address_list,
								CPassword               *password);

	void			ProcessConferenceAddRequest(
								CNetAddrListContainer *network_address_list,
								CUserDataListContainer *user_data_list,
								UserID				adding_node,
								TagNumber			add_request_tag,
								UserID				requesting_node);

	void			InitiateTermination(GCCReason, UserID uidRequester);

    // look for this node ID in the roster's record set.
    BOOL            IsThisNodeParticipant(GCCNodeID);

private:

	/*************************************************************/

	CAppRosterMgr		*GetAppRosterManager(PGCCSessionKey session_key);
	TagNumber			GetNewUserIDTag(void);
	void				GetConferenceNameAndModifier(PGCCConferenceName, PGCCNumericString pszConfModifier);
	BOOL				DoesRequesterHavePrivilege(UserID uidRequester, ConferencePrivilegeType);
	GCCError			SendFullRosterRefresh(void);
	GCCError			UpdateNewConferenceNode(void);

	/*
	**	This group of routines operates on the enrolled APE list.
	*/
	GCCError			GetEntityIDFromAPEList(CAppSap *, PGCCSessionKey, GCCEntityID *);
	GCCError			GenerateEntityIDForAPEList(CAppSap *, PGCCSessionKey, GCCEntityID *);
	void				RemoveSAPFromAPEList(CAppSap *);
	ENROLLED_APE_INFO	*GetEnrolledAPEbySap(CAppSap *, GCCEntityID *);
	GCCError			FlushRosterData(void);
	GCCError			AsynchFlushRosterData(void);
	void				DeleteEnrolledAPE(GCCEntityID);
	BOOL				IsReadyToSendAppRosterUpdate(void);
	void				DeleteOutstandingInviteRequests(void);
    void                DeleteInviteRequest(INVITE_REQ_INFO *);

    BOOL	DoesSAPHaveEnrolledAPE(CAppSap *pAppSap)
	{
		return (BOOL) (UINT_PTR) GetEnrolledAPEbySap(pAppSap, NULL);
	}


	// Yikang:  This method checks whether the roster update PDU
	// contains the applet. The refreshonly argument indicates
	// whether or not to check the record updates.
	BOOL	DoesRosterPDUContainApplet(PGCCPDU  roster_update,
				const struct Key *obj_key, BOOL  refreshonly = TRUE);

    void    AddNodeVersion(UserID, NodeRecord*);


private:

	CAppRosterMgrList				    m_AppRosterMgrList;
	CAppSapList                         m_RegisteredAppSapList;
	CEnrolledApeEidList2			    m_EnrolledApeEidList2;

    CNetAddrListContainer               *m_pNetworkAddressList;
	CUserDataListContainer		        *m_pUserDataList;

	CConnHandleList     			    m_ConnHandleList;
	CConnHdlTagNumberList2				m_ConnHdlTagNumberList2;

    CJoinRespNamePresentConnHdlList2	m_JoinRespNamePresentConnHdlList2;
	CInviteRequestList				    m_InviteRequestList;
	CEjectedNodeConfirmList			    m_EjectedNodeConfirmList;
	CConductorTestList   	            m_ConductorTestList;
	CNetAddrTagNumberList2				m_AddRequestList;
	CTagNumberTagNumberList2			m_AddResponseList;
	CNodeVersionList2					m_NodeVersionList2;
	
	PMCSUser						m_pMcsUserObject;

	LPSTR							m_pszConfNumericName;
	LPWSTR							m_pwszConfTextName;
	LPWSTR							m_pwszConfDescription;
	LPSTR							m_pszConfModifier;
	LPSTR							m_pszRemoteModifier;

	GCCConfID   					m_nConfID;
	UserID							m_nConvenerNodeID;

	BOOL							m_fConfLocked;
	BOOL							m_fConfListed;
	BOOL							m_fConfConductible;
	BOOL							m_fClearPassword;
	BOOL							m_fConfIsEstablished;
	BOOL							m_fConfDisconnectPending;
	BOOL							m_fConfTerminatePending;
    BOOL                            m_fTerminationInitiated;
	BOOL							m_fSecure;

	BOOL							m_fWBEnrolled;
	BOOL							m_fFTEnrolled;
	BOOL							m_fChatEnrolled;

	GCCTerminationMethod			m_eTerminationMethod;
	GCCReason						m_eConfTerminateReason;

	PDomainParameters 				m_pDomainParameters;

	ConferenceNodeType				m_eNodeType;

	UserIDTagNumber					m_nUserIDTagNumber;
	UserIDTagNumber					m_nConvenerUserIDTagNumber;
	TagNumber						m_nParentIDTagNumber;
	TagNumber						m_nConfAddRequestTagNumber;

    ConnectionHandle				m_hParentConnection;
	ConnectionHandle				m_hConvenerConnection;

	PAlarm							m_pConfTerminateAlarm;
	PAlarm							m_pConfStartupAlarm;

	PPrivilegeListData				    m_pConductorPrivilegeList;
	PPrivilegeListData				    m_pConductModePrivilegeList;
	PPrivilegeListData				    m_pNonConductModePrivilegeList;

    GCCResponseTag					m_nConfAddResponseTag;
	CConfRosterMgr					*m_pConfRosterMgr;
	CRegistry                       *m_pAppRegistry;
	UserID							m_nConductorNodeID;
	UserID							m_nPendingConductorNodeID;
	BOOL							m_fConductorGrantedPermission;
	BOOL							m_fConductorGiveResponsePending;
	BOOL							m_fConductorAssignRequestPending;
	EntityID						m_nAPEEntityID;
    //
    // LONCHANC; m_cPermittedEnrollment is the number of
	// GCC-Application-Permit-to-Enroll. we need to wait for all
	// the corresponding GCC-Application-Enroll-Request come in.
	// then, we will send out a single
	// GCC-Application-Roster-Update-Indication to the wire.
    //
    int								m_cEnrollRequests; // LONCHANC: must be signed
	BOOL							m_fFirstAppRosterSent;
};
typedef	CConf 		*			PConference;

#endif

/*
 *	CConf(		PGCCConferenceName			conference_name,
 *					GCCNumericString			conference_modifier,
 *					GCCConfID   				conference_id,
 *					BOOL						use_password_in_the_clear,
 *					BOOL						conference_locked,
 *					BOOL						conference_listed,
 *					BOOL						conference_conductable,
 *					GCCTerminationMethod		termination_method,
 *					PGCCConferencePrivileges	conduct_privilege_list,
 *					PGCCConferencePrivileges	conduct_mode_privilege_list,
 *					PGCCConferencePrivileges	non_conduct_privilege_list,
 *					LPWSTR						pwszConfDescriptor,
 *					UINT						number_of_network_addresses,
 *					PGCCNetworkAddress 		*	local_network_address_list,
 *					CControlSAP					*control_sap,
 *					UINT						owner_message_base,
 *					PGCCError					return_value);
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This is the conference constructor. It is responsible for
 *		initializing all the instance variables used by this class.
 *		It also creates the MCS domain based on the conference id.
 *		Fatal errors are returned from this constructor in the
 *		return value. Note that this constructor is used when the
 *		CConf specification parameters such as termination	
 *		method or known in advance of conference creation.  This is
 *		the case for a convenor node and a top provider.  It is not
 *		used for joining nodes.
 *
 *	Formal Parameters:
 *		conference_name		(i)	Structure pointer that holds the confernce name.
 *		conference_modifier	(i)	Pointer to the conference modifier.
 *		conference_id		(i)	The assigned conference ID.
 *		use_password_in_the_clear	
 *							(i)	Flag specifying if the password is in the clear.
 *		conference_locked	(i)	Flag specifying if the conference is locked.
 *		conference_listed	(i)	Flag specifying if the conference is listed.
 *		conference_conductable
 *							(i)	Flag specifying if conference is conductable.
 *		termination_method	(i)	Flag specifying the termination method.
 *		conduct_privilege_list
 *							(i)	Privilege list used by the conductor.
 *		conduct_mode_privilege_list
 *							(i)	Privilege list used in conducted mode.
 *		non_conduct_privilege_list
 *							(i) Privilege list used when not in conducted mode.
 *		conference_descriptor
 *							(i)	Pointer to the conference descriptor.
 *		number_of_network_addresses
 *							(i)	Number of network addresses in list.
 *		local_network_address_list
 *							(i) List of local network addresses.
 *		mcs_interface		(i)	Pointer to the MCS interface object.
 *		control_sap			(i) Pointer to the Node Controller SAP.
 *		owner_object		(i)	Pointer to the object that created this object.
 *		owner_message_base	(i) The number added to all owner callback messages.
 *		packet_coder		(i)	Pointer to the Packet Coder object used for PDUs
 *		return_value		(o)	Errors that occur are returned here.
 *		
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	Resource error occured.
 *		GCC_INVALID_CONFERENCE_NAME		-	Invalid conference name passed in.
 *		GCC_FAILURE_CREATING_DOMAIN		-	Failure creating domain.
 *		GCC_BAD_NETWORK_ADDRESS			-	Bad network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	-	Bad network address type passed in.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	CConf(		PGCCConferenceName	  		conference_name,
 *					GCCNumericString			conference_modifier,
 *					GCCConfID   				conference_id,
 *					UINT						number_of_network_addresses,
 *					PGCCNetworkAddress 	*		local_network_address_list,
 *					CControlSAP					*control_sap,
 *					UINT								owner_message_base,
 *					PGCCError					return_value);
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This is the conference constructor. It is responsible for
 *		initializing all the instance variables used by this class.
 *		It also creates the MCS domain based on the conference id.
 *		Fatal errors are returned from this constructor in the
 *		return value. Note that this constructor is used by nodes that
 *		do not know the CConf specification parameters such as
 *		termination	method in advance of conference creation.  This is
 *		the case for joining nodes.
 *
 *	Formal Parameters:
 *		conference_name		(i)	Structure pointer that holds the confernce name.
 *		conference_modifier	(i)	Pointer to the conference modifier.
 *		conference_id		(i)	The assigned conference ID.
 *		number_of_network_addresses
 *							(i)	Number of local network addresses in list.
 *		local_network_address_list
 *							(i) List of local network addresses.
 *		control_sap			(i) Pointer to the Node Controller SAP.
 *		packet_coder		(i)	Pointer to the Packet Coder object used for PDUs
 *		return_value		(o)	Errors that occur are returned here.
 *		
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	Resource error occured.
 *		GCC_FAILURE_CREATING_DOMAIN		-	Failure creating domain.
 *		GCC_BAD_NETWORK_ADDRESS			-	Bad network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	-	Bad network address type passed in.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConfCreateRequest(
 *							TransportAddress		calling_address,
 *							TransportAddress		called_addrescs,
 *							CPassword               *convener_password,
 *							CPassword               *password,
 *							LPWSTR					pwszCallerID,
 *							PDomainParameters		domain_parameters,
 *							CUserDataListContainer  *user_data_list,
 *							PConnectionHandle		connection_handle)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function is called when a Conference Create Request PDU is to be
 *		issued.  Note that a local conference can be created by setting the
 *		called address to NULL.
 *
 *	Formal Parameters:
 *		calling_address		(i)	Address of the calling node.
 *		called_address		(i)	Address of the called node. Null for local conf.
 *		convener_password	(i)	Password used by convener to get back priviliges
 *		password			(i)	Password needed to join the conference.
 *		caller_identifier	(i) Unicode string specifying the caller ID.
 *		domain_parameters	(i)	The MCS domain parameters.
 *		user_data_list		(i) Pointer to a User data list object.
 *		connection_handle	(o)	The logical connection handle is returned here.
 *
 *	Return Value
 *		GCC_NO_ERROR:					- No error
 *		GCC_ALLOCATION_FAILURE			- Resource error occured
 *		GCC_INVALID_TRANSPORT_ADDRESS	- Something wrong with transport address
 *		GCC_FAILURE_ATTACHING_TO_MCS	- Failure creating MCS user attachment
 *		GCC_INVALID_ADDRESS_PREFIX		- Invalid transport address prefix
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		Passing in NULL for the called address will create a local conference.
 */

/*
 *	GCCError	ConfCreateResponse(
 *							ConnectionHandle		connection_handle,
 *							PDomainParameters		domain_parameters,
 *							CUserDataListContainer  *user_data_list)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function is called when a Conference Create Response PDU is to be
 *		issued.  It should only be issued in response to a
 *		ConferenceCreateRequest. The connection handle is used to match the
 *		request with the response.
 *
 *	Formal Parameters:
 *		connection_handle	(i)	Connection handled specified in the request.
 *		domain_parameters	(i)	The MCS domain parameters.
 *		user_data_list		(i) Pointer to a User data list object.
 *
 *	Return Value
 *		GCC_NO_ERROR:					- No error
 *		GCC_ALLOCATION_FAILURE			- Resource error occured
 *		GCC_FAILURE_ATTACHING_TO_MCS	- Failure creating MCS user attachment
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 * 	GCCError	ConfJoinRequest(
 *							GCCNumericString		called_node_modifier,
 *							CPassword               *convener_password,
 *							CPassword               *password_challenge,
 *							LPWSTR					pwszCallerID,
 *							TransportAddress		calling_address,
 *							TransportAddress		called_address,
 *							PDomainParameters 		domain_parameters,
 *							CUserDataListContainer  *user_data_list,
 *							PConnectionHandle		connection_handle)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function is called when a Conference Join Request PDU is to be
 *		issued.  The second constructor defined above should have been
 *		used to create the conference object before the routine is called.
 *
 *	Formal Parameters:
 *		called_node_modifier(i)	The conference modifier at the node being joined
 *		convener_password	(i)	Password used by convener to get back priviliges
 *		password_challenge	(i) Password used to join a conference.
 *		caller_identifier	(i) Unicode string specifying the caller ID.
 *		calling_address		(i)	Address of the calling node.
 *		called_address		(i)	Address of the called node.
 *		domain_parameters	(i)	The MCS domain parameters.
 *		user_data_list		(i) Pointer to a User data list object.
 *		connection_handle	(o)	The logical connection handle is returned here.
 *
 *	Return Value
 *		GCC_NO_ERROR:					- No error
 *		GCC_ALLOCATION_FAILURE			- Resource error occured
 *		GCC_INVALID_TRANSPORT_ADDRESS	- Something wrong with transport address
 *		GCC_FAILURE_ATTACHING_TO_MCS	- Failure creating MCS user attachment
 *		GCC_INVALID_ADDRESS_PREFIX		- Invalid transport address prefix
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ForwardConfJoinRequest (
 *							CPassword               *convener_password,
 *							CPassword               *password_challange,
 *							LPWSTR					pwszCallerID,
 *							CUserDataListContainer  *user_data_list,
 *							BOOL					numeric_name_present,
 *							ConnectionHandle		connection_handle)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function is called when a Conference Join Request is to be
 *		forwarded to the Top Provider.  This call will be made after an
 *		intermediate node calls Join Response with a successful result
 *		value.
 *
 *	Formal Parameters:
 *		convener_password	(i)	Password used by convener to get back priviliges
 *		password_challenge	(i) Password used to join a conference.
 *		caller_identifier	(i) Unicode string specifying the caller ID.
 *		user_data_list		(i) Pointer to a User data list object.
 *		numeric_name_present(i) This flag states that the numeric portion of
 *								the conference name was specified in the
 *								request.  Therefore, the text name is returned
 *								in the response.
 *		connection_handle	(i)	The logical connection handle defined by the
 *								request.
 *
 *	Return Value
 *		GCC_NO_ERROR:					- No error
 *		GCC_ALLOCATION_FAILURE			- Resource error occured
 *		GCC_INVALID_CONFERENCE			- Returned if this node is the Top
 *										  Provider
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConfJoinIndResponse(
 *							ConnectionHandle		connection_handle,
 *							CPassword               *password_challenge,
 *							CUserDataListContainer  *user_data_list,
 *							BOOL					numeric_name_present,
 *							BOOL					convener_is_joining,
 *							GCCResult				result)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function is called when a Conference Join Response PDU is to be
 *		issued.  It is called in response to a ConferenceJoinRequest being
 *		received.
 *
 *	Formal Parameters:
 *		connection_handle	(i)	Connection handled specified in the request.
 *		password_challenge	(i) Password used when joining a conference.
 *		user_data_list		(i) Pointer to a User data list object.
 *		numeric_name_present(i) This flag states that the numeric portion of
 *								the conference name was specified in the
 *								request.  Therefore, the text name is returned
 *								in the response.
 *		convener_is_joining	(i)	Flag stating that the convener is rejoining
 *								the conference.
 *		result				(i)	Result code to be returned in the response.
 *
 *	Return Value
 *		GCC_NO_ERROR:						- No error
 *		GCC_ALLOCATION_FAILURE				- Resource error occured
 *		GCC_DOMAIN_PARAMETERS_UNACCEPTABLE	- Domain parameters were
 *											  unacceptable for this connection.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		If the GCC_DOMAIN_PARAMETERS_UNACCEPTABLE error is returned from this
 *		routine, MCS will automatically reject the connection sending a
 *		result to the other side stating the the Domain Parameters were
 *		unacceptable.
 */

/*
 *	GCCError	ConfInviteResponse(
 *							UserID					parent_user_id,
 *							UserID					top_user_id,
 *							TagNumber				tag_number,
 *							ConnectionHandle		connection_handle,
 *							PDomainParameters		domain_parameters,
 *							CUserDataListContainer  *user_data_list)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function is called when a Conference Invite Response PDU is to be
 *		issued.  It is called in response to an Invite request.
 *
 *	Formal Parameters:
 *		parent_user_id		(i)	The MCS user ID of the parent node.
 *		top_user_id			(i) The MCS user ID of the Top Provider.
 *		tag_number			(i) Tag the matches the request with the response.
 *		connection_handle	(i)	Connection handled specified in the request.
 *		domain_parameters	(i)	The MCS domain parameters.
 *		user_data_list		(i) Pointer to a User data list object.
 *
 *	Return Value
 *		GCC_NO_ERROR:						- No error
 *		GCC_ALLOCATION_FAILURE				- Resource error occured
 *		GCC_FAILURE_ATTACHING_TO_MCS		- Failure creating MCS user
 *											  attachment
 *		GCC_DOMAIN_PARAMETERS_UNACCEPTABLE	- Domain parameters were
 *											  unacceptable for this connection.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	CConf::RegisterAppSap(CAppSap *pAppSap)
 *
 *	Public Function Description
 *		This routine is called from the owner object whenever an application
 *		SAP becomes a candidate for Enrollment.  This will happen whenever
 *		Applications SAPs exists at the same time a conference becomes
 *		established.  It will also be called whenever a conference exists
 *		and a new application SAP is created.
 *
 *	Formal Parameters:
 *		pAppSap		(i)	Pointer to the application SAP object associated
 *								with the registering Application.
 *		hSap
 *							(i) SAP handle of the registering Application.
 *
 *	Return Value
 *		GCC_NO_ERROR:					- No error
 *		GCC_ALLOCATION_FAILURE			- Resource error occured
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	CConf::UnRegisterAppSap(CAppSap *pAppSap)
 *
 *	Public Function Description
 *		This routine is called from the owner object whenever an application
 *		SAP becomes unavailable due to whatever reason.  This routine is
 *		responsible for unenrolling any APEs from any rosters that it might have
 *		used this SAP to enroll with.
 *
 *	Formal Parameters:
 *		application_sap_handle
 *							(i) SAP handle of the unregistering Application.
 *
 *	Return Value
 *		GCC_NO_ERROR:					- No error
 *		GCC_APPLICATION_NOT_REGISTERED	- The application was not registered.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	DisconnectProviderIndication(
 *							ConnectionHandle		connection_handle)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function is called whenever a disconnect indication is received
 *		by GCC.  It is used to inform the conference of any logical connections
 *		it that might have gone down.
 *
 *	Formal Parameters:
 *		connection_handle	(i)	Logical connection handle that was disconnected
 *
 *	Return Value
 *		GCC_NO_ERROR:					- No error
 *		GCC_ALLOCATION_FAILURE			- Resource error occured
 *		GCC_INVALID_PARAMETER			- This connection handle is not used
 *										  by this conference.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	DisconnectProviderIndication(
 *							ConnectionHandle		connection_handle)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function is called whenever a disconnect indication is received
 *		by GCC.  It is used to inform the conference of any logical connections
 *		it that might have gone down.
 *
 *	Formal Parameters:
 *		connection_handle	(i)	Logical connection handle that was disconnected
 *
 *	Return Value
 *		GCC_NO_ERROR:					- No error
 *		GCC_ALLOCATION_FAILURE			- Resource error occured
 *		GCC_INVALID_PARAMETER			- This connection handle is not used
 *										  by this conference.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConfRosterInquireRequest(CBaseSap *)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function is used to obtain a conference roster.  The conference
 *		roster is delivered to the requesting command target in a Conference
 *		Roster inquire confirm.
 *
 *	Formal Parameters:
 *		command_target	(i)	Pointer to object that made the request.
 *
 *	Return Value
 *		GCC_NO_ERROR:					- No error
 *		GCC_ALLOCATION_FAILURE			- Resource error occured
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	AppRosterInquireRequest(GCCSessionKey *, CAppRosterMsg **)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function is used to obtain a list of application rosters.  This
 *		list is delivered to the requesting SAP through an	Application Roster
 *		inquire confirm message.
 *
 *	Formal Parameters:
 *		session_key		(i)	Session Key of desired roster.  If NULL is
 *							specified then all the available application rosters
 *							are delivered in the confirm.
 *		command_target	(i)	Pointer to object that made the request.
 *
 *	Return Value
 *		GCC_NO_ERROR:					- No error
 *		GCC_ALLOCATION_FAILURE			- Resource error occured
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL		FlushOutgoingPDU ();
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function is used by the owner object to flush any PDUs queued
 *		by the conference object.  This routine will all flush PDUs queued
 *		by the User Attachment object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return value:
 *		TRUE, if there remain un-processed msgs in the conference message queue
 *		FALSE, if all the msgs in the conference msg queue were processed.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL			IsConfEstablished();
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		Function informs whether the conference has completed its
 *		establishment process.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		TRUE	-	Establishment is complete.
 *		FALSE	-	Establishment is still in process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL		IsConfTopProvider();
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		Function informs whether this node is the Top Provider of the
 *		conference.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		TRUE	-	This node is the Top Provider.
 *		FALSE	-	This node is NOT the Top Provider.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL		DoesConvenerExists();
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function informs whether or not the convener is still joined to
 *		this conference.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		TRUE	-	There is a convener node joined to the conference.
 *		FALSE	-	There is NOT a convener node joined to the conference.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	LPSTR	GetNumericConfName();
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function returns an internal pointer to a LPSTR string
 *		that holds the numeric conference name.  This string should not be
 *		altered by the requesting module.  It should also not be used after
 *		the conference is deleted.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		Pointer to the numeric string portion of the Conference Name.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	LPWSTR	GetTextConfName();
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function returns an internal pointer to the unicode string
 *		that holds the text portion of the conference name.  This string should
 *		not be altered by the requesting module.  It should also not be used
 *		after the conference is deleted.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		Pointer to the text string portion of the Conference Name.
 *		NULL if no text conference name exists.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	LPSTR	GetConfModifier();
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function returns an internal pointer to the LPSTR string
 *		that holds the conference name modifier.  This string should
 *		not be altered by the requesting module.  It should also not be used
 *		after the conference is deleted.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		Pointer to the Conference Name modifier.
 *		NULL if no modifier exists.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	LPWSTR	GetConfDescription()
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function returns an internal pointer to the unicode string
 *		that holds the conference descriptor.  This string should
 *		not be altered by the requesting module.  It should also not be used
 *		after the conference is deleted.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		Pointer to the Conference Descriptor.
 *		NULL if no descriptor exists.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	CNetAddrListContainer *GetNetworkAddressList()
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function returns an internal pointer to the object that holds the
 *		list of local network addresses.  This object should
 *		not be altered by the requesting module.  It should also not be used
 *		after the conference is deleted.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		Pointer to the Local network address list.
 *		NULL if no descriptor exists.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCConfID		GetConfID()
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function returns the conference ID for this conference object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		The conference ID
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL			IsConfListed();
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function informs whether or NOT the conference is listed.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		TRUE	-	The conference is listed
 *		FALSE	-	This conference is NOT listed
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL			IsConfPasswordInTheClear();
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function informs whether or NOT the conference is using an
 *		in the clear password.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		TRUE	-	The conference is using a Password in the clear
 *		FALSE	-	The conference is NOT using a Password in the clear
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL			IsConfLocked();
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This function informs whether or NOT the conference is locked.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		TRUE	-	The conference is locked.
 *		FALSE	-	The conference is NOT locked.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */


/*
 *	These routines live in conf2.cpp
 */

/*
 *		GCCError		ConfJoinReqResponse(
 *									UserID				receiver_id,
 *									CPassword           *password_challenge,
 *									CUserDataListContainer *user_data_list,
 *									GCCResult			result)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is used when the join request was delivered
 *		through an intermediate node.  In this case, the join response is sent
 *		back through the intermediate node.
 *
 *	Formal Parameters:
 *		receiver_id		- (i)	The user ID of the intermediate node that
 *								forwarded the join request.  This user ID is
 *								used to match the join request with the join
 *								response.
 *		password_challenge
 *						- (i)	The password challenge to be delivered to the
 *								joining node.  NULL if none should be delivered.
 *		user_data_list	- (i)	Pointer to a user data object to be delivered
 *								to joiner.  NULL if none should be delivered.
 *		result			- (i)	Result of the join request.
 *
 *	Return Value
 *		GCC_NO_ERROR		-	No error.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError		ConfInviteRequest(
 *								LPWSTR					pwszCallerID,
 *								TransportAddress		calling_address,
 *								TransportAddress		called_address,
 *								CUserDataListContainer  *user_data_list,
 *								PConnectionHandle		connection_handle)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is used to issue an invite request.  This
 *		can be a command target because the conference at the requesting node
 *		should already be established before the request comes in.
 *
 *	Formal Parameters:
 *		caller_identifier	(i) Unicode string specifying the caller ID.
 *		calling_address		(i)	Address of the calling node.
 *		called_address		(i)	Address of the called node.
 *		user_data_list		(i) Pointer to a User data list object.
 *		connection_handle	(o)	The logical connection handle is returned here.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.	
 *		GCC_INVALID_TRANSPORT_ADDRESS	- Something wrong with transport address
 *		GCC_INVALID_ADDRESS_PREFIX		- Invalid transport address prefix
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError		ConfLockRequest ()
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is used to issue a lock request to
 *		the conference.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.	
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConfLockResponse (
 *								UserID					requesting_node,
 *								GCCResult				result)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is used to issue a lock response.  It
 *		is called in response to a lock request.
 *
 *	Formal Parameters:
 *		requesting_node		-	(i)	Node ID of node the issued the lock request.
 *		result				-	(i)	Result of lock request.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.	
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError		ConfUnlockRequest ()
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is used to issue an unlock request to
 *		the conference.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.	
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConfUnlockResponse (
 *								UserID					requesting_node,
 *								GCCResult				result)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is used to issue an unlock response.  It
 *		is called in response to an unlock request.
 *
 *	Formal Parameters:
 *		requesting_node		-	(i)	ID of node the issued the unlock request.
 *		result				-	(i)	Result of unlock request.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.	
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError 	ConfEjectUserRequest (
 *									UserID					ejected_node_id,
 *									GCCReason				reason)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is used to eject a user from the
 *		conference.  Note that the user must have the appropriate priviliges
 *		to perform the eject.
 *
 *	Formal Parameters:
 *		ejected_node_id		-	(i)	ID of node to be ejected.
 *		reason				-	(i)	Reason for ejection
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.	
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError		ConfAnnouncePresenceRequest(
 *									PGCCNodeRecord		node_record)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when the Node Controller
 *		announces its presence with the conference.  This request will
 *		generate a roster report PDU and indication.
 *
 *	Formal Parameters:
 *		node_record		-	(i)	Structure containing the complete node
 *								record for the requesting node controller.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_BAD_NETWORK_ADDRESS			- If an invalid network address is
 *										  passed in as part of the record.	
 *		GCC_BAD_USER_DATA				- If an invalid user data list is
 *										  passed in as part of the record.	
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConfDisconnectRequest(void)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when the Node Controller
 *		wishes to disconnect the node from the conference.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		If this node is the Top Provider the conference will be terminated
 *		on all nodes.
 */

/*
 *	GCCError		ConfTerminateRequest(
 *									GCCReason			reason)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when the Node Controller
 *		wishes to terminate the conference.  This will eventually cause
 *		the object to be deleted if successful.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	AppEnrollRequest(
 *							CAppSap     *			pAppSap,
 *							PGCCSessionKey			session_key,
 *							PGCCApplicationRecord	application_record,
 *							BOOL					application_enrolled,
 *							UINT					number_of_capabilities,
 *							PGCCApplicationCapability	FAR *
 *													capabilities_list)
 *
 *	Public Function Description
 *		This function is called when a User Application wishes to enroll with
 *		the conference (or wishes to UnEnroll with it).  This call will
 *		initiate a roster update if the conference is established.
 *
 *	Formal Parameters:
 *		application_sap_handle
 *							(i) SAP handle of the enrolling Application.  Used
 *								for the entity ID.
 *		session_key			(i) Session key of the enrolling application
 *		application_record	(i)	Structure that defines the Application
 *								attributes.
 *		application_enrolled
 *							(i)	Is the application enrolling or unenrolling?
 *		number_of_capabilities
 *							(i) Number of Application capabilities in list.
 *		capabilities_list	(i)	Actual list of capabilities.
 *
 *	Return Value
 *		GCC_NO_ERROR:					- No error
 *		GCC_ALLOCATION_FAILURE			- Resource error occured
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	RegistryRegisterChannelRequest(
 *									PGCCRegistryKey			registry_key,
 *									ChannelID				channel_id,
 *									CAppSap                  *app_sap)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called by an application wishing to
 *		register a channel with the conference.	Here the application must
 *		supply the channel.
 *
 *	Formal Parameters:
 *		registry_key	-	(i)	Pointer to structure that holds registry key.
 *		channel_id		-	(i)	Channel ID to be registered.
 *		app_sap			-	(i)	The Command Target that is making the request.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  enrolled with the conference.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	RegistryAssignTokenRequest(
 *									PGCCRegistryKey			registry_key,
 *									CAppSap		            *app_sap);
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called by an application wishing to
 *		register a token with the conference.  Here the token is supplied by
 *		the conference.
 *
 *	Formal Parameters:
 *		registry_key	-	(i)	Pointer to structure that holds registry key.
 *		app_sap			-	(i)	The Command Target that is making the request.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  enrolled with the conference.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError		RegistrySetParameterRequest (
 *								PGCCRegistryKey			registry_key,
 *								LPOSTR                  parameter_value,
 *								GCCModificationRights	modification_rights,
 *								CAppSap		            *app_sap);
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called by an application wishing to
 *		register a parameter with the conference.  Here the token is supplied by
 *		the conference.
 *
 *	Formal Parameters:
 *		registry_key	-	(i)	Pointer to structure that holds registry key.
 *		parameter_value	-	(i)	Parameter to be registered
 *		modification_rights-(i)	Modification rights on the parameter.
 *		app_sap			-	(i)	The Command Target that is making the request.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  enrolled with the conference.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	RegistryRetrieveEntryRequest(
 *									PGCCRegistryKey			registry_key,
 *									CAppSap		            *app_sap)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called by an application wishing to
 *		retrieve a registry entry.
 *
 *	Formal Parameters:
 *		registry_key	-	(i)	Pointer to structure that holds registry key.
 *		app_sap			-	(i)	The Command Target that is making the request.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  enrolled with the conference.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	RegistryDeleteEntryRequest(
 *									PGCCRegistryKey			registry_key,
 *									CAppSap		            *app_sap);
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called by an application wishing to
 *		delete a registry entry.
 *
 *	Formal Parameters:
 *		registry_key	-	(i)	Pointer to structure that holds registry key.
 *		app_sap			-	(i)	The Command Target that is making the request.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  enrolled with the conference.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	RegistryMonitorRequest(
 *									BOOL					enable_delivery,
 *									PGCCRegistryKey			registry_key,
 *									CAppSap		            *app_sap)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called by an application wishing to
 *		delete a registry entry.
 *
 *	Formal Parameters:
 *		enable_delivery -	(i)	Toggle used to turn on and off monitoring of
 *								an entry.
 *		registry_key	-	(i)	Pointer to structure that holds registry key.
 *		app_sap			-	(i)	The Command Target that is making the request.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  enrolled with the conference.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	RegistryAllocateHandleRequest(
 *									UINT					number_of_handles,
 *									CAppSap		            *app_sap)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called by an application that needs
 *		to allocate a certain number of parameters.
 *
 *	Formal Parameters:
 *		number_of_handles -	(i) Number of handles to allocate.
 *		app_sap			-	(i)	The Command Target that is making the request.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_BAD_REGISTRY_KEY			- The registry key is invalid.
 *		GCC_APP_NOT_ENROLLED			- Requesting application is not
 *										  enrolled with the conference.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError 			ConductorAssignRequest();
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when a node wants to become
 *		the conductor.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError 	ConductorReleaseRequest()
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when a node wants to give up
 *		conductorship.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError 	ConductorPleaseRequest()
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when a node wants to request
 *		the conductorship token from another node.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError 		ConductorGiveRequest(
 *								UserID					recipient_node_id)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when a node wants to give
 *		the conductorship token to another node.  Usually called in response
 *		to a please request.
 *
 *	Formal Parameters:
 *		recipient_node_id	-	(i)	User ID of node to give conductorship to.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError 		ConductorGiveResponse(
 *									GCCResult				result)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called after a node has received a
 *		give indication.  This response informs the conference of whether or
 *		not this node is accepting the conductorship token.
 *
 *	Formal Parameters:
 *		result		-	(i)	If the node is accepting conductorship the result
 *							will be set to GCC_RESULT_SUCCESSFUL.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_NO_GIVE_RESPONSE_PENDING	- A give indication was never issued.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError 		ConductorPermitAskRequest(
 *							BOOL					grant_permission)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when a node wants permission
 *		from the conductor.  The definition of permission may vary from
 *		application to application.
 *
 *	Formal Parameters:
 *		grant_permission -	(i)	Flag stating whether permission is being
 *								requested or given up.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError 				ConductorPermitGrantRequest(
 *									UINT					number_granted,
 *									PUserID					granted_node_list,
 *									UINT					number_waiting,
 *									PUserID					waiting_node_list);
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called by the conductor when
 *		permission is being granted to a node or list of nodes.
 *
 *	Formal Parameters:
 *		number_granted 		-	(i)	The number of nodes granted permission.
 *		granted_node_list 	-	(i)	List of nodes granted permission.
 *		number_waiting		-	(i)	The number of nodes waiting for permission.
 *		waiting_node_list 	-	(i)	List of nodes waiting for permission.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *		GCCError ConductorInquireRequest(CBaseSap *pSap);
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when conductorship information
 *		is required by a SAP.
 *
 *	Formal Parameters:
 *		pSap 	-	(i)	SAP making the request.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConferenceTimeRemainingRequest (
 *									UINT			time_remaining,
 *									UserID			node_id)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called to inform all the nodes in
 *		the conference how much time is left in the conference.
 *
 *	Formal Parameters:
 *		time_remaining 	-	(i)	Time in miliseconds left in the conference.
 *		node_id		 	-	(i)	node_id of node to deliver time remaining
 *								indication. NULL if it should go to all nodes.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError 		ConfTimeInquireRequest (
 *									BOOL			time_is_conference_wide)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called by a node that wants to
 *		know how much time is remaining in a timed conference.
 *
 *	Formal Parameters:
 *		time_is_conference_wide	-	(i)	TRUE if time is for entire conference.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConfExtendRequest (
 *									UINT			extension_time,
 *									BOOL		 	time_is_conference_wide)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when the time left in the
 *		conference is to be extended.
 *
 *	Formal Parameters:
 *		extension_time			-	(i)	Extension time.
 *		time_is_conference_wide	-	(i)	TRUE if time is for entire conference.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConfAssistanceRequest(
 *									UINT			number_of_user_data_members,
 *									PGCCUserData *	user_data_list)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when a node wishes to request
 *		assistance.
 *
 *	Formal Parameters:
 *		number_of_user_data_members	-	(i)	number of user data members in list.
 *		user_data_list				-	(i)	list of user data members.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	AppInvokeRequest(
 *							CInvokeSpecifierListContainer	*invoke_list,
 *							UINT			number_of_destination_nodes,
 *							UserID			*list_of_destination_nodes,
 *                 			CBaseSap        *pSap)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when a node wishes to invoke
 *		a list of applications on remote node or nodes.
 *
 *	Formal Parameters:
 *		invoke_list					-	(i)	list of applications to invoke.
 *		number_of_destination_nodes	-	(i)	number of nodes in destination list
 *		list_of_destination_nodes	-	(i)	list of destination user IDs
 *		command_target				-	(i)	Command Target that made the request
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError 	TextMessageRequest (
 *							LPWSTR				pwszTextMsg,
 *							UserID				destination_node )
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when a node wishes to deliver
 *		a text message to a remote node.
 *
 *	Formal Parameters:
 *		pwszTextMsg				-	(i)	the actual text message in unicode.
 *		destination_node		-	(i)	Node ID of node receiving message
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConfTransferRequest (
 *							PGCCConferenceName	destination_conference_name,
 *							GCCNumericString	destination_conference_modifier,
 *							CNetAddrListContainer *network_address_list,
 *							UINT				number_of_destination_nodes,
 *	 						PUserID				destination_node_list,
 *							CPassword           *password)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when a node wishes transfer a
 *		list of nodes to another conference.
 *
 *	Formal Parameters:
 *		destination_conference_name	-	(i)	Name of conference to transfer to.
 *		destination_conference_modifier-(i)	Name of modifier to transfer to.
 *		network_address_list		-	(i)	Address list of new conference.
 *		number_of_destination_nodes	-	(i)	Number of nodes to transfer
 *		destination_node_list		-	(i)	List of nodes to transfer.
 *		password					-	(i)	Password needed to join new conf.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError		ConfAddRequest (	
 *							CNetAddrListContainer *network_address_container,
 *							UserID				adding_node,
 *							CUserDataListContainer *user_data_container)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when a node wishes add a new
 *		node to the conference.
 *
 *	Formal Parameters:
 *		network_address_container	-	(i)	Address of node to add.
 *		adding_node					-	(i)	Node to perform the invite. If
 *											zero then Top Provider does the
 *											invite.
 *		user_data_container			-	(i)	Container holding user data to be
 *											passed in the add request.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError		ConfAddResponse (	
 *							GCCResponseTag		add_response_tag,
 *							UserID				requesting_node,
 *							CUserDataListContainer *user_data_container,
 *							GCCResult			result)
 *
 *	Public member function of CConf
 *
 *	Function Description
 *		This Command Target function is called when a node wishes to respond
 *		to an add request.  This response should be done after the invite
 *		sequence is complete (unless result is not successful).
 *
 *	Formal Parameters:
 *		add_response_tag		-	(i)	Tag used to match request with response.
 *		requesting_node			-	(i)	Node that made the original add request.
 *		user_data_container		-	(i)	Container holding user data to be
 *										passed in the add response.
 *		result					-	(i)	The result of the Add request.
 *
 *	Return Value
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occured.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed
 *										  its establishment process.
 *		GCC_INVALID_ADD_RESPONSE_TAG	- There was no match of the response tag
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\cnpcoder.h ===
/*
 *	ogcccode.h
 *
 *	Copyright (c) 1999 by Microsoft Corporation
 *
 *	Abstract:
 *		This is the interface file for the CNPCoder class.  This
 *		class is used to encode and decode CNP Protocol Data Units (PDU's)
 *		to and from ASN.1 compliant byte streams using the ASN.1 toolkit.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		Xin Liu
 *
 */
#ifndef	_CCNPCODER_
#define	_CCNPCODER_

#include "pktcoder.h"
#include "cnppdu.h"

/*
 *	This is the class definition for class CCNPCoder
 */
class	CCNPCoder : public PacketCoder
{
 public:
    CCNPCoder ();
    BOOL                Init ( void );
    virtual             ~CCNPCoder ();
    virtual	BOOL	Encode (LPVOID                  pdu_structure,
                                int                     pdu_type,
                                UINT                    rules_type,
                                LPBYTE			*encoding_buffer,
                                UINT			*encoding_buffer_length);
    
    virtual BOOL	Decode (LPBYTE			encoded_buffer,
                                UINT			encoded_buffer_length,
                                int                     pdu_type,
                                UINT			rules_type,
                                LPVOID			*decoding_buffer,
                                UINT			*decoding_buffer_length);
    
    virtual void	FreeEncoded (LPBYTE encoded_buffer);
    
    virtual void	FreeDecoded (int pdu_type, LPVOID decoded_buffer);
    
    virtual BOOL     IsMCSDataPacket (	LPBYTE,	UINT		) { return FALSE; };
    
 private:
    //    BOOL    		IsObjectIDCompliant (PKey	t124_identifier);
    ASN1encoding_t  m_pEncInfo;    // ptr to encoder info
    ASN1decoding_t  m_pDecInfo;    // ptr to decoder info
};

typedef CCNPCoder *		PCCNPCoder;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\connect.h ===
/*
 *	connect.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the Connection class.  Instances of
 *		this class are used to connect CommandTarget objects within the local
 *		provider to CommandTarget objects in a remote provider.  This class
 *		inherits from CommandTarget, allowing it to communicate with other
 *		CommandTarget classes using their common MCS command language.
 *
 *		This class can be thought of as providing a Remote Procedure Call (RPC)
 *		facility between CommandTarget objects.  When an MCS command is sent
 *		to a Connection object, it encodes the command as a T.125 Protocol
 *		Data Unit (PDU) and sends it to a remote provider via the transport
 *		services provided by a TransportInterface object.  At the remote side
 *		The PDU is received by a Connection object who decodes the PDU, and
 *		issues the equivalent MCS command to the CommandTarget object that it is
 *		attached to.  The fact that the call crossed a transport connection
 *		in route to its destination is completely transparent to the object
 *		that initiated the command sequence.
 *
 *		The primary responsibility of this class is to convert MCS commands
 *		to T.125 PDUs and back again (as described above).  This class overrides
 *		all of the commands that are defined in class CommandTarget.
 *
 *		A secondary responsibility of this class is to provide flow control
 *		to and from the transport layer.  To do this is keeps a queue of PDUs
 *		that need to be transmitted (actually it keeps 4 queues, one for each
 *		data priority).  During each MCS heartbeat, all Connection objects are
 *		given the opportunity to flush PDUs from the queues.  If the transport
 *		layer returns an error, the PDU in question will be re-tried during
 *		the next heartbeat.  For data coming from the transport layer, this
 *		class provides code to allocate memory.  If an allocation fails, then
 *		an error will be returned to the transport layer, effectively telling
 *		it that it needs to retry that data indication during the next
 *		heartbeat.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	_CONNECTION_
#define	_CONNECTION_

/*
 *	These are the owner callback functions that a Connection object can send to
 *	its creator (which is typically the MCS controller).
 *
 *	When a class uses an instance of the Connection class (or any other class
 *	that can issue owner callbacks), it is accepting the responsibility of
 *	receiving and handling these callbacks.
 *
 *	Each owner callback function, along with a description of how its parameters
 *	are packed, is described in the following section.
 */
#define	DELETE_CONNECTION						0
#define	CONNECT_PROVIDER_CONFIRM				1

typedef	struct
{
	PDomainParameters	domain_parameters;
	Result				result;
	PMemory				memory;
} ConnectConfirmInfo;
typedef	ConnectConfirmInfo *		PConnectConfirmInfo;

/*
 *	Owner Callback:	DELETE_CONNECTION
 *	Parameter1:		PDisconnectProviderIndication
 *											disconnect_provider_indication
 *	Parameter2:		Unused
 *
 *	Usage:
 *		This owner callback will be issued if the Connection detects a situation
 *		is which it is no longer valid.  This can happen for several reasons:
 *		transmission or reception of a ConnectResult with a failed result
 *		code; transmission or reception of a DisconnectProviderUltimatum; or
 *		a Disconnect-Indication from the transport layer.
 */

/*
 *	Owner Callback:	CONNECT_PROVIDER_CONFIRM
 *	Parameter1:		PConnectConfirmInfo		connect_confirm_info
 *	Parameter2:		ConnectionHandle		connection_handle
 *
 *	Usage:
 *		This callback is issued when the connection object completes the
 *		building of a new MCS connection that was locally requested.  This is to
 *		inform the requester that the connection is ready for use.
 */

/*
 *	This enumeration dsefines the various states that a transport connection
 *	can be in at any given time.
 */
typedef	enum
{
	TRANSPORT_CONNECTION_UNASSIGNED,
	TRANSPORT_CONNECTION_PENDING,
	TRANSPORT_CONNECTION_READY
} TransportConnectionState;
typedef	TransportConnectionState *	PTransportConnectionState;


/*
 *	This is the class definition for class CommandTarget.
 */
class Connection : public CAttachment
{
public:

	Connection (
				PDomain				attachment,
				ConnectionHandle	connection_handle,
				GCCConfID          *calling_domain,
				GCCConfID          *called_domain,
				PChar				called_address,
				BOOL				fSecure,
				BOOL    			upward_connection,
				PDomainParameters	domain_parameters,
				PUChar				user_data,
				ULong				user_data_length,
				PMCSError			connection_error);
		Connection (
				PDomain				attachment,
				ConnectionHandle	connection_handle,
				TransportConnection	transport_connection,
				BOOL    			upward_connection,
				PDomainParameters	domain_parameters,
				PDomainParameters	min_domain_parameters,
				PDomainParameters	max_domain_parameters,
				PUChar				user_data,
				ULong				user_data_length,
				PMCSError			connection_error);
		~Connection ();

    void		RegisterTransportConnection (
				TransportConnection	transport_connection,
				Priority			priority);

private:

		Void		ConnectInitial (
							GCCConfID          *calling_domain,
							GCCConfID          *called_domain,
							BOOL    			upward_connection,
							PDomainParameters	domain_parameters,
							PDomainParameters	min_domain_parameters,
							PDomainParameters	max_domain_parameters,
							PUChar				user_data,
							ULong				user_data_length);
		Void		ConnectResponse (
							Result				result,
							PDomainParameters	domain_parameters,
							ConnectID			connect_id,
							PUChar				user_data,
							ULong				user_data_length);
		Void		ConnectAdditional (
							ConnectID			connect_id,
							Priority			priority);
		Void		ConnectResult (
							Result				result,
							Priority			priority);
		ULong		ProcessConnectResponse (
							PConnectResponsePDU	pdu_structure);
		Void		ProcessConnectResult (
							PConnectResultPDU	pdu_structure);
		Void		IssueConnectProviderConfirm (
							Result				result);
		Void		DestroyConnection (
							Reason				reason);
		Void		AssignRemainingTransportConnections ();
    TransportError	CreateTransportConnection (
							LPCTSTR				called_address,
							BOOL				fSecure,
							Priority			priority);
    TransportError	AcceptTransportConnection (
							TransportConnection	transport_connection,
							Priority			priority);
		Void		AdjustDomainParameters (
							PDomainParameters	min_domain_parameters,
							PDomainParameters	max_domain_parameters,
							PDomainParameters	domain_parameters);
		BOOL    	MergeDomainParameters (
							PDomainParameters	min_domain_parameters1,
							PDomainParameters	max_domain_parameters1,
							PDomainParameters	min_domain_parameters2,
							PDomainParameters	max_domain_parameters2);
#ifdef DEBUG
		Void		PrintDomainParameters (
							PDomainParameters	domain_parameters);
#endif // DEBUG

public:

		inline TransportConnection GetTransportConnection (UInt priority)
		{
			return (Transport_Connection[priority]);
		}

		virtual Void		PlumbDomainIndication (
									ULong				height_limit);
		Void		ErectDomainRequest (
									UINT_PTR				height_in_domain,
									ULong				throughput_interval);
		Void		RejectUltimatum (
									Diagnostic			diagnostic,
									PUChar				octet_string_address,
									ULong				octet_string_length);
		Void		MergeChannelsRequest (
									CChannelAttributesList *merge_channel_list,
									CChannelIDList         *purge_channel_list);
		Void		MergeChannelsConfirm (
									CChannelAttributesList *merge_channel_list,
									CChannelIDList         *purge_channel_list);
		virtual	Void		PurgeChannelsIndication (
									CUidList           *purge_user_list,
									CChannelIDList     *purge_channel_list);
		Void		MergeTokensRequest (
									CTokenAttributesList   *merge_token_list,
									CTokenIDList           *purge_token_list);
		Void		MergeTokensConfirm (
									CTokenAttributesList   *merge_token_list,
									CTokenIDList           *purge_token_list);
		virtual	Void		PurgeTokensIndication (
									PDomain             originator,
									CTokenIDList       *purge_token_ids);
		virtual	Void		DisconnectProviderUltimatum (
									Reason				reason);
		Void		AttachUserRequest ( void );
		virtual	Void		AttachUserConfirm (
									Result				result,
									UserID				uidInitiator);
		Void		DetachUserRequest (
									Reason				reason,
									CUidList           *user_id_list);
		virtual	Void		DetachUserIndication (
									Reason				reason,
									CUidList           *user_id_list);
		Void		ChannelJoinRequest (
									UserID				uidInitiator,
									ChannelID			channel_id);
		virtual	Void		ChannelJoinConfirm (
									Result				result,
									UserID				uidInitiator,
									ChannelID			requested_id,
									ChannelID			channel_id);
		Void		ChannelLeaveRequest (
									CChannelIDList     *channel_id_list);
		Void		ChannelConveneRequest (
									UserID				uidInitiator);
		virtual	Void		ChannelConveneConfirm (
									Result				result,
									UserID				uidInitiator,
									ChannelID			channel_id);
		Void		ChannelDisbandRequest (
									UserID				uidInitiator,
									ChannelID			channel_id);
		virtual	Void		ChannelDisbandIndication (
									ChannelID			channel_id);
		Void		ChannelAdmitRequest (
									UserID				uidInitiator,
									ChannelID			channel_id,
									CUidList           *user_id_list);
		virtual	Void		ChannelAdmitIndication (
									UserID				uidInitiator,
									ChannelID			channel_id,
									CUidList           *user_id_list);
		Void		ChannelExpelRequest (
									UserID				uidInitiator,
									ChannelID			channel_id,
									CUidList           *user_id_list);
		virtual	Void		ChannelExpelIndication (
									ChannelID			channel_id,
									CUidList           *user_id_list);
		Void		SendDataRequest ( PDataPacket data_packet )
					{
						QueueForTransmission ((PSimplePacket) data_packet,
											  data_packet->GetPriority());
					};
		virtual	Void		SendDataIndication (
									UINT,
									PDataPacket			data_packet)
								{
									QueueForTransmission ((PSimplePacket) data_packet, 
														  data_packet->GetPriority());
								};
		Void		TokenGrabRequest (
									UserID				uidInitiator,
									TokenID				token_id);
		virtual	Void		TokenGrabConfirm (
									Result				result,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
		Void		TokenInhibitRequest (
									UserID				uidInitiator,
									TokenID				token_id);
		virtual	Void		TokenInhibitConfirm (
									Result				result,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
		Void		TokenGiveRequest (
									PTokenGiveRecord	pTokenGiveRec);
		virtual Void		TokenGiveIndication (
									PTokenGiveRecord	pTokenGiveRec);
		Void		TokenGiveResponse (
									Result				result,
									UserID				receiver_id,
									TokenID				token_id);
		virtual Void		TokenGiveConfirm (
									Result				result,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
		Void		TokenReleaseRequest (
									UserID				uidInitiator,
									TokenID				token_id);
		virtual	Void		TokenReleaseConfirm (
									Result				result,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
		Void		TokenPleaseRequest (
									UserID				uidInitiator,
									TokenID				token_id);
		virtual Void		TokenPleaseIndication (
									UserID				uidInitiator,
									TokenID				token_id);
		Void		TokenTestRequest (
									UserID				uidInitiator,
									TokenID				token_id);
		virtual	Void		TokenTestConfirm (
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
		virtual	Void		MergeDomainIndication (
									MergeStatus			merge_status);

private:

	Void		SendPacket (
						PVoid				pdu_structure,
						int					pdu_type,
						Priority			priority);
	Void		QueueForTransmission (
						PSimplePacket		packet,
						Priority			priority,
						BOOL    			bFlush = TRUE);
	BOOL    	FlushAMessage (
						PSimplePacket		packet,
						Priority			priority);
	Void		MergeChannelsRC (
						ASN1choice_t		choice,
						CChannelAttributesList *merge_channel_list,
						CChannelIDList         *purge_channel_list);
	Void		MergeTokensRC (
						ASN1choice_t		choice,
						CTokenAttributesList   *merge_token_list,
						CTokenIDList           *purge_token_list);
	Void		UserChannelRI (
						ASN1choice_t		choice,
						UINT				reason_userID,
						ChannelID			channel_id,
						CUidList           *user_id_list);

public:

	BOOL    	FlushMessageQueue();
	BOOL    	FlushPriority (
						Priority				priority);
	BOOL    	IsDomainTrafficAllowed() { return Domain_Traffic_Allowed; };

public:

    // the old owner callback
    TransportError  HandleDataIndication(PTransportData, TransportConnection);
    void            HandleBufferEmptyIndication(TransportConnection transport_connection);
    void            HandleConnectConfirm(TransportConnection transport_connection);
    void            HandleDisconnectIndication(TransportConnection transport_connection, ULONG *pnNotify);

    LPSTR       GetCalledAddress(void) { return m_pszCalledAddress; }

private:

	inline ULong	ProcessMergeChannelsRequest (
						PMergeChannelsRequestPDU	pdu_structure);
	inline ULong	ProcessMergeChannelsConfirm (
						PMergeChannelsConfirmPDU	pdu_structure);
	inline Void		ProcessPurgeChannelIndication (
						PPurgeChannelIndicationPDU	pdu_structure);
	inline ULong	ProcessMergeTokensRequest (
						PMergeTokensRequestPDU		pdu_structure);
	inline ULong	ProcessMergeTokensConfirm (
						PMergeTokensConfirmPDU		pdu_structure);
	inline Void		ProcessPurgeTokenIndication (
						PPurgeTokenIndicationPDU	pdu_structure);
	inline Void		ProcessDisconnectProviderUltimatum (
						PDisconnectProviderUltimatumPDU
													pdu_structure);
	inline Void		ProcessAttachUserRequest (
						PAttachUserRequestPDU		pdu_structure);
	inline Void		ProcessAttachUserConfirm (
						PAttachUserConfirmPDU		pdu_structure);
	inline Void		ProcessDetachUserRequest (
						PDetachUserRequestPDU		pdu_structure);
	inline Void		ProcessDetachUserIndication (
						PDetachUserIndicationPDU	pdu_structure);
	inline Void		ProcessChannelJoinRequest (
						PChannelJoinRequestPDU		pdu_structure);
	inline Void		ProcessChannelJoinConfirm (
						PChannelJoinConfirmPDU		pdu_structure);
	inline Void		ProcessChannelLeaveRequest (
						PChannelLeaveRequestPDU		pdu_structure);
	inline Void		ProcessChannelConveneRequest (
						PChannelConveneRequestPDU	pdu_structure);
	inline Void		ProcessChannelConveneConfirm (
						PChannelConveneConfirmPDU	pdu_structure);
	inline Void		ProcessChannelDisbandRequest (
						PChannelDisbandRequestPDU	pdu_structure);
	inline Void		ProcessChannelDisbandIndication (
						PChannelDisbandIndicationPDU
													pdu_structure);
	inline Void		ProcessChannelAdmitRequest (
						PChannelAdmitRequestPDU		pdu_structure);
	inline Void		ProcessChannelAdmitIndication (
						PChannelAdmitIndicationPDU	pdu_structure);
	inline Void		ProcessChannelExpelRequest (
						PChannelExpelRequestPDU		pdu_structure);
	inline Void		ProcessChannelExpelIndication (
						PChannelExpelIndicationPDU	pdu_structure);
	inline Void		ProcessSendDataRequest (
						PSendDataRequestPDU			pdu_structure,
						PDataPacket					packet);
	inline Void		ProcessSendDataIndication (
						PSendDataIndicationPDU		pdu_structure,
						PDataPacket					packet);
	inline Void		ProcessUniformSendDataRequest (
						PUniformSendDataRequestPDU	pdu_structure,
						PDataPacket					packet);
	inline Void		ProcessUniformSendDataIndication (
						PUniformSendDataIndicationPDU
													pdu_structure,
						PDataPacket					packet);
	inline Void		ProcessTokenGrabRequest (
						PTokenGrabRequestPDU		pdu_structure);
	inline Void		ProcessTokenGrabConfirm (
						PTokenGrabConfirmPDU		pdu_structure);
	inline Void		ProcessTokenInhibitRequest (
						PTokenInhibitRequestPDU		pdu_structure);
	inline Void		ProcessTokenInhibitConfirm (
						PTokenInhibitConfirmPDU		pdu_structure);
	inline Void		ProcessTokenReleaseRequest (
						PTokenReleaseRequestPDU		pdu_structure);
	inline Void		ProcessTokenReleaseConfirm (
						PTokenReleaseConfirmPDU		pdu_structure);
	inline Void		ProcessTokenTestRequest (
						PTokenTestRequestPDU		pdu_structure);
	inline Void		ProcessTokenTestConfirm (
						PTokenTestConfirmPDU		pdu_structure);
	inline Void		ProcessRejectUltimatum (
						PRejectUltimatumPDU			pdu_structure);
	inline Void		ProcessTokenGiveRequest (
						PTokenGiveRequestPDU		pdu_structure);
	inline Void		ProcessTokenGiveIndication (
						PTokenGiveIndicationPDU		pdu_structure);
	inline Void		ProcessTokenGiveResponse (
						PTokenGiveResponsePDU		pdu_structure);
	inline Void		ProcessTokenGiveConfirm (
						PTokenGiveConfirmPDU		pdu_structure);
	inline Void		ProcessTokenPleaseRequest (
						PTokenPleaseRequestPDU		pdu_structure);
	inline Void		ProcessTokenPleaseIndication (
						PTokenPleaseIndicationPDU	pdu_structure);
	inline Void		ProcessPlumbDomainIndication (
						PPlumbDomainIndicationPDU	pdu_structure);
	inline Void		ProcessErectDomainRequest (
						PErectDomainRequestPDU		pdu_structure);
	inline ULong 	ValidateConnectionRequest ();

private:

    LPSTR               m_pszCalledAddress;
	UINT        		Encoding_Rules;
	PDomain				m_pDomain;
	PDomain				m_pPendingDomain;
	ConnectionHandle	Connection_Handle;
	DomainParameters	Domain_Parameters;
	PMemory				Connect_Response_Memory;

	TransportConnection	Transport_Connection[MAXIMUM_PRIORITIES];
	int					Transport_Connection_PDU_Type[MAXIMUM_PRIORITIES];
	TransportConnectionState
						Transport_Connection_State[MAXIMUM_PRIORITIES];
	UINT				Transport_Connection_Count;
	CSimplePktQueue		m_OutPktQueue[MAXIMUM_PRIORITIES];

	Reason				Deletion_Reason;
	
	BOOL				Upward_Connection;
	BOOL				m_fSecure;
	BOOL    			Merge_In_Progress;
	BOOL    			Domain_Traffic_Allowed;
	BOOL    			Connect_Provider_Confirm_Pending;
};

/*
 *	ULong	ProcessMergeChannelsRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "MergeChannelsRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline ULong Connection::ProcessMergeChannelsRequest ( 
									PMergeChannelsRequestPDU	pdu_structure)
{
	PChannelAttributes			channel_attributes;
	PSetOfChannelIDs			channel_ids;
	PSetOfUserIDs				user_ids;
	CUidList					admitted_list;
	CChannelAttributesList		merge_channel_list;
	CChannelIDList				purge_channel_list;
	PSetOfPDUChannelAttributes	merge_channels;
	BOOL    					first_set = TRUE;

	/*
	 *	Retrieve values from the decoded PDU structure and fill in the
	 *	parameters lists to be passed into the domain.
	 */
	merge_channels = pdu_structure->merge_channels;
	while (merge_channels != NULL)
	{
		DBG_SAVE_FILE_LINE
		channel_attributes = new ChannelAttributes;

		/*
		 *	Check to make to sure the memory allocation has succeeded.  If
		 *	the memory allocation fails we just return an error code which
		 *	results in the PDU being rejected so that it may be tried again
		 *	at a later time.  If subsequent allocations fail, we must first
		 *	free the memory for the successful allocations and then return.
		 */
		if (channel_attributes == NULL)
		{
			if (first_set)
				return (TRANSPORT_READ_QUEUE_FULL);
			else
			{
				while (NULL != (channel_attributes = merge_channel_list.Get()))
				{
					delete channel_attributes;
				}
				return (TRANSPORT_READ_QUEUE_FULL);
			}
		}

		switch (merge_channels->value.choice)
		{
			case CHANNEL_ATTRIBUTES_STATIC_CHOSEN:
				channel_attributes->channel_type = STATIC_CHANNEL;
				channel_attributes->u.static_channel_attributes.channel_id =
						merge_channels->value.u.
						channel_attributes_static.channel_id;
				break;

			case CHANNEL_ATTRIBUTES_USER_ID_CHOSEN:
				channel_attributes->channel_type = USER_CHANNEL;
				channel_attributes->u.user_channel_attributes.joined =
						merge_channels->value.u.
						channel_attributes_user_id.joined;
				channel_attributes->u.user_channel_attributes.user_id =
						(UShort)merge_channels->value.u.
						channel_attributes_user_id.user_id;
				break;

			case CHANNEL_ATTRIBUTES_PRIVATE_CHOSEN:
				channel_attributes->channel_type = PRIVATE_CHANNEL;
				user_ids = merge_channels->value.u.
						channel_attributes_private.admitted;
				channel_attributes->u.private_channel_attributes.joined =
						merge_channels->value.u.
						channel_attributes_private.joined;
				channel_attributes->u.private_channel_attributes.channel_id=
						(UShort)merge_channels->value.u.
						channel_attributes_private.channel_id;
				channel_attributes->u.private_channel_attributes.
						channel_manager = (UShort)merge_channels->
						value.u.channel_attributes_private.manager;

				/*
				 *	Retrieve all of the user ID's from the PDU structure and
				 *	put them into the list to be passed into the domain.
				 */
				while (user_ids != NULL)
				{
					admitted_list.Append(user_ids->value);
					user_ids = user_ids->next;
				}
				channel_attributes->u.private_channel_attributes.
						admitted_list =	&admitted_list;
				break;

			case CHANNEL_ATTRIBUTES_ASSIGNED_CHOSEN:
				channel_attributes->channel_type = ASSIGNED_CHANNEL;
				channel_attributes->u.assigned_channel_attributes.
						channel_id = (UShort)merge_channels->value.u.
						channel_attributes_assigned.channel_id;
				break;

			default:
				ERROR_OUT(("Connection::ProcessMergeChannelsRequest "
						"Bad channel attributes choice."));
				break;
		}
		/*
		 *	Put the channel attributes structure into the list to be passed
		 *	into the domain.  Retrieve the "next" merge channels structure.
		 */
		merge_channel_list.Append(channel_attributes);
		merge_channels = merge_channels->next;
	}

	/*
	 *	Retrieve all of the purge channel ID's from the PDU structure and
	 *	put them into the list to be passed into the domain.
	 */
	channel_ids = pdu_structure->purge_channel_ids;
	while (channel_ids != NULL)
	{
		purge_channel_list.Append(channel_ids->value);
		channel_ids = channel_ids->next;
	}

	m_pDomain->MergeChannelsRequest(this, &merge_channel_list, &purge_channel_list);

	/*
	 *	Free any memory which was allocated for the channel attributes
	 *	structures by setting up an iterator for the list of channel 
	 *	attributes and freeing the memory associated with each pointer.
	 */
	while (NULL != (channel_attributes = merge_channel_list.Get()))
	{
		delete channel_attributes;
	}
	return (TRANSPORT_NO_ERROR);
}

/*
 *	ULong	ProcessMergeChannelsConfirm()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "MergeChannelsConfirm" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline ULong	Connection::ProcessMergeChannelsConfirm (
									PMergeChannelsConfirmPDU	pdu_structure)
{
	PChannelAttributes			channel_attributes;
	PSetOfChannelIDs			channel_ids;
	PSetOfUserIDs				user_ids;
	CUidList					admitted_list;
	CChannelAttributesList		merge_channel_list;
	CChannelIDList				purge_channel_list;
	PSetOfPDUChannelAttributes	merge_channels;
	BOOL    					first_set = TRUE;

	/*
	 *	Retrieve values from the decoded PDU structure and fill in the
	 *	parameters lists to be passed into the domain.
	 */
	merge_channels = pdu_structure->merge_channels;
	while (merge_channels != NULL)
	{
		DBG_SAVE_FILE_LINE
		channel_attributes = new ChannelAttributes;

		/*
		 *	Check to make to sure the memory allocation has succeeded.  If
		 *	the memory allocation fails we just return an error code which
		 *	results in the PDU being rejected so that it may be tried again
		 *	at a later time.  If subsequent allocations fail, we must first
		 *	free the memory for the successful allocations and then return.
		 */
		if (channel_attributes == NULL)
		{
			if (first_set)
				return (TRANSPORT_READ_QUEUE_FULL);
			else
			{
				while (NULL != (channel_attributes = merge_channel_list.Get()))
				{
					delete channel_attributes;
				}
				return (TRANSPORT_READ_QUEUE_FULL);
			}
		}

		switch (merge_channels->value.choice)
		{
			case CHANNEL_ATTRIBUTES_STATIC_CHOSEN:
					channel_attributes->channel_type = STATIC_CHANNEL;
					channel_attributes->u.static_channel_attributes.channel_id =
							merge_channels->value.u.
							channel_attributes_static.channel_id;
					break;

			case CHANNEL_ATTRIBUTES_USER_ID_CHOSEN:
					channel_attributes->channel_type = USER_CHANNEL;
					channel_attributes->u.user_channel_attributes.joined =
							merge_channels->value.u.
							channel_attributes_user_id.joined;
					channel_attributes->u.user_channel_attributes.user_id =
							(UShort)merge_channels->value.u.
							channel_attributes_user_id.user_id;
					break;

			case CHANNEL_ATTRIBUTES_PRIVATE_CHOSEN:
					channel_attributes->channel_type = PRIVATE_CHANNEL;
					user_ids = merge_channels->value.u.
							channel_attributes_private.admitted;

					channel_attributes->u.private_channel_attributes.joined =
							merge_channels->value.u.
							channel_attributes_private.joined;
					channel_attributes->u.private_channel_attributes.channel_id=
							(UShort)merge_channels->value.u.
							channel_attributes_private.channel_id;
					channel_attributes->u.private_channel_attributes.
							channel_manager = (UShort)merge_channels->
							value.u.channel_attributes_private.manager;

					/*
					 *	Retrieve all of the user ID's from the PDU structure and
					 *	put them into the list to be passed into the domain.
					 */
					while (user_ids != NULL)
					{
						admitted_list.Append(user_ids->value);
						user_ids = user_ids->next;
					}
					channel_attributes->u.private_channel_attributes.
							admitted_list =	&admitted_list;
					break;

			case CHANNEL_ATTRIBUTES_ASSIGNED_CHOSEN:
					channel_attributes->channel_type = ASSIGNED_CHANNEL;
					channel_attributes->u.assigned_channel_attributes.
							channel_id = (UShort)merge_channels->value.u.
							channel_attributes_assigned.channel_id;
					break;

			default:
					ERROR_OUT(("Connection::ProcessMergeChannelsConfirm "
							"Bad channel attributes choice."));
					break;
		}
		/*
		 *	Put the channel attributes structure into the list to be passed
		 *	into the domain.  Retrieve the "next" merge channels structure.
		 */
		merge_channel_list.Append(channel_attributes);
		merge_channels = merge_channels->next;
	}

	/*
	 *	Retrieve all of the purge channel ID's from the PDU structure and
	 *	put them into the list to be passed into the domain.
	 */
	channel_ids = pdu_structure->purge_channel_ids;
	while (channel_ids != NULL)
	{
		purge_channel_list.Append(channel_ids->value);
		channel_ids = channel_ids->next;
	}

	m_pDomain->MergeChannelsConfirm(this, &merge_channel_list, &purge_channel_list);

	/*
	 *	Free any memory which was allocated for the channel attributes
	 *	structures by setting up an iterator for the list of channel 
	 *	attributes and freeing the memory associated with each pointer.
	 */
	while (NULL != (channel_attributes = merge_channel_list.Get()))
	{
		delete channel_attributes;
	}
	return (TRANSPORT_NO_ERROR);
}

/*
 *	Void	ProcessPurgeChannelIndication()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "PurgeChannelsIndication" PDU's being
 *		received through the transport interface.  The pertinent data is read
 *		from the incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessPurgeChannelIndication (
								PPurgeChannelIndicationPDU	 	pdu_structure)
{
	CUidList				purge_user_list;
	CChannelIDList			purge_channel_list;
	PSetOfChannelIDs		channel_ids;
	PSetOfUserIDs	   		user_ids;

	/*
	 *	Retrieve all of the purge user ID's from the PDU structure and put
	 *	them into the list to be passed into the domain.
	 */
	user_ids = pdu_structure->detach_user_ids;

	while (user_ids != NULL)
	{
		purge_user_list.Append(user_ids->value);
		user_ids = user_ids->next;
	}

	/*
	 *	Retrieve all of the purge channel ID's from the PDU structure and
	 *	put them into the list to be passed into the domain.
	 */
	channel_ids = pdu_structure->purge_channel_ids;
	while (channel_ids != NULL)
	{
		purge_channel_list.Append(channel_ids->value);
		channel_ids = channel_ids->next;
	}

	m_pDomain->PurgeChannelsIndication(this, &purge_user_list, &purge_channel_list);
}

/*
 *	ULong	ProcessMergeTokensRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "MergeTokenRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline ULong	Connection::ProcessMergeTokensRequest (
								PMergeTokensRequestPDU			pdu_structure)
{
	PTokenAttributes			token_attributes;
	PSetOfTokenIDs				token_ids;
	PSetOfUserIDs				user_ids;
	CUidList					inhibited_list;
	CTokenAttributesList		merge_token_list;
	CTokenIDList				purge_token_list;
	PSetOfPDUTokenAttributes	merge_tokens;
	BOOL    					first_set = TRUE;

	/*
 	 *	Retrieve values from the decoded PDU structure and fill in the
 	 *	parameters lists to be passed into the domain.
 	 */
	merge_tokens = pdu_structure->merge_tokens;

	while (merge_tokens != NULL)
	{
		DBG_SAVE_FILE_LINE
		token_attributes = new TokenAttributes;

		/*
		 *	Check to make to sure the memory allocation has succeeded.  If
		 *	the memory allocation fails we just return an error code which
		 *	results in the PDU being rejected so that it may be tried again
		 *	at a later time.  If subsequent allocations fail, we must first
		 *	free the memory for the successful allocations and then return.
		 */
		if (token_attributes == NULL)
		{
			if (first_set)
				return (TRANSPORT_READ_QUEUE_FULL);
			else
			{
				while (NULL != (token_attributes = merge_token_list.Get()))
				{
					delete token_attributes;
				}
				return (TRANSPORT_READ_QUEUE_FULL);
			}
		}

		switch (merge_tokens->value.choice)
		{
			case GRABBED_CHOSEN:
					token_attributes->token_state = TOKEN_GRABBED;
					token_attributes->u.grabbed_token_attributes.token_id =
							(UShort)merge_tokens->value.u.
							grabbed.token_id;
					token_attributes->u.grabbed_token_attributes.grabber =
							(UShort)merge_tokens->
							value.u.grabbed.grabber;
				  break;

			case INHIBITED_CHOSEN:
					token_attributes->token_state = TOKEN_INHIBITED;
					user_ids = merge_tokens->value.u.
							inhibited.inhibitors;

					token_attributes->u.inhibited_token_attributes.token_id =
							(UShort)merge_tokens->
							value.u.inhibited.token_id;
					/*
					 *	Retrieve all of the user ID's from the PDU structure and 
					 *	put them into the list to be passed into the domain.
					 */
					while (user_ids != NULL)
					{
						inhibited_list.Append(user_ids->value);
						user_ids= user_ids->next;
					}
					token_attributes->u.inhibited_token_attributes.
							inhibitors = &inhibited_list;
					break;

			case GIVING_CHOSEN:
					token_attributes->token_state = TOKEN_GIVING;
					token_attributes->u.giving_token_attributes.token_id =
							(UShort)merge_tokens->
							value.u.giving.token_id;
					token_attributes->u.giving_token_attributes.grabber =
							(UShort)merge_tokens->
							value.u.giving.grabber;
					token_attributes->u.giving_token_attributes.recipient =
							(UShort)merge_tokens->value.u.giving.
							recipient;
					break;

			case GIVEN_CHOSEN:
					token_attributes->token_state = TOKEN_GIVEN;
					token_attributes->u.given_token_attributes.token_id =
							(UShort)merge_tokens->
							value.u.given.token_id;
					token_attributes->u.given_token_attributes.recipient =
							(UShort)merge_tokens->
							value.u.given.recipient;
					break;

			default:
					ERROR_OUT(("Connection::ProcessMergeTokensRequest "
							"Bad token attributes choice."));
					break;
		}
		/*
		 *	Put the token attributes structure into the list to be passed
		 *	into the domain.  We are only doing one channel attributes 
		 *	structures at a time for now.
		 */
		merge_token_list.Append(token_attributes);
		merge_tokens = merge_tokens->next;
	}

	/*
	 *	Retrieve all of the purge token ID's from the PDU structure and put
	 *	them into the list to be passed into the domain.
	 */
	token_ids = pdu_structure->purge_token_ids;
	while (token_ids != NULL)
	{
		purge_token_list.Append(token_ids->value);
		token_ids = token_ids->next;
	}

	m_pDomain->MergeTokensRequest(this, &merge_token_list, &purge_token_list);

	/*
	 *	Free any memory which was allocated for the token attributes
	 *	structures by setting up an iterator for the list of token 
	 *	attributes and freeing the memory associated with each pointer.
	 */
	while (NULL != (token_attributes = merge_token_list.Get()))
	{
		delete token_attributes;
	}
	return (TRANSPORT_NO_ERROR);
}

/*
 *	ULong	ProcessMergeTokensConfirm()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "MergeTokenConfirm" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline ULong	Connection::ProcessMergeTokensConfirm (
								PMergeTokensConfirmPDU			pdu_structure)
{
	PTokenAttributes			token_attributes;
	PSetOfTokenIDs				token_ids;
	PSetOfUserIDs				user_ids;
	CUidList					inhibited_list;
	CTokenAttributesList		merge_token_list;
	CTokenIDList				purge_token_list;
	PSetOfPDUTokenAttributes	merge_tokens;
	BOOL    					first_set = TRUE;

	/*
 	 *	Retrieve values from the decoded PDU structure and fill in the
 	 *	parameters lists to be passed into the domain.
 	 */
	merge_tokens = pdu_structure->merge_tokens;

	while (merge_tokens != NULL)
	{
		DBG_SAVE_FILE_LINE
		token_attributes = new TokenAttributes;

		/*
		 *	Check to make to sure the memory allocation has succeeded.  If
		 *	the memory allocation fails we just return an error code which
		 *	results in the PDU being rejected so that it may be tried again
		 *	at a later time.  If subsequent allocations fail, we must first
		 *	free the memory for the successful allocations and then return.
		 */
		if (token_attributes == NULL)
		{
			if (first_set)
				return (TRANSPORT_READ_QUEUE_FULL);
			else
			{
				while (NULL != (token_attributes = merge_token_list.Get()))
				{
					delete token_attributes;
				}
				return (TRANSPORT_READ_QUEUE_FULL);
			}
		}

		switch (merge_tokens->value.choice)
		{
			case GRABBED_CHOSEN:
					token_attributes->token_state = TOKEN_GRABBED;
					token_attributes->u.grabbed_token_attributes.token_id =
							(UShort)merge_tokens->value.u.
							grabbed.token_id;
					token_attributes->u.grabbed_token_attributes.grabber =
							(UShort)merge_tokens->
							value.u.grabbed.grabber;
				  break;

			case INHIBITED_CHOSEN:
					token_attributes->token_state = TOKEN_INHIBITED;
					user_ids = merge_tokens->value.u.
							inhibited.inhibitors;

					token_attributes->u.inhibited_token_attributes.token_id =
							(UShort)merge_tokens->
							value.u.inhibited.token_id;
					/*
					 *	Retrieve all of the user ID's from the PDU structure and 
					 *	put them into the list to be passed into the domain.
					 */
					while (user_ids != NULL)
					{
						inhibited_list.Append(user_ids->value);
						user_ids = user_ids->next;
					}
					token_attributes->u.inhibited_token_attributes.
							inhibitors = &inhibited_list;
					break;

			case GIVING_CHOSEN:
					token_attributes->token_state = TOKEN_GIVING;
					token_attributes->u.giving_token_attributes.token_id =
							(UShort)merge_tokens->
							value.u.giving.token_id;
					token_attributes->u.giving_token_attributes.grabber =
							(UShort)merge_tokens->
							value.u.giving.grabber;
					token_attributes->u.giving_token_attributes.recipient =
							(UShort)merge_tokens->value.u.giving.
							recipient;
					break;

			case GIVEN_CHOSEN:
					token_attributes->token_state = TOKEN_GIVEN;
					token_attributes->u.given_token_attributes.token_id =
							(UShort)merge_tokens->
							value.u.given.token_id;
					token_attributes->u.given_token_attributes.recipient =
							(UShort)merge_tokens->
							value.u.given.recipient;
					break;

			default:
					ERROR_OUT(("Connection::ProcessMergeTokensConfirm "
							"Bad token attributes choice."));
					break;
		}
		/*
		 *	Put the token attributes structure into the list to be passed
		 *	into the domain.  We are only doing one channel attributes 
		 *	structures at a time for now.
		 */
		merge_token_list.Append(token_attributes);
		merge_tokens = merge_tokens->next;
	}

	/*
	 *	Retrieve all of the purge token ID's from the PDU structure and put
	 *	them into the list to be passed into the domain.
	 */
	token_ids = pdu_structure->purge_token_ids;
	while (token_ids != NULL)
	{
		purge_token_list.Append(token_ids->value);
		token_ids = token_ids->next;
	}

	m_pDomain->MergeTokensConfirm(this, &merge_token_list, &purge_token_list);

	/*
	 *	Free any memory which was allocated for the token attributes
	 *	structures by setting up an iterator for the list of token 
	 *	attributes and freeing the memory associated with each pointer.
	 */
	while (NULL != (token_attributes = merge_token_list.Get()))
	{
		delete token_attributes;
	}
	return (TRANSPORT_NO_ERROR);
}

/*
 *	Void	ProcessPurgeTokenIndication()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "PurgeTokenIndication" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessPurgeTokenIndication ( 
									PPurgeTokenIndicationPDU	pdu_structure)
{
	PSetOfTokenIDs			token_ids;
	CTokenIDList			purge_token_list;
	
	/*
	 *	Retrieve all of the purge token ID's from the PDU structure and put
	 *	them into the list to be passed into the domain.
	 */
	token_ids = pdu_structure->purge_token_ids;
	while (token_ids != NULL)
	{
		purge_token_list.Append(token_ids->value);
		token_ids = token_ids->next;
	}

	m_pDomain->PurgeTokensIndication(this, &purge_token_list);
}

/*
 *	Void	ProcessDisconnectProviderUltimatum()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "DisconnectProviderUltimatum" PDU's being
 *		received through the transport interface.  The pertinent data is read
 *		from the incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessDisconnectProviderUltimatum (
						PDisconnectProviderUltimatumPDU			pdu_structure)
{
	TRACE_OUT(("Connection::ProcessDisconnectProviderUltimatum: PDU received"));

	m_pDomain->DisconnectProviderUltimatum(this, (Reason)pdu_structure->reason);
	m_pDomain = NULL;
}

/*
 *	Void	ProcessAttachUserRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "AttachUserRequest" PDU's being received
 *		through the transport interface by forwarding the request on to the
 *		domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessAttachUserRequest (PAttachUserRequestPDU)
{
	m_pDomain->AttachUserRequest(this);
}

/*
 *	Void	ProcessAttachUserConfirm()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "AttachUserConfirm" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessAttachUserConfirm (
							PAttachUserConfirmPDU		pdu_structure)
{
	m_pDomain->AttachUserConfirm(this, (Result) pdu_structure->result,
	                                   (UserID) pdu_structure->initiator);
}

/*
 *	Void	ProcessDetachUserRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "DetachUserRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessDetachUserRequest (
								PDetachUserRequestPDU			pdu_structure)
{
	PSetOfUserIDs		user_ids;
	CUidList			user_id_list;

	/*
	 *	Retrieve the user ID's from the PDU structure and put them into the
	 *	list to be passed into the domain.
	 */
	user_ids = pdu_structure->user_ids;
	while (user_ids != NULL)
	{
		user_id_list.Append(user_ids->value);
		user_ids = user_ids->next;
	}

	m_pDomain->DetachUserRequest(this, (Reason) pdu_structure->reason, &user_id_list);
}

/*
 *	Void	ProcessDetachUserIndication()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "DetachUserIndication" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessDetachUserIndication (
									PDetachUserIndicationPDU	pdu_structure)
{
	PSetOfUserIDs		user_ids;
	CUidList			user_id_list;

	/*
	 *	Retrieve the user ID's from the PDU structure and put them into the
	 *	list to be passed into the domain.
	 */
	user_ids = pdu_structure->user_ids;
	while (user_ids != NULL)
	{
		user_id_list.Append(user_ids->value);
		user_ids = user_ids->next;
	}

	m_pDomain->DetachUserIndication(this, (Reason) pdu_structure->reason,
                                          &user_id_list);
}

/*
 *	Void	ProcessChannelJoinRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ChannelJoinRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessChannelJoinRequest (
									PChannelJoinRequestPDU		pdu_structure)
{
	m_pDomain->ChannelJoinRequest(this, (UserID) pdu_structure->initiator,
                                        (ChannelID) pdu_structure->channel_id);
}

/*
 *	Void	ProcessChannelJoinConfirm()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ChannelJoinConfirm" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessChannelJoinConfirm (
									PChannelJoinConfirmPDU		pdu_structure)
{
	m_pDomain->ChannelJoinConfirm(this, (Result) pdu_structure->result,
                                        (UserID) pdu_structure->initiator,
                                        (ChannelID) pdu_structure->requested,
                                        (ChannelID) pdu_structure->join_channel_id);
}

/*
 *	Void	ProcessChannelLeaveRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ChannelLeaveRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessChannelLeaveRequest (
									PChannelLeaveRequestPDU		pdu_structure)
{
	PSetOfChannelIDs		channel_ids;
	CChannelIDList			channel_id_list;

	/*
	 *	Retrieve the channel ID's from the PDU structure and put them into
	 *	the list to be passed into the domain.
	 */
	channel_ids = pdu_structure->channel_ids;
	while (channel_ids != NULL)
	{
		channel_id_list.Append(channel_ids->value);
		channel_ids = channel_ids->next;
	}

	m_pDomain->ChannelLeaveRequest(this, &channel_id_list);
}

/*
 *	Void	ProcessChannelConveneRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ChannelConveneRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessChannelConveneRequest (
									PChannelConveneRequestPDU	pdu_structure)
{
	m_pDomain->ChannelConveneRequest(this, (UserID) pdu_structure->initiator);
}

/*
 *	Void	ProcessChannelConveneConfirm ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ChannelConveneConfirm" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessChannelConveneConfirm (
									PChannelConveneConfirmPDU	pdu_structure)
{
	m_pDomain->ChannelConveneConfirm(this, (Result) pdu_structure->result,
                                           (UserID) pdu_structure->initiator,
                                           (ChannelID) pdu_structure->convene_channel_id);
}

/*
 *	Void	ProcessChannelDisbandRequest ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ChannelDisbandRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessChannelDisbandRequest (
									PChannelDisbandRequestPDU	pdu_structure)
{
	m_pDomain->ChannelDisbandRequest(this, (UserID) pdu_structure->initiator,
                                           (ChannelID) pdu_structure->channel_id);
}

/*
 *	Void	ProcessChannelDisbandIndication ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ChannelDisbandIndication" PDU's being
 *		received through the transport interface.  The pertinent data is read
 *		from the incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessChannelDisbandIndication (
								PChannelDisbandIndicationPDU	pdu_structure)
{
	m_pDomain->ChannelDisbandIndication(this, (ChannelID) pdu_structure->channel_id);
}

/*
 *	Void	ProcessChannelAdmitRequest ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ChannelAdmitRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessChannelAdmitRequest (
									PChannelAdmitRequestPDU		pdu_structure)
{
	PSetOfUserIDs		user_ids;
	CUidList			user_id_list;

	/*
	 *	Retrieve the user ID's from the PDU structure and put them into the
	 *	list to be passed into the domain.
	 */
	user_ids = pdu_structure->user_ids;
	while (user_ids != NULL)
	{
		user_id_list.Append(user_ids->value);
		user_ids = user_ids->next;
	}

	m_pDomain->ChannelAdmitRequest(this, (UserID) pdu_structure->initiator,
                                         (ChannelID) pdu_structure->channel_id,
                                         &user_id_list);
}

/*
 *	Void	ProcessChannelAdmitIndication ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ChannelAdmitIndication" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessChannelAdmitIndication (
								PChannelAdmitIndicationPDU		pdu_structure)
{
	PSetOfUserIDs		user_ids;
	CUidList			user_id_list;

	/*
	 *	Retrieve the user ID's from the PDU structure and put them into the
	 *	list to be passed into the domain.
	 */
	user_ids = pdu_structure->user_ids;
	while (user_ids != NULL)
	{
		user_id_list.Append(user_ids->value);
		user_ids = user_ids->next;
	}

	m_pDomain->ChannelAdmitIndication(this, (UserID) pdu_structure->initiator,
                                            (ChannelID) pdu_structure->channel_id,
                                            &user_id_list);
}

/*
 *	Void	ProcessChannelExpelRequest ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ChannelExpelRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessChannelExpelRequest (
							PChannelExpelRequestPDU				pdu_structure)
{
	PSetOfUserIDs		user_ids;
	CUidList			user_id_list;

	/*
	 *	Retrieve the user ID's from the PDU structure and put them into the
	 *	list to be passed into the domain.
	 */
	user_ids = pdu_structure->user_ids;
	while (user_ids != NULL)
	{
		user_id_list.Append(user_ids->value);
		user_ids = user_ids->next;
	}

	m_pDomain->ChannelExpelRequest(this, (UserID) pdu_structure->initiator,
                                         (ChannelID) pdu_structure->channel_id,
                                         &user_id_list);
}

/*
 *	Void	ProcessChannelExpelIndication ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ChannelExpelIndication" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessChannelExpelIndication (
								PChannelExpelIndicationPDU		pdu_structure)
{
	PSetOfUserIDs		user_ids;
	CUidList			user_id_list;

	/*
	 *	Retrieve the user ID's from the PDU structure and put them into the
	 *	list to be passed into the domain.
	 */
	user_ids = pdu_structure->user_ids;
	while (user_ids != NULL)
	{
		user_id_list.Append(user_ids->value);
		user_ids = user_ids->next;
	}

	m_pDomain->ChannelExpelIndication(this, (ChannelID) pdu_structure->channel_id,
                                            &user_id_list);
}

/*
 *	Void	ProcessSendDataRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "SendDataRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessSendDataRequest (
									PSendDataRequestPDU			pdu_structure,
									PDataPacket					packet)
{	
	m_pDomain->SendDataRequest(this, MCS_SEND_DATA_INDICATION, packet);
}

/*
 *	Void	ProcessSendDataIndication()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "SendDataIndication" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessSendDataIndication (
									PSendDataIndicationPDU		pdu_structure,
									PDataPacket					data_packet)
{	
	m_pDomain->SendDataIndication(this, MCS_SEND_DATA_INDICATION, data_packet);
}

/*
 *	Void	ProcessUniformSendDataRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "UniformSendDataRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessUniformSendDataRequest (
									PUniformSendDataRequestPDU	pdu_structure,
									PDataPacket					packet)
{	
	m_pDomain->SendDataRequest(this, MCS_UNIFORM_SEND_DATA_INDICATION, packet);
}

/*
 *	Void	ProcessUniformSendDataIndication()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "UniformSendDataIndication" PDU's being
 *		received through the transport interface.  The pertinent data is read
 *		from the incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessUniformSendDataIndication (
								PUniformSendDataIndicationPDU	pdu_structure,
								PDataPacket						data_packet)
{	
	m_pDomain->SendDataIndication(this, MCS_UNIFORM_SEND_DATA_INDICATION, data_packet);
}

/*
 *	Void	ProcessTokenGrabRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenGrabRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenGrabRequest (
									PTokenGrabRequestPDU		pdu_structure)
{
	m_pDomain->TokenGrabRequest(this, (UserID) pdu_structure->initiator,
                                      (TokenID) pdu_structure->token_id);
}

/*
 *	Void	ProcessTokenGrabConfirm()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenGrabConfirm" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenGrabConfirm (
									PTokenGrabConfirmPDU		pdu_structure)
{
	m_pDomain->TokenGrabConfirm(this, (Result) pdu_structure->result,
                                      (UserID) pdu_structure->initiator,
                                      (TokenID) pdu_structure->token_id,
                                      (TokenStatus)pdu_structure->token_status);
}

/*
 *	Void	ProcessTokenInhibitRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenInhibitRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenInhibitRequest (
									PTokenInhibitRequestPDU		pdu_structure)
{
	m_pDomain->TokenInhibitRequest(this, (UserID) pdu_structure->initiator,
                                         (TokenID) pdu_structure->token_id);
}

/*
 *	Void	ProcessTokenInhibitConfirm()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenInhibitConfirm" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenInhibitConfirm (
									PTokenInhibitConfirmPDU		pdu_structure)
{
	m_pDomain->TokenInhibitConfirm(this, (Result) pdu_structure->result,
                                         (UserID) pdu_structure->initiator,
                                         (TokenID) pdu_structure->token_id,
                                         (TokenStatus)pdu_structure->token_status);
}

/*
 *	Void	ProcessTokenReleaseRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenReleaseRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenReleaseRequest (
									PTokenReleaseRequestPDU		pdu_structure)
{
	m_pDomain->TokenReleaseRequest(this, (UserID) pdu_structure->initiator,
                                         (TokenID) pdu_structure->token_id);
}

/*
 *	Void	ProcessTokenReleaseConfirm()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenReleaseConfirm" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenReleaseConfirm (
									PTokenReleaseConfirmPDU		pdu_structure)
{
	m_pDomain->TokenReleaseConfirm(this, (Result) pdu_structure->result,
                                         (UserID) pdu_structure->initiator,
                                         (TokenID) pdu_structure->token_id,
                                         (TokenStatus)pdu_structure->token_status);
}

/*
 *	Void	ProcessTokenTestRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenTestRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenTestRequest (
									PTokenTestRequestPDU		pdu_structure)
{
	m_pDomain->TokenTestRequest(this, (UserID) pdu_structure->initiator,
                                      (TokenID) pdu_structure->token_id);
}

/*
 *	Void	ProcessTokenTestConfirm()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenTestConfirm" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenTestConfirm (
									PTokenTestConfirmPDU		pdu_structure)
{
	m_pDomain->TokenTestConfirm(this, (UserID) pdu_structure->initiator,
                                      (TokenID) pdu_structure->token_id,
                                      (TokenStatus)pdu_structure->token_status);
}

/*
 *	Void	ProcessRejectUltimatum()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "RejectUltimatum" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessRejectUltimatum (
									PRejectUltimatumPDU			pdu_structure)
{
	m_pDomain->RejectUltimatum(this,
				pdu_structure->diagnostic,
				pdu_structure->initial_octets.value,
				(ULong) pdu_structure->initial_octets.length);
}

/*
 *	Void	ProcessTokenGiveRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenGiveRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenGiveRequest (
									PTokenGiveRequestPDU		pdu_structure)
{
		TokenGiveRecord		TokenGiveRec;

	// Fill in the TokenGive record
	TokenGiveRec.uidInitiator = pdu_structure->initiator;
	TokenGiveRec.token_id = pdu_structure->token_id;
	TokenGiveRec.receiver_id = pdu_structure->recipient;
	m_pDomain->TokenGiveRequest(this, &TokenGiveRec);
}

/*
 *	Void	ProcessTokenGiveIndication()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenGiveIndication" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenGiveIndication (
									PTokenGiveIndicationPDU		pdu_structure)
{
		TokenGiveRecord		TokenGiveRec;

	// Fill in the TokenGive record
	TokenGiveRec.uidInitiator = pdu_structure->initiator;
	TokenGiveRec.token_id = pdu_structure->token_id;
	TokenGiveRec.receiver_id = pdu_structure->recipient;
	m_pDomain->TokenGiveIndication(this, &TokenGiveRec);
}

/*
 *	Void	ProcessTokenGiveResponse()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenGiveResponse" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenGiveResponse (
									PTokenGiveResponsePDU		pdu_structure)
{
	m_pDomain->TokenGiveResponse(this, (Result) pdu_structure->result,
                                       (UserID) pdu_structure->recipient,
                                       (TokenID) pdu_structure->token_id);
}

/*
 *	Void	ProcessTokenGiveConfirm()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenGiveConfirm" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenGiveConfirm (
									PTokenGiveConfirmPDU		pdu_structure)
{
	m_pDomain->TokenGiveConfirm(this, (Result) pdu_structure->result,
                                      (UserID) pdu_structure->initiator,
                                      (TokenID) pdu_structure->token_id,
                                      (TokenStatus)pdu_structure->token_status);
}

/*
 *	Void	ProcessTokenPleaseRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenPleaseRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenPleaseRequest (
									PTokenPleaseRequestPDU		pdu_structure)
{
	m_pDomain->TokenPleaseRequest(this, (UserID) pdu_structure->initiator,
                                        (TokenID) pdu_structure->token_id);
}

/*
 *	Void	ProcessTokenPleaseIndication()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenPleaseIndication" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenPleaseIndication (
									PTokenPleaseIndicationPDU	pdu_structure)
{
	m_pDomain->TokenPleaseIndication(this, (UserID) pdu_structure->initiator,
                                           (TokenID) pdu_structure->token_id);
}

/*
 *	Void	ProcessPlumbDomainIndication()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "PlumbDomainIndication" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessPlumbDomainIndication (
									PPlumbDomainIndicationPDU	pdu_structure)
{
	m_pDomain->PlumbDomainIndication(this, pdu_structure->height_limit);
}

/*
 *	Void	ProcessErectDomainRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ErectDomainRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessErectDomainRequest (
									PErectDomainRequestPDU		pdu_structure)
{
	m_pDomain->ErectDomainRequest(this, pdu_structure->sub_height,
                                        pdu_structure->sub_interval);
}

/*
 *	ULong	ValidateConnectionRequest ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is used to determine if it is valid to process an incoming
 *		request at the current time.  It checks several different conditions
 *		to determine this, as follows:
 *
 *		- If there is a merge in progress, then the request is not valid.
 *		- If this MCS connection is not yet bound to a domain, then the request
 *		  is not valid.
 *		- If there are not enough objects of the Memory, Packet, or UserMessage
 *		  class to handle a reasonable request, then the request is not valid.
 *
 *		Note that the check on number of objects is not an absolute guarantee
 *		that there will be enough to handle a given request, because a request
 *		can result in MANY PDUs and user messages being generated.  For example,
 *		a single channel admit request can result in lots of channel admit
 *		indications being sent.  However, checking against a minimum number
 *		of objects can reduce the possibility of failure to be astronomically
 *		low.  And remember, even if MCS runs out of something while processing
 *		such a request, it WILL handle it properly (by cleanly destroying the
 *		user attachment or MCS connection upon which the failure occurred).  So
 *		there is no chance of MCS crashing as a result of this.
 *
 *	Caveats:
 *		None.
 */
inline ULong	Connection::ValidateConnectionRequest ()
{
	ULong				return_value;

	/*
	 *	Check to see if there is a domain merger in progress.
	 */
	if (Merge_In_Progress == FALSE)
	{
		/*
		 *	Make sure that this MCS connection is bound to a domain.
		 */
		if (m_pDomain != NULL)
		{
			/*
			 *	Everything is okay, so the request is to be permitted.
			 */
			return_value = TRANSPORT_NO_ERROR;
		}
		else
		{
			/*
			 *	We are not yet attached to a domain.
			 */
			TRACE_OUT (("Connection::ValidateConnectionRequest: "
					"not attached to a domain"));
			return_value = TRANSPORT_READ_QUEUE_FULL;
		}
	}
	else
	{
		/*
		 *	There is a domain merge in progress.
		 */
		WARNING_OUT (("Connection::ValidateConnectionRequest: "
				"domain merger in progress"));
		return_value = TRANSPORT_READ_QUEUE_FULL;
	}

	return (return_value);
}

/*
 *	Connection (
 *				PCommandTarget		attachment,
 *				ConnectionHandle	connection_handle,
 *				PUChar				calling_domain,
 *				UINT				calling_domain_length,
 *				PUChar				called_domain,
 *				UINT				called_domain_length,
 *				PChar				calling_address,
 *				PChar				called_address,
 *				BOOL    			upward_connection,
 *				PDomainParameters	domain_parameters,
 *				PUChar				user_data,
 *				ULong				user_data_length,
 *				PMCSError			connection_error)
 *
 *	Functional Description:
 *		This is a constructor for the Connection class.  This constructor
 *		is used for creating outbound connections.  It initializes private
 *		instance variables and calls the transport interface to set up a
 *		transport connection and register this connection object (through a
 *		callback structure) with the transport object.
 *
 *	Formal Parameters:
 *		packet_coder
 *			This is the coder which is used by the connection object to encode
 *			PDU's into, and decode PDU's from, ASN.1 compliant byte streams.
 *		attachment
 *			The Domain to which this connection object is attached.
 *		connection_handle
 *			The handle which uniquely identifies this connection object.
 *		owner_object
 *			This is a pointer to the owner of this connection object (typically
 *			the MCS Controller) which allows this connection to communicate with
 *			the owner through callbacks. 
 *		owner_message_base
 *			This is the base value to which offsets are added to identify which
 *			callback routine in the owner object this connection is calling.
 *		calling_domain
 *			This is a pointer to an ASCII string which contains the name of the
 *			domain to which this connection object is attached.
 *		calling_domain_length
 *			The length of the ASCII string which is the name of domain to which
 *			this connection object is attached.
 *		called_domain
 *			This is a pointer to an ASCII string which contains the name of the
 *			remote domain with which this connection will communicate.
 *		called_domain_length
 *			The length of the ASCII string which is the name of the remote
 *			domain.
 *		calling_address
 *			The transport address of the caller.
 *		called_address
 *			The transport address of the party being called.
 *		upward_connection
 *			This is a boolean flag which indicates whether this is an upward
 *			connection or a downward connection.
 *		domain_parameters
 *			This is the set of parameters which describes the local domain.
 *		user_data
 *			This is a pointer to a buffer containing data which is sent to the
 *			remote provider through the "ConnectInitial" PDU.
 *		user_data_length
 *			The length of the user data described above.
 *		connection_error
 *			A return parameter which indicates any errors which may have 
 *			occurred in construction of the connection object.
 *
 *	Return Value:
 *		MCS_NO_ERROR			The connection was created successfully.
 *		MCS_TRANSPORT_FAILED	An error occurred in creating the transport
 *									connection.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Connection (
 *				PCommandTarget		attachment,
 *				ConnectionHandle	connection_handle,
 *				TransportConnection	transport_connection,
 *				BOOL    			upward_connection,
 *				PDomainParameters	domain_parameters,
 *				PDomainParameters	min_domain_parameters,
 *				PDomainParameters	max_domain_parameters,
 *				PUChar				user_data,
 *				ULong				user_data_length,
 *				PMCSError			connection_error)
 *
 *	Functional Description:
 *		This is a constructor for the Connection class.  This constructor is 
 *		used for creating inbound connections and is called when a transport
 *		connection already exists.  It initializes private instance variables
 *		and calls the transport interface to register this connection object 
 *		(through a callback structure) with the transport object.
 *
 *	Formal Parameters:
 *		attachment
 *			The Domain to which this connection object is attached.
 *		connection_handle
 *			The handle which uniquely identifies this connection object.
 *		owner_object
 *			This is a pointer to the owner of this connection object (typically
 *			the MCS Controller) which allows this connection to communicate with
 *			the owner through callbacks. 
 *		owner_message_base
 *			This is the base value to which offsets are added to identify which
 *			callback routine in the owner object this connection is calling.
 *		transport_connection
 *			This is the object used by this connection to communicate with the
 *			transport layer.
 *		upward_connection
 *			This is a boolean flag which indicates whether this is an upward
 *			connection or a downward connection.
 *		domain_parameters
 *			This is the set of parameters which describes the local domain.
 *		min_domain_parameters
 *			This is the set of parameters which describes the minimum
 *			permissable values for local domain parameters.
 *		max_domain_parameters
 *			This is the set of parameters which describes the maximum
 *			permissable values for local domain parameters.
 *		user_data
 *			This is a pointer to a buffer containing data which is sent to the
 *			remote provider through the "ConnectInitial" PDU.
 *		user_data_length
 *			The length of the user data described above.
 *		connection_error
 *			A return parameter which indicates any errors which may have 
 *			occurred in construction of the connection object.
 *
 *	Return Value:
 *		MCS_NO_ERROR			
 *			The connection was created successfully.
 *		MCS_TRANSPORT_FAILED	
 *			An error occurred in accepting the transport connection.
 *		MCS_BAD_DOMAIN_PARAMETERS
 *			There was no acceptable overlap between the local and remote
 *			domain parameters.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~Connection ()
 *
 *	Functional Description:
 *		This is the destructor for the Connection class.  If no connection
 *		deletion is pending, it terminates the current connection by issuing
 *		a DisconnectProviderUltimatum to the domain, transmitting a
 *		"DISCONNECT_PROVIDER_ULTIMATUM" PDU, and issuing a DisconnectRequest
 *		to the transport interface.  The destructor also clears the transmission
 *		queue and frees any allocated memory.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	void		RegisterTransportConnection ()
 *
 *	Functional Description:
 *		This routine is called in order to register the transport connection
 *		with the connection object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void		PlumbDomainIndication (
 *						PCommandTarget		originator,
 *						ULong				height_limit)
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"PlumbDomainIndication" PDU through the transport interface.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		height_limit
 *			This is the number of connections between this user and the
 *			top provider.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ErectDomainRequest (
 *						PCommandTarget		originator,
 *						ULong				height_in_domain,
 *						ULong				throughput_interval)
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"ErectDomainRequest" PDU through the transport interface.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		height_in_domain
 *			This is the number of connections between this user and the
 *			top provider.
 *		throughput_interval
 *			The minimum number of octets per second required.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		RejectUltimatum (
 *						PCommandTarget		originator,
 *						Diagnostic			diagnostic,
 *						PUChar				octet_string_address,
 *						ULong				octet_string_length)
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"RejectUltimatum" PDU through the transport interface.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		diagnostic
 *			An enumeration indicating the reason for this reject.
 *		octet_string_address
 *			A pointer to the PDU data which resulted in the reject.
 *		octet_string_length
 *			The length of the PDU data which resulted in the reject.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	MergeChannelsRequest (
 *					PCommandTarget			originator,
 *					CChannelAttributesList *merge_channel_list,
 *					CChannelIDList         *purge_channel_list)
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"MergeChannelsRequest" PDU through the transport interface.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		merge_channel_list
 *			This is a list of attributes describing the channels which are to
 *			be merged.
 *		purge_channel_list
 *			This is a list of ID's for the channels that are to be purged.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	MergeChannelsConfirm (
 *					PCommandTarget			originator,
 *					CChannelAttributesList *merge_channel_list,
 *					CChannelIDList         *purge_channel_list)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		MergeChannelConfirm command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		merge_channel_list
 *			This is a list of attributes describing the channels which are to
 *			be merged.
 *		purge_channel_list
 *			This is a list of ID's for the channels that are to be purged.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	PurgeChannelsIndication (
 *					PCommandTarget		originator,
 *					CUidList           *purge_user_list,
 *					CChannelIDList     *purge_channel_list)
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"PurgeChannelsIndication" PDU through the transport interface.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		purge_user_list
 *			This is a list of IDs of the users being purged.
 *		purge_channel_list
 *			This is a list of IDs of the channels being purged.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	MergeTokensRequest (
 *					PCommandTarget			originator,
 *					CTokenAttributesList   *merge_token_list,
 *					CTokenIDList           *purge_token_list)
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"MergeTokensRequest" PDU through the transport interface.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		merge_token_list
 *			This is a list of attributes describing the tokens which are to
 *			be merged.
 *		purge_token_list
 *			This is a list of ID's for the tokens that are to be purged.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	MergeTokensConfirm (
 *					PCommandTarget			originator,
 *					CTokenAttributesList   *merge_token_list,
 *					CTokenIDList           *purge_token_list)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		MergeTokensConfirm command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		merge_token_list
 *			This is a list of attributes describing the tokens which are to
 *			be merged.
 *		purge_token_list
 *			This is a list of ID's for the tokens that are to be purged.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	PurgeTokensIndication (
 *					PCommandTarget		originator,
 *					CTokenIDList       *purge_token_ids)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		PurgeTokenIndication command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		purge_token_ids
 *			This is a list of ID's for the tokens that are to be purged.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	DisconnectProviderUltimatum (
 *					PCommandTarget		originator,
 *					Reason				reason)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		DisconnectProviderUltimatum command to the remote attachment.  Note
 *		that this command automatically causes this Connection object to
 *		destroy itself.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		reason
 *			The reason for the diconnect.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	AttachUserRequest (
 *					PCommandTarget		originator)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		AttachUserRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	AttachUserConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		AttachUserConfirm command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		result
 *			The result of the attach request.
 *		uidInitiator
 *			If the result was successful, this will contain the unique user
 *			ID to be associated with this user.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	DetachUserRequest (
 *					PCommandTarget		originator,
 *					Reason				reason,
 *					UserID				user_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		DetachUserRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		reason
 *			This is the reason for the detachment.
 *		user_id
 *			The ID of the user who wishes to detach.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	DetachUserIndication (
 *					PCommandTarget		originator,
 *					Reason				reason,
 *					UserID				user_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		DetachUserIndication command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		reason
 *			The reason for the detachment.
 *		user_id
 *			The ID of the user who has detached.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelJoinRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		ChannelJoinRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			The ID of the user who initiated the request.
 *		channel_id
 *			The ID of the channel to be joined.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelJoinConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					ChannelID			requested_id,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		ChannelJoinConfirm command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		result
 *			The result of the join request.
 *		uidInitiator
 *			The ID of the user who initiated the request.
 *		requested_id
 *			This ID of the channel that the user attempted to join (which may
 *			be 0).
 *		channel_id
 *			The ID of the channel being joined.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelLeaveRequest (
 *					PCommandTarget		originator,
 *					CChannelIDList     *channel_id_list)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		ChannelLeaveRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		channel_id_list
 *			The list of IDs of the channels to be left.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelConveneRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		ChannelConveneRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			This is the ID of the user who is trying to convene a private
 *			channel.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelConveneConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		ChannelConveneConfirm command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		result
 *			This is the result of the previously requested convene operation.
 *		uidInitiator
 *			This is the ID of the user who tried to convene a new channel.
 *		channel_id
 *			If the request was successful, this is the ID of the newly created
 *			private channel.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelDisbandRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		ChannelDisbandRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			This is the ID of the user who is trying to disband a private
 *			channel.
 *		channel_id
 *			This is the ID of the channel being disbanded.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelDisbandIndication (
 *					PCommandTarget		originator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		ChannelDisbandIndication command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		channel_id
 *			This is the ID of the channel being disbanded.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelAdmitRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		ChannelAdmitRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			This is the ID of the user who is trying to admit some users to
 *			a private channel.
 *		channel_id
 *			This is the ID of the channel to be affected.
 *		user_id_list
 *			This is a container holding the IDs of the users to be admitted.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelAdmitIndication (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		ChannelAdmitIndication command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			This is the ID of the user who is trying to admit some users to
 *			a private channel.
 *		channel_id
 *			This is the ID of the channel to be affected.
 *		user_id_list
 *			This is a container holding the IDs of the users to be admitted.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelExpelRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		ChannelExpelRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			This is the ID of the user who is trying to expel some users from
 *			a private channel.
 *		channel_id
 *			This is the ID of the channel to be affected.
 *		user_id_list
 *			This is a container holding the IDs of the users to be expelled.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelExpelIndication (
 *					PCommandTarget		originator,
 *					ChannelID			channel_id,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		ChannelExpelIndication command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		channel_id
 *			This is the ID of the channel to be affected.
 *		user_id_list
 *			This is a container holding the IDs of the users to be expelled.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	SendDataRequest (
 *					PCommandTarget		originator,
 *					UINT				type,
					PDataPacket			data_packet)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		SendDataRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		type (i)
 *			Normal or uniform send data request
 *		pDataPacket (i)
 *			This is a pointer to a DataPacket object containing the channel
 *			ID, the User ID of the data sender, segmentation flags, priority of
 *			the data packet and a pointer to the packet to be sent.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	SendDataIndication (
 *					PCommandTarget		originator,
 *					UINT				type,
 *					PDataPacket			data_packet)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		SendDataIndication command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		type (i)
 *			normal or uniform data indication
 *		data_packet (i)
 *			This is a pointer to a DataPacket object containing the channel
 *			ID, the User ID of the data sender, segmentation flags, priority of
 *			the data packet and a pointer to the packet to be sent.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGrabRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenGrabRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			The ID of the user attempting to grab the token.
 *		token_id
 *			The ID of the token being grabbed.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGrabConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenGrabConfirm command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		result
 *			The result of the grab operation.
 *		uidInitiator
 *			The ID of the user attempting to grab the token.
 *		token_id
 *			The ID of the token being grabbed.
 *		token_status
 *			The status of the token after processing the request.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenInhibitRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenInhibitRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			The ID of the user attempting to inhibit the token.
 *		token_id
 *			The ID of the token being inhibited.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenInhibitConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenInhibitConfirm command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		result
 *			The result of the inhibit operation.
 *		uidInitiator
 *			The ID of the user attempting to inhibit the token.
 *		token_id
 *			The ID of the token being inhibited.
 *		token_status
 *			The status of the token after processing the request.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGiveRequest (
 *					PCommandTarget		originator,
 *					PTokenGiveRecord	pTokenGiveRec)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenGiveRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		pTokenGiveRec (i)
 *			This is the address of a structure containing the following information:
 *			The ID of the user attempting to give away the token.
 *			The ID of the token being given.
 *			The ID of the user that the token is being given to.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGiveIndication (
 *					PCommandTarget		originator,
 *					PTokenGiveRecord	pTokenGiveRec)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenGiveIndication command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		pTokenGiveRec (i)
 *			This is the address of a structure containing the following information:
 *			The ID of the user attempting to give away the token.
 *			The ID of the token being given.
 *			The ID of the user that the token is being given to.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGiveResponse (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				receiver_id,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenGiveResponse command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		result
 *			The result of the give operation.
 *		receiver_id
 *			The ID of the user being given the token.
 *		token_id
 *			The ID of the token being given.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGiveConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenGiveConfirm command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		result
 *			The result of the give operation.
 *		uidInitiator
 *			The ID of the user being given the token.
 *		token_id
 *			The ID of the token being given.
 *		token_status
 *			The status of the token after processing the request.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenReleaseRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenReleaseRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			The ID of the user attempting to release the token.
 *		token_id
 *			The ID of the token being released.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenReleaseConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenReleaseConfirm command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		result
 *			The result of the release operation.
 *		uidInitiator
 *			The ID of the user attempting to release the token.
 *		token_id
 *			The ID of the token being released.
 *		token_status
 *			The status of the token after processing the request.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenPleaseRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenPleaseRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			The ID of the user requesting the token.
 *		token_id
 *			The ID of the token being requested.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenPleaseIndication (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenPleaseIndication command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			The ID of the user requesting the token.
 *		token_id
 *			The ID of the token being requested.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenTestRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenTestRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			The ID of the user testing the token.
 *		token_id
 *			The ID of the token being tested.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenTestConfirm (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenTestConfirm command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			The ID of the user testing the token.
 *		token_id
 *			The ID of the token being tested.
 *		token_status
 *			The status of the token after processing the request.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	MergeDomainIndication (
 *					PCommandTarget		originator,
 *					MergeStatus			merge_status)
 *
 *	Functional Description:
 *		This command is received when a domain enters or leaves the domain merge
 *		state.  When in a domain merge state, NO commands are to be sent to
 *		the Domain object.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		merge_status
 *			This is the current status of the domain merge.  It indicates
 *			whether the merge is active, or just completed.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		All command traffic to the Domain object must halt when the domain is
 *		in the merge state.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	FlushMessageQueue()
 *
 *	Functional Description:
 *		This function is called by the controller during the MCS heartbeat to
 *		allow it to flush its output buffers.  If there is any data waiting
 *		to be transmitted (at any priority), the Connection object will attempt
 *		to send it at this time.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	ULong		OwnerCallback (
 *						unsigned int		message,
 *						PVoid				parameter1,
 						TransportConnection	transport_connection)
 *
 *	Functional Description:
 *		This function is used to receive owner callbacks from the Transport
 *		Interface object.  Connection objects sends data and requests to
 *		the Transport Interface object through its public interface, but it
 *		receives data and indications through this owner callback.  For a more
 *		complete description of the callbacks, and how the parameter for each
 *		one are packed, see the interface file for the class TransportInterface
 *		(since it is this class that originates the callbacks).
 *
 *	Formal Parameters:
 *		message
 *			This is the message to be processed.  These are defined in the
 *			interface file of the class issuing the callbacks.
 *		parameter1
 *			The meaning of this parameter varies according to the message
 *			being processed.
 *		transport_connection
 *			The transport connection on which the callback applies.
 *
 *	Return Value:
 *		The meaning of the return value varies according to the message being
 *		processed.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\control.h ===
/*
 *	control.h
 *
 *	Copyright (c) 1993 - 1996 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the MCS Controller class.  There will
 *		be exactly one instance of this class at run-time, whose job it is
 *		to coordinate the creation, deletion, and linking of other objects
 *		in the system.
 *
 *		The controller is primarily responsible for managing five "layers"
 *		of objects in the system at run-time.  These layers can be depicted
 *		as follows:
 *
 *		+---+       +------------------------+
 *		|   | <---> | Application Interfaces |
 *		|   |       +------------------------+
 *		|   |                   |
 *		| C |       +------------------------+
 *		| o | <---> |    User Attachments    |
 *		| n |       +------------------------+
 *		| t |                   |
 *		| r |       +------------------------+
 *		| o | <---> |        Domains         |
 *		| l |       +------------------------+
 *		| l |                   |
 *		| e |       +------------------------+
 *		| r | <---> |    MCS Connections     |
 *		|   |       +------------------------+
 *		|   |                   |
 *		|   |       +------------------------+
 *		|   | <---> |  Transport Interfaces  |
 *		+---+       +------------------------+
 *
 *		The controller is the first object created in the MCS system.  It is
 *		responsible for creating all other objects during initialization.  In
 *		the constructor, the controller creates all necessary application
 *		interface and transport interface objects.  These are the objects
 *		through which MCS communicates with the outside world.  They are
 *		static in that they live throughout the lifetime of MCS itself.
 *
 *		During initialization, the node controller must register itself with
 *		the controller so that the controller knows which application interface
 *		object to use when issuing indications and confirms back to the node
 *		controller.  Note that even though it is possible to have more than
 *		one way to communicate with applications, there is still only one node
 *		controller.
 *
 *		Four of the five layers of objects communicate with the controller
 *		through the owner callback facility.  This mechanism is used to send
 *		requests to the controller.
 *
 *		User attachments (instances of class User) are created when the
 *		controller receives an AttachUserRequest from one of the application
 *		interface objects (with a valid domain selector).  A new user object
 *		is created, who in turn registers with the correct application interface
 *		object to insure proper data flow at run-time.
 *
 *		Domains (instances of class Domain) are created when the controller
 *		receives a CreateDomain from one of the application interface objects.
 *		Since both user attachments and MCS connections identify specific
 *		domains, this must occur before any attaching or connecting can be
 *		done.
 *
 *		MCS connections (instances of class Connection) are created in two
 *		possible ways.  First, when a ConnectProviderRequest is received from
 *		one of the application interface objects (with a valid local domain
 *		selector and a valid transport address).  Second, when a
 *		ConnectProviderResponse is received from one of the application
 *		interface objects in response to a previous connect provider indication.
 *		Either way, a Connection object is created to represent the new MCS
 *		connection.
 *
 *		User attachments are deleted in one of two ways.  First, when a
 *		DetachUserRequest is received from an application interface with a
 *		valid user handle.  Second, if the user attachment is told by the
 *		domain that the attachment is severed.  In the latter case, the user
 *		object asks the controller to delete it using the owner callback
 *		facility.
 *
 *		Domains are deleted when a DeleteDomain is received from an application
 *		interface.
 *
 *		Connections are deleted in one of three ways.  First, when a
 *		DisconnectProviderRequest is received from an application interface
 *		with a valid connection handle.  Second, if the transport interface
 *		detects a loss of the connection at a lower layer.  Third, if the
 *		connection is told by the domain that the connection is to be severed.
 *		In the latter two cases, the connection object asks the controller to
 *		delete it using the owner callback facility.
 *
 *		The primary role of the controller is to create and delete all of these
 *		objects, and to "plug" them together as needed.
 *
 *		During initialization, the controller also creates a single instance
 *		of a memory manager.  This objects is then passed on to all other
 *		objects that require its services (in their constructors).  A possible
 *		way to improve upon this scheme would be to create a memory manager
 *		for each domain, so that traffic in one domain does not influence
 *		traffic in another.
 *
 *	Portable:
 *		Not completely.  During initialization, the constructor "knows"
 *		how to create application interface and transport interface objects
 *		that are specific to the environment.  In the case of the transport
 *		interfaces, it actually reads a windows ".INI" file.  It can also
 *		optionally allocate a windows timer in order have a "heartbeat".  Other
 *		than initialization, everything else is portable.
 *
 *	Caveats:
 *		There can be only one instance of this class in an MCS provider.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	_CONTROLLER_
#define	_CONTROLLER_

/*
 *	Include files.
 */
#include "omcscode.h"

/*
 *	This structure is used to hold information about an incoming connection,
 *	while MCS waits for a connect provider response from the node controller.
 */
typedef	struct
{
	TransportConnection		transport_connection;
	BOOL    				upward_connection;
	DomainParameters		domain_parameters;
	DomainParameters		minimum_domain_parameters;
	DomainParameters		maximum_domain_parameters;
} ConnectionPending;
typedef	ConnectionPending *				PConnectionPending;

/*
 *	This is the set of container definitions defined using templates.  All
 *	containers are based on classes in the Rogue Wave Tools.h++ class
 *	library.
 *
 *	The controller keeps a list of objects at each of the five levels, as
 *	follows:
 *
 *	DomainList
 *		This is a dictionary of currently existing domain objects, which is
 *		keyed by DomainSelector.
 *	CConnectionList2
 *		This is a dictionary of currently existing connection objects, which is
 *		keyed by connection handle.
 *	TransportList
 *		This is a dictionary of currently existing transport interface objects,
 *		which is keyed by transport identifier.  Note that the transport
 *		identifier is just a character string.
 *	ConnectionPendingList
 *		This is a dictionary of pending connections.  The key is the connection
 *		handle, and the value is a pointer to a connection pending structure
 *		that "remembers" details about a pending connection that are not
 *		going to be passed back in the connect provider response.
 *	ConnectionPollList
 *		This is a singly-linked list that is used to hold all connection
 *		objects.  This list is used to iterate through the list, granting a time
 *		slice to each object during the heartbeat.
 */
class CConnPendingList2 : public CList2
{
    DEFINE_CLIST2_(CConnPendingList2, PConnectionPending, ConnectionHandle)
};

class CConnPollList : public CList
{
    DEFINE_CLIST(CConnPollList, PConnection)
};

/*
 *	The controller makes extensive use of the owner callback mechanism to
 *	receive requests from the objects that it owns.  In order for the
 *	requests to be differentiated here in the controller, each object must
 *	issue its message using a different message offset.  The required message
 *	offset is given to each object as it is created by the controller.  The
 *	message offsets for the five layers of objects are as follows.
 *
 *	This allows the controller to easily determine what type of object a
 *	given owner callback message is from (see the implementation of the
 *	OwnerCallback member function for details).
 */
#define	APPLICATION_MESSAGE_BASE		0
#define	USER_MESSAGE_BASE				100
#define	DOMAIN_MESSAGE_BASE				200
#define	CONNECTION_MESSAGE_BASE			300
#ifndef TRANSPORT_MESSAGE_BASE
#define	TRANSPORT_MESSAGE_BASE			400
#endif  // !TRANSPORT_MESSAGE_BASE

/*
**	The following are timeout times that are used to set and test the
**	Controller_Wait_Timeout instance variable of a Controller object.
**	When the controller is signalled thru an event to process and send
**	msgs to an application, GCC, etc..., tries to process it. Sometimes
**	the event can't be processed immediately. In these cases, we make
**	the controller timeout in the WaitForMultipleObjects finite, and set
**	the Controller_Event_Mask to store which event we want to re-try
**	later. When the event is processed, the mask is reset.
*/
#define CONTROLLER_THREAD_TIMEOUT				200
#define TRANSPORT_RECEIVE_TIMEOUT				300
#define	TRANSPORT_TRANSMIT_TIMEOUT				10000

/*
**	The following are the indices in the arrays of masks and timeouts.
*/
#define TRANSPORT_RECEIVE_INDEX			0
#define	TRANSPORT_TRANSMIT_INDEX		1
#define GCC_FLUSH_OUTGOING_PDU_INDEX    3

/*
**	The following values are the masks used for checking against
**	the Controller_Event_Mask in the PollMCSDevices() member of the
**	MCS Controller.
*/
#define TRANSPORT_RECEIVE_MASK 			(0x1 << TRANSPORT_RECEIVE_INDEX)
#define	TRANSPORT_TRANSMIT_MASK 		(0x1 << TRANSPORT_TRANSMIT_INDEX)
#define GCC_FLUSH_OUTGOING_PDU_MASK     (0x1 << GCC_FLUSH_OUTGOING_PDU_INDEX)
#define TRANSPORT_MASK					(TRANSPORT_RECEIVE_MASK | TRANSPORT_TRANSMIT_MASK)

/*
 *	These are the owner callback functions that an application interface object
 *	can send to its creator (which is typically the MCS controller).  The
 *	first one allows an application interface object to tell the controller that
 *	it represents the interface to the node controller application.  The rest
 *	are primitives that would generally come from the node controller
 *	application, but must be acted upon internally by the MCS controller.
 *
 *	When an object instantiates an application interface object (or any other
 *	object that uses owner callbacks), it is accepting the responsibility of
 *	receiving and handling those callbacks.  For that reason, any object that
 *	issues owner callbacks will have those callbacks defined as part of the
 *	interface file (since they really are part of a bi-directional interface).
 *
 *	Each owner callback function, along with a description of how its parameters
 *	are packed, is described in the following section.
 */
#define	REGISTER_NODE_CONTROLLER			0
#define	RESET_DEVICE						1
#define	CREATE_DOMAIN						2
#define	DELETE_DOMAIN						3
#define	CONNECT_PROVIDER_REQUEST			4
#define	CONNECT_PROVIDER_RESPONSE			5
#define	DISCONNECT_PROVIDER_REQUEST			6
#define	APPLICATION_ATTACH_USER_REQUEST		7

/*
 *	These are the structures used by some of the owner callback function listed
 *	above (for the case that the parameters to a function cannot fit into two
 *	32-bit parameters).
 */

#ifdef NM_RESET_DEVICE
typedef	struct
{
	PChar					device_identifier;
} ResetDeviceInfo;
typedef	ResetDeviceInfo *		PResetDeviceInfo;
#endif // #ifdef NM_RESET_DEVICE

typedef	struct
{
	TransportAddress		local_address;
	PInt					local_address_length;
} LocalAddressInfo;
typedef	LocalAddressInfo *		PLocalAddressInfo;

typedef	struct
{
	GCCConfID              *calling_domain;
	GCCConfID              *called_domain;
	PChar					calling_address;
	PChar					called_address;
	BOOL					fSecure;
	BOOL    				upward_connection;
	PDomainParameters		domain_parameters;
	PUChar					user_data;
	ULong					user_data_length;
	PConnectionHandle		connection_handle;
} ConnectRequestInfo;
typedef	ConnectRequestInfo *	PConnectRequestInfo;

typedef	struct
{
	ConnectionHandle		connection_handle;
	GCCConfID              *domain_selector;
	PDomainParameters		domain_parameters;
	Result					result;
	PUChar					user_data;
	ULong					user_data_length;
} ConnectResponseInfo;
typedef	ConnectResponseInfo *	PConnectResponseInfo;

typedef	struct
{
	GCCConfID              *domain_selector;
	PUser					*ppuser;
} AttachRequestInfo;
typedef	AttachRequestInfo *		PAttachRequestInfo;

/*
 *	These structures are used to hold information that would not fit into
 *	the one parameter defined as part of an MCS call back function.  In the case
 *	where these structures are used for call backs, the address of the structure
 *	is passed as the only parameter.
 */
// LONCHANC: we dropped calling and called domain selectors here.
typedef struct
{
	ConnectionHandle	connection_handle;
	BOOL    			upward_connection;
	DomainParameters	domain_parameters;
	unsigned char  *	user_data;
	unsigned long		user_data_length;
	BOOL				fSecure;
} ConnectProviderIndication;
typedef	ConnectProviderIndication  *		PConnectProviderIndication;

typedef struct
{
	ConnectionHandle	connection_handle;
	DomainParameters	domain_parameters;
	Result				result;
	unsigned char  *	user_data;
	unsigned long		user_data_length;
	PBYTE               pb_cred;
	DWORD               cb_cred;
} ConnectProviderConfirm;
typedef	ConnectProviderConfirm  *		PConnectProviderConfirm;

/*
 *	This is the class definition for the Controller class.  It is worth
 *	noting that there are only three public member functions defined in the
 *	controller (besides the constructor and the destructor).  The Owner
 *	callback function is used by all "owned" objects to make requests
 *	of the controller (who created them).  The poll routine, which is
 *	called from the windows timer event handler.  This is the heartbeat
 *	of MCS at the current time.
 */
class	Controller : public CRefCount
{
public:
	Controller (
		PMCSError			mcs_error);
	~Controller ();

	Void		CreateTCPWindow ();
	Void		DestroyTCPWindow ();
	Void		EventLoop ();
	BOOL		FindSocketNumber(ConnectionHandle connection_handle, SOCKET * socket_number);
	BOOL    	GetLocalAddress(
						ConnectionHandle	connection_handle,
						TransportAddress	local_address,
						PInt				local_address_length);

    // the old owner callback
    void     HandleTransportDataIndication(PTransportData);
    void     HandleTransportWaitUpdateIndication(BOOL fMoreData);
#ifdef NM_RESET_DEVICE
    MCSError HandleAppletResetDevice(PResetDeviceInfo);
#endif
    MCSError HandleAppletCreateDomain(GCCConfID *domain_selector);
    MCSError HandleAppletDeleteDomain(GCCConfID *domain_selector);
    MCSError HandleAppletConnectProviderRequest(PConnectRequestInfo);
    MCSError HandleAppletConnectProviderResponse(PConnectResponseInfo);
    MCSError HandleAppletDisconnectProviderRequest(ConnectionHandle);
    MCSError HandleAppletAttachUserRequest(PAttachRequestInfo);
    void     HandleConnDeleteConnection(ConnectionHandle);
    void     HandleConnConnectProviderConfirm(PConnectConfirmInfo, ConnectionHandle);
    void     HandleTransportDisconnectIndication(TransportConnection, ULONG *pnNotify);
#ifdef TSTATUS_INDICATION
    void     HandleTransportStatusIndication(PTransportStatus);
#endif


private:

#ifdef NM_RESET_DEVICE
			ULong		ApplicationResetDevice (
								PChar				device_identifier);
#endif // NM_RESET_DEVICE
			MCSError	ApplicationCreateDomain(GCCConfID *domain_selector);
			MCSError	ApplicationDeleteDomain(GCCConfID *domain_selector);
			MCSError	ApplicationConnectProviderRequest (
								PConnectRequestInfo	pcriConnectRequestInfo);
			MCSError	ApplicationConnectProviderResponse (
								ConnectionHandle	connection_handle,
								GCCConfID          *domain_selector,
								PDomainParameters	domain_parameters,
								Result				result,
								PUChar				user_data,
								ULong				user_data_length);
			MCSError	ApplicationDisconnectProviderRequest (
								ConnectionHandle	connection_handle);
			MCSError	ApplicationAttachUserRequest (
								GCCConfID          *domain_selector,
								PUser				*ppUser);
			Void		ConnectionDeleteConnection (
								ConnectionHandle    connection_handle);
			void		ConnectionConnectProviderConfirm (
								ConnectionHandle    connection_handle,
								PDomainParameters	domain_parameters,
								Result				result,
								PMemory				memory);
			Void		TransportDisconnectIndication (
								TransportConnection	transport_connection);
			Void		TransportDataIndication (
								TransportConnection	transport_connection,
								PUChar				user_data,
								ULong				user_data_length);
#ifdef TSTATUS_INDICATION
			Void		TransportStatusIndication (
								PTransportStatus	transport_status);
#endif
			Void		ProcessConnectInitial (
								TransportConnection	transport_connection,
								ConnectInitialPDU *pdu_structure);
			Void		ProcessConnectAdditional (
								TransportConnection	transport_connection,
								ConnectAdditionalPDU *pdu_structure);
			Void		ConnectResponse (
								TransportConnection	transport_connection,
								Result				result,
								PDomainParameters	domain_parameters,
								ConnectID			connect_id,
								PUChar				user_data,
								ULong				user_data_length);
			Void		ConnectResult (
								TransportConnection	transport_connection,
								Result				result);
	ConnectionHandle	AllocateConnectionHandle ();
			Void		PollMCSDevices ();
			Void		UpdateWaitInfo (
								BOOL     			bMoreData,
								UINT        		index);

	ConnectionHandle		Connection_Handle_Counter;
	HANDLE					Transport_Transmit_Event;
	HANDLE					Connection_Deletion_Pending_Event;
	BOOL    				Controller_Closing;
	BOOL					m_fControllerThreadActive;

	CDomainList2			m_DomainList2;
	CConnectionList2		m_ConnectionList2;

	CConnPollList		    m_ConnPollList;
	CConnPendingList2       m_ConnPendingList2;

	CConnectionList2		m_ConnectionDeletionList2;
	BOOL    				Connection_Deletion_Pending;
	BOOL    				Domain_Traffic_Allowed;

	DWORD					Controller_Wait_Timeout;
	DWORD					Controller_Event_Mask;

#ifndef NO_TCP_TIMER
	UINT_PTR       			Timer_ID;
#endif	/* NO_TCP_TIMER */

public:
	HANDLE					Synchronization_Event;
};
typedef	Controller *			PController;

/*
 *	Controller (
 *			UShort					timer_duration,
 *			PMCSError				mcs_error)
 *
 *	Functional Description:
 *		This is the constructor for the MCS controller.  Its primary
 *		duty is to instantiate the application interface and transport
 *		interface objects that will be used by this provider.  These objects
 *		are static in that they are created by the controller constructor
 *		and destroyed by the controller destructor (below).  Unlike other
 *		objects in the system, they are NOT created and destroyed as needed.
 *
 *		The constructor also instantiates the memory manager that will be
 *		used throughout the MCS system.
 *
 *		The constructor also allocates a windows timer that is used to
 *		provide MCS with a "heartbeat".  This is VERY platform specific and
 *		will definitely change before final release.
 *
 *		Note that if anything goes wrong, the mcs_error variable will be
 *		set to the appropriate error.  It is assumed that whoever is creating
 *		the controller will check this return value and destroy the newly
 *		created controller if something is wrong.
 *
 *		Note that it is not possible to use MCS if there is not at least
 *		one application interface object successfully created.  However, it
 *		is possible to use MCS if there are no transport interfaces.  Multiple
 *		user applications could use this to communicate with one another.  On the
 *		other hand, MCS_NO_TRANSPORT_STACKS is considered a fatal error.
 *
 *	Formal Parameters:
 *		timer_duration (i)
 *			If non-zero, this causes the constructor to allocate a timer to
 *			provide the heartbeat, and this variable is in milliseconds.  If
 *			zero, no timer is allocated, and the application is responsible
 *			for providing the heartbeat.
 *		mcs_error (o)
 *			This is the return value for the constructor.  In C++ constructors
 *			cannot directly return a value, but this can be simulated by passing
 *			in the address of a return value variable.  This value should be
 *			checked by whoever creates the controller.  If it is anything but
 *			MCS_NO_ERROR, the controller should be
 *			deleted immediately, as this is a non-recoverable failure.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine, and the controller is ready to be used.
 *		MCS_NO_TRANSPORT_STACKS
 *			The controller initialized okay, but the TCP transport did
 *			not initialize.
 *		MCS_ALLOCATION_FAILURE
 *			MCS was unable to initialize properly due to a memory allocation
 *			failure.  The controller should be deleted immediately.
 *
 *	Side Effects:
 *		The proper initialization of the application interface and transport
 *		interface objects will probably cause device initializations to occur
 *		in readying for communication.
 *
 *	Caveats:
 *		None.
 */
/*
 *	~Controller ();
 *
 *	Functional Description:
 *		This is the controller destructor.  Its primary purpose is to free up
 *		all resources used by this MCS provider.  It attempts to destroy all
 *		objects in a controlled fashion so as to cleanly sever both user
 *		attachments and MCS connections.  It does this by destroying
 *		connections first, and then transport interfaces.  Next it deletes
 *		user attachments, followed by application interfaces.  Only then does
 *		it destroy existing domains (which should be empty as a result of all
 *		the previous destruction).
 *
 *		Note that this is the ONLY place where application interface and
 *		transport interface objects are destroyed.
 *
 *	Formal Parameters:
 *		Destructors have no parameters.
 *
 *	Return Value:
 *		Destructors have no return value.
 *
 *	Side Effects:
 *		All external connections are broken, and devices will be released.
 *
 *	Caveats:
 *		None.
 */

/*
 *	ULong		OwnerCallback (
 *						unsigned int			message,
 *						PVoid					parameter1,
 *						ULong					parameter2)
 *
 *	Functional Description:
 *		This is the owner callback routine for the MCS controller.  This member
 *		function is used when it is necessary for an object created by the
 *		controller to send a message back to it.
 *		Essentially, it allows objects to make requests of their creators
 *		without having to "tightly couple" the two classes by having them
 *		both aware of the public interface of the other.
 *
 *		When an object such as the controller creates an object that expects
 *		to use the owner callback facility, the creator is accepting the
 *		responsibility of handling owner callbacks.  All owner callbacks
 *		are defined as part of the interface specification for the object
 *		that will issue them.
 *
 *		How the controller handles each owner callback is considered an
 *		implementation issue within the controller.  As such, that information
 *		can be found in the controller implementation file.
 *
 *	Formal Parameters:
 *		message (i)
 *			This is the message to processed.  Note that when the controller
 *			creates each object, it gives it a message offset to use for owner
 *			callbacks, so that the controller can differentiate between
 *			callbacks from different classes.
 *		parameter1 (i)
 *			The meaning of this parameter varies according to the message being
 *			processed.  See the interface specification for the class issuing
 *			the owner callback for a detailed explanation.
 *		parameter2 (i)
 *			The meaning of this parameter varies according to the message being
 *			processed.  See the interface specification for the class issuing
 *			the owner callback for a detailed explanation.
 *
 *	Return Value:
 *		Each owner callback returns an unsigned long.  The meaning of this
 *		return value varies according to the message being processed.  See the
 *		interface specification for the class issuing the owner callback for a
 *		detailed explanation.
 *
 *	Side Effects:
 *		Message specific.
 *
 *	Caveats:
 *		None.
 */

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\conflist.h ===
/*
 *	conflist.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class CConfDescriptorListContainer.
 *		Instances of this class represent the Conference Descriptor list that is
 *		generated by a call to GCCConferenceQueryRequest.  This class hides most
 *		of the complexity associated with building this list.  It also handles
 *		building the set of conference descriptors used in the
 *		ConferenceQueryResponse PDU	and the conference descriptor list passed 
 *		to the GCC interface.  This class is designed so that a CControlSAP 
 *		object can use it to create	a GCC_CONFERENCE_QUERY_CONFIRM message by 
 *		requesting a pointer to a list of Conference Descriptor pointers from 
 *		it.  Objects of this type only live long enough to service a particular
 *		query request.  After a message	callback has returned or a PDU has been
 *		sent to MCS, the CConfDescriptorListContainer object is deleted.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */
#ifndef _CONFERENCE_DESCRIPTOR_LIST_
#define _CONFERENCE_DESCRIPTOR_LIST_

#include "netaddr.h"

/*
 * This typedef defines the structure used internally by this class to maintain
 * the data associated with an individual conference descriptor.
 */
typedef struct CONF_DESCRIPTOR
{
	CONF_DESCRIPTOR(void);
	~CONF_DESCRIPTOR(void);

	LPSTR					pszNumericConfName;
	LPWSTR					pwszTextConfName;
	LPSTR					pszConfModifier;
	LPWSTR					pwszConfDescription;
	CNetAddrListContainer   *network_address_list;
	BOOL					conference_is_locked;
	BOOL					password_in_the_clear;
}
    CONF_DESCRIPTOR;

/*
 * These typedefs define the Rogue Wave container used to hold the list of 
 * CONF_DESCRIPTOR structures internally and the iterator used for
 * accessing structures in the list.
 */
class CConfDesccriptorList : public CList
{
    DEFINE_CLIST(CConfDesccriptorList, CONF_DESCRIPTOR*)
};


/*
 * Class definition:
 */
class CConfDescriptorListContainer : public CRefCount
{
public:

    CConfDescriptorListContainer(void);
    CConfDescriptorListContainer(PSetOfConferenceDescriptors, PGCCError);

    ~CConfDescriptorListContainer(void);

    GCCError	AddConferenceDescriptorToList(
    						LPSTR					pszNumericConfName,
    						LPWSTR					conference_text_name,
    						LPSTR					pszConfModifier,
    						BOOL					locked_conference,
    						BOOL					password_in_the_clear,
    						LPWSTR					pwszConfDescription,
    						CNetAddrListContainer   *network_address_list);

    GCCError	GetConferenceDescriptorListPDU(PSetOfConferenceDescriptors *);
    void		FreeConferenceDescriptorListPDU(void);

    GCCError	LockConferenceDescriptorList(void);
    void		UnLockConferenceDescriptorList(void);

    void		GetConferenceDescriptorList(PGCCConferenceDescriptor **, UINT *pcDescriptors);

private:

	void		GetConferenceDescriptor(PGCCConferenceDescriptor, CONF_DESCRIPTOR *);

private:

	/*
	 * Instance variables:
	 */
	PGCCConferenceDescriptor	*	m_ppGCCConfDescriptorList;
	PSetOfConferenceDescriptors		m_pSetOfConfDescriptors;
	UINT							m_cDescriptors;
	LPBYTE							m_pDescriptorListMemory;
	CConfDesccriptorList            m_ConfDescriptorList;

	//
	// LONCHANC: m_pNetAddrMemoryPointer points to available space,
	// initially equaling to m_pNetAddrListMemory.
	//
	LPBYTE							m_pNetAddrListMemory;
    LPBYTE                          m_pNetAddrMemoryPointer;
};

/*
 *	Comments explaining the public and private class member functions
 */

/*
 *	CConfDescriptorListContainer ();
 *
 *	Public member function of CConfDescriptorListContainer.
 *
 *	Function Description:
 *		This is a constructor for the CConfDescriptorListContainer class.  It
 *		initializes instance variables.
 *
 *	Formal Parameters:
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	CConfDescriptorListContainer (	PSetOfConferenceDescriptors		conference_list,
 *								PGCCError						gcc_error);
 *
 *	Public member function of CConfDescriptorListContainer.
 *
 *	Function Description:
 *		This is a constructor for the CConfDescriptorListContainer class.  
 *		This constructor builds a list of conference descriptors that can
 *		be passed on to the GCC interface.  This list is built from a set
 *		of conference descriptors which is part of a Query Response PDU.
 *
 *	Formal Parameters:
 *		conference_list		(i) The PDU form of the descriptor list.
 *		gcc_error			(o) Error return parameter.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~CConfDescriptorListContainer ();
 *
 *	Public member function of CConfDescriptorListContainer.
 *
 *	Function Description:
 *		This is the destructor for the CConfDescriptorListContainer class.  It is
 *		responsible for freeing up any resources allocated during the life of
 *		this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError		AddConferenceDescriptorToList (
 *								LPSTR					pszNumericConfName,
 *								LPWSTR					conference_text_name,
 *								LPSTR					pszConfModifier,
 *								BOOL					locked_conference,
 *								BOOL					password_in_the_clear,
 *								LPWSTR					pwszConfDescription,
 *								CNetAddrListContainer   *network_address_list);
 *
 *	Public member function of CConfDescriptorListContainer.
 *
 *	Function Description:
 *		This routine is used to add a single new conference descriptor to the
 *		list of conference descriptors.
 *
 *	Formal Parameters:
 *		conference_numeric_name		(i)	The numeric form of the conference name.
 *		conference_text_name		(i) The text form of the conference name.
 *		pszConfModifier				(i) The conference modifier string.
 *		locked_conference			(i) Flag indicating whether or not the
 *											conference is locked.
 *		password_in_the_clear		(i)	Flag indicating whether the conference 
 *											password is "clear" or is a
 *											"challenge".
 *		pwszConfDescription			(i)	The conference description string.
 *		network_address_list		(i) List of network addresses at the queried
 *											node.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError		GetConferenceDescriptorListPDU (
 *								PSetOfConferenceDescriptors	*  conference_list);
 *
 *	Public member function of CConfDescriptorListContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the PDU form of the conference 
 *		descriptor list which is a list of "SetOfConferenceDescriptors"
 *		structures.
 *
 *	Formal Parameters:
 *		conference_list			(o)	The pointer to the list of 
 *										"SetOfConferenceDescriptors" structures
 *										to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void		FreeConferenceDescriptorListPDU ();
 *
 *	Public member function of CConfDescriptorListContainer.
 *
 *	Function Description:
 *		This routine is used to free up any resources allocated to hold the PDU 
 *		form of the conference descriptor list.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError		LockConferenceDescriptorList ();
 *
 *	Public member function of CConfDescriptorListContainer.
 *
 *	Function Description:
 *		This routine is used to "lock" the API form of the conference descriptor
 *		list.  The lock count is incremented and the API form of the list
 *		created in preparation for a "GetConferenceDescriptorList" call used to
 *		retrieve the API form of the list.  The memory necessary to hold the
 *		API list is allocated by this routine.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		GCC_NO_ERROR			   -	No error.
 *		GCC_ALLOCATION_FAILURE	   - 	Error creating an object using the "new"
 *											operator or else an	allocation using
 *								   			the memory manager failed.
 *
 *  Side Effects:
 *		The internal lock count is incremented.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void		GetConferenceDescriptorList (
 *								PGCCConferenceDescriptor **	   conference_list,	
 *								UINT*							number_of_descriptors);
 *
 *	Public member function of CConfDescriptorListContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the API form of the conference 
 *		descriptor list.
 *
 *	Formal Parameters:
 *		conference_list			(o) Pointer to list of GCCConferenceDescriptor
 *										API structures to fill in.
 *		number_of_descriptors	(o) Pointer to the number of descriptors in the
 *										list to fill in.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void		UnLockConferenceDescriptorList ();
 *
 *	Public member function of CConfDescriptorListContainer.
 *
 *	Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine 
 *		whether the object has been freed through a call to 
 *		FreeConferenceDescriptorList.  If so, the object will automatically 
 *		delete itself.  If not, any resources allocated to hold the API form
 *		of the decriptor list are freed.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal lock count is decremented.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\crc.h ===
/*	crc.h
 *
 *	Copyright (c) 1994-1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This file contains the CRC class definition.  This class can use either
 *		the table-driven or bit-shifting approach to generate its CRC.
 *
 *	Public Instance Variable:
 *		None
 *
 *	Caveats:
 *		None.
 *
 *	Authors:
 *		Marvin Nicholson
 */

#ifndef _CRC_
#define _CRC_

#include "databeam.h"

#define	CRC_TABLE_SIZE	256

class	CRC
{
	public:
				CRC ();
				~CRC ();

		ULong 	OldCRCGenerator(
					PUChar	block_adr,
					ULong	block_len);
		ULong 	CRCGenerator(
					PUChar	block_adr,
					ULong	block_len);
		DBBoolean CheckCRC(
					PUChar	block_adr,
					ULong	block_len);
		Void	GetOverhead(
					UShort		maximum_packet,
					PUShort		new_maximum_packet);

	private:
		UShort		CRCTableValue(
						Int		Index,
						ULong	poly);
		Void		CRCTableGenerator(
						ULong poly);

        UShort		CRC_Table[CRC_TABLE_SIZE];
		Int			CRC_Width;
        ULong		CRC_Poly;
        ULong		CRC_Init;
        UShort		CRC_Check_Value;
		DBBoolean	Invert;
		UShort		CRC_Register;

};
typedef CRC *	PCRC;

#endif

/*	
 *	CRC::CRC ();
 *
 *	Functional Description
 *		This is the constructor for this class.
 *
 *	Formal Parameters
 *		None.
 *
 *	Return Value
 *		None
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		None
 */

/*	
 *	CRC::~CRC ();
 *
 *	Functional Description
 *		This is the destructor for this class.
 *
 *	Formal Parameters
 *		None.
 *
 *	Return Value
 *		None
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		None
 */

/*	
 *	ULong 	CRC::OldCRCGenerator(
 *					PUChar	block_adr,
 *					ULong	block_len);
 *
 *	Functional Description
 *		This function generates the crc using bit-shifting methods.  This method
 *		is slower than the table-driven approach.
 *
 *	Formal Parameters
 *		block_adr	(i)	-	Address of buffer to generate CRC on.
 *		block_lengh	(i)	-	Length of buffer
 *
 *	Return Value
 *		CRC value
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		None
 */

/*	
 *	ULong 	CRC::CRCGenerator(
 *					PUChar	block_adr,
 *					ULong	block_len);
 *
 *	Functional Description
 *		This function generates the crc using the table-driven method.
 *
 *	Formal Parameters
 *		block_adr	(i)	-	Address of buffer to generate CRC on.
 *		block_lengh	(i)	-	Length of buffer
 *
 *	Return Value
 *		CRC value
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		None
 */

/*	
 *	DBBoolean CRC::CheckCRC(
 *					PUChar	block_adr,
 *					ULong	block_len);
 *
 *	Functional Description
 *		This function generates a CRC based on the block passed in.  It assumes
 *		that the CRC is attached to the end of the block.  It compares the
 *		CRC generated to the CRC at the end of the block and returns TRUE if
 *		the CRC is correct.
 *
 *	Formal Parameters
 *		block_adr	(i)	-	Address of buffer to generate CRC on.
 *		block_lengh	(i)	-	Length of buffer
 *
 *	Return Value
 *		TRUE		-	CRC in the block is correct
 *		FALSE		-	CRC in the block is NOT correct
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		None
 */

/*	
 *	Void	CRC::GetOverhead(
 *					UShort		maximum_packet,
 *					PUShort		new_maximum_packet);
 *
 *	Functional Description
 *		This function is called to determine the overhead that will be added
 *		to the packet by the CRC.
 *
 *	Formal Parameters
 *		maximum_packet		(i)	-	Current max. packet size
 *		new_maximum_packet	(o)	-	Maximum length of packet including CRC.
 *
 *	Return Value
 *		None
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		None
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\crostmsg.h ===
/*
 *	crostmsg.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */
#ifndef	_CONFERENCE_ROSTER_MESSAGE_
#define	_CONFERENCE_ROSTER_MESSAGE_

#include "crost.h"

class CConfRosterMsg : public CRefCount
{
public:

	CConfRosterMsg(CConfRoster *conference_roster);

	~CConfRosterMsg(void);

	GCCError		LockConferenceRosterMessage(void);
	void			UnLockConferenceRosterMessage(void);
	GCCError		GetConferenceRosterMessage(LPBYTE *ppData);

private:

	LPBYTE			m_pMemoryBlock;
	CConfRoster		*m_pConfRoster;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\crost.h ===
/*
 *	crost.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		Instances of this class represent a single Conference Roster's
 *		information base.  It encapsulates all the functionality required to
 *		maintain the information base which includes the ability to add new
 *		roster records, delete records and update records.  It has the ability
 *		to convert its internal information base into a list of conference
 *		records that can be used in a GCC_ROSTER_UPDATE_INDICATION callback.  It
 *		is also responsible for converting its internal information base into
 *		Conference Roster Update PDUs.  Basically,  this class is responsible
 *		for all operations that require direct access to the records contained
 *		in a Conference Roster.
 *
 *		The Conference Roster class incorporates Rogue Wave list to hold the
 *		roster record information.  Using iterators throughout the class makes
 *		it easy to quickly convert the information contained in the list into
 *		either a PDU or into a list of record pointers (for roster update
 *		indications back to the node controller).
 *
 *		A Conference Roster object has the ability to serialize its roster data
 *		into a single contiguous memory block when it is required to send a
 *		message to the application interface.  This serialization process is
 *		managed externally by the CConfRosterMsg class through calls to
 *		LockConferenceRoster(), UnLockConferenceRoster() and
 *		GetConfRoster().  When a conference roster is to be serialized, a
 *		call is made to LockConferenceRoster() which causes the CConfRoster
 *		object to increment an internal lock count and returns the number of
 *		bytes required to hold the complete roster update.  The Conference
 *		Roster is then serialized into memory through a call to
 *		GetConfRoster().  The CConfRoster is then unlocked to allow
 *		it to be deleted when the free flag gets set through the
 *		FreeConferenceRoster() function.  In the current implementation of GCC,
 *		FreeConferenceRoster() is not used since the CConfRosterMsg
 *		maintains the data used to deliver the message (see a more detailed
 *		description of the lock, free and unlock mechanism in the section
 *		describing the data containers).
 *
 *		The Conference Roster object also is responsible for maintaining
 *		internal PDU data which is updated whenever a change occurs to its
 *		internal information base.  This PDU can be affected by both local
 *		request or by processing incoming PDUs.  Higher level objects access
 *		this PDU data by calling the Conference Roster's flush routine which in
 *		turn causes the PDU to be freed on any subsequent request that affects
 *		the rosters internal information base.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */
#ifndef	_CONFERENCE_ROSTER_
#define	_CONFERENCE_ROSTER_

#include "netaddr.h"
#include "userdata.h"
#include "clists.h"

/*
**	These enumerations define the different ways the a conference roster list
**	can be updated.  It is used externally to inform a conference roster object
**	what to of send data PDU to build.
*/
typedef enum
{
	ADD_RECORD,
	DELETE_RECORD,
	REPLACE_RECORD,
	FULL_REFRESH
}
	CONF_ROSTER_UPDATE_TYPE;

/*
**	This list is used to keep track of the conference participants.  It is
**	a list of rogue wave pointers to Unicode Strings.
*/
class CParticipantNameList : public CList
{
	DEFINE_CLIST(CParticipantNameList, LPWSTR)
	void DeleteList(void);
};

/*
**	This is the structure used to maintain the conference roster information
**	internally.  Optional paramters use a NULL pointer to indicate that the
**	parameter is not in use.
*/
typedef struct CONF_RECORD
{
	CONF_RECORD(void);
	~CONF_RECORD(void);

	UserID					superior_node;
	NodeType				node_type;
	NodeProperties			node_properties;
	LPWSTR					pwszNodeName;
	CParticipantNameList	*participant_name_list;
	LPWSTR					pwszSiteInfo;
	CNetAddrListContainer   *network_address_list;
	LPOSTR					poszAltNodeID;
	CUserDataListContainer  *user_data_list;
}
	CONF_RECORD;

/*
**	This list is used to hold the pointers to the actual conference record for
**	each node in the conference.  The list is indexed by the Node ID associated
**	with the record.
*/
class CConfRecordList2 : public CList2
{
	DEFINE_CLIST2_(CConfRecordList2, CONF_RECORD*, UserID)
	void CleanList(void);
};


class CConfRoster : public CRefCount
{
public:

	CConfRoster(UserID uidTopProvider, UserID uidSuperiorNode, UserID uidMime,
				BOOL is_top_provider, BOOL is_local_roster, BOOL maintain_pdu_buffer);

	~CConfRoster(void);

	/*
	 * Utilities that operate on roster update PDU strucutures.
	 */
	void				FlushRosterUpdateIndicationPDU(PNodeInformation);
	GCCError			BuildFullRefreshPDU(void);
	GCCError			ProcessRosterUpdateIndicationPDU(PNodeInformation, UserID uidSender);

	/*
	 * Utilities used to generate a roster update message.
	 */
	UINT	    LockConferenceRoster(void);
	void		UnLockConferenceRoster(void);
	UINT		GetConfRoster(PGCCConferenceRoster *, LPBYTE memory_pointer);
	/*
	**	Utilities that operate directly on the conference roster objects
	**	internal databease.
	*/
	GCCError	AddRecord(PGCCNodeRecord, UserID);
	GCCError	ReplaceRecord(PGCCNodeRecord, UserID);
	GCCError	RemoveUserReference(UserID);

	/*
	**	Miscelaneous utilities.
	*/
	void    ResetConferenceRoster(void);

	UINT    GetNumberOfNodeRecords(void) { return m_RecordList2.GetCount(); }
	BOOL	Contains(UserID uidConf) { return m_RecordList2.Find(uidConf) ? TRUE : FALSE; }
	BOOL	HasRosterChanged(void) { return m_fRosterChanged; }

private:

	/*
	 * Utilities used to create a roster update indication PDU.
	 */
	GCCError	BuildRosterUpdateIndicationPDU(CONF_ROSTER_UPDATE_TYPE, UserID);
	GCCError	BuildSetOfRefreshesPDU(void);
	GCCError	BuildSetOfUpdatesPDU(UserID, CONF_ROSTER_UPDATE_TYPE);
	GCCError	BuildParticipantsListPDU(UserID, PParticipantsList *);

	/*
	 * Utilities used to Free a roster update indication PDU.
	 */
	void    FreeRosterUpdateIndicationPDU(void);
	void    FreeSetOfRefreshesPDU(void);
	void    FreeSetOfUpdatesPDU(void);
	void    FreeParticipantsListPDU(PParticipantsList);
    void    CleanUpdateRecordPDU(PSetOfNodeRecordUpdates);

	/*
	 * Utilities used to Process roster update indications.
	 */
	GCCError				ProcessSetOfRefreshesPDU(PSetOfNodeRecordRefreshes);
	GCCError				ProcessSetOfUpdatesPDU(PSetOfNodeRecordUpdates);
	GCCError				ProcessParticipantsListPDU(PParticipantsList, CONF_RECORD *);
								
	/*
	 * Utilities used to operate on conference roster reports.
	 */
	void					ClearRecordList(void);
	
	void					GetNodeTypeAndProperties (
								NodeType			pdu_node_type,
								NodeProperties		pdu_node_properties,
								PGCCNodeType		node_type,
								PGCCNodeProperties	node_properties);

	void					GetPDUNodeTypeAndProperties (
								GCCNodeType			node_type,
								GCCNodeProperties	node_properties,
								PNodeType			pdu_node_type,
								PNodeProperties		pdu_node_properties);
	
	GCCError				DeleteRecord(UserID node_id);

	GCCError				GetNodeSubTree(UserID, CUidList *);

private:

	BOOL					m_fNodesAdded;
	BOOL	 				m_fNodesRemoved;
	BOOL	 				m_fRosterChanged;
	BOOL					m_fTopProvider;
	BOOL					m_fLocalRoster;
	BOOL					m_fMaintainPduBuffer;
	BOOL					m_fPduFlushed;
	UserID					m_uidTopProvider;
	UserID					m_uidSuperiorNode;
	UserID					m_uidMyNodeID;
	UINT					m_nInstanceNumber;
	UINT					m_cbDataMemorySize;
	NodeInformation			m_NodeInformation;
	CConfRecordList2		m_RecordList2;
	PSetOfNodeRecordUpdates	m_pNodeRecordUpdateSet;
};

#endif

/*
 *	CConfRoster(	UserID					top_provider_id,
 *						UserID					superior_node,
 *						BOOL					is_top_provider,
 *						BOOL					is_local_roster,
 *						BOOL					maintain_pdu_buffer,
 *
 *	Public Function Description
 *		This is the conference roster constructor. It is responsible for
 *		initializing all the instance variables used by this class.
 *
 *	Formal Parameters:
 *		top_provider_id		-	(i) The Node ID of the Top Provider
 *		superior_node		-	(i) The Node ID of the node that is the parent
 *								to this one. Zero for the top provider.
 *		is_top_provider		-	(i)	Indicates if this is the top provider node.
 *		is_local_roster		-	(i)	Indicates if this roster is a local one.
 *		maintain_pdu_buffer	-	(i)	Indicates if this roster should maintain
 *									a PDU buffer.
 *		
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	~CConfRoster ()
 *
 *	Public Function Description
 *		This is the conference roster destructor. It is responsible for
 *		freeing up all the internal memory used by this class.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	FlushRosterUpdateIndicationPDU (
 *								PNodeInformation			node_information)
 *
 *	Public Function Description
 *		This routine is used to access any PDU data that might currently be
 *		queued inside the conference roster.  PDU data is queued whenever
 *		a request is made to the conference roster that affects its
 *		internal information base.
 *
 *	Formal Parameters:
 *		node_information	-	(o) Pointer to the PDU buffer to fill in.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		The PDU data returned by this routine is automatically freed the next
 *		time a request is made to this roster object that affects its internal
 *		databease.
 */

/*
 *	GCCError	BuildFullRefreshPDU (void)
 *
 *	Public Function Description
 *		This routine is responsible for generating a full conference roster
 *		refresh PDU.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ProcessRosterUpdateIndicationPDU (
 *						PNodeInformation			node_information)
 *
 *	Public Function Description
 *		This routine is responsible for processing the decoded PDU data.
 *		It essentially changes the conference roster objects internal database
 *		based on the information in the structure.
 *
 *	Formal Parameters:
 *		node_information	-	(i) This is a pointer to a structure that
 *									holds the decoded PDU data.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	UINT		LockConferenceRoster()
 *
 *	Public Function Description:
 *		This routine is used to "lock" the "API" data for this object.  This
 *		results in the lock count for this object being incremented.  When the
 *		lock count transitions from 0 to 1, a calculation is made to determine
 *		how much memory will be needed to hold any "API" data which will
 *		be referenced by, but not held in, the GCCConferenceRoster structure
 *		which is filled in on a call to GetConfRoster.  This is the
 *		value returned by this routine in order to allow the calling object to
 *		allocate that amount of memory in preparation for the call to
 *		GetConfRoster.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The amount of memory, if any, which will be needed to hold "API" data
 *		which is referenced by, but not held in, the GCCConferenceRoster
 *		structure provided as an output parameter to the GetConfRoster
 *		call.
 *
 *  Side Effects:
 *		The internal lock count is incremented.
 *
 *	Caveats:
 *		The internal lock count is used in conjuction with an internal "free"
 *		flag as a mechanism for ensuring that this object remains in existance
 *		until all interested parties are through with it.  The object remains
 *		valid (unless explicity deleted) until the lock count is zero and the
 *		"free" flag is set through a call to FreeConferenceRoster.  This allows
 *		other objects to lock this object and be sure that it remains valid
 *		until they call UnLock which will decrement the internal lock count.  A
 *		typical usage scenerio for this object would be:  A CConfRoster
 *		object is constructed and then passed off to any interested parties
 *		through a function call.  On return from the function call, the
 *		FreeConferenceRoster call is made which will set the internal "free"
 *		flag.  If no other parties have locked the object with a Lock call,
 *		then the CConfRoster object will automatically delete itself when
 *		the FreeConferenceRoster call is made.  If, however, any number of
 *		other parties has locked the object, it will remain in existence until
 *		each of them has unlocked the object through a call to UnLock.
 */

/*
 *	void			UnLockConferenceRoster ();
 *
 *	Public Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine
 *		whether the object has been freed through a call to
 *		FreeConferenceRoster.  If so, the object will automatically delete
 *		itself.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal lock count is decremented.
 *
 *	Caveats:
 *		It is the responsibility of any party which locks an CConfRoster
 *		object by calling Lock to also unlock the object with a call to UnLock.
 *		If the party calling UnLock did not construct the CConfRoster
 *		object,	it should assume the object to be invalid thereafter.
 */

/*
 *  UINT		GetConfRoster(
 *        					PGCCConferenceRoster	FAR * 	conference_roster,
 *                          LPSTR							memory_pointer);
 *
 *	Public Function Description:
 *		This routine is used to retrieve the conference roster data from
 *		the CConfRoster object in the "API" form of a GCCConferenceRoster.
 *
 *	Formal Parameters:
 *		conference_roster	(o)	The GCCConferenceRoster structure to fill in.
 *		memory_pointer		(o)	The memory used to hold any data referenced by,
 *									but not held in, the output structure.
 *
 *	Return Value:
 *		The amount of data, if any, written into the bulk memory block provided.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError		AddRecord(	PGCCNodeRecord			conference_record,
 *								UserID					node_id)
 *
 *	Public Function Description:
 *		This routine is used to add a single nodes conference record to the
 *		conference roster object's internal list of records.
 *
 *	Formal Parameters:
 *		conference_record	(i)	Pointer to the "API" record	structure to add.
 *		node_id				(i)	Node ID associated with record being added.	
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_PARAMETER			-	Invalid parameter passed in.
 *		GCC_BAD_NETWORK_ADDRESS			-	Invalid network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	-	Bad "choice" field for address
 *		GCC_BAD_USER_DATA				-	The user data passed in contained
 *												an invalid object key.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	RemoveRecord(UserID			node_id)
 *
 *	Public Function Description:
 *		This routine is used to remove a single nodes conference record from the
 *		conference roster object's internal list of records.
 *
 *	Formal Parameters:
 *		node_id				(i)	Node ID of record to be removed.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_INVALID_PARAMETER			-	Invalid parameter passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ReplaceRecord(		PGCCNodeRecord			conference_record,
 *									UserID					node_id)
 *
 *	Public Function Description:
 *		This routine is used to replace a single nodes conference record in the
 *		conference roster object's internal list of records.
 *
 *	Formal Parameters:
 *		conference_record	(i)	Conference record to use as the replacement.
 *		node_id				(i)	Node ID of record to be replaced.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_PARAMETER			-	Invalid parameter passed in.
 *		GCC_BAD_NETWORK_ADDRESS			-	Invalid network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	-	Bad "choice" field for address
 *		GCC_BAD_USER_DATA				-	The user data passed in contained
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	RemoveUserReference (
 *							UserID					detached_node)
 *
 *	Public Function Description:
 *		This routine removes the record associated with the specified node
 *		id.
 *
 *	Formal Parameters:
 *		detached_node		(i)	Node reference to remove.
 *
 *	Return Value:
 *		GCC_NO_ERROR				-	No error occured.
 *		GCC_INVALID_PARAMETER		-	No records associated with this node
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	BOOL			Contains( UserID			conference_node_id )
 *
 *	Public Function Description:
 *		This routine is used to determine if the specified record exists in
 *		the conference roster.
 *
 *	Formal Parameters:
 *		conference_node_id	(i)	Node ID of record to check for
 *
 *	Return Value:
 *		TRUE	-	If the record is contained in the conference roster.
 *		FALSE	-	If the record is not contained in the conference roster.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	USHORT		GetNumberOfNodeRecords ();
 *
 *	Public Function Description:
 *		This routine returns the total number of conference roster records
 *		contained in the objects conference roster record list.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The number of records in the conference roster list.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	void		ResetConferenceRoster ()
 *
 *	Public Function Description:
 *		This routine takes care of resetting all the internal flags that are
 *		used to convey the current state of the conference roster.  Should be
 *		called after the roster is flushed and any roster update messages have
 *		been delivered (after a change to the roster occurs).
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	BOOL			HasRosterChanged ();
 *
 *	Public Function Description:
 *		This routine informs the caller if the roster has changed since the
 *		last time it was reset.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		TRUE		-	If roster has changed
 *		FALSE		-	If roster has not changed
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\crostmgr.h ===
/*
 *	crostmgr.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		Instances of this class represent the owner of the Conference Roster 
 *		for a single Conference object at an individual node.  This class will 
 *		create either a single CConfRoster object (referred to as a 
 *		"Global" roster) or two CConfRoster objects (refered to as a 
 *		"Local" and "Global" roster) in its constructor and will return a 
 *		resource error if there is not enough memory to instantiate it.  The 
 *		CConfRosterMgr is mainly responsible for routing Roster 
 *		Updates to and from the CConfRoster object(s) it manages.  This 
 *		includes updates sent to both the Control SAP and Application SAPs as 
 *		well as Updates sent to other nodes via PDUs.  This class makes 
 *		decisions on how to route updates based on whether or not it is at a 
 *		Top Provider node.  It also must make routing decisions based on whether 
 *		the change affects the Local or Global roster being maintained.
 *
 *		The CConfRosterMgr object at every node except the Top Provider 
 *		will maintain two ConferenceRosters, a local one and a global one.  This 
 *		is a very important distinction in that it implies two entirely 
 *		different sets of responsibilities. Conference Roster information is 
 *		distributed over the entire Conference.  Nodes that lie lower in the 
 *		connection hierarchy (subordinate nodes) contain less information than 
 *		higher nodes but all play an important role in maintaining the overall 
 *		roster.  
 *
 *		The "Local" CConfRoster is mainly used to inform parent nodes of 
 *		changes to the Conference Roster that occur at the local node or below 
 *		it in the connection hierarchy.  The Local CConfRoster consist of 
 *		all the Conference Roster Records at its local node and below it.  It is 
 *		not used to deliver Conference Roster Update messages to the various 
 *		SAPs.  Its only input is from either primitive calls at the local node 
 *		or from Roster Update PDUs received from subordinate nodes.  A "Local" 
 *		CConfRoster is only maintained by ConferenceRosterManagers at nodes 
 *		that are not the Top Provider.  
 *
 *		A "Global" CConfRoster maintained by a CConfRosterMgr has 
 *		a dual set of responsibilities depending on if it is at a Top Provider 
 *		node.  A CConfRoster of this type at a Top Provider is responsible 
 *		for maintaining a record entry for every node in the Conference.  It is 
 *		also used to send full conference roster refreshes to all of its 
 *		subordinate nodes when changes to the roster occur.  All "Global" 
 *		ConferenceRosters (regardless of location within the connection 
 *		hierarchy) are used to send Roster Update indications to all the 
 *		appropriate SAPs (Control and Application) via an Owner-Callback call to 
 *		the Conference Object that owns it.  The owner object is informed of the 
 *		roster update through a CONF_ROSTER_MGR_ROSTER_REPORT message.  Included 
 *		in this message is a pointer to a CConfRosterMsg object.  The 
 *		CConfRosterMgr creates a CConfRosterMsg from the 
 *		"Global" CConfRoster object that it maintains.  This 
 *		CConfRosterMsg object contains all the conference roster data 
 *		serialized into a single memory block which is formatted for delivery to 
 *		the appropriate SAPs.  You can think of this as a snapshot in time of 
 *		the CConfRoster being delivered in the roster update message.
 *
 *		A "Global" CConfRoster at a subordinate node is responsible for 
 *		storing full refreshes of the Conference Roster from the Top Provider.  
 *		It is also used to send the Conference Roster Update message to all the 
 *		appropriate SAPs through an Owner-Callback to the Conference object (as 
 *		mentioned above) after processing the full refresh PDU.
 *
 *		All PDUs and messages are delivered when the CConfRosterMgr is 
 *		flushed. This is also true for ApplicationRosterManagers.  This is a 
 *		very important concept in that it allows a CConfRosterMgr to 
 *		process a number of request and PDUs before actually being flushed.  The 
 *		CConfRoster itself will queue up changes to a PDU that can consist 
 *		of either multiple updates or a single refresh and will not free it 
 *		until after it is flushed.  Therefore, when processing a roster update 
 *		PDU that consists of changes to the conference roster as well as 
 *		multiple application rosters, a roster refresh PDU can be held back 
 *		until all the roster managers have had a chance to process their portion 
 *		of the roster update.  Once complete, a single PDU can be built by 
 *		flushing the CConfRosterMgr and all the affected 
 *		ApplicationRosterManagers.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */
#ifndef	_CONFERENCE_ROSTER_MANAGER_
#define	_CONFERENCE_ROSTER_MANAGER_

#include "mcsuser.h"
#include "clists.h"
#include "crost.h"


class CConf;
class CConfRosterMgr : public CRefCount
{
public:

	CConfRosterMgr(
		PMCSUser				user_object,
		CConf					*pConf,
		BOOL					top_provider,
		PGCCError				roster_error);

	~CConfRosterMgr(void);

	GCCError			AddNodeRecord(PGCCNodeRecord node_record);

	GCCError			UpdateNodeRecord(PGCCNodeRecord node_record);
	
	GCCError			RemoveUserReference(UserID deteched_node_id);
								
	GCCError			RosterUpdateIndication(
							PGCCPDU					roster_update,
							UserID					sender_id);
								
	GCCError			FlushRosterUpdateIndication(PNodeInformation node_information);

	GCCError			GetFullRosterRefreshPDU(PNodeInformation node_information);
								

	CConfRoster		*GetConferenceRosterPointer(void) { return (m_pGlobalConfRoster); }
	BOOL			Contains(UserID uid) { return m_pGlobalConfRoster->Contains(uid); }
	UINT			GetNumberOfNodeRecords(void) { return m_pGlobalConfRoster->GetNumberOfNodeRecords(); }

    BOOL            IsThisNodeParticipant ( GCCNodeID );

private:

	BOOL							m_fTopProvider;
	CConfRoster						*m_pGlobalConfRoster;
	CConfRoster						*m_pLocalConfRoster;
	MCSUser						    *m_pMcsUserObject;
	CConf							*m_pConf;
};

#endif


/*
 *	CConfRosterMgr	(	
 *					PMCSUser				user_object,
 *					UINT        			owner_message_base,
 *					BOOL					top_provider,
 *					PGCCError				roster_error)
 *
 *	Public Function Description
 *		This is the conference roster manager constructor. It is responsible for
 *		initializing all the instance variables used by this class.
 *
 *	Formal Parameters:
 *		user_object			-	(i)	Pointer to the user attachment object used
 *									by this class.
 *		owner_object		-	(i)	Pointer to the owner object.
 *		owner_message_base	-	(i)	Message base to add to all the owner 
 *									callbacks.
 *		top_provider		-	(i)	Indicates if this is the top provider node.
 *		roster_error		-	(o)	Pointer to error value to be returned.
 *		
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No resource error occured.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	~CConfRosterMgr ()
 *
 *	Public Function Description
 *		This is the conference roster destructor. It is responsible for
 *		freeing up all memory allocated by this class.
 *
 *	Formal Parameters:
 *		None.
 *		
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	AddNodeRecord (PGCCNodeRecord			node_record)
 *
 *	Public Function Description
 *		This routine is used to add a new record to the conference roster.
 *		This class makes the decision about which roster the new record goes
 *		into (global or local).
 *
 *	Formal Parameters:
 *		node_record		-	(i)	Pointer to the record to add to the roster.
 *		
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_PARAMETER			-	Invalid parameter passed in.
 *		GCC_BAD_NETWORK_ADDRESS			-	Invalid network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	-	Bad "choice" field for address
 *		GCC_BAD_USER_DATA				-	The user data passed in contained
 *												an invalid object key.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	UpdateNodeRecord(
 *								PGCCNodeRecord			node_record)
 *
 *	Public Function Description
 *		This routine is used to replace a record in the conference roster with
 *		a new record. This class makes the decision about which roster the new 
 *		record affects (global or local).
 *
 *	Formal Parameters:
 *		node_record		-	(i)	Pointer to the record to replace with.
 *		
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_PARAMETER			-	Invalid parameter passed in.
 *		GCC_BAD_NETWORK_ADDRESS			-	Invalid network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	-	Bad "choice" field for address
 *		GCC_BAD_USER_DATA				-	The user data passed in contained
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	RemoveUserReference (
 *								UserID					deteched_node_id)
 *
 *	Public Function Description
 *		This routine removes the record associated with the specified node
 *		id.
 *
 *	Formal Parameters:
 *		deteched_node_id		(i)	Node reference to remove.
 *
 *	Return Value:
 *		GCC_NO_ERROR				-	No error occured.
 *		GCC_INVALID_PARAMETER		-	No records associated with this node
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	RosterUpdateIndication(
 *								PGCCPDU					roster_update,
 *								UserID					sender_id)
 *
 *	Public Function Description
 *		This routine is responsible for processing the decoded PDU data.
 *		It essentially passes the PDU on along to the appropriate roster.
 *
 *	Formal Parameters:
 *		roster_update	-	(i) This is a pointer to a structure that
 *									holds the decoded PDU data.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	FlushRosterUpdateIndication(
 *								PNodeInformation		node_information)
 *
 *	Public Function Description
 *		This routine is used to access any PDU data that might currently be
 *		queued inside the conference roster.  It also is responsible for 
 *		flushing a roster update message if necessary.
 *
 *	Formal Parameters:
 *		node_information	-	(o) Pointer to the PDU buffer to fill in.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	GetFullRosterRefreshPDU(
 *								PNodeInformation		node_information)
 *
 *	Public Function Description
 *		This routine is used to access a full conference roster refresh.
 *
 *	Formal Parameters:
 *		node_information	-	(o) Pointer to the PDU buffer to fill in.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL			Contains(UserID		node_record_entry)
 *
 *	Public Function Description
 *		This routine is used to determine if the specified record exists in
 *		the conference roster.
 *
 *	Formal Parameters:
 *		node_record_entry	(i)	Node ID of record to check for
 *
 *	Return Value:
 *		TRUE	-	If the record is contained in the conference roster.
 *		FALSE	-	If the record is not contained in the conference roster.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	CConfRoster		*GetConferenceRosterPointer ()
 *
 *	Public Function Description
 *		This routine is used to access a pointer to the conference roster
 *		managed by this conference roster manager.  The global roster
 *		is always returned by this routine.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		A pointer to the Global conference roster.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	USHORT		GetNumberOfNodeRecords ();
 *
 *	Public Function Description
 *		This routine returns the total number of conference roster records
 *		contained in the global conference roster record list.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The number of records in the conference roster list.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\csap.h ===
/*
 *	csap.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class CControlSAP.  CControlSAP objects
 *		represent the node controller's Service Access Point to GCC.  This 
 *		class inherits from the SAP class.  The CControlSAP object is 
 *		instantiated when GCCInitialize is called.  From that point forward all
 *		messages to and from the node controller pass through this object.  The
 *		primary responsibility of the CControlSAP object is to route incoming GCC
 *		primitives to their appropriate destination and to convert the 
 *		primitives into a form that is understandable to the objects processing
 *		them. A secondary responsibility of the CControlSAP is to maintain a 
 *		queue for all indication and confirm messages that are eventually sent 
 *		back to the node controller.  
 *
 *		Commands received from the Application Interface (or Node Controller) 
 *		can be routed by the CControlSAP in one of two directions.  Either to the
 *		controller or to a specified conference.  Commands that are passed to 
 *		the controller, are done so using owner callbacks.  Commands that are 
 *		routed to conferences are done so using command target calls and are 
 *		routed based on a Conference ID.  Whenever a new CConf is 
 *		instantiated by the Controller, the CConf informs the CControlSAP 
 *		of its existence by registering its conference ID with it.  The 
 *		CControlSAP maintains a list of command target objects which are indexed
 *		by the conference ID.  
 *
 *	Caveats:
 *		Structures that are passed back to the node controller
 *		are defined in GCC.H.
 *
 *	Author:
 *		blp
 */

#ifndef _GCC_CONTROL_SAP_
#define _GCC_CONTROL_SAP_

/*
 * include files 
 */
#include "sap.h"
#include "password.h"
#include "privlist.h"
#include "conflist.h"

#define GCCNC_DIRECT_INDICATION
#define GCCNC_DIRECT_CONFIRM


/* 
 *	Structure used for passing conference create information from control sap
 *	to the controller.
 */

typedef struct
{
    GCCConfCreateReqCore    Core;
    CPassword               *convener_password;
    CPassword               *password;
    BOOL					fSecure;
    CUserDataListContainer  *user_data_list;
}
    CONF_CREATE_REQUEST;    // internal data structure


typedef struct
{
	GCCNumericString				conference_modifier;
	GCCConfID   					conference_id;
	BOOL							use_password_in_the_clear;
	PDomainParameters 				domain_parameters;
	UINT        					number_of_network_addresses;
	PGCCNetworkAddress 	*			network_address_list;
	CUserDataListContainer		    *user_data_list;
	GCCResult						result;
}
    ConfCreateResponseInfo, *PConfCreateResponseInfo;

typedef struct
{
	GCCNodeType					node_type;
	PGCCAsymmetryIndicator		asymmetry_indicator;
	TransportAddress			calling_address;
	TransportAddress			called_address;
	BOOL                        fSecure;
	CUserDataListContainer      *user_data_list;
	PConnectionHandle			connection_handle;
}
    ConfQueryRequestInfo, *PConfQueryRequestInfo;

typedef struct
{
	GCCResponseTag				query_response_tag;
	GCCNodeType					node_type;
	PGCCAsymmetryIndicator		asymmetry_indicator;
	CUserDataListContainer      *user_data_list;
	GCCResult					result;
}
    ConfQueryResponseInfo, *PConfQueryResponseInfo;

typedef struct
{
	PGCCConferenceName				conference_name;
	GCCNumericString				called_node_modifier;
	GCCNumericString				calling_node_modifier;
	CPassword                       *convener_password;
	CPassword                       *password_challenge;
	LPWSTR							pwszCallerID;
	TransportAddress				calling_address;
	TransportAddress				called_address;
	BOOL							fSecure;
	PDomainParameters 				domain_parameters;
	UINT        					number_of_network_addresses;
	PGCCNetworkAddress			*	local_network_address_list;
	CUserDataListContainer  	    *user_data_list;
	PConnectionHandle				connection_handle;
}
    ConfJoinRequestInfo, *PConfJoinRequestInfo;

typedef struct
{
	GCCConfID   					conference_id;
	CPassword                       *password_challenge;
	CUserDataListContainer  	    *user_data_list;
	GCCResult						result;
	ConnectionHandle				connection_handle;
}
    ConfJoinResponseInfo, *PConfJoinResponseInfo;

typedef struct
{
	UserID						user_id;
	ConnectionHandle			connection_handle;
	GCCConfID   				conference_id;
	BOOL						command_target_call;
}
    JoinResponseStructure, *PJoinResponseStructure;

typedef struct
{
	GCCConfID   			conference_id;
	GCCNumericString		conference_modifier;
	BOOL					fSecure;
	PDomainParameters 		domain_parameters;
	UINT        			number_of_network_addresses;
	PGCCNetworkAddress	*	local_network_address_list;
	CUserDataListContainer  *user_data_list;
	GCCResult				result;
}
    ConfInviteResponseInfo, *PConfInviteResponseInfo;

#ifdef NM_RESET_DEVICE
typedef struct
{
	LPSTR						device_identifier;
}
    ResetDeviceInfo, *PResetDeviceInfo;
#endif // #ifdef NM_RESET_DEVICE

/*
 *	Container used to hold the list of outstanding join response 
 *	structures.
 */
class CJoinResponseTagList2 : public CList2
{
    DEFINE_CLIST2(CJoinResponseTagList2, JoinResponseStructure*, GCCResponseTag)
};



//
//	This structure holds any data that may need to be deleted after a particular
//	GCC message is delivered.
//
typedef struct DataToBeDeleted
{
	LPSTR							pszNumericConfName;
	LPWSTR							pwszTextConfName;
	LPSTR							pszConfNameModifier;
	LPSTR							pszRemoteModifier;
	LPWSTR							pwszConfDescriptor;
	LPWSTR							pwszCallerID;
	LPSTR							pszCalledAddress;
	LPSTR							pszCallingAddress;
	LPBYTE							user_data_list_memory;
	DomainParameters                *pDomainParams;
	GCCConferencePrivileges         *conductor_privilege_list;
	GCCConferencePrivileges         *conducted_mode_privilege_list;
	GCCConferencePrivileges         *non_conducted_privilege_list;
	CPassword                       *convener_password;
	CPassword                       *password;
	CConfDescriptorListContainer    *conference_list;
	CAppRosterMsg					*application_roster_message;
	CConfRosterMsg					*conference_roster_message;
}
    DataToBeDeleted, *PDataToBeDeleted;

//
// Control SAP callback message.
//
typedef GCCMessage      GCCCtrlSapMsg;
typedef struct GCCCtrlSapMsgEx
{
    //
    // Message body
    //
    GCCCtrlSapMsg       Msg;

    //
    // Data to free later.
    //
    LPBYTE              pBuf;
    DataToBeDeleted     *pToDelete;
}
    GCCCtrlSapMsgEx, *PGCCCtrlSapMsgEx;


/*
 *	Class definition:
 */
class CControlSAP : public CBaseSap, public IT120ControlSAP
{
    friend class GCCController;
    friend class CConf;
    friend class CAppRosterMgr; // for AppRosterReportIndication()
    friend class MCSUser; // for ForwardedConfJoinIndication()

    friend LRESULT CALLBACK SapNotifyWndProc(HWND, UINT, WPARAM, LPARAM);

public:

    CControlSAP(void);
    ~CControlSAP(void);

    HWND GetHwnd ( void ) { return m_hwndNotify; }

    //
    // Node Controller (NC conference manager) callback
    //
    void RegisterNodeController ( LPFN_T120_CONTROL_SAP_CB pfn, LPVOID user_defined )
    {
        m_pfnNCCallback = pfn;
        m_pNCData = user_defined;
    }
    void UnregisterNodeController ( void )
    {
        m_pfnNCCallback = NULL;
        m_pNCData = NULL;
    }


    //
    // IT120ControlSAP
    //

    STDMETHOD_(void, ReleaseInterface) (THIS);

    /*
     *  GCCError    ConfCreateRequest()
     *        This routine is a request to create a new conference. Both 
     *        the local node and the node to which the create conference 
     *        request is directed to, join the conference automatically.  
     */
    STDMETHOD_(GCCError, ConfCreateRequest) (THIS_
                    GCCConfCreateRequest *,
                    GCCConfID *);

    /*    
     *  GCCError    ConfCreateResponse()
     *        This procedure is a remote node controller's response to a con-
     *        ference creation request by the convener. 
     */

    STDMETHOD_(GCCError, ConfCreateResponse) (THIS_
                    GCCNumericString            conference_modifier,
                    GCCConfID,
                    BOOL                        use_password_in_the_clear,
                    DomainParameters           *domain_parameters,
                    UINT                        number_of_network_addresses,
                    GCCNetworkAddress         **local_network_address_list,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    GCCResult);

    /*
     *  GCCError    ConfQueryRequest()
     *        This routine is a request to query a node for information about the
     *        conferences that exist at that node.
     */
    STDMETHOD_(GCCError, ConfQueryRequest) (THIS_
                    GCCNodeType                 node_type,
                    GCCAsymmetryIndicator      *asymmetry_indicator,
                    TransportAddress            calling_address,
                    TransportAddress            called_address,
                    BOOL                        fSecure,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    ConnectionHandle           *connection_handle);

    STDMETHOD_(void, CancelConfQueryRequest) (THIS_
                    ConnectionHandle);

    /*
     *  GCCError    ConfQueryResponse()
     *        This routine is called in response to a conference query request.
     */
    STDMETHOD_(GCCError, ConfQueryResponse) (THIS_
                    GCCResponseTag              query_response_tag,
                    GCCNodeType                 node_type,
                    GCCAsymmetryIndicator      *asymmetry_indicator,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    GCCResult);

    /*
     *  GCCError    AnnouncePresenceRequest()
     *        This routine is invoked by node controller when a node joins a 
     *        conference, to announce the presence of the new node to all
     *        other nodes of the conference. This should be followed by a
     *        GCCConferenceReport indication by the GCC to all nodes.
     */
    STDMETHOD_(GCCError, AnnouncePresenceRequest) (THIS_
                    GCCConfID,
                    GCCNodeType                 node_type,
                    GCCNodeProperties           node_properties,
                    LPWSTR                      pwszNodeName,
                    UINT                        number_of_participants,
                    LPWSTR                     *ppwszParticipantNameList,
                    LPWSTR                      pwszSiteInfo,
                    UINT                        number_of_network_addresses,
                    GCCNetworkAddress         **network_address_list,
                    LPOSTR                      alternative_node_id,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list);

    /*
     *  GCCError    ConfJoinRequest()
     *        This routine is invoked by node controller to cause the local
     *        node to join an existing conference.    
     */
    STDMETHOD_(GCCError, ConfJoinRequest) (THIS_
                    GCCConferenceName          *conference_name,
                    GCCNumericString            called_node_modifier,
                    GCCNumericString            calling_node_modifier,
                    GCCPassword                *convener_password,
                    GCCChallengeRequestResponse*password_challenge,
                    LPWSTR                      pwszCallerID,
                    TransportAddress            calling_address,
                    TransportAddress            called_address,
                    BOOL						fSecure,
                    DomainParameters           *domain_parameters,
                    UINT                        number_of_network_addresses,
                    GCCNetworkAddress         **local_network_address_list,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    ConnectionHandle           *connection_handle,
                    GCCConfID                  *pnConfID);

    /*
     *  GCCError    ConfJoinResponse()
     *        This routine is remote node controller's response to conference join 
     *        request by the local node controller.
     */
    STDMETHOD_(GCCError, ConfJoinResponse) (THIS_
                    GCCResponseTag              join_response_tag,
                    GCCChallengeRequestResponse*password_challenge,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    GCCResult);

    /*
     *  GCCError    ConfInviteRequest()
     *        This routine is invoked by node controller to invite a node  
     *        to join a conference.
     */
    STDMETHOD_(GCCError, ConfInviteRequest) (THIS_
                    GCCConfID,
                    LPWSTR                      pwszCallerID,
                    TransportAddress            calling_address,
                    TransportAddress            called_address,
                    BOOL						fSecure,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    ConnectionHandle           *connection_handle);

    STDMETHOD_(void, CancelInviteRequest) (THIS_
                    GCCConfID,
                    ConnectionHandle);

    /*
     *  GCCError    ConfInviteResponse()
     *        This routine is invoked by node controller to respond to an
     *        invite indication.
     */
    STDMETHOD_(GCCError, ConfInviteResponse) (THIS_
                    GCCConfID,
                    GCCNumericString            conference_modifier,
                    BOOL						fSecure,
                    DomainParameters           *domain_parameters,
                    UINT                        number_of_network_addresses,
                    GCCNetworkAddress         **local_network_address_list,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    GCCResult);

    /*
     *  GCCError    ConfAddResponse()
     */
    STDMETHOD_(GCCError, ConfAddResponse) (THIS_
                    GCCResponseTag              app_response_tag,
                    GCCConfID,
                    UserID                      requesting_node,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    GCCResult);

    /*
     *  GCCError    ConfLockResponse()
     *        This routine is invoked by node controller to respond to a
     *        lock indication.
     */
    STDMETHOD_(GCCError, ConfLockResponse) (THIS_
                    GCCConfID,
                    UserID                      requesting_node,
                    GCCResult);

    /*
     *  GCCError    ConfDisconnectRequest()
     *        This routine is used by a node controller to disconnect itself
     *        from a specified conference. GccConferenceDisconnectIndication
     *        sent to all other nodes of the conference. This is for client 
     *        initiated case.
     */
    STDMETHOD_(GCCError, ConfDisconnectRequest) (THIS_
                    GCCConfID);

    /*
     *  GCCError    ConfEjectUserRequest()
     */
    STDMETHOD_(GCCError, ConfEjectUserRequest) (THIS_
                    GCCConfID,
                    UserID                      ejected_node_id,
                    GCCReason);

    /*
     *  GCCError    AppletInvokeRequest()
     */
    STDMETHOD_(GCCError, AppletInvokeRequest) (THIS_
                    GCCConfID,
                    UINT                        number_of_app_protcol_entities,
                    GCCAppProtocolEntity      **app_protocol_entity_list,
                    UINT                        number_of_destination_nodes,
                    UserID                     *list_of_destination_nodes);

    /*
     *  GCCError    ConfRosterInqRequest()
     *        This routine is invoked to request a conference roster.  It can be
     *        called by either the Node Controller or the client application.
     */
    STDMETHOD_(GCCError, ConfRosterInqRequest) (THIS_
                    GCCConfID);

    /*
     *  GCCError    ConductorGiveResponse()
     */
    STDMETHOD_(GCCError, ConductorGiveResponse) (THIS_
                    GCCConfID,
                    GCCResult);

    /*
     *  GCCError    ConfTimeRemainingRequest()
     */
    STDMETHOD_(GCCError, ConfTimeRemainingRequest) (THIS_
                    GCCConfID,
                    UINT                        time_remaining,
                    UserID                      node_id);



    STDMETHOD_(GCCError, GetParentNodeID) (THIS_
                    GCCConfID,
                    GCCNodeID *);

#ifdef JASPER // ------------------------------------------------
    /*
     *  GCCError    ConfAddRequest()
     */
    STDMETHOD_(GCCError, ConfAddRequest) (THIS_
                    GCCConfID,
                    UINT                        number_of_network_addresses,
                    GCCNetworkAddress         **network_address_list,
                    UserID                      adding_node,
                    UINT                         number_of_user_data_members,
                    GCCUserData               **user_data_list);

    /*
     *  GCCError    ConfLockRequest()
     *        This routine is invoked by node controller to lock a conference.
     */
    STDMETHOD_(GCCError, ConfLockRequest) (THIS_
                    GCCConfID);

    /*
     *  GCCError    ConfUnlockRequest()
     *        This routine is invoked by node controller to unlock a conference.
     */
    STDMETHOD_(GCCError, ConfUnlockRequest) (THIS_
                    GCCConfID);

    /*
     *  GCCError    ConfUnlockResponse()
     *        This routine is invoked by node controller to respond to an
     *        unlock indication.
     */
    STDMETHOD_(GCCError, ConfUnlockResponse) (
                    GCCConfID,
                    UserID                      requesting_node,
                    GCCResult);

    /*
     *  GCCError    ConfTerminateRequest()
     */
    STDMETHOD_(GCCError, ConfTerminateRequest) (THIS_
                    GCCConfID,
                    GCCReason);

    /*
     *  GCCError    ConfTransferRequest()
     */
    STDMETHOD_(GCCError, ConfTransferRequest) (THIS_
                    GCCConfID,
                    GCCConferenceName          *destination_conference_name,
                    GCCNumericString            destination_conference_modifier,
                    UINT                        number_of_destination_addresses,
                    GCCNetworkAddress         **destination_address_list,
                    UINT                        number_of_destination_nodes,
                    UserID                     *destination_node_list,
                    GCCPassword                *password);

    /*
     *  GCCError    ConductorAssignRequest()
     */
    STDMETHOD_(GCCError, ConductorAssignRequest) (THIS_
                    GCCConfID);

    /*
     *  GCCError    ConductorReleaseRequest()
     */
    STDMETHOD_(GCCError, ConductorReleaseRequest) (THIS_
                    GCCConfID);

    /*
     *  GCCError    ConductorPleaseRequest()
     */
    STDMETHOD_(GCCError, ConductorPleaseRequest) (THIS_
                    GCCConfID);

    /*
     *  GCCError    ConductorGiveRequest()
     */
    STDMETHOD_(GCCError, ConductorGiveRequest) (THIS_
                    GCCConfID,
                    UserID                      recipient_user_id);

    /*
     *  GCCError    ConductorPermitAskRequest()
     */
    STDMETHOD_(GCCError, ConductorPermitAskRequest) (THIS_
                            GCCConfID,
                            BOOL                grant_permission);

    /*
     *  GCCError    ConductorPermitGrantRequest()
     */
    STDMETHOD_(GCCError, ConductorPermitGrantRequest) (THIS_
                    GCCConfID,
                    UINT                        number_granted,
                    UserID                     *granted_node_list,
                    UINT                        number_waiting,
                    UserID                     *waiting_node_list);

    /*
     *  GCCError    ConductorInquireRequest()
     */
    STDMETHOD_(GCCError, ConductorInquireRequest) (THIS_
                    GCCConfID);

    /*
     *  GCCError    ConfTimeInquireRequest()
     */
    STDMETHOD_(GCCError, ConfTimeInquireRequest) (THIS_
                    GCCConfID,
                    BOOL                        time_is_conference_wide);

    /*
     *  GCCError    ConfExtendRequest()
     */
    STDMETHOD_(GCCError, ConfExtendRequest) (THIS_
                    GCCConfID,
                    UINT                        extension_time,
                    BOOL                        time_is_conference_wide);

    /*
     *  GCCError    ConfAssistanceRequest()
     */
    STDMETHOD_(GCCError, ConfAssistanceRequest) (THIS_
                    GCCConfID,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list);

    /*
     *  GCCError    TextMessageRequest()
     */
    STDMETHOD_(GCCError, TextMessageRequest) (THIS_
                    GCCConfID,
                    LPWSTR                      pwszTextMsg,
                    UserID                      destination_node);
#endif // JASPER // ------------------------------------------------


#ifdef NM_RESET_DEVICE
    GCCError	ResetDevice ( LPSTR device_identifier );
#endif // NM_RESET_DEVICE

protected:

    //
    // These methods are called by GCC Controller.
    //

    GCCError	ConfCreateIndication (
    			PGCCConferenceName			conference_name,
    			GCCConfID   				conference_id,
    			CPassword                   *convener_password,
    			CPassword                   *password,
    			BOOL						conference_is_locked,
    			BOOL						conference_is_listed,
    			BOOL						conference_is_conductible,
    			GCCTerminationMethod		termination_method,
    			PPrivilegeListData			conductor_privilege_list,
    			PPrivilegeListData			conduct_mode_privilege_list,
    			PPrivilegeListData			non_conduct_privilege_list,
    			LPWSTR						pwszConfDescriptor,
    			LPWSTR						pwszCallerID,
    			TransportAddress			calling_address,
    			TransportAddress			called_address,
    			PDomainParameters			domain_parameters,
    			CUserDataListContainer      *user_data_list,
    			ConnectionHandle			connection_handle);

    GCCError	ConfQueryIndication (
    			GCCResponseTag				query_response_tag,
    			GCCNodeType					node_type,
    			PGCCAsymmetryIndicator		asymmetry_indicator,
    			TransportAddress			calling_address,
    			TransportAddress			called_address,
    			CUserDataListContainer      *user_data_list,
    			ConnectionHandle			connection_handle);

    GCCError	ConfQueryConfirm (
    			GCCNodeType					node_type,
    			PGCCAsymmetryIndicator		asymmetry_indicator,
    			CConfDescriptorListContainer *conference_list,
    			CUserDataListContainer      *user_data_list,
    			GCCResult					result,
    			ConnectionHandle			connection_handle);

    GCCError	ConfJoinIndication (
    			GCCConfID   				conference_id,
    			CPassword                   *convener_password,
    			CPassword                   *password_challenge,
    			LPWSTR						pwszCallerID,
    			TransportAddress			calling_address,
    			TransportAddress			called_address,
    			CUserDataListContainer      *user_data_list,
    			BOOL						intermediate_node,
    			ConnectionHandle			connection_handle);

    GCCError	ConfInviteIndication (
    			GCCConfID   			conference_id,
    			PGCCConferenceName		conference_name,
    			LPWSTR					pwszCallerID,
    			TransportAddress		calling_address,
    			TransportAddress		called_address,
		        BOOL					fSecure,
    			PDomainParameters 		domain_parameters,
    			BOOL					clear_password_required,
    			BOOL					conference_is_locked,
    			BOOL					conference_is_listed,
    			BOOL					conference_is_conductible,
    			GCCTerminationMethod	termination_method,
    			PPrivilegeListData		conductor_privilege_list,
    			PPrivilegeListData		conducted_mode_privilege_list,
    			PPrivilegeListData		non_conducted_privilege_list, 
    			LPWSTR					pwszConfDescriptor, 
    			CUserDataListContainer  *user_data_list,
    			ConnectionHandle		connection_handle);

#ifdef TSTATUS_INDICATION
    GCCError	TransportStatusIndication (
    				PTransportStatus		transport_status);

    GCCError	StatusIndication (
    				GCCStatusMessageType	status_message,
    				UINT					parameter);
#endif // TSTATUS_INDICATION

    GCCError	ConnectionBrokenIndication (
    				ConnectionHandle		connection_handle);

    //
    // These methods are called by CConf.
    //

    GCCError	ConfCreateConfirm (
    				PGCCConferenceName	  	conference_name,
    				GCCNumericString		conference_modifier,
    				GCCConfID   			conference_id,
    				PDomainParameters		domain_parameters,
    				CUserDataListContainer  *user_data_list,
    				GCCResult				result,
    				ConnectionHandle		connection_handle);

    GCCError	ConfDisconnectConfirm (
    			GCCConfID   		  			conference_id,
    			GCCResult						result);

    GCCError	ConfPermissionToAnnounce (
    				GCCConfID   			conference_id,
    				UserID					gcc_node_id);

    GCCError	ConfAnnouncePresenceConfirm (
    				GCCConfID   			conference_id,
    				GCCResult				result);

    GCCError	ConfDisconnectIndication (
    				GCCConfID   			conference_id,
    				GCCReason				reason,
    				UserID					disconnected_node_id);

    GCCError  	ForwardedConfJoinIndication (
    				UserID					sender_id,
    				GCCConfID   			conference_id,
    				CPassword               *convener_password,
    				CPassword               *password_challange,
    				LPWSTR					pwszCallerID,
    				CUserDataListContainer  *user_data_list);

    GCCError  	ConfJoinConfirm (
    				PGCCConferenceName		conference_name,
    				GCCNumericString		remote_modifier,
    				GCCNumericString		local_modifier,
    				GCCConfID   			conference_id,
    				CPassword               *password_challenge,
    				PDomainParameters		domain_parameters,
    				BOOL					password_in_the_clear,
    				BOOL					conference_locked,
    				BOOL					conference_listed,
    				BOOL					conference_conductible,
    				GCCTerminationMethod	termination_method,
    				PPrivilegeListData		conductor_privilege_list,
    				PPrivilegeListData		conduct_mode_privilege_list,
    				PPrivilegeListData		non_conduct_privilege_list,
    				LPWSTR					pwszConfDescription,
    				CUserDataListContainer  *user_data_list,	
    				GCCResult				result,
    				ConnectionHandle		connection_handle,
    				PBYTE                   pbRemoteCred,
    				DWORD                   cbRemoteCred);

    GCCError	ConfInviteConfirm (
    				GCCConfID   			conference_id,
    				CUserDataListContainer  *user_data_list,
    				GCCResult				result,
    				ConnectionHandle		connection_handle);

    GCCError	ConfTerminateIndication (
    				GCCConfID   			conference_id,
    				UserID					requesting_node_id,
    				GCCReason				reason);

    GCCError	ConfLockIndication (
    				GCCConfID   			conference_id,
    				UserID					source_node_id);

    GCCError	ConfEjectUserIndication (
    				GCCConfID   			conference_id,
    				GCCReason				reason,
    				UserID					gcc_node_id);

    GCCError	ConfTerminateConfirm (
    				GCCConfID   			conference_id,
    				GCCResult				result);

    GCCError	ConductorGiveIndication (
    				GCCConfID   			conference_id);

    GCCError	ConfTimeInquireIndication (
    				GCCConfID   			conference_id,
    				BOOL					time_is_conference_wide,
    				UserID					requesting_node_id);

#ifdef JASPER
    GCCError 	ConfLockReport (
    				GCCConfID   			conference_id,
    				BOOL					conference_is_locked);

    GCCError	ConfLockConfirm (
    				GCCResult				result,
    				GCCConfID   			conference_id);

    GCCError	ConfUnlockIndication (
    				GCCConfID   			conference_id,
    				UserID					source_node_id);

    GCCError 	ConfUnlockConfirm (
    				GCCResult				result,
    				GCCConfID   			conference_id);

    GCCError	ConfEjectUserConfirm (
    				GCCConfID   			conference_id,
    				UserID					ejected_node_id,
    				GCCResult				result);

    GCCError	ConductorAssignConfirm (
    				GCCResult				result,
    				GCCConfID   			conference_id);

    GCCError	ConductorReleaseConfirm (
    				GCCResult				result,
    				GCCConfID   			conference_id);

    GCCError	ConductorPleaseIndication (
    				GCCConfID   			conference_id,
    				UserID					requester_user_id);

    GCCError	ConductorPleaseConfirm (
    				GCCResult				result,
    				GCCConfID   			conference_id);

    GCCError	ConductorGiveConfirm (
    				GCCResult				result,
    				GCCConfID   			conference_id,
    				UserID					recipient_node);

    GCCError	ConductorPermitAskIndication (
    				GCCConfID   			conference_id,
    				BOOL					grant_flag,
    				UserID					requester_id);

    GCCError	ConductorPermitAskConfirm (
    				GCCResult				result,
    				BOOL					grant_permission,
    				GCCConfID   			conference_id);

    GCCError	ConductorPermitGrantConfirm (
    				GCCResult				result,
    				GCCConfID   			conference_id);

    GCCError	ConfTimeRemainingIndication (
    				GCCConfID   			conference_id,
    				UserID					source_node_id,
    				UserID					node_id,
    				UINT					time_remaining);

    GCCError	ConfTimeRemainingConfirm (
    				GCCConfID   			conference_id,
    				GCCResult				result);

    GCCError	ConfTimeInquireConfirm (
    				GCCConfID   			conference_id,
    				GCCResult				result);

    GCCError	ConfExtendIndication (
    				GCCConfID   			conference_id,
    				UINT					extension_time,
    				BOOL					time_is_conference_wide,
    				UserID                  requesting_node_id);

    GCCError 	ConfExtendConfirm (
    				GCCConfID   			conference_id,
    				UINT					extension_time,
    				GCCResult				result);

    GCCError	ConfAssistanceIndication (
    				GCCConfID   			conference_id,
    				CUserDataListContainer  *user_data_list,
    				UserID					source_node_id);

    GCCError	ConfAssistanceConfirm (
    				GCCConfID   	 		conference_id,
    				GCCResult				result);

    GCCError	TextMessageIndication (
    				GCCConfID   			conference_id,
    				LPWSTR					pwszTextMsg,
    				UserID					source_node_id);

    GCCError	TextMessageConfirm (
    				GCCConfID   			conference_id,
    				GCCResult				result);

    GCCError	ConfTransferIndication (
    				GCCConfID   		conference_id,
    				PGCCConferenceName	destination_conference_name,
    				GCCNumericString	destination_conference_modifier,
    				CNetAddrListContainer *destination_address_list,
    				CPassword           *password);

    GCCError	ConfTransferConfirm (
    				GCCConfID   		conference_id,
    				PGCCConferenceName	destination_conference_name,
    				GCCNumericString	destination_conference_modifier,
    				UINT				number_of_destination_nodes,
    				PUserID				destination_node_list,
    				GCCResult			result);
#endif // JASPER

    GCCError	ConfAddIndication (
    				GCCConfID   		conference_id,
    				GCCResponseTag		add_response_tag,
    				CNetAddrListContainer *network_address_list,
    				CUserDataListContainer *user_data_list,
    				UserID				requesting_node);

    GCCError	ConfAddConfirm (
    				GCCConfID   		conference_id,
    				CNetAddrListContainer *network_address_list,
    				CUserDataListContainer *user_data_list,
    				GCCResult			result);

    GCCError	SubInitializationCompleteIndication (
    				UserID				user_id,
    				ConnectionHandle	connection_handle);

    /* ------ pure virtual in CBaseSap (shared with CAppSap) ------ */

    GCCError	ConfRosterInquireConfirm (
    					GCCConfID,
    					PGCCConferenceName,
    					LPSTR           			conference_modifier,
    					LPWSTR						pwszConfDescriptor,
    					CConfRoster *,
    					GCCResult,
    					GCCAppSapMsgEx **);

    GCCError	AppRosterInquireConfirm (
    					GCCConfID,
    					CAppRosterMsg *,
    					GCCResult,
                        GCCAppSapMsgEx **);

    GCCError	ConductorInquireConfirm (
    					GCCNodeID				nidConductor,
    					GCCResult,
    					BOOL					permission_flag,
    					BOOL					conducted_mode,
    					GCCConfID);

    GCCError AppInvokeConfirm (
                        GCCConfID,
                        CInvokeSpecifierListContainer *,
                        GCCResult,
                        GCCRequestTag);

    GCCError AppInvokeIndication (
                        GCCConfID,
                        CInvokeSpecifierListContainer *,
                        GCCNodeID nidInvoker);

    GCCError ConfRosterReportIndication ( GCCConfID, CConfRosterMsg * );

    GCCError AppRosterReportIndication ( GCCConfID, CAppRosterMsg * );


    /* ------ from CBaseSap ------ */

	GCCError	ConductorAssignIndication (
					UserID					conductor_user_id,
					GCCConfID   			conference_id);

	GCCError	ConductorReleaseIndication (
					GCCConfID   			conference_id);

	GCCError	ConductorPermitGrantIndication (
					GCCConfID   			conference_id,
					UINT					number_granted,
					GCCNodeID				*granted_node_list,
					UINT					number_waiting,
					GCCNodeID				*waiting_node_list,
					BOOL					permission_is_granted);

protected:

    void NotifyProc ( GCCCtrlSapMsgEx * );
    void WndMsgHandler ( UINT uMsg, WPARAM wParam, LPARAM lParam );

private:

    GCCCtrlSapMsgEx * CreateCtrlSapMsgEx ( GCCMessageType, BOOL fUseToDelete = FALSE );
    void FreeCtrlSapMsgEx ( GCCCtrlSapMsgEx * );

#if defined(GCCNC_DIRECT_INDICATION) || defined(GCCNC_DIRECT_CONFIRM)
    void SendCtrlSapMsg ( GCCCtrlSapMsg *pCtrlSapMsg );
#endif // GCCNC_DIRECT_INDICATION

    void PostCtrlSapMsg ( GCCCtrlSapMsgEx *pCtrlSapMsgEx );
    void PostConfirmCtrlSapMsg ( GCCCtrlSapMsgEx *pCtrlSapMsgEx ) { PostCtrlSapMsg(pCtrlSapMsgEx); }
    void PostIndCtrlSapMsg ( GCCCtrlSapMsgEx *pCtrlSapMsgEx ) { PostCtrlSapMsg(pCtrlSapMsgEx); }

    void PostAsynDirectConfirmMsg ( UINT uMsg, WPARAM wParam, GCCConfID nConfID )
    {
        ASSERT(NULL != m_hwndNotify);
        ::PostMessage(m_hwndNotify, CSAPCONFIRM_BASE + uMsg, wParam, (LPARAM) nConfID);
    }

    void PostAsynDirectConfirmMsg ( UINT uMsg, GCCResult nResult, GCCConfID nConfID )
    {
        PostAsynDirectConfirmMsg(uMsg, (WPARAM) nResult, nConfID);
    }

    void PostAsynDirectConfirmMsg ( UINT uMsg, GCCResult nResult, GCCNodeID nid, GCCConfID nConfID )
    {
        PostAsynDirectConfirmMsg(uMsg, (WPARAM) MAKELONG(nResult, nid), nConfID);
    }

    void PostAsynDirectConfirmMsg ( UINT uMsg, GCCReason nReason, GCCNodeID nid, GCCConfID nConfID )
    {
        PostAsynDirectConfirmMsg(uMsg, (WPARAM) MAKELONG(nReason, nid), nConfID);
    }

    void PostAsynDirectConfirmMsg ( UINT uMsg, GCCResult nResult, BOOL flag, GCCConfID nConfID )
    {
        flag = ! (! flag);  // to make sure it is either TRUE or FALSE
        ASSERT(flag == TRUE || flag == FALSE);
        PostAsynDirectConfirmMsg(uMsg, (WPARAM) MAKELONG(nResult, flag), nConfID);
    }


    void HandleResourceFailure ( void )
    {
        ERROR_OUT(("CSAPHandleResourceFailure: Resource Error occurred"));
        #ifdef TSTATUS_INDICATION
        StatusIndication(GCC_STATUS_CTL_SAP_RESOURCE_ERROR, 0);
        #endif
    }
    void HandleResourceFailure ( GCCError rc )
    {
        if (GCC_ALLOCATION_FAILURE == rc)
        {
            HandleResourceFailure();
        }
    }

    GCCError		QueueJoinIndication (
    					GCCResponseTag				response_tag,
    					GCCConfID   				conference_id,
    					CPassword                   *convener_password,
    					CPassword                   *password_challenge,
    					LPWSTR						pwszCallerID,
    					TransportAddress			calling_address,
    					TransportAddress			called_address,
    					CUserDataListContainer      *user_data_list,
    					BOOL						intermediate_node,
    					ConnectionHandle			connection_handle);
    					
    BOOL			IsNumericNameValid ( GCCNumericString );

    BOOL			IsTextNameValid ( LPWSTR );

    GCCError		RetrieveUserDataList (
    					CUserDataListContainer  *user_data_list_object,
    					UINT					*number_of_data_members,
    					PGCCUserData 			**user_data_list,
    					LPBYTE                  *ppUserDataMemory);

private:

    //
    // Node Controller (NC conference manager) callback
    //
    LPFN_T120_CONTROL_SAP_CB    m_pfnNCCallback;
    LPVOID                      m_pNCData;

    GCCResponseTag              m_nJoinResponseTag;
    CJoinResponseTagList2       m_JoinResponseTagList2;
};


extern CControlSAP *g_pControlSap;


//
// Some handy utility functions to set up DataToBeDeleted in GCCCtrlSapMsgEx.
//
#ifdef GCCNC_DIRECT_INDICATION

__inline void
CSAP_CopyDataToGCCMessage_ConfName
(
    GCCConfName     *pSrcConfName,
    GCCConfName     *pDstConfName
)
{
    *pDstConfName = *pSrcConfName;
}

__inline void
CSAP_CopyDataToGCCMessage_Modifier
(
    GCCNumericString    pszSrc,
    GCCNumericString    *ppszDst
)
{
    *ppszDst = pszSrc;
}

__inline void
CSAP_CopyDataToGCCMessage_Password
(
    CPassword           *pSrcPassword,
    GCCPassword         **ppDstPassword
)
{
    *ppDstPassword = NULL;
    if (NULL != pSrcPassword)
    {
        pSrcPassword->LockPasswordData();
        pSrcPassword->GetPasswordData(ppDstPassword);
    }
}

__inline void
CSAP_CopyDataToGCCMessage_Challenge
(
    CPassword                       *pSrcPassword,
    GCCChallengeRequestResponse     **ppDstChallenge
)
{
    *ppDstChallenge = NULL;
    if (pSrcPassword != NULL)
    {
        pSrcPassword->LockPasswordData();
        pSrcPassword->GetPasswordChallengeData(ppDstChallenge);
    }
}

__inline void
CSAP_CopyDataToGCCMessage_PrivilegeList
(
    PrivilegeListData       *pSrcPrivilegeListData,
    GCCConfPrivileges       **ppDstPrivileges,
    GCCConfPrivileges       *pDstPlaceHolder
)
{
    if (pSrcPrivilegeListData != NULL)
    {
        *ppDstPrivileges = pDstPlaceHolder;
        *pDstPlaceHolder = *(pSrcPrivilegeListData->GetPrivilegeListData());
    }
    else
    {
        *ppDstPrivileges = NULL;
    }
}

__inline void
CSAP_CopyDataToGCCMessage_IDvsDesc
(
    LPWSTR          pwszSrc,
    LPWSTR          *ppwszDst
)
{
    *ppwszDst = pwszSrc;
}

__inline void
CSAP_CopyDataToGCCMessage_Call
(
    TransportAddress    pszSrcTransportAddr,
    TransportAddress    *ppszDstTransportAddr
)
{
    *ppszDstTransportAddr = pszSrcTransportAddr;
}

__inline void
CSAP_CopyDataToGCCMessage_DomainParams
(
    DomainParameters    *pSrcDomainParams,
    DomainParameters    **ppDstDomainParams,
    DomainParameters    *pDstPlaceHolder
)
{
    if (pSrcDomainParams != NULL)
    {
        *ppDstDomainParams = pDstPlaceHolder;
        *pDstPlaceHolder = *pSrcDomainParams;
    }
    else
    {
        *ppDstDomainParams = NULL;
    }
}

#endif // GCCNC_DIRECT_CALLBACK


void CSAP_CopyDataToGCCMessage_ConfName(
				PDataToBeDeleted		data_to_be_deleted,
				PGCCConferenceName		source_conference_name,
				PGCCConferenceName		destination_conference_name,
				PGCCError				pRetCode);

void CSAP_CopyDataToGCCMessage_Modifier(
				BOOL					fRemoteModifier,
				PDataToBeDeleted		data_to_be_deleted,
				GCCNumericString		source_numeric_string,
				GCCNumericString		*destination_numeric_string,
				PGCCError				pRetCode);

void CSAP_CopyDataToGCCMessage_Password(
				BOOL					fConvener,
				PDataToBeDeleted		data_to_be_deleted,
				CPassword               *source_password,
				PGCCPassword			*destination_password,
				PGCCError				pRetCode);

void CSAP_CopyDataToGCCMessage_Challenge(
				PDataToBeDeleted				data_to_be_deleted,
				CPassword                       *source_password,
				PGCCChallengeRequestResponse	*password_challenge,
				PGCCError						pRetCode);

void CSAP_CopyDataToGCCMessage_PrivilegeList(
				PPrivilegeListData			source_privilege_list_data,
				PGCCConferencePrivileges	*destination_privilege_list,
				PGCCError					pRetCode);

void CSAP_CopyDataToGCCMessage_IDvsDesc(
				BOOL				fCallerID,
				PDataToBeDeleted	data_to_be_deleted,
				LPWSTR				source_text_string,
				LPWSTR				*destination_text_string,
				PGCCError			pRetCode);

void CSAP_CopyDataToGCCMessage_Call(
				BOOL				fCalling,
				PDataToBeDeleted	data_to_be_deleted,
				TransportAddress	source_transport_address,
				TransportAddress	*destination_transport_address,
				PGCCError			pRetCode);

void CSAP_CopyDataToGCCMessage_DomainParams(
				PDataToBeDeleted	data_to_be_deleted,
				PDomainParameters	source_domain_parameters,
				PDomainParameters	*destination_domain_parameters,
				PGCCError			pRetCode);

/*
 *	Comments explaining the public and protected class member functions
 */

/*
 *	CControlSAP (		UINT        				owner_message_base,
 *						UINT						application_messsage_base);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This is the control sap constructor. It is responsible for
 *		registering control sap with the application interface via
 *		an owner callback.
 *
 *	Formal Parameters:
 *		owner_object			(i) The owner of this object (the controller)
 *		owner_message_base		(i) Offset into the controller callback message
 *										base.
 *		application_object		(i) The node controller interface object.
 *		application_messsage_base	(i) Offset into the node controller callback
 *											message base.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~ControlSap ();
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This is the CControlSAP destructor.  It is responsible for 
 *		flushing any pending upward bound messages and freeing all
 *		the resources tied up with pending messages.  Also it clears 
 *		the message queue and the queue of command targets that are registered
 *		with it.  Actually all command targets at this point should 
 *		already have been unregistered but this is just a double check.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfCreateRequest(
 *						PGCCConferenceName			conference_name,
 *						GCCNumericString			conference_modifier,
 *						PGCCPassword				convener_password,
 *						PGCCPassword				password,
 *						BOOL						use_password_in_the_clear,
 *						BOOL						conference_is_locked,
 *						BOOL						conference_is_listed,
 *						BOOL						conference_is_conductible,
 *						GCCTerminationMethod		termination_method,
 *						PGCCConferencePrivileges	conduct_privilege_list,
 *						PGCCConferencePrivileges	conduct_mode_privilege_list,
 *						PGCCConferencePrivileges	non_conduct_privilege_list,
 *						LPWSTR						pwszConfDescriptor,
 *						LPWSTR						pwszCallerID,
 *						TransportAddress			calling_address,
 *						TransportAddress			called_address,
 *						PDomainParameters 			domain_parameters,
 *						UINT        				number_of_network_addresses,
 *						PGCCNetworkAddress 		*	local_network_address_list,
 *						UINT					   	number_of_user_data_members,
 *						PGCCUserData			*	user_data_list,				 
 *						PConnectionHandle			connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference 
 *		create request from the node controller.  This function just passes this 
 *		request	to the controller via an owner callback. 
 *
 *	Formal Parameters:
 *		conference_name				(i) Name of the conference.
 *		conference_modifier			(i) Conference modifier numeric string.
 *		convener_password			(i) Password used for convener privileges.
 *		password					(i) Password used for conference create.
 *		use_password_in_the_clear	(i) Flag indicating use clear password.
 *		conference_is_locked		(i) Flag indicating if conference is locked.
 *		conference_is_listed		(i) Flag indicating if conference is listed
 *											in roster.
 *		conference_is_conductible	(i) Flag indicating if conference is
 *											conductable.
 *		termination_method			(i) Method of termination to use.
 *		conduct_privilege_list		(i) List of conductor privileges.
 *		conduct_mode_privilege_list	(i) List of privileges available when in
 *											conducted mode.
 *		non_conduct_privilege_list	(i) List of privileges available when not
 *											in conducted mode.
 *		pwszConfDescriptor			(i) Conference descriptor string.
 *		pwszCallerID				(i) Caller identifier string.
 *		calling_address				(i) Transport address of caller.
 *		called_address				(i) Transport address of party being called.
 *		domain_parameters			(i) Structure holding domain parameters.
 *		number_of_network_addresses	(i) Number of network addresses.
 *		local_network_address_list	(i) List of local network addresses.
 *		number_of_user_data_members	(i) Number of items in user data list.
 *		user_data_list				(i) List of user data items.
 *		connection_handle			(i) Logical connection handle.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error occurred.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_INVALID_CONFERENCE_NAME		- Invalid conference name passed in.
 *		GCC_INVALID_CONFERENCE_MODIFIER - Invalid conference modifier passed.
 *		GCC_FAILURE_CREATING_DOMAIN		- Failure creating domain.
 *		GCC_BAD_NETWORK_ADDRESS			- Bad network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	- Bad network address type passed in.
 *		GCC_CONFERENCE_ALREADY_EXISTS	- Conference specified already exists.
 *		GCC_INVALID_TRANSPORT			- Cannot find specified transport.
 *		GCC_INVALID_ADDRESS_PREFIX		- Bad transport address passed in.
 *		GCC_INVALID_TRANSPORT_ADDRESS	- Bad transport address
 *		GCC_INVALID_PASSWORD			- Invalid password passed in.
 *		GCC_FAILURE_ATTACHING_TO_MCS	- Failure creating MCS user attachment
 *		GCC_BAD_USER_DATA				- Invalid user data passed in.
 *		GCC_BAD_CONNECTION_HANDLE_POINTER - Null connection handle ptr passed in
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfCreateResponse (
 *						PGCCConferenceName			conference_name,
 *						GCCNumericString			conference_modifier,
 *						GCCConfID   				conference_id,
 *						BOOL						use_password_in_the_clear,
 *						PDomainParameters 			domain_parameters,
 *						UINT        				number_of_network_addresses,
 *						PGCCNetworkAddress 		*	local_network_address_list,
 *						UINT					   	number_of_user_data_members,
 *						PGCCUserData			*	user_data_list,				 
 *						GCCResult				 	result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference 
 *		create response from the node controller, to be sent to the provider
 *		that issued the conference create request. This function just passes 
 *		this request to the controller via an owner callback. 
 *
 *	Formal Parameters:
 *		conference_name				(i) Name of conference.
 *		conference_modifier			(i) Conference modifier numeric string.
 *		conference_id				(i) Conference ID.
 *		use_password_in_the_clear	(i) Flag indicating password is clear.
 *		domain_parameters			(i) Structure holding domain parameters.
 *		number_of_network_addresses	(i) Number of local network addresses.
 *		local_network_address_list	(i) List of local network addresses.
 *		number_of_user_data_members	(i) Number of items in list of user data.
 *		user_data_list,				(i) List of user data items.
 *		result						(i) Result code for the create.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error occurred.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_INVALID_CONFERENCE			- An invalid conference was passed in.
 *		GCC_INVALID_CONFERENCE_NAME		- Invalid conference name passed in.
 *		GCC_INVALID_CONFERENCE_MODIFIER - Invalid conference modifier passed in.
 *		GCC_FAILURE_CREATING_DOMAIN		- Failure creating domain.
 *		GCC_CONFERENCE_ALREADY_EXISTS	- Conference specified already exists.
 *		GCC_BAD_USER_DATA				- Invalid user data passed in.
 *		GCC_FAILURE_ATTACHING_TO_MCS	- Failure creating MCS user attachment
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfQueryRequest (
 *						GCCNodeType					node_type,
 *						PGCCAsymmetryIndicator		asymmetry_indicator,
 *						TransportAddress			calling_address,
 *						TransportAddress			called_address,
 *						UINT				   		number_of_user_data_members,
 *						PGCCUserData			*	user_data_list,
 *						PConnectionHandle			connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference 
 *		query request from the node controller. This function just passes 
 *		this request to the controller via an owner callback.   
 *
 *	Formal Parameters:
 *		node_type					(i)	Type of node (terminal, MCU, both).
 *		asymmetry_indicator			(i) Structure used to indicate caller and
 *											called nodes.
 *		calling_address				(i) Transport address of calling node.
 *		called_address				(i) Transport address of node being called.
 *		number_of_user_data_members	(i) Number of items in list of user data.
 *		user_data_list				(i) List of user data items.
 *		connection_handle			(i) Logical connection handle.
 *
 *	Return Value:
 *		GCC_NO_ERROR						- No error occurred.
 *		GCC_ALLOCATION_FAILURE				- A resource error occurred.
 *		GCC_INVALID_ADDRESS_PREFIX			- Bad transport address passed in.
 *		GCC_INVALID_TRANSPORT				- Bad transport address passed in.
 *		GCC_BAD_USER_DATA					- Invalid user data passed in.
 *		GCC_INVALID_TRANSPORT_ADDRESS		- Bad transport address passed in.
 *		GCC_BAD_CONNECTION_HANDLE_POINTER	- Bad connection handle ptr. passed.
 *		GCC_INVALID_NODE_TYPE				- Invalid node type passed in.
 *		GCC_INVALID_ASYMMETRY_INDICATOR		- Asymmetry indicator has invalid
 *													type.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfQueryResponse (
 *						GCCResponseTag				query_response_tag,
 *						GCCNodeType					node_type,
 *						PGCCAsymmetryIndicator		asymmetry_indicator,
 *						UINT				   		number_of_user_data_members,
 *						PGCCUserData			*	user_data_list,
 *						GCCResult					result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the DLL interface when it gets a conference 
 *		query response from the node controller.  This function just passes 
 *		this response to the controller via an owner callback.  
 *
 *	Formal Parameters:
 *		query_response_tag			(i) Tag identifying the query response.
 *		node_type					(i) Type of node (terminal, MCU, both).
 *		asymmetry_indicator			(i) Structure used to identify the caller
 *											and called nodes.
 *		number_of_user_data_members	(i) Number of items in list of user data.
 *		user_data_list				(i) List of user data items.
 *		result						(i) Result code for query.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error occurred.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_BAD_NETWORK_ADDRESS			- Bad network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	- Bad network address type passed in.
 *		GCC_BAD_USER_DATA				- Invalid user data passed in.
 *		GCC_INVALID_NODE_TYPE			- Invalid node type passed in.
 *		GCC_INVALID_ASYMMETRY_INDICATOR	- Invalid asymmetry indicator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	AnnouncePresenceRequest (
 *						GCCConfID   				conference_id,
 *						GCCNodeType					node_type,
 *						GCCNodeProperties			node_properties,
 *						LPWSTR						node_name,
 *						UINT						number_of_participants,
 *						LPWSTR					*	participant_name_list,
 *						LPWSTR						pwszSiteInfo,
 *						UINT        				number_of_network_addresses,
 *						PGCCNetworkAddress		*	network_address_list,
 *						LPOSTR      				alternative_node_id,
 *						UINT						number_of_user_data_members,
 *						PGCCUserData			*	user_data_list);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets an announce 
 *		presence request from the node controller.  This function passes this
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that control sap maintains. The ConferenceID
 *		passed in is used to index the list of command targets to get the
 *		correct conference.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		node_type					(i) Type of node (terminal, MCU, both).
 *		node_properties				(i) Properties of the node.
 *		node_name					(i) Name of the node.
 *		number_of_participants		(i) Number of participants in the conference
 *		participant_name_list		(i) List of conference participants names.
 *		pwszSiteInfo				(i) Other information about the node.
 *		number_of_network_addresses	(i) Number of local network addresses.
 *		network_address_list		(i) List of local network addresses.
 *		alternative_node_id			(i) ID used to associate announcing node
 *											with an alternative node.
 *		number_of_user_data_members	(i) Number of items in list of user data.
 *		user_data_list				(i) List of user data items.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_BAD_NETWORK_ADDRESS			- If an invalid network address is
 *										  		passed in as part of the record.	
 *		GCC_BAD_USER_DATA				- If an invalid user data list is
 *										  		passed in as part of the record.	
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- Conference object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_NODE_TYPE			- Invalid node type passed in.
 *		GCC_INVALID_NODE_PROPERTIES		- Invalid node properties passed in.
 *		GCC_INVALID_CONFERENCE			- Conference not present.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfJoinRequest (
 *					PGCCConferenceName				conference_name,
 *					GCCNumericString				called_node_modifier,
 *					GCCNumericString				calling_node_modifier,
 *					PGCCPassword					convener_password,
 *					PGCCChallengeRequestResponse	password_challenge,
 *					LPWSTR							pwszCallerID,
 *					TransportAddress				calling_address,
 *					TransportAddress				called_address,
 *					PDomainParameters 				domain_parameters,
 *					UINT        					number_of_network_addresses,
 *					PGCCNetworkAddress			*	local_network_address_list,
 *					UINT						   	number_of_user_data_members,
 *					PGCCUserData				*	user_data_list,
 *					PConnectionHandle				connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference 
 *		join request from the node controller, to be sent to the top provider
 *		either directly or through a directly connected intermediate provider.
 *	    This function just passes this request to the controller via an owner 
 *		callback.  
 *
 *	Formal Parameters:
 *		conference_name				(i) Name of conference.
 *		called_node_modifier		(i)	Numeric modifier string for called node.
 *		calling_node_modifier		(i) Numeric modifier string for calling node
 *		convener_password			(i) Password used for convener privileges.
 *		password_challenge			(i) Password challenge used for join.
 *		pwszCallerID				(i) Calling node identifier string.
 *		calling_address				(i) Transport address of calling node.
 *		called_address				(i) Transport address of node being called.
 *		domain_parameters			(i) Structure holding domain parameters.
 *		number_of_network_addresses	(i) Number of local network addresses.
 *		local_network_address_list	(i) List of local network addresses.
 *		number_of_user_data_members	(i) Number of items in list of user data.
 *		user_data_list,				(i) List of user data items.
 *		connection_handle			(i)	Logical connection handle.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error occurred.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_INVALID_CONFERENCE_NAME		- Invalid conference name passed in.
 *		GCC_FAILURE_CREATING_DOMAIN		- Failure creating domain.
 *		GCC_BAD_NETWORK_ADDRESS			- Bad network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	- Bad network address type passed in.
 *		GCC_CONFERENCE_ALREADY_EXISTS	- Conference specified already exists.
 *		GCC_INVALID_ADDRESS_PREFIX		- Bad transport address passed in.
 *		GCC_INVALID_TRANSPORT			- Bad transport address passed in.
 *		GCC_INVALID_PASSWORD			- Invalid password passed in.
 *		GCC_BAD_USER_DATA				- Invalid user data passed in.
 *		GCC_FAILURE_ATTACHING_TO_MCS	- Failure creating MCS user attachment
 *		GCC_INVALID_CONFERENCE_MODIFIER	- Invalid conference modifier passed in.
 *		GCC_BAD_CONNECTION_HANDLE_POINTER - Bad connection handle ptr. passed in
 *		GCC_INVALID_TRANSPORT_ADDRESS	- Called address passed in is NULL.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfJoinResponse (
 *					GCCResponseTag					join_response_tag,
 *					PGCCChallengeRequestResponse	password_challenge,
 *					UINT						   	number_of_user_data_members,
 *					PGCCUserData				*	user_data_list,
 *					GCCResult						result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		join response from the node controller.  This routine is responsible
 *		for routing the response to either the conference that made the
 *		request or the controller.  Responses which are routed to a conference
 *		are associated with requests that originate at a subnode that is a
 *		node removed from the Top Provider.
 *
 *	Formal Parameters:
 *		join_response_tag			(i) Tag identifying the join response.
 *		password_challenge			(i) Password challenge structure.
 *		number_of_user_data_members	(i) Number of user data items in list.
 *		user_data_list				(i) List of user data items.
 *		result						(i) Result of join.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error occurred.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occurred.
 *		GCC_INVALID_JOIN_RESPONSE_TAG	-	No match found for join response tag
 *		GCC_INVALID_CONFERENCE_NAME		-	Invalid conference name passed in.
 *		GCC_FAILURE_CREATING_DOMAIN		-	Failure creating domain.
 *		GCC_CONFERENCE_ALREADY_EXISTS	-	Conference specified already exists.
 *		GCC_INVALID_PASSWORD			-	Invalid password passed in.
 *		GCC_BAD_USER_DATA				-	Invalid user data passed in.
 *		GCC_INVALID_CONFERENCE			-	Invalid conference ID passed in.
 *		GCC_DOMAIN_PARAMETERS_UNACCEPTABLE	- Domain parameters were
 *											  unacceptable for this connection.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfInviteRequest (
 *					GCCConfID   					conference_id,
 *					LPWSTR							pwszCallerID,
 *					TransportAddress				calling_address,
 *					TransportAddress				called_address,
 *					UINT						   	number_of_user_data_members,
 *					PGCCUserData				*	user_data_list,
 *					PConnectionHandle				connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		invite request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.  
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier.
 *		pwszCallerID				(i) Identifier string of calling node.
 *		calling_address				(i) Transport address of calling node.
 *		called_address				(i) Transport address of node being called. 
 *		number_of_user_data_members	(i) Number of items in user data list.
 *		user_data_list				(i) List of user data items.
 *		connection_handle			(i) Logical connection handle.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.	
 *		GCC_INVALID_TRANSPORT_ADDRESS	- Something wrong with transport address
 *		GCC_INVALID_ADDRESS_PREFIX		- Invalid transport address prefix
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_BAD_CONNECTION_HANDLE_POINTER - Connection handle pointer invalid.
 *		GCC_INVALID_CONFERENCE 			- Invalid conference ID passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfInviteResponse (
 *					GCCConfID   					conference_id,
 *					GCCNumericString				conference_modifier,
 *					PDomainParameters 				domain_parameters,
 *					UINT        					number_of_network_addresses,
 *					PGCCNetworkAddress 			*	local_network_address_list,
 *					UINT						   	number_of_user_data_members,
 *					PGCCUserData				*	user_data_list,
 *					GCCResult						result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		invite response from the node controller.  This function passes the
 *		response on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.  
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier.
 *		conference_modifier			(i) Modifier string for conference.
 *		domain_parameters			(i) Structure holding domain parameters.
 *		number_of_network_addresses	(i) Number of local network addresses.
 *		local_network_address_list	(i) List of local network addresses.
 *		number_of_user_data_members	(i) Number of items in list of user data.
 *		user_data_list,				(i) List of user data items.
 *		result						(i)	Result of invitation.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error occurred.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_INVALID_CONFERENCE_NAME		- Invalid conference name passed in.
 *		GCC_FAILURE_CREATING_DOMAIN		- Failure creating domain.
 *		GCC_CONFERENCE_ALREADY_EXISTS	- Conference specified already exists.
 *		GCC_BAD_USER_DATA				- Invalid user data passed in.
 *		GCC_INVALID_CONFERENCE			- Invalid conference ID passed in.
 *		GCC_FAILURE_ATTACHING_TO_MCS	- Failure creating MCS user attachment
 *		GCC_INVALID_CONFERENCE_MODIFIER	- Invalid conference modifier passed in.
 *		GCC_DOMAIN_PARAMETERS_UNACCEPTABLE	- Domain parameters were
 *											  unacceptable for this connection.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfLockRequest (
 *						GCCConfID   					conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		lock request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.	
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_CONFERENCE			- Conference ID not valid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfLockResponse (
 *						GCCConfID   					conference_id,
 *						UserID							requesting_node,
 *						GCCResult						result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		lock response from the node controller.  This function passes the
 *		response on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier.
 *		requesting_node				(i) Node ID of the requesting node.
 *		result						(i) Result of conference lock request.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.	
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_CONFERENCE			- Conference ID not valid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfUnlockRequest (
 *						GCCConfID   					conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		unlock request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.	
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_CONFERENCE			- Conference ID not valid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfUnlockResponse (
 *						GCCConfID   					conference_id,
 *						UserID							requesting_node,
 *						GCCResult						result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		lock request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier.
 *		requesting_node				(i) Node ID of the requesting node.
 *		result						(i) Result of conference lock request.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.	
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_CONFERENCE			- Conference ID not valid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfDisconnectRequest(
 *						GCCConfID   					conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference 
 *		disconnect request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains. 
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_INVALID_CONFERENCE			- Conference ID not valid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfTerminateRequest(
 *						GCCConfID   					conference_id,
 *						GCCReason						reason);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference 
 *		terminate request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains. 
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier.
 *		reason						(i) Reason for the termination.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_CONFERENCE			- Conference ID not valid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfDisconnectConfirm (
 *						GCCConfID   		  			conference_id,
 *						GCCResult						result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the Conference when it need to send a 
 *		conference disconnect confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier.
 *		result						(i) Result of disconnect attempt.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfEjectUserRequest (
 *						GCCConfID   					conference_id,
 *						UserID							ejected_node_id,
 *						GCCReason						reason);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference 
 *		eject user request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains. 
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier.
 *		ejected_node_id				(i) Node ID of node being ejected.
 *		reason						(i) Reason for the ejection.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.	
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_MCS_USER_ID			- Invalid eject node ID.
 *		GCC_INVALID_CONFERENCE			- Invalid conference ID.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorAssignRequest(
 *						GCCConfID   					conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conductor
 *		assign request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id			(i) The conference identifier.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_CONFERENCE			- Conference ID invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorReleaseRequest(
 *						GCCConfID   					conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conductor
 *		release request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id			(i) The conference identifier.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_CONFERENCE			- Conference ID invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorPleaseRequest(
 *						GCCConfID   					conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conductor
 *		please request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id			(i) The conference identifier.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_INVALID_CONFERENCE			- Conference ID is invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorGiveRequest(
 *						GCCConfID   					conference_id,
 *						UserID							recipient_user_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conductor
 *		give request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id			(i) The conference identifier.
 *		recipient_user_id		(i) ID of user to give conductroship to.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_INVALID_MCS_USER_ID			- Recipient user ID invalid.
 *		GCC_INVALID_CONFERENCE			- Conference ID invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorGiveResponse(
 *						GCCConfID   					conference_id,
 *						GCCResult						result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conductor
 *		give response from the node controller.  This function passes the
 *		response on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id			(i) The conference identifier.
 *		result					(i) Result of the conductorship give.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_NO_GIVE_RESPONSE_PENDING	- A give indication was never issued.
 *		GCC_INVALID_CONFERENCE			- Conference ID invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorPermitGrantRequest(
 *						GCCConfID   					conference_id,
 *						UINT							number_granted,
 *						PUserID							granted_node_list,
 *						UINT							number_waiting,
 *						PUserID							waiting_node_list);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conductor
 *		permit grant request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		 conference_id			(i) The conference identifier value.
 *		 number_granted			(i) Number of nodes being granted permission.
 *		 granted_node_list		(i) List of nodes being granted permission.
 *		 number_waiting			(i) Number of nodes waiting for permission.
 *		 waiting_node_list		(i) List of nodes waiting for permission.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_INVALID_MCS_USER_ID			- Invalid user ID in the granted node
 *												list.
 *		GCC_INVALID_CONFERENCE			- The conference ID is invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfTimeRemainingRequest (
 *						GCCConfID   					conference_id,
 *						UINT							time_remaining,
 *						UserID							node_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference time
 *		remaining request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id			(i) Conference identifier value.
 *		time_remaining			(i) Time remaining in the conference (in sec.).
 *		node_id					(i) If present, indicates time remaining applies
 *										only to this node.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_MCS_USER_ID			- Invalid node ID.
 *		GCC_INVALID_CONFERENCE			- Invalid conference ID.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfTimeInquireRequest (
 *						GCCConfID   				conference_id,
 *						BOOL						time_is_conference_wide);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference time
 *		inquire request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier value.
 *		time_is_conference_wide		(i) Flag indicating request is for time
 *											remaining in entire conference.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_CONFERENCE			- Conference ID invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfExtendRequest (
 *						GCCConfID   				conference_id,
 *						UINT						extension_time,
 *						BOOL						time_is_conference_wide);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		extend request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier value.
 *		extension_time				(i) Amount of time to extend the
 *											conference (in seconds).
 *		time_is_conference_wide		(i) Flag indicating time extension is for
 *											entire conference.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_CONFERENCE			- Conference ID invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfAssistanceRequest (
 *						GCCConfID   				conference_id,
 *						UINT						number_of_user_data_members,
 *						PGCCUserData		  *		user_data_list);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		assistance request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier value.
 *		number_of_user_data_members	(i) Number of items in list of user data.
 *		user_data_list				(i) List of user data items.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_CONFERENCE			- Conference ID invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	TextMessageRequest (
 *						GCCConfID   					conference_id,
 *						LPWSTR							pwszTextMsg,
 *						UserID							destination_node );
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a text message
 *		request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier value.
 *		pwszTextMsg					(i) Text message to send.
 *		destination_node			(i) ID of node to receive text message.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_CONFERENCE			- Conference ID invalid.
 *		GCC_INVALID_MCS_USER_ID			- Destination node invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfTransferRequest (
 *						GCCConfID   			conference_id,
 *						PGCCConferenceName		destination_conference_name,
 *						GCCNumericString		destination_conference_modifier,
 *						UINT        			number_of_destination_addresses,
 *						PGCCNetworkAddress		*destination_address_list,
 *						UINT					number_of_destination_nodes,
 *						PUserID					destination_node_list,
 *						PGCCPassword			password);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		transfer request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id					(i) Conference identifier value.
 *		destination_conference_name		(i) Name of conference to transfer to.
 *		destination_conference_modifier	(i) Name modifier of transfer conference
 *		number_of_destination_addresses	(i) Number of optional called addresses
 *												to be included in JoinRequest to
 *												be issued by transferring nodes.
 *		destination_address_list		(i) Optional called address parameter to
 *												be included in Join Request to
 *												be issued by transferring nodes.
 *		number_of_destination_nodes		(i)	Number of nodes to be transferred.
 *		destination_node_list			(i) List of nodes to be transferred.
 *		password						(i) Password to be used for joining
 *												transfer conference.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_CONFERENCE_NAME		- Conference name is invalid.
 *		GCC_INVALID_CONFERENCE_MODIFIER	- Conference modifier is invalid.
 *		GCC_INVALID_PASSWORD			- Password is invalid.
 *		GCC_INVALID_MCS_USER_ID			- A destination node ID is invalid.
 *		GCC_INVALID_CONFERENCE			- Conference ID invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfAddRequest	(
 *						GCCConfID   			conference_id,
 *						UINT        			number_of_network_addresses,
 *						PGCCNetworkAddress	*	network_address_list,
 *						UserID					adding_node,
 *						UINT					number_of_user_data_members,
 *						PGCCUserData		*	user_data_list );
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		add request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier value.
 *		number_of_network_addresses	(i) Number of network addresses in list
 *											of addresses of adding node.
 *		network_address_list		(i) List of addresses of adding node.
 *		adding_node					(i)	Node ID of node to add.
 *		number_of_user_data_members	(i) Number of items in list of user data.
 *		user_data_list 				(i) List of user data items.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_MCS_USER_ID			- Adding node ID invalid.
 *		GCC_INVALID_CONFERENCE			- Conference ID invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfAddResponse (
 *						GCCResponseTag			add_response_tag,
 *						GCCConfID   			conference_id,
 *						UserID					requesting_node,
 *						UINT					number_of_user_data_members,
 *						PGCCUserData		*	user_data_list,
 *						GCCResult				result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		add response from the node controller.  This function passes the
 *		response on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		add_response_tag			(i) Tag identifying the Add request.
 *		conference_id				(i) ID of conference to add node to.
 *		requesting_node				(i) ID of node requesting the Add.
 *		number_of_user_data_members	(i) Number of items in user data list.
 *		user_data_list				(i) List of user data items.
 *		result						(i) Result of Add.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  its establishment process.
 *		GCC_INVALID_ADD_RESPONSE_TAG	- There was no match of the response tag
 *		GCC_INVALID_MCS_USER_ID			- Adding node ID invalid.
 *		GCC_INVALID_CONFERENCE			- Conference ID invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfCreateIndication (
 *						PGCCConferenceName			conference_name,
 *						GCCConfID   				conference_id,
 *						CPassword                   *convener_password,
 *						CPassword                   *password,
 *						BOOL						conference_is_locked,
 *						BOOL						conference_is_listed,
 *						BOOL						conference_is_conductible,
 *						GCCTerminationMethod		termination_method,
 *						PPrivilegeListData			conductor_privilege_list,
 *						PPrivilegeListData			conduct_mode_privilege_list,
 *						PPrivilegeListData			non_conduct_privilege_list,
 *						LPWSTR						pwszConfDescriptor,
 *						LPWSTR						pwszCallerID,
 *						TransportAddress			calling_address,
 *						TransportAddress			called_address,
 *						PDomainParameters			domain_parameters,
 *						CUserDataListContainer      *user_data_list,
 *						ConnectionHandle			connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the GCC Controller when it gets a connect 
 *		provider indication from MCS, carrying a conference create request PDU.
 *		This function fills in all the parameters in the CreateIndicationInfo 
 *		structure. It then adds it to a queue of messages supposed to be sent to
 *		the node controller in the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_name				(i) Name of the conference.
 *		conference_id				(i) ID of the conference.
 *		convener_password			(i) Password used for convener privileges.
 *		password					(i) Password used for access restriction.
 *		conference_is_locked		(i) Flag indicating whether conf. is locked.
 *		conference_is_listed		(i) Flag indicating whether conf. is listed.
 *		conference_is_conductible	(i) Flag indicating whether conference is
 *											conductable.
 *		termination_method			(i)	Type of termination method.
 *		conductor_privilege_list	(i) List of privileges granted to conductor
 *											by the convener.
 *		conduct_mode_privilege_list	(i) List of privileges granted to all nodes
 *											when in conducted mode.
 *		non_conduct_privilege_list	(i) List of privileges granted to all nodes
 *											when not in conducted mode.
 *		pwszConfDescriptor			(i) Conference descriptor string.
 *		pwszCallerID				(i) Caller identifier string.
 *		calling_address				(i) Transport address of calling node.
 *		called_address				(i) Tranport address of called node.
 *		domain_parameters			(i) Conference domain parameters.
 *		user_data_list				(i) List of user data items.
 *		connection_handle			(i) Logical connection handle.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfQueryIndication (
 *						GCCResponseTag				query_response_tag,
 *						GCCNodeType					node_type,
 *						PGCCAsymmetryIndicator		asymmetry_indicator,
 *						TransportAddress			calling_address,
 *						TransportAddress			called_address,
 *						CUserDataListContainer      *user_data_list,
 *						ConnectionHandle			connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the GCC Controller when it need to send a 
 *		conference query indication to the node controller. It adds the message
 *		to a queue of messages to be sent to the node controller in the next 
 *		heartbeat.
 *
 *	Formal Parameters:
 *		query_response_tag			(i)	Tag identifying this query.
 *		node_type					(i) Type of node (terminal, MCU, both).
 *		asymmetry_indicator			(i) Structure used to identify calling and
 *											called nodes.
 *		calling_address				(i) Transport address of calling node.
 *		called_address				(i) Transport address of called node.
 *		user_data_list				(i) List of user data items.
 *		connection_handle			(i) Logical connection handle.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfQueryConfirm (
 *						GCCNodeType					node_type,
 *						PGCCAsymmetryIndicator		asymmetry_indicator,
 *						CConfDescriptorListContainer *conference_list,
 *						CUserDataListContainer	    *user_data_list,
 *						GCCResult					result,
 *						ConnectionHandle			connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the GCC Controller when it need to send a 
 *		conference query confirm to the node controller. It adds the message
 *		to a queue of messages to be sent to the node controller in the next 
 *		heartbeat.
 *
 *	Formal Parameters:
 *		node_type					(i) Type of node (terminal, MCU, both).
 *		asymmetry_indicator			(i) Structure used to identify calling and
 *											called nodes.
 *		conference_list				(i) List of available conferences.
 *		user_data_list				(i) List of user data items.
 *		result						(i) Result of query.
 *		connection_handle			(i) Logical connection handle.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfJoinIndication(
 *						GCCConfID   				conference_id,
 *						CPassword                   *convener_password,
 *						CPassword                   *password_challenge,
 *						LPWSTR						pwszCallerID,
 *						TransportAddress			calling_address,
 *						TransportAddress			called_address,
 *						CUserDataListContainer      *user_data_list,
 *						BOOL						intermediate_node,
 *						ConnectionHandle			connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This join indication is recevied from the owner object. This join
 *		indication is designed to make the join response very flexible at the 
 *		node controller.  The node controller can respond to this indication
 *		by either creating a new conference and moving the joiner into it, 
 *		putting the joiner in the conference requested or putting the joiner
 *		into a different conference that already exist.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier value.
 *		convener_password			(i)	Password used for convener privileges.
 *		password_challenge			(i) Password challenge used for join.
 *		pwszCallerID				(i) Caller identifier string.
 *		calling_address				(i) Transport address of calling node.
 *		called_address				(i) Transport address of called node.
 *		user_data_list				(i) List of user data items.
 *		intermediate_node			(i) Flag indicating if join made at
 *											an intermediate node.
 *		connection_handle			(i) Logical connection handle.
 *
 *	Return Value:
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	???GCCConferenceQueryConfirm (
 *						GCCResponseTag				query_response_tag,
 *						GCCNodeType					node_type,
 *						PGCCAsymmetryIndicator		asymmetry_indicator,
 *						TransportAddress			calling_address,
 *						TransportAddress			called_address,
 *						CUserDataListContainer      *user_data_list,
 *						ConnectionHandle			connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		add request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier value.
 *		number_of_network_addresses	(i) Number of network addresses in list
 *											of addresses of adding node.
 *		network_address_list		(i) List of addresses of adding node.
 *		adding_node					(i)	Node ID of node to add.
 *		number_of_user_data_members	(i) Number of items in list of user data.
 *		user_data_list 				(i) List of user data items.
 *
 *	Return Value:
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfInviteIndication(
 *						GCCConfID   			conference_id,
 *						PGCCConferenceName		conference_name,
 *						LPWSTR					pwszCallerID,			  
 *						TransportAddress		calling_address,			  
 *						TransportAddress		called_address,				  
 *						PDomainParameters 		domain_parameters,			  
 *						BOOL					clear_password_required,
 *						BOOL					conference_is_locked,
 *						BOOL					conference_is_listed,
 *						BOOL					conference_is_conductible,
 *						GCCTerminationMethod	termination_method,
 *						PPrivilegeListData		conductor_privilege_list,	  
 *						PPrivilegeListData		conducted_mode_privilege_list,
 *						PPrivilegeListData		non_conducted_privilege_list, 
 *						LPWSTR					pwszConfDescriptor,		  
 *						CUserDataListContainer  *user_data_list,				  
 *						ConnectionHandle		connection_handle,
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the GCC Controller when it need to send a 
 *		conference invite indication to the node controller. It adds the message
 *		to a queue of messages to be sent to the node controller in the next 
 *		heartbeat.
 *
 *	Formal Parameters:
 *		conference_id					(i)	Conference identifier value.
 *		conference_name					(i) Name of conference.
 *		pwszCallerID	,			 	(i) Caller identifier value.
 *		calling_address,			 	(i) Transport address of calling node.
 *		called_address,				 	(i) Transport address of called node.
 *		domain_parameters,			 	(i) Conference domain parameters.
 *		clear_password_required			(i) Flag indicating if a clear password
 *												is required.
 *		conference_is_locked			(i) Flag indicating whether conference
 *												is locked.
 *		conference_is_listed			(i)	Flag indicating whether conference
 *												is listed.
 *		conference_is_conductible		(i)	Flag indicating whether conference
 *												is conductable.
 *		termination_method				(i)	Method of conference termination.
 *		conductor_privilege_list		(i) List of privileges granted to 
 *												conductor by the convener.
 *		conduct_mode_privilege_list		(i) List of privileges granted to all 
 *												nodes when in conducted mode.
 *		non_conducted_privilege_list	(i) List of privileges granted to all 
 *												nodes when not in conducted mode
 *		pwszConfDescriptor			 	(i)	Conference descriptor string.
 *		user_data_list				 	(i) List of user data items.
 *		connection_handle				(i) Logical connection handle.
 *
 *	Return Value:
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	TransportStatusIndication (
 *							PTransportStatus		transport_status);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the GCC Controller when it need to send a 
 *		transport status indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		transport_status			(i)	Transport status message.
 *
 *	Return Value:
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	StatusIndication (
 *							GCCStatusMessageType	status_message,
 *							UINT					parameter);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the GCC Controller when it need to send a 
 *		status indication to the node controller. It adds the message to a  
 *		queue of messages to be sent to the node controller in the next 
 *		heartbeat.
 *
 *	Formal Parameters:
 *		status_message					(i)	GCC status message.
 *		parameter						(i) Parameter whose meaning depends 
 *												upon the type of message.
 *
 *	Return Value:
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		Note that we do not handle a resource error here to avoid an
 *		endless loop that could occur when this routine is called from the
 *		HandleResourceError() routine.
 */

/*
 *	GCCError	ConnectionBrokenIndication (	
 *							ConnectionHandle		connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the GCC Controller when it need to send a 
 *		connection broken indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		connection_handle			(i)	Logical connection handle.
 *
 *	Return Value:
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfCreateConfirm (
 *							PGCCConferenceName	  	conference_name,
 *							GCCNumericString		conference_modifier,
 *							GCCConfID   			conference_id,
 *							PDomainParameters		domain_parameters,			
 *							CUserDataListContainer  *user_data_list,				
 *							GCCResult				result,
 *							ConnectionHandle		connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference create confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_name				(i) Conference name string.
 *		conference_modifier			(i) Conference modifier string.
 *		conference_id				(i) Conference identifier value.
 *		domain_parameters,			(i) Conference domain parameters.
 *		user_data_list,				(i) List of user data items.
 *		result						(i) Result of creation.
 *		connection_handle			(i) Logical connection handle.
 *
 *	Return Value:
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfPermissionToAnnounce (
 *							GCCConfID   			conference_id,
 *							UserID					gcc_node_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference permission to announce to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id			(i)	Conference identifier value.
 *		gcc_node_id				(i) Node ID of node being given permission.
 *
 *	Return Value:
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfAnnouncePresenceConfirm (
 *							GCCConfID   			conference_id,
 *							GCCResult				result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference announce presence confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id		(i)	Conference identifier value.
 *		result				(i) Result of announcing presence.
 *
 *	Return Value:
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfDisconnectIndication (
 *							GCCConfID   			conference_id,
 *							GCCReason				reason,
 *							UserID					disconnected_node_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the Conference when it need to send a 
 *		conference disconnect indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conferenc identifier value.
 *		reason						(i) Reason for disconnection.
 *		disconnected_node_id		(i) Node ID of node disconnected.
 *
 *	Return Value:
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError  	ConfJoinIndication (
 *							UserID					sender_id,
 *							GCCConfID   			conference_id,
 *							CPassword               *convener_password,
 *							CPassword               *password_challange,
 *							LPWSTR					pwszCallerID,
 *							CUserDataListContainer  *user_data_list);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference join indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		sender_id					(i)	ID of node sending join indication.
 *		conference_id				(i) Conference identifier value.
 *		convener_password			(i) Password used for convener privileges.
 *		password_challange			(i) Password challenge used for join.
 *		pwszCallerID				(i) Caller identifier string.
 *		user_data_list)				(i) List of user data items.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError  	ConfJoinConfirm (
 *							PGCCConferenceName		conference_name,
 *							GCCNumericString		remote_modifier,
 *							GCCNumericString		local_modifier,
 *							GCCConfID   			conference_id,
 *							CPassword               *password_challenge,
 *							PDomainParameters		domain_parameters,
 *							BOOL					password_in_the_clear,
 *							BOOL					conference_locked,
 *							BOOL					conference_listed,
 *							BOOL					conference_conductible,
 *							GCCTerminationMethod	termination_method,
 *							PPrivilegeListData		conductor_privilege_list,
 *							PPrivilegeListData		conduct_mode_privilege_list,
 *							PPrivilegeListData		non_conduct_privilege_list,
 *							LPWSTR					pwszConfDescription,
 *							CUserDataListContainer  *user_data_list,	
 *							GCCResult				result,
 *							ConnectionHandle		connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference join confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_name				(i)	Conference name.
 *		remote_modifier				(i) Conference name modifier at remote node.
 *		local_modifier				(i) Conference name modifier at local node.
 *		conference_id				(i) Conference identifier value.
 *		password_challenge			(i) Password challenge used for join.
 *		domain_parameters			(i) Conference domain parameters.
 *		password_in_the_clear		(i) Flag indicating	password is clear.
 *		conference_locked			(i) Flag indicating conference is locked.
 *		conference_listed			(i) Flag indicating conference is listed.
 *		conference_conductible		(i) Flag indicating conference is 
 *											conductable.
 *		termination_method			(i) Method of termination.
 *		conductor_privilege_list	(i) List of privileges granted the conductor
 *											by the convener.
 *		conduct_mode_privilege_list	(i) List of privileges granted to all nodes
 *											when in conducted mode.
 *		non_conduct_privilege_list	(i)	List of privileges granted to all nodes
 *											when in conducted mode.
 *		pwszConfDescription			(i)	Conference description string.
 *		user_data_list,				(i) List of user data items.
 *		result						(i) Result of conference join.
 *		connection_handle			(i) Logical connection handle.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfInviteConfirm (
 *							GCCConfID   			conference_id,
 *							CUserDataListContainer  *user_data_list,
 *							GCCResult				result,
 *							ConnectionHandle		connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference invite confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		user_data_list,				(i) List of user data items.
 *		result						(i) Result of conference join.
 *		connection_handle			(i) Logical connection handle.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
 
/*
 *	GCCError	ConfTerminateIndication (
 *							GCCConfID   			conference_id,
 *							UserID					requesting_node_id,
 *							GCCReason				reason);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the GCC Controller when it need to send a 
 *		conference terminate indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id					(i)	Conference identifier value.
 *		requesting_node_id				(i) ID of node requesting termination.
 *		reason							(i) Reason for termination.
 *
 *	Return Value:
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError 	ConfLockReport (
 *							GCCConfID   			conference_id,
 *							BOOL					conference_is_locked);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference lock report to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		conference_is_locked		(i) Flag indicating whether conference is
 *											locked.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfLockIndication (
 *							GCCConfID   			conference_id,
 *							UserID					source_node_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference lock indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		source_node_id				(i) ID of node requesting lock.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfLockConfirm(
 *							GCCResult				result,
 *							GCCConfID   			conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference lock confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		result						(i) Result of conference lock.
 *		conference_id				(i)	Conference identifier value.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfUnlockIndication (
 *							GCCConfID   			conference_id,
 *							UserID					source_node_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference unlock indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		source_node_id				(i) ID of node requesting unlock.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfUnlockConfirm (
 *							GCCResult				result,
 *							GCCConfID   			conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference unlock confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		result						(i) Result of conference unlock.
 *		conference_id				(i)	Conference identifier value.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfEjectUserIndication (	
 *							GCCConfID   			conference_id,
 *							GCCReason				reason,
 *							UserID					gcc_node_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference eject user indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		reason						(i) Reason for node ejection.
 *		gcc_node_id					(i) ID of node being ejected.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfEjectUserConfirm (
 *							GCCConfID   			conference_id,
 *							UserID					ejected_node_id,
 *							GCCResult				result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference eject user confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		ejected_node_id				(i) ID of node being ejected.
 *		result						(i) Result of ejection attempt.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfTerminateConfirm (
 *							GCCConfID   			conference_id,
 *							GCCResult				result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference terminate confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		result						(i) Result of termination attempt.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorAssignConfirm (
 *							GCCResult				result,
 *							GCCConfID   			conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conductor assign confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		result						(i) Result of conductor assign attempt.
 *		conference_id				(i)	Conference identifier value.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorReleaseConfirm (
 *							GCCResult				result,
 *							GCCConfID   			conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conductor release confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		result						(i) Result of conductor release attempt.
 *		conference_id				(i)	Conference identifier value.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorPleaseIndication (
 *							GCCConfID   			conference_id,
 *							UserID					requester_user_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conductor please indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		requester_user_id			(i) ID of node requesting conductorship.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorPleaseConfirm (	
 *							GCCResult				result,
 *							GCCConfID   			conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conductor please confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		result						(i) Result of conductor please attempt.
 *		conference_id				(i)	Conference identifier value.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorGiveIndication (
 *							GCCConfID   			conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conductor give indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorGiveConfirm (	
 *							GCCResult				result,
 *							GCCConfID   			conference_id,
 *							UserID					recipient_node);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conductor give confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		result						(i) Result of conductor assign attempt.
 *		conference_id				(i)	Conference identifier value.
 *		recipient_node				(i) ID of node receiving conductorship.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorPermitAskIndication (	
 *							GCCConfID   			conference_id,
 *							BOOL					grant_flag,
 *							UserID					requester_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conductor permit ask indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		grant_flag					(i) Flag indicating whether conductorship
 *											is to be granted or given up.
 *		requester_id				(i)	ID of node asking for permission.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorPermitAskConfirm (
 *							GCCResult				result,
 *							BOOL					grant_permission,
 *							GCCConfID   			conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conductor permit ask confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		result						(i) Result of conductor permit ask attempt.
 *		grant_permission			(i) Flag indicating whether conductor
 *											permission is granted.
 *		conference_id				(i)	Conference identifier value.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorPermitGrantConfirm (
 *							GCCResult				result,
 *							GCCConfID   			conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conductor permit grant confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		result						(i) Result of conductor permit grant attempt
 *		conference_id				(i)	Conference identifier value.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfTimeRemainingIndication (
 *							GCCConfID   			conference_id,
 *							UserID					source_node_id,
 *							UserID					node_id,
 *							UINT					time_remaining);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference time remaining indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		source_node_id				(i)	Node ID of the node that issued the
 *											time remaining request..
 *		node_id						(i)	Optional parameter which, if present,
 *											indicates that time remaining 
 *											applies only to node with this ID.
 *		time_remaining				(i)	Time remaining in conference (in sec.).
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfTimeRemainingConfirm (
 *							GCCConfID   			conference_id,
 *							GCCResult				result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference time remaining confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		result						(i) Result of time remaining request.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfTimeInquireIndication (
 *							GCCConfID   			conference_id,
 *							BOOL					time_is_conference_wide,
 *							UserID					requesting_node_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference time inquire indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		time_is_conference_wide		(i) Flag indicating time inquire is for
 *											entire conference.
 *		requesting_node_id			(i) Node ID of node inquiring.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfTimeInquireConfirm (
 *							GCCConfID   			conference_id,
 *							GCCResult				result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference time inquire confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		result						(i) Result of time inquire attempt.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfExtendIndication (
 *							GCCConfID   			conference_id,
 *							UINT					extension_time,
 *							BOOL					time_is_conference_wide,
 *							UserID                  requesting_node_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference extend indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		extension_time				(i) Amount of time (in sec.) to extend
 *											conference.
 *		time_is_conference_wide		(i) Flag indicating time inquire is for
 *											entire conference.
 *		requesting_node_id			(i) Node ID of node requesting extension.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfExtendConfirm (
 *							GCCConfID   			conference_id,
 *							UINT					extension_time,
 *							GCCResult				result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference extend confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		extension_time				(i) Amount of time (in sec.) to extend
 *											conference.
 *		result						(i) Result of conductor assign attempt.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfAssistanceIndication (
 *							GCCConfID   			conference_id,
 *							CUserDataListContainer  *user_data_list,
 *							UserID					source_node_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference assistance indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		user_data_list				(i) List of user data items.
 *		source_node_id				(i) Node ID of node requesting assistance.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfAssistanceConfirm (
 *							GCCConfID   	 		conference_id,
 *							GCCResult				result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf  when it need to send a 
 *		conference assistance confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		result						(i) Result of conference assistance attempt.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	TextMessageIndication (
 *							GCCConfID   			conference_id,
 *							LPWSTR					pwszTextMsg,
 *							UserID					source_node_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		text message indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		pwszTextMsg					(i) Text message being sent.
 *		source_node_id				(i) Node ID of node sending text message.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	TextMessageConfirm ( 	
 *							GCCConfID   			conference_id,
 *							GCCResult				result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		text message confirm to the node controller. It adds the message 
 *		to a queue of messages to be sent to the node controller in the
 *		next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		result						(i) Result of text message send attempt.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfTransferIndication (
 *							GCCConfID   		conference_id,
 *							PGCCConferenceName	destination_conference_name,
 *							GCCNumericString	destination_conference_modifier,
 *							CNetAddrListContainer *destination_address_list,
 *							CPassword           *password);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference transfer indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id					(i)	Conference identifier value.
 *		destination_conference_name		(i)	Name of destination conference.
 *		destination_conference_modifier	(i) Name modifier of destination conf.
 *		destination_address_list		(i) List of network addresses for
 *												inclusion in the Join Request to
 *												be made by transferring nodes.
 *		password						(i)	Password to be used in Join	Request
 *												by transferring nodes.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfTransferConfirm (
 *							GCCConfID   		conference_id,
 *							PGCCConferenceName	destination_conference_name,
 *							GCCNumericString	destination_conference_modifier,
 *							UINT				number_of_destination_nodes,
 *			 				PUserID				destination_node_list,
 *							GCCResult			result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference transfer confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id					(i)	Conference identifier value.
 *		destination_conference_name		(i)	Name of destination conference.
 *		destination_conference_modifier	(i) Name modifier of destination conf.
 *		number_of_destination_nodes		(i) Number of nodes being transferred.
 *		destination_node_list			(i) List of nodes being transferred.
 *		result							(i) Result of conference transfer.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfAddIndication (
 *							GCCConfID   		conference_id,
 *							GCCResponseTag		add_response_tag,
 *							CNetAddrListContainer *network_address_list,
 *							CUserDataListContainer *user_data_list,
 *							UserID				requesting_node);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference add indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		add_response_tag			(i)	Tag used to identify this add event.
 *		network_address_list		(i) Network addresses of node to be added.
 *		user_data_list				(i) List of user data items.
 *		requesting_node				(i) Node ID of node requesting the add.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfAddConfirm (
 *							GCCConfID   		conference_id,
 *							CNetAddrListContainer *network_address_list,
 *							CUserDataListContainer *user_data_list,
 *							GCCResult			result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference add confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		network_address_list		(i) Network addresses of node to be added.
 *		user_data_list				(i) List of user data items.
 *		result						(i) Result of Add attempt.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	SubInitializationCompleteIndication (
 *							UserID				user_id,
 *							ConnectionHandle	connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		sub-initialization complete indication to the node controller. This call
 *		tells this node that a node directly connected to it has initialized.
 *		It adds the message	to a queue of messages to be sent to the node 
 *		controller in the next heartbeat.
 *
 *	Formal Parameters:
 *		user_id						(i) Node ID of the intializing node. 
 *		connection_handle			(i) Logical connection handle for directly
 *											connected node.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif // _GCC_CONTROL_SAP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\fclasses.h ===
#ifndef __FORWARD_DECL_CLASSES__
#define __FORWARD_DECL_CLASSES__

// Forward declarations of GCC classes

class CAppRoster;
class CAppRosterMgr;
class CAppRosterMsg;

class CConfRoster;
class CConfRosterMgr;
class CConfRosterMsg;

class CConf;

class CBaseSap;
class CAppSap;
class CControlSAP;

// Forward declarations of MCS classes

class Domain;
typedef Domain *PDomain;

class Channel;
typedef Channel *PChannel;

class PrivateChannel;
typedef PrivateChannel *PPrivateChannel;

class UserChannel;
typedef UserChannel *PUserChannel;

class Connection;
typedef Connection *PConnection;

class User;
typedef User *PUser;

class Token;
typedef Token *PToken;

class SimplePacket;
typedef SimplePacket *PSimplePacket;

class CAttachment;

#endif // __FORWARD_DECL_CLASSES__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\datapkt.h ===
/*
 *	datapkt.h
 *
 *	Copyright (c) 1997 by Microsoft Corporation, Redmond, WA
 *
 *	Abstract:
 *		This is the interface file for the MCS Data Packet class.  Instances of this
 *		class represent MCS Data Protocol Data Units (Data PDUs) as they flow through the
 *		system.  These instances allocate the memory required to hold both
 *		encoded and decoded versions of the PDU, and make sure that no PDU
 *		is ever encoded or decoded more than once.  However, they differ from normal
 *		packets, in that there is only one copy of the user data in the encoded 
 *		and decoded buffers.  The use of lock counts
 *		allows multiple objects in the system to reference and use the same
 *		packet object at the same time.  This class inherits from the SimplePacket
 *		class, which is a pure virtual class.
 *
 *		A data packet object can be created in two different ways.  It can be created
 *		with either decoded data or encoded data.  During instantiation, the
 *		new packet object will include the memory it will need to
 *		hold both the encoded and decoded data
 *		The DataPacket class, however, does not put any data into those buffers.
 *
 *		When a Lock message is sent to the object, it will put encoded
 *		data into the encode buffer.  If the packet was created
 *		with decoded data, then this will entail an encode operation.  However,
 *		if the packet was created with encoded data, then it is smart enough
 *		to just COPY the encoded data into the internal buffer, thus avoiding
 *		the overhead associated with the encode operation.
 *                  
 *		When a Lock message is sent to the object, it will put decoded
 *		data into the pre-allocated decode buffer.  If the packet was created
 *		with encoded data, then this will entail a decode operation.  However,
 *		if the packet was created with decoded data, then it is smart enough
 *		to just COPY the decoded data into the internal buffer, thus avoiding
 *		the overhead associated with the decode operation.
 *
 *		When Unlock messages are received, the lock count is decremented.  When a packet's
 *		lock count is 0, the packet deletes itself (it commits
 *		suicide).  Note that for this reason, no other object should explicitly
 *		delete a packet object.
 *                  
 *	Caveats:
 *		None.
 *
 *	Authors:
 *		Christos Tsollis
 */

#ifndef _DATAPACKET_
#define _DATAPACKET_

#include "mpdutype.h"

/*
 *	 Definition of class DataPacket.
 */

class DataPacket;
typedef DataPacket *		PDataPacket;

class DataPacket : public SimplePacket
{
	public:
		static Void		AllocateMemoryPool (long maximum_objects);
		static Void		FreeMemoryPool ();
		PVoid			operator new (size_t);
		Void			operator delete (PVoid	object);

						DataPacket (ASN1choice_t		choice,
									PUChar				data_ptr,
									ULong				data_length,
									UINT				channel_id,
									Priority			priority,
									Segmentation		segmentation,
									UINT				initiator_id,
									SendDataFlags		flags,
									PMemory				memory,
									PPacketError		packet_error);	
						DataPacket(	PTransportData		pTransportData,
									BOOL				fPacketDirectionUp);	
		virtual			~DataPacket ();
		Void			SetDirection (DBBoolean packet_direction_up);
		virtual PVoid	GetDecodedData(void);
		virtual BOOL	IsDataPacket (void);
		virtual int		GetPDUType (void);
		BOOL			Equivalent (PDataPacket);
		Priority		GetPriority (void) 
						{
							return ((Priority) m_DecodedPDU.u.send_data_request.
												data_priority);
						};
		UserID			GetInitiator (void)
						{
							return (m_DecodedPDU.u.send_data_request.initiator);
						};
		ChannelID		GetChannelID (void)
						{
							return (m_DecodedPDU.u.send_data_request.channel_id);
						};
		Segmentation	GetSegmentation (void)
						{
							return (m_DecodedPDU.u.send_data_request.segmentation);
						};
		LPBYTE			GetUserData (void)
						{
							return ((LPBYTE) m_DecodedPDU.u.send_data_request.user_data.value);
						};
		UINT			GetUserDataLength (void)
						{
							return (m_DecodedPDU.u.send_data_request.user_data.length);
						};
		PMemory			GetMemory (void)
						{
							return (m_Memory);
						};
		BOOL			IsEncodedDataBroken (void)
						{
							return (m_EncodedDataBroken);
						};

        void SetMessageType(UINT nMsgType) { m_nMessageType = nMsgType; }
        UINT GetMessageType(void) { return m_nMessageType; }

	protected:
	
		static PVoid *	Object_Array;
		static long		Object_Count;
		BOOL			fPreAlloc;

		DomainMCSPDU	m_DecodedPDU;	// The decoded data PDU (w/o the user data)
		PMemory			m_Memory;		// Memory object pointing to big buffer which contains the object's buffer.
		BOOL			m_fIncoming;	// Does this packet represent recv data?
		BOOL			m_EncodedDataBroken;
		UINT            m_nMessageType; // for retry in CUser::SendDataIndication
};


/*
 *	Void	AllocateMemoryPool (
 *					long			maximum_objects);
 *
 *	Functional Description:
 *		This is a static member function that should only be called during MCS
 *		initialization (exactly once).  It allocates a memory block that will
 *		be used to hold all instances of this class during the operation of
 *		the system.  This allows us to VERY efficiently allocate and destroy
 *		instances of this class.
 *
 *	Formal Parameters:
 *		maximum_objects
 *			This is the maximum number of objects of this class that can exist
 *			in the system at the same time.  This is used to determine how much
 *			memory to allocate to hold the objects.  Once this number of
 *			objects exist, all calls to "new" will return NULL.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	FreeMemoryPool ();
 *
 *	Functional Description:
 *		This is a static member function that should only be called during a
 *		shutdown of MCS (exactly once).  It frees up the memory pool allocated
 *		to hold all instances of this class.  Note that calling this function
 *		will cause ALL existing instances of this class to be invalid (they
 *		no longer exist, and should not be referenced).
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		Any existing instances of this class are no longer valid and should not
 *		be referenced.
 *
 *	Caveats:
 *		None.
 */

/*
 *	PVoid	operator new (
 *					size_t			object_size);
 *
 *	Functional Description:
 *		This is an override of the "new" operator for this class.  Since all
 *		instances of this class come from a single memory pool allocated up
 *		front, this function merely pops the first entry from the list of
 *		available objects.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		Pointer to an object of this class, or NULL if no memory is available.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	operator delete (
 *					PVoid			object);
 *
 *	Functional Description:
 *		This function is used to free up a previously allocated object of this
 *		class.  Note that it is VERY important not to call this function with an
 *		invalid address, because no error checking is performed.  This decision
 *		was made due to speed requirements.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	DataPacket(	PUChar			pEncodedData,
 *				ULong			ulEncodedDataSize,
 *				BOOL			fPacketDirectionUp,
 *				PPacketError	pePktErr)
 *
 *	Functional Description:
 *		This version of the constructor is used to create a Data Packet object
 *		for incomming PDUs when the packet is to be created from an encoded
 *		data stream containing the PDU data to be decoded.
 *
 *	Formal Parameters:
 *		pEncodedData (i)
 *			Pointer to the input encoded PDU.
 *		ulEncodedDataSize (i)
 *			The length in bytes of the input encoded PDU.
 *		fPacketDirectionUp (i)
 *			The packet_direction_up flag indicates the initial orientation of
 *			the packet.  Valid values are:
 *				TRUE -	The packet's direction is up.
 *				FALSE -	The packet's direction is down.
 *		pePktErr (o)
 *			When the constructor returns control to the calling function, this
 *			variable will be set to one of the return values listed below.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */							      

/*
 *	DataPacket (ASN1choice_t	choice,
 *				PUChar			data_ptr,
 *				ULong			data_length,
 *				UINT			channel_id,
 *				Priority		priority,
 *				Segmentation	segmentation,
 *				UINT			initiator_id,
 *				PPacketError	packet_error)
 *
 *	Functional Description:
 *		This constructor is used for outgoing data packets.
 *		It needs to copy the data into the encoded PDU buffer
 *		that will be allocated by this constructor.
 *
 *	Formal Parameters:
 *		choice (i)
 *			Either normal or uniform send data PDU
 *		data_ptr (i)
 *			Pointer to the user data for this data PDU.
 *		data_length (i)
 *			The length of the user data
 *		channel_id (i)
 *			The MCS channel on which the data will be xmitted.
 *		priority (i)
 *			Data priority
 *		segmentation (i)
 *			The segmentation bits for the packet
 *		initiator_id (i)
 *			MCS user id of the user (application) sending the data
 *		packet_error (o)
 *			Ptr to location for storing the success/failure code for the constructor.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */	
/*
 *	~DataPacket ()
 *
 *	Functional Description:
 *		Destructor for the DataPacket class.  The destructor ensures that all 
 *		resources that have been allocated are freed.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GetDecodedData ()
 *
 *	Functional Description:
 *		The GetDecodedData method returns a pointer to the decoded data
 *		buffer.  
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		A pointer to the decoded data.  If an decoding error occurs, this
 *		method will return NULL.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GetEncodedDataLength ()
 *
 *	Functional Description:
 *		This method returns the encoded data's length.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The number of bytes in the encoded data.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GetDecodedDataLength ()
 *
 *	Functional Description:
 *		This method returns the decoded data's length.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The number of bytes in the decoded data.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\framer.h ===
/*	Framer.h
 *
 *	Copyright (c) 1994-1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the packet frame base class.  This class defines the behavior
 *		for other packet framers that inherit from this class.  Some packet
 *		framing definitions can be found in RFC1006 and Q.922
 *	
 *	Caveats:
 *
 *	Authors:
 *		James W. Lawwill
 */

#ifndef _PACKETFRAME_
#define _PACKETFRAME_

#include "databeam.h"

typedef	enum
{
	PACKET_FRAME_NO_ERROR,
	PACKET_FRAME_DEST_BUFFER_TOO_SMALL,
	PACKET_FRAME_PACKET_DECODED,
	PACKET_FRAME_ILLEGAL_FLAG_FOUND,
	PACKET_FRAME_FATAL_ERROR
}	PacketFrameError;

class  PacketFrame
{
	public:

		virtual	PacketFrameError	PacketEncode (
										PUChar		source_address, 
										UShort		source_length,
										PUChar		dest_address,
										UShort		dest_length,
										DBBoolean	prepend_flag,
										DBBoolean	append_flag,
										PUShort		packet_size) = 0;
									
		virtual	PacketFrameError	PacketDecode (
										PUChar		source_address,
										UShort		source_length,
										PUChar		dest_address,
										UShort		dest_length,
										PUShort		bytes_accepted,
										PUShort		packet_size,
										DBBoolean	continue_packet) = 0;
		virtual	Void				GetOverhead (
										UShort		original_packet_size,
										PUShort		max_packet_size) = 0;


};
typedef	PacketFrame	*	PPacketFrame;

#endif


/*	
 *	PacketFrameError	PacketFrame::PacketEncode (
 *										PUChar		source_address, 
 *										UShort		source_length,
 *										PUChar		dest_address,
 *										UShort		dest_length,
 *										DBBoolean	packet_start,
 *										DBBoolean	packet_end,
 *										PUShort		packet_size) = 0;
 *
 *	Functional Description
 *		This function receives takes the source data and encodes it.
 *
 *	Formal Parameters
 *		source_address	- (i)	Address of source buffer
 *		source_length	- (i)	Length of source buffer
 *		dest_address	- (i)	Address of destination buffer.
 *		dest_length		- (i)	Length of destination buffer.
 *		packet_start	- (i)	This is the beginning of a packet.
 *		packet_end		- (i)	This is the end of a packet.
 *		packet_size		- (o)	Size of packet after encoding
 *
 *	Return Value
 *		PACKET_FRAME_NO_ERROR				-	No error
 *		PACKET_FRAME_FATAL_ERROR			-	Fatal error during encode
 *		PACKET_FRAME_DEST_BUFFER_TOO_SMALL	-	Self-explanatory
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		None
 */

/*	
 *	PacketFrameError	PacketFrame::PacketDecode (
 *										PUChar		source_address,
 *										UShort		source_length,
 *										PUChar		dest_address,
 *										UShort		dest_length,
 *										PUShort		bytes_accepted,
 *										PUShort		packet_size,
 *										DBBoolean	continue_packet) = 0;
 *
 *	Functional Description
 *		This function takes the stream data passed in and decodes it into a
 *		packet
 *		
 *	Formal Parameters
 *		source_address	- (i)	Address of source buffer.  If this parm is 
 *								NULL, continue using the current address.
 *		source_length	- (i)	Length of source buffer
 *		dest_address	- (i)	Address of destination buffer.  If this address
 *								is NULL, continue using current buffer.
 *		dest_length		- (i)	Length of destination buffer.
 *		bytes_accepted	- (o)	Number of bytes processed before return
 *		packet_size		- (o)	Size of packet after decoding
 *		continue_packet	- (i)	Restart decoding
 *
 *	Return Value
 *		PACKET_FRAME_NO_ERROR				-	No error
 *		PACKET_FRAME_FATAL_ERROR			-	Fatal error during encode
 *		PACKET_FRAME_DEST_BUFFER_TOO_SMALL	-	Self-explanatory
 *		PACKET_FRAME_PACKET_DECODED			-	Self-explanatory
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		None
 *
 */

/*	
 *	Void	PacketFrame::GetOverhead (
 *							UShort	original_packet_size,
 *							PUShort	max_packet_size) = 0;
 *
 *	Functional Description
 *		This returns the new maximum packet size
 *
 *	Formal Parameters
 *		original_packet_size	- (i)
 *		max_packet_size			- (o)	new maximum packet size
 *
 *	Return Value
 *		PACKET_FRAME_NO_ERROR	-	No error
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		None
 *
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\domain.h ===
/*
 *	domain.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the domain class.  This class contains
 *		all code necessary to maintain a domain information base within the
 *		MCS system.  When a domain object is first created, it is completely
 *		empty.  That is, it has no user attachments, no MCS connections, and
 *		therefore no outstanding resources, such as channels and tokens.
 *
 *		A word of caution about terminology.  Throughout the MCS documentation
 *		the word "attachment" is used in conjunction with a USER attachment. The
 *		word "connection" is used in conjunction with a TRANSPORT connection. In
 *		this class, the two types of "attachments" are NOT differentiated (most
 *		of the time).  They are both referred to as attachments.  When deleting
 *		an attachment, it is necessary to know the difference, however, and so
 *		there is an enumerated type (AttachmentType) to distinguish.  The type
 *		of each attachment is stored in a dictionary for easy access (see
 *		description of AttachmentType below).
 *
 *		This class keeps a list of "attachments" that are hierarchically below
 *		the local provider within the domain.  It also keeps a pointer to the
 *		one attachment that is hierarchically above the local provider (if any).
 *
 *		Since this class inherits from CommandTarget, it processes MCS commands
 *		as member function calls (see cmdtar.h for a description of how this
 *		mechanism works).  In essence, domain objects are just big command
 *		routers who react to incoming commands according to the contents of the
 *		information base.  That information base, in turn, is modified by the
 *		commands that are handled.
 *
 *		Domain objects keep lists of both channel objects and token objects,
 *		who maintain information about the current state of various channels
 *		and tokens.  Objects of this class are the heart of MCS.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */

#ifndef	_DOMAIN_
#define	_DOMAIN_

/*
 *	Interface files.
 */
#include "userchnl.h"
#include "privchnl.h"
#include "token.h"
#include "randchnl.h"
#include "attmnt.h"

/*
 *	This enumeration defines the errors that a domain object can return when
 *	instructed to do something by its creator.
 */
typedef	enum
{
	DOMAIN_NO_ERROR,
	DOMAIN_NOT_HIERARCHICAL,
	DOMAIN_NO_SUCH_CONNECTION,
	DOMAIN_CONNECTION_ALREADY_EXISTS
} DomainError;
typedef	DomainError *		PDomainError;

/*
 *	This enumeration defines the different merge states that a domain can be in
 *	at any given time.  They can be described as follows:
 *
 *	MERGE_INACTIVE
 *		There is no merge operation underway.  This is the normal operational
 *		state.
 *	MERGE_USER_IDS
 *		The domain is currently merging user IDs into the upper domain.
 *	MERGE_STATIC_CHANNELS
 *		The domain is currently merging static channels into the upper domain.
 *	MERGE_ASSIGNED_CHANNELS
 *		The domain is currently merging assigned channels into the upper domain.
 *	MERGE_PRIVATE_CHANNELS
 *		The domain is currently merging private channels into the upper domain.
 *	MERGE_TOKENS
 *		The domain is currently merging tokens into the upper domain.
 *	MERGE_COMPLETE
 *		The merge operation is complete (this is a transitional state).
 */
typedef	enum
{
	MERGE_INACTIVE,
	MERGE_USER_IDS,
	MERGE_STATIC_CHANNELS,
	MERGE_ASSIGNED_CHANNELS,
	MERGE_PRIVATE_CHANNELS,
	MERGE_TOKENS,
	MERGE_COMPLETE
} MergeState;
typedef	MergeState *		PMergeState;

/*
 *	This collection type is used to hold the height of the domain across
 *	various downward attachments.  The Domain object needs to know this in order
 *	to calculate the effect of attachment loss on the height of the domain.
 */
class CDomainHeightList2 : public CList2
{
    DEFINE_CLIST2(CDomainHeightList2, UINT_PTR, PConnection)
};

/*
 *	This is the class definition for the Domain class.
 */
class Domain
{
public:

    Domain ();
    ~Domain ();

    BOOL    IsTopProvider(void) { return (NULL == m_pConnToTopProvider); }

			Void		GetDomainParameters (
									PDomainParameters	domain_parameters,
									PDomainParameters	min_domain_parameters,
									PDomainParameters	max_domain_parameters);
			Void		BindConnAttmnt (
									PConnection         originator,
									BOOL    			upward_connection,
									PDomainParameters	domain_parameters);
			Void		PlumbDomainIndication (
									PConnection         originator,
									ULong				height_limit);
			Void		ErectDomainRequest (
									PConnection         originator,
									ULONG_PTR				height_in_domain,
									ULong				throughput_interval);
			Void		MergeChannelsRequest (
									PConnection             originator,
									CChannelAttributesList *merge_channel_list,
									CChannelIDList         *purge_channel_list);
			Void		MergeChannelsConfirm (
									PConnection             originator,
									CChannelAttributesList *merge_channel_list,
									CChannelIDList         *purge_channel_list);
			Void		PurgeChannelsIndication (
									PConnection             originator,
									CUidList               *purge_user_list,
									CChannelIDList         *purge_channel_list);
			Void		MergeTokensRequest (
									PConnection             originator,
									CTokenAttributesList   *merge_token_list,
									CTokenIDList           *purge_token_list);
			Void		MergeTokensConfirm (
									PConnection             originator,
									CTokenAttributesList   *merge_token_list,
									CTokenIDList           *purge_token_list);
			Void		PurgeTokensIndication (
									PConnection             originator,
									CTokenIDList           *purge_token_list);
			Void		DisconnectProviderUltimatum (
									CAttachment        *originator,
									Reason				reason);
			Void		RejectUltimatum (
									PConnection         originator,
									Diagnostic			diagnostic,
									PUChar				octet_string_address,
									ULong				octet_string_length);
			Void		AttachUserRequest (
									CAttachment        *originator);
			Void		AttachUserConfirm (
									PConnection         originator,
									Result				result,
									UserID				uidInitiator);
			Void		DetachUserRequest (
									CAttachment        *originator,
									Reason				reason,
									CUidList           *user_id_list);
			Void		DetachUserIndication (
									PConnection         originator,
									Reason				reason,
									CUidList           *user_id_list);
			Void		ChannelJoinRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									ChannelID			channel_id);
			Void		ChannelJoinConfirm (
									PConnection         originator,
									Result				result,
									UserID				uidInitiator,
									ChannelID			requested_id,
									ChannelID			channel_id);
			Void		ChannelLeaveRequest (
									CAttachment        *originator,
									CChannelIDList     *channel_id_list);
			Void		ChannelConveneRequest (
									CAttachment        *originator,
									UserID				uidInitiator);
			Void		ChannelConveneConfirm (
									PConnection         originator,
									Result				result,
									UserID				uidInitiator,
									ChannelID			channel_id);
			Void		ChannelDisbandRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									ChannelID			channel_id);
			Void		ChannelDisbandIndication (
									PConnection         originator,
									ChannelID			channel_id);
			Void		ChannelAdmitRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									ChannelID			channel_id,
									CUidList           *user_id_list);
			Void		ChannelAdmitIndication (
									PConnection         originator,
									UserID				uidInitiator,
									ChannelID			channel_id,
									CUidList           *user_id_list);
			Void		ChannelExpelRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									ChannelID			channel_id,
									CUidList           *user_id_list);
			Void		ChannelExpelIndication (
									PConnection         originator,
									ChannelID			channel_id,
									CUidList           *user_id_list);
			Void		SendDataRequest (
									CAttachment        *originator,
									UINT				type,
									PDataPacket			data_packet);
			Void		SendDataIndication (
									PConnection         originator,
									UINT				type,
									PDataPacket			data_packet);
			Void		TokenGrabRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									TokenID				token_id);
			Void		TokenGrabConfirm (
									PConnection         originator,
									Result				result,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
			Void		TokenInhibitRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									TokenID				token_id);
			Void		TokenInhibitConfirm (
									PConnection         originator,
									Result				result,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
			Void		TokenGiveRequest (
									CAttachment        *originator,
									PTokenGiveRecord	pTokenGiveRec);
			Void		TokenGiveIndication (
									PConnection         originator,
									PTokenGiveRecord	pTokenGiveRec);
			Void		TokenGiveResponse (
									CAttachment        *originator,
									Result				result,
									UserID				receiver_id,
									TokenID				token_id);
			Void		TokenGiveConfirm (
									PConnection         originator,
									Result				result,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
			Void		TokenPleaseRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									TokenID				token_id);
			Void		TokenPleaseIndication (
									PConnection         originator,
									UserID				uidInitiator,
									TokenID				token_id);
			Void		TokenReleaseRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									TokenID				token_id);
			Void		TokenReleaseConfirm (
									PConnection         originator,
									Result				result,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
			Void		TokenTestRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									TokenID				token_id);
			Void		TokenTestConfirm (
									PConnection         originator,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);

	private:
				Void		LockDomainParameters (
									PDomainParameters	domain_parameters,
									BOOL    			parameters_locked);
				ChannelID	AllocateDynamicChannel ();
				BOOL    	ValidateUserID (
									UserID				user_id,
									CAttachment         *pOrigAtt);
				Void		PurgeDomain (
									Reason				reason);
				Void		DeleteAttachment (
									CAttachment         *pAtt,
									Reason				reason);
				Void		DeleteUser (
									UserID				user_id);
				Void		DeleteChannel (
									ChannelID			channel_id);
				Void		DeleteToken (
									TokenID				token_id);
				Void		ReclaimResources ();
				Void		MergeInformationBase ();
				Void		SetMergeState (
									MergeState			merge_state);
				Void		AddChannel (
									PConnection             pConn,
									PChannelAttributes	merge_channel,
									CChannelAttributesList *merge_channel_list,
									CChannelIDList         *purge_channel_list);
				Void		AddToken (
									PTokenAttributes	merge_token,
									CTokenAttributesList   *merge_token_list,
									CTokenIDList           *purge_token_list);
				Void		CalculateDomainHeight ();

		MergeState			Merge_State;
		UShort				Outstanding_Merge_Requests;
		UINT				Number_Of_Users;
		UINT				Number_Of_Channels;
		UINT				Number_Of_Tokens;
		DomainParameters	Domain_Parameters;
		BOOL    			Domain_Parameters_Locked;

		PConnection 		m_pConnToTopProvider;
		CAttachmentList     m_AttachmentList;

		CAttachmentQueue    m_AttachUserQueue;
		CConnectionQueue    m_MergeQueue;

		CChannelList2       m_ChannelList2;
		CTokenList2         m_TokenList2;

		UINT_PTR			m_nDomainHeight;
		CDomainHeightList2	m_DomainHeightList2;

		RandomChannelGenerator
							Random_Channel_Generator;
};

/*
 *	Domain ()
 *
 *	Functional Description:
 *		This is the constructor for the domain class.  It initializes the state
 *		of the domain, which at creation is empty.  It also initializes the
 *		domain parameters structure that will be used by this domain for all
 *		future parameters and negotiation.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~Domain ()
 *
 *	Functional Description:
 *		This is the destructor for the domain class.  It purges the entire
 *		domain by first sending disconnect provider ultimatums to ALL
 *		attachments (both user attachments and MCS connections).  It then frees
 *		up all resources in use by the domain (which is just objects in its
 *		various containers).
 *
 *		Note that doing this will result in all user attachments and MCS
 *		connections being broken.  Furthermore, all providers that are
 *		hierarchically below this one, will respond by purging their domains
 *		as well.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		The domain from this provider downward is completely eradicated.
 *
 *	Caveats:
 *		None.
 */

/*
 *	BOOL    	IsTopProvider ()
 *
 *	Functional Description:
 *		This function is used to ask the domain if it is the top provider in
 *		the domain that it represents.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		TRUE if this is the top provider.  FALSE otherwise.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	GetDomainParameters (
 *					PDomainParameters		domain_parameters,
 *					PDomainParameters		min_domain_parameters,
 *					PDomainParameters		max_domain_parameters)
 *
 *	Functional Description:
 *		This function is used to ask the domain what the minimum and maximum
 *		acceptable values for domain parameters are.  If the domain has no
 *		connections (and therefore has not yet locked its domain parameters),
 *		then it will return min and max values based on what it can handle.
 *		If it has locked its domain parameters, then both the min and max values
 *		will be set to the locked set (indicating that it will not accept
 *		anything else).
 *
 *	Formal Parameters:
 *		domain_parameters (o)
 *			Pointer to a structure to be filled with the current domain
 *			parameters (those that are in use).  Setting this to NULL will
 *			prevent current domain parameters from being returned.
 *		min_domain_parameters (o)
 *			Pointer to a structure to be filled with the minimum domain
 *			parameters.  Setting this to NULL will prevent minimum domain
 *			parameters from being returned.
 *		max_domain_parameters (o)
 *			Pointer to a structure to be filled with the maximum domain
 *			parameters.  Setting this to NULL will prevent maximum domain
 *			parameters from being returned.
 *
 *	Return Value:
 *		None (except as specified in the parameter list above).
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	BindConnAttmnt (
 *					PConnection         originator,
 *					BOOL    			upward_connection,
 *					PDomainParameters	domain_parameters,
 *					AttachmentType		attachment_type)
 *
 *	Functional Description:
 *		This function is used when an attachment wishes to bind itself to the
 *		domain.  This will occur only after the connection has been been
 *		completely and successfully negotiated.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment that wishes to bind.
 *		upward_connection (i)
 *			A boolean flag indicating whether or not this is an upward
 *			connection.
 *		domain_parameters (i)
 *			A pointer to a domain parameters structure that holds the parameters
 *			that were negotiated for the connection.  If the domain has not
 *			already locked its parameters, it will accept and lock these.
 *		attachment_type (i)
 *			What type of attachment is this (local or remote).
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	PlumbDomainIndication (
 *					PCommandTarget		originator,
 *					ULong				height_limit)
 *
 *	Functional Description:
 *		This member function represents the reception of a plumb domain
 *		indication from the top provider.  If the height limit is zero, then
 *		the connection to the top provder will be severed.  If its not, then
 *		it will be decremented and broadcast to all downward attachments.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		height_limit (i)
 *			This is initially the height limit for the domain.  It is
 *			decremented at each layer in the domain.  When it reaches zero,
 *			the recipient is too far from the top provider, and must
 *			disconnect.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ErectDomainRequest (
 *					PCommandTarget		originator,
 *					ULong				height_in_domain,
 *					ULong				throughput_interval)
 *
 *	Functional Description:
 *		This member function represents the reception of an erect domain request
 *		from one of its downward attachments.  This contains information needed
 *		by higher providers to know what's going on below (such as total
 *		height of domain).
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		height_in_domain (i)
 *			This is the height of the domain from the originator down.
 *		throughput_interval (i)
 *			This is not currently supported and will always be zero (0).
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	MergeChannelsRequest (
 *					PCommandTarget			originator,
 *					CChannelAttributesList *merge_channel_list,
 *					CChannelIDList         *purge_channel_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a merge channel
 *		request from one of this domain's attachments.  If this is the top
 *		provider, then the merge request will be processed locally (which
 *		will result in the transmission of merge channel confirms back to
 *		the originating attachment).  If this is not the top provider, then
 *		the command will be forwarded toward the top provider, and this
 *		provider will remember how to route it back.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		merge_channel_list (i)
 *			This is a list of strutures that contains the attributes of channels
 *			that are being merged into the upper domain.
 *		purge_channel_list (i)
 *			This is a list of channel IDs for those channels that are determined
 *			to be invalid even before this request reaches the Top Provider.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	MergeChannelsConfirm (
 *					PCommandTarget			originator,
 *					CChannelAttributesList *merge_channel_list,
 *					CChannelIDList         *purge_channel_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a merge channel
 *		confirm from the top provider.  If this is the former top provider of
 *		a lower domain, the confirm will contain information indicating
 *		acceptance or rejection of the named channel.  If a channel is rejected,
 *		the former top provider will issue a purge channel indication
 *		downwards.  If this is not the former top provider, then it must be
 *		an intermediate provider. The command will be forwarded downward towards
 *		the former top provider.  The intermediate providers will also add the
 *		channel to their channel lists if it was accepted into the upper
 *		domain.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		merge_channel_list (i)
 *			This is a list of strutures that contains the attributes of channels
 *			that are being merged into the upper domain.
 *		purge_channel_list (i)
 *			This is a list of channel IDs for those channels that are to be
 *			purged from the lower domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	PurgeChannelsIndication (
 *					PCommandTarget		originator,
 *					CUidList           *purge_user_list,
 *					CChannelIDList     *purge_channel_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a purge channel
 *		indication from the top provider.  This will cause the local
 *		provider to remove the channel from the local information base (if
 *		it are there).  It will also broadcast the message downward in the
 *		domain.  Note that this will be translated by user objects into either
 *		a detach user indication or a channel leave indication, depending on
 *		which type of channel is being left.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		purge_user_list (i)
 *			This is a list of users that are being purged from the lower
 *			domain.
 *		purge_channel_list (i)
 *			This is a list of channels that are being purged from the lower
 *			domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	MergeTokensRequest (
 *					PCommandTarget			originator,
 *					CTokenAttributesList   *merge_token_list,
 *					CTokenIDList           *purge_token_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a merge token
 *		request from one of this domain's attachments.  If this is the top
 *		provider, then the merge request will be processed locally (which
 *		will result in the transmission of merge token confirms back to
 *		the originating attachment).  If this is not the top provider, then
 *		the command will be forwarded toward the top provider, and this provider
 *		will remember how to route it back.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		merge_token_list (i)
 *			This is a list of token attributes structures, each of which
 *			describes one token to be merged.
 *		purge_token_list (i)
 *			This is a list of tokens that are to be purged from the lower
 *			domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	MergeTokensConfirm (
 *					PCommandTarget			originator,
 *					CTokenAttributesList   *merge_token_list,
 *					CTokenIDList           *purge_token_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a merge token
 *		confirm from the top provider.  If this is the former top provider of
 *		a lower domain, the confirm will contain information indicating
 *		acceptance or rejection of the named token.  If a token is rejected,
 *		the former top provider will issue a purge token indication
 *		downwards.  If this is not the former top provider, then it must be
 *		an intermediate provider. The command will be forwarded downward towards
 *		the former top provider.  The intermediate providers will also add the
 *		token to their token lists if it was accepted into the upper
 *		domain.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		merge_token_list (i)
 *			This is a list of token attributes structures, each of which
 *			describes one token to be merged.
 *		purge_token_list (i)
 *			This is a list of tokens that are to be purged from the lower
 *			domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	PurgeTokensIndication (
 *					PCommandTarget		originator,
 *					CTokenIDList       *purge_token_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a purge token
 *		indication  from the top provider.  This will cause the local
 *		provider to remove the token from the local information base (if
 *		it are there).  It will also broadcast the message downward in the
 *		domain.  Note that this will be translated by user objects into a
 *		token release indication.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		purge_token_list (i)
 *			This is a list of tokens that are to be purged from the lower
 *			domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	DisconnectProviderUltimatum (
 *					PCommandTarget		originator,
 *					Reason				reason)
 *
 *	Functional Description:
 *		This member function represents the reception of a disconnect provider
 *		ultimatum.  The attachment from which this command is received is
 *		automatically terminated.  Any resources that are held by users on
 *		the other side of the attachment are automatically freed by the top
 *		provider (if it was a downward attachment).  If it was an upward
 *		attachment then the domain is purged completely (which means that it
 *		is returned to its initialized state).
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		reason (i)
 *			This is the reason for the disconnect.  This will be one of the
 *			reasons defined in "mcatmcs.h".
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		An attachment will be severed, and potentially the entire domain can
 *		be purged.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	RejectUltimatum (
 *					PCommandTarget		originator,
 *					Diagnostic			diagnostic,
 *					PUChar				octet_string_address,
 *					ULong				octet_string_length)
 *
 *	Functional Description:
 *		This command represents the reception of a reject ultimatum.  This
 *		indicates that the remote side was unable to correctly process a PDU
 *		that was sent to them.  At this time we simply sever the connection
 *		that carried the reject.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		diagnostic (i)
 *			This is a diagnostic code describing the nature of the problem.
 *		octet_string_address (i)
 *			This is address of an optional octet string that contains the
 *			bad PDU.
 *		octet_string_length (i)
 *			This is the length of the above octet string.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	AttachUserRequest (
 *					PCommandTarget		originator)
 *
 *	Functional Description:
 *		This member function represents the reception of an attach user request.
 *		If this is the top provider, the domain will attempt to add the
 *		new user into the channel list (as a user channel).  A confirm will
 *		be issued in the direction of the requesting user, letting it know
 *		the outcome of the attach operation (as well as the user ID if the
 *		attach was successful).  If his is not the top provider, then the
 *		request will be forwarded in the direction of the top provider.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	AttachUserConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator)
 *
 *	Functional Description:
 *		This member function represents the reception of an attach user confirm.
 *		If this provider has an outstanding attach user request, then it
 *		will forward the confirm in the direction of the requester.  It will
 *		also add the new user channel to the local channel list.  If there
 *		are no outstanding requests (as a result of the requester being
 *		disconnected), then this provider will issue a detach user request
 *		upward to eliminate the user ID that is no longer needed (it will only
 *		do this if the result of the attach was successful).
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		result (i)
 *			This is the result of the attach operation.  Anything but
 *			RESULT_SUCCESSFUL indicates that the attach did not succeed.
 *		uidInitiator (i)
 *			If the attach succeeded, then this field will contain the user ID
 *			of the newly attached user.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	DetachUserRequest (
 *					PCommandTarget		originator,
 *					Reason				reason,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a detach user request.
 *		This causes the user channels associated with all users in the list to
 *		be deleted from the user information base.  If this is not the top
 *		provider, the request will then be forwarded upward.  Additionally,
 *		all resources owned by the detaching users will be reclaimed by all
 *		providers along the way.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		reason (i)
 *			This is the reason for th detachment.
 *		user_id_list (i)
 *			This is a list of the users that are detaching.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	DetachUserIndication (
 *					PCommandTarget		originator,
 *					Reason				reason,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a detach user
 *		indication.  This indication will be repeated to all downward
 *		attachments (both user attachments and MCS connections).  Then, if
 *		the user IDs represent any users in the local sub-tree, those users will
 *		be removed from the information base.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		reason (i)
 *			This is the reason for the detachment.
 *		user_id_list (i)
 *			This is a list of the users that are detaching.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ChannelJoinRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This member function represents the reception of a channel join request.
 *		If the channel exists in the local information base, then the
 *		domain will attempt to join the requesting attachment to the channel.
 *		A channel join confirm will be sent to the requesting attachment
 *		informing the requester of the result.  If the channel is not already
 *		in the information base, then one of two things will happen.  If this
 *		is the top provider, then the domain will attempt to add the channel
 *		(if it is a static channel).  If this is not the top provider, then
 *		the request will be forwarded upward.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the user ID of the user requesting the join.
 *		channel_id (i)
 *			This is the ID of the channel to be joined.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ChannelJoinConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					ChannelID			requested_id,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This member function represents the reception of a channel join confirm.
 *		If the channel has not already been added to the channel, it will
 *		be put there now.  The confirm will then be forwarded in the direction
 *		of the requesting user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		result (i)
 *			This is the result of the join.  Anything but RESULT_SUCCESSFUL
 *			means that the join failed.
 *		uidInitiator (i)
 *			This is the user ID of the user that requested the channel join.
 *			This is used to properly route the confirm.
 *		requested_id (i)
 *			This is the ID of the channel the user originally requested, which
 *			may be 0.
 *		channel_id (i)
 *			This is the ID of the channel that has been joined.  If the original
 *			request was for channel 0, then this field will indicate to the
 *			user which assigned channel was selected by the top provider.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ChannelLeaveRequest (
 *					PCommandTarget		originator,
 *					CChannelIDList     *channel_id_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a channel leave
 *		request.  The domain removes the requesting attachment from all channels
 *		in the channel list. If this results in any empty channels, then the
 *		channel leave request will be forwarded to the next higher provider in
 *		the domain (unless this is the top provider).  Furthermore, if a static
 *		or assigned channel is left empty, it is automatically removed from the
 *		channel list.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		channel_id_list (i)
 *			This is a list of channels to be left.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelConveneRequest (
 *						PCommandTarget		originator,
 *						UserID				uidInitiator)
 *
 *	Functional Description:
 *		This member function represents the reception of a channel convene
 *		request.  If this is not the Top Provider, the request will be sent
 *		upward.  If this is the Top Provider, then a new private channel will
 *		be created (if domain parameters allow).
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the user ID of the user that requested the creation of a
 *			new private channel.  This is used to properly route the confirm.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelConveneConfirm (
 *						PCommandTarget		originator,
 *						Result				result,
 *						UserID				uidInitiator,
 *						ChannelID			channel_id)
 *
 *	Functional Description:
 *		This member function represents the reception of a channel convene
 *		confirm.  This causes the local provider to add the new private channel
 *		to the local information base, and route the confirm on toward the
 *		initiator of the request.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		result (i)
 *			This is the result of the convene.  Anything but RESULT_SUCCESSFUL
 *			means that the convene failed.
 *		uidInitiator (i)
 *			This is the user ID of the user that requested the channel convene.
 *			This is used to properly route the confirm.
 *		channel_id (i)
 *			This is the ID of the new private channel that has been created.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelDisbandRequest (
 *						PCommandTarget		originator,
 *						UserID				uidInitiator,
 *						ChannelID			channel_id)
 *
 *	Functional Description:
 *		This member function represents the reception of a channel disband
 *		request.  If this is not the Top Provider, then the request will be
 *		forwarded upward.  If this is the Top Provider, then the specified
 *		private channel will be destroyed (after appropriate identity
 *		verification).  This will cause channel disband and channel expel
 *		indications to be sent downward to all admitted users.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the user ID of the user that requested the channel disband.
 *			If this does not correspond to the channel manager, then the request
 *			will be ignored.
 *		channel_id (i)
 *			This is the ID of the channel to be disbanded.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelDisbandIndication (
 *						PCommandTarget		originator,
 *						ChannelID			channel_id)
 *
 *	Functional Description:
 *		This member function represents the reception of a channel disband
 *		indication.  This causes the specified private channel to be removed
 *		from the information base.  The indication is then forwarded to all
 *		attachments that are either admitted or the channel manager.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		channel_id (i)
 *			This is the ID of the channel being disbanded.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelAdmitRequest (
 *						PCommandTarget		originator,
 *						UserID				uidInitiator,
 *						ChannelID			channel_id,
 *						CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a channel admit
 *		request.  If this is not the Top Provider, then the request will be
 *		forwarded upward.  If this is the Top Provider, then the user IDs
 *		will be added to the admitted list, and a channel admit indication will
 *		be sent downward toward all attachments that contain an admitted user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the user ID of the user that requested the channel admit.
 *			This must be the channel manager for the admit to succeed.
 *		channel_id (i)
 *			This is the ID of the private channel whose admitted list is to
 *			be expanded.
 *		user_id_list (i)
 *			This is a container holding the user IDs of those users to be
 *			admitted to the private channel.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelAdmitIndication (
 *						PCommandTarget		originator,
 *						UserID				uidInitiator,
 *						ChannelID			channel_id,
 *						CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a channel admit
 *		indication.  If the specified private channel does not yet exist in the
 *		information base, it will be created now.  The users specified will be
 *		added to the admitted list, and this indication will be forwarded to
 *		all attachments that contain an admitted user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the user ID of the manager of this private channel.
 *		channel_id (i)
 *			This is the ID of the private channel for which this indication
 *			is intended.
 *		user_id_list (i)
 *			This is a container holding the list of user IDs to be added to
 *			the admitted list.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelExpelRequest (
 *						PCommandTarget		originator,
 *						UserID				uidInitiator,
 *						ChannelID			channel_id,
 *						CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a channel expel
 *		request.  If this is not the Top Provider, then the request will be
 *		forwarded upward.  If this is the Top Provider, then the specifed users
 *		will be removed from the private channel, and an expel indication will
 *		be sent downward to all attachments that contain (or did contain) an
 *		admitted user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the user ID of the user that requested the channel expel.
 *			This must be the channel manager for the expel to succeed.
 *		channel_id (i)
 *			This is the ID of the private channel whose admitted list is to
 *			be reduced.
 *		user_id_list (i)
 *			This is a container holding the user IDs of those users to be
 *			expelled from the private channel.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelExpelIndication (
 *						PCommandTarget		originator,
 *						ChannelID			channel_id,
 *						CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a channel expel
 *		indication.  The specified users will be removed from the admitted
 *		list of the channel.  If the channel is empty, and the channel manager
 *		is not in the sub-tree of this provider, then the channel will be
 *		removed from the local information base.  The expel indication will
 *		also be forwarded to all attachments that contain (or did contain( an
 *		admitted user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		channel_id (i)
 *			This is the ID of the private channel for which this indication
 *			is intended.
 *		user_id_list (i)
 *			This is a container holding the list of user IDs to be removed
 *			from the admitted list.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	SendDataRequest (
 *					PCommandTarget		originator,
 *					UINT				type,
 *					PDataPacket			data_packet)
 *
 *	Functional Description:
 *		This member function represents the reception of a send data request.
 *		If this is not the top provider, the request will be repeated
 *		upward toward the top provider.  The data will also be sent downward
 *		to all attachments that are joined to the channel (except for the
 *		originator) in the form of a send data indication.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		type (i)
 *			Normal or uniform send data request.
 *		data_packet (i)
 *			This is a pointer to a DataPacket object containing the channel
 *			ID, the User ID of the data sender, segmentation flags, priority of
 *			the data packet and a pointer to the packet to be sent.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	SendDataIndication (
 *					PCommandTarget		originator,
 *					UINT				type,
 *					PDataPacket			data_packet)
 *
 *	Functional Description:
 *		This member function represents the reception of a send data indication.
 *		This indication will be repeated downward to all attachments that
 *		are joined to the channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		type (i)
 *			normal or uniform send data indication
 *		data_packet (i)
 *			This is a pointer to a DataPacket object containing the channel
 *			ID, the User ID of the data sender, segmentation flags, priority of
 *			the data packet and a pointer to the packet to be sent.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGrabRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This member function represents the reception of a token grab request.
 *		If this is not the top provider, the request will be forwarded
 *		upward towards the top provider.  If this is the top provider, the
 *		domain will attempt to grab the token on behalf of the requesting user.
 *		A token grab confirm will be issued to the requesting user informing
 *		it of the outcome.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the ID of the user that is requesting the token grab.
 *		token_id (i)
 *			This is the ID of the token that the user is attempting to grab.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenGrabConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This member function represents the reception of a token grab confirm.
 *		This confirm will simply be forwarded in the direction of the
 *		requesting user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		result (i)
 *			This is the result of the grab request.  If it is anything but
 *			RESULT_SUCCESSFUL, the grab request failed.
 *		uidInitiator (i)
 *			This is the ID of the user that is requesting the token grab.
 *		token_id (i)
 *			This is the ID of the token that the user is attempting to grab.
 *		token_status (i)
 *			This is the state of the token after the grab request was
 *			processed at the top provider.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenInhibitRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This member function represents the reception of a token inhibit
 *		request.  If this is not the top provider, the request will be forwarded
 *		upward towards the top provider.  If this is the top provider, the
 *		domain will attempt to inhibit the token on behalf of the requesting
 *		user.  A token inhibit confirm will be issued to the requesting user
 *		informing it of the outcome.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the ID of the user that is requesting the token inhibit.
 *		token_id (i)
 *			This is the ID of the token that the user is attempting to inhibit.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenInhibitConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This member function represents the reception of a token inhibit
 *		confirm.  This confirm will simply be forwarded in the direction of the
 *		requesting user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		result (i)
 *			This is the result of the inhibit request.  If it is anything but
 *			RESULT_SUCCESSFUL, the inhibit request failed.
 *		uidInitiator (i)
 *			This is the ID of the user that is requesting the token inhibit.
 *		token_id (i)
 *			This is the ID of the token that the user is attempting to inhibit.
 *		token_status (i)
 *			This is the state of the token after the inhibit request was
 *			processed at the top provider.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		TokenGiveRequest (
 *						PCommandTarget		originator,
 *						PTokenGiveRecord	pTokenGiveRec)
 *
 *	Functional Description:
 *		This member function represents the reception of a token give request.
 *		If this is not the top provider, the request will be forwarded upward
 *		towards the top provider.  If this is the top provider, the domain will
 *		issue a token give indication in the direction of the user identified
 *		to receive the token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		pTokenGiveRec (i)
 *			This is the address of a structure containing the following information:
 *			The ID of the user attempting to give away the token.
 *			The ID of the token being given.
 *			The ID of the user that the token is being given to.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		TokenGiveIndication (
 *						PCommandTarget		originator,
 *						PTokenGiveRecord	pTokenGiveRec)
 *
 *	Functional Description:
 *		This member function represents the reception of a token give
 *		indication.  This indication will be forwarded toward the user that
 *		is to receive the token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		pTokenGiveRec (i)
 *			This is the address of a structure containing the following information:
 *			The ID of the user attempting to give away the token.
 *			The ID of the token being given.
 *			The ID of the user that the token is being given to.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		TokenGiveResponse (
 *						PCommandTarget		originator,
 *						Result				result,
 *						UserID				receiver_id,
 *						TokenID				token_id)
 *
 *	Functional Description:
 *		This member function represents the reception of a token give response.
 *		If this is not the top provider, the response will be forwarded
 *		upward towards the top provider.  If this is the top provider, the
 *		domain will make the appropriate changes to the state of the token in
 *		the local information base, and then issue a token give confirm to the
 *		user that initiated the give request.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		result (i)
 *			This specifies whether or not the token was accepted.  Anything but
 *			RESULT_SUCCESSFUL indicates that the token was rejected.
 *		receiver_id (i)
 *			This is the ID of the user that has either accepted or rejected the
 *			token.
 *		token_id (i)
 *			This is the ID of the token that the user has been given.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		TokenGiveConfirm (
 *						PCommandTarget		originator,
 *						Result				result,
 *						UserID				uidInitiator,
 *						TokenID				token_id,
 *						TokenStatus			token_status)
 *
 *	Functional Description:
 *		This member function represents the reception of a token give confirm.
 *		This is forwarded toward the user that initiated the give request to
 *		inform it of the outcome.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		result (i)
 *			This parameter specifies whether or not the token was accepted.
 *			Anything but RESULT_SUCCESSFUL indicates that the token was not
 *			accepted.
 *		uidInitiator (i)
 *			This is the ID of the user that originally requested the token
 *			give request.
 *		token_id (i)
 *			This is the ID of the token that the user is attempting to give.
 *		token_status (i)
 *			This specifies the status of the token after the give operation
 *			was complete.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		TokenPleaseRequest (
 *						PCommandTarget		originator,
 *						UserID				uidInitiator,
 *						TokenID				token_id)
 *
 *	Functional Description:
 *		This member function represents the reception of a token please
 *		request.  If this is not the top provider, the request will be forwarded
 *		upward towards the top provider.  If this is the top provider, the
 *		domain will issue a token please indication in the direction of all
 *		users that currently own the token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the ID of the user that is asking for the token.
 *		token_id (i)
 *			This is the ID of the token that the user is asking for.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		TokenPleaseIndication (
 *						PCommandTarget		originator,
 *						UserID				uidInitiator,
 *						TokenID				token_id)
 *
 *	Functional Description:
 *		This member function represents the reception of a token please
 *		indication.  This indication is forwarded to all users who currently
 *		own the specified token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the ID of the user that is asking for the token.
 *		token_id (i)
 *			This is the ID of the token that the user is asking for.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenReleaseRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This member function represents the reception of a token release
 *		request.  If this is not the top provider, the request will be forwarded
 *		upward towards the top provider.  If this is the top provider, the
 *		domain will attempt to release the token on behalf of the requesting
 *		user.  A token release confirm will be issued to the requesting user
 *		informing it of the outcome.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the ID of the user that is requesting the token release.
 *		token_id (i)
 *			This is the ID of the token that the user is attempting to release.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenReleaseConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This member function represents the reception of a token release
 *		confirm.  This confirm will simply be forwarded in the direction of the
 *		requesting user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		result (i)
 *			This is the result of the release request.  If it is anything but
 *			RESULT_SUCCESSFUL, the release request failed.
 *		uidInitiator (i)
 *			This is the ID of the user that is requesting the token release.
 *		token_id (i)
 *			This is the ID of the token that the user is attempting to release.
 *		token_status (i)
 *			This is the state of the token after the release request was
 *			processed at the top provider.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenTestRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This member function represents the reception of a token test request.
 *		If this is not the top provider, the request will be forwarded
 *		upward towards the top provider.  If this is the top provider, the
 *		domain will test the current state of the token.  A token test confirm
 *		will be issued to the requesting user informing it of the outcome.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the ID of the user that is requesting the token test.
 *		token_id (i)
 *			This is the ID of the token that the user is testing.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenTestConfirm (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This member function represents the reception of a token test confirm.
 *		This confirm will simply be forwarded in the direction of the
 *		requesting user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the ID of the user that is requesting the token test.
 *		token_id (i)
 *			This is the ID of the token that the user is testing.
 *		token_status (i)
 *			This is the state of the token at the time of the test.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\fsdiag.h ===
// fsdiag.h


#ifndef	_FSDIAG_
#define	_FSDIAG_

#define MULTI_LEVEL_ZONES
#include <mlzdbg.h>

#if defined(_DEBUG)

VOID T120DiagnosticCreate(VOID);
VOID T120DiagnosticDestroy(VOID);

#define TRACE_OUT_EX(z,s)	(MLZ_TraceZoneEnabled(z) || MLZ_TraceZoneEnabled(MLZ_FILE_ZONE))  ? (MLZ_TraceOut s) : 0

#else

#define T120DiagnosticCreate()
#define T120DiagnosticDestroy()
#define DEBUG_FILEZONE(z)

#define TRACE_OUT_EX(z,s)

#endif // _DEBUG


#ifdef _DEBUG

enum
{
    ZONE_T120_MCSNC = BASE_ZONE_INDEX,
    ZONE_T120_GCCNC,    // GCC Provider
    ZONE_T120_MSMCSTCP,
    ZONE_T120_SAP,      // GCC App SAP and Control SAP
    ZONE_T120_APP_ROSTER,
    ZONE_T120_CONF_ROSTER,
    ZONE_T120_REGISTRY, // GCC App Registry
    ZONE_T120_MEMORY,
    ZONE_T120_UTILITY,
    ZONE_GCC_NC,        // GCC Node Controller
    ZONE_GCC_NCI,       // GCC Node Controller Interface INodeController
    ZONE_T120_T123PSTN,
};

extern UINT MLZ_FILE_ZONE;
#define DEBUG_FILEZONE(z)  static UINT MLZ_FILE_ZONE = (z)

#endif // _DEBUG

#endif // _FSDIAG_


// lonchanc: this must be outside the _FSDIAG_ protection.
#if defined(_DEBUG) && defined(INIT_DBG_ZONE_DATA)

static const PSTR c_apszDbgZones[] =
{
	"T.120",				// debug zone module name
	DEFAULT_ZONES
	TEXT("MCS"),			// ZONE_T120_MCSNC
	TEXT("GCC"),			// ZONE_T120_GCCNC
	TEXT("TCP"),			// ZONE_T120_MSMCSTCP
	TEXT("SAP"),			// ZONE_T120_SAP
	TEXT("A-Roster"),		// ZONE_T120_APP_ROSTER
	TEXT("C-Roster"),		// ZONE_T120_CONF_ROSTER
	TEXT("Registry"),		// ZONE_T120_REGISTRY
	TEXT("Memory Tracking"),// ZONE_T120_MEMORY
	TEXT("Common"),			// ZONE_T120_UTILITY
	TEXT("GCC NC"),         // ZONE_GCC_NC
	TEXT("GCC NC Intf"),    // ZONE_GCC_NCI
    TEXT("T123 PSTN"),      // ZONE_T120_T123PSTN
};

UINT MLZ_FILE_ZONE = ZONE_T120_UTILITY;

#endif // _DEBUG && INIT_DBG_ZONE_DATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\gccpdu.h ===
#ifndef _GCCPDU_Module_H_
#define _GCCPDU_Module_H_

#include "msper.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct WaitingList * PWaitingList;

typedef struct PermissionList * PPermissionList;

typedef struct SetOfDestinationNodes * PSetOfDestinationNodes;

typedef struct SetOfTransferringNodesIn * PSetOfTransferringNodesIn;

typedef struct SetOfTransferringNodesRs * PSetOfTransferringNodesRs;

typedef struct SetOfTransferringNodesRq * PSetOfTransferringNodesRq;

typedef struct ParticipantsList * PParticipantsList;

typedef struct SetOfPrivileges * PSetOfPrivileges;

typedef struct SetOfApplicationRecordUpdates * PSetOfApplicationRecordUpdates;

typedef struct SetOfApplicationRecordRefreshes * PSetOfApplicationRecordRefreshes;

typedef struct SetOfApplicationCapabilityRefreshes * PSetOfApplicationCapabilityRefreshes;

typedef struct SetOfNodeRecordUpdates * PSetOfNodeRecordUpdates;

typedef struct SetOfNodeRecordRefreshes * PSetOfNodeRecordRefreshes;

typedef struct ApplicationProtocolEntityList * PApplicationProtocolEntityList;

typedef struct SetOfApplicationInformation * PSetOfApplicationInformation;

typedef struct SetOfConferenceDescriptors * PSetOfConferenceDescriptors;

typedef struct SetOfExpectedCapabilities * PSetOfExpectedCapabilities;

typedef struct SetOfNonCollapsingCapabilities * PSetOfNonCollapsingCapabilities;

typedef struct SetOfChallengeItems * PSetOfChallengeItems;

typedef struct SetOfUserData * PSetOfUserData;

typedef struct SetOfNetworkAddresses * PSetOfNetworkAddresses;

typedef ASN1uint16_t ChannelID;

typedef ASN1uint16_t StaticChannelID;

typedef ASN1uint16_t DynamicChannelID;

typedef DynamicChannelID UserID;

typedef ASN1uint16_t TokenID;

typedef ASN1uint16_t StaticTokenID;

typedef ASN1uint16_t DynamicTokenID;

typedef ASN1int32_t Time;

typedef ASN1uint32_t Handle;

typedef struct H221NonStandardIdentifier {
    ASN1uint32_t length;
    ASN1octet_t value[255];
} H221NonStandardIdentifier;

typedef ASN1char16string_t TextString;

typedef ASN1char16string_t SimpleTextString;

typedef ASN1char_t SimpleNumericString[256];

typedef ASN1char_t DialingString[17];

typedef ASN1char_t SubAddressString[41];

typedef TextString ExtraDialingString;

typedef SimpleNumericString ConferenceNameModifier;

typedef enum Privilege {
    terminate = 0,
    ejectUser = 1,
    add = 2,
    lockUnlock = 3,
    transfer = 4,
} Privilege;

typedef enum TerminationMethod {
    automatic = 0,
    manual = 1,
} TerminationMethod;

typedef enum NodeType {
    terminal = 0,
    multiportTerminal = 1,
    mcu = 2,
} NodeType;

typedef enum ChannelType {
    ChannelType_static = 0,
    dynamicMulticast = 1,
    dynamicPrivate = 2,
    dynamicUserId = 3,
} ChannelType;

typedef ASN1uint16_t EntityID;

typedef enum RegistryModificationRights {
    owner = 0,
    session = 1,
    RegistryModificationRights_public = 2,
} RegistryModificationRights;

typedef struct ApplicationCapabilitiesList {
    ASN1choice_t choice;
    union {
#	define capability_no_change_chosen 1
#	define application_capability_refresh_chosen 2
	PSetOfApplicationCapabilityRefreshes application_capability_refresh;
    } u;
} ApplicationCapabilitiesList;

typedef struct ApplicationRecordList {
    ASN1choice_t choice;
    union {
#	define application_no_change_chosen 1
#	define application_record_refresh_chosen 2
	PSetOfApplicationRecordRefreshes application_record_refresh;
#	define application_record_update_chosen 3
	PSetOfApplicationRecordUpdates application_record_update;
    } u;
} ApplicationRecordList;

typedef struct HighLayerCompatibility {
    ASN1bool_t telephony3kHz;
    ASN1bool_t telephony7kHz;
    ASN1bool_t videotelephony;
    ASN1bool_t videoconference;
    ASN1bool_t audiographic;
    ASN1bool_t audiovisual;
    ASN1bool_t multimedia;
} HighLayerCompatibility;

typedef struct TransferModes {
    ASN1bool_t speech;
    ASN1bool_t voice_band;
    ASN1bool_t digital_56k;
    ASN1bool_t digital_64k;
    ASN1bool_t digital_128k;
    ASN1bool_t digital_192k;
    ASN1bool_t digital_256k;
    ASN1bool_t digital_320k;
    ASN1bool_t digital_384k;
    ASN1bool_t digital_512k;
    ASN1bool_t digital_768k;
    ASN1bool_t digital_1152k;
    ASN1bool_t digital_1472k;
    ASN1bool_t digital_1536k;
    ASN1bool_t digital_1920k;
    ASN1bool_t packet_mode;
    ASN1bool_t frame_mode;
    ASN1bool_t atm;
} TransferModes;

typedef struct TransportConnectionType {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    struct TransportConnectionType_nsap_address_nsap_address {
	ASN1uint32_t length;
	ASN1octet_t value[20];
    } nsap_address;
#   define transport_selector_present 0x80
    ASN1octetstring_t transport_selector;
} TransportConnectionType;

typedef struct AggregateChannel {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    TransferModes transfer_modes;
    DialingString international_number;
#   define sub_address_present 0x80
    SubAddressString sub_address;
#   define extra_dialing_string_present 0x40
    ExtraDialingString extra_dialing_string;
#   define high_layer_compatibility_present 0x20
    HighLayerCompatibility high_layer_compatibility;
} AggregateChannel;

typedef struct NodeRecordList {
    ASN1choice_t choice;
    union {
#	define node_no_change_chosen 1
#	define node_record_refresh_chosen 2
	PSetOfNodeRecordRefreshes node_record_refresh;
#	define node_record_update_chosen 3
	PSetOfNodeRecordUpdates node_record_update;
    } u;
} NodeRecordList;

typedef struct WaitingList {
    PWaitingList next;
    UserID value;
} WaitingList_Element;

typedef struct PermissionList {
    PPermissionList next;
    UserID value;
} PermissionList_Element;

typedef struct SetOfDestinationNodes {
    PSetOfDestinationNodes next;
    UserID value;
} SetOfDestinationNodes_Element;

typedef struct NodeInformation {
    NodeRecordList node_record_list;
    ASN1uint16_t roster_instance_number;
    ASN1bool_t nodes_are_added;
    ASN1bool_t nodes_are_removed;
} NodeInformation;

typedef struct SetOfTransferringNodesIn {
    PSetOfTransferringNodesIn next;
    UserID value;
} SetOfTransferringNodesIn_Element;

typedef struct SetOfTransferringNodesRs {
    PSetOfTransferringNodesRs next;
    UserID value;
} SetOfTransferringNodesRs_Element;

typedef struct SetOfTransferringNodesRq {
    PSetOfTransferringNodesRq next;
    UserID value;
} SetOfTransferringNodesRq_Element;

typedef struct RegistryEntryOwnerOwned {
    UserID node_id;
    EntityID entity_id;
} RegistryEntryOwnerOwned;

typedef struct ParticipantsList {
    PParticipantsList next;
    TextString value;
} ParticipantsList_Element;

typedef struct Key {
    ASN1choice_t choice;
    union {
#	define object_chosen 1
	ASN1objectidentifier_t object;
#	define h221_non_standard_chosen 2
	H221NonStandardIdentifier h221_non_standard;
    } u;
} Key;

typedef struct NonStandardParameter {
    Key key;
    ASN1octetstring_t data;
} NonStandardParameter;

typedef struct Password {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    SimpleNumericString numeric;
#   define password_text_present 0x80
    SimpleTextString password_text;
} Password;

typedef struct PasswordSelector {
    ASN1choice_t choice;
    union {
#	define password_selector_numeric_chosen 1
	SimpleNumericString password_selector_numeric;
#	define password_selector_text_chosen 2
	SimpleTextString password_selector_text;
    } u;
} PasswordSelector;

typedef struct ChallengeResponseItem {
    ASN1choice_t choice;
    union {
#	define password_string_chosen 1
	PasswordSelector password_string;
#	define set_of_response_data_chosen 2
	PSetOfUserData set_of_response_data;
    } u;
} ChallengeResponseItem;

typedef struct ChallengeResponseAlgorithm {
    ASN1choice_t choice;
    union {
#	define algorithm_clear_password_chosen 1
#	define non_standard_algorithm_chosen 2
	NonStandardParameter non_standard_algorithm;
    } u;
} ChallengeResponseAlgorithm;

typedef struct ChallengeItem {
    ChallengeResponseAlgorithm response_algorithm;
    PSetOfUserData set_of_challenge_data;
} ChallengeItem;

typedef struct ChallengeRequest {
    ASN1int32_t challenge_tag;
    PSetOfChallengeItems set_of_challenge_items;
} ChallengeRequest;

typedef struct ChallengeResponse {
    ASN1int32_t challenge_tag;
    ChallengeResponseAlgorithm response_algorithm;
    ChallengeResponseItem response_item;
} ChallengeResponse;

typedef struct ConferenceName {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    SimpleNumericString numeric;
#   define conference_name_text_present 0x80
    SimpleTextString conference_name_text;
} ConferenceName;

typedef struct ConferenceNameSelector {
    ASN1choice_t choice;
    union {
#	define name_selector_numeric_chosen 1
	SimpleNumericString name_selector_numeric;
#	define name_selector_text_chosen 2
	SimpleTextString name_selector_text;
    } u;
} ConferenceNameSelector;

typedef struct NodeProperties {
    ASN1bool_t device_is_manager;
    ASN1bool_t device_is_peripheral;
} NodeProperties;

typedef struct AsymmetryIndicator {
    ASN1choice_t choice;
    union {
#	define calling_node_chosen 1
#	define called_node_chosen 2
#	define unknown_chosen 3
	ASN1uint32_t unknown;
    } u;
} AsymmetryIndicator;

typedef struct AlternativeNodeID {
    ASN1choice_t choice;
    union {
#	define h243_node_id_chosen 1
	struct AlternativeNodeID_h243_node_id_h243_node_id {
	    ASN1uint32_t length;
	    ASN1octet_t value[2];
	} h243_node_id;
    } u;
} AlternativeNodeID;

typedef struct ConferenceDescriptor {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ConferenceName conference_name;
#   define conference_name_modifier_present 0x80
    ConferenceNameModifier conference_name_modifier;
#   define conference_description_present 0x40
    TextString conference_description;
    ASN1bool_t conference_is_locked;
    ASN1bool_t clear_password_required;
#   define descriptor_net_address_present 0x20
    PSetOfNetworkAddresses descriptor_net_address;
} ConferenceDescriptor;

typedef struct NodeRecord {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define superior_node_present 0x80
    UserID superior_node;
    NodeType node_type;
    NodeProperties node_properties;
#   define node_name_present 0x40
    TextString node_name;
#   define participants_list_present 0x20
    PParticipantsList participants_list;
#   define site_information_present 0x10
    TextString site_information;
#   define record_net_address_present 0x8
    PSetOfNetworkAddresses record_net_address;
#   define alternative_node_id_present 0x4
    AlternativeNodeID alternative_node_id;
#   define record_user_data_present 0x2
    PSetOfUserData record_user_data;
} NodeRecord;

typedef struct SessionKey {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Key application_protocol_key;
#   define session_id_present 0x80
    ChannelID session_id;
} SessionKey;

typedef struct ApplicationRecord {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t application_is_active;
    ASN1bool_t is_conducting_capable;
#   define record_startup_channel_present 0x80
    ChannelType record_startup_channel;
#   define application_user_id_present 0x40
    UserID application_user_id;
#   define non_collapsing_capabilities_present 0x20
    PSetOfNonCollapsingCapabilities non_collapsing_capabilities;
} ApplicationRecord;

typedef struct CapabilityID {
    ASN1choice_t choice;
    union {
#	define standard_chosen 1
	ASN1uint16_t standard;
#	define capability_non_standard_chosen 2
	Key capability_non_standard;
    } u;
} CapabilityID;

typedef struct CapabilityClass {
    ASN1choice_t choice;
    union {
#	define logical_chosen 1
#	define unsigned_minimum_chosen 2
	ASN1uint32_t unsigned_minimum;
#	define unsigned_maximum_chosen 3
	ASN1uint32_t unsigned_maximum;
    } u;
} CapabilityClass;

typedef struct ApplicationInvokeSpecifier {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    SessionKey session_key;
#   define expected_capability_set_present 0x80
    PSetOfExpectedCapabilities expected_capability_set;
#   define invoke_startup_channel_present 0x40
    ChannelType invoke_startup_channel;
    ASN1bool_t invoke_is_mandatory;
} ApplicationInvokeSpecifier;

typedef struct RegistryKey {
    SessionKey session_key;
    struct RegistryKey_resource_id_resource_id {
	ASN1uint32_t length;
	ASN1octet_t value[64];
    } resource_id;
} RegistryKey;

typedef struct RegistryItem {
    ASN1choice_t choice;
    union {
#	define channel_id_chosen 1
	DynamicChannelID channel_id;
#	define token_id_chosen 2
	DynamicTokenID token_id;
#	define parameter_chosen 3
	struct RegistryItem_parameter_parameter {
	    ASN1uint32_t length;
	    ASN1octet_t value[64];
	} parameter;
#	define vacant_chosen 4
    } u;
} RegistryItem;

typedef struct RegistryEntryOwner {
    ASN1choice_t choice;
    union {
#	define owned_chosen 1
	RegistryEntryOwnerOwned owned;
#	define not_owned_chosen 2
    } u;
} RegistryEntryOwner;

typedef struct UserIDIndication {
    UINT_PTR tag;
} UserIDIndication;

typedef struct SetOfPrivileges {
    PSetOfPrivileges next;
    Privilege value;
} SetOfPrivileges_Element;

typedef struct ConferenceCreateRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ConferenceName conference_name;
#   define ccrq_convener_password_present 0x80
    Password ccrq_convener_password;
#   define ccrq_password_present 0x40
    Password ccrq_password;
    ASN1bool_t conference_is_locked;
    ASN1bool_t conference_is_listed;
    ASN1bool_t conference_is_conductible;
    TerminationMethod termination_method;
#   define ccrq_conductor_privs_present 0x20
    PSetOfPrivileges ccrq_conductor_privs;
#   define ccrq_conducted_privs_present 0x10
    PSetOfPrivileges ccrq_conducted_privs;
#   define ccrq_non_conducted_privs_present 0x8
    PSetOfPrivileges ccrq_non_conducted_privs;
#   define ccrq_description_present 0x4
    TextString ccrq_description;
#   define ccrq_caller_id_present 0x2
    TextString ccrq_caller_id;
#   define ccrq_user_data_present 0x1
    PSetOfUserData ccrq_user_data;
} ConferenceCreateRequest;

typedef enum ConferenceCreateResult {
    ConferenceCreateResult_success = 0,
    ConferenceCreateResult_userRejected = 1,
    resourcesNotAvailable = 2,
    rejectedForSymmetryBreaking = 3,
    lockedConferenceNotSupported = 4,
} ConferenceCreateResult;
typedef struct ConferenceCreateResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    UserID node_id;
    UINT_PTR tag;
    ConferenceCreateResult result;
#   define ccrs_user_data_present 0x80
    PSetOfUserData ccrs_user_data;
} ConferenceCreateResponse;

typedef struct ConferenceQueryRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    NodeType node_type;
#   define cqrq_asymmetry_indicator_present 0x80
    AsymmetryIndicator cqrq_asymmetry_indicator;
#   define cqrq_user_data_present 0x40
    PSetOfUserData cqrq_user_data;
} ConferenceQueryRequest;

typedef enum ConferenceQueryResult {
    ConferenceQueryResult_success = 0,
    ConferenceQueryResult_userRejected = 1,
} ConferenceQueryResult;
typedef struct ConferenceQueryResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    NodeType node_type;
#   define cqrs_asymmetry_indicator_present 0x80
    AsymmetryIndicator cqrs_asymmetry_indicator;
    PSetOfConferenceDescriptors conference_list;
    ConferenceQueryResult result;
#   define cqrs_user_data_present 0x40
    PSetOfUserData cqrs_user_data;
} ConferenceQueryResponse;

typedef struct ConferenceInviteRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ConferenceName conference_name;
    UserID node_id;
    UserID top_node_id;
    UINT_PTR tag;
    ASN1bool_t clear_password_required;
    ASN1bool_t conference_is_locked;
    ASN1bool_t conference_is_listed;
    ASN1bool_t conference_is_conductible;
    TerminationMethod termination_method;
#   define cirq_conductor_privs_present 0x80
    PSetOfPrivileges cirq_conductor_privs;
#   define cirq_conducted_privs_present 0x40
    PSetOfPrivileges cirq_conducted_privs;
#   define cirq_non_conducted_privs_present 0x20
    PSetOfPrivileges cirq_non_conducted_privs;
#   define cirq_description_present 0x10
    TextString cirq_description;
#   define cirq_caller_id_present 0x8
    TextString cirq_caller_id;
#   define cirq_user_data_present 0x4
    PSetOfUserData cirq_user_data;
} ConferenceInviteRequest;

typedef enum ConferenceInviteResult {
    ConferenceInviteResult_success = 0,
    ConferenceInviteResult_userRejected = 1,
} ConferenceInviteResult;
typedef struct ConferenceInviteResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ConferenceInviteResult result;
#   define cirs_user_data_present 0x80
    PSetOfUserData cirs_user_data;
} ConferenceInviteResponse;

typedef struct ConferenceAddRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PSetOfNetworkAddresses add_request_net_address;
    UserID requesting_node;
    UINT_PTR tag;
#   define adding_mcu_present 0x80
    UserID adding_mcu;
#   define carq_user_data_present 0x40
    PSetOfUserData carq_user_data;
} ConferenceAddRequest;

typedef enum ConferenceAddResult {
    ConferenceAddResult_success = 0,
    ConferenceAddResult_invalidRequester = 1,
    invalidNetworkType = 2,
    invalidNetworkAddress = 3,
    addedNodeBusy = 4,
    networkBusy = 5,
    noPortsAvailable = 6,
    connectionUnsuccessful = 7,
} ConferenceAddResult;
typedef struct ConferenceAddResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    UINT_PTR tag;
    ConferenceAddResult result;
#   define cars_user_data_present 0x80
    PSetOfUserData cars_user_data;
} ConferenceAddResponse;

typedef struct ConferenceLockRequest {
    char placeholder;
} ConferenceLockRequest;

typedef enum ConferenceLockResult {
    ConferenceLockResult_success = 0,
    ConferenceLockResult_invalidRequester = 1,
    alreadyLocked = 2,
} ConferenceLockResult;
typedef struct ConferenceLockResponse {
    ConferenceLockResult result;
} ConferenceLockResponse;

typedef struct ConferenceLockIndication {
    char placeholder;
} ConferenceLockIndication;

typedef struct ConferenceUnlockRequest {
    char placeholder;
} ConferenceUnlockRequest;

typedef enum ConferenceUnlockResult {
    ConferenceUnlockResult_success = 0,
    ConferenceUnlockResult_invalidRequester = 1,
    alreadyUnlocked = 2,
} ConferenceUnlockResult;
typedef struct ConferenceUnlockResponse {
    ConferenceUnlockResult result;
} ConferenceUnlockResponse;

typedef struct ConferenceUnlockIndication {
    char placeholder;
} ConferenceUnlockIndication;

typedef enum ConferenceTerminateRequestReason {
    ConferenceTerminateRequestReason_userInitiated = 0,
    ConferenceTerminateRequestReason_timedConferenceTermination = 1,
} ConferenceTerminateRequestReason;
typedef struct ConferenceTerminateRequest {
    ConferenceTerminateRequestReason reason;
} ConferenceTerminateRequest;

typedef enum ConferenceTerminateResult {
    ConferenceTerminateResult_success = 0,
    ConferenceTerminateResult_invalidRequester = 1,
} ConferenceTerminateResult;
typedef struct ConferenceTerminateResponse {
    ConferenceTerminateResult result;
} ConferenceTerminateResponse;

typedef enum ConferenceTerminateIndicationReason {
    ConferenceTerminateIndicationReason_userInitiated = 0,
    ConferenceTerminateIndicationReason_timedConferenceTermination = 1,
} ConferenceTerminateIndicationReason;
typedef struct ConferenceTerminateIndication {
    ConferenceTerminateIndicationReason reason;
} ConferenceTerminateIndication;

typedef enum ConferenceEjectRequestReason {
    ConferenceEjectRequestReason_userInitiated = 0,
} ConferenceEjectRequestReason;
typedef struct ConferenceEjectUserRequest {
    UserID node_to_eject;
    ConferenceEjectRequestReason reason;
} ConferenceEjectUserRequest;

typedef enum ConferenceEjectResult {
    ConferenceEjectResult_success = 0,
    ConferenceEjectResult_invalidRequester = 1,
    invalidNode = 2,
} ConferenceEjectResult;
typedef struct ConferenceEjectUserResponse {
    UserID node_to_eject;
    ConferenceEjectResult result;
} ConferenceEjectUserResponse;

typedef enum ConferenceEjectIndicationReason {
    ConferenceEjectIndicationReason_userInitiated = 0,
    higherNodeDisconnected = 1,
    higherNodeEjected = 2,
} ConferenceEjectIndicationReason;
typedef struct ConferenceEjectUserIndication {
    UserID node_to_eject;
    ConferenceEjectIndicationReason reason;
} ConferenceEjectUserIndication;

typedef struct ConferenceTransferRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ConferenceNameSelector conference_name;
#   define ctrq_conference_modifier_present 0x80
    ConferenceNameModifier ctrq_conference_modifier;
#   define ctrq_net_address_present 0x40
    PSetOfNetworkAddresses ctrq_net_address;
#   define ctrq_transferring_nodes_present 0x20
    PSetOfTransferringNodesRq ctrq_transferring_nodes;
#   define ctrq_password_present 0x10
    PasswordSelector ctrq_password;
} ConferenceTransferRequest;

typedef enum ConferenceTransferResult {
    ConferenceTransferResult_success = 0,
    ConferenceTransferResult_invalidRequester = 1,
} ConferenceTransferResult;
typedef struct ConferenceTransferResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ConferenceNameSelector conference_name;
#   define ctrs_conference_modifier_present 0x80
    ConferenceNameModifier ctrs_conference_modifier;
#   define ctrs_transferring_nodes_present 0x40
    PSetOfTransferringNodesRs ctrs_transferring_nodes;
    ConferenceTransferResult result;
} ConferenceTransferResponse;

typedef struct ConferenceTransferIndication {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ConferenceNameSelector conference_name;
#   define ctin_conference_modifier_present 0x80
    ConferenceNameModifier ctin_conference_modifier;
#   define ctin_net_address_present 0x40
    PSetOfNetworkAddresses ctin_net_address;
#   define ctin_transferring_nodes_present 0x20
    PSetOfTransferringNodesIn ctin_transferring_nodes;
#   define ctin_password_present 0x10
    PasswordSelector ctin_password;
} ConferenceTransferIndication;

typedef struct RosterUpdateIndication {
    ASN1bool_t refresh_is_full;
    NodeInformation node_information;
    PSetOfApplicationInformation application_information;
} RosterUpdateIndication;

typedef struct ApplicationInvokeIndication {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PApplicationProtocolEntityList application_protocol_entity_list;
#   define destination_nodes_present 0x80
    PSetOfDestinationNodes destination_nodes;
} ApplicationInvokeIndication;

typedef struct RegistryRegisterChannelRequest {
    EntityID entity_id;
    RegistryKey key;
    DynamicChannelID channel_id;
} RegistryRegisterChannelRequest;

typedef struct RegistryAssignTokenRequest {
    EntityID entity_id;
    RegistryKey registry_key;
} RegistryAssignTokenRequest;

typedef struct RegistrySetParameterRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EntityID entity_id;
    RegistryKey key;
    struct RegistrySetParameterRequest_registry_set_parameter_registry_set_parameter {
	ASN1uint32_t length;
	ASN1octet_t value[64];
    } registry_set_parameter;
#   define parameter_modify_rights_present 0x80
    RegistryModificationRights parameter_modify_rights;
} RegistrySetParameterRequest;

typedef struct RegistryRetrieveEntryRequest {
    EntityID entity_id;
    RegistryKey key;
} RegistryRetrieveEntryRequest;

typedef struct RegistryDeleteEntryRequest {
    EntityID entity_id;
    RegistryKey key;
} RegistryDeleteEntryRequest;

typedef struct RegistryMonitorEntryRequest {
    EntityID entity_id;
    RegistryKey key;
} RegistryMonitorEntryRequest;

typedef struct RegistryMonitorEntryIndication {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RegistryKey key;
    RegistryItem item;
    RegistryEntryOwner owner;
#   define entry_modify_rights_present 0x80
    RegistryModificationRights entry_modify_rights;
} RegistryMonitorEntryIndication;

typedef struct RegistryAllocateHandleRequest {
    EntityID entity_id;
    ASN1uint16_t number_of_handles;
} RegistryAllocateHandleRequest;

typedef enum RegistryAllocateHandleResult {
    RegistryAllocateHandleResult_successful = 0,
    noHandlesAvailable = 1,
} RegistryAllocateHandleResult;
typedef struct RegistryAllocateHandleResponse {
    EntityID entity_id;
    ASN1uint16_t number_of_handles;
    Handle first_handle;
    RegistryAllocateHandleResult result;
} RegistryAllocateHandleResponse;

typedef enum RegistryResponsePrimitiveType {
    registerChannel = 0,
    assignToken = 1,
    setParameter = 2,
    retrieveEntry = 3,
    deleteEntry = 4,
    monitorEntry = 5,
} RegistryResponsePrimitiveType;
typedef enum RegistryResponseResult {
    RegistryResponseResult_successful = 0,
    belongsToOther = 1,
    tooManyEntries = 2,
    inconsistentType = 3,
    entryNotFound = 4,
    entryAlreadyExists = 5,
    RegistryResponseResult_invalidRequester = 6,
} RegistryResponseResult;
typedef struct RegistryResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EntityID entity_id;
    RegistryResponsePrimitiveType primitive_type;
    RegistryKey key;
    RegistryItem item;
    RegistryEntryOwner owner;
#   define response_modify_rights_present 0x80
    RegistryModificationRights response_modify_rights;
    RegistryResponseResult result;
} RegistryResponse;

typedef struct ConductorAssignIndication {
    UserID user_id;
} ConductorAssignIndication;

typedef struct ConductorReleaseIndication {
    char placeholder;
} ConductorReleaseIndication;

typedef struct ConductorPermissionAskIndication {
    ASN1bool_t permission_is_granted;
} ConductorPermissionAskIndication;

typedef struct ConductorPermissionGrantIndication {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PPermissionList permission_list;
#   define waiting_list_present 0x80
    PWaitingList waiting_list;
} ConductorPermissionGrantIndication;

typedef struct ConferenceTimeRemainingIndication {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Time time_remaining;
#   define time_remaining_node_id_present 0x80
    UserID time_remaining_node_id;
} ConferenceTimeRemainingIndication;

typedef struct ConferenceTimeInquireIndication {
    ASN1bool_t time_is_node_specific;
} ConferenceTimeInquireIndication;

typedef struct ConferenceTimeExtendIndication {
    Time time_to_extend;
    ASN1bool_t time_is_node_specific;
} ConferenceTimeExtendIndication;

typedef struct ConferenceAssistanceIndication {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define cain_user_data_present 0x80
    PSetOfUserData cain_user_data;
} ConferenceAssistanceIndication;

typedef struct TextMessageIndication {
    TextString message;
} TextMessageIndication;

typedef struct NonStandardPDU {
    NonStandardParameter data;
} NonStandardPDU;

typedef struct ConnectData {
    Key t124_identifier;
    ASN1octetstring_t connect_pdu;
} ConnectData;
#define ConnectData_PDU 0
#define SIZE_GCCPDU_Module_PDU_0 sizeof(ConnectData)

typedef struct IndicationPDU {
    ASN1choice_t choice;
    union {
#	define user_id_indication_chosen 1
	UserIDIndication user_id_indication;
#	define conference_lock_indication_chosen 2
	ConferenceLockIndication conference_lock_indication;
#	define conference_unlock_indication_chosen 3
	ConferenceUnlockIndication conference_unlock_indication;
#	define conference_terminate_indication_chosen 4
	ConferenceTerminateIndication conference_terminate_indication;
#	define conference_eject_user_indication_chosen 5
	ConferenceEjectUserIndication conference_eject_user_indication;
#	define conference_transfer_indication_chosen 6
	ConferenceTransferIndication conference_transfer_indication;
#	define roster_update_indication_chosen 7
	RosterUpdateIndication roster_update_indication;
#	define application_invoke_indication_chosen 8
	ApplicationInvokeIndication application_invoke_indication;
#	define registry_monitor_entry_indication_chosen 9
	RegistryMonitorEntryIndication registry_monitor_entry_indication;
#	define conductor_assign_indication_chosen 10
	ConductorAssignIndication conductor_assign_indication;
#	define conductor_release_indication_chosen 11
	ConductorReleaseIndication conductor_release_indication;
#	define conductor_permission_ask_indication_chosen 12
	ConductorPermissionAskIndication conductor_permission_ask_indication;
#	define conductor_permission_grant_indication_chosen 13
	ConductorPermissionGrantIndication conductor_permission_grant_indication;
#	define conference_time_remaining_indication_chosen 14
	ConferenceTimeRemainingIndication conference_time_remaining_indication;
#	define conference_time_inquire_indication_chosen 15
	ConferenceTimeInquireIndication conference_time_inquire_indication;
#	define conference_time_extend_indication_chosen 16
	ConferenceTimeExtendIndication conference_time_extend_indication;
#	define conference_assistance_indication_chosen 17
	ConferenceAssistanceIndication conference_assistance_indication;
#	define text_message_indication_chosen 18
	TextMessageIndication text_message_indication;
#	define non_standard_indication_chosen 19
	NonStandardPDU non_standard_indication;
    } u;
} IndicationPDU;

typedef struct ApplicationUpdate {
    ASN1choice_t choice;
    union {
#	define application_add_record_chosen 1
	ApplicationRecord application_add_record;
#	define application_replace_record_chosen 2
	ApplicationRecord application_replace_record;
#	define application_remove_record_chosen 3
    } u;
} ApplicationUpdate;

typedef struct RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set {
    CapabilityID capability_id;
    CapabilityClass capability_class;
    ASN1uint32_t number_of_entities;
} RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set;

typedef struct RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set {
    UserID node_id;
    EntityID entity_id;
    ApplicationRecord application_record;
} RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set;

typedef struct RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set {
    UserID node_id;
    EntityID entity_id;
    ApplicationUpdate application_update;
} RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set;

typedef struct NodeUpdate {
    ASN1choice_t choice;
    union {
#	define node_add_record_chosen 1
	NodeRecord node_add_record;
#	define node_replace_record_chosen 2
	NodeRecord node_replace_record;
#	define node_remove_record_chosen 3
    } u;
} NodeUpdate;

typedef struct RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set {
    UserID node_id;
    NodeRecord node_record;
} RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set;

typedef struct RosterUpdateIndication_node_information_node_record_list_node_record_update_Set {
    UserID node_id;
    NodeUpdate node_update;
} RosterUpdateIndication_node_information_node_record_list_node_record_update_Set;

typedef struct SetOfApplicationRecordUpdates {
    PSetOfApplicationRecordUpdates next;
    RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set value;
} SetOfApplicationRecordUpdates_Element;

typedef struct SetOfApplicationRecordRefreshes {
    PSetOfApplicationRecordRefreshes next;
    RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set value;
} SetOfApplicationRecordRefreshes_Element;

typedef struct SetOfApplicationCapabilityRefreshes {
    PSetOfApplicationCapabilityRefreshes next;
    RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set value;
} SetOfApplicationCapabilityRefreshes_Element;

typedef struct SetOfNodeRecordUpdates {
    PSetOfNodeRecordUpdates next;
    RosterUpdateIndication_node_information_node_record_list_node_record_update_Set value;
} SetOfNodeRecordUpdates_Element;

typedef struct SetOfNodeRecordRefreshes {
    PSetOfNodeRecordRefreshes next;
    RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set value;
} SetOfNodeRecordRefreshes_Element;

typedef struct ApplicationRecord_non_collapsing_capabilities_Set {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CapabilityID capability_id;
#   define application_data_present 0x80
    ASN1octetstring_t application_data;
} ApplicationRecord_non_collapsing_capabilities_Set;

typedef struct ApplicationInvokeSpecifier_expected_capability_set_Set {
    CapabilityID capability_id;
    CapabilityClass capability_class;
} ApplicationInvokeSpecifier_expected_capability_set_Set;

typedef struct RosterUpdateIndication_application_information_Set {
    SessionKey session_key;
    ApplicationRecordList application_record_list;
    ApplicationCapabilitiesList application_capabilities_list;
    ASN1uint16_t roster_instance_number;
    ASN1bool_t peer_entities_are_added;
    ASN1bool_t peer_entities_are_removed;
} RosterUpdateIndication_application_information_Set;

typedef struct ApplicationProtocolEntityList {
    PApplicationProtocolEntityList next;
    ApplicationInvokeSpecifier value;
} ApplicationProtocolEntityList_Element;

typedef struct SetOfApplicationInformation {
    PSetOfApplicationInformation next;
    RosterUpdateIndication_application_information_Set value;
} SetOfApplicationInformation_Element;

typedef struct SetOfConferenceDescriptors {
    PSetOfConferenceDescriptors next;
    ConferenceDescriptor value;
} SetOfConferenceDescriptors_Element;

typedef struct SetOfExpectedCapabilities {
    PSetOfExpectedCapabilities next;
    ApplicationInvokeSpecifier_expected_capability_set_Set value;
} SetOfExpectedCapabilities_Element;

typedef struct SetOfNonCollapsingCapabilities {
    PSetOfNonCollapsingCapabilities next;
    ApplicationRecord_non_collapsing_capabilities_Set value;
} SetOfNonCollapsingCapabilities_Element;

typedef struct NetworkAddress {
    ASN1choice_t choice;
    union {
#	define aggregated_channel_chosen 1
	AggregateChannel aggregated_channel;
#	define transport_connection_chosen 2
	TransportConnectionType transport_connection;
#	define address_non_standard_chosen 3
	NonStandardParameter address_non_standard;
    } u;
} NetworkAddress;

typedef struct ChallengeRequestResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define challenge_request_present 0x80
    ChallengeRequest challenge_request;
#   define challenge_response_present 0x40
    ChallengeResponse challenge_response;
} ChallengeRequestResponse;

typedef struct SetOfChallengeItems {
    PSetOfChallengeItems next;
    ChallengeItem value;
} SetOfChallengeItems_Element;

typedef struct UserData_Set {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Key key;
#   define user_data_field_present 0x80
    ASN1octetstring_t user_data_field;
} UserData_Set;

typedef struct SetOfUserData {
    PSetOfUserData next;
    UserData_Set user_data_element;
} SetOfUserData_Element;

typedef struct PasswordChallengeRequestResponse {
    ASN1choice_t choice;
    union {
#	define challenge_clear_password_chosen 1
	PasswordSelector challenge_clear_password;
#	define challenge_request_response_chosen 2
	ChallengeRequestResponse challenge_request_response;
    } u;
} PasswordChallengeRequestResponse;

typedef struct SetOfNetworkAddresses {
    PSetOfNetworkAddresses next;
    NetworkAddress value;
} SetOfNetworkAddresses_Element;

typedef struct ConferenceJoinRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define conference_name_present 0x80
    ConferenceNameSelector conference_name;
#   define cjrq_conference_modifier_present 0x40
    ConferenceNameModifier cjrq_conference_modifier;
#   define tag_present 0x20
    UINT_PTR tag;
#   define cjrq_password_present 0x10
    PasswordChallengeRequestResponse cjrq_password;
#   define cjrq_convener_password_present 0x8
    PasswordSelector cjrq_convener_password;
#   define cjrq_caller_id_present 0x4
    TextString cjrq_caller_id;
#   define cjrq_user_data_present 0x2
    PSetOfUserData cjrq_user_data;
} ConferenceJoinRequest;

typedef enum ConferenceJoinResult {
    ConferenceJoinResult_success = 0,
    ConferenceJoinResult_userRejected = 1,
    invalidConference = 2,
    invalidPassword = 3,
    invalidConvenerPassword = 4,
    challengeResponseRequired = 5,
    invalidChallengeResponse = 6,
} ConferenceJoinResult;
typedef struct ConferenceJoinResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define cjrs_node_id_present 0x80
    UserID cjrs_node_id;
    UserID top_node_id;
    UINT_PTR tag;
#   define conference_name_alias_present 0x40
    ConferenceNameSelector conference_name_alias;
    ASN1bool_t clear_password_required;
    ASN1bool_t conference_is_locked;
    ASN1bool_t conference_is_listed;
    ASN1bool_t conference_is_conductible;
    TerminationMethod termination_method;
#   define cjrs_conductor_privs_present 0x20
    PSetOfPrivileges cjrs_conductor_privs;
#   define cjrs_conducted_privs_present 0x10
    PSetOfPrivileges cjrs_conducted_privs;
#   define cjrs_non_conducted_privs_present 0x8
    PSetOfPrivileges cjrs_non_conducted_privs;
#   define cjrs_description_present 0x4
    TextString cjrs_description;
#   define cjrs_password_present 0x2
    PasswordChallengeRequestResponse cjrs_password;
    ConferenceJoinResult result;
#   define cjrs_user_data_present 0x1
    PSetOfUserData cjrs_user_data;
} ConferenceJoinResponse;

typedef struct ConnectGCCPDU {
    ASN1choice_t choice;
    union {
#	define conference_create_request_chosen 1
	ConferenceCreateRequest conference_create_request;
#	define conference_create_response_chosen 2
	ConferenceCreateResponse conference_create_response;
#	define conference_query_request_chosen 3
	ConferenceQueryRequest conference_query_request;
#	define conference_query_response_chosen 4
	ConferenceQueryResponse conference_query_response;
#	define connect_join_request_chosen 5
	ConferenceJoinRequest connect_join_request;
#	define connect_join_response_chosen 6
	ConferenceJoinResponse connect_join_response;
#	define conference_invite_request_chosen 7
	ConferenceInviteRequest conference_invite_request;
#	define conference_invite_response_chosen 8
	ConferenceInviteResponse conference_invite_response;
    } u;
} ConnectGCCPDU;
#define ConnectGCCPDU_PDU 1
#define SIZE_GCCPDU_Module_PDU_1 sizeof(ConnectGCCPDU)

typedef struct RequestPDU {
    ASN1choice_t choice;
    union {
#	define conference_join_request_chosen 1
	ConferenceJoinRequest conference_join_request;
#	define conference_add_request_chosen 2
	ConferenceAddRequest conference_add_request;
#	define conference_lock_request_chosen 3
	ConferenceLockRequest conference_lock_request;
#	define conference_unlock_request_chosen 4
	ConferenceUnlockRequest conference_unlock_request;
#	define conference_terminate_request_chosen 5
	ConferenceTerminateRequest conference_terminate_request;
#	define conference_eject_user_request_chosen 6
	ConferenceEjectUserRequest conference_eject_user_request;
#	define conference_transfer_request_chosen 7
	ConferenceTransferRequest conference_transfer_request;
#	define registry_register_channel_request_chosen 8
	RegistryRegisterChannelRequest registry_register_channel_request;
#	define registry_assign_token_request_chosen 9
	RegistryAssignTokenRequest registry_assign_token_request;
#	define registry_set_parameter_request_chosen 10
	RegistrySetParameterRequest registry_set_parameter_request;
#	define registry_retrieve_entry_request_chosen 11
	RegistryRetrieveEntryRequest registry_retrieve_entry_request;
#	define registry_delete_entry_request_chosen 12
	RegistryDeleteEntryRequest registry_delete_entry_request;
#	define registry_monitor_entry_request_chosen 13
	RegistryMonitorEntryRequest registry_monitor_entry_request;
#	define registry_allocate_handle_request_chosen 14
	RegistryAllocateHandleRequest registry_allocate_handle_request;
#	define non_standard_request_chosen 15
	NonStandardPDU non_standard_request;
    } u;
} RequestPDU;

typedef struct FunctionNotSupportedResponse {
    RequestPDU request;
} FunctionNotSupportedResponse;

typedef struct ResponsePDU {
    ASN1choice_t choice;
    union {
#	define conference_join_response_chosen 1
	ConferenceJoinResponse conference_join_response;
#	define conference_add_response_chosen 2
	ConferenceAddResponse conference_add_response;
#	define conference_lock_response_chosen 3
	ConferenceLockResponse conference_lock_response;
#	define conference_unlock_response_chosen 4
	ConferenceUnlockResponse conference_unlock_response;
#	define conference_terminate_response_chosen 5
	ConferenceTerminateResponse conference_terminate_response;
#	define conference_eject_user_response_chosen 6
	ConferenceEjectUserResponse conference_eject_user_response;
#	define conference_transfer_response_chosen 7
	ConferenceTransferResponse conference_transfer_response;
#	define registry_response_chosen 8
	RegistryResponse registry_response;
#	define registry_allocate_handle_response_chosen 9
	RegistryAllocateHandleResponse registry_allocate_handle_response;
#	define function_not_supported_response_chosen 10
	FunctionNotSupportedResponse function_not_supported_response;
#	define non_standard_response_chosen 11
	NonStandardPDU non_standard_response;
    } u;
} ResponsePDU;

typedef struct GCCPDU {
    ASN1choice_t choice;
    union {
#	define request_chosen 1
	RequestPDU request;
#	define response_chosen 2
	ResponsePDU response;
#	define indication_chosen 3
	IndicationPDU indication;
    } u;
} GCCPDU;
#define GCCPDU_PDU 2
#define SIZE_GCCPDU_Module_PDU_2 sizeof(GCCPDU)

extern Key t124identifier;

extern ASN1char32string_t simpleTextFirstCharacter;

extern ASN1char32string_t simpleTextLastCharacter;

extern ASN1module_t GCCPDU_Module;
extern void ASN1CALL GCCPDU_Module_Startup(void);
extern void ASN1CALL GCCPDU_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */
    extern int ASN1CALL ASN1Enc_WaitingList_ElmFn(ASN1encoding_t enc, PWaitingList val);
    extern int ASN1CALL ASN1Dec_WaitingList_ElmFn(ASN1decoding_t dec, PWaitingList val);
    extern void ASN1CALL ASN1Free_WaitingList_ElmFn(PWaitingList val);
    extern int ASN1CALL ASN1Enc_PermissionList_ElmFn(ASN1encoding_t enc, PPermissionList val);
    extern int ASN1CALL ASN1Dec_PermissionList_ElmFn(ASN1decoding_t dec, PPermissionList val);
    extern void ASN1CALL ASN1Free_PermissionList_ElmFn(PPermissionList val);
    extern int ASN1CALL ASN1Enc_SetOfDestinationNodes_ElmFn(ASN1encoding_t enc, PSetOfDestinationNodes val);
    extern int ASN1CALL ASN1Dec_SetOfDestinationNodes_ElmFn(ASN1decoding_t dec, PSetOfDestinationNodes val);
    extern void ASN1CALL ASN1Free_SetOfDestinationNodes_ElmFn(PSetOfDestinationNodes val);
    extern int ASN1CALL ASN1Enc_SetOfTransferringNodesIn_ElmFn(ASN1encoding_t enc, PSetOfTransferringNodesIn val);
    extern int ASN1CALL ASN1Dec_SetOfTransferringNodesIn_ElmFn(ASN1decoding_t dec, PSetOfTransferringNodesIn val);
    extern void ASN1CALL ASN1Free_SetOfTransferringNodesIn_ElmFn(PSetOfTransferringNodesIn val);
    extern int ASN1CALL ASN1Enc_SetOfTransferringNodesRs_ElmFn(ASN1encoding_t enc, PSetOfTransferringNodesRs val);
    extern int ASN1CALL ASN1Dec_SetOfTransferringNodesRs_ElmFn(ASN1decoding_t dec, PSetOfTransferringNodesRs val);
    extern void ASN1CALL ASN1Free_SetOfTransferringNodesRs_ElmFn(PSetOfTransferringNodesRs val);
    extern int ASN1CALL ASN1Enc_SetOfTransferringNodesRq_ElmFn(ASN1encoding_t enc, PSetOfTransferringNodesRq val);
    extern int ASN1CALL ASN1Dec_SetOfTransferringNodesRq_ElmFn(ASN1decoding_t dec, PSetOfTransferringNodesRq val);
    extern void ASN1CALL ASN1Free_SetOfTransferringNodesRq_ElmFn(PSetOfTransferringNodesRq val);
    extern int ASN1CALL ASN1Enc_ParticipantsList_ElmFn(ASN1encoding_t enc, PParticipantsList val);
    extern int ASN1CALL ASN1Dec_ParticipantsList_ElmFn(ASN1decoding_t dec, PParticipantsList val);
    extern void ASN1CALL ASN1Free_ParticipantsList_ElmFn(PParticipantsList val);
    extern int ASN1CALL ASN1Enc_SetOfPrivileges_ElmFn(ASN1encoding_t enc, PSetOfPrivileges val);
    extern int ASN1CALL ASN1Dec_SetOfPrivileges_ElmFn(ASN1decoding_t dec, PSetOfPrivileges val);
    extern void ASN1CALL ASN1Free_SetOfPrivileges_ElmFn(PSetOfPrivileges val);
    extern int ASN1CALL ASN1Enc_SetOfApplicationRecordUpdates_ElmFn(ASN1encoding_t enc, PSetOfApplicationRecordUpdates val);
    extern int ASN1CALL ASN1Dec_SetOfApplicationRecordUpdates_ElmFn(ASN1decoding_t dec, PSetOfApplicationRecordUpdates val);
    extern void ASN1CALL ASN1Free_SetOfApplicationRecordUpdates_ElmFn(PSetOfApplicationRecordUpdates val);
    extern int ASN1CALL ASN1Enc_SetOfApplicationRecordRefreshes_ElmFn(ASN1encoding_t enc, PSetOfApplicationRecordRefreshes val);
    extern int ASN1CALL ASN1Dec_SetOfApplicationRecordRefreshes_ElmFn(ASN1decoding_t dec, PSetOfApplicationRecordRefreshes val);
    extern void ASN1CALL ASN1Free_SetOfApplicationRecordRefreshes_ElmFn(PSetOfApplicationRecordRefreshes val);
    extern int ASN1CALL ASN1Enc_SetOfApplicationCapabilityRefreshes_ElmFn(ASN1encoding_t enc, PSetOfApplicationCapabilityRefreshes val);
    extern int ASN1CALL ASN1Dec_SetOfApplicationCapabilityRefreshes_ElmFn(ASN1decoding_t dec, PSetOfApplicationCapabilityRefreshes val);
    extern void ASN1CALL ASN1Free_SetOfApplicationCapabilityRefreshes_ElmFn(PSetOfApplicationCapabilityRefreshes val);
    extern int ASN1CALL ASN1Enc_SetOfNodeRecordUpdates_ElmFn(ASN1encoding_t enc, PSetOfNodeRecordUpdates val);
    extern int ASN1CALL ASN1Dec_SetOfNodeRecordUpdates_ElmFn(ASN1decoding_t dec, PSetOfNodeRecordUpdates val);
    extern void ASN1CALL ASN1Free_SetOfNodeRecordUpdates_ElmFn(PSetOfNodeRecordUpdates val);
    extern int ASN1CALL ASN1Enc_SetOfNodeRecordRefreshes_ElmFn(ASN1encoding_t enc, PSetOfNodeRecordRefreshes val);
    extern int ASN1CALL ASN1Dec_SetOfNodeRecordRefreshes_ElmFn(ASN1decoding_t dec, PSetOfNodeRecordRefreshes val);
    extern void ASN1CALL ASN1Free_SetOfNodeRecordRefreshes_ElmFn(PSetOfNodeRecordRefreshes val);
    extern int ASN1CALL ASN1Enc_ApplicationProtocolEntityList_ElmFn(ASN1encoding_t enc, PApplicationProtocolEntityList val);
    extern int ASN1CALL ASN1Dec_ApplicationProtocolEntityList_ElmFn(ASN1decoding_t dec, PApplicationProtocolEntityList val);
    extern void ASN1CALL ASN1Free_ApplicationProtocolEntityList_ElmFn(PApplicationProtocolEntityList val);
    extern int ASN1CALL ASN1Enc_SetOfApplicationInformation_ElmFn(ASN1encoding_t enc, PSetOfApplicationInformation val);
    extern int ASN1CALL ASN1Dec_SetOfApplicationInformation_ElmFn(ASN1decoding_t dec, PSetOfApplicationInformation val);
    extern void ASN1CALL ASN1Free_SetOfApplicationInformation_ElmFn(PSetOfApplicationInformation val);
    extern int ASN1CALL ASN1Enc_SetOfConferenceDescriptors_ElmFn(ASN1encoding_t enc, PSetOfConferenceDescriptors val);
    extern int ASN1CALL ASN1Dec_SetOfConferenceDescriptors_ElmFn(ASN1decoding_t dec, PSetOfConferenceDescriptors val);
    extern void ASN1CALL ASN1Free_SetOfConferenceDescriptors_ElmFn(PSetOfConferenceDescriptors val);
    extern int ASN1CALL ASN1Enc_SetOfExpectedCapabilities_ElmFn(ASN1encoding_t enc, PSetOfExpectedCapabilities val);
    extern int ASN1CALL ASN1Dec_SetOfExpectedCapabilities_ElmFn(ASN1decoding_t dec, PSetOfExpectedCapabilities val);
    extern void ASN1CALL ASN1Free_SetOfExpectedCapabilities_ElmFn(PSetOfExpectedCapabilities val);
    extern int ASN1CALL ASN1Enc_SetOfNonCollapsingCapabilities_ElmFn(ASN1encoding_t enc, PSetOfNonCollapsingCapabilities val);
    extern int ASN1CALL ASN1Dec_SetOfNonCollapsingCapabilities_ElmFn(ASN1decoding_t dec, PSetOfNonCollapsingCapabilities val);
    extern void ASN1CALL ASN1Free_SetOfNonCollapsingCapabilities_ElmFn(PSetOfNonCollapsingCapabilities val);
    extern int ASN1CALL ASN1Enc_SetOfChallengeItems_ElmFn(ASN1encoding_t enc, PSetOfChallengeItems val);
    extern int ASN1CALL ASN1Dec_SetOfChallengeItems_ElmFn(ASN1decoding_t dec, PSetOfChallengeItems val);
    extern void ASN1CALL ASN1Free_SetOfChallengeItems_ElmFn(PSetOfChallengeItems val);
    extern int ASN1CALL ASN1Enc_SetOfUserData_ElmFn(ASN1encoding_t enc, PSetOfUserData val);
    extern int ASN1CALL ASN1Dec_SetOfUserData_ElmFn(ASN1decoding_t dec, PSetOfUserData val);
    extern void ASN1CALL ASN1Free_SetOfUserData_ElmFn(PSetOfUserData val);
    extern int ASN1CALL ASN1Enc_SetOfNetworkAddresses_ElmFn(ASN1encoding_t enc, PSetOfNetworkAddresses val);
    extern int ASN1CALL ASN1Dec_SetOfNetworkAddresses_ElmFn(ASN1decoding_t dec, PSetOfNetworkAddresses val);
    extern void ASN1CALL ASN1Free_SetOfNetworkAddresses_ElmFn(PSetOfNetworkAddresses val);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _GCCPDU_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\hash.h ===
/*	hash.h
 *
 *	Copyright (c) 1996 by Microsoft Corporation
 *
 *  Written by:	 Christos Tsollis
 *
 *  Revisions:
 *		
 *	Abstract:
 *
 *	This is the interface to a dictionary data structure.  
 *	Both the key and the value in a dictionary entry are DWORD values.  So, for example, if the 
 *  value is really a pointer it has to be converted into a DWORD before being passed into a 
 *  member dictionary function.
 *
 */


#ifndef _HASH_
#define _HASH_

#include <windows.h>

#define DEFAULT_NUMBER_OF_BUCKETS	3


typedef enum {
	DWORD_DICTIONARY,			/* The key is a 32-bit unsigned value */
	STRING_DICTIONARY,			/* The key is a NULL-terminated string that is being pointed by 
								 * the "key" field in the structure below */
	LENGTH_STRING_DICTIONARY	/* The key is a string with a specific length.  The "key" field
								 * in the structure below, points to memory space containing 
								 * the length and a string of that length. */
} DictionaryType;


typedef struct _dictionary_item {
	DWORD						key;	// The key value, or a pointer to a string (depending on the dictionary type)
	DWORD						value;	// This is always a 32-bit unsigned value
	struct _dictionary_item		*next;	// Pointer to the next structure in the dictionary bucket
} DICTIONARY_ITEM, *PDICTIONARY_ITEM;


class DictionaryClass
{
public:

	DictionaryClass (ULong num_of_buckets = DEFAULT_NUMBER_OF_BUCKETS, DictionaryType dtype = DWORD_DICTIONARY);
	DictionaryClass (const DictionaryClass& original);
	~DictionaryClass ();

	BOOL insert (DWORD new_key, DWORD new_value, ULong length = 0);
	BOOL remove (DWORD Key, ULong length = 0);
	BOOL find (DWORD Key, LPDWORD pValue = NULL, ULong length = 0);
	BOOL isEmpty ();
	void clear ();
	ULong entries () {
		return (3 * NumOfBuckets - ItemCount + NumOfExternItems);
	};
	BOOL iterate (LPDWORD pValue = NULL, LPDWORD pKey = NULL);
	void reset () { pCurrent = NULL; };		// Resets the dictionary iterator

	BOOL Insert(DWORD new_key, LPVOID new_value, UINT length = 0) { ASSERT(new_value != NULL); return insert(new_key, (DWORD) new_value, (ULONG) length); }
	BOOL Remove(DWORD Key, UINT length = 0) { return remove(Key, (ULONG) length); }
	LPVOID Find(DWORD Key, UINT length = 0);
	LPVOID Iterate(LPDWORD pKey = NULL);
	BOOL IsEmpty(void) { return isEmpty(); }
	void Clear(void) { clear(); }
	UINT GetCount(void) { return (UINT) entries(); }
	void Reset(void) { reset(); }


private:

	DWORD hashFunction (DWORD key);
	int LengthStrcmp (DWORD DictionaryKey, DWORD ChallengeKey, ULong length);

	ULong				 NumOfBuckets;		// Number of dictionary buckets.  Specified during object construction.
	DWORD				 dwNormalSize;		// Initial space allocated for the dictionary
	PDICTIONARY_ITEM	*Buckets;			// Address of the Buckets array
	PDICTIONARY_ITEM	*ItemArray;			// Pointer to the array of initially allocated dictionary items
	ULong		 		 ItemCount;			// Number of dictionary items left in the ItemArray
	PDICTIONARY_ITEM	 pCurrent;			// Points to the current dictionary item while we iterate through the dictionary
	ULong				 ulCurrentBucket;	// Id of the current bucket while we iterate
	DictionaryType		 Type;				// Dictionary type
	ULong				 NumOfExternItems;	// Number of external dictionary items

};

typedef DictionaryClass * PDictionaryClass;

#define DEFINE_DICTIONARY_FRIENDLY_METHODS(_ClassName_)			\
	BOOL Insert(DWORD new_key, _ClassName_ *new_value, UINT length = 0) { return DictionaryClass::Insert(new_key, (LPVOID) new_value, length); }	\
	BOOL Remove(DWORD Key, UINT length = 0) { return DictionaryClass::Remove(Key, length); }	\
	_ClassName_ *Find(DWORD Key, UINT length = 0) { return (_ClassName_ *) DictionaryClass::Find(Key, length); }	\
	_ClassName_ *Iterate(LPDWORD pKey = NULL) { return (_ClassName_ *) DictionaryClass::Iterate(pKey); }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\gcontrol.h ===
#ifndef _GCC_CONTROLLER_
#define _GCC_CONTROLLER_

/*
 *	gcontrol.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		It is the responsibility of the controller to create and destroy many 
 *		of the other objects in the system at run-time.  There is should only 
 *		be one controller in existence at a time per GCC provider.  The 
 *		controller is constructed during system initialization, and not 
 *		destroyed until the provider is shut down.  The controller's primary 
 *		responsibility is to maintain five "layers" of objects in the system at 
 *		run-time.  These include the Application Interface, the SAPs (the
 *		Control SAP as well as the Application SAPs), the Conference objects, 
 *		the MCSUser object (which is actualy created by the conference object),
 *		and the MCS Interface.  It also "plugs" together objects in adjacent 
 *		layers by informing a newly created object of the identity of those 
 *		objects with which it must communicate.  The newly created object can 
 *		then register itself with the appropriate objects in the layers above 
 *		and below.  The controller plays a small role in the passing of 
 *		information during a conference (this is handled by the objects it 
 *		creates).
 *
 *		It is worth noting that the controller is the primary recipient of 
 *		owner callbacks in the GCC system.  Most of the objects in its "object 
 *		stack" are capable of issuing owner callbacks to the controller for 
 *		various events and requests.
 *
 *		The controller is not completely portable.  Since the nature of 
 *		application and MCS interfaces will vary from platform to platform, the 
 *		interface objects that must be created will also vary.  It is necessary 
 *		for the controller to know which objects to create and destroy during 
 *		initialization and cleanup.  Other than this, however, the rest of the 
 *		code in the controller class should port cleanly.
 *
 *		The constructor performs all activity required to prepare GCC for use.  
 *		It creates an instance of the Memory Manager class (and possibly a 
 *		Message Memory Manager class in certain environments), which will be 
 *		used for memory handling by other objects in the system.  It creates the 
 *		GccAppInterface objects that will be used to communicate with all user 
 *		applications (including the node controller).  It creates the MCS 
 *		Interface object that will be used to communicate with MCS.  GCC relies 
 *		on an owner callback from a GccAppInterface object to give it a 
 *		heartbeat.  It is during this heartbeat that the controller does all of 
 *		its work at run-time.
 *
 *		The destructor essentially does the opposite of what the constructor 
 *		does (as you might expect).  It destroys all objects that are "owned" 
 *		by the controller, cleanly shutting everything down.
 *
 *		As mentioned above, the controller is the primary recipient of owner 
 *		callbacks in the GCC system.  To accomplish this it overrides the 
 *		Owner-Callback member function.  It can then pass its "this" pointer to 
 *		objects that it creates, allowing them to issue owner callbacks when 
 *		necessary.  Everything the controller does at run-time is in response 
 *		to these owner callbacks.
 *
 *		The controller is the prime recipient of connect provider indications 
 *		from MCS.  Many of the messages that are passed between GCC and the 
 *		GccAppInterface before a conference is established involve the 
 *		controller.  These include ConferenceCreateIndication,  
 *		ConferenceInviteIndication,  etc.  Also, the controller object is 
 *		exclusively responsible for handling conference queries since it 
 *		maintains a complete list of all the conferences that exist in the 
 *		system.
 *
 *	Portable:
 *		Not Completely (80 % portable)
 *		Member functions which aren't portable:
 *			-	GCCControl()
 *			-	~GCCControl()
 *			-	EventLoop()
 *			-	PollCommDevices()
 *			-	CreateApplicationSap()
 *
 *	Protected Instance Variables:
 *		None.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */

#include "sap.h"
#include "csap.h"
#include "appsap.h"
#include "conf.h"
#include "pktcoder.h"
#include "privlist.h"
#include "mcsdllif.h"
#include "t120app.h"

// #include "gccncif.h"

extern CRITICAL_SECTION     g_csGCCProvider;


/*
**	These are the message bases used by the controller object.  Any
**	owner callback message received from an object that the controller
**	created must have a message base added to it before it is received
**	at the controller.
*/
#define MCS_INTERFACE_MESSAGE_BASE		300   //	Leave room for status

enum
{
    GCTRL_REBUILD_CONF_POLL_LIST    = GCTRLMSG_BASE + 1,
};


// permit to enroll callback list
class CApplet;
class CAppletList : public CList
{
    DEFINE_CLIST(CAppletList, CApplet*)
};

/*
**	The conference information structure is used to temporarily store
**	information needed to create a conference while waiting for a
**	conference create response.
*/
typedef struct PENDING_CREATE_CONF
{
	// a destructor to this data structure
	PENDING_CREATE_CONF(void);
	~PENDING_CREATE_CONF(void);

	LPSTR							pszConfNumericName;
	LPWSTR							pwszConfTextName;
	BOOL							password_in_the_clear;
	BOOL							conference_is_locked;
	BOOL							conference_is_listed;
	BOOL							conference_is_conductible;
	GCCTerminationMethod			termination_method;
	PPrivilegeListData				conduct_privilege_list;
	PPrivilegeListData				conduct_mode_privilege_list;
	PPrivilegeListData				non_conduct_privilege_list;
	LPWSTR							pwszConfDescription;
    ConnectionHandle				connection_handle;
	UserID							parent_node_id;
	UserID							top_node_id;
	TagNumber						tag_number;
}
	PENDING_CREATE_CONF;

/*
**	This defines the template for the list that keeps track of information
**	associated with a conference that is waiting for a response on a 
**	create conference indication.
*/
class CPendingCreateConfList2 : public CList2
{
    DEFINE_CLIST2(CPendingCreateConfList2, PENDING_CREATE_CONF*, GCCConfID)
};


/*
**	The join information structure is used to temporarily store
**	information needed to join a conference after the join response is
**	issued.
*/
typedef struct PENDING_JOIN_CONF
{
	PENDING_JOIN_CONF(void);
	~PENDING_JOIN_CONF(void);

	CPassword               *convener_password;
	CPassword               *password_challenge;
	LPWSTR					pwszCallerID;
	BOOL					numeric_name_present;
	GCCConfID               nConfID;
}
	PENDING_JOIN_CONF;

/*
**	This defines the template for the list that keeps track of information
**	associated with an outstanding join request.
*/
class CPendingJoinConfList2 : public CList2
{
    DEFINE_CLIST2_(CPendingJoinConfList2, PENDING_JOIN_CONF*, ConnectionHandle)
};


//	Holds the list of outstanding query request
class CPendingQueryConfList2 : public CList2
{
    DEFINE_CLIST2_(CPendingQueryConfList2, GCCConfID, ConnectionHandle)
};


extern HANDLE g_hevGCCOutgoingPDU;


class GCCController : public CRefCount
{
public:

	GCCController(PGCCError);
	~GCCController(void);

    void RegisterAppSap(CAppSap *);
    void UnRegisterAppSap(CAppSap *);

    void RegisterApplet(CApplet *);
    void UnregisterApplet(CApplet *);

    CConf *GetConfObject(GCCConfID nConfID) { return m_ConfList2.Find(nConfID); }

	//	Functions initiated from the node controller 
	GCCError ConfCreateRequest(CONF_CREATE_REQUEST *, GCCConfID *);

    void WndMsgHandler ( UINT uMsg );
    BOOL FlushOutgoingPDU ( void );
    void SetEventToFlushOutgoingPDU ( void ) { ::SetEvent(g_hevGCCOutgoingPDU); }

	//	Functions initiated from Control SAP
	GCCError    ConfCreateResponse(PConfCreateResponseInfo);
	GCCError    ConfQueryRequest(PConfQueryRequestInfo);
	GCCError    ConfQueryResponse(PConfQueryResponseInfo);
	GCCError    ConfJoinRequest(PConfJoinRequestInfo, GCCConfID *);
	GCCError    ConfJoinIndResponse(PConfJoinResponseInfo);
	GCCError    ConfInviteResponse(PConfInviteResponseInfo);
    GCCError    FailConfJoinIndResponse(GCCConfID, ConnectionHandle);
    GCCError    FailConfJoinIndResponse(PConfJoinResponseInfo);
    void        RemoveConfJoinInfo(ConnectionHandle hConn);

	//	Functions initiated from Conference object
	GCCError    ProcessConfEstablished(GCCConfID);
	GCCError    ProcessConfTerminated(GCCConfID, GCCReason);

	//	Functions initiated from the MCS Interface
	GCCError	ProcessConnectProviderIndication(PConnectProviderIndication);
	GCCError	ProcessConferenceCreateRequest(PConferenceCreateRequest, PConnectProviderIndication);
	GCCError	ProcessConferenceQueryRequest(PConferenceQueryRequest, PConnectProviderIndication);
	GCCError	ProcessConferenceJoinRequest(PConferenceJoinRequest, PConnectProviderIndication);
	GCCError	ProcessConferenceInviteRequest(PConferenceInviteRequest, PConnectProviderIndication);
	GCCError	ProcessConnectProviderConfirm(PConnectProviderConfirm);
	GCCError	ProcessConferenceQueryResponse(PConferenceQueryResponse, PConnectProviderConfirm);
	GCCError	ProcessDisconnectProviderIndication(ConnectionHandle);
    void        CancelConfQueryRequest(ConnectionHandle);

private:

	/*
	**	Routines called from the Owner-Callback function
	*/

    //	Miscelaneous support functions
	GCCConfID	AllocateConferenceID();
	GCCConfID	AllocateQueryID();

	GCCConfID	GetConferenceIDFromName(
							PGCCConferenceName		conference_name,
							GCCNumericString		conference_modifier);

    void RebuildConfPollList ( void );
    void PostMsgToRebuildConfPollList ( void );

private:

	CPendingCreateConfList2			m_PendingCreateConfList2;
	CPendingJoinConfList2			m_PendingJoinConfList2;
	CPendingQueryConfList2			m_PendingQueryConfList2;

	CConfList           			m_ConfDeleteList;
	CConfList2  					m_ConfList2;

	CAppSapList 				    m_AppSapList;

    BOOL							m_fConfListChangePending;

	GCCConfID   					m_ConfIDCounter;
	GCCConfID   					m_QueryIDCounter;

    BOOL							m_fControllerIsExiting;

	DWORD							m_dwControllerWaitTimeout;
	DWORD							m_dwControllerEventMask;
	
    //	These list are used only for iterating.  Whenever a conference or 
    //	application SAP object is deleted (or created in the case of an
    //	application SAP) it is added to the dictionary list first and
    //	a flag is set which forces the Polled list to get recreated at the
    //	top of the next heartbeat.
	CConfList                       m_ConfPollList;

    // T120 Applet list
    CAppletList                     m_AppletList;

};

extern GCCController *g_pGCCController;

/*
 *	GCCController (PGCCError	gcc_error)
 *
 *	Public member function of Conference
 *
 *	Function Description
 *		This is the Windows 32 Bit version of the GCC controller constructor. It 
 *		is responsible for initializing all the instance variables used by this 
 *		class.  It is also responsible for creating the memory manager, the
 *		packet coder, the Node Controller application interface, the Shared 
 *		memory interface used to communicate with enrolled applications, the
 *		Node Controller SAP and the MCS Interface.  It also sets up the 
 *		g_csGCCProvider that protects the core of GCC in the multi-threaded 
 *		Win32 environment.  It also sets up a number of Windows Event objects
 *		used to signal the GCC thread when various events happen at the
 *		interfaces. The last thing it does before returning if no errors have
 *		occured is launch the GCC thread. Fatal errors are returned from this 
 *		constructor in the return value. 
 *
 *	Formal Parameters:
 *		gcc_error	-	(o)	Errors that occur are returned here.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		This constructor launches the GCC thread if no errors occur.
 *
 *	Caveats
 *		This constructor is very specific to the Win32 environment.  When
 *		porting GCC to other platforms, this constructor will have to be
 *		rewritten for the proper platform.
 */

/*
 *	GCCController(	USHORT		timer_duration,
 *					PGCCError	gcc_error)
 *
 *	Public member function of Conference
 *
 *	Function Description
 *		This is the Windows 16 Bit version of the GCC controller constructor. It 
 *		is responsible for initializing all the instance variables used by this 
 *		class.  It is also responsible for creating the memory manager, the
 *		packet coder, the Node Controller application interface, the Shared 
 *		memory interface used to communicate with enrolled applications, the
 *		Node Controller SAP and the MCS Interface.  It also sets up the 
 *		internal Windows timer if a timer_interval other than zero is specified.
 *		Fatal errors are returned from this constructor in the return value. 
 *
 *	Formal Parameters:
 *		timer_duration	-	(i)	Timer interval in miliseconds that the
 *								heartbeat will trigger at.
 *		instance_handle	-	(i)	This is the windows instance handle used to
 *								set up the Windows timer.
 *		gcc_error		-	(o)	Errors that occur are returned here.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		This constructor is very specific to the Win16 environment.  When
 *		porting GCC to other platforms, this constructor will have to be
 *		rewritten for the proper platform.
 */

/*
 *	~GCCController();
 *
 *	Public member function of Conference
 *
 *	Function Description
 *		This is the Controller destructor.  All platform specific cleanup that
 *		occurs is included in this destructor but is "macro'd" out in 
 *		environments where the cleanup is not necessary (things like
 *		critical sections, and Windows timers).  Deleting the controller
 *		essentially shuts down GCC.  Deleting all the active conferences, SAPs,
 *		and interfaces along with all the GCC support modules (memory manager,
 *		packet coder, etc.).
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		This destructor includes platform specific code.  It may be necessary
 *		to include some platform specific code here when porting GCC to 
 *		other platforms.  Macros should be used to isolate this code
 *		where ever possible.
 */

/*
 *	ULONG		Owner-Callback (		UINT        		message,
 *									LPVOID				parameter1,
 *									ULONG				parameter2);
 *
 *	Public member function of Conference
 *
 *	Function Description
 *		This function overides the base class function and is used to
 *		receive all owner callback information from the objects the
 *		the controller creates.
 *
 *	Formal Parameters:
 *		message		-		(i)	Message number including base offset.
 *		parameter1	-		(i)	void pointer of message data.
 *		parameter2	-		(i)	Long holding message data.		
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	Resource error occured.
 *		GCC_INVALID_CONFERENCE_NAME		-	Invalid conference name passed in.
 *		GCC_FAILURE_CREATING_DOMAIN		-	Failure creating domain.
 *		GCC_BAD_NETWORK_ADDRESS			-	Bad network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	-	Bad network address type passed in.
 *		GCC_CONFERENCE_ALREADY_EXISTS	-	Conference specified already exists.
 *		GCC_INVALID_TRANSPORT			-	Cannot find specified transport.
 *		GCC_INVALID_ADDRESS_PREFIX		-	Bad transport address passed in.
 *		GCC_INVALID_TRANSPORT_ADDRESS	- 	Bad transport address
 *		GCC_BAD_SESSION_KEY				-	Enrolling with invalid session key.
 *		GCC_INVALID_PASSWORD			-	Invalid password passed in.
 *		GCC_BAD_USER_DATA				-	Invalid user data passed in.
 *		GCC_INVALID_JOIN_RESPONSE_TAG	-	No match found for join response tag
 *		GCC_NO_SUCH_APPLICATION			-	Invalid SAP handle passed in.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	-	Request failed because conference
 *											was not established.
 *		GCC_BAD_CAPABILITY_ID			-	Invalid capability ID passed in.
 *		GCC_NO_SUCH_APPLICATION			-	Bad SAP handle passed in.
 *		GCC_DOMAIN_PARAMETERS_UNACCEPTABLE	- Domain parameters were
 *											  unacceptable for this connection.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	EventLoop();
 *
 *	Public member function of Conference
 *
 *	Function Description
 *		This routine is only used for the 32 bit windows platform.  It gets
 *		called whenever an event occurs in this environment.  These include
 *		timer events as well as PDU and message events
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

#endif // _GCC_CONTROLLER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\imst123.h ===
#ifndef _T123_TRANSPORT_DRIVER_INTERFACE_H_
#define _T123_TRANSPORT_DRIVER_INTERFACE_H_

#include <basetyps.h>
#include <t120type.h>
#include "iplgxprt.h"

typedef UINT_PTR        LEGACY_HANDLE;
typedef HANDLE          PHYSICAL_HANDLE;


typedef ULONG (CALLBACK *TransportCallback) (ULONG, void *, void *);


/*
 *  This structure is passed back with the TRANSPORT_DATA_INDICATION message.
 */
typedef	struct
{
	UINT_PTR            logical_handle;
	LPBYTE              pbData;
	ULONG               cbDataSize;
}
    LegacyTransportData;


/*
 *  This structure is passed back with the TRANSPORT_CONNECT_INDICATION,
 *  TRANSPORT_CONNECT_CONFIRM, and the TRANSPORT_DISONNECT_INDICATION messages.
 *  This structure contains the transport connection identifier and
 *  physical handle.
 */
typedef struct
{
    LEGACY_HANDLE       logical_handle;
    PHYSICAL_HANDLE     hCommLink;
}
    LegacyTransportID;


#undef  INTERFACE
#define INTERFACE ILegacyTransport
DECLARE_INTERFACE(ILegacyTransport)
{
    STDMETHOD_(void, ReleaseInterface) (THIS) PURE;

    STDMETHOD_(TransportError, TInitialize) (THIS_ TransportCallback, void *user_defined) PURE;
    STDMETHOD_(TransportError, TCleanup) (THIS) PURE;
    STDMETHOD_(TransportError, TCreateTransportStack) (THIS_ BOOL fCaller, HANDLE hCommLink, HANDLE hevtClose, PLUGXPRT_PARAMETERS *pParams) PURE;
    STDMETHOD_(TransportError, TCloseTransportStack) (THIS_ HANDLE hCommLink) PURE;
    STDMETHOD_(TransportError, TConnectRequest) (THIS_ LEGACY_HANDLE *, HANDLE hCommLink) PURE;
    STDMETHOD_(TransportError, TDisconnectRequest) (THIS_ LEGACY_HANDLE, BOOL trash_packets) PURE;
    STDMETHOD_(TransportError, TDataRequest) (THIS_ LEGACY_HANDLE, LPBYTE pbData, ULONG cbDataSize) PURE;
    STDMETHOD_(TransportError, TReceiveBufferAvailable) (THIS) PURE;
    STDMETHOD_(TransportError, TPurgeRequest) (THIS_ LEGACY_HANDLE) PURE;
    STDMETHOD_(TransportError, TEnableReceiver) (THIS) PURE;
};


#ifdef __cplusplus
extern "C" {
#endif

TransportError WINAPI T123_CreateTransportInterface(ILegacyTransport **);
typedef TransportError (WINAPI *LPFN_T123_CreateTransportInterface) (ILegacyTransport **);
#define LPSTR_T123_CreateTransportInterface     "T123_CreateTransportInterface"

#ifdef __cplusplus
}
#endif


#endif // _PSTN_TRANSPORT_DRIVER_INTERFACE_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\lportmsg.h ===
/*
 *	lportmsg.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *
 *	Portable:
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	_LISTEN_GCC_PORTAL_MESSAGE_
#define	_LISTEN_GCC_PORTAL_MESSAGE_

#define	LISTEN_CREATE_SAP_PORTALS_REQUEST	0
#define	LISTEN_CREATE_SAP_PORTALS_CONFIRM	1

#define	LISTEN_NO_ERROR						0
#define	LISTEN_CREATE_FAILED				1

typedef struct
{
} LPCreateSapPortalsRequest;


typedef struct
{
	ULong		return_value;
	PVoid		blocking_portal_address;
	PVoid		non_blocking_portal_address;
} LPCreateSapPortalsConfirm;

typedef struct
{
} LPCloseSapPortalsRequest;

typedef	struct
{
	unsigned int		message_type;
	union
	{
		LPCreateSapPortalsRequest		create_sap_portals_request;
		LPCreateSapPortalsConfirm		create_sap_portals_confirm;
		LPCloseSapPortalsRequest		close_sap_portals_request;
	} u;
} GccListenPortalMessage;
typedef	GccListenPortalMessage *		PGccListenPortalMessage;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\invoklst.h ===
/*
 *	invoklst.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class CInvokeSpecifierListContainer.
 *		This class manages the data associated with an Application Invoke 
 *		Request or Indication.  This includes a list of applications to be 
 *		invoked.  The CInvokeSpecifierListContainer data container utilizes a 
 *		CSessKeyContainer container to buffer part of the data associated with each
 *		application invoke specifier.  Each application invoke specifier also 
 *		includes a capability ID whose data is buffered internally by the 
 *		using a CCapIDContainer container.  The list of application 
 *		invoke specifiers is maintained internally by the class through the use
 *		of a Rogue Wave list container.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */
#ifndef	_APPLICATION_INVOKE_SPECIFIER_LIST_
#define	_APPLICATION_INVOKE_SPECIFIER_LIST_

#include "capid.h"
#include "sesskey.h"
#include "arost.h"

/*
 * This is the internal structure used to hold the data associated with each
 * invoke specifier.
 */
typedef struct
{
	CSessKeyContainer			    *session_key;
	CAppCapItemList             	ExpectedCapItemList;
	MCSChannelType					startup_channel_type;
	BOOL    						must_be_invoked;
}
    INVOKE_SPECIFIER;

/*
 * These are the typedefs for the Rogue Wave list which is used to hold the
 * invoke specifier info structures.
 */
class CInvokeSpecifierList : public CList
{
    DEFINE_CLIST(CInvokeSpecifierList, INVOKE_SPECIFIER*)
};

/*
 * Class definition:
 */
class CInvokeSpecifierListContainer : public CRefCount
{
public:

	CInvokeSpecifierListContainer(UINT cProtEntities, PGCCAppProtocolEntity *, PGCCError);
	CInvokeSpecifierListContainer(PApplicationProtocolEntityList, PGCCError);

	~CInvokeSpecifierListContainer(void);

	UINT		LockApplicationInvokeSpecifierList(void);
	void		UnLockApplicationInvokeSpecifierList(void);

    UINT		GetApplicationInvokeSpecifierList(USHORT *pcProtEntities, LPBYTE memory);
    UINT		GetApplicationInvokeSpecifierList(ULONG *pcProtEntities, LPBYTE pMemory)
    {
        USHORT c;
        UINT nRet = GetApplicationInvokeSpecifierList(&c, pMemory);
        *pcProtEntities = c;
        return nRet;
    }

    GCCError	GetApplicationInvokeSpecifierListPDU(PApplicationProtocolEntityList *);
	void		FreeApplicationInvokeSpecifierListPDU(void);

protected:

	CInvokeSpecifierList			m_InvokeSpecifierList;
	UINT							m_cbDataSize;

	PApplicationProtocolEntityList	m_pAPEListPDU;
	BOOL    						m_fValidAPEListPDU;

private:

	GCCError	SaveAPICapabilities(INVOKE_SPECIFIER *, UINT cCaps, PGCCApplicationCapability *);
	GCCError	SavePDUCapabilities(INVOKE_SPECIFIER *, PSetOfExpectedCapabilities);
	UINT		GetApplicationCapability(APP_CAP_ITEM *, PGCCApplicationCapability, LPBYTE memory);
	GCCError	ConvertInvokeSpecifierInfoToPDU(INVOKE_SPECIFIER *, PApplicationProtocolEntityList);
	GCCError	ConvertExpectedCapabilityDataToPDU(APP_CAP_ITEM *, PSetOfExpectedCapabilities);
};


/*
 *	Comments explaining the public and private class member functions
 */

/*
 *	CInvokeSpecifierListContainer (
 *					USHORT						number_of_protocol_entities,
 *					PGCCAppProtocolEntity *		app_protocol_entity_list,
 *					PGCCError					return_value);
 *
 *	Public member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 *		This is a constructor for the CInvokeSpecifierListContainer class.
 *		This constructor is used to create an CInvokeSpecifierListContainer
 * 		object from a list of "API" application protocol entities.
 *
 *	Formal Parameters:
 *		number_of_protocol_entities		(i) The number of "APE"s in the list.
 *		app_protocol_entity_list		(i) The list of API "APE"s.
 *		return_value					(o) Error return value.
 *
 *	Return Value:
 *		GCC_NO_ERROR			- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE	- A resource allocation error occurred.
 *		GCC_BAD_SESSION_KEY		- An APE contained an invalid session key.
 *		GCC_BAD_CAPABILITY_ID	- An API contained an invalid capability ID.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	CInvokeSpecifierListContainer (
 *				PApplicationProtocolEntityList		app_protocol_entity_list,
 *				PGCCError							return_value);
 *
 *	Public member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 *		This is a constructor for the CInvokeSpecifierListContainer class.
 *		This constructor is used to create an CInvokeSpecifierListContainer 
 *		object from	a "PDU" ApplicationProtocolEntityList.
 *
 *	Formal Parameters:
 *		app_protocol_entity_list		(i) The list of PDU "APE"s.
 *		return_value					(o) Error return value.
 *
 *	Return Value:
 *		GCC_NO_ERROR			- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE	- A resource allocation error occurred.
 *		GCC_BAD_SESSION_KEY		- An APE contained an invalid session key.
 *		GCC_BAD_CAPABILITY_ID	- An API contained an invalid capability ID.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	~CInvokeSpecifierListContainer ();
 *
 *	Public member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 *		This is the destructor for the CInvokeSpecifierListContainer class.
 *		It is responsible for freeing any memory allocated to hold the 
 *		invoke data.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	UINT	LockApplicationInvokeSpecifierList ();
 *
 *	Public member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 *		This routine is used to "lock" the "API" data for this object.  This
 *		results in the lock count for this object being incremented.  When the
 *		lock count transitions from 0 to 1, a calculation is made to determine
 *		how much memory will be needed to hold any "API" data which will
 *		be referenced by, but not held in, the list of GCCAppProtocolEntity 
 *		structures which is filled in on a call to GetApplicationInvoke-
 *		SpecifierList.  This is the	value returned by this routine in order to 
 *		allow the calling object to	allocate that amount of memory in 
 *		preparation for the call to GetApplicationInvokeSpecifierList.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The amount of memory which will be needed to hold "API" data
 *		which is a list of GCCAppProtocolEntity structures.
 *
 *  Side Effects:
 *		The internal lock count is incremented.
 *
 *	Caveats:
 *		The internal lock count is used in conjuction with an internal "free" 
 *		flag as a mechanism for ensuring that this object remains in existance 
 *		until all interested parties are through with it.  The object remains 
 *		valid (unless explicity deleted) until the lock count is zero and the 
 *		"free" flag is set through a call to FreeApplicationInvokeSpecifierList.
 *		This allows	other objects to lock this object and be sure that it 
 *		remains valid until they call UnLock which will decrement the internal 
 *		lock count.  A typical usage scenerio for this object would be:  An 
 *		CInvokeSpecifierListContainer object is constructed and then passed off
 *		to any interested parties through a function call.  On return from the 
 *		function call, the FreeApplicationInvokeSpecifierList call is made which
 *		will set the internal "free" flag.  If no other parties have locked the 
 *		object with a Lock call, then the CInvokeSpecifierListContainer object
 *		will automatically delete itself when the FreeApplicationInvoke-
 *		SpecifierList call is made.  If, however, any number of other parties 
 *		has locked the object, it will remain in existence until each of them 
 *		has unlocked the object through a call to UnLock.
 */


/*
 *	UINT	GetApplicationInvokeSpecifierList (
 *								PUShort			number_of_protocol_entities,
 *								LPSTR			memory);
 *
 *	Public member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the application invoke specifier list
 *		from the CInvokeSpecifierListContainer object in the "API" form of a 
 *		list of PGCCAppProtocolEntity structures.
 *
 *	Formal Parameters:
 *		number_of_protocol_entities		(o) The number of APEs in the list.
 *		memory							(o)	The memory used to hold the 
 *												APE data.
 *
 *	Return Value:
 *		The amount of memory which will be needed to hold "API" data
 *		which is a list of GCCAppProtocolEntity structures.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void	UnLockApplicationInvokeSpecifierList ();
 *
 *	Public member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine 
 *		whether the object has been freed through a call to 
 *		FreeApplicationInvokeSpecifierList.  If so, the object will 
 *		automatically delete itself.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal lock count is decremented.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	GetApplicationInvokeSpecifierListPDU (
 *					PApplicationProtocolEntityList	*  protocol_entity_list);
 *
 *	Public member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the object key data from the
 *		CInvokeSpecifierListContainer object in the "PDU" form of a list of
 *		PApplicationProtocolEntityList structures.
 *
 *	Formal Parameters:
 *		protocol_entity_list		(o)	The list of structures to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR				-	No error.
 *		GCC_ALLOCATION_FAILURE		- 	A resource allocation error occurred.
 *
 *  Side Effects:
 *		The first time this routine is called, data is allocated internally to
 *		hold the PDU form.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void	FreeApplicationInvokeSpecifierListPDU ();
 *
 *	Public member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 *		This routine is used to "free" the "PDU" data allocated for this object
 *		which is held internally.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal flag is set to indicate that the PDU form of data no
 *		longer is valid for this object.
 *
 *	Caveats:
 *		None.
 */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\mcsdllif.h ===
/*
 *	mcsdllif.h
 *
 *	Copyright (c) 1993 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the MCAT MCS DLL Interface class.
 *
 *		When this class is first instantiated, it initializes MCS.  After
 *		that, the application using this object requests MCS services through
 *		this object. This object is also responsible for receiving and
 *		forwarding cllback messages.  When this object is deleted it calls
 *		MCSCleanupAPI to shut down the MCATMCS DLL.
 *
 *		MCS interface objects represent the Service Access Point (SAP)
 *		between GCC and MCS.  Exactly how the interface works is an
 *		implementation matter for those classes that inherit from this one.
 *		This class defines the public member functions that GCC expects to be
 *		able to call upon to utilize MCS.
 *
 *		The public member functions defined here can be broken into two
 *		categories: those that are part of T.122; and those that are not.
 *		The T.122 functions include connect provider request, connect
 *		provider response, disconnect provider request, create domain, delete
 *		domain, send data request, etc.  All other member functions are
 *		considered a local matter from a standards point-of-view.  These
 *		functions include support for initialization and setup, as well as
 *		functions allowing GCC to poll MCS for activity.
 *
 *		Note that this class also handles the connect provider confirms by
 *		keeping a list of all the objects with outstanding connect provider
 *		request.  These are held in the ConfirmObjectList.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		Christos Tsollis
 *
 */
#ifndef	_MCS_DLL_INTERFACE_
#define	_MCS_DLL_INTERFACE_

#include "mcsuser.h"

/*
**	This dictionary keeps up with all the outstanding connect provider
**	request.  When a response is received, this interface class will obtain
**	a pointer to the correct object from this list and will then pass on the
**	response.
*/
class CConnHdlConfList2 : public CList2
{
    DEFINE_CLIST2_(CConnHdlConfList2, CConf*, ConnectionHandle)
};

extern  PController					g_pMCSController;

/*
 *	CONNECT_PROVIDER_INDICATION
 *
 *	Parameter1:
 *		PConnectProviderIndication
 *			This is a pointer to a structure that contains all necessary
 *			information about an incoming connection.
 *	Parameter2: Unused
 *
 *	Functional Description:
 *		This indication is sent to the owner object when an incoming
 *		connection is detected.  The owner object should respond by calling
 *		MCSConnectProviderResponse indicating whether or not the connection
 *		is to be accepted.
 */

/*
 *	CONNECT_PROVIDER_CONFIRM
 *
 *	Parameter1:
 *		PConnectProviderConfirm
 *			This is a pointer to a structure that contains all necessary
 *			information about an outgoing connection.
 *	Parameter2: Unused
 *
 *	Functional Description:
 *		This confirm is sent to the object that made the original connect
 *		provider request.  It informs the requesting object of when the new
 *		connection is available for use, or that the connection could not be
 *		established (or that it was rejected by the	remote site).
 */

/*
 *	DISCONNECT_PROVIDER_INDICATION
 *
 *	Parameter1: Unused
 *	Parameter2:
 *		(LOWUSHORT) ConnectionHandle
 *			This is the handle for the connection that was lost.
 *		(HIGHUSHORT) Reason
 *			This is the reason for the disconnect.
 *
 *	Functional Description:
 *		This indication is sent to the owner object whenever a connection
 *		is lost.  This essentially tells the owner object that the contained
 *		connection handle is no longer valid.
 */

/*
 *	GCC_ATTACH_USER_CONFIRM
 *
 *	Parameter1: Unused
 *	Parameter2:
 *		(LOWUSHORT) UserID
 *			If the result is success, then this is the newly assigned user ID.
 *			If the result is failure, then this field is undefined.
 *		(HIGHUSHORT) Result
 *			This is the result of the attach user request.
 *
 *	Functional Description:
 *		This confirm is sent to the user object in response to a previous
 *		call to MCS_AttachRequest.  It contains the result of that service
 *		request.  If successful, it also contains the user ID that has been
 *		assigned to that attachment.
 */

/*
 *	GCC_DETACH_USER_INDICATION
 *
 *	Parameter1: Unused
 *	Parameter2:
 *		(LOWUSHORT) UserID
 *			This is the user ID of the user that is detaching.
 *		(HIGHUSHORT) Reason
 *			This is the reason for the detachment.
 *
 *	Functional Description:
 *		This indication is sent to the user object whenever a user detaches
 *		from the domain.  This is sent to ALL remaining user objects in the
 *		domain automatically.  Note that if the user ID contained in this
 *		indication is the same as that of the user object receiving it, the
 *		user is	essentially being told that it has been kicked out of the
 *		conference.  The user handle and user ID are no longer valid in this
 *		case.  It is the responsibility of the user object to recognize when
 *		this occurs.
 */

/*
 *	GCC_CHANNEL_JOIN_CONFIRM
 *
 *	Parameter1: Unused
 *	Parameter2:
 *		(LOWUSHORT) ChannelID
 *			This is the channel that has been joined.
 *		(HIGHUSHORT) Result
 *			This is the result of the join request.
 *
 *	Functional Description:
 *		This confirm is sent to a user object in response to a previous
 *		call to ChannelJoinRequest.  It lets the user object know if the
 *		join was successful for a particular channel.  Furthermore, if the
 *		join request was for channel 0 (zero), then the ID of the assigned
 *		channel is contained in this confirm.
 */

/*
 *	CHANNEL_LEAVE_INDICATION
 *
 *	Parameter1: Unused
 *	Parameter2:
 *		(LOWUSHORT) ChannelID
 *			This is the channel that has been left or is being told to leave.
 *		(HIGHUSHORT) Reason
 *			This is the reason for the leave.
 *
 *	Functional Description:
 *		This indication is sent to a user object when a domain merger has
 *		caused a channel to be purged from the lower domain.  This informs the
 *		the user that it is no longer joined to the channel.
 */

/*
 *	GCC_SEND_DATA_INDICATION
 *
 *	Parameter1:
 *		PSendData
 *			This is a pointer to a SendData structure that contains all
 *			information about the data received.
 *	Parameter2: Unused
 *
 *	Functional Description:
 *		This indication is sent to a user object when data is received
 *		by the local MCS provider on a channel to which the user is joined.
 */

/*
 *	GCC_UNIFORM_SEND_DATA_INDICATION
 *
 *	Parameter1:
 *		PSendData
 *			This is a pointer to a SendData structure that contains all
 *			information about the data received.
 *	Parameter2: Unused
 *
 *	Functional Description:
 *		This indication is sent to a user object when data is received
 *		by the local MCS provider on a channel to which the user is joined.
 */
/*
 *	TRANSPORT_STATUS_INDICATION
 *
 *	Parameter1:
 *		PTransportStatus
 *			This is a pointer to a TransportStatus structure that contains
 *			information about this indication.  This structure is defined in
 *			"transprt.h".
 *
 *	Functional Description:
 *		A transport stack will issue this indication when it detects a status
 *		change of some sort.  It fills in the TransportStatus structure to
 *		describe the state change and the sends it to MCS.  MCS fills in the
 *		field containing the name of the stack (using the transport identifier),
 *		and forwards it to GCC.
 */

class CConf;
class MCSUser;

class CMCSUserList : public CList
{
    DEFINE_CLIST(CMCSUserList, MCSUser*)
};

class MCSDLLInterface
{
public:

    MCSDLLInterface(PMCSError);
    ~MCSDLLInterface ();

	MCSError 	CreateDomain(GCCConfID *domain_selector)
	{
		ASSERT (g_pMCSController != NULL);
		return g_pMCSController->HandleAppletCreateDomain(domain_selector);
	};

	MCSError 	DeleteDomain(GCCConfID *domain_selector)
	{
		ASSERT (g_pMCSController != NULL);
		return g_pMCSController->HandleAppletDeleteDomain(domain_selector);
	}


	MCSError	ConnectProviderRequest (
							GCCConfID          *calling_domain,
							GCCConfID          *called_domain,
							TransportAddress	calling_address,
							TransportAddress	called_address,
							BOOL				fSecure,
							DBBoolean			upward_connection,
							PUChar				user_data,
							ULong				user_data_length,
							PConnectionHandle	connection_handle,
							PDomainParameters	domain_parameters,
							CConf		        *confirm_object);


	MCSError	ConnectProviderResponse (
							ConnectionHandle	connection_handle,
							GCCConfID          *domain_selector,
							PDomainParameters	domain_parameters,
							Result				result,
							PUChar				user_data,
							ULong				user_data_length);

	MCSError	DisconnectProviderRequest (
							ConnectionHandle	connection_handle);

	MCSError	AttachUserRequest (
							GCCConfID           *domain_selector,
							PIMCSSap 			*ppMCSSap,
							MCSUser		        *user_object);

	MCSError	DetachUserRequest (
							PIMCSSap 			pMCSSap,
							MCSUser 			*pMCSUser);

	MCSError	ChannelJoinRequest (
							ChannelID			channel_id,
							PIMCSSap 			pMCSSap)
				{
					return pMCSSap->ChannelJoin (channel_id);
				};

	MCSError	ChannelLeaveRequest (
							ChannelID			channel_id,
							PIMCSSap 			pMCSSap)
				{
					return pMCSSap->ChannelLeave (channel_id);
				};

	MCSError	SendDataRequest (
							ChannelID			channel_id,
							PIMCSSap 			pMCSSap,
							Priority			priority,
							PUChar				user_data,
							ULong				user_data_length)
				{
					return pMCSSap->SendData (NORMAL_SEND_DATA,
									channel_id,
									priority,
									user_data,
									user_data_length,
									APP_ALLOCATION);
				};

	MCSError	UniformSendDataRequest (	
							ChannelID			channel_id,
							PIMCSSap 			pMCSSap,
							Priority			priority,
							PUChar				user_data,
							ULong				user_data_length)
				{
					return pMCSSap->SendData (UNIFORM_SEND_DATA,
									channel_id,
									priority,
									user_data,
									user_data_length,
									APP_ALLOCATION);
				};

	MCSError	TokenGrabRequest (
							PIMCSSap 			pMCSSap,
							TokenID				token_id)
				{
					return pMCSSap->TokenGrab (token_id);
				};
							
	MCSError	TokenGiveRequest (
							PIMCSSap 			pMCSSap,
							TokenID				token_id,
							UserID				receiver_id)
				{
					return pMCSSap->TokenGive (token_id,
									receiver_id);
				};
							
	MCSError	TokenGiveResponse (
							PIMCSSap 			pMCSSap,
							TokenID				token_id,
							Result				result)
				{
					return pMCSSap->TokenGiveResponse (token_id,
									result);
				};

	MCSError	TokenPleaseRequest (
							PIMCSSap 			pMCSSap,
							TokenID				token_id)
				{
					return pMCSSap->TokenPlease (token_id);
				};
							
	MCSError	TokenReleaseRequest (
							PIMCSSap 			pMCSSap,
							TokenID				token_id)
				{
					return pMCSSap->TokenRelease (token_id);
				};

	MCSError	TokenTestRequest (
							PIMCSSap 			pMCSSap,
							TokenID				token_id)
				{
					return pMCSSap->TokenTest (token_id);
				};

#ifdef NM_RESET_DEVICE
	MCSError	ResetDevice (
							PChar				device_identifier)
				{
					return MCSResetDevice (device_identifier);
				};
#endif // NM_RESET_DEVICE

	GCCError	TranslateMCSIFErrorToGCCError (MCSError	mcs_error)
				{
					return ((mcs_error <= MCS_SECURITY_FAILED) ?
							(GCCError) mcs_error : GCC_UNSUPPORTED_ERROR);
				};

	void			ProcessCallback (
							unsigned int		message,
							LPARAM				parameter,
							PVoid				object_ptr);
private:
	MCSError	AddObjectToConfirmList (
								CConf		        *confirm_object,
								ConnectionHandle	connection_handle);

	DBBoolean			IsUserAttachmentVaid (
								MCSUser				*user_object)
						{
							return (m_MCSUserList.Find(user_object));
						};
	CConnHdlConfList2   m_ConfirmConnHdlConfList2;
	CMCSUserList        m_MCSUserList;
};
typedef	MCSDLLInterface *			PMCSDLLInterface;


GCCResult TranslateMCSResultToGCCResult ( Result mcs_result );

/*
 *	MCSDLLInterface (	HANDLE				instance_handle,
 *						PMCSError			error_value)
 *
 *	Functional Description:
 *		This is the constructor for the MCS Interface class. It is responsible
 *		for initializing the MCAT MCS DLL.  Any errors that occur during
 *		initialization are returned in the error_value provided.
 *
 *	Formal Parameters:
 *		instance_handle (i)
 *			The windows instance handle is used when creating MCS diagnostics.
 *		error_value (i)
 *			This pointer is used to pass back any errors that may have occured
 *			while initializing the class.  This includes any problems with
 *			initializing the MCAT MCS DLL.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~MCSDLLInterface ()
 *
 *	Functional Description:
 *		This is the destructor for the MCS Interface class. It is responsible
 *		for cleaning up both itself and the MCAT MCS DLL.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	CreateDomain (
 *							DomainSelector		domain_selector_string,
 *							UINT				domain_selector_length)
 *
 *	Functional Description:
 *		This function is used to create an MCS domain.
 *
 *	Formal Parameters:
 *		domain_selector_string (i)
 *			This is the name of the domain to be created.
 *		domain_selector_length (i)
 *			This is the length of the domain name in characters.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			On success
 *		MCS_NOT_INITIALIZED
 *			The mcs interface did not initialize properly
 *		MCS_DOMAIN_ALREADY_EXISTS
 *			A domain by this name alread exist
 *		MCS_ALLOCATION_FAILURE
 *			A memory failure occured
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	DeleteDomain (
 *							DomainSelector		domain_selector_string,
 *							UINT				domain_selector_length)
 *
 *	Functional Description:
 *		This function an MCS domain which was created using the CreateDomain
 *		call.
 *
 *	Formal Parameters:
 *		domain_selector_string (i)
 *			This is the name of the domain to be deleted.
 *		domain_selector_length (i)
 *			This is the length of the domain name in characters.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			On success
 *		MCS_NOT_INITIALIZED
 *			The mcs interface did not initialize properly
 *		MCS_NO_SUCH_DOMAIN
 *			The domain to be deleted does not exist
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	ConnectProviderRequest (
 *							DomainSelector		calling_domain,
 *							UINT				calling_domain_length,
 *							DomainSelector		called_domain,
 *							UINT				called_domain_length,
 *							TransportAddress	calling_address,
 *							TransportAddress	called_address,
 *							DBBoolean				upward_connection,
 *							PUChar				user_data,
 *							ULong				user_data_length,
 *							PConnectionHandle	connection_handle,
 *							PDomainParameters	domain_parameters,
 *							CConf		        *confirm_object)
 *
 *	Functional Description:
 *		This T.122 primitive is used to connect two domains. This request
 *		should always be followed by a connect provider confirm.  The
 *		confirm will be sent to be object specified by the confirm object
 *		the is passed into this routine.
 *
 *	Formal Parameters:
 *		calling_domain (i)
 *			This is a pointer to the calling domain selector string.
 *		calling_domain_length (i)
 *			This is the length of the calling domain selector string.
 *		called_domain (i)
 *			This is a pointer to the called domain selector string.
 *		called_domain_length (i)
 *			This is the length of the called domain selector length.
 *		calling_address (i)
 *			This is a pointer to the calling addres (an ASCII string).
 *		called_address (i)
 *			This is a pointer to the address being called (an ASCII string).
 *		upward_connection (i)
 *			This boolean flag denotes the hierarchical direction of the
 *			connection to be created (TRUE means upward, FALSE means downward).
 *		user_data (i)
 *			This is a pointer to the user data to be transmitted during the
 *			creation of this new connection.
 *		user_data_length (i)
 *			This is the length of the user data field mentioned above.
 *		connection_handle (o)
 *			This is set by MCS to a unique handle that can be used to access
 *			this connection on subsequent calls.
 *		domain_parameters (i)
 *			This is a pointer to a structure containing the domain parameters
 *			that the node controller wishes to use for this new connection.
 *		confirm_object (i)
 *			This is a pointer to the object that the connect provider response
 *			is sent to.
 *		object_message_base (i)
 *			This message base is added to the connect provider response
 *			message.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			On success
 *		MCS_NOT_INITIALIZED
 *			The mcs interface did not initialize properly
 *		MCS_NO_SUCH_DOMAIN
 *			The domain to connect does not exist
 *		MCS_DOMAIN_NOT_HIERARCHICAL
 *			An upward connection from this domain already exist
 *		MCS_NVALID_ADDRESS_PREFIX
 *			The transport prefix is not recognized
 *		MCS_ALLOCATION_FAILURE
 *			A memory failure occured
 *		MCS_INVALID_PARAMETER
 *			One of the parameters to the request is invalid
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	ConnectProviderResponse (
 *							ConnectionHandle	connection_handle,
 *							DomainSelector		domain_selector,
 *							UINT				domain_selector_length,
 *							PDomainParameters	domain_parameters,
 *							Result				result,
 *							PUChar				user_data,
 *							ULong				user_data_length)
 *
 *	Functional Description:
 *		This function is used to respond to a connect provider indication.
 *		This call will result in a connect provider confirm at the remote
 *		node.
 *
 *	Formal Parameters:
 *		connection_handle (i)
 *			This is the handle of the connection that the response is for.
 *		domain_selector (i)
 *			This is a pointer to the domain selector identifying which domain
 *			the inbound connection is to be bound to.
 *		domain_selector_length (i)
 *			This is the length of the above domain selector.
 *		domain_parameters (i)
 *			This is a pointer to a structure containing the domain parameters
 *			that the node controller has agreed to use for the connection
 *			being created.
 *		result (i)
 *			This is the result.  This determines whether an inbound connection
 *			is accepted or rejected.  Anything but RESULT_SUCCESSFUL rejects
 *			the connection.
 *		user_data (i)
 *			This is the address of user data to be sent in the connect response
 *			PDU.
 *		user_data_length (i)
 *			This is the length of the user data mentioned above.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			On success
 *		MCS_NOT_INITIALIZED
 *			The mcs interface did not initialize properly
 *		MCS_NO_SUCH_CONNECTION
 *			The connection specified is invalid
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	DisconnectProviderRequest (
 *							ConnectionHandle	connection_handle)
 *
 *	Functional Description:
 *		This function is used to disconnect a node from a particular connection.
 *		This can be either an upward or downward connection
 *
 *	Formal Parameters:
 *		connection_handle (i)
 *			This is the handle of the connection which the node controller wants
 *			to disconnect.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			On success
 *		MCS_NOT_INITIALIZED
 *			The mcs interface did not initialize properly
 *		MCS_NO_SUCH_CONNECTION
 *			The connection specified is invalid
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	AttachUserRequest (
 *							DomainSelector		domain_selector,
 *							UINT				domain_selector_length,
 *							PIMCSSap 			*ppMCSSap,
 *							PMCSUser			user_object)
 *
 *	Functional Description:
 *		This function is used to create a user attachment to MCS. It will result
 *		in an attach user confirm.
 *
 *	Formal Parameters:
 *		domain_selector (i)
 *			This is the name of the domain to which the user wishes to attach.
 *		domain_selector_length (i)
 *			This is the length of the above domain selector.
 *		ppMCSSap (o)
 *			This is a pointer to a variable where the new user handle will be
 *			stored upon successful completion of this call.
 *		user_object (i)
 *			This is a pointer to the MCSUser object which should receive the callbacks
 *			for this user attachment.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			On success
 *		MCS_NO_SUCH_DOMAIN
 *			The domain to be attached to does not exist
 *		MCS_ALLOCATION_FAILURE
 *			A memory failure occured
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	void	ProcessCallback (	UINT				message,
 *								ULong				parameter,
 *								PVoid				object_ptr)
 *
 *	Functional Description:
 *		This routine is called whenever a callback message is received by
 *		the "C" callback routine. It is responsible for both processing
 *		callback messages and forwarding callback messages on to the
 *		appropriate object.
 *
 *	Formal Parameters:
 *		message	(i)
 *			This is the mcs message to be processed
 *		parameter (i)
 *			Varies according to the message. See the MCAT programmers manual
 *		object_ptr (i)
 *			This is the user defined field that was passed to MCS on
 *			initialization.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	MCSDLLInterface::TranslateMCSIFErrorToGCCError ()
 *								MCSError			mcs_error)
 *
 *	Public
 *
 *	Function Description
 *		This routine translate an MCS Interface error into a GCC Error.
 *
 *	Formal Parameters:
 *		mcs_error (i)
 *			This is the error to be translated.
 *
 *	Return Value:
 *		This is the translated GCC error.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\memmgr.h ===
/*
 *	memmgr.h
 *
 *	Copyright (c) 1998 by Microsoft Corporation, Redmond, WA
 *
 *	Abstract:
 *		This is the header file for the T.120 memory allocation mechanism.  This
 *		file contains the declarations necessary to allocate and distribute memory
 *		in the form of Memory objects within T.120.
 *
 *	This implementation defines priorities of memory allocations.  A lower
 *	priority number implies higher priority.  Priority-0 allocations will be
 *	satisfied, unless the system is out of memory.  Priorities 1 and 2
 *	limit the amount of total memory that can be allocated, but priority 1 (recv priority)
 *	has higher water mark limits than priority 2 (send priority).
 *
 *	Protected Member Functions:
 *		None.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		Christos Tsollis
 */

/*
 *	We define the following 3 memory priorities:
 *		TOP_PRIORITY  (0): 	The allocation will succeed unless the system is out of memory
 *		RECV_PRIORITY (1):	Allocation will succeed only if less than 1 MB has been allocated
 *		SEND_PRIORITY (2):	Allocation will succeed only if less than 0xE0000 bytes have been allocated so far.
 */
#ifndef _T120_MEMORY_MANAGER
#define _T120_MEMORY_MANAGER

#include "memory.h"

// This is the main T.120 allocation routine
PMemory	AllocateMemory (
				PUChar				reference_ptr,
				UINT				length,
				MemoryPriority		priority = HIGHEST_PRIORITY);
// Routine to ReAlloc memory allocated by AllocateMemory().
BOOL ReAllocateMemory (
				PMemory		*pmemory,
				UINT		length);
// Routine to free the memory allocated by AllocateMemory().
void FreeMemory (PMemory	memory);

// To discover how much space is available at a non-TOP priority...
unsigned int GetFreeMemory (MemoryPriority	priority);

// Macro to get to the Memory object from app-requested buffer space
#define GetMemoryObject(p)				((PMemory) ((PUChar) p - (sizeof(Memory) + MAXIMUM_PROTOCOL_OVERHEAD)))
// Macro to get to the Memory object from the coder-alloced buffer space
#define GetMemoryObjectFromEncData(p)	((PMemory) ((PUChar) p - sizeof(Memory)))

// Routines to lock/unlock (AddRef/Release) memory allocated by AllocateMemory()
#define  LockMemory(memory)  			((memory)->Lock())
#define	 UnlockMemory(memory)			(FreeMemory(memory))

// Routines to allocate, realloc and free space without an associated Memory object
#ifdef DEBUG
	PUChar	Allocate (UINT		length);
#else 
#	define Allocate(length)				((PUChar) new BYTE[length])
#endif // DEBUG
#define Free(p)							(delete [] (BYTE *) (p))

#endif // _T120_MEMORY_MANAGER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\mcattprt.h ===
/*	MCATTPRT.h
 *
 *	Copyright (c) 1993-1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the TCP Transport. If an application
 *		is making calls directly to the Transport DLL, this file MUST be
 *		included.  All transports have the same interface.  This makes
 *		programming to the Transports simpler for the user.
 *
 *		This file contains all of the prototypes and defintions needed to use
 *		any of the Transport DLLs.
 *
 *		Transports have 2 modes of operation, either in-band call control or
 *		out-of-band call control.  With in-band call control, the Transport DLL
 *		makes the physical connection when the TConnectRequest() call is made
 *		from MCS.  It also breaks the physical connection when MCS makes a
 *		TDisconnectRequest() call.  This basic mode of operation works well but
 *		we have added the out-of-band call control mode for 2 reasons:
 *
 *			1.  Allow the user to make multiple MCS connections without
 *				breaking the physical connection.  This is needed if the
 *				application is using the GCC Query commands.
 *
 *			2.  Allow the user to use any type of calling mechanism (i.e. TAPI,
 *				TSAPI,...) that they want.
 *		
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James W. Lawwill
 *
 */
#ifndef	_MCATTPRT_
#define	_MCATTPRT_

#include "databeam.h"

/*
 *	These are valid return codes from the Transport DLL.
 *	
 *	TRANSPORT_NO_ERROR
 *		The function executed properly, without error.  This does not mean
 *		that the function is complete.  Some functions are non-blocking
 *		(they don't occur immediately), therefore they could still fail.
 *		A good example of this is the TConnectRequest() function in the
 *		TCP transport.  It takes a few seconds to call the remote site and
 *		establish a link.  If the connection fails or succeeds, a callback
 *		will be sent back to the user to give them the status.
 *	TRANSPORT_INITIALIZATION_FAILED
 *		The TInitialize() function failed.  This can occur for a number of
 *		reasons.
 *	TRANSPORT_NOT_INITIALIZED
 *		The user is attempting to use a function even though the TInitialize()
 *		function failed.
 *	TRANSPORT_NO_SUCH_CONNECTION
 *		The user is attempting a function call with an illegal
 *		TransportConnection handle.
 *	TRANSPORT_WRITE_QUEUE_FULL
 *		The TDataRequest() function failed because its write queue is full
 *	TRANSPORT_READ_QUEUE_FULL
 *		This return value is returned from the TRANSPORT_DATA_INDICATION
 *		callback.  It occurs when the user application can not handle the
 *		data packet because it does not currently have room for it.  This
 *		is a flow control mechanism between the user application and the
 *		Transport DLL.
 *	TRANSPORT_CONNECT_REQUEST_FAILED
 *		The TConnectRequest() function failed because the modem was not
 *		in the proper mode.  As we initialize a modem, it is not possible
 *		to dial out it.  Try the TConnectRequest() later.
 *	TRANSPORT_CONNECT_RESPONSE_FAILED
 *		The TConnectResponse() function failed.  Evidently, the function was
 *		called at the wrong time.
 *	TRANSPORT_NO_CONNECTION_AVAILABLE
 *		The TConnectRequest() function failed because all available modems
 *		are currently in use.
 *	TRANSPORT_NOT_READY_TO_TRANSMIT
 *		The TDataRequest() function failed because it is not ready to send
 *		data.  If you attempt this function before you receive a
 *		TRANSPORT_CONNECT_INDICATION callback, you will receive this value
 *	TRANSPORT_ILLEGAL_COMMAND
 *		TResetDevice() or TProcessCommand() failed because the command submitted
 *		to the function was invalid.
 *	TRANSPORT_CONFIGURATION_ERROR
 *		Return value from TProcessCommand() if the user is enabling a device
 *		that has an illegal configuration setup in the .ini file
 *	TRANSPORT_MEMORY_FAILURE
 *		The function failed because the Transport Stack was not able to allocate
 *		the memory necessary to perform the function.
 */
typedef	unsigned long						TransportError;
typedef	TransportError *					PTransportError;

#define	TRANSPORT_NO_ERROR					0
#define	TRANSPORT_INITIALIZATION_FAILED		1
#define	TRANSPORT_NOT_INITIALIZED			2
#define	TRANSPORT_NO_SUCH_CONNECTION		3
#define	TRANSPORT_WRITE_QUEUE_FULL			4
#define	TRANSPORT_READ_QUEUE_FULL			5
#define	TRANSPORT_CONNECT_REQUEST_FAILED	6
#define TRANSPORT_MEMORY_FAILURE			7
#define	TRANSPORT_NOT_READY_TO_TRANSMIT		8
#define TRANSPORT_CANT_SEND_NOW				9
#define	TRANSPORT_ILLEGAL_COMMAND			10
#define	TRANSPORT_CONFIGURATION_ERROR		12
#define TRANSPORT_CONNECT_RESPONSE_FAILED	13

#define TRANSPORT_SECURITY_FAILED			14

#define TRANSPORT_BUFFER_TOO_SMALL          15
#define TRANSPORT_NO_PLUGGABLE_CONNECTION   16
#define TRANSPORT_WRITE_FILE_FAILED         17
#define TRANSPORT_ALREADY_INITIALIZED       18
#define TRANSPORT_INVALID_PARAMETER         19
#define TRANSPORT_PHYSICAL_LAYER_NOT_FOUND  20
#define TRANSPORT_NO_T123_STACK             21

/*
 *	TransportConnection is the handle used by the Transport DLL
 *	to distinguish one logical connection from another.  The DLL assigns
 *	the transport connection in a TConnectRequest() call or as a
 *	result of a TRANSPORT_CONNECT_INDICATION callback
 */
typedef enum tagTransportType
{
    TRANSPORT_TYPE_WINSOCK          = 0,
    TRANSPORT_TYPE_PLUGGABLE_X224   = 1,
    TRANSPORT_TYPE_PLUGGABLE_PSTN   = 2,
}
    TransportType;

typedef struct tagTransportConnection
{
    TransportType   eType;
    UINT_PTR        nLogicalHandle;
}
    TransportConnection, *PTransportConnection;

#define PACK_XPRTCONN(x)            (MAKELONG((x).nLogicalHandle, (x).eType))
#define UNPACK_XPRTCONN(x,n)        { (x).nLogicalHandle = LOWORD((n)); (x).eType = (TransportType) HIWORD((n)); }

#define IS_SAME_TRANSPORT_CONNECTION(x1,x2) (((x1).eType == (x2).eType) && ((x1).nLogicalHandle == (x2).nLogicalHandle))
#define IS_SOCKET(x)                        (TRANSPORT_TYPE_WINSOCK == (x).eType)
#define IS_PLUGGABLE(x)                     (TRANSPORT_TYPE_WINSOCK != (x).eType)
#define IS_PLUGGABLE_X224(x)                (TRANSPORT_TYPE_PLUGGABLE_X224 == (x).eType)
#define IS_PLUGGABLE_PSTN(x)                (TRANSPORT_TYPE_PLUGGABLE_PSTN == (x).eType)
#define IS_VALID_TRANSPORT_CONNECTION_TYPE(x) (IS_SOCKET(x) || IS_PLUGGABLE_X224(x) || IS_PLUGGABLE_PSTN(x))

#define SET_SOCKET_CONNECTION(x,s)          { (x).eType = TRANSPORT_TYPE_WINSOCK; (x).nLogicalHandle = (s); }


/*
 *	This structure is passed back with the TRANSPORT_DATA_INDICATION message.
 *
 *	Since there is only one callback address passed into the Transport DLL and
 *	there can be many transport connections maintained by this DLL, the
 *	transport_connection number is included in the structure.  This number
 *	tells the user application which connection the data is associated with.
 *
 *	The other two parameters are the data address and data length
 */
typedef	struct
{
	TransportConnection		transport_connection;
	unsigned char *			user_data;
	unsigned long			user_data_length;
	PMemory					memory;
} TransportData;
typedef	TransportData *		PTransportData;


/*
 *	The following section defines the callbacks that can be issued to the
 *	user.
 *
 *	The callback contains three parameters:
 *		The first is the callback message.
 *		The second is specific to the callback message.
 *		The third is the user defined value that is passed in
 *			during TInitialize().
 */

/*
 *	Message:	TRANSPORT_CONNECT_INDICATION
 *	Parameter:	
 *		TransportConnection		transport_connection
 *
 *	Functional Description:
 *		The user receives this message when an incoming call has been
 *		received.  The user can issue a TConnectResponse() to accept the
 *		call or a TDisconnectRequest() to terminate the connection.
 *
 *		The user will never receive this callback message if he originates
 *		the connection.  In that case the user will receive a
 *		TRANSPORT_CONNECT_CONFIRM.
 */

/*
 *	Message:	TRANSPORT_DATA_INDICATION
 *	Parameter:	
 *		PTransportData
 *			This is the address of the transport data structure
 *
 *	Functional Description:
 *		The callback returns this message when it has data for the user.
 *		The message is sent with the address of a TransportData structure,
 *		which contains the transport_connection, the data address, and the
 *		data length.
 */

/*
 *	Message:	TRANSPORT_EXPEDITED_DATA_INDICATION
 *	Parameter:	
 *		PTransportData
 *			This is the address of the transport data structure
 *
 *	Functional Description:
 *		This callback is currently unsupported.
 */

/*
 *	Message:	TRANSPORT_DISCONNECT_INDICATION
 *	Parameter:	
 *		TransportConnection
 *
 *	Functional Description:
 *		The callback returns this message when the transport connection
 *		is broken.  It can result from a TDisconnectRequest() call by the
 *		user, or from an unstable physical connection.
 */

/*
 *	Message:	TRANSPORT_CONNECT_CONFIRM
 *	Parameter:	
 *		TransportConnection
 *
 *	Functional Description:
 *		The callback returns this message when a new transport connection
 *		has been established.
 *
 *		This message is issued in response to the user issuing a
 *		TConnectRequest().  When the Transport Connection is up and
 *		operational, the user will receive this callback message.
 *
 *		If you are called by another user, you will receive a
 *		TRANSPORT_CONNECT_INDICATION.
 */

/*
 *  Message:    TRANSPORT_STATUS_INDICATION
 *  Parameter:
 *      PTransportStatus
 *          Address of the TransportStatus structure
 *
 *  Functional Description:
 *      This callback is sent from a Transport Layer to notify the user of a
 *      change in a physical device.  For example, in the case of the PSTN
 *      Transport Stack, this message will be sent up when the modem detects an
 *      incoming RING or when a connection is established.  Any time the state
 *      of the modem changes, a message will be sent up.  Messages will also be
 *      sent up when an error occurs
 */

#define TRANSPORT_CONNECT_INDICATION            0
#define TRANSPORT_CONNECT_CONFIRM               1
#define TRANSPORT_DATA_INDICATION               2
// #define TRANSPORT_EXPEDITED_DATA_INDICATION     3
#define TRANSPORT_DISCONNECT_INDICATION         4
// #define TRANSPORT_STATUS_INDICATION             5
#define TRANSPORT_BUFFER_EMPTY_INDICATION       6



#ifdef TSTATUS_INDICATION
/*
 *	Physical Device states
 */
typedef enum
{
	TSTATE_NOT_READY,
	TSTATE_NOT_CONNECTED,
	TSTATE_CONNECT_PENDING,
	TSTATE_CONNECTED,
	TSTATE_REMOVED
}  TransportState;

/*
 *	The following structure is passed to ths user via the
 *	TRANSPORT_STATUS_INDICATION callback.
 *
 *
 *		device_identifier 	 -	The device_identifier is only set if a specific
 *								device is referenced (i.e. "COM1").
 *
 *		remote_address 		 -	String specifying the address of the person we
 *								are linked to.
 *
 *		message				 -	This string is filled in to give the user some
 *								type of feedback.  A message may reflect an
 *								error in the configuration file, an incoming
 *								RING from the modem, or a BUSY signal on the
 *								telephone line.
 *
 *		state				 -	Current state of the device.  This is one of
 *								the TransportState enumerations.
 */
typedef struct
{
	char *			device_identifier;
	char *			remote_address;
	char *			message;
	TransportState	state;
}  TransportStatus;
typedef TransportStatus *	PTransportStatus;

#endif // TSTATUS_INDICATION

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\memory.h ===
/*
 *	memory.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the Memory class.  Instances of this
 *		class are used to pass data around the system.
 *
 *		Each instance of this class maintains two pointers.  The first is a
 *		pointer to the reference data (or the source data) which this object
 *		is responsible for representing.  The second is a pointer to a copy
 *		buffer, which is a piece of allocated memory that a Memory object
 *		can copy the data into if necessary.
 *
 *		When a Memory object is created, both of these addresses are passed
 *		in to it.  It does not, however, copy the data from the reference
 *		buffer to the copy buffer just yet.  If anyone asks the address of the
 *		buffer, it will simply return the reference pointer.  However, the
 *		first time the buffer is locked, the data will be copied from the
 *		reference buffer to the copy buffer for safe keeping.  In essence,
 *		the lock function tells the Memory object that someone is interested
 *		in the data for longer than the reference buffer will remain valid.
 *
 *		After the object is locked, a call to retrieve a memory pointer will
 *		result in the copy pointer being returned.
 *
 *		Each time the lock function is called, a lock count is incremented.
 *		The copy operation only takes place the first time the buffer is
 *		locked, however.
 *
 *		In addition to maintaining a lock count, this object keeps a flag
 *		indicating whether or not it has been freed by the allocator.  This
 *		freeing really means that the object is enabled to be freed as soon
 *		as the lock count hits zero.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	_MEMORY_
#define	_MEMORY_

#include "signatr.h"

#define MEMORY_PRIORITIES		3

typedef enum {
	HIGHEST_PRIORITY		= 0,
	RECV_PRIORITY			= 1,
	SEND_PRIORITY			= 2
} MemoryPriority;

/*
 *	This is the class definition for the Memory class.
 */
class Memory;
typedef	Memory *		PMemory;

class Memory
{	
	public:
						Memory (PUChar			reference_ptr,
								ULong			length,
								PUChar			copy_ptr);
						~Memory ()
						{
							ASSERT(SIGNATURE_MATCH(this, MemorySignature));
						};
		Void			Init (PUChar			reference_ptr,
								ULong			length,
								MemoryPriority	priority,
								PUChar			copy_ptr);
		PUChar			GetPointer ()
						{
							ASSERT(SIGNATURE_MATCH(this, MemorySignature));
							return (Copy_Ptr);
						}
		ULong			GetLength ()
						{
							ASSERT(SIGNATURE_MATCH(this, MemorySignature));
							return (Length);
						}
		int				GetLockCount ()
						{
							ASSERT(SIGNATURE_MATCH(this, MemorySignature));
							return ((int) lLock);
						};
		MemoryPriority	GetMemoryPriority ()
						{
							return m_priority;
						};
		Void			Lock ()
						{
							ASSERT(SIGNATURE_MATCH(this, MemorySignature));
							InterlockedIncrement (& lLock);
							TRACE_OUT (("Memory::Lock: buffer at address %p. Lock count: %d",
										(UINT_PTR) Copy_Ptr, lLock));
							ASSERT (lLock > 0);
						};
		long			Unlock ()
						{
							ASSERT(SIGNATURE_MATCH(this, MemorySignature));
							ASSERT (lLock > 0);
							TRACE_OUT (("Memory::UnLock: buffer at address %p. Lock count: %d",
										(UINT_PTR) Copy_Ptr, lLock - 1));
							return (InterlockedDecrement (&lLock));
						}

	private:
		ULong			Length;
		PUChar			Copy_Ptr;
		long			lLock;
		MemoryPriority	m_priority;
/*
 *	NOTEs:
 *		1. The Memory class can not have virtual member functions, because
 *			of the Init() member.
 *		2. sizeof(Memory) should be DWORD-aligned, because of the
 *			AllocateMemory implementation.
 */

#ifndef SHIP_BUILD
	public:
		char			mSignature[SIGNATURE_LENGTH];
#endif // SHIP_BUILD
};


/*
 *	Memory (
 *			PUChar		reference_ptr,
 *			ULong		length,
 *			PUChar		copy_ptr)
 *
 *	Functional Description:
 *		This is the constructor for the Memory class.  All it does is
 *		initialize the instance variable with the passed in values.
 *
 *	Formal Parameters:
 *		reference_ptr (i)
 *			This is a pointer to the data that is to represented by this
 *			Memory object.
 *		length (i)
 *			This is the length of the reference buffer.
 *		copy_ptr (i)
 *			This is the address of an allocated buffer that the Memory object
 *			can use to preserve the contents of the reference buffer if a lock
 *			operation occurs.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~Memory ()
 *
 *	Functional Description:
 *		This is the destructor for the Memory class.  It does nothing at this
 *		time.  Note that it is the responsibility of the memory manager that
 *		is using Memory objects to free up the memory.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	ULong		GetLength ()
 *
 *	Functional Description:
 *		This function retrieves the length of the data being represented by
 *		this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The length of the data.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	PUChar		GetPointer ()
 *
 *	Functional Description:
 *		This function retrieves the buffer being represented by
 *		this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The buffer pointer.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	int		GetLockCount ()
 *
 *	Functional Description:
 *		This function retrieves the lock counter for the buffer being represented by
 *		this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The buffer's current lock counter.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		Lock ()
 *
 *	Functional Description:
 *		This function locks the buffer being represented by
 *		this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	int		Unlock ()
 *
 *	Functional Description:
 *		This function unlocks the buffer being represented by
 *		this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The lock count after the unlock operation.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\mcsuser.h ===
/*
 *	mcsuser.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		An instance of this class represents a Conference object's user 
 *		attachment to MCS.  This is a fairly complex class that handles a lot of 
 *		conference establishment details such as creating a User attachment to 
 *		MCS and joining all the appropriate MCS channels.  After everything is 
 *		established the User object is responsible for encoding and decoding 
 *		certain PDUs as well as management of a data queue which can hold a 
 *		number of outgoing PDUs.  The MCSUser object is designed so that it 
 *		knows very little about any object other than the MCS Interface object 
 *		which it uses to send out PDUs.  This class only deals with data PDUs 
 *		(or GCC PDUs) as opposed to connect PDUs.  These GCC PDUs are sent and 
 *		received through channels joined by the GCC user attachment.
 *
 *		When an MCSUser object is first instantiated it goes through a number of 
 *		steps to establish its links to MCS.  First,  an MCSUser object 
 *		immediately creates an MCS user attachment in its constructor.  After 
 *		the MCS_ATTACH_USER_CONFIRM is received it begins joining all of the 
 *		appropriate channels.  The channels it joins varies depending on the 
 *		node type which is passed in through the MCSUser objects constructor.  
 *		After all channels have been successfully joined, the MCSUser object 
 *		issues an owner callback informing the Conference object that it is 
 *		completely initiated and ready to service requests.  
 *
 *		The MCSUser object can handle a number of different requests that can 
 *		result in PDU traffic being generated.  Therefore,  the user object has 
 *		the ability (within certain requests) to encode outgoing PDUs.  Many of 
 *		the more complex PDUs are handled by the class that contains the 
 *		information needed to build the PDU such as the ConferenceRoster and the 
 *		ApplicationRoster.  All PDU traffic received by an MCSUser object is 
 *		directly decoded by this class and immediately sent back to the owner 
 *		object (a Conference object) through an owner callback.
 *
 *		An MCSUser object has the ability to Terminate itself when an 
 *		unrecoverable resource error occurs.  This is handled through an owner 
 *		callback message informing the Owner Object to do the delete.  
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */
#ifndef _GCC_MCS_USER_
#define _GCC_MCS_USER_

/** include files **/
#include "mcsdllif.h"
#include "pktcoder.h"
#include "userdata.h"
#include "password.h"
#include "alarm.h"
#include "regkey.h"
#include "regitem.h"
#include "netaddr.h"
#include "invoklst.h"
#include "clists.h"


// was defined in gcmdtar.h
typedef UINT_PTR       TagNumber;


/*
 * Result types for attach user and channel joins performed by the user object
 */
typedef enum
{
	USER_RESULT_SUCCESSFUL,
	USER_ATTACH_FAILURE,
	USER_CHANNEL_JOIN_FAILURE
}UserResultType;


/*
 *	This enum defines all the possible types of nodes that can exists
 *	in a GCC conference.  Note that this is an internal definition and
 *	is not the save the the T.124 node type.
 */
typedef enum
{
	TOP_PROVIDER_NODE,
	CONVENER_NODE,		  
	TOP_PROVIDER_AND_CONVENER_NODE,
	JOINED_NODE,
	INVITED_NODE,
	JOINED_CONVENER_NODE
} ConferenceNodeType;


/*
**	The structures defined below are used to pack the data associated with
**	all the above owner callback messages.  A pointer to one of these
**	structures is passed in the LPVOID parameter of the owner callback.
*/

//	USER_CREATE_CONFIRM data structure
typedef struct
{
	UserID			user_id;
	UserResultType	create_result;
}
    UserCreateConfirmInfo, *PUserCreateConfirmInfo;

//	USER_CONFERENCE_JOIN_REQUEST data structure
typedef struct
{
	CPassword       *convener_password;
	CPassword       *password_challenge;		
	LPWSTR			pwszCallerID;
	CUserDataListContainer *user_data_list;
	UserID			sender_id;
}
    UserJoinRequestInfo, *PUserJoinRequestInfo;

//	USER_CONFERENCE_JOIN_RESPONSE data structure
typedef struct
{
	CPassword           *password_challenge;		
	CUserDataListContainer *user_data_list;
	ConnectionHandle	connection_handle;
	GCCResult			result;
}
    UserJoinResponseInfo, *PUserJoinResponseInfo;

//	USER_TIME_REMAINING_INDICATION data structure
typedef struct
{
	UserID		source_node_id;
	UserID		node_id;
	UINT		time_remaining;
}
    UserTimeRemainingInfo, *PUserTimeRemainingInfo;

//	USER_CONFERENCE_EXTEND_INDICATION data structure
typedef struct
{
	UINT			extension_time;
	BOOL    	time_is_conference_wide;
	UserID		source_node_id;
}
    UserTimeExtendInfo, *PUserTimeExtendInfo;

//	USER_TERMINATE_REQUEST data structure
typedef struct
{
	UserID		requester_id;
	GCCReason	reason;
}
    UserTerminateRequestInfo, *PUserTerminateRequestInfo;

//	USER_NODE_EJECTION_REQUEST data structure
typedef struct
{
	UserID		requester_id;
	UserID		node_to_eject;
	GCCReason	reason;
}
    UserEjectNodeRequestInfo, *PUserEjectNodeRequestInfo;

//	USER_NODE_EJECTION_RESPONSE data structure
typedef struct
{
	UserID		node_to_eject;
	GCCResult	result;
}
    UserEjectNodeResponseInfo, *PUserEjectNodeResponseInfo;

//	USER_REGISTRY_CHANNEL_REQUEST data structure
typedef struct
{
	CRegKeyContainer    *registry_key;
	ChannelID			channel_id;
	EntityID			requester_entity_id;
}
    UserRegistryChannelRequestInfo, *PUserRegistryChannelRequestInfo;

//	USER_REGISTRY_SET_PARAMETER_REQUEST data structure
typedef struct
{
	CRegKeyContainer        *registry_key;
	LPOSTR                  parameter_value;
	GCCModificationRights	modification_rights;
	EntityID				requester_entity_id;
}
    UserRegistrySetParameterRequestInfo, *PUserRegistrySetParameterRequestInfo;

/*
**	Data structure associated with the following: 
**
**	USER_REGISTRY_TOKEN_REQUEST,
**	USER_REGISTRY_RETRIEVE_REQUEST, 
**	USER_REGISTRY_DELETE_REQUEST,
**	USER_REGISTRY_MONITOR_REQUEST.
*/
typedef struct
{
	CRegKeyContainer    *registry_key;
	EntityID			requester_entity_id;
}
    UserRegistryRequestInfo, *PUserRegistryRequestInfo;

//	USER_REGISTRY_RESPONSE data structure
typedef struct
{
	RegistryResponsePrimitiveType	primitive_type;
	CRegKeyContainer                *registry_key;
	CRegItem                        *registry_item;
	GCCModificationRights			modification_rights;
	EntityID						owner_node_id;
	EntityID						owner_entity_id;
	EntityID						requester_entity_id;
	GCCResult						result;
}
    UserRegistryResponseInfo, *PUserRegistryResponseInfo;

//	USER_REGISTRY_MONITOR_INDICATION data structure
typedef struct
{
	CRegKeyContainer                *registry_key;
	CRegItem                        *registry_item;
	GCCModificationRights			modification_rights;
	EntityID						owner_node_id;
	EntityID						owner_entity_id;
}
    UserRegistryMonitorInfo, *PUserRegistryMonitorInfo;

/*
**	Data structure associated with the following:
**
**	USER_REGISTRY_ALLOCATE_HANDLE_REQUEST,
**	USER_REGISTRY_ALLOCATE_HANDLE_RESPONSE.
*/
typedef struct
{
	EntityID						requester_entity_id;
	USHORT							number_of_handles;
	UINT							first_handle;
	GCCResult						result;
}
    UserRegistryAllocateHandleInfo, *PUserRegistryAllocateHandleInfo;

//	USER_CONDUCTOR_PERMIT_GRANT_INDICATION data structure
typedef struct
{
	USHORT			number_granted;
	PUserID			granted_node_list;
	USHORT			number_waiting;
	PUserID			waiting_node_list;
}
    UserPermissionGrantIndicationInfo, *PUserPermissionGrantIndicationInfo;

//	USER_USER_ID_INDICATION data structure
typedef struct
{
	UserID			sender_id;
	TagNumber		tag;
}
    UserIDIndicationInfo, *PUserIDIndicationInfo;

//	USER_TIME_INQUIRE_INDICATION data structure
typedef struct
{
	UserID			sender_id;
	BOOL    		time_is_node_specific;
}
    TimeInquireIndicationInfo, *PTimeInquireIndicationInfo;

//	USER_CONDUCTOR_ASSIGN_INDICATION data structure
typedef struct
{
	UserID			sender_id;
	UserID			conductor_id;
}
    ConductorAssignIndicationInfo, *PConductorAssignIndicationInfo;

//	USER_CONDUCTOR_PERMIT_ASK_INDICATION data structure
typedef struct
{
	UserID			sender_id;
	BOOL    		permission_is_granted;
}
    PermitAskIndicationInfo, *PPermitAskIndicationInfo;

//	USER_DETACH_INDICATION data structure
typedef struct
{
	UserID			detached_user;
	GCCReason		reason;
}
    DetachIndicationInfo, *PDetachIndicationInfo;

/*
**	Data structure associated with the following:
**
**	USER_CONFERENCE_TRANSFER_REQUEST,
**	USER_CONFERENCE_TRANSFER_INDICATION,
**	USER_CONFERENCE_TRANSFER_RESPONSE.
*/
typedef struct
{
	GCCConferenceName		destination_conference_name;
	GCCNumericString		destination_conference_modifier;
	CNetAddrListContainer   *destination_address_list;
	USHORT					number_of_destination_nodes;
	PUserID					destination_node_list;
	CPassword               *password;
	UserID					requesting_node_id;
	GCCResult				result;
}
    TransferInfo, *PTransferInfo;

//	USER_CONFERENCE_ADD_REQUEST data structure
typedef struct
{
	CNetAddrListContainer   *network_address_list;
	CUserDataListContainer  *user_data_list;
	UserID					adding_node;
	TagNumber				add_request_tag;
	UserID					requesting_node;
}
    AddRequestInfo, *PAddRequestInfo;

//	USER_CONFERENCE_ADD_RESPONSE data structure
typedef struct
{
	CUserDataListContainer  *user_data_list;
	TagNumber				add_request_tag;
	GCCResult				result;
}
    AddResponseInfo, *PAddResponseInfo;

/******************** End of callback data structures *********************/


/*
 *	Structure to hold send data information (besides the actual data packet), 
 *	when the send data request is queued to be sent during the heartbeat.
 */
typedef struct
{
	ChannelID				channel_id;
	Priority				priority;
	BOOL    				uniform_send;

	PPacket                 packet;
}
    SEND_DATA_REQ_INFO;

/* 
 *	This structure holds information as to which channels the user object
 *	has joined at a particular instance of time. Also it indicates whether
 *	there has been an error in joining any of these channels or not.
 */
typedef struct
{
	BOOL    				convener_channel_joined;
	BOOL    				user_channel_joined;
	BOOL    				broadcast_channel_joined;
	BOOL    				channel_join_error;
}
    ChannelJoinedFlag, *PChannelJoinedFlag;

/* 
**	Queue of structures (SendDataMessages) to be flushed during a
**	heartbeat.
*/
class COutgoingPDUQueue : public CQueue
{
    DEFINE_CQUEUE(COutgoingPDUQueue, SEND_DATA_REQ_INFO*);
};

/*	
**	List to maintain sequence number in the response with sender's userid
**	to be able to route the response to the correct gcc provider.
*/
class CConfJoinResponseList2 : public CList2
{
    DEFINE_CLIST2_(CConfJoinResponseList2, TagNumber, UserID);
};

/*
**	List to hold the user ids of users in this provider's subtree
**	This list is used to match outstanding user IDs
*/
class CConnHandleUidList2 : public CList2
{
    DEFINE_CLIST2___(CConnHandleUidList2, USHORT)
};

/*
**	This list holds alarms used to disconnect any misbehaving nodes.  If an
**	alarm is placed in this list, the node has a specified amount of time to
**	disconnect before this node will disconnect it.
*/
class CAlarmUidList2 : public CList2
{
    DEFINE_CLIST2_(CAlarmUidList2, PAlarm, UserID)
};


//	The class definition.
class CConf;
class MCSUser : public CRefCount
{
    friend class MCSDLLInterface;

public:

    MCSUser(CConf *,
            GCCNodeID       nidTopProvider,
            GCCNodeID       nidParent,
            PGCCError);

    ~MCSUser(void);

    void		SendUserIDRequest(TagNumber);
	void		SetChildUserIDAndConnection(UserID, ConnectionHandle);

	/* 
	 * Called by conference of intermediate node to send join request
	 * over to the top provider.
	 */
	GCCError	ConferenceJoinRequest(
					CPassword               *convener_password,
					CPassword               *password_challange,
					LPWSTR					pwszCallerID,
					CUserDataListContainer  *user_data_list,
					ConnectionHandle		connection_handle);
			
	/*
	**	Called by conference of top provider to send the response
	**	back to the intermediate node.
	*/
	void		ConferenceJoinResponse(
					UserID					receiver_id,
					BOOL    				password_is_in_the_clear,
					BOOL    				conference_locked,
					BOOL    				conference_listed,
					GCCTerminationMethod	termination_method,
					CPassword               *password_challenge,
					CUserDataListContainer  *user_data_list,
					GCCResult				result);
					
	GCCError SendConferenceLockRequest(void);
	GCCError SendConferenceLockResponse(UserID uidSource, GCCResult);
	GCCError SendConferenceUnlockRequest(void);
	GCCError SendConferenceUnlockResponse(UserID uidSource, GCCResult);
	GCCError SendConferenceLockIndication(BOOL fUniformSend, UserID uidSource);
	GCCError SendConferenceUnlockIndication(BOOL fUniformSend, UserID uidSource);

	//	Calls related to conference termination
	void		ConferenceTerminateRequest(GCCReason);
	void		ConferenceTerminateResponse(UserID uidRequester, GCCResult);
	void		ConferenceTerminateIndication(GCCReason);

    GCCError	EjectNodeFromConference(UserID uidEjected, GCCReason);
	GCCError	SendEjectNodeResponse(UserID uidRequester, UserID uidEject, GCCResult);

	//	Roster related calls
	void		RosterUpdateIndication(PGCCPDU, BOOL send_update_upward);

    //	Registry related calls
	void		RegistryRegisterChannelRequest(CRegKeyContainer *, ChannelID, EntityID);
	void		RegistryAssignTokenRequest(CRegKeyContainer *, EntityID);
	void		RegistrySetParameterRequest(CRegKeyContainer *,
	                                        LPOSTR,
					                        GCCModificationRights,
					                        EntityID);
	void		RegistryRetrieveEntryRequest(CRegKeyContainer *, EntityID);
	void		RegistryDeleteEntryRequest(CRegKeyContainer *, EntityID);
	void		RegistryMonitorRequest(CRegKeyContainer *, EntityID);
   	void		RegistryAllocateHandleRequest(UINT, EntityID);
	void		RegistryAllocateHandleResponse(UINT cHandles, UINT registry_handle,
        					EntityID eidRequester, UserID uidRequester, GCCResult);

    void		RegistryResponse(
					RegistryResponsePrimitiveType	primitive_type,
					UserID  						requester_owner_id,
					EntityID						requester_entity_id,
					CRegKeyContainer	            *registry_key_data,
					CRegItem                        *registry_item_data,
					GCCModificationRights			modification_rights,
					UserID  						entry_owner_id,
					EntityID						entry_entity_id,
					GCCResult						result);

   	void		RegistryMonitorEntryIndication ( 	
					CRegKeyContainer	            *registry_key_data,
					CRegItem                        *registry_item,
					UserID  						entry_owner_id,
					EntityID						entry_entity_id,
					GCCModificationRights			modification_rights);

	GCCError 	AppInvokeIndication(CInvokeSpecifierListContainer *, GCCSimpleNodeList *);

	GCCError 	TextMessageIndication(LPWSTR pwszTextMsg, UserID uidDst);

	GCCError	ConferenceAssistanceIndication(UINT cElements, PGCCUserData *);

	GCCError	ConferenceTransferRequest (
					PGCCConferenceName		destination_conference_name,
					GCCNumericString		destination_conference_modifier,
					CNetAddrListContainer   *destination_address_list,
					UINT					number_of_destination_nodes,
					PUserID					destination_node_list,
					CPassword               *password);

	GCCError	ConferenceTransferIndication (
					PGCCConferenceName		destination_conference_name,
					GCCNumericString		destination_conference_modifier,
					CNetAddrListContainer   *destination_address_list,
					UINT					number_of_destination_nodes,
 					PUserID					destination_node_list,
					CPassword               *password);

	GCCError	ConferenceTransferResponse (
					UserID					requesting_node_id,
					PGCCConferenceName		destination_conference_name,
					GCCNumericString		destination_conference_modifier,
					UINT					number_of_destination_nodes,
 					PUserID					destination_node_list,
					GCCResult				result);
																		 
	GCCError	ConferenceAddRequest(
					TagNumber				conference_add_tag,
					UserID					requesting_node,
					UserID					adding_node,
					UserID					target_node,
					CNetAddrListContainer   *network_address_container,
					CUserDataListContainer  *user_data_container);
		
	GCCError	ConferenceAddResponse(
					TagNumber				add_request_tag,
					UserID					requesting_node,
					CUserDataListContainer  *user_data_container,
					GCCResult				result);
	

	//	Calls related to conductorship
 	GCCError	ConductorTokenGrab(void);
	GCCError	ConductorTokenRelease(void);
   	GCCError	ConductorTokenPlease(void);
	GCCError	ConductorTokenGive(UserID uidRecipient);
   	GCCError	ConductorTokenGiveResponse(Result);
	GCCError	ConductorTokenTest(void);
   	GCCError	SendConductorAssignIndication(UserID uidConductor);
   	GCCError	SendConductorReleaseIndication(void);
	GCCError	SendConductorPermitAsk(BOOL fGranted);

	GCCError	SendConductorPermitGrant(UINT cGranted, PUserID granted_node_list,
					                     UINT cWaiting, PUserID waiting_node_list);

    //	Miscelaneous calls
	GCCError	TimeRemainingRequest(UINT time_remaining, UserID);
	GCCError	TimeInquireRequest(BOOL time_is_conference_wide);	
	GCCError	ConferenceExtendIndication(UINT extension_time, BOOL time_is_conference_wide);
    void        CheckEjectedNodeAlarms(void);
	BOOL    	FlushOutgoingPDU(void);

	GCCNodeID	GetMyNodeID(void) {  return(m_nidMyself); }
	GCCNodeID	GetTopNodeID(void) { return(m_nidTopProvider); }
	GCCNodeID	GetParentNodeID(void) { return(m_nidParent); }

	UserID		GetUserIDFromConnection(ConnectionHandle);
	void		UserDisconnectIndication(UserID);

protected:

	UINT  				ProcessAttachUserConfirm(
							Result					result,
							UserID					user_id);

	UINT				ProcessChannelJoinConfirm(	
							Result					result,
							ChannelID				channel_id);

	UINT				ProcessDetachUserIndication(
							Reason					mcs_reason,
							UserID					detached_user);

	UINT				ProcessSendDataIndication(
							PSendData				send_data_info);

	UINT				ProcessUniformSendDataIndication(	
							PSendData				send_data_info);

	void				ProcessConferenceJoinRequestPDU(
							PConferenceJoinRequest	join_request,
							PSendData				send_data_info);

	void				ProcessConferenceJoinResponsePDU(
							PConferenceJoinResponse	join_response);

	void				ProcessConferenceTerminateRequestPDU(
							PConferenceTerminateRequest	terminate_request,
							PSendData					send_data_info);

	void				ProcessConferenceTerminateResponsePDU(
							PConferenceTerminateResponse
														terminate_response);

	void				ProcessConferenceTerminateIndicationPDU (
							PConferenceTerminateIndication	
													terminate_indication,
							UserID					sender_id);

#ifdef JASPER
	void				ProcessTimeRemainingIndicationPDU (
							PConferenceTimeRemainingIndication	
												time_remaining_indication,
							UserID					sender_id);
#endif // JASPER

#ifdef JASPER
	void				ProcessConferenceAssistanceIndicationPDU(
							PConferenceAssistanceIndication
												conf_assistance_indication,
							UserID					sender_id);
#endif // JASPER

#ifdef JASPER
	void  				ProcessConferenceExtendIndicationPDU(
							PConferenceTimeExtendIndication
												conf_time_extend_indication,
							UserID					sender_id);
#endif // JASPER

	void				ProcessConferenceEjectUserRequestPDU(
							PConferenceEjectUserRequest	
													eject_user_request,
							PSendData				send_data_info);

	void				ProcessConferenceEjectUserResponsePDU(
							PConferenceEjectUserResponse	
													eject_user_request);

	void				ProcessConferenceEjectUserIndicationPDU (
							PConferenceEjectUserIndication	
													eject_user_indication,
							UserID					sender_id);

	void				ProcessRegistryRequestPDU(	
							PGCCPDU					gcc_pdu,
							PSendData				send_data_info);

	void				ProcessRegistryAllocateHandleRequestPDU(
							PRegistryAllocateHandleRequest	
													allocate_handle_request,
							PSendData				send_data_info);

	void				ProcessRegistryAllocateHandleResponsePDU(
							PRegistryAllocateHandleResponse
                        						allocate_handle_response);

	void				ProcessRegistryResponsePDU(	
							PRegistryResponse			registry_response);

	void				ProcessRegistryMonitorIndicationPDU(
							PRegistryMonitorEntryIndication		
														monitor_indication,
							UserID						sender_id);

	void				ProcessTransferRequestPDU (
							PConferenceTransferRequest
											conference_transfer_request,
							PSendData		send_data_info);

#ifdef JASPER
	void				ProcessTransferIndicationPDU (
							PConferenceTransferIndication
											conference_transfer_indication);
#endif // JASPER

#ifdef JASPER
	void				ProcessTransferResponsePDU (
							PConferenceTransferResponse
											conference_transfer_response);
#endif // JASPER

	void				ProcessAddRequestPDU (
							PConferenceAddRequest	conference_add_request,
							PSendData				send_data_info);

	void				ProcessAddResponsePDU (
							PConferenceAddResponse	
												conference_add_response);

	void				ProcessPermissionGrantIndication(
							PConductorPermissionGrantIndication
												permission_grant_indication,
							UserID				sender_id);

	void				ProcessApplicationInvokeIndication(
							PApplicationInvokeIndication	
												invoke_indication,
							UserID				sender_id);

#ifdef JASPER
	GCCError			ProcessTextMessageIndication(
							PTextMessageIndication	text_message_indication,
							UserID					sender_id);
#endif // JASPER

	void				ProcessFunctionNotSupported (
							UINT					request_choice);

    void ProcessTokenGrabConfirm(TokenID, Result);
    void ProcessTokenGiveIndication(TokenID, UserID);
    void ProcessTokenGiveConfirm(TokenID, Result);

#ifdef JASPER
    void ProcessTokenPleaseIndication(TokenID, UserID);
#endif // JASPER

#ifdef JASPER
    void ProcessTokenReleaseConfirm(TokenID, Result);
#endif // JASPER

    void ProcessTokenTestConfirm(TokenID, TokenStatus);

private:

    void                AddToMCSMessageQueue(
                        	PPacket                 packet,
                        	ChannelID				channel_id,
                        	Priority				priority,
                        	BOOL    				uniform_send);

	GCCError			InitiateEjectionFromConference (
      						GCCReason				reason);

	MCSError			JoinUserAndBroadCastChannels();

	MCSError			JoinConvenerChannel();

	BOOL    			AreAllChannelsJoined();

    void ResourceFailureHandler(void);

private:

    CConf                           *m_pConf;

	PIMCSSap 						m_pMCSSap;
	GCCNodeID						m_nidMyself;
	GCCNodeID						m_nidTopProvider;
	GCCNodeID						m_nidParent;

	BOOL    						m_fEjectionPending;
	GCCReason						m_eEjectReason;

	ChannelJoinedFlag				m_ChannelJoinedFlags;
	CConnHandleUidList2             m_ChildUidConnHdlList2;
	COutgoingPDUQueue				m_OutgoingPDUQueue;                
	CConfJoinResponseList2          m_ConfJoinResponseList2;
	CAlarmUidList2                  m_EjectedNodeAlarmList2;
	CUidList    					m_EjectedNodeList;
};
typedef	MCSUser *		PMCSUser;

/*
 *	MCSUser(	UINT        		owner_message_base,
 *				GCCConferenceID		conference_id,
 *				ConferenceNodeType	conference_node_type,
 *				UserID				top_provider,
 *				UserID				parent_user_id,
 *				PGCCError			return_value)
 *
 *	Public Function Description
 *		This is the MCSUser object constructor.  It is responsible for
 *		initializing all the instance variables used by this class.  The
 *		constructor is responsible for establishing the user attachment to
 *		the MCS domain defined by the conference ID.  It also kicks off the
 *		process of joining all the appropriate channels.
 *
 *	Formal Parameters:
 *		conference_id		-	(i)	Conference ID associated with this user also
 *									defines the domain to attach to.	
 *		conference_node_type-	(i)	Internal Node type (see above enumeration).
 *		top_provider		-	(i)	User ID of top provider node. Zero if this
 *									is the top provider.	
 *		parent_user_id		-	(i)	User ID of parent node. Zero if this is the
 *									top provider node.	
 *		return_value		-	(o)	Return value for constructor.
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_FAILURE_ATTACHING_TO_MCS	-	Failure to attach to MCS.
 *
 *  Side Effects
 *		The constructor kicks off a sequence of events that culminates in
 *		a USER_CREATE_CONFIRM message being returned to the owner object.
 *		This includes attaching to MCS and joining all the appropriate channels.
 *
 *	Caveats
 *		None.
 */

/*
 *	~MCSUser ()
 *
 *	Public Function Description
 *		This is the MCSUser object destructor.  It is responsible for freeing
 *		up all the internal data allocated by this object.  It also performs
 *		the detach from GCC and leaves all the appropriate channels.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	SendUserIDRequest(
 *						TagNumber			tag_number)
 *
 *	Public Function Description
 *		This routine maps directly to a GCC PDU that delivers the this
 *		nodes user ID to the appropriate node.  The tag number matches the
 *		tag specified by the other node.
 *
 *	Formal Parameters:
 *		tag_number	-	(i)	Tag number that matches the request to the
 *							reponse for the user ID.
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_FAILURE_ATTACHING_TO_MCS	-	Failure to attach to MCS.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void		SetChildUserIDAndConnection (
 *						UserID				child_user_id,
 *						ConnectionHandle	child_connection_handle)
 *
 *	Public Function Description
 *		This routine is used to set the child user id associated with a
 *		particular logical connection.  This information is saved by the
 *		MCSUser object in an internal list.  This is typical called after 
 *		receiving a user ID indication back from a child node.
 *
 *	Formal Parameters:
 *		child_user_id			-	(i)	User ID associated with child connection
 *		child_connection_handle	-	(i)	Logical connection assoicated with
 *										specified user id.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConferenceJoinRequest(
 *					CPassword               *convener_password,
 *					CPassword               *password_challange,
 *					LPWSTR					pwszCallerID,
 *					CUserDataListContainer  *user_data_list,
 *					ConnectionHandle		connection_handle);
 *
 *	Public Function Description:
 *		This function is used to pass a join request on up to the Top Provider.
 *		It is called by a conference at an intermediate node.  This routine is
 *		not used if the joining node is directly connected to the top 
 *		provider.
 *
 *	Formal Parameters:
 *		convener_password	-	(i)	Convener password included with the
 *									original join request.
 *		password_challenge	-	(i)	Password challenge included with the
 *									original join request.
 *		pwszCallerID		-	(i)	Caller ID used in original join request.
 *		user_data_list		-	(i)	User data included in original join
 *									request.
 *		connection_handle	-	(i)	This is the logical connection handle
 *									on which the original join came in.  It is
 *									used here as a tag to match the request
 *									with the response.  
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void		ConferenceJoinResponse(
 *						UserID					receiver_id,
 *						BOOL    				password_is_in_the_clear,
 *						BOOL    				conference_locked,
 *						BOOL    				conference_listed,
 *						GCCTerminationMethod	termination_method,
 *						CPassword               *password_challenge,
 *						CUserDataListContainer  *user_data_list,
 *						GCCResult				result);
 *
 *	Public Function Description:
 *		This routine is used to send a join response back to a node that is
 *		joining through an intermediate nodes.
 *
 *	Formal Parameters:
 *		receiver_id			-	(i)	This is the intermediate node id that made 
 *									the request to the top provider.
 *		password_is_in_the_clear(i)	Flag indicating password in the clear
 *									status of the conference.
 *		conference_locked	-	(i)	Lock state of the conference.
 *		conference_listed	-	(i)	Listed state of the conference.
 *		termination_method	-	(i)	Termination method of the conference.
 *		password_challenge	-	(i)	Password challenge to pass back to the
 *									joining node.
 *		user_data_list		-	(i)	User data to pass back to the joining node.
 *									request.
 *		result				-	(i)	The result of the join request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError SendConferenceLockRequest()
 *
 *	Public Function Description:
 *		This routine is used to issue a conference lock request to the
 *		top provider.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError SendConferenceLockResponse(
 *									UserID		source_node,
 *									GCCResult	result)
 *
 *	Public Function Description:
 *		This routine is used to issue the conference lock response back to the
 *		original requester.
 *
 *	Formal Parameters:
 *		source_node		-	(i)	Node ID of node that made the original request.
 *		result			-	(i)	Result of the lock request.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError SendConferenceUnlockRequest()
 *
 *	Public Function Description:
 *		This routine is used to issue a conference unlock request to the
 *		top provider.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError SendConferenceUnlockResponse(
 *									UserID		source_node,
 *									GCCResult	result)
 *
 *	Public Function Description:
 *		This routine is used to issue the conference lock response back to the
 *		original requester.
 *
 *	Formal Parameters:
 *		source_node		-	(i)	Node ID of node that made the original request.
 *		result			-	(i)	Result of the lock request.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError SendConferenceLockIndication(
 *									BOOL    	uniform_send,
 *									UserID		source_node)
 *
 *	Public Function Description:
 *		This routine is used by the Top Provider to issue a conference lock 
 *		indication to either everyone in the conference or to a specific node.
 *
 *	Formal Parameters:
 *		uniform_send		-	(i)	Flag indicating whether this indication 
 *									should be sent to everyone or to a
 *									specific node (TRUE for everyone).
 *		source_node			-	(i)	Specific node to send it to.  uniform_send
 *									must equal FALSE to use this.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError SendConferenceUnlockIndication(
 *									BOOL    	uniform_send,
 *									UserID		source_node)
 *
 *	Public Function Description:
 *		This routine is used by the Top Provider to issue a conference unlock 
 *		indication to either everyone in the conference or to a specific node.
 *
 *	Formal Parameters:
 *		uniform_send		-	(i)	Flag indicating whether this indication 
 *									should be sent to everyone or to a
 *									specific node (TRUE for everyone).
 *		source_node			-	(i)	Specific node to send it to.  uniform_send
 *									must equal FALSE to use this.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void		ConferenceTerminateRequest(
 *						GCCReason				reason)
 *
 *	Public Function Description:
 *		This routine is used by a node subordinate to the top provider to 
 *		request that the conference by terminated.
 *
 *	Formal Parameters:
 *		reason		-	(i)	Reason for the terminate.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void		ConferenceTerminateResponse (	
 *						UserID					requester_id,
 *						GCCResult				result)
 *
 *	Public Function Description:
 *		This routine is used by the top provider to respond to a terminate
 *		request issued by a subordinate node.  The result indicates if the
 *		requesting node had the correct privileges.
 *
 *	Formal Parameters:
 *		requester_id	-	(i)	Node ID of node to send the response back to.
 *		result			-	(i)	Result of terminate request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void		ConferenceTerminateIndication (
 *							GCCReason				reason)
 *
 *	Public Function Description:
 *		This routine is used by the top provider to send out a terminate 
 *		indication to every node in the conference.
 *
 *	Formal Parameters:
 *		reason		-	(i)	Reason for the terminate.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	EjectNodeFromConference (	
 *						UserID					ejected_node_id,
 *						GCCReason				reason)
 *
 *	Public Function Description:
 *		This routine is used when attempting to eject a node from the
 *		conference.
 *
 *	Formal Parameters:
 *		ejected_node_id	-	(i)	Node ID of node to eject.
 *		reason			-	(i)	Reason for node being ejected.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	SendEjectNodeResponse (	
 *						UserID					requester_id,
 *						UserID					node_to_eject,
 *						GCCResult				result)
 *
 *	Public Function Description:
 *		This routine is used by the top provider to respond to an eject
 *		user request.
 *
 *	Formal Parameters:
 *		requester_id	-	(i)	Node ID of node that requested the eject.
 *		node_to_eject	-	(i)	Node that was requested to eject.
 *		result			-	(i)	Result of the eject request.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	RosterUpdateIndication (
 *						PGCCPDU					gcc_pdu,
 *						BOOL    				send_update_upward)
 *
 *	Public Function Description:
 *		This routine is used to forward a roster update indication either
 *		upward to the parent node or downward as a full refresh to all nodes
 *		in the conference.
 *
 *	Formal Parameters:
 *		gcc_pdu				-	(i)	Pointer to the roster update PDU structure 
 *									to send.
 *		send_update_upward	-	(i)	Flag indicating if this indication should
 *									be sent upward to the parent node or
 *									downward to all nodes (TRUE is upward).
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	RegistryRegisterChannelRequest (
 *						CRegKeyContainer        *registry_key_data,
 *						ChannelID				channel_id,
 *						EntityID				entity_id)
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to register a channel in
 *		the application registry.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i)	Registry key associated with the channel
 *									to register.
 *		channel_id			-	(i)	Channel ID to add to the registry.
 *		entity_id			-	(i)	Entity ID associated with the APE that is
 *									registering the channel.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	RegistryAssignTokenRequest (
 *						CRegKeyContainer        *registry_key_data,
 *						EntityID				entity_id)
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to register a token in
 *		the application registry.  Note that there is no token ID included in
 *		this request.  The token ID is allocated at the top provider.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i)	Registry key associated with the token
 *									to register.
 *		entity_id			-	(i)	Entity ID associated with the APE that is
 *									registering the token.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	RegistrySetParameterRequest (
 *						CRegKeyContainer        *registry_key_data,
 *						LPOSTR      			parameter_value,
 *						GCCModificationRights	modification_rights,
 *						EntityID				entity_id);
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to register a parameter in
 *		the application registry.  Note that parameter to be registered is
 *		included in this request.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i)	Registry key associated with the parameter
 *									to register.
 *		parameter_value		-	(i)	The parameter string to register.
 *		modification_rights	-	(i)	The modification rights associated with the
 *									parameter being registered.
 *		entity_id			-	(i)	Entity ID associated with the APE that is
 *									registering the parameter.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	RegistryRetrieveEntryRequest (
 *						CRegKeyContainer        *registry_key_data,
 *						EntityID				entity_id)
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to retrieve an registry item
 *		from the registry.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i)	Registry key associated with the registry
 *									entry to retrieve.
 *		entity_id			-	(i)	Entity ID associated with the APE that is
 *									requesting the registry entry.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	RegistryDeleteEntryRequest (
 *						CRegKeyContainer   	    *registry_key_data,
 *						EntityID				entity_id)
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to delete a registry item
 *		from the registry.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i)	Registry key associated with the registry
 *									entry to delete.
 *		entity_id			-	(i)	Entity ID associated with the APE that is
 *									making the delete request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	RegistryMonitorRequest (	
 *						CRegKeyContainer        *registry_key_data,
 *						EntityID				entity_id)
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to monitor a registry item
 *		in the registry.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i)	Registry key associated with the registry
 *									entry to monitor.
 *		entity_id			-	(i)	Entity ID associated with the APE that is
 *									making the monitor request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	RegistryAllocateHandleRequest ( 	
 *  						USHORT					number_of_handles, 
 *  						EntityID				entity_id )
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to allocate a number of
 *		handles from the application registry.
 *
 *	Formal Parameters:
 *		number_of_handles	-	(i)	Number of handles to allocate.
 *		entity_id			-	(i)	Entity ID associated with the APE that is
 *									making the request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	RegistryAllocateHandleResponse (
 *						USHORT					number_of_handles,
 *						UINT					registry_handle,
 *						EntityID				requester_entity_id,
 *						UserID					requester_node_id,
 *						GCCResult				result)
 *
 *	Public Function Description:
 *		This routine is used by the Top Provider to respond to an allocate
 *		handle request from an APE at a remote node.  The allocated handles
 *		are passed back here.
 *
 *	Formal Parameters:
 *		number_of_handles	-	(i)	Number of handles allocated.
 *		registry_handle		-	(i)	The first handle in the list of contiguously
 *									allocated handles.
 *		requester_entity_id	-	(i)	Entity ID associated with the APE that made
 *									the request.
 *		requester_node_id	-	(i)	Node ID of node that made the request.
 *		result				-	(i)	Result of the request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	RegistryResponse (
 *						RegistryResponsePrimitiveType	primitive_type,
 *						UserID							requester_owner_id,
 *						EntityID						requester_entity_id,
 *						CRegKeyContainer	            *registry_key_data,
 *						CRegItem                        *registry_item_data,
 *						GCCModificationRights			modification_rights,
 *						UserID							entry_owner_id,
 *						EntityID						entry_entity_id,
 *						GCCResult						result)
 *
 *	Public Function Description:
 *		This routine is used to respond to all the registry request except
 *		allocate handle.  It formulates the response PDU and queues it for
 *		delivery.
 *
 *	Formal Parameters:
 *		primitive_type		-	(i)	This is the type of response being issued.
 *									(i.e. register channel response, register
 *									token response, etc.).
 *		requester_owner_id	-	(i)	Node ID of APE making the original request.
 *		requester_entity_id	-	(i)	Entity ID of APE making the original
 *									request.
 *		registry_key_data	-	(i)	Registry key associated with registry 
 *									entry info being included in the response.
 *		registry_item_data	-	(i)	Registry item data associated with registry 
 *									entry info being included in the response.
 *		modification_rights	-	(i)	Modification rights associated with registry 
 *									entry info being included in the response.
 *		entry_owner_id		-	(i)	Node ID associated with registry entry
 *									info being included in the response.
 *		entry_entity_id		-	(i)	APE Entity ID associated with registry entry
 *									info being included in the response.
 *		result				-	(i)	Result to be sent back in the response.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	RegistryMonitorEntryIndication ( 	
 *						CRegKeyContainer                *registry_key_data,
 *						CRegItem                        *registry_item,
 *						UserID							entry_owner_id,
 *						EntityID						entry_entity_id,
 *						GCCModificationRights			modification_rights)
 *
 *	Public Function Description:
 *		This routine is used by the top provider to issue a monitor
 *		indication anytime a registry entry that is being monitored changes.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i)	Registry key associated with registry 
 *									entry being monitored.
 *		registry_item		-	(i)	Registry item data associated with registry 
 *									entry being monitored.
 *		entry_owner_id		-	(i)	Node ID associated with registry entry
 *									info being monitored.
 *		entry_entity_id		-	(i)	APE Entity ID associated with registry entry
 *									info being monitored.
 *		modification_rights	-	(i)	Modification rights associated with registry 
 *									entry info being monitored.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError 	AppInvokeIndication(
 *						CInvokeSpecifierListContainer *invoke_specifier_list,
 *						USHORT						number_of_destination_nodes,
 *						UserID			*			list_of_destination_nodes)
 *
 *	Public Function Description:
 *		This routine is used to send an application invoke indication to
 *		every node in the conference.
 *
 *	Formal Parameters:
 *		invoke_specifier_list		-	(i)	List of applications to invoke. 
 *		number_of_destination_nodes	-	(i)	Number of nodes in the destination
 *											node list.
 *		list_of_destination_nodes	-	(i)	List of nodes that should process
 *											invoke indication. 
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError 	TextMessageIndication (
 *						LPWSTR						pwszTextMsg,
 *						UserID						destination_node )
 *
 *	Public Function Description:
 *		This routine is used to send a text message to either a specific node
 *		or to every node in the conference.
 *
 *	Formal Parameters:
 *		pwszTextMsg			-	(i)	Text message string to send.
 *		destination_node	-	(i)	Node to receive the text message.  If zero
 *									the text message is sent to every node in 
 *									the conference.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConferenceAssistanceIndication (
 *						USHORT						number_of_user_data_members,
 *						PGCCUserData		*		user_data_list)
 *
 *	Public Function Description:
 *		This routine is used to send a conference assistance indication to
 *		every node in the conference.
 *
 *	Formal Parameters:
 *		number_of_user_data_members	-	(i)	Number of entries in the user data
 *											list passed into this routine.
 *		user_data_list				-	(i)	This list holds pointers to the
 *											user data to send out in the
 *											indication.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConferenceTransferRequest (
 *						PGCCConferenceName		destination_conference_name,
 *						GCCNumericString		destination_conference_modifier,
 *						CNetAddrListContainer   *destination_address_list,
 *						USHORT					number_of_destination_nodes,
 *						PUserID					destination_node_list,
 *						CPassword               *password);
 *
 *	Public Function Description:
 *		This routine is used to send a conference transfer request to the
 *		top provider in the conference.
 *
 *	Formal Parameters:
 *		destination_conference_name	-	(i)	The conference name to transfer to.
 *		destination_conference_modifier (i)	The conference modifier to 
 *											transfer to.
 *		destination_address_list	-	(i)	Network address list used to
 *											determine address of node to 
 *											transfer to.
 *		number_of_destination_nodes	-	(i)	Number of nodes in the list
 *											of nodes that should transfer.
 *		destination_node_list		-	(i)	List of node IDs that should perform
 *											the transfer.
 *		password					-	(i)	Password to use to join the
 *											new conference.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConferenceTransferIndication (
 *						PGCCConferenceName		destination_conference_name,
 *						GCCNumericString		destination_conference_modifier,
 *						CNetAddrListContainer   *destination_address_list,
 *						USHORT					number_of_destination_nodes,
 *						PUserID					destination_node_list,
 *						CPassword               *password)
 *
 *	Public Function Description:
 *		This routine is used by the top provider to send out the transfer
 *		indication to every node in the conference.  It is each nodes
 *		responsiblity to search the destination node list to see if
 *		it should transfer.
 *
 *	Formal Parameters:
 *		destination_conference_name	-	(i)	The conference name to transfer to.
 *		destination_conference_modifier (i)	The conference modifier to 
 *											transfer to.
 *		destination_address_list	-	(i)	Network address list used to
 *											determine address of node to 
 *											transfer to.
 *		number_of_destination_nodes	-	(i)	Number of nodes in the list
 *											of nodes that should transfer.
 *		destination_node_list		-	(i)	List of node IDs that should perform
 *											the transfer.
 *		password					-	(i)	Password to use to join the
 *											new conference.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConferenceTransferResponse (
 *						UserID					requesting_node_id,
 *						PGCCConferenceName		destination_conference_name,
 *						GCCNumericString		destination_conference_modifier,
 *						USHORT					number_of_destination_nodes,
 *						PUserID					destination_node_list,
 *						GCCResult				result)
 *																		     
 *
 *	Public Function Description:
 *		This routine is used by the top provider to send back a response to
 *		the node that made a transfer request.  The info specified in the
 *		request is included in the response to match request to response.
 *
 *	Formal Parameters:
 *		requesting_node_id			-	(i)	The node ID of the node that made
 *											the original transfer request.
 *		destination_conference_name	-	(i)	The conference name to transfer to.
 *		destination_conference_modifier (i)	The conference modifier to 
 *											transfer to.
 *		number_of_destination_nodes	-	(i)	Number of nodes in the list
 *											of nodes that should transfer.
 *		destination_node_list		-	(i)	List of node IDs that should perform
 *											the transfer.
 *		result						-	(i)	Result of the transfer request.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConferenceAddRequest(
 *						TagNumber				conference_add_tag,
 *						UserID					requesting_node,
 *						UserID					adding_node,
 *						UserID					target_node,
 *						CNetAddrListContainer   *network_address_container,
 *						CUserDataListContainer  *user_data_container)
 *																		     
 *
 *	Public Function Description:
 *		This routine is used to send a conference add request to the appropriate
 *		node.  This call can be made by the requesting node or by the top
 *		provider to pass the add request on to the adding node.
 *
 *	Formal Parameters:
 *		conference_add_tag			-	(i)	Tag that is returned in the
 *											response to match request and
 *											response.
 *		requesting_node				-	(i)	Node ID of node that made the
 *											original request.
 *		adding_node					-	(i)	Node ID of node that is to do
 *											the invite request to the new node.
 *		target_node					-	(i)	Node ID of node that this request
 *											should be sent to.
 *		network_address_container	-	(i)	Network address list that can be
 *											used when inviting the new node.
 *		user_data_container			-	(i)	User data to pass on to the
 *											adding node.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConferenceAddResponse(
 *						TagNumber				add_request_tag,
 *						UserID					requesting_node,
 *						CUserDataListContainer  *user_data_container,
 *						GCCResult				result)
 *																		     
 *	Public Function Description:
 *		This routine is used to send a conference add request to the appropriate
 *		node.  This call can be made by the requesting node or by the top
 *		provider to pass the add request on to the adding node.
 *
 *	Formal Parameters:
 *		add_request_tag		-	(i)	Tag number that was specified in the
 *									original add request.
 *		requesting_node		-	(i)	Node ID of node that made the original 
 *									request.
 *		user_data_container	-	(i)	User data to pass back to the requesting 
 *									node.
 *		result				-	(i)	Final result of the add request.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConductorTokenGrab();
 *																		     
 *	Public Function Description:
 *		This routine makes the MCS calls to grab the conductor token.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConductorTokenRelease();
 *																		     
 *	Public Function Description:
 *		This routine makes the MCS calls to release the conductor token.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR	-	No error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConductorTokenPlease();
 *																		     
 *	Public Function Description:
 *		This routine makes the MCS calls to request the conductor token from
 *		the current conductor.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR	-	No error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConductorTokenGive (
 *						UserID					recipient_user_id)
 *																		     
 *	Public Function Description:
 *		This routine makes the MCS calls to give the conductor token to the
 *		specified node.
 *
 *	Formal Parameters:
 *		recipient_user_id	-	(i)	Node ID of node to give the token to.
 *
 *	Return Value
 *		GCC_NO_ERROR	-	No error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConductorTokenGiveResponse(
 *  						Result					result)
 *																		     
 *	Public Function Description:
 *		This routine makes the MCS calls to respond to a conductor give
 *		request.
 *
 *	Formal Parameters:
 *		result	-	(i)	Did this node accept the token or not?
 *
 *	Return Value
 *		GCC_NO_ERROR	-	No error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConductorTokenTest()
 *																		     
 *	Public Function Description:
 *		This routine is used to test the current state of the conductor token
 *		(is it grabbed or not).
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR	-	No error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	SendConductorAssignIndication(
 *  						UserID					conductor_user_id)
 *																		     
 *	Public Function Description:
 *		This routine sends a conductor assign indication to all the
 *		nodes in the conference.
 *
 *	Formal Parameters:
 *		conductor_user_id	-	(i)	The Node ID of the new Conductor.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	SendConductorReleaseIndication()
 *																		     
 *	Public Function Description:
 *		This routine sends a conductor release indication to all the
 *		nodes in the conference.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	SendConductorPermitAsk (
 *						BOOL    				grant_permission)
 *																		     
 *	Public Function Description:
 *		This routine sends a conductor permission ask request directly to the
 *		conductor node.
 *
 *	Formal Parameters:
 *		grant_permission	-	(i)	The flag indicates if permission is
 *									being requested or given up.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	SendConductorPermitGrant (
 *						USHORT					number_granted,
 *						PUserID					granted_node_list,
 *						USHORT					number_waiting,
 *						PUserID					waiting_node_list)
 *																		     
 *	Public Function Description:
 *		This routine sends a conductor permission grant indication to every
 *		node in the conference.  Usually issued when permissions change.
 *
 *	Formal Parameters:
 *		number_granted		-	(i)	Number of nodes in the permission granted 
 *									list.
 *		granted_node_list	-	(i)	List of nodes that have been granted 
 *									permission.
 *		number_waiting		-	(i)	Number of nodes in the list of nodes
 *									waiting to be granted permission.
 *		waiting_node_list	-	(i)	List of nodes waiting. 
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	TimeRemainingRequest (
 *						UINT					time_remaining,
 *						UserID					node_id)
 *																		     
 *	Public Function Description:
 *		This routine sends out an indication to every node in the
 *		conference informing how much time is remaining in the conference.
 *
 *	Formal Parameters:
 *		time_remaining	-	(i)	Time in seconds left in the conference.
 *		node_id			-	(i)	If a value other than zero, it is which node
 *								to send the time remaining indication to.  If
 *								zero send it to every node in the conference.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	TimeInquireRequest (
 *						BOOL    				time_is_conference_wide)
 *																		     
 *	Public Function Description:
 *		This routine sends out a request for a time remaing update.
 *
 *	Formal Parameters:
 *		time_is_conference_wide	-	(i)	Flag indicating if the request is
 *										for the time conference wide.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConferenceExtendIndication (
 *						UINT					extension_time,
 *						BOOL    				time_is_conference_wide)
 *
 *																		     
 *	Public Function Description:
 *		This routine sends out an indication informing conference participants
 *		of an extension.
 *
 *	Formal Parameters:
 *		extension_time			-	(i)	Amount of time that the conference is
 *										extended.
 *		time_is_conference_wide	-	(i)	Flag indicating if the extension time 
 *										is conference wide.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	ULONG		OwnerCallback (		UINT				message,
 *									PVoid				parameter1,
 *									ULONG				parameter2);
 *
 *	Public Function Description
 *		This function overides the base class function and is used to
 *		receive all owner callback information from the MCS Interface object.
 *
 *	Formal Parameters:
 *		message		-		(i)	Message number including base offset.
 *		parameter1	-		(i)	void pointer of message data.
 *		parameter2	-		(i)	Long holding message data.		
 *
 *	Return Value
 *		GCC_NO_ERROR is always returned from this.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL    		FlushOutgoingPDU();
 *
 *	Public Function Description
 *		This function gives the user object a chance to flush all the PDUs
 *		queued up for delivery.  GCC PDUs are only delivered during this call.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		TRUE, if there remain un-processed msgs in the MCS message queue
 *		FALSE, if all the msgs in the MCS msg queue were processed.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCNodeID		GetMyNodeID()
 *
 *	Public Function Description
 *		This function returns the Node ID for this node.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		This nodes Node ID.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCNodeID		GetTopNodeID ()
 *
 *	Public Function Description
 *		This function returns the Top Provider's Node ID.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		The Top Providers node ID.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCNodeID		GetParentNodeID ()
 *
 *	Public Function Description
 *		This function returns the Node ID of this nodes Parent Node.
 *		It returns zero if this is the top provider.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		The Parent Node ID or zero if Top Provider.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	UserID		GetUserIDFromConnection(
 *						ConnectionHandle		connection_handle)
 *
 *	Public Function Description
 *		This function returns the Node ID associated with the specified
 *		connection handle.  It returns zero if the connection handle is
 *		not a child connection of this node.
 *
 *	Formal Parameters:
 *		connection_handle	-	(i)	Connection Handle to search on.
 *
 *	Return Value
 *		The Node ID associated with the passed in connection handle or
 *		ZERO if connection is not a child connection.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void		UserDisconnectIndication (
 *						UserID					disconnected_user)
 *
 *	Public Function Description
 *		This function informs the user object when a Node disconnects from
 *		the conference.  This gives the user object a chance to clean up
 *		its internal information base.
 *
 *	Formal Parameters:
 *		disconnected_user	-	(i)	User ID of user that disconnected.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

#endif // _MCS_USER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\mportmsg.h ===
/*
 *	mportmsg.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *
 *	Portable:
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	_LISTEN_MCS_PORTAL_MESSAGE_
#define	_LISTEN_MCS_PORTAL_MESSAGE_

#define	LISTEN_PORTAL_NAME				"MCS Listen Portal"
#define	USER_PORTAL_NAME				"MCS User Portal"

#define	LISTEN_CREATE_PORTAL_REQUEST	0
#define	LISTEN_CREATE_PORTAL_CONFIRM	1

#define	LISTEN_NO_ERROR					0
#define	LISTEN_CREATE_FAILED			1

#define	USER_PORTAL_NAME_LENGTH			32

/*
 *	The following type defines a container that is used to map domain selectors to
 *	portal memory addresses.  This is necessary to find the right in-process
 *	MCS portal for each domain.
 */
typedef struct
{
} LPCreatePortalRequest;

typedef struct
{
	ULong			return_value;
	unsigned int	portal_id;
} LPCreatePortalConfirm;

typedef struct
{
} LPClosePortalRequest;

typedef	struct
{
	unsigned int			message_type;
	union
	{
		LPCreatePortalRequest		create_portal_request;
		LPCreatePortalConfirm		create_portal_confirm;
	} u;
} ListenPortalMessage;
typedef	ListenPortalMessage *		PListenPortalMessage;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\mpdutype.h ===
/*
 *	mpdutype.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This file is used to convert from the ASN.1 generated types into types
 *		compliant with the DataBeam coding standard.
 *
 *	Author:
 *		
 *
 *	Caveats:
 *		none
 */

#ifndef	_MCS_PDU_TYPES_
#define	_MCS_PDU_TYPES_

#include "mcspdu.h"

/*
 *	PDU types
 */
#define CONNECT_MCS_PDU   					ConnectMCSPDU_PDU
#define DOMAIN_MCS_PDU    					DomainMCSPDU_PDU
#define DATA_MCS_PDU						(DOMAIN_MCS_PDU + CONNECT_MCS_PDU + 1)

/*
 * Segmentation bits.
 */
#define BEGIN								begin
#define END									end

/*
 *	Typedef for Octet Strings.
 */
typedef	struct	_octet1						OctetString;

/*
 *	PDUChannelAttributes and ChannelIDs
 */
#define CHANNEL_ATTRIBUTES_STATIC_CHOSEN	channel_attributes_static_chosen
#define CHANNEL_ATTRIBUTES_USER_ID_CHOSEN	channel_attributes_user_id_chosen
#define CHANNEL_ATTRIBUTES_PRIVATE_CHOSEN	channel_attributes_private_chosen
#define CHANNEL_ATTRIBUTES_ASSIGNED_CHOSEN	channel_attributes_assigned_chosen

/*
 *	PDUTokenAttributes and TokenIDs
 */
#define GRABBED_CHOSEN			grabbed_chosen
#define INHIBITED_CHOSEN		inhibited_chosen
#define GIVING_CHOSEN			giving_chosen
#define UNGIVABLE_CHOSEN		ungivable_chosen
#define GIVEN_CHOSEN			given_chosen

/*
 * Diagnostics
 */
#define DC_INCONSISTENT_MERGE			dc_inconsistent_merge
#define DC_FORBIDDEN_PDU_DOWNWARD		dc_forbidden_pdu_downward
#define DC_FORBIDDEN_PDU_UPWARD			dc_forbidden_pdu_upward
#define DC_INVALID_BER_ENCODING			dc_invalid_ber_encoding
#define DC_INVALID_PER_ENCODING			dc_invalid_per_encoding
#define DC_MISROUTED_USER				dc_misrouted_user
#define DC_UNREQUESTED_CONFIRM			dc_unrequested_confirm
#define DC_WRONG_TRANSPORT_PRIORITY		dc_wrong_transport_priority
#define DC_CHANNEL_ID_CONFLICT			dc_channel_id_conflict
#define DC_TOKEN_ID_CONFLICT			dc_token_id_conflict
#define DC_NOT_USER_ID_CHANNEL			dc_not_user_id_channel
#define DC_TOO_MANY_CHANNELS			dc_too_many_channels
#define DC_TOO_MANY_TOKENS				dc_too_many_tokens
#define DC_TOO_MANY_USERS				dc_too_many_users

/*
 * AttachUserConfirmPDU
 */
#define INITIATOR_PRESENT		initiator_present

/*
 * ChannelJoinConfirmPDU
 */
#define JOIN_CHANNEL_ID_PRESENT		join_channel_id_present

/*
 * ChannelConveneConfirmPDU
 */
#define CONVENE_CHANNEL_ID_PRESENT		convene_channel_id_present

/*
 * ConnectMCSPDU
 */
#define CONNECT_INITIAL_CHOSEN			connect_initial_chosen
#define CONNECT_RESPONSE_CHOSEN			connect_response_chosen
#define CONNECT_ADDITIONAL_CHOSEN		connect_additional_chosen
#define CONNECT_RESULT_CHOSEN			connect_result_chosen

/*
 * DomainMCSPDU
 */
#define PLUMB_DOMAIN_INDICATION_CHOSEN	plumb_domain_indication_chosen
#define ERECT_DOMAIN_REQUEST_CHOSEN		erect_domain_request_chosen
#define MERGE_CHANNELS_REQUEST_CHOSEN	merge_channels_request_chosen
#define MERGE_CHANNELS_CONFIRM_CHOSEN	merge_channels_confirm_chosen
#define PURGE_CHANNEL_INDICATION_CHOSEN	purge_channel_indication_chosen
#define MERGE_TOKENS_REQUEST_CHOSEN		merge_tokens_request_chosen
#define MERGE_TOKENS_CONFIRM_CHOSEN		merge_tokens_confirm_chosen
#define PURGE_TOKEN_INDICATION_CHOSEN	purge_token_indication_chosen
#define DISCONNECT_PROVIDER_ULTIMATUM_CHOSEN disconnect_provider_ultimatum_chosen
#define REJECT_ULTIMATUM_CHOSEN			reject_user_ultimatum_chosen
#define ATTACH_USER_REQUEST_CHOSEN		attach_user_request_chosen
#define ATTACH_USER_CONFIRM_CHOSEN		attach_user_confirm_chosen
#define DETACH_USER_REQUEST_CHOSEN		detach_user_request_chosen
#define DETACH_USER_INDICATION_CHOSEN	detach_user_indication_chosen
#define CHANNEL_JOIN_REQUEST_CHOSEN		channel_join_request_chosen
#define CHANNEL_JOIN_CONFIRM_CHOSEN		channel_join_confirm_chosen
#define CHANNEL_LEAVE_REQUEST_CHOSEN	channel_leave_request_chosen
#define CHANNEL_CONVENE_REQUEST_CHOSEN	channel_convene_request_chosen
#define CHANNEL_CONVENE_CONFIRM_CHOSEN	channel_convene_confirm_chosen
#define CHANNEL_DISBAND_REQUEST_CHOSEN	channel_disband_request_chosen
#define CHANNEL_DISBAND_INDICATION_CHOSEN channel_disband_indication_chosen
#define CHANNEL_ADMIT_REQUEST_CHOSEN	channel_admit_request_chosen
#define CHANNEL_ADMIT_INDICATION_CHOSEN	channel_admit_indication_chosen
#define CHANNEL_EXPEL_REQUEST_CHOSEN	channel_expel_request_chosen
#define CHANNEL_EXPEL_INDICATION_CHOSEN	channel_expel_indication_chosen
#define SEND_DATA_REQUEST_CHOSEN		send_data_request_chosen
#define SEND_DATA_INDICATION_CHOSEN		send_data_indication_chosen
#define UNIFORM_SEND_DATA_REQUEST_CHOSEN uniform_send_data_request_chosen
#define UNIFORM_SEND_DATA_INDICATION_CHOSEN	uniform_send_data_indication_chosen
#define TOKEN_GRAB_REQUEST_CHOSEN		token_grab_request_chosen
#define TOKEN_GRAB_CONFIRM_CHOSEN		token_grab_confirm_chosen
#define TOKEN_INHIBIT_REQUEST_CHOSEN	token_inhibit_request_chosen
#define TOKEN_INHIBIT_CONFIRM_CHOSEN	token_inhibit_confirm_chosen
#define TOKEN_GIVE_REQUEST_CHOSEN		token_give_request_chosen
#define TOKEN_GIVE_INDICATION_CHOSEN	token_give_indication_chosen
#define TOKEN_GIVE_RESPONSE_CHOSEN		token_give_response_chosen
#define TOKEN_GIVE_CONFIRM_CHOSEN		token_give_confirm_chosen
#define TOKEN_PLEASE_REQUEST_CHOSEN		token_please_request_chosen
#define TOKEN_PLEASE_INDICATION_CHOSEN	token_please_indication_chosen
#define TOKEN_RELEASE_REQUEST_CHOSEN	token_release_request_chosen
#define TOKEN_RELEASE_CONFIRM_CHOSEN	token_release_confirm_chosen
#define TOKEN_TEST_REQUEST_CHOSEN		token_test_request_chosen
#define TOKEN_TEST_CONFIRM_CHOSEN		token_test_confirm_chosen

/*
 * Pointer typedefs
 */
typedef ConnectInitialPDU * 				PConnectInitialPDU;
typedef ConnectResponsePDU * 				PConnectResponsePDU;
typedef ConnectAdditionalPDU * 				PConnectAdditionalPDU;
typedef ConnectResultPDU * 					PConnectResultPDU;
typedef PlumbDomainIndicationPDU * 			PPlumbDomainIndicationPDU;
typedef ErectDomainRequestPDU * 			PErectDomainRequestPDU;
typedef MergeChannelsRequestPDU *			PMergeChannelsRequestPDU;
typedef MergeChannelsConfirmPDU *			PMergeChannelsConfirmPDU;
typedef PurgeChannelIndicationPDU *			PPurgeChannelIndicationPDU;
typedef MergeTokensRequestPDU *				PMergeTokensRequestPDU;
typedef MergeTokensConfirmPDU *				PMergeTokensConfirmPDU;
typedef PurgeTokenIndicationPDU *			PPurgeTokenIndicationPDU;
typedef DisconnectProviderUltimatumPDU *	PDisconnectProviderUltimatumPDU;
typedef RejectUltimatumPDU *				PRejectUltimatumPDU;
typedef AttachUserRequestPDU *				PAttachUserRequestPDU;
typedef AttachUserConfirmPDU *				PAttachUserConfirmPDU;
typedef DetachUserRequestPDU *				PDetachUserRequestPDU;
typedef DetachUserIndicationPDU *			PDetachUserIndicationPDU;
typedef ChannelJoinRequestPDU *				PChannelJoinRequestPDU;
typedef ChannelJoinConfirmPDU *				PChannelJoinConfirmPDU;
typedef ChannelLeaveRequestPDU *			PChannelLeaveRequestPDU;
typedef ChannelConveneRequestPDU *			PChannelConveneRequestPDU;
typedef ChannelConveneConfirmPDU *			PChannelConveneConfirmPDU;
typedef ChannelDisbandRequestPDU *			PChannelDisbandRequestPDU;
typedef ChannelDisbandIndicationPDU *		PChannelDisbandIndicationPDU;
typedef ChannelAdmitRequestPDU *			PChannelAdmitRequestPDU;
typedef ChannelAdmitIndicationPDU *			PChannelAdmitIndicationPDU;
typedef ChannelExpelRequestPDU *			PChannelExpelRequestPDU;
typedef ChannelExpelIndicationPDU *			PChannelExpelIndicationPDU;
typedef SendDataRequestPDU *				PSendDataRequestPDU;
typedef SendDataIndicationPDU *				PSendDataIndicationPDU;
typedef UniformSendDataRequestPDU *			PUniformSendDataRequestPDU;
typedef UniformSendDataIndicationPDU *		PUniformSendDataIndicationPDU;
typedef TokenGrabRequestPDU *				PTokenGrabRequestPDU;
typedef TokenGrabConfirmPDU *				PTokenGrabConfirmPDU;
typedef TokenInhibitRequestPDU *			PTokenInhibitRequestPDU;
typedef TokenInhibitConfirmPDU *			PTokenInhibitConfirmPDU;
typedef TokenGiveRequestPDU *				PTokenGiveRequestPDU;
typedef TokenGiveIndicationPDU *			PTokenGiveIndicationPDU;
typedef TokenGiveResponsePDU *				PTokenGiveResponsePDU;
typedef TokenGiveConfirmPDU *				PTokenGiveConfirmPDU;
typedef TokenPleaseRequestPDU *				PTokenPleaseRequestPDU;
typedef TokenPleaseIndicationPDU *			PTokenPleaseIndicationPDU;
typedef TokenReleaseRequestPDU *			PTokenReleaseRequestPDU;
typedef TokenReleaseConfirmPDU *			PTokenReleaseConfirmPDU;
typedef TokenTestRequestPDU *				PTokenTestRequestPDU;
typedef TokenTestConfirmPDU *				PTokenTestConfirmPDU;

typedef ConnectMCSPDU 	*	PConnectMCSPDU;
typedef DomainMCSPDU 	*	PDomainMCSPDU;

/*
 *	Typedefs for other PDU structures.
 */
typedef PDUDomainParameters *				PPDUDomainParameters;
typedef	Diagnostic *						PDiagnostic;

typedef	struct	SetOfUserIDs				SetOfUserIDs;

typedef	struct	SetOfPDUChannelAttributes	SetOfPDUChannelAttributes;
typedef PDUChannelAttributes * 				PPDUChannelAttributes;

typedef struct	SetOfChannelIDs			    SetOfChannelIDs;

typedef struct	SetOfPDUTokenAttributes	    SetOfPDUTokenAttributes;
typedef PDUTokenAttributes * 				PPDUTokenAttributes;

typedef struct	SetOfTokenIDs				SetOfTokenIDs;

/*
 *	MAXIMUM_PROTOCOL_OVERHEAD
 *		This is used to calculate the maximum size of the user data field within
 *		a send data PDU.  This will be set to the maximum PDU size as set in
 *		the domain parameters, minus this number to allow for protocol overhead.
 *		This number MUST be large enough to handle the worst case overhead
 *		for ONLY the Packed Encoding Rules (PER).
 *		The max overhead consists of 2 parts: MAXIMUM_PROTOCOL_OVERHEAD_MCS
 *		is the max MCS overhead for a Send Data request while 
 *		PROTOCOL_OVERHEAD_X224 is the overhead imposed by X.224.
 *
 *	PROTOCOL_OVERHEAD_SECURITY
 *		This is the max overhead allowed for encryption/decryption of MCS data
 *		packets. That space should be enough for both the trailer and
 *		the header of an encrypted X.224 packet.
 */
#define PROTOCOL_OVERHEAD_SECURITY		64
#define	MAXIMUM_PROTOCOL_OVERHEAD_MCS	8
#define PROTOCOL_OVERHEAD_X224			sizeof(X224_DATA_PACKET)
#define	MAXIMUM_PROTOCOL_OVERHEAD		(MAXIMUM_PROTOCOL_OVERHEAD_MCS + PROTOCOL_OVERHEAD_X224)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\ms_util.h ===
#ifndef __MS_UTIL_H__
#define __MS_UTIL_H__

extern "C"
{
#include "t120.h"
}

//
// GUI message boxes kill us when we hit an assert or error, because they
// have a message pump that causes messages to get dispatched, making it
// very difficult for us to debug problems when they occur.  Therefore
// we redefine ERROR_OUT and ASSERT
//
#ifdef _DEBUG

__inline void MyDebugBreak(void) { DebugBreak(); }

#endif // _DEBUG




/*
 * Macro used to force values to four byte boundaries.  This macro will need to
 * be considered when portability issues arise.
 */
#define ROUNDTOBOUNDARY(num)	(((UINT)(num) + 0x03) & 0xfffffffcL)


// the following create a dword that will look like "abcd" in debugger
#ifdef SHIP_BUILD
#define MAKE_STAMP_ID(a,b,c,d)     
#else
#define MAKE_STAMP_ID(a,b,c,d)     MAKELONG(MAKEWORD(a,b),MAKEWORD(c,d))
#endif // SHIP_BUILD

class CRefCount
{
public:

#ifdef SHIP_BUILD
    CRefCount(void);
#else
    CRefCount(DWORD dwStampID);
#endif
    virtual ~CRefCount(void) = 0;

    LONG AddRef(void);
    LONG Release(void);

    void ReleaseNow(void);

protected:

    LONG GetRefCount(void) { return m_cRefs; }
    BOOL IsRefCountZero(void) { return (0 == m_cRefs); }

    LONG Lock(void);
    LONG Unlock(BOOL fRelease = TRUE);

    LONG GetLockCount(void) { return m_cLocks; }
    BOOL IsLocked(void) { return (0 == m_cLocks); }

private:

#ifndef SHIP_BUILD
    DWORD       m_dwStampID;// to remove before we ship it
#endif
    LONG        m_cRefs;    // reference count
    LONG        m_cLocks;   // lock count of the essential contents
};


extern HINSTANCE g_hDllInst;

__inline void My_CloseHandle(HANDLE hdl)
{
    if (NULL != hdl)
    {
        CloseHandle(hdl);
    }
}


#if defined(_DEBUG)
LPSTR _My_strdupA(LPCSTR pszSrc, LPSTR pszFileName, UINT nLineNumber);
LPWSTR _My_strdupW(LPCWSTR pszSrc, LPSTR pszFileName, UINT nLineNumber);
LPWSTR _My_strdupW2(UINT cchSrc, LPCWSTR pszSrc, LPSTR pszFileName, UINT nLineNumber);
LPOSTR _My_strdupO2(LPBYTE lpbSrc, UINT cOctets, LPSTR pszFileName, UINT nLineNumber);

#define My_strdupA(pszSrc) _My_strdupA(pszSrc, __FILE__, __LINE__)
#define My_strdupW(pszSrc) _My_strdupW(pszSrc, __FILE__, __LINE__)
#define My_strdupW2(cchSrc,pszSrc) _My_strdupW2(cchSrc, pszSrc, __FILE__, __LINE__)
#define My_strdupO2(lpbSrc,cOctets) _My_strdupO2(lpbSrc, cOctets, __FILE__, __LINE__)
#define My_strdupO(poszSrc) _My_strdupO2(poszSrc->value, poszSrc->length, __FILE__, __LINE__)
#else
LPSTR My_strdupA(LPCSTR pszSrc);
LPWSTR My_strdupW(LPCWSTR pszSrc);
LPWSTR My_strdupW2(UINT cchSrc, LPCWSTR pszSrc); // backward compatible to UnicodeString
LPOSTR My_strdupO2(LPBYTE lpbSrc, UINT cOctets);
__inline LPOSTR My_strdupO(LPOSTR poszSrc) { return My_strdupO2(poszSrc->value, poszSrc->length); }
#endif

UINT My_strlenA(LPCSTR pszSrc);
UINT My_strlenW(LPCWSTR pszSrc);
int My_strcmpW(LPCWSTR pwsz1, LPCWSTR pwsz2);

#ifdef _UNICODE
#define My_strdup			My_strdupW
#define My_strlen			My_strlenW
#define My_strcmp			My_strcmpW
#else
#define My_strdup			My_strdupA
#define My_strlen			My_strlenA
#define My_strcmp			lstrcmpA
#endif

INT My_strcmpO(LPOSTR posz1, LPOSTR posz2);



#endif // __MS_UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\ncmcs.h ===
/*
 *	ncmcs.h
 *
 *	Copyright (c) 1998 by Microsoft Corporation, Redmond, WA
 *
 *	Abstract:
 *		This file defines macros, types, and functions needed to use the Node Controller MCS 
 *		interface.
 *
 *		Basically, the Node Controller (GCC) requests services from MCS by making direct
 *		calls into the DLL (this includes T.122 requests and responses).  MCS
 *		sends information back to the application through a callback (this
 *		includes T.122 indications and confirms).  The callback for the node
 *		controller is specified in the call MCSInitialize.
 *
 *	Author:
 *		Christos Tsollis
 */
#ifndef	_NCMCS_
#define	_NCMCS_

#include "mcspdu.h"

/*
 *	The following structure is used to identify various parameters that apply
 *	only within a given domain.  This information is negotiated between the
 *	first two providers in the domain, and must be accepted by any others
 *	providers that attempt to connect to that domain.
 *
 *	Note that MCS allows up to 4 priorities of data transfer, all of which are
 *	supported by this implementation.
 */
#define	MAXIMUM_PRIORITIES		4
typedef PDUDomainParameters		DomainParameters;
typedef	DomainParameters  *		PDomainParameters;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\netaddr.h ===
/*
 *	netaddr.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the Network Address List class.  This  
 *		class manages the data associated with a network address.  Network
 *		addresses can be one of three types: aggregated channel, transport
 *		connection, or non-standard.  A variety of structures, objects, and
 *		Rogue Wave containers are used to buffer the network address data
 *		internally.
 *
 *	Caveats:
 *		A network address may contain an Object Key if it is a non-standard
 *		type.  When created locally with "API" data, checks are made to ensure
 *		that the constraints imposed upon Object Keys are not violated.  Checks
 *		are also performed to validate certain types of strings which may exist
 *		in a network address.  If however, a network address is created from 
 *		"PDU" data received from a remote site no such validation is performed.
 *		We are taking no responsibility for validation of data originated by
 *		other GCC providers.
 *
 *	Author:
 *		blp/jbo
 */
#ifndef	_NETWORK_ADDRESS_
#define	_NETWORK_ADDRESS_

#include "objkey.h"

/*
 * This structure holds network address information and data.
 */
typedef struct NET_ADDR
{
    NET_ADDR(void);
    ~NET_ADDR(void);

    GCCNetworkAddress	        network_address;
  
	// Variables associated with aggregated channels.
	LPSTR						pszSubAddress;
	LPWSTR						pwszExtraDialing;
    PGCCHighLayerCompatibility	high_layer_compatibility;

    // Variables associated with transport connection addresses.
	LPOSTR						poszTransportSelector;

    // Variables associated with non-standard network addresses.
	LPOSTR						poszNonStandardParam;
	CObjectKeyContainer 	    *object_key;
}
    NET_ADDR;


/*
 * This list is holds the network address information structures.
 */
class CNetAddrList : public CList
{
    DEFINE_CLIST(CNetAddrList, NET_ADDR*)
};


/*
 * Class definition:
 */
class CNetAddrListContainer : public CRefCount
{
public:

	CNetAddrListContainer(UINT cAddrs, PGCCNetworkAddress *, PGCCError);
	CNetAddrListContainer(PSetOfNetworkAddresses, PGCCError);
	CNetAddrListContainer(CNetAddrListContainer *, PGCCError);

    ~CNetAddrListContainer(void);

	UINT		LockNetworkAddressList(void);
	void		UnLockNetworkAddressList(void);

	UINT		GetNetworkAddressListAPI(UINT *pcAddrs, PGCCNetworkAddress **, LPBYTE pMemory);
	GCCError	GetNetworkAddressListPDU(PSetOfNetworkAddresses *);
	GCCError	FreeNetworkAddressListPDU(void);

protected:

	CNetAddrList    		    m_NetAddrItemList;
	UINT						m_cbDataSize;

    PSetOfNetworkAddresses		m_pSetOfNetAddrPDU;
	BOOL						m_fValidNetAddrPDU;

private:

	GCCError	StoreNetworkAddressList(UINT cAddrs, PGCCNetworkAddress *);
	GCCError	ConvertPDUDataToInternal(PSetOfNetworkAddresses);
	GCCError	ConvertNetworkAddressInfoToPDU(NET_ADDR *, PSetOfNetworkAddresses);
    void		ConvertTransferModesToInternal(PTransferModes pSrc, PGCCTransferModes pDst);
	void		ConvertHighLayerCompatibilityToInternal(PHighLayerCompatibility pSrc, PGCCHighLayerCompatibility pDst);
	void		ConvertTransferModesToPDU(PGCCTransferModes pSrc, PTransferModes pDst);
	void		ConvertHighLayerCompatibilityToPDU(PGCCHighLayerCompatibility pSrc,	PHighLayerCompatibility	pDst);

    BOOL		IsDialingStringValid(GCCDialingString);
	BOOL		IsCharacterStringValid(GCCCharacterString);
	BOOL		IsExtraDialingStringValid(PGCCExtraDialingString);
};

/*
 *	Comments explaining the public and protected class member functions
 */

/*
 *	CNetAddrListContainer (
 *		UINT       			number_of_network_addresses,
 *		PGCCNetworkAddress 	*	network_address_list,
 *		PGCCError				return_value);
 *
 *	Public member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This is the constructor for the CNetAddrListContainer class which takes as
 *		input the "API" version of network address data, GCCNetworkAddress.
 *
 *	Formal Parameters:
 *		number_of_network_addresses	(i) The number of addresses in the list.
 *		network_address_list		(i)	The network address data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_NETWORK_ADDRESS			-	Invalid network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	-	Bad "choice" field for address
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	CNetAddrListContainer (		
 *			PSetOfNetworkAddresses		network_address_list,
 *			PGCCError					return_value);
 *
 *	Public member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This is the constructor for the CNetAddrListContainer class which takes as
 *		input the "PDU" version of network address data, SetOfNetworkAddresses.
 *
 *	Formal Parameters:
 *		network_address_list	(i)	The network address data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	CNetAddrListContainer (		
 *				CNetAddrListContainer		*network_address_list,
 *				PGCCError		return_value);
 *
 *	Public member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This is the copy constructor for the CNetAddrListContainer class which
 *		takes as input another CNetAddrListContainer object.
 *
 *	Formal Parameters:
 *		network_address_list	(i)	The CNetAddrListContainer object to copy.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	~CNetAddrListContainer ();
 *
 *	Public member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This is the destructor for the CNetAddrListContainer class.  It is used to
 *		clean up any memory allocated during the life of this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	UINT	LockNetworkAddressList ();
 *
 *	Public member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to "lock" the "API" data for this object.  This
 *		results in the lock count for this object being incremented.  When the
 *		lock count transitions from 0 to 1, a calculation is made to determine
 *		how much memory will be needed to hold any "API" data which will
 *		be referenced by, but not held in, the list of GCCNetworkAddress 
 *		structures which is filled in on a call to GetNetworkAddressListAPI.  
 *		This is the	value returned by this routine in order to allow the calling
 *		object to allocate that amount of memory in preparation for the call to 
 *		GetNetworkAddressListAPI.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The amount of memory, if any, which will be needed to hold "API" data
 *		which is referenced by, but not held in, the list of GCCNetworkAddress
 *		structures provided as an output parameter to the 
 *		GetNetworkAddressListAPI call.
 *
 *  Side Effects:
 *		The internal lock count is incremented.
 *
 *	Caveats:
 *		The internal lock count is used in conjuction with an internal "free" 
 *		flag as a mechanism for ensuring that this object remains in existance 
 *		until all interested parties are through with it.  The object remains 
 *		valid (unless explicity deleted) until the lock count is zero and the 
 *		"free" flag is set through a call to FreeNetworkAddressList. This allows
 *		other objects to lock this object and be sure that it remains valid 
 *		until they call UnLock which will decrement the internal lock count.  A
 *		typical usage scenerio for this object would be:  A CNetAddrListContainer
 *		object is constructed and then passed off to any interested parties
 *		through a function call.  On return from the function call, the
 *		FreeNetworkAddressList call is made which will set the internal "free"
 *		flag.  If no other parties have locked the object with a Lock call,
 *		then the CNetAddrListContainer object will automatically delete itself when
 *		the FreeNetworkAddressList call is made.  If, however, any number of 
 *		other parties has locked the object, it will remain in existence until
 *		each of them has unlocked the object through a call to UnLock.
 */

/*
 *	UINT			GetNetworkAddressListAPI (	
 *							UINT *			number_of_network_addresses,
 *							PGCCNetworkAddress	**	network_address_list,
 *							LPSTR					memory);
 *
 *	Public member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the network address data from the
 *		CNetAddrListContainer object in the "API" form of a list of 
 *		GCCNetworkAddress structures.
 *
 *	Formal Parameters:
 *		number_of_network_addresses	(o) Number of addresses in returned list.
 *		network_address_list		(o)	The pointer to the list of
 *											GCCNetworkAddress structures 
 *											to fill in.
 *		memory						(o)	The memory used to hold any data 
 *											referenced by, but not held in, the 
 *											list of output structures.
 *
 *	Return Value:
 *		The amount of data, if any, written into the bulk memory block provided.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void		UnLockNetworkAddressList ();
 *
 *	Public member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine 
 *		whether the object has been freed through a call to 
 *		FreeNetworkAddressList.  If so, the object will automatically delete
 *		itself.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal lock count is decremented.
 *
 *	Caveats:
 *		It is the responsibility of any party which locks a CNetAddrListContainer
 *		object by calling Lock to also unlock the object with a call to UnLock.
 *		If the party calling UnLock did not construct the CNetAddrListContainer 
 *		object,	it should assume the object to be invalid thereafter.
 */


/*
 *	GCCError		GetNetworkAddressListPDU (	
 *						PSetOfNetworkAddresses	*	set_of_network_addresses);
 *
 *	Public member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the network address data from the
 *		CNetAddrListContainer object in the "PDU" form of a SetOfNetworkAddresses.
 *
 *	Formal Parameters:
 *		set_of_network_addresses	(o)	The address structure to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError		FreeNetworkAddressListPDU ();
 *
 *	Public member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to "free" the "PDU" data allocated for this object
 *		which is held internally in a SetOfNetworkAddresses structure.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *
 *  Side Effects:
 *		The internal "free" flag is set.
 *
 *	Caveats:
 *		This object should be assumed invalid after a call to 
 *		FreeNetworkAddressListPDU has been made.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\ogcccode.h ===
/*
 *	ogcccode.h
 *
 *	Copyright (c) 1994 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the CGCCCoder class.  This
 *		class is used to encode and decode GCC Protocol Data Units (PDU's)
 *		to and from ASN.1 compliant byte streams using the ASN.1 toolkit.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		John B. O'Nan
 *
 */
#ifndef	_CGCCCODER_
#define	_CGCCCODER_

#include "pktcoder.h"
#include "pdutypes.h"
#include "gccpdu.h"

/*
 * Macros
 */
#define		MAXIMUM_PDU_SIZE			512
#define		DECODED_ROSTER_PDU_SIZE		1024

#define		USER_ID_INDICATION				0x61
#define		CONFERENCE_CREATE_REQUEST		0x62
#define		CONFERENCE_CREATE_RESPONSE		0x63
#define		CONFERENCE_QUERY_REQUEST		0x64
#define		CONFERENCE_QUERY_RESPONSE		0x65
#define		CONFERENCE_JOIN_REQUEST			0x66
#define		CONFERENCE_JOIN_RESPONSE		0x67
#define		CONFERENCE_INVITE_REQUEST		0x68
#define		CONFERENCE_INVITE_RESPONSE		0x69
#define		ROSTER_UPDATE_INDICATION		0x7e
#define		MULTIPLE_OCTET_ID	 			0x7f
#define		REGISTER_CHANNEL_REQUEST		0xa0
#define		ASSIGN_TOKEN_REQUEST			0xa1
#define		RETRIEVE_ENTRY_REQUEST			0xa3
#define		DELETE_ENTRY_REQUEST			0xa4
#define		REGISTRY_RESPONSE				0xa9


/*
 *	This is the class definition for class CGCCCoder
 */
class	CGCCCoder : public PacketCoder
{
	public:
						CGCCCoder ();
		        BOOL    Init ( void );
		virtual			~CGCCCoder ();
		virtual	BOOL	Encode (LPVOID			pdu_structure,
								int				pdu_type,
								UINT		 	rules_type,
								LPBYTE			*encoding_buffer,
								UINT			*encoding_buffer_length);

		virtual BOOL	Decode (LPBYTE			encoded_buffer,
								UINT			encoded_buffer_length,
								int				pdu_type,
								UINT			rules_type,
								LPVOID			*decoding_buffer,
								UINT			*decoding_buffer_length);
									
		virtual void	FreeEncoded (LPBYTE encoded_buffer);

		virtual void	FreeDecoded (int pdu_type, LPVOID decoded_buffer);

		virtual BOOL     IsMCSDataPacket (	LPBYTE,	UINT		) 
													{ return FALSE; };

	private:
		BOOL    		IsObjectIDCompliant (PKey	t124_identifier);
		ASN1encoding_t  m_pEncInfo;    // ptr to encoder info
		ASN1decoding_t  m_pDecInfo;    // ptr to decoder info
};
typedef CGCCCoder *		PCGCCCoder;

/*
 *	CGCCCoder ()
 *
 *	Functional Description:
 *		This is the constructor for the CGCCCoder class.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~CGCCCoder ()
 *
 *	Functional Description:
 *		This is a virtual destructor.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	void Encode (	LPVOID		pdu_structure,
 *					int			pdu_type,
 *					UINT		rules_type,
 *					LPBYTE		*encoding_buffer,
 *					UINT		*encoding_buffer_length);
 *
 *	Functional Description:
 *		This function encodes Protocol data units (PDU's) into ASN.1 compliant
 *		byte streams.  The Encode happens into an encoder-allocated buffer.
 *
 *	Formal Parameters:
 *		pdu_structure (i)		Pointer to structure holding PDU data.
 *		pdu_type (i)			Define indicating type of GCC PDU.
 *		rules_type (i)			Type (PER or BER) of encoding rules to use.
 *		encoding_buffer (o)		Indirect pointer to buffer to hold encoded data.
 *		encoding_buffer_length(o)	Pointer that receives the Length of buffer for encoded data.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	void Decode (	LPBYTE		encoded_buffer,
 *					UINT		encoded_buffer_length,
 *					int			pdu_type,
 *					UINT		rules_type,
 *					LPVOID		decoding_buffer,
 *					UINT		decoding_buffer_length,
 *					PULong);
 *
 *	Functional Description:
 *		This function decodes ASN.1 compliant byte streams into the
 *		appropriate GCC PDU structures.
 *
 *	Formal Parameters:
 *		encoded_buffer (i)		Pointer to buffer holding data to decode.
 *		encoded_buffer_length (i)	Length of buffer holding data to decode.
 *		pdu_type (i)			Define indicating type of GCC PDU.
 *		rules_type (i)			Type (PER or BER) of encoding rules to use.
 *		decoding_buffer (o)		Pointer to buffer to hold the decoded data.
 *		decoding_buffer_length(i)	Length of buffer to hold decoded data.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	void	CopyDecodedData (	LPVOID	pdu_source_structure,
 *								LPVOID	pdu_destination_structure,
 *								UShort	pdu_type)
 *
 *	Functional Description:
 *		This function makes a complete copy of a decoded PDU structure.
 *
 *	Formal Parameters:
 *		pdu_source_structure (i)	Pointer to buffer holding decoded structure.
 *		pdu_destination_structure (i) Pointer to copy buffer.
 *		pdu_type (i)				Define indicating type of GCC PDU.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

 /*
 *	BOOL    	IsMCSDataPacket ()
 *
 *	Functional Description:
 *		This function determines whether the encoded packet is an MCS Data packet
 *		or not.
 *
 *	Formal Parameters:
 *		encoded_buffer (i)		Pointer to buffer holding the encoded PDU.
 *		rules_type (i)			The used encoding rules.
 *
 *	Return value:
 *		Always returns FALSE.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\omcscode.h ===
/*
 *	omcscode.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the CMCSCoder class.  This
 *		class is used to encode and decode MCS Protocol Data Units (PDU's)
 *		to and from ASN.1 compliant byte streams using the ASN.1 toolkit.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		John B. O'Nan
 *
 */
#ifndef	_CMCSCODER_
#define	_CMCSCODER_

#include "pktcoder.h"
#include "mcspdu.h"

/*
 * Macros
 */
#define		PLUMB_DOMAIN_INDICATION	 		0x60
#define		ERECT_DOMAIN_REQUEST		 	0x61
#define		MERGE_CHANNELS_REQUEST	 		0x62
#define		MERGE_CHANNELS_CONFIRM		 	0x63
#define		PURGE_CHANNEL_INDICATION		0x64
#define		MERGE_TOKENS_REQUEST	 		0x65
#define		MERGE_TOKENS_CONFIRM		 	0x66
#define		PURGE_TOKEN_INDICATION		 	0x67
#define		DISCONNECT_PROVIDER_ULTIMATUM	0x68
#define		REJECT_ULTIMATUM			 	0x69
#define		ATTACH_USER_REQUEST		 		0x6a
#define		ATTACH_USER_CONFIRM		 		0x6b
#define		DETACH_USER_REQUEST		 		0x6c
#define		DETACH_USER_INDICATION		 	0x6d
#define		CHANNEL_JOIN_REQUEST		 	0x6e
#define		CHANNEL_JOIN_CONFIRM		 	0x6f
#define		CHANNEL_LEAVE_REQUEST		 	0x70
#define		CHANNEL_CONVENE_REQUEST		 	0x71
#define		CHANNEL_CONVENE_CONFIRM		 	0x72
#define		CHANNEL_DISBAND_REQUEST		 	0x73
#define		CHANNEL_DISBAND_INDICATION		0x74
#define		CHANNEL_ADMIT_REQUEST		 	0x75
#define		CHANNEL_ADMIT_INDICATION		0x76
#define		CHANNEL_EXPEL_REQUEST		 	0x77
#define		CHANNEL_EXPEL_INDICATION		0x78
#define		SEND_DATA_REQUEST		 		0x79
#define		SEND_DATA_INDICATION		 	0x7a
#define		UNIFORM_SEND_DATA_REQUEST		0x7b
#define		UNIFORM_SEND_DATA_INDICATION	0x7c
#define		TOKEN_GRAB_REQUEST		 		0x7d
#define		TOKEN_GRAB_CONFIRM		 		0x7e
#define		MULTIPLE_OCTET_ID	 			0x7f
#define		TOKEN_INHIBIT_REQUEST			0x1f
#define		TOKEN_INHIBIT_CONFIRM			0x20
#define		TOKEN_GIVE_REQUEST				0x21
#define		TOKEN_GIVE_INDICATION			0x22
#define		TOKEN_GIVE_RESPONSE				0x23
#define		TOKEN_GIVE_CONFIRM				0x24
#define		TOKEN_PLEASE_REQUEST			0x25
#define		TOKEN_PLEASE_INDICATION			0x26
#define		TOKEN_RELEASE_REQUEST			0x27
#define		TOKEN_RELEASE_CONFIRM			0x28
#define		TOKEN_TEST_REQUEST				0x29
#define		TOKEN_TEST_CONFIRM				0x2a
#define		CONNECT_INITIAL				 	0x65
#define		CONNECT_RESPONSE				0x66
#define		CONNECT_ADDITIONAL				0x67
#define		CONNECT_RESULT				 	0x68

#define		HIGHEST_BER_SEND_DATA_OVERHEAD		25
#define		LOWEST_BER_SEND_DATA_OVERHEAD		19		
#define		HIGHEST_PER_SEND_DATA_OVERHEAD		9
#define		LOWEST_PER_SEND_DATA_OVERHEAD		7

#define		PER_SEND_DATA_REQUEST				0x64
#define		PER_SEND_DATA_INDICATION			0x68
#define		PER_UNIFORM_SEND_DATA_REQUEST		0x6c
#define		PER_UNIFORM_SEND_DATA_INDICATION	0x70

#define		INITIATOR_LOWER_BOUND				1001

/*
 *	This is the class definition for class CMCSCoder
 */
class	CMCSCoder : public PacketCoder
{
	public:
						CMCSCoder ();
		        BOOL    Init ( void );
		virtual			~CMCSCoder ();
		virtual	BOOL	Encode (LPVOID			pdu_structure,
								int				pdu_type,
								UINT			rules_type,
								LPBYTE			*encoding_buffer,
								UINT			*encoding_buffer_length);

		virtual BOOL	Decode (LPBYTE			encoded_buffer,
								UINT			encoded_buffer_length,
								int				pdu_type,
								UINT			rules_type,
								LPVOID			*pdecoding_buffer,
								UINT			*pdecoding_buffer_length);

		Void			ReverseDirection (LPBYTE		encoded_buffer);
											
		virtual DBBoolean IsMCSDataPacket (	LPBYTE		 encoded_buffer,
											UINT		 rules_type);
		virtual void	FreeEncoded (LPBYTE encoded_buffer);

		virtual void	FreeDecoded (int pdu_type, LPVOID decoded_buffer);

	private:
		void SetEncodingRules				(UINT			rules_type); 
												 
		UINT					Encoding_Rules_Type;
		ASN1encoding_t  m_pEncInfo;    // ptr to encoder info
		ASN1decoding_t  m_pDecInfo;    // ptr to decoder info
};
typedef CMCSCoder *		PCMCSCoder;

/*
 *	CMCSCoder ()
 *
 *	Functional Description:
 *		This is the constructor for the CMCSCoder class.  It initializes the
 *		ASN.1 toolkit and sets the type of encoding rules to Basic Encoding
 *		Rules (BER).  It also initializes some private instance variables.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~CMCSCoder ()
 *
 *	Functional Description:
 *		This is a virtual destructor.  It cleans up after the ASN.1 toolkit.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	void Encode (	LPVOID		pdu_structure,
 *					int			pdu_type,
 *					UINT		 rules_type,
 *					LPBYTE		*encoding_buffer,
 *					UINT		*encoding_buffer_length)
 *
 *	Functional Description:
 *		This function encodes Protocol data units (PDU's) into ASN.1 compliant
 *		byte streams.
 *		The coder allocates the buffer space for the encoded data.
 *
 *	Formal Parameters:
 *		pdu_structure (i)		Pointer to structure holding PDU data.
 *		pdu_type (i)			Define indicating Connect or Domain MCS PDU.
 *		rules_type (i)			Type of encoding rules (BER or PER).
 *		encoding_buffer (o)		Pointer to buffer to hold encoded data.
 *		encoding_buffer_length (o) Length of encoded data.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	void Decode (	LPBYTE		encoded_buffer,
 *					UINT		encoded_buffer_length,
 *					int			pdu_type,
 *					UINT		rules_type,
 *					LPVOID		decoding_buffer,
 *					UINT		decoding_buffer_length,
 *					UINT		*pulDataOffset)
 *
 *	Functional Description:
 *		This function decodes ASN.1 compliant byte streams into the
 *		appropriate MCS PDU structures.
 *
 *	Formal Parameters:
 *		encoded_buffer (i)		Pointer to buffer holding data to decode.
 *		encoded_buffer_length(i) Length of buffer holding encoded data.
 *		pdu_type (i)			Type (Domain or Connect) of MCS PDU.
 *		rules_type (i)			Type of encoding rules (BER or PER).
 *		decoding_buffer (o)		Pointer to buffer to hold the decoded data.
 *		decoding_buffer_length (i) Length of buffer to hold decoded data.
 *		pulDataOffset (o)		Pointer to a value that stores the offset of the data in an encoded MCS data packet.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	void	CopyDecodedData (	LPVOID	pdu_source_structure,
 *								LPVOID	pdu_destination_structure,
 *								UINT		 pdu_type)
 *
 *	Functional Description:
 *		This function makes a complete copy of a decoded PDU structure.
 *
 *	Formal Parameters:
 *		pdu_source_structure (i)	Pointer to buffer holding decoded structure.
 *		pdu_destination_structure (i) Pointer to copy buffer.
 *		pdu_type (i) 				Type (Domain or Connect) of PDU.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void ReverseDirection (LPBYTE	encoded_buffer)
 *
 *	Functional Description:
 *		This function alters the identifier of encoded "Send Data" PDU's in 
 * 		order to change back and forth between data requests and indications.
 *
 *	Formal Parameters:
 *		encoded_buffer (i)		Pointer to buffer holding encoded data.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

 /*
 *	DBBoolean	IsMCSDataPacket ()
 *
 *	Functional Description:
 *		This function determines whether the encoded packet is an MCS Data packet
 *		or not.
 *
 *	Formal Parameters:
 *		encoded_buffer (i)		Pointer to buffer holding the encoded PDU.
 *		rules_type (i)			The used encoding rules.
 *
 *	Return value:
 *		TRUE, if the packet is an MCS Data packet. FALSE, otherwise.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\packet.h ===
/*
 *	packet.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *				  1997 by Microsoft Corporation, Redmond, WA
 *
 *	Abstract:
 *		This is the interface file for the Packet class.  Instances of this
 *		class represent Protocol Data Units (PDUs) as they flow through the
 *		system.  These instances manage the memory required to hold both
 *		encoded and decoded versions of the PDU, and make sure that no PDU
 *		is ever encoded or decoded more than once.  The use of lock counts
 *		allow multiple objects in the system to reference and use the same
 *		packet object at the same time. This class inherits from the SimplePacket
 *		class (a pure virtual class).
 *
 *		A packet object can be created in 2 different ways.  It can be created
 *		with either decoded data or encoded data.  During instantiation, the
 *		new packet object will calculate how much memory it will need to
 *		hold both the encoded and decoded data, and attempts to allocate that
 *		memory.  If it cannot, then it will report an error, and the newly
 *		created object should be immediately destroyed.  If the allocations are
 *		successful, then the packet will report success, but WILL NOT yet put
 *		any data into those allocated buffers.
 *
 *		When a Lock message is sent to the object, it will put encoded
 *		data into the pre-allocated encode buffer.  If the packet was created
 *		with decoded data, then this will entail an encode operation.  However,
 *		if the packet was created with encoded data, then it is smart enough
 *		to just COPY the encoded data into the internal buffer, thus avoiding
 *		the overhead associated with the encode operation.
 *                  
 *		When a Lock message is sent to the object, it will put decoded
 *		data into the pre-allocated decode buffer.  If the packet was created
 *		with encoded data, then this will entail a decode operation.  However,
 *		if the packet was created with decoded data, then it is smart enough
 *		to just COPY the decoded data into the internal buffer, thus avoiding
 *		the overhead associated with the decode operation.
 *
 *		When Unlock messages are received, the lock count is decremented.  When
 *		the lock count is 0, the packet deletes itself (it commits
 *		suicide).  Note that for this reason, no other object should explicitly
 *		delete a packet object.
 *                  
 *	Caveats:
 *		None.
 *
 *	Authors:
 *		James J. Johnstone IV
 *		Christos Tsollis
 */

#ifndef _PACKET_
#define _PACKET_

#include "pktcoder.h"

/*
 *	 Definition of class Packet.
 */

class Packet;
typedef Packet *		PPacket;

class Packet : public SimplePacket
{
public:

	// outgoing packets
	Packet(PPacketCoder	pPacketCoder,
			UINT			nEncodingRules,
			LPVOID			pInputPduStructure,
			int				nPduType,
			BOOL			fPacketDirectionUp,
			PPacketError	pePktErr,
			BOOL			fLockEncodedData = FALSE);

	// incoming packets
	Packet(PPacketCoder	pPacketCoder,
			UINT			nEncodingRules,
			LPBYTE			pEncodedData,
			UINT			cbEncodedDataSize,
			int				nPduType,
			BOOL			fPacketDirectionUp,
			PPacketError	pePktErr);

	virtual 			~Packet(void);
	
	virtual BOOL		IsDataPacket (void);
	virtual PVoid		GetDecodedData(void);
	UINT				GetDecodedDataLength(void) { return Decoded_Data_Length; };
	virtual int			GetPDUType(void);

protected:
	
	PPacketCoder	Packet_Coder;
	LPVOID			m_Decoded_Data;
	UINT			Decoded_Data_Length;
	int				PDU_Type;
};


/*
 *	Packet (
 *			PPacketCoder	packet_coder,
 *			UINT			encoding_rules,
 *			PVoid			pInputPduStructure,
 *			PMemory			pInputPduStructure_Memory,
 *			int				pdu_type,
 *			DBBoolean		packet_direction_up,
 *			PPacketError	return_value )
 *
 *	Functional Description:
 *		This version of the constructor is used to create a Packet object
 *		for outgoing PDUs when the packet is to be created from a structure
 *		containing the PDU data to be encoded.
 *
 *	Formal Parameters:
 *		packet_coder (i)
 *			Pointer to the packet coder object.  This pointer will be used by
 *			the packet object to encode and decode PDU structures.  This pointer
 *			must not become stale during the life of the packet object.
 *		encoding_rules (i)
 *			This value identifies which set of encoding rules should be used
 *			on the current packet.  This is simply through to the packet coder
 *			during all encode and decode operations.
 *		pInputPduStructure (i)
 *			Pointer to the input PDU structure.
 *		pInputPduStructure_Memory
 *			Pointer to a Memory struct for the buffer containing the pdu structure.
 *			Exactly one of the args pInputPduStructure_Memory and pInputPduStructure
 *			should be non-NULL;
 *		pdu_type (i)
 *			The type of PDU contained in the packet.  This is passed through
 *			to the packet coder specified above.
 *		packet_direction_up (i)
 *			The packet_direction_up flag indicates the initial orientation of
 *			the packet.  Valid values are:
 *				TRUE -	The packet's direction is up.
 *				FALSE -	The packet's direction is down.
 *		return_value (o)
 *			When the constructor returns control to the calling function, this
 *			variable will be set to one of the return values listed below.
 *
 *	Return Value:
 *		PACKET_NO_ERROR
 *			The Packet object was constructed correctly. 
 *		PACKET_MALLOC_FAILURE
 *			The constructor was unable to allocate the memory required to work
 *			properly.  The Packet object should be deleted.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Packet (
 *			PPacketCoder	packet_coder,
 *			UINT			encoding_rules,
 *			PUChar			encoded_data_ptr,
 *			UShort			encoded_data_length,
 *			int				pdu_type,
 *			DBBoolean		packet_direction_up,
 *			PPacketError	return_value )
 *
 *	Functional Description:
 *		This version of the constructor is used to create a Packet object
 *		for incomming PDUs when the packet is to be created from an encoded
 *		data stream containing the PDU data to be decoded.
 *
 *	Formal Parameters:
 *		packet_coder (i)
 *			Pointer to the packet coder object.  This pointer will be used by
 *			the packet object to encode and decode PDU structures.  This pointer
 *			must not become stale during the life of the packet object.
 *		encoding_rules (i)
 *			This value identifies which set of encoding rules should be used
 *			on the current packet.  This is simply through to the packet coder
 *			during all encode and decode operations.
 *		encoded_data_ptr (i)
 *			Pointer to the input encoded PDU.
 *		encoded_data_length (i)
 *			The length in bytes of the input encoded PDU.
 *		pdu_type (i)
 *			The type of PDU contained in the packet.  This is passed through
 *			to the packet coder specified above.
 *		packet_direction_up (i)
 *			The packet_direction_up flag indicates the initial orientation of
 *			the packet.  Valid values are:
 *				TRUE -	The packet's direction is up.
 *				FALSE -	The packet's direction is down.
 *		return_value (o)
 *			When the constructor returns control to the calling function, this
 *			variable will be set to one of the return values listed below.
 *
 *	Return Value:
 *		PACKET_NO_ERROR
 *			The Packet object was constructed correctly. 
 *		PACKET_MALLOC_FAILURE
 *			The constructor was unable to allocate the memory required to work
 *			properly.  The Packet object should be deleted.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */							      				      
/*
 *	~Packet ()
 *
 *	Functional Description:
 *		Destructor for the Packet class.  The destructor ensures that all 
 *		resources that have been allocated are freed.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GetDecodedData ()
 *
 *	Functional Description:
 *		The GetDecodedData method returns a pointer to the decoded data
 *		buffer.  
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		A pointer to the decoded data.  If an decoding error occurs, this
 *		method will return NULL.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GetDecodedDataLength ()
 *
 *	Functional Description:
 *		This method returns the decoded data's length.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The number of bytes in the decoded data.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GetPDUType ()
 *
 *	Functional Description:
 *		This method returns the PDU type.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		Either DOMAIN_MCS_PDU or CONNECT_MCS_PDU dependant upon the PDU type.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\objkey.h ===
/*
 *	objkey.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class CObjectKeyContainer.  This class 
 *		manages the data associated with an Object Key.  Object Key are used 
 *		to identify a particular application protocol, whether it is standard or
 *		non-standard.  When used to identify a standard protocol, the Object Key
 *		takes the form of an Object ID which is a series of non-negative 
 *		integers.  This type of Object Key is maintained internally through the
 *		use of a UnicodeString object.  When used to identify a non-standard 
 *		protocol, the Object Key takes the form of an H221 non-standard ID which
 *		is an octet string of no fewer than four octets and no more than 255 
 *		octets.  In this case the Object Key is maintained internally by using a
 *		Rogue Wave string object.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */
#ifndef	_OBJECT_KEY_DATA_
#define	_OBJECT_KEY_DATA_


/*
 * Macros used by this class.
 */
#define 	MINIMUM_OBJECT_ID_ARCS				3
#define 	ITUT_IDENTIFIER						0
#define 	ISO_IDENTIFIER						1
#define 	JOINT_ISO_ITUT_IDENTIFIER			2
#define 	MINIMUM_NON_STANDARD_ID_LENGTH		4
#define 	MAXIMUM_NON_STANDARD_ID_LENGTH		255


/*
 * This is the typedef for the structure used to hold the object key data
 * internally.
 */
typedef struct
{
	LPBYTE						object_id_key;
	UINT						object_id_length;
	LPOSTR						poszNonStandardIDKey;
}
    OBJECT_KEY;

/*
 * Class definition:
 */
class CObjectKeyContainer : public CRefCount
{
public:

	CObjectKeyContainer(PGCCObjectKey, PGCCError);
	CObjectKeyContainer(PKey, PGCCError);
	CObjectKeyContainer(CObjectKeyContainer *, PGCCError);

	~CObjectKeyContainer(void);

	UINT		LockObjectKeyData(void);
	void		UnLockObjectKeyData(void);

	UINT		GetGCCObjectKeyData(PGCCObjectKey, LPBYTE memory);
	GCCError	GetObjectKeyDataPDU(PKey);
	void		FreeObjectKeyDataPDU(void);

	friend BOOL operator== (const CObjectKeyContainer&, const CObjectKeyContainer&);

protected:

	OBJECT_KEY  		m_InternalObjectKey;
	UINT				m_cbDataSize;

	Key					m_ObjectKeyPDU;
	BOOL    			m_fValidObjectKeyPDU;

private:

	BOOL		ValidateObjectIdValues(UINT first_arc, UINT second_arc);
};

/*
 *	Comments explaining the public and protected class member functions
 */

/*
 *	CObjectKeyContainer (	PGCCObjectKey		object_key,
 *					PGCCError			return_value);
 *
 *	Public member function of CObjectKeyContainer.
 *
 *	Function Description:
 *		This is the constructor for the CObjectKeyContainer class which takes as
 *		input the "API" version of object key data, GCCObjectKey.
 *
 *	Formal Parameters:
 *		object_key			(i)	The object key data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_OBJECT_KEY				-	An invalid object key passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	CObjectKeyContainer (		PKey				object_key,
 *						PGCCError			return_value);
 *
 *	Public member function of CObjectKeyContainer.
 *
 *	Function Description:
 *		This is the constructor for the CObjectKeyContainer class which takes as
 *		input the "PDU" version of object key data, Key.
 *
 *	Formal Parameters:
 *		object_key			(i)	The object key data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	CObjectKeyContainer (		CObjectKeyContainer		    *object_key,
 *						PGCCError			return_value);
 *
 *	Public member function of CObjectKeyContainer.
 *
 *	Function Description:
 *		This is the copy constructor for the CObjectKeyContainer class which takes
 *		as input another CObjectKeyContainer object.
 *
 *	Formal Parameters:
 *		object_key			(i)	The CObjectKeyContainer object to copy.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_OBJECT_KEY				-	An invalid CObjectKeyContainer passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	~ObjectKeyData();
 *
 *	Public member function of CObjectKeyContainer.
 *
 *	Function Description:
 *		This is the destructor for the CObjectKeyContainer class.  It is used to
 *		clean up any memory allocated during the life of this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	UINT			LockObjectKeyData ();
 *
 *	Public member function of CObjectKeyContainer.
 *
 *	Function Description:
 *		This routine is used to "lock" the "API" data for this object.  This
 *		results in the lock count for this object being incremented.  When the
 *		lock count transitions from 0 to 1, a calculation is made to determine
 *		how much memory will be needed to hold any "API" data which will
 *		be referenced by, but not held in, the GCCObjectKey structure
 *		which is filled in on a call to GetGCCObjectKeyData.  This is the
 *		value returned by this routine in order to allow the calling object to
 *		allocate that amount of memory in preparation for the call to 
 *		GetGCCObjectKeyData.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The amount of memory, if any, which will be needed to hold "API" data
 *		which is referenced by, but not held in, the GCCObjectKey structure
 *		provided as an output parameter to the GetGCCObjectKeyData call.
 *
 *  Side Effects:
 *		The internal lock count is incremented.
 *
 *	Caveats:
 *		The internal lock count is used in conjuction with an internal "free" 
 *		flag as a mechanism for ensuring that this object remains in existance 
 *		until all interested parties are through with it.  The object remains 
 *		valid (unless explicity deleted) until the lock count is zero and the 
 *		"free" flag is set through a call to FreeObjectKeyData.  This allows
 *		other objects to lock this object and be sure that it remains valid 
 *		until they call UnLock which will decrement the internal lock count.  A
 *		typical usage scenerio for this object would be:  An CObjectKeyContainer
 *		object is constructed and then passed off to any interested parties
 *		through a function call.  On return from the function call, the
 *		FreeObjectKeyData call is made which will set the internal "free"
 *		flag.  If no other parties have locked the object with a Lock call,
 *		then the CObjectKeyContainer object will automatically delete itself when
 *		the FreeObjectKeyData call is made.  If, however, any number of 
 *		other parties has locked the object, it will remain in existence until
 *		each of them has unlocked the object through a call to UnLock.
 */


/*
 *	UINT			GetGCCObjectKeyData (	
 *							PGCCObjectKey 		object_key,
 *							LPSTR				memory);
 *
 *	Public member function of CObjectKeyContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the object key data from the
 *		CObjectKeyContainer object in the "API" form of a GCCObjectKey.
 *
 *	Formal Parameters:
 *		object_key			(o)	The GCCObjectKey structure to fill in.
 *		memory				(o)	The memory used to hold any data referenced by,
 *									but not held in, the output structure.
 *
 *	Return Value:
 *		The amount of data, if any, written into the bulk memory block provided.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void			UnLockObjectKeyData ();
 *
 *	Public member function of CObjectKeyContainer.
 *
 *	Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine 
 *		whether the object has been freed through a call to 
 *		FreeObjectKeyData.  If so, the object will automatically delete
 *		itself.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal lock count is decremented.
 *
 *	Caveats:
 *		It is the responsibility of any party which locks an CObjectKeyContainer
 *		object by calling Lock to also unlock the object with a call to UnLock.
 *		If the party calling UnLock did not construct the CObjectKeyContainer 
 *		object,	it should assume the object to be invalid thereafter.
 */


/*
 *	void			FreeObjectKeyData ();
 *
 *	Public member function of CObjectKeyContainer.
 *
 *	Function Description:
 *		This routine is used to "free" the "API" data for this object.  This 
 *		will result in the automatic deletion of this object if the object is
 *		not in the "locked" state.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal "free" flag is set.
 *
 *	Caveats:
 *		This object should be assumed invalid after a call to 
 *		FreeObjectKeyData has been made.
 */


/*
 *	GCCError		GetObjectKeyDataPDU (	
 *							PKey 		object_key);
 *
 *	Public member function of CObjectKeyContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the object key data from the
 *		CObjectKeyContainer object in the "PDU" form of a Key.
 *
 *	Formal Parameters:
 *		object_key		(o)	The Key structure to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_OBJECT_KEY				-	One of the internal pointers has
 *												been corrupted.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void		FreeObjectKeyDataPDU ();
 *
 *	Public member function of CObjectKeyContainer.
 *
 *	Function Description:
 *		This routine is used to "free" the "PDU" data allocated for this object
 *		which is held internally in a Key structure.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal flag is set to indicate that the PDU form of data no
 *		longer is valid for this object.
 *
 *	Caveats:
 *		None.
 */


/*
 *	friend BOOL    	operator== (const CObjectKeyContainer& 		object_key_1, 
 *									const CObjectKeyContainer& 		object_key_2);
 *
 *	Public member function of CObjectKeyContainer.
 *
 *	Function Description:
 *		This routine is used to compare two CObjectKeyContainer objects to determine
 *		whether or not they are equal in value.
 *
 *	Formal Parameters:
 *		object_key_1			(i)	The first CObjectKeyContainer object to compare.
 *		object_key_2			(i)	The other CObjectKeyContainer object to compare.
 *
 *	Return Value:
 *		TRUE				-	The two objects are equal in value.
 *		FALSE				- 	The two objects are not equal in value.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\pdutypes.h ===
/*
 *	pdutypes.h
 *
 *	Copyright (c) 1994, 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This file is used to convert from the ASN.1 generated types into types
 *		compliant with the DataBeam coding standard.
 *
 *	Author:
 *		jbo
 *
 *	Caveats:
 *		none
 */

#ifndef	_GCC_PDU_TYPES_
#define	_GCC_PDU_TYPES_

#include "gccpdu.h"

/*
 *	PDU types
 */
#define CONNECT_DATA_PDU   					ConnectData_PDU
#define CONNECT_GCC_PDU    					ConnectGCCPDU_PDU
#define GCC_PDU            					GCCPDU_PDU 

/*
 *	Key
 */
#define OBJECT_CHOSEN       				object_chosen
#define H221_NON_STANDARD_CHOSEN   			h221_non_standard_chosen

/*
 *	SetOfUserData
 */
#define USER_DATA_FIELD_PRESENT				user_data_field_present

/*
 *	Password
 */
#define PASSWORD_TEXT_PRESENT				password_text_present

/*
 *	PasswordSelector
 */
#define PASSWORD_SELECTOR_NUMERIC_CHOSEN  	password_selector_numeric_chosen
#define PASSWORD_SELECTOR_TEXT_CHOSEN     	password_selector_text_chosen

/*
 *	ChallengeResponseItem
 */
#define PASSWORD_STRING_CHOSEN				password_string_chosen
#define SET_OF_RESPONSE_DATA_CHOSEN			set_of_response_data_chosen

/*
 *	ChallengeResponseAlgorithm
 */
#define ALGORITHM_CLEAR_PASSWORD_CHOSEN		algorithm_clear_password_chosen
#define NON_STANDARD_ALGORITHM_CHOSEN		non_standard_algorithm_chosen

/*
 *	PasswordChallengeRequestResponse
 */
#define CHALLENGE_CLEAR_PASSWORD_CHOSEN		challenge_clear_password_chosen
#define CHALLENGE_REQUEST_RESPONSE_CHOSEN	challenge_request_response_chosen

/*
 *	ChallengeRequestResponse
 */
#define CHALLENGE_REQUEST_PRESENT			challenge_request_present
#define CHALLENGE_RESPONSE_PRESENT			challenge_response_present

/*
 *	ConferenceName
 */
#define CONFERENCE_NAME_TEXT_PRESENT		conference_name_text_present

/*
 *	ConferenceNameSelector
 */
#define NAME_SELECTOR_NUMERIC_CHOSEN  		name_selector_numeric_chosen
#define NAME_SELECTOR_TEXT_CHOSEN     		name_selector_text_chosen


/*
 *	Defines to match Enums for Privileges
 */
#define	NUMBER_OF_PRIVILEGES		5
#define TERMINATE_IS_ALLOWED		terminate
#define	EJECT_USER_IS_ALLOWED		ejectUser
#define	ADD_IS_ALLOWED				add
#define	LOCK_UNLOCK_IS_ALLOWED		lockUnlock
#define	TRANSFER_IS_ALLOWED			transfer


/*
 *	NetworkAddress
 */
#define AGGREGATED_CHANNEL_CHOSEN 			aggregated_channel_chosen
#define TRANSPORT_CONNECTION_CHOSEN 		transport_connection_chosen
#define ADDRESS_NON_STANDARD_CHOSEN			address_non_standard_chosen

/*
 *	AggregateChannel
 */
#define SUB_ADDRESS_PRESENT 				sub_address_present
#define EXTRA_DIALING_STRING_PRESENT 		extra_dialing_string_present
#define HIGH_LAYER_COMPATIBILITY_PRESENT 	high_layer_compatibility_present

/*
 *	TransportConnection
 */
#define TRANSPORT_SELECTOR_PRESENT 			transport_selector_present

/*
 *	AsymmetryIndicator
 */
#define CALLING_NODE_CHOSEN 				calling_node_chosen
#define CALLED_NODE_CHOSEN 					called_node_chosen
#define UNKNOWN_CHOSEN 						unknown_chosen

/*
 *	AlternativeNodeID
 */
#define H243_NODE_ID_CHOSEN 				h243_node_id_chosen

/*
 *	ConferenceDescriptor
 */
#define CONFERENCE_NAME_MODIFIER_PRESENT 	conference_name_modifier_present
#define CONFERENCE_DESCRIPTION_PRESENT 		conference_description_present
#define DESCRIPTOR_NET_ADDRESS_PRESENT 		descriptor_net_address_present

/*
 *	NodeRecord
 */
#define SUPERIOR_NODE_PRESENT 				superior_node_present
#define NODE_NAME_PRESENT 					node_name_present
#define PARTICIPANTS_LIST_PRESENT 			participants_list_present
#define SITE_INFORMATION_PRESENT 			site_information_present
#define RECORD_NET_ADDRESS_PRESENT 			record_net_address_present
#define ALTERNATIVE_NODE_ID_PRESENT 		alternative_node_id_present
#define RECORD_USER_DATA_PRESENT 			record_user_data_present

/*
 *	SessionKey
 */
#define SESSION_ID_PRESENT 					session_id_present

/*
 *	CapabilityID
 */
#define STANDARD_CHOSEN 					standard_chosen
#define CAPABILITY_NON_STANDARD_CHOSEN		capability_non_standard_chosen

/*
 *	ApplicationRecord
 */
#define RECORD_STARTUP_CHANNEL_PRESENT		record_startup_channel_present
#define APPLICATION_USER_ID_PRESENT 		application_user_id_present
#define NON_COLLAPSING_CAPABILITIES_PRESENT	non_collapsing_capabilities_present

/*
 *	SetOfNonCollapsingCapabilities
 */
#define APPLICATION_DATA_PRESENT 			application_data_present

/*
 *	CapabilityClass
 */
#define LOGICAL_CHOSEN 						logical_chosen
#define UNSIGNED_MINIMUM_CHOSEN 			unsigned_minimum_chosen
#define UNSIGNED_MAXIMUM_CHOSEN 			unsigned_maximum_chosen

/*
 *	ApplicationInvokeSpecifier
 */
#define EXPECTED_CAPABILITY_SET_PRESENT 	expected_capability_set_present
#define INVOKE_STARTUP_CHANNEL_PRESENT		invoke_startup_channel_present

/*
 *	RegistryItem
 */
#define CHANNEL_ID_CHOSEN 					channel_id_chosen
#define TOKEN_ID_CHOSEN 					token_id_chosen
#define PARAMETER_CHOSEN 					parameter_chosen
#define VACANT_CHOSEN 						vacant_chosen

/*
 *	RegistryEntryOwner
 */
#define OWNED_CHOSEN 						owned_chosen
#define NOT_OWNED_CHOSEN 					not_owned_chosen

/*
 *	ConferenceCreateRequest
 */
#define CCRQ_CONVENER_PASSWORD_PRESENT 		ccrq_convener_password_present
#define CCRQ_PASSWORD_PRESENT 				ccrq_password_present
#define CCRQ_CONDUCTOR_PRIVS_PRESENT 		ccrq_conductor_privs_present
#define CCRQ_CONDUCTED_PRIVS_PRESENT 		ccrq_conducted_privs_present
#define CCRQ_NON_CONDUCTED_PRIVS_PRESENT 	ccrq_non_conducted_privs_present
#define CCRQ_DESCRIPTION_PRESENT 			ccrq_description_present
#define CCRQ_CALLER_ID_PRESENT 				ccrq_caller_id_present
#define CCRQ_USER_DATA_PRESENT 				ccrq_user_data_present

/*
 *	ConferenceCreateResponse
 */
#define CCRS_USER_DATA_PRESENT				ccrs_user_data_present

/*
 *	ConferenceQueryRequest
 */
#define CQRQ_ASYMMETRY_INDICATOR_PRESENT	cqrq_asymmetry_indicator_present
#define CQRQ_USER_DATA_PRESENT				cqrq_user_data_present

/*
 *	ConferenceQueryResponse
 */
#define CQRS_ASYMMETRY_INDICATOR_PRESENT 	cqrs_asymmetry_indicator_present
#define CQRS_USER_DATA_PRESENT				cqrs_user_data_present

/*
 *	ConferenceJoinRequest
 */
#define CONFERENCE_NAME_PRESENT 			conference_name_present
#define CJRQ_CONFERENCE_MODIFIER_PRESENT 	cjrq_conference_modifier_present
#define TAG_PRESENT 						tag_present
#define CJRQ_PASSWORD_PRESENT 				cjrq_password_present
#define CJRQ_CONVENER_PASSWORD_PRESENT 		cjrq_convener_password_present
#define CJRQ_CALLER_ID_PRESENT 				cjrq_caller_id_present
#define CJRQ_USER_DATA_PRESENT 				cjrq_user_data_present

/*
 *	ConferenceJoinResponse
 */
#define CJRS_NODE_ID_PRESENT 				cjrs_node_id_present
#define CONFERENCE_NAME_ALIAS_PRESENT 		conference_name_alias_present
#define CJRS_CONDUCTOR_PRIVS_PRESENT 		cjrs_conductor_privs_present
#define CJRS_CONDUCTED_PRIVS_PRESENT 		cjrs_conducted_privs_present
#define CJRS_NON_CONDUCTED_PRIVS_PRESENT 	cjrs_non_conducted_privs_present
#define CJRS_DESCRIPTION_PRESENT 			cjrs_description_present
#define CJRS_PASSWORD_PRESENT 				cjrs_password_present
#define CJRS_USER_DATA_PRESENT 				cjrs_user_data_present

/*
 *	ConferenceInviteRequest
 */
#define CIRQ_CONDUCTOR_PRIVS_PRESENT 		cirq_conductor_privs_present
#define CIRQ_CONDUCTED_PRIVS_PRESENT 		cirq_conducted_privs_present
#define CIRQ_NON_CONDUCTED_PRIVS_PRESENT 	cirq_non_conducted_privs_present
#define CIRQ_DESCRIPTION_PRESENT 			cirq_description_present
#define CIRQ_CALLER_ID_PRESENT 				cirq_caller_id_present
#define CIRQ_USER_DATA_PRESENT 				cirq_user_data_present

/*
 *	ConferenceInviteResponse
 */
#define CIRS_USER_DATA_PRESENT				cirs_user_data_present

/*
 *	ConferenceAddRequest
 */
#define ADDING_MCU_PRESENT 					adding_mcu_present
#define CARQ_USER_DATA_PRESENT				carq_user_data_present

/*
 *	ConferenceAddResponse
 */
#define CARS_USER_DATA_PRESENT				cars_user_data_present

/*
 *	ConferenceTransferRequest
 */
#define CTRQ_CONFERENCE_MODIFIER_PRESENT 	ctrq_conference_modifier_present
#define CTRQ_NETWORK_ADDRESS_PRESENT 		ctrq_net_address_present
#define CTRQ_TRANSFERRING_NODES_PRESENT 	ctrq_transferring_nodes_present
#define CTRQ_PASSWORD_PRESENT 				ctrq_password_present

/*
 *	ConferenceTransferResponse
 */
#define CTRS_CONFERENCE_MODIFIER_PRESENT 	ctrs_conference_modifier_present
#define CTRS_TRANSFERRING_NODES_PRESENT 	ctrs_transferring_nodes_present

/*
 *	ConferenceTransferIndication
 */
#define CTIN_CONFERENCE_MODIFIER_PRESENT 	ctin_conference_modifier_present
#define CTIN_NETWORK_ADDRESS_PRESENT 		ctin_net_address_present
#define CTIN_TRANSFERRING_NODES_PRESENT 	ctin_transferring_nodes_present
#define CTIN_PASSWORD_PRESENT 				ctin_password_present

/*
 *	NodeUpdate
 */
#define NODE_ADD_RECORD_CHOSEN 				node_add_record_chosen
#define NODE_REPLACE_RECORD_CHOSEN 			node_replace_record_chosen
#define NODE_REMOVE_RECORD_CHOSEN 			node_remove_record_chosen

/*
 *	NodeRecordList
 */
#define NODE_NO_CHANGE_CHOSEN 				node_no_change_chosen
#define NODE_RECORD_REFRESH_CHOSEN 			node_record_refresh_chosen
#define NODE_RECORD_UPDATE_CHOSEN 			node_record_update_chosen

/*
 *	ApplicationUpdate
 */
#define APPLICATION_ADD_RECORD_CHOSEN 		application_add_record_chosen
#define APPLICATION_REPLACE_RECORD_CHOSEN 	application_replace_record_chosen
#define APPLICATION_REMOVE_RECORD_CHOSEN 	application_remove_record_chosen

/*
 *	ApplicationRecordList
 */
#define APPLICATION_NO_CHANGE_CHOSEN 		application_no_change_chosen
#define APPLICATION_RECORD_REFRESH_CHOSEN 	application_record_refresh_chosen
#define APPLICATION_RECORD_UPDATE_CHOSEN 	application_record_update_chosen

/*
 *	ApplicationCapabilitiesList
 */
#define CAPABILITY_NO_CHANGE_CHOSEN 		capability_no_change_chosen
#define APPLICATION_CAPABILITY_REFRESH_CHOSEN \
										application_capability_refresh_chosen

/*
 *	ApplicationInvokeIndication
 */
#define DESTINATION_NODES_PRESENT 			destination_nodes_present

/*
 *	RegistrySetParameterRequest
 */
#define PARAMETER_MODIFY_RIGHTS_PRESENT		parameter_modify_rights_present

/*
 *	RegistryMonitorEntryIndication
 */
#define ENTRY_MODIFY_RIGHTS_PRESENT 		entry_modify_rights_present

/*
 *	RegistryResponse
 */
#define RESPONSE_MODIFY_RIGHTS_PRESENT 		response_modify_rights_present

/*
 *	ConductorPermissionGrantIndication
 */
#define WAITING_LIST_PRESENT 				waiting_list_present

/*
 *	ConferenceTimeRemainingIndication
 */
#define TIME_REMAINING_NODE_ID_PRESENT		time_remaining_node_id_present

/*
 *	ConferenceAssistanceIndication
 */
#define CAIN_USER_DATA_PRESENT 				cain_user_data_present

/*
 *	RequestPDU
 */
#define CONFERENCE_JOIN_REQUEST_CHOSEN 				\
									conference_join_request_chosen
#define CONFERENCE_JOIN_RESPONSE_CHOSEN 			\
									conference_join_response_chosen
#define CONFERENCE_LOCK_REQUEST_CHOSEN 				\
									conference_lock_request_chosen
#define CONFERENCE_UNLOCK_REQUEST_CHOSEN 			\
									conference_unlock_request_chosen
#define CONFERENCE_TERMINATE_REQUEST_CHOSEN 		\
									conference_terminate_request_chosen
#define CONFERENCE_EJECT_USER_REQUEST_CHOSEN 		\
									conference_eject_user_request_chosen
#define CONFERENCE_TRANSFER_REQUEST_CHOSEN 			\
									conference_transfer_request_chosen
#define	CONFERENCE_ADD_REQUEST_CHOSEN				\
									conference_add_request_chosen
#define REGISTRY_REGISTER_CHANNEL_REQUEST_CHOSEN 	\
									registry_register_channel_request_chosen
#define REGISTRY_ASSIGN_TOKEN_REQUEST_CHOSEN 		\
									registry_assign_token_request_chosen
#define REGISTRY_SET_PARAMETER_REQUEST_CHOSEN 		\
									registry_set_parameter_request_chosen
#define REGISTRY_RETRIEVE_ENTRY_REQUEST_CHOSEN 		\
									registry_retrieve_entry_request_chosen
#define REGISTRY_DELETE_ENTRY_REQUEST_CHOSEN 		\
									registry_delete_entry_request_chosen
#define REGISTRY_MONITOR_ENTRY_REQUEST_CHOSEN 		\
									registry_monitor_entry_request_chosen
#define REGISTRY_ALLOCATE_HANDLE_REQUEST_CHOSEN 	\
									registry_allocate_handle_request_chosen
#define NON_STANDARD_REQUEST_CHOSEN 				\
									non_standard_request_chosen

/*
 *	ConnectGCCPDU
 */
#define CONFERENCE_CREATE_REQUEST_CHOSEN 	conference_create_request_chosen
#define CONFERENCE_CREATE_RESPONSE_CHOSEN 	conference_create_response_chosen
#define CONFERENCE_QUERY_REQUEST_CHOSEN 	conference_query_request_chosen
#define CONFERENCE_QUERY_RESPONSE_CHOSEN 	conference_query_response_chosen
#define CONNECT_JOIN_REQUEST_CHOSEN 		connect_join_request_chosen
#define CONNECT_JOIN_RESPONSE_CHOSEN 		connect_join_response_chosen
#define CONFERENCE_INVITE_REQUEST_CHOSEN 	conference_invite_request_chosen
#define CONFERENCE_INVITE_RESPONSE_CHOSEN 	conference_invite_response_chosen

/*
 *	ResponsePDU
 */
#define CONFERENCE_JOIN_RESPONSE_CHOSEN 			\
									conference_join_response_chosen
#define CONFERENCE_ADD_RESPONSE_CHOSEN 				\
									conference_add_response_chosen
#define CONFERENCE_LOCK_RESPONSE_CHOSEN 			\
									conference_lock_response_chosen
#define CONFERENCE_UNLOCK_RESPONSE_CHOSEN 			\
									conference_unlock_response_chosen
#define CONFERENCE_TERMINATE_RESPONSE_CHOSEN 		\
									conference_terminate_response_chosen
#define CONFERENCE_EJECT_USER_RESPONSE_CHOSEN		\
									conference_eject_user_response_chosen
#define CONFERENCE_TRANSFER_RESPONSE_CHOSEN 		\
									conference_transfer_response_chosen
#define REGISTRY_RESPONSE_CHOSEN 					\
									registry_response_chosen
#define REGISTRY_ALLOCATE_HANDLE_RESPONSE_CHOSEN 	\
									registry_allocate_handle_response_chosen
#define FUNCTION_NOT_SUPPORTED_RESPONSE_CHOSEN 		\
									function_not_supported_response_chosen
#define NON_STANDARD_RESPONSE_CHOSEN 				\
									non_standard_response_chosen

/*
 *	IndicationPDU
 */
#define USER_ID_INDICATION_CHOSEN 						\
									user_id_indication_chosen
#define CONFERENCE_LOCK_INDICATION_CHOSEN 				\
									conference_lock_indication_chosen
#define CONFERENCE_UNLOCK_INDICATION_CHOSEN 			\
									conference_unlock_indication_chosen
#define CONFERENCE_TERMINATE_INDICATION_CHOSEN 			\
									conference_terminate_indication_chosen
#define CONFERENCE_EJECT_USER_INDICATION_CHOSEN 		\
									conference_eject_user_indication_chosen
#define CONFERENCE_TRANSFER_INDICATION_CHOSEN 			\
									conference_transfer_indication_chosen
#define ROSTER_UPDATE_INDICATION_CHOSEN 				\
									roster_update_indication_chosen
#define APPLICATION_INVOKE_INDICATION_CHOSEN 			\
									application_invoke_indication_chosen
#define REGISTRY_MONITOR_ENTRY_INDICATION_CHOSEN 		\
									registry_monitor_entry_indication_chosen
#define CONDUCTOR_ASSIGN_INDICATION_CHOSEN 				\
									conductor_assign_indication_chosen
#define CONDUCTOR_RELEASE_INDICATION_CHOSEN 			\
									conductor_release_indication_chosen
#define CONDUCTOR_PERMISSION_ASK_INDICATION_CHOSEN 		\
									conductor_permission_ask_indication_chosen
#define CONDUCTOR_PERMISSION_GRANT_INDICATION_CHOSEN 	\
									conductor_permission_grant_indication_chosen
#define CONFERENCE_TIME_REMAINING_INDICATION_CHOSEN 	\
									conference_time_remaining_indication_chosen
#define CONFERENCE_TIME_INQUIRE_INDICATION_CHOSEN 		\
									conference_time_inquire_indication_chosen
#define CONFERENCE_TIME_EXTEND_INDICATION_CHOSEN 		\
									conference_time_extend_indication_chosen
#define CONFERENCE_ASSISTANCE_INDICATION_CHOSEN 		\
									conference_assistance_indication_chosen
#define TEXT_MESSAGE_INDICATION_CHOSEN 					\
									text_message_indication_chosen
#define NON_STANDARD_INDICATION_CHOSEN 					\
									non_standard_indication_chosen

/*
 *	GCCPDU
 */
#define REQUEST_CHOSEN 						request_chosen
#define RESPONSE_CHOSEN 					response_chosen
#define INDICATION_CHOSEN 					indication_chosen


/*
 * 	Typedefs for enumerated types generated in "gccpdu.h".
 */

/*
 *	Typedefs for Privilege enumerations.
 */
#define TERMINATE								terminate
#define EJECT_USER								ejectUser
#define ADD										add
#define LOCK_UNLOCK								lockUnlock
#define TRANSFER								transfer

/*
 *	Typedefs for TerminationMethod enumerations.
 */
#define AUTOMATIC								automatic
#define MANUAL									manual

/*
 *	Typedefs for NodeType enumerations.
 */
#define TERMINAL            					terminal
#define MULTIPORT_TERMINAL						multiportTerminal
#define MCU										mcu

/*
 *	Typedefs for ChannelType enumerations.
 */
#define CHANNEL_TYPE_STATIC            			ChannelType_static
#define DYNAMIC_MULTICAST						dynamicMulticast
#define DYNAMIC_PRIVATE							dynamicPrivate
#define DYNAMIC_USER_ID							dynamicUserId

/*
 *	Typedefs for RegistryModificationRights enumerations.
 */
#define OWNER			            		owner
#define SESSION								session
#define REGISTRY_MODIFY_RIGHTS_PUBLIC		RegistryModiFicationRights_public

/*
 *	Typedefs for ConferenceCreateResult enumerations.
 */
#define CCRS_RESULT_SUCCESS	            	ConferenceCreateResult_success
#define CCRS_USER_REJECTED					ConferenceCreateResult_userRejected
#define RESOURCES_NOT_AVAILABLE				resourcesNotAvailable
#define REJECTED_FOR_SYMMETRY_BREAKING		rejectedForSymmetryBreaking
#define LOCKED_CONFERENCE_NOT_SUPPORTED		lockedConferenceNotSupported

/*
 *	Typedefs for ConferenceQueryResult enumerations.
 */
#define CQRS_RESULT_SUCCESS	            	ConferenceQueryResult_success
#define CQRS_USER_REJECTED					ConferenceQueryResult_userRejected

/*
 *	Typedefs for ConferenceJoinResult enumerations.
 */
#define CJRS_RESULT_SUCCESS	            	ConferenceJoinResult_success
#define CJRS_USER_REJECTED					ConferenceJoinResult_userRejected
#define INVALID_CONFERENCE					invalidConference
#define INVALID_PASSWORD					invalidPassword
#define INVALID_CONVENER_PASSWORD			invalidConvenerPassword
#define CHALLENGE_RESPONSE_REQUIRED			challengeResponseRequired
#define INVALID_CHALLENGE_RESPONSE			invalidChallengeResponse

/*
 *	Typedefs for ConferenceInviteResult enumerations.
 */
#define CIRS_RESULT_SUCCESS	            	ConferenceInviteResult_success
#define CIRS_USER_REJECTED					ConferenceInviteResult_userRejected

/*
 *	Typedefs for ConferenceAddResult enumerations.
 */
#define CARS_SUCCESS	            		ConferenceAddResult_success
#define CARS_INVALID_REQUESTER				ConferenceAddResult_invalidRequester
#define INVALID_NETWORK_TYPE				invalidNetworkType
#define INVALID_NETWORK_ADDRESS				invalidNetworkAddress
#define ADDED_NODE_BUSY						addedNodeBusy
#define NETWORK_BUSY						networkBusy
#define NO_PORTS_AVAILABLE					noPortsAvailable
#define CONNECTION_UNSUCCESSFUL				connectionUnsuccessful

/*
 *	Typedefs for ConferenceLockResult enumerations.
 */
#define CLRS_SUCCESS	            		ConferenceLockResult_success
#define CLRS_INVALID_REQUESTER			ConferenceLockResult_invalidRequester
#define CLRS_ALREADY_LOCKED				alreadyLocked

/*
 *	Typedefs for ConferenceUnlockResult enumerations.
 */
#define CURS_SUCCESS	            	ConferenceUnlockResult_success
#define CURS_INVALID_REQUESTER		ConferenceUnlockResult_invalidRequester
#define CURS_ALREADY_UNLOCKED		   alreadyUnlocked

/*
 *	Typedefs for ConferenceTerminateRequestReason enumerations.
 */
#define CTRQ_REASON_USER_INITIATED	 		ConferenceTerminateRequestReason_userInitiated
#define CTRQ_TIMED_CONFERENCE_TERMINATE		ConferenceTerminateRequestReason_timedConferenceTermination

/*
 *	Typedefs for ConferenceTerminateResult enumerations.
 */
#define CTRS_RESULT_SUCCESS	 			ConferenceTerminateResult_success
#define CTRS_INVALID_REQUESTER			ConferenceTerminateResult_invalidRequester

/*
 *	Typedefs for ConferenceTerminateIndicationReason enumerations.
 */
#define CTIN_REASON_USER_INITIATED			ConferenceTerminateIndicationReason_userInitiated
#define CTIN_TIMED_CONFERENCE_TERMINATE		ConferenceTerminateIndicationReason_timedConferenceTermination

/*
 *	Typedefs for ConferenceEjectRequestReason enumerations.
 */
#define CERQ_REASON_USER_INITIATED		ConferenceEjectRequestReason_userInitiated

/*
 *	Typedefs for ConferenceEjectResult enumerations.
 */
#define CERS_RESULT_SUCCESS	 		ConferenceEjectResult_success
#define CERS_INVALID_REQUESTER		ConferenceEjectResult_invalidRequester
#define	CERS_INVALID_NODE			invalidNode

/*
 *	Typedefs for ConferenceEjectIndicationReason enumerations.
 */
#define CEIN_USER_INITIATED			ConferenceEjectIndicationReason_userInitiated
#define HIGHER_NODE_DISCONNECTED	higherNodeDisconnected
#define HIGHER_NODE_EJECTED			higherNodeEjected

/*
 *	Typedefs for ConferenceTransferResult enumerations.
 */
#define CTRANS_RESULT_SUCCESS				ConferenceTransferResult_success
#define CTRANS_RESULT_INVALID_REQUESTER		ConferenceTransferResult_invalidRequester

/*
 *	Typedefs for RegistryAllocateHandleResult enumerations.
 */
#define RARS_RESULT_SUCCESS	 		RegistryAllocateHandleResult_successful
#define NO_HANDLES_AVAILABLE		noHandlesAvailable

/*
 *	Typedefs for RegistryResponsePrimitiveType enumerations.
 */
#define REGISTER_CHANNEL	 		registerChannel
#define ASSIGN_TOKEN				assignToken
#define SET_PARAMETER				setParameter
#define RETRIEVE_ENTRY				retrieveEntry
#define DELETE_ENTRY				deleteEntry
#define MONITOR_ENTRY				monitorEntry

/*
 *	Typedefs for RegistryResponseResult enumerations.
 */
#define RRRS_RESULT_SUCCESSFUL	 		RegistryResponseResult_successful
#define BELONGS_TO_OTHER				belongsToOther
#define TOO_MANY_ENTRIES				tooManyEntries
#define INCONSISTENT_TYPE				inconsistentType
#define ENTRY_NOT_FOUND					entryNotFound
#define ENTRY_ALREADY_EXISTS			entryAlreadyExists
#define RRRS_INVALID_REQUESTER			RegistryResponseResult_invalidRequester


/*
 *	Typedefs for pointers to GCC Connect PDU structures.
 */
typedef	ConferenceCreateRequest			*	PConferenceCreateRequest;
typedef	ConferenceCreateResponse		*	PConferenceCreateResponse;
typedef	ConferenceQueryRequest			*	PConferenceQueryRequest;
typedef	ConferenceQueryResponse			*	PConferenceQueryResponse;
typedef	ConferenceJoinRequest			*	PConferenceJoinRequest;
typedef	ConferenceJoinResponse			*	PConferenceJoinResponse;
typedef	ConferenceInviteRequest			*	PConferenceInviteRequest;
typedef	ConferenceInviteResponse		*	PConferenceInviteResponse;

/*
 *	Typedefs for pointers to GCC Request PDU structures.
 */
typedef	ConferenceTerminateRequest		*	PConferenceTerminateRequest;
typedef	ConferenceEjectUserRequest		*	PConferenceEjectUserRequest;
typedef	ConferenceTransferRequest		*	PConferenceTransferRequest;
typedef ConferenceAddRequest			*	PConferenceAddRequest;


/*
 *	Typedefs for pointers to GCC Response PDU structures.
 */
typedef	ResponsePDU						*	PResponsePDU;
typedef	ConferenceAddResponse			*	PConferenceAddResponse;
typedef	ConferenceLockResponse			*	PConferenceLockResponse;
typedef	ConferenceUnlockResponse		*	PConferenceUnlockResponse;
typedef	ConferenceTerminateResponse		*	PConferenceTerminateResponse;
typedef	ConferenceEjectUserResponse		*	PConferenceEjectUserResponse;
typedef	ConferenceTransferResponse		*	PConferenceTransferResponse;
typedef	RegistryResponse				*	PRegistryResponse;
typedef	RegistryAllocateHandleRequest	*	PRegistryAllocateHandleRequest;
typedef	RegistryAllocateHandleResponse	*	PRegistryAllocateHandleResponse;
typedef	FunctionNotSupportedResponse	*	PFunctionNotSupportedResponse;
typedef	NonStandardPDU					*	PNonStandardPDU;

/*
 *	Typedefs for pointers to GCC Indication PDU structures.
 */
typedef IndicationPDU					*	PIndicationPDU;
typedef	UserIDIndication				*	PUserIDIndication;
typedef	ConferenceLockIndication		*	PConferenceLockIndication;
typedef	ConferenceUnlockIndication		*	PConferenceUnlockIndication;
typedef	ConferenceTerminateIndication	*	PConferenceTerminateIndication;
typedef	ConferenceEjectUserIndication	*	PConferenceEjectUserIndication;
typedef	ConferenceTransferIndication	*	PConferenceTransferIndication;
typedef	RosterUpdateIndication			*	PRosterUpdateIndication;
typedef	ApplicationInvokeIndication		*	PApplicationInvokeIndication;
typedef	RegistryMonitorEntryIndication	*	PRegistryMonitorEntryIndication;
typedef	ConductorAssignIndication		*	PConductorAssignIndication;
typedef	ConductorReleaseIndication		*	PConductorReleaseIndication;
typedef	ConductorPermissionAskIndication
								*	PConductorPermissionAskIndication;
typedef	ConductorPermissionGrantIndication
								*	PConductorPermissionGrantIndication;
typedef	ConferenceTimeRemainingIndication
								*	PConferenceTimeRemainingIndication;
typedef	ConferenceTimeInquireIndication
								*	PConferenceTimeInquireIndication;
typedef	ConferenceTimeExtendIndication	*	PConferenceTimeExtendIndication;
typedef	ConferenceAssistanceIndication	*	PConferenceAssistanceIndication;
typedef	TextMessageIndication			*	PTextMessageIndication;

/*
 *	Typedef for a pointer to the main GCC PDU structure.
 */
typedef	GCCPDU							*	PGCCPDU;
typedef	ConnectGCCPDU					*	PConnectGCCPDU;
typedef ConnectData						*	PConnectData;

/*
 *	Typedef for pointers to password structures.
 */
typedef	Password									*	PPassword;
typedef	PasswordSelector							*	PPasswordSelector;
typedef	PasswordChallengeRequestResponse			
									*	PPasswordChallengeRequestResponse;
typedef	ChallengeRequest							*	PChallengeRequest;
typedef	ChallengeResponse							*	PChallengeResponse;
typedef	ChallengeResponseAlgorithm	*	PChallengeResponseAlgorithm;

/*
 *	Typedefs for other PDU structures.
 */
typedef		ASN1objectidentifier_t              ObjectID;
typedef	    ASN1objectidentifier_s				SetOfObjectID;
typedef		ASN1objectidentifier_t				PSetOfObjectID;
typedef SetOfNodeRecordRefreshes		*		PSetOfNodeRecordRefreshes;
typedef SetOfNodeRecordUpdates			*		PSetOfNodeRecordUpdates;

typedef ParticipantsList				*		PParticipantsList;
typedef NodeType						*		PNodeType;
typedef NodeProperties					*		PNodeProperties;
typedef NodeRecord						*		PNodeRecord;
typedef Key								* 		PKey;
typedef SessionKey						* 		PSessionKey;
typedef ChallengeItem					* 		PChallengeItem;
typedef SetOfChallengeItems		*			PSetOfChallengeItems;

typedef SetOfConferenceDescriptors	*		PSetOfConferenceDescriptors;

typedef NetworkAddress				*		PNetworkAddress;
typedef TransferModes				*		PTransferModes;

typedef HighLayerCompatibility				*		PHighLayerCompatibility;

/*
 * Application related typedefs.
 */
typedef NodeInformation		*					PNodeInformation;

typedef SetOfApplicationRecordRefreshes		* PSetOfApplicationRecordRefreshes;


typedef SetOfApplicationCapabilityRefreshes		*	
										PSetOfApplicationCapabilityRefreshes;

typedef ApplicationRecord				*	PApplicationRecord;

typedef CapabilityID				*	PCapabilityID;

typedef SetOfNonCollapsingCapabilities	*	PSetOfNonCollapsingCapabilities;

typedef RegistryKey				*	PRegistryKey;
typedef RegistryItem			*	PRegistryItem;

typedef PermissionList		*						PPermissionList;

typedef WaitingList		*							PWaitingList;

typedef SetOfDestinationNodes	*	PSetOfDestinationNodes;

typedef ApplicationProtocolEntityList	*		PApplicationProtocolEntityList;
typedef SetOfExpectedCapabilities	*			PSetOfExpectedCapabilities;
												
												
typedef	SetOfTransferringNodesRq	*	PSetOfTransferringNodesRq;

typedef	SetOfTransferringNodesRs	*	PSetOfTransferringNodesRs;

typedef	SetOfTransferringNodesIn	*	PSetOfTransferringNodesIn;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\password.h ===
/*
 *	password.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class CPassword.  This class
 *		manages the data associated with a Password.  Passwords are used to 
 *		restrict access to conferences.  A password can be one of two basic
 *		types.  The simple type consists of either a simple numeric password or
 *		a simple textual password, or both.  The "PDU" type "Password" is a
 *		structure which must contain the numeric form of the password and may
 *		optionally contain the textual part as well.  The "PDU" type
 *		"PasswordSelector" is a union of the numeric and textual forms of a
 *		password and is therefore always one or the other but not both.  When
 *		the password is not the simple type it assumes the form of a
 *		"PasswordChallengeRequestResponse".  This complex structure allows a
 *		challenge-response scheme to be used to control access to conferences.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */
#ifndef	_PASSWORD_DATA_
#define	_PASSWORD_DATA_

#include "userdata.h"

class CPassword;

/*
 * This is the typedef for the structure used to maintain the challenge 
 * response algorithms internally.
 */
typedef struct
{
	GCCPasswordAlgorithmType	algorithm_type;
	CObjectKeyContainer 	    *object_key;
	LPOSTR						poszOctetString;
} ResponseAlgorithmInfo;
typedef	ResponseAlgorithmInfo * 	PResponseAlgorithmInfo;

/*
 * This is the typedef for the structure used to maintain the challenge items 
 * associated with a challenge request.
 */
typedef struct
{
	ResponseAlgorithmInfo		algorithm;
	CUserDataListContainer      *challenge_data_list;
} ChallengeItemInfo;
typedef	ChallengeItemInfo * 	PChallengeItemInfo;

/*
 * This is the typedef for the structure used to maintain the memory used 
 * to hold the user data and object key data associated with a challenge 
 * request item.
 */
typedef struct
{
	LPBYTE						user_data_list_memory;
	LPBYTE						object_key_memory;
} ChallengeItemMemoryInfo;
typedef	ChallengeItemMemoryInfo * 	PChallengeItemMemoryInfo;

/*
 * This is the typedef for the structure used to maintain the 
 * challenge-reponse items internally.
 */
typedef struct
{
	CPassword                   *password;
	CUserDataListContainer	    *response_data_list;
} ChallengeResponseItemInfo;
typedef	ChallengeResponseItemInfo * 	PChallengeResponseItemInfo;

/*
 * The set of challenge items is maintained internally in a linked List.
 */
class CChallengeItemList : public CList
{
    DEFINE_CLIST(CChallengeItemList, PChallengeItemInfo)
};

/*
 * The memory associated with each challenge item is maintained internally in 
 * linked List.
 */
class CChallengeItemMemoryList : public CList
{
    DEFINE_CLIST(CChallengeItemMemoryList, PChallengeItemMemoryInfo)
};

/*
 * This is the typedef for the structure used to maintain the "Request" 
 * data internally.
 */
typedef struct
{
	GCCResponseTag				challenge_tag;
	CChallengeItemList			ChallengeItemList;
}
    RequestInfo, *PRequestInfo;

/*
 * This is the typedef for the structure used to maintain the "Response" 
 * data internally.
 */
typedef struct
{
	GCCResponseTag						challenge_tag;
	ResponseAlgorithmInfo				algorithm;
	ChallengeResponseItemInfo			challenge_response_item;
}
    ResponseInfo, *PResponseInfo;

/*
 * Class definition:
 */
class CPassword : public CRefCount
{
public:

	CPassword(PGCCPassword, PGCCError);
	CPassword(PGCCChallengeRequestResponse, PGCCError);
	CPassword(PPassword, PGCCError);
	CPassword(PPasswordSelector, PGCCError);
	CPassword(PPasswordChallengeRequestResponse, PGCCError);

    ~CPassword(void);

	GCCError	LockPasswordData(void);
	void		UnLockPasswordData(void);
	GCCError	GetPasswordData(PGCCPassword *);
	GCCError	GetPasswordChallengeData(PGCCChallengeRequestResponse *);
	GCCError	GetPasswordPDU(PPassword);
	GCCError	GetPasswordSelectorPDU(PPasswordSelector);
	GCCError	GetPasswordChallengeResponsePDU(PPasswordChallengeRequestResponse);
	void		FreePasswordChallengeResponsePDU(void);

protected:

    BOOL							m_fSimplePassword;
    BOOL							m_fClearPassword;

    /*
     * Variables and structures used to hold the password data internally.
     */
    LPSTR							m_pszNumeric;
    LPWSTR							m_pwszText;
    PRequestInfo					m_pInternalRequest;
    PResponseInfo					m_pInternalResponse;

    /*
     * Structures used to hold the password data in "API" form.
     */
    PGCCChallengeRequestResponse	m_pChallengeResponse;
    PGCCPassword					m_pPassword;
    LPBYTE							m_pUserDataMemory;
    LPBYTE							m_pChallengeItemListMemory;
    LPBYTE							m_pObjectKeyMemory;
    CChallengeItemMemoryList		m_ChallengeItemMemoryList;

    /*
     * Structure used to hold the password data in "PDU" form.
     */
    PasswordChallengeRequestResponse		m_ChallengeResponsePDU;
    BOOL									m_fValidChallengeResponsePDU;

private:

	GCCError	ConvertAPIChallengeRequest(PGCCChallengeRequest);
	GCCError	ConvertAPIChallengeResponse(PGCCChallengeResponse);
	GCCError	CopyResponseAlgorithm(PGCCChallengeResponseAlgorithm, PResponseAlgorithmInfo);
	GCCError	ConvertPDUChallengeRequest(PChallengeRequest);
	GCCError	ConvertPDUChallengeItem(PChallengeItem);
	GCCError	ConvertPDUChallengeResponse(PChallengeResponse);
	GCCError	ConvertPDUResponseAlgorithm(PChallengeResponseAlgorithm, PResponseAlgorithmInfo);
	GCCError	GetGCCChallengeRequest(PGCCChallengeRequest);
	GCCError	GetGCCChallengeResponse(PGCCChallengeResponse);
	GCCError	GetChallengeRequestPDU(PChallengeRequest);
	GCCError	ConvertInternalChallengeItemToPDU(PChallengeItemInfo, PChallengeItem);
	GCCError	GetChallengeResponsePDU(PChallengeResponse);
	void		FreeChallengeRequestPDU(void);
	void		FreeChallengeResponsePDU(void);
    void		FreeAPIPasswordData(void);
};

/*
 *	Comments explaining the public and protected class member functions
 */

/*
 *	CPassword (	PGCCPassword		password,
 *					PGCCError			return_value);
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This is the constructor for the CPassword class which takes as
 *		input the "API" version of password data, GCCPassword.
 *
 *	Formal Parameters:
 *		password			(i)	The password data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PASSWORD			-	An invalid password passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	CPassword ( 	PGCCChallengeRequestResponse		challenge_response_data,
 *					PGCCError							return_value)
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This is the constructor for the CPassword class which takes as
 *		input the "API" version of password challenge data, 
 *		GCCChallengeRequestResponse.
 *
 *	Formal Parameters:
 *		challenge_response_data	(i)	The password challenge data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PASSWORD			-	An invalid password passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	CPassword ( 	PPassword				password_pdu,
 *					PGCCError				return_value)
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This is the constructor for the CPassword class which takes as
 *		input the "PDU" version of password data, Password.
 *
 *	Formal Parameters:
 *		password_pdu		(i)	The password data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PASSWORD			-	An invalid password passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	CPassword(	PPasswordSelector			password_selector_pdu,
 *					PGCCError					return_value)
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This is the constructor for the CPassword class which takes as
 *		input the "PDU" version of password data, PasswordSelector.
 *
 *	Formal Parameters:
 *		password_selector_pdu	(i)	The password selector data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PASSWORD			-	An invalid password passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	CPassword (	PPasswordChallengeRequestResponse	pdu_challenge_data,
 *					PGCCError							return_value)
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This is the constructor for the CPassword class which takes as
 *		input the "PDU" version of password challenge data, 
 *		PasswordChallengeRequestResponse.
 *
 *	Formal Parameters:
 *		pdu_challenge_data	(i)	The password challenge data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PASSWORD			-	An invalid password passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	~CPassword();
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This is the destructor for the CPassword class.  It is used to
 *		clean up any memory allocated during the life of this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	LockPasswordData ();
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to "lock" the "API" data for this object.  This
 *		results in the appropriate form of the "API" password being stored
 *		internally in preparation for a call to "GetGCCPasswordData" which will
 *		return that data.  
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		The internal lock count is incremented.
 *
 *	Caveats:
 *		The internal lock count is used in conjuction with an internal "free" 
 *		flag as a mechanism for ensuring that this object remains in existance 
 *		until all interested parties are through with it.  The object remains 
 *		valid (unless explicity deleted) until the lock count is zero and the 
 *		"free" flag is set through a call to FreePasswordData.  This allows
 *		other objects to lock this object and be sure that it remains valid 
 *		until they call UnLock which will decrement the internal lock count.  A
 *		typical usage scenerio for this object would be:  A CPassword
 *		object is constructed and then passed off to any interested parties
 *		through a function call.  On return from the function call, the
 *		FreePasswordData call is made which will set the internal "free"
 *		flag.  If no other parties have locked the object with a Lock call,
 *		then the CPassword object will automatically delete itself when
 *		the FreePasswordData call is made.  If, however, any number of 
 *		other parties has locked the object, it will remain in existence until
 *		each of them has unlocked the object through a call to UnLock.
 */


/*
 *	GCCError	GetPasswordData (	PGCCPassword	 *	gcc_password)
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to retrieve the password data from the
 *		CPassword object in the "API" form of a GCCPassword.
 *
 *	Formal Parameters:
 *		gcc_password			(o)	The GCCPassword structure to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	The object was not properly locked
 *												prior to this call.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	GetPasswordChallengeData (
 *					PGCCChallengeRequestResponse	 *	gcc_challenge_password)
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to retrieve the password challenge data from the
 *		CPassword object in the "API" form of a GCCChallengeRequestResponse.
 *
 *	Formal Parameters:
 *		gcc_challenge_password		(o)	The GCCChallengeRequestResponse 
 *											structure to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	The object was not properly locked
 *												prior to this call.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void	UnLockPasswordData ();
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine 
 *		whether the object has been freed through a call to FreePasswordData.
 *		If so, the object will automatically delete	itself.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal lock count is decremented.
 *
 *	Caveats:
 *		It is the responsibility of any party which locks a CPassword
 *		object by calling Lock to also unlock the object with a call to UnLock.
 *		If the party calling UnLock did not construct the CPassword 
 *		object,	it should assume the object to be invalid thereafter.
 */


/*
 *	GCCError	GetPasswordPDU (PPassword		pdu_password)
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to retrieve the password data from the
 *		CPassword object in the "PDU" form of a Password.
 *
 *	Formal Parameters:
 *		pdu_password		(o)	The Password structure to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	The required numeric portion of the
 *												password does not exist.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	GetPasswordSelectorPDU(
 *					PPasswordSelector				password_selector_pdu)
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to retrieve the password data from the
 *		CPassword object in the "PDU" form of a PasswordSelector.
 *
 *	Formal Parameters:
 *		password_selector_pdu	(o)	The PasswordSelector structure to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_INVALID_PASSWORD			- 	Neither the numeric nor the textual
 *												form of the password are valid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	GetPasswordChallengeResponsePDU(
 *					PPasswordChallengeRequestResponse	challenge_pdu)
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to retrieve the password challenge data from the
 *		CPassword object in the "PDU" form of a 
 *		PasswordChallengeRequestResponse.
 *
 *	Formal Parameters:
 *		challenge_pdu			(o)	The PasswordChallengeRequestResponse 
 *										structure to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_INVALID_PARAMETER			-	Invalid attempt to retrieve
 *												challenge data from a simple
 *												password.
 *		GCC_INVALID_PASSWORD			-	The challenge password is "clear"
 *												but no valid data exists.
 *		GCC_ALLOCATION_FAILURE			- 	Neither the numeric nor the textual
 *												form of the password are valid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void	FreePasswordChallengeResponsePDU ()
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to "free" the "PDU" data allocated for this object
 *		which is held internally in a GCCChallengeRequestResponse structure.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal "free" flag is set.
 *
 *	Caveats:
 *		This object should be assumed invalid after a call to 
 *		FreePasswordChallengeResponsePDU has been made.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\pktcoder.h ===
/*
 *	pktcoder.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the PacketCoder class.  This
 *		is an abstract base class which cannot be directly instantiated, but 
 *		rather, exists to be inherited from.  It defines  a set of virtual 
 *		member functions which will be shared by all classes that inherit from 
 *		this one.  This class defines the behaviors necessary to encode, 
 *		decode, and manipulate Protocol Data Unit (PDU) structures.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		John B. O'Nan
 */
#ifndef	_PACKETCODER_
#define	_PACKETCODER_

/*
 * Macros.
 */
#define		BASIC_ENCODING_RULES	0
#define		PACKED_ENCODING_RULES	1

/*
 *	This enumeration defines the various errors that can be returned during
 *	the use of a PacketCoder object.
 */
typedef	enum
{
	PACKET_CODER_NO_ERROR,
	PACKET_CODER_BAD_REVERSE_ATTEMPT,
	PACKET_CODER_INCOMPATIBLE_PROTOCOL
} PacketCoderError;
typedef	PacketCoderError *		PPacketCoderError;


/*
 *	This is the class definition for class PacketCoder
 */
class	PacketCoder
{
	public:
		virtual			~PacketCoder ();
		virtual	BOOL	Encode (LPVOID			pdu_structure,
								int				pdu_type,
								UINT			rules_type,
								LPBYTE			*encoding_buffer,
								UINT			*encoding_buffer_length) = 0;

		virtual BOOL	Decode (LPBYTE			encoded_buffer,
								UINT			encoded_buffer_length,
								int				pdu_type,
								UINT			rules_type,
								LPVOID			*pdecoding_buffer,
								UINT			*pdecoding_buffer_length) = 0;

		virtual DBBoolean IsMCSDataPacket (	LPBYTE			encoded_buffer,
											UINT			rules_type) = 0;
		virtual void	FreeEncoded (LPBYTE encoded_buffer) = 0;

		virtual void	FreeDecoded (int pdu_type, LPVOID decoded_buffer) = 0;

};
typedef PacketCoder *	PPacketCoder;

/*
 *	~PacketCoder ()
 *
 *	Functional Description:
 *		This is a virtual destructor.  It does not actually do anything in this
 *		class.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	void Encode (	LPVOID		pdu_structure,
 *					int			pdu_type,
 *					LPBYTE		*encoding_buffer,
 *					UINT		*encoding_buffer_length)
 *
 *	Functional Description:
 *		This function encodes Protocol data units (PDU's) into ASN.1 compliant
 *		byte streams.
 *		The coder allocates the buffer space for the encoded data.
 *
 *	Formal Parameters:
 *		pdu_structure (i)		Pointer to structure holding PDU data.
 *		pdu_type (i)			Define indicating type of PDU.
 *		encoding_buffer (o)		Pointer to buffer to hold encoded data.
 *		encoding_buffer_length (o) Pointer to length of buffer for encoded data.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	void Decode (	LPBYTE		encoded_buffer,
 *					UINT		encoded_buffer_length,
 *					int			pdu_type,
 *					LPVOID		decoding_buffer,
 *					UINT		decoding_buffer_length,
 *					UINT		*pulDataOffset)
 *
 *	Functional Description:
 *		This function decodes ASN.1 compliant byte streams into the
 *		appropriate PDU structures.
 *
 *	Formal Parameters:
 *		encoded_buffer (i)		Pointer to buffer holding data to decode.
 *		encoded_buffer_length (i) Length of buffer holding data to decode.
 *		pdu_type (o)			Returns type of PDU.
 *		decoding_buffer (o)		Pointer to buffer to hold the decoded data.
 *		decoding_buffer_length (i) Length of buffer to hold the decoded data.
 *		pulDataOffset (o)		Pointer to a value that stores the offset of the data in an encoded MCS data packet.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	void	CopyDecodedData (	LPVOID		pdu_source_structure,
 *								LPVOID		pdu_destination_structure,
 *								int			pdu_type)
 *
 *	Functional Description:
 *		This function makes a copy of the non-encoded PDU structure.  It returns
 *		the length of the structure it has created.  Normally, this will just
 *		be the length of the source structure but the length is returned for
 *		added flexibility later.
 *
 *	Formal Parameters:
 *		pdu_source_structure(i)			Pointer to structure holding PDU data.
 *		pdu_destination_structure(o)	Pointer to structure to hold copy of
 *										PDU data.
 *		pdu_type (i)					The type of PDU to copy.
 *
 *	Return Value:
 *		Size of the destination PDU structure.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	DBBoolean	IsMCSDataPacket ()
 *
 *	Functional Description:
 *		This function determines whether the encoded packet is an MCS Data packet
 *		or not.
 *
 *	Formal Parameters:
 *		encoded_buffer (i)		Pointer to buffer holding the encoded PDU.
 *		rules_type (i)			The used encoding rules.
 *
 *	Return value:
 *		TRUE, if the packet is an MCS Data packet. FALSE, otherwise.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\privchnl.h ===
/*
 *	privchnl.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the PrivateChannel class.  Objects of
 *		this class represent private channels in the MCS environment.  This
 *		class inherits much of its behavior from class Channel.  However,
 *		objects of this class maintain a list of authorized users, and do not
 *		allow any other users to use the channel.  Users that are not part
 *		of the authorized user list may not join the channel, nor may they
 *		even send data on the channel.
 *
 *		Private channels are created as the result of a user issuing a
 *		channel convene request.  This user is known as the channel manager.
 *		Only the channel manager may modify the authorized user list, and
 *		only the channel manager may destroy (disband) the private channel.
 *
 *		The channel adds users to the authorized user list by issuing a
 *		channel admit request.  Users are removed from this list when the
 *		channel manager issues a channel expel request.
 *
 *		Private channel objects will exist in the information base of all
 *		providers who contain either an admitted user or the channel
 *		manager in their sub-tree.  Requests pass upward to the Top Provider
 *		who issues the appropriate indications downward to manage the
 *		information base synchronization process.
 *
 *		Private channel objects restrict the joining of channel by overriding
 *		the join commands.  They restrict the transmission of data by
 *		overriding the send data commands.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	_PRIVATECHANNEL_
#define	_PRIVATECHANNEL_


/*
 *	This is the class definition for the PrivateChannel class.
 */
class	PrivateChannel : public Channel
{
public:
	PrivateChannel (
			ChannelID			channel_id,
			UserID				channel_manager,
			PDomain             local_provider,
			PConnection         top_provider,
			CChannelList2      *channel_list,
			CAttachmentList    *attachment_list);
	PrivateChannel (
			ChannelID			channel_id,
			UserID				channel_manager,
			PDomain             local_provider,
			PConnection         top_provider,
			CChannelList2      *channel_list,
			CAttachmentList    *attachment_list,
			CUidList           *admitted_list,
			PConnection         pConn);
    virtual					~PrivateChannel ();
		virtual Channel_Type	GetChannelType ();
		virtual	BOOL    		IsValid ();
		virtual CAttachment *GetAttachment(void);
		virtual	Void			IssueMergeRequest ();
		virtual Void			ChannelJoinRequest (
										CAttachment        *originator,
										UserID				uidInitiator,
										ChannelID			channel_id);
		Void			ChannelDisbandRequest (
										CAttachment        *originator,
										UserID				uidInitiator,
										ChannelID			channel_id);
		Void			ChannelDisbandIndication (
										ChannelID			channel_id);
		Void			ChannelAdmitRequest (
										CAttachment        *originator,
										UserID				uidInitiator,
										ChannelID			channel_id,
										CUidList           *user_id_list);
		Void			ChannelAdmitIndication (
										PConnection         originator,
										UserID				uidInitiator,
										ChannelID			channel_id,
										CUidList           *user_id_list);
		Void			ChannelExpelRequest (
										CAttachment        *originator,
										UserID				uidInitiator,
										ChannelID			channel_id,
										CUidList           *user_id_list);
		Void			ChannelExpelIndication (
										PConnection         originator,
										ChannelID			channel_id,
										CUidList           *user_id_list);
		virtual Void			SendDataRequest (
										CAttachment        *originator,
										UINT				type,
										PDataPacket			data_packet);
	private:
				BOOL    		ValidateUserID (
										UserID				user_id);
				Void			BuildAttachmentLists (
										CUidList            *user_id_list,
										CAttachmentList     *local_attachment_list,
										CAttachmentList     *remote_attachment_list);
				Void			BuildUserIDList (
										CUidList           *user_id_list,
										CAttachment        *attachment,
										CUidList           *user_id_subset);

private:

	UserID					m_uidChannelManager;
	CUidList				m_AuthorizedUserList;
	BOOL    				m_fDisbandRequestPending;
};

/*
 *	PrivateChannel (
 *			ChannelID			channel_id,
 *			UserID				channel_manager,
 *			PDomain     		local_provider,
 *			PConnection 		top_provider,
 *			PChannelList		channel_list,
 *			PAttachmentList		attachment_list)
 *
 *	Functional Description:
 *		This is the normal constructor for the PrivateChannel class.  It simply
 *		initializes the instance variables that identify the channel, the local
 *		provider, the top provider, and the channel manager.  The attachment
 *		list is empty by default (meaning that no users have joined the
 *		channel).  The authorized user list is also empty by default.
 *
 *		Upon successful construction of this object, a channel convene confirm
 *		is automatically issued to the channel manager, if it is in the
 *		sub-tree of this provider.
 *
 *	Formal Parameters:
 *		channel_id (i)
 *			This is the ID of the channel object.  By keeping track of this
 *			internally, it doesn't have to be passed in for every operation.
 *		channel_manager (i)
 *			This is the user ID of the channel manager.  Only this user is
 *			permitted to expand or reduce the size of the authorized user list.
 *		local_provider (i)
 *			This is the identity of the local provider.  A PrivateChannel object
 *			needs this since it issues MCS commands on behalf of the local
 *			provider.
 *		top_provider (i)
 *			This is a pointer to the top provider.  This is used by the
 *			PrivateChannel object when it needs to issue a request to the Top
 *			Provider.
 *		channel_list (i)
 *			This is a pointer to the domain's channel list, which identifies
 *			all valid channels in the domain.  This is used by channel objects
 *			to validate user IDs.
 *		attachment_list (i)
 *			This is a pointer to the domain's attachment list, which identifies
 *			all valid attachments in the domain.  This is used by channel
 *			objects to validate joined attachments.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	PrivateChannel (
 *			ChannelID			channel_id,
 *			UserID				channel_manager,
 *			PDomain     		local_provider,
 *			PConnection 		top_provider,
 *			PChannelList		channel_list,
 *			PAttachmentList		attachment_list,
 *			CUidList           *admitted_list,
 *			PCommandTarget		attachment)
 *
 *	Functional Description:
 *		This is a secondary version of the constructor that is used only during
 *		merge operations.  The only difference between this one and the one
 *		above is that this one allows the specification of an initial
 *		attachment.  This allows a PrivateChannel object to be constructed with
 *		an attachment already joined to the channel.
 *
 *		This version of the constructor will not issue a channel convene confirm
 *		or a channel join confirm to the user.
 *
 *	Formal Parameters:
 *		channel_id (i)
 *			This is the ID of the channel object.  By keeping track of this
 *			internally, it doesn't have to be passed in for every operation.
 *		channel_manager (i)
 *			This is the user ID of the channel manager.  Only this user is
 *			permitted to expand or reduce the size of the authorized user list.
 *		local_provider (i)
 *			This is the identity of the local provider.  A PrivateChannel object
 *			needs this since it issues MCS commands on behalf of the local
 *			provider.
 *		top_provider (i)
 *			This is a pointer to the top provider.  This is used by the
 *			PrivateChannel object when it needs to issue a request to the Top
 *			Provider.
 *		channel_list (i)
 *			This is a pointer to the domain's channel list, which identifies
 *			all valid channels in the domain.  This is used by channel objects
 *			to validate user IDs.
 *		attachment_list (i)
 *			This is a pointer to the domain's attachment list, which identifies
 *			all valid attachments in the domain.  This is used by channel
 *			objects to validate joined attachments.
 *		admitted_list (i)
 *			This is a list of users that are admitted to the channel at the
 *			time of the merge.
 *		attachment (i)
 *			This is the initial attachment for the channel.  A channel join
 *			confirm is NOT issued to the attachment.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~PrivateChannel ()
 *
 *	Functional Description:
 *		This is the PrivateChannel class destructor.  It does nothing at this
 *		time.  The base class constructor takes care of clearing the attachment
 *		list.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Channel_Type	GetChannelType ()
 *
 *	Functional Description:
 *		This virtual member function returns the type of the channel.  For this
 *		class it will always be PRIVATE_CHANNEL.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		PRIVATE_CHANNEL
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	BOOL    	IsValid ()
 *
 *	Functional Description:
 *		This function will return TRUE until the channel is disbanded.  Then
 *		it will return FALSE to indicate that the channel object can be deleted
 *		from the domain infirmation base.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		TRUE if channel still valid.
 *		FALSE if the channel has been disbanded.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	CAttachment *GetAttachment ()
 *
 *	Functional Description:
 *		This function returns the attachment which leads to the private channel
 *		manager.  If the channel manager is not in the sub-tree of this
 *		provider, it returns NULL.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		Attachment that leads to channel manager, or NULL if channel manager is
 *		not in the sub-tree of this provider.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		IssueMergeRequest ()
 *
 *	Functional Description:
 *		This member function causes the PrivateChannel object to issue a merge
 *		request to the top provider.  It will pack the appropriate local
 *		information into the command.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelJoinRequest (
 *						PCommandTarget		originator,
 *						UserID				uidInitiator,
 *						ChannelID			channel_id)
 *
 *	Functional Description:
 *		This function is invoked when a user tries to join the private channel
 *		associated with a PrivateChannel object.  The originator of the request
 *		will only be permitted to join if their user ID is contained in the
 *		authorized user list,  If it does, then the originator will be permitted
 *		to join.
 *
 *		If this provider is not the Top Provider, then the request will be
 *		forwarded upward to the Top Provider.  If this is the Top Provider,
 *		the a channel join confirm will be issued back to the requesting
 *		user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which this command originated.
 *		uidInitiator (i)
 *			This is the user ID of the user joining the channel.  This must
 *			be contained in  the authorized user list maintained by the object,
 *			or the request will automatically be rejected.
 *		channel_id (i)
 *			This is the channel being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ChannelDisbandRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This function is invoked when a user tries to destroy an existing
 *		private channel.  This is only permitted if the operation is invoked
 *		by the manager of the specified private channel.
 *
 *		If this provider is not the Top Provider, then the request will be
 *		forwarded upward to the Top Provider.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which this command originated.
 *		uidInitiator (i)
 *			This is the user ID of the user disbanding the channel.  This must
 *			be the same as the user ID of the private channel manager, or the
 *			request will automatically be rejected.
 *		channel_id (i)
 *			This is the channel being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ChannelDisbandIndication (
 *					PCommandTarget		originator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This function is invoked when the Top Provider determines the need to
 *		destroy a private channel.  This may be done in response to a
 *		disband request from the channel manager, or it may be done for
 *		other reasons (such as the channel manager detaching from the domain).
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which this command originated.
 *		channel_id (i)
 *			This is the channel being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ChannelAdmitRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This function is invoked when a user tries to expand the authorized
 *		user list of a private channel.  This operation will only be permitted
 *		if the uidInitiator is the same as the user ID of the private channel
 *		manager.
 *
 *		If this is the Top Provider, this request will be serviced locally,
 *		resulting in the transmission of a channel admit indication to all
 *		downward attachments that contain an admitted user in their sub-tree.
 *		If this is not the Top Provider, ths request will forwarded toward
 *		the Top Provider once the request has been validated.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which this command originated.
 *		uidInitiator (i)
 *			This is the user ID of the user who is attempting to add users to
 *			the authorized user list.  This must be the same as the user ID
 *			represented by the object, or the request will automatically be
 *			rejected.
 *		channel_id (i)
 *			This is the channel being acted upon.
 *		user_id_list (i)
 *			This is a list containing the IDs of the users to added to the
 *			user list.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ChannelAdmitIndication (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This function is invoked by the Top Provider upon reception of a
 *		channel admit request from the legitimate manager of a private channel.
 *		It travels downward toward any providers that contain an admitted user
 *		in their sub-tree.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which this command originated.
 *		uidInitiator (i)
 *			This is the user ID of the user who is attempting to add users to
 *			the authorized user list.  This must be the same as the user ID
 *			represented by the object, or the request will automatically be
 *			rejected.
 *		channel_id (i)
 *			This is the channel being acted upon.
 *		user_id_list (i)
 *			This is a list containing the IDs of the users to added to the
 *			user list.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ChannelExpelRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This function is invoked when a user tries to shrink the authorized
 *		user list of a private channel.  This operation will only be permitted
 *		if the uidInitiator is the same as the user ID of the private channel
 *		manager.
 *
 *		If this is the Top Provider, this request will be serviced locally,
 *		resulting in the transmission of a channel admit indication to all
 *		downward attachments that contain an admitted user in their sub-tree.
 *		If this is not the Top Provider, ths request will forwarded toward
 *		the Top Provider once the request has been validated.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which this command originated.
 *		uidInitiator (i)
 *			This is the user ID of the user who is attempting to remove users
 *			from the authorized user list.  This must be the same as the user ID
 *			represented by the object, or the request will automatically be
 *			rejected.
 *		channel_id (i)
 *			This is the channel being acted upon.
 *		user_id_list (i)
 *			This is a list containing the IDs of the users to removed from the
 *			user list.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ChannelExpelIndication (
 *					PCommandTarget		originator,
 *					ChannelID			channel_id,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This function is invoked by the Top Provider upon reception of a
 *		channel expel request from the legitimate manager of a private channel.
 *		It travels downward toward any providers that contain (or used to
 *		contain) an admitted user in their sub-tree.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which this command originated.
 *		uidInitiator (i)
 *			This is the user ID of the user who is attempting to remove users
 *			from the authorized user list.  This must be the same as the user ID
 *			represented by the object, or the request will automatically be
 *			rejected.
 *		channel_id (i)
 *			This is the channel being acted upon.
 *		user_id_list (i)
 *			This is a list containing the IDs of the users to removed from the
 *			user list.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		SendDataRequest (
 *						PCommandTarget		originator,
 *						UINT				type,
 *						PDataPacket			data_packet)
 *
 *	Functional Description:
 *		This function is called when it is necessary to send data through the
 *		channel that this PrivateChannel object represents.  The identity of
 *		the requesting user will be validated to make sure the user is allowed
 *		to send data on the private channel.  If so, then the request is
 *		passed to the Channel class SendDataRequest to be processed.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the data came.
 *		type (i)
 *			Normal or uniform send data request.
 *		data_packet (i)
 *			This is a pointer to a DataPacket object containing the channel
 *			ID, the User ID of the data sender, segmentation flags, priority of
 *			the data packet and a pointer to the packet to be sent.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\privlist.h ===
/*
 *	privlist.h
 *
 *	Copyright (c) 1993 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the header file for the class PrivilegeListData.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */
#ifndef	_PRIVILEGE_LIST_DATA_
#define	_PRIVILEGE_LIST_DATA_


typedef enum
{
	TERMINATE_PRIVILEGE,
	EJECT_USER_PRIVILEGE,
	ADD_PRIVILEGE,
	LOCK_UNLOCK_PRIVILEGE,
	TRANSFER_PRIVILEGE
} ConferencePrivilegeType;
typedef	ConferencePrivilegeType	*	PConferencePrivilegeType;


class 	PrivilegeListData;
typedef	PrivilegeListData 	*	PPrivilegeListData;


class PrivilegeListData
{
public:

	PrivilegeListData(PGCCConferencePrivileges);
	PrivilegeListData(PSetOfPrivileges);
	~PrivilegeListData(void);

	PGCCConferencePrivileges GetPrivilegeListData(void) { return &Privilege_List; }
	void GetPrivilegeListData(PGCCConferencePrivileges *pp) { *pp = &Privilege_List; }

	GCCError	GetPrivilegeListPDU(PSetOfPrivileges *);
	void		FreePrivilegeListPDU(PSetOfPrivileges);
	BOOL    	IsPrivilegeAvailable(ConferencePrivilegeType);

protected:

	GCCConferencePrivileges		Privilege_List;
	BOOL        				Privilege_List_Free_Flag;
};
typedef	PrivilegeListData 	*		PPrivilegeListData;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\randchnl.h ===
/*
 *	randchnl.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the RandomChannelGenerator class.  This
 *		class inherits from the RandomNumberGenerator class.  On instantiation,
 *		instances of this class will internally generate a random number which
 *		falls within the allowable range of dynamic channel values.  Channel
 *		assignments are then generated by incrementing this value each time a
 *		new assignment is requested.  Once the maximum allowable value has been
 *		assigned, the next value to be generated "wraps around" to the minimum
 *		allowable value.
 *
 *		Obviously, this class does not generate completely random channel
 *		values for each request.  With a completely random generator, it is
 *		possible to delete a channel in MCS, and then have the random number
 *		generator assign the same value as the deleted channel before all
 *		components of the system even know that the channel was deleted to
 *		start with, thus causing erratic behavior in the system.  In this
 *		class, no channel can be reassigned until all other possible channels
 *		have been assigned.
 *
 *		This class can be modifed in the future to incorporate additional
 *		"randomness" into the algorithm and still not reassign any channel
 *		numbers before all other possible values are used.  This, however,
 *		would be at the expense of performance and/or memory resources.
 *                  
 *	Caveats:
 *		None.
 *
 *	Author:
 *		Alan D. May
 */
#ifndef _RANDOM_CHANNEL_GENERATOR_
#define _RANDOM_CHANNEL_GENERATOR_

#include "databeam.h"
#include "random.h"

/*
 *	The definition of the RandomChannelGenerator class.
 */
class RandomChannelGenerator
{
	public:
						RandomChannelGenerator ();
		virtual			~RandomChannelGenerator ();
		RandomValue		GetRandomChannel ();

	private:
		ULong			Current_Channel;
};		
typedef RandomChannelGenerator *		PRandomChannelGenerator;

/*
 *	RandomChannelGenerator ()
 *
 *	Functional Description:
 *		The constructor creates a random channel generator object by calling the
 *		constructor for the parent class, RandomNumberGenerator.  This then
 *		automatically seeds the random number generator with the current time.
 *		The default algorithm will be used.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~RandomChannelGenerator ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the destructor for the RandomChannelGenerator class.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	RandomValue		GetRandomChannel ()
 *
 *	Public
 *
 *	Functional Description:
 *		This method returns a valid dynamic channel number.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		A RandomValue in the range of valid dynamic channel values.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\random.h ===
/*
 *	random.h
 *
 *	Copyright (c) 1993-1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the RandomNumberGenerator class.
 *		Instances of this class can generate random numbers within a specifed
 *		range on demand.  Many of these objects can exist at once, and they
 *		will not interfere with each other.
 *                  
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James J. Johnstone IV
 */
#ifndef _RANDOM_
#define _RANDOM_

/*
 *	The data type of the return value of the RandomNumberGenerator class.
 */

typedef	ULong				RandomValue;

#ifdef USE_RANDOM_CLASS

/*
 *	This typedef is an enumeration of all possible random number generation
 *	algorithms and is used when constructing a new random number generator.
 *	See "Numerical Recipes in 'C'" for details as to the difference between
 *	the various algorithms.
 */
typedef	enum
{
	ALGORITHM_RAN1,
	ALGORITHM_RANQD2,
	ALGORITHM_RAN4
} Algorithm;
typedef	Algorithm * 		PAlgorithm;

/*
 *	The default algorithm for the random number generator object.
 */
#define DEFAULT_ALGORITHM	ALGORITHM_RAN1

/*
 *	If specified as the seed value, a random seed will be generated by the 
 *	random number generator.
 */
#define RANDOM_SEED			0

/*
 *	Defines for ran1() algorithm from "Numerical Recipes in 'C'"
 */
#define IA					16807
#define	IM					2147483647L
#define	AM					(1.0/IM)
#define IQ					127773L
#define IR					2836
#define	NTAB				32
#define	NDIV				(1+(IM-1)/NTAB)
#define	EPS					1.2e-7
#define	RNMX				(1.0-EPS)

/*
 *	Defines for ranqd2() algorithm from "Numerical Recipes in 'C'"
 */
#define RANQD2_A			1664525L
#define RANQD2_C			1013904223L

/*
 *	Defines for ranqd2() and ran4() algorithms from "Numerical Recipes in 'C'"
 */
#define	JFLONE				0x3f800000L
#define JFLMSK				0x007fffffL

/*
 *	Defines for the ran4() algorithm from "Numerical Recipes in 'C'"
 */
#define NITER				4

/*
 *	The definition of the RandomNumberGenerator class.
 */
class RandomNumberGenerator
{
	public:
						RandomNumberGenerator ();
						RandomNumberGenerator (
								ULong			seed);
						RandomNumberGenerator (
								Algorithm		algorithm);
						RandomNumberGenerator (
								Algorithm		algorithm,
								ULong			seed);
		virtual			~RandomNumberGenerator ();
		RandomValue		GetRandomNumber (
								RandomValue		lo_extent,
								RandomValue		hi_extent);
		Void			Reseed ();
		Void			Reseed (
								ULong			seed);

	private:
		Void			GenerateSeed (
								ULong			seed);
		Float			RAN1UniformDeviate ();
		Float			RAN4UniformDeviate ();
		Void 			PseudoDESHashing (
								ULong 			*lword, 
								ULong 			*irword);

		Algorithm		Algorithm_In_Use;
		Long			Running_Random_Number;
};		
typedef RandomNumberGenerator *		PRandomNumberGenerator;

/*
 *	RandomNumberGenerator ()
 *
 *	Functional Description:
 *		This version of the constructor is used to create a random number
 *		generator object that has been automatically seeded with the current
 *		time.  The default algorithm will be used.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	RandomNumberGenerator (
 *			ULong	seed)
 *
 *	Functional Description:
 *		This version of the constructor is used to create a random number
 *		generator object which is seeded with the supplied value.  The default
 *		algorithm will be used.
 *
 *	Formal Parameters:
 *		seed (i)
 *			A value used to seed the random number generator.  If the seed value
 *			is zero, the random number generator object will use a random seed
 *			value based on the time. 
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	RandomNumberGenerator (
 *			Algorithm		algorithm)
 *
 *	Functional Description:
 *		This version of the constructor is used to create a random number
 *		generator object that has been automatically seeded with the current
 *		time.  The algorithm specifies the algorithm to be used.
 *
 *	Formal Parameters:
 *		algorithm (i)
 *			The random number generation algorithm to be used.  The parameter
 *			algorithm must be one of the following:
 *	
 *			ALGORITHM_RAN1
 *				A good general purpose algorithm with a rather long period.
 *				This algorithm was benchmarked on a Gateway 2000 486/33C at
 *				29+ Kops (thousand operations per second).
 *			ALGORITHM_RANQD2
 *				A quick and dirty algorithm.  Use this algorithm if speed is an
 *				issue and the period of the random sequence is unimportant.
 *				This algorithm was benchmarked on a Gateway 2000 486/33C at
 *				49+ Kops (thousand operations per second).
 *			ALGORITHM_RAN4
 *				A slow algorithm with an exceptionally long period.
 *				This algorithm was benchmarked on a Gateway 2000 486/33C at
 *				18+ Kops (thousand operations per second).
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	RandomNumberGenerator (
 *			Algorithm		algorithm,
 *			ULong			seed)
 *
 *	Functional Description:
 *		This version of the constructor is used to create a random number
 *		generator object which is seeded with the supplied value.  The algorithm
 *		specified the algorithm to be used.
 *
 *	Formal Parameters:
 *		algorithm (i)
 *			The random number generation algorithm to be used.  The parameter
 *			algorithm must be one of the following:
 *	
 *			ALGORITHM_RAN1
 *				A good general purpose algorithm with a rather long period.
 *				This algorithm was benchmarked on a Gateway 2000 486/33C at
 *				29+ Kops (thousand operations per second).
 *			ALGORITHM_RANQD2
 *				A quick and dirty algorithm.  Use this algorithm if speed is an
 *				issue and the period of the random sequence is unimportant.
 *				This algorithm was benchmarked on a Gateway 2000 486/33C at
 *				49+ Kops (thousand operations per second).
 *			ALGORITHM_RAN4
 *				A slow algorithm with an exceptionally long period.
 *				This algorithm was benchmarked on a Gateway 2000 486/33C at
 *				18+ Kops (thousand operations per second).
 *		seed (i)
 *			A value used to seed the random number generator.  If the seed value
 *			is zero, the random number generator object will use a random seed
 *			value based on the time. 
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~RandomNumberGenerator ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the destructor for the RandomNumberGenerator class.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	RandomValue		GetRandomNumber (
 *							RandomValue 	lo_extent,
 *							RandomValue		hi_extent)
 *
 *	Public
 *
 *	Functional Description:
 *		This method is used to generate a random number between the 
 *		specified values.
 *
 *	Formal Parameters:
 *		lo_extent (i)
 *			The lowest number you wish to receive.
 *		hi_extent (i)
 *			The highest number you wish to receive.
 *
 *	Return Value:
 *		A RandomValue in the range specified.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		Reseed ()
 *
 *	Public
 *
 *	Functional Description:
 *		This method is used to reseed the random number generator object using
 *		the system time as the seed value.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	Reseed (
 *					ULong		seed)
 *
 *	Public
 *
 *	Functional Description:
 *		This method is used to reseed the random number generator object using
 *		the specified seed value.
 *
 *	Formal Parameters:
 *		seed (i)
 *			A value used to seed the random number generator.  If the seed value
 *			is zero, the random number generator object will use a random seed
 *			value based on the time. 
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif	// USE_RANDOM_CLASS
#endif	// _RANDOM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\registry.h ===
/*
 *	registry.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		Instances of this class represent the application registry for a 
 *		single conference.  This is a dual purpose class that is designed 
 *		to support both a Top Provider node and all other nodes.  The 
 *		information base for the application registry is completely contained at 
 *		the Top Provider node. This information is not distributively held at 
 *		all nodes in the conference like roster information.  It is completely 
 *		managed at the Top Provider.  Therefore all requests to alter 
 *		information in the registry or get information from the registry are 
 *		made to the Top Provider.
 *
 *		When an Application Registry object is instantiated it is informed if it 
 *		is the Top Provider or not.  Application Registry objects that are Top 
 *		Providers are responsible for maintaining the registry information base 
 *		for the entire conference.  It is also responsible for servicing all 
 *		incoming requests and sending out the necessary confirms.  Application 
 *		Registry objects that are not Top Providers are responsible for sending 
 *		all requests to the Top Provider node.  They are also responsible for 
 *		issuing confirms to the CAppSap that made the request after receiving the 
 *		responses back from the Top Provider registry.  All Application Registry 
 *		requests include an Entity ID associated with the APE that made the 
 *		request.  Note that all registry requests are processed in the order 
 *		that they are received.  Therefore, there is no need to include 
 *		sequencing data with each request.  
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */
#ifndef	_APPLICATION_REGISTRY_
#define	_APPLICATION_REGISTRY_

#include "regkey.h"
#include "regitem.h"
#include "arostmgr.h"

/*
**	This list keeps up with all the APEs that are currently monitoring a 
**	registry entry.
*/
class CMonitoringList : public CList
{
    DEFINE_CLIST_(CMonitoringList, EntityID)
};


//	This structure defines a single registry entry
typedef struct
{
	CRegKeyContainer        *registry_key;
	CRegItem                *entry_item;
	GCCModificationRights	modification_rights;
	CMonitoringList			monitoring_list;
	BOOL    				monitoring_state;
	UserID					owner_id;
	EntityID				entity_id;
}
    REG_ENTRY;


//	This list holds all the registry entries
class CRegEntryList : public CList
{
    DEFINE_CLIST(CRegEntryList, REG_ENTRY*)
};


class CRegistry : public CRefCount
{
public:

    CRegistry(PMCSUser, BOOL top_provider, GCCConfID, CAppRosterMgrList *, PGCCError);
    ~CRegistry(void);

    void		EnrollAPE(EntityID, CAppSap *);
	void		UnEnrollAPE(EntityID);

	GCCError	RegisterChannel(PGCCRegistryKey, ChannelID, EntityID);
	GCCError	AssignToken(PGCCRegistryKey, EntityID);
	GCCError	SetParameter(PGCCRegistryKey, LPOSTR, GCCModificationRights, EntityID);
	GCCError	RetrieveEntry(PGCCRegistryKey, EntityID);
	GCCError	DeleteEntry(PGCCRegistryKey, EntityID);
	GCCError	MonitorRequest(PGCCRegistryKey, BOOL enable_delivery, EntityID);
	GCCError	AllocateHandleRequest(UINT cHandles, EntityID);
	GCCError	ProcessRegisterChannelPDU(CRegKeyContainer *, ChannelID, UserID, EntityID);
	GCCError	ProcessAssignTokenPDU(CRegKeyContainer *, UserID, EntityID);
	GCCError	ProcessSetParameterPDU(CRegKeyContainer *, LPOSTR param, GCCModificationRights, UserID, EntityID);
	void		ProcessRetrieveEntryPDU(CRegKeyContainer *, UserID, EntityID);
	void		ProcessDeleteEntryPDU(CRegKeyContainer *, UserID, EntityID);
	void		ProcessMonitorEntryPDU(CRegKeyContainer *, UserID, EntityID);
	void		ProcessRegistryResponsePDU(RegistryResponsePrimitiveType, CRegKeyContainer *, CRegItem *,
							                GCCModificationRights, EntityID eidRequester,
							                UserID uidOwner, EntityID eidOwner, GCCResult);
	void		ProcessMonitorIndicationPDU(CRegKeyContainer *, CRegItem *, GCCModificationRights,
							                UserID uidOwner, EntityID eidOwner);
	void		ProcessAllocateHandleRequestPDU(UINT cHandles, EntityID eidRequester, UserID uidRequester);
	void		ProcessAllocateHandleResponsePDU(UINT cHandles, UINT first_handle, EntityID, GCCResult);
	void		RemoveNodeOwnership(UserID);
	void		RemoveEntityOwnership(UserID, EntityID);
	void		RemoveSessionKeyReference(CSessKeyContainer *);

private:

    REG_ENTRY       *GetRegistryEntry(CRegKeyContainer *);
    TokenID			GetUnusedToken(void);
	GCCError		AddAPEToMonitoringList(CRegKeyContainer *, EntityID, CAppSap *);
    void			RemoveAPEFromMonitoringList(CRegKeyContainer *, EntityID);
	void			SendMonitorEntryIndicationMessage(REG_ENTRY *);

private:

    PMCSUser						m_pMCSUserObject;
	CRegEntryList				    m_RegEntryList;
	BOOL    						m_fTopProvider;
	TokenID							m_nCurrentTokenID;
	GCCConfID					    m_nConfID;
	CRegItem                        *m_pEmptyRegItem;
	CAppSapEidList2                 m_AppSapEidList2;
	UINT							m_nRegHandle;
	CAppRosterMgrList				*m_pAppRosterMgrList;
};
#endif

/*
 *	CRegistry	(
 *					PMCSUser						user_object,
 *					BOOL    						top_provider,
 *					GCCConfID   					conference_id,
 *					CAppRosterMgrList				*app_roster_manager_list,
 *					PGCCError						return_value )
 *
 *	Public Function Description
 *		This is the Application Registry constructor. It is responsible for
 *		initializing all the instance variables used by this class.  It also
 *		creates an Empty Registry Item to pass back in confirms where a real
 *		registry item does not exists.
 *
 *	Formal Parameters:
 *		user_object			-	(i) Pointer to the MCS User Attachment object.
 *		top_provider		-	(i) Flag indicating if this is the Top Provider
 *									node.
 *		conference_id		-	(i)	The Conference ID associated witht this
 *									registry.
 *		app_roster_manager_list	(i)	List holding all of the application
 *									roster managers assoicated with this
 *									conference.  Needed when verifying if
 *									an requesting APE is truly enrolled.
 *		return_value		-	(o)	Any errors that occur in the constructor
 *									are returned here.
 *		
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 * 	~ApplicationRegistry ()
 *
 *	Public Function Description
 *		This is the Application Registry destructor.  It is responsible for
 *		freeing up all the registry data allocated by this class.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	void EnrollAPE(EntityID		entity_id,
 *					CAppSap		*pAppSap)
 *
 *	Public Function Description
 *		This routine is used to inform the application registry of a newly
 *		enrolling APE and its corresponding command target interface.
 *
 *	Formal Parameters:
 *		entity_id		-	(i)	Entity ID associated with the enrolling APE.
 *		pAppSap     	-	(i)	Command Target pointer associated with the
 *								enrolling APE.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	void	UnEnrollAPE (	EntityID				entity_id )
 *
 *	Public Function Description
 *		This routine is used to inform the application registry of an 
 *		APE that is unerolling from the conference.
 *
 *	Formal Parameters:
 *		entity_id		-	(i)	Entity ID associated with the unenrolling APE.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		This routine removes ownership from all the entries currently owned by 
 *		the passed in application entity.  It will also remove any outstanding
 *		request for the SAP that unenrolled.
 */
/*
 *	GCCError		RegisterChannel (
 *							PGCCRegistryKey			registry_key,
 *							ChannelID				channel_id,
 *							EntityID				entity_id )
 *
 *	Public Function Description
 *		This routine is used by a local APE to register an MCS channel with this
 *		conferences application registry.  If this registry object does NOT 
 *		live at the top provider node this class is responsible for 
 *		forwarding the request on up to the top provider.
 *
 *	Formal Parameters:
 *		registry_key	-	(i)	Registry Key to associate with channel being
 *								registered (this is "API" data).
 *		channel_id		-	(i)	Channel ID to register.
 *		entity_id		-	(i)	Entity ID associated with the APE making the
 *								request.
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No error occured.
 *		GCC_INVALID_REGISTRY_KEY	-	Specified registry key is invalid.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		The MCS channel being registerd must be determined before this
 *		routine is called.
 */
/*
 *	GCCError			AssignToken (
 *							PGCCRegistryKey			registry_key,
 *							EntityID				entity_id );
 *
 *	Public Function Description
 *		This routine is used by a local APE to register an MCS Token with this
 *		conferences application registry.  If this registry object does NOT 
 *		live at the top provider node this class is responsible for 
 *		forwarding the request on up to the top provider.
 *
 *	Formal Parameters:
 *		registry_key	-	(i)	Registry Key to associate with token being
 *								registered (this is "API" data).
 *		entity_id		-	(i)	Entity ID associated with the APE making the
 *								request.
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No error occured.
 *		GCC_BAD_REGISTRY_KEY		-	Specified registry key is invalid.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		The MCS token being registerd is determined by GCC and is therefore
 *		not included in the request.
 */
/*
 *	GCCError		SetParameter (
 *							PGCCRegistryKey			registry_key,
 *							LPOSTR      			parameter_value,
 *							GCCModificationRights	modification_rights,
 *							EntityID				entity_id )
 *
 *	Public Function Description
 *		This routine is used by a local APE to register a  parameter with this
 *		conferences application registry.  If this registry object does NOT 
 *		live at the top provider node this class is responsible for 
 *		forwarding the request on up to the top provider.
 *
 *	Formal Parameters:
 *		registry_key		-	(i)	Registry Key to associate with parameter 
 *									being registered (this is "API" data).
 *		parameter_value		-	(i)	Value of the parameter being registered.
 *		modification_rights	-	(i)	Modification rights associated with
 *									parameter being registered.	
 *		entity_id			-	(i)	Entity ID associated with the APE making the
 *									request.
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No error occured.
 *		GCC_BAD_REGISTRY_KEY		-	Specified registry key is invalid.
 *		GCC_INVALID_REGISTRY_ITEM	-	Parameter is not valid.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	GCCError		RetrieveEntry (
 *							PGCCRegistryKey			registry_key,
 *							EntityID				entity_id )
 *
 *	Public Function Description
 *		This routine is used by a local APE to obtain an item that was 
 *		registered with GCC.  If this registry object does NOT 
 *		live at the top provider node this class is responsible for 
 *		forwarding the request on up to the top provider.
 *
 *	Formal Parameters:
 *		registry_key		-	(i)	Registry Key associated with item being
 *									retrieved (this is "API" data).
 *		entity_id			-	(i)	Entity ID associated with the APE making the
 *									request.
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No error occured.
 *		GCC_BAD_REGISTRY_KEY		-	Specified registry key is invalid.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	GCCError	DeleteEntry (
 *							PGCCRegistryKey			registry_key,
 *							EntityID				entity_id )
 *
 *	Public Function Description
 *		This routine is used by a local APE to delete an item that was 
 *		registered with GCC.  If this registry object does NOT 
 *		live at the top provider node this class is responsible for 
 *		forwarding the request on up to the top provider.
 *
 *	Formal Parameters:
 *		registry_key		-	(i)	Registry Key associated with item to delete
 *									(this is "API" data).
 *		entity_id			-	(i)	Entity ID associated with the APE making the
 *									request.
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No error occured.
 *		GCC_BAD_REGISTRY_KEY		-	Specified registry key is invalid.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	GCCError	MonitorRequest (
 *							PGCCRegistryKey			registry_key,
 *							BOOL    				enable_delivery,
 *							EntityID				entity_id )
 *
 *	Public Function Description
 *		This routine is used by a local APE to monitor an item that was 
 *		registered with GCC.  If this registry object does NOT 
 *		live at the top provider node this class is responsible for 
 *		forwarding the request on up to the top provider.
 *
 *	Formal Parameters:
 *		registry_key		-	(i)	Registry Key associated with item to 
 *									monitor (this is "API" data).
 *		enable_delivery		-	(i)	This flag indicates if monitoring is being
 *									turned on or off.
 *		entity_id			-	(i)	Entity ID associated with the APE making the
 *									request.
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No error occured.
 *		GCC_BAD_REGISTRY_KEY		-	Specified registry key is invalid.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	GCCError			AllocateHandleRequest (	
 *							UINT					number_of_handles,
 *							EntityID				entity_id )
 *
 *	Public Function Description
 *		This routine is used by a local APE to allocate a specified number of
 *		handles from the application registry.  If this registry object does NOT 
 *		live at the top provider node this class is responsible for 
 *		forwarding the request on up to the top provider.
 *
 *	Formal Parameters:
 *		number_of_handles	-	(i)	Number of handles to allocate.
 *		entity_id			-	(i)	Entity ID associated with the APE making the
 *									request.
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	GCCError		ProcessRegisterChannelPDU (
 *							CRegKeyContainer		            *registry_key,
 *							ChannelID				channel_id,
 *							UserID					requester_id,
 *							EntityID				entity_id )
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process incomming
 *		register channel PDUs.  It is responsible for returning any
 *		necessary responses that must be sent back to the requesting node.
 *
 *	Formal Parameters:
 *		registry_key	-	(i)	Registry Key associated with channel to
 *								register (this is "PDU" data).
 *		channel_id		-	(i)	Channel ID to register.
 *		requester_id	-	(i)	Node ID associated with the APE making the
 *								request.
 *		entity_id		-	(i)	Entity ID associated with the APE making the
 *								request.
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No error occured.
 *		GCC_BAD_REGISTRY_KEY		-	Specified registry key is invalid.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	GCCError	ProcessAssignTokenPDU (
 *							CRegKeyContainer		            *registry_key,
 *							UserID					requester_id,
 *							EntityID				entity_id )
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process incomming
 *		register token PDUs.  It is responsible for returning any
 *		necessary responses that must be sent back to the requesting node.
 *
 *	Formal Parameters:
 *		registry_key	-	(i)	Registry Key associated with token to register
 *								(this is "PDU" data).
 *		requester_id	-	(i)	Node ID associated with the APE making the
 *								request.
 *		entity_id		-	(i)	Entity ID associated with the APE making the
 *								request.
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No error occured.
 *		GCC_BAD_REGISTRY_KEY		-	Specified registry key is invalid.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	GCCError	ProcessSetParameterPDU(
 *							CRegKeyContainer		*registry_key_data,
 *							LPOSTR      			parameter_value,
 *							GCCModificationRights	modification_rights,
 *							UserID					requester_node_id,
 *							EntityID				requester_entity_id)
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process incomming
 *		register parameter PDUs.  It is responsible for returning any
 *		necessary responses that must be sent back to the requesting node.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i)	Registry Key associated with parameter to 
 *									register (this is "PDU" data).
 *		parameter_value		-	(i)	Value of the parameter being registered.
 *		modification_rights	-	(i)	Modification rights associated with the
 *									parameter being registered.
 *		requester_node_id	-	(i)	Node ID associated with the APE making the
 *									request.
 *		requester_entity_id	-	(i)	Entity ID associated with the APE making the
 *									request.
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No error occured.
 *		GCC_BAD_REGISTRY_KEY		-	Specified registry key is invalid.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	void	ProcessRetrieveEntryPDU (
 *							CRegKeyContainer        *registry_key,
 *							UserID					requester_id,
 *							EntityID				entity_id )
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process an incomming
 *		request to retrieve a registry entry.  It is responsible for returning 
 *		any necessary responses that must be sent back to the requesting node.
 *
 *	Formal Parameters:
 *		registry_key	-	(i)	Registry Key associated with item to 
 *								retrieve (this is "PDU" data).
 *		requester_id	-	(i)	Node ID associated with the APE making the
 *								request.
 *		entity_id		-	(i)	Entity ID associated with the APE making the
 *								request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	void	ProcessDeleteEntryPDU (
 *							CRegKeyContainer        *registry_key,
 *							UserID					requester_id,
 *							EntityID				entity_id )
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process an incomming
 *		request to delete a registry entry.  It is responsible for returning 
 *		any necessary responses that must be sent back to the requesting node.
 *
 *	Formal Parameters:
 *		registry_key	-	(i)	Registry Key associated with item to 
 *								delete (this is "PDU" data).
 *		requester_id	-	(i)	Node ID associated with the APE making the
 *								request.
 *		entity_id		-	(i)	Entity ID associated with the APE making the
 *								request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	void		ProcessMonitorEntryPDU (
 *							CRegKeyContainer        *registry_key_data,
 *							UserID					requester_node_id,
 *							EntityID				requester_entity_id )
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process an incomming
 *		request to monitor a registry entry.  It is responsible for returning 
 *		any necessary responses that must be sent back to the requesting node.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i)	Registry Key associated with item to 
 *									monitor (this is "PDU" data).
 *		requester_node_id	-	(i)	Node ID associated with the APE making the
 *									request.
 *		requester_entity_id	-	(i)	Entity ID associated with the APE making
 *									the request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	void	ProcessRegistryResponsePDU(
 *					RegistryResponsePrimitiveType	primitive_type,
 *					CRegKeyContainer                *registry_key_data,
 *					CRegItem                        *registry_item_data,
 *					GCCModificationRights			modification_rights,
 *					EntityID						requester_entity_id,
 *					UserID							owner_node_id,
 *					EntityID						owner_entity_id,
 *					GCCResult						result)
 *
 *	Public Function Description
 *		This routine is used by nodes other than the top provider node to 
 *		process registry responses from the top provider.  It is responsible for 
 *		generating any local messages associated with this response.
 *
 *	Formal Parameters:
 *		primitive_type		-	(i)	This parameter defines what type of
 *									registry response this is.
 *		registry_key_data	-	(i)	Registry Key associated with item in
 *									in the response (this is "PDU" data).
 *		registry_item_data	-	(i)	Registry item returned in the response.
 *		modification_rights	-	(i)	Modification rights associated with item
 *									in response (may not be used).
 *		requester_entity_id	-	(i)	Entity ID associated with the APE that 
 *									made the request that generated the 
 *									response.
 *		owner_node_id		-	(i)	Node ID associated with APE that owns the
 *									registry entry returned in the response.
 *		owner_entity_id		-	(i)	Entity ID associated with APE that owns the
 *									registry entry returned in the response.
 *		result				-	(i)	Result of original request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	void		ProcessMonitorIndicationPDU (
 *							CRegKeyContainer        *registry_key_data,
 *							CRegItem                *registry_item_data,
 *							GCCModificationRights	modification_rights,
 *							UserID					owner_node_id,
 *							EntityID				owner_entity_id);
 *
 *	Public Function Description
 *		This routine is used by nodes other than the top provider node to 
 *		process registry monitor indications from the top provider.  It is 
 *		responsible for generating any local messages associated with this 
 *		response.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i)	Registry Key associated with item being
 *									monitored (this is "PDU" data).
 *		registry_item_data	-	(i)	Registry item being monitored.
 *		modification_rights	-	(i)	Modification rights of registry item being
 *									monitored (may not be used).
 *		owner_node_id		-	(i)	Node ID associated with APE that owns the
 *									registry entry returned in the indication.
 *		owner_entity_id		-	(i)	Entity ID associated with APE that owns the
 *									registry entry returned in the indication.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	void	ProcessAllocateHandleRequestPDU (
 *							UINT					number_of_handles,
 *							EntityID				requester_entity_id,
 *							UserID					requester_node_id)
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process an incomming
 *		request to allocate a number of handles.  It is responsible for 
 *		returning any necessary responses that must be sent back to the 
 *		requesting node.
 *
 *	Formal Parameters:
 *		number_of_handles	-	(i)	Number of handles to allocate.
 *		requester_node_id	-	(i)	Node ID associated with the APE making the
 *								request.
 *		requester_entity_id	-	(i)	Entity ID associated with the APE making the
 *								request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	void		ProcessAllocateHandleResponsePDU (
 *							UINT					number_of_handles,
 *							UINT					first_handle,
 *							EntityID				requester_entity_id,
 *							GCCResult				result)
 *
 *	Public Function Description
 *		This routine is used by a node other than the top provider node to 
 *		process an allocate handle response.  It is responsible for generating 
 *		any local messages associated with this response.
 *
 *	Formal Parameters:
 *		number_of_handles	-	(i)	Number of handles that were allocated.
 *		first_handle		-	(i)	This is the value of the first handle in
 *									the contiguous list of handles.
 *		requester_entity_id	-	(i)	Entity ID associated with the APE that made
 *									the original allocate handle request.
 *		result				-	(i)	Result of allocate handle request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	void		RemoveNodeOwnership (
 *							UserID				node_id )
 *
 *	Public Function Description
 *		This routine removes ownership of all the registry entries associated 
 *		with the specified node ID.  These entries become unowned. This request 
 *		should only be made from the top provider node.  This is a local 
 *		operation.
 *
 *	Formal Parameters:
 *		node_id	-	(i) Node ID of node that owns the registry entries to set
 *						to unowned.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	void	RemoveEntityOwnership (
 *							UserID					node_id,
 *							EntityID				entity_id)
 *
 *	Public Function Description
 *		This routine removes ownership of all the registry entries associated 
 *		with the specified APE.  These entries become unowned. This request 
 *		should only be made from the top provider node.  This is a local 
 *		operation.
 *
 *	Formal Parameters:
 *		node_id	-	(i) Node ID of node that owns the registry entries to set
 *						to unowned.
 *		entity_id-	(i) Entity ID of node that owns the registry entries to set
 *						to unowned.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	void	RemoveSessionKeyReference(CSessKeyContainer *session_key)
 *
 *	Public Function Description
 *		This routine removes all registry entries associated with the
 *		specified session.  This is a local operation.
 *
 *	Formal Parameters:
 *		session_key	-	(i) Session key associated with all the registry 
 *							entries to delete.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\regkey.h ===
/*
 *	regkey.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class CRegKeyContainer.  This class
 *		manages the data associated with a Registry Key.  Registry Key are
 *		used to identify resources held in the application registry and consist
 *		of a Session Key and a resource ID octet string.  The CRegKeyContainer 
 *		class uses a CSessKeyContainer container to maintain the session key data 
 *		internally.  A Rogue Wave string object is used to hold the resource ID
 *		octet string.  
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */
#ifndef	_REGISTRY_KEY_DATA_
#define	_REGISTRY_KEY_DATA_

#include "sesskey.h"

/*
 * This is the typedef for the structure used to hold the registry key data
 * internally.
 */
typedef struct
{
	CSessKeyContainer		    *session_key;
	LPOSTR						poszResourceID;
}
    REG_KEY;

/*
 * Class definition:
 */
class CRegKeyContainer : public CRefCount
{
public:

	CRegKeyContainer(PGCCRegistryKey, PGCCError);
	CRegKeyContainer(PRegistryKey, PGCCError);
	CRegKeyContainer(CRegKeyContainer *, PGCCError);

	~CRegKeyContainer(void);

	UINT		LockRegistryKeyData(void);
	void		UnLockRegistryKeyData(void);

	UINT		GetGCCRegistryKeyData(PGCCRegistryKey, LPBYTE memory);
	GCCError	GetRegistryKeyDataPDU(PRegistryKey);
	void		FreeRegistryKeyDataPDU(void);
    GCCError    CreateRegistryKeyData(PGCCRegistryKey *);
	BOOL    	IsThisYourSessionKey(CSessKeyContainer *);

    CSessKeyContainer *GetSessionKey(void) { return m_InternalRegKey.session_key; }

    friend BOOL operator==(const CRegKeyContainer&, const CRegKeyContainer&);

protected:

	REG_KEY     		m_InternalRegKey;
	UINT				m_cbDataSize;

    RegistryKey 		m_RegKeyPDU;
	BOOL    			m_fValidRegKeyPDU;
};

/*
 *	Comments explaining the public and protected class member functions
 */

/*
 *	CRegKeyContainer (	PGCCRegistryKey		registry_key,
 *						PGCCError			return_value);
 *
 *	Public member function of CRegKeyContainer.
 *
 *	Function Description:
 *		This is the constructor for the CRegKeyContainer class which takes as
 *		input the "API" version of registry key data, GCCRegistryKey.
 *
 *	Formal Parameters:
 *		registry_key		(i)	The registry key data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_REGISTRY_KEY			-	An invalid registry key passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	CRegKeyContainer (	PRegistryKey		registry_key,
 *						PGCCError			return_value);
 *
 *	Public member function of CRegKeyContainer.
 *
 *	Function Description:
 *		This is the constructor for the CRegKeyContainer class which takes as
 *		input the "PDU" version of registry key data, RegistryKey.
 *
 *	Formal Parameters:
 *		registry_key		(i)	The registry key data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	CRegKeyContainer(CRegKeyContainer	            *registry_key,
 *			        PGCCError			return_value);
 *
 *	Public member function of CRegKeyContainer.
 *
 *	Function Description:
 *		This is the copy constructor for the CRegKeyContainer class which takes
 *		as input another CRegKeyContainer object.
 *
 *	Formal Parameters:
 *		registry_key		(i)	The CRegKeyContainer object to copy.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	~CRegKeyContainer();
 *
 *	Public member function of CRegKeyContainer.
 *
 *	Function Description:
 *		This is the destructor for the CRegKeyContainer class.  It is used to
 *		clean up any memory allocated during the life of this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	ULong			LockRegistryKeyData ();
 *
 *	Public member function of CRegKeyContainer.
 *
 *	Function Description:
 *		This routine is used to "lock" the "API" data for this object.  This
 *		results in the lock count for this object being incremented.  When the
 *		lock count transitions from 0 to 1, a calculation is made to determine
 *		how much memory will be needed to hold any "API" data which will
 *		be referenced by, but not held in, the GCCRegistryKey structure
 *		which is filled in on a call to GetGCCRegistryKeyData.  This is the
 *		value returned by this routine in order to allow the calling object to
 *		allocate that amount of memory in preparation for the call to 
 *		GetGCCRegistryKeyData.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The amount of memory, if any, which will be needed to hold "API" data
 *		which is referenced by, but not held in, the GCCRegistryKey structure
 *		provided as an output parameter to the GetGCCRegistryKeyData call.
 *
 *  Side Effects:
 *		The internal lock count is incremented.
 *
 *	Caveats:
 *		The internal lock count is used in conjuction with an internal "free" 
 *		flag as a mechanism for ensuring that this object remains in existance 
 *		until all interested parties are through with it.  The object remains 
 *		valid (unless explicity deleted) until the lock count is zero and the 
 *		"free" flag is set through a call to FreeRegistryKeyData.  This allows
 *		other objects to lock this object and be sure that it remains valid 
 *		until they call UnLock which will decrement the internal lock count.  A
 *		typical usage scenerio for this object would be:  A CRegKeyContainer
 *		object is constructed and then passed off to any interested parties
 *		through a function call.  On return from the function call, the
 *		FreeRegistryKeyData call is made which will set the internal "free"
 *		flag.  If no other parties have locked the object with a Lock call,
 *		then the CRegKeyContainer object will automatically delete itself when
 *		the FreeRegistryKeyData call is made.  If, however, any number of 
 *		other parties has locked the object, it will remain in existence until
 *		each of them has unlocked the object through a call to UnLock.
 */


/*
 *	ULong			GetGCCRegistryKeyData (	
 *							PGCCRegistryKey 		registry_key,
 *							LPSTR					memory);
 *
 *	Public member function of CRegKeyContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the registry key data from the
 *		CRegKeyContainer object in the "API" form of a GCCRegistryKey.
 *
 *	Formal Parameters:
 *		registry_key		(o)	The GCCRegistryKey structure to fill in.
 *		memory				(o)	The memory used to hold any data referenced by,
 *									but not held in, the output structure.
 *
 *	Return Value:
 *		The amount of data, if any, written into the bulk memory block provided.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void			UnLockRegistryKeyData ();
 *
 *	Public member function of CRegKeyContainer.
 *
 *	Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine 
 *		whether the object has been freed through a call to 
 *		FreeRegistryKeyData.  If so, the object will automatically delete
 *		itself.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal lock count is decremented.
 *
 *	Caveats:
 *		It is the responsibility of any party which locks a CRegKeyContainer
 *		object by calling Lock to also unlock the object with a call to UnLock.
 *		If the party calling UnLock did not construct the CRegKeyContainer 
 *		object,	it should assume the object to be invalid thereafter.
 */


/*
 *	GCCError		GetRegistryKeyDataPDU (	
 *							PRegistryKey 		registry_key);
 *
 *	Public member function of CRegKeyContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the registry key data from the
 *		CRegKeyContainer object in the "PDU" form of a RegistryKey.
 *
 *	Formal Parameters:
 *		registry_key		(o)	The RegistryKey structure to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_OBJECT_KEY				-	One of the internal pointers has
 *												been corrupted.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void		FreeRegistryKeyDataPDU ();
 *
 *	Public member function of CRegKeyContainer.
 *
 *	Function Description:
 *		This routine is used to "free" the "PDU" data allocated for this object
 *		which is held internally in a RegistryKey structure.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal "free" flag is set.
 *
 *	Caveats:
 *		This object should be assumed invalid after a call to 
 *		FreeRegistryKeyDataPDU has been made.
 */


/*
 *	BOOL    		IsThisYourSessionKey (
 *								CSessKeyContainer		*session_key);
 *
 *	Public member function of CRegKeyContainer.
 *
 *	Function Description:
 *		This routine is used to determine whether the specified session key
 *		is held within this registry key object.  The session key is 
 *		provided in "API" form.
 *
 *	Formal Parameters:
 *		session_key		(i)	The session key to use for comparison.
 *
 *	Return Value:
 *		TRUE				-	The specified session key is contained 
 *									within this	registry key object.
 *		FALSE				-	The specified session key is not contained 
 *									within this registry key object.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	CSessKeyContainer *GetSessionKey ();
 *
 *	Public member function of CRegKeyContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the session key held in this registry
 *		key object.  The session key is returned in the form of a
 *		CSessKeyContainer object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		A pointer to the CSessKeyContainer object contained within this
 *		CRegKeyContainer object.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	friend BOOL    	operator== (const CRegKeyContainer& 		registry_key_1, 
 *								const CRegKeyContainer& 		registry_key_2);
 *
 *	Public member function of CRegKeyContainer.
 *
 *	Function Description:
 *		This routine is used to compare two CRegKeyContainer objects to determine
 *		whether or not they are equal in value.
 *
 *	Formal Parameters:
 *		registry_key_1			(i)	The first CRegKeyContainer object to compare.
 *		registry_key_2			(i)	The other CRegKeyContainer object to compare.
 *
 *	Return Value:
 *		TRUE				-	The two objects are equal in value.
 *		FALSE				- 	The two objects are not equal in value.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\regitem.h ===
/*
 *	regitem.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class CRegItem.  This class 
 *		manages the data associated with a Registry Item.  Registry Items are
 *		used to identify a particular entry in the application registry and
 *		may exist in the form of a Channel ID, a Token ID, or an octet string 
 *		parameter.  A CRegItem object holds the data for the first two 
 *		forms in a ChannelID and a TokeID, respectively.  When the registry item
 *		assumes the octet string parameter form, the data is held internally in
 *		a Rogue Wave string object.  
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */
#ifndef	_REGISTRY_ITEM_
#define	_REGISTRY_ITEM_


/*
 * Class definition:
 */
class CRegItem : public CRefCount
{
public:

    CRegItem(PGCCRegistryItem, PGCCError);
    CRegItem(PRegistryItem, PGCCError);
    CRegItem(CRegItem *, PGCCError);
    ~CRegItem(void);

	UINT			GetGCCRegistryItemData(PGCCRegistryItem, LPBYTE memory);

	UINT			LockRegistryItemData(void);
	void			UnLockRegistryItemData(void);

	void    		GetRegistryItemDataPDU(PRegistryItem);
	void			FreeRegistryItemDataPDU(void);

    GCCError        CreateRegistryItemData(PGCCRegistryItem *);

    BOOL IsThisYourTokenID(TokenID nTokenID)
    {
        return ((m_eItemType == GCC_REGISTRY_TOKEN_ID) && (nTokenID == m_nTokenID));
    }

	void			operator= (const CRegItem&);

protected:

	GCCRegistryItemType		m_eItemType;
	ChannelID   			m_nChannelID;
	TokenID					m_nTokenID;
	LPOSTR					m_poszParameter;
    UINT					m_cbDataSize;

    RegistryItem 			m_RegItemPDU;
	BOOL    				m_fValidRegItemPDU;
};

/*
 *	Comments explaining the public and protected class member functions
 */

/*
 *	CRegItem (	PGCCRegistryItem	registry_item,
 *						PGCCError			return_value);
 *
 *	Public member function of CRegItem.
 *
 *	Function Description:
 *		This is the constructor for the CRegItem class which takes as
 *		input the "API" version of registry item data, GCCRegistryItem.
 *
 *	Formal Parameters:
 *		registry_item		(i)	The registry item data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	CRegItem (	PRegistryItem		registry_item,
 *						PGCCError			return_value);
 *
 *	Public member function of CRegItem.
 *
 *	Function Description:
 *		This is the constructor for the CRegItem class which takes as
 *		input the "PDU" version of registry item data, RegistryItem.
 *
 *	Formal Parameters:
 *		registry_item		(i)	The registry item data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	CRegItem(CRegItem	*registry_item,
 *			PGCCError	return_value);
 *
 *	Public member function of CRegItem.
 *
 *	Function Description:
 *		This is the copy constructor for the CRegItem class which takes
 *		as input another CRegItem object.
 *
 *	Formal Parameters:
 *		registry_item		(i)	The CRegItem object to copy.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	~CRegItem();
 *
 *	Public member function of CRegItem.
 *
 *	Function Description:
 *		This is the destructor for the CRegItem class.  Since all data
 *		maintained by this class is held in automatic private instance
 *		variables, there is no cleanup needed in this destructor.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	UINT			GetGCCRegistryItemData (	
 *							PGCCRegistryItem 	registry_item,
 *							LPSTR				memory);
 *
 *	Public member function of CRegItem.
 *
 *	Function Description:
 *		This routine is used to retrieve the registry item data from the
 *		CRegItem object in the "API" form of a GCCRegistryItem.
 *
 *	Formal Parameters:
 *		registry_item		(o)	The GCCRegistryItem structure to fill in.
 *		memory				(o)	The memory used to hold any data referenced by,
 *									but not held in, the output structure.
 *
 *	Return Value:
 *		The amount of data, if any, written into the bulk memory block provided.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	UINT			LockRegistryItemData ();
 *
 *	Public member function of CRegItem.
 *
 *	Function Description:
 *		This routine is used to "lock" the "API" data for this object.  This
 *		results in the lock count for this object being incremented.  When the
 *		lock count transitions from 0 to 1, a calculation is made to determine
 *		how much memory, if any, will be needed to hold any "API" data which
 *		will be referenced by, but not held in, the GCCRegistryItem structure
 *		which is filled in on a call to GetGCCRegistryItemData.  This is the
 *		value returned by this routine in order to allow the calling object to
 *		allocate that amount of memory in preparation for the call to 
 *		GetGCCRegistryItemData.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The amount of memory, if any, which will be needed to hold "API" data
 *		which is referenced by, but not held in, the GCCRegistryItem structure
 *		provided as an output parameter to the GetGCCRegistryItemData call.
 *
 *  Side Effects:
 *		The internal lock count is incremented.
 *
 *	Caveats:
 *		The internal lock count is used in conjuction with an internal "free" 
 *		flag as a mechanism for ensuring that this object remains in existance 
 *		until all interested parties are through with it.  The object remains 
 *		valid (unless explicity deleted) until the lock count is zero and the 
 *		"free" flag is set through a call to FreeRegistryItemData.  This allows
 *		other objects to lock this object and be sure that it remains valid 
 *		until they call UnLock which will decrement the internal lock count.  A
 *		typical usage scenerio for this object would be:  A CRegItem
 *		object is constructed and then passed off to any interested parties
 *		through a function call.  On return from the function call, the
 *		FreeRegistryItemData call is made which will set the internal "free"
 *		flag.  If no other parties have locked the object with a Lock call,
 *		then the CRegItem object will automatically delete itself when
 *		the FreeRegistryItemData call is made.  If, however, any number of 
 *		other parties has locked the object, it will remain in existence until
 *		each of them has unlocked the object through a call to UnLock.
 */
/*
 *	void			UnLockRegistryItemData ();
 *
 *	Public member function of CRegItem.
 *
 *	Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine 
 *		whether the object has been freed through a call to 
 *		FreeRegistryItemData.  If so, the object will automatically delete
 *		itself.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal lock count is decremented.
 *
 *	Caveats:
 *		It is the responsibility of any party which locks a CRegItem
 *		object by calling Lock to also unlock the object with a call to UnLock.
 *		If the party calling UnLock did not construct the CRegItem 
 *		object,	it should assume the object to be invalid thereafter.
 */
/*
 *	void		GetRegistryItemDataPDU (	
 *							PRegistryItem 	registry_item);
 *
 *	Public member function of CRegItem.
 *
 *	Function Description:
 *		This routine is used to retrieve the registry item data from the
 *		CRegItem object in the "PDU" form of a RegistryItem.
 *
 *	Formal Parameters:
 *		registry_item		(o)	The RegistryItem structure to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	void			FreeRegistryItemDataPDU ();
 *
 *	Public member function of CRegItem.
 *
 *	Function Description:
 *		This routine is used to "free" the "PDU" data for this object.  For
 *		this object, this means setting a flag to indicate that the "PDU" data
 *		for this object is no longer valid.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal "free" flag is set.
 *
 *	Caveats:
 *		This object should be assumed invalid after a call to 
 *		FreeRegistryItemData has been made.
 */
/*
 *	BOOL    		IsThisYourTokenID (	
 *							TokenID				token_id);
 *
 *	Public member function of CRegItem.
 *
 *	Function Description:
 *		This routine is used to determine whether the specified token ID is
 *		held within this registry item object.
 *
 *	Formal Parameters:
 *		token_id			(i)	The token ID to use for comparison.
 *
 *	Return Value:
 *		TRUE				-	The specified token ID is contained within this
 *									registry item object.
 *		FALSE				-	The specified token ID is not contained within
 *									this registry item object.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	void			operator= (
 *						const CRegItem&		registry_item_data);	
 *
 *	Public member function of CRegItem.
 *
 *	Function Description:
 *		This routine is used to set this CRegItem object to be equal
 *		in value to the specified CRegItem object.
 *
 *	Formal Parameters:
 *		registry_item_data			(i)	The CRegItem object to copy.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The registry item data values for this object are modified by this call.
 *
 *	Caveats:
 *		The "lock" and "free" states for this object are not affected by
 *		this call.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\sap.h ===
/*
 *	sap.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class CBaseSap.  This class is an abstract
 *		base class for objects that act as Service Access Points (SAPs) to 
 *		external applications or the node controller. 
 *
 *		This class has two main responsibilities. First, it handles many of the 
 *		administrative tasks that are common to all types of SAPs.  These 
 *		include handling command target registration responsibilities and 
 *		managing the message queue.  It	also handles all of the primitives that
 *		are common between the Control SAP (CControlSAP class) and Application 
 *		SAPs (CAppSap class).  Since this class inherits from CommandTarget, it 
 *		has the ability to communicate directly with other command targets.  A 
 *		CommandTarget object wishing to	communicate with a CBaseSap object must 
 *		register itself by passing it a CommandTarget pointer and a handle 
 *		(typically a ConferenceID).  This process is identical for both of the 
 *		derived CBaseSap classes.  Note that the CBaseSap object can handle multiple 
 *		registered command targets at the same time.  
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */
#ifndef _SAP_
#define _SAP_

/*
 * include files 
 */
// #include "gcmdtar.h"
#include "password.h"
#include "crost.h"
#include "arost.h"
#include "conflist.h"
#include "sesskey.h"
#include "regkey.h"
#include "regitem.h"
#include "invoklst.h"
#include "arostmsg.h"
#include "crostmsg.h"
#include "privlist.h"
#include "clists.h"


#define MSG_RANGE                       0x0100
enum
{
    // GCCController
    GCTRLMSG_BASE                       = 0x2100,

    // CConf
    CONFMSG_BASE                        = 0x2200,

    // CControlSAP
    CSAPMSG_BASE                        = 0x2300,

    // CControlSAP asyn direct confirm message
    CSAPCONFIRM_BASE                    = 0x2400,

    // CAppSap
    ASAPMSG_BASE                        = 0x2500,
    
    // NCUI
    NCMSG_BASE                          = 0x2600,

    // MCS (Node) Controller
    MCTRLMSG_BASE                       = 0x2700,
};

LRESULT CALLBACK SapNotifyWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);


typedef struct GCCAppSapMsgEx
{
    GCCAppSapMsgEx(GCCMessageType);
    ~GCCAppSapMsgEx(void);

    GCCAppSapMsg        Msg;
}
    GCCAppSapMsgEx, *PGCCAppSapMsgEx;


/*
 * This macro defines the minimum user ID value allowed by MCS.
 */
#define	MINIMUM_USER_ID_VALUE	1001

/*
 * Structures and enumerations used by the CBaseSap class.
 */


//
// Class definition.
//
class CConf;
class CBaseSap : public CRefCount
{
public:

#ifdef SHIP_BUILD
    CBaseSap();
#else
    CBaseSap(DWORD dwStampID);
#endif
    virtual ~CBaseSap(void) = 0;

    GCCError  ConfRosterInquire(GCCConfID, GCCAppSapMsgEx **);
    GCCError  AppRosterInquire(GCCConfID, GCCSessionKey *, GCCAppSapMsgEx **);
    GCCError  ConductorInquire(GCCConfID);
    GCCError  AppInvoke(GCCConfID, GCCAppProtEntityList *, GCCSimpleNodeList *, GCCRequestTag *);
    BOOL      IsThisNodeTopProvider(GCCConfID);
    GCCNodeID GetTopProvider(GCCConfID);

    virtual GCCError	ConfRosterInquireConfirm(
    					GCCConfID,
    					PGCCConferenceName,
    					LPSTR           	conference_modifier,
    					LPWSTR				pwszConfDescriptor,
    					CConfRoster *,
    					GCCResult,
    					GCCAppSapMsgEx **) = 0;

    virtual GCCError	AppRosterInquireConfirm(
    					GCCConfID,
    					CAppRosterMsg *,
    					GCCResult,
                        GCCAppSapMsgEx **) = 0;

    virtual GCCError AppInvokeConfirm(
                        GCCConfID,
                        CInvokeSpecifierListContainer *,
                        GCCResult,
                        GCCRequestTag) = 0;

    virtual GCCError AppInvokeIndication(
                        GCCConfID,
                        CInvokeSpecifierListContainer *,
                        GCCNodeID nidInvoker) = 0;

    virtual GCCError AppRosterReportIndication(GCCConfID, CAppRosterMsg *) = 0;

    virtual GCCError ConductorInquireConfirm(
    					GCCNodeID			nidConductor,
    					GCCResult,
    					BOOL				permission_flag,
    					BOOL				conducted_mode,
    					GCCConfID) = 0;

    virtual GCCError ConductorPermitGrantIndication(
                        GCCConfID           nConfID,
                        UINT                cGranted,
                        GCCNodeID           *aGranted,
                        UINT                cWaiting,
                        GCCNodeID           *aWaiting,
                        BOOL                fThisNodeIsGranted) = 0;

    virtual GCCError ConductorAssignIndication(
                        GCCNodeID			nidConductor,
                        GCCConfID			conference_id) = 0;

    virtual GCCError ConductorReleaseIndication(
                        GCCConfID			conference_id) = 0;


protected:

    GCCRequestTag GenerateRequestTag(void);

    GCCRequestTag       m_nReqTag;

    HWND                m_hwndNotify;
};



/*
 *	Comments explaining the public and protected class member functions
 */

/*
 *	CBaseSap();
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This is the CBaseSap constructor.  The hash list used to hold command
 *		target objects is initialized by this constructor.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	~Sap ();
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This is the CBaseSap destructor.  All message flushing and queue clearing
 *		is performed by the classes which inherit from CBaseSap.  No work is actually
 *		done by this constructor.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	RegisterConf(CConf *, GCCConfID)
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is used by command target objects (such as Conferences) in
 *		order to register themselves with the CBaseSap object.  This is done in order
 *		to allow the command target object to communicate directly with the CBaseSap. 
 *
 *	Formal Parameters:
 *		cmdtar_object			(i) Pointer to the command target object 
 *										wishing to be registered with the CBaseSap.
 *		handle					(i) Integer value used to index the registering
 *										command target in the list of command
 *										targets (the conference ID for confs).
 *
 *	Return Value:
 *		SAP_NO_ERROR						- Command target object has been
 *													successfully registered.
 *		SAP_CONFERENCE_ALREADY_REGISTERED	- A command target object was 
 *													already registered with the
 *													handle passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	UnRegisterConf (
 *							UINT					handle);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is used by command target objects (such as Conferences) in
 *		order to un-register themselves with the CBaseSap object.  This is done when
 *		the command target object is through communicating with the CBaseSap. 
 *
 *	Formal Parameters:
 *		handle					(i) Integer value used to index the registering
 *										command target in the list of command
 *										targets (the conference ID for confs).
 *
 *	Return Value:
 *		SAP_NO_ERROR				- Command target object has been
 *											successfully un-registered.
 *		SAP_NO_SUCH_CONFERENCE		- No command target object was found 
 *											registered with the	handle passed in
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	ConfRosterInquire(
 *							GCCConfID			conference_id);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is used to retrieve the conference roster.  This function
 *		just passes this request to the controller via an owner callback.  The 
 *		conference roster is delivered to the requesting command target object
 *		in a Conference Roster inquire confirm. 
 *
 *	Formal Parameters:
 *		conference_id			- ID of conference for desired roster.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource allocation error occurred.
 *		GCC_INVALID_CONFERENCE			- Conference ID is invalid.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- Conference object has not completed 
 *										  		its establishment process.
 *		
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	AppRosterInquire (
 *							GCCConfID			conference_id,
 *							PGCCSessionKey			session_key	);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is used to retrieve a list of application rosters.  This 
 *		function just passes this request to the controller via an owner 
 *		callback.  This	list is delivered to the requesting SAP through an
 *		Application Roster inquire confirm message.
 *
 *	Formal Parameters:
 *		handle					(i) Integer value used to index the registering
 *										command target in the list of command
 *										targets (the conference ID for confs).
 *
 *	Return Value:
 *		GCC_NO_ERROR			- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE	- A resource allocation error occurred.
 *		GCC_INVALID_CONFERENCE	- Conference ID is invalid.
 *		GCC_BAD_SESSION_KEY		- Session key pointer is invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	ConductorInquire (
 *							GCCConfID			conference_id);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to retrieve conductorship information.
 *		The conductorship information is returned in the confirm.
 *
 *	Formal Parameters:
 *		conference_id		(i) ID of conference.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_INVALID_CONFERENCE			- Conference ID is invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError 	AppInvoke(
 *							GCCConfID			conference_id,
 *							UINT					number_of_apes,
 *							PGCCAppProtocolEntity *	ape_list,
 *							UINT					number_of_destination_nodes,
 *							UserID			*		list_of_destination_nodes);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to invoke other applications at remote
 *		nodes.  The request is passed on to the appropriate Conference objects.
 *
 *	Formal Parameters:
 *		conference_id				(i) ID of conference.
 *		number_of_apes				(i)	Number of Application Protocol Entities
 *											to be invoked.
 *		ape_list					(i) List of "APE"s to be invoked.
 *		number_of_destination_nodes	(i) Number of nodes where applications are
 *											to be invoked.
 *		list_of_destination_nodes	(i) List of nodes where applications are to
 *											be invoked.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- Error creating an object using the
 *										  		"new" operator.
 *		GCC_BAD_SESSION_KEY				- An invalid session key exists in
 *										  		an APE passed in.
 *		GCC_BAD_NUMBER_OF_APES			- Number of APEs passed in as zero.
 *		GCC_INVALID_CONFERENCE			- Conference ID is invalid.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- Conference object has not completed 
 *										  	its establishment process.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	ConductorPermitAskRequest(
 *							GCCConfID			conference_id,
 *							BOOL				grant_permission);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to ask for certain permissions to be 
 *		granted (or not granted) by the conductor.
 *
 *	Formal Parameters:
 *		conference_id		(i) ID of conference.
 *		grant_permission	(i) Flag indicating whether asking for a certain
 *									permission or giving up that permission.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_INVALID_CONFERENCE			- Conference ID is invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	AppRosterInquireConfirm(
 *							GCCConfID				conference_id,
 *							CAppRosterMsg				*roster_message,
 *							GCCResult					result );
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to return a requested list of
 *		application rosters to an application or the node controller.
 *
 *	Formal Parameters:
 *		conference_id		(i) ID of conference.
 *		roster_message		(i) Roster message object containing the roster data
 *		result				(i) Result code indicating if call is successful.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	ConfRosterInquireConfirm (
 *							GCCConfID				conference_id,
 *							PGCCConferenceName			conference_name,
 *							LPSTR           			conference_modifier,
 *							LPWSTR						pwszConfDescriptor,
 *							CConfRoster	  				*conference_roster,
 *							GCCResult					result );
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to return a requested conference
 *		roster to an application or the node controller.
 *
 *	Formal Parameters:
 *		conference_id			(i) ID of conference.
 *		conference_name			(i) Name of conference.
 *		conference_modifier		(i) Name modifier for conference.
 *		pwszConfDescriptor		(i) Desciptor string for conference.
 *		conference_roster		(i) The conference roster being returned.
 *		result					(i) Result code indicating result of call.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	AppInvokeConfirm( 	
 *							GCCConfID					conference_id,
 *							CInvokeSpecifierListContainer	*invoke_list,
 *							GCCResult						result);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to confirm a call requesting application
 *		invocation.
 *
 *	Formal Parameters:
 *		conference_id		(i) ID of conference.
 *		invoke_list			(i) List of APE attempted to be invoked.
 *		result				(i) Result code indicating result of call.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	AppInvokeIndication (
 *							GCCConfID					conference_id,
 *							CInvokeSpecifierListContainer	*invoke_list,
 *							UserID							invoking_node_id);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to send an indication to an application
 *		or node controller that a request for application invocation has been
 *		made.
 *
 *	Formal Parameters:
 *		conference_id		(i) ID of conference.
 *		invoke_list			(i) List of APE's to be invoked.
 *		invoking_node_id	(i) ID of node requesting the invoke.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	ConductorInquireConfirm (
 *							UserID					conductor_node_id,
 *							GCCResult				result,
 *							BOOL				permission_flag,
 *							BOOL				conducted_mode,
 *							GCCConfID			conference_id);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to return conductorship information
 *		which has been requested.
 *
 *	Formal Parameters:
 *		conductor_node_id			(i) Node ID of conducting node.
 *		result						(i) Result of call.
 *		permission_flag				(i) Flag indicating whether or not local
 *											node has conductorship permission.
 *		conducted_mode				(i) Flag indicating whether or not 
 *											conference is in conducted mode.
 *		conference_id				(i) ID of conference.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	ConductorAssignIndication (
 *							UserID					conductor_user_id,
 *							GCCConfID			conference_id);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to send an indication to an application
 *		or node controller that a request has been made to assign conductorship.
 *
 *	Formal Parameters:
 *		conductor_user_id			(i) Node ID of conductor.
 *		conference_id				(i) ID of conference.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	ConductorReleaseIndication (
 *							GCCConfID			conference_id);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to send an indication to an application
 *		or node controller that a request for releasing conductorship has been
 *		made.
 *
 *	Formal Parameters:
 *		conference_id		(i) ID of conference.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	ConductorPermitGrantIndication (	
 *							GCCConfID			conference_id,
 *							UINT					number_granted,
 *							PUserID					granted_node_list,
 *							UINT					number_waiting,
 *							PUserID					waiting_node_list,
 *							BOOL				permission_is_granted);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to send an indication to an application
 *		or node controller that a request for permission from the conductor
 *		has been made.
 *
 *	Formal Parameters:
 *		conference_id				(i) ID of conference.
 *		number_granted				(i) Number of nodes permission is requested
 *											for.
 *		granted_node_list			(i) List of node ID's for nodes to be
 *											granted permission.
 *		number_waiting				(i) Number of nodes waiting for permission.
 *		waiting_node_list			(i) List of nodes waiting for permission.
 *		permission_is_granted		(i) Flag indicating whether permission is
 *											granted.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	ConfRosterReportIndication (
 *							GCCConfID				conference_id,
 *							CConfRosterMsg				*roster_message);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to indicate to applications and the
 *		node controller that the conference roster has been updated.
 *
 *	Formal Parameters:
 *		conference_id		(i) ID of conference.
 *		roster_message		(i) Roster message object holding the updated
 *									roster information.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	ApplicationRosterReportIndication (
 *							GCCConfID				conference_id,
 *							CAppRosterMsg				*roster_message);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to indicate to applications and the
 *		node controller that the list of application rosters has been updated.
 *
 *	Formal Parameters:
 *		conference_id		(i) ID of conference.
 *		roster_message		(i) Roster message object holding the updated
 *									roster information.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\signatr.h ===
/*
 *
 *	signatr.h
 *	
 *	This file defines the signatures of various T.120 objects.  These
 *	signatures are used mainly for debugging debug and retail versions
 *	of T.120.
 *
 *	T.120 used to have many many dictionaries where pointers to objects were put using
 *	16-bit values as keys to search the dictionary and get the pointer to
 *	the appropriate object.  These lookups were inefficient for three
 *	reasons:
 *
 *		1. The lookup takes time
 *		2. The dictionaries take space
 *		3. A 16-bit value passed around requires masking to extract in a 
 *			32-bit machine, that is, extra instructions.
 *
 *	To eliminate these efficiency problems, the pointers to the objects are
 *	used as handles to them (unique values identifying the objects).
 *	But, to catch bugs caused by modifications of these handles as they are
 *	passed around, we need to put a signature in each object that lets us
 *	verify whether an object of type X is really an object of type X.  The way
 *	we do this is by specifying a unique signature for type X and putting this
 *	signature into every object of type X.
 *
 *	Each signature contains only 8 significant bytes.
 */

#ifndef	_T120_SIGNATURES
#define _T120_SIGNATURES

// Signature length
#define SIGNATURE_LENGTH		8

#ifdef _DEBUG
// The macro to compare signatures
#define SIGNATURE_MATCH(p, s)		(memcmp ((p)->mSignature, (s), SIGNATURE_LENGTH) == 0)
// The macro to copy signatures
#define SIGNATURE_COPY(s)			(memcpy (mSignature, (s), SIGNATURE_LENGTH))

#else		// _DEBUG
#define SIGNATURE_MATCH(p, s)		(TRUE)

#	ifndef SHIP_BUILD
#	define SIGNATURE_COPY(s)		(memcpy (mSignature, (s), SIGNATURE_LENGTH))
#	else	// SHIP_BUILD
#	define SIGNATURE_COPY(s)
#	endif	// SHIP_BUILD
#endif		// _DEBUG

extern const char *MemorySignature;

#endif	// _T120_SIGNATURES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\t120qos.h ===
extern LPIQOS				g_pIQoS;

extern DWORD g_dwLastQoSCB;
extern DWORD g_dwSentSinceLastQoS;

typedef struct _t120rrq
{
	int cResourceRequests;
	RESOURCEREQUEST aResourceRequest[1];
}T120RRQ;

extern T120RRQ g_aRRq;

extern HRESULT CALLBACK QosNotifyDataCB (
		LPRESOURCEREQUESTLIST lpResourceRequestList,
		DWORD dwThis);
extern VOID InitializeQoS( VOID );
extern VOID DeInitializeQoS( VOID );
extern VOID MaybeReleaseQoSResources( VOID );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\socket.h ===
/*	Socket.h
 *
 *	Copyright (c) 1996 by Microsoft Corporation
 *
 *	Abstract:
 *		This is the WinSock interface to a socket.  It can create a 
 *		connection with another machine, transmit and receive data, and shut
 *		down the socket when it is finished.
 *
 */
#ifndef _SOCKET_
#define _SOCKET_

#include "databeam.h"

extern "C"
{
	#include "t120.h"
	#include "winsock2.h"
}
#include "tprtsec.h"

/* States that the socket can be in */
typedef	enum
{
	NOT_CONNECTED,
	WAITING_FOR_CONNECTION,
	SOCKET_CONNECTED,
	X224_CONNECTED,
	WAITING_FOR_DISCONNECT
}	SocketState;

/* Security states that the socket can be in */
typedef enum
{
	SC_UNDETERMINED,
	SC_SECURE,
	SC_NONSECURE
}	SecurityState;

#define	MAXIMUM_IP_ADDRESS_SIZE	32

 /*
 **	This is the port number specified by IMTC
 */
#define	TCP_PORT_NUMBER			1503

typedef enum {
	READ_HEADER,
	READ_DATA,
	DISCONNECT_REQUEST,	/* There are dependencies on this order */
	CONNECTION_CONFIRM,
	CONNECTION_REQUEST,
	DATA_READY
} ReadState;

#define	WM_SOCKET_NOTIFICATION			(WM_APP)
#define	WM_SECURE_SOCKET_NOTIFICATION	(WM_APP+1)
#define	WM_PLUGGABLE_X224               (WM_APP+2)
#define WM_PLUGGABLE_PSTN               (WM_APP+3)

typedef struct _Security_Buffer_Info {
	LPBYTE		lpBuffer;
	UINT		uiLength;
} Security_Buffer_Info;

class CSocket : public CRefCount
{
public:

    CSocket(BOOL *, TransportConnection, PSecurityContext);
    ~CSocket(void);

    void FreeTransportBuffer(void);

public:

	X224_DATA_PACKET 	X224_Header;

	/* global variables */
	// SOCKET				Socket_Number;
	SocketState			State;
	SecurityState		SecState;
	PSecurityContext 	pSC;
	UINT				Max_Packet_Length;
	
	Char				Remote_Address[MAXIMUM_IP_ADDRESS_SIZE];

	/* recv state variables */
	UINT				Current_Length;
	PUChar				Data_Indication_Buffer;
	UINT				Data_Indication_Length;
	ReadState			Read_State;
	UINT				X224_Length;
	BOOL				bSpaceAllocated;
	PMemory				Data_Memory;

	/* send state variables */
	union {
	PDataPacket			pUnfinishedPacket;
	Security_Buffer_Info sbiBufferInfo;
	}					Retry_Info;

	BOOL			fExtendedX224;
	BOOL			fIncomingSecure;

    // plugable transport
    TransportConnection     XprtConn;
};

typedef	CSocket *PSocket;

class CSocketList : public CList
{
    DEFINE_CLIST(CSocketList, PSocket)
    void SafeAppend(PSocket);
    BOOL SafeRemove(PSocket);
    PSocket FindByTransportConnection(TransportConnection, BOOL fNoAddRef = FALSE);
    PSocket RemoveByTransportConnection(TransportConnection);
};

extern CSocketList     *g_pSocketList;


/* Function prototypes */
PSocket newSocket(TransportConnection, PSecurityContext);
PSocket	newPluggableSocket(TransportConnection);
PSocket	newSocketEx(TransportConnection, PSecurityContext);

void freeSocket(PSocket, TransportConnection);
void freeListenSocket(TransportConnection);
void freePluggableSocket(PSocket);
void freeSocketEx(PSocket, TransportConnection /* listen_socket_number */);

SOCKET			CreateAndConfigureListenSocket (VOID);

#endif	/* _SOCKET_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\sesskey.h ===
/*
 *	sesskey.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class CSessKeyContainer.  This class 
 *		manages the data associated with a Session Key. Session Keys are used
 *		to uniquely identify an Application Protocol Session.  The Application
 *		Protocol is identified by an Object Key and the particular session
 *		identified by an optional session ID.  The CSessKeyContainer class uses an
 *		CObjectKey container to maintain the object key data internally.  An
 *		unsigned short integer is used to hold the optional session ID.  
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */
#ifndef	_SESSION_KEY_DATA_
#define	_SESSION_KEY_DATA_

#include "objkey.h"

/*
 * This is the typedef for the structure used to hold the session key data
 * internally.
 */
typedef struct
{
	CObjectKeyContainer		    *application_protocol_key;
	GCCSessionID				session_id;
}
    SESSION_KEY;

/*
 * Class definition:
 */
class CSessKeyContainer : public CRefCount
{

public:

	CSessKeyContainer(PGCCSessionKey, PGCCError);
	CSessKeyContainer(PSessionKey, PGCCError);
	CSessKeyContainer(CSessKeyContainer *, PGCCError);

	~CSessKeyContainer(void);

	UINT		LockSessionKeyData(void);
	void		UnLockSessionKeyData(void);

	UINT		GetGCCSessionKeyData(PGCCSessionKey, LPBYTE memory);

	GCCError	GetSessionKeyDataPDU(PSessionKey);
	void		FreeSessionKeyDataPDU(void);

	BOOL    	IsThisYourApplicationKey(PGCCObjectKey);
	BOOL    	IsThisYourApplicationKeyPDU(PKey);
	BOOL    	IsThisYourSessionKeyPDU(PSessionKey);

#if 0 // LONCHANC: no one use them
	BOOL	IsThisYourSessionID(PSessionKey pSessKey)
	{
		return (m_InternalSessKey.session_id == pSessKey->session_id);
	}
	BOOL	IsThisYourSessionID(PGCCSessionKey pGccSessKey)
	{
		return (m_InternalSessKey.session_id == pGccSessKey->session_id);
	}
	BOOL	IsThisYourSessionID(UINT nSessionID)
	{
		return ((UINT) m_InternalSessKey.session_id == nSessionID);
	}
#endif

friend BOOL     operator== (const CSessKeyContainer&, const CSessKeyContainer&);

protected:

	SESSION_KEY     	m_InternalSessKey;
	UINT				m_cbDataSize;

	SessionKey 			m_SessionKeyPDU;
	BOOL    			m_fValidSessionKeyPDU;
};

/*
 *	Comments explaining the public and protected class member functions
 */

/*
 *	CSessKeyContainer (	PGCCSessionKey		session_key,
 *						PGCCError			return_value);
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This is the constructor for the CSessKeyContainer class which takes as
 *		input the "API" version of session key data, GCCSessionKey.
 *
 *	Formal Parameters:
 *		session_key			(i)	The session key data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_SESSION_KEY				-	An invalid session key passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	CSessKeyContainer (	PSessionKey			session_key,
 *						PGCCError			return_value);
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This is the constructor for the CSessKeyContainer class which takes as
 *		input the "PDU" version of session key data, SessionKey.
 *
 *	Formal Parameters:
 *		session_key			(i)	The session key data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_SESSION_KEY				-	An invalid session key passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	CSessKeyContainer(CSessKeyContainer		*session_key,
 *				    PGCCError			return_value);
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This is the copy constructor for the CSessKeyContainer class which takes
 *		as input another CSessKeyContainer object.
 *
 *	Formal Parameters:
 *		session_key			(i)	The CSessKeyContainer object to copy.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_SESSION_KEY				-	An invalid session key passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	~SessionKeyData();
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This is the destructor for the CSessKeyContainer class.  It is used to
 *		clean up any memory allocated during the life of this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	UINT			LockSessionKeyData ();
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This routine is used to "lock" the "API" data for this object.  This
 *		results in the lock count for this object being incremented.  When the
 *		lock count transitions from 0 to 1, a calculation is made to determine
 *		how much memory will be needed to hold any "API" data which will
 *		be referenced by, but not held in, the GCCSessionKey structure
 *		which is filled in on a call to GetGCCSessionKeyData.  This is the
 *		value returned by this routine in order to allow the calling object to
 *		allocate that amount of memory in preparation for the call to 
 *		GetGCCSessionKeyData.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The amount of memory, if any, which will be needed to hold "API" data
 *		which is referenced by, but not held in, the GCCSessionKey structure
 *		provided as an output parameter to the GetGCCSessionKeyData call.
 *
 *  Side Effects:
 *		The internal lock count is incremented.
 *
 *	Caveats:
 *		The internal lock count is used in conjuction with an internal "free" 
 *		flag as a mechanism for ensuring that this object remains in existance 
 *		until all interested parties are through with it.  The object remains 
 *		valid (unless explicity deleted) until the lock count is zero and the 
 *		"free" flag is set through a call to FreeSessionKeyData.  This allows
 *		other objects to lock this object and be sure that it remains valid 
 *		until they call UnLock which will decrement the internal lock count.  A
 *		typical usage scenerio for this object would be:  A CSessKeyContainer
 *		object is constructed and then passed off to any interested parties
 *		through a function call.  On return from the function call, the
 *		FreeSessionKeyData call is made which will set the internal "free"
 *		flag.  If no other parties have locked the object with a Lock call,
 *		then the CSessKeyContainer object will automatically delete itself when
 *		the FreeSessionKeyData call is made.  If, however, any number of 
 *		other parties has locked the object, it will remain in existence until
 *		each of them has unlocked the object through a call to UnLock.
 */


/*
 *	UINT			GetGCCSessionKeyData (	
 *							PGCCSessionKey 		session_key,
 *							LPSTR				memory);
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the session key data from the
 *		CSessKeyContainer object in the "API" form of a GCCSessionKey.
 *
 *	Formal Parameters:
 *		session_key			(o)	The GCCSessionKey structure to fill in.
 *		memory				(o)	The memory used to hold any data referenced by,
 *									but not held in, the output structure.
 *
 *	Return Value:
 *		The amount of data, if any, written into the bulk memory block provided.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void			UnLockSessionKeyData ();
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine 
 *		whether the object has been freed through a call to 
 *		FreeSessionKeyData.  If so, the object will automatically delete
 *		itself.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal lock count is decremented.
 *
 *	Caveats:
 *		It is the responsibility of any party which locks a CSessKeyContainer
 *		object by calling Lock to also unlock the object with a call to UnLock.
 *		If the party calling UnLock did not construct the CSessKeyContainer 
 *		object,	it should assume the object to be invalid thereafter.
 */


/*
 *	GCCError		GetSessionKeyDataPDU (	
 *							PSessionKey 		session_key);
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the session key data from the
 *		CSessKeyContainer object in the "PDU" form of a SessionKey.
 *
 *	Formal Parameters:
 *		session_key		(o)	The SessionKey structure to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void		FreeSessionKeyDataPDU ();
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This routine is used to "free" the "PDU" data allocated for this object
 *		which is held internally in a Key structure.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal "free" flag is set.
 *
 *	Caveats:
 *		This object should be assumed invalid after a call to 
 *		FreeSessionKeyDataPDU has been made.
 */


/*
 *	BOOL    		IsThisYourApplicationKey (	
 *							PGCCObjectKey			application_key);
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This routine is used to determine whether the specified application key
 *		is held within this session key object.  The application key is 
 *		provided in "API" form.
 *
 *	Formal Parameters:
 *		application_key		(i)	The application key to use for comparison.
 *
 *	Return Value:
 *		TRUE				-	The specified application key is contained 
 *									within this	session key object.
 *		FALSE				-	The specified application key is not contained 
 *									within this session key object.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	BOOL    		IsThisYourApplicationKeyPDU (	
 *							PKey				application_key);
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This routine is used to determine whether the specified application key
 *		is held within this session key object.  The application key is 
 *		provided in "PDU" form.
 *
 *	Formal Parameters:
 *		application_key		(i)	The application key to use for comparison.
 *
 *	Return Value:
 *		TRUE				-	The specified application key is contained 
 *									within this	session key object.
 *		FALSE				-	The specified application key is not contained 
 *									within this session key object.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	BOOL    		IsThisYourSessionKeyPDU (	
 *							PSessionKey			session_key);
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This routine is used to determine whether the specified session key
 *		is equal in value to the session key maintained by this object.
 *
 *	Formal Parameters:
 *		session_key		(i)	The session key to use for comparison.
 *
 *	Return Value:
 *		TRUE				-	The specified session key is equal in value to
 *									the session key maintained by this object.
 *		FALSE				-	The specified session key is not equal in value
 *									to the session key maintained by this 
 *									object.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	friend BOOL    	operator== (const CSessKeyContainer& 		session_key_1, 
 *								const CSessKeyContainer& 		session_key_2);
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This routine is used to compare two CSessKeyContainer objects to determine
 *		whether or not they are equal in value.
 *
 *	Formal Parameters:
 *		session_key_1			(i)	The first CSessKeyContainer object to compare.
 *		session_key_2			(i)	The other CSessKeyContainer object to compare.
 *
 *	Return Value:
 *		TRUE				-	The two objects are equal in value.
 *		FALSE				- 	The two objects are not equal in value.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\spacket.h ===
/*
 *	spacket.h
 *
 *	Copyright (c) 1997-98 by Microsoft Corporation, Redmond, WA
 *
 *	Abstract:
 *		This is the interface file for the SimplePacket class.  Instances of this
 *		class represent Protocol Data Units (PDUs) as they flow through the
 *		system.  Objects of this class can not be instantiated, because it's a 
 *		pure virtual class.  It exists only to be inherited from.  The Packet
 *		and DataPacket classes inherit from this one.  
 *
 *		A packet object can be created in 2 different ways.  It can be created
 *		with either decoded data or encoded data.  During instantiation, the
 *		new packet object will calculate how much memory it will need to
 *		hold both the encoded and decoded data, and attempts to allocate that
 *		memory.  If it cannot, then it will report an error, and the newly
 *		created object should be immediately destroyed.  If the allocations are
 *		successful, then the packet will report success, but WILL NOT yet put
 *		any data into those allocated buffers.
 *
 *		When a Lock message is sent to the object, it will put encoded
 *		data into the pre-allocated encode buffer.  If the packet was created
 *		with decoded data, then this will entail an encode operation.  However,
 *		if the packet was created with encoded data, then it is smart enough
 *		to just COPY the encoded data into the internal buffer, thus avoiding
 *		the overhead associated with the encode operation.
 *                  
 *		When a Lock message is sent to the object, it will put decoded
 *		data into the pre-allocated decode buffer.  If the packet was created
 *		with encoded data, then this will entail a decode operation.  However,
 *		if the packet was created with decoded data, then it is smart enough
 *		to just COPY the decoded data into the internal buffer, thus avoiding
 *		the overhead associated with the decode operation.
 *                  
 *	Caveats:
 *		None.
 *
 *	Authors:
 *		Christos Tsollis
 */

#ifndef _SIMPLE_PACKET_
#define _SIMPLE_PACKET_

/*
 *	This typedef is used to define possible return values from various public
 *	member functions of this class.
 */
typedef	enum
{
	PACKET_NO_ERROR,
	PACKET_MALLOC_FAILURE,
	PACKET_INCOMPATIBLE_PROTOCOL
} PacketError;
typedef	PacketError * 		PPacketError;

/*
 *	 Definition of class Packet.
 */

class SimplePacket
{
public:
							SimplePacket(BOOL fPacketDirectionUp);
	virtual					~SimplePacket(void) = 0;

	Void					Lock(void)
							{
								InterlockedIncrement(&lLock);
								ASSERT (lLock > 0);
							};
	UINT					GetEncodedDataLength(void) 
							{ 
								return (Encoded_Data_Length); 
							};

	void					Unlock(void);
			LPBYTE			GetEncodedData (void) 
							{ 
								ASSERT (m_EncodedPDU);
								return m_EncodedPDU;
							};
	virtual PVoid			GetDecodedData(void) = 0;
	virtual BOOL			IsDataPacket (void) = 0;
	virtual int				GetPDUType (void) = 0;

protected:
	
	long			lLock;
	LPBYTE			m_EncodedPDU;			// The encoded data pdu.
	BOOL			Packet_Direction_Up;
	UINT			Encoded_Data_Length; 	// the size of the whole encoded PDU.
};


/*
 *	SimplePacket ()
 *
 *	Functional Description:
 *		This is the default constructor of a SimplePacket.  It initializes 
 *		the few member variables to default values.
 *
 
/*
 *	~SimplePacket ()
 *
 *	Functional Description:
 *		Destructor for the SimplePacket class.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GetEncodedData ()
 *
 *	Functional Description:
 *		The GetEncodedData method returns a pointer to the encoded data
 *		buffer.  If the Packet object is oriented differently than desired
 *		by the caller of this method, then the packet coder is called to
 *		reverse the direction of the PDU.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		A pointer to the encoded data.  If an encoding error occurs, this
 *		method will return NULL.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GetDecodedData ()
 *
 *	Functional Description:
 *		The GetDecodedData method returns a pointer to the decoded data
 *		buffer.  
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		A pointer to the decoded data.  If an decoding error occurs, this
 *		method will return NULL.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\tprtsec.h ===
/*
 *	tprtsec.h
 *
 *	Copyright (c) 1997 by Microsoft Corp.
 *
 *	Author:
 *		Claus T. Giloi
 */

#ifndef	_TPRTSEC
#define	_TPRTSEC


#define SECURITY_WIN32
#include "sspi.h"
#include "spseal.h"
#include "schnlsp.h"

typedef BOOL (WINAPI *PFN_SSL_EMPTY_CACHE)(VOID);
#define SZ_SSLEMPTYCACHE "SslEmptyCache"

#ifdef UNICODE
#error "Compile time character width conflict"
// Above entry point strings need to be changed to unicode equivalents
// or abstracted.
#endif // UNICODE

/*
 *	This typedef defines the errors that can be returned from calls that are
 *	specific to TransportSecurity classes.
 */
typedef	enum
{
	TPRTSEC_NOERROR,
	TPRTSEC_NODLL,
	TPRTSEC_NOENTRYPT,
	TPRTSEC_SSPIFAIL,
	TPRTSEC_NOMEM,
	TPRTSEC_INVALID_PARAMETER,
	TPRTSEC_INCOMPLETE_CONTEXT,
	TPRTSEC_INVALID_STATE
} TransportSecurityError;

/*
 * This typedef defines the states that a security context object can be
 * in.
 */
typedef enum
{
	SECCTX_STATE_NEW,
	SECCTX_STATE_INIT,
	SECCTX_STATE_ACCEPT,
	SECCTX_STATE_INIT_COMPLETE,
	SECCTX_STATE_ACCEPT_COMPLETE,
	SECCTX_STATE_ERROR
} SecurityContextState;

/*
 *	This is simply a forward reference for the class defined below.  It is used
 *	in the definition of the owner callback structure defined in this section.
 */
class SecurityInterface;
typedef	SecurityInterface *		PSecurityInterface;
class SecurityContext;
typedef	SecurityContext *		PSecurityContext;

#ifdef DEBUG
extern void dumpbytes(PSTR szComment, PBYTE p, int cb);
#endif // DEBUG
extern BOOL InitCertList ( SecurityInterface * pSI, HWND hwnd);
extern BOOL SetUserPreferredCert ( SecurityInterface * pSI, DWORD dwCertID);

class SecurityInterface
{

	friend class SecurityContext;

	public:
								SecurityInterface (BOOL bService);
								~SecurityInterface ();

		TransportSecurityError Initialize ();
		TransportSecurityError InitializeCreds (PCCERT_CONTEXT);
		TransportSecurityError GetLastError(VOID) { return LastError; };

		BOOL GetUserCert(PBYTE pInfo, PDWORD pcbInfo);
		BOOL IsInServiceContext(VOID) { return bInServiceContext; }

	
	private:

		HINSTANCE				hSecurityDll;
		INIT_SECURITY_INTERFACE pfnInitSecurityInterface;
		PSecurityFunctionTable pfnTable;
		PFN_SSL_EMPTY_CACHE pfn_SslEmptyCache;
		

		PBYTE		m_pbEncodedCert;
		DWORD		m_cbEncodedCert;

		BOOL		bInboundCredentialValid;
		BOOL		bOutboundCredentialValid;
		BOOL		bInServiceContext;
		CredHandle hInboundCredential;
		CredHandle hOutboundCredential;
		TimeStamp tsExpiry;
		TransportSecurityError LastError;
};


class SecurityContext
{
	public:

		SecurityContext (PSecurityInterface pSI, LPCSTR szHostName);
		~SecurityContext ();

		TransportSecurityError Initialize (PBYTE pData, DWORD cbData);
		TransportSecurityError Accept (PBYTE pData, DWORD cbData);
		TransportSecurityError Encrypt(LPBYTE pBufIn1, UINT cbBufIn1,
									LPBYTE pBufIn2, UINT cbBufIn2,
									LPBYTE *ppBufOut, UINT *pcbBufOut);
		TransportSecurityError Decrypt( PBYTE pszBuf,
								  DWORD cbBuf);
		PVOID GetTokenBuf(VOID) { return OutBuffers[0].pvBuffer; };
		ULONG GetTokenSiz(VOID) { return OutBuffers[0].cbBuffer; };
		BOOL ContinueNeeded(VOID) { return fContinueNeeded; };
		BOOL StateComplete(VOID) { return
									scstate == SECCTX_STATE_INIT_COMPLETE ||
									scstate == SECCTX_STATE_ACCEPT_COMPLETE; };
		BOOL WaitingForPacket(VOID) { return
									scstate == SECCTX_STATE_NEW ||
									scstate == SECCTX_STATE_ACCEPT ||
									scstate == SECCTX_STATE_INIT; };
		TransportSecurityError AdvanceState(PBYTE pBuf,DWORD cbBuf);
		BOOL EncryptOutgoing(VOID)
			{ return scstate == SECCTX_STATE_INIT_COMPLETE; };
		BOOL DecryptIncoming(VOID)
			{ return scstate == SECCTX_STATE_ACCEPT_COMPLETE; };
		ULONG GetStreamHeaderSize(VOID) { return Sizes.cbHeader; };
		ULONG GetStreamTrailerSize(VOID) { return Sizes.cbTrailer; };
		TransportSecurityError GetLastError(VOID) { return LastError; };
		BOOL GetUserCert(PBYTE pInfo, PDWORD pcbInfo);
		BOOL Verify(VOID);

	private:

		TransportSecurityError InitContextAttributes(VOID);

		PSecurityInterface pSecurityInterface;
		SecurityContextState		scstate;
		CHAR			szTargetName[128]; // Long enough for any dotted-decimal
										  // address, followed by 2 dwords in
										  // hex.
		BOOL			bContextHandleValid;
		CtxtHandle		hContext;
		TimeStamp		Expiration;
		SecPkgContext_StreamSizes Sizes;
		SecBufferDesc	OutputBufferDescriptor;
		SecBufferDesc	InputBufferDescriptor;
		SecBuffer		OutBuffers[1];
		SecBuffer		InBuffers[2];
		ULONG			ContextRequirements;
		ULONG			ContextAttributes;
		BOOL			fContinueNeeded;
		TransportSecurityError LastError;

};

// Codes used for GetSecurityInfo()
#define NOT_DIRECTLY_CONNECTED		-1
		
#endif // _TPRTSEC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\tptif.h ===
/*
 *	tptif.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the TransportInterface class.
 *		This class provides a seamless interface to the TCP	transport stack.
 *	
 *		The public interface of this class includes a member function for each
 *		of the API routines that a user application would need to call.  The
 *		only API routines not directly accessible are those used for
 *		initialization and cleanup (which are automatically executed in the
 *		constructor and destructor, respectively).  When a user application
 *		needs to call one of the available API routines, it merely calls the
 *		equivalent member function within the proper instance of this class.
 *		The API routine will then be invoked using the same parameters.
 *	
 *		The destructor calls the cleanup routine within the DLL for which it is
 *		responsible.
 *
 *		The management plane functions include support for initialization and
 *		setup, as well as functions allowing MCS to poll the transport
 *		interfaces for activity.
 *	
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	_TRANSPORTINTERFACE_
#define	_TRANSPORTINTERFACE_

#include "tprtsec.h"

/*
 *	This typedef defines the errors that can be returned from calls that are
 *	specific to TransportInterface classes.  Note that the public member
 *	functions that map to transport stack calls do not return an error of this
 *	type.  Rather, they return an error as defined by the transport API (TRAPI).
 */
typedef	enum
{
	TRANSPORT_INTERFACE_NO_ERROR,
	TRANSPORT_INTERFACE_INITIALIZATION_FAILED,
	TRANSPORT_INTERFACE_ALLOCATION_FAILED,
	TRANSPORT_INTERFACE_NO_SUCH_CONNECTION,
	TRANSPORT_INTERFACE_CONNECTION_ALREADY_EXISTS
} TransportInterfaceError;
typedef	TransportInterfaceError *		PTransportInterfaceError;


class CTransportConnList2 : public CList2
{
    DEFINE_CLIST2(CTransportConnList2, PConnection, UINT)
    void AppendEx(PConnection p, TransportConnection XprtConn)
    {
        UINT nKey = PACK_XPRTCONN(XprtConn);
        Append(nKey, p);
    }
    PConnection FindEx(TransportConnection XprtConn)
    {
        UINT nKey = PACK_XPRTCONN(XprtConn);
        return Find(nKey);
    }
    PConnection RemoveEx(TransportConnection XprtConn)
    {
        UINT nKey = PACK_XPRTCONN(XprtConn);
        return Remove(nKey);
    }
};


/*
 *	These are the owner callback messages that a transport interface object
 *	can send.  They correspond directly to the messages that will be received
 *	from the various transport stacks.
 */
#define	CONNECT_CONFIRM				0
#define	DISCONNECT_INDICATION		1
#define	DATA_INDICATION				2
#define	STATUS_INDICATION			3
#define BUFFER_EMPTY_INDICATION		4
#define	WAIT_UPDATE_INDICATION		5

/*
 *	This is simply a forward reference for the class defined below.  It is used
 *	in the definition of the owner callback structure defined in this section.
 */
class TransportInterface;
typedef	TransportInterface *		PTransportInterface;

/*
 *	Owner Callback:	CONNECT_CONFIRM
 *	Parameter1:		Unused
 *	Parameter2:		TransportConnection		transport_connection
 *
 *	Usage:
 *		This owner callback is sent when a connect confirm is received from
 *		the transport layer.  This is to inform the recipient that a transport
 *		connection is now available for use.  Connect confirm will occur
 *		on outbound connections.  They represent a new transport connection
 *		that has resulted from this system calling a remote one.  As such,
 *		there should always be a registered owner of the transport connection
 *		(registration is a side-effect of the call to ConnectRequest).
 *
 *		So the connect confirm will be routed to the object that is the
 *		registered owner of the transport connection.  That object may now
 *		utilize the connection to transfer data.
 */

/*
 *	Owner Callback:	DISCONNECT_INDICATION
 *	Parameter1:		Unused
 *	Parameter2:		TransportConnection		transport_connection
 *
 *	Usage:
 *		This owner callback is sent when a disconnect indication is received
 *		from the transport layer.  This is to inform the recipient that a
 *		transport connection is no longer available for use.  If an object
 *		has explicitly registered itself as the owner of a transport connection,
 *		then it will receive the disconnect indication.  If there has been no
 *		such registration, then the disconnect indication will be sent to the
 *		default owner callback.
 *
 *		Once a disconnect indication has been issued for a given transport
 *		connection, that connection can no longer be used for anything.
 */

/*
 *	Owner Callback:	DATA_INDICATION
 *	Parameter1:		PDataIndicationInfo		data_indication_info
 *	Parameter2:		TransportConnection		transport_connection
 *
 *	Usage:
 *		This owner callback is sent when a data indication is received from
 *		the transport layer.  The transport data structure contains the address
 *		and length of the user data field that is associated with the data
 *		indication.  If an object in the system has explicitly registered
 *		ownership of the transport connection that carried the data (either
 *		through ConnectRequest or RegisterTransportConnection), then this
 *		callback will be sent to that object.  If no object has registered
 *		this transport connection, then the data will be sent to the default
 *		owner.
 */

/*
 *	Owner Callback:	STATUS_INDICATION
 *	Parameter1:		PTransportStatus		transport_status
 *	Parameter2:		Unused
 *
 *	Usage:
 *		This owner callback is just a pass-through of the status indication
 *		that comes from the transport layer.  It contains a pointer to a
 *		transport status structure that contains status information that
 *		originated from the stack represented by this object.  This is always
 *		passed to the default owner object.
 */

/*
 *	Owner Callback:	BUFFER_EMPTY_INDICATION
 *	Parameter1:		Unused
 *	Parameter2:		TransportConnection		transport_connection
 *
 *	Usage:
 *		This owner callback is a pass-through of the buffer empty indication
 *		that comes from the transport layer.  It is sent to the object that
 *		has registered ownership of the specified transport connection.  This
 *		indication tells that object that the transport layer can now accept
 *		more data.
 */

class Connection;
typedef Connection *PConnection;

/*
 *	This is the class definition for the TransportInterface class.  Remember,
 *	this class contains pure virtual functions which makes it an abstract base
 *	class.  It cannot be instantiated, but rather, exists to be inherited from.
 *	These derived classes will implement the behavior that is specific to a
 *	particular transport stack (or possibly just the interface to a particular
 *	transport stack).
 */
class TransportInterface
{
	public:
								TransportInterface (
									HANDLE			transport_transmit_event,
									PTransportInterfaceError
											transport_interface_error);
								~TransportInterface ();
		TransportInterfaceError RegisterTransportConnection (
									TransportConnection	transport_connection,
									PConnection			owner_object,
									BOOL				bNoNagle);
#ifdef NM_RESET_DEVICE
				TransportError 	ResetDevice (
									PChar				device_identifier);
#endif // NM_RESET_DEVICE
				TransportError 	ConnectRequest (
									TransportAddress	transport_address,
									BOOL				fSecure,
									BOOL				bNoNagle,
									PConnection			owner_object,
									PTransportConnection
														transport_connection);
				void		 	DisconnectRequest (
									TransportConnection	transport_connection);
				void			DataRequestReady () { 
									SetEvent (Transport_Transmit_Event); 
								};
				void		 	ReceiveBufferAvailable ();
				BOOL			GetSecurity( TransportConnection transport_connection );

				PSecurityInterface		pSecurityInterface;
				BOOL					bInServiceContext;
		TransportInterfaceError	CreateConnectionCallback (
									TransportConnection	transport_connection,
									PConnection			owner_object);
				void			ConnectIndication (
									TransportConnection	transport_connection);
				void			ConnectConfirm (
									TransportConnection	transport_connection);
				void			DisconnectIndication (
									TransportConnection	transport_connection,
									ULONG               ulReason);
				TransportError	DataIndication (
									PTransportData		transport_data);
				void			BufferEmptyIndication (
									TransportConnection	transport_connection);

private:

		CTransportConnList2     m_TrnsprtConnCallbackList2;
		HANDLE					Transport_Transmit_Event;
};

/*
 *	TransportInterface (
 *			PTransportInterfaceError	transport_interface_error)
 *
 *	Functional Description:
 *		The constructor initializes the TCP transport code.
 *	
 *		The constructor also includes parameters specifying the default
 *		callback. This callback is used to inform the controller whenever an
 *		unexpected inbound connection is detected.  This gives the controller
 *		the opportunity to assign responsibility for the new connection to some
 *		other object in the system.
 *	
 *		If anything goes wrong in the constructor, the return value (whose
 *		address is passed as a constructor parameter) will be set to one of the
 *		failure codes.  If this happens, it is expected that whoever invoked the
 *		constructor (probably the controller), will immediately delete the
 *		object without using it.  Failure to do this WILL result in unexpected
 *		behavior.
 *
 *	Formal Parameters:
 *		default_owner_object (i)
 *			This is the address of the object that will handle all transport
 *			events for unregistered transport connections.  This includes
 *			connect indication, dicsonnect indication, and data indication.
 *			This object will also receive all state and message indications.
 *		default_owner_message_base (i)
 *			This is the base value to be used for all owner callback messages.
 *		transport_interface_error (o)
 *			This is where the return code will be stored so that the creator of
 *			this object can make sure that everything is okay before using the
 *			new object.  If this value is set to anything but success, the
 *			object should be destroyed immediately, without being used.
 *
 *	Return Value:
 *		Note: the return value is handled as a constructor parameter.
 *		TRANSPORT_INTERFACE_NO_ERROR
 *			Everything worked, and the object is ready for use.
 *		TRANSPORT_INTERFACE_INITIALIZATION_FAILED
 *			The initialization of the transport interface object failed.  It is
 *			therefore necessary to destroy the object without attempting to
 *			use it.
 *
 *	Side Effects:
 *		A DLL will be loaded into memory, for later use.
 *
 *	Caveats:
 */
 
/*
 *	~TransportInterface ()
 *
 *	Functional Description:
 *		The destructor frees up all resources used by the base class.  This
 *		is primarily associated with the callback list (which is maintained by
 *		this class).
 *
 *	Formal Parameters:
 *		Destructors have no parameters.
 *
 *	Return Value:
 *		Destructors have no return value.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	TransportInterfaceError 	RegisterTransportConnection (
 *			TransportConnection		transport_connection,
 *			PConnection				owner_object,
 *			BOOL					bNoNagle)
 *
 *	Functional Description:
 *		When an inbound connection is detected, an entry is created in the
 *		callback list for it using the default owner callback information (that
 *		was specified in the constructor).  This means that all events detected
 *		for the new transport connection will be sent to the default owner
 *		object until another object explicitly registers itself as the owner
 *		of the transport connection.  That is what this routine is used for.
 *
 *		Once an object has registered itself as the owner of a transport
 *		connection, it will receive all events related to that connection.
 *
 *	Formal Parameters:
 *		transport_connection (i)
 *			This is the transport connection for which the callback information
 *			is to be associated.
 *		owner_object (i)
 *			This is the address of the Connection object that is to receive all transport
 *			layer events for the specified transport connection.
 *		bNoNagle (i)
 *			Should the connection stop using the Nagle algorithm?
 *
 *	Return Value:
 *		TRANSPORT_INTERFACE_NO_ERROR
 *			The operation completed successfully.
 *		TRANSPORT_INTERFACE_NO_SUCH_CONNECTION
 *			This indicates that the named transport connection does not exist.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	TransportError 	ConnectRequest (
 *			TransportAddress		transport_address,
 *			BOOL					bNoNagle,
 *			PConnection				owner_object,
 *			PTransportConnection	transport_connection)
 *
 *	Functional Description:
 *		This operation is invoked when the user application wishes to establish
 *		an outbound connection.  Assuming that everything is successful, the
 *		owner callback information that is passed in to this operation is saved
 *		for later use.  All events for this transport connection will be routed
 *		to the specified owner rather than the default owner.
 *
 *	Formal Parameters:
 *		transport_address (i)
 *			This is the transport address to be passed to the transport stack
 *			during the connection creation process.  The format of this address
 *			string will vary by transport stack, and cannot be specified here.
 *		bNoNagle (i)
 *			Do we need to disable the Nagle algorithm?
 *		owner_object (i)
 *			This is the address of the object that is to receive all transport
 *			layer events for the new transport connection.
 *		transport_connection (o)
 *			This is the address of the variable that is to receive the transport
 *			connection handle that is associated with this connection.  Note
 *			that this handle is assigned before the connection is actually
 *			established, to allow the application to abort a connection in
 *			progress.
 *
 *	Return Value:
 *		TRANSPORT_NO_ERROR
 *			The operation completed successfully.
 *		TRANSPORT_NOT_INITIALIZED
 *			The transport stack is not initialized.
 *
 *	Side Effects:
 *		An outbound connection establishment process is begun in the background.
 *
 *	Caveats:
 *		None.
 */
/*
 *	TransportError 	DisconnectRequest (
 *			TransportConnection		transport_connection)
 *
 *	Functional Description:
 *		This operation is used to break an existing transport connection.  If
 *		the operation is successful, the transport connection will be removed
 *		from the callback list.
 *
 *	Formal Parameters:
 *		transport_connection (i)
 *			This is the transport connection that is to be broken.
 *
 *	Return Value:
 *		TRANSPORT_NO_ERROR
 *			The operation completed successfully.
 *		TRANSPORT_NOT_INITIALIZED
 *			The transport stack is not initialized.
 *		TRANSPORT_NO_SUCH_CONNECTION
 *			This indicates that the specified transport connection does not
 *			exist.
 *
 *	Side Effects:
 *		A transport connection is severed.
 *
 *	Caveats:
 *		None.
 */

/*
 *	TransportError 	PollReceiver ()
 *
 *	Functional Description:
 *		This operation is used to check a transport stack for incoming data (or
 *		other events, such as connect and disconnect indications).  In a single
 *		threaded environment, this call could also be used to provide a
 *		time-slice for the processing of inbound data, as well as other events
 *		(such as the creation of new connections).
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		TRANSPORT_NO_ERROR
 *			The operation completed successfully.
 *
 *	Side Effects:
 *		This can result in callbacks from the transport layer back into this
 *		object.
 *
 *	Caveats:
 *		None.
 */


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\token.h ===
/*
 *	token.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the Token class.  Objects of this class
 *		represent tokens in the MCS environment.  Whenever a token is allocated
 *		by a user, one of these objects is created.  Its job is to handle all
 *		requests that are specific to the token ID with which it is associated.
 *
 *		Tokens in the MCS environment are used for critical resource management.
 *		The exact use of tokens is up to the user applications attaching to
 *		MCS.  They are provided as a generic resource.
 *
 *		Tokens can be "owned" by one or more users.  There are two types of
 *		ownership.  There is exclusive ownership, where only one user can
 *		own the token at a time.  That user has "grabbed" the token.  And there
 *		is non-exclusive ownership, where several users can own the token at
 *		the same time.  Those users have "inhibited" the token.  It is not
 *		possible to mix exclusive and non-exclusive ownership.
 *
 *		If a user has grabbed a token, that same user can inhibit the token,
 *		thus converting to non-exclusive ownership.  Similarly, if a user is
 *		the sole inhibitor of a token, that user can grab the token, thus
 *		converting to exclusive ownership.
 *
 *		During a domain merge operation, it is necessary to merge tokens upward
 *		to the new Top Provider of the enlarged domain.  This class also defines
 *		a member function allowing it to be told to issue a merge request with
 *		all of its state contained therein.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	_TOKEN_
#define	_TOKEN_

/*
 *	This is the class definition for the Token class.
 */
class	Token
{
public:

	Token (
			TokenID				token_id,
			PDomain             local_provider,
			PConnection         top_provider,
			CChannelList2      *channel_list,
			CAttachmentList    *attachment_list);
	Token (
			TokenID				token_id,
			PDomain             local_provider,
			PConnection         top_provider,
			CChannelList2      *channel_list,
			CAttachmentList    *attachment_list,
			TokenState			token_state,
			UserID				grabber,
			CUidList           *inhibitor_list,
			UserID				recipient);
	~Token ();

    void    SetTopProvider(PConnection top_provider) { m_pConnToTopProvider = top_provider; }
    BOOL    IsTopProvider(void) { return (m_pConnToTopProvider == NULL); }

				TokenState	GetTokenState () { return (Token_State); };
				BOOL    	IsValid ();
				Void		IssueMergeRequest ();
		Void		TokenGrabRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									TokenID				token_id);
		Void		TokenGrabConfirm (
									Result				result,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
		Void		TokenInhibitRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									TokenID				token_id);
		Void		TokenInhibitConfirm (
									Result				result,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
		Void		TokenGiveRequest (
									CAttachment        *originator,
									PTokenGiveRecord	pTokenGiveRec);
		Void		TokenGiveIndication (
									PTokenGiveRecord	pTokenGiveRec);
		Void		TokenGiveResponse (
									Result				result,
									UserID				receiver_id,
									TokenID				token_id);
		Void		TokenGiveConfirm (
									Result				result,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
		Void		TokenPleaseRequest (
									UserID				uidInitiator,
									TokenID				token_id);
		Void		TokenPleaseIndication (
									UserID				uidInitiator,
									TokenID				token_id);
		Void		TokenReleaseRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									TokenID				token_id);
		Void		TokenReleaseConfirm (
									Result				result,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
		Void		TokenTestRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									TokenID				token_id);
		Void		TokenTestConfirm (
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);

	private:
				BOOL    	ValidateUserID (
									UserID				user_id);
			CAttachment    *GetUserAttachment (
									UserID				user_id);
				Void		IssueTokenReleaseIndication (
									UserID				user_id);
				Void		BuildAttachmentList (
									CUidList            *user_id_list,
									CAttachmentList     *attachment_list);

		TokenID				Token_ID;
		PDomain             m_pDomain;
		PConnection         m_pConnToTopProvider;
		CChannelList2      *m_pChannelList2;
		CAttachmentList    *m_pAttachmentList;
		TokenState			Token_State;
		UserID				m_uidGrabber;
		CUidList			m_InhibitorList;
		UserID				m_uidRecipient;
};

/*
 *	Token (
 *			TokenID				token_id,
 *			PDomain     		local_provider,
 *			PConnection 		top_provider,
 *			PChannelList		channel_list,
 *			PAttachmentList		attachment_list)
 *
 *	Functional Description:
 *		This is the constructor for the Token class.  It simply initializes
 *		local instance variables with the passed in values.  It also marks
 *		the state of the token as available.
 *
 *	Formal Parameters:
 *		token_id (i)
 *			This is the token ID that this token object is associated with.
 *		local_provider (i)
 *			This is a pointer to the local provider.  A Token object will
 *			never actually send a command to the local provider, but it needs
 *			this value to use a parameter when it sends commands to various
 *			attachments (since it is doing so on behalf of the local provider).
 *		top_provider (i)
 *			This is a pointer to the top provider.  This is used by the
 *			Token object when it needs to issue a request to the Top
 *			Provider.
 *		channel_list (i)
 *			This is a pointer to the domain's channel list, which identifies
 *			all valid channels in the domain.  This is used by token objects
 *			to validate user IDs.
 *		attachment_list (i)
 *			This is a pointer to the domain's attachment list, which identifies
 *			all valid attachments in the domain.  This is used by token
 *			objects to validate joined attachments.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Token (
 *			TokenID				token_id,
 *			PDomain     		local_provider,
 *			PConnection 		top_provider,
 *			PChannelList		channel_list,
 *			PAttachmentList		attachment_list,
 *			TokenState			token_state,
 *			UserID				grabber,
 *			CUidList           *inhibitor_list,
 *			UserID				recipient)
 *
 *	Functional Description:
 *		This is the constructor for the Token class.  It simply initializes
 *		local instance variables with the passed in values.  It also marks
 *		the state of the token as available.
 *
 *	Formal Parameters:
 *		token_id (i)
 *			This is the token ID that this token object is associated with.
 *		local_provider (i)
 *			This is a pointer to the local provider.  A Token object will
 *			never actually send a command to the local provider, but it needs
 *			this value to use a parameter when it sends commands to various
 *			attachments (since it is doing so on behalf of the local provider).
 *		top_provider (i)
 *			This is a pointer to the top provider.  This is used by the
 *			Token object when it needs to issue a request to the Top
 *			Provider.
 *		channel_list (i)
 *			This is a pointer to the domain's channel list, which identifies
 *			all valid channels in the domain.  This is used by token objects
 *			to validate user IDs.
 *		attachment_list (i)
 *			This is a pointer to the domain's attachment list, which identifies
 *			all valid attachments in the domain.  This is used by token
 *			objects to validate joined attachments.
 *		token_state (i)
 *			This is the state of the token being merged.
 *		grabber (i)
 *			This is the user ID of the user who has the token grabbed (this is
 *			only valid if the token state is grabbed or giving).
 *		inhibitor_list (i)
 *			This is a list of the users who have the token inhibited (this is
 *			only valid if the token state is inhibited).
 *		recipient (i)
 *			This is the user ID of the user who is being offered the token
 *			as part of a give operation (this is only valid if the token state
 *			is giving or given).
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~Token ()
 *
 *	Functional Description:
 *		This is a virtual destructor defined for the Token class.  It does
 *		nothing at this time.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		SetTopProvider (
 *						PConnection		top_provider)
 *
 *	Functional Description:
 *		This member function is used to change the identity of the Top Provider
 *		in an existing token.  The only time this will really occur is when
 *		a provider that used to be the Top Provider merges into another
 *		domain, and therefore ceases to be the Top Provider.  When the merge
 *		operation has been successfully completed, this function allows the
 *		domain to inform all of its Token objects about the identity of
 *		the new Top Provider.
 *
 *	Formal Parameters:
 *		top_provider (i)
 *			This is a pointer to the new Top Provider.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	TokenState		GetTokenState ()
 *
 *	Functional Description:
 *		This function returns the current state of the token.  This is used
 *		by the caller primarily during a merge operation, when decisions have
 *		to made about what tokens can and cannot be merged.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		TOKEN_AVAILABLE if the token is not in use.
 *		TOKEN_GRABBED if the token is currently grabbed.
 *		TOKEN_INHIBITED if the token is currently inhiited.
 *		TOKEN_GIVING if the token is currently in the giving state.
 *		TOKEN_GIVEN if the token is currently in the given state.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	BOOL    	IsValid ()
 *
 *	Functional Description:
 *		This function returns TRUE if the token is still valid, or FALSE if the
 *		token needs to be deleted.  A token is valid if it has ANY owners
 *		(grabbers, inhibitors, or recipient).
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		TRUE if the token is valid.
 *		FALSE if the token needs to be deleted.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void			IssueMergeRequest ()
 *
 *	Functional Description:
 *		This function is called during a domain merge operation.  It causes
 *		the token object to pack it state and send it out in a merge token
 *		request to the top provider.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void			TokenGrabRequest (
 *							PCommandTarget		originator,
 *							UserID				uidInitiator,
 *							TokenID				token_id)
 *
 *	Functional Description:
 *		This function is called when a user wishes to grab a token.  Depending
 *		on the current state of the token, the request will either succeed or
 *		fail.  Either way, an appropriate token grab confirm will be issued
 *		to the requesting user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		uidInitiator (i)
 *			This is the user ID of the user that originated the request.
 *		token_id (i)
 *			This is the token being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void			TokenGrabConfirm (
 *							PCommandTarget		originator,
 *							Result				result,
 *							UserID				uidInitiator,
 *							TokenID				token_id,
 *							TokenStatus			token_status)
 *
 *	Functional Description:
 *		This function is called as a result of the top provider answering a
 *		previous grab request.  It tells the user whether or not the request
 *		succeeded.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		result (i)
 *			This is the result of the request.  RESULT_SUCCESSFUL indicates
 *			that the token was successfully grabbed.
 *		uidInitiator (i)
 *			This is the user ID of the user that originated the request.
 *		token_id (i)
 *			This is the token being acted upon.
 *		token_status (i)
 *			This is the status of the token after this request is processed.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void			TokenInhibitRequest (
 *							PCommandTarget		originator,
 *							UserID				uidInitiator,
 *							TokenID				token_id)
 *
 *	Functional Description:
 *		This function is called when a user wishes to inhibit a token.
 *		Depending on the current state of the token, the request will either
 *		succeed or fail.  Either way, an appropriate token inhibit confirm will
 *		be issued to the requesting user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		uidInitiator (i)
 *			This is the user ID of the user that originated the request.
 *		token_id (i)
 *			This is the token being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void			TokenInhibitConfirm (
 *							PCommandTarget		originator,
 *							Result				result,
 *							UserID				uidInitiator,
 *							TokenID				token_id,
 *							TokenStatus			token_status)
 *
 *	Functional Description:
 *		This function is called as a result of the top provider answering a
 *		previous inhibit request.  It tells the user whether or not the request
 *		succeeded.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		result (i)
 *			This is the result of the request.  RESULT_SUCCESSFUL indicates
 *			that the token was successfully inhibited.
 *		uidInitiator (i)
 *			This is the user ID of the user that originated the request.
 *		token_id (i)
 *			This is the token being acted upon.
 *		token_status (i)
 *			This is the status of the token after this request is processed.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenGiveRequest (
 *					PCommandTarget		originator,
 *					PTokenGiveRecord	pTokenGiveRec)
 *
 *	Functional Description:
 *		This function is called when a user wishes to give a token to another
 *		user.  Depending on the current state of the token, the request will
 *		either succeed or fail.  Either way, an appropriate token grab confirm
 *		will be issued to the requesting user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		pTokenGiveRec (i)
 *			This is the address of a structure containing the following information:
 *			The ID of the user attempting to give away the token.
 *			The ID of the token being given.
 *			The ID of the user that the token is being given to.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenGiveIndication (
 *					PCommandTarget		originator,
 *					PTokenGiveRecord	pTokenGiveRec)
 *
 *	Functional Description:
 *		This function is called when the top provider wants to indicate to a
 *		user that another user is offering them a token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		pTokenGiveRec (i)
 *			This is the address of a structure containing the following information:
 *			The ID of the user attempting to give away the token.
 *			The ID of the token being given.
 *			The ID of the user that the token is being given to.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenGiveResponse (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				receiver_id,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This function is called in response to a previous give indication.  It
 *		contains the user's answer as to whether or not the token was
 *		accepted.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		result (i)
 *			This is the result of the request.  RESULT_SUCCESSFUL indicates that
 *			the recipient has accepted the token.
 *		token_id (i)
 *			This is the token being acted upon.
 *		receiver_id (i)
 *			This is the ID of the user that is to receive the token.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenGiveConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This function is called to send a confirmation back to a user who
 *		is trying to give away a token.  It lets the user know whether or
 *		not the operation was successful.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		result (i)
 *			This is the result of the request.  RESULT_SUCCESSFUL indicates that
 *			the recipient has accepted the token.
 *		uidInitiator (i)
 *			This is the user ID of the user that originated the request.
 *		token_id (i)
 *			This is the token being acted upon.
 *		token_status (i)
 *			This is the status of the token after the operation.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenPleaseRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This function is called when a user wishes to ask the current owners
 *		of a token to relinquish it.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		uidInitiator (i)
 *			This is the user ID of the user that originated the request.
 *		token_id (i)
 *			This is the token being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenPleaseIndication (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This function is initially called by the top provider in response to
 *		a received token please request.  It is forwarded to all users who
 *		currently own the specified token, asking them to relinquish it.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		uidInitiator (i)
 *			This is the user ID of the user that originated the request.
 *		token_id (i)
 *			This is the token being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	BOOL    		TokenReleaseRequest (
 *							PCommandTarget		originator,
 *							UserID				uidInitiator,
 *							TokenID				token_id)
 *
 *	Functional Description:
 *		This function is called when a user wishes to release a token.
 *		Depending on the current state of the token, the request will either
 *		succeed or fail.  Either way, an appropriate token release confirm will
 *		be issued to the requesting user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		uidInitiator (i)
 *			This is the user ID of the user that originated the request.
 *		token_id (i)
 *			This is the token being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void			TokenReleaseConfirm (
 *							PCommandTarget		originator,
 *							Result				result,
 *							UserID				uidInitiator,
 *							TokenID				token_id,
 *							TokenStatus			token_status)
 *
 *	Functional Description:
 *		This function is called as a result of the top provider answering a
 *		previous release request.  It tells the user whether or not the request
 *		succeeded.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		result (i)
 *			This is the result of the request.  RESULT_SUCCESSFUL indicates
 *			that the token was successfully released.
 *		uidInitiator (i)
 *			This is the user ID of the user that originated the request.
 *		token_id (i)
 *			This is the token being acted upon.
 *		token_status (i)
 *			This is the status of the token after this request is processed.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void			TokenTestRequest (
 *							PCommandTarget		originator,
 *							UserID				uidInitiator,
 *							TokenID				token_id)
 *
 *	Functional Description:
 *		This function is called when a user wishes to test the current state
 *		of a token.  The token will issue a token test confirm to the
 *		originating user containing the requested information.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		uidInitiator (i)
 *			This is the user ID of the user that originated the request.
 *		token_id (i)
 *			This is the token being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void			TokenTestConfirm (
 *							PCommandTarget		originator,
 *							UserID				uidInitiator,
 *							TokenID				token_id,
 *							TokenStatus			token_status)
 *
 *	Functional Description:
 *		This function is called as a result of the top provider answering a
 *		previous test request.  It tells the user the current state of the
 *		token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		uidInitiator (i)
 *			This is the user ID of the user that originated the request.
 *		token_id (i)
 *			This is the token being tested.
 *		token_status (i)
 *			This is the current status of the token.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\translat.h ===
/*
 *	translat.h
 *
 *	Copyright (c) 1993 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */
#ifndef	_REASON_RESULT_TRANSLATOR_
#define	_REASON_RESULT_TRANSLATOR_

#include "gccpdu.h"

GCCResult				TranslateCreateResultToGCCResult (
						ConferenceCreateResult		create_result);

GCCResult				TranslateQueryResultToGCCResult (
						ConferenceQueryResult		query_result);

GCCResult				TranslateJoinResultToGCCResult (
						ConferenceJoinResult		join_result);

GCCResult				TranslateInviteResultToGCCResult (
						ConferenceInviteResult		invite_result);

GCCResult				TranslateRegistryRespToGCCResult(
						RegistryResponseResult		response_result);

ConferenceCreateResult	TranslateGCCResultToCreateResult (
						GCCResult 					gcc_result);

ConferenceQueryResult	TranslateGCCResultToQueryResult (
						GCCResult 					gcc_result);

ConferenceJoinResult	TranslateGCCResultToJoinResult (
						GCCResult 					gcc_result);

ConferenceInviteResult	TranslateGCCResultToInviteResult (
						GCCResult 					gcc_result);

RegistryResponseResult	TranslateGCCResultToRegistryResp(
						GCCResult					gcc_result);

GCCReason				TranslateTerminateRqReasonToGCCReason (
						ConferenceTerminateRequestReason 	reason);

ConferenceTerminateRequestReason	
						TranslateGCCReasonToTerminateRqReason (
						GCCReason 					gcc_reason);

GCCReason				TranslateEjectIndReasonToGCCReason(
						ConferenceEjectIndicationReason	eject_reason);

ConferenceEjectIndicationReason						
						TranslateGCCReasonToEjectInd (
						GCCReason					gcc_reason);

GCCResult				TranslateEjectResultToGCCResult(
						ConferenceEjectResult		eject_result);

ConferenceEjectResult	TranslateGCCResultToEjectResult (
						GCCResult					gcc_result);

GCCReason				TranslateTerminateInReasonToGCCReason (
						ConferenceTerminateIndicationReason	reason);

ConferenceTerminateIndicationReason
						TranslateGCCReasonToTerminateInReason (
						GCCReason							gcc_reason);

ConferenceTerminateResult	
						TranslateGCCResultToTerminateResult (
						GCCResult						gcc_result);

GCCResult				TranslateTerminateResultToGCCResult (
						ConferenceTerminateResult		result);

ConferenceLockResult	TranslateGCCResultToLockResult (
								GCCResult				gcc_result);

GCCResult				TranslateLockResultToGCCResult (
								ConferenceLockResult	result);

ConferenceUnlockResult	TranslateGCCResultToUnlockResult (
								GCCResult				gcc_result);

GCCResult				TranslateUnlockResultToGCCResult (
								ConferenceUnlockResult	result);

ConferenceAddResult		TranslateGCCResultToAddResult (
								GCCResult				gcc_result);

GCCResult				TranslateAddResultToGCCResult (
								ConferenceAddResult		add_result);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\userchnl.h ===
/*
 *	userchnl.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the UserChannel class.  Objects of this
 *		class represent user ID channels in the MCS environment.  This class
 *		inherits most of its behavior from class Channel.  In fact, with the
 *		exception of how user channels are joined, and how merge commands are
 *		constructed, this class works exactly the same as class Channel.
 *
 *		When a user attaches to a domain, each provider in the path from the
 *		Top Provider to the user will create an object of this class.  Unlike
 *		static and assigned channels, it is NOT necessary for the user to
 *		be joined to the channel for the channel to exist.  It is perfectly
 *		legal to have a user channel that no one is joined to.
 *
 *		The major distinguishing characteristic of user channels is that they
 *		know the user ID of the user they are associated with.  They will
 *		only allow that user to join the channel.  Furthermore, when the user
 *		leaves the usert channel, the LeaveRequest does not return a value
 *		asking to be deleted.  Anyone can send data on a user ID channel.
 *
 *		The merge channel command is constructed slightly differently for user
 *		channels, so that behavior is overridden here as well.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	_USERCHANNEL_
#define	_USERCHANNEL_

/*
 *	This is the class definition for the UserChannel class.
 */
class	UserChannel : public Channel
{
public:
	UserChannel (
			ChannelID			channel_id,
			CAttachment        *user_attachment,
			PDomain             local_provider,
			PConnection         top_provider,
			CChannelList2      *channel_list,
			CAttachmentList    *attachment_list);
	UserChannel (
			ChannelID			channel_id,
			CAttachment        *user_attachment,
			PDomain             local_provider,
			PConnection         top_provider,
			CChannelList2      *channel_list,
			CAttachmentList    *attachment_list,
			PConnection         pConn);
    virtual					~UserChannel ();
		virtual Channel_Type	GetChannelType ();
		virtual	BOOL    		IsValid ();
		virtual CAttachment *GetAttachment(void);
		virtual	Void			IssueMergeRequest ();
		virtual Void			ChannelJoinRequest (
										CAttachment        *originator,
										UserID				uidInitiator,
										ChannelID			channel_id);
		virtual Void			SendDataRequest (
										CAttachment        *originator,
										UINT				type,
										PDataPacket			data_packet);

private:

    CAttachment         *m_pUserAttachment;
};
typedef	UserChannel *			PUserChannel;

/*
 *	UserChannel (
 *			ChannelID			channel_id,
 *			PCommandTarget		user_attachment,
 *			PDomain     		local_provider,
 *			PConnection 		top_provider,
 *			PChannelList		channel_list,
 *			PAttachmentList		attachment_list)
 *
 *	Functional Description:
 *		This is the normal constructor for the UserChannel class.  It simply
 *		initializes the instance variables that identify the channel, the local
 *		provider, the top provider, and the user attachment.  The attachment
 *		list is empty by default (meaning that the user is not yet joined to
 *		its channel).
 *
 *		Upon successful construction of this object, an attach user confirm
 *		is automatically issued to the user.
 *
 *	Formal Parameters:
 *		channel_id (i)
 *			This is the ID of the channel object.  By keeping track of this
 *			internally, it doesn't have to be passed in for every operation.
 *		user_attachment (i)
 *			This is the attachment which leads to the user represented by this
 *			UserChannel object.  It does not matter if it is a local attachment
 *			or a remote attachment.  This is used to issue MCS commands (such
 *			as attach user confirm) to the user.
 *		local_provider (i)
 *			This is the identity of the local provider.  A UserChannel object
 *			needs this since it issues MCS commands on behalf of the local
 *			provider.
 *		top_provider (i)
 *			This is a pointer to the top provider.  This is used by the
 *			UserChannel object when it needs to issue a request to the Top
 *			Provider.
 *		channel_list (i)
 *			This is a pointer to the domain's channel list, which identifies
 *			all valid channels in the domain.  This is used by channel objects
 *			to validate user IDs.
 *		attachment_list (i)
 *			This is a pointer to the domain's attachment list, which identifies
 *			all valid attachments in the domain.  This is used by channel
 *			objects to validate joined attachments.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	UserChannel (
 *			ChannelID			channel_id,
 *			PCommandTarget		user_attachment,
 *			PDomain     		local_provider,
 *			PConnection 		top_provider,
 *			PChannelList		channel_list,
 *			PAttachmentList		attachment_list,
 *			PCommandTarget		attachment)
 *
 *	Functional Description:
 *		This is a secondary version of the constructor that is used only during
 *		merge operations.  The only difference between this one and the one
 *		above is that this one allows the specification of an initial
 *		attachment.  This allows a UserChannel object to be constructed with the
 *		user already joined to the channel.  The initial attachment should be
 *		the same as the user attachment.
 *
 *		This version of the constructor will not issue an attach user confirm
 *		or a channel join confirm to the user.
 *
 *	Formal Parameters:
 *		channel_id (i)
 *			This is the ID of the channel object.  By keeping track of this
 *			internally, it doesn't have to be passed in for every operation.
 *		user_attachment (i)
 *			This is the attachment which leads to the user represented by this
 *			UserChannel object.  It does not matter if it is a local attachment
 *			or a remote attachment.  This is used to issue MCS commands (such
 *			as attach user confirm) to the user.
 *		local_provider (i)
 *			This is the identity of the local provider.  A UserChannel object
 *			needs this since it issues MCS commands on behalf of the local
 *			provider.
 *		top_provider (i)
 *			This is a pointer to the top provider.  This is used by the
 *			UserChannel object when it needs to issue a request to the Top
 *			Provider.
 *		channel_list (i)
 *			This is a pointer to the domain's channel list, which identifies
 *			all valid channels in the domain.  This is used by channel objects
 *			to validate user IDs.
 *		attachment_list (i)
 *			This is a pointer to the domain's attachment list, which identifies
 *			all valid attachments in the domain.  This is used by channel
 *			objects to validate joined attachments.
 *		attachment (i)
 *			This is the initial attachment for the channel.  A channel join
 *			confirm is NOT issued to the attachment.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~UserChannel ()
 *
 *	Functional Description:
 *		This is the UserChannel class destructor.  It does nothing at this time.
 *		The base class constructor takes care of clearing the attachment list.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Channel_Type	GetChannelType ()
 *
 *	Functional Description:
 *		This virtual member function returns the type of the channel.  For this
 *		class it will always be USER_CHANNEL.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		USER_CHANNEL
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	BOOL    	IsValid ()
 *
 *	Functional Description:
 *		This function always returns TRUE since User ID channels are always
 *		valid (as long as the user is still attached).
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		TRUE
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	CAttachment *GetAttachment ()
 *
 *	Functional Description:
 *		This function is used to retrieve the attachment associated with the
 *		user represented by this object.  This is used by Domain objects when
 *		it is necessary to send an MCS command to a user, and it needs to know
 *		how to get it there.  That information is currently excapsulated within
 *		this class.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		A pointer to the attachment that leads to the user represented by this
 *		object.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		IssueMergeRequest ()
 *
 *	Functional Description:
 *		This member function causes the UserChannel object to issue a merge
 *		request to the top provider.  It will pack the appropriate local
 *		information into the command.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelJoinRequest (
 *						PCommandTarget		originator,
 *						UserID				uidInitiator,
 *						ChannelID			channel_id)
 *
 *	Functional Description:
 *		This function is invoked when a user tries to join the channel
 *		associated with a UserChannel object.  The originator of the request
 *		will only be permitted to join if their user ID matches that of the
 *		user with which this UserChannel object is associated.  If it does,
 *		then the originator will be permitted to join.
 *
 *		If this provider is not the Top Provider, then the request will be
 *		forwarded upward to the Top Provider.  If this is the Top Provider,
 *		the a channel join confirm will be issued back to the requesting
 *		user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment of the user wishing to join the channel.
 *		uidInitiator (i)
 *			This is the user ID of the user joining the channel.  This must
 *			be the same as the user ID represented by the object, or the
 *			request will automatically be rejected.
 *		channel_id (i)
 *			This is the channel being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	SendDataRequest (
 *					PCommandTarget		originator,
 *					PDataPacket			data_packet)
 *
 *	Functional Description:
 *		This member function handles a send data request on the channel.  It
 *		determines where to send the data.  This differs from the base class
 *		implementation only in that it is unnecessary to send data upward
 *		if it is known that the user is in the sub-tree of the current
 *		provider.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the data originated.
 *		data_packet (i)
 *			This is a pointer to a DataPacket object containing the channel
 *			ID, the User ID of the data sender, segmentation flags, priority of
 *			the data packet and a pointer to the packet to be sent.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\user.h ===
/*
 *	user.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the User class.  Instances of this class
 *		represent attachments between user applications and domains within MCS.
 *
 *		This class inherits from CommandTarget.  This means that all message
 *		traffic between this class and other CommandTarget classes is in MCS
 *		commands.  Not all commands need to be handled (some are not relevant
 *		for user attachments).  For example, a user attachment should never
 *		receive a SendDataRequest.  It should only receive indications,
 *		confirms, and ultimatums.
 *
 *		Messages coming from the application pass through one of these objects,
 *		where they are translated into MCS commands before being sent to the
 *		domain to which this user is attached.  This usually involves adding
 *		the correct user ID, as well as a fair amount of error checking and
 *		parameter validation.
 *
 *		It is worth noting that this class contains two types of public member
 *		functions.  The first type represent messages flowing from the user
 *		application into MCS.  All of these member functions are inherited from the
 *		IMCSSap interface.  These are converted as memntioned above, and sent
 *		into the appropriate domain if everything checks out.  The second type
 *		of public member function represents messages flowing from within MCS
 *		to the user application.  All of these member function are overrides
 *		of virtual functions defined in class CommandTarget, and are not
 *		prefixed with anything.
 *
 *		Messages coming from the domain are translated into T.122 indications
 *		and confirms, and sent to the proper application interface object via
 *		the owner callback mechanism.
 *
 *		A third duty of this class is to post indications and confirms to user
 *		applications using a client window.  The client must dispatch messages
 *		to receive these indications/confirms.  It also
 *		prevents a user application from having to worry about receiving an
 *		indication or confirm before they have even returned from the request
 *		that caused it.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */

#ifndef	_USER_
#define	_USER_

/*
 *	Interface files.
 */
#include "pktcoder.h"
#include "imcsapp.h"
#include "attmnt.h"

/*
 *	These types are used to keep track of what users have attached to MCS
 *	within a given process, as well as pertinent information about that
 *	attachment.
 *
 *	BufferRetryInfo
 *		In cases where MCSSendDataRequest and MCSUniformSendDataRequest fail
 *		due to a lack of resources, this structure will be used to capture
 *		appropriate information such that follow-up resource level checks can
 *		be performed during timer events.
 */

typedef struct
{
	ULong					user_data_length;
	UINT_PTR				timer_id;
} BufferRetryInfo;
typedef BufferRetryInfo *		PBufferRetryInfo;

/*
 *	These are the owner callback functions that a user object can send to an
 *	object whose public interface is unknown to it.  The first one is sent to
 *	the controller when a user object detects the need to delete itself.  The
 *	rest are sent to an application interface object as part of communicating
 *	with the user application (the proper application interface object is
 *	identified to this class as one of its constructor parameters).
 *
 *	When an object instantiates a user object (or any other object that uses
 *	owner callbacks), it is accepting the responsibility of receiving and
 *	handling those callbacks.  For that reason, any object that issues owner
 *	callbacks will have those callbacks defined as part of the interface file
 *	(since they really are part of a bi-directional interface).
 *
 *	Each owner callback function, along with a description of how its parameters
 *	are packed, is described in the following section.
 */

/*
 *	This macro is used to pack callback parameters into a single long word
 *	for delivery to the user application.
 */
#define PACK_PARAMETER(l,h)	((ULong) (((UShort) (l)) | \
							(((ULong) ((UShort) (h))) << 16)))

/*
 *	TIMER_PROCEDURE_TIMEOUT
 *		This macro specifies the granularity, in milliseconds, of any timer
 *		which may be created to recheck resource levels following a call to
 *		MCSSendDataRequest or MCSUniformSendDataRequest which returned
 *		MCS_TRANSMIT_BUFFER_FULL.
 *	CLASS_NAME_LENGTH
 *		The class name of the window class for all User-related windows.  These
 *		are the client windows that receive messages related to MCS indications and
 *		confirms that have to be delivered to the client apps.
 */
#define TIMER_PROCEDURE_TIMEOUT			300
#define	CLASS_NAME_LENGTH				35

/*
 *	This is the function signature of the timer procedure.  Timer messages will
 *	be routed to this function as a result of timer events which have been set
 *	up to recheck resource levels.  This would happen following a call to either
 *	SendData or GetBuffer call which resulted in a return
 *	value of MCS_TRANSMIT_BUFFER_FULL.
 */
Void CALLBACK TimerProc (HWND, UINT, UINT, DWORD);

/*	Client window procedure declarations
 *
 *	UserWindowProc
 *		Declaration of the window procedure used to deliver all MCS messages
 *		to MCS apps (clients).  The MCS main thread sends msgs to a client
 *		window with this window procedure.  The window procedure is then
 *		responsible to deliver the callback to the MCS client.
 */
LRESULT CALLBACK	UserWindowProc (HWND, UINT, WPARAM, LPARAM);

// Data packet queue
class CDataPktQueue : public CQueue
{
    DEFINE_CQUEUE(CDataPktQueue, PDataPacket)
};

// timer user object list
class CTimerUserList2 : public CList2
{
    DEFINE_CLIST2(CTimerUserList2, PUser, UINT_PTR) // timerID
};

// memory and buffer list
class CMemoryBufferList2 : public CList2
{
    DEFINE_CLIST2(CMemoryBufferList2, PMemory, LPVOID)
};

/*
 *	This is the actual class definition for the User class.  It inherits from
 *	CommandTarget (which in turn inherits from Object).  It has only one
 *	constructor, which tells the newly created object who it is, who the
 *	controller is, and who the proper application interface object is.  It also
 *	has a destructor, to clean up after itself.  Most importantly, it has
 *	one public member function for each MCS command that it must handle.
 */
class User: public CAttachment, public CRefCount, public IMCSSap
{
	friend Void CALLBACK TimerProc (HWND, UINT, UINT, DWORD);
	friend LRESULT CALLBACK UserWindowProc (HWND, UINT, WPARAM, LPARAM);
	public:
						User (PDomain, PMCSError);
		virtual			~User ();

		static BOOL		InitializeClass (void);
		static void		CleanupClass (void);

		/*	-------  IMCSSap interface --------	*/
		MCSAPI		 	ReleaseInterface(void);

		MCSAPI			GetBuffer (UINT, PVoid *);
		MCSAPI_(void)	FreeBuffer (PVoid);
		MCSAPI			ChannelJoin (ChannelID);
		MCSAPI			ChannelLeave (ChannelID);
		MCSAPI			ChannelConvene ();
		MCSAPI			ChannelDisband (ChannelID);
		MCSAPI			ChannelAdmit (ChannelID, PUserID, UINT);
		MCSAPI			SendData (DataRequestType, ChannelID, Priority, unsigned char *, ULong, SendDataFlags);
		MCSAPI			TokenGrab (TokenID);
		MCSAPI			TokenInhibit (TokenID);
		MCSAPI			TokenGive (TokenID, UserID);
		MCSAPI			TokenGiveResponse (TokenID, Result);
		MCSAPI			TokenPlease (TokenID);
		MCSAPI			TokenRelease (TokenID);
		MCSAPI			TokenTest (TokenID);
				
#ifdef USE_CHANNEL_EXPEL_REQUEST
		MCSError		MCSChannelExpelRequest (ChannelID, PMemory, UINT);
#endif // USE_CHANNEL_EXPEL_REQUEST

				void	SetDomainParameters (PDomainParameters);
        virtual void    PlumbDomainIndication(ULONG height_limit) { };
		virtual	void	PurgeChannelsIndication (CUidList *, CChannelIDList *);
        virtual void    PurgeTokensIndication(PDomain, CTokenIDList *) { };
		virtual void	DisconnectProviderUltimatum (Reason);
		virtual	void	AttachUserConfirm (Result, UserID);
		virtual	void	DetachUserIndication (Reason, CUidList *);
		virtual	void	ChannelJoinConfirm (Result, UserID, ChannelID, ChannelID);
				void	ChannelLeaveIndication (Reason, ChannelID);
		virtual	void	ChannelConveneConfirm (Result, UserID, ChannelID);
		virtual	void	ChannelDisbandIndication (ChannelID);
		virtual	void	ChannelAdmitIndication (UserID, ChannelID, CUidList *);
		virtual	void	ChannelExpelIndication (ChannelID, CUidList *);
		virtual	void	SendDataIndication (UINT, PDataPacket);
		virtual	void	TokenGrabConfirm (Result, UserID, TokenID, TokenStatus);
		virtual	void	TokenInhibitConfirm (Result, UserID, TokenID, TokenStatus);
		virtual	void	TokenGiveIndication (PTokenGiveRecord);
		virtual	void	TokenGiveConfirm (Result, UserID, TokenID, TokenStatus);
		virtual	void	TokenPleaseIndication (UserID, TokenID);
		        void	TokenReleaseIndication (Reason, TokenID);
		virtual	void	TokenReleaseConfirm (Result, UserID, TokenID, TokenStatus);
		virtual	void	TokenTestConfirm (UserID, TokenID, TokenStatus);
		virtual	void	MergeDomainIndication (MergeStatus);
				void	RegisterUserAttachment (MCSCallBack, PVoid, UINT);
				void	IssueDataIndication (UINT, PDataPacket);


	private:
		MCSError		ValidateUserRequest ();
		void			CreateRetryTimer (ULong);
		MCSError		ChannelJLCD (int, ChannelID);
		void			ChannelConfInd (UINT, ChannelID, UINT);
		MCSError		TokenGIRPT (int, TokenID);
		void			TokenConfInd (UINT, TokenID, UINT);
		void			PurgeMessageQueue ();

	// Static member variables
	static CTimerUserList2 *s_pTimerUserList2;
	static HINSTANCE		s_hInstance;
	
		PDomain				m_pDomain;
		UserID				User_ID;
		UserID				m_originalUser_ID;
		BOOL				Merge_In_Progress;
		BOOL				Deletion_Pending;
		ULong				Maximum_User_Data_Length;
		HWND				m_hWnd;

		MCSCallBack			m_MCSCallback;
		PVoid				m_UserDefined;
		BOOL				m_fDisconnectInDataLoss;
		BOOL				m_fFreeDataIndBuffer;
		CDataPktQueue		m_DataPktQueue;
		CDataPktQueue		m_PostMsgPendingQueue;
		CMemoryBufferList2	m_DataIndMemoryBuf2;
		PBufferRetryInfo	m_BufferRetryInfo;
};

/*
 *	User (PCommandTarget		top_provider)
 *
 *	Functional Description:
 *		This is the constructor for the user object.  Its primary purpose is
 *		to "insert" itself into the layered structure built by the controller.
 *		To do this it must register itself with the objects above and below it.
 *
 *		It first registers itself with the application interface object
 *		identified as one of the parameters.  This assures that any traffic
 *		from the application will get to this object correctly.
 *
 *		It then issues an attach user request to the domain object identified
 *		by another of the parameters.  This informs the domain of the users
 *		presence and also kicks off the process of attaching to that domain.
 *		Note that the object is not really attached to the domain until it
 *		receives a successful attach user confirm.
 *
 *	Formal Parameters:
 *		top_provider (i)
 *			This is a pointer to the domain object to which this user should
 *			attach.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~User ()
 *
 *	Functional Description:
 *		This is the destructor for the user class.  It detaches itself from the
 *		objects above and below it, and frees any outstanding resources that
 *		it may holding in conjunction with unsent user messages.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	DetachUser ()
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.  It will also cause the user object to destroy itself.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	ChannelJoin (
 *						ChannelID			channel_id)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		channel_id (i)
 *			This is the channel that the user application wishes to join.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	ChannelLeave (
 *						ChannelID			channel_id)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		channel_id (i)
 *			This is the channel that the user application wishes to leave.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	ChannelConvene ()
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	ChannelDisband (
 *						ChannelID			channel_id)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		channel_id (i)
 *			This is the channel that the user wishes to disband.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	ChannelAdmit (
 *						ChannelID			channel_id,
 *						PUserID				user_id_list,
 *						UINT				user_id_count)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		channel_id (i)
 *			This is the private channel for which the user wishes to expand
 *			the authorized user list.
 *		user_id_list (i)
 *			This is an array containing the user IDs of the users to be added
 *			to the authorized user list.
 *		user_id_count (i)
 *			This is the number of user IDs in the above array.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	ChannelExpel (
 *						ChannelID			channel_id,
 *						PUserID				user_id_list,
 *						UINT				user_id_count)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		channel_id (i)
 *			This is the private channel for which the user wishes to shrink
 *			the authorized user list.
 *		user_id_list (i)
 *			This is an array containing the user IDs of the users to be removed
 *			from the authorized user list.
 *		user_id_count (i)
 *			This is the number of user IDs in the above array.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	SendData (
 *						ChannelID			channel_id,
 *						Priority			priority,
 *						PUChar				user_data,
 *						ULong				user_data_length)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		channel_id (i)
 *			This is the channel that the user application wishes to transmit
 *			data on.
 *		priority (i)
 *			This is the priority at which the data is to be transmitted.
 *		user_data (i)
 *			This is the address of the data to be transmitted.
 *		user_data_length (i)
 *			This is the length of the data to be transmitted.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request has failed because the required memory could not be
 *			allocated.  It is the responsibility of the user application to
 *			repeat the request at a later time.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	MCSError	TokenGrab (
 *						TokenID				token_id)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		token_id (i)
 *			This is the token the user application wishes to grab.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_INVALID_PARAMETER
 *			The user attempted to perform an operation on token 0, which is not
 *			a valid token.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	TokenInhibit (
 *						TokenID				token_id)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		token_id (i)
 *			This is the token the user application wishes to inhibit.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_INVALID_PARAMETER
 *			The user attempted to perform an operation on token 0, which is not
 *			a valid token.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	TokenGive (
 *						TokenID				token_id,
 *						UserID				receiver_id)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		token_id (i)
 *			This is the token the user application wishes to give away.
 *		receiver_id (i)
 *			This is the ID of the user to receive the token.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_INVALID_PARAMETER
 *			The user attempted to perform an operation on token 0, which is not
 *			a valid token.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	TokenGiveResponse (
 *						TokenID				token_id,
 *						Result				result)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		token_id (i)
 *			This is the token that the user application is either accepting or
 *			rejecting in response to a previous give indication from another
 *			user.
 *		result (i)
 *			This parameter specifies whether or not the token was accepted.
 *			Success indicates acceptance while anything else indicates that the
 *			token was not accepted.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_INVALID_PARAMETER
 *			The user attempted to perform an operation on token 0, which is not
 *			a valid token.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	TokenPlease (
 *						TokenID				token_id)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		token_id (i)
 *			This is the token the user application wishes to ask for.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_INVALID_PARAMETER
 *			The user attempted to perform an operation on token 0, which is not
 *			a valid token.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	TokenRelease (
 *						TokenID				token_id)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		token_id (i)
 *			This is the token the user application wishes to release.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_INVALID_PARAMETER
 *			The user attempted to perform an operation on token 0, which is not
 *			a valid token.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	TokenTest(
 *						TokenID				token_id)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		token_id (i)
 *			This is the token the user application wishes to test the state of.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_INVALID_PARAMETER
 *			The user attempted to perform an operation on token 0, which is not
 *			a valid token.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	SetDomainParameters (
 *					PDomainParameters	domain_parameters)
 *
 *	Functional Description:
 *		This member function is called whenever the domain parameters change
 *		as the result of accepting a first connection.  It informs the user
 *		object of a change in the maximum PDU size, which is used when creating
 *		outbound data PDUs.
 *
 *	Formal Parameters:
 *		domain_parameters (i)
 *			Pointer to a structure that contains the current domain parameters
 *			(those that are in use).
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		PlumbDomainIndication (
 *						PCommandTarget		originator,
 *						ULong				height_limit)
 *
 *	Functional Description:
 *		This command is issued by the domain object during a plumb domain
 *		operation.  This is not relevant to user objects, and should be ignored.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		height_limit (i)
 *			This is height value passed through during the plumb operation.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		PurgeChannelsIndication (
 *						PCommandTarget		originator,
 *						CUidList           *purge_user_list,
 *						CChannelIDList     *purge_channel_list)
 *
 *	Functional Description:
 *		This command is issued by the domain object when purging channels
 *		from the lower domain during a domain merge operation.
 *
 *		The user object will issue one MCS_DETACH_USER_INDICATION object for
 *		each user in the user list.  Furthermore, if the user objects finds
 *		its own user ID in the list, it will destroy itself.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		purge_user_list (i)
 *			This is a list of user IDs that are to be purged from the lower
 *			domain.
 *		purge_channel_list (i)
 *			This is a list of channel IDs that are to be purged from the lower
 *			domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	PurgeTokensIndication (
 *					PCommandTarget		originator,
 *					CTokenIDList       *token_id_list)
 *
 *	Functional Description:
 *		This command is issued by the domain object when purging tokens from
 *		the lower domain during a domain merge operation.  IT is not relevant
 *		to a user object, and is therefore ignored.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		token_id (i)
 *			This is the ID of the token that is being purged.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	DisconnectProviderUltimatum (
 *					PCommandTarget		originator,
 *					Reason				reason)
 *
 *	Functional Description:
 *		This command is issued by the domain object when it is necessary to
 *		force a user from the domain.  This usually happens in response to
 *		the purging of an entire domain (either this user was in the bottom
 *		of a disconnected domain or the domain was deleted locally by user
 *		request).
 *
 *		If the user was already attached to the domain, this will result in a
 *		DETACH_USER_INDICATION with the local user ID.  Otherwise this will
 *		result is an ATTACH_USER_CONFIRM with a result of UNSPECIFIED_FAILURE.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		reason (i)
 *			This is the reason parameter to be issued to the local user
 *			application.  See "mcatmcs.h" for a complete list of possible reaons.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	AttachUserConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator)
 *
 *	Functional Description:
 *		This command is issued by the domain object in response to the
 *		attach user request issued by this object during construction.  If the
 *		result is successful, then this user is now attached and may request
 *		MCS services through this attachment.
 *
 *		An ATTACH_USER_CONFIRM will be issued to the user application.  If the
 *		result is not successful, this object will delete itself.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		result (i)
 *			This is the result of the attach request.
 *		uidInitiator (i)
 *			If the result was successful, this is the new user ID associated
 *			with this attachment.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	DetachUserIndication (
 *					PCommandTarget		originator,
 *					Reason				reason,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command is issued by the domain object when one or more users leave
 *		the domain.
 *
 *		An MCS_DETACH_USER_INDICATION is issued to the user application for each
 *		user in the list.  Furthermore, if the user finds its own ID in the
 *		list, then it will destroy itself.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		reason (i)
 *			This is the reason for the detachment.  Possible values are listed
 *			in "mcatmcs.h".
 *		user_id_list (i)
 *			This is a list user IDs of the users that are leaving.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ChannelJoinConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					ChannelID			requested_id,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command is issued by the domain object in response to a previous
 *		channel join request.
 *
 *		A CHANNEL_JOIN_CONFIRM is issued to the user application.  Note that a
 *		user is not really considered to be joined to a channel until a
 *		successful confirm is received.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		result (i)
 *			This is the result from the join request.  If successful, then the
 *			user is now joined to the channel.
 *		uidInitiator (i)
 *			This is the user ID of the requestor.  It will be the same as the
 *			local user ID (or else this command would not have gotten here).
 *		requested_id (i)
 *			This is the ID of the channel that the user originally requested
 *			to join.  This will differ from the ID of the channel actually
 *			joined only if this ID is 0 (which identifies a request to join an
 *			assigned channel).
 *		channel_id (i)
 *			This is the channel that is now joined.  This is important for
 *			two reasons.  First, it is possible for a user to have more than
 *			one outstanding join request, in which case this parameter
 *			identifies which channel this confirm is for.  Second, if the
 *			request is for channel 0 (zero), then this parameter identifies
 *			which assigned channel the user has successfully joined.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ChannelLeaveIndication (
 *					PCommandTarget		originator,
 *					Reason				reason,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command is issued by the domain object when a user loses its right
 *		to use a channel.
 *
 *		A CHANNEL_LEAVE_INDICATION is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		reason (i)
 *			This is the reason for the lost channel.  Possible values are listed
 *			in "mcatmcs.h".
 *		channel (i)
 *			This is the channel that the user can no longer use.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelConveneConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command is issued by the domain object in response to a previous
 *		channel convene request.
 *
 *		A CHANNEL_CONVENE_CONFIRM is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		result (i)
 *			This is the result from the convene request.  If successful, then
 *			a private channel has been created, with this user as the manager.
 *		uidInitiator (i)
 *			This is the user ID of the requestor.  It will be the same as the
 *			local user ID (or else this command would not have gotten here).
 *		channel_id (i)
 *			This is the channel ID for the newly created private channel.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelDisbandIndication (
 *					PCommandTarget		originator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command is issued by the domain object to the manager of a private
 *		channel when MCS determines the need to disband the channel.  This will
 *		usually be done only if the channel is purged during a domain merger.
 *
 *		A CHANNEL_DISBAND_INDICATION is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		channel_id (i)
 *			This is the channel ID of the private channel that is being
 *			disbanded.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelAdmitIndication (
 *						PCommandTarget		originator,
 *						UserID				uidInitiator,
 *						ChannelID			channel_id,
 *						CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command is issued by the domain object when a user is admitted to
 *		a private channel by the manager of that channel.  It informs the user
 *		that the channel can be used.
 *
 *		A CHANNEL_ADMIT_INDICATION is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		uidInitiator (i)
 *			This is the user ID of the private channel manager.
 *		channel_id (i)
 *			This is the channel ID of the private channel to which the user has
 *			been admitted.
 *		user_id_list (i)
 *			This is a container holding the IDs of the users that have been
 *			admitted.  By the time this reaches a particular user, that user
 *			should be the only one in the list (since the list is broken apart
 *			and forwarded in the direction of the contained users, recursively).
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelExpelIndication (
 *						PCommandTarget		originator,
 *						ChannelID			channel_id,
 *						CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command is issued by the domain object when a user is expelled from
 *		a private channel by the manager of that channel.  It informs the user
 *		that the channel can no longer be used.
 *
 *		A CHANNEL_EXPEL_INDICATION is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		channel_id (i)
 *			This is the channel ID of the private channel from which the user
 *			has been expelled.
 *		user_id_list (i)
 *			This is a container holding the IDs of the users that have been
 *			expelled.  By the time this reaches a particular user, that user
 *			should be the only one in the list (since the list is broken apart
 *			and forwarded in the direction of the contained users, recursively).
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	SendDataIndication (
 *					PCommandTarget		originator,
 *					UINT				message_type,
 *					PDataPacket			data_packet)
 *
 *	Functional Description:
 *		This command is issued by the domain object when non-uniform data
 *		data is received on a channel to which this user is joined.
 *
 *		A SEND_DATA_INDICATION is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		message_type (i)
 *			normal or uniform send data indication
 *		data_packet (i)
 *			This is a pointer to a DataPacket object containing the channel
 *			ID, the User ID of the data sender, segmentation flags, priority of
 *			the data packet and a pointer to the packet to be sent.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGrabConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command is issued by the domain object in response to a previous
 *		token grab request.
 *
 *		A TOKEN_GRAB_CONFIRM is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		result (i)
 *			This is the result of the grab request.  If successful, the user
 *			now exclusively owns the token.
 *		uidInitiator (i)
 *			This is the user ID of the user that made the grab request.  This
 *			will be the same as the local user ID (or else this command would
 *			not have gotten here).
 *		token_id (i)
 *			This is the ID of the token which the grab confirm is for.  It
 *			is possible to have more than one outstanding grab request, so this
 *			parameter tells the user application which request has been
 *			satisfied by this confirm.
 *		token_status (i)
 *			This is the status of the token at the time the Top Provider
 *			serviced the grab request.  This will be SELF_GRABBED if the grab
 *			request was successful.  It will be something else if not (see
 *			"mcatmcs.h" for a list of possible token status values).
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenInhibitConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command is issued by the domain object in response to a previous
 *		token inhibit request.
 *
 *		A TOKEN_INHIBIT_CONFIRM is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		result (i)
 *			This is the result of the inhibit request.  If successful, the user
 *			now non-exclusively owns the token.
 *		uidInitiator (i)
 *			This is the user ID of the user that made the inhibit request.  This
 *			will be the same as the local user ID (or else this command would
 *			not have gotten here).
 *		token_id (i)
 *			This is the ID of the token which the inihibit confirm is for.
 *			It is possible to have more than one outstanding inihibit request,
 *			so this parameter tells the user application which request has been
 *			satisfied by this confirm.
 *		token_status (i)
 *			This is the status of the token at the time the Top Provider
 *			serviced the inhibit request.  This will be SELF_INHIBITED if the
 *			inhibit request was successful.  It will be something else if not
 *			(see "mcatmcs.h" for a list of possible token status values).
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		TokenGiveIndication (
 *						PCommandTarget		originator,
 *						PTokenGiveRecord	pTokenGiveRec)
 *
 *	Functional Description:
 *		This command is issued by the domain object in response to a remote
 *		token give request (with the local user listed as the desired receiver).
 *
 *		A TOKEN_GIVE_INDICATION is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		pTokenGiveRec (i)
 *			This is the address of a structure containing the following information:
 *			The ID of the user attempting to give away the token.
 *			The ID of the token being given.
 *			The ID of the user that the token is being given to.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		TokenGiveConfirm (
 *						PCommandTarget		originator,
 *						Result				result,
 *						UserID				uidInitiator,
 *						TokenID				token_id,
 *						TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command is issued by the domain object in response to a previous
 *		token give request.
 *
 *		A TOKEN_GIVE_CONFIRM is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		result (i)
 *			This is the result of the give request.  If successful, the user
 *			no longer owns the token.
 *		uidInitiator (i)
 *			This is the user ID of the user that made the give request.  This
 *			will be the same as the local user ID (or else this command would
 *			not have gotten here).
 *		token_id (i)
 *			This is the ID of the token which the give confirm is for.
 *		token_status (i)
 *			This is the status of the token at the time the Top Provider
 *			serviced the give request.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		TokenPleaseIndication (
 *						PCommandTarget		originator,
 *						UserID				uidInitiator,
 *						TokenID				token_id)
 *
 *	Functional Description:
 *		This command is issued by the domain object to all owners of a token
 *		when a user issues a token please request for that token.
 *
 *		A TOKEN_PLEASE_INDICATION is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		uidInitiator (i)
 *			This is the user ID of the user that made the please request.
 *		token_id (i)
 *			This is the ID of the token which the please request is for.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenReleaseIndication (
 *					PCommandTarget		originator,
 *					Reason				reason,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command is issued by the domain object when a token is taken
 *		away from its current owner.
 *
 *		A TOKEN_RELEASE_INDICATION is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		reason (i)
 *			This is the reason the token is being taken away.
 *		token_id (i)
 *			This is the ID of the token that is being taken away.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenReleaseConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command is issued by the domain object in response to a previous
 *		token release request.
 *
 *		A TOKEN_RELEASE_CONFIRM is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		result (i)
 *			This is the result of the release request.  If successful, the user
 *			no longer owns the token (if it ever did)
 *		uidInitiator (i)
 *			This is the user ID of the user that made the release request.  This
 *			will be the same as the local user ID (or else this command would
 *			not have gotten here).
 *		token_id (i)
 *			This is the ID of the token which the release confirm is for.
 *			It is possible to have more than one outstanding release request,
 *			so this parameter tells the user application which request has been
 *			satisfied by this confirm.
 *		token_status (i)
 *			This is the status of the token at the time the Top Provider
 *			serviced the release request.  This will be NOT_IN_USE or
 *			OTHER_INHIBITED if the release request was successful.  It will be
 *			something else if not (see "mcatmcs.h" for a list of possible token
 *			status values).
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenTestConfirm (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command is issued by the domain object in response to a previous
 *		token test request.
 *
 *		A TOKEN_TEST_CONFIRM is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		uidInitiator (i)
 *			This is the user ID of the user that made the test request.  This
 *			will be the same as the local user ID (or else this command would
 *			not have gotten here).
 *		token_id (i)
 *			This is the ID of the token which the test confirm is for.
 *			It is possible to have more than one outstanding test request,
 *			so this parameter tells the user application which request has been
 *			satisfied by this confirm.
 *		token_status (i)
 *			This is the status of the token at the time the Top Provider
 *			serviced the test request (see "mcatmcs.h" for a list of possible
 *			token status values).
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	MergeDomainIndication (
 *					PCommandTarget		originator,
 *					MergeStatus			merge_status)
 *
 *	Functional Description:
 *		This command is issued by a domain when it begins a merge operation.
 *		It is issued again when the merge operation is complete.
 *
 *		A MERGE_DOMAIN_INDICATION is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		merge_status (i)
 *			This is the current merge status.  It will indicate either that the
 *			merge operation is in progress, or that it is complete.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		FlushMessageQueue (
 *						Void)
 *
 *	Functional Description:
 *		This function is periodically called by the controller to allocate a
 *		time slice to the user object.  It is during this time slice that this
 *		object will issue its queued messages to the user application.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\arost.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_APP_ROSTER);
/*
 *	arost.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the Application Roster Class. This
 *		class maintains the application roster, builds roster update and
 *		refresh PDUs and manages the capabilities list which is part of the
 *		application roster.
 *
 *		This class makes use of a number of Rogue Wave lists to maintain the
 *		roster entries and the capabilities list.  The lists are organized in
 *		such a way that the heirarchy of the conference can be maintained.  This
 *		is important to perform the necessary operations required by the T.124
 *		specification.  In general, there is a main "Roster_Record_List" that
 *		maintains a list of "AppRosterRecords". The list is indexed by the
 *		GCC user ID where each record in the list holds a list of application
 *		records (or entities) at that node, a list of capabilities for each
 *		"entity" and a list of sub-nodes (the GCC user IDs of all the nodes
 *		below this one in the connection hierarchy).  The Roster_Record_List
 *		only holds entries for immediately connected nodes.
 *
 *		SEE INTERFACE FILE FOR A MORE DETAILED ABSTRACT
 *
 *	Private Instance Variables:
 *		m_pAppRosterMgr
 *			Pointer to the object that will receive all owner callbacks.
 *		m_cbDataMemory
 *			This is the number of bytes required to hold the data associated
 *			with a roster update message.  This is calculated on a lock.
 *		m_fTopProvider
 *			Flag indicating if the node where this roster lives is the top
 *			provider.
 *		m_fLocalRoster
 *			Flag indicating if the roster data is associated with a local
 *			roster (maintaining intermediate node data) or global roster (
 *			(maintaining roster data for the whole conference).
 *		m_pSessionKey
 *			Pointer to a session key object that holds the session key
 *			associated with this roster.
 *		m_nInstance
 *			The current instance of the roster.  This number will change
 *			whenever the roster is updated.
 *		m_fRosterHasChanged
 *			Flag indicating if the roster has changed since the last reset.
 *		m_fPeerEntitiesAdded
 *			Flag indicating if any APE records have been added to the
 *			application roster since the last reset.
 *		m_fPeerEntitiesRemoved
 *			Flag indicating if any APE records have been deleted from the
 *			application roster since the last reset.
 *		m_fCapabilitiesHaveChanged
 *			Flag indicating if the capabilities has changed since the last
 *			reset.
 *		m_NodeRecordList2
 *			List which contains all the application roster's node records.
 *		m_CollapsedCapListForAllNodes
 *			List which contains all the application roster's collapsed
 *			capabilities.
 *		m_fMaintainPduBuffer
 *			Flag indicating if it is necessary for this roster object to
 *			maintain internal PDU data.  Won't be necessary for global rosters
 *			at subordinate nodes.
 *		m_fPduIsFlushed
 *			Flag indicating if the PDU that currently exists has been flushed.
 *		m_SetOfAppInfo
 *			Pointer to internal PDU data.
 *		m_pSetOfAppRecordUpdates
 *			This instance variable keeps up with the current record update so
 *			that it will not be necessary to search the entire list updates
 *			each a new update is added to the internal PDU.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */

#include "arost.h"
#include "arostmgr.h"
#include "clists.h"


/*
**	The maximum length the application data for a non-collapsed capablity
**	can be.
*/
#define	MAXIMUM_APPLICATION_DATA_LENGTH				255

/*
 *	AppRosterRecord	()
 *
 *	Public Function Description
 *		Constructor definition to instantiate the hash list dictionaries that
 *		are used in an AppRosterRecord.  This constructor is needed to allow
 *		the AppRosterRecord structure to be directly instantiated with hash
 *		list.
 */
APP_NODE_RECORD::APP_NODE_RECORD(void) :
	AppRecordList(DESIRED_MAX_APP_RECORDS),
	ListOfAppCapItemList2(DESIRED_MAX_CAP_LISTS),
	SubNodeList2(DESIRED_MAX_NODES)
{}


/*
 *	CAppRoster	()
 *
 *	Public Function Description
 *	When pGccSessKey is not NULL
 *		This constructor is used to create an empty application roster. Note
 *		that the session key for the roster must be passed in to the
 *		constructor.
 *
 *	When pSessKey is not NULL
 *		This constructor builds a roster based on an indication pdu.
 *		Application Roster objects may exist at nodes which do not have
 *		applications to perform the necessary operations required by T.124
 */
CAppRoster::CAppRoster (	
			PGCCSessionKey				pGccSessKey,// create an empty app roster
			PSessionKey					pPduSessKey,// build an app roster based on an indication pdu
			CAppRosterMgr				*pAppRosterMgr,
			BOOL						fTopProvider,
			BOOL						fLocalRoster,
			BOOL						fMaintainPduBuffer,
			PGCCError					pRetCode)
:
    CRefCount(MAKE_STAMP_ID('A','R','s','t')),
	m_nInstance(0),
	m_pAppRosterMgr(pAppRosterMgr),
	m_cbDataMemory(0),
	m_fTopProvider(fTopProvider),
	m_fLocalRoster(fLocalRoster),
	m_pSessionKey(NULL),
	m_fRosterHasChanged(FALSE),
	m_fPeerEntitiesAdded(FALSE),
	m_fPeerEntitiesRemoved(FALSE),
	m_fCapabilitiesHaveChanged(FALSE),
	m_NodeRecordList2(DESIRED_MAX_NODES),
	m_fMaintainPduBuffer(fMaintainPduBuffer),
	m_fPduIsFlushed(FALSE),
	m_pSetOfAppRecordUpdates(NULL)
{
	DebugEntry(CAppRoster::CAppRoster);

	GCCError rc = GCC_NO_ERROR;

	ZeroMemory(&m_SetOfAppInfo, sizeof(m_SetOfAppInfo));

	/*
	**	Here we store the session key of the roster.
	*/
	if (NULL != pGccSessKey)
	{
		ASSERT(NULL == pPduSessKey);
		DBG_SAVE_FILE_LINE
		m_pSessionKey = new CSessKeyContainer(pGccSessKey, &rc);
	}
	else
	if (NULL != pPduSessKey)
	{
		DBG_SAVE_FILE_LINE
		m_pSessionKey = new CSessKeyContainer(pPduSessKey, &rc);
	}
	else
	{
		ERROR_OUT(("CAppRoster::CAppRoster: invalid session key"));
		rc = GCC_BAD_SESSION_KEY;
		goto MyExit;
	}

	if (NULL == m_pSessionKey || GCC_NO_ERROR != rc)
	{
		ERROR_OUT(("CAppRoster::CAppRoster: can't create session key"));
		rc = GCC_ALLOCATION_FAILURE;
		// we do the cleanup in the destructor
		goto MyExit;
	}

	//	Initialize the PDU structure to be no change.
	m_SetOfAppInfo.value.application_record_list.choice = APPLICATION_NO_CHANGE_CHOSEN;
	m_SetOfAppInfo.value.application_capabilities_list.choice = CAPABILITY_NO_CHANGE_CHOSEN;

	/*
	**	Here we go ahead and set up the session key portion of the
	**	PDU so we don't have to worry about it later.
	*/
	if (m_fMaintainPduBuffer)
	{
		rc = m_pSessionKey->GetSessionKeyDataPDU(&m_SetOfAppInfo.value.session_key);
	}

	ASSERT(GCC_NO_ERROR == rc);

MyExit:

	DebugExitINT(CAppRoster:;CAppRoster, rc);

	*pRetCode = rc;
}


/*
 *	~CAppRoster	()
 *
 *	Public Function Description:
 *		The destructor for the CAppRoster class is used to clean up
 *		any memory allocated during the life of the object.
 */
CAppRoster::~CAppRoster(void)
{
	/*
	 * Free up all memory associated with the roster record list.
	 */
	ClearNodeRecordList();

	//	Clear the Collapsed Capabilities List.
	m_CollapsedCapListForAllNodes.DeleteList();

	/*
	 * Free up any outstanding PDU data.
	 */
	if (m_fMaintainPduBuffer)
	{
		FreeRosterUpdateIndicationPDU();
	}

	/*
	 * Free any memory associated with the session key..
	 */
	if (NULL != m_pSessionKey)
	{
	    m_pSessionKey->Release();
	}
}


/*
 * Utilities that operate on roster update PDU strucutures.
 */

/*
 *	GCCError	FlushRosterUpdateIndicationPDU ()
 *
 *	Public Function Description
 *		This routine is used to access any PDU data that might currently be
 *		queued inside the application roster.  PDU data is queued whenever
 *		a request is made to the application roster that affects its
 *		internal information base.
 */
void CAppRoster::FlushRosterUpdateIndicationPDU(PSetOfApplicationInformation *pSetOfAppInfo)
{
	DebugEntry(CAppRoster::FlushRosterUpdateIndicationPDU);

	/*
	**	If this roster has already been flushed we will NOT allow the same
	**	PDU to be flushed again.  Instead we delete the previously flushed
	**	PDU and set the flag back to unflushed.  If another flush comes in
	**	before a PDU is built NULL will be returned in the application
	**	information pointer.
	*/	
	if (m_fPduIsFlushed)
	{
		FreeRosterUpdateIndicationPDU();
		m_fPduIsFlushed = FALSE;
	}

	if ((m_SetOfAppInfo.value.application_record_list.choice != APPLICATION_NO_CHANGE_CHOSEN) ||
		(m_SetOfAppInfo.value.application_capabilities_list.choice != CAPABILITY_NO_CHANGE_CHOSEN))
	{
		if (m_SetOfAppInfo.value.application_record_list.choice == APPLICATION_NO_CHANGE_CHOSEN)
		{
			TRACE_OUT(("CAppRoster::FlushRosterUpdateIndicationPDU:"
						"Sending APPLICATION_NO_CHANGE_CHOSEN PDU"));
		}

		/*
		**	This section of the code sets up all the variables that don't
		**	pertain to the record list or the caps list.  Note that the
		**	session key PDU data was set up in the constructor.  Also note that
		**	the record list data and capabilities list data should be set up
		**	before this routine is called if there is any PDU traffic to issue.	
		*/
		m_SetOfAppInfo.next = NULL;
		m_SetOfAppInfo.value.roster_instance_number = (USHORT) m_nInstance;
		m_SetOfAppInfo.value.peer_entities_are_added = (ASN1bool_t)m_fPeerEntitiesAdded;
		m_SetOfAppInfo.value.peer_entities_are_removed = (ASN1bool_t)m_fPeerEntitiesRemoved;

		/*
		**	Here we set up the pointer to the whole PDU structure associated
		**	with this application roster.
		*/
		*pSetOfAppInfo = &m_SetOfAppInfo;

		/*
		**	Setting this to true will cause the PDU data to be freed up the
		**	next time the roster object is entered insuring that new PDU
		**	data will be created.
		*/
		m_fPduIsFlushed = TRUE;
	}
	else
	{
		*pSetOfAppInfo = NULL;
	}
}


/*
 *	GCCError	BuildFullRefreshPDU ()
 *
 *	Public Function Description
 *		This routine is responsible for generating a full application roster
 *		refresh PDU.
 */
GCCError CAppRoster::BuildFullRefreshPDU(void)
{
	GCCError	rc;

	DebugEntry(CAppRoster::BuildFullRefreshPDU);

	/*
	**	Free up the old PDU data here if it is being maintained and the
	**	PDU has been flushed.  Note that we also set the PDU is flushed boolean
	**	back to FALSE so that the new PDU will be maintained until it is
	**	flushed.
	*/
	if (m_fPduIsFlushed)
	{
		FreeRosterUpdateIndicationPDU ();
		m_fPduIsFlushed = FALSE;
	}

	rc = BuildApplicationRecordListPDU (APP_FULL_REFRESH, 0, 0);
	if (rc == GCC_NO_ERROR)
	{
		BuildSetOfCapabilityRefreshesPDU ();
	}

	return rc;
}


/*
 *	GCCError	BuildApplicationRecordListPDU ()
 *
 *	Private Function Description
 *		This routine creates an application roster update indication
 *		PDU based on the passed in parameters. Memory used after this
 *		routine is called is still owned by this object and will be
 *		freed the next time this objects internal information base is
 *		modified.
 *
 *	Formal Parameters:
 *		update_type		-	What type of update are we building.
 *		user_id			-	node id of record to update.
 *		entity_id		-	entity id of record to update.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_INVALID_PARAMETER	-	Parameter passed in is invalid.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
GCCError CAppRoster::BuildApplicationRecordListPDU (
						APP_ROSTER_UPDATE_TYPE			update_type,
						UserID							user_id,
						EntityID						entity_id)
{
	GCCError	rc = GCC_NO_ERROR;

	DebugEntry(CAppRoster::BuildApplicationRecordListPDU);

	if (m_fMaintainPduBuffer)
	{
		/*
		**	Note here that the top provider node always sends a full refresh
		**	PDU so there is no need to pay any attention to update type in
		**	this case.
		*/
		if ((update_type == APP_FULL_REFRESH) || m_fTopProvider)
		{
			/*
			**	First check to see if a refresh was already processed since the
			**	last PDU was flushed.  If so we must free up the last refresh in
			**	preperation for the new one built here.  Otherwise, if we have
			**	already started building an update this is not currently
			**	supported and is considered an error here.
			*/
			if (m_SetOfAppInfo.value.application_record_list.choice == APPLICATION_RECORD_REFRESH_CHOSEN)
			{
				FreeSetOfRefreshesPDU();
			}
			else
			if (m_SetOfAppInfo.value.application_record_list.choice == APPLICATION_RECORD_UPDATE_CHOSEN)
			{
				ERROR_OUT(("CAppRoster::BuildApplicationRecordListPDU:"
							"ASSERTION: building refresh when update exists"));
				return GCC_INVALID_PARAMETER;
			}

			//	This routine fills in the complete record list at this node.
			rc = BuildSetOfRefreshesPDU();
			if (rc == GCC_NO_ERROR)
			{
				m_SetOfAppInfo.value.application_record_list.choice = APPLICATION_RECORD_REFRESH_CHOSEN;
			}
		}
		else
		if (update_type != APP_NO_CHANGE)
		{
			/*
			**	Here if there has already been a refresh PDU built we flag this
			**	as an error since we do not support both types of application
			**	information at the same time.
			*/
			if (m_SetOfAppInfo.value.application_record_list.choice == APPLICATION_RECORD_REFRESH_CHOSEN)
			{
				ERROR_OUT(("CAppRoster::BuildApplicationRecordListPDU:"
							"ASSERTION: building update when refresh exists"));
				return GCC_INVALID_PARAMETER;
			}

			//	This routine fills in the specified update.
			rc = BuildSetOfUpdatesPDU(update_type, user_id, entity_id);
			if (rc == GCC_NO_ERROR)
			{
				/*
				**	If the first set of updates has not been used yet we
				**	initialize it here with the first update.
				*/
				if (m_SetOfAppInfo.value.application_record_list.choice == APPLICATION_NO_CHANGE_CHOSEN)
				{
					ASSERT(NULL != m_pSetOfAppRecordUpdates);
					m_SetOfAppInfo.value.application_record_list.u.application_record_update =
								m_pSetOfAppRecordUpdates;
					m_SetOfAppInfo.value.application_record_list.choice = APPLICATION_RECORD_UPDATE_CHOSEN;
				}
			}
		}
	}

	return rc;
}


/*
 *	GCCError	BuildSetOfRefreshesPDU	()
 *
 *	Private Function Description
 *		This member function fills in the PDU with the entire set of roster
 *		entries at this node.  This is typically called when the Top Provider is
 *		broadcasting a full refresh of the application roster.
 *
 *	Formal Parameters
 *		none
 *
 *	Return Value
 *		GCC_NO_ERROR - On Success
 *		GCC_ALLOCATION_FAILURE - On resource failure
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
GCCError CAppRoster::BuildSetOfRefreshesPDU(void)
{
	GCCError							rc = GCC_ALLOCATION_FAILURE;
	PSetOfApplicationRecordRefreshes	pNewAppRecordRefreshes;
	PSetOfApplicationRecordRefreshes	pOldAppRecordRefreshes = NULL;
	APP_NODE_RECORD						*lpAppNodeRecord;
	APP_RECORD  					    *lpAppRecData;
	CAppRecordList2						*lpAppRecDataList;
	UserID								uid, uid2;
	EntityID							eid;

	DebugEntry(CAppRoster::BuildSetOfRefreshesPDU);

	m_SetOfAppInfo.value.application_record_list.u.application_record_refresh = NULL;

	m_NodeRecordList2.Reset();
	while (NULL != (lpAppNodeRecord = m_NodeRecordList2.Iterate(&uid)))
	{
		/*
		**	First we iterate through this nodes application record list. This
		**	encodes all the records local to this node. After this, all the
		**	sub nodes within this roster record will be encoded.
		*/
		lpAppNodeRecord->AppRecordList.Reset();
		while (NULL != (lpAppRecData = lpAppNodeRecord->AppRecordList.Iterate(&eid)))
		{
			DBG_SAVE_FILE_LINE
			pNewAppRecordRefreshes = new SetOfApplicationRecordRefreshes;
			if (NULL == pNewAppRecordRefreshes)
			{
				goto MyExit;
			}

			if (m_SetOfAppInfo.value.application_record_list.u.application_record_refresh == NULL)
			{
				m_SetOfAppInfo.value.application_record_list.u.application_record_refresh = pNewAppRecordRefreshes;
			}
			else
			{
				pOldAppRecordRefreshes->next = pNewAppRecordRefreshes;
			}
	
			(pOldAppRecordRefreshes = pNewAppRecordRefreshes)->next = NULL;
			pNewAppRecordRefreshes->value.node_id = uid;
			pNewAppRecordRefreshes->value.entity_id = eid;

			//	Fill in the application record.
			rc = BuildApplicationRecordPDU(lpAppRecData,
	            			&pNewAppRecordRefreshes->value.application_record);
			if (GCC_NO_ERROR != rc)
			{
				goto MyExit;
			}
		}

		//	This section of the code copies the sub node records.
		lpAppNodeRecord->SubNodeList2.Reset();
		while (NULL != (lpAppRecDataList = lpAppNodeRecord->SubNodeList2.Iterate(&uid2)))
		{
			lpAppRecDataList->Reset();
			while (NULL != (lpAppRecData = lpAppRecDataList->Iterate(&eid)))
			{
				DBG_SAVE_FILE_LINE
				pNewAppRecordRefreshes = new SetOfApplicationRecordRefreshes;
				if (NULL == pNewAppRecordRefreshes)
				{
					goto MyExit;
				}

				/*
				**	We must again check for null because it is possible
				**	to have an application roster with sub node records
				**	but no application records.
				*/
				if (m_SetOfAppInfo.value.application_record_list.u.application_record_refresh == NULL)
				{
					m_SetOfAppInfo.value.application_record_list.u.application_record_refresh = pNewAppRecordRefreshes;
				}
				else
				{
					pOldAppRecordRefreshes->next = pNewAppRecordRefreshes;
				}
		
				(pOldAppRecordRefreshes = pNewAppRecordRefreshes)->next = NULL;
				pNewAppRecordRefreshes->value.node_id = uid2;
				pNewAppRecordRefreshes->value.entity_id = eid;

				//	Fill in the application record.
				rc = BuildApplicationRecordPDU (lpAppRecData,
	                	&pNewAppRecordRefreshes->value.application_record);
				if (GCC_NO_ERROR != rc)
				{
					goto MyExit;
				}
			}
		}
	}

	rc = GCC_NO_ERROR;

MyExit:

	return rc;
}


/*
 *	GCCError	BuildSetOfUpdatesPDU	()
 *
 *	Private Function Description
 *		This routine builds a single update based on the update type specified
 *		in the passed in parameter.
 *
 *	Formal Parameters
 *		update_type - 	(i)	Either APP_REPLACE_RECORD, APP_DELETE_RECORD, or
 *							APP_ADD_RECORD.
 *		node_id -		(i)	The node id of the update PDU record to build.
 *		entity_id 		(i) The entity id of the update PDU record to build.
 *
 *	Return Value
 *		GCC_NO_ERROR - On Success
 *		GCC_ALLOCATION_FAILURE - On resource failure
 *		GCC_NO_SUCH_APPLICATION - If the specified record doesn't exist
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
GCCError CAppRoster::BuildSetOfUpdatesPDU(
						APP_ROSTER_UPDATE_TYPE				update_type,
						UserID								node_id,
						EntityID							entity_id)
{
	GCCError					rc = GCC_NO_ERROR;
	CAppRecordList2				*pAppRecordList;
	APP_RECORD  			    *pAppRecord = NULL;
	APP_NODE_RECORD				*node_record;

	DebugEntry(CAppRoster::BuildSetOfUpdatesPDU);

	/*
	**	We must first determine the pointer to the application record
	**	specified by the passed in user id and entity_id. We only do
	**	this search if the update type is not APP_DELETE_RECORD.
	*/
	if (update_type != APP_DELETE_RECORD)
	{
		if (NULL != (node_record = m_NodeRecordList2.Find(node_id)))
		{
			//	Get a pointer to the application record from the entity id.
			pAppRecord = node_record->AppRecordList.Find(entity_id);
		}
		else
		{
			//	Here we iterate through the sub-node list looking for the record
			m_NodeRecordList2.Reset();
			while(NULL != (node_record = m_NodeRecordList2.Iterate()))
			{
				if (NULL != (pAppRecordList = node_record->SubNodeList2.Find(node_id)))
				{
					pAppRecord = pAppRecordList->Find(entity_id);
					break;
				}
			}
		}
	}

	/*
	**	Now if the application record was found or the update type is delete
	**	record we go ahead and encode the PDU here.
	*/
	if ((pAppRecord != NULL) || (update_type == APP_DELETE_RECORD))
	{
		/*
		**	Here the record update will be NULL if it is the first record
		**	update being encoded. Otherwise we must bump the record to the
		**	next set of updates.
		*/
		DBG_SAVE_FILE_LINE
		PSetOfApplicationRecordUpdates pUpdates = new SetOfApplicationRecordUpdates;
		if (NULL == pUpdates)
		{
			return GCC_ALLOCATION_FAILURE;
		}
		pUpdates->next = NULL;

		if (m_pSetOfAppRecordUpdates == NULL)
		{
			m_pSetOfAppRecordUpdates = pUpdates;
		}
		else
		{
		    //
			// LONCHANC: right now, append the new one.
			// but, can we prepend the new one???
			//
			PSetOfApplicationRecordUpdates p;
			for (p = m_pSetOfAppRecordUpdates; NULL != p->next; p = p->next)
				;
			p->next = pUpdates;
		}

		/*
		 * This routine only returns one record.
		 */
		pUpdates->value.node_id = node_id;
		pUpdates->value.entity_id = entity_id;

		switch (update_type)
		{
		case APP_ADD_RECORD:
			pUpdates->value.application_update.choice = APPLICATION_ADD_RECORD_CHOSEN;

			BuildApplicationRecordPDU(pAppRecord,
					&(pUpdates->value.application_update.u.application_add_record));
			break;
		case APP_REPLACE_RECORD:
			pUpdates->value.application_update.choice = APPLICATION_REPLACE_RECORD_CHOSEN;

			rc = BuildApplicationRecordPDU(pAppRecord,
					&(pUpdates->value.application_update.u.application_replace_record));
			break;
		default:
			/*
			 * The record does not have to be filled in for this case.
			 */
			pUpdates->value.application_update.choice = APPLICATION_REMOVE_RECORD_CHOSEN;
			break;
		}
	}
	else
	{
		WARNING_OUT(("CAppRoster::BuildSetOfUpdatesPDU: Assertion:"
					"No applicaton record found for PDU"));
		rc = GCC_NO_SUCH_APPLICATION;
	}

	return rc;
}


/*
 *	GCCError	BuildApplicationRecordPDU ()
 *
 *	Private Function Description
 *		This routine build a single application record for a PDU. A pointer to
 *		the record is passed in to the routine.
 *
 *	Formal Parameters
 *		application_record - 		(i)	Record to be encoded.
 *		application_record_pdu -	(i)	PDU to fill in.
 *
 *	Return Value
 *		GCC_NO_ERROR 			- On Success
 *		GCC_ALLOCATION_FAILURE	- A resource error occured.
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
GCCError CAppRoster::BuildApplicationRecordPDU(
							APP_RECORD  		    *pAppRecord,
							PApplicationRecord		pAppRecordPdu)
{
	GCCError	rc = GCC_NO_ERROR;

	DebugEntry(CAppRoster::BuildApplicationRecordPDU);

	pAppRecordPdu->bit_mask = 0;

	if (! pAppRecord->non_collapsed_caps_list.IsEmpty())
	{
		pAppRecordPdu->bit_mask |= NON_COLLAPSING_CAPABILITIES_PRESENT;
		
		rc = BuildSetOfNonCollapsingCapabilitiesPDU(
								&pAppRecordPdu->non_collapsing_capabilities,
								&pAppRecord->non_collapsed_caps_list);
		if (GCC_NO_ERROR != rc)
		{
			goto MyExit;
		}
	}

	//	Fill in the startup channel type if it is specified
	if (pAppRecord->startup_channel_type != MCS_NO_CHANNEL_TYPE_SPECIFIED)
	{
		pAppRecordPdu->bit_mask |= RECORD_STARTUP_CHANNEL_PRESENT;
		pAppRecordPdu->record_startup_channel = (ChannelType) pAppRecord->startup_channel_type;
	}

	//	Fill in the application user id if one is specified
	if (pAppRecord->application_user_id	!= 0)
	{
		pAppRecordPdu->bit_mask |= APPLICATION_USER_ID_PRESENT;
		pAppRecordPdu->application_user_id = pAppRecord->application_user_id;
	}

	//	Fill in the required fields
	pAppRecordPdu->application_is_active = (ASN1bool_t)pAppRecord->is_enrolled_actively;
	pAppRecordPdu->is_conducting_capable = (ASN1bool_t)pAppRecord->is_conducting_capable;

	ASSERT(GCC_NO_ERROR == rc);

MyExit:

	return rc;
}


/*
 *	GCCError	BuildSetOfCapabilityRefreshesPDU	()
 *
 *	Private Function Description
 *		This routine builds a PDU structure with the complete set of
 *		capabilities maintained at this node.
 *
 *	Formal Parameters
 *		None
 *
 *	Return Value
 *		GCC_NO_ERROR - On Success
 *		GCC_ALLOCATIONFAILURE - On resource failure
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		The standard allows us to send a zero length set of capabilities when
 *		an application leaves that previously had capabilites.
 */
GCCError CAppRoster::BuildSetOfCapabilityRefreshesPDU(void)
{
	GCCError								rc = GCC_ALLOCATION_FAILURE;
	PSetOfApplicationCapabilityRefreshes	pNew;
	PSetOfApplicationCapabilityRefreshes	pOld = NULL;

	DebugEntry(CAppRoster::BuildSetOfCapabilityRefreshesPDU);

	if (m_fMaintainPduBuffer)
	{
		APP_CAP_ITEM		*lpAppCapData;
		/*
		**	We must first free up any previously built PDU data associated
		**	with a capability refresh.
		*/
		if (m_SetOfAppInfo.value.application_capabilities_list.choice == APPLICATION_CAPABILITY_REFRESH_CHOSEN)
		{
			FreeSetOfCapabilityRefreshesPDU ();
		}

		m_SetOfAppInfo.value.application_capabilities_list.choice = APPLICATION_CAPABILITY_REFRESH_CHOSEN;
		m_SetOfAppInfo.value.application_capabilities_list.u.application_capability_refresh = NULL;

		//	Iterate through the complete list of capabilities.
		m_CollapsedCapListForAllNodes.Reset();
		while (NULL != (lpAppCapData = m_CollapsedCapListForAllNodes.Iterate()))
		{
			DBG_SAVE_FILE_LINE
			pNew = new SetOfApplicationCapabilityRefreshes;
			if (NULL == pNew)
			{
				goto MyExit;
			}

			/*
			**	If the set of capability refreshes pointer is equal to NULL
			**	we are at the first capability. Here we need to save the
			**	pointer to the first capability.
			*/
			if (m_SetOfAppInfo.value.application_capabilities_list.u.
					application_capability_refresh == NULL)
			{
				m_SetOfAppInfo.value.application_capabilities_list.u.
					application_capability_refresh = pNew;
			}
			else
			{
				pOld->next = pNew;
			}

			/*
			**	This is used to set the next pointer if another record
			**	exists after this one.
			*/
			/*
			 * This will get filled in later if there is another record.
			 */
			(pOld = pNew)->next = NULL;

			//	Fill in the capability identifier
			rc = lpAppCapData->pCapID->GetCapabilityIdentifierDataPDU(
							&pNew->value.capability_id);
			if (GCC_NO_ERROR != rc)
			{
				goto MyExit;
			}
		
			//	Fill in the capability choice from the GCC capability class.
			pNew->value.capability_class.choice = (USHORT) lpAppCapData->eCapType;

			//	Note that nothing is filled in for a logical capability.
			if (lpAppCapData->eCapType == GCC_UNSIGNED_MINIMUM_CAPABILITY)
			{
				pNew->value.capability_class.u.unsigned_minimum =
						lpAppCapData->nUnsignedMinimum;
			}
			else if (lpAppCapData->eCapType == GCC_UNSIGNED_MAXIMUM_CAPABILITY)
			{
				pNew->value.capability_class.u.unsigned_maximum =
						lpAppCapData->nUnsignedMaximum;
			}

			//	Fill in number of entities regardless of capability type.
			pNew->value.number_of_entities = lpAppCapData->cEntries;
		}
	}

	rc = GCC_NO_ERROR;

MyExit:

	return rc;
}


/*
 *	ApplicationRosterError	BuildSetOfNonCollapsingCapabilitiesPDU ()
 *
 *	Private Function Description
 *		This routine builds a PDU structure for the non collapsing capabilities
 *		list associated passed in.
 *
 *	Formal Parameters
 *		pSetOfCaps				-	(o)	PDU structure to fill in
 *		capabilities_list		-	(i)	Source non-collapsing capabilities.
 *
 *	Return Value
 *		GCC_NO_ERROR - On Success
 *		GCC_ALLOCATIONFAILURE - On resource failure
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		None
 */
GCCError CAppRoster::BuildSetOfNonCollapsingCapabilitiesPDU(
				PSetOfNonCollapsingCapabilities	*pSetOfCaps,
				CAppCapItemList					*pAppCapItemList)
{
	GCCError							rc = GCC_ALLOCATION_FAILURE;
	PSetOfNonCollapsingCapabilities		new_set_of_capabilities;
	PSetOfNonCollapsingCapabilities		old_set_of_capabilities;
	APP_CAP_ITEM						*lpAppCapData;

	DebugEntry(CAppRoster::BuildSetOfNonCollapsingCapabilitiesPDU);

	*pSetOfCaps = NULL;
	old_set_of_capabilities = NULL;	//	Setting this to NULL removes warning

	/*
	 * Iterate through the complete list of capabilities.
	 */
	pAppCapItemList->Reset();
	while (NULL != (lpAppCapData = pAppCapItemList->Iterate()))
	{
		DBG_SAVE_FILE_LINE
		new_set_of_capabilities = new SetOfNonCollapsingCapabilities;
		if (NULL == new_set_of_capabilities)
		{
			goto MyExit;
		}

		/*
		**	If the passed in pointer is equal to NULL we are at the first
		**	capability. Here we need to save the pointer to the first
		**	capability in the passed in pointer.
		*/
		if (*pSetOfCaps == NULL)
		{
			*pSetOfCaps = new_set_of_capabilities;
		}
		else
		{
			old_set_of_capabilities->next = new_set_of_capabilities;
		}

		/*
		**	This is used to set the next pointer if another record exists
		**	after this one.
		*/
		old_set_of_capabilities = new_set_of_capabilities;

		/*
		 * This will get filled in later if there is another record.
		 */
		new_set_of_capabilities->next = NULL;

		new_set_of_capabilities->value.bit_mask = 0;

		//	Fill in the capability identifier									
		rc = lpAppCapData->pCapID->GetCapabilityIdentifierDataPDU(
							&new_set_of_capabilities->value.capability_id);
		if (GCC_NO_ERROR != rc)
		{
			goto MyExit;
		}

		if ((lpAppCapData->poszAppData != NULL) && (rc == GCC_NO_ERROR))
		{
			new_set_of_capabilities->value.bit_mask |= APPLICATION_DATA_PRESENT;

			new_set_of_capabilities->value.application_data.length =
					lpAppCapData->poszAppData->length;

			new_set_of_capabilities->value.application_data.value =
					lpAppCapData->poszAppData->value;
		}
	}

	rc = GCC_NO_ERROR;

MyExit:

    return rc;
}


/*
 * These routines are used to free up a roster update indication PDU.
 */

/*
 *	void	FreeRosterUpdateIndicationPDU ()
 *
 *	Private Function Description
 *		This routine frees up all the internal data allocated to hold the roster
 *		update PDU.
 *
 *	Formal Parameters
 *		None
 *
 *	Return Value
 *		None
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		Note that the session key PDU data is not freed.  Since this data will
 *		not change through out the life of this application roster object
 *		we just use the same session id PDU data for every roster update
 *		indication.
 */
void CAppRoster::FreeRosterUpdateIndicationPDU(void)
{
	DebugEntry(CAppRoster::FreeRosterUpdateIndicationPDU);

	switch (m_SetOfAppInfo.value.application_record_list.choice)
	{
	case APPLICATION_RECORD_REFRESH_CHOSEN:
		FreeSetOfRefreshesPDU ();
		break;
	case APPLICATION_RECORD_UPDATE_CHOSEN:
		FreeSetOfUpdatesPDU ();
		break;
	}

	//	Free the PDU data associated with the capability list if one exists.
	if (m_SetOfAppInfo.value.application_capabilities_list.choice == APPLICATION_CAPABILITY_REFRESH_CHOSEN)
	{
		FreeSetOfCapabilityRefreshesPDU ();
	}
	
	m_SetOfAppInfo.value.application_record_list.choice = APPLICATION_NO_CHANGE_CHOSEN;
	m_SetOfAppInfo.value.application_capabilities_list.choice = CAPABILITY_NO_CHANGE_CHOSEN;
	m_pSetOfAppRecordUpdates = NULL;
}


/*
 *	void	FreeSetOfRefreshesPDU	()
 *
 *	Private Function Description
 *		This routine Frees all the memory associated with a set
 *		of application record refreshes.
 *
 *	Formal Parameters
 *		none
 *
 *	Return Value
 *		none
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
void CAppRoster::FreeSetOfRefreshesPDU(void)
{
	PSetOfApplicationRecordRefreshes		pCurr, pNext;

	DebugEntry(CAppRoster::FreeSetOfRefreshesPDU);

	for (pCurr = m_SetOfAppInfo.value.application_record_list.u.application_record_refresh;
			NULL != pCurr;
			pCurr = pNext)
	{
		pNext = pCurr->next;

		//	Free up any non-collapsing capabilities data
		if (pCurr->value.application_record.bit_mask & NON_COLLAPSING_CAPABILITIES_PRESENT)
		{
			FreeSetOfNonCollapsingCapabilitiesPDU(pCurr->value.application_record.non_collapsing_capabilities);
		}

		//	Delete the actual record refresh
		delete pCurr;
	}
	m_SetOfAppInfo.value.application_record_list.u.application_record_refresh = NULL;
}


/*
 *	void	FreeSetOfUpdatesPDU	()
 *
 *	Private Function Description
 *		This routine frees the memory associated with a complete set
 *		application roster updates.
 *
 *	Formal Parameters
 *		none
 *
 *	Return Value
 *		none
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
void CAppRoster::FreeSetOfUpdatesPDU(void)
{
	PSetOfApplicationRecordUpdates		pCurr, pNext;
	PApplicationRecord					application_record;

	DebugEntry(CAppRoster::FreeSetOfUpdatesPDU);

	for (pCurr = m_SetOfAppInfo.value.application_record_list.u.application_record_update;
			NULL != pCurr;
			pCurr = pNext)
	{
		// remember the next one because we will free the current one
		pNext = pCurr->next;

		//	Free up any non-collapsing capabilities data
		switch(pCurr->value.application_update.choice)
		{
		case APPLICATION_ADD_RECORD_CHOSEN:
			application_record = &pCurr->value.application_update.u.application_add_record;
			break;
		case APPLICATION_REPLACE_RECORD_CHOSEN:
			application_record = &pCurr->value.application_update.u.application_replace_record;
			break;
		default:
			application_record = NULL;
			break;
		}

		if (application_record != NULL)
		{
			if (application_record->bit_mask & NON_COLLAPSING_CAPABILITIES_PRESENT)
			{
				FreeSetOfNonCollapsingCapabilitiesPDU(application_record->non_collapsing_capabilities);
			}
		}

		//	Delete the actual update structure
		delete pCurr;
	}
    m_SetOfAppInfo.value.application_record_list.u.application_record_update = NULL;
}


/*
 *	void	FreeSetOfCapabilityRefreshesPDU	()
 *
 *	Private Function Description
 *		This routine frees all the memory associated with the capability PDU.
 *
 *	Formal Parameters
 *		capability_refresh -	(i)	Capabilities to be freed.
 *
 *	Return Value
 *		none
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		Note that the capability id PDU data is not freed here.  Since this
 *		data should not change through out the life of this object we don't
 *		bother freeing and regenerating it.
 */
void CAppRoster::FreeSetOfCapabilityRefreshesPDU(void)
{
	PSetOfApplicationCapabilityRefreshes		pCurr, pNext;

	for (pCurr = m_SetOfAppInfo.value.application_capabilities_list.u.application_capability_refresh;
			NULL != pCurr;
			pCurr = pNext)
	{
		pNext = pCurr->next;
		delete pCurr;
	}
}


/*
 *	void	FreeSetOfNonCollapsingCapabilitiesPDU	()
 *
 *	Private Function Description
 *		This routine frees all the memory associated with the
 *		non-collapsed capability PDU.
 *
 *	Formal Parameters
 *		capability_refresh -	(i)	Non-Collapsed Capabilities to be freed.
 *
 *	Return Value
 *		none
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		Note that the capability id PDU data is not freed here.  Since this
 *		data should not change through out the life of this object we don't
 *		bother freeing and regenerating it.
 */
void CAppRoster::FreeSetOfNonCollapsingCapabilitiesPDU (
						PSetOfNonCollapsingCapabilities		capability_refresh)
{
	PSetOfNonCollapsingCapabilities		pCurr, pNext;

	for (pCurr = capability_refresh; NULL != pCurr; pCurr = pNext)
	{
		pNext = pCurr->next;
		delete pCurr;
	}
}


/*
 * These routines process roster update indication PDUs.
 */

/*
 *	ApplicationRosterError	ProcessRosterUpdateIndicationPDU	()
 *
 *	Public Function Description
 *		This routine is responsible for processing the decoded PDU data.
 *		It essentially changes the application roster object's internal database
 *		based on the information in the structure.
 */
GCCError CAppRoster::ProcessRosterUpdateIndicationPDU (
						PSetOfApplicationInformation  	application_information,
                        UserID							sender_id)
{
	GCCError	rc = GCC_NO_ERROR;

	DebugEntry(CAppRoster::ProcessRosterUpdateIndicationPDU);

	/*
	**	Free up the old PDU data here if it is being maintained and the
	**	PDU has been flushed.  Note that we also set the PDU is flushed boolean
	**	back to FALSE so that the new PDU will be maintained until it is
	**	flushed.
	*/
	if (m_fPduIsFlushed)
	{
		FreeRosterUpdateIndicationPDU ();
		m_fPduIsFlushed = FALSE;
	}

	/*
	**	Now check the application key to make sure we have a match. If
	**	not, return with no change.
	*/
	if (! m_pSessionKey->IsThisYourSessionKeyPDU(&application_information->value.session_key))
	{
		WARNING_OUT(("CAppRoster::ProcessRosterUpdateIndicationPDU:GCC_BAD_SESSION_KEY"));
		rc = GCC_BAD_SESSION_KEY;
		goto MyExit;
	}

	/*
	**	If this is a roster update and refresh is chosen we must
	**	clear out the entire list and rebuild it.
	*/
	if (application_information->value.application_record_list.choice != APPLICATION_NO_CHANGE_CHOSEN)
	{
		//	The roster is about to change
		m_fRosterHasChanged = TRUE;

		/*
		**	If this node is the top provider or this roster is local and
		**	only used to propogate PDUs up toward the top provider,
		**	we increment the instance number. If it is not we get the
		**	instance number out of the PDU.
		*/
		if (m_fTopProvider || m_fLocalRoster)
		{
			m_nInstance++;
		}
		else
		{
			m_nInstance = application_information->value.roster_instance_number;
		}
		
		/*
		**	Here if either of these booleans is already TRUE we do not
		**	want to write over them with this PDU data.  Therefore, we
		**	check for FALSE before we do anything with them.
		*/
		if (! m_fPeerEntitiesAdded)
		{
			m_fPeerEntitiesAdded = application_information->value.peer_entities_are_added;
		}

		if (! m_fPeerEntitiesRemoved)
		{
			m_fPeerEntitiesRemoved = application_information->value.peer_entities_are_removed;
		}

		if (application_information->value.application_record_list.choice == APPLICATION_RECORD_REFRESH_CHOSEN)
		{
			TRACE_OUT(("CAppRoster::ProcessRosterUpdateIndicationPDU:ProcessSetOfRefreshesPDU"));
			rc = ProcessSetOfRefreshesPDU(
							application_information->value.application_record_list.u.application_record_refresh,
							sender_id);
		}
		else
		{
			TRACE_OUT(("CAppRoster::ProcessRosterUpdateIndicationPDU:ProcessSetOfUpdatesPDU"));
			rc = ProcessSetOfUpdatesPDU(
							application_information->value.application_record_list.u.application_record_update,
							sender_id);
		}
		if (GCC_NO_ERROR != rc)
		{
			goto MyExit;
		}
	}
	else
	{
		ERROR_OUT(("AppRoster::ProcessRosterUpdateIndicationPDU:ASSERTION: NO Change PDU received"));
	}

	//	Process the capabilities list portion of the PDU.
	if (application_information->value.application_capabilities_list.choice == APPLICATION_CAPABILITY_REFRESH_CHOSEN)
	{
		//	Set flag to show that change has occured.
		m_fCapabilitiesHaveChanged = TRUE;

		/*
		**	We will store the new capabilities in the roster record
		**	associated with the sender id.  Note that it is possible for
		**	this roster record to contain an empty application record list
		**	if the sending node has no enrolled applications.
		*/
		rc = ProcessSetOfCapabilityRefreshesPDU(
						application_information->value.application_capabilities_list.u.application_capability_refresh,
						sender_id);
	}
	else
	{
		ASSERT(GCC_NO_ERROR == rc);
	}

MyExit:

	return rc;
}


/*
 *	GCCError	ProcessSetOfRefreshesPDU	()
 *
 *	Private Function Description
 *		This routine processes a set of record refreshes. It is responsible
 *		for managing the creation (or update) of all affected application
 *		records. The roster list built from a refresh PDU does not maintain the
 *		hierarchy of the conference since it is not important at this point.
 *		Refreshes are issued as broacast from the Top Provider down to the
 *		sub-ordinate nodes.
 *
 *	Formal Parameters
 *		record_refresh 	-	(i) Set of record refresh PDUs to be processed.
 *		sender_id		-	(i)	Node id of node that sent the update.
 *
 *	Return Value
 *		GCC_NO_ERROR - On Success
 *		GCC_ALLOCATION_FAILURE - On resource failure
 *
 *	Side Effects
 *		none
 *
 *	Caveate
 *		none
 */
GCCError CAppRoster::ProcessSetOfRefreshesPDU(
							PSetOfApplicationRecordRefreshes	record_refresh,
							UserID								sender_id)
{
	GCCError							rc = GCC_ALLOCATION_FAILURE;
	PSetOfApplicationRecordRefreshes	pCurr;
	APP_RECORD  					    *app_record;
	APP_NODE_RECORD						*node_record;
	CAppRecordList2						*record_list;
	UserID								node_id;
	EntityID							entity_id;

	DebugEntry(CAppRoster::ProcessSetOfRefreshesPDU);

	if (record_refresh != NULL)
	{
		//	Clear out the node record for the sender id	
		ClearNodeRecordFromList (sender_id);

		/*
		** 	Create the node record for the sender id passed into this routine.
		**	Note that if the sender of this refresh is the Top Provider
		**	all nodes below the top provider are contained in the sub node
		**	list of the Top Provider's node record.	
		*/
		DBG_SAVE_FILE_LINE
		node_record = new APP_NODE_RECORD;
		if (NULL == node_record)
		{
			goto MyExit;
		}

		m_NodeRecordList2.Append(sender_id, node_record);

		for (pCurr = record_refresh; NULL != pCurr; pCurr = pCurr->next)
		{
			node_id = pCurr->value.node_id;
			entity_id = pCurr->value.entity_id;

			if (sender_id != node_id)
			{
				//	Get or create the sub node record list	
				if (NULL == (record_list = node_record->SubNodeList2.Find(node_id)))
				{
					DBG_SAVE_FILE_LINE
					record_list = new CAppRecordList2(DESIRED_MAX_APP_RECORDS);
					if (NULL == record_list)
					{
						goto MyExit;
					}
					node_record->SubNodeList2.Append(node_id, record_list);
				}
			}
			else
			{
				/*
				**	Here we set up the pointer to the record list.  This
				**	list is the node records application list which
				**	means that this list contains the application records
				**	associated with the sender's node.
				*/
				record_list = &node_record->AppRecordList;
			}

			//	Now	create and fill in the new application record.
			DBG_SAVE_FILE_LINE
			app_record = new APP_RECORD;
			if (NULL == app_record)
			{
				goto MyExit;
			}

			rc = ProcessApplicationRecordPDU(app_record, &pCurr->value.application_record);
			if (GCC_NO_ERROR != rc)
			{
				goto MyExit;
			}

			record_list->Append(entity_id, app_record);
		} // for
	}
	else
	{
		//	This roster no longer contains any entries so clear the list!!!
		ClearNodeRecordList ();
	}

	/*
	**	Build a full refresh PDU here if no errors occured while processing
	**	the refresh PDU.									
	*/
	rc = BuildApplicationRecordListPDU (APP_FULL_REFRESH, 0, 0);

MyExit:

	return rc;
}


/*
 *	GCCError	ProcessSetOfUpdatesPDU	()
 *
 *	Private Function Description
 *		This routine processes a set of roster updates.  It iterates through
 *		the complete list of updates making all necessary changes to the
 *		internal information base and building the appropriate PDU.
 *
 *	Formal Parameters
 *		record_update -	(i) set of updates PDU to be processed
 *		sender_id -		(i)	gcc user id of node that sent the update
 *
 *	Return Value
 *		APP_ROSTER_NO_ERROR - On Success
 *		APP_ROSTER_RESOURCE_ERROR - On resource failure
 *
 *	Side Effects
 *		none
 *
 *	Caveate
 *		none
 */
GCCError CAppRoster::ProcessSetOfUpdatesPDU(
					  		PSetOfApplicationRecordUpdates		record_update,
					  		UserID								sender_id)
{
	GCCError							rc = GCC_ALLOCATION_FAILURE;
	PSetOfApplicationRecordUpdates		pCurr;
	UserID								node_id;
	EntityID							entity_id;
	PApplicationRecord					pdu_record;
	APP_RECORD  					    *application_record = NULL;
	APP_NODE_RECORD						*node_record;
	CAppRecordList2						*record_list;
	APP_ROSTER_UPDATE_TYPE				update_type;

	DebugEntry(CAppRoster::ProcessSetOfUpdatesPDU);

	if (record_update != NULL)
	{
		for (pCurr = record_update; NULL != pCurr; pCurr = pCurr->next)
		{
			node_id = pCurr->value.node_id;
			entity_id = pCurr->value.entity_id;

			switch(pCurr->value.application_update.choice)
			{
			case APPLICATION_ADD_RECORD_CHOSEN:
				pdu_record = &(pCurr->value.application_update.u.application_add_record);
				update_type = APP_ADD_RECORD;
				break;
			case APPLICATION_REPLACE_RECORD_CHOSEN:
				DeleteRecord (node_id, entity_id, FALSE);
				pdu_record = &(pCurr->value.application_update.u.application_replace_record);
				update_type = APP_REPLACE_RECORD;
				break;
			default: //	Remove record
				/*
				**	Inform the owner that a record was delete while processing
				**	this PDU so that it can perform any necessary cleanup.
				*/
				m_pAppRosterMgr->DeleteRosterRecord(node_id, entity_id);

				DeleteRecord (node_id, entity_id, TRUE);
				pdu_record = NULL;
				update_type = APP_DELETE_RECORD;
				break;
			}

			/*
			**	First get the roster record and if one does not exist for this
			**	app record create it. After that we will create the application
			**	record and put it into the correct slot in the application
			**	roster record.
			*/
			if (pdu_record != NULL)
			{
				/*
				**	First find the correct node record and if it does not
				**	exist create it.
				*/
				if (NULL == (node_record = m_NodeRecordList2.Find(sender_id)))
				{
					DBG_SAVE_FILE_LINE
					node_record = new APP_NODE_RECORD;
					if (NULL == node_record)
					{
						goto MyExit;
					}

					m_NodeRecordList2.Append(sender_id, node_record);
				}

				/*
				**	If the user and sender id is the same then the record
				**	will be contained in the app_record_list. Otherwise, it
				**	will be maintained in the sub-node list.
				*/

				/*
				**	If the sender_id equals the node id being processed
				**	use the application record list instead of the sub
				**	node list.
				*/
				if (sender_id != node_id)
				{
					/*	
					**	Find the correct node list and create it if it does
					**	not exists. This list holds lists of all the
					**	application	peer entities at a node.
					*/
					if (NULL == (record_list = node_record->SubNodeList2.Find(node_id)))
					{
						DBG_SAVE_FILE_LINE
						record_list = new CAppRecordList2(DESIRED_MAX_APP_RECORDS);
						if (NULL == record_list)
						{
							goto MyExit;
						}

						node_record->SubNodeList2.Append(node_id, record_list);
					}
				}
				else
				{
					record_list = &node_record->AppRecordList;
				}

				//	Now fill in the application record
				DBG_SAVE_FILE_LINE
				application_record = new APP_RECORD;
				if (NULL == application_record)
				{
					goto MyExit;
				}

				record_list->Append(entity_id, application_record);
				rc = ProcessApplicationRecordPDU(application_record, pdu_record);
				if (GCC_NO_ERROR != rc)
				{
					goto MyExit;
				}
			} // if
			
			/*
			**	Here we add this update to our PDU and jump to the next update
			**	in the PDU currently being processed.
			*/
			rc = BuildApplicationRecordListPDU (	update_type,
															node_id,
															entity_id);
			if (rc != GCC_NO_ERROR)
			{
				goto MyExit;
			}

			/*
			**	If the capabilities changed during the above processing
			**	we must	create a new collapsed capabilities list and
			**	build a new capability refresh PDU.
			*/
			if (m_fCapabilitiesHaveChanged)
			{
				MakeCollapsedCapabilitiesList();
				rc = BuildSetOfCapabilityRefreshesPDU ();
				if (rc != GCC_NO_ERROR)
				{
					goto MyExit;
				}
			}
		} // for
	} // if

	rc = GCC_NO_ERROR;

MyExit:

	return rc;
}


/*
 *	GCCError	ProcessApplicationRecordPDU ()
 *
 *	Private Function Description
 *		This routine is responsible for decoding the Application Record
 *		portion of the roster update pdu.
 *
 *	Formal Parameters
 *		application_record -	This is the internal destination app record.
 *		pdu_record - 			Source PDU data
 *
 *	Return Value
 *		GCC_NO_ERROR - On Success
 *		GCC_ALLOCATION_FAILURE - On resource failure
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
GCCError CAppRoster::ProcessApplicationRecordPDU (
									APP_RECORD  	        *application_record,
									PApplicationRecord		pdu_record)
{
	GCCError	rc = GCC_NO_ERROR;

	DebugEntry(CAppRoster::ProcessApplicationRecordPDU);

	application_record->is_enrolled_actively = pdu_record->application_is_active;
	application_record->is_conducting_capable = pdu_record->is_conducting_capable;

	if (pdu_record->bit_mask & RECORD_STARTUP_CHANNEL_PRESENT)
	{
		application_record->startup_channel_type =
						(MCSChannelType)pdu_record->record_startup_channel;
	}
	else
		application_record->startup_channel_type= MCS_NO_CHANNEL_TYPE_SPECIFIED;

	if (pdu_record->bit_mask & APPLICATION_USER_ID_PRESENT)
	{
		application_record->application_user_id =
												pdu_record->application_user_id;
	}
	else
		application_record->application_user_id = 0;

	if (pdu_record->bit_mask & NON_COLLAPSING_CAPABILITIES_PRESENT)
	{
		rc = ProcessNonCollapsingCapabilitiesPDU (
								&application_record->non_collapsed_caps_list,
								pdu_record->non_collapsing_capabilities);
	}

	return rc;
}


/*
 *	GCCError	ProcessSetOfCapabilityRefreshesPDU	()
 *
 *	Private Function Description
 *		This routine is responsible for decoding the capabilities portion
 *		of an roster update PDU.
 *
 *	Formal Parameters
 *		capability_refresh -	(i) set of capabilities PDU to be processed
 *		sender_id -				(i)	gcc user id of node that sent the update
 *
 *	Return Value
 *		GCC_NO_ERROR 			- On Success
 *		GCC_ALLOCATION_FAILURE 	- On resource failure
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		This routine does handle NULL for the capability refresh which means
 *		that the capabilities delivered no longer exists.
 */
GCCError CAppRoster::ProcessSetOfCapabilityRefreshesPDU(
						PSetOfApplicationCapabilityRefreshes	capability_refresh,
                   		UserID									sender_id)
{
	GCCError								rc = GCC_NO_ERROR;
	PSetOfApplicationCapabilityRefreshes	pCurr;
	CAppCapItemList							*pAppCapList;
	APP_CAP_ITEM							*pAppCapItem;
	APP_NODE_RECORD							*node_record;

	DebugEntry(CAppRoster::ProcessSetOfCapabilityRefreshesPDU);

	if (NULL == (node_record = m_NodeRecordList2.Find(sender_id)))
	{
		DBG_SAVE_FILE_LINE
		node_record = new APP_NODE_RECORD;
		if (NULL == node_record)
		{
			return GCC_ALLOCATION_FAILURE;
		}

		m_NodeRecordList2.Append(sender_id, node_record);
	}

	// get collapsed cap list ptr
	pAppCapList = &node_record->CollapsedCapList;

	//	Clear out all the old capabilities from this list.
	pAppCapList->DeleteList();

	//	Begin processing the PDU.
	for (pCurr = capability_refresh; NULL != pCurr; pCurr = pCurr->next)
	{
		ASSERT(GCC_NO_ERROR == rc);

		//	Create and fill in the new capability.
		DBG_SAVE_FILE_LINE
		pAppCapItem = new APP_CAP_ITEM((GCCCapabilityType) pCurr->value.capability_class.choice);
		if (NULL == pAppCapItem)
		{
			return GCC_ALLOCATION_FAILURE;
		}

		//	Create the capability ID
		DBG_SAVE_FILE_LINE
		pAppCapItem->pCapID = new CCapIDContainer(&pCurr->value.capability_id, &rc);
		if (NULL == pAppCapItem->pCapID)
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
		if (GCC_NO_ERROR != rc)
		{
			delete pAppCapItem;
			return rc;
		}

		// append this cap to the collapsed cap list
		pAppCapList->Append(pAppCapItem);

		/*	
		**	Note that a logical type's value is maintained as
		**	number of entities.
		*/
		if (pCurr->value.capability_class.choice == UNSIGNED_MINIMUM_CHOSEN)
		{
			pAppCapItem->nUnsignedMinimum = pCurr->value.capability_class.u.unsigned_minimum;
		}
		else
		if (pCurr->value.capability_class.choice == UNSIGNED_MAXIMUM_CHOSEN)
		{
			pAppCapItem->nUnsignedMaximum = pCurr->value.capability_class.u.unsigned_maximum;
		}

		pAppCapItem->cEntries = pCurr->value.number_of_entities;
	} // for

	//	This forces a new capabilities list to be calculated.
	MakeCollapsedCapabilitiesList();

	/*
	**	Here we build the new PDU data associated with this refresh of the
	**	capability list.
	*/
	return BuildSetOfCapabilityRefreshesPDU();
}


/*
 *	GCCError	ProcessNonCollapsingCapabilitiesPDU	()
 *
 *	Private Function Description
 *		This routine is responsible for decoding the non-collapsing capabilities
 *		portion of a roster record PDU.
 *
 *	Formal Parameters
 *		non_collapsed_caps_list -	(o) Pointer to list to fill in with new
 *										non-collapsed caps.
 *		pSetOfCaps -		(i)	non-collapsed PDU data
 *
 *	Return Value
 *		GCC_NO_ERROR 			- On Success
 *		GCC_ALLOCATION_FAILURE 	- On resource failure
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
GCCError CAppRoster::ProcessNonCollapsingCapabilitiesPDU (
					CAppCapItemList						*non_collapsed_caps_list,
					PSetOfNonCollapsingCapabilities		pSetOfCaps)
{
	GCCError						rc = GCC_NO_ERROR;
	PSetOfNonCollapsingCapabilities	pCurr;
	APP_CAP_ITEM					*pAppCapItem;

	DebugEntry(CAppRoster::ProcessNonCollapsingCapsPDU);

	for (pCurr = pSetOfCaps; NULL != pCurr; pCurr = pCurr->next)
	{
	    //
		// LONCHANC: The following cap data does not have a type???
		// for now, set it to zero.
		//
		DBG_SAVE_FILE_LINE
		pAppCapItem = new APP_CAP_ITEM((GCCCapabilityType)0);
		if (NULL == pAppCapItem)
		{
			rc = GCC_ALLOCATION_FAILURE;
			goto MyExit;
		}

		DBG_SAVE_FILE_LINE
		pAppCapItem->pCapID = new CCapIDContainer(&pCurr->value.capability_id, &rc);
		if (NULL == pAppCapItem->pCapID)
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
		if (rc != GCC_NO_ERROR)
		{
			goto MyExit;
		}

		if (pCurr->value.bit_mask & APPLICATION_DATA_PRESENT)
		{
			if (NULL == (pAppCapItem->poszAppData = ::My_strdupO2(
									pCurr->value.application_data.value,
									pCurr->value.application_data.length)))
			{
				rc = GCC_ALLOCATION_FAILURE;
				goto MyExit;
			}
		}

		non_collapsed_caps_list->Append(pAppCapItem);
	} // for

	ASSERT(GCC_NO_ERROR == rc);

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        delete pAppCapItem;
    }

	return rc;
}


/*
 * Utilities that operate on conference records.
 */

/*
 *	UINT	LockApplicationRoster	()
 *
 *	Public Function Description
 *		This routine is used to lock a GCCApplicationRoster and to determine the
 *		amount of memory necessary to hold the data referenced by the "API"
 *		application roster structure.  The GCCApplicationRoster is used in
 *		indications to applications at the local node.
 */
UINT CAppRoster::LockApplicationRoster(void)
{
	UINT						number_of_records = 0;
	UINT						number_of_capabilities = 0;
	APP_NODE_RECORD				*lpAppNodeRecord;
	APP_RECORD  			    *lpAppRecData;
	APP_CAP_ITEM				*lpAppCapData;
	CAppRecordList2				*lpAppRecDataList;

	DebugEntry(CAppRoster::LockApplicationRoster);

	/*
	 * If this is the first time this routine is called, determine the size of
	 * the memory required to hold the data referenced by the application
	 * roster structure.  Otherwise, just increment the lock count.
	 */
	if (Lock() == 1)
	{
		/*
		 * Lock the data for the session key held within the roster.  This lock
		 * call returns the size of the memory required to hold the session key
		 * data, rounded to an even multiple of four-bytes.
		 */
		m_cbDataMemory = m_pSessionKey->LockSessionKeyData();

		/*
	     * First calculate the total number of records. This count is used to
		 * determine the space necessary to hold the records. Note that we must
		 * count both the application record list and the sub-node list.
	     */
		m_NodeRecordList2.Reset();
	 	while (NULL != (lpAppNodeRecord = m_NodeRecordList2.Iterate()))
		{
			/*
			 * Add the application records at this node to the count.
			 */
			number_of_records += lpAppNodeRecord->AppRecordList.GetCount();
		
			/*
			 * Next count the sub node records.
			 */
			if (! lpAppNodeRecord->SubNodeList2.IsEmpty())
			{
				lpAppNodeRecord->SubNodeList2.Reset();
				while (NULL != (lpAppRecDataList = lpAppNodeRecord->SubNodeList2.Iterate()))
				{
					number_of_records += lpAppRecDataList->GetCount();
				}
			}
		}

		/*
		 * Now determine the amount of memory necessary to hold all of the
		 * pointers to the application records as well as the actual
		 * GCCApplicationRecord structures.
		 */
		m_cbDataMemory += number_of_records *
				(sizeof(PGCCApplicationRecord) +
				ROUNDTOBOUNDARY( sizeof(GCCApplicationRecord)) );
		
		m_NodeRecordList2.Reset();
	   	while (NULL != (lpAppNodeRecord = m_NodeRecordList2.Iterate()))
		{
			/*
			 * Iterate through this node's record list, determining the amount
			 * of memory necessary to hold the pointers to the non-collapsing
			 * capabilities as well as the capability ID data and octet string
			 * data associated with each non-collapsing capability.
			 */
			lpAppNodeRecord->AppRecordList.Reset();
			while (NULL != (lpAppRecData = lpAppNodeRecord->AppRecordList.Iterate()))
			{
				/*
				 * Set up an iterator for the list of non-collapsing
				 * capabilities held within each application roster.
				 */
				lpAppRecData->non_collapsed_caps_list.Reset();
				number_of_capabilities += lpAppRecData->non_collapsed_caps_list.GetCount();

				while (NULL != (lpAppCapData = lpAppRecData->non_collapsed_caps_list.Iterate()))
				{
					/*
					 * Lock the data for each capability ID.  The lock call
					 * returns the length of the data referenced by each
					 * capability ID rounded to occupy an even multiple of
					 * four-bytes.
					 */
					m_cbDataMemory += lpAppCapData->pCapID->LockCapabilityIdentifierData();

					/*
					 * Add up the space required to hold the application data
					 * octet strings if they are present.  Make sure there is
					 * enough space for each octet string to occupy an even
					 * multiple of four bytes.  Add room to hold the actual
					 * octet string structure also since the capability
					 * structure only contains a pointer to a OSTR.
					 */
					if (lpAppCapData->poszAppData != NULL)
					{
						m_cbDataMemory += ROUNDTOBOUNDARY(sizeof(OSTR));
						m_cbDataMemory += ROUNDTOBOUNDARY(lpAppCapData->poszAppData->length);
					}
				}
			}

			/*
			 * Iterate through this node's sub-node record list, determining the
			 * amount of memory necessary to hold the pointers to the
			 * non-collapsing capabilities as well as the capability ID data and
			 * octet string	data associated with each non-collapsing capability.
			 */
			lpAppNodeRecord->SubNodeList2.Reset();
			while (NULL != (lpAppRecDataList = lpAppNodeRecord->SubNodeList2.Iterate()))
			{
				lpAppRecDataList->Reset();
				while (NULL != (lpAppRecData = lpAppRecDataList->Iterate()))
				{
					/*
					 * Set up an iterator for the list of non-collapsing
					 * capabilities held within each application roster.
					 */
					number_of_capabilities += lpAppRecData->non_collapsed_caps_list.GetCount();

					lpAppRecData->non_collapsed_caps_list.Reset();
					while (NULL != (lpAppCapData = lpAppRecData->non_collapsed_caps_list.Iterate()))
					{
						/*
						 * Lock the data for each capability ID.  The lock call
						 * returns the length of the data referenced by each
						 * capability ID fixed up to occupy an even multiple of
						 * four-bytes.
						 */
						m_cbDataMemory += lpAppCapData->pCapID->LockCapabilityIdentifierData();
					
						/*
						 * Add up the space required to hold the application
						 * data octet strings if they are present.  Make sure
						 * there is	enough space for each octet string to occupy
						 * an even multiple of four bytes.  Add room to hold the
						 * actual octet string structure also since the
						 * capability structure only contains a pointer to a OSTR
						 */
						if (lpAppCapData->poszAppData != NULL)
						{
							m_cbDataMemory += ROUNDTOBOUNDARY(sizeof(OSTR));
							m_cbDataMemory += ROUNDTOBOUNDARY(lpAppCapData->poszAppData->length);
						}
					}
				}
			}
		}

		/*
		 * Determine the amount of memory necessary to hold all of the pointers
		 * to the non-collapsing capabilities as well as the actual
		 * GCCNonCollapsingCapability structures.
		 */
		m_cbDataMemory += number_of_capabilities *
				(sizeof (PGCCNonCollapsingCapability) +
				ROUNDTOBOUNDARY( sizeof(GCCNonCollapsingCapability)) );

		/*
		 * Add the amount of memory necessary to hold the string data associated
		 * with each capability ID.
		 */
		m_CollapsedCapListForAllNodes.Reset();
		while (NULL != (lpAppCapData = m_CollapsedCapListForAllNodes.Iterate()))
		{
			m_cbDataMemory += lpAppCapData->pCapID->LockCapabilityIdentifierData();
		}

		/*
		 * Add the memory to hold the application capability pointers
		 * and structures.
		 */
		number_of_capabilities = m_CollapsedCapListForAllNodes.GetCount();

		m_cbDataMemory += number_of_capabilities *
				(sizeof (PGCCApplicationCapability) +
				ROUNDTOBOUNDARY( sizeof(GCCApplicationCapability)) );
	}

	return m_cbDataMemory;
}


/*
 *	UINT	GetAppRoster()
 *
 *	Public Function Description
 *		This routine is used to obtain a pointer to the GCCApplicatonRoster.
 *		This routine should not be called before LockApplicationRoster is
 *		called. LockApplicationRoster will create the GCCApplicationRoster in
 *		the memory provided.  The GCCApplicationRoster is what is delivered to
 * 		the end user Application SAP.
 */
UINT CAppRoster::GetAppRoster(
						PGCCApplicationRoster		pGccAppRoster,
						LPBYTE						pData)
{
	UINT rc;

	DebugEntry(CAppRoster::GetAppRoster);

	if (GetLockCount() > 0)
	{
        UINT data_length;

	    /*
	     * Fill in the output length parameter which indicates how much data
	     * referenced outside the structure will be written.
	     */
        rc = m_cbDataMemory;

        /*
		 * Get the data associated with the roster's session key and save
		 * the length of the data written into memory.
		 */
		data_length = m_pSessionKey->GetGCCSessionKeyData(&pGccAppRoster->session_key, pData);

		/*
		 * Move the memory pointer past the data associated with the
		 * session key.
		 */
		pData += data_length;

		/*
		 * Fill in other roster structure elements.
		 */
		pGccAppRoster->application_roster_was_changed = m_fRosterHasChanged;
		pGccAppRoster->instance_number = (USHORT) m_nInstance;
		pGccAppRoster->nodes_were_added = m_fPeerEntitiesAdded;
		pGccAppRoster->nodes_were_removed = m_fPeerEntitiesRemoved;
		pGccAppRoster->capabilities_were_changed = m_fCapabilitiesHaveChanged;

		/*
		 * Fill in the full set of application roster records.
		 */
		data_length = GetApplicationRecords(pGccAppRoster,	pData);

		/*
		 * Move the memory pointer past the application records and their
		 * associated data.  Get the full set of application capabilities.
		 */
		pData += data_length;

		data_length = GetCapabilitiesList(pGccAppRoster, pData);
	}
	else
	{
		ERROR_OUT(("CAppRoster::GetAppRoster: Error data not locked"));
        rc = 0;
	}

	return rc;
}


/*
 *	void	UnLockApplicationRoster	()
 *
 *	Public Function Description
 *		This member function is responsible for unlocking the data locked for
 *		the "API" application roster after the lock count goes to zero.
 */
void CAppRoster::UnLockApplicationRoster()
{
	DebugEntry(CAppRoster::UnLockApplicationRoster);

    if (Unlock(FALSE) == 0)
	{
        // reset the size
        m_cbDataMemory = 0;

        // free up all the memory locked for "API" data.
	    APP_NODE_RECORD				*lpAppNodeRecord;
	    APP_RECORD  			    *lpAppRecData;
	    APP_CAP_ITEM				*lpAppCapData;
	    CAppRecordList2				*lpAppRecDataList;

        // unlock session key data
        m_pSessionKey->UnLockSessionKeyData();

        // iterate through all the node records
	    m_NodeRecordList2.Reset();
	    while (NULL != (lpAppNodeRecord = m_NodeRecordList2.Iterate()))
	    {
		    // iterate through this node's record list
		    lpAppNodeRecord->AppRecordList.Reset();
		    while (NULL != (lpAppRecData = lpAppNodeRecord->AppRecordList.Iterate()))
		    {
			    // set up an iterator for the list of non-collapsing
			    // capabilities held within each application roster.
			    lpAppRecData->non_collapsed_caps_list.Reset();
			    while (NULL != (lpAppCapData = lpAppRecData->non_collapsed_caps_list.Iterate()))
			    {
				    lpAppCapData->pCapID->UnLockCapabilityIdentifierData();
			    }
		    }

		    // iterate through this node's sub-node record list
		    lpAppNodeRecord->SubNodeList2.Reset();
		    while (NULL != (lpAppRecDataList = lpAppNodeRecord->SubNodeList2.Iterate()))
		    {
			    lpAppRecDataList->Reset();
			    while (NULL != (lpAppRecData = lpAppRecDataList->Iterate()))
			    {
				    // set up an iterator for the list of non-collapsing
				    // capabilities held within each application roster.
				    lpAppRecData->non_collapsed_caps_list.Reset();
				    while (NULL != (lpAppCapData = lpAppRecData->non_collapsed_caps_list.Iterate()))
				    {
					    lpAppCapData->pCapID->UnLockCapabilityIdentifierData();
				    }
			    }
		    }
	    }

        // iterate through collapsed caps
	    m_CollapsedCapListForAllNodes.Reset();
	    while (NULL != (lpAppCapData = m_CollapsedCapListForAllNodes.Iterate()))
	    {
		    lpAppCapData->pCapID->UnLockCapabilityIdentifierData();
	    }
	}

    // we have to call Release() because we used Unlock(FALSE)
    Release();
}


/*
 *	UINT	GetApplicationRecords	()
 *
 *	Private Function Description
 *		This routine inserts the complete set of application roster records
 *		into the passed in application roster structure.
 *
 *	Formal Parameters
 *		gcc_roster 	-	(o) GCCApplicationRoster to be filled in.
 *		memory		-	(o) Location in memory to begin writing records.
 *
 *	Return Value
 *		The total amount of data written into memory.
 *
 *	Side Effects
 *		The memory pointer passed in will be advanced by the amount of memory
 *		necessary to hold the application records and their data.
 *
 *	Caveats
 *		none
 */
UINT CAppRoster::GetApplicationRecords(
						PGCCApplicationRoster		gcc_roster,
						LPBYTE						memory)
{
	UINT							data_length = 0;
	UINT							record_count = 0;
	PGCCApplicationRecord			gcc_record;
	UINT							capability_data_length;
	APP_NODE_RECORD					*lpAppNodeRec;
	CAppRecordList2					*lpAppRecDataList;
	APP_RECORD  				    *lpAppRecData;
    UserID                          uid, uid2;
	EntityID						eid;

	DebugEntry(CAppRoster::GetApplicationRecords);

	/*
	 * Initialize the number of records in the roster to zero.
	 */
	gcc_roster->number_of_records = 0;

	/*
     * First calculate the total number of records. This count is used to
	 * allocate the space necessary to hold the record pointers. Note that we
	 * must count both the application record list and the sub-node list.
     */
	m_NodeRecordList2.Reset();
	while (NULL != (lpAppNodeRec = m_NodeRecordList2.Iterate()))
	{
		/*
		 * Add the number of application records at this node to the count.
		 */
		gcc_roster->number_of_records += (USHORT) (lpAppNodeRec->AppRecordList.GetCount());

		/*
		 * Next add the number of sub node entries.
		 */
		if (! lpAppNodeRec->SubNodeList2.IsEmpty())
		{
			lpAppNodeRec->SubNodeList2.Reset();
			while (NULL != (lpAppRecDataList = lpAppNodeRec->SubNodeList2.Iterate()))
			{
				gcc_roster->number_of_records += (USHORT) (lpAppRecDataList->GetCount());
			}
		}
	}

	if (gcc_roster->number_of_records != 0)
	{
		/*
		 * Fill in the roster's pointer to the list of application record
		 * pointers.  The pointer list will begin at the memory location passed
		 * into this routine.
		 */
		gcc_roster->application_record_list = (PGCCApplicationRecord *)memory;

		/*
		 * Move the memory pointer past the list of record pointers.  This is
		 * where the first application record will be written.
		 */
		memory += gcc_roster->number_of_records * sizeof(PGCCApplicationRecord);

		/*
		 * Add to the data length the amount of memory necessary to hold the
		 * application record pointers.  Go ahead and add the amount of memory
		 * necessary to hold all of the GCCApplicationRecord structures.
		 */
		data_length += gcc_roster->number_of_records *
				            (sizeof(PGCCApplicationRecord) +
                             ROUNDTOBOUNDARY(sizeof(GCCApplicationRecord)));
		
		record_count = 0;
		m_NodeRecordList2.Reset();
	   	while (NULL != (lpAppNodeRec = m_NodeRecordList2.Iterate(&uid)))
		{
			/*
			 * Iterate through this node's record list, building an "API"
			 * application record for each record in the list.
			 */
			lpAppNodeRec->AppRecordList.Reset();
			while (NULL != (lpAppRecData = lpAppNodeRec->AppRecordList.Iterate(&eid)))
			{
				/*
				 * Set the application record pointer equal to the location in
				 * memory where it will be written.
				 */
				gcc_record = (PGCCApplicationRecord)memory;

				/*
				 * Save the pointer to the application record in the roster's
				 * list of record pointers.
				 */
				gcc_roster->application_record_list[record_count] = gcc_record;

				/*
				 * Get the GCC node ID from the node iterator.
				 */
				gcc_record->node_id = uid;

				/*
				 * Get the Entity ID from the record iterator.
				 */
				gcc_record->entity_id = eid;

				/*
				 * Fill in other application record elements.
				 */
				gcc_record->is_enrolled_actively = lpAppRecData->is_enrolled_actively;
				gcc_record->is_conducting_capable =	lpAppRecData->is_conducting_capable;
				gcc_record->startup_channel_type = lpAppRecData->startup_channel_type;
				gcc_record->application_user_id = lpAppRecData->application_user_id;

				/*
				 * Advance the memory pointer past the application record
				 * structure.  This is where the list of non-collapsing
				 * capabilities pointers will begin.  Round the memory location
				 * off to fall on an even four-byte boundary.
				 */
				memory += ROUNDTOBOUNDARY(sizeof(GCCApplicationRecord));

				/*
				 * Fill in the non-collapsing capabilities for this application
				 * record.
				 */
				capability_data_length = GetNonCollapsedCapabilitiesList(
											gcc_record,
											&lpAppRecData->non_collapsed_caps_list,
											memory);

				/*
				 * Add the amount of memory necessary to hold the list of
				 * capabilities and associated data to the overall length and
				 * move the memory pointer past the capabilities data.
				 */
				memory += capability_data_length;
				data_length += capability_data_length;

				/*
				 * Increment the record list array counter.
				 */
				record_count++;
			}
			
			/*
			 * Iterate through this node's sub-node record list, building an
			 * "API" application record for each record in the list.
			 */
			lpAppNodeRec->SubNodeList2.Reset();
			while (NULL != (lpAppRecDataList = lpAppNodeRec->SubNodeList2.Iterate(&uid2)))
			{
				/*
				 * Iterate through this node's record list.
				 */
				lpAppRecDataList->Reset();
				while (NULL != (lpAppRecData = lpAppRecDataList->Iterate(&eid)))
				{
					/*
					 * Set the application record pointer equal to the location
					 * in memory where it will be written.
					 */
					gcc_record = (PGCCApplicationRecord)memory;

					/*
					 * Save the pointer to the application record in the
					 * roster's list of record pointers.
					 */
					gcc_roster->application_record_list[record_count] = gcc_record;

					/*
					 * Get the node ID from the sub_node_iterator.
					 */
					gcc_record->node_id = uid2;

					/*
					 * Get the entity ID from the record_iterator.
					 */
					gcc_record->entity_id = eid;

					/*
					 * Fill in other application record elements.
					 */
					gcc_record->is_enrolled_actively = lpAppRecData->is_enrolled_actively;
					gcc_record->is_conducting_capable = lpAppRecData->is_conducting_capable;
					gcc_record->startup_channel_type = lpAppRecData->startup_channel_type;
					gcc_record->application_user_id = lpAppRecData->application_user_id;

					/*
					 * Advance the memory pointer past the application record
					 * structure.  This is where the list of non-collapsing
					 * capabilities pointers will begin.  Round the memory
					 * location	off to fall on an even four-byte boundary.
					 */
					memory += ROUNDTOBOUNDARY(sizeof(GCCApplicationRecord));

					/*
					 * Fill in the non-collapsing capabilities for this
					 * application record.  The memory pointer will be advanced
					 * past the capabilities list and data.
					 */
					capability_data_length = GetNonCollapsedCapabilitiesList(
													gcc_record,
													&lpAppRecData->non_collapsed_caps_list,
													memory);

					/*
					 * Add the amount of memory necessary to hold the list of
					 * capabilities and associated data to the overall length.
					 */
					memory += capability_data_length;
					data_length += capability_data_length;

					/*
					 * Increment the record list array counter.
					 */
					record_count++;
				}
			}
		}
	}
	else
	{
		/*
		 * There were no application records so set the pointer to the list
		 * of records to NULL and the data_length return value to zero.
		 */
		gcc_roster->application_record_list = NULL;
		data_length = 0;
	}

	return (data_length);
}


/*
 *	UINT	GetCapabilitiesList	()
 *
 *	Private Function Description
 *		This routine fills in the capabilities portion of the
 *		GCCAppicationRoster structure.
 *
 *	Formal Parameters
 *		gcc_roster -	(o) GCCApplicationRoster to be filled in
 *		memory		-	(o) Location in memory to begin writing records.
 *
 *	Return Value
 *		The total amount of data written into memory.
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
UINT CAppRoster::GetCapabilitiesList(
						PGCCApplicationRoster	gcc_roster,
						LPBYTE					memory)
{
	UINT								data_length = 0;
	UINT								capability_id_data_length = 0;
	UINT								capability_count;
	PGCCApplicationCapability			gcc_capability;
	APP_CAP_ITEM						*lpAppCapData;

	DebugEntry(CAppRoster::GetCapabilitiesList);

	/*
	 * Retrieve the number of capabilities for this roster and fill in any that
	 * are present.
	 */
	gcc_roster->number_of_capabilities = (USHORT) m_CollapsedCapListForAllNodes.GetCount();

	if (gcc_roster->number_of_capabilities != 0)
	{
		/*
		 * Fill in the roster's pointer to the list of application capability
		 * pointers.  The pointer list will begin at the memory location passed
		 * into this routine.
		 */
		gcc_roster->capabilities_list = (PGCCApplicationCapability *)memory;

		/*
		 * Move the memory pointer past the list of capability pointers.  This
		 * is where the first application capability structure will be written.
		 */
		memory += (Int)(gcc_roster->number_of_capabilities *
				sizeof(PGCCApplicationCapability));

		/*
		 * Add to the data length the amount of memory necessary to hold the
		 * application capability pointers.  Go ahead and add the amount of
		 * memory necessary to hold all of the GCCApplicationCapability
		 * structures.
		 */
		data_length += gcc_roster->number_of_capabilities *
				(sizeof(PGCCApplicationCapability) +
				ROUNDTOBOUNDARY ( sizeof(GCCApplicationCapability)) );

		capability_count = 0;
		m_CollapsedCapListForAllNodes.Reset();
	   	while (NULL != (lpAppCapData = m_CollapsedCapListForAllNodes.Iterate()))
		{
			/*
			 * Set the application capability pointer equal to the
			 * location in memory where it will be written.
			 */
			gcc_capability = (PGCCApplicationCapability)memory;
				
			/*
			 * Save the pointer to the application capability in the roster's
			 * list of application capability pointers.
			 */
			gcc_roster->capabilities_list[capability_count] =
													gcc_capability;
			
			/*
			 * Advance the memory pointer past the application capability
			 * structure.  This is where the string data for the capability ID
			 * will be written.  Ensure that the memory pointer falls on an
			 * even four-byte boundary.
			 */
			memory += (Int)(ROUNDTOBOUNDARY(sizeof(GCCApplicationCapability)));

			/*
			 * Retrieve the capability ID information from the internal
			 * CapabilityIDData object.  The length returned by this call will
			 * have already been rounded to an even multiple of four bytes.
			 */
			capability_id_data_length = lpAppCapData->pCapID->GetGCCCapabilityIDData(
												&gcc_capability->capability_id,
												memory);

			/*
			 * Advance the memory pointer past the string data written into
			 * memory by the capability ID object.  Add the length of the string
			 * data to the overall capability length.
			 */
			memory += (Int)capability_id_data_length;
			data_length += capability_id_data_length;

			/*
			 * Now fill in the rest of the capability.
			 */
			gcc_capability->capability_class.eType =lpAppCapData->eCapType;

			if (gcc_capability->capability_class.eType ==
									GCC_UNSIGNED_MINIMUM_CAPABILITY)
			{
				gcc_capability->capability_class.nMinOrMax = lpAppCapData->nUnsignedMinimum;
			}
			else if (gcc_capability->capability_class.eType == GCC_UNSIGNED_MAXIMUM_CAPABILITY)
			{
				gcc_capability->capability_class.nMinOrMax = lpAppCapData->nUnsignedMaximum;
			}

			gcc_capability->number_of_entities = lpAppCapData->cEntries;

			/*
			 * Increment the capability ID array counter.
			 */
			capability_count++;
		}
	}
	else
	{
		gcc_roster->capabilities_list = NULL;
	}

	return (data_length);
}


/*
 *	UINT	GetNonCollapsedCapabilitiesList	()
 *
 *	Private Function Description:
 *		This routine is used to fill in the "API" non-collapsing capabilities
 * 		portion of a GCCApplicationRoster from the data which is stored
 *		internally by this class.
 *
 *	Formal Parameters
 *		gcc_record	-		(o)		The application record to be filled in.
 *		pAppCapItemList 	(i)		The internal capabilities data.
 *		memory				(i/o)	The memory location to begin writing data.
 *
 *	Return Value
 *		The total amount of data written into memory.
 *
 *	Side Effects
 *		The memory pointer passed in will be advanced by the amount of memory
 *		necessary to hold the capabilities and their data.
 *
 *	Caveats
 *		none
 */
UINT CAppRoster::GetNonCollapsedCapabilitiesList(
					PGCCApplicationRecord				gcc_record,
					CAppCapItemList    					*pAppCapItemList,
					LPBYTE								memory)
{
	UINT								capability_count;
	PGCCNonCollapsingCapability			gcc_capability;
	APP_CAP_ITEM						*lpAppCapData;
	UINT								capability_id_length = 0;
	UINT								capability_data_length = 0;

	DebugEntry(CAppRoster::GetNonCollapsedCapabilitiesList);

	/*
	 * Get the number of non-collapsed capabilities.
	 */
	gcc_record->number_of_non_collapsed_caps = (USHORT) pAppCapItemList->GetCount();

	if (gcc_record->number_of_non_collapsed_caps != 0)
	{
		/*
		 * Fill in the record's pointer to the list of non-collapsing
		 * capabilities	pointers.  The pointer list will begin at the memory
		 * location passed into this routine.
		 */
		gcc_record->non_collapsed_caps_list = (PGCCNonCollapsingCapability *)memory;

		/*
		 * Move the memory pointer past the list of capability pointers.  This
		 * is where the first capability structure will be written.
		 */
		memory += (Int)(gcc_record->number_of_non_collapsed_caps *
				sizeof(PGCCNonCollapsingCapability));

		/*
		 * Add to the data length the amount of memory necessary to hold the
		 * capability pointers.  Go ahead and add the amount of memory necessary
		 * to hold all of the GCCNonCollapsingCapability structures.
		 */
		capability_data_length = gcc_record->number_of_non_collapsed_caps *
				(sizeof(PGCCNonCollapsingCapability) +
				ROUNDTOBOUNDARY(sizeof (GCCNonCollapsingCapability)));

		/*
		 * Iterate through this record's capabilities list, building an "API"
		 * non-collapsing capability for each capability in the list.
		 */
		capability_count = 0;
		pAppCapItemList->Reset();
		while (NULL != (lpAppCapData = pAppCapItemList->Iterate()))
		{
			/*
			 * Set the capability pointer equal to the location in memory where
			 * it will be written.
			 */
			gcc_capability = (PGCCNonCollapsingCapability)memory;

			/*
			 * Save the pointer to the capability in the record's list of
			 * capability pointers.
			 */
			gcc_record->non_collapsed_caps_list[capability_count] = gcc_capability;

			/*
			 * Move the memory pointer past the capability ID structure.  This
			 * is where the data associated with the structure will be written.
			 * Retrieve the capability ID data from the internal object, saving
			 * it in the "API" capability ID structure.
			 */
			memory += (Int)ROUNDTOBOUNDARY(sizeof(GCCNonCollapsingCapability));

			capability_id_length = lpAppCapData->pCapID->GetGCCCapabilityIDData(
							&gcc_capability->capability_id,	memory);

			/*
			 * Add to the data length the amount of memory necessary to hold the
			 * capability ID data.
			 */
			capability_data_length += capability_id_length;

			/*
			 * Move the memory pointer past the data filled in for the
			 * capability ID.  This is where the application data OSTR
			 * contained in the non-collapsing capability will be written, if
			 * one exists.  Note that the capability contains a pointer to a
			 * OSTR and therefore the OSTR structure as well
			 * as the string data must be written into memory.
			 */
			memory += capability_id_length;

			if (lpAppCapData->poszAppData != NULL)
			{
				/*
				 * Set the application data structure pointer equal to the
				 * location in memory where	it will be written.
				 */
				gcc_capability->application_data = (LPOSTR) memory;
				gcc_capability->application_data->length = lpAppCapData->poszAppData->length;

				/*
				 * Move the memory pointer past the OSTR structure
				 * and round it off to an even four-byte boundary.  This is
				 * where the actual string data will be written so set the
				 * structure string pointer equal to that location.
				 */
				memory += ROUNDTOBOUNDARY(sizeof(OSTR));
				gcc_capability->application_data->value =(LPBYTE)memory;

				/*
				 * Copy the actual application string data into memory.
				 */
				::CopyMemory(gcc_capability->application_data->value,
							lpAppCapData->poszAppData->value,
							lpAppCapData->poszAppData->length);

				/*
				 * Add to the data length the amount of memory necessary to
				 * hold the	application data structure and string.  The lengths
				 * will need to be aligned on a four-byte boundary	before
				 * adding them to the total length.
				 */
				capability_data_length += ROUNDTOBOUNDARY(sizeof(OSTR));
				capability_data_length += ROUNDTOBOUNDARY(gcc_capability->application_data->length);

				/*
				 * Move the memory pointer past the application string data.
				 * The memory pointer is then fixed up to ensure that it falls
				 * on an even four-byte boundary.
				 */
				memory += ROUNDTOBOUNDARY(lpAppCapData->poszAppData->length);
			}
			else
			{
				gcc_capability->application_data = NULL;
			}

			/*
			 * Increment the capability array counter.
			 */
			capability_count++;
		}
	}
	else
	{
		gcc_record->non_collapsed_caps_list = NULL;
		capability_data_length = 0;
	}

	return (capability_data_length);
}


/*
 *	void	FreeApplicationRosterData	()
 *
 *	Private Function Description:
 *		This routine is used to free up any data which was locked for an "API"
 *		application roster.
 *
 *	Formal Parameters
 *		none
 *
 *	Return Value
 *		none
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
void CAppRoster::FreeApplicationRosterData(void)
{
	APP_NODE_RECORD			*lpAppNodeRec;
	APP_RECORD  		    *lpAppRecData;
	APP_CAP_ITEM			*lpAppCapData;
	CAppRecordList2			*lpAppRecDataList;

	DebugEntry(CAppRoster::FreeApplicationRosterData);

	m_pSessionKey->UnLockSessionKeyData();

	/*
	 * Unlock the data associated with each non-collapsed capability by
	 * iterating through the list of application records at each node as well as
	 * the list of sub-node records at each node, calling "UnLock" for each
	 * CapabilityIDData associated with each cabability.
	 */
	m_NodeRecordList2.Reset();
	while (NULL != (lpAppNodeRec = m_NodeRecordList2.Iterate()))
	{
		lpAppNodeRec->AppRecordList.Reset();
		while (NULL != (lpAppRecData = lpAppNodeRec->AppRecordList.Iterate()))
		{
			lpAppRecData->non_collapsed_caps_list.Reset();
			while (NULL != (lpAppCapData = lpAppRecData->non_collapsed_caps_list.Iterate()))
			{
				lpAppCapData->pCapID->UnLockCapabilityIdentifierData ();
			}
		}

		lpAppNodeRec->SubNodeList2.Reset();
		while (NULL != (lpAppRecDataList = lpAppNodeRec->SubNodeList2.Iterate()))
		{
			lpAppRecDataList->Reset();
			while (NULL != (lpAppRecData = lpAppRecDataList->Iterate()))
			{
				lpAppRecData->non_collapsed_caps_list.Reset();
				while (NULL != (lpAppCapData = lpAppRecData->non_collapsed_caps_list.Iterate()))
				{
					lpAppCapData->pCapID->UnLockCapabilityIdentifierData();
				}
			}
		}
	}

	/*
	 * Iterate through the list of collapsed capabilities, unlocking the data
	 * for each CapabilityIDData object associated with each capability.
	 */
	m_CollapsedCapListForAllNodes.Reset();
	while (NULL != (lpAppCapData = m_CollapsedCapListForAllNodes.Iterate()))
	{
		lpAppCapData->pCapID->UnLockCapabilityIdentifierData();
	}
}


/*
 *	GCCError	AddRecord ()
 *
 *	Public Function Description
 *		This member function is responsible for inserting a new application
 *		record into the Roster. This routine will return a failure if the
 *		application record already exist.
 *
 *	Caveats
 *		Note that it is possible for a roster record (not application record)
 *		to already exist at this node if this is the second application
 *		entity to enroll at this node.
 */
GCCError CAppRoster::
AddRecord(GCCEnrollRequest *pReq, GCCNodeID nid, GCCEntityID eid)
{
	GCCError							rc = GCC_NO_ERROR;
	APP_NODE_RECORD						*node_record;
	APP_RECORD  					    *pAppRecord;
	CAppCapItemList						*pAppCapItemList;

	DebugEntry(CAppRoster::AddRecord);

	if (m_fPduIsFlushed)
	{
		FreeRosterUpdateIndicationPDU ();
		m_fPduIsFlushed = FALSE;
	}

	/*
	 * First create a roster entry for this user ID if one does not exists.
	 */
	if (NULL == (node_record = m_NodeRecordList2.Find(nid)))
	{
		DBG_SAVE_FILE_LINE
		node_record = new APP_NODE_RECORD;
		if (node_record != NULL)
		{
			m_NodeRecordList2.Append(nid, node_record);
		}
		else
		{
			ERROR_OUT(("CAppRoster: AddRecord: Resource Error Occured"));
			rc = GCC_ALLOCATION_FAILURE;
			goto MyExit;
		}
	}
	else
	{
		WARNING_OUT(("CAppRoster: AddRecord: Node Record is found"));
	}

	/*
	 * Check to make sure that the application record does not already exist..
	 */
	if ((NULL != node_record->AppRecordList.Find(eid)) ||
		(NULL != node_record->ListOfAppCapItemList2.Find(eid)))
	{
		WARNING_OUT(("AppRoster: AddRecord: Record already exists"));
		rc = GCC_INVALID_PARAMETER;
		goto MyExit;
	}

	//	Next create a record entry in the roster's app_record_list.
	DBG_SAVE_FILE_LINE
	pAppRecord = new APP_RECORD;
	if (NULL == pAppRecord)
	{
	    ERROR_OUT(("CAppRoster: AddRecord: can't create APP_RECORD"));
		rc = GCC_ALLOCATION_FAILURE;
		goto MyExit;
	}

	/*
	**	Here we must determine if an entry already exists at this
	**	node.  If so, only one entry can be conducting capable at a
	**	node.  Therefore, we set this variable based on this.  We use
	**	the "was_conducting_capable" variable to keep up with the
	**	original state incase the conducting capable node leaves the
	**	conference.
	*/
	pAppRecord->is_conducting_capable = pReq->fConductingCapable;

	APP_RECORD *p;
	node_record->AppRecordList.Reset();
	while (NULL != (p = node_record->AppRecordList.Iterate()))
	{
		if (p->is_conducting_capable)
		{
			pAppRecord->is_conducting_capable = FALSE;
			break;
		}
	}

	pAppRecord->was_conducting_capable = pReq->fConductingCapable;
	pAppRecord->is_enrolled_actively = pReq->fEnrollActively;
	pAppRecord->startup_channel_type = pReq->nStartupChannelType;
	pAppRecord->application_user_id = pReq->nUserID;

	if (pReq->cNonCollapsedCaps != 0)
	{
		rc = AddNonCollapsedCapabilities (
					&pAppRecord->non_collapsed_caps_list,
					pReq->cNonCollapsedCaps,
					pReq->apNonCollapsedCaps);
	    if (GCC_NO_ERROR != rc)
	    {
	        ERROR_OUT(("CAppRoster::AddRecord: can't add non collapsed caps, rc=%u", (UINT) rc));
	        delete pAppRecord;
	        goto MyExit;
	    }
	}

	//	Add the new record to the list of records at this node
	node_record->AppRecordList.Append(eid, pAppRecord);

    // from now on, we cannot free pAppRecord in case of error,
    // because it is now in the app record list.

	//	Increment the instance number.
	m_nInstance++;
	m_fPeerEntitiesAdded = TRUE;
	m_fRosterHasChanged = TRUE;

	//	Add an update to the PDU.
	rc = BuildApplicationRecordListPDU(APP_ADD_RECORD, nid, eid);
	if (GCC_NO_ERROR != rc)
	{
        ERROR_OUT(("CAppRoster::AddRecord: can't build app record list, rc=%u", (UINT) rc));
        goto MyExit;
	}

	if (pReq->cCollapsedCaps != 0)
	{
		/*
		**	Create a new capabilities list and insert it into the roster
		**	record list of capabilities.
		*/
		DBG_SAVE_FILE_LINE
		pAppCapItemList = new CAppCapItemList;
		if (NULL == pAppCapItemList)
		{
		    ERROR_OUT(("CAppRoster::AddRecord: can't create CAppCapItemList"));
			rc = GCC_ALLOCATION_FAILURE;
			goto MyExit;
		}

		rc = AddCollapsableCapabilities(pAppCapItemList,
										pReq->cCollapsedCaps,
										pReq->apCollapsedCaps);
		if (GCC_NO_ERROR != rc)
		{
		    ERROR_OUT(("CAppRoster::AddRecord: can't add collapsable caps, rc=%u", (UINT) rc));
		    delete pAppCapItemList;
		    goto MyExit;
		}

		//	Add list of capabilities to list at this node
		node_record->ListOfAppCapItemList2.Append(eid, pAppCapItemList);
		m_fCapabilitiesHaveChanged = TRUE;

        // from now on, we cannot free pAppCapItemList in case of error,
        // because it is now in the app cap item list

		//	Rebuild the collapsed capabilities list.
		MakeCollapsedCapabilitiesList();

		//	Build the capabilities refresh portion of the PDU.
		rc = BuildSetOfCapabilityRefreshesPDU();
		if (GCC_NO_ERROR != rc)
		{
		    ERROR_OUT(("CAppRoster::AddRecord: can't build set of cap refresh, rc=%u", (UINT) rc));
		    goto MyExit;
		}
	}

MyExit:

	DebugExitINT(CAppRoster::AddRecord, rc);
	return rc;
}


/*
 *	GCCError	AddCollapsableCapabilities ()
 *
 *	Private Function Description
 *		This routine takes API collapsed capabilities list data passed in
 *		through a local request and converts it to internal collapsed
 *		capabillities.
 *
 *	Formal Parameters
 *		pAppCapItemList     	-	(o)	Pointer to internal capabilites list
 *										to fill in.
 *		number_of_capabilities	-	(i)	Number of capabilities in the source
 *										list.
 *		capabilities_list		-	(i)	Pointer to source capabilities list.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *	Side Effects
 *		The collapsed capabilities will be recalculated at this node after
 *		all the new caps are added.
 *
 *	Caveats
 *		none
 */
GCCError CAppRoster::AddCollapsableCapabilities (
		CAppCapItemList				*pAppCapItemList,
		UINT						number_of_capabilities,
		PGCCApplicationCapability	*capabilities_list)
{
	GCCError			rc = GCC_NO_ERROR;
	APP_CAP_ITEM		*pAppCapItem;
	UINT				i;
	BOOL    			capability_already_exists;

	DebugEntry(CAppRoster::AddCollapsableCapabilities);

	for (i = 0; i < number_of_capabilities; i++)
	{
		DBG_SAVE_FILE_LINE
		pAppCapItem = new APP_CAP_ITEM((GCCCapabilityType)
							capabilities_list[i]->capability_class.eType);
		if (pAppCapItem != NULL)
		{
			DBG_SAVE_FILE_LINE
			pAppCapItem->pCapID = new CCapIDContainer(&capabilities_list[i]->capability_id, &rc);
			if ((pAppCapItem->pCapID != NULL) && (rc == GCC_NO_ERROR))
			{
				APP_CAP_ITEM		*lpAppCapData;
				/*
				**	Here we check to make sure that this capability id does
				**	not alreay exists in the list.
				*/
				capability_already_exists = FALSE;
				pAppCapItemList->Reset();
				while (NULL != (lpAppCapData = pAppCapItemList->Iterate()))
				{
					if (*lpAppCapData->pCapID == *pAppCapItem->pCapID)
					{
						capability_already_exists = TRUE;
						delete pAppCapItem;
						break;
					}
				}

				if (capability_already_exists == FALSE)
				{	
					if (capabilities_list[i]->capability_class.eType ==
											GCC_UNSIGNED_MINIMUM_CAPABILITY)
					{
						pAppCapItem->nUnsignedMinimum =
								capabilities_list[i]->capability_class.nMinOrMax;
					}
					else if	(capabilities_list[i]->capability_class.eType
										== GCC_UNSIGNED_MAXIMUM_CAPABILITY)
					{
						pAppCapItem->nUnsignedMaximum = capabilities_list[i]->capability_class.nMinOrMax;
					}

					//	Since we have yet to collapse the capabilities set to 1
					pAppCapItem->cEntries = 1;

					//	Add this capability to the list
					pAppCapItemList->Append(pAppCapItem);
				}
			}
			else if (pAppCapItem->pCapID == NULL)
			{
				rc = GCC_ALLOCATION_FAILURE;
				goto MyExit;
			}
			else
			{
			    goto MyExit;
			}
		}
		else
		{
			rc = GCC_ALLOCATION_FAILURE;
			goto MyExit;
		}
	}

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        delete pAppCapItem;
    }

	return rc;
}

/*
 *	GCCError	AddNonCollapsedCapabilities ()
 *
 *	Private Function Description
 *		This routine takes API non-collapsed capabilities list data passed in
 *		through a local request and converts it to internal non-collapsed
 *		capabillities.
 *
 *	Formal Parameters
 *		pAppCapItemList     	-	(o)	Pointer to internal non-collapsed
 *										capabilites list to fill in.
 *		number_of_capabilities	-	(i)	Number of non-collapsed capabilities in
 *										the source list.
 *		capabilities_list		-	(i)	Pointer to source non-collapsed
 *										capabilities list.
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_INVALID_NON_COLLAPSED_CAP	-	Invalid non-collapsed capability.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
GCCError CAppRoster::AddNonCollapsedCapabilities (
				CAppCapItemList				*pAppCapItemList,
				UINT						number_of_capabilities,
				PGCCNonCollapsingCapability	*capabilities_list)
{
	GCCError			rc = GCC_NO_ERROR;
	APP_CAP_ITEM		*pAppCapItem;
	UINT				i;

	DebugEntry(CAppRoster::AddNonCollapsedCapabilities);

	for (i = 0; i < number_of_capabilities; i++)
	{
	    //
		// LONCHANC: Cap type is not set here.
		// for now, it is zero.
		//
		DBG_SAVE_FILE_LINE
		pAppCapItem = new APP_CAP_ITEM((GCCCapabilityType) 0);
		if (pAppCapItem != NULL)
		{
			DBG_SAVE_FILE_LINE
			pAppCapItem->pCapID = new CCapIDContainer(&capabilities_list[i]->capability_id, &rc);
			if (pAppCapItem->pCapID != NULL)
			{
				if (capabilities_list[i]->application_data != NULL)
				{
					if (NULL == (pAppCapItem->poszAppData = ::My_strdupO2(
							capabilities_list[i]->application_data->value,
							capabilities_list[i]->application_data->length)))
					{
						rc = GCC_ALLOCATION_FAILURE;
						goto MyExit;
					}
					else if (pAppCapItem->poszAppData->length > MAXIMUM_APPLICATION_DATA_LENGTH)
					{
						rc = GCC_INVALID_NON_COLLAPSED_CAP;
						goto MyExit;
					}
				}

				//	Add this capability to the list if no errors
				pAppCapItemList->Append(pAppCapItem);
			}
			else if (pAppCapItem->pCapID == NULL)
			{
				rc = GCC_ALLOCATION_FAILURE;
				goto MyExit;
			}
			else
			{
			    goto MyExit;
			}
		}
		else
		{
			rc = GCC_ALLOCATION_FAILURE;
			goto MyExit;
	    }
	}

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        delete pAppCapItem;
    }

	return rc;
}


/*
 *	GCCError	RemoveRecord ()
 *
 *	Public Function Description
 *		This member function completely removes the specified record from the
 *		application roster.  This includes any capabilities associated with
 *		this record. It also takes care of keeping the Instance number and
 *		added and removed flags up to date.
 */
GCCError CAppRoster::RemoveRecord(GCCNodeID nid, GCCEntityID eid)
{
	GCCError				rc;
	APP_RECORD  		    *pAppRecord;
	APP_NODE_RECORD			*node_record;

	DebugEntry(CAppRoster::RemoveRecord);

	if (m_fPduIsFlushed)
	{
		FreeRosterUpdateIndicationPDU ();
		m_fPduIsFlushed = FALSE;
	}

	//	First see if the record is contained in the Roster_Record_List.
	if (NULL == (node_record = m_NodeRecordList2.Find(nid)))
	{
	    TRACE_OUT(("CAppRoster::RemoveRecord: can't find node record, nid=%u", (UINT) nid));
		rc = GCC_INVALID_PARAMETER;
		goto MyExit;
	}

	if (NULL == (pAppRecord = node_record->AppRecordList.Find(eid)))
	{
	    TRACE_OUT(("CAppRoster::RemoveRecord: can't find app record, eid=%u", (UINT) eid));
		rc = GCC_INVALID_PARAMETER;
		goto MyExit;
	}

	/*
	**	Here we must determine if any of the remaining APEs at this
	**	node should become conducting capable based on their role
	**	at the time they enrolled.  We only do this if the record
	**	that is being deleted was conducting capabile.
	*/
	if (pAppRecord->is_conducting_capable)
	{
		APP_RECORD  *p;
		EntityID    eid2;

		node_record->AppRecordList.Reset();
		while (NULL != (p = node_record->AppRecordList.Iterate(&eid2)))
		{
			/*
			**	Here we only deal with record entries other than the
			**	one being removed.
			*/
			if (eid2 != eid)
			{
				if (p->was_conducting_capable)
				{
					p->is_conducting_capable = TRUE;
					/*
					**	Set up the update PDU for this conducting
					**	capable change.
					*/
					rc = BuildApplicationRecordListPDU(APP_REPLACE_RECORD, nid, eid2);
					if (GCC_NO_ERROR != rc)
					{
                        ERROR_OUT(("CAppRoster::RemoveRecord: can't build app record list, rc=%u", (UINT) rc));
					    goto MyExit;
					}
					break;
				}
			}
		}
	}

	//	Now delete the record
	rc = DeleteRecord(nid, eid, TRUE);
	if (GCC_NO_ERROR != rc)
	{
	    WARNING_OUT(("CAppRoster::RemoveRecord: can't delete record, rc=%u", (UINT) rc));
        goto MyExit;
	}

	//	Increment the instance number.
	m_nInstance++;
	m_fPeerEntitiesRemoved = TRUE;
	m_fRosterHasChanged = TRUE;

	//	Add an update to the PDU.
	rc = BuildApplicationRecordListPDU(APP_DELETE_RECORD, nid, eid);
	if (GCC_NO_ERROR != rc)
	{
	    ERROR_OUT(("CAppRoster::RemoveRecord: can't build app record list, rc=%u", (UINT) rc));
        goto MyExit;
	}

	/*
	**	If the capabilities changed during the above processing
	**	we must	create a new collapsed capabilities list and
	**	build a new capability refresh PDU.
	*/
	if (m_fCapabilitiesHaveChanged)
	{
		MakeCollapsedCapabilitiesList();
		rc = BuildSetOfCapabilityRefreshesPDU();
		if (GCC_NO_ERROR != rc)
		{
    	    ERROR_OUT(("CAppRoster::RemoveRecord: can't build set of cap refreshes, rc=%u", (UINT) rc));
            goto MyExit;
		}
	}

MyExit:

	DebugExitINT(CAppRoster::RemoveRecord, rc);
	return rc;
}


/*
 *	GCCError	ReplaceRecord	()
 *
 *	Public Function Description
 *		This routine completely replaces the specified record's parameters
 *		with the new parameters passed in.  This includes the capabilities.
 */
GCCError CAppRoster::
ReplaceRecord(GCCEnrollRequest *pReq, GCCNodeID nid, GCCEntityID eid)
{
	GCCError				rc = GCC_NO_ERROR;
	BOOL    				capable_node_found;
	APP_NODE_RECORD			*node_record;
	APP_RECORD  		    *pAppRecord, *p;
	APP_CAP_ITEM			*lpAppCapData;
	CAppCapItemList         NonCollCapsList;

	DebugEntry(CAppRoster::ReplaceRecord);

	if (m_fPduIsFlushed)
	{
		FreeRosterUpdateIndicationPDU ();
		m_fPduIsFlushed = FALSE;
	}

	/*
	**	First determine if the node record does actually already exists. If not
	**	we return an error here.
	*/
	if (NULL == (node_record = m_NodeRecordList2.Find(nid)))
	{
	    ERROR_OUT(("CAppRoster::ReplaceRecord: can't find the node record for nid=%u", (UINT) nid));
		rc = GCC_INVALID_PARAMETER;
		goto MyExit;
	}

    // make sure the app record exists. if not, return an error
	if (NULL == (pAppRecord = node_record->AppRecordList.Find(eid)))
	{
	    ERROR_OUT(("CAppRoster::ReplaceRecord: can't find the app record for eid=%u", (UINT) eid));
		rc = GCC_INVALID_PARAMETER;
		goto MyExit;
	}

	/*
	**	First check to make sure that we can build the new record before
	**	replacing the old record.  The only entry we need to wory about
	**	here are the non-collapsing capabilities.
	*/
	if (pReq->cNonCollapsedCaps != 0)
	{
		rc = AddNonCollapsedCapabilities(&NonCollCapsList,
		                                pReq->cNonCollapsedCaps,
                                        pReq->apNonCollapsedCaps);
		if (GCC_NO_ERROR != rc)
		{
    	    ERROR_OUT(("CAppRoster::ReplaceRecord: can't add non collapsed caps, rc=%u", (UINT) rc));
    		goto MyExit;
		}
	}

	//	Now replace the record entries.
	pAppRecord->is_enrolled_actively = pReq->fEnrollActively;
	pAppRecord->was_conducting_capable = pReq->fConductingCapable;
	pAppRecord->startup_channel_type = pReq->nStartupChannelType;
	pAppRecord->application_user_id = pReq->nUserID;

	/*
	**	If the is conducting capable flag that was passed in was set
	**	to FALSE we can go ahead and set the internal is conducting
	**	capable flag to FALSE regardless of what the previous
	**	setting was.  If it was passed in TRUE we leave the previous
	**	setting alone.
	*/
	if (pAppRecord->was_conducting_capable == FALSE)
	{
		pAppRecord->is_conducting_capable = FALSE;
	}

	/*
	**	Here we delete the old non-collapsed capabilites and then
	**	add the new ones.
	*/
	if (! pAppRecord->non_collapsed_caps_list.IsEmpty())
	{
		pAppRecord->non_collapsed_caps_list.DeleteList();
		pAppRecord->non_collapsed_caps_list.Clear();
	}

	//	Copy the new non collapsed capabilities if any exists.
	if (pReq->cNonCollapsedCaps != 0)
	{
        while (NULL != (lpAppCapData = NonCollCapsList.Get()))
        {
            pAppRecord->non_collapsed_caps_list.Append(lpAppCapData);
        }
	}

    //
    // handling collapsing cap list
    //

	m_nInstance++;
	m_fRosterHasChanged = TRUE;
	rc = BuildApplicationRecordListPDU(APP_REPLACE_RECORD, nid, eid);
	if (rc != GCC_NO_ERROR)
	{
	    ERROR_OUT(("CAppRoster::ReplaceRecord: can't build app record list, rc=%u", (UINT) rc));
	    goto MyExit;
	}

	/*
	**	Here we must make sure that at least one of the APEs is
	**	Conducting Capable.  We do this by first scanning the
	**	list to see if anyone is it.  If one is not found, the
	**	same list is scanned for an APE that "was" previously
	**	capable.  The first one found that was previously
	**	capable is now it.  If none are found then no one is
	**	capable.
	*/
	capable_node_found = FALSE;
	node_record->AppRecordList.Reset();
	while (NULL != (p = node_record->AppRecordList.Iterate()))
	{
		if (p->is_conducting_capable)
		{
			capable_node_found = TRUE;
			break;
		}
	}

	if (! capable_node_found)
	{
    	GCCEntityID  eid2;
		node_record->AppRecordList.Reset();
		while (NULL != (p = node_record->AppRecordList.Iterate(&eid2)))
		{
			if (p->was_conducting_capable)
			{
				p->is_conducting_capable = TRUE;

				/*
				**	Set up the update PDU for this conducting
				**	capable change.
				*/
				rc = BuildApplicationRecordListPDU(APP_REPLACE_RECORD, nid, eid2);
				if (GCC_NO_ERROR != rc)
				{
            	    ERROR_OUT(("CAppRoster::ReplaceRecord: can't build app record list, rc=%u", (UINT) rc));
            	    goto MyExit;
				}
				break;
			}
		}
	}

	/*
	**	This section of code deals with the collapsable capabilities.
	**	First we determine if the capabilities passed in are different
	**	from the previously existing capabilities.  If so, we must
	**	delete the old set of caps and add back in the new ones.
	*/
	TRACE_OUT(("ApplicatonRoster:ReplaceRecord: Check to see if caps match"));
	if (! DoCapabilitiesListMatch(nid, eid, pReq->cCollapsedCaps, pReq->apCollapsedCaps))
	{
    	CAppCapItemList *pCollCapsList, *q;

		TRACE_OUT(("ApplicatonRoster:ReplaceRecord: Capabilities match"));
		m_fCapabilitiesHaveChanged = TRUE;

		/*
		**	Delete the old capabilities list since it does not match the
		**	new capabilities list.
		*/
		if (NULL != (q = node_record->ListOfAppCapItemList2.Find(eid)))
		{
			q->DeleteList();
			delete q;
			node_record->ListOfAppCapItemList2.Remove(eid);
		}

		/*
		**	Here we add back in the new capabilities. Create a new
		**	capabilities list and insert it into the roster	record list of
		**	capabilities.
		*/
		if (pReq->cCollapsedCaps != 0)
		{
			DBG_SAVE_FILE_LINE
			pCollCapsList = new CAppCapItemList;
			if (NULL == pCollCapsList)
			{
          	    ERROR_OUT(("CAppRoster::ReplaceRecord: can't create CAppCapItemList"));
				rc = GCC_ALLOCATION_FAILURE;
				goto MyExit;
			}

			rc = AddCollapsableCapabilities(pCollCapsList,
											pReq->cCollapsedCaps,
											pReq->apCollapsedCaps);
			if (rc != GCC_NO_ERROR)
			{
          	    ERROR_OUT(("CAppRoster::ReplaceRecord: can't add collapsed caps, rc=%u", (UINT) rc));
			    delete pCollCapsList;
			    goto MyExit;
			}

			//	Add list of capabilities to list at this node
			node_record->ListOfAppCapItemList2.Append(eid, pCollCapsList);
		}

		//	Rebuild the collapsed capabilities list.
		MakeCollapsedCapabilitiesList();

		//	Build the capabilities refresh portion of the PDU.
		rc = BuildSetOfCapabilityRefreshesPDU();
		if (GCC_NO_ERROR != rc)
		{
		    ERROR_OUT(("CAppRoster::ReplaceRecord: can't build set of cap refreshes, rc=%u", (UINT) rc));
		    goto MyExit;
		}
	}
	else
	{
		TRACE_OUT(("CAppRoster:ReplaceRecord:Capabilities match with previous record"));
	}

MyExit:

	DebugExitINT(CAppRoster::ReplaceRecord, rc);
	return rc;
}


/*
 *	GCCError	DeleteRecord ()
 *
 *	Private Function Description
 *		This member function completely removes the specified record from the
 *		application roster.  This includes any capabilities associated with
 *		this record.
 *
 *	Formal Parameters
 *		node_id				-	(i)	Node ID of record to delete.
 *		entity_id			-	(i)	Entity ID of record to delete.
 *		clear_empty_records	-	(i)	This flag indicates whether or not to
 *									clear out the node record if it no-longer
 *									holds data.  When replacing a record we
 *									do NOT want to do this so that we don't
 *									lose any "unchanged" capabilities.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_INVALID_PARAMETER	-	Record specified to delete does not exists.
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
GCCError CAppRoster::DeleteRecord(UserID			node_id,
									EntityID		entity_id,
									BOOL			clear_empty_records)
{
	GCCError						rc = GCC_NO_ERROR;
	APP_RECORD  				    *application_record;
	CAppCapItemList					*pAppCapItemList;
	CAppRecordList2					*pAppRecordList;
	UserID							node_to_check;
	APP_NODE_RECORD					*node_record;
	//APP_CAP_ITEM					*lpAppCapData;
	APP_NODE_RECORD					*lpAppNodeRec;

	DebugEntry(CAppRoster::DeleteRecord);

	//	First see if the record is contained in the Roster_Record_List.
	if (NULL != (node_record = m_NodeRecordList2.Find(node_id)))
	{
		//	Set up node id to check at bottom for empty record
		node_to_check = node_id;
		
		//	Delete the application record.
		if (NULL != (application_record = node_record->AppRecordList.Find(entity_id)))
		{
			TRACE_OUT(("AppRoster: DeleteRecord: Delete AppRecord"));

			//	Delete the data associated with the application record
			DeleteApplicationRecordData (application_record);
			
			//	Remove record from application record list
			node_record->AppRecordList.Remove(entity_id);

			/*
			**	Delete the associated capabilities list.  Note that this list
			**	only exists for records of local nodes.  The collapsed
			**	capabilities list at the root node record take create of
			**	subordniate nodes and is deleted some where else.
			*/
			if (NULL != (pAppCapItemList = node_record->ListOfAppCapItemList2.Find(entity_id)))
			{
				m_fCapabilitiesHaveChanged = TRUE;
				pAppCapItemList->DeleteList();
				TRACE_OUT(("AppRoster: DeleteRecord: Delete Capabilities"));
				delete pAppCapItemList;
				node_record->ListOfAppCapItemList2.Remove(entity_id);
			}
		}
		else
		{
		    WARNING_OUT(("AppRoster: DeleteRecord: can't find this eid=%u", (UINT) entity_id));
			rc = GCC_INVALID_PARAMETER;
		}
	}
	else
	{
		UserID  uid2;
		/*
		**	Here we search through all the sub node list trying to find the
		**	record.  Set return value to record does not exist here and
		**	after the record is found set it back to no error.
		*/
		rc = GCC_INVALID_PARAMETER;
		m_NodeRecordList2.Reset();
		while (NULL != (lpAppNodeRec = m_NodeRecordList2.Iterate(&uid2)))
		{
			//	Delete the sub_node list if it exists
			if (NULL != (pAppRecordList = lpAppNodeRec->SubNodeList2.Find(node_id)))
			{
				//	Delete the app_record_list entry.
				if (NULL != (application_record = pAppRecordList->Find(entity_id)))
				{
					//	Delete the data associated with the application record
					DeleteApplicationRecordData (application_record);

					pAppRecordList->Remove(entity_id);

					if (pAppRecordList->IsEmpty())
					{
						TRACE_OUT(("AppRoster: DeleteRecord: Deleting Sub-Node"));
						delete pAppRecordList;
						lpAppNodeRec->SubNodeList2.Remove(node_id);
					}

					//	Set up node id to check at bottom for empty record
					node_to_check = uid2;

					rc = GCC_NO_ERROR;
				}
				break;
			}
		}
	}

	/*
	**	If the record list is empty and the sub node list is empty
	**	we can remove this entire record from the application roster.
	**	If the record list is empty but the sub node list is not we
	**	must keep the roster record around to maintain the sub node list.
	*/
	if ((rc == GCC_NO_ERROR) && clear_empty_records)
    {
		if (NULL != (node_record = m_NodeRecordList2.Find(node_to_check)) &&
			node_record->AppRecordList.IsEmpty() &&
			node_record->SubNodeList2.IsEmpty())
		{
			if (! node_record->CollapsedCapList.IsEmpty())
			{
				m_fCapabilitiesHaveChanged = TRUE;
				
				//	Delete the collapsed capabilities list.
				node_record->CollapsedCapList.DeleteList();
			}

			delete node_record;
			m_NodeRecordList2.Remove(node_to_check);
		}
    }

	return rc;
}


/*
 *	GCCError		RemoveUserReference	()
 *
 *	Public Function Description
 *		This routine will only remove the application record and its sub nodes
 *		if the node being removed is directly connected to this node.
 *		Otherwise, we wait to receive the update from either the sub node or
 *		the Top Provider.
 */
GCCError CAppRoster::RemoveUserReference(UserID detached_node)
{
	GCCError					rc = GCC_NO_ERROR;

	DebugEntry(CAppRoster::RemoveUserReference);

	//	Clear out any previously allocated PDUs
	if (m_fPduIsFlushed)
	{
		FreeRosterUpdateIndicationPDU ();
		m_fPduIsFlushed = FALSE;
	}

	/*
	**	First Try to remove the node record if one exist.  If it does not
	**	exist we return immediately.  If it does exists we will build the
	**	appropriate PDU and update the instance variables.
	*/
	rc = ClearNodeRecordFromList (detached_node);

	if (rc == GCC_NO_ERROR)
	{
		//	Increment the instance number.
		m_nInstance++;
		m_fPeerEntitiesRemoved = TRUE;
		m_fRosterHasChanged = TRUE;

		/*
		**	Go ahead and do the full refresh here since we do not know the
		**	specifics about who was deleted.
		*/
		rc = BuildApplicationRecordListPDU(APP_FULL_REFRESH, 0, 0);

		if (m_fCapabilitiesHaveChanged && (rc == GCC_NO_ERROR))
		{
			//	Create a new collapsed capabilities list.
			MakeCollapsedCapabilitiesList();

			//	Build the capabilities refresh portion of the PDU.
			rc = BuildSetOfCapabilityRefreshesPDU ();
		}
	}

	return rc;
}


/*
 *	void	DeleteApplicationRecordData	()
 *
 *	Private Function Description
 *		This routine internal application record data.
 *
 *	Formal Parameters
 *		application_record	-	Pointer to the application record data to
 *								delete.
 *
 *	Return Value
 *		none
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
void CAppRoster::DeleteApplicationRecordData(APP_RECORD *pAppRec)
{
	pAppRec->non_collapsed_caps_list.DeleteList();
	delete pAppRec;
}


/*
 *	USHORT		GetNumberOfApplicationRecords	()
 *
 *	Public Function Description
 *		This routine returns the total number of application records that exist
 *		in this application roster.
 *
 *	Formal Parameters
 *		none
 *
 *	Return Value
 *		Number of application roster records
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
UINT CAppRoster::GetNumberOfApplicationRecords(void)
{
	UINT						cRecords = 0;
	APP_NODE_RECORD				*lpAppNodeRec;
	CAppRecordList2				*lpAppRecDataList;

	DebugEntry(CAppRoster::GetNumberOfApplicationRecords);

	/*
	**	First calculate the total number of records. This count is used to
	**	allocate the space necessary to hold the records. Note that we must
	**	count both the application record list and the sub-node list.
	*/
	m_NodeRecordList2.Reset();
	while (NULL != (lpAppNodeRec = m_NodeRecordList2.Iterate()))
	{
		//	Add the application records at this node to the count.
		cRecords += lpAppNodeRec->AppRecordList.GetCount();

		//	Next count the sub node entries.
		if (! lpAppNodeRec->SubNodeList2.IsEmpty())
		{
			lpAppNodeRec->SubNodeList2.Reset();
			while (NULL != (lpAppRecDataList = lpAppNodeRec->SubNodeList2.Iterate()))
			{
				cRecords += lpAppRecDataList->GetCount();
			}
		}
	}

	return cRecords;
}


/*
 *	PGCCSessionKey		GetSessionKey	()
 *
 *	Public Function Description
 *		This routine returns the session key associated with this
 *		application roster.
 *
 *	Formal Parameters
 *		none
 *
 *	Return Value
 *		PGCCSessionKey -	the application key associated with this roster
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */


/*
 *	void	ResetApplicationRoster	()
 *
 *	Public Function Description
 *		This routine takes care of resetting all the internal flags that are
 *		used to convey the current state of the application roster.  Should be
 *		called after the roster is flushed and any roster update messages have
 *		been delivered (after a change to the roster occurs).
 */
void CAppRoster::ResetApplicationRoster(void)
{
	m_fCapabilitiesHaveChanged = FALSE;
	m_fRosterHasChanged = FALSE;
	m_fPeerEntitiesRemoved = FALSE;
	m_fPeerEntitiesAdded = FALSE;
}


/*
 *	BOOL	DoesRecordExist	()
 *
 *	Public Function Description
 *		This routine informs the caller if the specified application record
 *		exists or not.
 */
BOOL CAppRoster::DoesRecordExist(UserID node_id, EntityID entity_id)
{
	BOOL    						rc = FALSE;
	APP_NODE_RECORD					*node_record;
	CAppRecordList2					*record_list;

	DebugEntry(CAppRoster::DoesRecordExist);

	if (NULL != (node_record = m_NodeRecordList2.Find(node_id)))
	{
		if (node_record->AppRecordList.Find(entity_id))
			rc = TRUE;
	}
	else
	{
		m_NodeRecordList2.Reset();
		while (NULL != (node_record = m_NodeRecordList2.Iterate()))
		{
			if (NULL != (record_list = node_record->SubNodeList2.Find(node_id)))
			{
				if (record_list->Find(entity_id))
					rc = TRUE;
			}
		}
	}
	
	return rc;
}


/*
 *	BOOL	HasRosterChanged	()
 *
 *	Public Function Description
 *		This routine informs the caller if the roster has changed since the
 *		last time it was reset.
 */


/*
 *	GCCError	ClearNodeRecordFromList	()
 *
 *	Private Function Description
 *		This routine clears out all the application records that exists at
 *		the specified node or below it in the connection hierarchy.
 *
 *	Formal Parameters
 *		node_id - 	Node ID of node to clear from Node Record list
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured
 *		GCC_INVALID_PARAMETER	-	The specified node ID is not associated
 *									with any records.
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
GCCError CAppRoster::ClearNodeRecordFromList(	UserID		node_id)
{
	GCCError					rc = GCC_NO_ERROR;
	APP_NODE_RECORD				*node_record;
	APP_RECORD  			    *lpAppRecData;
	//APP_CAP_ITEM				*lpAppCapData;
	CAppRecordList2				*lpAppRecDataList;

	DebugEntry(CAppRoster::ClearNodeRecordFromList);

	if (NULL != (node_record = m_NodeRecordList2.Find(node_id)))
	{
		//	Delete all the app_record_list entries.
		node_record->AppRecordList.Reset();
		while (NULL != (lpAppRecData = node_record->AppRecordList.Iterate()))
		{
			DeleteApplicationRecordData (lpAppRecData);
		}

		/*
		**	Delete the ListOfAppCapItemList2 entries.  Note that this
		**	list should not exists for detached nodes if the local applications
		**	cleanly unenroll with GCC.  This list should only exists for
		**	locally enrolled APEs.  We still check here just to make sure.
		*/
		if (! node_record->ListOfAppCapItemList2.IsEmpty())
		{
			//CAppCapItemList *lpAppCapDataList;

			m_fCapabilitiesHaveChanged = TRUE;

			node_record->ListOfAppCapItemList2.DeleteList();
		}
		
		//	Delete the sub_node list.
		node_record->SubNodeList2.Reset();
		while (NULL != (lpAppRecDataList = node_record->SubNodeList2.Iterate()))
		{
			//	Delete all the app_record_list entries.
			lpAppRecDataList->Reset();
			while (NULL != (lpAppRecData = lpAppRecDataList->Iterate()))
			{
				DeleteApplicationRecordData (lpAppRecData);
			}

			delete lpAppRecDataList;
		}
		
		//	Delete the collapsed capabilities list.
		if (! node_record->CollapsedCapList.IsEmpty())
		{
			m_fCapabilitiesHaveChanged = TRUE;
			node_record->CollapsedCapList.DeleteList();
		}

		//	Delete the rogoue wave reference to this roster record.
		delete node_record;
		m_NodeRecordList2.Remove(node_id);
	}
	else
		rc = GCC_INVALID_PARAMETER;
		
	return rc;
}


/*
 *	ApplicationRosterError	ClearNodeRecordList	()
 *
 *	Private Function Description
 *		This routine complete frees all memory associated with the roster
 *		record list and clears the list of all its entries.
 *
 *	Formal Parameters
 *		none
 *
 *	Return Value
 *		none
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		Currently this routine does not handle standard identifiers.
 */
void CAppRoster::ClearNodeRecordList(void)
{
	APP_NODE_RECORD					*lpAppNodeRec;
	APP_RECORD  				    *lpAppRecData;
	CAppRecordList2					*lpAppRecDataList;
	//APP_CAP_ITEM					*lpAppCapData;
	//CAppCapItemList					*lpAppCapDataList;

	DebugEntry(CAppRoster::ClearNodeRecordList);

	//	Delete all the records in the application roster.
	m_NodeRecordList2.Reset();
	while (NULL != (lpAppNodeRec = m_NodeRecordList2.Iterate()))
	{
		//	First delete all the app records at this node.
		lpAppNodeRec->AppRecordList.Reset();
		while (NULL != (lpAppRecData = lpAppNodeRec->AppRecordList.Iterate()))
		{
			DeleteApplicationRecordData(lpAppRecData);
		}

		//	Next delete all the sub node record list.
		lpAppNodeRec->SubNodeList2.Reset();
		while (NULL != (lpAppRecDataList = lpAppNodeRec->SubNodeList2.Iterate()))
		{
			lpAppRecDataList->Reset();
			while (NULL != (lpAppRecData = lpAppRecDataList->Iterate()))
			{
				DeleteApplicationRecordData(lpAppRecData);
			}
				
			//	Delete the rogue wave list holding the lists of sub nodes.
			delete lpAppRecDataList;
		}

		//	Delete the collapsed capabilities list.
		lpAppNodeRec->CollapsedCapList.DeleteList();

		//	Delete the list of capabilities list.
		lpAppNodeRec->ListOfAppCapItemList2.DeleteList();
		
		//	Now delete the node record
		delete	lpAppNodeRec;
	}
	
	m_NodeRecordList2.Clear();
}


/*
 *	GCCError		MakeCollapsedCapabilitiesList	()
 *
 *	Private Function Description
 *		This routine is responsible for applying the T.124 capabilities
 *		rules to create the collapsed capabilities list at this node.
 *		It iterates through all the capabilities at this node to create this
 *		collapsed list.
 *
 *	Formal Parameters
 *		none
 *
 *	Return Value
 *		GCC_NO_ERROR -	On success
 *		GCC_ALLOCATION_FAILURE - On resource error
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		Currently this routine does not handle standard identifiers.
 */
GCCError CAppRoster::MakeCollapsedCapabilitiesList(void)
{
	GCCError						rc = GCC_NO_ERROR;
	APP_CAP_ITEM					*lpAppCapData;
	APP_NODE_RECORD					*lpAppNodeRec;
	CAppCapItemList					*lpAppCapDataList;

	DebugEntry(CAppRoster::MakeCollapsedCapabilitiesList);

	//	First clear out the old capabilities list.
	m_CollapsedCapListForAllNodes.DeleteList();

	/*
	**	We now iterate through the capabilities at each node to create the
	**	new capabilities list. Note that we have to check for the collapsed
	**	capabilities list at each node as well as the list of capabilities list
	**	that represents all the different capabilities for each entity at a
	**	node.  Note that in this implementation it is not possible to have both
	**	a list of capabilities list and a collapsed capabilities list in the
	**	same roster record.
	*/
	m_NodeRecordList2.Reset();
	while (NULL != (lpAppNodeRec = m_NodeRecordList2.Iterate()))
	{
		/*
		**	First check the collapsed capabilities list. If entries exists
		**	then we don't have to worry about the list of list.
		*/
		if (! lpAppNodeRec->CollapsedCapList.IsEmpty())
		{
			lpAppNodeRec->CollapsedCapList.Reset();
			while (NULL != (lpAppCapData = lpAppNodeRec->CollapsedCapList.Iterate()))
			{
				rc = AddCapabilityToCollapsedList(lpAppCapData);
				if (GCC_NO_ERROR != rc)
				{
					goto MyExit; // break;
				}
			}
		}
		else
		if (! lpAppNodeRec->ListOfAppCapItemList2.IsEmpty())
		{
			//	Here we check the list of capabilities list.
			lpAppNodeRec->ListOfAppCapItemList2.Reset();
			while (NULL != (lpAppCapDataList = lpAppNodeRec->ListOfAppCapItemList2.Iterate()))
			{
				lpAppCapDataList->Reset();
				while (NULL != (lpAppCapData = lpAppCapDataList->Iterate()))
				{
					rc = AddCapabilityToCollapsedList(lpAppCapData);
					if (GCC_NO_ERROR != rc)
					{
						goto MyExit;
					}
				}
			}
		}
	}

	ASSERT(GCC_NO_ERROR == rc);

MyExit:

	return rc;
}


/*
 *	GCCError		AddCapabilityToCollapsedList	()
 *
 *	Private Function Description
 *		This is the routine that performs the rules that allow the capability
 *		to be collapsed into the collapsed list.
 *
 *	Formal Parameters
 *		new_capability		-	(i)	Add this capability to the collapsed list.
 *
 *	Return Value
 *		GCC_NO_ERROR	-	On success
 *		GCC_ALLOCATION_FAILURE - On resource error
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
GCCError CAppRoster::AddCapabilityToCollapsedList(APP_CAP_ITEM *new_capability)
{
	GCCError			rc = GCC_NO_ERROR;
	APP_CAP_ITEM		*pAppCapItem;

	DebugEntry(CAppRoster::AddCapabilityToCollapsedList);

	/*
	**	First determine if the capability already exists in the list.
	**	We must iterate through the complete list to determine if there
	**	is a matching capability id.
	*/
	m_CollapsedCapListForAllNodes.Reset();
	while (NULL != (pAppCapItem = m_CollapsedCapListForAllNodes.Iterate()))
	{
		if (*pAppCapItem->pCapID == *new_capability->pCapID)
		{
			pAppCapItem->cEntries += new_capability->cEntries;
			break;
		}
	}

	if (pAppCapItem == NULL)
	{
		DBG_SAVE_FILE_LINE
		pAppCapItem = new APP_CAP_ITEM(new_capability, &rc);
		if (NULL == pAppCapItem)
		{
			return GCC_ALLOCATION_FAILURE;
		}
		if (GCC_NO_ERROR != rc)
		{
			delete pAppCapItem;
			return rc;
		}

		m_CollapsedCapListForAllNodes.Append(pAppCapItem);
	}

	/*
	**	If the unsigned minimum or unsigned maximum rule is used perform the
	**	operation here.
	*/
	ASSERT(GCC_NO_ERROR == rc);
	if (new_capability->eCapType == GCC_UNSIGNED_MINIMUM_CAPABILITY)
	{
		if (new_capability->nUnsignedMinimum < pAppCapItem->nUnsignedMinimum)
		{
			pAppCapItem->nUnsignedMinimum = new_capability->nUnsignedMinimum;
		}
	}
	else if (new_capability->eCapType == GCC_UNSIGNED_MAXIMUM_CAPABILITY)
	{
		if (new_capability->nUnsignedMaximum > pAppCapItem->nUnsignedMaximum)
		{
			pAppCapItem->nUnsignedMaximum = new_capability->nUnsignedMaximum;
		}
	}

	return rc;
}


/*
 *	BOOL		DoCapabilitiesListMatch	()
 *
 *	Private Function Description
 *		This routine determines if the set of capabilities that were passed in
 *		match the set of internal capabilities associated with the record.
 *
 *	Formal Parameters
 *		node_id					-	(i)	Node ID of record that contains the
 *										capabilities to check.
 *		entity_id				-	(i)	Entity ID of record that contains the
 *										capbilities to check.
 *		number_of_capabilities	-	(i)	Number of capabilities in list to check.
 *		capabilities_list		-	(i)	"API" capabillities list to check
 *
 *	Return Value
 *		TRUE 	-	If capabillities list match
 *		FALSE 	- 	If capabillities list do NOT match
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
BOOL CAppRoster::DoCapabilitiesListMatch (	
							UserID						node_id,
							EntityID					entity_id,
							UINT						number_of_capabilities,
							PGCCApplicationCapability	* capabilities_list)
{
	BOOL    							rc = FALSE;
	CAppCapItemList						*pAppCapItemList;
	GCCError							error_value;
	APP_NODE_RECORD						*node_record;
	UINT								i;
	CCapIDContainer	                    *capability_id;

	DebugEntry(CAppRoster::DoCapabilitiesListMatch);

	if (NULL == (node_record = m_NodeRecordList2.Find(node_id)))
		return (FALSE);

	if (NULL == (pAppCapItemList = node_record->ListOfAppCapItemList2.Find(entity_id)))
	{
		/*
		**	If the record shows no capabilities and the number of passed
		**	in capabilities is zero than we got a match.
		*/
		return ((number_of_capabilities == 0) ? TRUE : FALSE);
	}
	else if (pAppCapItemList->GetCount() != number_of_capabilities)
	{
		return (FALSE);
	}


	/*
	**	If we have gotten this far we must iterate through the entire list to
	**	see if all the capabilities match.
	*/
	for (i = 0; i < number_of_capabilities; i++)
	{
		/*
		**	First we create a temporary ID to compare to the other
		**	capability IDs.
		*/
        DBG_SAVE_FILE_LINE
        capability_id = new CCapIDContainer(&capabilities_list[i]->capability_id, &error_value);
		if ((capability_id != NULL) && (error_value == GCC_NO_ERROR))
		{
			APP_CAP_ITEM			*lpAppCapData;

			//	Start with the return value equal to FALSE
			rc = FALSE;

			/*
			**	Now iterate through the complate internal capability
			**	list looking for a matching capability.
			*/
			pAppCapItemList->Reset();
			while (NULL != (lpAppCapData = pAppCapItemList->Iterate()))
			{
				if (*capability_id == *lpAppCapData->pCapID)
				{
					if (lpAppCapData->eCapType == capabilities_list[i]->capability_class.eType)
					{
						if (capabilities_list[i]->capability_class.eType ==
								GCC_UNSIGNED_MINIMUM_CAPABILITY)
						{
							if (capabilities_list[i]->capability_class.nMinOrMax ==
										lpAppCapData->nUnsignedMinimum)
							{
								rc = TRUE;
							}
						}
						else if (capabilities_list[i]->capability_class.eType ==
									GCC_UNSIGNED_MAXIMUM_CAPABILITY)
						{
							if (capabilities_list[i]->capability_class.nMinOrMax ==
										lpAppCapData->nUnsignedMaximum)
							{
								rc = TRUE;
							}
						}
						else
							rc = TRUE;
					}
					break;
				}
			}

			//	Delete the capability ID data
			capability_id->Release();

			if (rc == FALSE)
				break;
		}
		else
		{
		    if (NULL != capability_id)
		    {
		        capability_id->Release();
		    }
			break;
		}
	}

	return rc;
}

void CAppRosterList::DeleteList(void)
{
    CAppRoster *pAppRoster;
    while (NULL != (pAppRoster = Get()))
    {
        pAppRoster->Release();
    }
}



void CListOfAppCapItemList2::DeleteList(void)
{
    CAppCapItemList  *pAppCapItemList;
    while (NULL != (pAppCapItemList = Get()))
    {
        pAppCapItemList->DeleteList();
        delete pAppCapItemList;
    }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\h\userdata.h ===
/*
 *	userdata.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class CUserDataListContainer.  CUserDataListContainer
 *		objects are used to maintain user data elements. A user data element
 *		consists of an Object Key and an optional octet string.  The Object
 *		Key data is maintained internally by this class by using an
 *		CObjectKeyContainer container.  The optional octet string data is maintained
 *		internally through the use of a Rogue Wave string container.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */
#ifndef	_USER_DATA_LIST__
#define	_USER_DATA_LIST__

#include "objkey.h"

/*
 * This is the typedef for the structure used to maintain the list of user
 * data internally.
 */
typedef struct USER_DATA
{
	~USER_DATA(void);

    CObjectKeyContainer		    *key;
	LPOSTR						poszOctetString;
}
    USER_DATA;

/*
 * These are the typedefs for the Rogue Wave list which is used to hold the 
 * USER_DATA structures and the iterator for the list.
 */
class CUserDataList : public CList
{
    DEFINE_CLIST(CUserDataList, USER_DATA*)
};

/*
 * Class definition:
 */
class CUserDataListContainer : public CRefCount
{
public:

    CUserDataListContainer(UINT cMembers, PGCCUserData *, PGCCError);
    CUserDataListContainer(CUserDataListContainer *, PGCCError);
    CUserDataListContainer(PSetOfUserData, PGCCError);
    ~CUserDataListContainer(void);

	UINT	    LockUserDataList(void);
	void	    UnLockUserDataList(void);

	UINT	    GetUserDataList(USHORT *pcMembers, PGCCUserData**, LPBYTE pMemory);
	UINT        GetUserDataList(UINT *pcMembers, PGCCUserData** pppUserData, LPBYTE pMemory)
	{
	    *pcMembers = 0;
	    return GetUserDataList((USHORT *) pcMembers, pppUserData, pMemory);
	}

	GCCError	GetUserDataPDU(PSetOfUserData *);
	void		FreeUserDataListPDU(void);

protected:

	CUserDataList   		m_UserDataItemList;
	UINT					m_cbDataSize;

	PSetOfUserData			m_pSetOfUserDataPDU;

private:

	GCCError    CopyUserDataList(UINT cMembers, PGCCUserData *);
	GCCError    UnPackUserDataFromPDU(PSetOfUserData);
	GCCError    ConvertPDUDataToInternal(PSetOfUserData);
	GCCError    ConvertUserDataInfoToPDUUserData(USER_DATA *, PSetOfUserData);
};

/*
 *	Comments explaining the public and protected class member functions
 */

/*
 *	CUserDataListContainer (	UINT					number_of_members,
 *				PGCCUserData	*		user_data_list,
 *				PGCCError				return_value);
 *
 *	Public member function of CUserDataListContainer.
 *
 *	Function Description:
 *		This CUserDataListContainer constructor is used to create a CUserDataListContainer object
 *		from "API" data.  The constructor immediately copies the user data 
 *		passed in as a list of "GCCUserData" structures into it's internal form
 *		where a Rogue Wave container holds the data in the form of 
 *		USER_DATA structures.
 *
 *	Formal Parameters:
 *		number_of_members	(i) The number of elements in the user data list.
 *		user_datalist		(i)	The list holding the user data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_USER_DATA				-	The user data passed in contained
 *												an invalid object key.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	CUserDataListContainer (	PSetOfUserData			set_of_user_data,
 *					PGCCError				return_value);
 *
 *	Public member function of CUserDataListContainer.
 *
 *	Function Description:
 *		This CUserDataListContainer constructor is used to create a CUserDataListContainer object 
 *		from data passed in as a "PDU" SetOfUserData structure.  The user
 *		data is copied into it's internal form where a Rogue Wave container 
 *		holds the data in the form of USER_DATA structures.
 *
 *	Formal Parameters:
 *		set_of_user_data	(i)	The structure holding the "PDU" user data
 *									to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator or else an
 *												invalid object key PDU was
 *												received.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	CUserDataListContainer(CUserDataListContainer *user_data, PGCCError return_value);
 *
 *	Public member function of CUserDataListContainer.
 *
 *	Function Description:
 *		This is the copy constructor for the CUserDataListContainer class which takes
 *		as input another CUserDataListContainer object.
 *
 *	Formal Parameters:
 *		user_data			(i)	The CUserDataListContainer object to copy.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_OBJECT_KEY				-	An invalid CUserDataListContainer passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	~CUserDataListContainer();
 *
 *	Public member function of CUserDataListContainer.
 *
 *	Function Description:
 *		This is the destructor for the CUserDataListContainer class.  It is used to
 *		clean up any memory allocated during the life of this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	UINT			LockUserDataList ();
 *
 *	Public member function of CUserDataListContainer.
 *
 *	Function Description:
 *		This routine is used to "lock" the "API" data for this object.  This
 *		results in the lock count for this object being incremented.  When the
 *		lock count transitions from 0 to 1, a calculation is made to determine
 *		how much memory will be needed to hold any "API" data which will
 *		be referenced by, but not held in, the GCCUserData structure
 *		which is filled in on a call to GetUserDataList.  This is the
 *		value returned by this routine in order to allow the calling object to
 *		allocate that amount of memory in preparation for the call to 
 *		GetUserDataList.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The amount of memory which will be needed to hold "API" data
 *		which is referenced by, but not held in, the GCCUserData structure
 *		provided as an output parameter to the GetUserDataList call.
 *
 *  Side Effects:
 *		The internal lock count is incremented.
 *
 *	Caveats:
 *		The internal lock count is used in conjuction with an internal "free" 
 *		flag as a mechanism for ensuring that this object remains in existance 
 *		until all interested parties are through with it.  The object remains 
 *		valid (unless explicity deleted) until the lock count is zero and the 
 *		"free" flag is set through a call to FreeUserDataList.  This allows
 *		other objects to lock this object and be sure that it remains valid 
 *		until they call UnLock which will decrement the internal lock count.  A
 *		typical usage scenerio for this object would be:  A CUserDataListContainer
 *		object is constructed and then passed off to any interested parties
 *		through a function call.  On return from the function call, the
 *		FreeUserDataList call is made which will set the internal "free"
 *		flag.  If no other parties have locked the object with a Lock call,
 *		then the CUserDataListContainer object will automatically delete itself when
 *		the FreeUserDataList call is made.  If, however, any number of 
 *		other parties has locked the object, it will remain in existence until
 *		each of them has unlocked the object through a call to UnLock.
 */
/*
 *	UINT	GetUserDataList (	USHORT					*number_of_members,
 *								PGCCUserData	**		user_data_list,
 *								LPSTR					memory);
 *
 *	Public member function of CUserDataListContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the user data from the
 *		CUserDataListContainer object in the "API" form of a GCCUserData list.
 *
 *	Formal Parameters:
 *		number_of_members	(o) The number of elements in the user data list.
 *		user_data			(o)	The list of GCCUserData structures to fill in.
 *		memory				(o)	The memory used to hold any data referenced by,
 *									but not held in, the output structures.
 *
 *	Return Value:
 *		The amount of data, if any, written into the bulk memory block provided.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	void			UnLockUserDataList ();
 *
 *	Public member function of CUserDataListContainer.
 *
 *	Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine 
 *		whether the object has been freed through a call to 
 *		FreeUserDataList.  If so, the object will automatically delete
 *		itself.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal lock count is decremented.
 *
 *	Caveats:
 *		It is the responsibility of any party which locks a CUserDataListContainer
 *		object by calling Lock to also unlock the object with a call to UnLock.
 *		If the party calling UnLock did not construct the CUserDataListContainer 
 *		object,	it should assume the object to be invalid thereafter.
 */
/*
 *	void			FreeUserDataList ();
 *
 *	Public member function of CUserDataListContainer.
 *
 *	Function Description:
 *		This routine is used to "free" the "API" data for this object.  This 
 *		will result in the automatic deletion of this object if the object is
 *		not in the "locked" state.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal "free" flag is set.
 *
 *	Caveats:
 *		This object should be assumed invalid after a call to 
 *		FreeUserDataList has been made.
 */
/*
 *	GCCError	GetUserDataPDU (	PSetOfUserData	*		set_of_user_data);
 *
 *	Public member function of CUserDataListContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the user data from the
 *		CUserDataListContainer object in the "PDU" form of a SetOfUserData.
 *
 *	Formal Parameters:
 *		set_of_user_data		(o)	The SetOfUserData structure to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator or else an
 *												internal pointer has been
 *												corrupted.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	void		FreeUserDataListPDU ();
 *
 *	Public member function of CUserDataListContainer.
 *
 *	Function Description:
 *		This routine is used to "free" the "PDU" data allocated for this object
 *		which is held internally in a SetOfUserData structure.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal "free" flag is set.
 *
 *	Caveats:
 *		This object should be assumed invalid after a call to 
 *		FreeUserDataListPDU has been made.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\appsap.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_SAP);
/*
 *	appsap.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *
 *	Protected Instance Variables:
 *		None.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */

#include "appsap.h"
#include "conf.h"
#include "gcontrol.h"


GCCError WINAPI GCC_CreateAppSap(IGCCAppSap **ppIAppSap, LPVOID pUserData, LPFN_APP_SAP_CB pfnCallback)
{
    GCCError rc;

    if (NULL != ppIAppSap && NULL != pfnCallback)
    {
        if (NULL != g_pGCCController)
        {
            DBG_SAVE_FILE_LINE
            if (NULL != (*ppIAppSap = (IGCCAppSap *) new CAppSap(pUserData, pfnCallback, &rc)))
            {
                if (GCC_NO_ERROR != rc)
                {
                    (*ppIAppSap)->ReleaseInterface(); // free the interface in case of error
                }
            }
            else
            {
                ERROR_OUT(("GCC_CreateAppSap: can't create IAppSap."));
                rc = GCC_ALLOCATION_FAILURE;
            }
        }
        else
        {
            WARNING_OUT(("GCC_CreateAppSap: GCC Provider is not initialized."));
            rc = GCC_NOT_INITIALIZED;
        }
    }
    else
    {
        ERROR_OUT(("GCC_CreateAppSap: either or both pointers are null"));
        rc = GCC_INVALID_PARAMETER;
    }

    return rc;
}


/*
 * Macros defining the number of handles which may be allocated.
 */
#define		MINIMUM_NUMBER_OF_ALLOCATED_HANDLES		1
#define		MAXIMUM_NUMBER_OF_ALLOCATED_HANDLES		1024

/*
 *	CAppSap()
 *
 *	Public Function Description:
 *		This is the constructor for the CAppSap class.  It initializes instance
 *		variables and registers with the new application.
 */
CAppSap::
CAppSap
(
    LPVOID              pAppData,
    LPFN_APP_SAP_CB     pfnCallback,
    PGCCError           pRetCode
)
:
    CBaseSap(MAKE_STAMP_ID('A','S','a','p')),
    m_pAppData(pAppData),
    m_pfnCallback(pfnCallback)
{
    ASSERT(NULL != pfnCallback);
    ASSERT(NULL != g_pGCCController);

    //
    // We just created a window in the constructor of CBaseSap.
    // Double check the window is created successfully.
    //
    if (NULL != m_hwndNotify)
    {
        //
        // Make sure the gcc provider does not go away randomly.
        //
        ::EnterCriticalSection(&g_csGCCProvider);
        g_pGCCController->AddRef();
        g_pGCCController->RegisterAppSap(this);
        ::LeaveCriticalSection(&g_csGCCProvider);

        *pRetCode = GCC_NO_ERROR;
    }
    else
    {
        ERROR_OUT(("CAppSap::CAppSap: can't create window, win32_err=%u", ::GetLastError()));
        *pRetCode = GCC_ALLOCATION_FAILURE;
    }
}


/*
 *	~AppSap ()
 *
 *	Public Function Description:
 *		This is the destructor for the CAppSap class.  It is called when the 
 *		controller marks the CAppSap to be deleted.  This occurs when either
 *		the CAppSap asks to be deleted due to an "unregister request" 
 *		issued from the client application, or when there is an error
 *		condition in the CAppSap.
 */
CAppSap::
~CAppSap ( void )
{
    //
    // LONCHANC: This Release() must be outside of the GCC critical section
    // because the GCC Controller can delete this critical section in
    // its destructor.
    //
    g_pGCCController->Release();
}


void CAppSap::
ReleaseInterface ( void )
{
    ASSERT(NULL != g_pGCCController);

    //
    // It is ok for the gcc provider to go away now.
    //
    ::EnterCriticalSection(&g_csGCCProvider);
    g_pGCCController->UnRegisterAppSap(this);
    ::LeaveCriticalSection(&g_csGCCProvider);

    //
    // Reset the app related data
    //
    m_pAppData = NULL;
    m_pfnCallback = NULL;

    //
    // Remove any message in the queue.
    //
    PurgeMessageQueue();

    //
    // Release this object now.
    //
    Release();
}


void CAppSap::
PostAppSapMsg ( GCCAppSapMsgEx *pAppSapMsgEx )
{
    ASSERT(NULL != m_hwndNotify);
    ::PostMessage(m_hwndNotify,
                  ASAPMSG_BASE + (UINT) pAppSapMsgEx->Msg.eMsgType,
                  (WPARAM) pAppSapMsgEx,
                  (LPARAM) this);
}


/*
 *	AppEnroll()
 *
 *	Public Function Description:
 *		This routine is called when an application wants to enroll in a 
 *		conference.  The controller is notified of the enrollment request.
 */
GCCError CAppSap::
AppEnroll
(
    GCCConfID           nConfID,
    GCCEnrollRequest    *pReq,
    GCCRequestTag       *pnReqTag
)
{
    GCCError    rc;
    CConf       *pConf;

    DebugEntry(CAppSap::AppEnroll);

    // sanity check
    if (NULL == pReq || NULL == pnReqTag)
    {
        rc = GCC_INVALID_PARAMETER;
        goto MyExit;
    }

    TRACE_OUT_EX(ZONE_T120_APP_ROSTER,
            ("CAppSap::AppEnroll: confID=%u, enrolled?=%u, active?=%u\r\n",
            (UINT) nConfID, (UINT) pReq->fEnroll, (UINT) pReq->fEnrollActively));

    // create the request id
    *pnReqTag = GenerateRequestTag();

    // find the corresponding conference
    if (NULL == (pConf = g_pGCCController->GetConfObject(nConfID)))
    {
        rc = GCC_INVALID_CONFERENCE;
        goto MyExit;
    }

	// check to make sure that the application has a valid uid and
	// session key if it is enrolling.
	if (pReq->fEnroll)
	{
		if (pReq->fEnrollActively)
		{
			if (pReq->nUserID < MINIMUM_USER_ID_VALUE)
			{
				rc = GCC_INVALID_MCS_USER_ID;
				goto MyExit;
			}
		}
		else if (pReq->nUserID < MINIMUM_USER_ID_VALUE)
		{
			// we must make sure that this is zero if it is invalid and
			// the user is enrolling inactively.
			pReq->nUserID = GCC_INVALID_UID;
		}

		if (NULL == pReq->pSessionKey)
		{
			rc = GCC_BAD_SESSION_KEY;
			goto MyExit;
		}
	}

    ::EnterCriticalSection(&g_csGCCProvider);
    rc = pConf->AppEnrollRequest(this, pReq, *pnReqTag);
    ::LeaveCriticalSection(&g_csGCCProvider);

MyExit:

    DebugExitINT(CAppSap::AppEnroll, rc);
    return rc;
}


GCCError CAppSap::
AppInvoke
(
    GCCConfID                 nConfID,
    GCCAppProtEntityList      *pApeList,
    GCCSimpleNodeList         *pNodeList,
    GCCRequestTag             *pnReqTag
)
{
    return CBaseSap::AppInvoke(nConfID, pApeList, pNodeList, pnReqTag);
}


GCCError CAppSap::
AppRosterInquire
(
    GCCConfID                  nConfID,
    GCCSessionKey              *pSessionKey,
    GCCAppSapMsg               **ppMsg
)
{
    return CBaseSap::AppRosterInquire(nConfID, pSessionKey, (GCCAppSapMsgEx **) ppMsg);
}


BOOL CAppSap::
IsThisNodeTopProvider ( GCCConfID nConfID )
{
    return CBaseSap::IsThisNodeTopProvider(nConfID);
}


GCCNodeID CAppSap::
GetTopProvider ( GCCConfID nConfID )
{
    return CBaseSap::GetTopProvider(nConfID);
}


GCCError CAppSap::
ConfRosterInquire(GCCConfID nConfID, GCCAppSapMsg **ppMsg)
{
    return CBaseSap::ConfRosterInquire(nConfID, (GCCAppSapMsgEx **) ppMsg);
}


GCCError CAppSap::
ConductorInquire ( GCCConfID nConfID )
{
    return CBaseSap::ConductorInquire(nConfID);
}


/*
 *	RegisterChannel()
 *
 *	Public Function Description:
 *		This routine is called when an application wishes to register a 
 *		channel.  The call is routed to the appropriate conference object.
 */
GCCError CAppSap::
RegisterChannel
(
    GCCConfID           nConfID,
    GCCRegistryKey      *pRegKey,
    ChannelID           nChnlID
)
{
	GCCError    rc;
	CConf       *pConf;

    DebugEntry(CAppSap::RegisterChannel);

    if (NULL == pRegKey)
    {
        rc = GCC_INVALID_PARAMETER;
        goto MyExit;
    }

    /*
	**	If the desired conference exists, call it in order to register the
	**	channel.  Report an error if the desired conference does not exist.
	*/
	if (NULL == (pConf = g_pGCCController->GetConfObject(nConfID)))
	{
        WARNING_OUT(("CAppSap::RegisterChannel: invalid conf id=%u", (UINT) nConfID));
		rc = GCC_INVALID_CONFERENCE;
        goto MyExit;
    }

    ::EnterCriticalSection(&g_csGCCProvider);
    rc = (nChnlID != 0) ? pConf->RegistryRegisterChannelRequest(pRegKey, nChnlID, this) :
                          GCC_INVALID_CHANNEL;
    ::LeaveCriticalSection(&g_csGCCProvider);
    if (GCC_NO_ERROR != rc)
    {
        ERROR_OUT(("CAppSap::RegisterChannel: can't register channel, rc=%u", (UINT) rc));
        // goto MyExit;
    }

MyExit:

    DebugExitINT(CAppSap::RegisterChannel, rc);
	return rc;
}


/*
 *	RegistryAssignToken()
 *
 *	Public Function Description:
 *		This routine is called when an application wishes to assign a 
 *		token.  The call is routed to the appropriate conference object.
 */
GCCError CAppSap::
RegistryAssignToken
(
    GCCConfID           nConfID,
    GCCRegistryKey      *pRegKey
)
{
	GCCError    rc;
	CConf       *pConf;

    DebugEntry(CAppSap::RegistryAssignToken);

    if (NULL == pRegKey)
    {
        rc = GCC_INVALID_PARAMETER;
        goto MyExit;
    }

	/*
	**	If the desired conference exists, call it in order to assign the
	**	token.  Report an error if the desired conference does not exist.
	*/
	if (NULL == (pConf = g_pGCCController->GetConfObject(nConfID)))
	{
        WARNING_OUT(("CAppSap::RegistryAssignToken: invalid conf id=%u", (UINT) nConfID));
		rc = GCC_INVALID_CONFERENCE;
        goto MyExit;
    }

    ::EnterCriticalSection(&g_csGCCProvider);
    rc = pConf->RegistryAssignTokenRequest(pRegKey, this);
    ::LeaveCriticalSection(&g_csGCCProvider);
    if (GCC_NO_ERROR != rc)
    {
        ERROR_OUT(("CAppSap::RegistryAssignToken: can't assign token, rc=%u", (UINT) rc));
        // goto MyExit;
    }

MyExit:

    DebugExitINT(CAppSap::RegistryAssignToken, rc);
	return rc;
}

/*
 *	RegistrySetParameter()
 *
 *	Public Function Description:
 *		This routine is called when an application wishes to set a 
 *		parameter.  The call is routed to the appropriate conference object.
 */
GCCError CAppSap::
RegistrySetParameter
(
    GCCConfID              nConfID,
    GCCRegistryKey         *pRegKey,
    LPOSTR                 poszParameter,
    GCCModificationRights  eRights
)
{
	GCCError    rc;
	CConf       *pConf;

    DebugEntry(CAppSap::RegistrySetParameter);

    if (NULL == pRegKey || NULL == poszParameter)
    {
        rc = GCC_INVALID_PARAMETER;
        goto MyExit;
    }

	/*
	**	If the desired conference exists, call it in order to set the
	**	parameter.  Report an error if the desired conference does not exist.
	*/
	if (NULL == (pConf = g_pGCCController->GetConfObject(nConfID)))
	{
        WARNING_OUT(("CAppSap::RegistrySetParameter: invalid conf id=%u", (UINT) nConfID));
		rc = GCC_INVALID_CONFERENCE;
        goto MyExit;
    }

    switch (eRights)
    {
    case GCC_OWNER_RIGHTS:
    case GCC_SESSION_RIGHTS:
    case GCC_PUBLIC_RIGHTS:
    case GCC_NO_MODIFICATION_RIGHTS_SPECIFIED:
        ::EnterCriticalSection(&g_csGCCProvider);
        rc = pConf->RegistrySetParameterRequest(pRegKey, poszParameter, eRights, this);
        ::LeaveCriticalSection(&g_csGCCProvider);
        if (GCC_NO_ERROR != rc)
        {
            ERROR_OUT(("CAppSap::RegistrySetParameter: can't set param, rc=%u", (UINT) rc));
            // goto MyExit;
        }
        break;
    default:
        rc = GCC_INVALID_MODIFICATION_RIGHTS;
        break;
	}

MyExit:

    DebugExitINT(CAppSap::RegistrySetParameter, rc);
	return rc;
}

/*
 *	RegistryRetrieveEntry()
 *
 *	Public Function Description:
 *		This routine is called when an application wishes to retrieve a registry 
 *		entry.  The call is routed to the appropriate conference object.
 */
GCCError CAppSap::
RegistryRetrieveEntry
(
    GCCConfID           nConfID,
    GCCRegistryKey      *pRegKey
)
{
	GCCError    rc;
	CConf       *pConf;

    DebugEntry(CAppSap::RegistryRetrieveEntry);

    if (NULL == pRegKey)
    {
        rc = GCC_INVALID_PARAMETER;
        goto MyExit;
    }

	/*
	**	If the desired conference exists, call it in order to retrieve the
	**	registry entry.  Report an error if the desired conference does not 
	**	exist.
	*/
	if (NULL == (pConf = g_pGCCController->GetConfObject(nConfID)))
	{
        WARNING_OUT(("CAppSap::RegistryRetrieveEntry: invalid conf id=%u", (UINT) nConfID));
		rc = GCC_INVALID_CONFERENCE;
        goto MyExit;
    }

    ::EnterCriticalSection(&g_csGCCProvider);
	rc = pConf->RegistryRetrieveEntryRequest(pRegKey, this);
    ::LeaveCriticalSection(&g_csGCCProvider);
    if (GCC_NO_ERROR != rc)
    {
        ERROR_OUT(("CAppSap::RegistryRetrieveEntry: can't retrieve entry, rc=%u", (UINT) rc));
        // goto MyExit;
    }

MyExit:

    DebugExitINT(CAppSap::RegistryRetrieveEntry, rc);
	return rc;
}

/*
 *	RegistryDeleteEntry()
 *
 *	Public Function Description:
 *		This routine is called when an application wishes to delete a registry 
 *		entry.  The call is routed to the appropriate conference object.
 */
GCCError CAppSap::
RegistryDeleteEntry
(
    GCCConfID           nConfID,
    GCCRegistryKey      *pRegKey
)
{
	GCCError    rc;
	CConf       *pConf;

    DebugEntry(IAppSap::RegistryDeleteEntry);

    if (NULL == pRegKey)
    {
		ERROR_OUT(("CAppSap::RegistryDeleteEntry: null pRegKey"));
        rc = GCC_INVALID_PARAMETER;
        goto MyExit;
    }

	/*
	**	If the desired conference exists, call it in order to delete the
	**	desired registry entry.  Report an error if the desired conference does
	**	not exist.
	*/
	if (NULL == (pConf = g_pGCCController->GetConfObject(nConfID)))
	{
        TRACE_OUT(("CAppSap::RegistryDeleteEntry: invalid conf id=%u", (UINT) nConfID));
		rc = GCC_INVALID_CONFERENCE;
        goto MyExit;
    }

    ::EnterCriticalSection(&g_csGCCProvider);
	rc = pConf->RegistryDeleteEntryRequest(pRegKey, this);
    ::LeaveCriticalSection(&g_csGCCProvider);
    if (GCC_NO_ERROR != rc)
    {
        WARNING_OUT(("CAppSap::RegistryDeleteEntry: can't delete entry, rc=%u", (UINT) rc));
        // goto MyExit;
    }

MyExit:

    DebugExitINT(CAppSap::RegistryDeleteEntry, rc);
	return rc;
}

/*
 *	RegistryMonitor()
 *
 *	Public Function Description:
 *		This routine is called when an application wishes to monitor a 
 *		particular registry entry.  The call is routed to the appropriate 
 *		conference object.
 */
GCCError CAppSap::
RegistryMonitor
(
    GCCConfID           nConfID,
    BOOL                fEnalbeDelivery,
    GCCRegistryKey      *pRegKey
)
{
	GCCError    rc;
	CConf       *pConf;

    DebugEntry(IAppSap::RegistryMonitor);

    if (NULL == pRegKey)
    {
        rc = GCC_INVALID_PARAMETER;
        goto MyExit;
    }

	/*
	**	If the desired conference exists, call it in order to monitor the
	**	appropriate registry entry.  Report an error if the desired conference
	**	does not exist.
	*/
	if (NULL == (pConf = g_pGCCController->GetConfObject(nConfID)))
	{
        WARNING_OUT(("CAppSap::RegistryMonitor: invalid conf id=%u", (UINT) nConfID));
		rc = GCC_INVALID_CONFERENCE;
        goto MyExit;
    }

    ::EnterCriticalSection(&g_csGCCProvider);
	rc = pConf->RegistryMonitorRequest(fEnalbeDelivery, pRegKey, this);
    ::LeaveCriticalSection(&g_csGCCProvider);
    if (GCC_NO_ERROR != rc)
    {
        ERROR_OUT(("CAppSap::RegistryMonitor: can't monitor the registry, rc=%u", (UINT) rc));
        // goto MyExit;
    }

MyExit:

    DebugExitINT(CAppSap::RegistryMonitor, rc);
	return rc;
}

/*
 *	RegistryAllocateHandle()
 *
 *	Public Function Description:
 *		This routine is called when an application wishes to allocate one or 
 *		more handles.  The call is routed to the appropriate conference object.
 */
GCCError CAppSap::
RegistryAllocateHandle
(
    GCCConfID           nConfID,
    ULONG               cHandles
)
{
	GCCError    rc;
	CConf       *pConf;

    DebugEntry(CAppSap::RegistryAllocateHandle);

	/*
	**	If the desired conference exists, call it in order to allocate the
	**	handle(s).  Report an error if the desired conference does not exist or
	**	if the number of handles wishing to be allocated is not within the
	**	allowable range.
	*/
	if (NULL == (pConf = g_pGCCController->GetConfObject(nConfID)))
	{
        WARNING_OUT(("CAppSap::RegistryAllocateHandle: invalid conf id=%u", (UINT) nConfID));
		rc = GCC_INVALID_CONFERENCE;
        goto MyExit;
    }

    ::EnterCriticalSection(&g_csGCCProvider);
	rc = ((cHandles >= MINIMUM_NUMBER_OF_ALLOCATED_HANDLES) &&
          (cHandles <= MAXIMUM_NUMBER_OF_ALLOCATED_HANDLES)) ?
            pConf->RegistryAllocateHandleRequest(cHandles, this) :
            GCC_BAD_NUMBER_OF_HANDLES;
    ::LeaveCriticalSection(&g_csGCCProvider);
    if (GCC_NO_ERROR != rc)
    {
        ERROR_OUT(("CAppSap::RegistryAllocateHandle: can't allocate handles, cHandles=%u, rc=%u", (UINT) cHandles, (UINT) rc));
        // goto MyExit;
    }

MyExit:

    DebugExitINT(CAppSap::RegistryAllocateHandle, rc);
    return rc;
}

/*
 *	The following routines are all Command Target Calls
 */
 
/*
 *	PermissionToEnrollIndication ()
 *
 *	Public Function Description:
 *		This routine is called by the Controller when it wishes to send an
 *		indication to the user application notifying it of a "permission to 
 *		enroll" event.  This does not mean that permission to enroll is
 *		necessarily granted to the application.
 */
GCCError CAppSap::
PermissionToEnrollIndication
(
    GCCConfID           nConfID,
    BOOL                fGranted
)
{
    GCCError rc;

    DebugEntry(CAppSap: PermissionToEnrollIndication);
    TRACE_OUT_EX(ZONE_T120_APP_ROSTER, ("CAppSap::PermissionToEnrollIndication: "
                    "confID=%u, granted?=%u\r\n",
                    (UINT) nConfID, (UINT) fGranted));

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(GCC_PERMIT_TO_ENROLL_INDICATION);
    if (NULL != pMsgEx)
    {
        pMsgEx->Msg.nConfID = nConfID;
        pMsgEx->Msg.AppPermissionToEnrollInd.nConfID = nConfID;
        pMsgEx->Msg.AppPermissionToEnrollInd.fPermissionGranted = fGranted;
        PostAppSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
    }
    else
    {
        ERROR_OUT(("CAppSap: PermissionToEnrollIndication: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
    }

    DebugExitINT(CAppSap: PermissionToEnrollIndication, rc);
    return rc;
}

/*
 *	AppEnrollConfirm ()
 *
 *	Public Function Description:
 *		This routine is called by the CConf object when it wishes
 *		to send an enrollment confirmation to the user application.
 */
GCCError CAppSap::
AppEnrollConfirm ( GCCAppEnrollConfirm *pConfirm )
{
    GCCError rc;

    DebugEntry(CAppSap::AppEnrollConfirm);

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(GCC_ENROLL_CONFIRM);
    if (NULL != pMsgEx)
    {
        pMsgEx->Msg.nConfID = pConfirm->nConfID;
        pMsgEx->Msg.AppEnrollConfirm = *pConfirm;

        PostAppSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
    }
    else
    {
        ERROR_OUT(("CAppSap::AppEnrollConfirm: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
    }

    DebugExitINT(CAppSap: AppEnrollConfirm, rc);
    return rc;
}

/*
 *	RegistryConfirm ()
 *
 *	Public Function Description:
 *		This command target routine is called by the CConf object when it
 *		wishes to send an registry confirmation to the user application.
 */
GCCError CAppSap::
RegistryConfirm
(
    GCCConfID               nConfID,
    GCCMessageType          eMsgType,
    CRegKeyContainer        *pRegKey,
    CRegItem                *pRegItem,
    GCCModificationRights   eRights,
    GCCNodeID               nidOwner,
    GCCEntityID             eidOwner,
    BOOL                    fDeliveryEnabled,
    GCCResult               nResult
)
{
    GCCError                rc;

    DebugEntry(CAppSap::RegistryConfirm);

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(eMsgType);
    if (NULL == pMsgEx)
    {
        ERROR_OUT(("CAppSap::RegistryConfirm: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
        goto MyExit;
    }

    pMsgEx->Msg.nConfID = nConfID;

    if (NULL != pRegKey)
    {
        rc = pRegKey->CreateRegistryKeyData(&(pMsgEx->Msg.RegistryConfirm.pRegKey));
        if (GCC_NO_ERROR != rc)
        {
            ERROR_OUT(("CAppSap::RegistryConfirm: can't get registry key data, rc=%u", (UINT) rc));
            goto MyExit;
        }
    }

    if (NULL != pRegItem)
    {
        rc = pRegItem->CreateRegistryItemData(&(pMsgEx->Msg.RegistryConfirm.pRegItem));
        if (GCC_NO_ERROR != rc)
        {
            ERROR_OUT(("CAppSap::RegistryConfirm: can't get registry item data, rc=%u", (UINT) rc));
            goto MyExit;
        }
    }

    if (GCC_INVALID_NID != nidOwner)
    {
        pMsgEx->Msg.RegistryConfirm.EntryOwner.entry_is_owned = TRUE;
        pMsgEx->Msg.RegistryConfirm.EntryOwner.owner_node_id = nidOwner;
        pMsgEx->Msg.RegistryConfirm.EntryOwner.owner_entity_id = eidOwner;
    }

    pMsgEx->Msg.RegistryConfirm.nConfID = nConfID;
    pMsgEx->Msg.RegistryConfirm.eRights = eRights;
    pMsgEx->Msg.RegistryConfirm.nResult = nResult;
    pMsgEx->Msg.RegistryConfirm.fDeliveryEnabled = fDeliveryEnabled; // for monitor only

    PostAppSapMsg(pMsgEx);
    rc = GCC_NO_ERROR;

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        delete pMsgEx;
    }

    DebugExitINT(CAppSap::RegistryConfirm, rc);
    return rc;
}


/*
 *	RegistryMonitorIndication()
 *
 *	Public Function Description
 *		This command target routine is called by the CConf object when it
 *		wishes to send a Registry monitor indication to the user application.
 */


/*
 *	RegistryAllocateHandleConfirm()
 *
 *	Public Function Description:
 *		This command target routine is called by the CConf object when it
 *		wishes to send a handle allocation confirmation to the user application.
 */
GCCError CAppSap::
RegistryAllocateHandleConfirm
(
    GCCConfID       nConfID,
    ULONG           cHandles,
    ULONG           nFirstHandle,
    GCCResult       nResult
)
{
    GCCError                     rc;

    DebugEntry(CAppSap::RegistryAllocateHandleConfirm);

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(GCC_ALLOCATE_HANDLE_CONFIRM);
    if (NULL != pMsgEx)
    {
        pMsgEx->Msg.nConfID = nConfID;
        pMsgEx->Msg.RegAllocHandleConfirm.nConfID = nConfID;
        pMsgEx->Msg.RegAllocHandleConfirm.cHandles = cHandles;
        pMsgEx->Msg.RegAllocHandleConfirm.nFirstHandle = nFirstHandle;
        pMsgEx->Msg.RegAllocHandleConfirm.nResult = nResult;

        PostAppSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
    }
    else
    {
        ERROR_OUT(("CAppSap::RegistryAllocateHandleConfirm: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
    }

    DebugExitINT(CAppSap::RegistryAllocateHandleConfirm, rc);
    return rc;
}



void CAppSapList::
DeleteList ( void )
{
    CAppSap *pAppSap;
    while (NULL != (pAppSap = Get()))
    {
        pAppSap->Release();
    }
}


void CAppSapEidList2::
DeleteList ( void )
{
    CAppSap *pAppSap;
    while (NULL != (pAppSap = Get()))
    {
        pAppSap->Release();
    }
}


/* 
 *	ConfRosterInquireConfirm()
 *
 *	Public Function Description
 *		This routine is called in order to return a requested conference
 *		roster to an application or the node controller.
 */
GCCError CAppSap::
ConfRosterInquireConfirm
(
    GCCConfID                   nConfID,
    PGCCConferenceName          pConfName,
    LPSTR                       pszConfModifier,
    LPWSTR                      pwszConfDescriptor,
    CConfRoster                 *pConfRoster,
    GCCResult                   nResult,
    GCCAppSapMsgEx              **ppMsgExToRet
)
{
    GCCError  rc;
    BOOL      fLock = FALSE;
    UINT      cbDataSize;

    DebugEntry(CAppSap::ConfRosterInquireConfirm);

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(GCC_ROSTER_INQUIRE_CONFIRM);
    if (NULL == pMsgEx)
    {
        ERROR_OUT(("CAppSap::ConfRosterInquireConfirm: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
        goto MyExit;
    }

    pMsgEx->Msg.nConfID = nConfID;

    pMsgEx->Msg.ConfRosterInquireConfirm.nConfID = nConfID;
    pMsgEx->Msg.ConfRosterInquireConfirm.nResult = nResult;
    pMsgEx->Msg.ConfRosterInquireConfirm.ConfName.numeric_string = ::My_strdupA(pConfName->numeric_string);
    pMsgEx->Msg.ConfRosterInquireConfirm.ConfName.text_string = ::My_strdupW(pConfName->text_string);
    pMsgEx->Msg.ConfRosterInquireConfirm.pszConfModifier = ::My_strdupA(pszConfModifier);
    pMsgEx->Msg.ConfRosterInquireConfirm.pwszConfDescriptor = ::My_strdupW(pwszConfDescriptor);

    /*
     * Lock the data for the conference roster.  The lock call will 
     * return the length of the data to be serialized for the roster so
     * add that	length to the total memory block size and allocate the 
     * memory block.
     */
    fLock = TRUE;
    cbDataSize = pConfRoster->LockConferenceRoster();
    if (0 != cbDataSize)
    {
        DBG_SAVE_FILE_LINE
        pMsgEx->Msg.ConfRosterInquireConfirm.pConfRoster = (PGCCConfRoster) new char[cbDataSize];
        if (NULL == pMsgEx->Msg.ConfRosterInquireConfirm.pConfRoster)
        {
            ERROR_OUT(("CAppSap::ConfRosterInquireConfirm: can't create conf roster buffer"));
            rc = GCC_ALLOCATION_FAILURE;
            goto MyExit;
        }

        /*
        * Retrieve the conference roster data from the roster object.
        * The roster object will serialize any referenced data into 
        * the memory block passed in to the "Get" call.
        */
        pConfRoster->GetConfRoster(&(pMsgEx->Msg.ConfRosterInquireConfirm.pConfRoster),
                                   (LPBYTE) pMsgEx->Msg.ConfRosterInquireConfirm.pConfRoster);
    }

    if (NULL != ppMsgExToRet)
    {
        *ppMsgExToRet = pMsgEx;
    }
    else
    {
        PostAppSapMsg(pMsgEx);
    }

    rc = GCC_NO_ERROR;

MyExit:

    if (fLock)
    {
        pConfRoster->UnLockConferenceRoster();
    }

    if (GCC_NO_ERROR != rc)
    {
        delete pMsgEx;
    }

    DebugExitINT(CAppSap::ConfRosterInquireConfirm, rc);
    return rc;
}


/*
 *	AppRosterInquireConfirm()
 *
 *	Public Function Description
 *		This routine is called in order to return a requested list of
 *		application rosters to an application or the node controller.
 */
GCCError CAppSap::
AppRosterInquireConfirm
(
    GCCConfID           nConfID,
    CAppRosterMsg       *pAppRosterMsg,
    GCCResult           nResult,
    GCCAppSapMsgEx      **ppMsgEx
)
{
    GCCError    rc;

    DebugEntry(CAppSap::AppRosterInquireConfirm);

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(GCC_APP_ROSTER_INQUIRE_CONFIRM);
    if (NULL == pMsgEx)
    {
        ERROR_OUT(("CAppSap::AppRosterInquireConfirm: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
        goto MyExit;
    }
    pMsgEx->Msg.nConfID = nConfID;

    /*
    * Lock the data for the roster message and retrieve the data.
    */
    rc = pAppRosterMsg->LockApplicationRosterMessage();
    if (GCC_NO_ERROR != rc)
    {
        ERROR_OUT(("CAppSap::AppRosterInquireConfirm: can't lock app roster message, rc=%u", (UINT) rc));
        goto MyExit;
    }

    rc = pAppRosterMsg->GetAppRosterMsg((LPBYTE *) &(pMsgEx->Msg.AppRosterInquireConfirm.apAppRosters),
                                        &(pMsgEx->Msg.AppRosterInquireConfirm.cRosters));
    if (GCC_NO_ERROR != rc)
    {
        ERROR_OUT(("CAppSap::AppRosterInquireConfirm: can't get app roster message, rc=%u", (UINT) rc));
        pAppRosterMsg->UnLockApplicationRosterMessage();
        goto MyExit;
    }

    // fill in the roster information
    pMsgEx->Msg.AppRosterInquireConfirm.pReserved = (LPVOID) pAppRosterMsg;
    pMsgEx->Msg.AppRosterInquireConfirm.nConfID = nConfID;
    pMsgEx->Msg.AppRosterInquireConfirm.nResult = nResult;

    if (NULL != ppMsgEx)
    {
        *ppMsgEx = pMsgEx;
    }
    else
    {
        PostAppSapMsg(pMsgEx);
    }

    rc = GCC_NO_ERROR;

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        delete pMsgEx;
    }

    DebugExitINT(CAppSap::AppRosterInquireConfirm, rc);
    return rc;
}


void CAppSap::
FreeAppSapMsg ( GCCAppSapMsg *pMsg )
{
    GCCAppSapMsgEx *pMsgEx = (GCCAppSapMsgEx *) pMsg;
    ASSERT((LPVOID) pMsgEx == (LPVOID) pMsg);
    delete pMsgEx;
}


/* 
 *	AppInvokeConfirm ()
 *
 *	Public Function Description
 *		This routine is called in order to confirm a call requesting application
 *		invocation.
 */
GCCError CAppSap::
AppInvokeConfirm
(
    GCCConfID                       nConfID,
    CInvokeSpecifierListContainer   *pInvokeList,
    GCCResult                       nResult,
    GCCRequestTag                   nReqTag
)
{
    GCCError                rc;

    DebugEntry(CAppSap::AppInvokeConfirm);

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(GCC_APPLICATION_INVOKE_CONFIRM);
    if (NULL != pMsgEx)
    {
        pMsgEx->Msg.nConfID = nConfID;
        pMsgEx->Msg.AppInvokeConfirm.nConfID = nConfID;
        pMsgEx->Msg.AppInvokeConfirm.nResult = nResult;
        pMsgEx->Msg.AppInvokeConfirm.nReqTag = nReqTag;

        PostAppSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
    }
    else
    {
        ERROR_OUT(("CAppSap::AppInvokeConfirm: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
    }

    DebugExitINT(CAppSap::AppInvokeConfirm, rc);
    return rc;
}


/* 
 *	AppInvokeIndication()
 *
 *	Public Function Description
 *		This routine is called in order to send an indication to an application
 *		or node controller that a request for application invocation has been
 *		made.
 */
GCCError CAppSap::
AppInvokeIndication
(
    GCCConfID                       nConfID,
    CInvokeSpecifierListContainer   *pInvokeList,
    GCCNodeID                       nidInvoker
)
{
    GCCError            rc;
    UINT                cbDataSize;
    BOOL                fLock = FALSE;

    DebugEntry(CAppSap::AppInvokeIndication);

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(GCC_APPLICATION_INVOKE_INDICATION);
    if (NULL == pMsgEx)
    {
        ERROR_OUT(("CAppSap::AppInvokeIndication: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
        goto MyExit;
    }
    pMsgEx->Msg.nConfID = nConfID;

    fLock = TRUE;
    cbDataSize = pInvokeList->LockApplicationInvokeSpecifierList();
    if (0 != cbDataSize)
    {
        DBG_SAVE_FILE_LINE
        pMsgEx->Msg.AppInvokeInd.ApeList.apApes = (PGCCAppProtocolEntity *) new char[cbDataSize];
        if (NULL == pMsgEx->Msg.AppInvokeInd.ApeList.apApes)
        {
            ERROR_OUT(("CAppSap::AppInvokeIndication: can't create ape list"));
            rc = GCC_ALLOCATION_FAILURE;
            goto MyExit;
        }

        pInvokeList->GetApplicationInvokeSpecifierList(
                            &(pMsgEx->Msg.AppInvokeInd.ApeList.cApes),
                            (LPBYTE) pMsgEx->Msg.AppInvokeInd.ApeList.apApes);
    }

    pMsgEx->Msg.AppInvokeInd.nConfID = nConfID;
    pMsgEx->Msg.AppInvokeInd.nidInvoker = nidInvoker;

    PostAppSapMsg(pMsgEx);

    rc = GCC_NO_ERROR;

MyExit:

    if (fLock)
    {
        pInvokeList->UnLockApplicationInvokeSpecifierList();
    }

    if (GCC_NO_ERROR != rc)
    {
        delete pMsgEx;
    }

    DebugExitINT(CAppSap::AppInvokeIndication, rc);
    return rc;
}


/*
 *	AppRosterReportIndication ()
 *
 *	Public Function Description
 *		This routine is called in order to indicate to applications and the
 *		node controller that the list of application rosters has been updated.
 */
GCCError CAppSap::
AppRosterReportIndication
(
    GCCConfID           nConfID,
    CAppRosterMsg       *pAppRosterMsg
)
{
    GCCError    rc;

    DebugEntry(CAppSap::AppRosterReportIndication);

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(GCC_APP_ROSTER_REPORT_INDICATION);
    if (NULL == pMsgEx)
    {
        ERROR_OUT(("CAppSap::AppRosterReportIndication: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
        goto MyExit;
    }
    pMsgEx->Msg.nConfID = nConfID;

    /*
    * Lock the data for the roster message and retrieve the data.
    */
    rc = pAppRosterMsg->LockApplicationRosterMessage();
    if (GCC_NO_ERROR != rc)
    {
        ERROR_OUT(("CAppSap::AppRosterReportIndication: can't lock app roster message, rc=%u", (UINT) rc));
        goto MyExit;
    }

    rc = pAppRosterMsg->GetAppRosterMsg((LPBYTE *) &(pMsgEx->Msg.AppRosterReportInd.apAppRosters),
                                        &(pMsgEx->Msg.AppRosterReportInd.cRosters));
    if (GCC_NO_ERROR != rc)
    {
        ERROR_OUT(("CAppSap::AppRosterReportIndication: can't get app roster message, rc=%u", (UINT) rc));
        pAppRosterMsg->UnLockApplicationRosterMessage();
        goto MyExit;
    }

    // fill in the roster information
    pMsgEx->Msg.AppRosterReportInd.pReserved = (LPVOID) pAppRosterMsg;
    pMsgEx->Msg.AppRosterReportInd.nConfID = nConfID;

    PostAppSapMsg(pMsgEx);

    rc = GCC_NO_ERROR;

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        delete pMsgEx;
    }

    DebugExitINT(CAppSap::AppRosterReportIndication, rc);
    return rc;
}


/*
 *	ConductorInquireConfirm ()
 *
 *	Public Function Description
 *		This routine is called in order to return conductorship information
 *		which has been requested.
 *
 */
GCCError CAppSap::
ConductorInquireConfirm
(
    GCCNodeID           nidConductor,
    GCCResult           nResult,
    BOOL                fGranted,
    BOOL                fConducted,
    GCCConfID           nConfID
)
{
    GCCError                    rc;

    DebugEntry(CAppSap::ConductorInquireConfirm);

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(GCC_CONDUCT_INQUIRE_CONFIRM);
    if (NULL != pMsgEx)
    {
        pMsgEx->Msg.nConfID = nConfID;
        pMsgEx->Msg.ConductorInquireConfirm.nConfID = nConfID;
        pMsgEx->Msg.ConductorInquireConfirm.fConducted = fConducted;
        pMsgEx->Msg.ConductorInquireConfirm.nidConductor = nidConductor;
        pMsgEx->Msg.ConductorInquireConfirm.fGranted = fGranted;
        pMsgEx->Msg.ConductorInquireConfirm.nResult = nResult;

        PostAppSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
    }
    else
    {
        ERROR_OUT(("CAppSap::ConductorInquireConfirm: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
    }

    DebugExitINT(CAppSap::ConductorInquireConfirm, rc);
    return rc;
}



/* 
 *	ConductorPermitGrantIndication ()
 *
 *	Public Function Description
 *		This routine is called in order to send an indication to an application
 *		or node controller that a request for permission from the conductor
 *		has been made.
 */
GCCError CAppSap::
ConductorPermitGrantIndication
(
    GCCConfID           nConfID,
    UINT                cGranted,
    GCCNodeID           *aGranted,
    UINT                cWaiting,
    GCCNodeID           *aWaiting,
    BOOL                fThisNodeIsGranted
)
{
    GCCError                            rc = GCC_NO_ERROR;;
    UINT                                cbDataSize = 0;

    DebugEntry(CAppSap::ConductorPermitGrantIndication);

    cbDataSize = (0 != cGranted || 0 != cWaiting) ?
                    (ROUNDTOBOUNDARY(sizeof(GCCNodeID)) * cGranted) +
                    (ROUNDTOBOUNDARY(sizeof(GCCNodeID)) * cWaiting) :
                    0;

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(GCC_CONDUCT_GRANT_INDICATION);
    if (NULL != pMsgEx)
    {
        pMsgEx->Msg.nConfID = nConfID;

        if (cbDataSize > 0)
        {
        	DBG_SAVE_FILE_LINE
            pMsgEx->Msg.ConductorPermitGrantInd.pReserved = (LPVOID) new char[cbDataSize];
            if (NULL == pMsgEx->Msg.ConductorPermitGrantInd.pReserved)
            {
                ERROR_OUT(("CAppSap::ConductorPermitGrantIndication: can't allocate buffer, cbDataSize=%u", (UINT) cbDataSize));
	        rc = GCC_ALLOCATION_FAILURE;
                goto MyExit;
            }
        }

        pMsgEx->Msg.ConductorPermitGrantInd.nConfID = nConfID;
        pMsgEx->Msg.ConductorPermitGrantInd.Granted.cNodes = cGranted;
        if (0 != cGranted)
        {
            pMsgEx->Msg.ConductorPermitGrantInd.Granted.aNodeIDs =
                            (GCCNodeID *) pMsgEx->Msg.ConductorPermitGrantInd.pReserved;
            ::CopyMemory(pMsgEx->Msg.ConductorPermitGrantInd.Granted.aNodeIDs,
                         aGranted,
                         sizeof(GCCNodeID) * cGranted);
        }

        pMsgEx->Msg.ConductorPermitGrantInd.Waiting.cNodes = cWaiting;
        if (0 != cWaiting)
        {
            pMsgEx->Msg.ConductorPermitGrantInd.Waiting.aNodeIDs =
                            (GCCNodeID *) ((LPBYTE) pMsgEx->Msg.ConductorPermitGrantInd.pReserved +
                                           (ROUNDTOBOUNDARY(sizeof(GCCNodeID)) * cGranted));
            ::CopyMemory(pMsgEx->Msg.ConductorPermitGrantInd.Waiting.aNodeIDs,
                         aWaiting,
                         sizeof(GCCNodeID) * cWaiting);
        }
        pMsgEx->Msg.ConductorPermitGrantInd.fThisNodeIsGranted = fThisNodeIsGranted;

        PostAppSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
    }
    else
    {
        ERROR_OUT(("CAppSap::ConductorPermitGrantIndication: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
    }

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        delete pMsgEx;
    }

    DebugExitINT(CAppSap::ConductorPermitGrantIndication, rc);
    return rc;
}


/*
 *	ConductorAssignIndication ()
 *
 *	Public Function Description
 *		This routine is called in order to send an indication to an application
 *		or node controller that a request has been made to assign conductorship.
 */
GCCError CAppSap::
ConductorAssignIndication
(
    GCCNodeID           nidConductor,
    GCCConfID           nConfID
)
{
    GCCError                 rc;

    DebugEntry(CAppSap::ConductorAssignIndication);

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(GCC_CONDUCT_ASSIGN_INDICATION);
    if (NULL != pMsgEx)
    {
        pMsgEx->Msg.nConfID = nConfID;
        pMsgEx->Msg.ConductorAssignInd.nConfID = nConfID;
        pMsgEx->Msg.ConductorAssignInd.nidConductor = nidConductor;

        PostAppSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
    }
    else
    {
        ERROR_OUT(("CAppSap::ConductorPermitGrantIndication: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
    }

    DebugExitINT(CAppSap::ConductorAssignIndication, rc);
    return rc;
}

/*
 *	ConductorReleaseIndication ()
 *
 *	Public Function Description
 *		This routine is called in order to send an indication to an application
 *		or node controller that a request for releasing conductorship has been
 *		made.
 */
GCCError CAppSap::
ConductorReleaseIndication ( GCCConfID nConfID )
{
    GCCError    rc;

    DebugEntry(CAppSap::ConductorReleaseIndication);

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(GCC_CONDUCT_RELEASE_INDICATION);
    if (NULL != pMsgEx)
    {
        pMsgEx->Msg.nConfID = nConfID;
        pMsgEx->Msg.ConductorReleaseInd.nConfID = nConfID;

        PostAppSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
    }
    else
    {
        ERROR_OUT(("CAppSap::ConductorReleaseIndication: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
    }

    DebugExitINT(CAppSap::ConductorReleaseIndication, rc);
    return rc;
}


void CAppSap::
NotifyProc ( GCCAppSapMsgEx *pAppSapMsgEx )
{
    if (NULL != m_pfnCallback)
    {
        pAppSapMsgEx->Msg.pAppData = m_pAppData;
        (*m_pfnCallback)(&(pAppSapMsgEx->Msg));
    }
    delete pAppSapMsgEx;
}










//
// The following is for GCCAppSapMsgEx structure
//


GCCAppSapMsgEx::
GCCAppSapMsgEx ( GCCMessageType eMsgType )
{
    ::ZeroMemory(&Msg, sizeof(Msg));
    Msg.eMsgType = eMsgType;
}

GCCAppSapMsgEx::
~GCCAppSapMsgEx ( void )
{
    switch (Msg.eMsgType)
    {
    // 
    // Application Roster related callbacks
    //

    case GCC_PERMIT_TO_ENROLL_INDICATION:
    case GCC_ENROLL_CONFIRM:
    case GCC_APPLICATION_INVOKE_CONFIRM:
        //
        // No need to free anything
        //
        break;

    case GCC_APP_ROSTER_REPORT_INDICATION:
        if (NULL != Msg.AppRosterReportInd.pReserved)
        {
            //
            // App roster report is also sent to control sap.
            //
            ::EnterCriticalSection(&g_csGCCProvider);
            ((CAppRosterMsg *) Msg.AppRosterReportInd.pReserved)->UnLockApplicationRosterMessage();
            ::LeaveCriticalSection(&g_csGCCProvider);
        }
        break;

    case GCC_APP_ROSTER_INQUIRE_CONFIRM:
        if (NULL != Msg.AppRosterInquireConfirm.pReserved)
        {
            ((CAppRosterMsg *) Msg.AppRosterInquireConfirm.pReserved)->UnLockApplicationRosterMessage();
        }
        break;

    case GCC_APPLICATION_INVOKE_INDICATION:
        delete Msg.AppInvokeInd.ApeList.apApes;
        break;

    //
    // Conference Roster related callbacks
    //

    case GCC_ROSTER_INQUIRE_CONFIRM:
        delete Msg.ConfRosterInquireConfirm.ConfName.numeric_string;
        delete Msg.ConfRosterInquireConfirm.ConfName.text_string;
        delete Msg.ConfRosterInquireConfirm.pszConfModifier;
        delete Msg.ConfRosterInquireConfirm.pwszConfDescriptor;
        delete Msg.ConfRosterInquireConfirm.pConfRoster;
        break;

    //
    // Application Registry related callbacks
    //
    
    case GCC_REGISTER_CHANNEL_CONFIRM:
    case GCC_ASSIGN_TOKEN_CONFIRM:
    case GCC_RETRIEVE_ENTRY_CONFIRM:
    case GCC_DELETE_ENTRY_CONFIRM:
    case GCC_SET_PARAMETER_CONFIRM:
    case GCC_MONITOR_INDICATION:
    case GCC_MONITOR_CONFIRM:
        delete Msg.RegistryConfirm.pRegKey;
        delete Msg.RegistryConfirm.pRegItem;
        break;

    case GCC_ALLOCATE_HANDLE_CONFIRM:
        //
        // No need to free anything
        //
        break;

    //
    // Conductorship related callbacks
    //

    case GCC_CONDUCT_ASSIGN_INDICATION:
    case GCC_CONDUCT_RELEASE_INDICATION:
    case GCC_CONDUCT_INQUIRE_CONFIRM:
        //
        // No need to free anything
        //
        break;

    case GCC_CONDUCT_GRANT_INDICATION:
        delete Msg.ConductorPermitGrantInd.pReserved;
        break;

    default:
        ERROR_OUT(("GCCAppSapMsgEx::~GCCAppSapMsgEx: unknown msg type=%u", (UINT) Msg.eMsgType));
        break;
    }
}


void CAppSap::
PurgeMessageQueue(void)
{
    MSG     msg;

    /*
     *	This loop calls PeekMessage to go through all the messages in the thread's
     *	queue that were posted by the main MCS thread.  It removes these
     *	messages and frees the resources that they consume.
     */
    while (PeekMessage(&msg, m_hwndNotify, ASAPMSG_BASE, ASAPMSG_BASE + MSG_RANGE, PM_REMOVE))
    {
        if (msg.message == WM_QUIT)
        {
            // Repost the quit
            PostQuitMessage(0);
            break;
        }

        ASSERT(this == (CAppSap *) msg.lParam);
        delete (GCCAppSapMsgEx *) msg.wParam;
    }

    // Destroy the window; we do not need it anymore
    if (NULL != m_hwndNotify)
    {
        ::DestroyWindow(m_hwndNotify);
        m_hwndNotify = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\appldr.cpp ===
//
//  User or remote site invokes applet
//

#include "precomp.h"
#include "appldr.h"
#include "cuserdta.hpp"
#include "csap.h"

#define count_of(array)		(sizeof(array) / sizeof(array[0]))


static  CRITICAL_SECTION  g_csAppLdrInfo;
static  AppLoaderInfo  g_aAppLoaderInfo[APPLET_LAST];
static  BOOL   g_fAppLdrInitialized = FALSE;

const static CHAR *g_fnAppletDLL[APPLET_LAST] = {"nmwb.dll", "nmft.dll", "nmchat.dll"};

// Chat session key
static const GUID guidNM2Chat = { 0x340f3a60, 0x7067, 0x11d0,
						 { 0xa0, 0x41, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0 } };
#define  CHAT_KEY_SIZE  25
extern struct Key CHAT_APP_PROTO_KEY;


// NetMeeting/UI,  T.120
T120Error  WINAPI  T120_LoadApplet
(
    APPLET_ID       nAppId,
    BOOL            flocal,
    T120ConfID      nConfId,
    BOOL            fNoUI,
    LPSTR           pszCmdLine
)
{
	T120Error   rc = T120_NO_ERROR;
	LPFN_CREATE_APPLET_LOADER_INTERFACE		pfnCreateInterface;

	if (nAppId >= APPLET_LAST)
	{
		ERROR_OUT(("T120_LoadApplet: invalid applet ID=%u", nAppId));
		return T120_INVALID_PARAMETER;
	}

    //
    // Check policies.  Launch & auto-launch not allowed if corp has
    // disabled applet.
    //
    RegEntry    rePol(POLICIES_KEY, HKEY_CURRENT_USER);
    switch (nAppId)
    {
        case APPLET_ID_WB:
            if (rePol.GetNumber(REGVAL_POL_NO_NEWWHITEBOARD, DEFAULT_POL_NO_NEWWHITEBOARD))
            {
                WARNING_OUT(("New WB disabled by policy, not starting"));
	            return GCC_NO_SUCH_APPLICATION;
            }
            break;

        case APPLET_ID_FT:
            if (rePol.GetNumber(REGVAL_POL_NO_FILETRANSFER_SEND, DEFAULT_POL_NO_FILETRANSFER_SEND) &&
                rePol.GetNumber(REGVAL_POL_NO_FILETRANSFER_RECEIVE, DEFAULT_POL_NO_FILETRANSFER_RECEIVE))
            {
                WARNING_OUT(("FT disabled by policy, not starting"));
                return GCC_NO_SUCH_APPLICATION;
            }
            break;

        case APPLET_ID_CHAT:
            if (rePol.GetNumber(REGVAL_POL_NO_CHAT, DEFAULT_POL_NO_CHAT))
            {
                WARNING_OUT(("Chat disabled by policy, not starting"));
                return GCC_NO_SUCH_APPLICATION;
            }
            break;
    }

	::EnterCriticalSection(&g_csAppLdrInfo);

	if (NULL != g_aAppLoaderInfo[nAppId].hLibApplet)
	{
		switch (g_aAppLoaderInfo[nAppId].eStatus)
		{
		case APPLET_CLOSING:
		case APPLET_WORK_THREAD_EXITED:
			WARNING_OUT(("T120_LoadApplet: applet is closing or work thread exited"));
			rc = GCC_APPLET_EXITING;
			break;
		default:
			if (APPLDR_NO_ERROR == g_aAppLoaderInfo[nAppId].pIAppLoader->AppletInvoke(flocal, nConfId, pszCmdLine))
			{
			    g_aAppLoaderInfo[nAppId].cLoads++;
			}
			// rc = T120_NO_ERROR;
			break;
		}
		goto MyExit;
	}

	g_aAppLoaderInfo[nAppId].hLibApplet = ::LoadLibrary(g_fnAppletDLL[nAppId]);
	if (NULL != g_aAppLoaderInfo[nAppId].hLibApplet)
	{
		pfnCreateInterface = (LPFN_CREATE_APPLET_LOADER_INTERFACE)
					::GetProcAddress(g_aAppLoaderInfo[nAppId].hLibApplet,
									CREATE_APPLET_LOADER_INTERFACE);
		if (NULL != pfnCreateInterface)
		{
			//g_aAppLoaderInfo[nAppId].pIAppLoader = (IAppletLoader*)(*pfnCreateInterface)();
			(*pfnCreateInterface)(&g_aAppLoaderInfo[nAppId].pIAppLoader);
			if (NULL != g_aAppLoaderInfo[nAppId].pIAppLoader)
			{
				if (APPLDR_NO_ERROR == g_aAppLoaderInfo[nAppId].pIAppLoader->AppletStartup(fNoUI))
				{
					if (APPLDR_NO_ERROR == g_aAppLoaderInfo[nAppId].pIAppLoader->AppletInvoke(flocal, nConfId, pszCmdLine))
					{
						g_aAppLoaderInfo[nAppId].cLoads++;
						// rc = T120_NO_ERROR;
						goto MyExit;
					}
					else
					{
						ERROR_OUT(("T120_LoadApplet: cannot invoke applet(%s), flocal=%u, nConfID=%u",
							g_fnAppletDLL[nAppId], flocal, nConfId));
					}
				}
				else
				{
					ERROR_OUT(("T120_LoadApplet: cannot start applet(%s)", g_fnAppletDLL[nAppId]));
				}

				g_aAppLoaderInfo[nAppId].pIAppLoader->ReleaseInterface();
				g_aAppLoaderInfo[nAppId].pIAppLoader = NULL;
			}
			else
			{
				ERROR_OUT(("T120_LoadApplet: Entry function of %s  failed.\n", g_fnAppletDLL[nAppId]));
			}
		}
		else
		{
			WARNING_OUT(("T120_LoadApplet: Can't find entry point of %s.\n", g_fnAppletDLL[nAppId]));
		}

		::FreeLibrary(g_aAppLoaderInfo[nAppId].hLibApplet);
		g_aAppLoaderInfo[nAppId].hLibApplet = NULL;
	}
	else
	{
		ERROR_OUT(("T120_LoadApplet: Can't open DLL %s,  err %d.\n", g_fnAppletDLL[nAppId], GetLastError()));
	}

	rc = GCC_NO_SUCH_APPLICATION;
	
MyExit:

	::LeaveCriticalSection(&g_csAppLdrInfo);
	return rc;
}


//  NetMeeting/UI shutdown
T120Error WINAPI 
T120_CloseApplet(APPLET_ID  nAppId, BOOL fNowRegardlessRefCount, BOOL fSync, DWORD dwTimeout)
{
	if (nAppId< APPLET_LAST)
	{
		if (g_fAppLdrInitialized)
		{
			::EnterCriticalSection(&g_csAppLdrInfo);
			IAppletLoader *pIAppLdr = g_aAppLoaderInfo[nAppId].pIAppLoader;
			if (NULL != pIAppLdr)
			{
				ASSERT(g_aAppLoaderInfo[nAppId].cLoads > 0);
				g_aAppLoaderInfo[nAppId].cLoads --;
				if ((! fNowRegardlessRefCount) && g_aAppLoaderInfo[nAppId].cLoads > 0)
				{
					pIAppLdr = NULL; // do not free the library
				}
			}
			::LeaveCriticalSection(&g_csAppLdrInfo);

			if (NULL != pIAppLdr)
			{
                // AppletCleanup() must be outside of the critical section
                // because applet worker thread will call AppletStatus() before
                // exiting its worker thread.
                switch (pIAppLdr->AppletCleanup(5000)) // always synchronous shutdown
                {
                case APPLDR_NO_ERROR :
                    // we are closing this applet
					g_aAppLoaderInfo[nAppId].eStatus = APPLET_CLOSING;

                    // it is safe to unload the library
   					::FreeLibrary(g_aAppLoaderInfo[nAppId].hLibApplet);
   					g_aAppLoaderInfo[nAppId].hLibApplet = NULL;
					break;

			    case APPLDR_CANCEL_EXIT:
					//
					// The app didn't want to be unloaded
					//
					::EnterCriticalSection(&g_csAppLdrInfo);
					g_aAppLoaderInfo[nAppId].cLoads++;
					g_aAppLoaderInfo[nAppId].pIAppLoader = pIAppLdr;
					::LeaveCriticalSection(&g_csAppLdrInfo);
    				return GCC_APPLET_CANCEL_EXIT;

			    default:
			        break;
				}
			}
		}
		return T120_NO_ERROR;
	}
	else
	{
		ERROR_OUT(("T120_CloseApplet: invalid applet ID=%u", nAppId));
	}
	return T120_INVALID_PARAMETER;
}


T120Error WINAPI 
T120_QueryApplet(APPLET_ID  nAppId, APPLET_QUERY_ID eQueryId)
{
	if (nAppId< APPLET_LAST)
	{
		if (g_fAppLdrInitialized)
		{
			::EnterCriticalSection(&g_csAppLdrInfo);
			IAppletLoader *pIAppLdr = g_aAppLoaderInfo[nAppId].pIAppLoader;
			::LeaveCriticalSection(&g_csAppLdrInfo);
			if (NULL != pIAppLdr)
			{
				if (APPLET_QUERY_NM2xNODE == eQueryId)
				{
					pIAppLdr->OnNM2xNodeJoin();
				}
				else if (APPLDR_CANCEL_EXIT == pIAppLdr->AppletQuery(eQueryId))
				{
                    return GCC_APPLET_CANCEL_EXIT;
                }
			}
		}
	    return		T120_NO_ERROR;
	}
	else
	{
		ERROR_OUT(("T120_CloseApplet: invalid applet ID=%u", nAppId));
	}
	return T120_INVALID_PARAMETER;
}


// Applet itself
T120Error WINAPI 
T120_AppletStatus(APPLET_ID  nAppId, APPLET_STATUS  status)
{
	if (nAppId < APPLET_LAST)
	{
		if (g_fAppLdrInitialized)
		{
			::EnterCriticalSection(&g_csAppLdrInfo);

			g_aAppLoaderInfo[nAppId].eStatus = status;

			switch (status)
			{
			case APPLET_WORK_THREAD_EXITED:
				if (NULL != g_aAppLoaderInfo[nAppId].pIAppLoader)
				{
					g_aAppLoaderInfo[nAppId].pIAppLoader->ReleaseInterface();
					g_aAppLoaderInfo[nAppId].pIAppLoader = NULL;
				}
				break;
			case APPLET_LIBRARY_FREED:
				// clean up this entry
				::ZeroMemory(&g_aAppLoaderInfo[nAppId], sizeof(g_aAppLoaderInfo[0]));
				break;
			}

			::LeaveCriticalSection(&g_csAppLdrInfo);
		}
		return T120_NO_ERROR;
	}
	else
	{
		ERROR_OUT(("T120_AppletStatus: invalid applet ID=%u", nAppId));
	}
	return T120_INVALID_PARAMETER;
}


T120Error AppLdr_Initialize(void)
{ 
	ASSERT(count_of(g_aAppLoaderInfo) == APPLET_LAST);

	::InitializeCriticalSection(&g_csAppLdrInfo);
	
	// clean all entries
	::ZeroMemory(g_aAppLoaderInfo, sizeof(g_aAppLoaderInfo));

	::CreateH221AppKeyFromGuid(CHAT_APP_PROTO_KEY.u.h221_non_standard.value,
								(GUID *)&guidNM2Chat );
	CHAT_APP_PROTO_KEY.choice = h221_non_standard_chosen;
	CHAT_APP_PROTO_KEY.u.h221_non_standard.length = CHAT_KEY_SIZE;

	g_fAppLdrInitialized = TRUE;
	return T120_NO_ERROR;
}


void AppLdr_Shutdown(void)
{
	g_fAppLdrInitialized = FALSE;

	for (ULONG i = 0; i < APPLET_LAST; i++)
	{
		if (NULL != g_aAppLoaderInfo[i].pIAppLoader)
		{
			APPLDR_RESULT rc = g_aAppLoaderInfo[i].pIAppLoader->AppletCleanup(5000); // always synchronous shutdown
			ASSERT(APPLDR_NO_ERROR == rc);

            // it is safe to unload the library
            ::FreeLibrary(g_aAppLoaderInfo[i].hLibApplet);
            g_aAppLoaderInfo[i].hLibApplet = NULL;
		}
	}

	// clean all entries
	::ZeroMemory(g_aAppLoaderInfo, sizeof(g_aAppLoaderInfo));

	::DeleteCriticalSection(&g_csAppLdrInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\alarm.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/*
 *	alarm.cpp
 *
 *	Copyright (c) 1995 by Databeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the Alarm class.  Objects of this
 *		class are used when the creator wishes to make sure that a certain
 *		activity doesn't exceed a certain amount of time.
 *
 *		By convention, an Alarm object is created with the time limitation
 *		passed in as the only parameter to the constructor.  The creator can
 *		then periodically ask the Alarm object if it has expired.  This hides
 *		all time maintenance code from the creator.
 *
 *		Note that the Alarm class is PASSIVE, meaning that it will not call
 *		back into its creator when the specified time is exceeded.  This
 *		capability could be added at a future data. if desirable.  Right now,
 *		the creator MUST call into an Alarm object to ask it if it has expired.
 *
 *	Private Data:
 *		Duration
 *			This refers to the original duration of the alarm.  It is kept
 *			around to allow the creator to reset the alarm without having to
 *			respecify the duration.
 *		Expiration_Time
 *			This is the time (in clock ticks) upon which the alarm will expire.
 *			Whenever the alarm is asked if it has expired, it checks the current
 *			system clock against this value.
 *		Expired
 *			This is a boolean flag that indicates whether or not the alarm has
 *			already expired.  This prevents the object from repeatedly checking
 *			the system clock if the timer has already expired.
 * 
 *	Caveats:
 *		None
 *
 *	Author:  
 *		James P. Galvin, Jr.
 *
 *	Revision History:
 *		09JAN95   jpg	Original
 */

#include "alarm.h"


/*
 *	Alarm ()
 *
 *	Public
 *
 *	Function Description
 *		This is the constructor for the Alarm class.  It calls Set to initialize
 *		all instance variables, and calculate the first expiration time value
 *		based on the specified duration.
 */
CAlarm::CAlarm(UINT nDuration)
{
	Set(nDuration);
}

/*
 *	~Alarm ()
 *
 *	Public
 *
 *	Function Description
 *		This is the destructor for the Alarm class.  It currently does nothing.
 */

/*
 *	void	Set ()
 *
 *	Public
 *
 *	Function Description
 *		This function initializes the alarm duration instance variable and
 *		calls Reset to ready the alarm for use.
 */
void CAlarm::Set(UINT nDuration)
{
	m_nDuration = nDuration;

	/*
	 *	Call Reset to initialize remaining instance variables and ready the
	 *	alarm for use.
	 */
	Reset();
}

/*
 *	void	Reset ()
 *
 *	Public
 *
 *	Function Description
 *		This function calculate an expiration time value based on the specified
 *		duration and marks the alarm as unexpired.
 */
void CAlarm::Reset(void)
{
	/*
	 *	Determine the expiration time by adding the alarm duration to the
	 *	current time.
	 */
	m_nStartTime = (UINT) ::GetTickCount();
	m_fExpired = FALSE;
}

/*
 *	void	Expire ()
 *
 *	Public
 *
 *	Function Description
 *		This function can be used to expire an alarm prematurely.  This might
 *		be useful if the alarm is used to determine whether or not to perform
 *		an action, and the caller decides to inhibit the action for reasons
 *		other than time.
 */

/*
 *	BOOL		IsExpired ()
 *
 *	Public
 *
 *	Function Description
 *		This function is used to check an alarm to see if it has expired.
 */
BOOL CAlarm::IsExpired(void)
{
	/*
	 *	See if the alarm has already expired before checking it again.
	 */
    // LONCHANC: The alarm object is totally bogus. We check for expiration
    // only when we are sending a PDU out. However, when it expires, it is
    // possible that there is no PDU to send. In this case, no one will know
    // this alarm is expired. This means some actions will not be taken in time.
    // Now, make it always expired because it did not work at all before and
    // most of time it returned "expired."
#if 1
    m_fExpired = TRUE;
#else
	if (! m_fExpired)
	{
		if (m_nStartTime + m_nDuration <= (UINT) ::GetTickCount())
		{
			m_fExpired = TRUE;
		}
	}
#endif

	return m_fExpired;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\channel.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MCSNC);
/*
 *	channel.cpp
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for class Channel.  It contains the
 *		code necessary to implement static and assigned channels in the
 *		MCS system.
 *
 *		This is also to be the base class for other classes that represent
 *		channels in the system.  Therefore, there will be times when some
 *		of these member functions are overridden to provide different
 *		behavior.  These derived classes may or may not invoke the operations
 *		in this class.
 *
 *	Protected Instance Variables:
 *		Channel_ID
 *			This instance variable contains the channel ID that is associated
 *			with a given instance of this class.
 *		m_pDomain
 *			This is a pointer to the local provider.  Note that no messages
 *			ever sent to this provider.  This pointer is used as a parameter
 *			whenever other MCS commands are issued, since this class acts on
 *			behalf of the local provider.
 *		m_pConnToTopProvider
 *			This is a pointer to the Top Provider.  This is used when it is
 *			necessary to send requests to the Top Provider.
 *		m_pChannelList2
 *			This is a reference to the channel list that is owned and maintained
 *			by the parent domain.  It is NEVER modified by this class.
 *		m_JoinedAttachmentList
 *			This is a container that contains the list of attachments currently
 *			joined to the channel.
 *
 *	Private Member Functions:
 *		None.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
/*
 *	Channel ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the primary constructor for the Channel class.  It simply
 *		initializes the instance variable to valid values.  It leaves the
 *		attachment list empty.
 */
Channel::Channel (
        ChannelID			channel_id,
        PDomain             local_provider,
        PConnection         top_provider,
        CChannelList2      *channel_list,
        CAttachmentList    *attachment_list)
:
    Channel_ID (channel_id),
    m_pDomain(local_provider),
    m_pConnToTopProvider(top_provider),
    m_pChannelList2(channel_list),
    m_pAttachmentList(attachment_list)
{
}

/*
 *	Channel ()
 *
 *	Public
 *
 *	Functional Description:
 *		This version of the constructor is used to create a Channel object
 *		with an existing attachment.  It is otherwise the same as the primary
 *		constructor above.
 */
Channel::Channel (
        ChannelID			channel_id,
        PDomain             local_provider,
        PConnection         top_provider,
        CChannelList2      *channel_list,
        CAttachmentList    *attachment_list,
        PConnection         pConn)
:
    Channel_ID (channel_id),
    m_pDomain(local_provider),
    m_pConnToTopProvider(top_provider),
    m_pChannelList2(channel_list),
    m_pAttachmentList(attachment_list)
{
	/*
	 *	Add the initial attachment to the attachment list.
	 */
	if (pConn != NULL)
		m_JoinedAttachmentList.Append(pConn);
}

/*
 *	~Channel ()
 *
 *	Public
 *
 *	Functional Description:
 *		If the object is destroyed before the attachment list is empty, it is
 *		the responsibility of this destructor to issue channel leave indications
 *		to all locally joined users.
 */
Channel::~Channel ()
{
	CAttachment        *pAtt;
	//DWORD				type;

	/*
	 *	Iterate through the joined attachment list sending channel leave
	 *	indications to all users who are locally attached to this provider.
	 */
	m_JoinedAttachmentList.Reset();
	while (NULL != (pAtt = m_JoinedAttachmentList.Iterate()))
	{
		if (m_pAttachmentList->Find(pAtt) && pAtt->IsUserAttachment())
		{
		    PUser pUser = (PUser) pAtt;
			pUser->ChannelLeaveIndication(REASON_CHANNEL_PURGED, Channel_ID);
		}
	}
}

/*
 *	Channel_Type		GetChannelType ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function returns the type of the channel.  For a Channel object,
 *		this will always be either STATIC_CHANNEL or ASSIGNED_CHANNEL, depending
 *		on the value of the channel ID.
 */
Channel_Type Channel::GetChannelType ()
{
	/*
	 *	T.125 specifies that channels from 1 to 1000 are static.  The rest
	 *	are dynamic (for this type of Channel object, that equates to
	 *	assigned).
	 */
	return (Channel_ID <= 1000) ? STATIC_CHANNEL : ASSIGNED_CHANNEL;
}

/*
 *	BOOL	IsValid ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function returns TRUE if the Channel object is still valid, or
 *		FALSE if it is ready to be deleted.
 */
BOOL	Channel::IsValid ()
{
	CAttachment        *pAtt;
	CAttachmentList     deletion_list;

	/*
	 *	Iterate through the joined attachment list, building a list of those
	 *	attachments in the list that are no longer valid.
	 */
	m_JoinedAttachmentList.Reset();
	while (NULL != (pAtt = m_JoinedAttachmentList.Iterate()))
	{
		if (m_pAttachmentList->Find(pAtt) == FALSE)
			deletion_list.Append(pAtt);
	}

	/*
	 *	Iterate through the deletion list, removing all those attachments that
	 *	were found to be invalid above.
	 */
	while (NULL != (pAtt = deletion_list.Get()))
	{
		m_JoinedAttachmentList.Remove(pAtt);
	}

	return (! m_JoinedAttachmentList.IsEmpty());
}

/*
 *	Void	IssueMergeRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This member function is used to cause the Channel object to issue a
 *		merge request to the pending top provier.
 */
Void	Channel::IssueMergeRequest ()
{
	Channel_Type			channel_type;
	ChannelAttributes		channel_attributes;
	CChannelAttributesList	merge_channel_list;
	CChannelIDList			purge_channel_list;

	if (m_pConnToTopProvider != NULL)
	{
		/*
		 *	Fill in the fields of the channel attributes structure so that it
		 *	accurately describes this channel.  Then put the structure into the
		 *	merge channel list.
		 */
		channel_type = GetChannelType ();
		channel_attributes.channel_type = channel_type;
		switch (channel_type)
		{
			case STATIC_CHANNEL:
				channel_attributes.u.static_channel_attributes.channel_id =
						Channel_ID;
				break;

			case ASSIGNED_CHANNEL:
				channel_attributes.u.assigned_channel_attributes.channel_id =
						Channel_ID;
				break;
		}
		merge_channel_list.Append(&channel_attributes);

		/*
		 *	Send the merge request to the indicated provider.
		 */
		m_pConnToTopProvider->MergeChannelsRequest(&merge_channel_list, &purge_channel_list);
	}
}

/*
 *	Void	ChannelJoinRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to add a new attachment to the attachment list.
 *		If the user ID is valid, this routine will also issue an automatic
 *		join confirm to the user.
 */
Void	Channel::ChannelJoinRequest (
				CAttachment        *pOrigAtt,
				UserID				uidInitiator,
				ChannelID			channel_id)
{
	/*
	 *	Make sure the attachment isn't already in the list before adding it.
	 */
	if (m_JoinedAttachmentList.Find(pOrigAtt) == FALSE)
	{
		TRACE_OUT (("Channel::ChannelJoinRequest: "
				"user %04X joining channel %04X", (UINT) uidInitiator, (UINT) Channel_ID));

		m_JoinedAttachmentList.Append(pOrigAtt);
	}

	/*
	 *	If the user ID is valid, then send a join confirm to the initiating
	 *	attachment.  Note that setting the user ID to 0 is a way of disabling
	 *	this behavior.  This is sometimes useful when adding attachments during
	 *	a domain merge.
	 */
	if (uidInitiator != 0)
	{
		pOrigAtt->ChannelJoinConfirm(RESULT_SUCCESSFUL, uidInitiator, channel_id, Channel_ID);
    }
}

/*
 *	Void	ChannelJoinConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function performs the same operation as JoinRequest above.
 */
Void	Channel::ChannelJoinConfirm (
				CAttachment        *pOrigAtt,
				Result,
				UserID				uidInitiator,
				ChannelID			requested_id,
				ChannelID)
{
	/*
	 *	Make sure the attachment isn't already in the list before adding it.
	 */
	if (m_JoinedAttachmentList.Find(pOrigAtt) == FALSE)
	{
		TRACE_OUT (("Channel::ChannelJoinConfirm: "
				"user %04X joining channel %04X", (UINT) uidInitiator, (UINT) Channel_ID));

		m_JoinedAttachmentList.Append(pOrigAtt);
	}

	/*
	 *	Send a join confirm to the initiating attachment.
	 */
	pOrigAtt->ChannelJoinConfirm(RESULT_SUCCESSFUL, uidInitiator, requested_id, Channel_ID);
}

/*
 *	Void	ChannelLeaveRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to remove an attachment from the attachment list.
 *		A leave request will also be issued upward (unless this is the Top
 *		Provider).
 */
Void	Channel::ChannelLeaveRequest (
				CAttachment     *pOrigAtt,
				CChannelIDList *)
{
	CChannelIDList		channel_leave_list;

	/*
	 *	Make sure the attachment is in the list before trying to remove it.
	 */
	if (m_JoinedAttachmentList.Remove(pOrigAtt))
	{
		TRACE_OUT (("Channel::ChannelLeaveRequest: leaving channel %04X", Channel_ID));

		/*
		 *	Remove the attachment from the list.
		 */

		/*
		 *	If this results in an empty list, then we have more work to do.
		 */
		if (m_JoinedAttachmentList.IsEmpty())
		{
			/*
			 *	If this is not the Top Provider, send a leave request upward
			 *	to the Top Provider.
			 */
			if (! IsTopProvider())
			{
				TRACE_OUT (("Channel::ChannelLeaveRequest: "
						"sending ChannelLeaveRequest to Top Provider"));

				channel_leave_list.Append(Channel_ID);
				m_pConnToTopProvider->ChannelLeaveRequest(&channel_leave_list);
			}
		}
	}
}

/*
 *	Void	SendDataRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to send data through the channel.
 */
Void	Channel::SendDataRequest (
				CAttachment        *pOrigAtt,
				UINT				type,
				PDataPacket			data_packet)
{
	CAttachment *pAtt;

	ASSERT (Channel_ID == data_packet->GetChannelID());
	/*
	 *	If this is not the Top Provider, forward the data upward.
	 */
	if (m_pConnToTopProvider != NULL)
		m_pConnToTopProvider->SendDataRequest(data_packet);

	/*
	 *	Iterate through the attachment list, sending the data to all
	 *	the attachments (except for one from whence the data came).
	 */
	m_JoinedAttachmentList.Reset();
	while (NULL != (pAtt = m_JoinedAttachmentList.Iterate()))
	{
		if ((pAtt != pOrigAtt) || (type != MCS_SEND_DATA_INDICATION))
		{
			pAtt->SendDataIndication(type, data_packet);
		}
	}
}

/*
 *	Void	SendDataIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to send data through the channel.
 */
Void	Channel::SendDataIndication (
				PConnection,
				UINT				type,
				PDataPacket			data_packet)
{
	CAttachment *pAtt;

	ASSERT (Channel_ID == data_packet->GetChannelID());
	/*
	 *	Iterate through the attachment list, sending the data to all
	 *	the attachments.
	 */
	m_JoinedAttachmentList.Reset();
	while (NULL != (pAtt = m_JoinedAttachmentList.Iterate()))
	{
		pAtt->SendDataIndication(type, data_packet);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\arostmgr.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_APP_ROSTER);
/*
 *	arostmgr.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the Application Roster
 *		Manager Class.
 *
 *		SEE THE INTERFACE FILE FOR A MORE DETAILED DESCRIPION OF THIS CLASS.
 *
 *	Private Instance Variables
 *		m_nConfID
 *			The conference ID associated with this roster manager.  Used
 *			when delivering roster update messages.
 *		m_fTopProvider
 *			Flag indicating if this is a top provider node for this conference.
 *		m_pMcsUserObject
 *			This is the user attachment object associated with this conference.	
 *		m_AppSapEidList2
 *			This list maintains all of the command target pointers for each
 *			of the enrolled APEs.  This list is used to deliver roster 
 *			update messages.
 *		m_pConf
 *			Pointer to object that will receive all owner callback messages
 *			delivered from the application roster manager.
 *		m_GlobalRosterList
 *			This list maintains pointers to all the global application rosters.
 *		m_LocalRosterList
 *			This list maintains pointers to all the local application rosters.
 *			This list will not be used if this is a Top Provider node.
 *		m_RosterDeleteList
 *			This list is used to hold any application rosters that have
 *			been marked to be deleted (usually when they become empty).  We
 *			don't delete immediately to allow messages and PDUs to be processed
 *			before deletion.
 *		m_pSessionKey
 *			This is the session key used to hold the protocol key associated
 *			with this application roster manager.
 *
 *	Caveats:
 *		None
 *
 *	Author:
 *		blp
 */


#include "arostmgr.h"
#include "arostmsg.h"
#include "appsap.h"
#include "csap.h"
#include "conf.h"


/*
 *	CAppRosterMgr	()
 *
 *	Public Function Description
 *	when pGccSessKey is not NULL
 *		This is the application roster manager constructor. It is responsible 
 *		for initializing all the instance variables used by this class.
 *		This constructor is used when the initial roster data that is
 *		availble comes from local API data.
 *
 *	when pSessKey is not NULL
 *		This is the application roster manager constructor. It is responsible 
 *		for initializing all the instance variables used by this class.
 *		This constructor is used when the initial roster data that is
 *		availble comes from remote PDU data.
 *		This constructor handles a number of different possiblities:
 *			For Non Top Providers:
 *				1)	A refresh received from the top provider.
 *				2)	An update from a node below this one.
 *
 *			For the Top Provider:
 *				1)	An Update from a lower node
 */
CAppRosterMgr::CAppRosterMgr(
					PGCCSessionKey			pGccSessKey,
					PSessionKey				pPduSessKey,
					GCCConfID   			nConfID,
					PMCSUser				pMcsUserObject,
					CConf					*pConf,
					PGCCError				pRetCode)
:
    CRefCount(MAKE_STAMP_ID('A','R','M','r')),
	m_nConfID(nConfID),
	// m_fTopProvider(FALSE),
	m_pMcsUserObject(pMcsUserObject),
	m_AppSapEidList2(DESIRED_MAX_APP_SAP_ITEMS),
	m_pConf(pConf)
{
	GCCError rc = GCC_NO_ERROR;

	DebugEntry(CAppRosterMgr::CAppRosterMgr);

	//	Determine if this is a top provider node
	m_fTopProvider = (m_pMcsUserObject->GetTopNodeID() == m_pMcsUserObject->GetMyNodeID());

	/*
	**	Set up this roster managers session key which will be used to 
	**	determine whether or not to process a roster request or update.
	*/
	if (NULL != pGccSessKey)
	{
		ASSERT(NULL == pPduSessKey);
		DBG_SAVE_FILE_LINE
		m_pSessionKey = new CSessKeyContainer(pGccSessKey, &rc);
	}
	else
	if (NULL != pPduSessKey)
	{
		DBG_SAVE_FILE_LINE
		m_pSessionKey = new CSessKeyContainer(pPduSessKey, &rc);
	}
	else
	{
		ERROR_OUT(("CAppRosterMgr::CAppRosterMgr: invalid session key"));
		rc = GCC_BAD_SESSION_KEY;
		goto MyExit;
	}

	if (NULL == m_pSessionKey || GCC_NO_ERROR != rc)
	{
		ERROR_OUT(("CAppRosterMgr::CAppRosterMgr: can't create session key"));
		rc = GCC_ALLOCATION_FAILURE;
		// we do the cleanup in the destructor
		goto MyExit;
    }

	ASSERT(GCC_NO_ERROR == rc);

MyExit:

	DebugExitINT(CAppRosterMgr:;CAppRosterMgr, rc);

	*pRetCode = rc;
}

/*
 *	~CAppRosterMgr()
 *
 *	Public Function Description
 *		This is the application roster manager destructor.  It is used to
 *		free up all memory associated with this class.
 */
CAppRosterMgr::~CAppRosterMgr(void)
{
	m_GlobalRosterList.DeleteList();
	m_LocalRosterList.DeleteList();
	m_RosterDeleteList.DeleteList();

	if (NULL != m_pSessionKey)
	{
	    m_pSessionKey->Release();
	}
}


/*
 *	GCCError	EnrollRequest	()
 *
 *	Public Function Description
 *		This routine is called whenever an APE wishes to enroll with the
 *		conference in a specific session.  This routine can be used to
 *		either add a new record or replace a currently existing record.
 */
GCCError CAppRosterMgr::
EnrollRequest(GCCEnrollRequest *pReq, GCCEntityID eid, GCCNodeID nid, CAppSap *pAppSap)
{
	GCCError			rc = GCC_NO_ERROR;
	CAppRoster			*pAppRoster = NULL;
	BOOL				perform_add_record;
	BOOL				maintain_pdu_data;

	DebugEntry(CAppRosterMgr::EnrollRequest);

	/*
	**	First we must make sure that the default version of this session
	**	key matches this application roster manager's
	*/
	if (! IsThisSessionKeyValid(pReq->pSessionKey))
	{
	    rc = GCC_BAD_SESSION_KEY;
	    goto MyExit;
	}

	//	Now save the App SAP so we can send roster report indications
	if (! m_AppSapEidList2.Find(eid))
	{
		m_AppSapEidList2.Append(eid, pAppSap);
		perform_add_record = TRUE;
	}
	else
    {
		perform_add_record = FALSE;
    }

	/*
	**	Next we must make sure that the global application roster (and 
	**	local for non top providers) that matches this session key exist.
	**	If they don't exists then create them here.
	*/
	pAppRoster = GetApplicationRoster(pReq->pSessionKey, &m_GlobalRosterList);
	if (pAppRoster == NULL)
	{
		maintain_pdu_data = m_fTopProvider;

		/*
		**	Here we create the global default application rosters.  If
		**	this is the Top Provider we DO maintain PDU data within the
		**	roster.
		*/
		DBG_SAVE_FILE_LINE
		pAppRoster = new CAppRoster(pReq->pSessionKey,
									NULL,	// pSessKey
									this,	// pOwnerObject
									m_fTopProvider,// fTopProvider
									FALSE,	// fLocalRoster
									maintain_pdu_data,	// fMaintainPduBuffer
									&rc);
		if ((pAppRoster != NULL) && (rc == GCC_NO_ERROR))
		{
			m_GlobalRosterList.Append(pAppRoster);
		}
		else
		{
		    rc = GCC_ALLOCATION_FAILURE;
		    goto MyExit;
		}
	}

	if (! m_fTopProvider)
	{
		pAppRoster = GetApplicationRoster(pReq->pSessionKey, &m_LocalRosterList);
		if (pAppRoster == NULL)
		{
			//	Here we create the local default application rosters.
			DBG_SAVE_FILE_LINE
			pAppRoster = new CAppRoster(pReq->pSessionKey,
										NULL,	// pSessKey
										this,	// pOwnerObject
										m_fTopProvider,// fTopProvider
										TRUE,	// fLocalRoster
										TRUE,	// fMaintainPduBuffer
										&rc);
			if ((pAppRoster != NULL) && (rc == GCC_NO_ERROR))
			{
				m_LocalRosterList.Append(pAppRoster);
			}
			else
			{
				rc = GCC_ALLOCATION_FAILURE;
				goto MyExit;
			}
		}
	}

//
// LONCHANC: Something wrong here. roster_ptr could be either
// the one in the global list or the one in the local list.
// Should we add records to both roster_ptr???
//
// LONCHANC: It seems to me that only the local list has records in non-top provider.
// On the other hand, only the global list has the record in top provider.
// cf. UnEnrollRequest().
//

    if (perform_add_record)
    {
    	//	Add the new record to the roster
    	rc = pAppRoster->AddRecord(pReq, nid, eid);
    	if (GCC_NO_ERROR != rc)
    	{
    		ERROR_OUT(("AppRosterManager::EnrollRequest: can't add record"));
    	}
    }
    else
    {
    	rc = pAppRoster->ReplaceRecord(pReq, nid, eid);
    	if (GCC_NO_ERROR != rc)
    	{
    		ERROR_OUT(("AppRosterManager::EnrollRequest: can't repalce record"));
    	}
    }

    // zero out the roster pointer because it should no be freed
    // in case of adding or replacing a record.
    // because the roster pointer has been added to the list,
    // it will be freed later.
	pAppRoster = NULL;

MyExit:

    if (GCC_NO_ERROR != rc)
    {
		if (pAppRoster != NULL)
        {
			pAppRoster->Release();
        }
    }

	DebugExitINT(CAppRosterMgr::EnrollRequest, rc);
	return rc;
}

/*
 *	GCCError	UnEnrollRequest	()
 *
 *	Public Function Description
 *		This routine is called whenever an APE wishes to unenroll from the
 *		conference (or a specific session).
 */
GCCError		CAppRosterMgr::UnEnrollRequest (
													PGCCSessionKey	session_key,
													EntityID		entity_id)
{
	GCCError				rc = GCC_NO_ERROR;
	CAppRoster				*application_roster = NULL;
	CAppRosterList			*roster_list;

	DebugEntry(CAppRosterMgr::UnEnrollRequest);

	//	Is this a valid session key for the application roster manager
	if (IsThisSessionKeyValid (session_key) == FALSE)
		rc = GCC_INVALID_PARAMETER;
	else if (m_AppSapEidList2.Remove(entity_id))
	{
		//	Now find the affected roster
		roster_list = m_fTopProvider ? &m_GlobalRosterList : &m_LocalRosterList;
 
		application_roster = GetApplicationRoster (	session_key, roster_list);
		//	Now unenroll from the specified roster 
		if (application_roster != NULL)
		{
			rc = application_roster->RemoveRecord(
												m_pMcsUserObject->GetMyNodeID(),
								 				entity_id);
		}
		else
			rc = GCC_BAD_SESSION_KEY;
	}
	else
		rc = GCC_APP_NOT_ENROLLED;

	DebugExitINT(CAppRosterMgr::UnEnrollRequest, rc);

    return rc;
}

/*
 *	GCCError	ProcessRosterUpdateIndicationPDU ()
 *
 *	Public Function Description
 *		This routine processes an incomming roster update PDU.  It is
 *		responsible for passing the PDU on to the right application roster.
 */
GCCError	CAppRosterMgr::ProcessRosterUpdateIndicationPDU(
					PSetOfApplicationInformation	set_of_application_info,
					UserID							sender_id)
{
	GCCError				rc = GCC_NO_ERROR;
	CAppRosterList			*roster_list;
	CAppRoster				*application_roster;
	BOOL					maintain_pdu_buffer;
	BOOL					is_local_roster;

	DebugEntry(CAppRosterMgr::ProcessRosterUpdateIndicationPDU);

	/*
	**	First make sure that the session key contained in the current
	**	set of application information is valid for this application roster 
	**	manager.
	*/ 
	if (IsThisSessionKeyPDUValid(&set_of_application_info->value.session_key))
	{
		/*
		**	Now search for the appropriate application roster.  If it is not 
		**	found we must create it here.
		*/

        //
		// LONCHANC:
		// (1) If top provider, add default application roster to the global roster list.
		// (2) If non-top provider, we do not create both the local and global version of the 
		// application roster for this particular session key.
		// instead, We create only the appropriate one here 
		// and wait until we receive either a refresh from the 
		// top provider or an update from a node below this one 
		// in the connection hierarchy (or an application 
		// enroll) before creating the other.
		// (3) If this PDU was sent from below this node it 
		// must be an update of the local roster so save 
		// the roster in the local roster list.
        //
		roster_list = (m_fTopProvider || (sender_id == m_pMcsUserObject->GetTopNodeID())) ?
						&m_GlobalRosterList : &m_LocalRosterList;
 
		application_roster = GetApplicationRosterFromPDU (
									&set_of_application_info->value.session_key,
									roster_list);
		if (application_roster != NULL)
		{
			rc = application_roster->
								ProcessRosterUpdateIndicationPDU(
												set_of_application_info,
												sender_id);
		}
		else
		{
			//	First determine the characteristics of this roster
			if (m_fTopProvider)
			{
				maintain_pdu_buffer = TRUE;
				is_local_roster = FALSE;
			}
			else if (sender_id == m_pMcsUserObject->GetTopNodeID())
			{
				maintain_pdu_buffer = FALSE;
				is_local_roster = FALSE;
			}
			else
			{
				maintain_pdu_buffer = TRUE;
				is_local_roster = TRUE;
			}

			//	Create the application roster from the passed in PDU.	
			DBG_SAVE_FILE_LINE
			application_roster = new CAppRoster(NULL,	// pGccSessKey
												&set_of_application_info->value.session_key,	// pSessKey
												this,	// pOwnerObject
												m_fTopProvider,// fTopProvider
												is_local_roster,// fLocalRoster
												maintain_pdu_buffer,// fMaintainPduBuffer
												&rc);
			if ((application_roster != NULL) && (rc == GCC_NO_ERROR))
			{
				//	Process the PDU with the created application roster.
				rc = application_roster->
								ProcessRosterUpdateIndicationPDU(
							        					set_of_application_info,
							                            sender_id);
				if (rc == GCC_NO_ERROR)
				{
					roster_list->Append(application_roster);
				}
			}
			else 
			{
				if (application_roster != NULL)
                {
					application_roster->Release();
                }
				else
                {
					rc = GCC_ALLOCATION_FAILURE;
                }
			}
		}
	}
	else
	{
		ERROR_OUT(("AppRosterManager::ProcessRosterUpdateIndicationPDU:"
					"ASSERTION: Application Information is not valid"));
		rc = GCC_INVALID_PARAMETER;
	}

	DebugExitINT(CAppRosterMgr::ProcessRosterUpdateIndicationPDU, rc);

	return rc;
}

/*
 *	PSetOfApplicationInformation	FlushRosterUpdateIndication ()
 *
 *	Public Function Description
 *		This routine is used to access any PDU data that might currently be
 *		queued inside the application rosters managed by this application
 *		roster manager.  It also is responsible for flushing any queued 
 *		roster update messages if necessary.
 */
PSetOfApplicationInformation
CAppRosterMgr::FlushRosterUpdateIndication(
						PSetOfApplicationInformation *	set_of_information,
						PGCCError						rc)
{
	PSetOfApplicationInformation	pOld = NULL, pCurr;
	CAppRosterList					*roster_list;
	CAppRoster						*lpAppRoster;

	DebugEntry(CAppRosterMgr::FlushRosterUpdateIndication);

	/*
	**	First we deal with flushing the PDU data. We iterate through the
	**	appropriate list (Global if the Top Provider and Local if not the
	**	Top Provider) and get any PDU data associated with each of these.
	**	Note that some of these may not contain any PDU data.
	*/
	*rc = GCC_NO_ERROR;
	*set_of_information = NULL;

	roster_list = m_fTopProvider ? &m_GlobalRosterList : &m_LocalRosterList;

	roster_list->Reset();
	while (NULL != (lpAppRoster = roster_list->Iterate()))
	{
		lpAppRoster->FlushRosterUpdateIndicationPDU(&pCurr);
		if (pCurr != NULL)
		{
			if (*set_of_information == NULL)
				*set_of_information = pCurr;
			else
				pOld->next = pCurr;

			(pOld = pCurr)->next = NULL;
		}
	}

	/*
	**	Next we deal with delivering the application roster update messages.
	**	We first check to see if any of the global rosters have changed.  If
	**	none have changed, we will not deliver a roster update indication.
	*/
	m_GlobalRosterList.Reset();
	while (NULL != (lpAppRoster = m_GlobalRosterList.Iterate()))
	{
		if (lpAppRoster->HasRosterChanged())
		{
			TRACE_OUT(("AppRosterManager::FlushRosterUpdateIndication:Roster HAS Changed"));
			*rc = SendRosterReportMessage ();
			break;
		}
	}

	/*
	**	Cleanup and reset any application rosters after the above flush is 
	**	completed.  This takes care of removing any rosters that have become
	**	empty.  It also resets the rosters which takes care of resetting all
	**	the internal instance variables to their appropriate initial state.
	*/
	CleanupApplicationRosterLists ();

	DebugExitPTR(CAppRosterMgr::FlushRosterUpdateIndication, pOld);

//
// LONCHANC: Yes, we need to return the last item in the list such that
// we can continue to grow the list.
// In fact, the next call to FlushRosterUpdateIndication() will have
// &pOld as the input argument.
// It is quite tricky.
//
// Please note that pOld is initialized to NULL.
//

	return (pOld); 
}

/*
 *	PSetOfApplicationInformation	GetFullRosterRefreshPDU ()
 *
 *	Public Function Description
 *		This routine is used to obtain a complete roster refresh of all the
 *		rosters maintained by this roster manger.
 */
PSetOfApplicationInformation
				CAppRosterMgr::GetFullRosterRefreshPDU (
						PSetOfApplicationInformation	*	set_of_information,
						PGCCError							rc)
{
	PSetOfApplicationInformation	new_set_of_information = NULL;

	DebugEntry(CAppRosterMgr::GetFullRosterRefreshPDU);

	if (m_fTopProvider)
	{
		CAppRoster			*lpAppRoster;

		*rc = GCC_NO_ERROR;
		*set_of_information = NULL;

		/*
		**	First we must tell all the application rosters to build the
		**	a full refresh PDU internally.
		*/
		m_GlobalRosterList.Reset();
		while (NULL != (lpAppRoster = m_GlobalRosterList.Iterate()))
		{
			*rc = lpAppRoster->BuildFullRefreshPDU();
			if (GCC_NO_ERROR != *rc)
			{
				return NULL;
			}
		}

		/*
		**	Now we flush all the refreshes.  Note that this also takes care
		**	of delivering any queued application roster update messages.
		*/	
		new_set_of_information = FlushRosterUpdateIndication (set_of_information, rc);
	}
	else
		*rc = GCC_INVALID_PARAMETER;

	DebugExitPTR(CAppRosterMgr::GetFullRosterRefreshPDU, new_set_of_information);

	return (new_set_of_information); 
}

/*
 *	Boolean	IsThisYourSessionKey ()
 *
 *	Public Function Description
 *		This routine is used to determine if the specified "API" session key is
 *		associated with this application roster manager.
 */


/*
 *	Boolean	IsThisYourSessionKeyPDU ()
 *
 *	Public Function Description
 *		This routine is used to determine if the specified "PDU" session key is
 *		associated with this application roster manager.
 */


/*
 *	GCCError	RemoveEntityReference ()
 *
 *	Public Function Description
 *		This routine is used to remove the specified APE entity from the 
 *		session it is enrolled with.  Note that this routine is only used
 *		to remove local entity references.
 */								
GCCError	CAppRosterMgr::RemoveEntityReference(EntityID entity_id)
{
	GCCError				rc = GCC_NO_ERROR;
	CAppRosterList			*roster_list;

	DebugEntry(CAppRosterMgr::RemoveEntityReference);

	/*
	**	First remove this entity from the command target list if it is valid.
	**	We then iterate through all the rosters until we determine which
	**	roster holds the record associated with this entity.
	*/
	if (m_AppSapEidList2.Remove(entity_id))
	{
		CAppRoster			*lpAppRoster;

		/*
		**	Now get the affected roster.  Note that if this is not the
		**	top provider we wait for the full refresh to update the
		**	global roster.
		*/
		roster_list = m_fTopProvider ? &m_GlobalRosterList : &m_LocalRosterList;

		/*
		**	Try to delete this record from every roster in the list.
		**	Break when the correct roster is found.
		*/
		roster_list->Reset();
		while (NULL != (lpAppRoster = roster_list->Iterate()))
		{
			rc = lpAppRoster->RemoveRecord(m_pMcsUserObject->GetMyNodeID(), entity_id);
			if (rc == GCC_NO_ERROR)
				break;
		}
	}
	else
		rc = GCC_APP_NOT_ENROLLED;

	DebugExitINT(CAppRosterMgr::RemoveEntityReference, rc);

	return rc;
}

/*
 *	GCCError	RemoveUserReference	()
 *
 *	Public Function Description
 *		This routine is used to remove all references associated with the
 *		node defined by the detached user.
 */								
GCCError	CAppRosterMgr::RemoveUserReference(
									UserID				detached_user)
{
	GCCError				rc = GCC_NO_ERROR;
	GCCError				error_value;
	CAppRosterList			*roster_list;
	CAppRoster				*lpAppRoster;

	DebugEntry(CAppRosterMgr::RemoveUserReference);

	/*
	**	Now get the affected roster.  Note that if this is not the
	**	top provider we wait for the full refresh to update the
	**	global roster.
	*/
	roster_list = m_fTopProvider ? &m_GlobalRosterList : &m_LocalRosterList;

	//	Try to delete this user from every roster in the list
	roster_list->Reset();
	while (NULL != (lpAppRoster = roster_list->Iterate()))
	{
		error_value = lpAppRoster->RemoveUserReference (detached_user);
		if ((error_value != GCC_NO_ERROR) && 
			(error_value != GCC_INVALID_PARAMETER))
		{
			rc = error_value;
			WARNING_OUT(("AppRosterManager::RemoveUserReference:"
						"FATAL error occured while removing user reference."));
			break;
		}
	}

	DebugExitINT(CAppRosterMgr::RemoveUserReference, rc);

	return rc;
}

/*
 *	Boolean	IsEntityEnrolled ()
 *
 *	Public Function Description
 *		This routine informs the caller if the specified entity is enrolled
 *		with any sessions managed by this application roster manager.
 */
BOOL	CAppRosterMgr::IsEntityEnrolled(EntityID application_entity)
{
	BOOL						rc = TRUE;
	CAppRosterList				*application_roster_list;
	CAppRoster					*lpAppRoster;

	DebugEntry(CAppRosterMgr::IsEntityEnrolled);

	application_roster_list = m_fTopProvider ? &m_GlobalRosterList : &m_LocalRosterList;

	application_roster_list->Reset();
	while (NULL != (lpAppRoster = application_roster_list->Iterate()))
	{
		if (lpAppRoster->DoesRecordExist(m_pMcsUserObject->GetMyNodeID(), application_entity))
		{
			rc = TRUE;
			break;
		}
	}

	DebugExitBOOL(AppRosterManager:IsEntityEnrolled, rc);

	return rc;
}

/*
 *	GCCError	ApplicationRosterInquire	()
 *
 *	Public Function Description
 *		This routine fills in an application roster message with either
 *		a single roster (if a session other than the default is specified)
 *		or the complete list of "Global" rosters contained by this roster
 *		manager (if the specified session key is NULL or the session ID is
 *		zero.
 */
GCCError	CAppRosterMgr::ApplicationRosterInquire (
						PGCCSessionKey			session_key,
						CAppRosterMsg			*roster_message)
{
	GCCError				rc = GCC_NO_ERROR;
	CAppRoster				*application_roster = NULL;
	CSessKeyContainer       *pSessKeyData;

	DebugEntry(CAppRosterMgr::ApplicationRosterInquire);

	if (session_key != NULL)
	{
		if (session_key->session_id != 0)
		{
			/*
			**	Here we try to find the specific application roster that was
			**	requested.
			*/
			DBG_SAVE_FILE_LINE
			pSessKeyData = new CSessKeyContainer(session_key, &rc);
			if ((pSessKeyData != NULL) && (rc == GCC_NO_ERROR))
			{
				CAppRoster *lpAppRoster;
				m_GlobalRosterList.Reset();
				while (NULL != (lpAppRoster = m_GlobalRosterList.Iterate()))
				{
					CSessKeyContainer *pTempSessKeyData = lpAppRoster->GetSessionKey();
					if (*pTempSessKeyData == *pSessKeyData)
					{
						application_roster = lpAppRoster;
						break;
					}
				}
			}

			if (pSessKeyData != NULL)
			{
				pSessKeyData->Release();
				if (application_roster == NULL)
				{
					rc = GCC_NO_SUCH_APPLICATION;
				}
			}
			else
			{
				rc = GCC_ALLOCATION_FAILURE;
			}
		}
	}

	if (rc == GCC_NO_ERROR)
	{
		if (application_roster != NULL)
		{
			roster_message->AddRosterToMessage(application_roster);
		}
		else
		{
			CAppRoster *lpAppRoster;
			m_GlobalRosterList.Reset();
			while (NULL != (lpAppRoster = m_GlobalRosterList.Iterate()))
			{
				roster_message->AddRosterToMessage(lpAppRoster);
			}
		}
	}

	DebugExitINT(AppRosterManager:ApplicationRosterInquire, rc);
	return rc;
}

/*
 *	BOOL		IsAPEEnrolled	()
 *
 *	Public Function Description
 *		This function determines if the specified APE is enrolled with
 *		any session in the list.  It does not worry about a specific
 *		session.
 */
BOOL		CAppRosterMgr::IsAPEEnrolled(
						UserID							node_id,
						EntityID						entity_id)
{
	BOOL				rc = FALSE;
	CAppRoster			*lpAppRoster;

	DebugEntry(CAppRosterMgr::IsAPEEnrolled);

	/*
	**	First get a single session key.  Note that it makes no difference
	**	where the key comes from because we are only goin to be comparing
	**	the base object key.
	*/
	m_GlobalRosterList.Reset();
	while (NULL != (lpAppRoster = m_GlobalRosterList.Iterate()))
	{
		if (lpAppRoster->DoesRecordExist (node_id, entity_id))
		{
			rc = TRUE;
			break;
		}
	}

	DebugExitBOOL(AppRosterManager:IsAPEEnrolled, rc);

	return rc;
}

/*
 *	BOOL		IsAPEEnrolled	()
 *
 *	Public Function Description
 *		This function determines if the specified APE is enrolled with
 *		a specific session in the list.
 */
BOOL		CAppRosterMgr::IsAPEEnrolled(
						CSessKeyContainer   		    *session_key_data,
						UserID							node_id,
						EntityID						entity_id)
{
	BOOL				rc = FALSE;
	CAppRoster			*lpAppRoster;

	DebugEntry(CAppRosterMgr::IsAPEEnrolled);

	/*
	**	First get a single session key.  Note that it makes no difference
	**	where the key comes from because we are only goin to be comparing
	**	the base object key.
	*/
	m_GlobalRosterList.Reset();
	while (NULL != (lpAppRoster = m_GlobalRosterList.Iterate()))
	{
		//	We are looking for a session key match
		if (*(lpAppRoster->GetSessionKey()) == *session_key_data)
		{
			//	If a match was found check to see if record exist
			rc = lpAppRoster->DoesRecordExist (node_id, entity_id);
		}
	}

	DebugExitBOOL(AppRosterManager:IsAPEEnrolled, rc);

	return rc;
}

/*
 *	GCCError	IsEmpty	()
 *
 *	Public Function Description
 *		This routine determines if this application roster managfer contains
 *		any application rosters.
 */
BOOL CAppRosterMgr::IsEmpty(void)
{
	return (m_GlobalRosterList.IsEmpty() && m_LocalRosterList.IsEmpty()) ?
					TRUE : FALSE;
}

/*
 *	GCCError	SendRosterReportMessage	()
 *
 *	Private Function Description
 *		This routine is responsible for sending the application roster
 *		update indications to the application SAPs.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR 			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats:
 *		We send indications for all rosters. Even roster that don't currently
 *		contain records.  
 */
GCCError CAppRosterMgr::
SendRosterReportMessage(void)
{
	GCCError					rc = GCC_NO_ERROR;
	CAppRosterMsg				*roster_message;

	DebugEntry(CAppRosterMgr::SendRosterReportMessage);

	if (! m_GlobalRosterList.IsEmpty())
	{
		//	First allocate the roster message
		DBG_SAVE_FILE_LINE
		roster_message = new CAppRosterMsg();
		if (roster_message != NULL)
		{
			CAppRoster			*lpAppRoster;

			m_GlobalRosterList.Reset();
			while (NULL != (lpAppRoster = m_GlobalRosterList.Iterate()))
			{
				roster_message->AddRosterToMessage(lpAppRoster);
			}

			/*
			**	Here we iterate through the complete list of application 
			**	saps to send the roster report indication.  Note that
			**	we used the sent list to avoid sending the same roster
			**	update to a single SAP more than once.  Note that since
			**	this sent list is defined as a local instance variable,
			**	it automatically is cleaned up after each roster update.
			**
			**	Note also that we iterate on a temporary list here in case
			**	an application unenrolls (usually due to a resource error)
			**	during this callback.  We must protect the rogue wave 
			**	iterator.
			*/
			CAppSap *pAppSap;
			CAppSapList SentList;
			CAppSapEidList2 ToSendList(m_AppSapEidList2);
			ToSendList.Reset();
			while (NULL != (pAppSap = ToSendList.Iterate()))
			{
				if (! SentList.Find(pAppSap))
				{
					/*
					**	Hold on to this sap so that we don't send to it 
					**	again for this update.
					*/
					SentList.Append(pAppSap);

					//	Here we actually deliver the roster update.
					pAppSap->AppRosterReportIndication(m_nConfID, roster_message);
				}
			}

			/*
			**	Here we send the roster report indication to the
			**	controler sap.
			*/
			g_pControlSap->AppRosterReportIndication(m_nConfID, roster_message);

			/*
			**	Here we free up the roster message.  Note that if this
			**	message got locked in the roster report indication calls
			**	this free will not delete the roster memory.
			*/
			roster_message->Release();
		}
		else
			rc = GCC_ALLOCATION_FAILURE;
	}

	DebugExitINT(AppRosterManager::SendRosterReportMessage, rc);

	return rc;
}

/*
 *	CAppRoster *GetApplicationRoster ()
 *
 *	Private Function Description
 *		This routine is responsible for returning the application pointer
 *		associated with the specified session key.
 *
 *	Formal Parameters:
 *		session_key	-	Session key associated with roster to return.
 *		roster_list	-	Roster list to search.
 *
 *	Return Value
 *		Either NULL	if roster does not exists in list or a pointer to
 *		the appropriate application roster.
 *		
 *  Side Effects
 *		None.
 *
 *	Caveats:
 *		None.
 */
CAppRoster * CAppRosterMgr::GetApplicationRoster (	
						PGCCSessionKey			session_key,
						CAppRosterList			*roster_list)
{
	GCCError				rc;
	CAppRoster				*application_roster = NULL;
	CAppRoster				*lpAppRoster;
	CSessKeyContainer	    *pTempSessKeyData;

	DebugEntry(CAppRosterMgr::GetApplicationRoster);

	//	First create a temporary session key for comparison purposes
	DBG_SAVE_FILE_LINE
	pTempSessKeyData = new CSessKeyContainer(session_key, &rc);
	if (pTempSessKeyData != NULL && GCC_NO_ERROR == rc)
	{
		//	Now find the affected roster

		//
		// LONCHANC: The following line is totally wrong!!!
		// we passed in roster_list, but now we overwrite it right here???
		// Commented out the following line.
		//      roster_list = m_fTopProvider ? &m_GlobalRosterList : &m_LocalRosterList;
		//

		roster_list->Reset();
		while (NULL != (lpAppRoster = roster_list->Iterate()))
		{
			if(*lpAppRoster->GetSessionKey() == *pTempSessKeyData)
			{
				application_roster = lpAppRoster;
				break;
			}
		}

		pTempSessKeyData->Release();
	}

	DebugExitPTR(AppRosterManager::GetApplicationRoster, application_roster);
	return (application_roster);
}

/*
 *	CAppRoster * GetApplicationRosterFromPDU ()
 *
 *	Private Function Description
 *		This routine is responsible for returning the application pointer
 *		associated with the specified session key PDU.
 *
 *	Formal Parameters:
 *		session_key	-	Session key PDU associated with roster to return.
 *		roster_list	-	Roster list to search.
 *
 *	Return Value
 *		Either NULL	if roster does not exists in list or a pointer to
 *		the appropriate application roster.
 *		
 *  Side Effects
 *		None.
 *
 *	Caveats:
 *		None.
 */
CAppRoster * CAppRosterMgr::GetApplicationRosterFromPDU (	
						PSessionKey				session_key,
						CAppRosterList			*roster_list)
{
	CSessKeyContainer		    *session_key_data;
	CAppRoster					*pAppRoster;

	DebugEntry(CAppRosterMgr::GetApplicationRosterFromPDU);

	roster_list->Reset();
	while (NULL != (pAppRoster = roster_list->Iterate()))
	{
		session_key_data = pAppRoster->GetSessionKey();
		if (session_key_data->IsThisYourSessionKeyPDU (session_key))
		{
			break;
		}
	}

	DebugExitPTR(CAppRosterMgr::GetApplicationRosterFromPDU, pAppRoster);

	return pAppRoster;
}

/*
 *	BOOL IsThisSessionKeyValid ()
 *
 *	Private Function Description
 *		This routine is responsible for determining if the specified
 *		session key's application protocol key matches this application
 *		roster manager's. This routine works on API data.
 *
 *	Formal Parameters:
 *		session_key	-	Session key to check.
 *
 *	Return Value
 *		TRUE	-	If we have a match.
 *		FALSE	-	If we do NOT have a match.
 *		
 *  Side Effects
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	BOOL IsThisSessionKeyPDUValid ()
 *
 *	Private Function Description
 *		This routine is responsible for determining if the specified
 *		session key's application protocol key matches this application
 *		roster manager's.  This routine works on PDU data.
 *
 *	Formal Parameters:
 *		session_key	-	Session key to check.
 *
 *	Return Value
 *		TRUE	-	If we have a match.
 *		FALSE	-	If we do NOT have a match.
 *		
 *  Side Effects
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void		CleanupApplicationRosterLists ()
 *
 *	Private Function Description
 *		This routine is responsible for cleaning up any empty application
 *		rosters.  It also resets all the application rosters back to their
 *		neutral state so that any new updates will be handled  correctly.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		None.
 *		
 *  Side Effects
 *		An owner callback will occur when the roster becomes empty.
 *
 *	Caveats:
 *		This routine does not actually delete the empty rosters until it
 *		is placed in the delete list.  Instead it places the rosters into the
 *		list of deleted rosters which causes them to be deleted the next time
 *		this routine is called (or when the object is destructed).
 */
void	CAppRosterMgr::CleanupApplicationRosterLists(void)
{
	CAppRoster			*lpAppRoster;

	DebugEntry(CAppRosterMgr::CleanupApplicationRosterLists);

	/*
	**	First we iterate through the list of deleted rosters and delete
	**	each entry in it.
	*/
	m_RosterDeleteList.DeleteList();

	/*
	**	Next we iterate through all the rosters and remove any that
	**	contain no application records. Here instead of deleting the
	**	roster we move the roster into the delete list.  We cannot do
	**	the delete here because it is possible that PDU data owned by the
	**	roster being deleted may be used after the Flush is called (or 
	**	after this routine is called).  Therefore, we save it in the delete
	**	list and delete it next time we enter this routine.
	*/

	//	Start with the Global Application Roster List
	m_GlobalRosterList.Reset();
	while (NULL != (lpAppRoster = m_GlobalRosterList.Iterate()))
	{
		if (lpAppRoster->GetNumberOfApplicationRecords() == 0)
		{
            //
            // Here we clean up any "dangling" entries in the application
            // registry by removing all the entries that contain the
            // session key associated with the roster that is being deleted.
            // Note that this is only done when a Global roster list is
            //removed.
            //
            CRegistry *pAppReg = m_pConf->GetRegistry();
            pAppReg->RemoveSessionKeyReference(lpAppRoster->GetSessionKey());

			m_GlobalRosterList.Remove(lpAppRoster);
			m_RosterDeleteList.Append(lpAppRoster);

			TRACE_OUT(("AppRosterMgr: Cleanup: Deleting Global Roster"));

			/*
			**	Since you can not delete a list entry while iterating on it
			**	we must reset the iterator every time an entry is removed.
			*/
			m_GlobalRosterList.Reset();
		}
		else
		{
			/*
			**	Here we reset the application roster to its neutral state.
			**	This affects the nodes added and nodes removed flags.
			*/
			lpAppRoster->ResetApplicationRoster();
		}
	}

	//	Next deal with the Local Application Roster List
	if (! m_fTopProvider)
	{
		m_LocalRosterList.Reset();
		while (NULL != (lpAppRoster = m_LocalRosterList.Iterate()))
		{
			if (lpAppRoster->GetNumberOfApplicationRecords() == 0)
			{
				m_LocalRosterList.Remove(lpAppRoster);
				m_RosterDeleteList.Append(lpAppRoster);

				TRACE_OUT(("AppRosterMgr: Cleanup: Deleting Local Roster"));

				/*
				**	Since you can not delete a list entry while iterating on it
				**	we must reset the iterator every time an entry is removed.
				*/
				m_LocalRosterList.Reset();
			}
			else
			{
				/*
				**	Here we reset the application roster to its neutral state.
				**	This affects the nodes added and nodes removed flags.
				*/
				lpAppRoster->ResetApplicationRoster();
			}
		}
	}
	
	DebugExitVOID(CAppRosterMgr::CleanupApplicationRosterLists);
}

/*
 *	void DeleteRosterRecord ()
 *
 *	Public Function Description
 *		This function overides the base class function and is used to
 *		receive all owner callback information from the application
 *		rosters owned by this object.
 */
void CAppRosterMgr::
DeleteRosterRecord
(
    GCCNodeID       nidRecordToDelete,
    GCCEntityID     eidRecordToDelete
)
{
    //
    // Here we remove ownership from any registry entries associated
    // with the record that was deleted.  Note that since the entity
    // id must be unique for all the APEs at a node (as stated by
    // T.124) there is no need to include the session key to determine
    // which registry entries to clean up.
    //
    CRegistry *pAppReg = m_pConf->GetRegistry();
    pAppReg->RemoveEntityOwnership(nidRecordToDelete, eidRecordToDelete);
}


void CAppRosterMgrList::DeleteList(void)
{
    CAppRosterMgr *pAppRosterMgr;
    while (NULL != (pAppRosterMgr = Get()))
    {
        pAppRosterMgr->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\arostmsg.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_APP_ROSTER);
/* 
 *	arostmsg.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the Application Roster Message 
 *		Class. This	class maintains a list of application rosters, and is able
 *		to "serialize" the list into a block of memory.  It utilizes a 
 *		"Lock - UnLock" facility to ensure that the roster list memory remains
 *		valid until all interested parties are through using the object.
 *
 *	Protected Instance Variables:
 *
 *	Private Member Functions:
 *
 *	Caveats:
 *		This message container holds a list of application rosters that is very
 *		temporary.  This list should not be accessed after Free is called.  It
 *		is important for the users of this class to understand that lock should
 *		be called at least once before any of the application rosters contained
 *		in this list are deleted.
 *
 *	Author:
 *		jbo/blp
 */

#include "arostmsg.h"

/*
 *	CAppRosterMsg()
 *
 *	Public Function Description
 *		This constructor is used to create an empty Application Roster
 *		Message.
 */
CAppRosterMsg::CAppRosterMsg(void)
:
    CRefCount(MAKE_STAMP_ID('A','R','M','g')),
    m_pMsgData(NULL)
{
}
 
/*
 *	~CAppRosterMsg()
 *
 *	Public Function Description:
 *		The destructor for the CAppRosterMsg class will clean up
 *		any memory allocated during the life of the object.
 */
CAppRosterMsg::~CAppRosterMsg(void)
{
    delete m_pMsgData;
}

/*
 *	GCCError	LockApplicationRosterMessage	()
 *
 *	Public Function Description
 *		This routine is used to lock an CAppRosterMsg.  The memory
 *		necessary to hold the list of rosters is allocated and the rosters are
 *		"serialized" into the allocated memory block.
 */
GCCError CAppRosterMsg::LockApplicationRosterMessage(void)
{  
	GCCError						rc = GCC_NO_ERROR;
	PGCCApplicationRoster 		*	roster_list;
	DWORD							i;
	UINT							roster_data_length;
	LPBYTE							memory_pointer;
	UINT							number_of_rosters;

	DebugEntry(CAppRosterMsg::LockApplicationRosterMessage);

	/*
	 * If this is the first time this routine is called, determine the size of 
	 * the memory required to hold the list of application rosters and go ahead
	 * and serialize the data.  Otherwise, just increment the lock count.
	 */
	if (Lock() == 1)
	{
		CAppRoster *lpAppRoster;

		ASSERT(NULL == m_pMsgData);

		//	Here we are determining the size of the memory block.
		number_of_rosters = m_AppRosterList.GetCount();

		roster_data_length = number_of_rosters * 
				(sizeof(PGCCApplicationRoster) + ROUNDTOBOUNDARY(sizeof(GCCApplicationRoster)));
 
		m_AppRosterList.Reset();
		while (NULL != (lpAppRoster = m_AppRosterList.Iterate()))
		{
			roster_data_length += lpAppRoster->LockApplicationRoster();
		}

		/*
		 * Allocate space to hold the list of GCCApplicationRoster pointers
		 * as well as rosters and all associated data.  
		 */
		if (roster_data_length != 0)
		{
		    DBG_SAVE_FILE_LINE
			if (NULL != (m_pMsgData = new BYTE[roster_data_length]))
			{
                ::ZeroMemory(m_pMsgData, roster_data_length);
				/*
				 * Retrieve the memory pointer and save it in the list of
				 * GCCApplicationRoster pointers.
				 */
				memory_pointer = m_pMsgData;
				roster_list = (PGCCApplicationRoster *)memory_pointer;

				/*
				 * Initialize all of the roster list pointers to NULL.  Move
				 * the memory pointer past the list of pointers.  This is where
				 * the first application roster will be written.
				 */
				for (i = 0; i < number_of_rosters; i++)
				{
					roster_list[i] = NULL;
				}
				memory_pointer += number_of_rosters * sizeof(PGCCApplicationRoster);

				/*
				 * Retrieve all of the data for each application roster.
				 */
				i = 0;
				m_AppRosterList.Reset();
				while (NULL != (lpAppRoster = m_AppRosterList.Iterate()))
				{
					/*
					 * Save the pointer to the roster structure in the list.
					 */
					roster_list[i] = (PGCCApplicationRoster)memory_pointer;

					/*
					 * Move the memory pointer past the actual roster structure.
					 */
					memory_pointer += ROUNDTOBOUNDARY(sizeof(GCCApplicationRoster));

					/*
					 * Fill in the roster structure and all associated data.
					 */
					roster_data_length = lpAppRoster->GetAppRoster(roster_list[i], memory_pointer);

					/*
					 * Move the memory pointer past the roster data.  This where
					 * the next roster structure will begin.
					 */
					memory_pointer += roster_data_length;

					//	Increment the counter
					i++;
				}
			}
			else
            {
                ERROR_OUT(("CAppRosterMsg::LockApplicationRosterMessage: "
                            "can't allocate memory, size=%u", (UINT) roster_data_length));
				rc = GCC_ALLOCATION_FAILURE;
            }
		}

		/*
		**	Since we do not need the application rosters anymore it is
		**	OK to unlock them here.
		*/		
		m_AppRosterList.Reset();
		while (NULL != (lpAppRoster = m_AppRosterList.Iterate()))
		{
			lpAppRoster->UnLockApplicationRoster();
		}
	}

	if (rc != GCC_NO_ERROR)
	{
        Unlock();
	}

	return (rc);
}

/*
 *	GCCError	GetAppRosterMsg	()
 *
 *	Public Function Description
 *		This routine is used to obtain a pointer to the Application Roster
 *		list memory block used to deliver messages.
 *		This routine should not be called before LockApplicationRosterMessage is
 *		called. 
 */
GCCError	CAppRosterMsg::GetAppRosterMsg(LPBYTE *ppRosterData, ULONG *pcRosters)
{
	GCCError	rc;

	DebugEntry(CAppRosterMsg::GetAppRosterMsg);

	if (GetLockCount() > 0)
	{
		if (((m_pMsgData != NULL) && (m_AppRosterList.GetCount() != 0)) ||
			(m_AppRosterList.GetCount() == 0))
		{
			*ppRosterData = m_pMsgData;
			*pcRosters = m_AppRosterList.GetCount();
			rc = GCC_NO_ERROR;
		}
	}
	else
	{
		ERROR_OUT(("CAppRosterMsg::GetAppRosterMsg: app roster msg is not locked"));
        rc = GCC_ALLOCATION_FAILURE;
	}

	DebugExitINT(CAppRosterMsg::GetAppRosterMsg, rc);
	return rc;
}


/*
 *	void	UnLockApplicationRosterMessage	()
 *
 *	Public Function Description
 *		This member function is responsible for unlocking the data locked for 
 *		the "API" application roster after the lock count goes to zero.
 */
void CAppRosterMsg::UnLockApplicationRosterMessage(void)
{
	DebugEntry(CAppRosterMsg::UnLockApplicationRosterMessage);

	if (Unlock(FALSE) == 0)
	{
		/*
		 * Free up the memory block allocated to hold the roster
		 */
		delete m_pMsgData;
		m_pMsgData = NULL;
	}

    // we have to call Release() because we used Unlock(FALSE)
    Release();
}


/*
 *	GCCError	AddRosterToMessage ()
 *
 *	Public Function Description
 *		This function adds an application roster pointer to the internal list
 *		of app roster pointers.  Note that this list is very temporary and
 *		should not be accessed after the free flag is set.
 */
void CAppRosterMsg::AddRosterToMessage(CAppRoster *pAppRoster)
{
	m_AppRosterList.Append(pAppRoster);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\cnppdu.h ===
/* Copyright (C) Microsoft Corporation, 1999. All rights reserved. */
/* ASN.1 definitions for Connection Negotiation Protocol (GNP) */

#ifndef _CNPPDU_Module_H_
#define _CNPPDU_Module_H_

#include "msper.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct CNP_TransportAddress_ipSourceRoute_route * PCNP_TransportAddress_ipSourceRoute_route;

typedef struct CNP_TransportAddress_ipAddress_nonStandardParameters * PCNP_TransportAddress_ipAddress_nonStandardParameters;

typedef struct CNP_TransportAddress_ipSourceRoute_nonStandardParameters * PCNP_TransportAddress_ipSourceRoute_nonStandardParameters;

typedef struct CNP_TransportAddress_ipxAddress_nonStandardParameters * PCNP_TransportAddress_ipxAddress_nonStandardParameters;

typedef struct CNP_TransportAddress_ip6Address_nonStandardParameters * PCNP_TransportAddress_ip6Address_nonStandardParameters;

typedef struct CNP_NonStandardPDU_nonStandardParameters * PCNP_NonStandardPDU_nonStandardParameters;

typedef struct ErrorPDU_nonStandardParameters * PErrorPDU_nonStandardParameters;

typedef struct DisconnectRequestPDU_nonStandardParameters * PDisconnectRequestPDU_nonStandardParameters;

typedef struct ConnectConfirmPDU_nonStandardParameters * PConnectConfirmPDU_nonStandardParameters;

typedef struct ConnectRequestPDU_nonStandardParameters * PConnectRequestPDU_nonStandardParameters;

typedef struct ConnectRequestPDU_unreliableSecurityProtocols * PConnectRequestPDU_unreliableSecurityProtocols;

typedef struct ConnectRequestPDU_reliableTransportProtocols * PConnectRequestPDU_reliableTransportProtocols;

typedef struct UnreliableTransportProtocol_nonStandardParameters * PUnreliableTransportProtocol_nonStandardParameters;

typedef struct ReliableTransportProtocol_nonStandardParameters * PReliableTransportProtocol_nonStandardParameters;

typedef struct PrivatePartyNumber_nonStandardParameters * PPrivatePartyNumber_nonStandardParameters;

typedef struct PublicPartyNumber_nonStandardParameters * PPublicPartyNumber_nonStandardParameters;

typedef struct DisconnectRequestPDU_destinationAddress * PDisconnectRequestPDU_destinationAddress;

typedef struct ConnectRequestPDU_destinationAddress * PConnectRequestPDU_destinationAddress;

typedef struct ConnectRequestPDU_unreliableTransportProtocols * PConnectRequestPDU_unreliableTransportProtocols;

typedef struct ConnectRequestPDU_reliableSecurityProtocols * PConnectRequestPDU_reliableSecurityProtocols;

typedef struct CNP_TransportAddress_ipSourceRoute_route_Seq {
    ASN1uint32_t length;
    ASN1octet_t value[4];
} CNP_TransportAddress_ipSourceRoute_route_Seq;

typedef ASN1char_t NumberDigits[129];

typedef ASN1uint16_t TPDUSize;

typedef ASN1uint16_t CNP_Priority;

typedef ASN1objectidentifier_t ProtocolIdentifier;

typedef struct CNP_TransportAddress_ipSourceRoute_route {
    PCNP_TransportAddress_ipSourceRoute_route next;
    CNP_TransportAddress_ipSourceRoute_route_Seq value;
} CNP_TransportAddress_ipSourceRoute_route_Element;

typedef struct CNP_TransportAddress_ip6Address {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    struct CNP_TransportAddress_ip6Address_ip_ip {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } ip;
    ASN1uint16_t port;
#   define CNP_TransportAddress_ip6Address_nonStandardParameters_present 0x80
    PCNP_TransportAddress_ip6Address_nonStandardParameters nonStandardParameters;
} CNP_TransportAddress_ip6Address;

typedef struct CNP_TransportAddress_ipxAddress {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    struct CNP_TransportAddress_ipxAddress_node_node {
	ASN1uint32_t length;
	ASN1octet_t value[6];
    } node;
    struct CNP_TransportAddress_ipxAddress_netnum_netnum {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } netnum;
    struct CNP_TransportAddress_ipxAddress_port_port {
	ASN1uint32_t length;
	ASN1octet_t value[2];
    } port;
#   define CNP_TransportAddress_ipxAddress_nonStandardParameters_present 0x80
    PCNP_TransportAddress_ipxAddress_nonStandardParameters nonStandardParameters;
} CNP_TransportAddress_ipxAddress;

typedef struct CNP_TransportAddress_ipAddress {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    struct CNP_TransportAddress_ipAddress_ip_ip {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } ip;
    ASN1uint16_t port;
#   define CNP_TransportAddress_ipAddress_nonStandardParameters_present 0x80
    PCNP_TransportAddress_ipAddress_nonStandardParameters nonStandardParameters;
} CNP_TransportAddress_ipAddress;

typedef struct H221NonStandard {
    ASN1uint16_t t35CountryCode;
    ASN1uint16_t t35Extension;
    ASN1uint16_t manufacturerCode;
} H221NonStandard;

typedef struct NonStandardIdentifier {
    ASN1choice_t choice;
    union {
#	define object_chosen 1
	ASN1objectidentifier_t object;
#	define h221NonStandard_chosen 2
	H221NonStandard h221NonStandard;
    } u;
} NonStandardIdentifier;

typedef struct CNP_NonStandardParameter {
    NonStandardIdentifier nonStandardIdentifier;
    ASN1octetstring_t data;
} CNP_NonStandardParameter;

typedef struct PublicTypeOfNumber {
    ASN1choice_t choice;
    union {
#	define PublicTypeOfNumber_unknown_chosen 1
#	define internationalNumber_chosen 2
#	define nationalNumber_chosen 3
#	define networkSpecificNumber_chosen 4
#	define subscriberNumber_chosen 5
#	define PublicTypeOfNumber_abbreviatedNumber_chosen 6
#	define nonStandardPublicTypeOfNumber_chosen 7
	CNP_NonStandardParameter nonStandardPublicTypeOfNumber;
    } u;
} PublicTypeOfNumber;

typedef struct PublicPartyNumber {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PublicTypeOfNumber publicTypeOfNumber;
    NumberDigits publicNumberDigits;
#   define PublicPartyNumber_nonStandardParameters_present 0x80
    PPublicPartyNumber_nonStandardParameters nonStandardParameters;
} PublicPartyNumber;

typedef struct PrivateTypeOfNumber {
    ASN1choice_t choice;
    union {
#	define PrivateTypeOfNumber_unknown_chosen 1
#	define level2RegionalNumber_chosen 2
#	define level1RegionalNumber_chosen 3
#	define pISNSpecificNumber_chosen 4
#	define localNumber_chosen 5
#	define PrivateTypeOfNumber_abbreviatedNumber_chosen 6
#	define nonStandardPrivateTypeOfNumber_chosen 7
	CNP_NonStandardParameter nonStandardPrivateTypeOfNumber;
    } u;
} PrivateTypeOfNumber;

typedef struct PrivatePartyNumber {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PrivateTypeOfNumber privateTypeOfNumber;
    NumberDigits privateNumberDigits;
#   define PrivatePartyNumber_nonStandardParameters_present 0x80
    PPrivatePartyNumber_nonStandardParameters nonStandardParameters;
} PrivatePartyNumber;

typedef struct PartyNumber {
    ASN1choice_t choice;
    union {
#	define publicNumber_chosen 1
	PublicPartyNumber publicNumber;
#	define dataPartyNumber_chosen 2
	NumberDigits dataPartyNumber;
#	define telexPartyNumber_chosen 3
	NumberDigits telexPartyNumber;
#	define privateNumber_chosen 4
	PrivatePartyNumber privateNumber;
#	define nationalStandardPartyNumber_chosen 5
	NumberDigits nationalStandardPartyNumber;
#	define nonStandardPartyNumber_chosen 6
	CNP_NonStandardParameter nonStandardPartyNumber;
    } u;
} PartyNumber;

typedef struct ReliableTransportProtocolType {
    ASN1choice_t choice;
    union {
#	define cnp_chosen 1
#	define x224_chosen 2
#	define map_chosen 3
#	define ReliableTransportProtocolType_nonStandardTransportProtocol_chosen 4
	CNP_NonStandardParameter nonStandardTransportProtocol;
    } u;
} ReliableTransportProtocolType;

typedef struct ReliableTransportProtocol {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ReliableTransportProtocolType type;
    TPDUSize maxTPDUSize;
#   define ReliableTransportProtocol_nonStandardParameters_present 0x80
    PReliableTransportProtocol_nonStandardParameters nonStandardParameters;
} ReliableTransportProtocol;

typedef struct UnreliableTransportProtocolType {
    ASN1choice_t choice;
    union {
#	define x234_chosen 1
#	define UnreliableTransportProtocolType_nonStandardTransportProtocol_chosen 2
	CNP_NonStandardParameter nonStandardTransportProtocol;
    } u;
} UnreliableTransportProtocolType;

typedef struct UnreliableSecurityProtocol {
    ASN1choice_t choice;
    union {
#	define UnreliableSecurityProtocol_none_chosen 1
#	define UnreliableSecurityProtocol_ipsecIKEKeyManagement_chosen 2
#	define UnreliableSecurityProtocol_ipsecManualKeyManagement_chosen 3
#	define UnreliableSecurityProtocol_physical_chosen 4
#	define UnreliableSecurityProtocol_nonStandardSecurityProtocol_chosen 5
	CNP_NonStandardParameter nonStandardSecurityProtocol;
    } u;
} UnreliableSecurityProtocol;

typedef struct X274WithSAIDInfo {
    ASN1octetstring_t localSAID;
    ASN1octetstring_t peerSAID;
} X274WithSAIDInfo;

typedef struct ConnectRequestPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ProtocolIdentifier protocolIdentifier;
    ASN1bool_t reconnectRequested;
#   define priority_present 0x80
    CNP_Priority priority;
#   define reliableTransportProtocols_present 0x40
    PConnectRequestPDU_reliableTransportProtocols reliableTransportProtocols;
#   define reliableSecurityProtocols_present 0x20
    PConnectRequestPDU_reliableSecurityProtocols reliableSecurityProtocols;
#   define unreliableTransportProtocols_present 0x10
    PConnectRequestPDU_unreliableTransportProtocols unreliableTransportProtocols;
#   define unreliableSecurityProtocols_present 0x8
    PConnectRequestPDU_unreliableSecurityProtocols unreliableSecurityProtocols;
#   define ConnectRequestPDU_destinationAddress_present 0x4
    PConnectRequestPDU_destinationAddress destinationAddress;
#   define ConnectRequestPDU_nonStandardParameters_present 0x2
    PConnectRequestPDU_nonStandardParameters nonStandardParameters;
} ConnectRequestPDU;

typedef struct DisconnectReason {
    ASN1choice_t choice;
    union {
#	define unacceptableVersion_chosen 1
#	define incompatibleParameters_chosen 2
#	define securityDenied_chosen 3
#	define destinationUnreachable_chosen 4
#	define userRejected_chosen 5
#	define userInitiated_chosen 6
#	define protocolError_chosen 7
#	define unspecifiedFailure_chosen 8
#	define routeToAlternate_chosen 9
#	define nonStandardDisconnectReason_chosen 10
	CNP_NonStandardParameter nonStandardDisconnectReason;
    } u;
} DisconnectReason;

typedef struct RejectCause {
    ASN1choice_t choice;
    union {
#	define unrecognizedPDU_chosen 1
#	define invalidParameter_chosen 2
#	define causeUnspecified_chosen 3
#	define nonStandardRejectCause_chosen 4
	CNP_NonStandardParameter nonStandardRejectCause;
    } u;
} RejectCause;

typedef struct ErrorPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RejectCause rejectCause;
    ASN1octetstring_t rejectedPDU;
#   define ErrorPDU_nonStandardParameters_present 0x80
    PErrorPDU_nonStandardParameters nonStandardParameters;
} ErrorPDU;

typedef struct CNP_NonStandardPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define CNP_NonStandardPDU_nonStandardParameters_present 0x80
    PCNP_NonStandardPDU_nonStandardParameters nonStandardParameters;
} CNP_NonStandardPDU;

typedef struct CNP_TransportAddress_ipAddress_nonStandardParameters {
    PCNP_TransportAddress_ipAddress_nonStandardParameters next;
    CNP_NonStandardParameter value;
} CNP_TransportAddress_ipAddress_nonStandardParameters_Element;

typedef struct CNP_TransportAddress_ipSourceRoute_nonStandardParameters {
    PCNP_TransportAddress_ipSourceRoute_nonStandardParameters next;
    CNP_NonStandardParameter value;
} CNP_TransportAddress_ipSourceRoute_nonStandardParameters_Element;

typedef struct CNP_TransportAddress_ipSourceRoute_routing {
    ASN1choice_t choice;
    union {
#	define strict_chosen 1
#	define loose_chosen 2
#	define nonStandardRouting_chosen 3
	CNP_NonStandardParameter nonStandardRouting;
    } u;
} CNP_TransportAddress_ipSourceRoute_routing;

typedef struct CNP_TransportAddress_ipxAddress_nonStandardParameters {
    PCNP_TransportAddress_ipxAddress_nonStandardParameters next;
    CNP_NonStandardParameter value;
} CNP_TransportAddress_ipxAddress_nonStandardParameters_Element;

typedef struct CNP_TransportAddress_ip6Address_nonStandardParameters {
    PCNP_TransportAddress_ip6Address_nonStandardParameters next;
    CNP_NonStandardParameter value;
} CNP_TransportAddress_ip6Address_nonStandardParameters_Element;

typedef struct CNP_NonStandardPDU_nonStandardParameters {
    PCNP_NonStandardPDU_nonStandardParameters next;
    CNP_NonStandardParameter value;
} CNP_NonStandardPDU_nonStandardParameters_Element;

typedef struct ErrorPDU_nonStandardParameters {
    PErrorPDU_nonStandardParameters next;
    CNP_NonStandardParameter value;
} ErrorPDU_nonStandardParameters_Element;

typedef struct DisconnectRequestPDU_nonStandardParameters {
    PDisconnectRequestPDU_nonStandardParameters next;
    CNP_NonStandardParameter value;
} DisconnectRequestPDU_nonStandardParameters_Element;

typedef struct ConnectConfirmPDU_nonStandardParameters {
    PConnectConfirmPDU_nonStandardParameters next;
    CNP_NonStandardParameter value;
} ConnectConfirmPDU_nonStandardParameters_Element;

typedef struct ConnectRequestPDU_nonStandardParameters {
    PConnectRequestPDU_nonStandardParameters next;
    CNP_NonStandardParameter value;
} ConnectRequestPDU_nonStandardParameters_Element;

typedef struct ConnectRequestPDU_unreliableSecurityProtocols {
    PConnectRequestPDU_unreliableSecurityProtocols next;
    UnreliableSecurityProtocol value;
} ConnectRequestPDU_unreliableSecurityProtocols_Element;

typedef struct ConnectRequestPDU_reliableTransportProtocols {
    PConnectRequestPDU_reliableTransportProtocols next;
    ReliableTransportProtocol value;
} ConnectRequestPDU_reliableTransportProtocols_Element;

typedef struct UnreliableTransportProtocol_nonStandardParameters {
    PUnreliableTransportProtocol_nonStandardParameters next;
    CNP_NonStandardParameter value;
} UnreliableTransportProtocol_nonStandardParameters_Element;

typedef struct ReliableTransportProtocol_nonStandardParameters {
    PReliableTransportProtocol_nonStandardParameters next;
    CNP_NonStandardParameter value;
} ReliableTransportProtocol_nonStandardParameters_Element;

typedef struct PrivatePartyNumber_nonStandardParameters {
    PPrivatePartyNumber_nonStandardParameters next;
    CNP_NonStandardParameter value;
} PrivatePartyNumber_nonStandardParameters_Element;

typedef struct PublicPartyNumber_nonStandardParameters {
    PPublicPartyNumber_nonStandardParameters next;
    CNP_NonStandardParameter value;
} PublicPartyNumber_nonStandardParameters_Element;

typedef struct CNP_TransportAddress_ipSourceRoute {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    struct CNP_TransportAddress_ipSourceRoute_ip_ip {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } ip;
    ASN1uint16_t port;
    PCNP_TransportAddress_ipSourceRoute_route route;
    CNP_TransportAddress_ipSourceRoute_routing routing;
#   define CNP_TransportAddress_ipSourceRoute_nonStandardParameters_present 0x80
    PCNP_TransportAddress_ipSourceRoute_nonStandardParameters nonStandardParameters;
} CNP_TransportAddress_ipSourceRoute;

typedef struct CNP_TransportAddress {
    ASN1choice_t choice;
    union {
#	define ipAddress_chosen 1
	CNP_TransportAddress_ipAddress ipAddress;
#	define ipSourceRoute_chosen 2
	CNP_TransportAddress_ipSourceRoute ipSourceRoute;
#	define ipxAddress_chosen 3
	CNP_TransportAddress_ipxAddress ipxAddress;
#	define ip6Address_chosen 4
	CNP_TransportAddress_ip6Address ip6Address;
#	define netBios_chosen 5
	struct CNP_TransportAddress_netBios_netBios {
	    ASN1uint32_t length;
	    ASN1octet_t value[16];
	} netBios;
#	define nsap_chosen 6
	struct CNP_TransportAddress_nsap_nsap {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsap;
#	define nonStandardTransportAddress_chosen 7
	CNP_NonStandardParameter nonStandardTransportAddress;
    } u;
} CNP_TransportAddress;

typedef struct AliasAddress {
    ASN1choice_t choice;
    union {
#	define e164Address_chosen 1
	NumberDigits e164Address;
#	define name_chosen 2
	ASN1char16string_t name;
#	define url_chosen 3
	ASN1char_t url[513];
#	define transportAddress_chosen 4
	CNP_TransportAddress transportAddress;
#	define emailAddress_chosen 5
	ASN1char_t emailAddress[513];
#	define partyNumber_chosen 6
	PartyNumber partyNumber;
#	define nonStandardAliasAddress_chosen 7
	CNP_NonStandardParameter nonStandardAliasAddress;
    } u;
} AliasAddress;

typedef struct ReliableSecurityProtocol {
    ASN1choice_t choice;
    union {
#	define ReliableSecurityProtocol_none_chosen 1
#	define tls_chosen 2
#	define ssl_chosen 3
#	define ReliableSecurityProtocol_ipsecIKEKeyManagement_chosen 4
#	define ReliableSecurityProtocol_ipsecManualKeyManagement_chosen 5
#	define x274WithoutSAID_chosen 6
#	define x274WithSAID_chosen 7
	X274WithSAIDInfo x274WithSAID;
#	define ReliableSecurityProtocol_physical_chosen 8
#	define gssApiX224_chosen 9
#	define ReliableSecurityProtocol_nonStandardSecurityProtocol_chosen 10
	CNP_NonStandardParameter nonStandardSecurityProtocol;
    } u;
} ReliableSecurityProtocol;

typedef struct UnreliableTransportProtocol {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    UnreliableTransportProtocolType type;
    TPDUSize maxTPDUSize;
    CNP_TransportAddress sourceAddress;
#   define sourceTSAP_present 0x80
    ASN1octetstring_t sourceTSAP;
#   define UnreliableTransportProtocol_nonStandardParameters_present 0x40
    PUnreliableTransportProtocol_nonStandardParameters nonStandardParameters;
} UnreliableTransportProtocol;

typedef struct ConnectConfirmPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ProtocolIdentifier protocolIdentifier;
#   define ConnectConfirmPDU_reliableTransportProtocol_present 0x80
    ReliableTransportProtocol reliableTransportProtocol;
#   define ConnectConfirmPDU_reliableSecurityProtocol_present 0x40
    ReliableSecurityProtocol reliableSecurityProtocol;
#   define ConnectConfirmPDU_unreliableTransportProtocol_present 0x20
    UnreliableTransportProtocol unreliableTransportProtocol;
#   define ConnectConfirmPDU_unreliableSecurityProtocol_present 0x10
    UnreliableSecurityProtocol unreliableSecurityProtocol;
#   define ConnectConfirmPDU_nonStandardParameters_present 0x8
    PConnectConfirmPDU_nonStandardParameters nonStandardParameters;
} ConnectConfirmPDU;

typedef struct DisconnectRequestPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    DisconnectReason disconnectReason;
#   define DisconnectRequestPDU_reliableTransportProtocol_present 0x80
    ReliableTransportProtocol reliableTransportProtocol;
#   define DisconnectRequestPDU_reliableSecurityProtocol_present 0x40
    ReliableSecurityProtocol reliableSecurityProtocol;
#   define DisconnectRequestPDU_unreliableTransportProtocol_present 0x20
    UnreliableTransportProtocol unreliableTransportProtocol;
#   define DisconnectRequestPDU_unreliableSecurityProtocol_present 0x10
    UnreliableSecurityProtocol unreliableSecurityProtocol;
#   define DisconnectRequestPDU_destinationAddress_present 0x8
    PDisconnectRequestPDU_destinationAddress destinationAddress;
#   define DisconnectRequestPDU_nonStandardParameters_present 0x4
    PDisconnectRequestPDU_nonStandardParameters nonStandardParameters;
} DisconnectRequestPDU;

typedef struct CNPPDU {
    ASN1choice_t choice;
    union {
#	define connectRequest_chosen 1
	ConnectRequestPDU connectRequest;
#	define connectConfirm_chosen 2
	ConnectConfirmPDU connectConfirm;
#	define disconnectRequest_chosen 3
	DisconnectRequestPDU disconnectRequest;
#	define error_chosen 4
	ErrorPDU error;
#	define nonStandardCNPPDU_chosen 5
	CNP_NonStandardPDU nonStandardCNPPDU;
    } u;
} CNPPDU;
#define CNPPDU_PDU 0
#define SIZE_CNPPDU_Module_PDU_0 sizeof(CNPPDU)

typedef struct DisconnectRequestPDU_destinationAddress {
    PDisconnectRequestPDU_destinationAddress next;
    AliasAddress value;
} DisconnectRequestPDU_destinationAddress_Element;

typedef struct ConnectRequestPDU_destinationAddress {
    PConnectRequestPDU_destinationAddress next;
    AliasAddress value;
} ConnectRequestPDU_destinationAddress_Element;

typedef struct ConnectRequestPDU_unreliableTransportProtocols {
    PConnectRequestPDU_unreliableTransportProtocols next;
    UnreliableTransportProtocol value;
} ConnectRequestPDU_unreliableTransportProtocols_Element;

typedef struct ConnectRequestPDU_reliableSecurityProtocols {
    PConnectRequestPDU_reliableSecurityProtocols next;
    ReliableSecurityProtocol value;
} ConnectRequestPDU_reliableSecurityProtocols_Element;

extern ASN1objectidentifier_t t123AnnexBProtocolId;

extern ASN1module_t CNPPDU_Module;
extern void ASN1CALL CNPPDU_Module_Startup(void);
extern void ASN1CALL CNPPDU_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */
    extern int ASN1CALL ASN1Enc_CNP_TransportAddress_ipSourceRoute_route_ElmFn(ASN1encoding_t enc, PCNP_TransportAddress_ipSourceRoute_route val);
    extern int ASN1CALL ASN1Dec_CNP_TransportAddress_ipSourceRoute_route_ElmFn(ASN1decoding_t dec, PCNP_TransportAddress_ipSourceRoute_route val);
	extern void ASN1CALL ASN1Free_CNP_TransportAddress_ipSourceRoute_route_ElmFn(PCNP_TransportAddress_ipSourceRoute_route val);
    extern int ASN1CALL ASN1Enc_CNP_TransportAddress_ipAddress_nonStandardParameters_ElmFn(ASN1encoding_t enc, PCNP_TransportAddress_ipAddress_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_CNP_TransportAddress_ipAddress_nonStandardParameters_ElmFn(ASN1decoding_t dec, PCNP_TransportAddress_ipAddress_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_CNP_TransportAddress_ipAddress_nonStandardParameters_ElmFn(PCNP_TransportAddress_ipAddress_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_CNP_TransportAddress_ipSourceRoute_nonStandardParameters_ElmFn(ASN1encoding_t enc, PCNP_TransportAddress_ipSourceRoute_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_CNP_TransportAddress_ipSourceRoute_nonStandardParameters_ElmFn(ASN1decoding_t dec, PCNP_TransportAddress_ipSourceRoute_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_CNP_TransportAddress_ipSourceRoute_nonStandardParameters_ElmFn(PCNP_TransportAddress_ipSourceRoute_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_CNP_TransportAddress_ipxAddress_nonStandardParameters_ElmFn(ASN1encoding_t enc, PCNP_TransportAddress_ipxAddress_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_CNP_TransportAddress_ipxAddress_nonStandardParameters_ElmFn(ASN1decoding_t dec, PCNP_TransportAddress_ipxAddress_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_CNP_TransportAddress_ipxAddress_nonStandardParameters_ElmFn(PCNP_TransportAddress_ipxAddress_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_CNP_TransportAddress_ip6Address_nonStandardParameters_ElmFn(ASN1encoding_t enc, PCNP_TransportAddress_ip6Address_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_CNP_TransportAddress_ip6Address_nonStandardParameters_ElmFn(ASN1decoding_t dec, PCNP_TransportAddress_ip6Address_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_CNP_TransportAddress_ip6Address_nonStandardParameters_ElmFn(PCNP_TransportAddress_ip6Address_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_CNP_NonStandardPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PCNP_NonStandardPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_CNP_NonStandardPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PCNP_NonStandardPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_CNP_NonStandardPDU_nonStandardParameters_ElmFn(PCNP_NonStandardPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_ErrorPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PErrorPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_ErrorPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PErrorPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_ErrorPDU_nonStandardParameters_ElmFn(PErrorPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_DisconnectRequestPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PDisconnectRequestPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_DisconnectRequestPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PDisconnectRequestPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_DisconnectRequestPDU_nonStandardParameters_ElmFn(PDisconnectRequestPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_ConnectConfirmPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PConnectConfirmPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_ConnectConfirmPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PConnectConfirmPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_ConnectConfirmPDU_nonStandardParameters_ElmFn(PConnectConfirmPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_ConnectRequestPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PConnectRequestPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_ConnectRequestPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PConnectRequestPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_ConnectRequestPDU_nonStandardParameters_ElmFn(PConnectRequestPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_ConnectRequestPDU_unreliableSecurityProtocols_ElmFn(ASN1encoding_t enc, PConnectRequestPDU_unreliableSecurityProtocols val);
    extern int ASN1CALL ASN1Dec_ConnectRequestPDU_unreliableSecurityProtocols_ElmFn(ASN1decoding_t dec, PConnectRequestPDU_unreliableSecurityProtocols val);
	extern void ASN1CALL ASN1Free_ConnectRequestPDU_unreliableSecurityProtocols_ElmFn(PConnectRequestPDU_unreliableSecurityProtocols val);
    extern int ASN1CALL ASN1Enc_ConnectRequestPDU_reliableTransportProtocols_ElmFn(ASN1encoding_t enc, PConnectRequestPDU_reliableTransportProtocols val);
    extern int ASN1CALL ASN1Dec_ConnectRequestPDU_reliableTransportProtocols_ElmFn(ASN1decoding_t dec, PConnectRequestPDU_reliableTransportProtocols val);
	extern void ASN1CALL ASN1Free_ConnectRequestPDU_reliableTransportProtocols_ElmFn(PConnectRequestPDU_reliableTransportProtocols val);
    extern int ASN1CALL ASN1Enc_UnreliableTransportProtocol_nonStandardParameters_ElmFn(ASN1encoding_t enc, PUnreliableTransportProtocol_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_UnreliableTransportProtocol_nonStandardParameters_ElmFn(ASN1decoding_t dec, PUnreliableTransportProtocol_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_UnreliableTransportProtocol_nonStandardParameters_ElmFn(PUnreliableTransportProtocol_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_ReliableTransportProtocol_nonStandardParameters_ElmFn(ASN1encoding_t enc, PReliableTransportProtocol_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_ReliableTransportProtocol_nonStandardParameters_ElmFn(ASN1decoding_t dec, PReliableTransportProtocol_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_ReliableTransportProtocol_nonStandardParameters_ElmFn(PReliableTransportProtocol_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_PrivatePartyNumber_nonStandardParameters_ElmFn(ASN1encoding_t enc, PPrivatePartyNumber_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_PrivatePartyNumber_nonStandardParameters_ElmFn(ASN1decoding_t dec, PPrivatePartyNumber_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_PrivatePartyNumber_nonStandardParameters_ElmFn(PPrivatePartyNumber_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_PublicPartyNumber_nonStandardParameters_ElmFn(ASN1encoding_t enc, PPublicPartyNumber_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_PublicPartyNumber_nonStandardParameters_ElmFn(ASN1decoding_t dec, PPublicPartyNumber_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_PublicPartyNumber_nonStandardParameters_ElmFn(PPublicPartyNumber_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_DisconnectRequestPDU_destinationAddress_ElmFn(ASN1encoding_t enc, PDisconnectRequestPDU_destinationAddress val);
    extern int ASN1CALL ASN1Dec_DisconnectRequestPDU_destinationAddress_ElmFn(ASN1decoding_t dec, PDisconnectRequestPDU_destinationAddress val);
	extern void ASN1CALL ASN1Free_DisconnectRequestPDU_destinationAddress_ElmFn(PDisconnectRequestPDU_destinationAddress val);
    extern int ASN1CALL ASN1Enc_ConnectRequestPDU_destinationAddress_ElmFn(ASN1encoding_t enc, PConnectRequestPDU_destinationAddress val);
    extern int ASN1CALL ASN1Dec_ConnectRequestPDU_destinationAddress_ElmFn(ASN1decoding_t dec, PConnectRequestPDU_destinationAddress val);
	extern void ASN1CALL ASN1Free_ConnectRequestPDU_destinationAddress_ElmFn(PConnectRequestPDU_destinationAddress val);
    extern int ASN1CALL ASN1Enc_ConnectRequestPDU_unreliableTransportProtocols_ElmFn(ASN1encoding_t enc, PConnectRequestPDU_unreliableTransportProtocols val);
    extern int ASN1CALL ASN1Dec_ConnectRequestPDU_unreliableTransportProtocols_ElmFn(ASN1decoding_t dec, PConnectRequestPDU_unreliableTransportProtocols val);
	extern void ASN1CALL ASN1Free_ConnectRequestPDU_unreliableTransportProtocols_ElmFn(PConnectRequestPDU_unreliableTransportProtocols val);
    extern int ASN1CALL ASN1Enc_ConnectRequestPDU_reliableSecurityProtocols_ElmFn(ASN1encoding_t enc, PConnectRequestPDU_reliableSecurityProtocols val);
    extern int ASN1CALL ASN1Dec_ConnectRequestPDU_reliableSecurityProtocols_ElmFn(ASN1decoding_t dec, PConnectRequestPDU_reliableSecurityProtocols val);
	extern void ASN1CALL ASN1Free_ConnectRequestPDU_reliableSecurityProtocols_ElmFn(PConnectRequestPDU_reliableSecurityProtocols val);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _CNPPDU_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\cnpcoder.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MSMCSTCP);
/*
 *	cnpcoder.cpp
 *	
 *	Copyright (c) 1999 by Microsoft Corporation
 *
 *	Abstract:
 *		This is the implementation file for the CCNPCoder class.  This class
 *		is responsible for encoding and decoding CNP (T.123 annex B) PDU's using ASN.1 
 *		encoding rules via the ASN.1 toolkit.  This class is also capable
 *		of determining the size of both the encoded and decoded PDU's. 
 *
 *	Static Variables:
 *
 *	Caveats:
 *		Only one instance of this class should be in existance at any one time
 *		due to the static variable.
 *
 *	Author:
 *		Xin Liu
 */

/*
 *	External Interfaces
 */
#include <string.h>
#include "cnpcoder.h"

/*
 *	This is a global variable that has a pointer to the one CNP coder
 */
CCNPCoder	*g_CNPCoder = NULL;

/*
 *	CCNPCoder ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the constructor for the CCNPCoder class.  It initializes
 *		the ASN.1 encoder/decoder and sets the encoding rules to the
 *		Packed-Aligned variant.
 */
CCNPCoder::CCNPCoder ()
        :m_pEncInfo(NULL),
         m_pDecInfo(NULL)
{
}

BOOL CCNPCoder::Init ( void )
{
    BOOL fRet = FALSE;
    CNPPDU_Module_Startup();
    if (CNPPDU_Module != NULL)
    {
        if (ASN1_CreateEncoder(
            CNPPDU_Module,	// ptr to mdule
            &m_pEncInfo,	// ptr to encoder info
            NULL,			// buffer ptr
            0,				// buffer size
            NULL)			// parent ptr
            == ASN1_SUCCESS)
        {
            ASSERT(m_pEncInfo != NULL);
            fRet = (ASN1_CreateDecoder(CNPPDU_Module,	// ptr to mdule
                                       &m_pDecInfo,	// ptr to decoder info
                                       NULL,			// buffer ptr
                                       0,				// buffer size
                                       NULL)			// parent ptr
                    == ASN1_SUCCESS);
            ASSERT(fRet && m_pDecInfo != NULL);
        }
    }
    ASSERT(fRet);
    return fRet;
}

/*
 *	~CCNPCoder ()
 *
 *	Public Functional Description:
 *		This is a virtual destructor.  It is used to clean up after ASN.1.
 */
CCNPCoder::~CCNPCoder ()
{
    if (CNPPDU_Module != NULL)
    {
        ASN1_CloseEncoder(m_pEncInfo);
        ASN1_CloseDecoder(m_pDecInfo);
        CNPPDU_Module_Cleanup();
    }
}

/*
 *	Encode ()
 *
 *	Public Functional Description:
 *		This function encodes CNP Protocol Data Units (PDU's) into ASN.1 
 *		compliant byte streams using the ASN.1 toolkit.
 *		The coder allocates the buffer space for the encoded data.
 */
BOOL	CCNPCoder::Encode(LPVOID		pdu_structure,
                          int			pdu_type,
                          UINT                  nEncodingRule_not_used,
                          LPBYTE		*encoding_buffer,
                          UINT                  *encoding_buffer_length)
{
    BOOL                  fRet = FALSE;
    int                   return_value;
    
    return_value = ASN1_Encode(m_pEncInfo,	// ptr to encoder info
                               pdu_structure,	// pdu data structure
                               pdu_type,        // pdu id
                               ASN1ENCODE_ALLOCATEBUFFER, // flags
                               NULL,			// do not provide buffer
                               0);			// buffer size if provided

    if (ASN1_FAILED(return_value))
    {
        ERROR_OUT(("CCNPCoder::Encode: ASN1_Encode failed, err=%d .",
                   return_value));
        ASSERT(FALSE);
        fRet = FALSE;
        goto MyExit;
    }
    ASSERT(return_value == ASN1_SUCCESS);
    fRet = TRUE;
    // len of encoded data in buffer
    *encoding_buffer_length = m_pEncInfo->len;
    // buffer to encode into
    *encoding_buffer = m_pEncInfo->buf;
    
 MyExit:
      
    return fRet;
}

/*
 *	Decode ()
 *
 *	Public Functional Description:
 *		This function decodes ASN.1 compliant byte streams into the
 *		appropriate CNP PDU structures using the ASN.1 toolkit.
 */
BOOL	CCNPCoder::Decode(LPBYTE		encoded_buffer,
                          UINT		        encoded_buffer_length,
                          int			pdu_type,
                          UINT		        nEncodingRule_not_used,
                          LPVOID		*pdecoding_buffer,
                          UINT		        *pdecoding_buffer_length)
{
    BOOL	          fRet = FALSE;   
    int		          return_value;
    ASN1optionparam_s     OptParam;

    return_value = ASN1_Decode(m_pDecInfo,	// ptr to decoder info
                               pdecoding_buffer,			// destination buffer
                               pdu_type,					// pdu type
                               ASN1DECODE_SETBUFFER,		// flags
                               encoded_buffer,				// source buffer
                               encoded_buffer_length);		// source buffer size
    if (ASN1_FAILED(return_value))
    {
        ERROR_OUT(("CNPCoder::Decode: ASN1_Decode failed, err=%d", return_value));
        ASSERT(FALSE);
        goto MyExit;
    }
      
    OptParam.eOption = ASN1OPT_GET_DECODED_BUFFER_SIZE;
    return_value = ASN1_GetDecoderOption(m_pDecInfo, &OptParam);
    if (ASN1_FAILED(return_value))
    {
        ERROR_OUT(("CCNPCoder::Decode: ASN1_GetDecoderOption failed, err=%d", return_value));
        ASSERT(FALSE);
        goto MyExit;
    }
    *pdecoding_buffer_length = OptParam.cbRequiredDecodedBufSize;
      
    ASSERT(return_value == ASN1_SUCCESS);
    ASSERT(*pdecoding_buffer_length > 0);
      
    fRet = TRUE;
      
 MyExit:

    return fRet;
}

void CCNPCoder::FreeEncoded (PUChar encoded_buffer)
{
    ASN1_FreeEncoded(m_pEncInfo, encoded_buffer);
}

void CCNPCoder::FreeDecoded (int pdu_type, LPVOID decoded_buffer)
{
    ASN1_FreeDecoded(m_pDecInfo, decoded_buffer, pdu_type);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\cnppdu.c ===
/* Copyright (C) Microsoft Corporation, 1999. All rights reserved. */
/* ASN.1 definitions for Connection Negotiation Protocol (GNP) */

#include <windows.h>
#include "cnppdu.h"

ASN1module_t CNPPDU_Module = NULL;

static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipSourceRoute_route(ASN1encoding_t enc, PCNP_TransportAddress_ipSourceRoute_route *val);
static int ASN1CALL ASN1Enc_CNP_TransportAddress_ip6Address(ASN1encoding_t enc, CNP_TransportAddress_ip6Address *val);
static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipxAddress(ASN1encoding_t enc, CNP_TransportAddress_ipxAddress *val);
static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipAddress(ASN1encoding_t enc, CNP_TransportAddress_ipAddress *val);
static int ASN1CALL ASN1Enc_H221NonStandard(ASN1encoding_t enc, H221NonStandard *val);
static int ASN1CALL ASN1Enc_NonStandardIdentifier(ASN1encoding_t enc, NonStandardIdentifier *val);
static int ASN1CALL ASN1Enc_CNP_NonStandardParameter(ASN1encoding_t enc, CNP_NonStandardParameter *val);
#define ASN1Enc_PublicTypeOfNumber(x,y)      0
#define ASN1Enc_PublicPartyNumber(x,y)      0
#define ASN1Enc_PrivateTypeOfNumber(x,y)      0
#define ASN1Enc_PrivatePartyNumber(x,y)      0
#define ASN1Enc_PartyNumber(x,y)      0
#define ASN1Enc_ReliableTransportProtocolType(x,y)      0
#define ASN1Enc_ReliableTransportProtocol(x,y)      0
#define ASN1Enc_UnreliableTransportProtocolType(x,y)      0
#define ASN1Enc_UnreliableSecurityProtocol(x,y)      0
static int ASN1CALL ASN1Enc_X274WithSAIDInfo(ASN1encoding_t enc, X274WithSAIDInfo *val);
static int ASN1CALL ASN1Enc_ConnectRequestPDU(ASN1encoding_t enc, ConnectRequestPDU *val);
static int ASN1CALL ASN1Enc_DisconnectReason(ASN1encoding_t enc, Disconn