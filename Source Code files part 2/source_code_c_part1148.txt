  {
            pString = pStart + pHashN->pLocaleHdr->SIntlSymbol;
            break;
        }
        case ( LOCALE_SENGCURRNAME ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SEngCurrName;
            break;
        }
        case ( LOCALE_SNATIVECURRNAME ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SNativeCurrName;
            break;
        }
        case ( LOCALE_SMONDECIMALSEP ) :
        {
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sMonDecSep),
                             NLS_VALUE_SMONDECIMALSEP,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             FALSE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pStart + pHashN->pLocaleHdr->SMonDecSep;
            }
            break;
        }
        case ( LOCALE_SMONTHOUSANDSEP ) :
        {
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sMonThouSep),
                             NLS_VALUE_SMONTHOUSANDSEP,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             FALSE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pStart + pHashN->pLocaleHdr->SMonThousSep;
            }
            break;
        }
        case ( LOCALE_SMONGROUPING ) :
        {
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sMonGrouping),
                             NLS_VALUE_SMONGROUPING,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pStart + pHashN->pLocaleHdr->SMonGrouping;
            }
            break;
        }
        case ( LOCALE_ICURRDIGITS ) :
        {
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iCurrDigits),
                             NLS_VALUE_ICURRDIGITS,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pHashN->pLocaleFixed->szICurrDigits;
            }
            break;
        }
        case ( LOCALE_IINTLCURRDIGITS ) :
        {
            Base = 10;
            pString = pHashN->pLocaleFixed->szIIntlCurrDigits;
            break;
        }
        case ( LOCALE_ICURRENCY ) :
        {
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iCurrency),
                             NLS_VALUE_ICURRENCY,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pHashN->pLocaleFixed->szICurrency;
            }
            break;
        }
        case ( LOCALE_INEGCURR ) :
        {
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iNegCurr),
                             NLS_VALUE_INEGCURR,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pHashN->pLocaleFixed->szINegCurr;
            }
            break;
        }
        case ( LOCALE_SPOSITIVESIGN ) :
        {
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sPosSign),
                             NLS_VALUE_SPOSITIVESIGN,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             FALSE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pStart + pHashN->pLocaleHdr->SPositiveSign;
            }
            break;
        }
        case ( LOCALE_SNEGATIVESIGN ) :
        {
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sNegSign),
                             NLS_VALUE_SNEGATIVESIGN,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             FALSE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pStart + pHashN->pLocaleHdr->SNegativeSign;
            }
            break;
        }
        case ( LOCALE_IPOSSIGNPOSN ) :
        {
            //
            //  Since there is no positive sign in any of the ICURRENCY
            //  options, use the INEGCURR options instead.  All known
            //  locales would use the positive sign in the same position
            //  as the negative sign.
            //
            //  NOTE:  For the 2 options that use parenthesis, put the
            //         positive sign at the beginning of the string
            //         (where the opening parenthesis is).
            //
            //      1  =>  4, 5, 8, 15
            //      2  =>  3, 11
            //      3  =>  0, 1, 6, 9, 13, 14
            //      4  =>  2, 7, 10, 12
            //
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iNegCurr),
                             NLS_VALUE_INEGCURR,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;

                //
                //  Set the appropriate value in pString.
                //
                switch (*pString)
                {
                    case ( L'4' ) :
                    case ( L'5' ) :
                    case ( L'8' ) :
                    {
                        *pString = L'1';
                        *(pString + 1) = 0;
                        break;
                    }
                    case ( L'3' ) :
                    {
                        *pString = L'2';
                        *(pString + 1) = 0;
                        break;
                    }
                    case ( L'0' ) :
                    case ( L'6' ) :
                    case ( L'9' ) :
                    {
                        *pString = L'3';
                        *(pString + 1) = 0;
                        break;
                    }
                    case ( L'2' ) :
                    case ( L'7' ) :
                    {
                        *pString = L'4';
                        *(pString + 1) = 0;
                        break;
                    }
                    case ( L'1' ) :
                    {
                        switch (*(pString + 1))
                        {
                            case ( 0 ) :
                            case ( L'3' ) :
                            case ( L'4' ) :
                            default :
                            {
                                *pString = L'3';
                                *(pString + 1) = 0;
                                break;
                            }
                            case ( L'0' ) :
                            case ( L'2' ) :
                            {
                                *pString = L'4';
                                *(pString + 1) = 0;
                                break;
                            }
                            case ( L'1' ) :
                            {
                                *pString = L'2';
                                *(pString + 1) = 0;
                                break;
                            }
                            case ( L'5' ) :
                            {
                                *pString = L'1';
                                *(pString + 1) = 0;
                                break;
                            }
                        }
                        break;
                    }
                    default :
                    {
                        pString = pHashN->pLocaleFixed->szIPosSignPosn;
                        break;
                    }
                }
            }
            else
            {
                pString = pHashN->pLocaleFixed->szIPosSignPosn;
            }
            break;
        }
        case ( LOCALE_INEGSIGNPOSN ) :
        {
            //
            //  Use the INEGCURR value from the user portion of the
            //  registry, if it exists.
            //
            //      0  =>  0, 4, 14, 15
            //      1  =>  5, 8
            //      2  =>  3, 11
            //      3  =>  1, 6, 9, 13
            //      4  =>  2, 7, 10, 12
            //
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iNegCurr),
                             NLS_VALUE_INEGCURR,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;

                //
                //  Set the appropriate value in pString.
                //
                switch (*pString)
                {
                    case ( L'0' ) :
                    case ( L'4' ) :
                    {
                        *pString = L'0';
                        *(pString + 1) = 0;
                        break;
                    }
                    case ( L'5' ) :
                    case ( L'8' ) :
                    {
                        *pString = L'1';
                        *(pString + 1) = 0;
                        break;
                    }
                    case ( L'3' ) :
                    {
                        *pString = L'2';
                        *(pString + 1) = 0;
                        break;
                    }
                    case ( L'6' ) :
                    case ( L'9' ) :
                    {
                        *pString = L'3';
                        *(pString + 1) = 0;
                        break;
                    }
                    case ( L'2' ) :
                    case ( L'7' ) :
                    {
                        *pString = L'4';
                        *(pString + 1) = 0;
                        break;
                    }
                    case ( L'1' ) :
                    {
                        switch (*(pString + 1))
                        {
                            case ( 0 ) :
                            case ( L'3' ) :
                            default :
                            {
                                *pString = L'3';
                                *(pString + 1) = 0;
                                break;
                            }
                            case ( L'0' ) :
                            case ( L'2' ) :
                            {
                                *pString = L'4';
                                *(pString + 1) = 0;
                                break;
                            }
                            case ( L'1' ) :
                            {
                                *pString = L'2';
                                *(pString + 1) = 0;
                                break;
                            }
                            case ( L'4' ) :
                            case ( L'5' ) :
                            {
                                *pString = L'0';
                                *(pString + 1) = 0;
                                break;
                            }
                        }
                        break;
                    }
                    default :
                    {
                        pString = pHashN->pLocaleFixed->szINegSignPosn;
                        break;
                    }
                }
            }
            else
            {
                pString = pHashN->pLocaleFixed->szINegSignPosn;
            }
            break;
        }
        case ( LOCALE_IPOSSYMPRECEDES ) :
        {
            //
            //  Use the ICURRENCY value from the user portion of the
            //  registry, if it exists.
            //
            //      0  =>  1, 3
            //      1  =>  0, 2
            //
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iCurrency),
                             NLS_VALUE_ICURRENCY,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;

                //
                //  Set the appropriate value in pString.
                //
                switch (*pString)
                {
                    case ( L'1' ) :
                    case ( L'3' ) :
                    {
                        *pString = L'0';
                        *(pString + 1) = 0;
                        break;
                    }
                    case ( L'0' ) :
                    case ( L'2' ) :
                    {
                        *pString = L'1';
                        *(pString + 1) = 0;
                        break;
                    }
                    default :
                    {
                        pString = pHashN->pLocaleFixed->szIPosSymPrecedes;
                        break;
                    }
                }
            }
            else
            {
                pString = pHashN->pLocaleFixed->szIPosSymPrecedes;
            }
            break;
        }
        case ( LOCALE_IPOSSEPBYSPACE ) :
        {
            //
            //  Use the ICURRENCY value from the user portion of the
            //  registry, if it exists.
            //
            //      0  =>  0, 1
            //      1  =>  2, 3
            //
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iCurrency),
                             NLS_VALUE_ICURRENCY,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;

                //
                //  Set the appropriate value in pString.
                //
                switch (*pString)
                {
                    case ( L'0' ) :
                    case ( L'1' ) :
                    {
                        *pString = L'0';
                        *(pString + 1) = 0;
                        break;
                    }
                    case ( L'2' ) :
                    case ( L'3' ) :
                    {
                        *pString = L'1';
                        *(pString + 1) = 0;
                        break;
                    }
                    default :
                    {
                        pString = pHashN->pLocaleFixed->szIPosSepBySpace;
                        break;
                    }
                }
            }
            else
            {
                pString = pHashN->pLocaleFixed->szIPosSepBySpace;
            }
            break;
        }
        case ( LOCALE_INEGSYMPRECEDES ) :
        {
            //
            //  Use the INEGCURR value from the user portion of the
            //  registry, if it exists.
            //
            //      0  =>  4, 5, 6, 7, 8, 10, 13, 15
            //      1  =>  0, 1, 2, 3, 9, 11, 12, 14
            //
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iNegCurr),
                             NLS_VALUE_INEGCURR,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;

                //
                //  Set the appropriate value in pString.
                //
                switch (*pString)
                {
                    case ( L'4' ) :
                    case ( L'5' ) :
                    case ( L'6' ) :
                    case ( L'7' ) :
                    case ( L'8' ) :
                    {
                        *pString = L'0';
                        *(pString + 1) = 0;
                        break;
                    }
                    case ( L'0' ) :
                    case ( L'2' ) :
                    case ( L'3' ) :
                    case ( L'9' ) :
                    {
                        *pString = L'1';
                        *(pString + 1) = 0;
                        break;
                    }
                    case ( L'1' ) :
                    {
                        if ((*(pString + 1) == L'0') ||
                            (*(pString + 1) == L'3') ||
                            (*(pString + 1) == L'5'))
                        {
                            *pString = L'0';
                            *(pString + 1) = 0;
                        }
                        else
                        {
                            *pString = L'1';
                            *(pString + 1) = 0;
                        }
                        break;
                    }
                    default :
                    {
                        pString = pHashN->pLocaleFixed->szINegSymPrecedes;
                        break;
                    }
                }
            }
            else
            {
                pString = pHashN->pLocaleFixed->szINegSymPrecedes;
            }
            break;
        }
        case ( LOCALE_INEGSEPBYSPACE ) :
        {
            //
            //  Use the INEGCURR value from the user portion of the
            //  registry, if it exists.
            //
            //      0  =>  0, 1, 2, 3, 4, 5, 6, 7
            //      1  =>  8, 9, 10, 11, 12, 13, 14, 15
            //
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iNegCurr),
                             NLS_VALUE_INEGCURR,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;

                //
                //  Set the appropriate value in pString.
                //
                switch (*pString)
                {
                    case ( L'0' ) :
                    case ( L'2' ) :
                    case ( L'3' ) :
                    case ( L'4' ) :
                    case ( L'5' ) :
                    case ( L'6' ) :
                    case ( L'7' ) :
                    {
                        *pString = L'0';
                        *(pString + 1) = 0;
                        break;
                    }
                    case ( L'8' ) :
                    case ( L'9' ) :
                    {
                        *pString = L'1';
                        *(pString + 1) = 0;
                        break;
                    }
                    case ( L'1' ) :
                    {
                        if (*(pString + 1) == 0)
                        {
                            *pString = L'0';
                            *(pString + 1) = 0;
                        }
                        else
                        {
                            *pString = L'1';
                            *(pString + 1) = 0;
                        }
                        break;
                    }
                    default :
                    {
                        pString = pHashN->pLocaleFixed->szINegSepBySpace;
                        break;
                    }
                }
            }
            else
            {
                pString = pHashN->pLocaleFixed->szINegSepBySpace;
            }
            break;
        }
        case ( LOCALE_STIMEFORMAT ) :
        {
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sTimeFormat),
                             NLS_VALUE_STIMEFORMAT,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pStart + pHashN->pLocaleHdr->STimeFormat;
            }
            break;
        }
        case ( LOCALE_STIME ) :
        {
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sTime),
                             NLS_VALUE_STIME,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pStart + pHashN->pLocaleHdr->STime;
            }
            break;
        }
        case ( LOCALE_ITIME ) :
        {
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iTime),
                             NLS_VALUE_ITIME,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pHashN->pLocaleFixed->szITime;
            }
            break;
        }
        case ( LOCALE_ITLZERO ) :
        {
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iTLZero),
                             NLS_VALUE_ITLZERO,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pHashN->pLocaleFixed->szITLZero;
            }
            break;
        }
        case ( LOCALE_ITIMEMARKPOSN ) :
        {
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iTimeMarkPosn),
                             NLS_VALUE_ITIMEMARKPOSN,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pHashN->pLocaleFixed->szITimeMarkPosn;
            }
            break;
        }
        case ( LOCALE_S1159 ) :
        {
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, s1159),
                             NLS_VALUE_S1159,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             FALSE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pStart + pHashN->pLocaleHdr->S1159;
            }
            break;
        }
        case ( LOCALE_S2359 ) :
        {
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, s2359),
                             NLS_VALUE_S2359,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             FALSE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pStart + pHashN->pLocaleHdr->S2359;
            }
            break;
        }
        case ( LOCALE_SSHORTDATE ) :
        {
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sShortDate),
                             NLS_VALUE_SSHORTDATE,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pStart + pHashN->pLocaleHdr->SShortDate;
            }
            break;
        }
        case ( LOCALE_SDATE ) :
        {
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sDate),
                             NLS_VALUE_SDATE,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pStart + pHashN->pLocaleHdr->SDate;
            }
            break;
        }
        case ( LOCALE_IDATE ) :
        {
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iDate),
                             NLS_VALUE_IDATE,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pHashN->pLocaleFixed->szIDate;
            }
            break;
        }
        case ( LOCALE_ICENTURY ) :
        {
            //
            //  Use the short date picture to get this information.
            //
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sShortDate),
                             NLS_VALUE_SSHORTDATE,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;

                //
                //  Find out how many y's in string.
                //  No need to ignore quotes in short date.
                //
                pTmp = pString;
                while ((*pTmp) &&
                       (*pTmp != L'y'))
                {
                    pTmp++;
                }

                //
                //  Set the appropriate value in pString.
                //
                if (*pTmp == L'y')
                {
                    //
                    //  Get the number of 'y' repetitions in the format string.
                    //
                    pTmp++;
                    for (Repeat = 0; (*pTmp == L'y'); Repeat++, pTmp++)
                        ;

                    switch (Repeat)
                    {
                        case ( 0 ) :
                        case ( 1 ) :
                        {
                            //
                            //  Two-digit century with leading zero.
                            //
                            *pString = L'0';
                            *(pString + 1) = 0;

                            break;
                        }

                        case ( 2 ) :
                        case ( 3 ) :
                        default :
                        {
                            //
                            //  Full century.
                            //
                            *pString = L'1';
                            *(pString + 1) = 0;

                            break;
                        }
                    }

                    break;
                }
            }

            //
            //  Use the system default value.
            //
            pString = pHashN->pLocaleFixed->szICentury;

            break;
        }
        case ( LOCALE_IDAYLZERO ) :
        {
            //
            //  Use the short date picture to get this information.
            //
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sShortDate),
                             NLS_VALUE_SSHORTDATE,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;

                //
                //  Find out how many d's in string.
                //  No need to ignore quotes in short date.
                //
                pTmp = pString;
                while ((*pTmp) &&
                       (*pTmp != L'd'))
                {
                    pTmp++;
                }

                //
                //  Set the appropriate value in pString.
                //
                if (*pTmp == L'd')
                {
                    //
                    //  Get the number of 'd' repetitions in the format string.
                    //
                    pTmp++;
                    for (Repeat = 0; (*pTmp == L'd'); Repeat++, pTmp++)
                        ;

                    switch (Repeat)
                    {
                        case ( 0 ) :
                        {
                            //
                            //  No leading zero.
                            //
                            *pString = L'0';
                            *(pString + 1) = 0;

                            break;
                        }

                        case ( 1 ) :
                        default :
                        {
                            //
                            //  Use leading zero.
                            //
                            *pString = L'1';
                            *(pString + 1) = 0;

                            break;
                        }
                    }

                    break;
                }
            }

            //
            //  Use the system default value.
            //
            pString = pHashN->pLocaleFixed->szIDayLZero;

            break;
        }
        case ( LOCALE_IMONLZERO ) :
        {
            //
            //  Use the short date picture to get this information.
            //
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sShortDate),
                             NLS_VALUE_SSHORTDATE,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;

                //
                //  Find out how many M's in string.
                //  No need to ignore quotes in short date.
                //
                pTmp = pString;
                while ((*pTmp) &&
                       (*pTmp != L'M'))
                {
                    pTmp++;
                }

                //
                //  Set the appropriate value in pString.
                //
                if (*pTmp == L'M')
                {
                    //
                    //  Get the number of 'M' repetitions in the format string.
                    //
                    pTmp++;
                    for (Repeat = 0; (*pTmp == L'M'); Repeat++, pTmp++)
                        ;

                    switch (Repeat)
                    {
                        case ( 0 ) :
                        {
                            //
                            //  No leading zero.
                            //
                            *pString = L'0';
                            *(pString + 1) = 0;

                            break;
                        }

                        case ( 1 ) :
                        default :
                        {
                            //
                            //  Use leading zero.
                            //
                            *pString = L'1';
                            *(pString + 1) = 0;

                            break;
                        }
                    }

                    break;
                }
            }

            //
            //  Use the system default value.
            //
            pString = pHashN->pLocaleFixed->szIMonLZero;

            break;
        }
        case ( LOCALE_SYEARMONTH ) :
        {
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sYearMonth),
                             NLS_VALUE_SYEARMONTH,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pStart + pHashN->pLocaleHdr->SYearMonth;
            }
            break;
        }
        case ( LOCALE_SLONGDATE ) :
        {
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sLongDate),
                             NLS_VALUE_SLONGDATE,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pStart + pHashN->pLocaleHdr->SLongDate;
            }
            break;
        }
        case ( LOCALE_ILDATE ) :
        {
            //
            //  Use the long date picture to get this information.
            //
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sLongDate),
                             NLS_VALUE_SLONGDATE,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;

                //
                //  Find out if d, M, or y is first, but ignore quotes.
                //  Also, if "ddd" or "dddd" is found, then skip it.  Only
                //  want "d" or "dd".
                //
                pTmp = pString;
                while (pTmp = wcspbrk(pTmp, L"dMy'"))
                {
                    //
                    //  Check special cases.
                    //
                    if (*pTmp == L'd')
                    {
                        //
                        //  Check for d's.  Ignore more than 2 d's.
                        //
                        for (Repeat = 0; (*pTmp == L'd'); Repeat++, pTmp++)
                            ;

                        if (Repeat < 3)
                        {
                            //
                            //  Break out of while loop.  Found "d" or "dd".
                            //
                            pTmp--;
                            break;
                        }
                    }
                    else if (*pTmp == NLS_CHAR_QUOTE)
                    {
                        //
                        //  Ignore quotes.
                        //
                        pTmp++;
                        while ((*pTmp) && (*pTmp != NLS_CHAR_QUOTE))
                        {
                            pTmp++;
                        }
                        pTmp++;
                    }
                    else
                    {
                        //
                        //  Found one of the values, so break out of
                        //  while loop.
                        //
                        break;
                    }
                }

                //
                //  Set the appropriate value in pString.
                //
                if (pTmp)
                {
                    switch (*pTmp)
                    {
                        case ( L'd' ) :
                        {
                            *pString = L'1';
                            break;
                        }
                        case ( L'M' ) :
                        {
                            *pString = L'0';
                            break;
                        }
                        case ( L'y' ) :
                        {
                            *pString = L'2';
                            break;
                        }
                    }

                    //
                    //  Null terminate the string.
                    //
                    *(pString + 1) = 0;

                    break;
                }
            }

            //
            //  Use the default value.
            //
            pString = pHashN->pLocaleFixed->szILDate;

            break;
        }
        case ( LOCALE_ICALENDARTYPE ) :
        {
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iCalType),
                             NLS_VALUE_ICALENDARTYPE,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pHashN->pLocaleFixed->szICalendarType;
            }
            break;
        }
        case ( LOCALE_IOPTIONALCALENDAR ) :
        {
            Base = 10;
            pString = pStart + pHashN->pLocaleHdr->IOptionalCal;
            pString = ((POPT_CAL)pString)->pCalStr;
            break;
        }
        case ( LOCALE_IFIRSTDAYOFWEEK ) :
        {
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iFirstDay),
                             NLS_VALUE_IFIRSTDAYOFWEEK,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pHashN->pLocaleFixed->szIFirstDayOfWk;
            }
            break;
        }
        case ( LOCALE_IFIRSTWEEKOFYEAR ) :
        {
            Base = 10;
            if (UserOverride &&
                GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, iFirstWeek),
                             NLS_VALUE_IFIRSTWEEKOFYEAR,
                             pTemp,
                             ARRAYSIZE(pTemp),
                             TRUE ))
            {
                pString = pTemp;
            }
            else
            {
                pString = pHashN->pLocaleFixed->szIFirstWkOfYr;
            }
            break;
        }
        case ( LOCALE_SDAYNAME1 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SDayName1;
            break;
        }
        case ( LOCALE_SDAYNAME2 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SDayName2;
            break;
        }
        case ( LOCALE_SDAYNAME3 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SDayName3;
            break;
        }
        case ( LOCALE_SDAYNAME4 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SDayName4;
            break;
        }
        case ( LOCALE_SDAYNAME5 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SDayName5;
            break;
        }
        case ( LOCALE_SDAYNAME6 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SDayName6;
            break;
        }
        case ( LOCALE_SDAYNAME7 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SDayName7;
            break;
        }
        case ( LOCALE_SABBREVDAYNAME1 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevDayName1;
            break;
        }
        case ( LOCALE_SABBREVDAYNAME2 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevDayName2;
            break;
        }
        case ( LOCALE_SABBREVDAYNAME3 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevDayName3;
            break;
        }
        case ( LOCALE_SABBREVDAYNAME4 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevDayName4;
            break;
        }
        case ( LOCALE_SABBREVDAYNAME5 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevDayName5;
            break;
        }
        case ( LOCALE_SABBREVDAYNAME6 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevDayName6;
            break;
        }
        case ( LOCALE_SABBREVDAYNAME7 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevDayName7;
            break;
        }
        case ( LOCALE_SMONTHNAME1 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SMonthName1;
            break;
        }
        case ( LOCALE_SMONTHNAME2 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SMonthName2;
            break;
        }
        case ( LOCALE_SMONTHNAME3 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SMonthName3;
            break;
        }
        case ( LOCALE_SMONTHNAME4 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SMonthName4;
            break;
        }
        case ( LOCALE_SMONTHNAME5 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SMonthName5;
            break;
        }
        case ( LOCALE_SMONTHNAME6 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SMonthName6;
            break;
        }
        case ( LOCALE_SMONTHNAME7 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SMonthName7;
            break;
        }
        case ( LOCALE_SMONTHNAME8 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SMonthName8;
            break;
        }
        case ( LOCALE_SMONTHNAME9 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SMonthName9;
            break;
        }
        case ( LOCALE_SMONTHNAME10 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SMonthName10;
            break;
        }
        case ( LOCALE_SMONTHNAME11 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SMonthName11;
            break;
        }
        case ( LOCALE_SMONTHNAME12 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SMonthName12;
            break;
        }
        case ( LOCALE_SMONTHNAME13 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SMonthName13;
            break;
        }
        case ( LOCALE_SABBREVMONTHNAME1 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevMonthName1;
            break;
        }
        case ( LOCALE_SABBREVMONTHNAME2 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevMonthName2;
            break;
        }
        case ( LOCALE_SABBREVMONTHNAME3 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevMonthName3;
            break;
        }
        case ( LOCALE_SABBREVMONTHNAME4 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevMonthName4;
            break;
        }
        case ( LOCALE_SABBREVMONTHNAME5 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevMonthName5;
            break;
        }
        case ( LOCALE_SABBREVMONTHNAME6 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevMonthName6;
            break;
        }
        case ( LOCALE_SABBREVMONTHNAME7 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevMonthName7;
            break;
        }
        case ( LOCALE_SABBREVMONTHNAME8 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevMonthName8;
            break;
        }
        case ( LOCALE_SABBREVMONTHNAME9 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevMonthName9;
            break;
        }
        case ( LOCALE_SABBREVMONTHNAME10 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevMonthName10;
            break;
        }
        case ( LOCALE_SABBREVMONTHNAME11 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevMonthName11;
            break;
        }
        case ( LOCALE_SABBREVMONTHNAME12 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevMonthName12;
            break;
        }
        case ( LOCALE_SABBREVMONTHNAME13 ) :
        {
            pString = pStart + pHashN->pLocaleHdr->SAbbrevMonthName13;
            break;
        }
        case ( LOCALE_FONTSIGNATURE ) :
        {
            //
            //  Check cchData for size of given buffer.
            //
            if (cchData == 0)
            {
                return (MAX_FONTSIGNATURE);
            }
            else if (cchData < MAX_FONTSIGNATURE)
            {
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                return (0);
            }

            //
            //  This string does NOT get zero terminated.
            //
            pString = pHashN->pLocaleFixed->szFontSignature;

            //
            //  Copy the string to lpLCData and return the number of
            //  characters copied.
            //
            RtlMoveMemory(lpLCData, pString, MAX_FONTSIGNATURE * sizeof(WCHAR));
            return (MAX_FONTSIGNATURE);

            break;
        }
        default :
        {
            SetLastError(ERROR_INVALID_FLAGS);
            return (0);
        }
    }

    //
    //  See if the caller wants the value in the form of a number instead
    //  of a string.
    //
    if (ReturnNum)
    {
        //
        //  Make sure the flags are valid and there is enough buffer
        //  space.
        //
        if (Base == 0)
        {
            SetLastError(ERROR_INVALID_FLAGS);
            return (0);
        }
        if (cchData < 2)
        {
            if (cchData == 0)
            {
                //
                //  DWORD is needed for this option (2 WORDS), so return 2.
                //
                return (2);
            }

            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return (0);
        }

        //
        //  Convert the string to an int and return 2 (1 DWORD = 2 WORDS).
        //
        RtlInitUnicodeString(&ObUnicodeStr, pString);
        if (RtlUnicodeStringToInteger(&ObUnicodeStr, Base, (LPDWORD)lpLCData))
        {
            SetLastError(ERROR_INVALID_FLAGS);
            return (0);
        }
        return (2);
    }

    //
    //  Get the length (in characters) of the string to copy.
    //
    if (Length == 0)
    {
        Length = NlsStrLenW(pString);
    }

    //
    //  Add one for the null termination.  All strings should be null
    //  terminated.
    //
    Length++;

    //
    //  Check cchData for size of given buffer.
    //
    if (cchData == 0)
    {
        //
        //  If cchData is 0, then we can't use lpLCData.  In this
        //  case, we simply want to return the length (in characters) of
        //  the string to be copied.
        //
        return (Length);
    }
    else if (cchData < Length)
    {
        //
        //  The buffer is too small for the string, so return an error
        //  and zero bytes written.
        //
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Copy the string to lpLCData and null terminate it.
    //  Return the number of characters copied.
    //
    wcsncpy(lpLCData, pString, Length - 1);
    lpLCData[Length - 1] = 0;
    return (Length);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetLocaleInfoW
//
//  Sets one of the various pieces of information about a particular
//  locale by making an entry in the user's portion of the configuration
//  registry.  This will only affect the user override portion of the locale
//  settings.  The system defaults will never be reset.
//
//  07-14-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI SetLocaleInfoW(
    LCID Locale,
    LCTYPE LCType,
    LPCWSTR lpLCData)
{
    PLOC_HASH pHashN;                       // ptr to LOC hash node
    int cchData;                            // length of lpLCData
    LPWSTR pString;                         // ptr to info string to change
    LPWSTR pPos;                            // ptr to position in info string
    LPWSTR pPos2;                           // ptr to position in info string
    LPWSTR pSep;                            // ptr to separator string
    WCHAR pTemp[MAX_PATH_LEN];              // ptr to temp storage buffer
    WCHAR pOutput[MAX_REG_VAL_SIZE];        // ptr to output for GetInfo call
    WCHAR pOutput2[MAX_REG_VAL_SIZE];       // ptr to output for GetInfo call
    UINT Order;                             // date or time order value
    UINT TLZero;                            // time leading zero value
    UINT TimeMarkPosn;                      // time mark position value
    WCHAR pFind[3];                         // ptr to chars to find
    int SepLen;                             // length of separator string
    UNICODE_STRING ObUnicodeStr;            // value string
    int Value;                              // value


    //
    //  Invalid Parameter Check:
    //    - validate LCID
    //    - NULL data pointer
    //
    //  NOTE: invalid type is checked in the switch statement below.
    //
    VALIDATE_LOCALE(Locale, pHashN, FALSE);
    if ((pHashN == NULL) || (lpLCData == NULL))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    //  Get the length of the buffer.
    //
    cchData = NlsStrLenW(lpLCData) + 1;

    //
    //  Initialize temp buffer.
    //
    pTemp[0] = 0;

    //
    //  Set the appropriate user information for the given LCTYPE.
    //
    LCType &= (~LOCALE_USE_CP_ACP);
    switch (LCType)
    {
        case ( LOCALE_SLIST ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_SLIST wide characters in length.
            //
            if (cchData > MAX_SLIST)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new SLIST string.
            //
            return (SetUserInfo( LOCALE_SLIST,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_IMEASURE ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_IMEASURE wide characters in length.
            //  It should be between 0 and MAX_VALUE_IMEASURE.
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).
            //
            //        Optimized - since MAX_IMEASURE is 2.
            //
            if ((cchData != MAX_IMEASURE) ||
                (*lpLCData < NLS_CHAR_ZERO) ||
                (*lpLCData > MAX_CHAR_IMEASURE))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new IMEASURE string.
            //
            return (SetUserInfo( LOCALE_IMEASURE,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_IPAPERSIZE ) :
        {
            //
            //  Validate the new value.
            //  It should be between DMPAPER_LETTER and DMPAPER_LAST.
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).
            //
            RtlInitUnicodeString(&ObUnicodeStr, lpLCData);
            if ((cchData < 2) ||
                (RtlUnicodeStringToInteger(&ObUnicodeStr, 10, &Value)) ||
                (Value < DMPAPER_LETTER) || (Value > DMPAPER_LAST))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new IPAPERSIZE string.
            //
            return (SetUserInfo( LOCALE_IPAPERSIZE,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_SDECIMAL ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_SDECIMAL wide characters in length and should not
            //  contain any integer values (L'0' thru L'9').
            //
            if (!IsValidSeparatorString( lpLCData,
                                         MAX_SDECIMAL,
                                         FALSE ))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new SDECIMAL string.
            //
            return (SetUserInfo( LOCALE_SDECIMAL,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_STHOUSAND ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_STHOUSAND wide characters in length and should not
            //  contain any integer values (L'0' thru L'9').
            //
            if (!IsValidSeparatorString( lpLCData,
                                         MAX_STHOUSAND,
                                         FALSE ))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new STHOUSAND string.
            //
            return (SetUserInfo( LOCALE_STHOUSAND,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_SGROUPING ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_SGROUPING wide characters in length and should
            //  contain alternating integer and semicolon values.
            //       (eg. 3;2;0  or  3;0  or  0)
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).
            //
            if (!IsValidGroupingString( lpLCData,
                                        MAX_SGROUPING,
                                        TRUE ))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new SGROUPING string.
            //
            return (SetUserInfo( LOCALE_SGROUPING,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_IDIGITS ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_IDIGITS wide characters in length.
            //  The value should be between 0 and MAX_VALUE_IDIGITS.
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).
            //
            //        Optimized - since MAX_IDIGITS is 2.
            //
            if ((cchData != MAX_IDIGITS) ||
                (*lpLCData < NLS_CHAR_ZERO) ||
                (*lpLCData > MAX_CHAR_IDIGITS))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new IDIGITS string.
            //
            return (SetUserInfo( LOCALE_IDIGITS,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_ILZERO ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_ILZERO wide characters in length.
            //  The value should be between 0 and MAX_VALUE_ILZERO.
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).
            //
            //        Optimized - since MAX_ILZERO is 2.
            //
            if ((cchData != MAX_ILZERO) ||
                (*lpLCData < NLS_CHAR_ZERO) ||
                (*lpLCData > MAX_CHAR_ILZERO))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new ILZERO string.
            //
            return (SetUserInfo( LOCALE_ILZERO,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_INEGNUMBER ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_INEGNUMBER wide characters in length.
            //  The value should be between 0 and MAX_VALUE_INEGNUMBER.
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).
            //
            //        Optimized - since MAX_INEGNUMBER is 2.
            //
            if ((cchData != MAX_INEGNUMBER) ||
                (*lpLCData < NLS_CHAR_ZERO) ||
                (*lpLCData > MAX_CHAR_INEGNUMBER))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new INEGNUMBER string.
            //
            return (SetUserInfo( LOCALE_INEGNUMBER,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_SNATIVEDIGITS ) :
        {
            //
            //  Validate the new value.  It should be exactly
            //  MAX_SNATIVEDIGITS wide characters in length.
            //
            if (cchData != MAX_SNATIVEDIGITS)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new SNATIVEDIGITS string.
            //
            return (SetUserInfo( LOCALE_SNATIVEDIGITS,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_IDIGITSUBSTITUTION ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_IDIGITSUBST wide characters in length.
            //  The value should be between 0 and MAX_VALUE_IDIGITSUBST.
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).
            //
            //        Optimized - since MAX_IDIGITSUBST is 2.
            //
            if ((cchData != MAX_IDIGITSUBST) ||
                (*lpLCData < NLS_CHAR_ZERO) ||
                (*lpLCData > MAX_CHAR_IDIGITSUBST))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new IDIGITSUBST string.
            //
            return (SetUserInfo( LOCALE_IDIGITSUBSTITUTION,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_SCURRENCY ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_SCURRENCY wide characters in length and should not
            //  contain any integer values (L'0' thru L'9').
            //
            if (!IsValidSeparatorString( lpLCData,
                                         MAX_SCURRENCY,
                                         FALSE ))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new SCURRENCY string.
            //
            return (SetUserInfo( LOCALE_SCURRENCY,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_SMONDECIMALSEP ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_SMONDECSEP wide characters in length and should not
            //  contain any integer values (L'0' thru L'9').
            //
            if (!IsValidSeparatorString( lpLCData,
                                         MAX_SMONDECSEP,
                                         FALSE ))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new SMONDECIMALSEP string.
            //
            return (SetUserInfo( LOCALE_SMONDECIMALSEP,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_SMONTHOUSANDSEP ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_SMONTHOUSEP wide characters in length and should not
            //  contain any integer values (L'0' thru L'9').
            //
            if (!IsValidSeparatorString( lpLCData,
                                         MAX_SMONTHOUSEP,
                                         FALSE ))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new SMONTHOUSANDSEP string.
            //
            return (SetUserInfo( LOCALE_SMONTHOUSANDSEP,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_SMONGROUPING ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_SMONGROUPING wide characters in length and should
            //  contain alternating integer and semicolon values.
            //       (eg. 3;2;0  or  3;0  or  0)
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).
            //
            if (!IsValidGroupingString( lpLCData,
                                        MAX_SMONGROUPING,
                                        TRUE ))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new SMONGROUPING string.
            //
            return (SetUserInfo( LOCALE_SMONGROUPING,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_ICURRDIGITS ) :
        {
            //
            //  Validate the new value.
            //  The value should be between 0 and MAX_VALUE_ICURRDIGITS.
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).
            //
            RtlInitUnicodeString(&ObUnicodeStr, lpLCData);
            if ((cchData < 2) ||
                (RtlUnicodeStringToInteger(&ObUnicodeStr, 10, &Value)) ||
                (Value < 0) || (Value > MAX_VALUE_ICURRDIGITS) ||
                ((Value == 0) &&
                 ((*lpLCData != NLS_CHAR_ZERO) || (cchData != 2))))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new ICURRDIGITS string.
            //
            return (SetUserInfo( LOCALE_ICURRDIGITS,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_ICURRENCY ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_ICURRENCY wide characters in length.
            //  The value should be between 0 and MAX_VALUE_ICURRENCY.
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).
            //
            //        Optimized - since MAX_ICURRENCY is 2.
            //
            if ((cchData != MAX_ICURRENCY) ||
                (*lpLCData < NLS_CHAR_ZERO) ||
                (*lpLCData > MAX_CHAR_ICURRENCY))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new ICURRENCY string.
            //
            return (SetUserInfo( LOCALE_ICURRENCY,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_INEGCURR ) :
        {
            //
            //  Validate the new value.
            //  The value should be between 0 and MAX_VALUE_INEGCURR.
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).
            //
            RtlInitUnicodeString(&ObUnicodeStr, lpLCData);
            if ((cchData < 2) ||
                (RtlUnicodeStringToInteger(&ObUnicodeStr, 10, &Value)) ||
                (Value < 0) || (Value > MAX_VALUE_INEGCURR) ||
                ((Value == 0) &&
                 ((*lpLCData != NLS_CHAR_ZERO) || (cchData != 2))))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new INEGCURR string.
            //
            return (SetUserInfo( LOCALE_INEGCURR,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_SPOSITIVESIGN ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_SPOSSIGN wide characters in length and should not
            //  contain any integer values (L'0' thru L'9').
            //
            if (!IsValidSeparatorString( lpLCData,
                                         MAX_SPOSSIGN,
                                         FALSE ))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new SPOSITIVESIGN string.
            //
            return (SetUserInfo( LOCALE_SPOSITIVESIGN,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_SNEGATIVESIGN ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_SNEGSIGN wide characters in length and should not
            //  contain any integer values (L'0' thru L'9').
            //
            if (!IsValidSeparatorString( lpLCData,
                                         MAX_SNEGSIGN,
                                         FALSE ))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new SNEGATIVESIGN string.
            //
            return (SetUserInfo( LOCALE_SNEGATIVESIGN,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_STIMEFORMAT ) :
        {
            BOOL bInsideQuotedString = FALSE;

            //
            //  Validate the new value.  It should be no longer than
            //  MAX_STIMEFORMAT wide characters in length.
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).  This is checked below
            //        in the check for whether or not there is an hour
            //        delimeter.
            //
            if (cchData > MAX_STIMEFORMAT)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  NOTE: Must link the STIME, ITIME, ITLZERO, and
            //        ITIMEMARKPOSN values in the registry.
            //

            //
            //  Search for H or h, so that iTime and iTLZero can be
            //  set.  If no H or h exists, return an error. Note: the
            //  combinations "hH" or "Hh" are invalid.
            //
            pPos = (LPWSTR)lpLCData;
            while ((pPos = wcspbrk(pPos, L"Hh'")))
            {
                if (*pPos == L'\'')
                {
                    //
                    //  Enter or leave a quoted string.
                    //
                    bInsideQuotedString &= ~TRUE;
                }
                else if (*pPos == L'H')
                {
                    //
                    //  Found an H.
                    //
                    if (!bInsideQuotedString)
                    {
                        //
                        //  Get the appropriate ITIME value.
                        //
                        Order = 1;

                        //
                        //  Get the appropriate ITLZERO value.
                        //
                        if (*(pPos + 1) == L'H')
                        {
                            TLZero = 1;
                            break;
                        }
                        else if (*(pPos + 1) == L'h')
                        {
                            //
                            //  Invalid combination.
                            //
                            pPos = NULL;
                            break;
                        }
                        else
                        {
                            TLZero = 0;
                            break;
                        }
                    }
                }
                else if (*pPos == L'h')
                {
                    //
                    //  Found an h.
                    //
                    if (!bInsideQuotedString)
                    {
                        //
                        //  Get the appropriate ITIME value.
                        //
                        Order = 0;

                        //
                        //  Get the appropriate ITLZERO value.
                        //
                        if (*(pPos + 1) == L'h')
                        {
                            TLZero = 1;
                            break;
                        }
                        else if (*(pPos + 1) == L'H')
                        {
                            //
                            //  Invalid combination.
                            //
                            pPos = NULL;
                            break;
                        }
                        else
                        {
                            TLZero = 0;
                            break;
                        }
                    }
                }
                pPos++;
            }

            //
            //  If pPos == NULL, then one of two things happened:
            //    - reached the end of the string without finding "H" or "h"
            //    - found an invalid combination like "hH" or "Hh"
            //
            if (!pPos)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Search for tt, so that ITIMEMARKPOSN can be
            //  set.  If no tt exists, do not change the value.
            //
            bInsideQuotedString = FALSE;
            pPos = (LPWSTR)lpLCData;
            while ((pPos = wcspbrk(pPos, L"t'")))
            {
                if (*pPos == L'\'')
                {
                    //
                    //  Enter or leave a quoted string.
                    //
                    bInsideQuotedString &= ~TRUE;
                }
                else if (*(pPos + 1) == L't')
                {
                    if (!bInsideQuotedString)
                    {
                        //
                        //  The string "tt" is found.
                        //
                        break;
                    }
                }
                pPos++;
            }
            if (pPos)
            {
                //
                //  Get the appropriate ITIMEMARKPOSN value.
                //
                bInsideQuotedString = FALSE;
                pPos2 = (LPWSTR)lpLCData;
                while ((pPos2 = wcspbrk(pPos2, L"Hhmst'")))
                {
                    if (*pPos == L'\'')
                    {
                        //
                        //  Enter or leave a quoted string.
                        //
                        bInsideQuotedString &= ~TRUE;
                    }
                    else
                    {
                        if (!bInsideQuotedString)
                        {
                            //
                            //  Get the appropriate ITIMEMARKPOSN value.
                            //
                            TimeMarkPosn = (pPos == pPos2) ? 1 : 0;
                            break;
                        }
                    }
                    pPos2++;
                }
            }

            //
            //  Find the time separator so that STIME can be set.
            //
            bInsideQuotedString = FALSE;
            pPos = (LPWSTR)lpLCData;
            while (pPos = wcspbrk(pPos, L"Hhms'"))
            {
                if (*pPos == L'\'')
                {
                    //
                    //  Enter or leave a quoted string.
                    //
                    bInsideQuotedString &= ~TRUE;
                    pPos++;
                }
                else
                {
                    if (!bInsideQuotedString)
                    {
                        //
                        //  Look for the beginning of the time separator.
                        //
                        pPos++;
                        while ((*pPos) && (wcschr(L"Hhms", *pPos)))
                        {
                            pPos++;
                        }

                        //
                        //  Look for the end of the time separator.
                        //
                        if (*pPos)
                        {
                            //
                            //  Find the end of the separator string.
                            //
                            pPos2 = wcspbrk(pPos, L"Hhmst");
                            if (pPos2)
                            {
                                if (*pPos2 == L't')
                                {
                                    //
                                    //  Found a time marker, so need to start
                                    //  over in search for separator.  There
                                    //  are no separators around the time
                                    //  marker.
                                    //
                                    pPos = pPos2 + 1;
                                }
                                else
                                {
                                    //
                                    //  Found end of separator, so break out of
                                    //  while loop.
                                    //
                                    break;
                                }
                            }
                        }
                    }
                    else
                    {
                        pPos++;
                    }
                }
            }

            //
            //  Get the appropriate STIME string.
            //
            if (pPos)
            {
                //
                //  Copy to temp buffer so that it's zero terminated.
                //
                pString = pTemp;
                while (pPos != pPos2)
                {
                    //
                    //  If there is a quoted string in the separator, then
                    //  just put in a white space, since there is no meaning
                    //  for time field separator anymore.
                    //
                    if (*pPos == L'\'')
                    {
                        pString = pTemp;
                        *pString++ = L' ';
                        break;
                    }

                    *pString = *pPos;
                    pPos++;
                    pString++;
                }
                *pString = 0;
            }
            else
            {
                //
                //  There is no time separator, so use NULL.
                //
                *pTemp = 0;
            }

            //
            //  Validate the new value.  It should be no longer than
            //  MAX_STIME wide characters in length and should not
            //  contain any integer values (L'0' thru L'9').
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).
            //
            if (!IsValidSeparatorString( pTemp,
                                         MAX_STIME,
                                         TRUE ))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Make sure that the time separator does NOT contain any
            //  of the special time picture characters - h, H, m, s, t, '.
            //
            if (wcspbrk(pTemp, L"Hhmst'"))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Call the server to set the registry.
            //
            return (SetMultipleUserInfo( LCType,
                                         cchData,
                                         lpLCData,
                                         pTemp,
                                         (Order == 0) ? L"0" : L"1",
                                         (TLZero == 0) ? L"0" : L"1",
                                         (TimeMarkPosn == 0) ? L"0" : L"1" ));
            break;
        }
        case ( LOCALE_STIME ) :
        {
            //
            //  NOTE: Must link the STIMEFORMAT value in the registry.
            //

            //
            //  Validate the new value.  It should be no longer than
            //  MAX_STIME wide characters in length and should not
            //  contain any integer values (L'0' thru L'9').
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).
            //
            if (!IsValidSeparatorString( lpLCData,
                                         MAX_STIME,
                                         TRUE ))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Make sure that the time separator does NOT contain any
            //  of the special time picture characters - h, H, m, s, t, '.
            //
            if (wcspbrk(lpLCData, L"Hhmst'"))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Get the current setting for STIMEFORMAT.
            //
            if (GetUserInfo( Locale,
                             LOCALE_STIMEFORMAT,
                             FIELD_OFFSET(NLS_USER_INFO, sTimeFormat),
                             NLS_VALUE_STIMEFORMAT,
                             pOutput,
                             ARRAYSIZE(pOutput),
                             TRUE ))
            {
                pString = pOutput;
            }
            else
            {
                pString = (LPWORD)(pHashN->pLocaleHdr) +
                          pHashN->pLocaleHdr->STimeFormat;
            }

            //
            //  Get the current setting for STIME.
            //
            if (GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sTime),
                             NLS_VALUE_STIME,
                             pOutput2,
                             ARRAYSIZE(pOutput2),
                             TRUE ))
            {
                pSep = pOutput2;
            }
            else
            {
                pSep = (LPWORD)(pHashN->pLocaleHdr) +
                       pHashN->pLocaleHdr->STime;
            }

            //
            //  Get the length of the separator string.
            //
            SepLen = NlsStrLenW(pSep);

            //
            //  Setup the string containing the characters to find in
            //  the timeformat string.
            //
            pFind[0] = NLS_CHAR_QUOTE;
            pFind[1] = *pSep;
            pFind[2] = 0;

            //
            //  Find the time separator in the STIMEFORMAT string and
            //  replace it with the new time separator.
            //
            //  The new separator may be a different length than
            //  the old one, so must use a static buffer for the new
            //  time format string.
            //
            pPos = pTemp;
            while (pPos2 = wcspbrk(pString, pFind))
            {
                //
                //  Copy format string up to pPos2.
                //
                while (pString < pPos2)
                {
                    *pPos = *pString;
                    pPos++;
                    pString++;
                }

                switch (*pPos2)
                {
                    case ( NLS_CHAR_QUOTE ) :
                    {
                        //
                        //  Copy the quote.
                        //
                        *pPos = *pString;
                        pPos++;
                        pString++;

                        //
                        //  Copy what's inside the quotes.
                        //
                        while ((*pString) && (*pString != NLS_CHAR_QUOTE))
                        {
                            *pPos = *pString;
                            pPos++;
                            pString++;
                        }

                        //
                        //  Copy the end quote.
                        //
                        *pPos = NLS_CHAR_QUOTE;
                        pPos++;
                        if (*pString)
                        {
                            pString++;
                        }

                        break;
                    }
                    default :
                    {
                        //
                        //  Make sure it's the old separator.
                        //
                        if (NlsStrNEqualW(pString, pSep, SepLen))
                        {
                            //
                            //  Adjust pointer to skip over old separator.
                            //
                            pString += SepLen;

                            //
                            //  Copy the new separator.
                            //
                            pPos2 = (LPWSTR)lpLCData;
                            while (*pPos2)
                            {
                                *pPos = *pPos2;
                                pPos++;
                                pPos2++;
                            }
                        }
                        else
                        {
                            //
                            //  Copy the code point and continue.
                            //
                            *pPos = *pString;
                            pPos++;
                            pString++;
                        }

                        break;
                    }
                }
            }

            //
            //  Copy to the end of the string and null terminate it.
            //
            while (*pString)
            {
                *pPos = *pString;
                pPos++;
                pString++;
            }
            *pPos = 0;

            //
            //  Call the server to set the registry.
            //
            return (SetMultipleUserInfo( LCType,
                                         cchData,
                                         pTemp,
                                         lpLCData,
                                         NULL,
                                         NULL,
                                         NULL ));
            break;
        }
        case ( LOCALE_ITIME ) :
        {
            //
            //  NOTE: Must link the STIMEFORMAT value in the registry.
            //

            //
            //  Validate the new value.  It should be no longer than
            //  MAX_ITIME wide characters in length.
            //  The value should be either 0 or MAX_VALUE_ITIME.
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).
            //
            //        Optimized - since MAX_ITIME is 2.
            //
            if ((cchData != MAX_ITIME) ||
                (*lpLCData < NLS_CHAR_ZERO) ||
                (*lpLCData > MAX_CHAR_ITIME))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Get the current setting for STIMEFORMAT.
            //
            if (GetUserInfo( Locale,
                             LOCALE_STIMEFORMAT,
                             FIELD_OFFSET(NLS_USER_INFO, sTimeFormat),
                             NLS_VALUE_STIMEFORMAT,
                             pOutput,
                             ARRAYSIZE(pOutput),
                             TRUE ))
            {
                pString = pOutput;
            }
            else
            {
                //
                //  Copy system default to temp buffer.
                //
                NlsStrCpyW( pTemp,
                            (LPWORD)(pHashN->pLocaleHdr) +
                              pHashN->pLocaleHdr->STimeFormat );
                pString = pTemp;
            }

            //
            //  Search down the STIMEFORMAT string.
            //  If iTime = 0, then H -> h.
            //  If iTime = 1, then h -> H.
            //
            pPos = pString;
            if (*lpLCData == NLS_CHAR_ZERO)
            {
                while (*pPos)
                {
                    if (*pPos == L'H')
                    {
                        *pPos = L'h';
                    }
                    pPos++;
                }
            }
            else
            {
                while (*pPos)
                {
                    if (*pPos == L'h')
                    {
                        *pPos = L'H';
                    }
                    pPos++;
                }
            }

            //
            //  Call the server to set the registry.
            //
            return (SetMultipleUserInfo( LCType,
                                         cchData,
                                         pString,
                                         NULL,
                                         lpLCData,
                                         NULL,
                                         NULL ));
            break;
        }
        case ( LOCALE_S1159 ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_S1159 wide characters in length.
            //
            if (cchData > MAX_S1159)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new S1159 string.
            //
            return (SetUserInfo( LOCALE_S1159,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_S2359 ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_S2359 wide characters in length.
            //
            if (cchData > MAX_S2359)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new S2359 string.
            //
            return (SetUserInfo( LOCALE_S2359,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_SSHORTDATE ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_SSHORTDATE wide characters in length.
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).  This is checked below
            //        in the check for whether or not there is a date,
            //        month, or year delimeter.
            //
            if (cchData > MAX_SSHORTDATE)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  NOTE: Must link the IDATE and SDATE values in the registry.
            //

            //
            //  Search for the 'd' or 'M' or 'y' sequence in the date format
            //  string to set the new IDATE value.
            //
            //  If none of these symbols exist in the date format string,
            //  then return an error.
            //
            pPos = wcspbrk(lpLCData, L"dMy");
            if (!pPos)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the appropriate IDATE string.
            //
            switch (*pPos)
            {
                case ( L'M' ) :
                {
                    Order = 0;
                    break;
                }

                case ( L'd' ) :
                {
                    Order = 1;
                    break;
                }

                case ( L'y' ) :
                {
                    Order = 2;
                    break;
                }
            }

            //
            //  Set the registry with the appropriate SDATE string.
            //
            //  The ptr "pPos" is pointing at either d, M, or y.
            //  Go to the next position past sequence of d, M, or y.
            //
            pPos++;
            while ((*pPos) && (wcschr( L"dMy", *pPos )))
            {
                pPos++;
            }

            *pTemp = 0;
            if (*pPos)
            {
                //
                //  Find the end of the separator string.
                //
                pPos2 = wcspbrk(pPos, L"dMy");
                if (pPos2)
                {
                    //
                    //  Copy to temp buffer so that it's zero terminated.
                    //
                    pString = pTemp;
                    while (pPos != pPos2)
                    {
                        //
                        // If there is a quoted string in the separator, then
                        // just punch in a white space, since there is no meaning
                        // for short date field separator anymore.
                        //
                        if (*pPos == L'\'')
                        {
                            pString = pTemp;
                            *pString++ = L' ';
                            break;
                        }
                        *pString = *pPos;
                        pPos++;
                        pString++;
                    }
                    *pString = 0;
                }
            }

            //
            // Since the date separator (LOCALE_SDATE) is being set here, we
            // should do the same validation as LOCALE_SDATE.
            //
            if (!IsValidSeparatorString( pTemp,
                                         MAX_SDATE,
                                         TRUE ))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Make sure that the date separator does NOT contain any
            //  of the special date picture characters - d, M, y, g, '.
            //
            if (wcspbrk(pTemp, L"dMyg'"))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }



            //
            //  Call the server to set the registry.
            //
            return (SetMultipleUserInfo( LCType,
                                         cchData,
                                         lpLCData,
                                         pTemp,
                                         (Order == 0) ? L"0" :
                                             ((Order == 1) ? L"1" : L"2"),
                                         NULL,
                                         NULL ));
            break;
        }
        case ( LOCALE_SDATE ) :
        {
            //
            //  NOTE: Must link the SSHORTDATE value in the registry.
            //

            //
            //  Validate the new value.  It should be no longer than
            //  MAX_SDATE wide characters in length and should not
            //  contain any integer values (L'0' thru L'9').
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).
            //
            if (!IsValidSeparatorString( lpLCData,
                                         MAX_SDATE,
                                         TRUE ))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Make sure that the date separator does NOT contain any
            //  of the special date picture characters - d, M, y, g, '.
            //
            if (wcspbrk(lpLCData, L"dMyg'"))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Get the current setting for SSHORTDATE.
            //
            if (GetUserInfo( Locale,
                             LOCALE_SSHORTDATE,
                             FIELD_OFFSET(NLS_USER_INFO, sShortDate),
                             NLS_VALUE_SSHORTDATE,
                             pOutput,
                             ARRAYSIZE(pOutput),
                             TRUE ))
            {
                pString = pOutput;
            }
            else
            {
                pString = (LPWORD)(pHashN->pLocaleHdr) +
                          pHashN->pLocaleHdr->SShortDate;
            }

            //
            //  Get the current setting for SDATE.
            //
            if (GetUserInfo( Locale,
                             LCType,
                             FIELD_OFFSET(NLS_USER_INFO, sDate),
                             NLS_VALUE_SDATE,
                             pOutput2,
                             ARRAYSIZE(pOutput2),
                             TRUE ))
            {
                pSep = pOutput2;
            }
            else
            {
                pSep = (LPWORD)(pHashN->pLocaleHdr) +
                       pHashN->pLocaleHdr->SDate;
            }

            //
            //  Get the length of the separator string.
            //
            SepLen = NlsStrLenW(pSep);

            //
            //  Setup the string containing the characters to find in
            //  the shortdate string.
            //
            pFind[0] = NLS_CHAR_QUOTE;
            pFind[1] = *pSep;
            pFind[2] = 0;

            //
            //  Find the date separator in the SSHORTDATE string and
            //  replace it with the new date separator.
            //
            //  The new separator may be a different length than
            //  the old one, so must use a static buffer for the new
            //  short date format string.
            //
            pPos = pTemp;
            while (pPos2 = wcspbrk(pString, pFind))
            {
                //
                //  Copy format string up to pPos2.
                //
                while (pString < pPos2)
                {
                    *pPos = *pString;
                    pPos++;
                    pString++;
                }

                switch (*pPos2)
                {
                    case ( NLS_CHAR_QUOTE ) :
                    {
                        //
                        //  Copy the quote.
                        //
                        *pPos = *pString;
                        pPos++;
                        pString++;

                        //
                        //  Copy what's inside the quotes.
                        //
                        while ((*pString) && (*pString != NLS_CHAR_QUOTE))
                        {
                            *pPos = *pString;
                            pPos++;
                            pString++;
                        }

                        //
                        //  Copy the end quote.
                        //
                        *pPos = NLS_CHAR_QUOTE;
                        pPos++;
                        if (*pString)
                        {
                            pString++;
                        }

                        break;
                    }
                    default :
                    {
                        //
                        //  Make sure it's the old separator.
                        //
                        if (NlsStrNEqualW(pString, pSep, SepLen))
                        {
                            //
                            //  Adjust pointer to skip over old separator.
                            //
                            pString += SepLen;

                            //
                            //  Copy the new separator.
                            //
                            pPos2 = (LPWSTR)lpLCData;
                            while (*pPos2)
                            {
                                *pPos = *pPos2;
                                pPos++;
                                pPos2++;
                            }
                        }
                        else
                        {
                            //
                            //  Copy the code point and continue.
                            //
                            *pPos = *pString;
                            pPos++;
                            pString++;
                        }

                        break;
                    }
                }
            }

            //
            //  Copy to the end of the string and null terminate it.
            //
            while (*pString)
            {
                *pPos = *pString;
                pPos++;
                pString++;
            }
            *pPos = 0;

            //
            //  Call the server to set the registry.
            //
            return (SetMultipleUserInfo( LCType,
                                         cchData,
                                         pTemp,
                                         lpLCData,
                                         NULL,
                                         NULL,
                                         NULL ));
            break;
        }
        case ( LOCALE_SYEARMONTH ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_SYEARMONTH wide characters in length.
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).  This is checked below
            //        in the check for whether or not there is a date,
            //        month, or year delimeter.
            //
            if (cchData > MAX_SYEARMONTH)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Make sure one of 'M' or 'y' exists in the date
            //  format string.  If it does not, then return an error.
            //
            pPos = wcspbrk(lpLCData, L"My");
            if (!pPos)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new SYEARMONTH string.
            //
            return (SetUserInfo( LOCALE_SYEARMONTH,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_SLONGDATE ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_SLONGDATE wide characters in length.
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).  This is checked below
            //        in the check for whether or not there is a date,
            //        month, or year delimeter.
            //
            if (cchData > MAX_SLONGDATE)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Make sure one of 'd' or 'M' or 'y' exists in the date
            //  format string.  If it does not, then return an error.
            //
            pPos = wcspbrk(lpLCData, L"dMy");
            if (!pPos)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new SLONGDATE string.
            //
            return (SetUserInfo( LOCALE_SLONGDATE,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_ICALENDARTYPE ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_ICALTYPE wide characters in length.
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).
            //
            if ((cchData < 2) || (cchData > MAX_ICALTYPE) ||
                (!IsValidCalendarTypeStr(pHashN, lpLCData)))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new ICALENDARTYPE string.
            //
            return (SetUserInfo( LOCALE_ICALENDARTYPE,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_IFIRSTDAYOFWEEK ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_IFIRSTDAY wide characters in length.
            //  The value should be between 0 and MAX_VALUE_IFIRSTDAY.
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).
            //
            //        Optimized - since MAX_IFIRSTDAY is 2.
            //
            if ((cchData != MAX_IFIRSTDAY) ||
                (*lpLCData < NLS_CHAR_ZERO) ||
                (*lpLCData > MAX_CHAR_IFIRSTDAY))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new IFIRSTDAYOFWEEK string.
            //
            return (SetUserInfo( LOCALE_IFIRSTDAYOFWEEK,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        case ( LOCALE_IFIRSTWEEKOFYEAR ) :
        {
            //
            //  Validate the new value.  It should be no longer than
            //  MAX_IFIRSTWEEK wide characters in length.
            //  The value should be between 0 and MAX_VALUE_IFIRSTWEEK.
            //
            //  NOTE: The string may not be NULL, so it must be at least
            //        2 chars long (includes null).
            //
            //        Optimized - since MAX_IFIRSTWEEK is 2.
            //
            if ((cchData != MAX_IFIRSTWEEK) ||
                (*lpLCData < NLS_CHAR_ZERO) ||
                (*lpLCData > MAX_CHAR_IFIRSTWEEK))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new IFIRSTWEEKOFYEAR string.
            //
            return (SetUserInfo( LOCALE_IFIRSTWEEKOFYEAR,
                                 (LPWSTR)lpLCData,
                                 cchData ));
            break;
        }
        default :
        {
            SetLastError(ERROR_INVALID_FLAGS);
            return (FALSE);
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetCalendarInfoW
//
//  Returns one of the various pieces of information about a particular
//  calendar by querying the configuration registry.  This call also
//  indicates how much memory is necessary to contain the desired
//  information.
//
//  12-17-97    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WINAPI GetCalendarInfoW(
    LCID Locale,
    CALID Calendar,
    CALTYPE CalType,
    LPWSTR lpCalData,
    int cchData,
    LPDWORD lpValue)
{
    PLOC_HASH pHashN;                       // ptr to LOC hash node
    int Length = 0;                         // length of info string
    LPWSTR pString;                         // ptr to the info string
    BOOL UserOverride = TRUE;               // use user override
    BOOL ReturnNum = FALSE;                 // return number instead of string
    WCHAR pTemp[MAX_REG_VAL_SIZE];          // temp buffer
    UNICODE_STRING ObUnicodeStr;            // value string
    int Base = 0;                           // base for str to int conversion
    LPWSTR pOptCal;                         // ptr to optional calendar values
    PCAL_INFO pCalInfo;                     // ptr to calendar info


    //
    //  Invalid Parameter Check:
    //    - validate LCID
    //    - count is negative
    //    - NULL data pointer AND count is not zero
    //
    VALIDATE_LOCALE(Locale, pHashN, FALSE);
    if ((pHashN == NULL) ||
        (cchData < 0) ||
        ((lpCalData == NULL) && (cchData != 0)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Need to check the parameters based on the CAL_RETURN_NUMBER
    //  CalType.
    //
    if (CalType & CAL_RETURN_NUMBER)
    {
        if ((lpCalData != NULL) || (cchData != 0) || (lpValue == NULL))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return (0);
        }
    }
    else
    {
        if ((lpValue != NULL) ||
            (cchData < 0) ||
            ((lpCalData == NULL) && (cchData != 0)))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return (0);
        }
    }

    //
    //  Check for NO USER OVERRIDE flag and remove the USE CP ACP flag.
    //
    if (CalType & CAL_NOUSEROVERRIDE)
    {
        //
        //  Flag is set, so set the boolean value and remove the flag
        //  from the CalType parameter (for switch statement).
        //
        UserOverride = FALSE;
    }
    if (CalType & CAL_RETURN_NUMBER)
    {
        //
        //  Flag is set, so set the boolean value and remove the flag
        //  from the CalType parameter (for switch statement).
        //
        ReturnNum = TRUE;
    }
    CalType &= (~(CAL_NOUSEROVERRIDE | CAL_USE_CP_ACP | CAL_RETURN_NUMBER));

    //
    //  Validate the Calendar parameter.
    //
    if (((CalType != CAL_ITWODIGITYEARMAX) &&
         ((pOptCal = IsValidCalendarType(pHashN, Calendar)) == NULL)) ||
        (GetCalendar(Calendar, &pCalInfo) != NO_ERROR))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Return the appropriate information for the given CALTYPE.
    //  If user information exists for the given CALTYPE, then
    //  the user default is returned instead of the system default.
    //
    switch (CalType)
    {
        case ( CAL_ICALINTVALUE ) :
        {
            Base = 10;

            //
            //  Get the integer value for the given calendar.
            //
            pString = ((POPT_CAL)pOptCal)->pCalStr;

            break;
        }
        case ( CAL_SCALNAME ) :
        {
            //
            //  Get the calendar name for the given calendar.
            //
            pString = ((POPT_CAL)pOptCal)->pCalStr +
                      NlsStrLenW(((POPT_CAL)pOptCal)->pCalStr) + 1;

            break;
        }
        case ( CAL_ITWODIGITYEARMAX ) :
        {
            Base = 10;

            //
            // Check if a policy is enforced for the current user,
            // and if so, let's use it.
            //
            if (GetTwoDigitYearInfo(Calendar, pTemp, NLS_POLICY_TWO_DIGIT_YEAR_KEY))
            {
                pString = pTemp;
            }
            else
            {
                if (UserOverride &&
                    GetTwoDigitYearInfo(Calendar, pTemp, NLS_TWO_DIGIT_YEAR_KEY))
                {
                    pString = pTemp;
                }
                else
                {
                    //
                    //  Use the default.
                    //
                    pString = (LPWORD)pCalInfo +
                              (((PCALENDAR_VAR)pCalInfo)->STwoDigitYearMax);
                }
            }

            break;
        }
        case ( CAL_IYEAROFFSETRANGE ) :
        {
            Base = 10;

            //
            //  Get the pointer to the appropriate calendar string.
            //
            pString = (LPWORD)pCalInfo +
                      (((PCALENDAR_VAR)pCalInfo)->SEraRanges);

            //
            //  Make sure the string is NOT empty.
            //
            if (*pString)
            {
                pString = ((PERA_RANGE)pString)->pYearStr;
            }
            else
            {
                pString = L"0";
            }

            break;
        }
        case ( CAL_SERASTRING ) :
        {
            //
            //  Get the pointer to the appropriate calendar string.
            //
            pString = (LPWORD)pCalInfo +
                      (((PCALENDAR_VAR)pCalInfo)->SEraRanges);

            //
            //  Make sure the string is NOT empty.  If it is, return the
            //  empty string.
            //
            if (*pString)
            {
                pString = ((PERA_RANGE)pString)->pYearStr +
                          NlsStrLenW(((PERA_RANGE)pString)->pYearStr) + 1;
            }

            break;
        }
        case ( CAL_SSHORTDATE ) :
        {
            //
            //  Get the pointer to the appropriate calendar string.
            //
            pString = (LPWORD)pCalInfo +
                      (((PCALENDAR_VAR)pCalInfo)->SShortDate);

            //
            //  Make sure the string is NOT empty.  If it is, use the
            //  locale's short date string.
            //
            if (*pString == 0)
            {
                pString = (LPWORD)(pHashN->pLocaleHdr) +
                          pHashN->pLocaleHdr->SShortDate;
            }

            break;
        }
        case ( CAL_SLONGDATE ) :
        {
            //
            //  Get the pointer to the appropriate calendar string.
            //
            pString = (LPWORD)pCalInfo +
                      (((PCALENDAR_VAR)pCalInfo)->SLongDate);

            //
            //  Make sure the string is NOT empty.  If it is, use the
            //  locale's long date string.
            //
            if (*pString == 0)
            {
                pString = (LPWORD)(pHashN->pLocaleHdr) +
                          pHashN->pLocaleHdr->SLongDate;
            }

            break;
        }
        case ( CAL_SYEARMONTH ) :
        {
            //
            //  Get the pointer to the appropriate calendar string.
            //
            pString = (LPWORD)pCalInfo +
                      (((PCALENDAR_VAR)pCalInfo)->SYearMonth);

            //
            //  Make sure the string is NOT empty.  If it is, use the
            //  locale's year month string.
            //
            if (*pString == 0)
            {
                pString = (LPWORD)(pHashN->pLocaleHdr) +
                          pHashN->pLocaleHdr->SYearMonth;
            }

            break;
        }
        case ( CAL_SDAYNAME1 ) :
        case ( CAL_SDAYNAME2 ) :
        case ( CAL_SDAYNAME3 ) :
        case ( CAL_SDAYNAME4 ) :
        case ( CAL_SDAYNAME5 ) :
        case ( CAL_SDAYNAME6 ) :
        case ( CAL_SDAYNAME7 ) :
        case ( CAL_SABBREVDAYNAME1 ) :
        case ( CAL_SABBREVDAYNAME2 ) :
        case ( CAL_SABBREVDAYNAME3 ) :
        case ( CAL_SABBREVDAYNAME4 ) :
        case ( CAL_SABBREVDAYNAME5 ) :
        case ( CAL_SABBREVDAYNAME6 ) :
        case ( CAL_SABBREVDAYNAME7 ) :
        case ( CAL_SMONTHNAME1 ) :
        case ( CAL_SMONTHNAME2 ) :
        case ( CAL_SMONTHNAME3 ) :
        case ( CAL_SMONTHNAME4 ) :
        case ( CAL_SMONTHNAME5 ) :
        case ( CAL_SMONTHNAME6 ) :
        case ( CAL_SMONTHNAME7 ) :
        case ( CAL_SMONTHNAME8 ) :
        case ( CAL_SMONTHNAME9 ) :
        case ( CAL_SMONTHNAME10 ) :
        case ( CAL_SMONTHNAME11 ) :
        case ( CAL_SMONTHNAME12 ) :
        case ( CAL_SMONTHNAME13 ) :
        case ( CAL_SABBREVMONTHNAME1 ) :
        case ( CAL_SABBREVMONTHNAME2 ) :
        case ( CAL_SABBREVMONTHNAME3 ) :
        case ( CAL_SABBREVMONTHNAME4 ) :
        case ( CAL_SABBREVMONTHNAME5 ) :
        case ( CAL_SABBREVMONTHNAME6 ) :
        case ( CAL_SABBREVMONTHNAME7 ) :
        case ( CAL_SABBREVMONTHNAME8 ) :
        case ( CAL_SABBREVMONTHNAME9 ) :
        case ( CAL_SABBREVMONTHNAME10 ) :
        case ( CAL_SABBREVMONTHNAME11 ) :
        case ( CAL_SABBREVMONTHNAME12 ) :
        case ( CAL_SABBREVMONTHNAME13 ) :
        {
            //
            //  Get the pointer to the appropriate calendar string if the
            //  IfNames flag is set for the calendar.
            //
            pString = NULL;
            if (((PCALENDAR_VAR)pCalInfo)->IfNames)
            {
                pString = (LPWORD)pCalInfo +
                          *((LPWORD)((LPBYTE)(pCalInfo) +
                                     (FIELD_OFFSET(CALENDAR_VAR, SDayName1) +
                                      ((CalType - CAL_SDAYNAME1) * sizeof(WORD)))));
            }

            //
            //  Make sure the string is NOT empty.  If it is, use the
            //  locale's string.
            //
            if ((pString == NULL) || (*pString == 0))
            {
                pString = (LPWORD)(pHashN->pLocaleHdr) +
                          *((LPWORD)((LPBYTE)(pHashN->pLocaleHdr) +
                                     (FIELD_OFFSET(LOCALE_VAR, SDayName1) +
                                      ((CalType - CAL_SDAYNAME1) * sizeof(WORD)))));
            }

            break;
        }
        default :
        {
            SetLastError(ERROR_INVALID_FLAGS);
            return (0);
        }
    }

    //
    //  See if the caller wants the value in the form of a number instead
    //  of a string.
    //
    if (ReturnNum)
    {
        //
        //  Make sure the flags are valid and that the DWORD buffer
        //  is not NULL.
        //
        if (Base == 0)
        {
            SetLastError(ERROR_INVALID_FLAGS);
            return (0);
        }

        if (lpValue == NULL)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return (0);
        }

        //
        //  Convert the string to an int and return 2 (1 DWORD = 2 WORDS).
        //
        RtlInitUnicodeString(&ObUnicodeStr, pString);
        if (RtlUnicodeStringToInteger(&ObUnicodeStr, Base, lpValue))
        {
            SetLastError(ERROR_INVALID_FLAGS);
            return (0);
        }
        return (2);
    }

    //
    //  Get the length (in characters) of the string to copy.
    //
    if (Length == 0)
    {
        Length = NlsStrLenW(pString);
    }

    //
    //  Add one for the null termination.  All strings should be null
    //  terminated.
    //
    Length++;

    //
    //  Check cchData for size of given buffer.
    //
    if (cchData == 0)
    {
        //
        //  If cchData is 0, then we can't use lpCalData.  In this
        //  case, we simply want to return the length (in characters) of
        //  the string to be copied.
        //
        return (Length);
    }
    else if (cchData < Length)
    {
        //
        //  The buffer is too small for the string, so return an error
        //  and zero bytes written.
        //
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Copy the string to lpCalData and null terminate it.
    //  Return the number of characters copied.
    //
    wcsncpy(lpCalData, pString, Length - 1);
    lpCalData[Length - 1] = 0;
    return (Length);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetCalendarInfoW
//
//  Sets one of the various pieces of information about a particular
//  calendar by making an entry in the user's portion of the configuration
//  registry.  This will only affect the user override portion of the
//  calendar settings.  The system defaults will never be reset.
//
//  12-17-97    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI SetCalendarInfoW(
    LCID Locale,
    CALID Calendar,
    CALTYPE CalType,
    LPCWSTR lpCalData)
{
    PLOC_HASH pHashN;                       // ptr to LOC hash node
    int cchData;                            // length of lpLCData
    PCAL_INFO pCalInfo;                     // ptr to calendar info
    UNICODE_STRING ObUnicodeStr;            // value string
    DWORD Value;                            // value


    //
    //  Invalid Parameter Check:
    //    - validate LCID
    //    - NULL data pointer
    //
    //  NOTE: invalid type is checked in the switch statement below.
    //
    VALIDATE_LOCALE(Locale, pHashN, FALSE);
    if ((pHashN == NULL) || (lpCalData == NULL))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    //  Get the length of the buffer.
    //
    cchData = NlsStrLenW(lpCalData) + 1;

    //
    //  Validate the Calendar parameter.
    //
    if (GetCalendar(Calendar, &pCalInfo) != NO_ERROR)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    //  Set the appropriate user information for the given CALTYPE.
    //
    CalType &= (~CAL_USE_CP_ACP);
    switch (CalType)
    {
        case ( CAL_ITWODIGITYEARMAX ) :
        {
            //
            //  Get the default value to make sure the calendar is
            //  allowed to be set.  Things like the Japanese Era calendar
            //  may not be set.
            //
            RtlInitUnicodeString( &ObUnicodeStr,
                                  ((LPWORD)pCalInfo +
                                   (((PCALENDAR_VAR)pCalInfo)->STwoDigitYearMax)) );
            RtlUnicodeStringToInteger(&ObUnicodeStr, 10, &Value);
            if (Value <= 99)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Validate the new value.  It should be no longer than
            //  MAX_ITWODIGITYEAR wide characters in length.
            //  It should be between 99 and 9999.
            //
            if ((cchData > MAX_ITWODIGITYEAR) ||
                (cchData < 3) ||
                ((cchData == 3) &&
                 ((*lpCalData != NLS_CHAR_NINE) ||
                  (*(lpCalData + 1) != NLS_CHAR_NINE))))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (FALSE);
            }

            //
            //  Set the registry with the new TwoDigitYearMax string.
            //
            return (SetTwoDigitYearInfo(Calendar, lpCalData, cchData));
            break;
        }
        default :
        {
            SetLastError(ERROR_INVALID_FLAGS);
            return (FALSE);
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}




//-------------------------------------------------------------------------//
//                           INTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  SetUserInfo
//
//  This routine sets the given value in the registry with the given data.
//  All values must be of the type REG_SZ.
//
//  NOTE: The handle to the registry key must be closed by the CALLER if
//        the return value is NO_ERROR.
//
//  07-14-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL SetUserInfo(
    LCTYPE   LCType,
    LPWSTR pData,
    ULONG DataLength)
{

    NTSTATUS Status;

    //
    //  Get the length of the value string.
    //
    DataLength *= sizeof(WCHAR);

    //
    // If there is no logged on user or the current security context
    // isn't the logged-on interactive user, then set the registry
    // value directly.
    //
    if (! NT_SUCCESS( NlsCheckForInteractiveUser() ))
    {
        return (SetCurrentUserRegValue(LCType, pData, DataLength));
    }

    // Call into server side (csrss.exe) to set the registry and update the cache for the current user.
    Status = CsrBasepNlsSetUserInfo(LCType,
                                    pData,
                                    DataLength);

    //
    //  Check to see if the "set" operation succeeded.
    //
    if (!NT_SUCCESS(Status))
    {
        //
        //  We got a failure.  Try using just the registry apis to set the
        //  registry.  It's possible that the cache is not valid yet if this
        //  is called from setup or winlogon.
        //
        return (SetCurrentUserRegValue(LCType, pData, DataLength));
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetCurrentUserRegValue
//
//  Set the registry value for the current security context. This routine
//  is called when the current security context is different from the logged
//  on user.
//
//  12-26-98    SamerA    Created.
////////////////////////////////////////////////////////////////////////////

BOOL SetCurrentUserRegValue(
    LCTYPE   LCType,
    LPWSTR pData,
    ULONG DataLength)
{
    HANDLE hKey = NULL;
    LPWSTR pValue;
    LPWSTR pCache;

    if (0 == ValidateLCType(pNlsUserInfo, LCType, &pValue, &pCache))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Open the registry for the current security context
    //
    OPEN_CPANEL_INTL_KEY(hKey, FALSE, KEY_READ | KEY_WRITE);
    if (SetRegValue(hKey, pValue, pData, DataLength) != NO_ERROR)
    {
        CLOSE_REG_KEY(hKey);
        SetLastError(ERROR_INVALID_ACCESS);
        return (FALSE);
    }

    CLOSE_REG_KEY(hKey);

    //
    // Flush the process cache entry, if needed.
    //
    NlsFlushProcessCache(LCType);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetMultipleUserInfoInRegistry
//
//  This routine sets the given multiple values in the registry with the
//  given data.  All values must be of the type REG_SZ.
//
//  06-11-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL SetMultipleUserInfoInRegistry(
    DWORD dwFlags,
    int cchData,
    LPCWSTR pPicture,
    LPCWSTR pSeparator,
    LPCWSTR pOrder,
    LPCWSTR pTLZero,
    LPCWSTR pTimeMarkPosn)
{
    HANDLE hKey = NULL;
    ULONG rc = 0L;


    //
    //  Open the Control Panel International registry key.
    //
    OPEN_CPANEL_INTL_KEY(hKey, FALSE, KEY_READ | KEY_WRITE);

    //
    //  Save the appropriate values in the registry based on the flags.
    //
    switch (dwFlags)
    {
        case ( LOCALE_STIMEFORMAT ) :
        {
            rc = SetRegValue( hKey,
                              NLS_VALUE_STIMEFORMAT,
                              pPicture,
                              cchData * sizeof(WCHAR) );
            if (NT_SUCCESS(rc))
            {
                NlsFlushProcessCache(LOCALE_STIMEFORMAT);

                rc = SetRegValue( hKey,
                                  NLS_VALUE_STIME,
                                  pSeparator,
                                  (lstrlen(pSeparator) + 1) * sizeof(WCHAR) );
            }
            if (NT_SUCCESS(rc))
            {
                NlsFlushProcessCache(LOCALE_STIME);

                rc = SetRegValue( hKey,
                                  NLS_VALUE_ITIME,
                                  pOrder,
                                  (lstrlen(pOrder) + 1) * sizeof(WCHAR) );
            }
            if (NT_SUCCESS(rc))
            {
                NlsFlushProcessCache(LOCALE_ITIME);

                rc = SetRegValue( hKey,
                                  NLS_VALUE_ITLZERO,
                                  pTLZero,
                                  (lstrlen(pTLZero) + 1) * sizeof(WCHAR) );
            }
            if (NT_SUCCESS(rc))
            {
                NlsFlushProcessCache(LOCALE_ITLZERO);

                rc = SetRegValue( hKey,
                                  NLS_VALUE_ITIMEMARKPOSN,
                                  pTimeMarkPosn,
                                  (lstrlen(pTimeMarkPosn) + 1) * sizeof(WCHAR) );

                if (NT_SUCCESS(rc))
                {
                    NlsFlushProcessCache(LOCALE_ITIMEMARKPOSN);
                }
            }

            break;
        }
        case ( LOCALE_STIME ) :
        {
            rc = SetRegValue( hKey,
                              NLS_VALUE_STIME,
                              pSeparator,
                              cchData * sizeof(WCHAR) );
            if (NT_SUCCESS(rc))
            {
                NlsFlushProcessCache(LOCALE_STIME);

                rc = SetRegValue( hKey,
                                  NLS_VALUE_STIMEFORMAT,
                                  pPicture,
                                  (lstrlen(pPicture) + 1) * sizeof(WCHAR) );

                if (NT_SUCCESS(rc))
                {
                    NlsFlushProcessCache(LOCALE_STIMEFORMAT);
                }
            }

            break;
        }
        case ( LOCALE_ITIME ) :
        {
            rc = SetRegValue( hKey,
                              NLS_VALUE_ITIME,
                              pOrder,
                              cchData * sizeof(WCHAR) );
            if (NT_SUCCESS(rc))
            {
                NlsFlushProcessCache(LOCALE_ITIME);

                rc = SetRegValue( hKey,
                                  NLS_VALUE_STIMEFORMAT,
                                  pPicture,
                                  (lstrlen(pPicture) + 1) * sizeof(WCHAR) );

                if (NT_SUCCESS(rc))
                {
                    NlsFlushProcessCache(LOCALE_STIMEFORMAT);
                }
            }

            break;
        }
        case ( LOCALE_SSHORTDATE ) :
        {
            rc = SetRegValue( hKey,
                              NLS_VALUE_SSHORTDATE,
                              pPicture,
                              cchData * sizeof(WCHAR) );
            if (NT_SUCCESS(rc))
            {
                NlsFlushProcessCache(LOCALE_SSHORTDATE);

                rc = SetRegValue( hKey,
                                  NLS_VALUE_SDATE,
                                  pSeparator,
                                  (lstrlen(pSeparator) + 1) * sizeof(WCHAR) );
            }
            if (NT_SUCCESS(rc))
            {
                NlsFlushProcessCache(LOCALE_SDATE);

                rc = SetRegValue( hKey,
                                  NLS_VALUE_IDATE,
                                  pOrder,
                                  (lstrlen(pOrder) + 1) * sizeof(WCHAR) );

                if (NT_SUCCESS(rc))
                {
                    NlsFlushProcessCache(LOCALE_IDATE);
                }
            }

            break;
        }
        case ( LOCALE_SDATE ) :
        {
            rc = SetRegValue( hKey,
                              NLS_VALUE_SDATE,
                              pSeparator,
                              cchData * sizeof(WCHAR) );
            if (NT_SUCCESS(rc))
            {
                NlsFlushProcessCache(LOCALE_SDATE);

                rc = SetRegValue( hKey,
                                  NLS_VALUE_SSHORTDATE,
                                  pPicture,
                                  (lstrlen(pPicture) + 1) * sizeof(WCHAR) );

                if (NT_SUCCESS(rc))
                {
                    NlsFlushProcessCache(LOCALE_SSHORTDATE);
                }
            }

            break;
        }
        default :
        {
            CLOSE_REG_KEY(hKey);
            return (FALSE);
        }
    }

    //
    //  Close the registry key.
    //
    CLOSE_REG_KEY(hKey);

    //
    //  Return the result.
    //
    return (rc == NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetMultipleUserInfo
//
//  This routine calls the server to set multiple registry values.  This way,
//  only one client/server transition is necessary.
//
//  08-19-94    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL SetMultipleUserInfo(
    DWORD dwFlags,
    int cchData,
    LPCWSTR pPicture,
    LPCWSTR pSeparator,
    LPCWSTR pOrder,
    LPCWSTR pTLZero,
    LPCWSTR pTimeMarkPosn)
{
    NTSTATUS Status;

    //
    // If there is no logged on user or the current security context
    // isn't the logged-on interactive user, then set the registry
    // value directly.
    //
    if (! NT_SUCCESS( NlsCheckForInteractiveUser() ))
    {
        if (SetMultipleUserInfoInRegistry( dwFlags,
                                           cchData,
                                           pPicture,
                                           pSeparator,
                                           pOrder,
                                           pTLZero,
                                           pTimeMarkPosn ) == FALSE)
        {
            SetLastError(ERROR_INVALID_ACCESS);
            return (FALSE);
        }

        return (TRUE);
    }

    Status = CsrBasepNlsSetMultipleUserInfo(dwFlags,
                                            cchData,
                                            pPicture,
                                            pSeparator,
                                            pOrder,
                                            pTLZero,
                                            pTimeMarkPosn
                                            );
    //
    //  Check to see if the "set" operation succeeded.
    //

    if (!NT_SUCCESS(Status))
    {
        //
        //  We got a failure.  Try using just the registry apis to set the
        //  registry.  It's possible that the cache is not valid yet if this
        //  is called from setup or winlogon.
        //
        if (SetMultipleUserInfoInRegistry( dwFlags,
                                           cchData,
                                           pPicture,
                                           pSeparator,
                                           pOrder,
                                           pTLZero,
                                           pTimeMarkPosn ) == FALSE)
        {
            SetLastError(ERROR_INVALID_ACCESS);
            return (FALSE);
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetTwoDigitYearInfo
//
//  This routine gets the two digit year info from the registry.
//
//  12-17-97    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL GetTwoDigitYearInfo(
    CALID Calendar,
    LPWSTR pYearInfo,
    PWSTR pwszKeyPath)
{
    HANDLE hKey = NULL;                          // handle to key
    WCHAR pCalStr[MAX_PATH];                     // ptr to calendar id string
    PKEY_VALUE_FULL_INFORMATION pKeyValueFull;   // ptr to query info
    BYTE pStatic[MAX_KEY_VALUE_FULLINFO];        // ptr to static buffer
    BOOL IfAlloc = FALSE;                        // if buffer was allocated
    ULONG rc = 0L;                               // return code
    BOOL bResult = FALSE;                        // result
    UNICODE_STRING ObUnicodeStr;                 // year string
    DWORD Year;                                  // year value


    //
    //  Open the Control Panel International registry key.
    //
    if (OpenRegKey( &hKey,
                    NULL,
                    pwszKeyPath,
                    KEY_READ ) != NO_ERROR)
    {
        return (FALSE);
    }

    //
    //  Convert calendar value to Unicode string.
    //
    if (NlsConvertIntegerToString(Calendar, 10, 0, pCalStr, MAX_PATH))
    {
        NtClose(hKey);
        return (FALSE);
    }

    //
    //  Query the registry for the TwoDigitYearMax value.
    //
    pKeyValueFull = (PKEY_VALUE_FULL_INFORMATION)pStatic;
    rc = QueryRegValue( hKey,
                        pCalStr,
                        &pKeyValueFull,
                        MAX_KEY_VALUE_FULLINFO,
                        &IfAlloc );

    //
    //  Close the registry key.
    //
    NtClose(hKey);

    //
    //  See if the TwoDigitYearMax value is present.
    //
    if (rc != NO_ERROR)
    {
        return (FALSE);
    }

    //
    //  See if the TwoDigitYearMax data is present.
    //
    if (pKeyValueFull->DataLength > 2)
    {
        //
        //  Copy the info.
        //
        NlsStrCpyW(pYearInfo, GET_VALUE_DATA_PTR(pKeyValueFull));

        //
        //  Make sure the value is between 99 and 9999.
        //
        RtlInitUnicodeString(&ObUnicodeStr, pYearInfo);
        if ((RtlUnicodeStringToInteger(&ObUnicodeStr, 10, &Year) == NO_ERROR) &&
            (Year >= 99) && (Year <= 9999))
        {
            bResult = TRUE;
        }
    }

    //
    //  Free the buffer used for the query.
    //
    if (IfAlloc)
    {
        NLS_FREE_MEM(pKeyValueFull);
    }

    //
    //  Return the result.
    //
    return (bResult);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetTwoDigitYearInfo
//
//  This routine sets the two digit year info in the registry.
//
//  12-17-97    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL SetTwoDigitYearInfo(
    CALID Calendar,
    LPCWSTR pYearInfo,
    int cchData)
{
    HANDLE hKey = NULL;                          // handle to key
    WCHAR pCalStr[MAX_PATH];                     // ptr to calendar id string
    ULONG rc = 0L;                               // return code


    //
    //  Open the Control Panel International registry key.
    //  If it doesn't exist, then we have to create each subkey
    //  separately.
    //
    if (OpenRegKey( &hKey,
                    NULL,
                    NLS_TWO_DIGIT_YEAR_KEY,
                    KEY_READ | KEY_WRITE ) != NO_ERROR)
    {
        //
        //  Registry key does not exist, so create each subkey
        //  separately.
        //
        if (CreateRegKey( &hKey,
                          NULL,
                          NLS_CALENDARS_KEY,
                          KEY_READ | KEY_WRITE ) == NO_ERROR)
        {
            if (CreateRegKey( &hKey,
                              NULL,
                              NLS_TWO_DIGIT_YEAR_KEY,
                              KEY_READ | KEY_WRITE ) != NO_ERROR)
            {
                return (FALSE);
            }
        }
        else
        {
            return (FALSE);
        }
    }

    //
    //  Make sure all Gregorian calendars are set to the same value.
    //
    switch (Calendar)
    {
        case ( 1 ) :
        case ( 2 ) :
        case ( 9 ) :
        case ( 10 ) :
        case ( 11 ) :
        case ( 12 ) :
        {
            rc = SetRegValue(hKey, L"1", pYearInfo, (ULONG)cchData * sizeof(WCHAR));
            if (rc == NO_ERROR)
            {
                rc = SetRegValue(hKey, L"2", pYearInfo, (ULONG)cchData * sizeof(WCHAR));
            }
            if (rc == NO_ERROR)
            {
                rc = SetRegValue(hKey, L"9",  pYearInfo, (ULONG)cchData * sizeof(WCHAR));
            }
            if (rc == NO_ERROR)
            {
                rc = SetRegValue(hKey, L"10", pYearInfo, (ULONG)cchData * sizeof(WCHAR));
            }
            if (rc == NO_ERROR)
            {
                rc = SetRegValue(hKey, L"11", pYearInfo, (ULONG)cchData * sizeof(WCHAR));
            }
            if (rc == NO_ERROR)
            {
                rc = SetRegValue(hKey, L"12", pYearInfo, (ULONG)cchData * sizeof(WCHAR));
            }

            break;
        }
        default :
        {
            //
            //  Convert calendar value to Unicode string.
            //
            if (NlsConvertIntegerToString(Calendar, 10, 0, pCalStr, MAX_PATH))
            {
                NtClose(hKey);
                return (FALSE);
            }

            //
            //  Set the TwoDigitYearMax value in the registry.
            //
            rc = SetRegValue(hKey, pCalStr, pYearInfo, (ULONG)cchData * sizeof(WCHAR));

            break;
        }
    }

    //
    // Update the NlsCacheUpdateCount inside csrss
    //
    if (rc == NO_ERROR)
    {
        CsrBasepNlsUpdateCacheCount();
    }

    //
    //  Close the registry key.
    //
    NtClose(hKey);

    //
    //  Return the result.
    //
    return (rc == NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\init.c ===
/*++

Copyright (c) 1991-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    init.c

Abstract:

    This file contains the initialization code for the NLS APIs.

    External Routines found in this file:
      NlsDllInitialize

Revision History:

    05-31-91    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nls.h"
#include "stdio.h"



//
//  Global Variables.
//

HANDLE                hModule;              // handle to module
RTL_CRITICAL_SECTION  gcsTblPtrs;           // critical section for tbl ptrs

UINT                  gAnsiCodePage;        // Ansi code page value
UINT                  gOemCodePage;         // OEM code page value
UINT                  gMacCodePage;         // MAC code page value
LCID                  gSystemLocale;        // system locale value
LANGID                gSystemInstallLang;   // system's original install language
PLOC_HASH             gpSysLocHashN;        // ptr to system loc hash node
PLOC_HASH             gpInvLocHashN;        // ptr to invariant loc hash node
PCP_HASH              gpACPHashN;           // ptr to ACP hash node
PCP_HASH              gpOEMCPHashN;         // ptr to OEMCP hash node
PCP_HASH              gpMACCPHashN;         // ptr to MACCP hash node

HANDLE                hCodePageKey;         // handle to System\Nls\CodePage key
HANDLE                hLocaleKey;           // handle to System\Nls\Locale key
HANDLE                hAltSortsKey;         // handle to Locale\Alternate Sorts key
HANDLE                hLangGroupsKey;       // handle to System\Nls\Language Groups key
PNLS_USER_INFO        pNlsUserInfo;         // ptr to the user info cache

RTL_CRITICAL_SECTION  gcsNlsProcessCache;   // critical section for nls process cache




//
//  Forward Declarations.
//

ULONG
NlsServerInitialize(void);

ULONG
NlsProcessInitialize(void);

void
InitKoreanWeights(void);





//-------------------------------------------------------------------------//
//                           EXTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  NlsDllInitialize
//
//  DLL Entry initialization procedure for NLSAPI.  This is called by
//  the base dll initialization.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOLEAN NlsDllInitialize(
    IN PVOID hMod,
    ULONG Reason,
    IN PBASE_STATIC_SERVER_DATA pBaseStaticServerData)
{

    if (Reason == DLL_PROCESS_ATTACH)
    {
        ULONG rc;

        //
        //  Save module handle for use later.
        //
        hModule = (HANDLE)hMod;

        //
        //  Initialize the cached user info pointer.
        //
        pNlsUserInfo = &(pBaseStaticServerData->NlsUserInfo);

        //
        //  Process attaching, so initialize tables.
        //
        rc = NlsServerInitialize();
        if (rc)
        {
            KdPrint(("NLSAPI: Could NOT initialize Server - %lx.\n", rc));
            return (FALSE);
        }

        rc = NlsProcessInitialize();
        if (rc)
        {
            KdPrint(("NLSAPI: Could NOT initialize Process - %lx.\n", rc));
            return (FALSE);
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  NlsThreadCleanup
//
//  Cleanup for thread resources when it terminates.
//
//  03-30-99    SamerA    Created.
////////////////////////////////////////////////////////////////////////////

BOOLEAN NlsThreadCleanup(void)
{
    if (NtCurrentTeb()->NlsCache)
    {
        CLOSE_REG_KEY( ((PNLS_LOCAL_CACHE)NtCurrentTeb()->NlsCache)->CurrentUserKeyHandle );
        RtlFreeHeap( RtlProcessHeap(),
                     0,
                     NtCurrentTeb()->NlsCache
                   );
    }

    return (TRUE);
}





//-------------------------------------------------------------------------//
//                           INTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//

////////////////////////////////////////////////////////////////////////////
//
//  NlsServerInitialize
//
//  Server initialization procedure for NLSAPI.  This is the ONE-TIME
//  initialization code for the NLSAPI DLL.  It simply does the calls
//  to NtCreateSection for the code pages that are currently found in the
//  system.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG NlsServerInitialize(void)
{
    HANDLE hSec = (HANDLE)0;           // section handle
    ULONG rc = 0L;                     // return code

#ifndef DOSWIN32
    PIMAGE_NT_HEADERS NtHeaders;

    //
    //  This is to avoid being initialized again when NTSD dynlinks to
    //  a server to get at its debugger extensions.
    //
    NtHeaders = RtlImageNtHeader(NtCurrentPeb()->ImageBaseAddress);
    if (NtHeaders &&
        (NtHeaders->OptionalHeader.Subsystem != IMAGE_SUBSYSTEM_NATIVE))
    {
        return (NO_ERROR);
    }
#endif

    //
    //  MultiUser NT (Hydra). SesssionId = 0 is the console CSRSS.
    //  If this is NOT the first server process, then just return success,
    //  since we only want to create the object directories once.
    //
    if (NtCurrentPeb()->SessionId != 0)
    {
        return (NO_ERROR);
    }

    //
    //  Create the NLS object directory.
    //
    //  Must create a separate directory off the root in order to have
    //  CreateSection access on the fly.
    //
    if (rc = CreateNlsObjectDirectory())
    {
        return (rc);
    }

    //
    //  The ACP, OEMCP, and Default Language files are already created
    //  at boot time.  The pointers to the files are stored in the PEB.
    //
    //  Create the section for the following data files:
    //      UNICODE
    //      LOCALE
    //      CTYPE
    //      SORTKEY
    //      SORT TABLES
    //
    //  All other data files will have the sections created only as they
    //  are needed.
    //
    if ((!NT_SUCCESS(rc = CsrBasepNlsCreateSection( NLS_CREATE_SECTION_UNICODE, 0, &hSec))) ||
        (!NT_SUCCESS(rc = CsrBasepNlsCreateSection( NLS_CREATE_SECTION_LOCALE, 0, &hSec)))  ||
        (!NT_SUCCESS(rc = CsrBasepNlsCreateSection( NLS_CREATE_SECTION_CTYPE, 0, &hSec)))   ||
        (!NT_SUCCESS(rc = CsrBasepNlsCreateSection( NLS_CREATE_SECTION_SORTKEY, 0, &hSec))) ||
        (!NT_SUCCESS(rc = CsrBasepNlsCreateSection( NLS_CREATE_SECTION_SORTTBLS, 0, &hSec))))
    {
        return (rc);
    }

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  NlsProcessInitialize
//
//  Process initialization procedure for NLS API.  This routine sets up all
//  of the tables so that they are accessable from the current process.  If
//  it is unable to allocate the appropriate memory or memory map the
//  appropriate files, an error is returned.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG NlsProcessInitialize(void)
{
    ULONG rc = 0L;                     // return code
    LPWORD pBaseAddr;                  // ptr to base address of section
    LCID UserLocale;                   // user locale id
    PLOC_HASH pUserLocHashN;           // ptr to user locale hash node

    //
    //  Initialize the critical section that protects the NLS cache for
    //  this process.
    //
    if ((rc = RtlInitializeCriticalSection(&gcsNlsProcessCache)) != ERROR_SUCCESS)
    {
        return (rc);
    }

    //
    //  Initialize the table pointers critical section.
    //  Enter the critical section to set up the tables.
    //
    if ((rc = RtlInitializeCriticalSectionAndSpinCount(&gcsTblPtrs, 4000)) != ERROR_SUCCESS)
    {
        return (rc);
    }
    RtlEnterCriticalSection(&gcsTblPtrs);

    //
    //  Allocate initial tables.
    //
    if (rc = AllocTables())
    {
        KdPrint(("AllocTables failed, rc %lx\n", rc));
        RtlLeaveCriticalSection(&gcsTblPtrs);
        return (rc);
    }

    //
    //  Initialize the handles to the various registry keys to NULL.
    //
    hCodePageKey = NULL;
    hLocaleKey = NULL;
    hAltSortsKey = NULL;
    hLangGroupsKey = NULL;

    //
    //  Get the ANSI code page value.
    //  Create the hash node for the ACP.
    //  Insert the hash node into the global CP hash table.
    //
    //  At this point, the ACP table has already been mapped into
    //  the process, so get the pointer from the PEB.
    //
    pBaseAddr = NtCurrentPeb()->AnsiCodePageData;
    gAnsiCodePage = ((PCP_TABLE)(pBaseAddr + CP_HEADER))->CodePage;
    if (rc = MakeCPHashNode( gAnsiCodePage,
                             pBaseAddr,
                             &gpACPHashN,
                             FALSE,
                             NULL ))
    {
        RtlLeaveCriticalSection(&gcsTblPtrs);
        return (rc);
    }

    //
    //  Get the OEM code page value.
    //  Create the hash node for the OEMCP.
    //  Insert the hash node into the global CP hash table.
    //
    //  At this point, the OEMCP table has already been mapped into
    //  the process, so get the pointer from the PEB.
    //
    pBaseAddr = NtCurrentPeb()->OemCodePageData;
    gOemCodePage = ((PCP_TABLE)(pBaseAddr + CP_HEADER))->CodePage;
    if (gOemCodePage != gAnsiCodePage)
    {
        //
        //  Oem code page is different than the Ansi code page, so
        //  need to create and store the new hash node.
        //
        if (rc = MakeCPHashNode( gOemCodePage,
                                 pBaseAddr,
                                 &gpOEMCPHashN,
                                 FALSE,
                                 NULL ))
        {
            RtlLeaveCriticalSection(&gcsTblPtrs);
            return (rc);
        }
    }
    else
    {
        //
        //  Oem code page is the same as the Ansi code page, so set
        //  the oem cp hash node to be the same as the ansi cp hash node.
        //
        gpOEMCPHashN = gpACPHashN;
    }

    //
    //  Initialize the MAC code page values to 0.
    //  These values will be set the first time they are requested for use.
    //
    gMacCodePage = 0;
    gpMACCPHashN = NULL;

    //
    //  Open and Map a View of the Section for UNICODE.NLS.
    //  Save the pointers to the table information in the table ptrs
    //  structure.
    //
    if (rc = GetUnicodeFileInfo())
    {
        KdPrint(("GetUnicodeFileInfo failed, rc %lx\n", rc));
        RtlLeaveCriticalSection(&gcsTblPtrs);
        return (rc);
    }

    //
    //  Cache the system locale value.
    //
    rc = NtQueryDefaultLocale(FALSE, &gSystemLocale);
    if (!NT_SUCCESS(rc))
    {
        RtlLeaveCriticalSection(&gcsTblPtrs);
        return (rc);
    }

    //
    //  Store the user locale value.
    //
    UserLocale = pNlsUserInfo->UserLocaleId;
    if (UserLocale == 0)        
    {
        UserLocale = gSystemLocale;
    }

    //
    //  Initialize the system install language to zero.  This will only
    //  be retrieved on an as need basis.
    //
    gSystemInstallLang = 0;

    //
    //  Open and Map a View of the Section for LOCALE.NLS.
    //  Create and insert the hash node into the global Locale hash table
    //  for the system default locale.
    //
    if (rc = GetLocaleFileInfo( gSystemLocale,
                                &gpSysLocHashN,
                                TRUE ))
    {
        //
        //  Change the system locale to be the default (English).
        //
        if (GetLocaleFileInfo( MAKELCID(NLS_DEFAULT_LANGID, SORT_DEFAULT),
                               &gpSysLocHashN,
                               TRUE ))
        {
            KdPrint(("Couldn't do English\n"));
            RtlLeaveCriticalSection(&gcsTblPtrs);
            return (rc);
        }
        else
        {
            //
            //  Registry is corrupt, but allow the English default to
            //  work.  Need to reset the system default.
            //
            gSystemLocale = MAKELCID(NLS_DEFAULT_LANGID, SORT_DEFAULT);
            KdPrint(("NLSAPI: Registry is corrupt - Using Default Locale.\n"));
        }
    }

    //
    //  If the user default locale is different from the system default
    //  locale, then create and insert the hash node into the global
    //  Locale hash table for the user default locale.
    //
    //  NOTE:  The System Default Locale Hash Node should be
    //         created before this call.
    //
    if (UserLocale != gSystemLocale)
    {
        if (rc = GetLocaleFileInfo( UserLocale,
                                    &pUserLocHashN,
                                    TRUE ))
        {
            //
            //  Change the user locale to be equal to the system default.
            //
            UserLocale = gSystemLocale;
            KdPrint(("NLSAPI: Registry is corrupt - User Locale Now Equals System Locale.\n"));
        }
    }

    //
    //  Create and insert the hash node into the global Locale hash
    //  table for the invariant locale.
    //
    if (rc = GetLocaleFileInfo( LOCALE_INVARIANT,
                                &gpInvLocHashN,
                                TRUE ))
    {
        KdPrint(("NLSAPI: Registry is corrupt - Invariant Locale Cannot Be Initialized.\n"));
    }

    //
    //  Open and Map a View of the Section for SORTKEY.NLS.
    //  Save the pointers to the semaphore dword and the default sortkey
    //  table in the table ptrs structure.
    //
    if (rc = GetDefaultSortkeyFileInfo())
    {
        KdPrint(("NLSAPI: Initialization, GetDefaultSortkeyFileInfo failed with rc %lx.\n", rc));
//      RtlLeaveCriticalSection(&gcsTblPtrs);
//      return (rc);
    }

    //
    //  Open and Map a View of the Section for SORTTBLS.NLS.
    //  Save the pointers to the sort table information in the
    //  table ptrs structure.
    //
    if (rc = GetDefaultSortTablesFileInfo())
    {
        RtlLeaveCriticalSection(&gcsTblPtrs);
        return (rc);
    }

    //
    //  Get the language information portion of the system locale.
    //
    //  NOTE:  GetDefaultSortkeyFileInfo and GetDefaultSortTablesFileInfo
    //         should be called before this so that the default sorting
    //         tables are already initialized at the time of the call.
    //
    if (rc = GetLanguageFileInfo( gSystemLocale,
                                  &gpSysLocHashN,
                                  FALSE,
                                  0 ))
    {
        RtlLeaveCriticalSection(&gcsTblPtrs);
        return (rc);
    }

    //
    //  Get the language information portion of the invariant locale. We
    //  use the default locale (US English).
    //
    if (rc = GetLanguageFileInfo( MAKELCID(NLS_DEFAULT_LANGID, SORT_DEFAULT),
                                  &gpInvLocHashN,
                                  FALSE,
                                  0 ))
    {
        RtlLeaveCriticalSection(&gcsTblPtrs);
        return (rc);
    }

    //
    //  If the user default is different from the system default,
    //  get the language information portion of the user default locale.
    //
    //  NOTE:  GetDefaultSortkeyFileInfo and GetDefaultSortTablesFileInfo
    //         should be called before this so that the default sorting
    //         tables are already initialized at the time of the call.
    //
    if (gSystemLocale != UserLocale)
    {
        if (rc = MakeLangHashNode( UserLocale,
                                   NULL,
                                   &pUserLocHashN,
                                   FALSE ))
        {
            RtlLeaveCriticalSection(&gcsTblPtrs);
            return (rc);
        }
    }

    //
    //  Initialize the Korean SMWeight values.
    //
    InitKoreanWeights();

    //
    //  Leave the critical section.
    //
    RtlLeaveCriticalSection(&gcsTblPtrs);

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitKoreanWeights
//
//  Creates the SMWeight array with the IDEOGRAPH script member sorting
//  before all other script members.
//
//  NOTE: This function assumes we're in a critical section.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

void InitKoreanWeights()
{
    DWORD ctr;                                 // loop counter
    BYTE NewScript;                            // new script to store
    LPBYTE pSMWeight = pTblPtrs->SMWeight;     // ptr to script member weights
    PMULTI_WT pMulti;                          // ptr to multi weight


    //
    //  Set the 0 to FIRST_SCRIPT of script structure to its default
    //  value.
    //
    RtlZeroMemory(pSMWeight, NUM_SM);
    for (ctr = 1; ctr < FIRST_SCRIPT; ctr++)
    {
        pSMWeight[ctr] = (BYTE)ctr;
    }

    //
    //  Save the order in the SMWeight array.
    //
    NewScript = FIRST_SCRIPT;
    pSMWeight[IDEOGRAPH] = NewScript;
    NewScript++;

    //
    //  See if the script is part of a multiple weights script.
    //
    pMulti = pTblPtrs->pMultiWeight;
    for (ctr = pTblPtrs->NumMultiWeight; ctr > 0; ctr--, pMulti++)
    {
        if (pMulti->FirstSM == IDEOGRAPH)
        {
            //
            //  Part of multiple weight, so must move entire range
            //  by setting each value in range to NewScript and
            //  then incrementing NewScript.
            //
            //  NOTE:  May use 'ctr' here since it ALWAYS breaks
            //         out of outer for loop.
            //
            for (ctr = 1; ctr < pMulti->NumSM; ctr++)
            {
                pSMWeight[IDEOGRAPH + ctr] = NewScript;
                NewScript++;
            }
            break;
        }
    }

    //
    //  Must set each script member that has not yet been reset to its
    //  new order.
    //
    //  The default ordering is to assign:
    //       Order  =  Script Member Value
    //
    //  Therefore, can simply set each zero entry in order to the end
    //  of the array to the next 'NewScript' value.
    //
    for (ctr = FIRST_SCRIPT; ctr < NUM_SM; ctr++)
    {
        //
        //  If it's a zero value, set it to the next sorting order value.
        //
        if (pSMWeight[ctr] == 0)
        {
            pSMWeight[ctr] = NewScript;
            NewScript++;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\ntwow64n.h ===
NTSTATUS
NTAPI
NtWow64CsrBasepNlsGetUserInfo(
    IN LCID Locale,
    IN SIZE_T CacheOffset,
    IN LPWSTR pData,
    IN ULONG DataLength
    );


NTSTATUS
NTAPI
NtWow64CsrBasepNlsSetUserInfo(
    IN LCTYPE   LCType,
    IN LPWSTR pData,
    IN ULONG DataLength
    );

NTSTATUS
NTAPI
NtWow64CsrBasepNlsSetMultipleUserInfo(
    IN DWORD dwFlags,
    IN int cchData,
    IN LPCWSTR pPicture,
    IN LPCWSTR pSeparator,
    IN LPCWSTR pOrder,
    IN LPCWSTR pTLZero,
    IN LPCWSTR pTimeMarkPosn
    );


NTSTATUS
NTAPI
NtWow64CsrBasepNlsCreateSection(
    IN UINT uiType,
    IN LCID Locale,
    OUT PHANDLE phSection
    );

NTSTATUS
NtWow64CsrBasepNlsUpdateCacheCount(
    VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\nlssafe.h ===
/*----
Copyright (c) 1991-2002,  Microsoft Corporation  All rights reserved.

Module Name:

    nlssafe.h

Abstract:

    This file is present for strsafe support. We cannot add this to nls.h
    as not all of the clients who include this file are "safe" in the
    strsafe sense.

Revision History:

    03-22-2002    v-michka    Created.

--*/

#ifndef _STRSAFE_H_INCLUDED_

// CONSIDER: Use the lib version of strsafe here?
//#define STRSAFE_LIB

#include <strsafe.h>
#endif _STRSAFE_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\map.c ===
/*++

Copyright (c) 1991-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    map.c

Abstract:

    This file contains functions that deal with map tables.

    APIs found in this file:
      FoldStringW
      LCMapStringW

Revision History:

    05-31-91    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nls.h"
#include "jamo.h"




//
//  Constant Declarations.
//

//
//  Invalid weight value.
//
#define MAP_INVALID_UW       0xffff

//
//  Number of bytes in each weight.
//
//  Note: Total number of bytes is limited by MAX_WEIGHTS definition.
//        The padding is needed if SW is not on a WORD boundary.
//
#define NUM_BYTES_UW         8
#define NUM_BYTES_DW         1
#define NUM_BYTES_CW         1
#define NUM_BYTES_XW         4
#define NUM_BYTES_PADDING    0
#define NUM_BYTES_SW         4

//
//  Flags to drop the 3rd weight (CW).
//
#define NORM_DROP_CW         (NORM_IGNORECASE | NORM_IGNOREWIDTH)

//
//  XW Values for FE Special Weights.
//
BYTE pXWDrop[] =                  // values to drop from XW
{
    0xc6,                         // weight 4
    0x03,                         // weight 5
    0xe4,                         // weight 6
    0xc5                          // weight 7
};
BYTE pXWSeparator[] =             // separator values for XW
{
    0xff,                         // weight 4
    0x02,                         // weight 5
    0xff,                         // weight 6
    0xff                          // weight 7
};




//
//  Forward Declarations.
//

int
FoldCZone(
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest);

int
FoldDigits(
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest);

int
FoldCZone_Digits(
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest);

int FoldLigatures(
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest);

int
FoldPreComposed(
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest);

int
FoldComposite(
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest);

int
MapCase(
    PLOC_HASH pHashN,
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest,
    PCASE pCaseTbl);

int
MapSortKey(
    PLOC_HASH pHashN,
    DWORD dwFlags,
    LPCWSTR pSrc,
    int cchSrc,
    LPBYTE pDest,
    int cchDest,
    BOOL fModify);

int
MapNormalization(
    PLOC_HASH pHashN,
    DWORD dwFlags,
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest);

int
MapKanaWidth(
    PLOC_HASH pHashN,
    DWORD dwFlags,
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest);

int
MapHalfKana(
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest,
    PKANA pKana,
    PCASE pCase);

int
MapFullKana(
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest,
    PKANA pKana,
    PCASE pCase);

int
MapTraditionalSimplified(
    PLOC_HASH pHashN,
    DWORD dwFlags,
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest,
    PCHINESE pChinese);





//-------------------------------------------------------------------------//
//                             API ROUTINES                                //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  FoldStringW
//
//  Maps one wide character string to another performing the specified
//  translation.  This mapping routine only takes flags that are locale
//  independent.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WINAPI FoldStringW(
    DWORD dwMapFlags,
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest)
{
    int Count = 0;                // word count


    //
    //  Invalid Parameter Check:
    //     - length of src string is 0
    //     - either buffer size is negative (except cchSrc == -1)
    //     - src string is NULL
    //     - length of dest string is NOT zero AND dest string is NULL
    //     - same buffer - src = destination
    //
    //     - flags are checked in switch statement below
    //
    if ((cchSrc == 0) || (cchDest < 0) ||
        (lpSrcStr == NULL) ||
        ((cchDest != 0) && (lpDestStr == NULL)) ||
        (lpSrcStr == lpDestStr))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  If cchSrc is -1, then the source string is null terminated and we
    //  need to get the length of the source string.  Add one to the
    //  length to include the null termination.
    //  (This will always be at least 1.)
    //
    if (cchSrc <= -1)
    {
        cchSrc = NlsStrLenW(lpSrcStr) + 1;
    }

    //
    //  Map the string based on the given flags.
    //
    switch (dwMapFlags)
    {
        case ( MAP_FOLDCZONE ) :
        {
            //
            //  Map the string to fold the Compatibility Zone.
            //
            Count = FoldCZone( lpSrcStr,
                               cchSrc,
                               lpDestStr,
                               cchDest );
            break;
        }
        case ( MAP_FOLDDIGITS ) :
        {
            //
            //  Map the string to fold the Ascii Digits.
            //
            Count = FoldDigits( lpSrcStr,
                                cchSrc,
                                lpDestStr,
                                cchDest );
            break;
        }
        case ( MAP_EXPAND_LIGATURES ) :
        {
            //
            //  Map the string to expand all Ligatures.
            //
            Count = FoldLigatures( lpSrcStr,
                                   cchSrc,
                                   lpDestStr,
                                   cchDest );
            break;
        }
        case ( MAP_PRECOMPOSED ) :
        {
            //
            //  Map the string to compress all composite forms of
            //  characters to their precomposed form.
            //
            Count = FoldPreComposed( lpSrcStr,
                                     cchSrc,
                                     lpDestStr,
                                     cchDest );
            break;
        }
        case ( MAP_COMPOSITE ) :
        {
            //
            //  Map the string to expand out all precomposed characters
            //  to their composite form.
            //
            Count = FoldComposite( lpSrcStr,
                                   cchSrc,
                                   lpDestStr,
                                   cchDest );
            break;
        }
        case ( MAP_FOLDCZONE | MAP_FOLDDIGITS ) :
        {
            //
            //  Map the string to fold the Compatibility Zone and fold the
            //  Ascii Digits.
            //
            Count = FoldCZone_Digits( lpSrcStr,
                                      cchSrc,
                                      lpDestStr,
                                      cchDest );
            break;
        }
        case ( MAP_EXPAND_LIGATURES | MAP_FOLDCZONE ) :
        {
            //
            //  Map the string to expand the ligatures and fold the
            //  Compatibility Zone.
            //
            Count = FoldLigatures( lpSrcStr,
                                   cchSrc,
                                   lpDestStr,
                                   cchDest );
            Count = FoldCZone( lpDestStr,
                               Count,
                               lpDestStr,
                               cchDest );
            break;
        }
        case ( MAP_EXPAND_LIGATURES | MAP_FOLDDIGITS ) :
        {
            //
            //  Map the string to expand the ligatures and fold the
            //  Ascii Digits.
            //
            Count = FoldLigatures( lpSrcStr,
                                   cchSrc,
                                   lpDestStr,
                                   cchDest );
            Count = FoldDigits( lpDestStr,
                                Count,
                                lpDestStr,
                                cchDest );
            break;
        }
        case ( MAP_EXPAND_LIGATURES | MAP_FOLDCZONE | MAP_FOLDDIGITS ) :
        {
            //
            //  Map the string to expand the ligatures, fold the
            //  Compatibility Zone and fold the Ascii Digits.
            //
            Count = FoldLigatures( lpSrcStr,
                                   cchSrc,
                                   lpDestStr,
                                   cchDest );
            Count = FoldCZone_Digits( lpDestStr,
                                      Count,
                                      lpDestStr,
                                      cchDest );
            break;
        }
        case ( MAP_PRECOMPOSED | MAP_FOLDCZONE ) :
        {
            //
            //  Map the string to convert to precomposed forms and to
            //  fold the Compatibility Zone.
            //
            Count = FoldPreComposed( lpSrcStr,
                                     cchSrc,
                                     lpDestStr,
                                     cchDest );
            Count = FoldCZone( lpDestStr,
                               Count,
                               lpDestStr,
                               cchDest );
            break;
        }
        case ( MAP_PRECOMPOSED | MAP_FOLDDIGITS ) :
        {
            //
            //  Map the string to convert to precomposed forms and to
            //  fold the Ascii Digits.
            //
            Count = FoldPreComposed( lpSrcStr,
                                     cchSrc,
                                     lpDestStr,
                                     cchDest );
            Count = FoldDigits( lpDestStr,
                                Count,
                                lpDestStr,
                                cchDest );
            break;
        }
        case ( MAP_PRECOMPOSED | MAP_FOLDCZONE | MAP_FOLDDIGITS ) :
        {
            //
            //  Map the string to convert to precomposed forms,
            //  fold the Compatibility Zone, and fold the Ascii Digits.
            //
            Count = FoldPreComposed( lpSrcStr,
                                     cchSrc,
                                     lpDestStr,
                                     cchDest );
            Count = FoldCZone_Digits( lpDestStr,
                                      Count,
                                      lpDestStr,
                                      cchDest );
            break;
        }
        case ( MAP_COMPOSITE | MAP_FOLDCZONE ) :
        {
            //
            //  Map the string to convert to composite forms and to
            //  fold the Compatibility Zone.
            //
            Count = FoldComposite( lpSrcStr,
                                   cchSrc,
                                   lpDestStr,
                                   cchDest );
            Count = FoldCZone( lpDestStr,
                               Count,
                               lpDestStr,
                               cchDest );
            break;
        }
        case ( MAP_COMPOSITE | MAP_FOLDDIGITS ) :
        {
            //
            //  Map the string to convert to composite forms and to
            //  fold the Ascii Digits.
            //
            Count = FoldComposite( lpSrcStr,
                                   cchSrc,
                                   lpDestStr,
                                   cchDest );
            Count = FoldDigits( lpDestStr,
                                Count,
                                lpDestStr,
                                cchDest );
            break;
        }
        case ( MAP_COMPOSITE | MAP_FOLDCZONE | MAP_FOLDDIGITS ) :
        {
            //
            //  Map the string to convert to composite forms,
            //  fold the Compatibility Zone, and fold the Ascii Digits.
            //
            Count = FoldComposite( lpSrcStr,
                                   cchSrc,
                                   lpDestStr,
                                   cchDest );
            Count = FoldCZone_Digits( lpDestStr,
                                      Count,
                                      lpDestStr,
                                      cchDest );
            break;
        }
        default :
        {
            SetLastError(ERROR_INVALID_FLAGS);
            return (0);
        }
    }

    //
    //  Return the number of characters written to the buffer.
    //  Or, if cchDest == 0, then return the number of characters
    //  that would have been written to the buffer.
    //
    return (Count);
}


////////////////////////////////////////////////////////////////////////////
//
//  LCMapStringW
//
//  Maps one wide character string to another performing the specified
//  translation.  This mapping routine only takes flags that are locale
//  dependent.
//
//  05-31-91    JulieB    Created.
//  07-26-93    JulieB    Added new flags for NT-J.
////////////////////////////////////////////////////////////////////////////

int WINAPI LCMapStringW(
    LCID Locale,
    DWORD dwMapFlags,
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest)
{
    PLOC_HASH pHashN;             // ptr to LOC hash node
    int Count = 0;                // word count or byte count
    int ctr;                      // loop counter


    //
    //  Invalid Parameter Check:
    //     - validate LCID
    //     - length of src string is 0
    //     - destination buffer size is negative
    //     - src string is NULL
    //     - length of dest string is NOT zero AND dest string is NULL
    //     - same buffer - src = destination
    //              if not UPPER or LOWER or
    //              UPPER or LOWER used with Japanese flags
    //
    VALIDATE_LANGUAGE(Locale, pHashN, dwMapFlags & LCMAP_LINGUISTIC_CASING, TRUE);
    if ( (pHashN == NULL) ||
         (cchSrc == 0) || (cchDest < 0) || (lpSrcStr == NULL) ||
         ((cchDest != 0) && (lpDestStr == NULL)) ||
         ((lpSrcStr == lpDestStr) &&
          ((!(dwMapFlags & (LCMAP_UPPERCASE | LCMAP_LOWERCASE))) ||
           (dwMapFlags & (LCMAP_HIRAGANA | LCMAP_KATAKANA |
                          LCMAP_HALFWIDTH | LCMAP_FULLWIDTH)))) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Invalid Flags Check:
    //     - flags other than valid ones or 0
    //     - (any NORM_ flag) AND (any LCMAP_ flag except byterev and sortkey)
    //     - (NORM_ flags for sortkey) AND (NOT LCMAP_SORTKEY)
    //     - more than one of lower, upper, sortkey
    //     - more than one of hiragana, katakana, sortkey
    //     - more than one of half width, full width, sortkey
    //     - more than one of traditional, simplified, sortkey
    //     - (LINGUISTIC flag) AND (NOT LCMAP_UPPER OR LCMAP_LOWER)
    //
    dwMapFlags &= (~LOCALE_USE_CP_ACP);
    if ( (dwMapFlags & LCMS_INVALID_FLAG) || (dwMapFlags == 0) ||
         ((dwMapFlags & (NORM_ALL | SORT_STRINGSORT)) &&
          (dwMapFlags & LCMAP_NO_NORM)) ||
         ((dwMapFlags & NORM_SORTKEY_ONLY) &&
          (!(dwMapFlags & LCMAP_SORTKEY))) ||
         (MORE_THAN_ONE(dwMapFlags, LCMS1_SINGLE_FLAG)) ||
         (MORE_THAN_ONE(dwMapFlags, LCMS2_SINGLE_FLAG)) ||
         (MORE_THAN_ONE(dwMapFlags, LCMS3_SINGLE_FLAG)) ||
         (MORE_THAN_ONE(dwMapFlags, LCMS4_SINGLE_FLAG)) ||
         ((dwMapFlags & LCMAP_LINGUISTIC_CASING) &&
          (!(dwMapFlags & (LCMAP_UPPERCASE | LCMAP_LOWERCASE)))) )
    {
        SetLastError(ERROR_INVALID_FLAGS);
        return (0);
    }

    //
    //  If cchSrc is -1, then the source string is null terminated and we
    //  need to get the length of the source string.  Add one to the
    //  length to include the null termination.
    //  (This will always be at least 1.)
    //
    if (cchSrc <= -1)
    {
        cchSrc = NlsStrLenW(lpSrcStr) + 1;
    }

    //
    //  Map the string based on the given flags.
    //
    if (dwMapFlags & LCMAP_SORTKEY)
    {
        //
        //  Map the string to its sortkey.
        //
        //  NOTE:  This returns the number of BYTES, instead of the
        //         number of wide characters (words).
        //
        Count = MapSortKey( pHashN,
                            dwMapFlags,
                            lpSrcStr,
                            cchSrc,
                            (LPBYTE)lpDestStr,
                            cchDest,
                            IS_KOREAN(Locale) );
    }
    else
    {
        switch (dwMapFlags & ~(LCMAP_BYTEREV | LCMAP_LINGUISTIC_CASING))
        {
            case ( LCMAP_LOWERCASE ) :
            {
                //
                //  Map the string to Lower Case.
                //
                Count = MapCase( pHashN,
                                 lpSrcStr,
                                 cchSrc,
                                 lpDestStr,
                                 cchDest,
                                 (dwMapFlags & LCMAP_LINGUISTIC_CASING)
                                     ? pHashN->pLowerLinguist
                                     : pHashN->pLowerCase );
                break;
            }
            case ( LCMAP_UPPERCASE ) :
            {
                //
                //  Map the string to Upper Case.
                //
                Count = MapCase( pHashN,
                                 lpSrcStr,
                                 cchSrc,
                                 lpDestStr,
                                 cchDest,
                                 (dwMapFlags & LCMAP_LINGUISTIC_CASING)
                                     ? pHashN->pUpperLinguist
                                     : pHashN->pUpperCase );
                break;
            }
            case ( NORM_IGNORENONSPACE )                      :
            case ( NORM_IGNORESYMBOLS )                       :
            case ( NORM_IGNORENONSPACE | NORM_IGNORESYMBOLS ) :
            {
                //
                //  Map the string to strip out nonspace marks and/or symbols.
                //
                Count = MapNormalization( pHashN,
                                          dwMapFlags & ~LCMAP_BYTEREV,
                                          lpSrcStr,
                                          cchSrc,
                                          lpDestStr,
                                          cchDest );
                break;
            }
            case ( LCMAP_TRADITIONAL_CHINESE ) :
            case ( LCMAP_TRADITIONAL_CHINESE | LCMAP_LOWERCASE ) :
            case ( LCMAP_TRADITIONAL_CHINESE | LCMAP_UPPERCASE) :
            {
                //
                //  Map the string to Traditional Chinese.
                //
                Count = MapTraditionalSimplified( pHashN,
                                                  dwMapFlags & ~LCMAP_BYTEREV,
                                                  lpSrcStr,
                                                  cchSrc,
                                                  lpDestStr,
                                                  cchDest,
                                                  pTblPtrs->pTraditional );
                break;
            }
            case ( LCMAP_SIMPLIFIED_CHINESE )  :
            case ( LCMAP_SIMPLIFIED_CHINESE | LCMAP_LOWERCASE )  :
            case ( LCMAP_SIMPLIFIED_CHINESE | LCMAP_UPPERCASE )  :
            {
                //
                //  Map the string to Simplified Chinese.
                //
                Count = MapTraditionalSimplified( pHashN,
                                                  dwMapFlags & ~LCMAP_BYTEREV,
                                                  lpSrcStr,
                                                  cchSrc,
                                                  lpDestStr,
                                                  cchDest,
                                                  pTblPtrs->pSimplified );
                break;
            }
            default :
            {
                //
                //  Make sure the Chinese flags are not used with the
                //  Japanese flags.
                //
                if (dwMapFlags &
                     (LCMAP_TRADITIONAL_CHINESE | LCMAP_SIMPLIFIED_CHINESE))
                {
                    SetLastError(ERROR_INVALID_FLAGS);
                    return (0);
                }

                //
                //  The only flags not yet handled are the variations
                //  containing the Kana and/or Width flags.
                //  This handles all variations for:
                //      LCMAP_HIRAGANA
                //      LCMAP_KATAKANA
                //      LCMAP_HALFWIDTH
                //      LCMAP_FULLWIDTH
                //
                //      Allow LCMAP_LOWERCASE and LCMAP_UPPERCASE
                //      in combination with the kana and width flags.
                //
                Count = MapKanaWidth( pHashN,
                                      dwMapFlags & ~LCMAP_BYTEREV,
                                      lpSrcStr,
                                      cchSrc,
                                      lpDestStr,
                                      cchDest );
                break;
            }
        }
    }

    //
    //  Always check LCMAP_BYTEREV last and do it in place.
    //  LCMAP_BYTEREV may be used in combination with any other flag
    //  (except ignore case without sortkey) or by itself.
    //
    if (dwMapFlags & LCMAP_BYTEREV)
    {
        //
        //  Reverse the bytes of each word in the string.
        //
        if (dwMapFlags == LCMAP_BYTEREV)
        {
            //
            //  Byte Reversal flag is used by itself.
            //
            //  Make sure that the size of the destination buffer is
            //  larger than zero.  If it is zero, return the size of
            //  the source string only.  Do NOT touch lpDestStr.
            //
            if (cchDest != 0)
            {
                //
                //  Flag is used by itself.  Reverse the bytes from
                //  the source string and store them in the destination
                //  string.
                //
                if (cchSrc > cchDest)
                {
                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    return (0);
                }

                for (ctr = 0; ctr < cchSrc; ctr++)
                {
                    lpDestStr[ctr] = MAKEWORD( HIBYTE(lpSrcStr[ctr]),
                                               LOBYTE(lpSrcStr[ctr]) );
                }
            }

            //
            //  Return the size of the source string.
            //
            Count = cchSrc;
        }
        else
        {
            //
            //  Make sure that the size of the destination buffer is
            //  larger than zero.  If it is zero, return the count and
            //  do NOT touch lpDestStr.
            //
            if (cchDest != 0)
            {
                //
                //  Check for sortkey flag.
                //
                if (dwMapFlags & LCMAP_SORTKEY)
                {
                    //
                    //  Sortkey flag is also set, so 'Count' contains the
                    //  number of BYTES instead of the number of words.
                    //
                    //  Reverse the bytes in place in the destination string.
                    //  No need to check the size of the destination buffer
                    //  here - it's been done elsewhere.
                    //
                    for (ctr = 0; ctr < Count / 2; ctr++)
                    {
                        lpDestStr[ctr] = MAKEWORD( HIBYTE(lpDestStr[ctr]),
                                                   LOBYTE(lpDestStr[ctr]) );
                    }
                }
                else
                {
                    //
                    //  Flag is used in combination with another flag.
                    //  Reverse the bytes in place in the destination string.
                    //  No need to check the size of the destination buffer
                    //  here - it's been done elsewhere.
                    //
                    for (ctr = 0; ctr < Count; ctr++)
                    {
                        lpDestStr[ctr] = MAKEWORD( HIBYTE(lpDestStr[ctr]),
                                                   LOBYTE(lpDestStr[ctr]) );
                    }
                }
            }
        }
    }

    //
    //  Return the number of characters (or number of bytes for sortkey)
    //  written to the buffer.
    //
    return (Count);
}




//-------------------------------------------------------------------------//
//                           INTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  FoldCZone
//
//  Stores the compatibility zone values for the given string in the
//  destination buffer, and returns the number of wide characters
//  written to the buffer.
//
//  02-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int FoldCZone(
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest)
{
    int ctr;                      // loop counter


    //
    //  If the destination value is zero, then just return the
    //  length of the source string.  Do NOT touch pDest.
    //
    if (cchDest == 0)
    {
        return (cchSrc);
    }

    //
    //  If cchSrc is greater than cchDest, then the destination buffer
    //  is too small to hold the new string.  Return an error.
    //
    if (cchSrc > cchDest)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Fold the Compatibility Zone and store it in the destination string.
    //
    for (ctr = 0; ctr < cchSrc; ctr++)
    {
        pDest[ctr] = GET_FOLD_CZONE(pTblPtrs->pCZone, pSrc[ctr]);
    }

    //
    //  Return the number of wide characters written.
    //
    return (ctr);
}


////////////////////////////////////////////////////////////////////////////
//
//  FoldDigits
//
//  Stores the ascii digits values for the given string in the
//  destination buffer, and returns the number of wide characters
//  written to the buffer.
//
//  02-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int FoldDigits(
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest)
{
    int ctr;                      // loop counter


    //
    //  If the destination value is zero, then just return the
    //  length of the source string.  Do NOT touch pDest.
    //
    if (cchDest == 0)
    {
        return (cchSrc);
    }

    //
    //  If cchSrc is greater than cchDest, then the destination buffer
    //  is too small to hold the new string.  Return an error.
    //
    if (cchSrc > cchDest)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Fold the Ascii Digits and store it in the destination string.
    //
    for (ctr = 0; ctr < cchSrc; ctr++)
    {
        pDest[ctr] = GET_ASCII_DIGITS(pTblPtrs->pADigit, pSrc[ctr]);
    }

    //
    //  Return the number of wide characters written.
    //
    return (ctr);
}


////////////////////////////////////////////////////////////////////////////
//
//  FoldCZone_Digits
//
//  Stores the compatibility zone and ascii digits values for the given
//  string in the destination buffer, and returns the number of wide
//  characters written to the buffer.
//
//  02-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int FoldCZone_Digits(
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest)
{
    int ctr;                      // loop counter


    //
    //  If the destination value is zero, then just return the
    //  length of the source string.  Do NOT touch pDest.
    //
    if (cchDest == 0)
    {
        return (cchSrc);
    }

    //
    //  If cchSrc is greater than cchDest, then the destination buffer
    //  is too small to hold the new string.  Return an error.
    //
    if (cchSrc > cchDest)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Fold the compatibility zone and the ascii digits values and store
    //  it in the destination string.
    //
    for (ctr = 0; ctr < cchSrc; ctr++)
    {
        pDest[ctr] = GET_FOLD_CZONE(pTblPtrs->pCZone, pSrc[ctr]);
        pDest[ctr] = GET_ASCII_DIGITS(pTblPtrs->pADigit, pDest[ctr]);
    }

    //
    //  Return the number of wide characters written.
    //
    return (ctr);
}


////////////////////////////////////////////////////////////////////////////
//
//  FoldLigatures
//
//  Stores the expanded ligature values for the given string in the
//  destination buffer, and returns the number of wide characters
//  written to the buffer.
//
//  10-15-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int FoldLigatures(
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest)
{
    int ctr  = 0;                 // source char counter
    int ctr2 = 0;                 // destination char counter
    DWORD Weight;                 // sort weight - used for expansions


    //
    //  Make sure the default sorting table is available.  If not,
    //  return an error.
    //
    if (pTblPtrs->pDefaultSortkey == NULL)
    {
        KdPrint(("NLSAPI: No Default Sorting Table Loaded.\n"));
        SetLastError(ERROR_FILE_NOT_FOUND);
        return (0);
    }

    //
    //  If the destination value is zero, then just return the
    //  length of the string that would be returned.  Do NOT touch pDest.
    //
    if (cchDest == 0)
    {
        //
        //  Convert the source string to expand all ligatures and calculate
        //  the number of characters that would have been written to a
        //  destination buffer.
        //
        while (ctr < cchSrc)
        {
            Weight = MAKE_SORTKEY_DWORD((pTblPtrs->pDefaultSortkey)[pSrc[ctr]]);
            if (GET_SCRIPT_MEMBER(&Weight) == EXPANSION)
            {
                do
                {
                    ctr2++;
                    Weight = MAKE_SORTKEY_DWORD(
                        (pTblPtrs->pDefaultSortkey)[GET_EXPANSION_2(&Weight)]);
                } while (GET_SCRIPT_MEMBER(&Weight) == EXPANSION);
                ctr2++;
            }
            else
            {
                ctr2++;
            }
            ctr++;
        }
    }
    else
    {
        //
        //  Convert the source string to expand all ligatures and store
        //  the result in the destination buffer.
        //
        while ((ctr < cchSrc) && (ctr2 < cchDest))
        {
            Weight = MAKE_SORTKEY_DWORD((pTblPtrs->pDefaultSortkey)[pSrc[ctr]]);
            if (GET_SCRIPT_MEMBER(&Weight) == EXPANSION)
            {
                do
                {
                    if ((ctr2 + 1) < cchDest)
                    {
                        pDest[ctr2]     = GET_EXPANSION_1(&Weight);
                        pDest[ctr2 + 1] = GET_EXPANSION_2(&Weight);
                        ctr2++;
                    }
                    else
                    {
                        ctr2++;
                        break;
                    }
                    Weight = MAKE_SORTKEY_DWORD(
                                 (pTblPtrs->pDefaultSortkey)[pDest[ctr2]]);
                } while (GET_SCRIPT_MEMBER(&Weight) == EXPANSION);

                if (ctr2 >= cchDest)
                {
                    break;
                }
                ctr2++;
            }
            else
            {
                pDest[ctr2] = pSrc[ctr];
                ctr2++;
            }
            ctr++;
        }
    }

    //
    //  Make sure destination buffer was large enough.
    //
    if (ctr < cchSrc)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Return the number of wide characters written.
    //
    return (ctr2);
}


////////////////////////////////////////////////////////////////////////////
//
//  FoldPreComposed
//
//  Stores the precomposed values for the given string in the
//  destination buffer, and returns the number of wide characters
//  written to the buffer.
//
//  02-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int FoldPreComposed(
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest)
{
    int ctr  = 0;                 // source char counter
    int ctr2 = 0;                 // destination char counter
    WCHAR wch = 0;                // wchar holder


    //
    //  Make sure the default sorting table is available.  If not,
    //  return an error.
    //
    if (pTblPtrs->pDefaultSortkey == NULL)
    {
        KdPrint(("NLSAPI: No Default Sorting Table Loaded.\n"));
        SetLastError(ERROR_FILE_NOT_FOUND);
        return (0);
    }

    //
    //  If the destination value is zero, then just return the
    //  length of the string that would be returned.  Do NOT touch pDest.
    //
    if (cchDest == 0)
    {
        //
        //  Convert the source string to precomposed and calculate the
        //  number of characters that would have been written to a
        //  destination buffer.
        //
        while (ctr < cchSrc)
        {
            if ((ctr2 != 0) &&
                (IS_NONSPACE_ONLY(pTblPtrs->pDefaultSortkey, pSrc[ctr])))
            {
                //
                //  Composite form.  Write the precomposed form.
                //
                //  If the precomposed character is written to the buffer,
                //  do NOT increment the destination pointer or the
                //  character count (the precomposed character was
                //  written over the previous character).
                //
                if (wch)
                {
                    if ((wch = GetPreComposedChar(pSrc[ctr], wch)) == 0)
                    {
                        //
                        //  No translation for composite form, so just
                        //  increment the destination counter.
                        //
                        ctr2++;
                    }
                }
                else
                {
                    if ((wch = GetPreComposedChar( pSrc[ctr],
                                                   pSrc[ctr - 1] )) == 0)
                    {
                        //
                        //  No translation for composite form, so just
                        //  increment the destination counter.
                        //
                        ctr2++;
                    }
                }
            }
            else
            {
                //
                //  Not part of a composite character, so just
                //  increment the destination counter.
                //
                wch = 0;
                ctr2++;
            }
            ctr++;
        }
    }
    else
    {
        //
        //  Convert the source string to precomposed and store it in the
        //  destination string.
        //
        while ((ctr < cchSrc) && (ctr2 < cchDest))
        {
            if ((ctr2 != 0) &&
                (IS_NONSPACE_ONLY(pTblPtrs->pDefaultSortkey, pSrc[ctr])))
            {
                //
                //  Composite form.  Write the precomposed form.
                //
                //  If the precomposed character is written to the buffer,
                //  do NOT increment the destination pointer or the
                //  character count (the precomposed character was
                //  written over the previous character).
                //
                wch = pDest[ctr2 - 1];
                if ((pDest[ctr2 - 1] =
                         GetPreComposedChar( pSrc[ctr],
                                             pDest[ctr2 - 1] )) == 0)
                {
                    //
                    //  No translation for composite form, so must
                    //  rewrite the base character and write the
                    //  composite character.
                    //
                    pDest[ctr2 - 1] = wch;
                    pDest[ctr2] = pSrc[ctr];
                    ctr2++;
                }
            }
            else
            {
                //
                //  Not part of a composite character, so just write
                //  the character to the destination string.
                //
                pDest[ctr2] = pSrc[ctr];
                ctr2++;
            }
            ctr++;
        }
    }

    //
    //  Make sure destination buffer was large enough.
    //
    if (ctr < cchSrc)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Return the number of wide characters written.
    //
    return (ctr2);
}


////////////////////////////////////////////////////////////////////////////
//
//  FoldComposite
//
//  Stores the composite values for the given string in the
//  destination buffer, and returns the number of wide characters
//  written to the buffer.
//
//  02-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int FoldComposite(
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest)
{
    int ctr  = 0;                 // source char counter
    int ctr2 = 0;                 // destination char counter
    LPWSTR pEndDest;              // ptr to end of destination string
    WCHAR pTmp[MAX_COMPOSITE];    // tmp buffer for composite chars


    //
    //  If the destination value is zero, then just return the
    //  length of the string that would be returned.  Do NOT touch pDest.
    //
    if (cchDest == 0)
    {
        //
        //  Get the end of the tmp buffer.
        //
        pEndDest = (LPWSTR)pTmp + MAX_COMPOSITE;

        //
        //  Convert the source string to precomposed and calculate the
        //  number of characters that would have been written to a
        //  destination buffer.
        //
        while (ctr < cchSrc)
        {
            //
            //  Write the character to the destination string.
            //
            *pTmp = pSrc[ctr];

            //
            //  See if it needs to be expanded to its composite form.
            //
            //  If no composite form is found, the routine returns 1 for
            //  the base character.  Simply increment by the return value.
            //
            ctr2 += InsertCompositeForm(pTmp, pEndDest);

            //
            //  Increment the source string counter.
            //
            ctr++;
        }
    }
    else
    {
        //
        //  Get the end of the destination string.
        //
        pEndDest = (LPWSTR)pDest + cchDest;

        //
        //  Convert the source string to precomposed and store it in the
        //  destination string.
        //
        while ((ctr < cchSrc) && (ctr2 < cchDest))
        {
            //
            //  Write the character to the destination string.
            //
            pDest[ctr2] = pSrc[ctr];

            //
            //  See if it needs to be expanded to its composite form.
            //
            //  If no composite form is found, the routine returns 1 for
            //  the base character.  Simply increment by the return value.
            //
            ctr2 += InsertCompositeForm(&(pDest[ctr2]), pEndDest);

            //
            //  Increment the source string counter.
            //
            ctr++;
        }
    }

    //
    //  Make sure destination buffer was large enough.
    //
    if (ctr < cchSrc)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Return the number of wide characters written.
    //
    return (ctr2);
}


////////////////////////////////////////////////////////////////////////////
//
//  MapCase
//
//  Stores the lower or upper case values for the given string in the
//  destination buffer, and returns the number of wide characters written to
//  the buffer.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int MapCase(
    PLOC_HASH pHashN,
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest,
    PCASE pCaseTbl)
{
    int ctr;                      // loop counter


    //
    //  If the destination value is zero, then just return the
    //  length of the source string.  Do NOT touch pDest.
    //
    if (cchDest == 0)
    {
        return (cchSrc);
    }

    //
    //  If cchSrc is greater than cchDest, then the destination buffer
    //  is too small to hold the lower or upper case string.  Return an
    //  error.
    //
    if (cchSrc > cchDest)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Lower or Upper case the source string and store it in the
    //  destination string.
    //
    for (ctr = 0; ctr < cchSrc; ctr++)
    {
        pDest[ctr] = GET_LOWER_UPPER_CASE(pCaseTbl, pSrc[ctr]);
    }

    //
    //  Return the number of wide characters written.
    //
    return (ctr);
}


////////////////////////////////////////////////////////////////////////////
//
//  SPECIAL_CASE_HANDLER
//
//  Handles all of the special cases for each character.  This includes only
//  the valid values less than or equal to MAX_SPECIAL_CASE.
//
//  DEFINED AS A MACRO.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define EXTRA_WEIGHT_POS(WtNum)        (*(pPosXW + (WtNum * WeightLen)))

#define SPECIAL_CASE_HANDLER( SM,                                           \
                              pWeight,                                      \
                              pSortkey,                                     \
                              pExpand,                                      \
                              Position,                                     \
                              fStringSort,                                  \
                              fIgnoreSymbols,                               \
                              pCur,                                         \
                              pBegin,                                       \
                              fModify )                                     \
{                                                                           \
    PSORTKEY pExpWt;              /* weight of 1 expansion char */          \
    BYTE AW;                      /* alphanumeric weight */                 \
    BYTE XW;                      /* case weight value with extra bits */   \
    DWORD PrevWt;                 /* previous weight */                     \
    BYTE PrevSM;                  /* previous script member */              \
    BYTE PrevAW;                  /* previuos alphanumeric weight */        \
    BYTE PrevCW;                  /* previuos case weight */                \
    LPWSTR pPrev;                 /* ptr to previous char */                \
                                                                            \
                                                                            \
    switch (SM)                                                             \
    {                                                                       \
        case ( UNSORTABLE ) :                                               \
        {                                                                   \
            /*                                                              \
             *  Character is unsortable, so skip it.                        \
             */                                                             \
            break;                                                          \
        }                                                                   \
        case ( NONSPACE_MARK ) :                                            \
        {                                                                   \
            /*                                                              \
             *  Character is a nonspace mark, so only store                 \
             *  the diacritic weight.                                       \
             */                                                             \
            if (pPosDW > pDW)                                               \
            {                                                               \
                (*(pPosDW - 1)) += GET_DIACRITIC(pWeight);                  \
            }                                                               \
            else                                                            \
            {                                                               \
                *pPosDW = GET_DIACRITIC(pWeight);                           \
                pPosDW++;                                                   \
            }                                                               \
                                                                            \
            break;                                                          \
        }                                                                   \
        case ( EXPANSION ) :                                                \
        {                                                                   \
            /*                                                              \
             *  Expansion character - one character has 2                   \
             *  different weights.  Store each weight separately.           \
             */                                                             \
            pExpWt = &(pSortkey[(pExpand[GET_EXPAND_INDEX(pWeight)]).UCP1]); \
            *pPosUW = GET_UNICODE_MOD(pExpWt, fModify);                     \
            *pPosDW = GET_DIACRITIC(pExpWt);                                \
            *pPosCW = GET_CASE(pExpWt) & CaseMask;                          \
            pPosUW++;                                                       \
            pPosDW++;                                                       \
            pPosCW++;                                                       \
                                                                            \
            pExpWt = &(pSortkey[(pExpand[GET_EXPAND_INDEX(pWeight)]).UCP2]); \
            while (GET_SCRIPT_MEMBER(pExpWt) == EXPANSION)                  \
            {                                                               \
                pWeight = pExpWt;                                           \
                pExpWt = &(pSortkey[(pExpand[GET_EXPAND_INDEX(pWeight)]).UCP1]); \
                *pPosUW = GET_UNICODE_MOD(pExpWt, fModify);                 \
                *pPosDW = GET_DIACRITIC(pExpWt);                            \
                *pPosCW = GET_CASE(pExpWt) & CaseMask;                      \
                pPosUW++;                                                   \
                pPosDW++;                                                   \
                pPosCW++;                                                   \
                pExpWt = &(pSortkey[(pExpand[GET_EXPAND_INDEX(pWeight)]).UCP2]); \
            }                                                               \
            *pPosUW = GET_UNICODE_MOD(pExpWt, fModify);                     \
            *pPosDW = GET_DIACRITIC(pExpWt);                                \
            *pPosCW = GET_CASE(pExpWt) & CaseMask;                          \
            pPosUW++;                                                       \
            pPosDW++;                                                       \
            pPosCW++;                                                       \
                                                                            \
            break;                                                          \
        }                                                                   \
        case ( PUNCTUATION ) :                                              \
        {                                                                   \
            if (!fStringSort)                                               \
            {                                                               \
                /*                                                          \
                 *  Word Sort Method.                                       \
                 *                                                          \
                 *  Character is punctuation, so only store the special     \
                 *  weight.                                                 \
                 */                                                         \
                *((LPBYTE)pPosSW)       = HIBYTE(GET_POSITION_SW(Position)); \
                *(((LPBYTE)pPosSW) + 1) = LOBYTE(GET_POSITION_SW(Position)); \
                pPosSW++;                                                   \
                *pPosSW = GET_SPECIAL_WEIGHT(pWeight);                      \
                pPosSW++;                                                   \
                                                                            \
                break;                                                      \
            }                                                               \
                                                                            \
            /*                                                              \
             *  If using STRING sort method, treat punctuation the same     \
             *  as symbol.  So, FALL THROUGH to the symbol cases.           \
             */                                                             \
        }                                                                   \
        case ( SYMBOL_1 ) :                                                 \
        case ( SYMBOL_2 ) :                                                 \
        case ( SYMBOL_3 ) :                                                 \
        case ( SYMBOL_4 ) :                                                 \
        case ( SYMBOL_5 ) :                                                 \
        {                                                                   \
            /*                                                              \
             *  Character is a symbol.                                      \
             *  Store the Unicode weights ONLY if the NORM_IGNORESYMBOLS    \
             *  flag is NOT set.                                            \
             */                                                             \
            if (!fIgnoreSymbols)                                            \
            {                                                               \
                *pPosUW = GET_UNICODE_MOD(pWeight, fModify);                \
                *pPosDW = GET_DIACRITIC(pWeight);                           \
                *pPosCW = GET_CASE(pWeight) & CaseMask;                     \
                pPosUW++;                                                   \
                pPosDW++;                                                   \
                pPosCW++;                                                   \
            }                                                               \
                                                                            \
            break;                                                          \
        }                                                                   \
        case ( FAREAST_SPECIAL ) :                                          \
        {                                                                   \
            /*                                                              \
             *  Get the alphanumeric weight and the case weight of the      \
             *  current code point.                                         \
             */                                                             \
            AW = GET_ALPHA_NUMERIC(pWeight);                                \
            XW = (GET_CASE(pWeight) & CaseMask) | CASE_XW_MASK;             \
                                                                            \
            /*                                                              \
             *  Special case Repeat and Cho-On.                             \
             *    AW = 0  =>  Repeat                                        \
             *    AW = 1  =>  Cho-On                                        \
             *    AW = 2+ =>  Kana                                          \
             */                                                             \
            if (AW <= MAX_SPECIAL_AW)                                       \
            {                                                               \
                /*                                                          \
                 *  If the script member of the previous character is       \
                 *  invalid, then give the special character an             \
                 *  invalid weight (highest possible weight) so that it     \
                 *  will sort AFTER everything else.                        \
                 */                                                         \
                pPrev = pCur - 1;                                           \
                *pPosUW = MAP_INVALID_UW;                                   \
                while (pPrev >= pBegin)                                     \
                {                                                           \
                    PrevWt = GET_DWORD_WEIGHT(pHashN, *pPrev);              \
                    PrevSM = GET_SCRIPT_MEMBER(&PrevWt);                    \
                    if (PrevSM < FAREAST_SPECIAL)                           \
                    {                                                       \
                        if (PrevSM != EXPANSION)                            \
                        {                                                   \
                            /*                                              \
                             *  UNSORTABLE or NONSPACE_MARK.                \
                             *                                              \
                             *  Just ignore these, since we only care       \
                             *  about the previous UW value.                \
                             */                                             \
                            pPrev--;                                        \
                            continue;                                       \
                        }                                                   \
                    }                                                       \
                    else if (PrevSM == FAREAST_SPECIAL)                     \
                    {                                                       \
                        PrevAW = GET_ALPHA_NUMERIC(&PrevWt);                \
                        if (PrevAW <= MAX_SPECIAL_AW)                       \
                        {                                                   \
                            /*                                              \
                             *  Handle case where two special chars follow  \
                             *  each other.  Keep going back in the string. \
                             */                                             \
                            pPrev--;                                        \
                            continue;                                       \
                        }                                                   \
                                                                            \
                        *pPosUW = MAKE_UNICODE_WT(KANA, PrevAW, fModify);   \
                                                                            \
                        /*                                                  \
                         *  Only build weights 4, 5, 6, and 7 if the        \
                         *  previous character is KANA.                     \
                         *                                                  \
                         *  Always:                                         \
                         *    4W = previous CW  &  ISOLATE_SMALL            \
                         *    6W = previous CW  &  ISOLATE_KANA             \
                         *                                                  \
                         */                                                 \
                        PrevCW = (GET_CASE(&PrevWt) & CaseMask) |           \
                                 CASE_XW_MASK;                              \
                                                                            \
                        EXTRA_WEIGHT_POS(0) = PrevCW & ISOLATE_SMALL;       \
                        EXTRA_WEIGHT_POS(2) = PrevCW & ISOLATE_KANA;        \
                                                                            \
                        if (AW == AW_REPEAT)                                \
                        {                                                   \
                            /*                                              \
                             *  Repeat:                                     \
                             *    UW = previous UW   (set above)            \
                             *    5W = WT_FIVE_REPEAT                       \
                             *    7W = previous CW  &  ISOLATE_WIDTH        \
                             */                                             \
                            EXTRA_WEIGHT_POS(1) = WT_FIVE_REPEAT;           \
                            EXTRA_WEIGHT_POS(3) = PrevCW & ISOLATE_WIDTH;   \
                        }                                                   \
                        else                                                \
                        {                                                   \
                            /*                                              \
                             *  Cho-On:                                     \
                             *    UW = previous UW  &  CHO_ON_UW_MASK       \
                             *    5W = WT_FIVE_CHO_ON                       \
                             *    7W = current  CW  &  ISOLATE_WIDTH        \
                             */                                             \
                            *pPosUW &= CHO_ON_UW_MASK;                      \
                            EXTRA_WEIGHT_POS(1) = WT_FIVE_CHO_ON;           \
                            EXTRA_WEIGHT_POS(3) = XW & ISOLATE_WIDTH;       \
                        }                                                   \
                                                                            \
                        pPosXW++;                                           \
                    }                                                       \
                    else                                                    \
                    {                                                       \
                        *pPosUW = GET_UNICODE_MOD(&PrevWt, fModify);        \
                    }                                                       \
                                                                            \
                    break;                                                  \
                }                                                           \
                                                                            \
                /*                                                          \
                 *  Make sure there is a valid UW.  If not, quit out        \
                 *  of switch case.                                         \
                 */                                                         \
                if (*pPosUW == MAP_INVALID_UW)                              \
                {                                                           \
                    pPosUW++;                                               \
                    break;                                                  \
                }                                                           \
            }                                                               \
            else                                                            \
            {                                                               \
                /*                                                          \
                 *  Kana:                                                   \
                 *    SM = KANA                                             \
                 *    AW = current AW                                       \
                 *    4W = current CW  &  ISOLATE_SMALL                     \
                 *    5W = WT_FIVE_KANA                                     \
                 *    6W = current CW  &  ISOLATE_KANA                      \
                 *    7W = current CW  &  ISOLATE_WIDTH                     \
                 */                                                         \
                *pPosUW = MAKE_UNICODE_WT(KANA, AW, fModify);               \
                EXTRA_WEIGHT_POS(0) = XW & ISOLATE_SMALL;                   \
                EXTRA_WEIGHT_POS(1) = WT_FIVE_KANA;                         \
                EXTRA_WEIGHT_POS(2) = XW & ISOLATE_KANA;                    \
                EXTRA_WEIGHT_POS(3) = XW & ISOLATE_WIDTH;                   \
                                                                            \
                pPosXW++;                                                   \
            }                                                               \
                                                                            \
            /*                                                              \
             *  Always:                                                     \
             *    DW = current DW                                           \
             *    CW = minimum CW                                           \
             */                                                             \
            *pPosDW = GET_DIACRITIC(pWeight);                               \
            *pPosCW = MIN_CW;                                               \
                                                                            \
            pPosUW++;                                                       \
            pPosDW++;                                                       \
            pPosCW++;                                                       \
                                                                            \
            break;                                                          \
        }                                                                   \
        case ( JAMO_SPECIAL ) :                                             \
        {                                                                   \
            /*                                                              \
             *  See if it's a leading Jamo.                                 \
             */                                                             \
            if (IsLeadingJamo(*pPos))                                       \
            {                                                               \
                int OldHangulCount;   /* number of old Hangul found */      \
                WORD JamoUW;                                                \
                BYTE JamoXW[3];                                             \
                                                                            \
                /*                                                          \
                 *  If the characters beginning from pPos are a valid old   \
                 *  Hangul composition, create the sortkey according to     \
                 *  the old Hangul rule.                                    \
                 */                                                         \
                if ((OldHangulCount =                                       \
                        MapOldHangulSortKey( pHashN,                        \
                                             pPos,                          \
                                             cchSrc - PosCtr,               \
                                             &JamoUW,                       \
                                             JamoXW,                        \
                                             fModify )) > 0)                \
                {                                                           \
                    *pPosUW = JamoUW;                                       \
                    pPosUW++;                                               \
                    *pPosUW = MAKE_UNICODE_WT(SM_UW_XW, JamoXW[0], FALSE);  \
                    pPosUW++;                                               \
                    *pPosUW = MAKE_UNICODE_WT(SM_UW_XW, JamoXW[1], FALSE);  \
                    pPosUW++;                                               \
                    *pPosUW = MAKE_UNICODE_WT(SM_UW_XW, JamoXW[2], FALSE);  \
                    pPosUW++;                                               \
                                                                            \
                    *pPosDW = MIN_DW;                                       \
                    *pPosCW = MIN_CW;                                       \
                    pPosDW++;                                               \
                    pPosCW++;                                               \
                                                                            \
                    /*                                                      \
                     *  Decrement OldHangulCount because the for loop will  \
                     *  increase PosCtr and pPos as well.                   \
                     */                                                     \
                    OldHangulCount--;                                       \
                    PosCtr += OldHangulCount;                               \
                    pPos += OldHangulCount;                                 \
                                                                            \
                    break;                                                  \
                }                                                           \
            }                                                               \
                                                                            \
            /*                                                              \
             *  Otherwise, fall back to the normal behavior.                \
             *                                                              \
             *  No special case on character, so store the various          \
             *  weights for the character.                                  \
             */                                                             \
                                                                            \
            /*                                                              \
             *  We store the real script member in the diacritic weight     \
             *  since both the diacritic weight and case weight are not     \
             *  used in Korean.                                             \
             */                                                             \
            *pPosUW = MAKE_UNICODE_WT( GET_DIACRITIC(pWeight),              \
                                       GET_ALPHA_NUMERIC(pWeight),          \
                                       fModify );                           \
            *pPosDW = MIN_DW;                                               \
            *pPosCW = GET_CASE(pWeight);                                    \
            pPosUW++;                                                       \
            pPosDW++;                                                       \
            pPosCW++;                                                       \
                                                                            \
            break;                                                          \
        }                                                                   \
        case ( EXTENSION_A ) :                                              \
        {                                                                   \
            /*                                                              \
             *  UW = SM_EXT_A, AW_EXT_A, AW, DW                             \
             *  DW = miniumum DW                                            \
             *  CW = minimum CW                                             \
             */                                                             \
            *pPosUW = MAKE_UNICODE_WT(SM_EXT_A, AW_EXT_A, fModify);         \
            pPosUW++;                                                       \
                                                                            \
            *pPosUW = MAKE_UNICODE_WT( GET_ALPHA_NUMERIC(pWeight),          \
                                       GET_DIACRITIC(pWeight),              \
                                       FALSE );                             \
            pPosUW++;                                                       \
                                                                            \
            *pPosDW = MIN_DW;                                               \
            *pPosCW = MIN_CW;                                               \
            pPosDW++;                                                       \
            pPosCW++;                                                       \
                                                                            \
            break;                                                          \
        }                                                                   \
    }                                                                       \
}


////////////////////////////////////////////////////////////////////////////
//
//  MapSortKey
//
//  Stores the sortkey weights for the given string in the destination
//  buffer and returns the number of BYTES written to the buffer.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int MapSortKey(
    PLOC_HASH pHashN,
    DWORD dwFlags,
    LPCWSTR pSrc,
    int cchSrc,
    LPBYTE pDest,
    int cbDest,
    BOOL fModify)
{
    register int WeightLen;       // length of one set of weights
    LPWSTR pUW;                   // ptr to Unicode Weights
    LPBYTE pDW;                   // ptr to Diacritic Weights
    LPBYTE pCW;                   // ptr to Case Weights
    LPBYTE pXW;                   // ptr to Extra Weights
    LPWSTR pSW;                   // ptr to Special Weights
    LPWSTR pPosUW;                // ptr to position in pUW buffer
    LPBYTE pPosDW;                // ptr to position in pDW buffer
    LPBYTE pPosCW;                // ptr to position in pCW buffer
    LPBYTE pPosXW;                // ptr to position in pXW buffer
    LPWSTR pPosSW;                // ptr to position in pSW buffer
    PSORTKEY pWeight;             // ptr to weight of character
    BYTE SM;                      // script member value
    BYTE CaseMask;                // mask for case weight
    int PosCtr;                   // position counter in string
    LPWSTR pPos;                  // ptr to position in string
    LPBYTE pTmp;                  // ptr to go through UW, XW, and SW
    LPBYTE pPosTmp;               // ptr to tmp position in XW
    PCOMPRESS_2 pComp2;           // ptr to compression 2 list
    PCOMPRESS_3 pComp3;           // ptr to compression 3 list
    WORD pBuffer[MAX_SORTKEY_BUF_LEN]; // buffer to hold weights
    int ctr;                      // loop counter
    BOOL IfDblCompress;           // if double compress possibility
    BOOL fStringSort;             // if using string sort method
    BOOL fIgnoreSymbols;          // if ignore symbols flag is set


    //
    //  Make sure the sorting information is available in the system.
    //
    if ((pHashN->pSortkey == NULL) ||
        (pHashN->IfIdeographFailure == TRUE))
    {
        KdPrint(("NLSAPI: Appropriate Sorting Tables Not Loaded.\n"));
        SetLastError(ERROR_FILE_NOT_FOUND);
        return (0);
    }

    //
    //  See if the length of the string is too large for the static
    //  buffer.  If so, allocate a buffer that is large enough.
    //
    if (cchSrc > MAX_SMALL_BUF_LEN)
    {
        //
        //  Allocate buffer to hold all of the weights.
        //     (cchSrc) * (max # of expansions) * (# of weights)
        //
        WeightLen = cchSrc * MAX_EXPANSION;
        if ((pUW = (LPWSTR)NLS_ALLOC_MEM( WeightLen * MAX_WEIGHTS *
                                          sizeof(WCHAR) )) == NULL)
        {
            SetLastError(ERROR_OUTOFMEMORY);
            return (0);
        }
    }
    else
    {
        WeightLen = MAX_SMALL_BUF_LEN * MAX_EXPANSION;
        pUW = (LPWSTR)pBuffer;
    }

    //
    //  Set the case weight mask based on the given flags.
    //  If none or all of the ignore case flags are set, then
    //  just leave the mask as 0xff.
    //
    CaseMask = 0xff;
    switch (dwFlags & NORM_ALL_CASE)
    {
        case ( NORM_IGNORECASE ) :
        {
            CaseMask &= CASE_UPPER_MASK;
            break;
        }
        case ( NORM_IGNOREKANATYPE ) :
        {
            CaseMask &= CASE_KANA_MASK;
            break;
        }
        case ( NORM_IGNOREWIDTH ) :
        {
            CaseMask &= CASE_WIDTH_MASK;
            break;
        }
        case ( NORM_IGNORECASE | NORM_IGNOREKANATYPE ) :
        {
            CaseMask &= (CASE_UPPER_MASK & CASE_KANA_MASK);
            break;
        }
        case ( NORM_IGNORECASE | NORM_IGNOREWIDTH ) :
        {
            CaseMask &= (CASE_UPPER_MASK & CASE_WIDTH_MASK);
            break;
        }
        case ( NORM_IGNOREKANATYPE | NORM_IGNOREWIDTH ) :
        {
            CaseMask &= (CASE_KANA_MASK & CASE_WIDTH_MASK);
            break;
        }
        case ( NORM_IGNORECASE | NORM_IGNOREKANATYPE | NORM_IGNOREWIDTH ) :
        {
            CaseMask &= (CASE_UPPER_MASK & CASE_KANA_MASK & CASE_WIDTH_MASK);
            break;
        }
    }

    //
    //  Set pointers to positions of weights in buffer.
    //
    //      UW  =>  4 word length  (extension A and Jamo need extra words)
    //      DW  =>  byte   length
    //      CW  =>  byte   length
    //      XW  =>  4 byte length  (4 weights, 1 byte each)   FE Special
    //      SW  =>  dword  length  (2 words each)
    //
    //  Note: SW must start on a WORD boundary, so XW needs to be padded
    //        appropriately.
    //
    pDW     = (LPBYTE)(pUW + (WeightLen * (NUM_BYTES_UW / sizeof(WCHAR))));
    pCW     = (LPBYTE)(pDW + (WeightLen *  NUM_BYTES_DW));
    pXW     = (LPBYTE)(pCW + (WeightLen *  NUM_BYTES_CW));
    pSW     = (LPWSTR)(pXW + (WeightLen * (NUM_BYTES_XW + NUM_BYTES_PADDING)));
    pPosUW  = pUW;
    pPosDW  = pDW;
    pPosCW  = pCW;
    pPosXW  = pXW;
    pPosSW  = pSW;

    //
    //  Initialize flags and loop values.
    //
    fStringSort = dwFlags & SORT_STRINGSORT;
    fIgnoreSymbols = dwFlags & NORM_IGNORESYMBOLS;
    pPos = (LPWSTR)pSrc;
    PosCtr = 1;

    //
    //  Check if given locale has compressions.
    //
    if (pHashN->IfCompression == FALSE)
    {
        //
        //  Go through string, code point by code point.
        //
        //  No compressions exist in the given locale, so
        //  DO NOT check for them.
        //
        for (; PosCtr <= cchSrc; PosCtr++, pPos++)
        {
            //
            //  Get weights.
            //
            pWeight = &((pHashN->pSortkey)[*pPos]);
            SM = GET_SCRIPT_MEMBER(pWeight);

            if (SM > MAX_SPECIAL_CASE)
            {
                //
                //  No special case on character, so store the
                //  various weights for the character.
                //
                *pPosUW = GET_UNICODE_MOD(pWeight, fModify);
                *pPosDW = GET_DIACRITIC(pWeight);
                *pPosCW = GET_CASE(pWeight) & CaseMask;
                pPosUW++;
                pPosDW++;
                pPosCW++;
            }
            else
            {
                SPECIAL_CASE_HANDLER( SM,
                                      pWeight,
                                      pHashN->pSortkey,
                                      pTblPtrs->pExpansion,
                                      pPosUW - pUW + 1,
                                      fStringSort,
                                      fIgnoreSymbols,
                                      pPos,
                                      (LPWSTR)pSrc,
                                      fModify );
            }
        }
    }
    else if (pHashN->IfDblCompression == FALSE)
    {
        //
        //  Go through string, code point by code point.
        //
        //  Compressions DO exist in the given locale, so
        //  check for them.
        //
        //  No double compressions exist in the given locale,
        //  so DO NOT check for them.
        //
        for (; PosCtr <= cchSrc; PosCtr++, pPos++)
        {
            //
            //  Get weights.
            //
            pWeight = &((pHashN->pSortkey)[*pPos]);
            SM = GET_SCRIPT_MEMBER(pWeight);

            if (SM > MAX_SPECIAL_CASE)
            {
                //
                //  No special case on character, but must check for
                //  compression characters.
                //
                switch (GET_COMPRESSION(pWeight))
                {
                    case ( COMPRESS_3_MASK ) :
                    {
                        if ((PosCtr + 2) <= cchSrc)
                        {
                            ctr = pHashN->pCompHdr->Num3;
                            pComp3 = pHashN->pCompress3;
                            for (; ctr > 0; ctr--, pComp3++)
                            {
                                if ((pComp3->UCP1 == *pPos) &&
                                    (pComp3->UCP2 == *(pPos + 1)) &&
                                    (pComp3->UCP3 == *(pPos + 2)))
                                {
                                    pWeight = &(pComp3->Weights);
                                    *pPosUW = GET_UNICODE_MOD(pWeight, fModify);
                                    *pPosDW = GET_DIACRITIC(pWeight);
                                    *pPosCW = GET_CASE(pWeight) & CaseMask;
                                    pPosUW++;
                                    pPosDW++;
                                    pPosCW++;

                                    //
                                    //  Add only two to source, since one
                                    //  will be added by "for" structure.
                                    //
                                    pPos += 2;
                                    PosCtr += 2;
                                    break;
                                }
                            }
                            if (ctr > 0)
                            {
                                break;
                            }
                        }

                        //
                        //  Fall through if not found.
                        //
                    }
                    case ( COMPRESS_2_MASK ) :
                    {
                        if ((PosCtr + 1) <= cchSrc)
                        {
                            ctr = pHashN->pCompHdr->Num2;
                            pComp2 = pHashN->pCompress2;
                            for (; ctr > 0; ctr--, pComp2++)
                            {
                                if ((pComp2->UCP1 == *pPos) &&
                                    (pComp2->UCP2 == *(pPos + 1)))
                                {
                                    pWeight = &(pComp2->Weights);
                                    *pPosUW = GET_UNICODE_MOD(pWeight, fModify);
                                    *pPosDW = GET_DIACRITIC(pWeight);
                                    *pPosCW = GET_CASE(pWeight) & CaseMask;
                                    pPosUW++;
                                    pPosDW++;
                                    pPosCW++;

                                    //
                                    //  Add only one to source, since one
                                    //  will be added by "for" structure.
                                    //
                                    pPos++;
                                    PosCtr++;
                                    break;
                                }
                            }
                            if (ctr > 0)
                            {
                                break;
                            }
                        }

                        //
                        //  Fall through if not found.
                        //
                    }
                    default :
                    {
                        //
                        //  No possible compression for character, so store
                        //  the various weights for the character.
                        //
                        *pPosUW = GET_UNICODE_SM_MOD(pWeight, SM, fModify);
                        *pPosDW = GET_DIACRITIC(pWeight);
                        *pPosCW = GET_CASE(pWeight) & CaseMask;
                        pPosUW++;
                        pPosDW++;
                        pPosCW++;
                    }
                }
            }
            else
            {
                SPECIAL_CASE_HANDLER( SM,
                                      pWeight,
                                      pHashN->pSortkey,
                                      pTblPtrs->pExpansion,
                                      pPosUW - pUW + 1,
                                      fStringSort,
                                      fIgnoreSymbols,
                                      pPos,
                                      (LPWSTR)pSrc,
                                      fModify );
            }
        }
    }
    else
    {
        //
        //  Go through string, code point by code point.
        //
        //  Compressions DO exist in the given locale, so
        //  check for them.
        //
        //  Double Compressions also exist in the given locale,
        //  so check for them.
        //
        for (; PosCtr <= cchSrc; PosCtr++, pPos++)
        {
            //
            //  Get weights.
            //
            pWeight = &((pHashN->pSortkey)[*pPos]);
            SM = GET_SCRIPT_MEMBER(pWeight);

            if (SM > MAX_SPECIAL_CASE)
            {
                //
                //  No special case on character, but must check for
                //  compression characters and double compression
                //  characters.
                //
                IfDblCompress =
                  (((PosCtr + 1) <= cchSrc) &&
                   ((GET_DWORD_WEIGHT(pHashN, *pPos) & CMP_MASKOFF_CW) ==
                    (GET_DWORD_WEIGHT(pHashN, *(pPos + 1)) & CMP_MASKOFF_CW)))
                   ? 1
                   : 0;

                switch (GET_COMPRESSION(pWeight))
                {
                    case ( COMPRESS_3_MASK ) :
                    {
                        if (IfDblCompress)
                        {
                            if ((PosCtr + 3) <= cchSrc)
                            {
                                ctr = pHashN->pCompHdr->Num3;
                                pComp3 = pHashN->pCompress3;
                                for (; ctr > 0; ctr--, pComp3++)
                                {
                                    if ((pComp3->UCP1 == *(pPos + 1)) &&
                                        (pComp3->UCP2 == *(pPos + 2)) &&
                                        (pComp3->UCP3 == *(pPos + 3)))
                                    {
                                        pWeight = &(pComp3->Weights);
                                        *pPosUW = GET_UNICODE_MOD(pWeight, fModify);
                                        *pPosDW = GET_DIACRITIC(pWeight);
                                        *pPosCW = GET_CASE(pWeight) & CaseMask;
                                        *(pPosUW + 1) = *pPosUW;
                                        *(pPosDW + 1) = *pPosDW;
                                        *(pPosCW + 1) = *pPosCW;
                                        pPosUW += 2;
                                        pPosDW += 2;
                                        pPosCW += 2;

                                        //
                                        //  Add only three to source, since one
                                        //  will be added by "for" structure.
                                        //
                                        pPos += 3;
                                        PosCtr += 3;
                                        break;
                                    }
                                }
                                if (ctr > 0)
                                {
                                    break;
                                }
                            }
                        }

                        //
                        //  Fall through if not found.
                        //
                        if ((PosCtr + 2) <= cchSrc)
                        {
                            ctr = pHashN->pCompHdr->Num3;
                            pComp3 = pHashN->pCompress3;
                            for (; ctr > 0; ctr--, pComp3++)
                            {
                                if ((pComp3->UCP1 == *pPos) &&
                                    (pComp3->UCP2 == *(pPos + 1)) &&
                                    (pComp3->UCP3 == *(pPos + 2)))
                                {
                                    pWeight = &(pComp3->Weights);
                                    *pPosUW = GET_UNICODE_MOD(pWeight, fModify);
                                    *pPosDW = GET_DIACRITIC(pWeight);
                                    *pPosCW = GET_CASE(pWeight) & CaseMask;
                                    pPosUW++;
                                    pPosDW++;
                                    pPosCW++;

                                    //
                                    //  Add only two to source, since one
                                    //  will be added by "for" structure.
                                    //
                                    pPos += 2;
                                    PosCtr += 2;
                                    break;
                                }
                            }
                            if (ctr > 0)
                            {
                                break;
                            }
                        }
                        //
                        //  Fall through if not found.
                        //
                    }
                    case ( COMPRESS_2_MASK ) :
                    {
                        if (IfDblCompress)
                        {
                            if ((PosCtr + 2) <= cchSrc)
                            {
                                ctr = pHashN->pCompHdr->Num2;
                                pComp2 = pHashN->pCompress2;
                                for (; ctr > 0; ctr--, pComp2++)
                                {
                                    if ((pComp2->UCP1 == *(pPos + 1)) &&
                                        (pComp2->UCP2 == *(pPos + 2)))
                                    {
                                        pWeight = &(pComp2->Weights);
                                        *pPosUW = GET_UNICODE_MOD(pWeight, fModify);
                                        *pPosDW = GET_DIACRITIC(pWeight);
                                        *pPosCW = GET_CASE(pWeight) & CaseMask;
                                        *(pPosUW + 1) = *pPosUW;
                                        *(pPosDW + 1) = *pPosDW;
                                        *(pPosCW + 1) = *pPosCW;
                                        pPosUW += 2;
                                        pPosDW += 2;
                                        pPosCW += 2;

                                        //
                                        //  Add only two to source, since one
                                        //  will be added by "for" structure.
                                        //
                                        pPos += 2;
                                        PosCtr += 2;
                                        break;
                                    }
                                }
                                if (ctr > 0)
                                {
                                    break;
                                }
                            }
                        }

                        //
                        //  Fall through if not found.
                        //
                        if ((PosCtr + 1) <= cchSrc)
                        {
                            ctr = pHashN->pCompHdr->Num2;
                            pComp2 = pHashN->pCompress2;
                            for (; ctr > 0; ctr--, pComp2++)
                            {
                                if ((pComp2->UCP1 == *pPos) &&
                                    (pComp2->UCP2 == *(pPos + 1)))
                                {
                                    pWeight = &(pComp2->Weights);
                                    *pPosUW = GET_UNICODE_MOD(pWeight, fModify);
                                    *pPosDW = GET_DIACRITIC(pWeight);
                                    *pPosCW = GET_CASE(pWeight) & CaseMask;
                                    pPosUW++;
                                    pPosDW++;
                                    pPosCW++;

                                    //
                                    //  Add only one to source, since one
                                    //  will be added by "for" structure.
                                    //
                                    pPos++;
                                    PosCtr++;
                                    break;
                                }
                            }
                            if (ctr > 0)
                            {
                                break;
                            }
                        }

                        //
                        //  Fall through if not found.
                        //
                    }
                    default :
                    {
                        //
                        //  No possible compression for character, so store
                        //  the various weights for the character.
                        //
                        *pPosUW = GET_UNICODE_SM_MOD(pWeight, SM, fModify);
                        *pPosDW = GET_DIACRITIC(pWeight);
                        *pPosCW = GET_CASE(pWeight) & CaseMask;
                        pPosUW++;
                        pPosDW++;
                        pPosCW++;
                    }
                }
            }
            else
            {
                SPECIAL_CASE_HANDLER( SM,
                                      pWeight,
                                      pHashN->pSortkey,
                                      pTblPtrs->pExpansion,
                                      pPosUW - pUW + 1,
                                      fStringSort,
                                      fIgnoreSymbols,
                                      pPos,
                                      (LPWSTR)pSrc,
                                      fModify );
            }
        }
    }

    //
    //  Store the final sortkey weights in the destination buffer.
    //
    //  PosCtr will be a BYTE count.
    //
    PosCtr = 0;

    //
    //  If the destination value is zero, then just return the
    //  length of the string that would be returned.  Do NOT touch pDest.
    //
    if (cbDest == 0)
    {
        //
        //  Count the Unicode Weights.
        //
        PosCtr += (int)((LPBYTE)pPosUW - (LPBYTE)pUW);

        //
        //  Count the Separator.
        //
        PosCtr++;

        //
        //  Count the Diacritic Weights.
        //
        //    - Eliminate minimum DW.
        //    - Count the number of diacritic weights.
        //
        if (!(dwFlags & NORM_IGNORENONSPACE))
        {
            pPosDW--;
            if (pHashN->IfReverseDW == TRUE)
            {
                //
                //  Reverse diacritics:
                //    - remove diacritics from left  to right.
                //    - count  diacritics from right to left.
                //
                while ((pDW <= pPosDW) && (*pDW <= MIN_DW))
                {
                    pDW++;
                }
                PosCtr += (int)(pPosDW - pDW + 1);
            }
            else
            {
                //
                //  Regular diacritics:
                //    - remove diacritics from right to left.
                //    - count  diacritics from left  to right.
                //
                while ((pPosDW >= pDW) && (*pPosDW <= MIN_DW))
                {
                    pPosDW--;
                }
                PosCtr += (int)(pPosDW - pDW + 1);
            }
        }

        //
        //  Count the Separator.
        //
        PosCtr++;

        //
        //  Count the Case Weights.
        //
        //    - Eliminate minimum CW.
        //    - Count the number of case weights.
        //
        if ((dwFlags & NORM_DROP_CW) != NORM_DROP_CW)
        {
            pPosCW--;
            while ((pPosCW >= pCW) && (*pPosCW <= MIN_CW))
            {
                pPosCW--;
            }
            PosCtr += (int)(pPosCW - pCW + 1);
        }

        //
        //  Count the Separator.
        //
        PosCtr++;

        //
        //  Count the Extra Weights for Far East Special.
        //
        //    - Eliminate unnecessary XW.
        //    - Count the number of extra weights and separators.
        //
        if (pXW < pPosXW)
        {
            if (dwFlags & NORM_IGNORENONSPACE)
            {
                //
                //  Ignore 4W and 5W.  Must count separators for
                //  4W and 5W, though.
                //
                PosCtr += 2;
                ctr = 2;
            }
            else
            {
                ctr = 0;
            }

            pPosXW--;
            for (; ctr < NUM_BYTES_XW; ctr++)
            {
                pTmp = pXW + (WeightLen * ctr);
                pPosTmp = pPosXW + (WeightLen * ctr);
                while ((pPosTmp >= pTmp) && (*pPosTmp == pXWDrop[ctr]))
                {
                    pPosTmp--;
                }
                PosCtr += (int)(pPosTmp - pTmp + 1);

                //
                //  Count the Separator.
                //
                PosCtr++;
            }
        }

        //
        //  Count the Separator.
        //
        PosCtr++;

        //
        //  Count the Special Weights.
        //
        if (!fIgnoreSymbols)
        {
            PosCtr += (int)((LPBYTE)pPosSW - (LPBYTE)pSW);
        }

        //
        //  Count the Terminator.
        //
        PosCtr++;
    }
    else
    {
        //
        //  Store the Unicode Weights in the destination buffer.
        //
        //    - Make sure destination buffer is large enough.
        //    - Copy unicode weights to destination buffer.
        //
        //  NOTE:  cbDest is the number of BYTES.
        //         Also, must add one to length for separator.
        //
        if (cbDest < (((LPBYTE)pPosUW - (LPBYTE)pUW) + 1))
        {
            NLS_FREE_TMP_BUFFER(pUW, pBuffer);
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return (0);
        }
        pTmp = (LPBYTE)pUW;
        while (pTmp < (LPBYTE)pPosUW)
        {
            //
            //  Copy Unicode weight to destination buffer.
            //
            //  NOTE:  Unicode Weight is stored in the data file as
            //             Alphanumeric Weight, Script Member
            //         so that the WORD value will be read correctly.
            //
            pDest[PosCtr]     = *(pTmp + 1);
            pDest[PosCtr + 1] = *pTmp;
            PosCtr += 2;
            pTmp += 2;
        }

        //
        //  Copy Separator to destination buffer.
        //
        //  Destination buffer is large enough to hold the separator,
        //  since it was checked with the Unicode weights above.
        //
        pDest[PosCtr] = SORTKEY_SEPARATOR;
        PosCtr++;

        //
        //  Store the Diacritic Weights in the destination buffer.
        //
        //    - Eliminate minimum DW.
        //    - Make sure destination buffer is large enough.
        //    - Copy diacritic weights to destination buffer.
        //
        if (!(dwFlags & NORM_IGNORENONSPACE))
        {
            pPosDW--;
            if (pHashN->IfReverseDW == TRUE)
            {
                //
                //  Reverse diacritics:
                //    - remove diacritics from left  to right.
                //    - store  diacritics from right to left.
                //
                while ((pDW <= pPosDW) && (*pDW <= MIN_DW))
                {
                    pDW++;
                }
                if ((cbDest - PosCtr) <= (pPosDW - pDW + 1))
                {
                    NLS_FREE_TMP_BUFFER(pUW, pBuffer);
                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    return (0);
                }
                while (pPosDW >= pDW)
                {
                    pDest[PosCtr] = *pPosDW;
                    PosCtr++;
                    pPosDW--;
                }
            }
            else
            {
                //
                //  Regular diacritics:
                //    - remove diacritics from right to left.
                //    - store  diacritics from left  to right.
                //
                while ((pPosDW >= pDW) && (*pPosDW <= MIN_DW))
                {
                    pPosDW--;
                }
                if ((cbDest - PosCtr) <= (pPosDW - pDW + 1))
                {
                    NLS_FREE_TMP_BUFFER(pUW, pBuffer);
                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    return (0);
                }
                while (pDW <= pPosDW)
                {
                    pDest[PosCtr] = *pDW;
                    PosCtr++;
                    pDW++;
                }
            }
        }

        //
        //  Copy Separator to destination buffer if the destination
        //  buffer is large enough.
        //
        if (PosCtr == cbDest)
        {
            NLS_FREE_TMP_BUFFER(pUW, pBuffer);
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return (0);
        }
        pDest[PosCtr] = SORTKEY_SEPARATOR;
        PosCtr++;

        //
        //  Store the Case Weights in the destination buffer.
        //
        //    - Eliminate minimum CW.
        //    - Make sure destination buffer is large enough.
        //    - Copy case weights to destination buffer.
        //
        if ((dwFlags & NORM_DROP_CW) != NORM_DROP_CW)
        {
            pPosCW--;
            while ((pPosCW >= pCW) && (*pPosCW <= MIN_CW))
            {
                pPosCW--;
            }
            if ((cbDest - PosCtr) <= (pPosCW - pCW + 1))
            {
                NLS_FREE_TMP_BUFFER(pUW, pBuffer);
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                return (0);
            }
            while (pCW <= pPosCW)
            {
                pDest[PosCtr] = *pCW;
                PosCtr++;
                pCW++;
            }
        }

        //
        //  Copy Separator to destination buffer if the destination
        //  buffer is large enough.
        //
        if (PosCtr == cbDest)
        {
            NLS_FREE_TMP_BUFFER(pUW, pBuffer);
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return (0);
        }
        pDest[PosCtr] = SORTKEY_SEPARATOR;
        PosCtr++;

        //
        //  Store the Extra Weights in the destination buffer for
        //  Far East Special.
        //
        //    - Eliminate unnecessary XW.
        //    - Make sure destination buffer is large enough.
        //    - Copy extra weights to destination buffer.
        //
        if (pXW < pPosXW)
        {
            if (dwFlags & NORM_IGNORENONSPACE)
            {
                //
                //  Ignore 4W and 5W.  Must count separators for
                //  4W and 5W, though.
                //
                if ((cbDest - PosCtr) <= 2)
                {
                    NLS_FREE_TMP_BUFFER(pUW, pBuffer);
                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    return (0);
                }

                pDest[PosCtr] = pXWSeparator[0];
                pDest[PosCtr + 1] = pXWSeparator[1];
                PosCtr += 2;
                ctr = 2;
            }
            else
            {
                ctr = 0;
            }

            pPosXW--;
            for (; ctr < NUM_BYTES_XW; ctr++)
            {
                pTmp = pXW + (WeightLen * ctr);
                pPosTmp = pPosXW + (WeightLen * ctr);
                while ((pPosTmp >= pTmp) && (*pPosTmp == pXWDrop[ctr]))
                {
                    pPosTmp--;
                }
                if ((cbDest - PosCtr) <= (pPosTmp - pTmp + 1))
                {
                    NLS_FREE_TMP_BUFFER(pUW, pBuffer);
                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    return (0);
                }
                while (pTmp <= pPosTmp)
                {
                    pDest[PosCtr] = *pTmp;
                    PosCtr++;
                    pTmp++;
                }

                //
                //  Copy Separator to destination buffer.
                //
                pDest[PosCtr] = pXWSeparator[ctr];
                PosCtr++;
            }
        }

        //
        //  Copy Separator to destination buffer if the destination
        //  buffer is large enough.
        //
        if (PosCtr == cbDest)
        {
            NLS_FREE_TMP_BUFFER(pUW, pBuffer);
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return (0);
        }
        pDest[PosCtr] = SORTKEY_SEPARATOR;
        PosCtr++;

        //
        //  Store the Special Weights in the destination buffer.
        //
        //    - Make sure destination buffer is large enough.
        //    - Copy special weights to destination buffer.
        //
        if (!fIgnoreSymbols)
        {
            if ((cbDest - PosCtr) <= (((LPBYTE)pPosSW - (LPBYTE)pSW)))
            {
                NLS_FREE_TMP_BUFFER(pUW, pBuffer);
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                return (0);
            }
            pTmp = (LPBYTE)pSW;
            while (pTmp < (LPBYTE)pPosSW)
            {
                pDest[PosCtr]     = *pTmp;
                pDest[PosCtr + 1] = *(pTmp + 1);

                //
                //  NOTE:  Special Weight is stored in the data file as
                //             Weight, Script
                //         so that the WORD value will be read correctly.
                //
                pDest[PosCtr + 2] = *(pTmp + 3);
                pDest[PosCtr + 3] = *(pTmp + 2);

                PosCtr += 4;
                pTmp += 4;
            }
        }

        //
        //  Copy Terminator to destination buffer if the destination
        //  buffer is large enough.
        //
        if (PosCtr == cbDest)
        {
            NLS_FREE_TMP_BUFFER(pUW, pBuffer);
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return (0);
        }
        pDest[PosCtr] = SORTKEY_TERMINATOR;
        PosCtr++;
    }

    //
    //  Free the buffer used for the weights, if one was allocated.
    //
    NLS_FREE_TMP_BUFFER(pUW, pBuffer);

    //
    //  Return number of BYTES written to destination buffer.
    //
    return (PosCtr);
}


////////////////////////////////////////////////////////////////////////////
//
//  MapNormalization
//
//  Stores the result of the normalization for the given string in the
//  destination buffer, and returns the number of wide characters written
//  to the buffer.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int MapNormalization(
    PLOC_HASH pHashN,
    DWORD dwFlags,
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest)
{
    int ctr;                      // source char counter
    int ctr2 = 0;                 // destination char counter

    //
    //  Make sure the ctype table is available in the system.
    //
    if (GetCTypeFileInfo())
    {
        SetLastError(ERROR_FILE_NOT_FOUND);
        return (0);
    }

    //
    //  Make sure the sorting information is available in the system.
    //
    if ((pHashN->pSortkey == NULL) ||
        (pHashN->IfIdeographFailure == TRUE))
    {
        KdPrint(("NLSAPI: Appropriate Sorting Tables Not Loaded.\n"));
        SetLastError(ERROR_FILE_NOT_FOUND);
        return (0);
    }

    //
    //  Normalize based on the flags.
    //
    switch (dwFlags)
    {
        case ( NORM_IGNORENONSPACE ) :
        {
            //
            //  If the destination value is zero, then only return
            //  the count of characters.  Do NOT touch pDest.
            //
            if (cchDest == 0)
            {
                //
                //  Count the number of characters that would be written
                //  to the destination buffer.
                //
                for (ctr = 0, ctr2 = 0; ctr < cchSrc; ctr++)
                {
                    if (!IS_NONSPACE(pHashN->pSortkey, pSrc[ctr]))
                    {
                        //
                        //  Not a nonspacing character, so just write the
                        //  character to the destination string.
                        //
                        ctr2++;
                    }
                    else if (!(IS_NONSPACE_ONLY(pHashN->pSortkey, pSrc[ctr])))
                    {
                        //
                        //  PreComposed Form.  Write the base character only.
                        //
                        ctr2++;
                    }
                    //
                    //  Else - nonspace character only, so don't write
                    //         anything.
                    //
                }
            }
            else
            {
                //
                //  Store the normalized string in the destination string.
                //
                for (ctr = 0, ctr2 = 0; (ctr < cchSrc) && (ctr2 < cchDest);
                     ctr++)
                {
                    if (!IS_NONSPACE(pHashN->pSortkey, pSrc[ctr]))
                    {
                        //
                        //  Not a nonspacing character, so just write the
                        //  character to the destination string.
                        //
                        pDest[ctr2] = pSrc[ctr];
                        ctr2++;
                    }
                    else if (!(IS_NONSPACE_ONLY(pHashN->pSortkey, pSrc[ctr])))
                    {
                        //
                        //  PreComposed Form.  Write the base character only.
                        //
                        GET_BASE_CHAR(pSrc[ctr], pDest[ctr2]);
                        if (pDest[ctr2] == 0)
                        {
                            //
                            //  No translation for precomposed character,
                            //  so must write the precomposed character.
                            //
                            pDest[ctr2] = pSrc[ctr];
                        }
                        ctr2++;
                    }
                    //
                    //  Else - nonspace character only, so don't write
                    //         anything.
                    //
                }
            }

            break;
        }
        case ( NORM_IGNORESYMBOLS ) :
        {
            //
            //  If the destination value is zero, then only return
            //  the count of characters.  Do NOT touch pDest.
            //
            if (cchDest == 0)
            {
                //
                //  Count the number of characters that would be written
                //  to the destination buffer.
                //
                for (ctr = 0, ctr2 = 0; ctr < cchSrc; ctr++)
                {
                    if (!IS_SYMBOL(pHashN->pSortkey, pSrc[ctr]))
                    {
                        //
                        //  Not a symbol, so write the character.
                        //
                        ctr2++;
                    }
                }
            }
            else
            {
                //
                //  Store the normalized string in the destination string.
                //
                for (ctr = 0, ctr2 = 0; (ctr < cchSrc) && (ctr2 < cchDest);
                     ctr++)
                {
                    if (!IS_SYMBOL(pHashN->pSortkey, pSrc[ctr]))
                    {
                        //
                        //  Not a symbol, so write the character.
                        //
                        pDest[ctr2] = pSrc[ctr];
                        ctr2++;
                    }
                }
            }

            break;
        }
        case ( NORM_IGNORENONSPACE | NORM_IGNORESYMBOLS ) :
        {
            //
            //  If the destination value is zero, then only return
            //  the count of characters.  Do NOT touch pDest.
            //
            if (cchDest == 0)
            {
                //
                //  Count the number of characters that would be written
                //  to the destination buffer.
                //
                for (ctr = 0, ctr2 = 0; ctr < cchSrc; ctr++)
                {
                    if (!IS_SYMBOL(pHashN->pSortkey, pSrc[ctr]))
                    {
                        //
                        //  Not a symbol, so check for nonspace.
                        //
                        if (!IS_NONSPACE(pHashN->pSortkey, pSrc[ctr]))
                        {
                            //
                            //  Not a nonspacing character, so just write the
                            //  character to the destination string.
                            //
                            ctr2++;
                        }
                        else if (!(IS_NONSPACE_ONLY( pHashN->pSortkey,
                                                     pSrc[ctr] )))
                        {
                            //
                            //  PreComposed Form.  Write the base character
                            //  only.
                            //
                            ctr2++;
                        }
                        //
                        //  Else - nonspace character only, so don't write
                        //         anything.
                        //
                    }
                }
            }
            else
            {
                //
                //  Store the normalized string in the destination string.
                //
                for (ctr = 0, ctr2 = 0; (ctr < cchSrc) && (ctr2 < cchDest);
                     ctr++)
                {
                    //
                    //  Check for symbol and nonspace.
                    //
                    if (!IS_SYMBOL(pHashN->pSortkey, pSrc[ctr]))
                    {
                        //
                        //  Not a symbol, so check for nonspace.
                        //
                        if (!IS_NONSPACE(pHashN->pSortkey, pSrc[ctr]))
                        {
                            //
                            //  Not a nonspacing character, so just write the
                            //  character to the destination string.
                            //
                            pDest[ctr2] = pSrc[ctr];
                            ctr2++;
                        }
                        else if (!(IS_NONSPACE_ONLY( pHashN->pSortkey,
                                                     pSrc[ctr] )))
                        {
                            //
                            //  PreComposed Form.  Write the base character
                            //  only.
                            //
                            GET_BASE_CHAR(pSrc[ctr], pDest[ctr2]);
                            if (pDest[ctr2] == 0)
                            {
                                //
                                //  No translation for precomposed character,
                                //  so must write the precomposed character.
                                //
                                pDest[ctr2] = pSrc[ctr];
                            }
                            ctr2++;
                        }
                        //
                        //  Else - nonspace character only, so don't write
                        //         anything.
                        //
                    }
                }
            }

            break;
        }
    }

    //
    //  Return the number of wide characters written.
    //
    return (ctr2);
}


////////////////////////////////////////////////////////////////////////////
//
//  MapKanaWidth
//
//  Stores the result of the Kana, Width, and/or Casing mappings for the
//  given string in the destination buffer, and returns the number of wide
//  characters written to the buffer.
//
//  07-26-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int MapKanaWidth(
    PLOC_HASH pHashN,
    DWORD dwFlags,
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest)
{
    int ctr;                 // loop counter
    PCASE pCase;             // ptr to case table (if case flag is set)


    //
    //  See if lower or upper case flags are present.
    //
    if (dwFlags & LCMAP_LOWERCASE)
    {
        pCase = (dwFlags & LCMAP_LINGUISTIC_CASING)
                    ? pHashN->pLowerLinguist
                    : pHashN->pLowerCase;
    }
    else if (dwFlags & LCMAP_UPPERCASE)
    {
        pCase = (dwFlags & LCMAP_LINGUISTIC_CASING)
                    ? pHashN->pUpperLinguist
                    : pHashN->pUpperCase;
    }
    else
    {
        pCase = NULL;
    }

    //
    //  Remove lower, upper, and linguistic casing flags.
    //
    dwFlags &= ~(LCMAP_LOWERCASE | LCMAP_UPPERCASE | LCMAP_LINGUISTIC_CASING);

    //
    //  Map the string based on the given flags.
    //
    switch (dwFlags)
    {
        case ( LCMAP_HIRAGANA ) :
        case ( LCMAP_KATAKANA ) :
        {
            //
            //  If the destination value is zero, then just return the
            //  length of the source string.  Do NOT touch pDest.
            //
            if (cchDest == 0)
            {
                return (cchSrc);
            }

            //
            //  If cchSrc is greater than cchDest, then the destination
            //  buffer is too small to hold the string.  Return an error.
            //
            if (cchSrc > cchDest)
            {
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                return (0);
            }

            if (dwFlags == LCMAP_HIRAGANA)
            {
                //
                //  Map all Katakana full width to Hiragana full width.
                //  Katakana half width will remain Katakana half width.
                //
                if (pCase)
                {
                    for (ctr = 0; ctr < cchSrc; ctr++)
                    {
                        pDest[ctr] = GET_KANA(pTblPtrs->pHiragana, pSrc[ctr]);

                        pDest[ctr] = GET_LOWER_UPPER_CASE(pCase, pDest[ctr]);
                    }
                }
                else
                {
                    for (ctr = 0; ctr < cchSrc; ctr++)
                    {
                        pDest[ctr] = GET_KANA(pTblPtrs->pHiragana, pSrc[ctr]);
                    }
                }
            }
            else
            {
                //
                //  Map all Hiragana full width to Katakana full width.
                //  Hiragana half width does not exist.
                //
                if (pCase)
                {
                    for (ctr = 0; ctr < cchSrc; ctr++)
                    {
                        pDest[ctr] = GET_KANA(pTblPtrs->pKatakana, pSrc[ctr]);

                        pDest[ctr] = GET_LOWER_UPPER_CASE(pCase, pDest[ctr]);
                    }
                }
                else
                {
                    for (ctr = 0; ctr < cchSrc; ctr++)
                    {
                        pDest[ctr] = GET_KANA(pTblPtrs->pKatakana, pSrc[ctr]);
                    }
                }
            }

            //
            //  Return the number of characters mapped.
            //
            return (cchSrc);

            break;
        }
        case ( LCMAP_HALFWIDTH ) :
        {
            //
            //  Map all chars to half width.
            //
            return (MapHalfKana( pSrc,
                                 cchSrc,
                                 pDest,
                                 cchDest,
                                 NULL,
                                 pCase ));

            break;
        }
        case ( LCMAP_FULLWIDTH ) :
        {
            //
            //  Map all chars to full width.
            //
            return (MapFullKana( pSrc,
                                 cchSrc,
                                 pDest,
                                 cchDest,
                                 NULL,
                                 pCase ));

            break;
        }
        case ( LCMAP_HIRAGANA | LCMAP_HALFWIDTH ) :
        {
            //
            //  This combination of flags is strange, because
            //  Hiragana is only full width.  So, the Hiragana flag
            //  is the most important.  Full width Katakana will be
            //  mapped to full width Hiragana, not half width
            //  Katakana.
            //
            //  Map to Hiragana, then Half Width.
            //
            return (MapHalfKana( pSrc,
                                 cchSrc,
                                 pDest,
                                 cchDest,
                                 pTblPtrs->pHiragana,
                                 pCase ));

            break;
        }
        case ( LCMAP_HIRAGANA | LCMAP_FULLWIDTH ) :
        {
            //
            //  Since Hiragana is only FULL width, the mapping to
            //  width must be done first to convert all half width
            //  Katakana to full width Katakana before trying to
            //  map to Hiragana.
            //
            //  Map to Full Width, then Hiragana.
            //
            return (MapFullKana( pSrc,
                                 cchSrc,
                                 pDest,
                                 cchDest,
                                 pTblPtrs->pHiragana,
                                 pCase ));

            break;
        }
        case ( LCMAP_KATAKANA | LCMAP_HALFWIDTH ) :
        {
            //
            //  Since Hiragana is only FULL width, the mapping to
            //  Katakana must be done first to convert all Hiragana
            //  to Katakana before trying to map to half width.
            //
            //  Map to Katakana, then Half Width.
            //
            return (MapHalfKana( pSrc,
                                 cchSrc,
                                 pDest,
                                 cchDest,
                                 pTblPtrs->pKatakana,
                                 pCase ));

            break;
        }
        case ( LCMAP_KATAKANA | LCMAP_FULLWIDTH ) :
        {
            //
            //  Since Hiragana is only FULL width, it doesn't matter
            //  which way the mapping is done for this combination.
            //
            //  Map to Full Width, then Katakana.
            //
            return (MapFullKana( pSrc,
                                 cchSrc,
                                 pDest,
                                 cchDest,
                                 pTblPtrs->pKatakana,
                                 pCase ));

            break;
        }
        default :
        {
            //
            //  Return error.
            //
            return (0);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  MapHalfKana
//
//  Stores the result of the half width and Kana mapping for the given string
//  in the destination buffer, and returns the number of wide characters
//  written to the buffer.
//
//  This first converts the precomposed characters to their composite forms,
//  and then maps all characters to their half width forms.  This handles the
//  case where the full width precomposed form should map to TWO half width
//  code points (composite form).  The half width precomposed forms do not
//  exist in Unicode.
//
//  11-04-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int MapHalfKana(
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest,
    PKANA pKana,
    PCASE pCase)
{
    int Count;                    // count of characters written
    int ctr = 0;                  // loop counter
    int ct;                       // loop counter
    LPWSTR pBuf;                  // ptr to destination buffer
    LPWSTR pEndBuf;               // ptr to end of destination buffer
    LPWSTR pPosDest;              // ptr to position in destination buffer
    LPWSTR *ppIncr;               // points to ptr to increment
    WCHAR pTmp[MAX_COMPOSITE];    // ptr to temporary buffer
    LPWSTR pEndTmp;               // ptr to end of temporary buffer


    //
    //  Initialize the destination pointers.
    //
    pEndTmp = pTmp + MAX_COMPOSITE;
    if (cchDest == 0)
    {
        //
        //  Do not touch the pDest pointer.  Use the pTmp buffer and
        //  initialize the end pointer.
        //
        pBuf = pTmp;
        pEndBuf = pEndTmp;

        //
        //  This is a bogus pointer and will never be touched.  It just
        //  increments this pointer into oblivion.
        //
        pDest = pBuf;
        ppIncr = &pDest;
    }
    else
    {
        //
        //  Initialize the pointers.  Use the pDest buffer.
        //
        pBuf = pDest;
        pEndBuf = pBuf + cchDest;
        ppIncr = &pBuf;
    }

    //
    //  Search through the source string.  Convert all precomposed
    //  forms to their composite form before converting to half width.
    //
    while ((ctr < cchSrc) && (pBuf < pEndBuf))
    {
        //
        //  Get the character to convert.  If we need to convert to
        //  kana, do it.
        //
        if (pKana)
        {
            *pTmp = GET_KANA(pKana, pSrc[ctr]);
        }
        else
        {
            *pTmp = pSrc[ctr];
        }

        //
        //  Convert to its composite form (if exists).
        //
        //  NOTE: Must use the tmp buffer in case the destination buffer
        //        isn't large enough to hold the composite form.
        //
        Count = InsertCompositeForm(pTmp, pEndTmp);

        //
        //  Convert to half width (if exists) and case (if appropriate).
        //
        pPosDest = pTmp;
        if (pCase)
        {
            for (ct = Count; ct > 0; ct--)
            {
                *pPosDest = GET_HALF_WIDTH(pTblPtrs->pHalfWidth, *pPosDest);

                *pPosDest = GET_LOWER_UPPER_CASE(pCase, *pPosDest);

                pPosDest++;
            }
        }
        else
        {
            for (ct = Count; ct > 0; ct--)
            {
                *pPosDest = GET_HALF_WIDTH(pTblPtrs->pHalfWidth, *pPosDest);
                pPosDest++;
            }
        }

        //
        //  Convert back to its precomposed form (if exists).
        //
        if (Count > 1)
        {
            //
            //  Get the precomposed form.
            //
            //  ct is the number of code points used from the
            //  composite form.
            //
            ct = InsertPreComposedForm(pTmp, pPosDest, pBuf);
            if (ct > 1)
            {
                //
                //  Precomposed form was found.  Need to make sure all
                //  of the composite chars were used.
                //
                if (ct == Count)
                {
                    //
                    //  All composite chars were used.  Increment by 1.
                    //
                    (*ppIncr)++;
                }
                else
                {
                    //
                    //  Not all composite chars were used.  Need to copy
                    //  the rest of the composite chars from the tmp buffer
                    //  to the destination buffer.
                    //
                    (*ppIncr)++;
                    Count -= ct;
                    if (pBuf + Count > pEndBuf)
                    {
                        break;
                    }
                    RtlMoveMemory(pBuf, pTmp + ct, Count * sizeof(WCHAR));
                    (*ppIncr) += Count;
                }
            }
            else
            {
                //
                //  Precomposed form was NOT found.  Need to copy the
                //  composite form from the tmp buffer to the destination
                //  buffer.
                //
                if (pBuf + Count > pEndBuf)
                {
                    break;
                }
                RtlMoveMemory(pBuf, pTmp, Count * sizeof(WCHAR));
                (*ppIncr) += Count;
            }
        }
        else
        {
            //
            //  Only one character (no composite form), so just copy it
            //  from the tmp buffer to the destination buffer.
            //
            *pBuf = *pTmp;
            (*ppIncr)++;
        }

        ctr++;
    }

    //
    //  Return the appropriate number of characters.
    //
    if (cchDest == 0)
    {
        //
        //  Return the number of characters written to the buffer.
        //
        return ((int)((*ppIncr) - pTmp));
    }
    else
    {
        //
        //  Make sure the given buffer was large enough to hold the
        //  mapping.
        //
        if (ctr < cchSrc)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return (0);
        }

        //
        //  Return the number of characters written to the buffer.
        //
        return ((int)((*ppIncr) - pDest));
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  MapFullKana
//
//  Stores the result of the full width and Kana mapping for the given string
//  in the destination buffer, and returns the number of wide characters
//  written to the buffer.
//
//  This first converts the characters to full width, and then maps all
//  composite characters to their precomposed forms.  This handles the case
//  where the half width composite form (TWO code points) should map to a
//  full width precomposed form (ONE full width code point).  The half
//  width precomposed forms do not exist in Unicode and we need the full
//  width precomposed forms to round trip with the TWO half width code
//  points.
//
//  11-04-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int MapFullKana(
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest,
    PKANA pKana,
    PCASE pCase)
{
    int Count;                    // count of characters
    LPWSTR pPosSrc;               // ptr to position in source buffer
    LPWSTR pEndSrc;               // ptr to end of source buffer
    LPWSTR pBuf;                  // ptr to destination buffer
    LPWSTR pEndBuf;               // ptr to end of destination buffer
    LPWSTR *ppIncr;               // points to ptr to increment
    WCHAR pTmp[MAX_COMPOSITE];    // ptr to temporary buffer


    //
    //  Initialize source string pointers.
    //
    pPosSrc = (LPWSTR)pSrc;
    pEndSrc = pPosSrc + cchSrc;

    //
    //  Initialize the destination pointers.
    //
    if (cchDest == 0)
    {
        //
        //  Do not touch the pDest pointer.  Use the pTmp buffer and
        //  initialize the end pointer.
        //
        pBuf = pTmp;
        pEndBuf = pTmp + MAX_COMPOSITE;

        //
        //  This is a bogus pointer and will never be touched.  It just
        //  increments this pointer into oblivion.
        //
        pDest = pBuf;
        ppIncr = &pDest;
    }
    else
    {
        //
        //  Initialize the pointers.  Use the pDest buffer.
        //
        pBuf = pDest;
        pEndBuf = pBuf + cchDest;
        ppIncr = &pBuf;
    }

    //
    //  Search through the source string.  Convert all composite
    //  forms to their precomposed form before converting to full width.
    //
    while ((pPosSrc < pEndSrc) && (pBuf < pEndBuf))
    {
        //
        //  Convert a composite form to its full width precomposed
        //  form (if exists).  Also, convert to case if necessary.
        //
        Count = InsertFullWidthPreComposedForm( pPosSrc,
                                                pEndSrc,
                                                pBuf,
                                                pCase );
        pPosSrc += Count;

        //
        //  Convert to kana if necessary.
        //
        if (pKana)
        {
            *pBuf = GET_KANA(pKana, *pBuf);
        }

        //
        //  Increment the destination pointer.
        //
        (*ppIncr)++;
    }

    //
    //  Return the appropriate number of characters.
    //
    if (cchDest == 0)
    {
        //
        //  Return the number of characters written to the buffer.
        //
        return ((int)((*ppIncr) - pTmp));
    }
    else
    {
        //
        //  Make sure the given buffer was large enough to hold the
        //  mapping.
        //
        if (pPosSrc < pEndSrc)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return (0);
        }

        //
        //  Return the number of characters written to the buffer.
        //
        return ((int)((*ppIncr) - pDest));
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  MapTraditionalSimplified
//
//  Stores the appropriate Traditional or Simplified Chinese values in the
//  destination buffer, and returns the number of wide characters
//  written to the buffer.
//
//  05-07-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int MapTraditionalSimplified(
    PLOC_HASH pHashN,
    DWORD dwFlags,
    LPCWSTR pSrc,
    int cchSrc,
    LPWSTR pDest,
    int cchDest,
    PCHINESE pChinese)
{
    int ctr;                 // loop counter
    PCASE pCase;             // ptr to case table (if case flag is set)


    //
    //  If the destination value is zero, then just return the
    //  length of the source string.  Do NOT touch pDest.
    //
    if (cchDest == 0)
    {
        return (cchSrc);
    }

    //
    //  If cchSrc is greater than cchDest, then the destination buffer
    //  is too small to hold the new string.  Return an error.
    //
    if (cchSrc > cchDest)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  See if lower or upper case flags are present.
    //
    if (dwFlags & LCMAP_LOWERCASE)
    {
        pCase = (dwFlags & LCMAP_LINGUISTIC_CASING)
                    ? pHashN->pLowerLinguist
                    : pHashN->pLowerCase;
    }
    else if (dwFlags & LCMAP_UPPERCASE)
    {
        pCase = (dwFlags & LCMAP_LINGUISTIC_CASING)
                    ? pHashN->pUpperLinguist
                    : pHashN->pUpperCase;
    }
    else
    {
        pCase = NULL;
    }

    //
    //  Map to Traditional/Simplified and store it in the destination string.
    //  Also map the case, if appropriate.
    //
    if (pCase)
    {
        for (ctr = 0; ctr < cchSrc; ctr++)
        {
            pDest[ctr] = GET_CHINESE(pChinese, pSrc[ctr]);

            pDest[ctr] = GET_LOWER_UPPER_CASE(pCase, pDest[ctr]);
        }
    }
    else
    {
        for (ctr = 0; ctr < cchSrc; ctr++)
        {
            pDest[ctr] = GET_CHINESE(pChinese, pSrc[ctr]);
        }
    }

    //
    //  Return the number of wide characters written.
    //
    return (ctr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\mbcs.c ===
/*++

Copyright (c) 1991-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    mbcs.c

Abstract:

    This file contains functions that convert multibyte character strings
    to wide character strings, convert wide character strings to multibyte
    character strings, convert a multibyte character string from one code
    page to a multibyte character string of another code page, and get the
    DBCS leadbyte ranges for a given code page.

    APIs found in this file:
      IsValidCodePage
      GetACP
      GetOEMCP
      GetCPInfo
      GetCPInfoExW
      IsDBCSLeadByte
      IsDBCSLeadByteEx
      MultiByteToWideChar
      WideCharToMultiByte

Revision History:

    05-31-91    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nls.h"




//
//  Forward Declarations.
//

int
GetWCCompSB(
    PMB_TABLE pMBTbl,
    LPBYTE pMBStr,
    LPWSTR pWCStr,
    LPWSTR pEndWCStr);

int
GetWCCompMB(
    PCP_HASH pHashN,
    PMB_TABLE pMBTbl,
    LPBYTE pMBStr,
    LPBYTE pEndMBStr,
    LPWSTR pWCStr,
    LPWSTR pEndWCStr,
    int *pmbIncr);

int
GetWCCompSBErr(
    PCP_HASH pHashN,
    PMB_TABLE pMBTbl,
    LPBYTE pMBStr,
    LPWSTR pWCStr,
    LPWSTR pEndWCStr);

int
GetWCCompMBErr(
    PCP_HASH pHashN,
    PMB_TABLE pMBTbl,
    LPBYTE pMBStr,
    LPBYTE pEndMBStr,
    LPWSTR pWCStr,
    LPWSTR pEndWCStr,
    int *pmbIncr);

int
GetMBNoDefault(
    PCP_HASH pHashN,
    LPWSTR pWCStr,
    LPWSTR pEndWCStr,
    LPBYTE pMBStr,
    int cbMultiByte,
    DWORD dwFlags);

int
GetMBDefault(
    PCP_HASH pHashN,
    LPWSTR pWCStr,
    LPWSTR pEndWCStr,
    LPBYTE pMBStr,
    int cbMultiByte,
    WORD wDefault,
    LPBOOL pUsedDef,
    DWORD dwFlags);

int
GetMBDefaultComp(
    PCP_HASH pHashN,
    LPWSTR pWCStr,
    LPWSTR pEndWCStr,
    LPBYTE pMBStr,
    int cbMultiByte,
    WORD wDefault,
    LPBOOL pUsedDef,
    DWORD dwFlags);

int
GetMBCompSB(
    PCP_HASH pHashN,
    DWORD dwFlags,
    LPWSTR pWCStr,
    LPBYTE pMBStr,
    int mbCount,
    WORD wDefault,
    LPBOOL pUsedDef);

int
GetMBCompMB(
    PCP_HASH pHashN,
    DWORD dwFlags,
    LPWSTR pWCStr,
    LPBYTE pMBStr,
    int mbCount,
    WORD wDefault,
    LPBOOL pUsedDef,
    BOOL *fError,
    BOOL fOnlyOne);

UINT
GetMacCodePage(void);





//-------------------------------------------------------------------------//
//                           INTERNAL MACROS                               //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  CHECK_DBCS_LEAD_BYTE
//
//  Returns the offset to the DBCS table for the given leadbyte character.
//  If the given character is not a leadbyte, then it returns zero (table
//  value).
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define CHECK_DBCS_LEAD_BYTE(pDBCSOff, Ch)                                 \
    (pDBCSOff ? ((WORD)(pDBCSOff[Ch])) : ((WORD)0))


////////////////////////////////////////////////////////////////////////////
//
//  CHECK_ERROR_WC_SINGLE
//
//  Checks to see if the default character was used due to an invalid
//  character.  Sets last error and returns 0 characters written if an
//  invalid character was used.
//
//  NOTE: This macro may return if an error is encountered.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define CHECK_ERROR_WC_SINGLE( pHashN,                                     \
                               wch,                                        \
                               Ch )                                        \
{                                                                          \
    if ( ( (wch == pHashN->pCPInfo->wUniDefaultChar) &&                    \
           (Ch != pHashN->pCPInfo->wTransUniDefaultChar) ) ||              \
         ( (wch >= PRIVATE_USE_BEGIN) && (wch <= PRIVATE_USE_END) ) )      \
    {                                                                      \
        SetLastError(ERROR_NO_UNICODE_TRANSLATION);                        \
        return (0);                                                        \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  CHECK_ERROR_WC_MULTI
//
//  Checks to see if the default character was used due to an invalid
//  character.  Sets last error and returns 0 characters written if an
//  invalid character was used.
//
//  NOTE: This macro may return if an error is encountered.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define CHECK_ERROR_WC_MULTI( pHashN,                                      \
                              wch,                                         \
                              lead,                                        \
                              trail )                                      \
{                                                                          \
    if ((wch == pHashN->pCPInfo->wUniDefaultChar) &&                       \
        (MAKEWORD(trail, lead) != pHashN->pCPInfo->wTransUniDefaultChar))  \
    {                                                                      \
        SetLastError(ERROR_NO_UNICODE_TRANSLATION);                        \
        return (0);                                                        \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  CHECK_ERROR_WC_MULTI_SPECIAL
//
//  Checks to see if the default character was used due to an invalid
//  character.  Sets it to 0xffff if invalid.
//
//  DEFINED AS A MACRO.
//
//  08-21-95    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define CHECK_ERROR_WC_MULTI_SPECIAL( pHashN,                              \
                                      pWCStr,                              \
                                      lead,                                \
                                      trail )                              \
{                                                                          \
    if ((*pWCStr == pHashN->pCPInfo->wUniDefaultChar) &&                   \
        (MAKEWORD(trail, lead) != pHashN->pCPInfo->wTransUniDefaultChar))  \
    {                                                                      \
        *pWCStr = 0xffff;                                                  \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  GET_WC_SINGLE
//
//  Fills in pWCStr with the wide character(s) for the corresponding single
//  byte character from the appropriate translation table.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_WC_SINGLE( pMBTbl,                                             \
                       pMBStr,                                             \
                       pWCStr )                                            \
{                                                                          \
    *pWCStr = pMBTbl[*pMBStr];                                             \
}


////////////////////////////////////////////////////////////////////////////
//
//  GET_WC_SINGLE_SPECIAL
//
//  Fills in pWCStr with the wide character(s) for the corresponding single
//  byte character from the appropriate translation table.  Also checks for
//  invalid characters - if invalid, it fills in 0xffff instead.
//
//  DEFINED AS A MACRO.
//
//  08-21-95    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_WC_SINGLE_SPECIAL( pHashN,                                     \
                               pMBTbl,                                     \
                               pMBStr,                                     \
                               pWCStr )                                    \
{                                                                          \
    *pWCStr = pMBTbl[*pMBStr];                                             \
                                                                           \
    if ( ( (*pWCStr == pHashN->pCPInfo->wUniDefaultChar) &&                \
           (*pMBStr != pHashN->pCPInfo->wTransUniDefaultChar) ) ||         \
         ( (*pWCStr >= PRIVATE_USE_BEGIN) &&                               \
           (*pWCStr <= PRIVATE_USE_END) ) )                                \
    {                                                                      \
        *pWCStr = 0xffff;                                                  \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  GET_WC_MULTI
//
//  Fills in pWCStr with the wide character(s) for the corresponding multibyte
//  character from the appropriate translation table.  The number of bytes
//  used from the pMBStr buffer (single byte or double byte) is stored in
//  the mbIncr parameter.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_WC_MULTI( pHashN,                                              \
                      pMBTbl,                                              \
                      pMBStr,                                              \
                      pEndMBStr,                                           \
                      pWCStr,                                              \
                      pEndWCStr,                                           \
                      mbIncr )                                             \
{                                                                          \
    WORD Offset;                  /* offset to DBCS table for range */     \
                                                                           \
                                                                           \
    if (Offset = CHECK_DBCS_LEAD_BYTE(pHashN->pDBCSOffsets, *pMBStr))      \
    {                                                                      \
        /*                                                                 \
         *  DBCS Lead Byte.  Make sure there is a trail byte with the      \
         *  lead byte.                                                     \
         */                                                                \
        if (pMBStr + 1 == pEndMBStr)                                       \
        {                                                                  \
            /*                                                             \
             *  There is no trail byte with the lead byte.  The lead byte  \
             *  is the LAST character in the string.  Translate to NULL.   \
             */                                                            \
            *pWCStr = (WCHAR)0;                                            \
            mbIncr = 1;                                                    \
        }                                                                  \
        else if (*(pMBStr + 1) == 0)                                       \
        {                                                                  \
            /*                                                             \
             *  There is no trail byte with the lead byte.  The lead byte  \
             *  is followed by a NULL.  Translate to NULL.                 \
             *                                                             \
             *  Increment by 2 so that the null is not counted twice.      \
             */                                                            \
            *pWCStr = (WCHAR)0;                                            \
            mbIncr = 2;                                                    \
        }                                                                  \
        else                                                               \
        {                                                                  \
            /*                                                             \
             *  Fill in the wide character translation from the double     \
             *  byte character table.                                      \
             */                                                            \
            *pWCStr = (pHashN->pDBCSOffsets + Offset)[*(pMBStr + 1)];      \
            mbIncr = 2;                                                    \
        }                                                                  \
    }                                                                      \
    else                                                                   \
    {                                                                      \
        /*                                                                 \
         *  Not DBCS Lead Byte.  Fill in the wide character translation    \
         *  from the single byte character table.                          \
         */                                                                \
        *pWCStr = pMBTbl[*pMBStr];                                         \
        mbIncr = 1;                                                        \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  GET_WC_MULTI_ERR
//
//  Fills in pWCStr with the wide character(s) for the corresponding multibyte
//  character from the appropriate translation table.  The number of bytes
//  used from the pMBStr buffer (single byte or double byte) is stored in
//  the mbIncr parameter.
//
//  Once the character has been translated, it checks to be sure the
//  character was valid.  If not, it sets last error and return 0 characters
//  written.
//
//  NOTE: This macro may return if an error is encountered.
//
//  DEFINED AS A MACRO.
//
//  09-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_WC_MULTI_ERR( pHashN,                                          \
                          pMBTbl,                                          \
                          pMBStr,                                          \
                          pEndMBStr,                                       \
                          pWCStr,                                          \
                          pEndWCStr,                                       \
                          mbIncr )                                         \
{                                                                          \
    WORD Offset;                  /* offset to DBCS table for range */     \
                                                                           \
                                                                           \
    if (Offset = CHECK_DBCS_LEAD_BYTE(pHashN->pDBCSOffsets, *pMBStr))      \
    {                                                                      \
        /*                                                                 \
         *  DBCS Lead Byte.  Make sure there is a trail byte with the      \
         *  lead byte.                                                     \
         */                                                                \
        if ((pMBStr + 1 == pEndMBStr) || (*(pMBStr + 1) == 0))             \
        {                                                                  \
            /*                                                             \
             *  There is no trail byte with the lead byte.  Return error.  \
             */                                                            \
            SetLastError(ERROR_NO_UNICODE_TRANSLATION);                    \
            return (0);                                                    \
        }                                                                  \
                                                                           \
        /*                                                                 \
         *  Fill in the wide character translation from the double         \
         *  byte character table.                                          \
         */                                                                \
        *pWCStr = (pHashN->pDBCSOffsets + Offset)[*(pMBStr + 1)];          \
        mbIncr = 2;                                                        \
                                                                           \
        /*                                                                 \
         *  Make sure an invalid character was not translated to           \
         *  the default char.  Return an error if invalid.                 \
         */                                                                \
        CHECK_ERROR_WC_MULTI( pHashN,                                      \
                              *pWCStr,                                     \
                              *pMBStr,                                     \
                              *(pMBStr + 1) );                             \
    }                                                                      \
    else                                                                   \
    {                                                                      \
        /*                                                                 \
         *  Not DBCS Lead Byte.  Fill in the wide character translation    \
         *  from the single byte character table.                          \
         */                                                                \
        *pWCStr = pMBTbl[*pMBStr];                                         \
        mbIncr = 1;                                                        \
                                                                           \
        /*                                                                 \
         *  Make sure an invalid character was not translated to           \
         *  the default char.  Return an error if invalid.                 \
         */                                                                \
        CHECK_ERROR_WC_SINGLE( pHashN,                                     \
                               *pWCStr,                                    \
                               *pMBStr );                                  \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  GET_WC_MULTI_ERR_SPECIAL
//
//  Fills in pWCStr with the wide character(s) for the corresponding multibyte
//  character from the appropriate translation table.  The number of bytes
//  used from the pMBStr buffer (single byte or double byte) is stored in
//  the mbIncr parameter.
//
//  Once the character has been translated, it checks to be sure the
//  character was valid.  If not, it fills in 0xffff.
//
//  DEFINED AS A MACRO.
//
//  08-21-95    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_WC_MULTI_ERR_SPECIAL( pHashN,                                  \
                                  pMBTbl,                                  \
                                  pMBStr,                                  \
                                  pEndMBStr,                               \
                                  pWCStr,                                  \
                                  pEndWCStr,                               \
                                  mbIncr )                                 \
{                                                                          \
    WORD Offset;                  /* offset to DBCS table for range */     \
                                                                           \
                                                                           \
    if (Offset = CHECK_DBCS_LEAD_BYTE(pHashN->pDBCSOffsets, *pMBStr))      \
    {                                                                      \
        /*                                                                 \
         *  DBCS Lead Byte.  Make sure there is a trail byte with the      \
         *  lead byte.                                                     \
         */                                                                \
        if ((pMBStr + 1 == pEndMBStr) || (*(pMBStr + 1) == 0))             \
        {                                                                  \
            /*                                                             \
             *  There is no trail byte with the lead byte.  The lead byte  \
             *  is the LAST character in the string.  Translate to 0xffff. \
             */                                                            \
            *pWCStr = (WCHAR)0xffff;                                       \
            mbIncr = 1;                                                    \
        }                                                                  \
        else                                                               \
        {                                                                  \
            /*                                                             \
             *  Fill in the wide character translation from the double     \
             *  byte character table.                                      \
             */                                                            \
            *pWCStr = (pHashN->pDBCSOffsets + Offset)[*(pMBStr + 1)];      \
            mbIncr = 2;                                                    \
                                                                           \
            /*                                                             \
             *  Make sure an invalid character was not translated to       \
             *  the default char.  Translate to 0xffff if invalid.         \
             */                                                            \
            CHECK_ERROR_WC_MULTI_SPECIAL( pHashN,                          \
                                          pWCStr,                          \
                                          *pMBStr,                         \
                                          *(pMBStr + 1) );                 \
        }                                                                  \
    }                                                                      \
    else                                                                   \
    {                                                                      \
        /*                                                                 \
         *  Not DBCS Lead Byte.  Fill in the wide character translation    \
         *  from the single byte character table.                          \
         *  Make sure an invalid character was not translated to           \
         *  the default char.  Return an error if invalid.                 \
         */                                                                \
        GET_WC_SINGLE_SPECIAL( pHashN,                                     \
                               pMBTbl,                                     \
                               pMBStr,                                     \
                               pWCStr );                                   \
        mbIncr = 1;                                                        \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  COPY_MB_CHAR
//
//  Copies a multibyte character to the given string buffer.  If the
//  high byte of the multibyte word is zero, then it is a single byte
//  character and the number of characters written (returned) is 1.
//  Otherwise, it is a double byte character and the number of characters
//  written (returned) is 2.
//
//  NumByte will be 0 if the buffer is too small for the translation.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define COPY_MB_CHAR( mbChar,                                              \
                      pMBStr,                                              \
                      NumByte,                                             \
                      fOnlyOne )                                           \
{                                                                          \
    if (HIBYTE(mbChar))                                                    \
    {                                                                      \
        /*                                                                 \
         *  Make sure there is enough room in the buffer for both bytes.   \
         */                                                                \
        if (fOnlyOne)                                                      \
        {                                                                  \
            NumByte = 0;                                                   \
        }                                                                  \
        else                                                               \
        {                                                                  \
            /*                                                             \
             *  High Byte is NOT zero, so it's a DOUBLE byte char.         \
             *  Return 2 characters written.                               \
             */                                                            \
            *pMBStr = HIBYTE(mbChar);                                      \
            *(pMBStr + 1) = LOBYTE(mbChar);                                \
            NumByte = 2;                                                   \
        }                                                                  \
    }                                                                      \
    else                                                                   \
    {                                                                      \
        /*                                                                 \
         *  High Byte IS zero, so it's a SINGLE byte char.                 \
         *  Return 1 character written.                                    \
         */                                                                \
        *pMBStr = LOBYTE(mbChar);                                          \
        NumByte = 1;                                                       \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  GET_SB
//
//  Fills in pMBStr with the single byte character for the corresponding
//  wide character from the appropriate translation table.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_SB( pWC,                                                       \
                wChar,                                                     \
                pMBStr )                                                   \
{                                                                          \
    *pMBStr = ((BYTE *)(pWC))[wChar];                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  GET_MB
//
//  Fills in pMBStr with the multi byte character for the corresponding
//  wide character from the appropriate translation table.
//
//  mbCount will be 0 if the buffer is too small for the translation.
//
//    Broken Down Version:
//    --------------------
//        mbChar = ((WORD *)(pHashN->pWC))[wChar];
//        COPY_MB_CHAR(mbChar, pMBStr, mbCount);
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_MB( pWC,                                                       \
                wChar,                                                     \
                pMBStr,                                                    \
                mbCount,                                                   \
                fOnlyOne )                                                 \
{                                                                          \
    COPY_MB_CHAR( ((WORD *)(pWC))[wChar],                                  \
                  pMBStr,                                                  \
                  mbCount,                                                 \
                  fOnlyOne );                                              \
}


////////////////////////////////////////////////////////////////////////////
//
//  ELIMINATE_BEST_FIT_SB
//
//  Checks to see if a single byte Best Fit character was used.  If so,
//  it replaces it with a single byte default character.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define ELIMINATE_BEST_FIT_SB( pHashN,                                     \
                               wChar,                                      \
                               pMBStr )                                    \
{                                                                          \
    if ((pHashN->pMBTbl)[*pMBStr] != wChar)                                \
    {                                                                      \
        *pMBStr = LOBYTE(pHashN->pCPInfo->wDefaultChar);                   \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  ELIMINATE_BEST_FIT_MB
//
//  Checks to see if a multi byte Best Fit character was used.  If so,
//  it replaces it with a multi byte default character.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define ELIMINATE_BEST_FIT_MB( pHashN,                                     \
                               wChar,                                      \
                               pMBStr,                                     \
                               mbCount,                                    \
                               fOnlyOne )                                  \
{                                                                          \
    WORD Offset;                                                           \
    WORD wDefault;                                                         \
                                                                           \
    if (((mbCount == 1) && ((pHashN->pMBTbl)[*pMBStr] != wChar)) ||        \
        ((mbCount == 2) &&                                                 \
         (Offset = CHECK_DBCS_LEAD_BYTE(pHashN->pDBCSOffsets, *pMBStr)) && \
         (((pHashN->pDBCSOffsets + Offset)[*(pMBStr + 1)]) != wChar)))     \
    {                                                                      \
        wDefault = pHashN->pCPInfo->wDefaultChar;                          \
        if (HIBYTE(wDefault))                                              \
        {                                                                  \
            if (fOnlyOne)                                                  \
            {                                                              \
                mbCount = 0;                                               \
            }                                                              \
            else                                                           \
            {                                                              \
                *pMBStr = HIBYTE(wDefault);                                \
                *(pMBStr + 1) = LOBYTE(wDefault);                          \
                mbCount = 2;                                               \
            }                                                              \
        }                                                                  \
        else                                                               \
        {                                                                  \
            *pMBStr = LOBYTE(wDefault);                                    \
            mbCount = 1;                                                   \
        }                                                                  \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  GET_DEFAULT_WORD
//
//  Takes a pointer to a character string (either one or two characters),
//  and converts it to a WORD value.  If the character is not DBCS, then it
//  zero extends the high byte.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_DEFAULT_WORD(pOff, pDefault)                                   \
    (CHECK_DBCS_LEAD_BYTE(pOff, *pDefault)                                 \
         ? MAKEWORD(*(pDefault + 1), *pDefault)                            \
         : MAKEWORD(*pDefault, 0))


////////////////////////////////////////////////////////////////////////////
//
//  DEFAULT_CHAR_CHECK_SB
//
//  Checks to see if the default character is used.  If it is, it sets
//  pUsedDef to TRUE (if non-null).  If the user specified a default, then
//  the user's default character is used.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define DEFAULT_CHAR_CHECK_SB( pHashN,                                     \
                               wch,                                        \
                               pMBStr,                                     \
                               wDefChar,                                   \
                               pUsedDef )                                  \
{                                                                          \
    WORD wSysDefChar = pHashN->pCPInfo->wDefaultChar;                      \
                                                                           \
                                                                           \
    /*                                                                     \
     *  Check for default character being used.                            \
     */                                                                    \
    if ((*pMBStr == (BYTE)wSysDefChar) &&                                  \
        (wch != pHashN->pCPInfo->wTransDefaultChar))                       \
    {                                                                      \
        /*                                                                 \
         *  Default was used.  Set the pUsedDef parameter to TRUE.         \
         */                                                                \
        *pUsedDef = TRUE;                                                  \
                                                                           \
        /*                                                                 \
         *  If the user specified a different default character than       \
         *  the system default, use that character instead.                \
         */                                                                \
        if (wSysDefChar != wDefChar)                                       \
        {                                                                  \
            *pMBStr = LOBYTE(wDefChar);                                    \
        }                                                                  \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  DEFAULT_CHAR_CHECK_MB
//
//  Checks to see if the default character is used.  If it is, it sets
//  pUsedDef to TRUE (if non-null).  If the user specified a default, then
//  the user's default character is used.  The number of bytes written to
//  the buffer is returned.
//
//  NumByte will be -1 if the buffer is too small for the translation.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define DEFAULT_CHAR_CHECK_MB( pHashN,                                     \
                               wch,                                        \
                               pMBStr,                                     \
                               wDefChar,                                   \
                               pUsedDef,                                   \
                               NumByte,                                    \
                               fOnlyOne )                                  \
{                                                                          \
    WORD wSysDefChar = pHashN->pCPInfo->wDefaultChar;                      \
                                                                           \
                                                                           \
    /*                                                                     \
     *  Set NumByte to zero for return (zero bytes written).               \
     */                                                                    \
    NumByte = 0;                                                           \
                                                                           \
    /*                                                                     \
     *  Check for default character being used.                            \
     */                                                                    \
    if ((*pMBStr == (BYTE)wSysDefChar) &&                                  \
        (wch != pHashN->pCPInfo->wTransDefaultChar))                       \
    {                                                                      \
        /*                                                                 \
         *  Default was used.  Set the pUsedDef parameter to TRUE.         \
         */                                                                \
        *pUsedDef = TRUE;                                                  \
                                                                           \
        /*                                                                 \
         *  If the user specified a different default character than       \
         *  the system default, use that character instead.                \
         */                                                                \
        if (wSysDefChar != wDefChar)                                       \
        {                                                                  \
            COPY_MB_CHAR( wDefChar,                                        \
                          pMBStr,                                          \
                          NumByte,                                         \
                          fOnlyOne );                                      \
            if (NumByte == 0)                                              \
            {                                                              \
                NumByte = -1;                                              \
            }                                                              \
        }                                                                  \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  GET_WC_TRANSLATION_SB
//
//  Gets the 1:1 translation of a given wide character.  It fills in the
//  string pointer with the single byte character.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_WC_TRANSLATION_SB( pHashN,                                     \
                               wch,                                        \
                               pMBStr,                                     \
                               wDefault,                                   \
                               pUsedDef,                                   \
                               dwFlags )                                   \
{                                                                          \
    GET_SB( pHashN->pWC,                                                   \
            wch,                                                           \
            pMBStr );                                                      \
    if (dwFlags & WC_NO_BEST_FIT_CHARS)                                    \
    {                                                                      \
        ELIMINATE_BEST_FIT_SB( pHashN,                                     \
                               wch,                                        \
                               pMBStr );                                   \
    }                                                                      \
    DEFAULT_CHAR_CHECK_SB( pHashN,                                         \
                           wch,                                            \
                           pMBStr,                                         \
                           wDefault,                                       \
                           pUsedDef );                                     \
}


////////////////////////////////////////////////////////////////////////////
//
//  GET_WC_TRANSLATION_MB
//
//  Gets the 1:1 translation of a given wide character.  It fills in the
//  appropriate number of characters for the multibyte character and then
//  returns the number of characters written to the multibyte string.
//
//  mbCnt will be 0 if the buffer is too small for the translation.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_WC_TRANSLATION_MB( pHashN,                                     \
                               wch,                                        \
                               pMBStr,                                     \
                               wDefault,                                   \
                               pUsedDef,                                   \
                               mbCnt,                                      \
                               fOnlyOne,                                   \
                               dwFlags )                                   \
{                                                                          \
    int mbCnt2;              /* number of characters written */            \
                                                                           \
                                                                           \
    GET_MB( pHashN->pWC,                                                   \
            wch,                                                           \
            pMBStr,                                                        \
            mbCnt,                                                         \
            fOnlyOne );                                                    \
    if (dwFlags & WC_NO_BEST_FIT_CHARS)                                    \
    {                                                                      \
        ELIMINATE_BEST_FIT_MB( pHashN,                                     \
                               wch,                                        \
                               pMBStr,                                     \
                               mbCnt,                                      \
                               fOnlyOne );                                 \
    }                                                                      \
    if (mbCnt)                                                             \
    {                                                                      \
        DEFAULT_CHAR_CHECK_MB( pHashN,                                     \
                               wch,                                        \
                               pMBStr,                                     \
                               wDefault,                                   \
                               pUsedDef,                                   \
                               mbCnt2,                                     \
                               fOnlyOne );                                 \
        if (mbCnt2 == -1)                                                  \
        {                                                                  \
            mbCnt = 0;                                                     \
        }                                                                  \
        else if (mbCnt2)                                                   \
        {                                                                  \
            mbCnt = mbCnt2;                                                \
        }                                                                  \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  GET_CP_HASH_NODE
//
//  Sets the code page value (if a special value is passed in) and the
//  hash node pointer.  If the code page value is invalid, the pointer
//  to the hash node will be set to NULL.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_CP_HASH_NODE( CodePage,                                        \
                          pHashN )                                         \
{                                                                          \
    PLOC_HASH pHashLoc;                                                    \
                                                                           \
                                                                           \
    /*                                                                     \
     *  Check for the ACP, OEMCP, or MACCP.  Fill in the appropriate       \
     *  value for the code page if one of these values is given.           \
     *  Otherwise, just get the hash node for the given code page.         \
     */                                                                    \
    if (CodePage == gAnsiCodePage)                                         \
    {                                                                      \
        pHashN = gpACPHashN;                                               \
    }                                                                      \
    else if (CodePage == gOemCodePage)                                     \
    {                                                                      \
        pHashN = gpOEMCPHashN;                                             \
    }                                                                      \
    else if (CodePage == CP_ACP)                                           \
    {                                                                      \
        CodePage = gAnsiCodePage;                                          \
        pHashN = gpACPHashN;                                               \
    }                                                                      \
    else if (CodePage == CP_OEMCP)                                         \
    {                                                                      \
        CodePage = gOemCodePage;                                           \
        pHashN = gpOEMCPHashN;                                             \
    }                                                                      \
    else if (CodePage == CP_SYMBOL)                                        \
    {                                                                      \
        pHashN = NULL;                                                     \
    }                                                                      \
    else if (CodePage == CP_MACCP)                                         \
    {                                                                      \
        CodePage = GetMacCodePage();                                       \
        pHashN = gpMACCPHashN;                                             \
    }                                                                      \
    else if (CodePage == CP_THREAD_ACP)                                    \
    {                                                                      \
        VALIDATE_LOCALE(NtCurrentTeb()->CurrentLocale, pHashLoc, FALSE);   \
        if (pHashLoc != NULL)                                              \
        {                                                                  \
            CodePage = pHashLoc->pLocaleFixed->DefaultACP;                 \
        }                                                                  \
        if (CodePage == CP_ACP)                                            \
        {                                                                  \
            CodePage = gAnsiCodePage;                                      \
            pHashN = gpACPHashN;                                           \
        }                                                                  \
        else if (CodePage == CP_OEMCP)                                     \
        {                                                                  \
            CodePage = gOemCodePage;                                       \
            pHashN = gpOEMCPHashN;                                         \
        }                                                                  \
        else if (CodePage == CP_MACCP)                                     \
        {                                                                  \
            CodePage = GetMacCodePage();                                   \
            pHashN = gpMACCPHashN;                                         \
        }                                                                  \
        else                                                               \
        {                                                                  \
            pHashN = GetCPHashNode(CodePage);                              \
        }                                                                  \
    }                                                                      \
    else                                                                   \
    {                                                                      \
        pHashN = GetCPHashNode(CodePage);                                  \
    }                                                                      \
}




//-------------------------------------------------------------------------//
//                             API ROUTINES                                //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  IsValidCodePage
//
//  Checks that the given code page is a valid one.  It does so by querying
//  the registry.  If the code page is found, then TRUE is returned.
//  Otherwise, FALSE is returned.
//
//  05-31-1991  JulieB      Created.
//  05-31-2002  ShawnSte    Make it not force the loading of the code page 
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI IsValidCodePage(
    UINT CodePage)
{
    //
    //  Do not allow special code page values to be valid here.
    //     (CP_ACP, CP_OEMCP, CP_MACCP, CP_THREAD_ACP, CP_SYMBOL are invalid)
    //

    //
    //  Do the quick check for the code page value equal to either
    //  the Ansi code page value or the OEM code page value.
    //
    if ((CodePage == gAnsiCodePage) || (CodePage == gOemCodePage) ||
        (CodePage == CP_UTF7) || (CodePage == CP_UTF8))
    {
        //
        //  Return success.
        //
        return (TRUE);
    }

    //
    //  Check for other code page values.
    //

    // If a node already exists, then we're OK
    if (IsCPHashNodeLoaded(CodePage) == TRUE)
    {
        //
        //  Return success.
        //
        return (TRUE);    
    }
    
    //
    //  Hash node doesn't exist.  Have to look in the registry.
    //  True if this works, false if it doesn't
    //
    return GetCPFileNameFromRegistry(CodePage, NULL, 0);
}

////////////////////////////////////////////////////////////////////////////
//
//  GetACP
//
//  Returns the ANSI code page for the system.  If the registry value is
//  not readable, then the chosen default ACP is used (NLS_DEFAULT_ACP).
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

UINT WINAPI GetACP()
{
    //
    //  Return the ACP stored in the cache.
    //
    return (gAnsiCodePage);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetCPGlobal
//
//  Sets the code page global, used by Setup to force the code page into
//  the correct value during GUI mode.
//
//  02-15-99    JimSchm   Created.
////////////////////////////////////////////////////////////////////////////

UINT
WINAPI
SetCPGlobal (
    IN      UINT NewAcp
    )
{
    UINT oldVal;


    oldVal = gAnsiCodePage;

    //
    //  Sets the ACP global.  This is a private exported routine, not an API.
    //
    gAnsiCodePage = NewAcp;
    return oldVal;
}


////////////////////////////////////////////////////////////////////////////
//
//  GetOEMCP
//
//  Returns the OEM code page for the system.  If the registry value is
//  not readable, then the chosen default ACP is used (NLS_DEFAULT_OEMCP).
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

UINT WINAPI GetOEMCP()
{
    //
    //  Return the OEMCP stored in the cache.
    //
    return (gOemCodePage);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetCPInfo
//
//  Returns information about a given code page.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI GetCPInfo(
    UINT CodePage,
    LPCPINFO lpCPInfo)
{
    PCP_HASH pHashN;              // ptr to CP hash node
    PCP_TABLE pInfo;              // ptr to CP information in file
    WORD wDefChar;                // default character
    BYTE *pLeadBytes;             // ptr to lead byte ranges
    UINT Ctr;                     // loop counter


    //
    //  See if it's a special code page value for UTF translations.
    //
    if (CodePage >= NLS_CP_ALGORITHM_RANGE)
    {
        return (UTFCPInfo(CodePage, lpCPInfo, FALSE));
    }

    //
    //  Get the code page value and the appropriate hash node.
    //
    GET_CP_HASH_NODE(CodePage, pHashN);

    //
    //  Invalid Parameter Check:
    //     - validate code page - get hash node containing translation tables
    //     - lpCPInfo is NULL
    //
    if ( (pHashN == NULL) ||
         ((pHashN->pCPInfo == NULL) && (pHashN->pfnCPProc == NULL)) ||
         (lpCPInfo == NULL) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    //  See if the given code page is in the DLL range.
    //
    if (pHashN->pfnCPProc)
    {
        //
        //  Call the DLL to get the code page information.
        //
        return ( (*(pHashN->pfnCPProc))( CodePage,
                                         NLS_CP_CPINFO,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         lpCPInfo ) );
    }

    //
    //  Fill in the CPINFO structure with the appropriate information.
    //
    pInfo = pHashN->pCPInfo;

    //
    //  Get the max char size.
    //
    lpCPInfo->MaxCharSize = (UINT)((WORD)pInfo->MaxCharSize);

    //
    //  Get the default character.
    //
    wDefChar = pInfo->wDefaultChar;
    if (HIBYTE(wDefChar))
    {
        (lpCPInfo->DefaultChar)[0] = HIBYTE(wDefChar);
        (lpCPInfo->DefaultChar)[1] = LOBYTE(wDefChar);
    }
    else
    {
        (lpCPInfo->DefaultChar)[0] = LOBYTE(wDefChar);
        (lpCPInfo->DefaultChar)[1] = (BYTE)0;
    }

    //
    //  Get the leadbytes.
    //
    pLeadBytes = pInfo->LeadByte;
    for (Ctr = 0; Ctr < MAX_LEADBYTES; Ctr++)
    {
        (lpCPInfo->LeadByte)[Ctr] = pLeadBytes[Ctr];
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetCPInfoExW
//
//  Returns information about a given code page.
//
//  11-15-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI GetCPInfoExW(
    UINT CodePage,
    DWORD dwFlags,
    LPCPINFOEXW lpCPInfoEx)
{
    PCP_HASH pHashN;              // ptr to CP hash node
    PCP_TABLE pInfo;              // ptr to CP information in file
    WORD wDefChar;                // default character
    BYTE *pLeadBytes;             // ptr to lead byte ranges
    UINT Ctr;                     // loop counter


    //
    //  See if it's a special code page value for UTF translations.
    //
    if (CodePage >= NLS_CP_ALGORITHM_RANGE)
    {
        if (UTFCPInfo(CodePage, (LPCPINFO)lpCPInfoEx, TRUE))
        {
            if (GetStringTableEntry( CodePage,
                                     0,
                                     lpCPInfoEx->CodePageName,
                                     MAX_PATH,
                                     RC_CODE_PAGE_NAME ) != 0)
            {
                return (TRUE);
            }
        }
        return (FALSE);
    }

    //
    //  Get the code page value and the appropriate hash node.
    //
    GET_CP_HASH_NODE(CodePage, pHashN);

    //
    //  Invalid Parameter Check:
    //     - validate code page - get hash node containing translation tables
    //     - lpCPInfoEx is NULL
    //
    if ( (pHashN == NULL) ||
         ((pHashN->pCPInfo == NULL) && (pHashN->pfnCPProc == NULL)) ||
         (lpCPInfoEx == NULL) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    //  Invalid Flags Check:
    //     - flags not 0
    //
    if (dwFlags != 0)
    {
        SetLastError(ERROR_INVALID_FLAGS);
        return (FALSE);
    }

    //
    //  See if the given code page is in the DLL range.
    //
    if (pHashN->pfnCPProc)
    {
        //
        //  Call the DLL to get the code page information.
        //
        if (((*(pHashN->pfnCPProc))( CodePage,
                                     NLS_CP_CPINFOEX,
                                     NULL,
                                     0,
                                     NULL,
                                     0,
                                     (LPCPINFO)lpCPInfoEx )) == TRUE)
        {
            return (TRUE);
        }
        else
        {
            //
            //  See if the CPINFO will succeed.  If so, then add the
            //  default CPINFOEX info to the structure.
            //
            if (((*(pHashN->pfnCPProc))( CodePage,
                                         NLS_CP_CPINFO,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         (LPCPINFO)lpCPInfoEx )) == TRUE)
            {
                //
                //  Fill in the Ex version info.
                //
                lpCPInfoEx->UnicodeDefaultChar = L'?';
                lpCPInfoEx->CodePage = CodePage;
                GetStringTableEntry( CodePage,
                                     0,
                                     lpCPInfoEx->CodePageName,
                                     MAX_PATH,
                                     RC_CODE_PAGE_NAME );

                SetLastError(NO_ERROR);
                return (TRUE);
            }

            return (FALSE);
        }
    }

    //
    //  Fill in the CPINFO structure with the appropriate information.
    //
    pInfo = pHashN->pCPInfo;

    //
    //  Get the max char size.
    //
    lpCPInfoEx->MaxCharSize = (UINT)((WORD)pInfo->MaxCharSize);

    //
    //  Get the default character.
    //
    wDefChar = pInfo->wDefaultChar;
    if (HIBYTE(wDefChar))
    {
        (lpCPInfoEx->DefaultChar)[0] = HIBYTE(wDefChar);
        (lpCPInfoEx->DefaultChar)[1] = LOBYTE(wDefChar);
    }
    else
    {
        (lpCPInfoEx->DefaultChar)[0] = LOBYTE(wDefChar);
        (lpCPInfoEx->DefaultChar)[1] = (BYTE)0;
    }

    //
    //  Get the leadbytes.
    //
    pLeadBytes = pInfo->LeadByte;
    for (Ctr = 0; Ctr < MAX_LEADBYTES; Ctr++)
    {
        (lpCPInfoEx->LeadByte)[Ctr] = pLeadBytes[Ctr];
    }

    //
    //  Get the Unicode default character.
    //
    lpCPInfoEx->UnicodeDefaultChar = pInfo->wUniDefaultChar;

    //
    //  Get the code page id.
    //
    lpCPInfoEx->CodePage = CodePage;

    //
    //  Get the code page name.
    //
    if (GetStringTableEntry( CodePage,
                             0,
                             lpCPInfoEx->CodePageName,
                             MAX_PATH,
                             RC_CODE_PAGE_NAME ) == 0)
    {
        return (FALSE);
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  IsDBCSLeadByte
//
//  Checks to see if a given character is a DBCS lead byte in the ACP.
//  Returns TRUE if it is, FALSE if it is not.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI IsDBCSLeadByte(
    BYTE TestChar)
{
    //
    //  Get the hash node for the ACP.
    //
    if (gpACPHashN == NULL)
    {
        SetLastError(ERROR_FILE_NOT_FOUND);
        return (FALSE);
    }

    //
    //  See if the given character is a DBCS lead byte.
    //
    if (CHECK_DBCS_LEAD_BYTE(gpACPHashN->pDBCSOffsets, TestChar))
    {
        //
        //  Return success - IS a DBCS lead byte.
        //
        return (TRUE);
    }

    //
    //  Return failure - is NOT a DBCS lead byte.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  IsDBCSLeadByteEx
//
//  Checks to see if a given character is a DBCS lead byte in the given
//  code page.  Returns TRUE if it is, FALSE if it is not.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI IsDBCSLeadByteEx(
    UINT CodePage,
    BYTE TestChar)
{
    PCP_HASH pHashN;              // ptr to CP hash node


    //
    //  See if it's a special code page value for UTF translations.
    //
    if (CodePage >= NLS_CP_ALGORITHM_RANGE)
    {
        //
        //  Return that it's not a DBCS leadbyte.
        //
        return (FALSE);
    }

    //
    //  Get the code page value and the appropriate hash node.
    //
    GET_CP_HASH_NODE(CodePage, pHashN);

    //
    //  Invalid Parameter Check:
    //     - validate code page
    //
    if (pHashN == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    //  See if the given character is a DBCS lead byte.
    //
    if (CHECK_DBCS_LEAD_BYTE(pHashN->pDBCSOffsets, TestChar))
    {
        //
        //  Return success - IS a DBCS lead byte.
        //
        return (TRUE);
    }

    //
    //  Return failure - is NOT a DBCS lead byte.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  MultiByteToWideChar
//
//  Maps a multibyte character string to its wide character string
//  counterpart.
//
//  05-31-91    JulieB    Created.
//  09-01-93    JulieB    Add support for MB_ERR_INVALID_CHARS flag.
////////////////////////////////////////////////////////////////////////////

int WINAPI MultiByteToWideChar(
    UINT CodePage,
    DWORD dwFlags,
    LPCSTR lpMultiByteStr,
    int cbMultiByte,
    LPWSTR lpWideCharStr,
    int cchWideChar)
{
    PCP_HASH pHashN;              // ptr to CP hash node
    register LPBYTE pMBStr;       // ptr to search through MB string
    register LPWSTR pWCStr;       // ptr to search through WC string
    LPBYTE pEndMBStr;             // ptr to end of MB search string
    LPWSTR pEndWCStr;             // ptr to end of WC string buffer
    int wcIncr;                   // amount to increment pWCStr
    int mbIncr;                   // amount to increment pMBStr
    int wcCount = 0;              // count of wide chars written
    int CompSet;                  // if MB_COMPOSITE flag is set
    PMB_TABLE pMBTbl;             // ptr to correct MB table (MB or GLYPH)
    int ctr;                      // loop counter


    //
    //  See if it's a special code page value for UTF translations.
    //
    if (CodePage >= NLS_CP_ALGORITHM_RANGE)
    {
        return (UTFToUnicode( CodePage,
                              dwFlags,
                              lpMultiByteStr,
                              cbMultiByte,
                              lpWideCharStr,
                              cchWideChar ));
    }

    //
    //  Get the code page value and the appropriate hash node.
    //
    GET_CP_HASH_NODE(CodePage, pHashN);

    //
    //  Invalid Parameter Check:
    //     - length of MB string is 0
    //     - wide char buffer size is negative
    //     - MB string is NULL
    //     - length of WC string is NOT zero AND
    //         (WC string is NULL OR src and dest pointers equal)
    //
    if ( (cbMultiByte == 0) || (cchWideChar < 0) ||
         (lpMultiByteStr == NULL) ||
         ((cchWideChar != 0) &&
          ((lpWideCharStr == NULL) ||
           (lpMultiByteStr == (LPSTR)lpWideCharStr))) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  If cbMultiByte is -1, then the string is null terminated and we
    //  need to get the length of the string.  Add one to the length to
    //  include the null termination.  (This will always be at least 1.)
    //
    if (cbMultiByte <= -1)
    {
        cbMultiByte = strlen(lpMultiByteStr) + 1;
    }

    //
    //  Check for valid code page.
    //
    if (pHashN == NULL)
    {
        //
        //  Special case the CP_SYMBOL code page.
        //
        if ((CodePage == CP_SYMBOL) && (dwFlags == 0))
        {
            //
            //  If the caller just wants the size of the buffer needed
            //  to do this translation, return the size of the MB string.
            //
            if (cchWideChar == 0)
            {
                return (cbMultiByte);
            }

            //
            //  Make sure the buffer is large enough.
            //
            if (cchWideChar < cbMultiByte)
            {
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                return (0);
            }

            //
            //  Translate SB char xx to Unicode f0xx.
            //    0x00->0x1f map to 0x0000->0x001f
            //    0x20->0xff map to 0xf020->0xf0ff
            //
            for (ctr = 0; ctr < cbMultiByte; ctr++)
            {
                lpWideCharStr[ctr] = ((BYTE)(lpMultiByteStr[ctr]) < 0x20)
                                       ? (WCHAR)lpMultiByteStr[ctr]
                                       : MAKEWORD(lpMultiByteStr[ctr], 0xf0);
            }
            return (cbMultiByte);
        }
        else
        {
            SetLastError(((CodePage == CP_SYMBOL) && (dwFlags != 0))
                           ? ERROR_INVALID_FLAGS
                           : ERROR_INVALID_PARAMETER);
            return (0);
        }
    }

    //
    //  See if the given code page is in the DLL range.
    //
    if (pHashN->pfnCPProc)
    {
        //
        //  Invalid Flags Check:
        //     - flags not 0
        //
        if (dwFlags != 0)
        {
            SetLastError(ERROR_INVALID_FLAGS);
            return (0);
        }

        //
        //  Call the DLL to do the translation.
        //
        return ( (*(pHashN->pfnCPProc))( CodePage,
                                         NLS_CP_MBTOWC,
                                         (LPSTR)lpMultiByteStr,
                                         cbMultiByte,
                                         (LPWSTR)lpWideCharStr,
                                         cchWideChar,
                                         NULL ) );
    }

    //
    //  Invalid Flags Check:
    //     - flags other than valid ones
    //     - composite and precomposed both set
    //
    if ( (dwFlags & MB_INVALID_FLAG) ||
         ((dwFlags & MB_PRECOMPOSED) && (dwFlags & MB_COMPOSITE)) )
    {
        SetLastError(ERROR_INVALID_FLAGS);
        return (0);
    }

    //
    //  Initialize multibyte character loop pointers.
    //
    pMBStr = (LPBYTE)lpMultiByteStr;
    pEndMBStr = pMBStr + cbMultiByte;
    CompSet = dwFlags & MB_COMPOSITE;

    //
    //  Get the correct MB table (MB or GLYPH).
    //
    if ((dwFlags & MB_USEGLYPHCHARS) && (pHashN->pGlyphTbl != NULL))
    {
        pMBTbl = pHashN->pGlyphTbl;
    }
    else
    {
        pMBTbl = pHashN->pMBTbl;
    }

    //
    //  If cchWideChar is 0, then we can't use lpWideCharStr.  In this
    //  case, we simply want to count the number of characters that would
    //  be written to the buffer.
    //
    if (cchWideChar == 0)
    {
        WCHAR pTempStr[MAX_COMPOSITE];   // tmp buffer - max for composite

        //
        //  For each multibyte char, translate it to its corresponding
        //  wide char and increment the wide character count.
        //
        pEndWCStr = pTempStr + MAX_COMPOSITE;
        if (IS_SBCS_CP(pHashN))
        {
            //
            //  Single Byte Character Code Page.
            //
            if (CompSet)
            {
                //
                //  Composite flag is set.
                //
                if (dwFlags & MB_ERR_INVALID_CHARS)
                {
                    //
                    //  Error check flag is set.
                    //
                    while (pMBStr < pEndMBStr)
                    {
                        if (!(wcIncr = GetWCCompSBErr( pHashN,
                                                       pMBTbl,
                                                       pMBStr,
                                                       pTempStr,
                                                       pEndWCStr )))
                        {
                            return (0);
                        }
                        pMBStr++;
                        wcCount += wcIncr;
                    }
                }
                else
                {
                    //
                    //  Error check flag is NOT set.
                    //
                    while (pMBStr < pEndMBStr)
                    {
                        wcCount += GetWCCompSB( pMBTbl,
                                                pMBStr,
                                                pTempStr,
                                                pEndWCStr );
                        pMBStr++;
                    }
                }
            }
            else
            {
                //
                //  Composite flag is NOT set.
                //
                if (dwFlags & MB_ERR_INVALID_CHARS)
                {
                    //
                    //  Error check flag is set.
                    //
                    wcCount = (int)(pEndMBStr - pMBStr);
                    while (pMBStr < pEndMBStr)
                    {
                        GET_WC_SINGLE( pMBTbl,
                                       pMBStr,
                                       pTempStr );
                        CHECK_ERROR_WC_SINGLE( pHashN,
                                               *pTempStr,
                                               *pMBStr );
                        pMBStr++;
                    }
                }
                else
                {
                    //
                    //  Error check flag is NOT set.
                    //
                    //  Just return the size of the MB string, since
                    //  it's a 1:1 translation.
                    //
                    wcCount = (int)(pEndMBStr - pMBStr);
                }
            }
        }
        else
        {
            //
            //  Multi Byte Character Code Page.
            //
            if (CompSet)
            {
                //
                //  Composite flag is set.
                //
                if (dwFlags & MB_ERR_INVALID_CHARS)
                {
                    //
                    //  Error check flag is set.
                    //
                    while (pMBStr < pEndMBStr)
                    {
                        if (!(wcIncr = GetWCCompMBErr( pHashN,
                                                       pMBTbl,
                                                       pMBStr,
                                                       pEndMBStr,
                                                       pTempStr,
                                                       pEndWCStr,
                                                       &mbIncr )))
                        {
                            return (0);
                        }
                        pMBStr += mbIncr;
                        wcCount += wcIncr;
                    }
                }
                else
                {
                    //
                    //  Error check flag is NOT set.
                    //
                    while (pMBStr < pEndMBStr)
                    {
                        wcCount += GetWCCompMB( pHashN,
                                                pMBTbl,
                                                pMBStr,
                                                pEndMBStr,
                                                pTempStr,
                                                pEndWCStr,
                                                &mbIncr );
                        pMBStr += mbIncr;
                    }
                }
            }
            else
            {
                //
                //  Composite flag is NOT set.
                //
                if (dwFlags & MB_ERR_INVALID_CHARS)
                {
                    //
                    //  Error check flag is set.
                    //
                    while (pMBStr < pEndMBStr)
                    {
                        GET_WC_MULTI_ERR( pHashN,
                                          pMBTbl,
                                          pMBStr,
                                          pEndMBStr,
                                          pTempStr,
                                          pEndWCStr,
                                          mbIncr );
                        pMBStr += mbIncr;
                        wcCount++;
                    }
                }
                else
                {
                    //
                    //  Error check flag is NOT set.
                    //
                    while (pMBStr < pEndMBStr)
                    {
                        GET_WC_MULTI( pHashN,
                                      pMBTbl,
                                      pMBStr,
                                      pEndMBStr,
                                      pTempStr,
                                      pEndWCStr,
                                      mbIncr );
                        pMBStr += mbIncr;
                        wcCount++;
                    }
                }
            }
        }
    }
    else
    {
        //
        //  Initialize wide character loop pointers.
        //
        pWCStr = lpWideCharStr;
        pEndWCStr = pWCStr + cchWideChar;

        //
        //  For each multibyte char, translate it to its corresponding
        //  wide char, store it in lpWideCharStr, and increment the wide
        //  character count.
        //
        if (IS_SBCS_CP(pHashN))
        {
            //
            //  Single Byte Character Code Page.
            //
            if (CompSet)
            {
                //
                //  Composite flag is set.
                //
                if (dwFlags & MB_ERR_INVALID_CHARS)
                {
                    //
                    //  Error check flag is set.
                    //
                    while ((pMBStr < pEndMBStr) && (pWCStr < pEndWCStr))
                    {
                        if (!(wcIncr = GetWCCompSBErr( pHashN,
                                                       pMBTbl,
                                                       pMBStr,
                                                       pWCStr,
                                                       pEndWCStr )))
                        {
                            return (0);
                        }
                        pMBStr++;
                        pWCStr += wcIncr;
                    }
                    wcCount = (int)(pWCStr - lpWideCharStr);
                }
                else
                {
                    //
                    //  Error check flag is NOT set.
                    //
                    while ((pMBStr < pEndMBStr) && (pWCStr < pEndWCStr))
                    {
                        pWCStr += GetWCCompSB( pMBTbl,
                                               pMBStr,
                                               pWCStr,
                                               pEndWCStr );
                        pMBStr++;
                    }
                    wcCount = (int)(pWCStr - lpWideCharStr);
                }
            }
            else
            {
                //
                //  Composite flag is NOT set.
                //
                if (dwFlags & MB_ERR_INVALID_CHARS)
                {
                    //
                    //  Error check flag is set.
                    //
                    wcCount = (int)(pEndMBStr - pMBStr);
                    if ((pEndWCStr - pWCStr) < wcCount)
                    {
                        wcCount = (int)(pEndWCStr - pWCStr);
                    }
                    for (ctr = wcCount; ctr > 0; ctr--)
                    {
                        GET_WC_SINGLE( pMBTbl,
                                       pMBStr,
                                       pWCStr );
                        CHECK_ERROR_WC_SINGLE( pHashN,
                                               *pWCStr,
                                               *pMBStr );
                        pMBStr++;
                        pWCStr++;
                    }
                }
                else
                {
                    //
                    //  Error check flag is NOT set.
                    //
                    wcCount = (int)(pEndMBStr - pMBStr);
                    if ((pEndWCStr - pWCStr) < wcCount)
                    {
                        wcCount = (int)(pEndWCStr - pWCStr);
                    }
                    for (ctr = wcCount; ctr > 0; ctr--)
                    {
                        GET_WC_SINGLE( pMBTbl,
                                       pMBStr,
                                       pWCStr );
                        pMBStr++;
                        pWCStr++;
                    }
                }
            }
        }
        else
        {
            //
            //  Multi Byte Character Code Page.
            //
            if (CompSet)
            {
                //
                //  Composite flag is set.
                //
                if (dwFlags & MB_ERR_INVALID_CHARS)
                {
                    //
                    //  Error check flag is set.
                    //
                    while ((pMBStr < pEndMBStr) && (pWCStr < pEndWCStr))
                    {
                        if (!(wcIncr = GetWCCompMBErr( pHashN,
                                                       pMBTbl,
                                                       pMBStr,
                                                       pEndMBStr,
                                                       pWCStr,
                                                       pEndWCStr,
                                                       &mbIncr )))
                        {
                            return (0);
                        }
                        pMBStr += mbIncr;
                        pWCStr += wcIncr;
                    }
                    wcCount = (int)(pWCStr - lpWideCharStr);
                }
                else
                {
                    //
                    //  Error check flag is NOT set.
                    //
                    while ((pMBStr < pEndMBStr) && (pWCStr < pEndWCStr))
                    {
                        pWCStr += GetWCCompMB( pHashN,
                                               pMBTbl,
                                               pMBStr,
                                               pEndMBStr,
                                               pWCStr,
                                               pEndWCStr,
                                               &mbIncr );
                        pMBStr += mbIncr;
                    }
                    wcCount = (int)(pWCStr - lpWideCharStr);
                }
            }
            else
            {
                //
                //  Composite flag is NOT set.
                //
                if (dwFlags & MB_ERR_INVALID_CHARS)
                {
                    //
                    //  Error check flag is set.
                    //
                    while ((pMBStr < pEndMBStr) && (pWCStr < pEndWCStr))
                    {
                        GET_WC_MULTI_ERR( pHashN,
                                          pMBTbl,
                                          pMBStr,
                                          pEndMBStr,
                                          pWCStr,
                                          pEndWCStr,
                                          mbIncr );
                        pMBStr += mbIncr;
                        pWCStr++;
                    }
                    wcCount = (int)(pWCStr - lpWideCharStr);
                }
                else
                {
                    //
                    //  Error check flag is NOT set.
                    //
                    while ((pMBStr < pEndMBStr) && (pWCStr < pEndWCStr))
                    {
                        GET_WC_MULTI( pHashN,
                                      pMBTbl,
                                      pMBStr,
                                      pEndMBStr,
                                      pWCStr,
                                      pEndWCStr,
                                      mbIncr );
                        pMBStr += mbIncr;
                        pWCStr++;
                    }
                    wcCount = (int)(pWCStr - lpWideCharStr);
                }
            }
        }

        //
        //  Make sure wide character buffer was large enough.
        //
        if (pMBStr < pEndMBStr)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return (0);
        }
    }

    //
    //  Return the number of characters written (or that would have
    //  been written) to the buffer.
    //
    return (wcCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  WideCharToMultiByte
//
//  Maps a wide character string to its multibyte character string
//  counterpart.
//
//  NOTE:  Most significant bit of dwFlags parameter is used by this routine
//         to indicate that the caller only wants the count of the number of
//         characters written, not the string (ie. do not back up in buffer).
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WINAPI WideCharToMultiByte(
    UINT CodePage,
    DWORD dwFlags,
    LPCWSTR lpWideCharStr,
    int cchWideChar,
    LPSTR lpMultiByteStr,
    int cbMultiByte,
    LPCSTR lpDefaultChar,
    LPBOOL lpUsedDefaultChar)
{
    PCP_HASH pHashN;              // ptr to CP hash node
    LPWSTR pWCStr;                // ptr to search through WC string
    LPWSTR pEndWCStr;             // ptr to end of WC string buffer
    WORD wDefault = 0;            // default character as a word
    int IfNoDefault;              // if default check is to be made
    int IfCompositeChk;           // if check for composite
    BOOL TmpUsed;                 // temp storage for default used
    int ctr;                      // loop counter


    //
    //  See if it's a special code page value for UTF translations.
    //
    if (CodePage >= NLS_CP_ALGORITHM_RANGE)
    {
        return (UnicodeToUTF( CodePage,
                              dwFlags,
                              lpWideCharStr,
                              cchWideChar,
                              lpMultiByteStr,
                              cbMultiByte,
                              lpDefaultChar,
                              lpUsedDefaultChar ));
    }

    //
    //  Get the code page value and the appropriate hash node.
    //
    GET_CP_HASH_NODE(CodePage, pHashN);

    //
    //  Invalid Parameter Check:
    //     - length of WC string is 0
    //     - multibyte buffer size is negative
    //     - WC string is NULL
    //     - length of WC string is NOT zero AND
    //         (MB string is NULL OR src and dest pointers equal)
    //
    if ( (cchWideChar == 0) || (cbMultiByte < 0) ||
         (lpWideCharStr == NULL) ||
         ((cbMultiByte != 0) &&
          ((lpMultiByteStr == NULL) ||
           (lpWideCharStr == (LPWSTR)lpMultiByteStr))) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  If cchWideChar is -1, then the string is null terminated and we
    //  need to get the length of the string.  Add one to the length to
    //  include the null termination.  (This will always be at least 1.)
    //
    if (cchWideChar <= -1)
    {
        cchWideChar = NlsStrLenW(lpWideCharStr) + 1;
    }

    //
    //  Check for valid code page.
    //
    if (pHashN == NULL)
    {
        //
        //  Special case the CP_SYMBOL code page.
        //
        if ((CodePage == CP_SYMBOL) && (dwFlags == 0) &&
            (lpDefaultChar == NULL) && (lpUsedDefaultChar == NULL))
        {
            //
            //  If the caller just wants the size of the buffer needed
            //  to do this translation, return the size of the MB string.
            //
            if (cbMultiByte == 0)
            {
                return (cchWideChar);
            }

            //
            //  Make sure the buffer is large enough.
            //
            if (cbMultiByte < cchWideChar)
            {
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                return (0);
            }

            //
            //  Translate Unicode char f0xx to SB xx.
            //    0x0000->0x001f map to 0x00->0x1f
            //    0xf020->0xf0ff map to 0x20->0xff
            //
            for (ctr = 0; ctr < cchWideChar; ctr++)
            {
                if ((lpWideCharStr[ctr] >= 0x0020) &&
                    ((lpWideCharStr[ctr] < 0xf020) ||
                     (lpWideCharStr[ctr] > 0xf0ff)))
                {
                    SetLastError(ERROR_NO_UNICODE_TRANSLATION);                        \
                    return (0);
                }
                lpMultiByteStr[ctr] = (BYTE)lpWideCharStr[ctr];
            }
            return (cchWideChar);
        }
        else
        {
            SetLastError(((CodePage == CP_SYMBOL) && (dwFlags != 0))
                           ? ERROR_INVALID_FLAGS
                           : ERROR_INVALID_PARAMETER);
            return (0);
        }
    }

    //
    //  See if the given code page is in the DLL range.
    //
    if (pHashN->pfnCPProc)
    {
        //
        //  Invalid Parameter Check:
        //     - lpDefaultChar not NULL
        //     - lpUsedDefaultChar not NULL
        //
        if ((lpDefaultChar != NULL) || (lpUsedDefaultChar != NULL))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return (0);
        }

        //
        //  Invalid Flags Check:
        //     - flags not 0
        //
        if (dwFlags != 0)
        {
            SetLastError(ERROR_INVALID_FLAGS);
            return (0);
        }

        //
        //  Call the DLL to do the translation.
        //
        return ( (*(pHashN->pfnCPProc))( CodePage,
                                         NLS_CP_WCTOMB,
                                         (LPSTR)lpMultiByteStr,
                                         cbMultiByte,
                                         (LPWSTR)lpWideCharStr,
                                         cchWideChar,
                                         NULL ) );
    }

    //
    //  Invalid Flags Check:
    //     - compositechk flag is not set AND any of comp flags are set
    //     - flags other than valid ones
    //
    if ( ((!(IfCompositeChk = (dwFlags & WC_COMPOSITECHECK))) &&
          (dwFlags & WC_COMPCHK_FLAGS)) ||
         (dwFlags & WC_INVALID_FLAG) )
    {
        SetLastError(ERROR_INVALID_FLAGS);
        return (0);
    }

    //
    //  Initialize wide character loop pointers.
    //
    pWCStr = (LPWSTR)lpWideCharStr;
    pEndWCStr = pWCStr + cchWideChar;

    //
    //  Set the IfNoDefault parameter to TRUE if both lpDefaultChar and
    //  lpUsedDefaultChar are NULL.
    //
    IfNoDefault = ((lpDefaultChar == NULL) && (lpUsedDefaultChar == NULL));

    //
    //  If the composite check flag is NOT set AND both of the default
    //  parameters (lpDefaultChar and lpUsedDefaultChar) are null, then
    //  do the quick translation.
    //
    if (IfNoDefault && !IfCompositeChk)
    {
        //
        //  Translate WC string to MB string, ignoring default chars.
        //
        return (GetMBNoDefault( pHashN,
                                pWCStr,
                                pEndWCStr,
                                (LPBYTE)lpMultiByteStr,
                                cbMultiByte,
                                dwFlags ));
    }

    //
    //  Set the system default character.
    //
    wDefault = pHashN->pCPInfo->wDefaultChar;

    //
    //  See if the default check is needed.
    //
    if (!IfNoDefault)
    {
        //
        //  If lpDefaultChar is NULL, then use the system default.
        //  Form a word out of the default character.  Single byte
        //  characters are zero extended, DBCS characters are as is.
        //
        if (lpDefaultChar != NULL)
        {
            wDefault = GET_DEFAULT_WORD( pHashN->pDBCSOffsets,
                                         (LPBYTE)lpDefaultChar );
        }

        //
        //  If lpUsedDefaultChar is NULL, then it won't be used later
        //  on if a default character is detected.  Otherwise, we need
        //  to initialize it.
        //
        if (lpUsedDefaultChar == NULL)
        {
            lpUsedDefaultChar = &TmpUsed;
        }
        *lpUsedDefaultChar = FALSE;

        //
        //  Check for "composite check" flag.
        //
        if (!IfCompositeChk)
        {
            //
            //  Translate WC string to MB string, checking for the use of the
            //  default character.
            //
            return (GetMBDefault( pHashN,
                                  pWCStr,
                                  pEndWCStr,
                                  (LPBYTE)lpMultiByteStr,
                                  cbMultiByte,
                                  wDefault,
                                  lpUsedDefaultChar,
                                  dwFlags ));
        }
        else
        {
            //
            //  Translate WC string to MB string, checking for the use of the
            //  default character.
            //
            return (GetMBDefaultComp( pHashN,
                                      pWCStr,
                                      pEndWCStr,
                                      (LPBYTE)lpMultiByteStr,
                                      cbMultiByte,
                                      wDefault,
                                      lpUsedDefaultChar,
                                      dwFlags ));
        }
    }
    else
    {
        //
        //  The only case left here is that the Composite check
        //  flag IS set and the default check flag is NOT set.
        //
        //  Translate WC string to MB string, checking for the use of the
        //  default character.
        //
        return (GetMBDefaultComp( pHashN,
                                  pWCStr,
                                  pEndWCStr,
                                  (LPBYTE)lpMultiByteStr,
                                  cbMultiByte,
                                  wDefault,
                                  &TmpUsed,
                                  dwFlags ));
    }
}




//-------------------------------------------------------------------------//
//                          INTERNAL ROUTINES                              //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  GetWCCompSB
//
//  Fills in pWCStr with the wide character(s) for the corresponding single
//  byte character from the appropriate translation table and returns the
//  number of wide characters written.  This routine should only be called
//  when the precomposed forms need to be translated to composite.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetWCCompSB(
    PMB_TABLE pMBTbl,
    LPBYTE pMBStr,
    LPWSTR pWCStr,
    LPWSTR pEndWCStr)
{
    //
    //  Get the single byte to wide character translation.
    //
    GET_WC_SINGLE(pMBTbl, pMBStr, pWCStr);

    //
    //  Fill in the composite form of the character (if one exists)
    //  and return the number of wide characters written.
    //
    return (InsertCompositeForm(pWCStr, pEndWCStr));
}


////////////////////////////////////////////////////////////////////////////
//
//  GetWCCompMB
//
//  Fills in pWCStr with the wide character(s) for the corresponding multibyte
//  character from the appropriate translation table and returns the number
//  of wide characters written.  The number of bytes used from the pMBStr
//  buffer (single byte or double byte) is returned in the mbIncr parameter.
//  This routine should only be called when the precomposed forms need to be
//  translated to composite.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetWCCompMB(
    PCP_HASH pHashN,
    PMB_TABLE pMBTbl,
    LPBYTE pMBStr,
    LPBYTE pEndMBStr,
    LPWSTR pWCStr,
    LPWSTR pEndWCStr,
    int *pmbIncr)
{
    //
    //  Get the multibyte to wide char translation.
    //
    GET_WC_MULTI( pHashN,
                  pMBTbl,
                  pMBStr,
                  pEndMBStr,
                  pWCStr,
                  pEndWCStr,
                  *pmbIncr );

    //
    //  Fill in the composite form of the character (if one exists)
    //  and return the number of wide characters written.
    //
    return (InsertCompositeForm(pWCStr, pEndWCStr));
}


////////////////////////////////////////////////////////////////////////////
//
//  GetWCCompSBErr
//
//  Fills in pWCStr with the wide character(s) for the corresponding single
//  byte character from the appropriate translation table and returns the
//  number of wide characters written.  This routine should only be called
//  when the precomposed forms need to be translated to composite.
//
//  Checks to be sure an invalid character is not translated to the default
//  character.  If so, it sets last error and returns 0 characters written.
//
//  09-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetWCCompSBErr(
    PCP_HASH pHashN,
    PMB_TABLE pMBTbl,
    LPBYTE pMBStr,
    LPWSTR pWCStr,
    LPWSTR pEndWCStr)
{
    //
    //  Get the single byte to wide character translation.
    //
    GET_WC_SINGLE(pMBTbl, pMBStr, pWCStr);

    //
    //  Make sure an invalid character was not translated to the
    //  default char.  If it was, set last error and return 0
    //  characters written.
    //
    CHECK_ERROR_WC_SINGLE(pHashN, *pWCStr, *pMBStr);

    //
    //  Fill in the composite form of the character (if one exists)
    //  and return the number of wide characters written.
    //
    return (InsertCompositeForm(pWCStr, pEndWCStr));
}


////////////////////////////////////////////////////////////////////////////
//
//  GetWCCompMBErr
//
//  Fills in pWCStr with the wide character(s) for the corresponding multibyte
//  character from the appropriate translation table and returns the number
//  of wide characters written.  The number of bytes used from the pMBStr
//  buffer (single byte or double byte) is returned in the mbIncr parameter.
//  This routine should only be called when the precomposed forms need to be
//  translated to composite.
//
//  Checks to be sure an invalid character is not translated to the default
//  character.  If so, it sets last error and returns 0 characters written.
//
//  09-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetWCCompMBErr(
    PCP_HASH pHashN,
    PMB_TABLE pMBTbl,
    LPBYTE pMBStr,
    LPBYTE pEndMBStr,
    LPWSTR pWCStr,
    LPWSTR pEndWCStr,
    int *pmbIncr)
{
    //
    //  Get the multibyte to wide char translation.
    //
    //  Make sure an invalid character was not translated to the
    //  default char.  If it was, set last error and return 0
    //  characters written.
    //
    GET_WC_MULTI_ERR( pHashN,
                      pMBTbl,
                      pMBStr,
                      pEndMBStr,
                      pWCStr,
                      pEndWCStr,
                      *pmbIncr );

    //
    //  Fill in the composite form of the character (if one exists)
    //  and return the number of wide characters written.
    //
    return (InsertCompositeForm(pWCStr, pEndWCStr));
}


////////////////////////////////////////////////////////////////////////////
//
//  GetMBNoDefault
//
//  Translates the wide character string to a multibyte string and returns
//  the number of bytes written.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetMBNoDefault(
    PCP_HASH pHashN,
    LPWSTR pWCStr,
    LPWSTR pEndWCStr,
    LPBYTE pMBStr,
    int cbMultiByte,
    DWORD dwFlags)
{
    int mbIncr;                   // amount to increment pMBStr
    int mbCount = 0;              // count of multibyte chars written
    LPBYTE pEndMBStr;             // ptr to end of MB string buffer
    PWC_TABLE pWC = pHashN->pWC;  // ptr to WC table
    int ctr;                      // loop counter


    //
    //  If cbMultiByte is 0, then we can't use pMBStr.  In this
    //  case, we simply want to count the number of characters that
    //  would be written to the buffer.
    //
    if (cbMultiByte == 0)
    {
        BYTE pTempStr[2];             // tmp buffer - 2 bytes for DBCS

        //
        //  For each wide char, translate it to its corresponding multibyte
        //  char and increment the multibyte character count.
        //
        if (IS_SBCS_CP(pHashN))
        {
            //
            //  Single Byte Character Code Page.
            //
            //  Just return the count of characters - it will be the
            //  same number of characters as the source string.
            //
            mbCount = (int)(pEndWCStr - pWCStr);
        }
        else
        {
            //
            //  Multi Byte Character Code Page.
            //
            if (dwFlags & WC_NO_BEST_FIT_CHARS)
            {
                while (pWCStr < pEndWCStr)
                {
                    GET_MB( pWC,
                            *pWCStr,
                            pTempStr,
                            mbIncr,
                            FALSE );
                    ELIMINATE_BEST_FIT_MB( pHashN,
                                           *pWCStr,
                                           pTempStr,
                                           mbIncr,
                                           FALSE );
                    pWCStr++;
                    mbCount += mbIncr;
                }
            }
            else
            {
                while (pWCStr < pEndWCStr)
                {
                    GET_MB( pWC,
                            *pWCStr,
                            pTempStr,
                            mbIncr,
                            FALSE );
                    pWCStr++;
                    mbCount += mbIncr;
                }
            }
        }
    }
    else
    {
        //
        //  Initialize multibyte loop pointers.
        //
        pEndMBStr = pMBStr + cbMultiByte;

        //
        //  For each wide char, translate it to its corresponding
        //  multibyte char, store it in pMBStr, and increment the
        //  multibyte character count.
        //
        if (IS_SBCS_CP(pHashN))
        {
            //
            //  Single Byte Character Code Page.
            //
            mbCount = (int)(pEndWCStr - pWCStr);
            if ((pEndMBStr - pMBStr) < mbCount)
            {
                mbCount = (int)(pEndMBStr - pMBStr);
            }
            if (dwFlags & WC_NO_BEST_FIT_CHARS)
            {
                for (ctr = mbCount; ctr > 0; ctr--)
                {
                    GET_SB( pWC,
                            *pWCStr,
                            pMBStr );
                    ELIMINATE_BEST_FIT_SB( pHashN,
                                           *pWCStr,
                                           pMBStr );
                    pWCStr++;
                    pMBStr++;
                }
            }
            else
            {
                for (ctr = mbCount; ctr > 0; ctr--)
                {
                    GET_SB( pWC,
                            *pWCStr,
                            pMBStr );
                    pWCStr++;
                    pMBStr++;
                }
            }
        }
        else
        {
            //
            //  Multi Byte Character Code Page.
            //
            if (dwFlags & WC_NO_BEST_FIT_CHARS)
            {
                while ((pWCStr < pEndWCStr) && (pMBStr < pEndMBStr))
                {
                    GET_MB( pWC,
                            *pWCStr,
                            pMBStr,
                            mbIncr,
                            ((pMBStr + 1) < pEndMBStr) ? FALSE : TRUE );
                    ELIMINATE_BEST_FIT_MB( pHashN,
                                           *pWCStr,
                                           pMBStr,
                                           mbIncr,
                                           ((pMBStr + 1) < pEndMBStr) ? FALSE : TRUE );
                    if (mbIncr == 0)
                    {
                        //
                        //  Not enough space in buffer.
                        //
                        break;
                    }

                    pWCStr++;
                    mbCount += mbIncr;
                    pMBStr += mbIncr;
                }
            }
            else
            {
                while ((pWCStr < pEndWCStr) && (pMBStr < pEndMBStr))
                {
                    GET_MB( pWC,
                            *pWCStr,
                            pMBStr,
                            mbIncr,
                            ((pMBStr + 1) < pEndMBStr) ? FALSE : TRUE );
                    if (mbIncr == 0)
                    {
                        //
                        //  Not enough space in buffer.
                        //
                        break;
                    }

                    pWCStr++;
                    mbCount += mbIncr;
                    pMBStr += mbIncr;
                }
            }
        }

        //
        //  Make sure multibyte character buffer was large enough.
        //
        if (pWCStr < pEndWCStr)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return (0);
        }
    }

    //
    //  Return the number of characters written (or that would have
    //  been written) to the buffer.
    //
    return (mbCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetMBDefault
//
//  Translates the wide character string to a multibyte string and returns
//  the number of bytes written.  This also checks for the use of the default
//  character, so the translation is slower.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetMBDefault(
    PCP_HASH pHashN,
    LPWSTR pWCStr,
    LPWSTR pEndWCStr,
    LPBYTE pMBStr,
    int cbMultiByte,
    WORD wDefault,
    LPBOOL pUsedDef,
    DWORD dwFlags)
{
    int mbIncr;                   // amount to increment pMBStr
    int mbIncr2;                  // amount to increment pMBStr
    int mbCount = 0;              // count of multibyte chars written
    LPBYTE pEndMBStr;             // ptr to end of MB string buffer
    PWC_TABLE pWC = pHashN->pWC;  // ptr to WC table
    int ctr;                      // loop counter


    //
    //  If cbMultiByte is 0, then we can't use pMBStr.  In this
    //  case, we simply want to count the number of characters that
    //  would be written to the buffer.
    //
    if (cbMultiByte == 0)
    {
        BYTE pTempStr[2];             // tmp buffer - 2 bytes for DBCS

        //
        //  For each wide char, translate it to its corresponding multibyte
        //  char and increment the multibyte character count.
        //
        if (IS_SBCS_CP(pHashN))
        {
            //
            //  Single Byte Character Code Page.
            //
            mbCount = (int)(pEndWCStr - pWCStr);
            if (dwFlags & WC_NO_BEST_FIT_CHARS)
            {
                while (pWCStr < pEndWCStr)
                {
                    GET_SB( pWC,
                            *pWCStr,
                            pTempStr );
                    ELIMINATE_BEST_FIT_SB( pHashN,
                                           *pWCStr,
                                           pTempStr );
                    DEFAULT_CHAR_CHECK_SB( pHashN,
                                           *pWCStr,
                                           pTempStr,
                                           wDefault,
                                           pUsedDef );
                    pWCStr++;
                }
            }
            else
            {
                while (pWCStr < pEndWCStr)
                {
                    GET_SB( pWC,
                            *pWCStr,
                            pTempStr );
                    DEFAULT_CHAR_CHECK_SB( pHashN,
                                           *pWCStr,
                                           pTempStr,
                                           wDefault,
                                           pUsedDef );
                    pWCStr++;
                }
            }
        }
        else
        {
            //
            //  Multi Byte Character Code Page.
            //
            if (dwFlags & WC_NO_BEST_FIT_CHARS)
            {
                while (pWCStr < pEndWCStr)
                {
                    GET_MB( pWC,
                            *pWCStr,
                            pTempStr,
                            mbIncr,
                            FALSE );
                    ELIMINATE_BEST_FIT_MB( pHashN,
                                           *pWCStr,
                                           pTempStr,
                                           mbIncr,
                                           FALSE );
                    DEFAULT_CHAR_CHECK_MB( pHashN,
                                           *pWCStr,
                                           pTempStr,
                                           wDefault,
                                           pUsedDef,
                                           mbIncr2,
                                           FALSE );
                    mbCount += (mbIncr2) ? (mbIncr2) : (mbIncr);
                    pWCStr++;
                }
            }
            else
            {
                while (pWCStr < pEndWCStr)
                {
                    GET_MB( pWC,
                            *pWCStr,
                            pTempStr,
                            mbIncr,
                            FALSE );
                    DEFAULT_CHAR_CHECK_MB( pHashN,
                                           *pWCStr,
                                           pTempStr,
                                           wDefault,
                                           pUsedDef,
                                           mbIncr2,
                                           FALSE );
                    mbCount += (mbIncr2) ? (mbIncr2) : (mbIncr);
                    pWCStr++;
                }
            }
        }
    }
    else
    {
        //
        //  Initialize multibyte loop pointers.
        //
        pEndMBStr = pMBStr + cbMultiByte;

        //
        //  For each wide char, translate it to its corresponding
        //  multibyte char, store it in pMBStr, and increment the
        //  multibyte character count.
        //
        if (IS_SBCS_CP(pHashN))
        {
            //
            //  Single Byte Character Code Page.
            //
            mbCount = (int)(pEndWCStr - pWCStr);
            if ((pEndMBStr - pMBStr) < mbCount)
            {
                mbCount = (int)(pEndMBStr - pMBStr);
            }
            if (dwFlags & WC_NO_BEST_FIT_CHARS)
            {
                for (ctr = mbCount; ctr > 0; ctr--)
                {
                    GET_SB( pWC,
                            *pWCStr,
                            pMBStr );
                    ELIMINATE_BEST_FIT_SB( pHashN,
                                           *pWCStr,
                                           pMBStr );
                    DEFAULT_CHAR_CHECK_SB( pHashN,
                                           *pWCStr,
                                           pMBStr,
                                           wDefault,
                                           pUsedDef );
                    pWCStr++;
                    pMBStr++;
                }
            }
            else
            {
                for (ctr = mbCount; ctr > 0; ctr--)
                {
                    GET_SB( pWC,
                            *pWCStr,
                            pMBStr );
                    DEFAULT_CHAR_CHECK_SB( pHashN,
                                           *pWCStr,
                                           pMBStr,
                                           wDefault,
                                           pUsedDef );
                    pWCStr++;
                    pMBStr++;
                }
            }
        }
        else
        {
            //
            //  Multi Byte Character Code Page.
            //
            if (dwFlags & WC_NO_BEST_FIT_CHARS)
            {
                while ((pWCStr < pEndWCStr) && (pMBStr < pEndMBStr))
                {
                    GET_MB( pWC,
                            *pWCStr,
                            pMBStr,
                            mbIncr,
                            ((pMBStr + 1) < pEndMBStr) ? FALSE : TRUE );
                    ELIMINATE_BEST_FIT_MB( pHashN,
                                           *pWCStr,
                                           pMBStr,
                                           mbIncr,
                                           ((pMBStr + 1) < pEndMBStr) ? FALSE : TRUE );
                    DEFAULT_CHAR_CHECK_MB( pHashN,
                                           *pWCStr,
                                           pMBStr,
                                           wDefault,
                                           pUsedDef,
                                           mbIncr2,
                                           ((pMBStr + 1) < pEndMBStr) ? FALSE : TRUE );
                    if ((mbIncr == 0) || (mbIncr2 == -1))
                    {
                        //
                        //  Not enough room in buffer.
                        //
                        break;
                    }

                    mbCount += (mbIncr2) ? (mbIncr2) : (mbIncr);
                    pWCStr++;
                    pMBStr += mbIncr;
                }
            }
            else
            {
                while ((pWCStr < pEndWCStr) && (pMBStr < pEndMBStr))
                {
                    GET_MB( pWC,
                            *pWCStr,
                            pMBStr,
                            mbIncr,
                            ((pMBStr + 1) < pEndMBStr) ? FALSE : TRUE );
                    DEFAULT_CHAR_CHECK_MB( pHashN,
                                           *pWCStr,
                                           pMBStr,
                                           wDefault,
                                           pUsedDef,
                                           mbIncr2,
                                           ((pMBStr + 1) < pEndMBStr) ? FALSE : TRUE );
                    if ((mbIncr == 0) || (mbIncr2 == -1))
                    {
                        //
                        //  Not enough room in buffer.
                        //
                        break;
                    }

                    mbCount += (mbIncr2) ? (mbIncr2) : (mbIncr);
                    pWCStr++;
                    pMBStr += mbIncr;
                }
            }
        }

        //
        //  Make sure multibyte character buffer was large enough.
        //
        if (pWCStr < pEndWCStr)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return (0);
        }
    }

    //
    //  Return the number of characters written (or that would have
    //  been written) to the buffer.
    //
    return (mbCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetMBDefaultComp
//
//  Translates the wide character string to a multibyte string and returns
//  the number of bytes written.  This also checks for the use of the default
//  character and tries to convert composite forms to precomposed forms, so
//  the translation is a lot slower.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetMBDefaultComp(
    PCP_HASH pHashN,
    LPWSTR pWCStr,
    LPWSTR pEndWCStr,
    LPBYTE pMBStr,
    int cbMultiByte,
    WORD wDefault,
    LPBOOL pUsedDef,
    DWORD dwFlags)
{
    int mbIncr;                   // amount to increment pMBStr
    int mbCount = 0;              // count of multibyte chars written
    LPBYTE pEndMBStr;             // ptr to end of MB string buffer
    BOOL fError;                  // if error during MB conversion


    //
    //  If cbMultiByte is 0, then we can't use pMBStr.  In this
    //  case, we simply want to count the number of characters that
    //  would be written to the buffer.
    //
    if (cbMultiByte == 0)
    {
        BYTE pTempStr[2];             // tmp buffer - 2 bytes for DBCS

        //
        //  Set most significant bit of flags to indicate to the
        //  GetMBComp routine that it's using a temporary storage
        //  area, so don't back up in the buffer.
        //
        SET_MSB(dwFlags);

        //
        //  For each wide char, translate it to its corresponding multibyte
        //  char and increment the multibyte character count.
        //
        if (IS_SBCS_CP(pHashN))
        {
            //
            //  Single Byte Character Code Page.
            //
            while (pWCStr < pEndWCStr)
            {
                //
                //  Get the translation.
                //
                mbCount += GetMBCompSB( pHashN,
                                        dwFlags,
                                        pWCStr,
                                        pTempStr,
                                        mbCount,
                                        wDefault,
                                        pUsedDef );
                pWCStr++;
            }
        }
        else
        {
            //
            //  Multi Byte Character Code Page.
            //
            while (pWCStr < pEndWCStr)
            {
                //
                //  Get the translation.
                //
                mbCount += GetMBCompMB( pHashN,
                                        dwFlags,
                                        pWCStr,
                                        pTempStr,
                                        mbCount,
                                        wDefault,
                                        pUsedDef,
                                        &fError,
                                        FALSE );
                pWCStr++;
            }
        }
    }
    else
    {
        //
        //  Initialize multibyte loop pointers.
        //
        pEndMBStr = pMBStr + cbMultiByte;

        //
        //  For each wide char, translate it to its corresponding
        //  multibyte char, store it in pMBStr, and increment the
        //  multibyte character count.
        //
        if (IS_SBCS_CP(pHashN))
        {
            //
            //  Single Byte Character Code Page.
            //
            while ((pWCStr < pEndWCStr) && (pMBStr < pEndMBStr))
            {
                //
                //  Get the translation.
                //
                mbIncr = GetMBCompSB( pHashN,
                                      dwFlags,
                                      pWCStr,
                                      pMBStr,
                                      mbCount,
                                      wDefault,
                                      pUsedDef );
                pWCStr++;
                mbCount += mbIncr;
                pMBStr += mbIncr;
            }
        }
        else
        {
            //
            //  Multi Byte Character Code Page.
            //
            while ((pWCStr < pEndWCStr) && (pMBStr < pEndMBStr))
            {
                //
                //  Get the translation.
                //
                mbIncr = GetMBCompMB( pHashN,
                                      dwFlags,
                                      pWCStr,
                                      pMBStr,
                                      mbCount,
                                      wDefault,
                                      pUsedDef,
                                      &fError,
                                      ((pMBStr + 1) < pEndMBStr) ? FALSE : TRUE );
                if (fError)
                {
                    //
                    //  Not enough room in the buffer.
                    //
                    break;
                }

                pWCStr++;
                mbCount += mbIncr;
                pMBStr += mbIncr;
            }
        }

        //
        //  Make sure multibyte character buffer was large enough.
        //
        if (pWCStr < pEndWCStr)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return (0);
        }
    }

    //
    //  Return the number of characters written (or that would have
    //  been written) to the buffer.
    //
    return (mbCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetMBCompSB
//
//  Fills in pMBStr with the byte character(s) for the corresponding wide
//  character from the appropriate translation table and returns the number
//  of byte characters written to pMBStr.  This routine is only called if
//  the defaultcheck and compositecheck flags were both set.
//
//  NOTE:  Most significant bit of dwFlags parameter is used by this routine
//         to indicate that the caller only wants the count of the number of
//         characters written, not the string (ie. do not back up in buffer).
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetMBCompSB(
    PCP_HASH pHashN,
    DWORD dwFlags,
    LPWSTR pWCStr,
    LPBYTE pMBStr,
    int mbCount,
    WORD wDefault,
    LPBOOL pUsedDef)
{
    WCHAR PreComp;                // precomposed wide character


    if ((pTblPtrs->pDefaultSortkey == NULL) ||
        (!IS_NONSPACE_ONLY(pTblPtrs->pDefaultSortkey, *pWCStr)))
    {
        //
        //  Get the 1:1 translation from wide char to single byte.
        //
        GET_WC_TRANSLATION_SB( pHashN,
                               *pWCStr,
                               pMBStr,
                               wDefault,
                               pUsedDef,
                               dwFlags );
        return (1);
    }
    else
    {
        if (mbCount < 1)
        {
            //
            //  Need to handle the nonspace character by itself, since
            //  it is the first character in the string.
            //
            if (dwFlags & WC_DISCARDNS)
            {
                //
                //  Discard the non-spacing char, so just return with
                //  zero chars written.
                //
                return (0);
            }
            else if (dwFlags & WC_DEFAULTCHAR)
            {
                //
                //  Need to replace the nonspace character with the default
                //  character and return the number of characters written
                //  to the multibyte string.
                //
                *pUsedDef = TRUE;
                *pMBStr = LOBYTE(wDefault);
                return (1);
            }
            else                  // WC_SEPCHARS - default
            {
                //
                //  Get the 1:1 translation from wide char to multibyte
                //  of the non-spacing char and return the number of
                //  characters written to the multibyte string.
                //
                GET_WC_TRANSLATION_SB( pHashN,
                                       *pWCStr,
                                       pMBStr,
                                       wDefault,
                                       pUsedDef,
                                       dwFlags );
                return (1);
            }
        }
        else if (PreComp = GetPreComposedChar(*pWCStr, *(pWCStr - 1)))
        {
            //
            //  Back up in the single byte string and write the
            //  precomposed char.
            //
            if (!IS_MSB(dwFlags))
            {
                pMBStr--;
            }

            GET_WC_TRANSLATION_SB( pHashN,
                                   PreComp,
                                   pMBStr,
                                   wDefault,
                                   pUsedDef,
                                   dwFlags );
            return (0);
        }
        else
        {
            if (dwFlags & WC_DISCARDNS)
            {
                //
                //  Discard the non-spacing char, so just return with
                //  zero chars written.
                //
                return (0);
            }
            else if (dwFlags & WC_DEFAULTCHAR)
            {
                //
                //  Need to replace the base character with the default
                //  character.  Since we've already written the base
                //  translation char in the single byte string, we need to
                //  back up in the single byte string and write the default
                //  char.
                //
                if (!IS_MSB(dwFlags))
                {
                    pMBStr--;
                }

                *pUsedDef = TRUE;
                *pMBStr = LOBYTE(wDefault);
                return (0);
            }
            else                  // WC_SEPCHARS - default
            {
                //
                //  Get the 1:1 translation from wide char to multibyte
                //  of the non-spacing char and return the number of
                //  characters written to the multibyte string.
                //
                GET_WC_TRANSLATION_SB( pHashN,
                                       *pWCStr,
                                       pMBStr,
                                       wDefault,
                                       pUsedDef,
                                       dwFlags );
                return (1);
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  GetMBCompMB
//
//  Fills in pMBStr with the byte character(s) for the corresponding wide
//  character from the appropriate translation table and returns the number
//  of byte characters written to pMBStr.  This routine is only called if
//  the defaultcheck and compositecheck flags were both set.
//
//  If the buffer was too small, the fError flag will be set to TRUE.
//
//  NOTE:  Most significant bit of dwFlags parameter is used by this routine
//         to indicate that the caller only wants the count of the number of
//         characters written, not the string (ie. do not back up in buffer).
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetMBCompMB(
    PCP_HASH pHashN,
    DWORD dwFlags,
    LPWSTR pWCStr,
    LPBYTE pMBStr,
    int mbCount,
    WORD wDefault,
    LPBOOL pUsedDef,
    BOOL *fError,
    BOOL fOnlyOne)
{
    WCHAR PreComp;                // precomposed wide character
    BYTE pTmpSp[2];               // temp space - 2 bytes for DBCS
    int nCnt;                     // number of characters written


    *fError = FALSE;
    if ((pTblPtrs->pDefaultSortkey == NULL) ||
        (!IS_NONSPACE_ONLY(pTblPtrs->pDefaultSortkey, *pWCStr)))
    {
        //
        //  Get the 1:1 translation from wide char to multibyte.
        //  This also handles DBCS and returns the number of characters
        //  written to the multibyte string.
        //
        GET_WC_TRANSLATION_MB( pHashN,
                               *pWCStr,
                               pMBStr,
                               wDefault,
                               pUsedDef,
                               nCnt,
                               fOnlyOne,
                               dwFlags );
        if (nCnt == 0)
        {
            *fError = TRUE;
        }
        return (nCnt);
    }
    else
    {
        if (mbCount < 1)
        {
            //
            //  Need to handle the nonspace character by itself, since
            //  it is the first character in the string.
            //
            if (dwFlags & WC_DISCARDNS)
            {
                //
                //  Discard the non-spacing char, so just return with
                //  zero chars written.
                //
                return (0);
            }
            else if (dwFlags & WC_DEFAULTCHAR)
            {
                //
                //  Need to replace the nonspace character with the default
                //  character and return the number of characters written
                //  to the multibyte string.
                //
                *pUsedDef = TRUE;
                COPY_MB_CHAR( wDefault,
                              pMBStr,
                              nCnt,
                              fOnlyOne );
                if (nCnt == 0)
                {
                    *fError = TRUE;
                }
                return (nCnt);
            }
            else                  // WC_SEPCHARS - default
            {
                //
                //  Get the 1:1 translation from wide char to multibyte
                //  of the non-spacing char and return the number of
                //  characters written to the multibyte string.
                //
                GET_WC_TRANSLATION_MB( pHashN,
                                       *pWCStr,
                                       pMBStr,
                                       wDefault,
                                       pUsedDef,
                                       nCnt,
                                       fOnlyOne,
                                       dwFlags );
                if (nCnt == 0)
                {
                    *fError = TRUE;
                }
                return (nCnt);
            }

        }
        else if (PreComp = GetPreComposedChar(*pWCStr, *(pWCStr - 1)))
        {
            //
            //  Get the 1:1 translation from wide char to multibyte
            //  of the precomposed char, back up in the multibyte string,
            //  write the precomposed char, and return the DIFFERENCE of
            //  the number of characters written to the the multibyte
            //  string.
            //
            GET_WC_TRANSLATION_MB( pHashN,
                                   *(pWCStr - 1),
                                   pTmpSp,
                                   wDefault,
                                   pUsedDef,
                                   nCnt,
                                   fOnlyOne,
                                   dwFlags );
            if (nCnt == 0)
            {
                *fError = TRUE;
                return (nCnt);
            }

            if (!IS_MSB(dwFlags))
            {
                pMBStr -= nCnt;
            }

            GET_WC_TRANSLATION_MB( pHashN,
                                   PreComp,
                                   pMBStr,
                                   wDefault,
                                   pUsedDef,
                                   mbCount,
                                   fOnlyOne,
                                   dwFlags );
            if (mbCount == 0)
            {
                *fError = TRUE;
            }
            return (mbCount - nCnt);
        }
        else
        {
            if (dwFlags & WC_DISCARDNS)
            {
                //
                //  Discard the non-spacing char, so just return with
                //  zero chars written.
                //
                return (0);
            }
            else if (dwFlags & WC_DEFAULTCHAR)
            {
                //
                //  Need to replace the base character with the default
                //  character.  Since we've already written the base
                //  translation char in the multibyte string, we need to
                //  back up in the multibyte string and return the
                //  DIFFERENCE of the number of characters written
                //  (could be negative).
                //

                //
                //  If the previous character written is the default
                //  character, then the base character for this nonspace
                //  character has already been replaced.  Simply throw
                //  this character away and return zero chars written.
                //
                if (!IS_MSB(dwFlags))
                {
                    //
                    //  Not using a temporary buffer, so find out if the
                    //  previous character translated was the default char.
                    //
                    if ((MAKEWORD(*(pMBStr - 1), 0) == wDefault) ||
                        ((mbCount > 1) &&
                         (MAKEWORD(*(pMBStr - 1), *(pMBStr - 2)) == wDefault)))
                    {
                        return (0);
                    }
                }
                else
                {
                    //
                    //  Using a temporary buffer.  The temp buffer is 2 bytes
                    //  in length and contains the previous character written.
                    //
                    if ((MAKEWORD(*pMBStr, 0) == wDefault) ||
                        ((mbCount > 1) &&
                         (MAKEWORD(*pMBStr, *(pMBStr + 1)) == wDefault)))
                    {
                        return (0);
                    }
                }

                //
                //  Get the 1:1 translation from wide char to multibyte
                //  of the base char, back up in the multibyte string,
                //  write the default char, and return the DIFFERENCE of
                //  the number of characters written to the the multibyte
                //  string.
                //
                GET_WC_TRANSLATION_MB( pHashN,
                                       *(pWCStr - 1),
                                       pTmpSp,
                                       wDefault,
                                       pUsedDef,
                                       nCnt,
                                       fOnlyOne,
                                       dwFlags );
                if (nCnt == 0)
                {
                    *fError = TRUE;
                    return (nCnt);
                }

                if (!IS_MSB(dwFlags))
                {
                    pMBStr -= nCnt;
                }

                *pUsedDef = TRUE;
                COPY_MB_CHAR( wDefault,
                              pMBStr,
                              mbCount,
                              fOnlyOne );
                if (mbCount == 0)
                {
                    *fError = TRUE;
                }
                return (mbCount - nCnt);
            }
            else                  // WC_SEPCHARS - default
            {
                //
                //  Get the 1:1 translation from wide char to multibyte
                //  of the non-spacing char and return the number of
                //  characters written to the multibyte string.
                //
                GET_WC_TRANSLATION_MB( pHashN,
                                       *pWCStr,
                                       pMBStr,
                                       wDefault,
                                       pUsedDef,
                                       nCnt,
                                       fOnlyOne,
                                       dwFlags );
                if (nCnt == 0)
                {
                    *fError = TRUE;
                }
                return (nCnt);
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  GetMacCodePage
//
//  Returns the system default Mac code page.
//
//  09-22-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

UINT GetMacCodePage()
{
    PKEY_VALUE_FULL_INFORMATION pKeyValueFull;   // ptr to query information
    BYTE pStatic[MAX_KEY_VALUE_FULLINFO];        // ptr to static buffer
    UNICODE_STRING ObUnicodeStr;                 // unicode string
    UINT CodePage;                               // code page value
    PCP_HASH pHashN;                             // ptr to hash node


    //
    //  See if the Mac code page globals have been initialized yet.
    //  If they have, return the mac code page value.
    //
    if (gMacCodePage != 0)
    {
        return (gMacCodePage);
    }

    //
    //  Make sure code page key is open.
    //
    OPEN_CODEPAGE_KEY(NLS_DEFAULT_MACCP);

    //
    //  Query the registry for the Mac CP value.
    //
    CodePage = 0;
    pKeyValueFull = (PKEY_VALUE_FULL_INFORMATION)pStatic;
    if ((QueryRegValue( hCodePageKey,
                        NLS_VALUE_MACCP,
                        &pKeyValueFull,
                        MAX_KEY_VALUE_FULLINFO,
                        NULL )) == NO_ERROR)
    {
        //
        //  Convert the value to an integer.
        //
        RtlInitUnicodeString(&ObUnicodeStr, GET_VALUE_DATA_PTR(pKeyValueFull));
        if (RtlUnicodeStringToInteger(&ObUnicodeStr, 10, (PULONG)&CodePage))
        {
            CodePage = 0;
        }
    }

    //
    //  Make sure the CodePage value was set.
    //
    if (CodePage == 0)
    {
        //
        //  Registry value is corrupt, so use default Mac code page.
        //
        CodePage = NLS_DEFAULT_MACCP;
    }

    //
    //  Get the hash node for the Mac code page.
    //
    pHashN = GetCPHashNode(CodePage);

    //
    //  Make sure the Mac hash node is valid.
    //
    if (pHashN == NULL)
    {
        //
        //  Invalid hash node, which means either the registry is
        //  corrupt, or setup failed to install a file.  Use the
        //  Ansi code page values.
        //
        CodePage = gAnsiCodePage;
        pHashN = gpACPHashN;
    }

    //
    //  Set the final MAC CP values.
    //
    RtlEnterCriticalSection(&gcsTblPtrs);

    if (gMacCodePage == 0)
    {
        gpMACCPHashN = pHashN;
        gMacCodePage = CodePage;
    }

    RtlLeaveCriticalSection(&gcsTblPtrs);

    //
    //  Return the Mac code page value.
    //
    return (gMacCodePage);
}


////////////////////////////////////////////////////////////////////////////
//
//  SpecialMBToWC
//
//  Maps a multibyte character string to its wide character string
//  counterpart.
//
//  08-21-95    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int SpecialMBToWC(
    PCP_HASH pHashN,
    DWORD dwFlags,
    LPCSTR lpMultiByteStr,
    int cbMultiByte,
    LPWSTR lpWideCharStr,
    int cchWideChar)
{
    register LPBYTE pMBStr;       // ptr to search through MB string
    register LPWSTR pWCStr;       // ptr to search through WC string
    LPBYTE pEndMBStr;             // ptr to end of MB search string
    LPWSTR pEndWCStr;             // ptr to end of WC string buffer
    int mbIncr;                   // amount to increment pMBStr
    int wcCount = 0;              // count of wide chars written
    PMB_TABLE pMBTbl;             // ptr to MB table
    int ctr;                      // loop counter


    //
    //  Initialize multibyte character loop pointers.
    //
    pMBStr = (LPBYTE)lpMultiByteStr;
    pEndMBStr = pMBStr + cbMultiByte;

    //
    //  Get the MB table.
    //
    pMBTbl = pHashN->pMBTbl;

    //
    //  If cchWideChar is 0, then we can't use lpWideCharStr.  In this
    //  case, we simply want to count the number of characters that would
    //  be written to the buffer.
    //
    if (cchWideChar == 0)
    {
        //
        //  For each multibyte char, translate it to its corresponding
        //  wide char and increment the wide character count.
        //
        if (IS_SBCS_CP(pHashN))
        {
            //
            //  Single Byte Character Code Page.
            //
            wcCount = (int)(pEndMBStr - pMBStr);
        }
        else
        {
            //
            //  Multi Byte Character Code Page.
            //
            WCHAR pTempStr[MAX_COMPOSITE];   // tmp buffer

            pEndWCStr = pTempStr + MAX_COMPOSITE;
            while (pMBStr < pEndMBStr)
            {
                GET_WC_MULTI( pHashN,
                              pMBTbl,
                              pMBStr,
                              pEndMBStr,
                              pTempStr,
                              pEndWCStr,
                              mbIncr );
                pMBStr += mbIncr;
                wcCount++;
            }
        }
    }
    else
    {
        //
        //  Initialize wide character loop pointers.
        //
        pWCStr = lpWideCharStr;
        pEndWCStr = pWCStr + cchWideChar;

        //
        //  For each multibyte char, translate it to its corresponding
        //  wide char, store it in lpWideCharStr, and increment the wide
        //  character count.
        //
        if (IS_SBCS_CP(pHashN))
        {
            //
            //  Single Byte Character Code Page.
            //
            wcCount = (int)(pEndMBStr - pMBStr);
            if ((pEndWCStr - pWCStr) < wcCount)
            {
                wcCount = (int)(pEndWCStr - pWCStr);
            }

            if (dwFlags & MB_INVALID_CHAR_CHECK)
            {
                //
                //  Error check flag is set.
                //
                for (ctr = wcCount; ctr > 0; ctr--)
                {
                    GET_WC_SINGLE_SPECIAL( pHashN,
                                           pMBTbl,
                                           pMBStr,
                                           pWCStr );
                    pMBStr++;
                    pWCStr++;
                }
            }
            else
            {
                //
                //  Error check flag is NOT set.
                //
                for (ctr = wcCount; ctr > 0; ctr--)
                {
                    GET_WC_SINGLE( pMBTbl,
                                   pMBStr,
                                   pWCStr );
                    pMBStr++;
                    pWCStr++;
                }
            }
        }
        else
        {
            //
            //  Multi Byte Character Code Page.
            //
            if (dwFlags & MB_INVALID_CHAR_CHECK)
            {
                //
                //  Error check flag is set.
                //
                while ((pMBStr < pEndMBStr) && (pWCStr < pEndWCStr))
                {
                    GET_WC_MULTI_ERR_SPECIAL( pHashN,
                                              pMBTbl,
                                              pMBStr,
                                              pEndMBStr,
                                              pWCStr,
                                              pEndWCStr,
                                              mbIncr );
                    pMBStr += mbIncr;
                    pWCStr++;
                }
                wcCount = (int)(pWCStr - lpWideCharStr);
            }
            else
            {
                //
                //  Error check flag is NOT set.
                //
                while ((pMBStr < pEndMBStr) && (pWCStr < pEndWCStr))
                {
                    GET_WC_MULTI( pHashN,
                                  pMBTbl,
                                  pMBStr,
                                  pEndMBStr,
                                  pWCStr,
                                  pEndWCStr,
                                  mbIncr );
                    pMBStr += mbIncr;
                    pWCStr++;
                }
                wcCount = (int)(pWCStr - lpWideCharStr);
            }
        }

        //
        //  Make sure wide character buffer was large enough.
        //
        if (pMBStr < pEndMBStr)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return (0);
        }
    }

    //
    //  Return the number of characters written (or that would have
    //  been written) to the buffer.
    //
    return (wcCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\security.c ===
/*++

Copyright (c) 1991-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    security.c

Abstract:

    This file handles the management of the NLS per-thread and process cache.
    The cache is only established when hitting an API that needs it. The process
    NLS cache is used when accessing NLS info for a process NOT running in the
    context of the interactive logged on user. The per-thread NLS cache is used
    when accssing NLS info and the thread is doing a user impersonation.

    External Routines found in this file:
      NlsFlushProcessCache
      NlsGetCurrentUserNlsInfo
      NlsIsInteractiveUserProcess
      NlsCheckForInteractiveUser
      NlsGetUserLocale

Revision History:

    03-29-1999    SamerA    Created.

--*/



//
//  Include Files.
//

#include "nls.h"




//
//  Global Variables.
//

//
//  Process Nls Cache.
//
PNLS_LOCAL_CACHE gpNlsProcessCache;

//
//  Whether the current running process is the same as the
//  interactive logged on user.
//
BOOL gInteractiveLogonUserProcess = (BOOL)-1;




//
//  Forward Declarations.
//

NTSTATUS FASTCALL
NlsGetCacheBuffer(
    PNLS_USER_INFO pNlsUserInfo,
    LCTYPE LCType,
    PWSTR *ppCache);

void FASTCALL
NlsInvalidateCache(
    PNLS_USER_INFO pNlsUserInfo);





//-------------------------------------------------------------------------//
//                           EXTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  NlsFlushProcessCache
//
//  Invalidates an entry in the NLS process cache.
//
//  05-22-99     SamerA     Created.
////////////////////////////////////////////////////////////////////////////

NTSTATUS NlsFlushProcessCache(
    LCTYPE LCType)
{
    PWSTR pOutputCache;
    NTSTATUS NtStatus = STATUS_SUCCESS;


    //
    //  If there is no thread impersonation, then flush the
    //  process entry cache.
    //
    if (NtCurrentTeb()->IsImpersonating != 0)
    {
        return (NtStatus);
    }

    if (gpNlsProcessCache)
    {
        NtStatus = NlsGetCacheBuffer( &gpNlsProcessCache->NlsInfo,
                                      LCType,
                                      &pOutputCache );
        if (NT_SUCCESS(NtStatus))
        {
            RtlEnterCriticalSection(&gcsNlsProcessCache);

            pOutputCache[0] = NLS_INVALID_INFO_CHAR;

            RtlLeaveCriticalSection(&gcsNlsProcessCache);
        }
    }

    return (NtStatus);
}


////////////////////////////////////////////////////////////////////////////
//
//  NlsGetCurrentUserNlsInfo
//
//  Retreive the NLS info correponding to the current security context.
//
//  03-29-99     SamerA     Created.
////////////////////////////////////////////////////////////////////////////

NTSTATUS NlsGetCurrentUserNlsInfo(
    LCID Locale,
    LCTYPE LCType,
    PWSTR RegistryValue,
    PWSTR pOutputBuffer,
    BOOL IgnoreLocaleValue)
{
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;
    PNLS_LOCAL_CACHE pNlsThreadCache;
    PWSTR pOutputCache;

    //
    //  Possible NtCurrentTeb()->IsImpersonating values :
    //
    //  0  : Thread isn't impersonating any user.
    //
    //  1  : Thread has just started to do impersonation.
    //       Per thread cache needs to be allocated now.
    //
    //  2  : Thread is calling the NLS apis while its
    //       a context other than the interactive logged on user.
    //
    switch (NtCurrentTeb()->IsImpersonating)
    {
        case ( 0 ) :
        {
            //
            //  Thread is NOT impersonating any user. We check if the process
            //  belongs to the interactive user, then we retreive the info from
            //  the NLS cache in CSR.  Otherwise if the process is running in
            //  the context of a different user, then we retreive the NLS info
            //  from the process cache.
            //
            if (gInteractiveLogonUserProcess == (BOOL)-1)
            {
                NlsIsInteractiveUserProcess();
            }

            if (gInteractiveLogonUserProcess == FALSE)
            {
                if ((IgnoreLocaleValue) ||
                    (GetUserDefaultLCID() == Locale))
                {
                    if (!gpNlsProcessCache)
                    {
                        //
                        //  Allocate and invalidate the NLS process cache.
                        //
                        RtlEnterCriticalSection(&gcsNlsProcessCache);

                        if (!gpNlsProcessCache)
                        {
                            gpNlsProcessCache = RtlAllocateHeap(
                                                     RtlProcessHeap(),
                                                     0,
                                                     sizeof(NLS_LOCAL_CACHE) );
                            if (gpNlsProcessCache)
                            {
                                NlsInvalidateCache(&gpNlsProcessCache->NlsInfo);
                                gpNlsProcessCache->CurrentUserKeyHandle = NULL;
                            }
                        }

                        RtlLeaveCriticalSection(&gcsNlsProcessCache);
                    }

                    if (gpNlsProcessCache)
                    {
                        NtStatus = NlsGetCacheBuffer( &gpNlsProcessCache->NlsInfo,
                                                      LCType,
                                                      &pOutputCache );
                        if (NT_SUCCESS(NtStatus))
                        {
                            //
                            //  See if it is a valid cache.
                            //
                            if (pOutputCache[0] == NLS_INVALID_INFO_CHAR)
                            {
                                RtlEnterCriticalSection(&gcsNlsProcessCache);

                                if (GetUserInfoFromRegistry( RegistryValue,
                                                             pOutputCache, 0 ) == FALSE)
                                {
                                    NtStatus = STATUS_UNSUCCESSFUL;
                                    pOutputCache[0] = NLS_INVALID_INFO_CHAR;
                                }

                                RtlLeaveCriticalSection(&gcsNlsProcessCache);
                            }

                            if (NT_SUCCESS(NtStatus))
                            {
                                NlsStrCpyW(pOutputBuffer, pOutputCache);
                            }
                        }
                    }
                }
            }
            break;
        }
        case ( 1 ) :
        {
            //
            //  Thread started to do impersonation.
            //
            pNlsThreadCache = NtCurrentTeb()->NlsCache;

            if (!pNlsThreadCache)
            {
                pNlsThreadCache = RtlAllocateHeap( RtlProcessHeap(),
                                                   0,
                                                   sizeof(NLS_LOCAL_CACHE) );
                if (pNlsThreadCache)
                {
                    pNlsThreadCache->CurrentUserKeyHandle = NULL;
                }

                NtCurrentTeb()->NlsCache = (PVOID) pNlsThreadCache;
            }

            if (pNlsThreadCache)
            {
                NlsInvalidateCache(&pNlsThreadCache->NlsInfo);
            }

            NtCurrentTeb()->IsImpersonating = 2;

            //
            //  Fall Thru...
            //
        }
        case ( 2 ) :
        {
            //
            //  Thread is impersonating a particular user.
            //
            pNlsThreadCache = NtCurrentTeb()->NlsCache;

            if (pNlsThreadCache)
            {

                if ((IgnoreLocaleValue) ||
                    (GetUserDefaultLCID() == Locale))
                {
                    NtStatus = NlsGetCacheBuffer( &pNlsThreadCache->NlsInfo,
                                                  LCType,
                                                  &pOutputCache );
                    if (NT_SUCCESS(NtStatus))
                    {
                        if (pOutputCache[0] == NLS_INVALID_INFO_CHAR)
                        {
                            //
                            //  Don't cache key handles - this will break
                            //  profile unload.
                            //
                            OPEN_CPANEL_INTL_KEY( pNlsThreadCache->CurrentUserKeyHandle,
                                                  STATUS_UNSUCCESSFUL,
                                                  KEY_READ );

                            NtStatus = NlsQueryCurrentUserInfo( pNlsThreadCache,
                                                                RegistryValue,
                                                                pOutputCache );

                            CLOSE_REG_KEY(pNlsThreadCache->CurrentUserKeyHandle);

                            if (!NT_SUCCESS(NtStatus))
                            {
                                pOutputCache[0] = NLS_INVALID_INFO_CHAR;
                            }
                        }

                        if (NT_SUCCESS(NtStatus))
                        {
                            NlsStrCpyW(pOutputBuffer, pOutputCache);
                        }
                    }
                }
            }
            break;
        }
    }

    return (NtStatus);
}


////////////////////////////////////////////////////////////////////////////
//
//  NlsIsInteractiveUserProcess
//
//  Read the process's authetication id out of its access token object and
//  cache it since it never changes.
//
//  12-27-98     SamerA     Created.
////////////////////////////////////////////////////////////////////////////

NTSTATUS NlsIsInteractiveUserProcess()
{
    NTSTATUS NtStatus;
    TOKEN_STATISTICS TokenInformation;
    HANDLE TokenHandle;
    ULONG BytesRequired;
    BOOL IsInteractiveProcess = TRUE;


    //
    //  Get the process access token.
    //
    NtStatus = NtOpenProcessToken( NtCurrentProcess(),
                                   TOKEN_QUERY,
                                   &TokenHandle );
    if (NT_SUCCESS(NtStatus))
    {
        //
        //  Get the LUID.
        //
        NtStatus = NtQueryInformationToken( TokenHandle,
                                            TokenStatistics,
                                            &TokenInformation,
                                            sizeof(TokenInformation),
                                            &BytesRequired );
        if (NT_SUCCESS(NtStatus))
        {
            if (RtlEqualLuid( &pNlsUserInfo->InteractiveUserLuid,
                              &TokenInformation.AuthenticationId ) == FALSE)
            {
                IsInteractiveProcess = FALSE;
            }
        }

        NtClose(TokenHandle);
    }

    gInteractiveLogonUserProcess = IsInteractiveProcess;

    return (NtStatus);
}


////////////////////////////////////////////////////////////////////////////
//
//  NlsCheckForInteractiveUser
//
//  This function makes sure that the current thread isn't impersonating
//  anybody, but the interactive.  It compares the authentication-id of the
//  interactive user -cached in CSRSS at logon time- with the
//  authentication-id of the current thread or process.  It returns failure
//  ONLY if the current security context -session- isn't the same as the
//  interactive logged-on user.
//
//  12-16-98     SamerA     Created.
////////////////////////////////////////////////////////////////////////////

NTSTATUS NlsCheckForInteractiveUser()
{
    NTSTATUS NtStatus, ReturnStatus = STATUS_SUCCESS;
    TOKEN_STATISTICS TokenInformation;
    HANDLE TokenHandle;
    ULONG BytesRequired;
    PLUID InteractiveUserLuid = &pNlsUserInfo->InteractiveUserLuid;


    //
    //  Get the Token Handle.
    //  Fast optimization to detect if a thread hasn't started to do any
    //  impersonation, which is the case for most GUI user apps.
    //
    if (NtCurrentTeb()->IsImpersonating == 0)
    {
        NtStatus = STATUS_NO_TOKEN;
    }
    else
    {
        NtStatus = NtOpenThreadToken( NtCurrentThread(),
                                      TOKEN_QUERY,
                                      FALSE,
                                      &TokenHandle );
    }

    if (!NT_SUCCESS(NtStatus))
    {
        if (NtStatus != STATUS_NO_TOKEN)
        {
            KdPrint(("NLSAPI: Couldn't retreive thread token - %lx.\n", NtStatus));
            return (STATUS_SUCCESS);
        }

        //
        //  Get the process access token.
        //
        if (gInteractiveLogonUserProcess == (BOOL)-1)
        {
            NtStatus = NlsIsInteractiveUserProcess();

            if (!NT_SUCCESS(NtStatus))
            {
                KdPrint(("NLSAPI: Couldn't retreive process token - %lx\n", NtStatus));
                return (STATUS_SUCCESS);
            }
        }

        if (gInteractiveLogonUserProcess == FALSE)
        {
            ReturnStatus = STATUS_UNSUCCESSFUL;
        }
    }
    else
    {
        //
        //  Get the AuthenticationId of the current thread's security context.
        //
        NtStatus = NtQueryInformationToken( TokenHandle,
                                            TokenStatistics,
                                            &TokenInformation,
                                            sizeof(TokenInformation),
                                            &BytesRequired );

        //
        //  Close the thread token here.
        //
        NtClose(TokenHandle);

        if (NT_SUCCESS(NtStatus))
        {
            if (RtlEqualLuid( InteractiveUserLuid,
                              &TokenInformation.AuthenticationId ) == FALSE)
            {
                ReturnStatus = STATUS_UNSUCCESSFUL;
            }
        }
    }

    return (ReturnStatus);
}


////////////////////////////////////////////////////////////////////////////
//
//  NlsGetUserLocale
//
//  Retreives the user locale from the registry of the current security
//  context.  It is called ONLY when the running security context is
//  different from the interactive logged-on security context-(user).
//
//  12-16-98     SamerA     Created.
////////////////////////////////////////////////////////////////////////////

NTSTATUS NlsGetUserLocale(
    LCID *Lcid)
{
    NTSTATUS NtStatus;
    WCHAR wszLocale[MAX_REG_VAL_SIZE];
    UNICODE_STRING ObLocaleString;
    PNLS_LOCAL_CACHE pNlsCache = NtCurrentTeb()->NlsCache;


    //
    //  Get the current user locale.
    //
    NtStatus = NlsGetCurrentUserNlsInfo( LOCALE_USER_DEFAULT,
                                         (LCTYPE)LOCALE_SLOCALE,
                                         L"Locale",
                                         wszLocale,
                                         TRUE );
    if ((NT_SUCCESS(NtStatus)) ||
        (GetUserInfoFromRegistry(L"Locale", wszLocale, 0)))
    {
        RtlInitUnicodeString(&ObLocaleString, wszLocale);
        NtStatus = RtlUnicodeStringToInteger( &ObLocaleString,
                                              16,
                                              (PULONG)Lcid);
    }

    return (NtStatus);
}





//-------------------------------------------------------------------------//
//                           INTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//

////////////////////////////////////////////////////////////////////////////
//
//  NlsGetCacheBuffer
//
//  Get a buffer pointer inside the cache for this LCTYPE.
//
//  03-29-99     SamerA     Created.
////////////////////////////////////////////////////////////////////////////

NTSTATUS FASTCALL NlsGetCacheBuffer(
    PNLS_USER_INFO pNlsUserInfo,
    LCTYPE LCType,
    PWSTR *ppCache)
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    switch (LCType)
    {
        case ( LOCALE_SLANGUAGE ) :
        {
            *ppCache = pNlsUserInfo->sAbbrevLangName;
            break;
        }
        case ( LOCALE_ICOUNTRY ) :
        {
            *ppCache = pNlsUserInfo->iCountry;
            break;
        }
        case ( LOCALE_SCOUNTRY ) :
        {
            *ppCache = pNlsUserInfo->sCountry;
            break;
        }
        case ( LOCALE_SLIST ) :
        {
            *ppCache = pNlsUserInfo->sList;
            break;
        }
        case ( LOCALE_IMEASURE ) :
        {
            *ppCache = pNlsUserInfo->iMeasure;
            break;
        }
        case ( LOCALE_IPAPERSIZE ) :
        {
            *ppCache = pNlsUserInfo->iPaperSize;
            break;
        }
        case ( LOCALE_SDECIMAL ) :
        {
            *ppCache = pNlsUserInfo->sDecimal;
            break;
        }
        case ( LOCALE_STHOUSAND ) :
        {
            *ppCache = pNlsUserInfo->sThousand;
            break;
        }
        case ( LOCALE_SGROUPING ) :
        {
            *ppCache = pNlsUserInfo->sGrouping;
            break;
        }
        case ( LOCALE_IDIGITS ) :
        {
            *ppCache = pNlsUserInfo->iDigits;
            break;
        }
        case ( LOCALE_ILZERO ) :
        {
            *ppCache = pNlsUserInfo->iLZero;
            break;
        }
        case ( LOCALE_INEGNUMBER ) :
        {
            *ppCache = pNlsUserInfo->iNegNumber;
            break;
        }
        case ( LOCALE_SNATIVEDIGITS ) :
        {
            *ppCache = pNlsUserInfo->sNativeDigits;
            break;
        }
        case ( LOCALE_IDIGITSUBSTITUTION ) :
        {
            *ppCache = pNlsUserInfo->iDigitSubstitution;
            break;
        }
        case ( LOCALE_SCURRENCY ) :
        {
            *ppCache = pNlsUserInfo->sCurrency;
            break;
        }
        case ( LOCALE_SMONDECIMALSEP ) :
        {
            *ppCache = pNlsUserInfo->sMonDecSep;
            break;
        }
        case ( LOCALE_SMONTHOUSANDSEP ) :
        {
            *ppCache = pNlsUserInfo->sMonThouSep;
            break;
        }
        case ( LOCALE_SMONGROUPING ) :
        {
            *ppCache = pNlsUserInfo->sMonGrouping;
            break;
        }
        case ( LOCALE_ICURRDIGITS ) :
        {
            *ppCache = pNlsUserInfo->iCurrDigits;
            break;
        }
        case ( LOCALE_ICURRENCY ) :
        {
            *ppCache = pNlsUserInfo->iCurrency;
            break;
        }
        case ( LOCALE_INEGCURR ) :
        {
            *ppCache = pNlsUserInfo->iNegCurr;
            break;
        }
        case ( LOCALE_SPOSITIVESIGN ) :
        {
            *ppCache = pNlsUserInfo->sPosSign;
            break;
        }
        case ( LOCALE_SNEGATIVESIGN ) :
        {
            *ppCache = pNlsUserInfo->sNegSign;
            break;
        }
        case ( LOCALE_STIMEFORMAT ) :
        {
            *ppCache = pNlsUserInfo->sTimeFormat;
            break;
        }
        case ( LOCALE_STIME ) :
        {
            *ppCache = pNlsUserInfo->sTime;
            break;
        }
        case ( LOCALE_ITIME ) :
        {
            *ppCache = pNlsUserInfo->iTime;
            break;
        }
        case ( LOCALE_ITLZERO ) :
        {
            *ppCache = pNlsUserInfo->iTLZero;
            break;
        }
        case ( LOCALE_ITIMEMARKPOSN ) :
        {
            *ppCache = pNlsUserInfo->iTimeMarkPosn;
            break;
        }
        case ( LOCALE_S1159 ) :
        {
            *ppCache = pNlsUserInfo->s1159;
            break;
        }
        case ( LOCALE_S2359 ) :
        {
            *ppCache = pNlsUserInfo->s2359;
            break;
        }
        case ( LOCALE_SSHORTDATE ) :
        {
            *ppCache = pNlsUserInfo->sShortDate;
            break;
        }
        case ( LOCALE_SDATE ) :
        {
            *ppCache = pNlsUserInfo->sDate;
            break;
        }
        case ( LOCALE_IDATE ) :
        {
            *ppCache = pNlsUserInfo->iDate;
            break;
        }
        case ( LOCALE_SYEARMONTH ) :
        {
            *ppCache = pNlsUserInfo->sYearMonth;
            break;
        }
        case ( LOCALE_SLONGDATE ) :
        {
            *ppCache = pNlsUserInfo->sLongDate;
            break;
        }
        case ( LOCALE_ICALENDARTYPE ) :
        {
            *ppCache = pNlsUserInfo->iCalType;
            break;
        }
        case ( LOCALE_IFIRSTDAYOFWEEK ) :
        {
            *ppCache = pNlsUserInfo->iFirstDay;
            break;
        }
        case ( LOCALE_IFIRSTWEEKOFYEAR ) :
        {
            *ppCache = pNlsUserInfo->iFirstWeek;
            break;
        }
        case ( LOCALE_SLOCALE ) :
        {
            *ppCache = pNlsUserInfo->sLocale;
            break;
        }
        default :
        {
            NtStatus = STATUS_UNSUCCESSFUL;
            break;
        }
    }

    return (NtStatus);
}


////////////////////////////////////////////////////////////////////////////
//
//  NlsQueryCurrentUserInfo
//
//  Retreive the NLS info from the registry using a cached key.
//
//  04-07-99     SamerA     Created.
////////////////////////////////////////////////////////////////////////////

NTSTATUS NlsQueryCurrentUserInfo(
    PNLS_LOCAL_CACHE pNlsCache,
    LPWSTR pValue,
    LPWSTR pOutput)
{
    PKEY_VALUE_FULL_INFORMATION pKeyValueFull;   // ptr to query info
    BYTE pStatic[MAX_KEY_VALUE_FULLINFO];        // ptr to static buffer
    ULONG rc;


    //
    //  Initialize the output string.
    //
    *pOutput = 0;

    //
    //  Query the registry value.
    //
    pKeyValueFull = (PKEY_VALUE_FULL_INFORMATION)pStatic;
    rc = QueryRegValue( pNlsCache->CurrentUserKeyHandle,
                        pValue,
                        &pKeyValueFull,
                        MAX_KEY_VALUE_FULLINFO,
                        NULL );

    //
    //  If the query failed or if the output buffer is not large enough,
    //  then return failure.
    //
    if ((rc != NO_ERROR) ||
        (pKeyValueFull->DataLength > (MAX_REG_VAL_SIZE * sizeof(WCHAR))))
    {
        return (STATUS_UNSUCCESSFUL);
    }

    //
    //  Save the string in pOutput.
    //
    NlsStrCpyW(pOutput, GET_VALUE_DATA_PTR(pKeyValueFull));

    //
    //  Return success.
    //
    return (STATUS_SUCCESS);
}


////////////////////////////////////////////////////////////////////////////
//
//  NlsInvalidateCache
//
//  Invalidate an NLS Cache.
//
//  03-29-99     SamerA     Created.
////////////////////////////////////////////////////////////////////////////

void FASTCALL NlsInvalidateCache(
    PNLS_USER_INFO pNlsUserInfo)
{
    pNlsUserInfo->sAbbrevLangName[0]    = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->iCountry[0]           = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sCountry[0]           = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sList[0]              = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->iMeasure[0]           = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->iPaperSize[0]         = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sDecimal[0]           = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sThousand[0]          = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sGrouping[0]          = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->iDigits[0]            = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->iLZero[0]             = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->iNegNumber[0]         = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sNativeDigits[0]      = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->iDigitSubstitution[0] = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sCurrency[0]          = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sMonDecSep[0]         = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sMonThouSep[0]        = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sMonGrouping[0]       = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->iCurrDigits[0]        = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->iCurrency[0]          = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->iNegCurr[0]           = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sPosSign[0]           = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sNegSign[0]           = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sTimeFormat[0]        = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sTime[0]              = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->iTime[0]              = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->iTLZero[0]            = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->iTimeMarkPosn[0]      = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->s1159[0]              = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->s2359[0]              = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sShortDate[0]         = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sDate[0]              = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->iDate[0]              = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sYearMonth[0]         = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sLongDate[0]          = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->iCalType[0]           = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->iFirstDay[0]          = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->iFirstWeek[0]         = NLS_INVALID_INFO_CHAR;
    pNlsUserInfo->sLocale[0]            = NLS_INVALID_INFO_CHAR;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\section.c ===
/*++

Copyright (c) 1991-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    section.c

Abstract:

    This file contains functions that deal with creating, opening, or
    mapping a section for data table files for the NLS API.

    External Routines found in this file:
      CreateNlsObjectDirectory
      CreateRegKey
      OpenRegKey
      QueryRegValue
      SetRegValue
      CreateSectionFromReg
      CreateSectionOneValue
      CreateSectionTemp
      OpenSection
      MapSection
      UnMapSection
      GetNlsSectionName
      GetCodePageDLLPathName

Revision History:

    05-31-91    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nls.h"




//
//  Forward Declarations.
//

ULONG
OpenDataFile(
    HANDLE *phFile,
    LPWSTR pFile);

ULONG
GetNTFileName(
    LPWSTR pFile,
    PUNICODE_STRING pFileName);

ULONG
CreateNlsSecurityDescriptor(
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    UINT                 SecurityDescriptorSize,
    ACCESS_MASK          AccessMask);

ULONG
AppendAccessAllowedACE(
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    ACCESS_MASK AccessMask);





//-------------------------------------------------------------------------//
//                           INTERNAL MACROS                               //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  NLS_REG_BUFFER_ALLOC
//
//  Allocates the buffer used by the registry enumeration and query calls
//  and sets the pKeyValueFull variable to point at the newly created buffer.
//
//  NOTE: This macro may return if an error is encountered.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NLS_REG_BUFFER_ALLOC( pKeyValueFull,                               \
                              BufSize,                                     \
                              pBuffer,                                     \
                              CritSect )                                   \
{                                                                          \
    if ((pBuffer = (PVOID)NLS_ALLOC_MEM(BufSize)) == NULL)                 \
    {                                                                      \
        KdPrint(("NLSAPI: Could NOT Allocate Memory.\n"));                 \
        if (CritSect)                                                      \
        {                                                                  \
            RtlLeaveCriticalSection(&gcsTblPtrs);                          \
        }                                                                  \
        return ((ULONG)STATUS_NO_MEMORY);                                  \
    }                                                                      \
                                                                           \
    pKeyValueFull = (PKEY_VALUE_FULL_INFORMATION)pBuffer;                  \
}


////////////////////////////////////////////////////////////////////////////
//
//  NLS_REG_BUFFER_FREE
//
//  Frees the buffer used by the registry enumeration and query calls.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NLS_REG_BUFFER_FREE(pBuffer)        (NLS_FREE_MEM(pBuffer))





//-------------------------------------------------------------------------//
//                           EXTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  CreateNlsObjectDirectory
//
//  This routine creates the object directory for the NLS memory mapped
//  sections.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG CreateNlsObjectDirectory()
{
    BYTE pSecurityDescriptor[MAX_SECURITY_BUF_LEN];  // security descriptor buffer (currently we use like 60 bytes or so of this)
    UNICODE_STRING ObDirName;                        // directory name
    OBJECT_ATTRIBUTES ObjA;                          // object attributes structure
    HANDLE hDirHandle;                               // directory handle
    ULONG rc = 0L;                                   // return code


    //
    //  Create the security descriptor with READ access to the world.
    //
    rc = CreateNlsSecurityDescriptor( pSecurityDescriptor,
                                   MAX_SECURITY_BUF_LEN,
                                   DIRECTORY_QUERY | DIRECTORY_TRAVERSE );
    if (!NT_SUCCESS(rc))
    {
        return (rc);
    }

    //
    //  Add Admin Access for Query.
    //
    rc = AppendAccessAllowedACE( pSecurityDescriptor,
                                 DIRECTORY_QUERY |
                                 DIRECTORY_TRAVERSE |
                                 DIRECTORY_CREATE_OBJECT );
    if (!NT_SUCCESS(rc))
    {
        return (rc);
    }

    //
    //  Create the object directory.
    //
    RtlInitUnicodeString(&ObDirName, NLS_OBJECT_DIRECTORY_NAME);
    InitializeObjectAttributes( &ObjA,
                                &ObDirName,
                                OBJ_PERMANENT | OBJ_CASE_INSENSITIVE,
                                NULL,
                                pSecurityDescriptor );

    rc = NtCreateDirectoryObject( &hDirHandle,
                                  DIRECTORY_TRAVERSE | DIRECTORY_CREATE_OBJECT,
                                  &ObjA );

    //
    //  Close the directory handle.
    //
    NtClose(hDirHandle);

    //
    //  Check for error from NtCreateDirectoryObject.
    //
    if (!NT_SUCCESS(rc))
    {
        KdPrint(("NLSAPI: Could NOT Create Object Directory %wZ - %lx.\n",
                 &ObDirName, rc));
        return (rc);
    }

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  CreateRegKey
//
//  This routine creates a key in the registry.
//
//  12-17-97    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG CreateRegKey(
    PHANDLE phKeyHandle,
    LPWSTR pBaseName,
    LPWSTR pKey,
    ULONG fAccess)
{
    WCHAR pwszKeyName[MAX_PATH_LEN];   // ptr to the full key name
    HANDLE UserKeyHandle;              // HKEY_CURRENT_USER equivalent
    OBJECT_ATTRIBUTES ObjA;            // object attributes structure
    UNICODE_STRING ObKeyName;          // key name
    ULONG rc = 0L;                     // return code


    //
    //  Get the full key name.
    //
    if (pBaseName == NULL)
    {
        //
        //  Get current user's key handle.
        //
        rc = RtlOpenCurrentUser(MAXIMUM_ALLOWED, &UserKeyHandle);
        if (!NT_SUCCESS(rc))
        {
            KdPrint(("NLSAPI: Could NOT Open HKEY_CURRENT_USER - %lx.\n", rc));
            return (rc);
        }
        pwszKeyName[0] = UNICODE_NULL;
    }
    else
    {
        //
        //  Base name exists, so not current user.
        //
        UserKeyHandle = NULL;
        NlsStrCpyW(pwszKeyName, pBaseName);
    }
    NlsStrCatW(pwszKeyName, pKey);

    //
    //  Create the registry key.
    //
    RtlInitUnicodeString(&ObKeyName, pwszKeyName);
    InitializeObjectAttributes( &ObjA,
                                &ObKeyName,
                                OBJ_CASE_INSENSITIVE,
                                UserKeyHandle,
                                NULL );
    rc = NtCreateKey( phKeyHandle,
                      fAccess,
                      &ObjA,
                      0,
                      NULL,
                      REG_OPTION_NON_VOLATILE,
                      NULL );

    //
    //  Close the current user handle, if necessary.
    //
    if (UserKeyHandle != NULL)
    {
        NtClose(UserKeyHandle);
    }

    //
    //  Check for error from NtCreateKey.
    //
    if (!NT_SUCCESS(rc))
    {
        *phKeyHandle = NULL;
    }

    //
    //  Return the status from NtCreateKey.
    //
    return (rc);
}


////////////////////////////////////////////////////////////////////////////
//
//  OpenRegKey
//
//  This routine opens a key in the registry.
//
//  08-02-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG OpenRegKey(
    PHANDLE phKeyHandle,
    LPWSTR pBaseName,
    LPWSTR pKey,
    ULONG fAccess)
{
    WCHAR pwszKeyName[MAX_PATH_LEN];   // ptr to the full key name
    HANDLE UserKeyHandle;              // HKEY_CURRENT_USER equivalent
    OBJECT_ATTRIBUTES ObjA;            // object attributes structure
    UNICODE_STRING ObKeyName;          // key name
    ULONG rc = 0L;                     // return code


    //
    //  Get the full key name.
    //
    if (pBaseName == NULL)
    {
        //
        //  Get current user's key handle.
        //
        rc = RtlOpenCurrentUser(MAXIMUM_ALLOWED, &UserKeyHandle);
        if (!NT_SUCCESS(rc))
        {
            KdPrint(("NLSAPI: Could NOT Open HKEY_CURRENT_USER - %lx.\n", rc));
            return (rc);
        }
        pwszKeyName[0] = UNICODE_NULL;
    }
    else
    {
        //
        //  Base name exists, so not current user.
        //
        UserKeyHandle = NULL;
        NlsStrCpyW(pwszKeyName, pBaseName);
    }
    if (pKey)
    {
        NlsStrCatW(pwszKeyName, pKey);
    }

    //
    //  Open the registry key.
    //
    RtlInitUnicodeString(&ObKeyName, pwszKeyName);
    InitializeObjectAttributes( &ObjA,
                                &ObKeyName,
                                OBJ_CASE_INSENSITIVE,
                                UserKeyHandle,
                                NULL );
    rc = NtOpenKey( phKeyHandle,
                    fAccess,
                    &ObjA );

    //
    //  Close the current user handle, if necessary.
    //
    if (UserKeyHandle != NULL)
    {
        NtClose(UserKeyHandle);
    }

    //
    //  Check for error from NtOpenKey.
    //
    if (!NT_SUCCESS(rc))
    {
        *phKeyHandle = NULL;
    }

    //
    //  Return the status from NtOpenKey.
    //
    return (rc);
}


////////////////////////////////////////////////////////////////////////////
//
//  QueryRegValue
//
//  This routine queries the given value from the registry.
//
//  NOTE: If pIfAlloc is NULL, then no buffer will be allocated.
//        If this routine is successful, the CALLER must free the
//        ppKeyValueFull information buffer if *pIfAlloc is TRUE.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG QueryRegValue(
    HANDLE hKeyHandle,
    LPWSTR pValue,
    PKEY_VALUE_FULL_INFORMATION *ppKeyValueFull,
    ULONG Length,
    LPBOOL pIfAlloc)
{
    UNICODE_STRING ObValueName;        // value name
    PVOID pBuffer;                     // ptr to buffer for enum
    ULONG ResultLength;                // # bytes written
    ULONG rc = 0L;                     // return code


    //
    //  Set contents of pIfAlloc to FALSE to show that we did NOT do a
    //  memory allocation (yet).
    //
    if (pIfAlloc)
    {
        *pIfAlloc = FALSE;
    }

    //
    //  Query the value from the registry.
    //
    RtlInitUnicodeString(&ObValueName, pValue);

    RtlZeroMemory(*ppKeyValueFull, Length);
    rc = NtQueryValueKey( hKeyHandle,
                          &ObValueName,
                          KeyValueFullInformation,
                          *ppKeyValueFull,
                          Length,
                          &ResultLength );

    //
    //  Check the error code.  If the buffer is too small, allocate
    //  a new one and try the query again.
    //
    if ((rc == STATUS_BUFFER_OVERFLOW) && (pIfAlloc))
    {
        //
        //  Buffer is too small, so allocate a new one.
        //
        NLS_REG_BUFFER_ALLOC(*ppKeyValueFull, ResultLength, pBuffer, FALSE);
        RtlZeroMemory(*ppKeyValueFull, ResultLength);
        rc = NtQueryValueKey( hKeyHandle,
                              &ObValueName,
                              KeyValueFullInformation,
                              *ppKeyValueFull,
                              ResultLength,
                              &ResultLength );

        //
        //  Set contents of pIfAlloc to TRUE to show that we DID do
        //  a memory allocation.
        //
        *pIfAlloc = TRUE;
    }

    //
    //  If there is an error at this point, then the query failed.
    //
    if (rc != NO_ERROR)
    {
        if ((pIfAlloc) && (*pIfAlloc))
        {
            NLS_REG_BUFFER_FREE(pBuffer);
        }
        return (rc);
    }

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetRegValue
//
//  This routine sets the given value in the registry.
//
//  12-17-97    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG SetRegValue(
    HANDLE hKeyHandle,
    LPCWSTR pValue,
    LPCWSTR pData,
    ULONG DataLength)
{
    UNICODE_STRING ObValueName;        // value name


    //
    //  Set the value in the registry.
    //
    RtlInitUnicodeString(&ObValueName, pValue);

    return (NtSetValueKey( hKeyHandle,
                           &ObValueName,
                           0,
                           REG_SZ,
                           (PVOID)pData,
                           DataLength ));
}

////////////////////////////////////////////////////////////////////////////
//
//  CreateSectionTemp
//
//  This routine creates a temporary memory mapped section for the given file
//  name and returns the handle to the section.
//
//  09-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG CreateSectionTemp(
    HANDLE *phSec,
    LPWSTR pwszFileName)
{
    HANDLE hFile = (HANDLE)0;          // file handle
    OBJECT_ATTRIBUTES ObjA;            // object attributes structure
    ULONG rc = 0L;                     // return code


    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    //
    //  Open the data file.
    //
    if (rc = OpenDataFile( &hFile,
                           pwszFileName ))
    {
        return (rc);
    }

    //
    //  Create the section.
    //
    InitializeObjectAttributes( &ObjA,
                                NULL,
                                0,
                                NULL,
                                NULL );

    rc = NtCreateSection( phSec,
                          SECTION_MAP_READ,
                          &ObjA,
                          NULL,
                          PAGE_READONLY,
                          SEC_COMMIT,
                          hFile );

    //
    //  Close the file.
    //
    NtClose(hFile);

    //
    //  Check for error from NtCreateSection.
    //
    if (!NT_SUCCESS(rc))
    {
        KdPrint(("NLSAPI: Could NOT Create Temp Section for %ws - %lx.\n",
                 pwszFileName, rc));
    }

    //
    //  Return success.
    //
    return (rc);
}


////////////////////////////////////////////////////////////////////////////
//
//  OpenSection
//
//  This routine opens the named memory mapped section for the given section
//  name and returns the handle to the section.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG OpenSection(
    HANDLE *phSec,
    PUNICODE_STRING pObSectionName,
    PVOID *ppBaseAddr,
    ULONG AccessMask,
    BOOL bCloseHandle)
{
    OBJECT_ATTRIBUTES ObjA;            // object attributes structure
    ULONG rc = 0L;                     // return code


    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    //
    //  Open the Section.
    //
    InitializeObjectAttributes( &ObjA,
                                pObSectionName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    rc = NtOpenSection( phSec,
                        AccessMask,
                        &ObjA );

    //
    //  Check for error from NtOpenSection.
    //
    if (!NT_SUCCESS(rc))
    {
        return (rc);
    }

    //
    //  Map a View of the Section.
    //
    if (rc = MapSection( *phSec,
                         ppBaseAddr,
                         PAGE_READONLY,
                         FALSE ))
    {
        NtClose(*phSec);
        return (rc);
    }

    //
    //  Close the handle to the section.  Once the section has been mapped,
    //  the pointer to the base address will remain valid until the section
    //  is unmapped.  It is not necessary to leave the handle to the section
    //  around.
    //
    if (bCloseHandle)
    {
        NtClose(*phSec);
    }

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  MapSection
//
//  This routine maps a view of the section to the current process and adds
//  the appropriate information to the hash table.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG MapSection(
    HANDLE hSec,
    PVOID *ppBaseAddr,
    ULONG PageProtection,
    BOOL bCloseHandle)
{
    SIZE_T ViewSize;                   // view size of mapped section
    ULONG rc = 0L;                     // return code


    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    //
    //  Map a View of the Section.
    //
    *ppBaseAddr = (PVOID)NULL;
    ViewSize = 0L;

    rc = NtMapViewOfSection( hSec,
                             NtCurrentProcess(),
                             ppBaseAddr,
                             0L,
                             0L,
                             NULL,
                             &ViewSize,
                             ViewUnmap,
                             0L,
                             PageProtection );

    //
    //  Close the handle to the section.  Once the section has been mapped,
    //  the pointer to the base address will remain valid until the section
    //  is unmapped.  It is not necessary to leave the handle to the section
    //  around.
    //
    if (bCloseHandle)
    {
        NtClose(hSec);
    }

    //
    //  Check for error from NtMapViewOfSection.
    //
    if (!NT_SUCCESS(rc))
    {
        KdPrint(("NLSAPI: Could NOT Map View of Section - %lx.\n", rc));
        return (rc);
    }

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  UnMapSection
//
//  This routine unmaps a view of the given section to the current process.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG UnMapSection(
    PVOID pBaseAddr)
{
    ULONG rc = 0L;                     // return code


    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    //
    //  UnMap a View of the Section.
    //
    rc = NtUnmapViewOfSection( NtCurrentProcess(),
                               pBaseAddr );

    //
    //  Check for error from NtUnmapViewOfSection.
    //
    if (!NT_SUCCESS(rc))
    {
        KdPrint(("NLSAPI: Could NOT Unmap View of Section - %lx.\n", rc));
        return (rc);
    }

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetNlsSectionName
//
//  This routine returns a section name by concatenating the given
//  section prefix and the given integer value converted to a string.
//
//  05-31-1991  JulieB      Created.
//  06-04-2002  ShawnSte    Added more security
////////////////////////////////////////////////////////////////////////////

ULONG GetNlsSectionName(
    UINT Value,
    UINT Base,
    UINT Padding,
    LPWSTR pwszPrefix,
    LPWSTR pwszSecName,
    UINT cchSecName)
{
    size_t  cchUsed;

    //
    //  Create section name string.
    //
    NlsStrCpyW(pwszSecName, pwszPrefix);

    // See how much we used already
    cchUsed = NlsStrLenW(pwszPrefix);

    // Now convert the number, passing along the used buffer length
    return ( NlsConvertIntegerToString( Value,
                                        Base,
                                        Padding,
                                        pwszSecName + NlsStrLenW(pwszSecName),
                                        cchSecName - cchUsed ));     // Some characters are already used
}


////////////////////////////////////////////////////////////////////////////
//
//  GetCodePageDLLPathName
//
//  This routine returns the full path name for the DLL file found in
//  the CodePage section of the registry for the given code page value.
//
//  10-23-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG GetCodePageDLLPathName(
    UINT CodePage,
    LPWSTR pDllName,
    USHORT cchLen)
{
    WCHAR pTmpBuf[MAX_SMALL_BUF_LEN];            // temp buffer
    PKEY_VALUE_FULL_INFORMATION pKeyValueFull;   // ptr to query info
    BYTE pStatic[MAX_KEY_VALUE_FULLINFO];        // ptr to static buffer
    BOOL IfAlloc = FALSE;                        // if buffer was allocated
    ULONG rc = 0L;                               // return code


    //
    //  Open the CodePage registry key.
    //
    OPEN_CODEPAGE_KEY(ERROR_BADDB);

    //
    //  Convert the code page value to a unicode string.
    //
    if (rc = NlsConvertIntegerToString( CodePage,
                                        10,
                                        0,
                                        pTmpBuf,
                                        MAX_SMALL_BUF_LEN ))
    {
        return (rc);
    }

    //
    //  Query the registry for the code page value.
    //
    pKeyValueFull = (PKEY_VALUE_FULL_INFORMATION)pStatic;
    if (rc = QueryRegValue( hCodePageKey,
                            pTmpBuf,
                            &pKeyValueFull,
                            MAX_KEY_VALUE_FULLINFO,
                            &IfAlloc ))
    {
        return (rc);
    }

    //
    //  Make sure there is data with this value.
    //
    if (pKeyValueFull->DataLength > 2)
    {
        //
        //  Get the full path name for the DLL file.
        //
        GetSystemDirectoryW(pDllName, cchLen / 2);
        NlsStrCatW(pDllName, L"\\");
        NlsStrCatW(pDllName, GET_VALUE_DATA_PTR(pKeyValueFull));
    }
    else
    {
        rc = ERROR_INVALID_PARAMETER;
    }

    //
    //  Free the buffer used for the query.
    //
    if (IfAlloc)
    {
        NLS_FREE_MEM(pKeyValueFull);
    }

    //
    //  Return.
    //
    return (rc);
}




//-------------------------------------------------------------------------//
//                           INTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  OpenDataFile
//
//  This routine opens the data file for the specified file name and
//  returns the handle to the file.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG OpenDataFile(
    HANDLE *phFile,
    LPWSTR pFile)
{
    UNICODE_STRING ObFileName;         // file name
    OBJECT_ATTRIBUTES ObjA;            // object attributes structure
    IO_STATUS_BLOCK iosb;              // IO status block
    ULONG rc = 0L;                     // return code


    //
    //  Get the NT file name.
    //
    if (rc = GetNTFileName( pFile,
                            &ObFileName ))
    {
        return (rc);
    }

    //
    //  Open the file.
    //
    InitializeObjectAttributes( &ObjA,
                                &ObFileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    rc = NtOpenFile( phFile,
                     FILE_READ_DATA | SYNCHRONIZE,
                     &ObjA,
                     &iosb,
                     FILE_SHARE_READ,
                     FILE_SYNCHRONOUS_IO_NONALERT );


    //
    //  Check for error from NtOpenFile.
    //
    if (!NT_SUCCESS(rc))
    {
        KdPrint(("NLSAPI: Could NOT Open File %wZ - %lx.\n", &ObFileName, rc));
        RtlFreeHeap(RtlProcessHeap(), 0, ObFileName.Buffer);
        return (rc);
    }
    if (!NT_SUCCESS(iosb.Status))
    {
        KdPrint(("NLSAPI: Could NOT Open File %wZ - Status = %lx.\n",
                 &ObFileName, iosb.Status));
        RtlFreeHeap(RtlProcessHeap(), 0, ObFileName.Buffer);
        return ((ULONG)iosb.Status);
    }

    //
    //  Return success.
    //
    RtlFreeHeap(RtlProcessHeap(), 0, ObFileName.Buffer);
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetNTFileName
//
//  This routine returns the full path name for the data file found in
//  the given registry information buffer.
//
//  NOTE: The pFileName parameter will contain a newly allocated buffer
//        that must be freed by the caller (pFileName->buffer).
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG GetNTFileName(
    LPWSTR pFile,
    PUNICODE_STRING pFileName)
{
    WCHAR pwszFilePath[MAX_PATH_LEN];  // ptr to file path string
    UNICODE_STRING ObFileName;         // file name
    ULONG rc = 0L;                     // return code


    //
    //  Get the full path name for the file.
    //
    pwszFilePath[0] = L'\0';
    GetSystemDirectoryW(pwszFilePath, MAX_PATH_LEN);
    NlsStrCatW(pwszFilePath, L"\\");
    NlsStrCatW(pwszFilePath, pFile);

    //
    //  Make the file name an NT path name.
    //
    RtlInitUnicodeString(&ObFileName, pwszFilePath);
    if (!RtlDosPathNameToNtPathName_U( ObFileName.Buffer,
                                       pFileName,
                                       NULL,
                                       NULL ))
    {
        KdPrint(("NLSAPI: Could NOT convert %wZ to NT path name - %lx.\n",
                 &ObFileName, rc));
        return (ERROR_FILE_NOT_FOUND);
    }

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  CreateNlsSecurityDescriptor
//
//  This routine creates the security descriptor needed to create the
//  memory mapped section for a data file and returns the world SID.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG CreateNlsSecurityDescriptor(
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    UINT SecurityDescriptorSize,
    ACCESS_MASK AccessMask)
{
    ULONG rc = STATUS_SUCCESS;         // return code (positive thinking)
    PACL pAclBuffer;                   // ptr to ACL buffer
    PSID pWorldSid = NULL;             // ptr to world SID
    SID_IDENTIFIER_AUTHORITY SidAuth = SECURITY_WORLD_SID_AUTHORITY;

    //
    //  Create World SID.
    //
    rc = RtlAllocateAndInitializeSid( &SidAuth,
                                      1,
                                      SECURITY_WORLD_RID,
                                      0, 0, 0, 0, 0, 0, 0,
                                      &pWorldSid );
    if (!NT_SUCCESS(rc))
    {
        KdPrint(("NLSAPI: Could NOT Create SID - %lx.\n", rc));
        goto CSD_Exit;
    }
    
    //
    //  Initialize Security Descriptor.
    //
    rc = RtlCreateSecurityDescriptor( pSecurityDescriptor,
                                      SECURITY_DESCRIPTOR_REVISION );
    if (!NT_SUCCESS(rc))
    {
        KdPrint(("NLSAPI: Could NOT Create Security Descriptor - %lx.\n", rc));
        goto CSD_Exit;
    }

    //
    //  Initialize ACL.
    //
    pAclBuffer = (PACL)((PBYTE)pSecurityDescriptor + SECURITY_DESCRIPTOR_MIN_LENGTH);
    rc = RtlCreateAcl( (PACL)pAclBuffer,
                       SecurityDescriptorSize - SECURITY_DESCRIPTOR_MIN_LENGTH,
                       ACL_REVISION2 );
    if (!NT_SUCCESS(rc))
    {
        KdPrint(("NLSAPI: Could NOT Create ACL - %lx.\n", rc));
        goto CSD_Exit;
    }

    //
    //  Add an ACE to the ACL that allows World GENERIC_READ to the
    //  section object.
    //
    rc = RtlAddAccessAllowedAce( (PACL)pAclBuffer,
                                 ACL_REVISION2,
                                 AccessMask,
                                 pWorldSid );
    if (!NT_SUCCESS(rc))
    {
        KdPrint(("NLSAPI: Could NOT Add Access Allowed ACE - %lx.\n", rc));
        goto CSD_Exit;
    }

    //
    //  Assign the DACL to the security descriptor.
    //
    rc = RtlSetDaclSecurityDescriptor( (PSECURITY_DESCRIPTOR)pSecurityDescriptor,
                                       (BOOLEAN)TRUE,
                                       (PACL)pAclBuffer,
                                       (BOOLEAN)FALSE );
    if (!NT_SUCCESS(rc))
    {
        KdPrint(("NLSAPI: Could NOT Set DACL Security Descriptor - %lx.\n", rc));
        goto CSD_Exit;
    }

CSD_Exit:
    //
    //  Free the Sid.
    //
    if (pWorldSid) RtlFreeHeap(RtlProcessHeap(), 0, pWorldSid);

    //
    //  Return the result.
    //
    return (rc);
}

////////////////////////////////////////////////////////////////////////////
//
//  AppendAccessAllowedACE
//
//  This routine adds an ACE to the ACL for administrators.
//
//  03-08-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG AppendAccessAllowedACE(
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    ACCESS_MASK AccessMask)
{
    ULONG rc = STATUS_SUCCESS;          // return code (positive thinking)
    PACL pDaclBuffer;                  // ptr to DACL buffer
    ULONG SidLength;                   // length of SID - 2 sub authorities
    PSID pLocalSystemSid = NULL;       // ptr to local system SID
    SID_IDENTIFIER_AUTHORITY SidAuth = SECURITY_NT_AUTHORITY;
    BOOLEAN DaclPresent;
    BOOLEAN DaclDefaulted;

    //
    //  Create Local System Account SID.
    //
    rc = RtlAllocateAndInitializeSid( &SidAuth,
                                      1,
                                      SECURITY_LOCAL_SYSTEM_RID,
                                      0, 0, 0, 0, 0, 0, 0,
                                      &pLocalSystemSid );
    if (!NT_SUCCESS(rc))
    {
        KdPrint(("NLSAPI: Could NOT Create SID - %lx.\n", rc));
        goto AAA_EXIT;
    }

    //
    //  Get DACL.
    //
    rc = RtlGetDaclSecurityDescriptor( pSecurityDescriptor,
                                       &DaclPresent,
                                       &pDaclBuffer,
                                       &DaclDefaulted );
    if (!NT_SUCCESS(rc) || !pDaclBuffer || !DaclPresent)
    {
        KdPrint(("NLSAPI: Could NOT Get DACL Security Descriptor - %lx.\n", rc));
        goto AAA_EXIT;
    }

    //
    //  Add an ACE to the ACL that allows Admin query access to the
    //  section object.
    //
    rc = RtlAddAccessAllowedAce( (PACL)pDaclBuffer,
                                 ACL_REVISION2,
                                 AccessMask,
                                 pLocalSystemSid );
    if (!NT_SUCCESS(rc))
    {
        KdPrint(("NLSAPI: Could NOT Add Access Allowed ACE - %lx.\n", rc));
        goto AAA_EXIT;
    }

AAA_EXIT:
    //
    //  Free SID.
    //
    if (pLocalSystemSid) RtlFreeHeap(RtlProcessHeap(), 0, pLocalSystemSid);

    //
    //  Return condition.
    //
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\nls.h ===
/*++

Copyright (c) 1991-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    nls.h

Abstract:

    This file contains the header information shared by all of the modules
    of NLS.

Revision History:

    05-31-91    JulieB    Created.
    03-07-00    lguindon  Began Geo API port

--*/



#ifndef _NLS_
#define _NLS_




////////////////////////////////////////////////////////////////////////////
//
//  RTL Includes Files.
//
////////////////////////////////////////////////////////////////////////////

#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif



////////////////////////////////////////////////////////////////////////////
//
//  Include Files.
//
////////////////////////////////////////////////////////////////////////////

#include <base.h>
#include <ntcsrdll.h>
#include <ntcsrsrv.h>
#include <basemsg.h>
#include <windows.h>
#include <winnlsp.h>
#include <winerror.h>
#include <string.h>
#include <stdlib.h>





////////////////////////////////////////////////////////////////////////////
//
//  Constant Declarations.
//
////////////////////////////////////////////////////////////////////////////

//
//  Code Page Ranges.
//
#define NLS_CP_TABLE_RANGE        0         // begin code page Table range
#define NLS_CP_DLL_RANGE          50000     // begin code page DLL range
#define NLS_CP_ALGORITHM_RANGE    60000     // begin code page Algorithm range


//
//  Table Values.
//
#define MB_TBL_SIZE               256  // size of MB tables
#define GLYPH_TBL_SIZE            256  // size of GLYPH tables
#define DBCS_TBL_SIZE             256  // size of DBCS tables

#define CP_TBL_SIZE               197  // size of code page hash table (prime #)
#define LOC_TBL_SIZE              197  // size of locale hash table (prime #)


//
//  String Constants.
//
#define MAX_PATH_LEN              512  // max length of path name
#define MAX_STRING_LEN            128  // max string length for static buffer
#define MAX_SMALL_BUF_LEN         64   // max length of small buffer

#define MAX_COMPOSITE             5    // max number of composite characters
#define MAX_EXPANSION             3    // max number of expansion characters
#define MAX_TBL_EXPANSION         2    // max expansion chars per table entry
#define MAX_WEIGHTS               9    // max number of words in all weights

#define MAX_SECURITY_BUF_LEN      128  // max length of security descriptor buffer

// length of sortkey static buffer
#define MAX_SORTKEY_BUF_LEN       ( MAX_SMALL_BUF_LEN * MAX_EXPANSION * MAX_WEIGHTS )


#define MAX_FONTSIGNATURE         16   // length of font signature string

// SetLocaleInfo string constants
#define MAX_SLIST                 4    // max wide chars in sList
#define MAX_IMEASURE              2    // max wide chars in iMeasure
#define MAX_SDECIMAL              4    // max wide chars in sDecimal
#define MAX_STHOUSAND             4    // max wide chars in sThousand
#define MAX_SGROUPING             10   // max wide chars in sGrouping
#define MAX_IDIGITS               2    // max wide chars in iDigits
#define MAX_ILZERO                2    // max wide chars in iLZero
#define MAX_INEGNUMBER            2    // max wide chars in iNegNumber
#define MAX_SNATIVEDIGITS         11   // max wide chars in sNativeDigits
#define MAX_IDIGITSUBST           2    // max wide chars in iDigitSubstitution
#define MAX_SCURRENCY             6    // max wide chars in sCurrency
#define MAX_SMONDECSEP            4    // max wide chars in sMonDecimalSep
#define MAX_SMONTHOUSEP           4    // max wide chars in sMonThousandSep
#define MAX_SMONGROUPING          10   // max wide chars in sMonGrouping
#define MAX_ICURRENCY             2    // max wide chars in iCurrency
#define MAX_SPOSSIGN              5    // max wide chars in sPositiveSign
#define MAX_SNEGSIGN              5    // max wide chars in sNegativeSign
#define MAX_STIMEFORMAT           MAX_REG_VAL_SIZE   // max wide chars in sTimeFormat
#define MAX_STIME                 4    // max wide chars in sTime
#define MAX_ITIME                 2    // max wide chars in iTime
#define MAX_S1159                 15   // max wide chars in s1159
#define MAX_S2359                 15   // max wide chars in s2359
#define MAX_SSHORTDATE            MAX_REG_VAL_SIZE   // max wide chars in sShortDate
#define MAX_SDATE                 4    // max wide chars in sDate
#define MAX_SYEARMONTH            MAX_REG_VAL_SIZE   // max wide chars in sYearMonth
#define MAX_SLONGDATE             MAX_REG_VAL_SIZE   // max wide chars in sLongDate
#define MAX_ICALTYPE              3    // max wide chars in iCalendarType
#define MAX_IFIRSTDAY             2    // max wide chars in iFirstDayOfWeek
#define MAX_IFIRSTWEEK            2    // max wide chars in iFirstWeekOfYear

//
//  NOTE:  If any of the MAX_VALUE_ values change, then the corresponding
//         MAX_CHAR_ value must also change.
//
#define MAX_VALUE_IMEASURE        1    // max value for iMeasure
#define MAX_VALUE_IDIGITS         9    // max value for iDigits
#define MAX_VALUE_ILZERO          1    // max value for iLZero
#define MAX_VALUE_INEGNUMBER      4    // max value for iNegNumber
#define MAX_VALUE_IDIGITSUBST     2    // max value for iDigitSubstitution
#define MAX_VALUE_ICURRDIGITS     99   // max value for iCurrDigits
#define MAX_VALUE_ICURRENCY       3    // max value for iCurrency
#define MAX_VALUE_INEGCURR        15   // max value for iNegCurr
#define MAX_VALUE_ITIME           1    // max value for iTime
#define MAX_VALUE_IFIRSTDAY       6    // max value for iFirstDayOfWeek
#define MAX_VALUE_IFIRSTWEEK      2    // max value for iFirstWeekOfYear

#define MAX_CHAR_IMEASURE       L'1'   // max char value for iMeasure
#define MAX_CHAR_IDIGITS        L'9'   // max char value for iDigits
#define MAX_CHAR_ILZERO         L'1'   // max char value for iLZero
#define MAX_CHAR_INEGNUMBER     L'4'   // max char value for iNegNumber
#define MAX_CHAR_IDIGITSUBST    L'2'   // max char value for iDigitSubstitution
#define MAX_CHAR_ICURRENCY      L'3'   // max char value for iCurrency
#define MAX_CHAR_ITIME          L'1'   // max char value for iTime
#define MAX_CHAR_IFIRSTDAY      L'6'   // max char value for iFirstDayOfWeek
#define MAX_CHAR_IFIRSTWEEK     L'2'   // max char value for iFirstWeekOfYear


// SetCalendarInfo string constants
#define MAX_ITWODIGITYEAR         5    // max wide chars in TwoDigitYearMax


#define NLS_CHAR_ZERO           L'0'   // digit 0 character
#define NLS_CHAR_ONE            L'1'   // digit 1 character
#define NLS_CHAR_NINE           L'9'   // digit 9 character
#define NLS_CHAR_SEMICOLON      L';'   // semicolon character
#define NLS_CHAR_PERIOD         L'.'   // period character
#define NLS_CHAR_QUOTE          L'\''  // single quote character
#define NLS_CHAR_SPACE          L' '   // space character
#define NLS_CHAR_HYPHEN         L'-'   // hyphen/minus character
#define NLS_CHAR_OPEN_PAREN     L'('   // open parenthesis character
#define NLS_CHAR_CLOSE_PAREN    L')'   // close parenthesis character

#define MAX_BLANKS                1    // max successive blanks in number string


//
//  RC File Constants.
//
#define NLS_SORT_RES_PREFIX       L"SORT_"
#define NLS_SORT_RES_DEFAULT      L"SORT_00000000"


//
//  Size of stack buffer for PKEY_VALUE_FULL_INFORMATION pointer.
//
#define MAX_KEY_VALUE_FULLINFO                                             \
    ( FIELD_OFFSET( KEY_VALUE_FULL_INFORMATION, Name ) + MAX_PATH_LEN )


//
//  Paths to registry keys.
//
#define NLS_HKLM_SYSTEM    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control"
#define NLS_HKLM_SOFTWARE  L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion"


//
//  Names of Registry Key Entries.
//
#define NLS_CODEPAGE_KEY           L"\\Nls\\Codepage"
#define NLS_LANGUAGE_GROUPS_KEY    L"\\Nls\\Language Groups"
#define NLS_LOCALE_KEY             L"\\Nls\\Locale"
#define NLS_ALT_SORTS_KEY          L"\\Nls\\Locale\\Alternate Sorts"
#define NLS_MUILANG_KEY            L"\\Nls\\MUILanguages"

//
//  User Info.
//
#define NLS_CTRL_PANEL_KEY         L"Control Panel\\International"
#define NLS_CALENDARS_KEY          L"Control Panel\\International\\Calendars"
#define NLS_TWO_DIGIT_YEAR_KEY     L"Control Panel\\International\\Calendars\\TwoDigitYearMax"
#define NLS_POLICY_TWO_DIGIT_YEAR_KEY L"Software\\Policies\\Microsoft\\Control Panel\\International\\Calendars\\TwoDigitYearMax"

//
//  GEO Registry Keys.
//
#define GEO_REG_KEY         L"Control Panel\\International\\Geo"
#define GEO_REG_NATION      L"Nation"
#define GEO_REG_REGION      L"Region"
#define GEO_REG_STATE       L"State"
#define GEO_REG_CITY        L"City"

//
//  Name of NLS Object Directory.
//  Must create this in order to have "create access" on the fly.
//
#define NLS_OBJECT_DIRECTORY_NAME  L"\\NLS"

//
//  Default values.
//
#define NLS_DEFAULT_ACP           1252
#define NLS_DEFAULT_OEMCP         437
#define NLS_DEFAULT_MACCP         10000
#define NLS_DEFAULT_LANGID        0x0409
#define NLS_DEFAULT_UILANG        0x0409


//
//  DLL Translation Function Names.
//
//  ****  Must be an ANSI string for GetProcAddress call.  ****
//
#define NLS_CP_DLL_PROC_NAME      "NlsDllCodePageTranslation"


//
//  Flag Constants.
//
#define MSB_FLAG         0x80000000    // most significant bit set


//
//  Table Header Constants  (all sizes in WORDS).
//
#define CP_HEADER                 1    // size of CP Info table header
#define MB_HEADER                 1    // size of MB table header
#define GLYPH_HEADER              1    // size of GLYPH table header
#define DBCS_HEADER               1    // size of DBCS table header
#define WC_HEADER                 1    // size of WC table header
#define CT_HEADER                 2    // size of CTYPE table header
#define LANG_HDR_OFFSET           0    // offset to LANGUAGE file header
#define LANG_HEADER               1    // size of language file header
#define UP_HEADER                 1    // size of UPPERCASE table header
#define LO_HEADER                 1    // size of LOWERCASE table header
#define L_EXCEPT_HDR_OFFSET       2    // offset to LANGUAGE EXCEPTION header
#define AD_HEADER                 1    // size of ASCIIDIGITS table header
#define CZ_HEADER                 1    // size of FOLDCZONE table header
#define HG_HEADER                 1    // size of HIRAGANA table header
#define KK_HEADER                 1    // size of KATAKANA table header
#define HW_HEADER                 1    // size of HALF WIDTH table header
#define FW_HEADER                 1    // size of FULL WIDTH table header
#define TR_HEADER                 1    // size of TRADITIONAL CHINESE table header
#define SP_HEADER                 1    // size of SIMPLIFIED CHINESE table header
#define PC_HEADER                 1    // size of PRECOMPOSED table header
#define CO_HEADER                 3    // size of COMPOSITE table header
#define SORTKEY_HEADER            2    // size of SORTKEY table header
#define REV_DW_HEADER             2    // size of REVERSE DW table header
#define DBL_COMP_HEADER           2    // size of DOUBLE COMPRESS table header
#define IDEO_LCID_HEADER          2    // size of IDEOGRAPH LCID table header
#define EXPAND_HEADER             2    // size of EXPANSION table header
#define COMPRESS_HDR_OFFSET       2    // offset to COMPRESSION header
#define EXCEPT_HDR_OFFSET         2    // offset to EXCEPTION header
#define MULTI_WT_HEADER           1    // size of MULTIPLE WEIGHTS table header
#define JAMO_INDEX_HEADER         1    // size of Jamo Index table header
#define JAMO_COMPOSITION_HEADER   1    // size of Jamo Composition state machine table hader


//
//  Invalid Flag Checks.
//
#define MB_INVALID_FLAG   (~(MB_PRECOMPOSED   | MB_COMPOSITE |              \
                             MB_USEGLYPHCHARS | MB_ERR_INVALID_CHARS))
#define WC_INVALID_FLAG   (~(WC_NO_BEST_FIT_CHARS | WC_COMPOSITECHECK |     \
                             WC_DISCARDNS | WC_SEPCHARS | WC_DEFAULTCHAR))
#define CS_INVALID_FLAG   (~(NORM_IGNORECASE    | NORM_IGNORENONSPACE |     \
                             NORM_IGNORESYMBOLS | NORM_IGNOREKANATYPE |     \
                             NORM_IGNOREWIDTH   | SORT_STRINGSORT     |     \
                             LOCALE_USE_CP_ACP  | NORM_STOP_ON_NULL))
#define FS_INVALID_FLAG   (~(MAP_FOLDCZONE | MAP_PRECOMPOSED |              \
                             MAP_COMPOSITE | MAP_FOLDDIGITS))
#define LCMS_INVALID_FLAG (~(LCMAP_LOWERCASE | LCMAP_UPPERCASE |            \
                             LCMAP_LINGUISTIC_CASING |                      \
                             LCMAP_SORTKEY   | LCMAP_BYTEREV   |            \
                             LCMAP_HIRAGANA  | LCMAP_KATAKANA  |            \
                             LCMAP_HALFWIDTH | LCMAP_FULLWIDTH |            \
                             LCMAP_TRADITIONAL_CHINESE |                    \
                             LCMAP_SIMPLIFIED_CHINESE  |                    \
                             NORM_IGNORECASE    | NORM_IGNORENONSPACE |     \
                             NORM_IGNORESYMBOLS | NORM_IGNOREKANATYPE |     \
                             NORM_IGNOREWIDTH   | SORT_STRINGSORT     |     \
                             LOCALE_USE_CP_ACP))
#define GTF_INVALID_FLAG  (~(LOCALE_NOUSEROVERRIDE | LOCALE_USE_CP_ACP |    \
                             TIME_NOMINUTESORSECONDS                   |    \
                             TIME_NOSECONDS | TIME_NOTIMEMARKER        |    \
                             TIME_FORCE24HOURFORMAT))
#define GDF_INVALID_FLAG  (~(LOCALE_NOUSEROVERRIDE | LOCALE_USE_CP_ACP |    \
                             DATE_LTRREADING       | DATE_RTLREADING   |    \
                             DATE_SHORTDATE        | DATE_LONGDATE     |    \
                             DATE_YEARMONTH        | DATE_USE_ALT_CALENDAR |\
                             DATE_ADDHIJRIDATETEMP))
#define IVLG_INVALID_FLAG (~(LGRPID_INSTALLED | LGRPID_SUPPORTED))
#define IVL_INVALID_FLAG  (~(LCID_INSTALLED | LCID_SUPPORTED))
#define GNF_INVALID_FLAG  (~(LOCALE_NOUSEROVERRIDE | LOCALE_USE_CP_ACP))
#define GCF_INVALID_FLAG  (~(LOCALE_NOUSEROVERRIDE | LOCALE_USE_CP_ACP))
#define ESLG_INVALID_FLAG (~(LGRPID_INSTALLED | LGRPID_SUPPORTED))
#define ESL_INVALID_FLAG  (~(LCID_INSTALLED | LCID_SUPPORTED |             \
                             LCID_ALTERNATE_SORTS))
#define ESCP_INVALID_FLAG (~(CP_INSTALLED | CP_SUPPORTED))
#define ETF_INVALID_FLAG  (~(LOCALE_USE_CP_ACP))


//
//  Single Flags (only one at a time is valid).
//
#define LCMS1_SINGLE_FLAG (LCMAP_LOWERCASE | LCMAP_UPPERCASE |             \
                           LCMAP_SORTKEY)
#define LCMS2_SINGLE_FLAG (LCMAP_HIRAGANA  | LCMAP_KATAKANA  |             \
                           LCMAP_SORTKEY)
#define LCMS3_SINGLE_FLAG (LCMAP_HALFWIDTH | LCMAP_FULLWIDTH |             \
                           LCMAP_SORTKEY)
#define LCMS4_SINGLE_FLAG (LCMAP_TRADITIONAL_CHINESE |                     \
                           LCMAP_SIMPLIFIED_CHINESE  |                     \
                           LCMAP_SORTKEY)
#define GDF_SINGLE_FLAG   (DATE_LTRREADING | DATE_RTLREADING)
#define IVLG_SINGLE_FLAG  (LGRPID_INSTALLED  | LGRPID_SUPPORTED)
#define IVL_SINGLE_FLAG   (LCID_INSTALLED  | LCID_SUPPORTED)
#define ESLG_SINGLE_FLAG  (LGRPID_INSTALLED  | LGRPID_SUPPORTED)
#define ESL_SINGLE_FLAG   (LCID_INSTALLED  | LCID_SUPPORTED)
#define ESCP_SINGLE_FLAG  (CP_INSTALLED    | CP_SUPPORTED)


//
//  Flag combinations.
//
#define WC_COMPCHK_FLAGS  (WC_DISCARDNS | WC_SEPCHARS | WC_DEFAULTCHAR)
#define NORM_ALL          (NORM_IGNORECASE    | NORM_IGNORENONSPACE |      \
                           NORM_IGNORESYMBOLS | NORM_IGNOREKANATYPE |      \
                           NORM_IGNOREWIDTH)
#define NORM_SORTKEY_ONLY (NORM_IGNORECASE    | NORM_IGNOREKANATYPE |      \
                           NORM_IGNOREWIDTH   | SORT_STRINGSORT)
#define NORM_ALL_CASE     (NORM_IGNORECASE    | NORM_IGNOREKANATYPE |      \
                           NORM_IGNOREWIDTH)
#define LCMAP_NO_NORM     (LCMAP_LOWERCASE    | LCMAP_UPPERCASE     |      \
                           LCMAP_HIRAGANA     | LCMAP_KATAKANA      |      \
                           LCMAP_HALFWIDTH    | LCMAP_FULLWIDTH     |      \
                           LCMAP_TRADITIONAL_CHINESE                |      \
                           LCMAP_SIMPLIFIED_CHINESE)

//
//  Get the LCType value from an LCType.
//
#define NLS_GET_LCTYPE_VALUE(x)  (x & ~(LOCALE_NOUSEROVERRIDE |  \
                                        LOCALE_USE_CP_ACP     |  \
                                        LOCALE_RETURN_NUMBER))

//
//  Get the CalType value from a CalType.
//
#define NLS_GET_CALTYPE_VALUE(x) (x & ~(CAL_NOUSEROVERRIDE |  \
                                        CAL_USE_CP_ACP     |  \
                                        CAL_RETURN_NUMBER))

//
//  Separator and Terminator Values - Sortkey String.
//
#define SORTKEY_SEPARATOR    0x01
#define SORTKEY_TERMINATOR   0x00


//
//  Lowest weight values.
//  Used to remove trailing DW and CW values.
//
#define MIN_DW  2
#define MIN_CW  2


//
//  Bit mask values.
//
//  Case Weight (CW) - 8 bits:
//    bit 0   => width
//    bit 1,2 => small kana, sei-on
//    bit 3,4 => upper/lower case
//    bit 5   => kana
//    bit 6,7 => compression
//
#define COMPRESS_3_MASK      0xc0      // compress 3-to-1 or 2-to-1
#define COMPRESS_2_MASK      0x80      // compress 2-to-1

#define CASE_MASK            0x3f      // zero out compression bits

#define CASE_UPPER_MASK      0xe7      // zero out case bits
#define CASE_SMALL_MASK      0xf9      // zero out small modifier bits
#define CASE_KANA_MASK       0xdf      // zero out kana bit
#define CASE_WIDTH_MASK      0xfe      // zero out width bit

#define SW_POSITION_MASK     0x8003    // avoid 0 or 1 in bytes of word

//
//  Bit Mask Values for CompareString.
//
//  NOTE: Due to intel byte reversal, the DWORD value is backwards:
//                CW   DW   SM   AW
//
//  Case Weight (CW) - 8 bits:
//    bit 0   => width
//    bit 4   => case
//    bit 5   => kana
//    bit 6,7 => compression
//
#define CMP_MASKOFF_NONE          0xffffffff
#define CMP_MASKOFF_DW            0xff00ffff
#define CMP_MASKOFF_CW            0xe7ffffff
#define CMP_MASKOFF_DW_CW         0xe700ffff
#define CMP_MASKOFF_COMPRESSION   0x3fffffff

#define CMP_MASKOFF_KANA          0xdfffffff
#define CMP_MASKOFF_WIDTH         0xfeffffff
#define CMP_MASKOFF_KANA_WIDTH    0xdeffffff

//
//  Masks to isolate the various bits in the case weight.
//
//  NOTE: Bit 2 must always equal 1 to avoid getting a byte value
//        of either 0 or 1.
//
#define CASE_XW_MASK         0xc4

#define ISOLATE_SMALL        ( (BYTE)((~CASE_SMALL_MASK) | CASE_XW_MASK) )
#define ISOLATE_KANA         ( (BYTE)((~CASE_KANA_MASK)  | CASE_XW_MASK) )
#define ISOLATE_WIDTH        ( (BYTE)((~CASE_WIDTH_MASK) | CASE_XW_MASK) )

//
//  UW Mask for Cho-On:
//    Leaves bit 7 on in AW, so it becomes Repeat if it follows Kana N.
//
#define CHO_ON_UW_MASK       0xff87

//
//  Values for fareast special case alphanumeric weights.
//
#define AW_REPEAT            0
#define AW_CHO_ON            1
#define MAX_SPECIAL_AW       AW_CHO_ON

//
//  Values for weight 5 - East Asia Extra Weights.
//
#define WT_FIVE_KANA         3
#define WT_FIVE_REPEAT       4
#define WT_FIVE_CHO_ON       5

//
//  Values for CJK Unified Ideographs Extension A range.
//    0x3400 thru 0x4dbf
//
#define SM_EXT_A                  254       // SM for Extension A
#define AW_EXT_A                  255       // AW for Extension A

//
//  Values for UW extra weights (e.g. Jamo (old Hangul)).
//
#define SM_UW_XW                  255       // SM for extra UW weights


//
//  Script Member Values.
//
#define UNSORTABLE           0
#define NONSPACE_MARK        1
#define EXPANSION            2
#define FAREAST_SPECIAL      3
#define JAMO_SPECIAL         4
#define EXTENSION_A          5

#define PUNCTUATION          6

#define SYMBOL_1             7
#define SYMBOL_2             8
#define SYMBOL_3             9
#define SYMBOL_4             10
#define SYMBOL_5             11

#define NUMERIC_1            12
#define NUMERIC_2            13

#define LATIN                14
#define GREEK                15
#define CYRILLIC             16
#define ARMENIAN             17
#define HEBREW               18
#define ARABIC               19
#define DEVANAGARI           20
#define BENGALI              21
#define GURMUKKHI            22
#define GUJARATI             23
#define ORIYA                24
#define TAMIL                25
#define TELUGU               26
#define KANNADA              27
#define MALAYLAM             28
#define SINHALESE            29
#define THAI                 30
#define LAO                  31
#define TIBETAN              32
#define GEORGIAN             33
#define KANA                 34
#define BOPOMOFO             35
#define HANGUL               36
#define IDEOGRAPH            128

#define MAX_SPECIAL_CASE     SYMBOL_5
#define FIRST_SCRIPT         LATIN


//
//  Calendar Type Values.
//
#define CAL_NO_OPTIONAL      0                          // no optional calendars
#define CAL_LAST             CAL_GREGORIAN_XLIT_FRENCH  // greatest calendar value

//
//  The following calendars are defined in winnls.w:
//
//  #define CAL_GREGORIAN                  1
//  #define CAL_GREGORIAN_US               2
//  #define CAL_JAPAN                      3
//  #define CAL_TAIWAN                     4
//  #define CAL_KOREA                      5
//  #define CAL_HIJRI                      6
//  #define CAL_THAI                       7
//  #define CAL_HEBREW                     8
//  #define CAL_GREGORIAN_ME_FRENCH        9
//  #define CAL_GREGORIAN_ARABIC           10
//  #define CAL_GREGORIAN_XLIT_ENGLISH     11
//  #define CAL_GREGORIAN_XLIT_FRENCH      12
//


//
//  Constants to define range of Unicode private use area.
//
#define PRIVATE_USE_BEGIN    0xe000
#define PRIVATE_USE_END      0xf8ff


//
//  Internal flag for SpecialMBToWC routine.
//
#define MB_INVALID_CHAR_CHECK     MB_ERR_INVALID_CHARS

//
//  Geo values.
//
#define MAX_GEO_STRING_SIZE       1024

//
//  Resource String Table Values.
//
#define RC_STRING_SEPARATOR       '$'

#define RC_LANGUAGE_NAME          0
#define RC_COUNTRY_NAME           1
#define RC_LANGUAGE_GROUP_NAME    2
#define RC_CODE_PAGE_NAME         3
#define RC_GEO_FRIENDLY_NAME      4
#define RC_GEO_OFFICIAL_NAME      5
#define RC_SORT_NAMES             6




////////////////////////////////////////////////////////////////////////////
//
//  Typedef Declarations.
//
////////////////////////////////////////////////////////////////////////////

//
//  Constant Types
//
typedef  LPWORD        P844_TABLE;     // ptr to 8:4:4 table

typedef  LPWORD        PMB_TABLE;      // ptr to MB translation table
typedef  PMB_TABLE     PGLYPH_TABLE;   // ptr to GLYPH translation table
typedef  LPWORD        PDBCS_RANGE;    // ptr to DBCS range
typedef  LPWORD        PDBCS_OFFSETS;  // ptr to DBCS offset section
typedef  LPWORD        PDBCS_TABLE;    // ptr to DBCS translation table
typedef  PVOID         PWC_TABLE;      // ptr to WC translation table
typedef  P844_TABLE    PCTYPE;         // ptr to Character Type table
typedef  P844_TABLE    PCASE;          // ptr to Lower or Upper Case table
typedef  P844_TABLE    PADIGIT;        // ptr to Ascii Digits table
typedef  P844_TABLE    PCZONE;         // ptr to Fold Compat. Zone table
typedef  P844_TABLE    PKANA;          // ptr to Hiragana/Katakana table
typedef  P844_TABLE    PHALFWIDTH;     // ptr to Half Width table
typedef  P844_TABLE    PFULLWIDTH;     // ptr to Full Width table
typedef  P844_TABLE    PCHINESE;       // ptr to Traditional/Simplified Chinese table
typedef  P844_TABLE    PPRECOMP;       // ptr to PreComposed table
typedef  LPWORD        PCOMP_GRID;     // ptr to Composite table 2D grid
typedef  LPWORD        PLOC_INFO;      // ptr to locale information
typedef  LPWORD        PCAL_INFO;      // ptr to calendar information

typedef  DWORD         REVERSE_DW;     // reverse diacritic table
typedef  REVERSE_DW   *PREVERSE_DW;    // ptr to reverse diacritic table
typedef  DWORD         DBL_COMPRESS;   // double compression table
typedef  DBL_COMPRESS *PDBL_COMPRESS;  // ptr to double compression table
typedef  LPWORD        PCOMPRESS;      // ptr to compression table (2 or 3)


//
//  Proc Definition for Code Page DLL Routine.
//
typedef DWORD (*LPFN_CP_PROC)(DWORD, DWORD, LPSTR, int, LPWSTR, int, LPCPINFO);


//
//  CP Information Table Structure (as it is in the data file).
//
typedef struct cp_table_s {
    WORD      CodePage;                // code page number
    WORD      MaxCharSize;             // max length (bytes) of a char
    WORD      wDefaultChar;            // default character (MB)
    WORD      wUniDefaultChar;         // default character (Unicode)
    WORD      wTransDefaultChar;       // translation of wDefaultChar (Unicode)
    WORD      wTransUniDefaultChar;    // translation of wUniDefaultChar (MB)
    BYTE      LeadByte[MAX_LEADBYTES]; // lead byte ranges
} CP_TABLE, *PCP_TABLE;


//
//  Composite Information Structure.
//
typedef struct comp_info_s {
    BYTE           NumBase;            // number base chars in grid
    BYTE           NumNonSp;           // number non space chars in grid
    P844_TABLE     pBase;              // ptr to base char table
    P844_TABLE     pNonSp;             // ptr to nonspace char table
    PCOMP_GRID     pGrid;              // ptr to 2D grid
} COMP_INFO, *PCOMP_INFO;


//
//  Code Page Hash Table Structure.
//
typedef struct cp_hash_s {
    UINT           CodePage;           // codepage ID
    LPFN_CP_PROC   pfnCPProc;          // ptr to code page function proc
    PCP_TABLE      pCPInfo;            // ptr to CPINFO table
    PMB_TABLE      pMBTbl;             // ptr to MB translation table
    PGLYPH_TABLE   pGlyphTbl;          // ptr to GLYPH translation table
    PDBCS_RANGE    pDBCSRanges;        // ptr to DBCS ranges
    PDBCS_OFFSETS  pDBCSOffsets;       // ptr to DBCS offsets
    PWC_TABLE      pWC;                // ptr to WC table
    struct cp_hash_s *pNext;           // ptr to next CP hash node
} CP_HASH, *PCP_HASH;


//
//  Language Exception Header Structure.
//
typedef struct l_except_hdr_s {
    DWORD     Locale;                  // locale id
    DWORD     Offset;                  // offset to exception nodes (words)
    DWORD     NumUpEntries;            // number of upper case entries
    DWORD     NumLoEntries;            // number of lower case entries
} L_EXCEPT_HDR, *PL_EXCEPT_HDR;


//
//  Language Exception Structure.
//
typedef struct l_except_s
{
    WORD      UCP;                     // unicode code point
    WORD      AddAmount;               // amount to add to code point
} L_EXCEPT, *PL_EXCEPT;


//
//  CType header structure.
//
typedef struct ctype_hdr_s {
    WORD      TblSize;                 // size of ctype table
    WORD      MapSize;                 // size of mapping table
} CTYPE_HDR, *PCTYPE_HDR;


//
//  CType Table Structure (Mapping table structure).
//
typedef struct ct_values_s {
    WORD      CType1;                  // ctype 1 value
    WORD      CType2;                  // ctype 2 value
    WORD      CType3;                  // ctype 3 value
} CT_VALUES, *PCT_VALUES;


//
//  Sortkey Structure.
//
typedef struct sortkey_s {

    union {
        struct sm_aw_s {
            BYTE   Alpha;              // alphanumeric weight
            BYTE   Script;             // script member
        } SM_AW;

        WORD  Unicode;                 // unicode weight

    } UW;

    BYTE      Diacritic;               // diacritic weight
    BYTE      Case;                    // case weight (with COMP)

} SORTKEY, *PSORTKEY;


//
//  Extra Weight Structure.
//
typedef struct extra_wt_s {
    BYTE      Four;                    // weight 4
    BYTE      Five;                    // weight 5
    BYTE      Six;                     // weight 6
    BYTE      Seven;                   // weight 7
} EXTRA_WT, *PEXTRA_WT;


//
//  Compression Header Structure.
//  This is the header for the compression tables.
//
typedef struct compress_hdr_s {
    DWORD     Locale;                  // locale id
    DWORD     Offset;                  // offset (in words)
    WORD      Num2;                    // Number of 2 compressions
    WORD      Num3;                    // Number of 3 compressions
} COMPRESS_HDR, *PCOMPRESS_HDR;


//
//  Compression 2 Structure.
//  This is for a 2 code point compression - 2 code points
//  compress to ONE weight.
//
typedef struct compress_2_s {
    WCHAR     UCP1;                    // Unicode code point 1
    WCHAR     UCP2;                    // Unicode code point 2
    SORTKEY   Weights;                 // sortkey weights
} COMPRESS_2, *PCOMPRESS_2;


//
//  Compression 3 Structure.
//  This is for a 3 code point compression - 3 code points
//  compress to ONE weight.
//
typedef struct compress_3_s {
    WCHAR     UCP1;                    // Unicode code point 1
    WCHAR     UCP2;                    // Unicode code point 2
    WCHAR     UCP3;                    // Unicode code point 3
    WCHAR     Reserved;                // dword alignment
    SORTKEY   Weights;                 // sortkey weights
} COMPRESS_3, *PCOMPRESS_3;


//
//  Multiple Weight Structure.
//
typedef struct multiwt_s {
    BYTE      FirstSM;                 // value of first script member
    BYTE      NumSM;                   // number of script members in range
} MULTI_WT, *PMULTI_WT;


//
//  Ideograph Lcid Exception Structure.
//
typedef struct ideograph_lcid_s {
    DWORD     Locale;                  // locale id
    WORD      pFileName[14];           // ptr to file name
} IDEOGRAPH_LCID, *PIDEOGRAPH_LCID;


//
//  Expansion Structure.
//
typedef struct expand_s {
    WCHAR     UCP1;                    // Unicode code point 1
    WCHAR     UCP2;                    // Unicode code point 2
} EXPAND, *PEXPAND;


//
//  Exception Header Structure.
//  This is the header for the exception tables.
//
typedef struct except_hdr_s {
    DWORD     Locale;                  // locale id
    DWORD     Offset;                  // offset to exception nodes (words)
    DWORD     NumEntries;              // number of entries for locale id
} EXCEPT_HDR, *PEXCEPT_HDR;


//
//  Exception Structure.
//
//  NOTE: May also be used for Ideograph Exceptions (4 column tables).
//
typedef struct except_s
{
    WORD      UCP;                     // unicode code point
    WORD      Unicode;                 // unicode weight
    BYTE      Diacritic;               // diacritic weight
    BYTE      Case;                    // case weight
} EXCEPT, *PEXCEPT;


//
//  Ideograph Exception Header Structure.
//
typedef struct ideograph_except_hdr_s
{
    DWORD     NumEntries;              // number of entries in table
    DWORD     NumColumns;              // number of columns in table (2 or 4)
} IDEOGRAPH_EXCEPT_HDR, *PIDEOGRAPH_EXCEPT_HDR;


//
//  Ideograph Exception Structure.
//
typedef struct ideograph_except_s
{
    WORD      UCP;                     // unicode code point
    WORD      Unicode;                 // unicode weight
} IDEOGRAPH_EXCEPT, *PIDEOGRAPH_EXCEPT;


//
//  Locale Information Structures.
//
//  This is the format in which the locale information is kept in the
//  locale data file.  These structures are only used for offsets into
//  the data file, not to store information.
//

//
//  Header at the top of the locale.nls file.
//
typedef struct loc_cal_hdr_s
{
    DWORD     NumLocales;              // number of locales
    DWORD     NumCalendars;            // number of calendars
    DWORD     CalOffset;               // offset to calendar info (words)
} LOC_CAL_HDR, *PLOC_CAL_HDR;

#define LOCALE_HDR_OFFSET    (sizeof(LOC_CAL_HDR) / sizeof(WORD))

//
//  Per entry locale header.
//
//  The locale header structure contains the information given in one entry
//  of the header for the locale information.
//
typedef struct locale_hdr_s {
    DWORD     Locale;                  // locale ID
    DWORD     Offset;                  // offset to locale information
} LOCALE_HDR, *PLOCALE_HDR;

#define LOCALE_HDR_SIZE  (sizeof(LOCALE_HDR) / sizeof(WORD))

//
//  The fixed structure contains the locale information that is of
//  fixed length and in the order in which it is given in the file.
//
typedef struct locale_fixed_s
{
    WORD      DefaultACP;              // default ACP - integer format
    WORD      szILanguage[5];          // language id
    WORD      szICountry[6];           // country id
    WORD      szIGeoID[8];            // geographical location identifier
    WORD      szIDefaultLang[5];       // default language ID
    WORD      szIDefaultCtry[6];       // default country ID
    WORD      szIDefaultACP[6];        // default ansi code page ID
    WORD      szIDefaultOCP[6];        // default oem code page ID
    WORD      szIDefaultMACCP[6];      // default mac code page ID
    WORD      szIDefaultEBCDICCP[6];   // default ebcdic code page ID
    WORD      szIMeasure[2];           // system of measurement
    WORD      szIPaperSize[2];         // default paper size
    WORD      szIDigits[3];            // number of fractional digits
    WORD      szILZero[2];             // leading zeros for decimal
    WORD      szINegNumber[2];         // negative number format
    WORD      szIDigitSubstitution[2]; // digit substitution
    WORD      szICurrDigits[3];        // # local monetary fractional digits
    WORD      szIIntlCurrDigits[3];    // # intl monetary fractional digits
    WORD      szICurrency[2];          // positive currency format
    WORD      szINegCurr[3];           // negative currency format
    WORD      szIPosSignPosn[2];       // format of positive sign
    WORD      szIPosSymPrecedes[2];    // if mon symbol precedes positive
    WORD      szIPosSepBySpace[2];     // if mon symbol separated by space
    WORD      szINegSignPosn[2];       // format of negative sign
    WORD      szINegSymPrecedes[2];    // if mon symbol precedes negative
    WORD      szINegSepBySpace[2];     // if mon symbol separated by space
    WORD      szITime[2];              // time format
    WORD      szITLZero[2];            // leading zeros for time field
    WORD      szITimeMarkPosn[2];      // time marker position
    WORD      szIDate[2];              // short date order
    WORD      szICentury[2];           // century format (short date)
    WORD      szIDayLZero[2];          // leading zeros for day field (short date)
    WORD      szIMonLZero[2];          // leading zeros for month field (short date)
    WORD      szILDate[2];             // long date order
    WORD      szICalendarType[3];      // type of calendar
    WORD      szIFirstDayOfWk[2];      // first day of week
    WORD      szIFirstWkOfYr[2];       // first week of year
    WORD      szFontSignature[MAX_FONTSIGNATURE];
} LOCALE_FIXED, *PLOCALE_FIXED;

//
//  The variable structure contains the offsets to the various pieces of
//  locale information that is of variable length.  It is in the order
//  in which it is given in the file.
//
typedef struct locale_var_s
{
    WORD      SEngLanguage;            // English language name
    WORD      SAbbrevLang;             // abbreviated language name
    WORD      SAbbrevLangISO;          // ISO abbreviated language name
    WORD      SNativeLang;             // native language name
    WORD      SEngCountry;             // English country name
    WORD      SAbbrevCtry;             // abbreviated country name
    WORD      SAbbrevCtryISO;          // ISO abbreviated country name
    WORD      SNativeCtry;             // native country name
    WORD      SList;                   // list separator
    WORD      SDecimal;                // decimal separator
    WORD      SThousand;               // thousands separator
    WORD      SGrouping;               // grouping of digits
    WORD      SNativeDigits;           // native digits 0-9
    WORD      SCurrency;               // local monetary symbol
    WORD      SIntlSymbol;             // international monetary symbol
    WORD      SEngCurrName;            // English currency name
    WORD      SNativeCurrName;         // native currency name
    WORD      SMonDecSep;              // monetary decimal separator
    WORD      SMonThousSep;            // monetary thousands separator
    WORD      SMonGrouping;            // monetary grouping of digits
    WORD      SPositiveSign;           // positive sign
    WORD      SNegativeSign;           // negative sign
    WORD      STimeFormat;             // time format
    WORD      STime;                   // time separator
    WORD      S1159;                   // AM designator
    WORD      S2359;                   // PM designator
    WORD      SShortDate;              // short date format
    WORD      SDate;                   // date separator
    WORD      SYearMonth;              // year month format
    WORD      SLongDate;               // long date format
    WORD      IOptionalCal;            // additional calendar type(s)
    WORD      SDayName1;               // day name 1
    WORD      SDayName2;               // day name 2
    WORD      SDayName3;               // day name 3
    WORD      SDayName4;               // day name 4
    WORD      SDayName5;               // day name 5
    WORD      SDayName6;               // day name 6
    WORD      SDayName7;               // day name 7
    WORD      SAbbrevDayName1;         // abbreviated day name 1
    WORD      SAbbrevDayName2;         // abbreviated day name 2
    WORD      SAbbrevDayName3;         // abbreviated day name 3
    WORD      SAbbrevDayName4;         // abbreviated day name 4
    WORD      SAbbrevDayName5;         // abbreviated day name 5
    WORD      SAbbrevDayName6;         // abbreviated day name 6
    WORD      SAbbrevDayName7;         // abbreviated day name 7
    WORD      SMonthName1;             // month name 1
    WORD      SMonthName2;             // month name 2
    WORD      SMonthName3;             // month name 3
    WORD      SMonthName4;             // month name 4
    WORD      SMonthName5;             // month name 5
    WORD      SMonthName6;             // month name 6
    WORD      SMonthName7;             // month name 7
    WORD      SMonthName8;             // month name 8
    WORD      SMonthName9;             // month name 9
    WORD      SMonthName10;            // month name 10
    WORD      SMonthName11;            // month name 11
    WORD      SMonthName12;            // month name 12
    WORD      SMonthName13;            // month name 13 (if exists)
    WORD      SAbbrevMonthName1;       // abbreviated month name 1
    WORD      SAbbrevMonthName2;       // abbreviated month name 2
    WORD      SAbbrevMonthName3;       // abbreviated month name 3
    WORD      SAbbrevMonthName4;       // abbreviated month name 4
    WORD      SAbbrevMonthName5;       // abbreviated month name 5
    WORD      SAbbrevMonthName6;       // abbreviated month name 6
    WORD      SAbbrevMonthName7;       // abbreviated month name 7
    WORD      SAbbrevMonthName8;       // abbreviated month name 8
    WORD      SAbbrevMonthName9;       // abbreviated month name 9
    WORD      SAbbrevMonthName10;      // abbreviated month name 10
    WORD      SAbbrevMonthName11;      // abbreviated month name 11
    WORD      SAbbrevMonthName12;      // abbreviated month name 12
    WORD      SAbbrevMonthName13;      // abbreviated month name 13 (if exists)
    WORD      SEndOfLocale;            // end of locale information
} LOCALE_VAR, *PLOCALE_VAR;


//
//  Per entry calendar header.
//
//  The calendar header structure contains the information given in one entry
//  of the header for the calendar information.
//
typedef struct calendar_hdr_s
{
    WORD      Calendar;                // calendar id
    WORD      Offset;                  // offset to calendar info (words)
} CALENDAR_HDR, *PCALENDAR_HDR;

#define CALENDAR_HDR_SIZE  (sizeof(CALENDAR_HDR) / sizeof(WORD))

//
//  The variable structure contains the offsets to the various pieces of
//  calendar information that is of variable length.  It is in the order
//  in which it is given in the file.
//
//  The NumRanges value is the number of era ranges.  If this value is zero,
//  then there are no year offsets.
//
//  The IfNames value is a boolean.  If it is 0, then there are NO special
//  day or month names for the calendar.  If it is 1, then there ARE
//  special day and month names for the calendar.
//
//  The rest of the values are offsets to the appropriate strings.
//
typedef struct calendar_var_s
{
    WORD      NumRanges;               // number of era ranges
    WORD      IfNames;                 // if any day or month names exist
    WORD      SCalendar;               // calendar id
    WORD      STwoDigitYearMax;        // two digit year max
    WORD      SEraRanges;              // era ranges
    WORD      SShortDate;              // short date format
    WORD      SYearMonth;              // year month format
    WORD      SLongDate;               // long date format
    WORD      SDayName1;               // day name 1
    WORD      SDayName2;               // day name 2
    WORD      SDayName3;               // day name 3
    WORD      SDayName4;               // day name 4
    WORD      SDayName5;               // day name 5
    WORD      SDayName6;               // day name 6
    WORD      SDayName7;               // day name 7
    WORD      SAbbrevDayName1;         // abbreviated day name 1
    WORD      SAbbrevDayName2;         // abbreviated day name 2
    WORD      SAbbrevDayName3;         // abbreviated day name 3
    WORD      SAbbrevDayName4;         // abbreviated day name 4
    WORD      SAbbrevDayName5;         // abbreviated day name 5
    WORD      SAbbrevDayName6;         // abbreviated day name 6
    WORD      SAbbrevDayName7;         // abbreviated day name 7
    WORD      SMonthName1;             // month name 1
    WORD      SMonthName2;             // month name 2
    WORD      SMonthName3;             // month name 3
    WORD      SMonthName4;             // month name 4
    WORD      SMonthName5;             // month name 5
    WORD      SMonthName6;             // month name 6
    WORD      SMonthName7;             // month name 7
    WORD      SMonthName8;             // month name 8
    WORD      SMonthName9;             // month name 9
    WORD      SMonthName10;            // month name 10
    WORD      SMonthName11;            // month name 11
    WORD      SMonthName12;            // month name 12
    WORD      SMonthName13;            // month name 13
    WORD      SAbbrevMonthName1;       // abbreviated month name 1
    WORD      SAbbrevMonthName2;       // abbreviated month name 2
    WORD      SAbbrevMonthName3;       // abbreviated month name 3
    WORD      SAbbrevMonthName4;       // abbreviated month name 4
    WORD      SAbbrevMonthName5;       // abbreviated month name 5
    WORD      SAbbrevMonthName6;       // abbreviated month name 6
    WORD      SAbbrevMonthName7;       // abbreviated month name 7
    WORD      SAbbrevMonthName8;       // abbreviated month name 8
    WORD      SAbbrevMonthName9;       // abbreviated month name 9
    WORD      SAbbrevMonthName10;      // abbreviated month name 10
    WORD      SAbbrevMonthName11;      // abbreviated month name 11
    WORD      SAbbrevMonthName12;      // abbreviated month name 12
    WORD      SAbbrevMonthName13;      // abbreviated month name 13
    WORD      SEndOfCalendar;          // end of calendar information
} CALENDAR_VAR, *PCALENDAR_VAR;

//
//  IOptionalCalendar structure (locale info).
//
typedef struct opt_cal_s
{
    WORD      CalId;                   // calendar id
    WORD      Offset;                  // offset to next optional calendar
    WORD      pCalStr[1];              // calendar id string (variable length)
//  WORD      pCalNameStr[1];          // calendar name string (variable length)
} OPT_CAL, *POPT_CAL;


//
//  SEraRanges structure inside calendar info.
//
typedef struct era_range_s
{
    WORD      Month;                   // month of era beginning
    WORD      Day;                     // day of era beginning
    WORD      Year;                    // year of era beginning
    WORD      Offset;                  // offset to next era info block
    WORD      pYearStr[1];             // year string (variable length)
//  WORD      pEraNameStr[1];          // era name string (variable length)
} ERA_RANGE, *PERA_RANGE;


//
//  Locale Hash Table Structure.
//
typedef struct loc_hash_s {
    LCID           Locale;             // locale ID
    PLOCALE_VAR    pLocaleHdr;         // ptr to locale header info
    PLOCALE_FIXED  pLocaleFixed;       // ptr to locale fixed size info
    PCASE          pUpperCase;         // ptr to Upper Case table
    PCASE          pLowerCase;         // ptr to Lower Case table
    PCASE          pUpperLinguist;     // ptr to Upper Case Linguistic table
    PCASE          pLowerLinguist;     // ptr to Lower Case Linguistic table
    PSORTKEY       pSortkey;           // ptr to sortkey table
    BOOL           IfReverseDW;        // if DW should go from right to left
    BOOL           IfCompression;      // if compression code points exist
    BOOL           IfDblCompression;   // if double compression exists
    BOOL           IfIdeographFailure; // if ideograph table failed to load
    PCOMPRESS_HDR  pCompHdr;           // ptr to compression header
    PCOMPRESS_2    pCompress2;         // ptr to 2 compression table
    PCOMPRESS_3    pCompress3;         // ptr to 3 compression table
    struct loc_hash_s *pNext;          // ptr to next locale hash node
} LOC_HASH, *PLOC_HASH;


//
//  Hash Table Pointers.
//
typedef  PCP_HASH  *PCP_HASH_TBL;      // ptr to a code page hash table
typedef  PLOC_HASH *PLOC_HASH_TBL;     // ptr to a locale hash table


//
//  Geo Information structure. This structure holds information about
//  a geographical location on earth.
//
typedef struct tagGeoInfo {
    GEOID       GeoId;
    WCHAR       szLatitude[12];
    WCHAR       szLongitude[12];
    GEOCLASS    GeoClass;
    GEOID       ParentGeoId;
    WCHAR       szISO3166Abbrev2[4];
    WCHAR       szISO3166Abbrev3[4];
    WORD        wISO3166;
    WORD        Reserved;              // dword alignment
} GEOINFO, *PGEOINFO;


//
//  GEOID/LCID structure. This structure is used to navigate through
//  the table that maps corresponding Language ID and Geo ID.
//
typedef struct tagGEOIDLCID {
    LCID    lcid;
    GEOID   GeoId;
    LANGID  LangId;
    WORD    Reserved;                  // dword alignment
} GEOLCID, *PGEOLCID;


//
//  GEO tables structure. This structure is used to get information
//  related to all geo tables.
//
typedef struct tagGeoTableHdr {
    WCHAR           szSig[4];
    unsigned long   nFileSize;
    DWORD           dwOffsetGeoInfo;
    long            nGeoInfo;
    DWORD           dwOffsetGeoLCID;
    long            nGeoLCID;
} GEOTABLEHDR, *PGEOTABLEHDR;


//
//  Jamo Sequence Sorting Info.
//
typedef struct {
    BYTE m_bOld;                  // sequence occurs only in old Hangul flag
    CHAR m_chLeadingIndex;        // indices used to locate prior modern Hangul syllable
    CHAR m_chVowelIndex;
    CHAR m_chTrailingIndex;
    BYTE m_ExtraWeight;           // extra weights that distinguish this from
                                  //   other old Hangul syllables, depending
                                  //   on the jamo, this can be a weight for
                                  //   leading jamo, vowel jamo, or trailing jamo.
} JAMO_SORT_INFO, *PJAMO_SORT_INFO;

//
//  Jamo Index Table Entry.
//
typedef struct {
    JAMO_SORT_INFO SortInfo;      // sequence sorting info
    BYTE Index;                   // index into the composition array
    BYTE TransitionCount;         // # of possible transitions from this state
    BYTE Reserved;                // word alignment
} JAMO_TABLE, *PJAMO_TABLE;


//
//  Jamo Combination Table Entry.
//
//  NOTE: Make sure this structure is WORD aligned.  Otherwise, code will
//        fail in GetDefaultSortTable().
//
typedef struct {
    WCHAR m_wcCodePoint;          // Code point value that enters this state
    JAMO_SORT_INFO m_SortInfo;    // Sequence sorting info
    BYTE m_bTransitionCount;      // # of possible transitions from this state
} JAMO_COMPOSE_STATE, *PJAMO_COMPOSE_STATE;


//
//  Table Pointers Structure.  This structure contains pointers to
//  the various tables needed for the NLS APIs.  There should be only
//  ONE of these for each process, and the information should be
//  global to the process.
//
#define NUM_SM     256                  // total number of script members
#define NUM_CAL    64                   // total number calendars allowed

typedef struct tbl_ptrs_s {
    PCP_HASH_TBL    pCPHashTbl;         // ptr to Code Page hash table
    PLOC_HASH_TBL   pLocHashTbl;        // ptr to Locale hash table
    PLOC_INFO       pLocaleInfo;        // ptr to locale table (all locales)
    DWORD           NumCalendars;       // number of calendars
    PCAL_INFO       pCalendarInfo;      // ptr to beginning of calendar info
    PCAL_INFO       pCalTbl[NUM_CAL];   // ptr to calendar table array
    P844_TABLE      pDefaultLanguage;   // ptr to default language table
    P844_TABLE      pLinguistLanguage;  // ptr to default linguistic lang table
    LARGE_INTEGER   LinguistLangSize;   // size of linguistic lang table
    int             NumLangException;   // number of language exceptions
    PL_EXCEPT_HDR   pLangExceptHdr;     // ptr to lang exception table header
    PL_EXCEPT       pLangException;     // ptr to lang exception tables
    PCT_VALUES      pCTypeMap;          // ptr to Ctype Mapping table
    PCTYPE          pCType844;          // ptr to Ctype 8:4:4 table
    PADIGIT         pADigit;            // ptr to Ascii Digits table
    PCZONE          pCZone;             // ptr to Compatibility Zone table
    PKANA           pHiragana;          // ptr to Hiragana table
    PKANA           pKatakana;          // ptr to Katakana table
    PHALFWIDTH      pHalfWidth;         // ptr to Half Width table
    PFULLWIDTH      pFullWidth;         // ptr to Full Width table
    PCHINESE        pTraditional;       // ptr to Traditional Chinese table
    PCHINESE        pSimplified;        // ptr to Simplified Chinese table
    PPRECOMP        pPreComposed;       // ptr to PreComposed Table
    PCOMP_INFO      pComposite;         // ptr to Composite info structure
    DWORD           NumReverseDW;       // number of REVERSE DIACRITICS
    DWORD           NumDblCompression;  // number of DOUBLE COMPRESSION locales
    DWORD           NumIdeographLcid;   // number of IDEOGRAPH LCIDs
    DWORD           NumExpansion;       // number of EXPANSIONS
    DWORD           NumCompression;     // number of COMPRESSION locales
    DWORD           NumException;       // number of EXCEPTION locales
    DWORD           NumMultiWeight;     // number of MULTIPLE WEIGHTS
    int             NumJamoIndex;       // number of entires for Jamo Index Table
    int             NumJamoComposition; // number of entires for Jamo Composition Table
    PSORTKEY        pDefaultSortkey;    // ptr to default sortkey table
    LARGE_INTEGER   DefaultSortkeySize; // size of default sortkey section
    PREVERSE_DW     pReverseDW;         // ptr to reverse diacritic table
    PDBL_COMPRESS   pDblCompression;    // ptr to double compression table
    PIDEOGRAPH_LCID pIdeographLcid;     // ptr to ideograph lcid table
    PEXPAND         pExpansion;         // ptr to expansion table
    PCOMPRESS_HDR   pCompressHdr;       // ptr to compression table header
    PCOMPRESS       pCompression;       // ptr to compression tables
    PEXCEPT_HDR     pExceptHdr;         // ptr to exception table header
    PEXCEPT         pException;         // ptr to exception tables
    PMULTI_WT       pMultiWeight;       // ptr to multiple weights table
    BYTE            SMWeight[NUM_SM];   // script member weights
    PJAMO_TABLE     pJamoIndex;         // ptr ot Jamo Index table
    PJAMO_COMPOSE_STATE pJamoComposition;  // ptr to Jamo Composition state machine table
    long            nGeoInfo;           // number of GEOINFO entries
    PGEOINFO        pGeoInfo;           // ptr to gegraphical info location table
    long            nGeoLCID;           // number of GEOID/LCID entries
    PGEOLCID        pGeoLCID;           // ptr to GEOID/LCID mapping table
} TBL_PTRS, *PTBL_PTRS;

typedef struct nls_locale_cache
{
    NLS_USER_INFO NlsInfo;              // NLS cached information
    HKEY CurrentUserKeyHandle;          // Cached key handle thread impersonation

} NLS_LOCAL_CACHE, *PNLS_LOCAL_CACHE;


//
//  Generic Enum Proc Definitions.
//
typedef BOOL (CALLBACK* NLS_ENUMPROC)(PVOID);
typedef BOOL (CALLBACK* NLS_ENUMPROCEX)(PVOID, DWORD);
typedef BOOL (CALLBACK* NLS_ENUMPROC2)(DWORD, DWORD, PVOID, LONG_PTR);
typedef BOOL (CALLBACK* NLS_ENUMPROC3)(DWORD, PVOID, PVOID, DWORD, LONG_PTR);
typedef BOOL (CALLBACK* NLS_ENUMPROC4)(PVOID, LONG_PTR);





////////////////////////////////////////////////////////////////////////////
//
//  Macro Definitions.
//
////////////////////////////////////////////////////////////////////////////

//
//  Get the wide character count from a byte count.
//
#define GET_WC_COUNT(bc)          ((bc) / sizeof(WCHAR))

//
//  Get the data pointer for the KEY_VALUE_FULL_INFORMATION structure.
//
#define GET_VALUE_DATA_PTR(p)     ((LPWSTR)((PBYTE)(p) + (p)->DataOffset))

//
//  Macros For High and Low Nibbles of a BYTE.
//
#define LO_NIBBLE(b)              ((BYTE)((BYTE)(b) & 0xF))
#define HI_NIBBLE(b)              ((BYTE)(((BYTE)(b) >> 4) & 0xF))

//
//  Macros for Extracting the 8:4:4 Index Values.
//
#define GET8(w)                   (HIBYTE(w))
#define GETHI4(w)                 (HI_NIBBLE(LOBYTE(w)))
#define GETLO4(w)                 (LO_NIBBLE(LOBYTE(w)))


//
//  Macros for setting and checking most significant bit of flag.
//
#define SET_MSB(fl)               (fl |= MSB_FLAG)
#define IS_MSB(fl)                (fl & MSB_FLAG)

//
//  Macro to check if more than one bit is set.
//  Returns 1 if more than one bit set, 0 otherwise.
//
#define MORE_THAN_ONE(f, bits)    (((f & bits) - 1) & (f & bits))

//
//  Macros for single and double byte code pages.
//
#define IS_SBCS_CP(pHash)         (pHash->pCPInfo->MaxCharSize == 1)
#define IS_DBCS_CP(pHash)         (pHash->pCPInfo->MaxCharSize == 2)


////////////////////////////////////////////////////////////////////////////
//
//  TRAVERSE_844_B
//
//  Traverses the 8:4:4 translation table for the given wide character.  It
//  returns the final value of the 8:4:4 table, which is a BYTE in length.
//
//  NOTE: Offsets in table are in BYTES.
//
//    Broken Down Version:
//    --------------------
//        Incr = pTable[GET8(wch)] / sizeof(WORD);
//        Incr = pTable[Incr + GETHI4(wch)];
//        Value = (BYTE *)pTable[Incr + GETLO4(wch)];
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define TRAVERSE_844_B(pTable, wch)                                        \
    (((BYTE *)pTable)[pTable[(pTable[GET8(wch)] / sizeof(WORD)) +          \
                               GETHI4(wch)] +                              \
                      GETLO4(wch)])


////////////////////////////////////////////////////////////////////////////
//
//  TRAVERSE_844_W
//
//  Traverses the 8:4:4 translation table for the given wide character.  It
//  returns the final value of the 8:4:4 table, which is a WORD in length.
//
//    Broken Down Version:
//    --------------------
//        Incr = pTable[GET8(wch)];
//        Incr = pTable[Incr + GETHI4(wch)];
//        Value = pTable[Incr + GETLO4(wch)];
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define TRAVERSE_844_W(pTable, wch)                                        \
    (pTable[pTable[pTable[GET8(wch)] + GETHI4(wch)] + GETLO4(wch)])


////////////////////////////////////////////////////////////////////////////
//
//  TRAVERSE_844_D
//
//  Traverses the 8:4:4 translation table for the given wide character.  It
//  fills in the final word values, Value1 and Value2.  The final value of the
//  8:4:4 table is a DWORD, so both Value1 and Value2 are filled in.
//
//    Broken Down Version:
//    --------------------
//        Incr = pTable[GET8(wch)];
//        Incr = pTable[Incr + GETHI4(wch)];
//        pTable += Incr + (GETLO4(wch) * 2);
//        Value1 = pTable[0];
//        Value2 = pTable[1];
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define TRAVERSE_844_D(pTable, wch, Value1, Value2)                        \
{                                                                          \
    pTable += pTable[pTable[GET8(wch)] + GETHI4(wch)] + (GETLO4(wch) * 2); \
    Value1 = pTable[0];                                                    \
    Value2 = pTable[1];                                                    \
}


////////////////////////////////////////////////////////////////////////////
//
//  GET_INCR_VALUE
//
//  Gets the value of a given wide character from the given 8:4:4 table.  It
//  then uses the value as an increment by adding it to the given wide
//  character code point.
//
//  NOTE:  Whenever there is no translation for the given code point, the
//         tables will return an increment value of 0.  This way, the
//         wide character passed in is the same value that is returned.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_INCR_VALUE(p844Tbl, wch)                                       \
     ((WCHAR)(wch + TRAVERSE_844_W(p844Tbl, wch)))


////////////////////////////////////////////////////////////////////////////
//
//  GET_LOWER_UPPER_CASE
//
//  Gets the lower/upper case value of a given wide character.  If a
//  lower/upper case value exists, it returns the lower/upper case wide
//  character.  Otherwise, it returns the same character passed in wch.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_LOWER_UPPER_CASE(pCaseTbl, wch)                                \
    (GET_INCR_VALUE(pCaseTbl, wch))


////////////////////////////////////////////////////////////////////////////
//
//  GET_ASCII_DIGITS
//
//  Gets the ascii translation for the given digit character.  If no
//  translation is found, then the given character is returned.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_ASCII_DIGITS(pADigit, wch)                                     \
    (GET_INCR_VALUE(pADigit, wch))


////////////////////////////////////////////////////////////////////////////
//
//  GET_FOLD_CZONE
//
//  Gets the translation for the given compatibility zone character.  If no
//  translation is found, then the given character is returned.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_FOLD_CZONE(pCZone, wch)                                        \
    (GET_INCR_VALUE(pCZone, wch))


////////////////////////////////////////////////////////////////////////////
//
//  GET_KANA
//
//  Gets the Hiragana/Katakana equivalent for the given Katakana/Hiragana
//  character.  If no translation is found, then the given character is
//  returned.
//
//  DEFINED AS A MACRO.
//
//  07-14-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_KANA(pKana, wch)                                               \
    (GET_INCR_VALUE(pKana, wch))


////////////////////////////////////////////////////////////////////////////
//
//  GET_HALF_WIDTH
//
//  Gets the Half Width equivalent for the given Full Width character.  If no
//  translation is found, then the given character is returned.
//
//  DEFINED AS A MACRO.
//
//  07-14-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_HALF_WIDTH(pHalf, wch)                                         \
    (GET_INCR_VALUE(pHalf, wch))


////////////////////////////////////////////////////////////////////////////
//
//  GET_FULL_WIDTH
//
//  Gets the Full Width equivalent for the given Half Width character.  If no
//  translation is found, then the given character is returned.
//
//  DEFINED AS A MACRO.
//
//  07-14-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_FULL_WIDTH(pFull, wch)                                         \
    (GET_INCR_VALUE(pFull, wch))


////////////////////////////////////////////////////////////////////////////
//
//  GET_CHINESE
//
//  Gets the Traditional/Simplified Chinese translation for the given
//  Simplified/Traditional Chinese character.  If no translation is found,
//  then the given character is returned.
//
//  DEFINED AS A MACRO.
//
//  05-07-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_CHINESE(pChinese, wch)                                         \
    (GET_INCR_VALUE(pChinese, wch))


////////////////////////////////////////////////////////////////////////////
//
//  GET_CTYPE
//
//  Gets the ctype information for a given wide character.  If the ctype
//  information exists, it returns it.  Otherwise, it returns 0.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_CTYPE(wch, offset)                                             \
    ((((PCT_VALUES)(pTblPtrs->pCTypeMap)) +                                \
      (TRAVERSE_844_B((pTblPtrs->pCType844), wch)))->offset)


////////////////////////////////////////////////////////////////////////////
//
//  GET_BASE_CHAR
//
//  Gets the base character of a given precomposed character.  If the
//  composite form is found, it returns the base character.  Otherwise,
//  it returns 0 for failure.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_BASE_CHAR(wch, Base)                                           \
{                                                                          \
    WCHAR NonSp;                  /* nonspacing character */               \
    WCHAR NewBase;                /* base character - temp holder */       \
                                                                           \
                                                                           \
    /*                                                                     \
     *  Get composite characters.                                          \
     */                                                                    \
    if (GetCompositeChars(wch, &NonSp, &Base))                             \
    {                                                                      \
        while (GetCompositeChars(Base, &NonSp, &NewBase))                  \
        {                                                                  \
            Base = NewBase;                                                \
        }                                                                  \
    }                                                                      \
    else                                                                   \
    {                                                                      \
        /*                                                                 \
         *  Return failure - no composite form.                            \
         */                                                                \
        Base = 0;                                                          \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  SORTKEY WEIGHT MACROS
//
//  Parse out the different sortkey weights from a DWORD value.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_SCRIPT_MEMBER(pwt)  ( (BYTE)(((PSORTKEY)(pwt))->UW.SM_AW.Script) )
#define GET_ALPHA_NUMERIC(pwt)  ( (BYTE)(((PSORTKEY)(pwt))->UW.SM_AW.Alpha) )

#define GET_UNICODE(pwt)        ( (WORD)(((PSORTKEY)(pwt))->UW.Unicode) )

#define GET_UNICODE_SM(pwt, sm) ( (WORD)(((PSORTKEY)(pwt))->UW.Unicode) )

#define GET_UNICODE_MOD(pwt, modify_sm)                                    \
    ( (modify_sm) ?                                                        \
        ((WORD)                                                            \
         ((((WORD)((pTblPtrs->SMWeight)[GET_SCRIPT_MEMBER(pwt)])) << 8) |  \
          (WORD)GET_ALPHA_NUMERIC(pwt))) :                                 \
        ((WORD)(((PSORTKEY)(pwt))->UW.Unicode)) )

#define GET_UNICODE_SM_MOD(pwt, sm, modify_sm)                             \
    ( (modify_sm) ?                                                        \
        ((WORD)                                                            \
         ((((WORD)((pTblPtrs->SMWeight)[sm])) << 8) |                      \
          (WORD)GET_ALPHA_NUMERIC(pwt))) :                                 \
        ((WORD)(((PSORTKEY)(pwt))->UW.Unicode)) )

#define MAKE_UNICODE_WT(sm, aw, modify_sm)                                 \
    ( (modify_sm) ?                                                        \
        ((WORD)((((WORD)((pTblPtrs->SMWeight)[sm])) << 8) | (WORD)(aw))) : \
        ((WORD)((((WORD)(sm)) << 8) | (WORD)(aw))) )

#define UNICODE_WT(pwt)           ( (WORD)(((PSORTKEY)(pwt))->UW.Unicode) )

#define GET_DIACRITIC(pwt)        ( (BYTE)(((PSORTKEY)(pwt))->Diacritic) )

#define GET_CASE(pwt)             ( (BYTE)((((PSORTKEY)(pwt))->Case) & CASE_MASK) )

#define CASE_WT(pwt)              ( (BYTE)(((PSORTKEY)(pwt))->Case) )

#define GET_COMPRESSION(pwt)      ( (BYTE)((((PSORTKEY)(pwt))->Case) & COMPRESS_3_MASK) )

#define GET_EXPAND_INDEX(pwt)     ( (BYTE)(((PSORTKEY)(pwt))->UW.SM_AW.Alpha) )

#define GET_SPECIAL_WEIGHT(pwt)   ( (WORD)(((PSORTKEY)(pwt))->UW.Unicode) )

//  position returned is backwards - byte reversal
#define GET_POSITION_SW(pos)      ( (WORD)(((pos) << 2) | SW_POSITION_MASK) )


#define GET_WT_FOUR(pwt)          ( (BYTE)(((PEXTRA_WT)(pwt))->Four) )
#define GET_WT_FIVE(pwt)          ( (BYTE)(((PEXTRA_WT)(pwt))->Five) )
#define GET_WT_SIX(pwt)           ( (BYTE)(((PEXTRA_WT)(pwt))->Six) )
#define GET_WT_SEVEN(pwt)         ( (BYTE)(((PEXTRA_WT)(pwt))->Seven) )


#define MAKE_SORTKEY_DWORD(wt)    ( (DWORD)(*((LPDWORD)(&(wt)))) )

#define MAKE_EXTRA_WT_DWORD(wt)   ( (DWORD)(*((LPDWORD)(&(wt)))) )

#define GET_DWORD_WEIGHT(pHashN, wch)                                      \
    ( MAKE_SORTKEY_DWORD(((pHashN)->pSortkey)[wch]) )

#define GET_EXPANSION_1(pwt)                                               \
    ( ((pTblPtrs->pExpansion)[GET_EXPAND_INDEX(pwt)]).UCP1 )

#define GET_EXPANSION_2(pwt)                                               \
    ( ((pTblPtrs->pExpansion)[GET_EXPAND_INDEX(pwt)]).UCP2 )




#define IS_SYMBOL(pSkey, wch)                                              \
    ( (GET_SCRIPT_MEMBER(&((pSkey)[wch])) >= PUNCTUATION) &&               \
      (GET_SCRIPT_MEMBER(&((pSkey)[wch])) <= SYMBOL_5) )

#define IS_NONSPACE_ONLY(pSkey, wch)                                       \
    ( GET_SCRIPT_MEMBER(&((pSkey)[wch])) == NONSPACE_MARK )

#define IS_NONSPACE(pSkey, wch)                                            \
    ( (GET_SCRIPT_MEMBER(&((pSkey)[wch])) == NONSPACE_MARK) ||             \
      (GET_DIACRITIC(&((pSkey)[wch])) > MIN_DW) )

#define IS_ALPHA(ctype1)          ( (ctype1) & C1_ALPHA )




#define IS_KOREAN(lcid)                                                    \
    ( LANGIDFROMLCID(lcid) == MAKELANGID(LANG_KOREAN, SUBLANG_KOREAN) )




////////////////////////////////////////////////////////////////////////////
//
//  CHECK_SPECIAL_LOCALES
//
//  Checks for the special locale values and sets the Locale to the
//  appropriate value.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define CHECK_SPECIAL_LOCALES(Locale, UseCachedLocaleId)                    \
{                                                                           \
    /*                                                                      \
     *  Check for special locale values.                                    \
     */                                                                     \
    if (Locale == LOCALE_SYSTEM_DEFAULT)                                    \
    {                                                                       \
        /*                                                                  \
         *  Get the System Default locale value.                            \
         */                                                                 \
        Locale = gSystemLocale;                                             \
    }                                                                       \
    else if ((Locale == LOCALE_NEUTRAL) || (Locale == LOCALE_USER_DEFAULT)) \
    {                                                                       \
        /*                                                                  \
         *  Get the User locale value.                                      \
         */                                                                 \
        if (!UseCachedLocaleId)                                             \
        {                                                                   \
            Locale = GetUserDefaultLCID();                                  \
        }                                                                   \
        else                                                                \
        {                                                                   \
            Locale = pNlsUserInfo->UserLocaleId;                            \
        }                                                                   \
    }                                                                       \
    /*                                                                      \
     *  Check for a valid primary language and a neutral sublanguage.       \
     */                                                                     \
    else if (SUBLANGID(LANGIDFROMLCID(Locale)) == SUBLANG_NEUTRAL)          \
    {                                                                       \
        /*                                                                  \
         *  Re-form the locale id using the primary language and the        \
         *  default sublanguage.                                            \
         */                                                                 \
        Locale = MAKELCID(MAKELANGID(PRIMARYLANGID(LANGIDFROMLCID(Locale)), \
                                     SUBLANG_DEFAULT),                      \
                          SORTIDFROMLCID(Locale));                          \
    }                                                                       \
}


////////////////////////////////////////////////////////////////////////////
//
//  IS_INVALID_LOCALE
//
//  Checks to see that only the proper bits are used in the locale.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NLS_VALID_LOCALE_MASK          0x000fffff
#define IS_INVALID_LOCALE(Locale)      ( Locale & ~NLS_VALID_LOCALE_MASK )


////////////////////////////////////////////////////////////////////////////
//
//  VALIDATE_LANGUAGE
//
//  Checks that the given Locale contains a valid language id.  It does so
//  by making sure the appropriate casing and sorting tables are present.
//  If the language is valid, pLocHashN will be non-NULL.  Otherwise,
//  pLocHashN will be NULL.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define VALIDATE_LANGUAGE(Locale, pLocHashN, dwFlags, UseCachedLocaleId)   \
{                                                                          \
    /*                                                                     \
     *  Check the system locale first for speed.  This is the most         \
     *  likely one to be used.                                             \
     */                                                                    \
    if (Locale == gSystemLocale)                                           \
    {                                                                      \
        pLocHashN = gpSysLocHashN;                                         \
    }                                                                      \
    /*                                                                     \
     *  Check the invariant locale second for speed.  This is the second   \
     *  most likely one to be used.                                        \
     */                                                                    \
    else if (Locale == LOCALE_INVARIANT)                                   \
    {                                                                      \
        pLocHashN = gpInvLocHashN;                                         \
    }                                                                      \
    else                                                                   \
    {                                                                      \
        /*                                                                 \
         *  Check special locale values.                                   \
         */                                                                \
        CHECK_SPECIAL_LOCALES(Locale, UseCachedLocaleId);                  \
                                                                           \
        /*                                                                 \
         *  If the locale is the system default, then the hash node is     \
         *  already stored in a global.                                    \
         */                                                                \
        if (Locale == gSystemLocale)                                       \
        {                                                                  \
            pLocHashN = gpSysLocHashN;                                     \
        }                                                                  \
        else if (IS_INVALID_LOCALE(Locale))                                \
        {                                                                  \
            pLocHashN = NULL;                                              \
        }                                                                  \
        else                                                               \
        {                                                                  \
            /*                                                             \
             *  Need to make sure the locale value is valid.  Need to      \
             *  check the locale file to see if the locale is supported.   \
             */                                                            \
            pLocHashN = GetLocHashNode(Locale);                            \
                                                                           \
            if (pLocHashN != NULL)                                         \
            {                                                              \
                /*                                                         \
                 *  Make sure the appropriate casing and sorting tables    \
                 *  are in the system.                                     \
                 *                                                         \
                 *  NOTE:  If the call fails, pLocHashN will be NULL.      \
                 */                                                        \
                pLocHashN = GetLangHashNode(Locale, dwFlags);              \
            }                                                              \
        }                                                                  \
    }                                                                      \
                                                                           \
    /*                                                                     \
     *  Make sure we don't need to get the linguistic tables.              \
     */                                                                    \
    if ((dwFlags) && (pLocHashN) && (pLocHashN->pLowerLinguist == NULL))   \
    {                                                                      \
        /*                                                                 \
         *  Get locale hash node to make sure the appropriate              \
         *  casing and sorting tables are in the system.                   \
         */                                                                \
        pLocHashN = GetLangHashNode(Locale, dwFlags);                      \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  VALIDATE_LOCALE
//
//  Checks that the given LCID contains a valid locale id.  It does so
//  by making sure the appropriate locale information is present.  If the
//  locale is valid, pLocHashN will be non-NULL.  Otherwise, pLocHashN
//  will be NULL.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define VALIDATE_LOCALE(Locale, pLocHashN, UseCachedLocaleId)              \
{                                                                          \
    /*                                                                     \
     *  Check the system locale first for speed.  This is the most         \
     *  likely one to be used.                                             \
     */                                                                    \
    if (Locale == gSystemLocale)                                           \
    {                                                                      \
        pLocHashN = gpSysLocHashN;                                         \
    }                                                                      \
    /*                                                                     \
     *  Check the invariant locale second for speed.  This is the second   \
     *  most likely one to be used.                                        \
     */                                                                    \
    else if (Locale == LOCALE_INVARIANT)                                   \
    {                                                                      \
        pLocHashN = gpInvLocHashN;                                         \
    }                                                                      \
    else                                                                   \
    {                                                                      \
        /*                                                                 \
         *  Check special locale values.                                   \
         */                                                                \
        CHECK_SPECIAL_LOCALES(Locale, UseCachedLocaleId);                  \
                                                                           \
        /*                                                                 \
         *  If the locale is the system default, then the hash node        \
         *  is already stored in a global.                                 \
         */                                                                \
        if (Locale == gSystemLocale)                                       \
        {                                                                  \
            pLocHashN = gpSysLocHashN;                                     \
        }                                                                  \
        else if (IS_INVALID_LOCALE(Locale))                                \
        {                                                                  \
            pLocHashN = NULL;                                              \
        }                                                                  \
        else                                                               \
        {                                                                  \
            /*                                                             \
             *  Get locale hash node to make sure the appropriate          \
             *  locale table is in the system.                             \
             *                                                             \
             *  NOTE:  If the call fails, pLocHashN will be NULL.          \
             */                                                            \
            pLocHashN = GetLocHashNode(Locale);                            \
        }                                                                  \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  OPEN_CODEPAGE_KEY
//
//  Opens the key for the code page section of the registry for read access.
//
//  DEFINED AS A MACRO.
//
//  09-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define OPEN_CODEPAGE_KEY(ReturnVal)                                       \
{                                                                          \
    /*                                                                     \
     *  Make sure code page key is open.                                   \
     */                                                                    \
    if (hCodePageKey == NULL)                                              \
    {                                                                      \
        RtlEnterCriticalSection(&gcsTblPtrs);                              \
        if (hCodePageKey == NULL)                                          \
        {                                                                  \
            if (OpenRegKey( &hCodePageKey,                                 \
                            NLS_HKLM_SYSTEM,                               \
                            NLS_CODEPAGE_KEY,                              \
                            KEY_READ ))                                    \
            {                                                              \
                SetLastError(ERROR_BADDB);                                 \
                RtlLeaveCriticalSection(&gcsTblPtrs);                      \
                return (ReturnVal);                                        \
            }                                                              \
        }                                                                  \
        RtlLeaveCriticalSection(&gcsTblPtrs);                              \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  OPEN_LOCALE_KEY
//
//  Opens the key for the locale section of the registry for read access.
//
//  DEFINED AS A MACRO.
//
//  09-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define OPEN_LOCALE_KEY(ReturnVal)                                         \
{                                                                          \
    /*                                                                     \
     *  Make sure locale key is open.                                      \
     */                                                                    \
    if (hLocaleKey == NULL)                                                \
    {                                                                      \
        RtlEnterCriticalSection(&gcsTblPtrs);                              \
        if (hLocaleKey == NULL)                                            \
        {                                                                  \
            if (OpenRegKey( &hLocaleKey,                                   \
                            NLS_HKLM_SYSTEM,                               \
                            NLS_LOCALE_KEY,                                \
                            KEY_READ ))                                    \
            {                                                              \
                SetLastError(ERROR_BADDB);                                 \
                RtlLeaveCriticalSection(&gcsTblPtrs);                      \
                return (ReturnVal);                                        \
            }                                                              \
        }                                                                  \
        RtlLeaveCriticalSection(&gcsTblPtrs);                              \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  OPEN_ALT_SORTS_KEY
//
//  Opens the key for the alternate sorts section of the registry for read
//  access.
//
//  DEFINED AS A MACRO.
//
//  11-15-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define OPEN_ALT_SORTS_KEY(ReturnVal)                                      \
{                                                                          \
    /*                                                                     \
     *  Make sure alternate sorts key is open.                             \
     */                                                                    \
    if (hAltSortsKey == NULL)                                              \
    {                                                                      \
        RtlEnterCriticalSection(&gcsTblPtrs);                              \
        if (hAltSortsKey == NULL)                                          \
        {                                                                  \
            if (OpenRegKey( &hAltSortsKey,                                 \
                            NLS_HKLM_SYSTEM,                               \
                            NLS_ALT_SORTS_KEY,                             \
                            KEY_READ ))                                    \
            {                                                              \
                SetLastError(ERROR_BADDB);                                 \
                RtlLeaveCriticalSection(&gcsTblPtrs);                      \
                return (ReturnVal);                                        \
            }                                                              \
        }                                                                  \
        RtlLeaveCriticalSection(&gcsTblPtrs);                              \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  OPEN_LANG_GROUPS_KEY
//
//  Opens the key for the language groups section of the registry for
//  read access.
//
//  DEFINED AS A MACRO.
//
//  09-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define OPEN_LANG_GROUPS_KEY(ReturnVal)                                    \
{                                                                          \
    /*                                                                     \
     *  Make sure language groups key is open.                             \
     */                                                                    \
    if (hLangGroupsKey == NULL)                                            \
    {                                                                      \
        RtlEnterCriticalSection(&gcsTblPtrs);                              \
        if (hLangGroupsKey == NULL)                                        \
        {                                                                  \
            if (OpenRegKey( &hLangGroupsKey,                               \
                            NLS_HKLM_SYSTEM,                               \
                            NLS_LANGUAGE_GROUPS_KEY,                       \
                            KEY_READ ))                                    \
            {                                                              \
                SetLastError(ERROR_BADDB);                                 \
                RtlLeaveCriticalSection(&gcsTblPtrs);                      \
                return (ReturnVal);                                        \
            }                                                              \
        }                                                                  \
        RtlLeaveCriticalSection(&gcsTblPtrs);                              \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  OPEN_MUILANG_KEY
//
//  Opens the key for the multilingual UI language section of the registry
//  for read access.  It is acceptable if this key is not in the registry,
//  so do not call SetLastError if the key cannot be opened.
//
//  DEFINED AS A MACRO.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define OPEN_MUILANG_KEY(hKey, ReturnVal)                                  \
{                                                                          \
    if ((hKey) == NULL)                                                    \
    {                                                                      \
        if (OpenRegKey( &(hKey),                                           \
                        NLS_HKLM_SYSTEM,                                   \
                        NLS_MUILANG_KEY,                                   \
                        KEY_READ ))                                        \
        {                                                                  \
            return (ReturnVal);                                            \
        }                                                                  \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  OPEN_CPANEL_INTL_KEY
//
//  Opens the key for the control panel international section of the
//  registry for the given access.
//
//  DEFINED AS A MACRO.
//
//  09-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define OPEN_CPANEL_INTL_KEY(hKey, ReturnVal, Access)                      \
{                                                                          \
    if ((hKey) == NULL)                                                    \
    {                                                                      \
        if (OpenRegKey( &(hKey),                                           \
                        NULL,                                              \
                        NLS_CTRL_PANEL_KEY,                                \
                        Access ))                                          \
        {                                                                  \
            SetLastError(ERROR_BADDB);                                     \
            return (ReturnVal);                                            \
        }                                                                  \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  OPEN_GEO_KEY
//
//  Opens the key for the geographic information section of the registry
//  for read access.
//
//  DEFINED AS A MACRO.
//
//  03-10-00    lguindon    Created.
////////////////////////////////////////////////////////////////////////////

#define OPEN_GEO_KEY(hKey, ReturnVal, Access)                              \
{                                                                          \
    if ((hKey) == NULL)                                                    \
    {                                                                      \
        if (OpenRegKey( &(hKey),                                           \
                        NULL,                                              \
                        GEO_REG_KEY,                                       \
                        Access ))                                          \
        {                                                                  \
            SetLastError(ERROR_BADDB);                                     \
            return (ReturnVal);                                            \
        }                                                                  \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  CLOSE_REG_KEY
//
//  Closes the given registry key.
//
//  DEFINED AS A MACRO.
//
//  09-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define CLOSE_REG_KEY(hKey)                                                \
{                                                                          \
    if ((hKey) != NULL)                                                    \
    {                                                                      \
        NtClose(hKey);                                                     \
        hKey = NULL;                                                       \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  NLS_ALLOC_MEM
//
//  Allocates the given number of bytes of memory from the process heap,
//  zeros the memory buffer, and returns the handle.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NLS_ALLOC_MEM(dwBytes)                                             \
    ( RtlAllocateHeap( RtlProcessHeap(),                                   \
                       HEAP_ZERO_MEMORY,                                   \
                       dwBytes ) )


////////////////////////////////////////////////////////////////////////////
//
//  NLS_FREE_MEM
//
//  Frees the memory of the given handle from the process heap.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NLS_FREE_MEM(hMem)                                                 \
    ( (hMem) ? (RtlFreeHeap( RtlProcessHeap(),                             \
                             0,                                            \
                             (PVOID)hMem ))                                \
             : 0 )


////////////////////////////////////////////////////////////////////////////
//
//  NLS_FREE_TMP_BUFFER
//
//  Checks to see if the buffer is the same as the static buffer.  If it
//  is NOT the same, then the buffer is freed.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NLS_FREE_TMP_BUFFER(pBuf, pStaticBuf)                              \
{                                                                          \
    if (pBuf != pStaticBuf)                                                \
    {                                                                      \
        NLS_FREE_MEM(pBuf);                                                \
    }                                                                      \
}

////////////////////////////////////////////////////////////////////////////
//
//  ARRAYSIZE
//
//  Hnady utility macro to get the size of an array (such as an array of
//  WCHARs).
////////////////////////////////////////////////////////////////////////////
#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x)/sizeof((x)[0]))
#endif



////////////////////////////////////////////////////////////////////////////
//
//  Function Prototypes
//
////////////////////////////////////////////////////////////////////////////

//
//  Table Routines - tables.c.
//
ULONG
AllocTables(void);

ULONG
GetUnicodeFileInfo(void);

ULONG
GetGeoFileInfo(void);

ULONG
GetCTypeFileInfo(void);

ULONG
GetDefaultSortkeyFileInfo(void);

ULONG
GetDefaultSortTablesFileInfo(void);

ULONG
GetSortkeyFileInfo(
    LCID Locale,
    PLOC_HASH pHashN);

void
GetSortTablesFileInfo(
    LCID Locale,
    PLOC_HASH pHashN);

ULONG
GetCodePageFileInfo(
    UINT CodePage,
    PCP_HASH *ppNode);

ULONG
GetLanguageFileInfo(
    LCID Locale,
    PLOC_HASH *ppNode,
    BOOLEAN fCreateNode,
    DWORD dwFlags);

ULONG
GetLocaleFileInfo(
    LCID Locale,
    PLOC_HASH *ppNode,
    BOOLEAN fCreateNode);

ULONG
MakeCPHashNode(
    UINT CodePage,
    LPWORD pBaseAddr,
    PCP_HASH *ppNode,
    BOOL IsDLL,
    LPFN_CP_PROC pfnCPProc);

ULONG
MakeLangHashNode(
    LCID Locale,
    LPWORD pBaseAddr,
    PLOC_HASH *ppNode,
    BOOLEAN fCreateNode);

ULONG
MakeLocHashNode(
    LCID Locale,
    LPWORD pBaseAddr,
    PLOC_HASH *ppNode,
    BOOLEAN fCreateNode);

PCP_HASH FASTCALL
GetCPHashNode(
    UINT CodePage);

PLOC_HASH FASTCALL
GetLangHashNode(
    LCID Locale,
    DWORD dwFlags);

BOOL
IsCPHashNodeLoaded(
    UINT CodePage);

PLOC_HASH FASTCALL
GetLocHashNode(
    LCID Locale);

ULONG
GetCalendar(
    CALID Calendar,
    PCAL_INFO *ppCalInfo);


//
//  Section Routines - section.c.
//
ULONG
CreateNlsObjectDirectory(void);

ULONG
CreateRegKey(
    PHANDLE phKeyHandle,
    LPWSTR pBaseName,
    LPWSTR pKey,
    ULONG fAccess);

ULONG
OpenRegKey(
    PHANDLE phKeyHandle,
    LPWSTR pBaseName,
    LPWSTR pKey,
    ULONG fAccess);

ULONG
QueryRegValue(
    HANDLE hKeyHandle,
    LPWSTR pValue,
    PKEY_VALUE_FULL_INFORMATION *ppKeyValueFull,
    ULONG Length,
    LPBOOL pIfAlloc);

ULONG
SetRegValue(
    HANDLE hKeyHandle,
    LPCWSTR pValue,
    LPCWSTR pData,
    ULONG DataLength);

ULONG
CreateSectionTemp(
    HANDLE *phSec,
    LPWSTR pwszFileName);

ULONG
OpenSection(
    HANDLE *phSec,
    PUNICODE_STRING pObSectionName,
    PVOID *ppBaseAddr,
    ULONG AccessMask,
    BOOL bCloseHandle);

ULONG
MapSection(
    HANDLE hSec,
    PVOID *ppBaseAddr,
    ULONG PageProtection,
    BOOL bCloseHandle);

ULONG
UnMapSection(
    PVOID pBaseAddr);

ULONG
GetNlsSectionName(
    UINT Value,
    UINT Base,
    UINT Padding,
    LPWSTR pwszPrefix,
    LPWSTR pwszSecName,
    UINT cchSecName);

ULONG
GetCodePageDLLPathName(
    UINT CodePage,
    LPWSTR pDllName,
    USHORT cchLen);


//
//  Utility Routines - util.c.
//
BOOL GetCPFileNameFromRegistry(
    UINT    CodePage,
    LPWSTR  pResultBuf,
    UINT    Size);
  
BOOL GetUserInfoFromRegistry(
    LPWSTR pValue,
    LPWSTR pOutput,
    LCID Locale);

int
GetStringTableEntry(
    UINT ResourceID,
    LANGID UILangId,
    LPWSTR pBuffer,
    int cchBuffer,
    int WhichString);

BOOL
IsValidSeparatorString(
    LPCWSTR pString,
    ULONG MaxLength,
    BOOL fCheckZeroLen);

BOOL
IsValidGroupingString(
    LPCWSTR pString,
    ULONG MaxLength,
    BOOL fCheckZeroLen);

LPWORD
IsValidCalendarType(
    PLOC_HASH pHashN,
    CALID CalId);

LPWORD
IsValidCalendarTypeStr(
    PLOC_HASH pHashN,
    LPCWSTR pCalStr);

BOOL
GetUserInfo(
    LCID Locale,
    LCTYPE LCType ,
    SIZE_T CacheOffset,
    LPWSTR pValue,
    LPWSTR pOutput,
    size_t cchOutput,
    BOOL fCheckNull);

WCHAR FASTCALL
GetPreComposedChar(
    WCHAR wcNonSp,
    WCHAR wcBase);

BOOL FASTCALL
GetCompositeChars(
    WCHAR wch,
    WCHAR *pNonSp,
    WCHAR *pBase);

int FASTCALL
InsertPreComposedForm(
    LPCWSTR pWCStr,
    LPWSTR pEndWCStr,
    LPWSTR pPreComp);

int FASTCALL
InsertFullWidthPreComposedForm(
    LPCWSTR pWCStr,
    LPWSTR pEndWCStr,
    LPWSTR pPreComp,
    PCASE pCase);

int FASTCALL
InsertCompositeForm(
    LPWSTR pWCStr,
    LPWSTR pEndWCStr);

ULONG
NlsConvertIntegerToString(
    UINT Value,
    UINT Base,
    UINT Padding,
    LPWSTR pResultBuf,
    UINT Size);

BOOL FASTCALL
NlsConvertIntegerToHexStringW(
    UINT Value,
    BOOL UpperCase,
    PWSTR Str,
    UINT Width);

BOOL FASTCALL
NlsConvertStringToIntegerW(
    PWSTR str,
    UINT Base,
    int CharCount,
    UINT* Result);

BOOL FASTCALL
NlsIsDll(
    LPCWSTR pFileName);

LPWSTR FASTCALL
NlsStrCpyW(
    LPWSTR pwszDest,
    LPCWSTR pwszSrc);

LPWSTR FASTCALL
NlsStrCatW(
    LPWSTR pwsz1,
    LPCWSTR pwsz2);

int FASTCALL
NlsStrLenW(
    LPCWSTR pwsz);

LPWSTR FASTCALL
NlsStrNCatW(
    LPWSTR pwszFront,
    LPCWSTR pwszBack,
    int Count);

int FASTCALL
NlsStrEqualW(
    LPCWSTR pwszFirst,
    LPCWSTR pwszSecond);

int FASTCALL
NlsStrNEqualW(
    LPCWSTR pwszFirst,
    LPCWSTR pwszSecond,
    int Count);

//
//  Security Routines - security.c.
//

NTSTATUS
NlsCheckForInteractiveUser();

NTSTATUS
NlsIsInteractiveUserProcess();

NTSTATUS
NlsGetUserLocale(
    LCID *Lcid);

NTSTATUS
NlsGetCurrentUserNlsInfo(
    LCID Locale,
    LCTYPE LCType,
    PWSTR RegistryValue,
    PWSTR pOutputBuffer,
    BOOL IgnoreLocaleValue);


NTSTATUS
NlsQueryCurrentUserInfo(
    PNLS_LOCAL_CACHE pNlsCache,
    LPWSTR pValue,
    LPWSTR pOutput);

NTSTATUS
NlsFlushProcessCache(
    LCTYPE LCType);


//
//  Internal Enumeration routines - enum.c.
//
BOOL
Internal_EnumSystemLanguageGroups(
    NLS_ENUMPROC lpLanguageGroupEnumProc,
    DWORD dwFlags,
    LONG_PTR lParam,
    BOOL fUnicodeVer);

BOOL
Internal_EnumLanguageGroupLocales(
    NLS_ENUMPROC lpLangGroupLocaleEnumProc,
    LGRPID LanguageGroup,
    DWORD dwFlags,
    LONG_PTR lParam,
    BOOL fUnicodeVer);

BOOL
Internal_EnumUILanguages(
    NLS_ENUMPROC lpUILanguageEnumProc,
    DWORD dwFlags,
    LONG_PTR lParam,
    BOOL fUnicodeVer);

BOOL
Internal_EnumSystemLocales(
    NLS_ENUMPROC lpLocaleEnumProc,
    DWORD dwFlags,
    BOOL fUnicodeVer);

BOOL
Internal_EnumSystemCodePages(
    NLS_ENUMPROC lpCodePageEnumProc,
    DWORD dwFlags,
    BOOL fUnicodeVer);

BOOL
Internal_EnumCalendarInfo(
    NLS_ENUMPROC lpCalInfoEnumProc,
    LCID Locale,
    CALID Calendar,
    CALTYPE CalType,
    BOOL fUnicodeVer,
    BOOL fExVersion);

BOOL
Internal_EnumTimeFormats(
    NLS_ENUMPROC lpTimeFmtEnumProc,
    LCID Locale,
    DWORD dwFlags,
    BOOL fUnicodeVer);

BOOL
Internal_EnumDateFormats(
    NLS_ENUMPROC lpDateFmtEnumProc,
    LCID Locale,
    DWORD dwFlags,
    BOOL fUnicodeVer,
    BOOL fExVersion);


//
//  Ansi routines - ansi.c.
//
BOOL
NlsDispatchAnsiEnumProc(
    LCID Locale,
    NLS_ENUMPROC pNlsEnumProc,
    DWORD dwFlags,
    LPWSTR pUnicodeBuffer1,
    LPWSTR pUnicodeBuffer2,
    DWORD dwValue1,
    DWORD dwValue2,
    LONG_PTR lParam,
    BOOL fVersion);


//
//  Translation Routines - mbcs.c.
//
int
SpecialMBToWC(
    PCP_HASH pHashN,
    DWORD dwFlags,
    LPCSTR lpMultiByteStr,
    int cbMultiByte,
    LPWSTR lpWideCharStr,
    int cchWideChar);


//
//  UTF Translation Routines - utf.c.
//
BOOL
UTFCPInfo(
    UINT CodePage,
    LPCPINFO lpCPInfo,
    BOOL fExVer);

int
UTFToUnicode(
    UINT CodePage,
    DWORD dwFlags,
    LPCSTR lpMultiByteStr,
    int cbMultiByte,
    LPWSTR lpWideCharStr,
    int cchWideChar);

int
UnicodeToUTF(
    UINT CodePage,
    DWORD dwFlags,
    LPCWSTR lpWideCharStr,
    int cchWideChar,
    LPSTR lpMultiByteStr,
    int cbMultiByte,
    LPCSTR lpDefaultChar,
    LPBOOL lpUsedDefaultChar);


//
// Locale/Calendar Info (locale.c)
//
BOOL
GetTwoDigitYearInfo(
    CALID Calendar,
    LPWSTR pYearInfo,
    PWSTR pwszKeyPath);





////////////////////////////////////////////////////////////////////////////
//
//  Global Variables
//
//  All of the global variables for the NLSAPI should be put here.  These are
//  all instance-specific.  In general, there shouldn't be much reason to
//  create instance globals.
//
//  Globals are included last because they may require some of the types
//  being defined above.
//
////////////////////////////////////////////////////////////////////////////

extern PTBL_PTRS        pTblPtrs;           // ptr to structure of table ptrs
extern HANDLE           hModule;            // handle to module
extern RTL_CRITICAL_SECTION gcsTblPtrs;     // critical section for tbl ptrs

extern UINT             gAnsiCodePage;      // Ansi code page value
extern UINT             gOemCodePage;       // OEM code page value
extern UINT             gMacCodePage;       // MAC code page value
extern LCID             gSystemLocale;      // system locale value
extern LANGID           gSystemInstallLang; // system's original install language
extern PLOC_HASH        gpSysLocHashN;      // ptr to system loc hash node
extern PLOC_HASH        gpInvLocHashN;      // ptr to invariant loc hash node
extern PCP_HASH         gpACPHashN;         // ptr to ACP hash node
extern PCP_HASH         gpOEMCPHashN;       // ptr to OEMCP hash node
extern PCP_HASH         gpMACCPHashN;       // ptr to MAC hash node

extern HANDLE           hCodePageKey;       // handle to System\Nls\CodePage key
extern HANDLE           hLocaleKey;         // handle to System\Nls\Locale key
extern HANDLE           hAltSortsKey;       // handle to Locale\Alternate Sorts key
extern HANDLE           hLangGroupsKey;     // handle to System\Nls\Language Groups key

extern PNLS_USER_INFO   pNlsUserInfo;       // ptr to the user info cache

extern BOOL gInteractiveLogonUserProcess;    // running in interactive user session or not.
extern RTL_CRITICAL_SECTION  gcsNlsProcessCache; // Nls process cache critical section





////////////////////////////////////////////////////////////////////////////
//
//   Functions used to communicate with CSRSS.
//
////////////////////////////////////////////////////////////////////////////

NTSTATUS
CsrBasepNlsGetUserInfo(
    IN LCID Locale,
    IN SIZE_T CacheOffset,
    OUT LPWSTR pData,
    IN ULONG DataLength);


NTSTATUS
CsrBasepNlsSetUserInfo(
    IN LCTYPE LCType,
    IN LPWSTR pData,
    IN ULONG DataLength);

NTSTATUS
CsrBasepNlsSetMultipleUserInfo(
    IN DWORD dwFlags,
    IN int cchData,
    IN LPCWSTR pPicture,
    IN LPCWSTR pSeparator,
    IN LPCWSTR pOrder,
    IN LPCWSTR pTLZero,
    IN LPCWSTR pTimeMarkPosn);

NTSTATUS
CsrBasepNlsCreateSection(
    IN UINT uiType,
    IN LCID Locale,
    OUT PHANDLE phSection);

NTSTATUS
CsrBasepNlsUpdateCacheCount(VOID);

#endif   // _NLS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\number.c ===
/*++

Copyright (c) 1991-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    number.c

Abstract:

    This file contains functions that form properly formatted number and
    currency strings for a given locale.

    APIs found in this file:
      GetNumberFormatW
      GetCurrencyFormatW

Revision History:

    07-28-93    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nls.h"




//
//  Constant Declarations.
//

#define MAX_NUMBER_BUFFER    256                 // size of static buffer
#define MAX_GROUPS           5                   // max number of groupings
#define MAX_GROUPING_NUMBER  9999                // max value for groupings

//
//  Account for:
//    - number of fractional digits
//    - decimal seperator
//    - negative sign
//    - zero terminator
//
#define MAX_NON_INTEGER_PART ( MAX_VALUE_IDIGITS +                        \
                               MAX_SDECIMAL +                             \
                               MAX_SNEGSIGN +                             \
                               1 )
//
//  Account for:
//    - negative sign
//    - blank spaces
//    - one extra number from rounding
//    - one extra grouping separator from rounding
//
#define MAX_NUMBER_EXTRAS    ( MAX_SNEGSIGN +                             \
                               MAX_BLANKS +                               \
                               1 +                                        \
                               MAX_STHOUSAND )
//
//  Account for:
//    - negative sign
//    - currency sign
//    - blank spaces
//    - one extra number from rounding
//    - one extra grouping separator from rounding
//
#define MAX_CURRENCY_EXTRAS  ( MAX_SNEGSIGN +                             \
                               MAX_SCURRENCY +                            \
                               MAX_BLANKS +                               \
                               1 +                                        \
                               MAX_SMONTHOUSEP )




//
//  Forward Declarations.
//

BOOL
IsValidNumberFormat(
    CONST NUMBERFMTW *pFormat);

BOOL
IsValidCurrencyFormat(
    CONST CURRENCYFMTW *pFormat);

UINT
GetRegIntValue(
    LCID Locale,
    LCTYPE LCType,
    BOOL NoUserOverride,
    SIZE_T CacheOffset,
    LPWSTR pRegVal,
    LPWSTR pDefault,
    int DefaultVal,
    int UpperBound);

int
ConvertGroupingStringToInt(
    LPWSTR pGroupingSrc,
    LPWSTR pGroupingDest);

UINT
GetGroupingValue(
    LCID Locale,
    LCTYPE LCType,
    BOOL NoUserOverride,
    SIZE_T CacheOffset,
    LPWSTR pRegVal,
    LPWSTR pDefault,
    int DefaultVal);

int
GetNumberString(
    PLOC_HASH pHashN,
    LPWSTR pValue,
    LPNUMBERFMTW pFormat,
    LPWSTR *ppBuf,
    int BufSize,
    BOOL *pfZeroValue,
    int *pNeededSizeToAllocate,
    BOOL fSetError);

int
ParseNumber(
    PLOC_HASH pHashN,
    BOOL NoUserOverride,
    LPWSTR pValue,
    LPNUMBERFMTW pFormat,
    LPWSTR *ppBuf,
    int BufSize,
    int *pNeededSizeToAllocate,
    BOOL fSetError);

int
ParseCurrency(
    PLOC_HASH pHashN,
    BOOL NoUserOverride,
    LPWSTR pValue,
    LPCURRENCYFMTW pFormat,
    LPWSTR *ppBuf,
    int BufSize,
    int *pNeededSizeToAllocate,
    BOOL fSetError);





//-------------------------------------------------------------------------//
//                            INTERNAL MACROS                              //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  NLS_COPY_UNICODE_STR
//
//  Copies a zero terminated Unicode string from pSrc to the pDest buffer.
//  The pDest pointer is advanced to the end of the string.
//
//  DEFINED AS A MACRO.
//
//  07-28-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NLS_COPY_UNICODE_STR( pDest,                                       \
                              pSrc )                                       \
{                                                                          \
    LPWSTR pTmp;             /* temp pointer to source */                  \
                                                                           \
                                                                           \
    pTmp = pSrc;                                                           \
    while (*pTmp)                                                          \
    {                                                                      \
        *pDest = *pTmp;                                                    \
        pDest++;                                                           \
        pTmp++;                                                            \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  NLS_COPY_UNICODE_STR_NOADV
//
//  Copies a zero terminated Unicode string from pSrc to the pDest buffer.
//  The pDest pointer is NOT advanced to the end of the string.
//
//  DEFINED AS A MACRO.
//
//  07-28-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NLS_COPY_UNICODE_STR_TMP( pDest,                                   \
                                  pSrc )                                   \
{                                                                          \
    LPWSTR pSrcT;            /* temp pointer to source */                  \
    LPWSTR pDestT;           /* temp pointer to destination */             \
                                                                           \
                                                                           \
    pSrcT = pSrc;                                                          \
    pDestT = pDest;                                                        \
    while (*pSrcT)                                                         \
    {                                                                      \
        *pDestT = *pSrcT;                                                  \
        pDestT++;                                                          \
        pSrcT++;                                                           \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  NLS_ROUND_IT
//
//  Rounds the floating point number given as a string.
//
//  NOTE:  This function will reset the pBegin pointer if an
//         extra character is added to the string.
//
//  DEFINED AS A MACRO.
//
//  07-28-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NLS_ROUND_IT( pBegin,                                              \
                      pEnd,                                                \
                      IntPartGroup,                                        \
                      pSep )                                               \
{                                                                          \
    LPWSTR pRound = pEnd;         /* ptr to position in string */          \
    LPWSTR pEndSep;               /* ptr to end of group separator */      \
                                                                           \
                                                                           \
    /*                                                                     \
     *  Round the digits in the string one by one, going backwards in      \
     *  the string.  Stop when either a value other than 9 is found,       \
     *  or the beginning of the string is reached.                         \
     */                                                                    \
    while (pRound >= pBegin)                                               \
    {                                                                      \
        if ((*pRound < NLS_CHAR_ZERO) || (*pRound > NLS_CHAR_NINE))        \
        {                                                                  \
            pRound--;                                                      \
        }                                                                  \
        else if (*pRound == NLS_CHAR_NINE)                                 \
        {                                                                  \
            *pRound = NLS_CHAR_ZERO;                                       \
            pRound--;                                                      \
        }                                                                  \
        else                                                               \
        {                                                                  \
            (*pRound)++;                                                   \
            break;                                                         \
        }                                                                  \
    }                                                                      \
                                                                           \
    /*                                                                     \
     *  Make sure we don't have a number like 9.999, where we would need   \
     *  to add an extra character to the string and make it 10.00.         \
     */                                                                    \
    if (pRound < pBegin)                                                   \
    {                                                                      \
        /*                                                                 \
         *  All values to the right of the decimal are zero.  All values   \
         *  to the left of the decimal are either zero or the grouping     \
         *  separator.                                                     \
         */                                                                \
        if ((IntPartGroup) == 0)                                           \
        {                                                                  \
            /*                                                             \
             *  Adding another integer means we need to add another        \
             *  grouping separator.                                        \
             */                                                            \
            pEndSep = pSep + NlsStrLenW(pSep) - 1;                         \
            while (pEndSep >= pSep)                                        \
            {                                                              \
                (pBegin)--;                                                \
                *(pBegin) = *pEndSep;                                      \
                pEndSep--;                                                 \
            }                                                              \
        }                                                                  \
                                                                           \
        /*                                                                 \
         *  Store a 1 at the beginning of the string and reset the         \
         *  pointer to the beginning of the string.                        \
         */                                                                \
        (pBegin)--;                                                        \
        *(pBegin) = NLS_CHAR_ONE;                                          \
    }                                                                      \
}




//-------------------------------------------------------------------------//
//                             API ROUTINES                                //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  GetNumberFormatW
//
//  Returns a properly formatted number string for the given locale.
//  This call also indicates how much memory is necessary to contain
//  the desired information.
//
//  07-28-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WINAPI GetNumberFormatW(
    LCID Locale,
    DWORD dwFlags,
    LPCWSTR lpValue,
    CONST NUMBERFMTW *lpFormat,
    LPWSTR lpNumberStr,
    int cchNumber)

{
    PLOC_HASH pHashN;                    // ptr to LOC hash node
    int Length = 0;                      // number of characters written
    LPNUMBERFMTW pFormat;                // ptr to number format struct
    NUMBERFMTW NumFmt;                   // number format
    WCHAR pString[MAX_NUMBER_BUFFER];    // ptr to temporary buffer
    LPWSTR pFinal;                       // ptr to the final string
    BOOL NoUserOverride;                 // if no user override flag set
    WCHAR pDecimal[MAX_REG_VAL_SIZE];    // temp buffer for decimal sep
    WCHAR pThousand[MAX_REG_VAL_SIZE];   // temp buffer for thousand sep
    int NeededSizeToAllocate = 0;        // size of buffer needed
    WCHAR *pTemp = NULL;                 // allocated temp storage buffer


    //
    //  Initialize UserOverride.
    //
    NoUserOverride = dwFlags & LOCALE_NOUSEROVERRIDE;

    //
    //  Invalid Parameter Check:
    //    - validate LCID
    //    - count is negative
    //    - NULL src string
    //    - NULL data pointer AND count is not zero
    //    - ptrs to string buffers same
    //
    VALIDATE_LOCALE(Locale, pHashN, FALSE);
    if ( (pHashN == NULL) ||
         (cchNumber < 0) ||
         (lpValue == NULL) ||
         ((lpNumberStr == NULL) && (cchNumber != 0)) ||
         (lpValue == lpNumberStr) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Invalid Flags Check:
    //    - flags other than valid ones
    //    - lpFormat not NULL AND NoUserOverride flag is set
    //
    if ( (dwFlags & GNF_INVALID_FLAG) ||
         ((lpFormat != NULL) && (NoUserOverride)) )
    {
        SetLastError(ERROR_INVALID_FLAGS);
        return (0);
    }

    //
    //  Set pFormat to point at the proper format structure.
    //
    if (lpFormat != NULL)
    {
        //
        //  Use the format structure given by the caller.
        //
        pFormat = (LPNUMBERFMTW)lpFormat;

        if (!IsValidNumberFormat(pFormat))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return (0);
        }
    }
    else
    {
        //
        //  Use the format structure defined here.
        //
        pFormat = &NumFmt;

        //
        //  Get the number of decimal digits.
        //
        pFormat->NumDigits =
            GetRegIntValue( Locale,
                            LOCALE_IDIGITS,
                            NoUserOverride,
                            FIELD_OFFSET(NLS_USER_INFO, iDigits),
                            NLS_VALUE_IDIGITS,
                            pHashN->pLocaleFixed->szIDigits,
                            2,
                            MAX_VALUE_IDIGITS );

        //
        //  Get the leading zero in decimal fields option.
        //
        pFormat->LeadingZero =
            GetRegIntValue( Locale,
                            LOCALE_ILZERO,
                            NoUserOverride,
                            FIELD_OFFSET(NLS_USER_INFO, iLZero),
                            NLS_VALUE_ILZERO,
                            pHashN->pLocaleFixed->szILZero,
                            1,
                            MAX_VALUE_ILZERO );

        //
        //  Get the negative ordering.
        //
        pFormat->NegativeOrder =
            GetRegIntValue( Locale,
                            LOCALE_INEGNUMBER,
                            NoUserOverride,
                            FIELD_OFFSET(NLS_USER_INFO, iNegNumber),
                            NLS_VALUE_INEGNUMBER,
                            pHashN->pLocaleFixed->szINegNumber,
                            1,
                            MAX_VALUE_INEGNUMBER );

        //
        //  Get the grouping left of the decimal.
        //
        pFormat->Grouping =
            GetGroupingValue( Locale,
                              LOCALE_SGROUPING,
                              NoUserOverride,
                              FIELD_OFFSET(NLS_USER_INFO, sGrouping),
                              NLS_VALUE_SGROUPING,
                              (LPWORD)(pHashN->pLocaleHdr) +
                                pHashN->pLocaleHdr->SGrouping,
                              3 );

        //
        //  Get the decimal separator.
        //
        //  NOTE:  This must follow the above calls because
        //         pDecSep is used as a temporary buffer above.
        //
        if ( (!NoUserOverride) &&
             GetUserInfo( Locale,
                          LOCALE_SDECIMAL,
                          FIELD_OFFSET(NLS_USER_INFO, sDecimal),
                          NLS_VALUE_SDECIMAL,
                          pDecimal,
                          ARRAYSIZE(pDecimal),
                          TRUE ) &&
             IsValidSeparatorString( pDecimal,
                                     MAX_SDECIMAL,
                                     FALSE ) )
        {
            pFormat->lpDecimalSep = pDecimal;
        }
        else
        {
            pFormat->lpDecimalSep = (LPWORD)(pHashN->pLocaleHdr) +
                                    pHashN->pLocaleHdr->SDecimal;
        }

        //
        //  Get the thousand separator.
        //  This string may be a null string.
        //
        if ( (!NoUserOverride) &&
             GetUserInfo( Locale,
                          LOCALE_STHOUSAND,
                          FIELD_OFFSET(NLS_USER_INFO, sThousand),
                          NLS_VALUE_STHOUSAND,
                          pThousand,
                          ARRAYSIZE(pThousand),
                          FALSE ) &&
             IsValidSeparatorString( pThousand,
                                     MAX_STHOUSAND,
                                     FALSE ) )
        {
            pFormat->lpThousandSep = pThousand;
        }
        else
        {
            pFormat->lpThousandSep = (LPWORD)(pHashN->pLocaleHdr) +
                                     pHashN->pLocaleHdr->SThousand;
        }
    }

    //
    //  Parse the number format string.
    //
    pFinal = pString;
    Length = ParseNumber( pHashN,
                          NoUserOverride,
                          (LPWSTR)lpValue,
                          pFormat,
                          &pFinal,
                          MAX_NUMBER_BUFFER,
                          &NeededSizeToAllocate,
                          FALSE );

    //
    //  If the failure is due to a stack variable size limitation, then
    //  try to satisfy the request from the local process heap.
    //
    if ((Length == 0) && (NeededSizeToAllocate > 0))
    {
        pTemp = RtlAllocateHeap( RtlProcessHeap(),
                                 0,
                                 NeededSizeToAllocate * sizeof(TCHAR) );
        if (pTemp)
        {
            pFinal = pTemp;
            Length = ParseNumber( pHashN,
                                  NoUserOverride,
                                  (LPWSTR)lpValue,
                                  pFormat,
                                  &pFinal,
                                  NeededSizeToAllocate,
                                  &NeededSizeToAllocate,
                                  TRUE );
        }
    }

    //
    //  Check cchNumber for size of given buffer.
    //
    if ((cchNumber == 0) || (Length == 0))
    {
        //
        //  If cchNumber is 0, then we can't use lpNumberStr.  In this
        //  case, we simply want to return the length (in characters) of
        //  the string to be copied.
        //
        Length = Length;
    }
    else if (cchNumber < Length)
    {
        //
        //  The buffer is too small for the string, so return an error
        //  and zero bytes written.
        //
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        Length = 0;
    }
    else
    {
        //
        //  Copy the number string to lpNumberStr and null terminate it.
        //  Return the number of characters copied.
        //
        NlsStrCpyW(lpNumberStr, pFinal);
    }

    //
    //  Free any dynamically allocated memory.
    //
    if (pTemp != NULL)
    {
        RtlFreeHeap(RtlProcessHeap(), 0, pTemp);
    }

    //
    //  Return the number of characters copied.
    //
    return (Length);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetCurrencyFormatW
//
//  Returns a properly formatted currency string for the given locale.
//  This call also indicates how much memory is necessary to contain
//  the desired information.
//
//  07-28-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WINAPI GetCurrencyFormatW(
    LCID Locale,
    DWORD dwFlags,
    LPCWSTR lpValue,
    CONST CURRENCYFMTW *lpFormat,
    LPWSTR lpCurrencyStr,
    int cchCurrency)

{
    PLOC_HASH pHashN;                    // ptr to LOC hash node
    int Length = 0;                      // number of characters written
    LPCURRENCYFMTW pFormat;              // ptr to currency format struct
    CURRENCYFMTW CurrFmt;                // currency format
    WCHAR pString[MAX_NUMBER_BUFFER];    // ptr to temporary buffer
    LPWSTR pFinal;                       // ptr to the final string
    BOOL NoUserOverride;                 // if no user override flag set
    WCHAR pDecimal[MAX_REG_VAL_SIZE];    // temp buffer for decimal sep
    WCHAR pThousand[MAX_REG_VAL_SIZE];   // temp buffer for thousand sep
    WCHAR pCurrency[MAX_REG_VAL_SIZE];   // temp buffer for currency symbol
    int NeededSizeToAllocate = 0;        // size of buffer needed
    WCHAR *pTemp = NULL;                 // allocated temp storage buffer


    //
    //  Initialize UserOverride.
    //
    NoUserOverride = dwFlags & LOCALE_NOUSEROVERRIDE;

    //
    //  Invalid Parameter Check:
    //    - validate LCID
    //    - count is negative
    //    - NULL src string
    //    - NULL data pointer AND count is not zero
    //    - ptrs to string buffers same
    //
    VALIDATE_LOCALE(Locale, pHashN, FALSE);
    if ( (pHashN == NULL) ||
         (cchCurrency < 0) ||
         (lpValue == NULL) ||
         ((lpCurrencyStr == NULL) && (cchCurrency != 0)) ||
         (lpValue == lpCurrencyStr) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Invalid Flags Check:
    //    - flags other than valid ones
    //    - lpFormat not NULL AND NoUserOverride flag is set
    //
    if ( (dwFlags & GCF_INVALID_FLAG) ||
         ((lpFormat != NULL) && (NoUserOverride)) )
    {
        SetLastError(ERROR_INVALID_FLAGS);
        return (0);
    }

    //
    //  Set pFormat to point at the proper format structure.
    //
    if (lpFormat != NULL)
    {
        //
        //  Use the format structure given by the caller.
        //
        pFormat = (LPCURRENCYFMTW)lpFormat;

        if (!IsValidCurrencyFormat(pFormat))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return (0);
        }
    }
    else
    {
        //
        //  Use the format structure defined here.
        //
        pFormat = &CurrFmt;

        //
        //  Get the number of decimal digits.
        //
        pFormat->NumDigits =
            GetRegIntValue( Locale,
                            LOCALE_ICURRDIGITS,
                            NoUserOverride,
                            FIELD_OFFSET(NLS_USER_INFO, iCurrDigits),
                            NLS_VALUE_ICURRDIGITS,
                            pHashN->pLocaleFixed->szICurrDigits,
                            2,
                            MAX_VALUE_ICURRDIGITS );

        //
        //  Get the leading zero in decimal fields option.
        //
        pFormat->LeadingZero =
            GetRegIntValue( Locale,
                            LOCALE_ILZERO,
                            NoUserOverride,
                            FIELD_OFFSET(NLS_USER_INFO, iLZero),
                            NLS_VALUE_ILZERO,
                            pHashN->pLocaleFixed->szILZero,
                            1,
                            MAX_VALUE_ILZERO );

        //
        //  Get the positive ordering.
        //
        pFormat->PositiveOrder =
            GetRegIntValue( Locale,
                            LOCALE_ICURRENCY,
                            NoUserOverride,
                            FIELD_OFFSET(NLS_USER_INFO, iCurrency),
                            NLS_VALUE_ICURRENCY,
                            pHashN->pLocaleFixed->szICurrency,
                            0,
                            MAX_VALUE_ICURRENCY );

        //
        //  Get the negative ordering.
        //
        pFormat->NegativeOrder =
            GetRegIntValue( Locale,
                            LOCALE_INEGCURR,
                            NoUserOverride,
                            FIELD_OFFSET(NLS_USER_INFO, iNegCurr),
                            NLS_VALUE_INEGCURR,
                            pHashN->pLocaleFixed->szINegCurr,
                            1,
                            MAX_VALUE_INEGCURR );

        //
        //  Get the grouping left of the decimal.
        //
        pFormat->Grouping =
            GetGroupingValue( Locale,
                              LOCALE_SMONGROUPING,
                              NoUserOverride,
                              FIELD_OFFSET(NLS_USER_INFO, sMonGrouping),
                              NLS_VALUE_SMONGROUPING,
                              (LPWORD)(pHashN->pLocaleHdr) +
                                pHashN->pLocaleHdr->SMonGrouping,
                              3 );

        //
        //  Get the decimal separator.
        //
        //  NOTE:  This must follow the above calls because
        //         pDecSep is used as a temporary buffer.
        //
        if ( (!NoUserOverride) &&
             GetUserInfo( Locale,
                          LOCALE_SMONDECIMALSEP,
                          FIELD_OFFSET(NLS_USER_INFO, sMonDecSep),
                          NLS_VALUE_SMONDECIMALSEP,
                          pDecimal,
                          ARRAYSIZE(pDecimal),
                          TRUE ) &&
             IsValidSeparatorString( pDecimal,
                                     MAX_SDECIMAL,
                                     FALSE ) )
        {
            pFormat->lpDecimalSep = pDecimal;
        }
        else
        {
            pFormat->lpDecimalSep = (LPWORD)(pHashN->pLocaleHdr) +
                                    pHashN->pLocaleHdr->SMonDecSep;
        }

        //
        //  Get the thousand separator.
        //  This string may be a null string.
        //
        if ( (!NoUserOverride) &&
             GetUserInfo( Locale,
                          LOCALE_SMONTHOUSANDSEP,
                          FIELD_OFFSET(NLS_USER_INFO, sMonThouSep),
                          NLS_VALUE_SMONTHOUSANDSEP,
                          pThousand,
                          ARRAYSIZE(pThousand),
                          FALSE ) &&
             IsValidSeparatorString( pThousand,
                                     MAX_STHOUSAND,
                                     FALSE ) )
        {
            pFormat->lpThousandSep = pThousand;
        }
        else
        {
            pFormat->lpThousandSep = (LPWORD)(pHashN->pLocaleHdr) +
                                     pHashN->pLocaleHdr->SMonThousSep;
        }

        //
        //  Get the currency symbol.
        //  This string may be a null string.
        //
        if ( (!NoUserOverride) &&
             GetUserInfo( Locale,
                          LOCALE_SCURRENCY,
                          FIELD_OFFSET(NLS_USER_INFO, sCurrency),
                          NLS_VALUE_SCURRENCY,
                          pCurrency,
                          ARRAYSIZE(pCurrency),
                          FALSE ) &&
             IsValidSeparatorString( pCurrency,
                                     MAX_SCURRENCY,
                                     FALSE ) )
        {
            pFormat->lpCurrencySymbol = pCurrency;
        }
        else
        {
            pFormat->lpCurrencySymbol = (LPWORD)(pHashN->pLocaleHdr) +
                                        pHashN->pLocaleHdr->SCurrency;
        }
    }

    //
    //  Parse the currency format string.
    //
    pFinal = pString;
    Length = ParseCurrency( pHashN,
                            NoUserOverride,
                            (LPWSTR)lpValue,
                            pFormat,
                            &pFinal,
                            MAX_NUMBER_BUFFER,
                            &NeededSizeToAllocate,
                            FALSE );

    //
    //  If the failure is due to a stack variable size limitation, then
    //  try to satisfy the request from the local process heap.
    //
    if ((Length == 0) && (NeededSizeToAllocate > 0))
    {
        pTemp = RtlAllocateHeap( RtlProcessHeap(),
                                 0,
                                 NeededSizeToAllocate * sizeof(TCHAR) );
        if (pTemp)
        {
            pFinal = pTemp;
            Length = ParseCurrency( pHashN,
                                    NoUserOverride,
                                    (LPWSTR)lpValue,
                                    pFormat,
                                    &pFinal,
                                    NeededSizeToAllocate,
                                    &NeededSizeToAllocate,
                                    TRUE );
        }
    }

    //
    //  Check cchCurrency for size of given buffer.
    //
    if ((cchCurrency == 0) || (Length == 0))
    {
        //
        //  If cchCurrency is 0, then we can't use lpCurrencyStr.  In this
        //  case, we simply want to return the length (in characters) of
        //  the string to be copied.
        //
        Length = Length;
    }
    else if (cchCurrency < Length)
    {
        //
        //  The buffer is too small for the string, so return an error
        //  and zero bytes written.
        //
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        Length = 0;
    }
    else
    {
        //
        //  Copy the currency string to lpCurrencyStr and null terminate it.
        //  Return the number of characters copied.
        //
        NlsStrCpyW(lpCurrencyStr, pFinal);
    }

    //
    //  Free any dynamically allocated memory.
    //
    if (pTemp != NULL)
    {
        RtlFreeHeap(RtlProcessHeap(), 0, pTemp);
    }

    //
    //  Return the number of characters copied.
    //
    return (Length);
}




//-------------------------------------------------------------------------//
//                           INTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  IsValidNumberFormat
//
//  Returns TRUE if the given format is valid.  Otherwise, it returns FALSE.
//
//  07-28-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL IsValidNumberFormat(
    CONST NUMBERFMTW *pFormat)

{
    //
    //  Check for invalid values.
    //
    if ((pFormat->NumDigits > MAX_VALUE_IDIGITS) ||
        (pFormat->LeadingZero > MAX_VALUE_ILZERO) ||
        (pFormat->Grouping > MAX_GROUPING_NUMBER) ||
        (pFormat->NegativeOrder > MAX_VALUE_INEGNUMBER) ||
        (pFormat->lpDecimalSep == NULL) ||
        (!IsValidSeparatorString( pFormat->lpDecimalSep,
                                  MAX_SDECIMAL,
                                  (pFormat->NumDigits) ? TRUE : FALSE)) ||
        (pFormat->lpThousandSep == NULL) ||
        (!IsValidSeparatorString( pFormat->lpThousandSep,
                                  MAX_STHOUSAND,
                                  FALSE )))
    {
        return (FALSE);
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  IsValidCurrencyFormat
//
//  Returns TRUE if the given format is valid.  Otherwise, it returns FALSE.
//
//  07-28-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL IsValidCurrencyFormat(
    CONST CURRENCYFMTW *pFormat)

{
    //
    //  Check for invalid values.
    //
    if ((pFormat->NumDigits > MAX_VALUE_IDIGITS) ||
        (pFormat->LeadingZero > MAX_VALUE_ILZERO) ||
        (pFormat->Grouping > MAX_GROUPING_NUMBER) ||
        (pFormat->lpDecimalSep == NULL) ||
        (!IsValidSeparatorString( pFormat->lpDecimalSep,
                                  MAX_SMONDECSEP,
                                  (pFormat->NumDigits) ? TRUE : FALSE)) ||
        (pFormat->lpThousandSep == NULL) ||
        (!IsValidSeparatorString( pFormat->lpThousandSep,
                                  MAX_SMONTHOUSEP,
                                  FALSE )) ||
        (pFormat->lpCurrencySymbol == NULL) ||
        (!IsValidSeparatorString( pFormat->lpCurrencySymbol,
                                  MAX_SCURRENCY,
                                  FALSE )) ||
        (pFormat->PositiveOrder > MAX_VALUE_ICURRENCY) ||
        (pFormat->NegativeOrder > MAX_VALUE_INEGCURR))
    {
        return (FALSE);
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetRegIntValue
//
//  Retrieves the specified locale information, converts the unicode string
//  to an integer value, and returns the value.
//
//  07-28-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

UINT GetRegIntValue(
    LCID Locale,
    LCTYPE LCType,
    BOOL NoUserOverride,
    SIZE_T CacheOffset,
    LPWSTR pRegVal,
    LPWSTR pDefault,
    int DefaultVal,
    int UpperBound)
{
    UNICODE_STRING ObUnicodeStr;            // value string
    int Value;                              // value
    WCHAR pTemp[MAX_REG_VAL_SIZE];          // temp buffer


    //
    //  Initialize values.
    //
    Value = -1;

    //
    //  Try the user registry.
    //
    if ((!NoUserOverride) &&
         GetUserInfo( Locale,
                      LCType,
                      CacheOffset,
                      pRegVal,
                      pTemp,
                      ARRAYSIZE(pTemp),
                      TRUE ))
    {
        //
        //  Convert the user data to an integer.
        //
        RtlInitUnicodeString(&ObUnicodeStr, pTemp);
        if ((RtlUnicodeStringToInteger(&ObUnicodeStr, 10, &Value)) ||
            (Value < 0) || (Value > UpperBound))
        {
            //
            //  Bad value, so store -1 so that the system default
            //  will be used.
            //
            Value = -1;
        }
    }

    //
    //  See if the value obtained above is valid.
    //
    if (Value < 0)
    {
        //
        //  Convert system default data to an integer.
        //
        RtlInitUnicodeString(&ObUnicodeStr, pDefault);
        if ((RtlUnicodeStringToInteger(&ObUnicodeStr, 10, &Value)) ||
            (Value < 0) || (Value > UpperBound))
        {
            //
            //  Bad value, so use the chosen default value.
            //
            Value = DefaultVal;
        }
    }

    return ((UINT)Value);
}


////////////////////////////////////////////////////////////////////////////
//
//  ConvertGroupingStringToInt
//
//  Converts the given grouping string to an integer.
//  For example, 3;2;0 becomes 32 and 3;0 becomes 3 and 3;2 becomes 320.
//
//  NOTE: The pGrouping buffer will be modified.
//
//  01-05-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ConvertGroupingStringToInt(
    LPWSTR pGroupingSrc,
    LPWSTR pGroupingDest)
{
    LPWSTR pSrc  = pGroupingSrc;       // temp ptr to src position
    LPWSTR pDest = pGroupingDest;      // temp ptr to dest position
    UNICODE_STRING ObUnicodeStr;       // value string
    int Value;                         // value


    //
    //  Filter out all non-numeric values and all zero values.
    //  Store the result in the destination buffer.
    //
    while (*pSrc)
    {
        if ((*pSrc < NLS_CHAR_ONE) || (*pSrc > NLS_CHAR_NINE))
        {
            pSrc++;
        }
        else
        {
            if (pSrc != pDest)
            {
                *pDest = *pSrc;
            }
            pSrc++;
            pDest++;
        }
    }

    //
    //  Make sure there is something in the destination buffer.
    //  Also, see if we need to add a zero in the case of 3;2 becomes 320.
    //
    if ((pDest == pGroupingDest) || (*(pSrc - 1) != NLS_CHAR_ZERO))
    {
        *pDest = NLS_CHAR_ZERO;
        pDest++;
    }

    //
    //  Null terminate the buffer.
    //
    *pDest = 0;

    //
    //  Convert the string to an integer.
    //
    RtlInitUnicodeString(&ObUnicodeStr, pGroupingDest);
    RtlUnicodeStringToInteger(&ObUnicodeStr, 10, &Value);

    //
    //  Return the integer value.
    //
    return (Value);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetGroupingValue
//
//  Retrieves the specified grouping information, converts the grouping
//  string to an integer value (eg. 3;2;0 -> 32), and returns the value.
//
//  07-28-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

UINT GetGroupingValue(
    LCID Locale,
    LCTYPE LCType,
    BOOL NoUserOverride,
    SIZE_T CacheOffset,
    LPWSTR pRegVal,
    LPWSTR pDefault,
    int DefaultVal)
{
    int Value;                              // value
    WCHAR pTemp[MAX_REG_VAL_SIZE];          // temp buffer


    //
    //  Initialize values.
    //
    Value = -1;

    //
    //  Try the user registry.
    //
    if ((!NoUserOverride) &&
         GetUserInfo( Locale,
                      LCType,
                      CacheOffset,
                      pRegVal,
                      pTemp,
                      ARRAYSIZE(pTemp),
                      TRUE ))
    {
        //
        //  Convert the grouping string to an integer.
        //  3;0 becomes 3, 3;2;0 becomes 32, and 3;2 becomes 320.
        //
        Value = ConvertGroupingStringToInt(pTemp, pTemp);
        if (Value < 0)
        {
            //
            //  Bad value, so store -1 so that the system default
            //  will be used.
            //
            Value = -1;
        }
    }

    //
    //  See if the value obtained above is valid.
    //
    if (Value < 0)
    {
        //
        //  Convert the grouping string to an integer.
        //  3;0 becomes 3, 3;2;0 becomes 32, and 3;2 becomes 320.
        //
        Value = ConvertGroupingStringToInt(pDefault, pTemp);
        if (Value < 0)
        {
            //
            //  Bad value, so use the chosen default value.
            //
            Value = DefaultVal;
        }
    }

    //
    //  Return the value.
    //
    return ((UINT)Value);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetNumberString
//
//  Puts the properly formatted number string into the given string buffer.
//  It returns the number of characters written to the string buffer.
//
//  07-28-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetNumberString(
    PLOC_HASH pHashN,
    LPWSTR pValue,
    LPNUMBERFMTW pFormat,
    LPWSTR *ppBuf,
    int BufSize,
    BOOL *pfZeroValue,
    int *pNeededSizeToAllocate,
    BOOL fSetError)

{
    LPWSTR pDecPt;                // ptr to decimal point in given buffer
    LPWSTR pPos;                  // ptr to position in given buffer
    LPWSTR pPos2;                 // ptr to position in given buffer
    LPWSTR pPosBuf;               // ptr to position in final buffer
    int IntPartSize;              // size of integer part of string
    int GroupSize;                // size of groupings left of decimal
    int IntegerNum;               // number of integers left of decimal
    WCHAR wch;                    // wide character place holder
    int pGroupArray[MAX_GROUPS];  // array of groups
    int NumGroupings;             // number of groupings
    int NumSeparators;            // number of separators
    int NumDigits;                // number of digits
    int Ctr;                      // loop counter
    UINT NumRound = 1;            // # digits left before adding group separator


    //
    //  Reset to indicate no need to allocate memory dynamically.
    //
    *pNeededSizeToAllocate = 0;

    //
    //  Validate the string and find the decimal point in the string.
    //
    //  The only valid characters within the string are:
    //     negative sign - in first position only
    //     decimal point
    //     Unicode code points for integers 0 - 9
    //
    pPos = pValue;
    while ((wch = *pPos) && (wch != NLS_CHAR_PERIOD))
    {
        if ((wch < NLS_CHAR_ZERO) || (wch > NLS_CHAR_NINE))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return (0);
        }
        pPos++;
    }
    pDecPt = pPos;

    if (*pPos)
    {
        pPos++;
        while (wch = *pPos)
        {
            if ((wch < NLS_CHAR_ZERO) || (wch > NLS_CHAR_NINE))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return (0);
            }
            pPos++;
        }
    }

    //
    //  Remove any leading zeros in the integer part.
    //
    while (pValue < pDecPt)
    {
        if (*pValue != NLS_CHAR_ZERO)
        {
            break;
        }
        pValue++;
    }

    //
    //  Save the number of integers to the left of the decimal.
    //
    IntegerNum = (int)(pDecPt - pValue);

    //
    //  Make sure the value string passed in is not too large for
    //  the buffers.
    //
    IntPartSize = IntegerNum;
    NumGroupings = 0;
    NumSeparators = 0;
    if ((GroupSize = pFormat->Grouping) && (IntPartSize))
    {
        //
        //  Count the number of groupings and save them in an array to be
        //  used later.
        //
        while (GroupSize && (NumGroupings < MAX_GROUPS))
        {
            pGroupArray[NumGroupings] = GroupSize % 10;
            GroupSize /= 10;
            NumGroupings++;
        }

        //
        //  Count the number of groupings that apply to the given number
        //  string.
        //
        NumDigits = IntegerNum;
        Ctr = (NumGroupings != 0) ? (NumGroupings - 1) : 0;
        while (Ctr)
        {
            if (NumDigits > pGroupArray[Ctr])
            {
                NumDigits -= pGroupArray[Ctr];
                NumSeparators++;
            }
            else
            {
                if (NumDigits == pGroupArray[Ctr])
                {
                    NumRound = 0;
                }
                break;
            }
            Ctr--;
        }
        if ((Ctr == 0) && pGroupArray[0])
        {
            if (NumDigits > pGroupArray[0])
            {
                NumSeparators += (NumDigits - 1) / pGroupArray[0];
            }
            NumRound = NumDigits % pGroupArray[0];
        }

        IntPartSize += MAX_STHOUSAND * NumSeparators;
    }

    //
    //  Make sure the buffer is large enough.  If not, return the size
    //  needed.
    //
    if (IntPartSize > (BufSize - MAX_NON_INTEGER_PART))
    {
        if (fSetError)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
        }
        *pNeededSizeToAllocate = (IntPartSize + MAX_NON_INTEGER_PART);
        return (0);
    }

    //
    //  Initialize pointers.
    //
    pPosBuf = *ppBuf;
    pPos = pValue;
    *pfZeroValue = FALSE;

    //
    //  See if there are any digits before the decimal point.
    //
    if (pPos == pDecPt)
    {
        //
        //  Possibly a zero value.  All leading zeros were removed, so
        //  there is no integer part.
        //
        *pfZeroValue = TRUE;

        //
        //  No digits before decimal point, so add a leading zero
        //  to the final string if appropriate.
        //
        if (pFormat->LeadingZero)
        {
            *pPosBuf = NLS_CHAR_ZERO;
            pPosBuf++;
        }
    }
    else if (!NumSeparators)
    {
        //
        //  Grouping Size is zero or larger than the integer part of the
        //  string, so copy up to the decimal point (or end of string).
        //
        while (pPos < pDecPt)
        {
            *pPosBuf = *pPos;
            pPosBuf++;
            pPos++;
        }
    }
    else
    {
        //
        //  Copy up to where the first thousand separator should be.
        //  Use groupings of GroupSize numbers up to the decimal point.
        //
        NumDigits = IntegerNum;
        Ctr = (NumGroupings != 0) ? (NumGroupings - 1) : 0;
        while (Ctr)
        {
            if (NumDigits > pGroupArray[Ctr])
            {
                NumDigits -= pGroupArray[Ctr];
            }
            else
            {
                break;
            }
            Ctr--;
        }
        GroupSize = pGroupArray[Ctr];

        pPos2 = GroupSize
                  ? (pPos + (NumDigits % GroupSize))
                  : (pPos + NumDigits);
        if (pPos2 == pPos)
        {
            //
            //  Don't want to write thousand separator at the beginning
            //  of the string.  There's at least GroupSize numbers
            //  in the string, so just advance pPos2 so that GroupSize
            //  numbers will be copied.
            //
            pPos2 = pPos + GroupSize;
        }
        while (pPos < pPos2)
        {
            *pPosBuf = *pPos;
            pPosBuf++;
            pPos++;
            NumDigits--;
        }

        //
        //  Copy the thousand separator followed by GroupSize number of
        //  digits from the given string until the entire repeating
        //  GroupSize ends (or end of string).
        //
        while (NumDigits)
        {
            //
            //  Copy the localized thousand separator.
            //
            pPos2 = pFormat->lpThousandSep;
            while (*pPos2)
            {
                *pPosBuf = *pPos2;
                pPosBuf++;
                pPos2++;
            }

            //
            //  Copy GroupSize number of digits.
            //
            pPos2 = pPos + GroupSize;
            while (pPos < pPos2)
            {
                *pPosBuf = *pPos;
                pPosBuf++;
                pPos++;
                NumDigits--;
            }
        }

        //
        //  Copy the thousand separator followed by GroupSize number of
        //  digits from the given string - until the decimal point (or
        //  end of string) in the given string is reached.
        //
        if (pPos < pDecPt)
        {
            Ctr++;
            while (Ctr < NumGroupings)
            {
                //
                //  Copy the localized thousand separator.
                //
                pPos2 = pFormat->lpThousandSep;
                while (*pPos2)
                {
                    *pPosBuf = *pPos2;
                    pPosBuf++;
                    pPos2++;
                }

                //
                //  Copy GroupSize number of digits.
                //
                pPos2 = pPos + pGroupArray[Ctr];
                while (pPos < pPos2)
                {
                    *pPosBuf = *pPos;
                    pPosBuf++;
                    pPos++;
                }

                //
                //  Go to the next grouping.
                //
                Ctr++;
            }
        }
    }

    //
    //  See if there is a decimal separator in the given string.
    //
    if (pFormat->NumDigits > 0)
    {
        //
        //  Copy the localized decimal separator only if the number
        //  of digits right of the decimal is greater than zero.
        //
        pDecPt = pPosBuf;
        pPos2 = pFormat->lpDecimalSep;
        while (*pPos2)
        {
            *pPosBuf = *pPos2;
            pPosBuf++;
            pPos2++;
        }
    }

    //
    //  Skip over the decimal point in the given string and
    //  copy the rest of the digits from the given string.
    //
    if (*pPos)
    {
        pPos++;
    }
    pPos2 = pPos + pFormat->NumDigits;
    while ((*pPos) && (pPos < pPos2))
    {
        if (*pPos != NLS_CHAR_ZERO)
        {
            *pfZeroValue = FALSE;
        }
        *pPosBuf = *pPos;
        pPosBuf++;
        pPos++;
    }

    //
    //  Make sure some value is in the buffer.
    //
    if (*ppBuf == pPosBuf)
    {
        *pPosBuf = NLS_CHAR_ZERO;
        pPosBuf++;
    }

    //
    //  See if we need to round the number or pad it with zeros.
    //
    if (*pPos)
    {
        //
        //  Round the number if necessary.
        //
        if (*pPos2 > L'4')
        {
            *pfZeroValue = FALSE;

            //
            //  Round the number.  If GroupSize is 0, then we need to
            //  pass in a non-zero value so that the thousand separator
            //  will not be added to the front of the string (if it
            //  rounds that far).
            //
            pPosBuf--;
            NLS_ROUND_IT( *ppBuf,
                          pPosBuf,
                          NumRound,
                          pFormat->lpThousandSep );
            pPosBuf++;
        }
    }
    else
    {
        //
        //  Pad the string with the appropriate number of zeros.
        //
        while (pPos < pPos2)
        {
            *pPosBuf = NLS_CHAR_ZERO;
            pPosBuf++;
            pPos++;
        }
    }

    //
    //  Zero terminate the string.
    //
    *pPosBuf = 0;

    //
    //  Return the number of characters written to the buffer, including
    //  the null terminator.
    //
    return ((int)((pPosBuf - *ppBuf) + 1));
}


////////////////////////////////////////////////////////////////////////////
//
//  ParseNumber
//
//  Puts the properly formatted number string into the given string buffer.
//  It returns the number of characters written to the string buffer.
//
//  07-28-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ParseNumber(
    PLOC_HASH pHashN,
    BOOL NoUserOverride,
    LPWSTR pValue,
    LPNUMBERFMTW pFormat,
    LPWSTR *ppBuf,
    int BufSize,
    int *pNeededSizeToAllocate,
    BOOL fSetError)

{
    LPWSTR pBegin;                     // ptr to beginning of final buffer
    LPWSTR pEnd;                       // ptr to end of final buffer
    LPWSTR pNegSign;                   // ptr to negative sign string
    BOOL IsNeg;                        // if negative sign in string
    int Length;                        // length of number string
    BOOL fZeroValue = FALSE;           // if number is a zero value
    int NegSignSize;                   // size of negative sign string
    WCHAR pTemp[MAX_REG_VAL_SIZE];     // temp buffer


    //
    //  Initialize pointer.
    //
    //  Account for:
    //    - negative sign
    //    - blank spaces
    //    - one extra number from rounding
    //    - one extra grouping separator from rounding
    //
    pBegin = *ppBuf + MAX_NUMBER_EXTRAS;

    //
    //  If the first value is a negative, then increment past it.
    //
    if (IsNeg = (*pValue == NLS_CHAR_HYPHEN))
    {
        pValue++;
    }

    //
    //  Get the appropriate number string and place it in the buffer.
    //
    Length = GetNumberString( pHashN,
                              pValue,
                              pFormat,
                              &pBegin,
                              BufSize - MAX_NUMBER_EXTRAS,
                              &fZeroValue,
                              pNeededSizeToAllocate,
                              fSetError );
    if (!Length)
    {
        if (*pNeededSizeToAllocate > 0)
        {
            *pNeededSizeToAllocate += MAX_NUMBER_EXTRAS;
        }
        return (0);
    }

    //
    //  Advance pEnd position pointer to the end of the number string.
    //
    pEnd = pBegin + (Length - 1);

    //
    //  See if any characters should be put in the buffer BEFORE and
    //  AFTER the properly formatted number string.
    //      - negative sign or opening/closing parenthesis
    //      - blank space
    //
    if (!fZeroValue && IsNeg)
    {
        //
        //  Get the negative sign string.
        //
        if (pFormat->NegativeOrder != 0)
        {
            if ( (!NoUserOverride) &&
                 GetUserInfo( pHashN->Locale,
                              LOCALE_SNEGATIVESIGN,
                              FIELD_OFFSET(NLS_USER_INFO, sNegSign),
                              NLS_VALUE_SNEGATIVESIGN,
                              pTemp,
                              ARRAYSIZE(pTemp),
                              TRUE ) &&
                 IsValidSeparatorString( pTemp,
                                         MAX_SNEGSIGN,
                                         FALSE ) )
            {
                pNegSign = pTemp;
            }
            else
            {
                pNegSign = (LPWORD)(pHashN->pLocaleHdr) +
                           pHashN->pLocaleHdr->SNegativeSign;
            }
        }

        switch (pFormat->NegativeOrder)
        {
            case ( 0 ) :
            {
                //
                //  Put the opening parenthesis in the buffer.
                //
                pBegin--;
                *pBegin = NLS_CHAR_OPEN_PAREN;

                //
                //  Put the closing parenthesis in the buffer.
                //
                *pEnd = NLS_CHAR_CLOSE_PAREN;
                pEnd++;

                break;
            }
            case ( 2 ) :
            {
                //
                //  Put the space in the buffer.
                //
                pBegin--;
                *pBegin = NLS_CHAR_SPACE;

                //
                //  Fall through to case 1.
                //
            }
            case ( 1 ) :
            default :
            {
                //
                //  Copy the negative sign to the buffer.
                //
                NegSignSize = NlsStrLenW(pNegSign);
                pBegin -= NegSignSize;
                NLS_COPY_UNICODE_STR_TMP(pBegin, pNegSign);

                break;
            }
            case ( 4 ) :
            {
                //
                //  Put the space in the buffer.
                //
                *pEnd = NLS_CHAR_SPACE;
                pEnd++;

                //
                //  Fall Through to case 3.
                //
            }
            case ( 3 ) :
            {
                //
                //  Copy the negative sign to the buffer.
                //
                NLS_COPY_UNICODE_STR(pEnd, pNegSign);

                break;
            }
        }
    }

    //
    //  Zero terminate the string.
    //
    *pEnd = 0;

    //
    //  Return the pointer to the beginning of the string.
    //
    *ppBuf = pBegin;

    //
    //  Return the number of characters written to the buffer, including
    //  the null terminator.
    //
    return ((int)((pEnd - pBegin) + 1));
}


////////////////////////////////////////////////////////////////////////////
//
//  ParseCurrency
//
//  Puts the properly formatted currency string into the given string buffer.
//  It returns the number of characters written to the string buffer.
//
//  07-28-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ParseCurrency(
    PLOC_HASH pHashN,
    BOOL NoUserOverride,
    LPWSTR pValue,
    LPCURRENCYFMTW pFormat,
    LPWSTR *ppBuf,
    int BufSize,
    int *pNeededSizeToAllocate,
    BOOL fSetError)

{
    LPWSTR pBegin;                     // ptr to beginning of final buffer
    LPWSTR pEnd;                       // ptr to end of final buffer
    LPWSTR pNegSign;                   // ptr to negative sign string
    BOOL IsNeg;                        // if negative sign in string
    int Length;                        // length of number string
    BOOL fZeroValue = FALSE;           // if number is a zero value
    int NegSignSize;                   // size of negative sign string
    UINT NegOrder;                     // negative ordering
    int CurrSymSize;                   // size of currency symbol
    WCHAR pTemp[MAX_REG_VAL_SIZE];     // temp buffer


    //
    //  Initialize pointer.
    //
    //  Account for:
    //    - negative sign
    //    - currency sign
    //    - blank spaces
    //    - one extra number from rounding
    //    - one extra grouping separator from rounding
    //
    pBegin = *ppBuf + MAX_CURRENCY_EXTRAS;

    //
    //  If the first value is a negative, then increment past it.
    //
    if (IsNeg = (*pValue == NLS_CHAR_HYPHEN))
    {
        pValue++;
    }

    //
    //  Get the appropriate number string and place it in the buffer.
    //
    Length = GetNumberString( pHashN,
                              pValue,
                              (LPNUMBERFMTW)pFormat,
                              &pBegin,
                              BufSize - MAX_CURRENCY_EXTRAS,
                              &fZeroValue,
                              pNeededSizeToAllocate,
                              fSetError );
    if (!Length)
    {
        if (*pNeededSizeToAllocate > 0)
        {
            *pNeededSizeToAllocate += MAX_CURRENCY_EXTRAS;
        }
        return (0);
    }

    //
    //  Advance pEnd position pointer to the end of the number string.
    //
    pEnd = pBegin + (Length - 1);

    //
    //  Get the size of the currency symbol.
    //
    CurrSymSize = NlsStrLenW(pFormat->lpCurrencySymbol);

    //
    //  See if any characters should be put in the buffer BEFORE and
    //  AFTER the properly formatted number string.
    //      - currency symbol
    //      - negative sign or opening/closing parenthesis
    //      - blank space
    //
    if (!fZeroValue && IsNeg)
    {
        //
        //  Get the negative sign string and the size of it.
        //
        NegOrder = pFormat->NegativeOrder;
        if ((NegOrder != 0) && (NegOrder != 4) && (NegOrder < 14))
        {
            if ( (!NoUserOverride) &&
                 GetUserInfo( pHashN->Locale,
                              LOCALE_SNEGATIVESIGN,
                              FIELD_OFFSET(NLS_USER_INFO, sNegSign),
                              NLS_VALUE_SNEGATIVESIGN,
                              pTemp,
                              ARRAYSIZE(pTemp),
                              TRUE ) &&
                 IsValidSeparatorString( pTemp,
                                         MAX_SNEGSIGN,
                                         FALSE ) )
            {
                pNegSign = pTemp;
            }
            else
            {
                pNegSign = (LPWORD)(pHashN->pLocaleHdr) +
                           pHashN->pLocaleHdr->SNegativeSign;
            }

            NegSignSize = NlsStrLenW(pNegSign);
        }

        switch (NegOrder)
        {
            case ( 0 ) :
            {
                //
                //  Copy the currency symbol to the buffer.
                //
                pBegin -= CurrSymSize;
                NLS_COPY_UNICODE_STR_TMP(pBegin, pFormat->lpCurrencySymbol);

                //
                //  Put the opening parenthesis in the buffer.
                //
                pBegin--;
                *pBegin = NLS_CHAR_OPEN_PAREN;

                //
                //  Put the closing parenthesis in the buffer.
                //
                *pEnd = NLS_CHAR_CLOSE_PAREN;
                pEnd++;

                break;
            }
            case ( 1 ) :
            default :
            {
                //
                //  Copy the currency symbol to the buffer.
                //
                pBegin -= CurrSymSize;
                NLS_COPY_UNICODE_STR_TMP(pBegin, pFormat->lpCurrencySymbol);

                //
                //  Copy the negative sign to the buffer.
                //
                pBegin -= NegSignSize;
                NLS_COPY_UNICODE_STR_TMP(pBegin, pNegSign);

                break;
            }
            case ( 2 ) :
            {
                //
                //  Copy the negative sign to the buffer.
                //
                pBegin -= NegSignSize;
                NLS_COPY_UNICODE_STR_TMP(pBegin, pNegSign);

                //
                //  Copy the currency symbol to the buffer.
                //
                pBegin -= CurrSymSize;
                NLS_COPY_UNICODE_STR_TMP(pBegin, pFormat->lpCurrencySymbol);

                break;
            }
            case ( 3 ) :
            {
                //
                //  Copy the currency symbol to the buffer.
                //
                pBegin -= CurrSymSize;
                NLS_COPY_UNICODE_STR_TMP(pBegin, pFormat->lpCurrencySymbol);

                //
                //  Copy the negative sign to the buffer.
                //
                NLS_COPY_UNICODE_STR(pEnd, pNegSign);

                break;
            }
            case ( 4 ) :
            {
                //
                //  Put the opening parenthesis in the buffer.
                //
                pBegin--;
                *pBegin = NLS_CHAR_OPEN_PAREN;

                //
                //  Copy the currency symbol to the buffer.
                //
                NLS_COPY_UNICODE_STR(pEnd, pFormat->lpCurrencySymbol);

                //
                //  Put the closing parenthesis in the buffer.
                //
                *pEnd = NLS_CHAR_CLOSE_PAREN;
                pEnd++;

                break;
            }
            case ( 5 ) :
            {
                //
                //  Copy the negative sign to the buffer.
                //
                pBegin -= NegSignSize;
                NLS_COPY_UNICODE_STR_TMP(pBegin, pNegSign);

                //
                //  Copy the currency symbol to the buffer.
                //
                NLS_COPY_UNICODE_STR(pEnd, pFormat->lpCurrencySymbol);

                break;
            }
            case ( 6 ) :
            {
                //
                //  Copy the negative sign to the buffer.
                //
                NLS_COPY_UNICODE_STR(pEnd, pNegSign);

                //
                //  Copy the currency symbol to the buffer.
                //
                NLS_COPY_UNICODE_STR(pEnd, pFormat->lpCurrencySymbol);

                break;
            }
            case ( 7 ) :
            {
                //
                //  Copy the currency symbol to the buffer.
                //
                NLS_COPY_UNICODE_STR(pEnd, pFormat->lpCurrencySymbol);

                //
                //  Copy the negative sign to the buffer.
                //
                NLS_COPY_UNICODE_STR(pEnd, pNegSign);

                break;
            }
            case ( 8 ) :
            {
                //
                //  Copy the negative sign to the buffer.
                //
                pBegin -= NegSignSize;
                NLS_COPY_UNICODE_STR_TMP(pBegin, pNegSign);

                //
                //  Put a space in the buffer.
                //
                *pEnd = NLS_CHAR_SPACE;
                pEnd++;

                //
                //  Copy the currency symbol to the buffer.
                //
                NLS_COPY_UNICODE_STR(pEnd, pFormat->lpCurrencySymbol);

                break;
            }
            case ( 9 ) :
            {
                //
                //  Put a space in the buffer.
                //
                pBegin--;
                *pBegin = NLS_CHAR_SPACE;

                //
                //  Copy the currency symbol to the buffer.
                //
                pBegin -= CurrSymSize;
                NLS_COPY_UNICODE_STR_TMP(pBegin, pFormat->lpCurrencySymbol);

                //
                //  Copy the negative sign to the buffer.
                //
                pBegin -= NegSignSize;
                NLS_COPY_UNICODE_STR_TMP(pBegin, pNegSign);

                break;
            }
            case ( 10 ) :
            {
                //
                //  Put a space in the buffer.
                //
                *pEnd = NLS_CHAR_SPACE;
                pEnd++;

                //
                //  Copy the currency symbol to the buffer.
                //
                NLS_COPY_UNICODE_STR(pEnd, pFormat->lpCurrencySymbol);

                //
                //  Copy the negative sign to the buffer.
                //
                NLS_COPY_UNICODE_STR(pEnd, pNegSign);

                break;
            }
            case ( 11 ) :
            {
                //
                //  Put a space in the buffer.
                //
                pBegin--;
                *pBegin = NLS_CHAR_SPACE;

                //
                //  Copy the currency symbol to the buffer.
                //
                pBegin -= CurrSymSize;
                NLS_COPY_UNICODE_STR_TMP(pBegin, pFormat->lpCurrencySymbol);

                //
                //  Copy the negative sign to the buffer.
                //
                NLS_COPY_UNICODE_STR(pEnd, pNegSign);

                break;
            }
            case ( 12 ) :
            {
                //
                //  Copy the negative sign to the buffer.
                //
                pBegin -= NegSignSize;
                NLS_COPY_UNICODE_STR_TMP(pBegin, pNegSign);

                //
                //  Put a space in the buffer.
                //
                pBegin--;
                *pBegin = NLS_CHAR_SPACE;

                //
                //  Copy the currency symbol to the buffer.
                //
                pBegin -= CurrSymSize;
                NLS_COPY_UNICODE_STR_TMP(pBegin, pFormat->lpCurrencySymbol);

                break;
            }
            case ( 13 ) :
            {
                //
                //  Copy the negative sign to the buffer.
                //
                NLS_COPY_UNICODE_STR(pEnd, pNegSign);

                //
                //  Put a space in the buffer.
                //
                *pEnd = NLS_CHAR_SPACE;
                pEnd++;

                //
                //  Copy the currency symbol to the buffer.
                //
                NLS_COPY_UNICODE_STR(pEnd, pFormat->lpCurrencySymbol);

                break;
            }
            case ( 14 ) :
            {
                //
                //  Put a space in the buffer.
                //
                pBegin--;
                *pBegin = NLS_CHAR_SPACE;

                //
                //  Copy the currency symbol to the buffer.
                //
                pBegin -= CurrSymSize;
                NLS_COPY_UNICODE_STR_TMP(pBegin, pFormat->lpCurrencySymbol);

                //
                //  Put the opening parenthesis in the buffer.
                //
                pBegin--;
                *pBegin = NLS_CHAR_OPEN_PAREN;

                //
                //  Put the closing parenthesis in the buffer.
                //
                *pEnd = NLS_CHAR_CLOSE_PAREN;
                pEnd++;

                break;
            }
            case ( 15 ) :
            {
                //
                //  Put the opening parenthesis in the buffer.
                //
                pBegin--;
                *pBegin = NLS_CHAR_OPEN_PAREN;

                //
                //  Put a space in the buffer.
                //
                *pEnd = NLS_CHAR_SPACE;
                pEnd++;

                //
                //  Copy the currency symbol to the buffer.
                //
                NLS_COPY_UNICODE_STR(pEnd, pFormat->lpCurrencySymbol);

                //
                //  Put the closing parenthesis in the buffer.
                //
                *pEnd = NLS_CHAR_CLOSE_PAREN;
                pEnd++;

                break;
            }
        }
    }
    else
    {
        //
        //  Positive value.  Store the currency symbol in the string
        //  if the positive order is either 0 or 2.  Otherwise, wait
        //  till the end.
        //
        switch (pFormat->PositiveOrder)
        {
            case ( 2 ) :
            {
                //
                //  Put a space in the buffer.
                //
                pBegin--;
                *pBegin = NLS_CHAR_SPACE;

                //
                //  Fall through to case 0.
                //
            }
            case ( 0 ) :
            default :
            {
                //
                //  Copy the currency symbol to the buffer.
                //
                pBegin -= CurrSymSize;
                NLS_COPY_UNICODE_STR_TMP(pBegin, pFormat->lpCurrencySymbol);

                break;
            }
            case ( 3 ) :
            {
                //
                //  Put a space in the buffer.
                //
                *pEnd = NLS_CHAR_SPACE;
                pEnd++;

                //
                //  Fall through to case 1.
                //
            }
            case ( 1 ) :
            {
                //
                //  Copy the currency symbol to the buffer.
                //
                NLS_COPY_UNICODE_STR(pEnd, pFormat->lpCurrencySymbol);

                break;
            }
        }
    }

    //
    //  Zero terminate the string.
    //
    *pEnd = 0;

    //
    //  Return the pointer to the beginning of the string.
    //
    *ppBuf = pBegin;

    //
    //  Return the number of characters written to the buffer, including
    //  the null terminator.
    //
    return ((int)((pEnd - pBegin) + 1));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\sources.inc ===
MAJORCOMP = nlsapi

TARGETNAME = nlslib
TARGETPATH = obj
TARGETTYPE = LIBRARY

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL = /W3
!ENDIF
MSC_WARNING_LEVEL = $(MSC_WARNING_LEVEL) /WX

C_DEFINES = $(C_DEFINES) -DUNICODE -D_KERNEL32_

INCLUDES = ..\..\inc;$(WINDOWS_INC_PATH)

SOURCES = ..\ansi.c       \
          ..\csrlocal.c   \
          ..\csrtables.c  \
          ..\datetime.c   \
          ..\enum.c       \
          ..\geo.c        \
          ..\init.c       \
          ..\jamo.c	  \
          ..\locale.c     \
          ..\map.c        \
          ..\mbcs.c       \
          ..\number.c     \
          ..\section.c    \
          ..\string.c     \
          ..\tables.c     \
          ..\utf.c        \
          ..\util.c       \
          ..\security.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\tables.c ===
/*++

Copyright (c) 1991-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    tables.c

Abstract:

    This file contains functions that manipulate or return information
    about the different tables used by the NLS API.

    External Routines found in this file:
      AllocTables
      GetUnicodeFileInfo
      GetGeoFileInfo
      GetCTypeFileInfo
      GetDefaultSortkeyFileInfo
      GetDefaultSortTablesFileInfo
      GetSortkeyFileInfo
      GetSortTablesFileInfo
      GetCodePageFileInfo
      GetLanguageFileInfo
      GetLocaleFileInfo
      MakeCPHashNode
      MakeLangHashNode
      MakeLocHashNode
      GetCPHashNode
      GetLangHashNode
      GetLocHashNode
      GetCalendar

Revision History:

    05-31-91    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nls.h"




//
//  Constant Declarations.
//

#define SEM_NOERROR   (SEM_FAILCRITICALERRORS |     \
                       SEM_NOGPFAULTERRORBOX  |     \
                       SEM_NOOPENFILEERRORBOX)



//
//  Global Variables.
//

PTBL_PTRS  pTblPtrs;              // ptr to structure of table ptrs




//
//  Forward Declarations.
//

BOOL
IsValidSortId(
    LCID Locale);

ULONG
GetLanguageExceptionInfo(void);

LPWORD
GetLinguisticLanguageInfo(
    LCID Locale);

ULONG
CreateAndCopyLanguageExceptions(
    LCID Locale,
    LPWORD *ppBaseAddr);

BOOL FASTCALL
FindLanguageExceptionPointers(
    LCID Locale,
    PL_EXCEPT_HDR *ppExceptHdr,
    PL_EXCEPT *ppExceptTbl);

void FASTCALL
CopyLanguageExceptionInfo(
    LPWORD pBaseAddr,
    PL_EXCEPT_HDR pExceptHdr,
    PL_EXCEPT pExceptTbl);

BOOL FASTCALL
FindExceptionPointers(
    LCID Locale,
    PEXCEPT_HDR *ppExceptHdr,
    PEXCEPT *ppExceptTbl,
    PVOID *ppIdeograph,
    PULONG pReturn);

void FASTCALL
CopyExceptionInfo(
    PSORTKEY pSortkey,
    PEXCEPT_HDR pExceptHdr,
    PEXCEPT pExceptTbl,
    PVOID pIdeograph);

ULONG
WaitOnEvent(
    LPWORD pSem);





//-------------------------------------------------------------------------//
//                           INTERNAL MACROS                               //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  GET_HASH_VALUE
//
//  Returns the hash value for given value and the given table size.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_HASH_VALUE(Value, TblSize)      (Value % TblSize)


////////////////////////////////////////////////////////////////////////////
//
//  CREATE_CODEPAGE_HASH_NODE
//
//  Creates a code page hash node and stores the pointer to it in pHashN.
//
//  NOTE: This macro may return if an error is encountered.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define CREATE_CODEPAGE_HASH_NODE( CodePage,                               \
                                   pHashN )                                \
{                                                                          \
    /*                                                                     \
     *  Allocate CP_HASH structure.                                        \
     */                                                                    \
    if ((pHashN = (PCP_HASH)NLS_ALLOC_MEM(sizeof(CP_HASH))) == NULL)       \
    {                                                                      \
        return (ERROR_OUTOFMEMORY);                                        \
    }                                                                      \
                                                                           \
    /*                                                                     \
     *  Fill in the CodePage value.                                        \
     */                                                                    \
    pHashN->CodePage = CodePage;                                           \
                                                                           \
    /*                                                                     \
     *   Make sure the pfnCPProc value is NULL for now.                    \
     */                                                                    \
    pHashN->pfnCPProc = NULL;                                              \
}


////////////////////////////////////////////////////////////////////////////
//
//  CREATE_LOCALE_HASH_NODE
//
//  Creates a locale hash node and stores the pointer to it in pHashN.
//
//  NOTE: This macro may return if an error is encountered.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define CREATE_LOCALE_HASH_NODE( Locale,                                   \
                                 pHashN )                                  \
{                                                                          \
    /*                                                                     \
     *  Allocate LOC_HASH structure.                                       \
     */                                                                    \
    if ((pHashN = (PLOC_HASH)NLS_ALLOC_MEM(sizeof(LOC_HASH))) == NULL)     \
    {                                                                      \
        return (ERROR_OUTOFMEMORY);                                        \
    }                                                                      \
                                                                           \
    /*                                                                     \
     *  Fill in the Locale value.                                          \
     */                                                                    \
    pHashN->Locale = Locale;                                               \
}


////////////////////////////////////////////////////////////////////////////
//
//  FIND_CP_HASH_NODE
//
//  Searches for the cp hash node for the given locale.  The result is
//  put in pHashN.  If no node exists, pHashN will be NULL.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define FIND_CP_HASH_NODE( CodePage,                                       \
                           pHashN )                                        \
{                                                                          \
    UINT Index;                   /* hash value */                         \
                                                                           \
    /*                                                                     \
     *  Get hash value.                                                    \
     */                                                                    \
    Index = GET_HASH_VALUE(CodePage, CP_TBL_SIZE);                         \
                                                                           \
    /*                                                                     \
     *  Make sure the hash node still doesn't exist in the table.          \
     */                                                                    \
    pHashN = (pTblPtrs->pCPHashTbl)[Index];                                \
    while ((pHashN != NULL) && (pHashN->CodePage != CodePage))             \
    {                                                                      \
        pHashN = pHashN->pNext;                                            \
    }                                                                      \
}

////////////////////////////////////////////////////////////////////////////
//
//  IsCPHashNodeLoaded
//
//  Wrapper for the FIND_CP_HASH_NODE macro so that we can call this from
//  mbcs.c.  Return TRUE if the node already exists, otherwise false.  False
//  could still indicate a valid code page, just not one already loaded.
//
//  05-31-02    ShawnSte    Created.
////////////////////////////////////////////////////////////////////////////
BOOL IsCPHashNodeLoaded( UINT CodePage )
{
    PCP_HASH pHashN;              // ptr to CP hash node

    //
    //  Get hash node.
    //
    FIND_CP_HASH_NODE(CodePage, pHashN);

    return (pHashN != NULL);
}

////////////////////////////////////////////////////////////////////////////
//
//  FIND_LOCALE_HASH_NODE
//
//  Searches for the locale hash node for the given locale.  The result is
//  put in pHashN.  If no node exists, pHashN will be NULL.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define FIND_LOCALE_HASH_NODE( Locale,                                     \
                               pHashN )                                    \
{                                                                          \
    UINT Index;                   /* hash value */                         \
                                                                           \
                                                                           \
    /*                                                                     \
     *  Get hash value.                                                    \
     */                                                                    \
    Index = GET_HASH_VALUE(Locale, LOC_TBL_SIZE);                          \
                                                                           \
    /*                                                                     \
     *  Get hash node.                                                     \
     */                                                                    \
    pHashN = (pTblPtrs->pLocHashTbl)[Index];                               \
    while ((pHashN != NULL) && (pHashN->Locale != Locale))                 \
    {                                                                      \
        pHashN = pHashN->pNext;                                            \
    }                                                                      \
}


////////////////////////////////////////////////////////////////////////////
//
//  EXIST_LANGUAGE_INFO
//
//  Checks to see if the casing tables have been added to the locale
//  hash node.
//
//  Must check the LOWER CASE pointer, since that value is set last in
//  the hash node.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define EXIST_LANGUAGE_INFO(pHashN)         (pHashN->pLowerCase)


////////////////////////////////////////////////////////////////////////////
//
//  EXIST_LINGUIST_LANGUAGE_INFO
//
//  Checks to see if the linguistic casing tables have been added to the locale
//  hash node.
//
//  Must check the LOWER CASE pointer, since that value is set last in
//  the hash node.
//
//  DEFINED AS A MACRO.
//
//  08-30-95    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define EXIST_LINGUIST_LANGUAGE_INFO(pHashN)  (pHashN->pLowerLinguist)


////////////////////////////////////////////////////////////////////////////
//
//  EXIST_LOCALE_INFO
//
//  Checks to see if the locale tables have been added to the locale
//  hash node.
//
//  Must check the FIXED locale pointer, since that value is set last in
//  the hash node.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define EXIST_LOCALE_INFO(pHashN)           (pHashN->pLocaleFixed)


////////////////////////////////////////////////////////////////////////////
//
//  INSERT_CP_HASH_NODE
//
//  Inserts a CP hash node into the global CP hash table.  It assumes that
//  all unused hash values in the table are pointing to NULL.  If there is
//  a collision, the new node will be added FIRST in the list.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define INSERT_CP_HASH_NODE( pHashN,                                       \
                             pBaseAddr )                                   \
{                                                                          \
    UINT Index;                   /* hash value */                         \
    PCP_HASH pSearch;             /* ptr to CP hash node for search */     \
                                                                           \
                                                                           \
    /*                                                                     \
     *  Get hash value.                                                    \
     */                                                                    \
    Index = GET_HASH_VALUE(pHashN->CodePage, CP_TBL_SIZE);                 \
                                                                           \
    /*                                                                     \
     *  Enter table pointers critical section.                             \
     */                                                                    \
    RtlEnterCriticalSection(&gcsTblPtrs);                                  \
                                                                           \
    /*                                                                     \
     *  Make sure the hash node still doesn't exist in the table.          \
     */                                                                    \
    pSearch = (pTblPtrs->pCPHashTbl)[Index];                               \
    while ((pSearch != NULL) && (pSearch->CodePage != pHashN->CodePage))   \
    {                                                                      \
        pSearch = pSearch->pNext;                                          \
    }                                                                      \
                                                                           \
    /*                                                                     \
     *  If the hash node does not exist, insert the new one.               \
     *  Otherwise, free it.                                                \
     */                                                                    \
    if (pSearch == NULL)                                                   \
    {                                                                      \
        /*                                                                 \
         *  Insert hash node into hash table.                              \
         */                                                                \
        pHashN->pNext = (pTblPtrs->pCPHashTbl)[Index];                     \
        (pTblPtrs->pCPHashTbl)[Index] = pHashN;                            \
    }                                                                      \
    else                                                                   \
    {                                                                      \
        /*                                                                 \
         *  Free the resources allocated.                                  \
         */                                                                \
        if (pBaseAddr)                                                     \
        {                                                                  \
            UnMapSection(pBaseAddr);                                       \
        }                                                                  \
        NLS_FREE_MEM(pHashN);                                              \
    }                                                                      \
                                                                           \
    /*                                                                     \
     *  Leave table pointers critical section.                             \
     */                                                                    \
    RtlLeaveCriticalSection(&gcsTblPtrs);                                  \
}


////////////////////////////////////////////////////////////////////////////
//
//  INSERT_LOC_HASH_NODE
//
//  Inserts a LOC hash node into the global LOC hash table.  It assumes
//  that all unused hash values in the table are pointing to NULL.  If
//  there is a collision, the new node will be added FIRST in the list.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define INSERT_LOC_HASH_NODE( pHashN,                                      \
                              pBaseAddr )                                  \
{                                                                          \
    UINT Index;                   /* hash value */                         \
    PLOC_HASH pSearch;            /* ptr to LOC hash node for search */    \
                                                                           \
                                                                           \
    /*                                                                     \
     *  Get hash value.                                                    \
     */                                                                    \
    Index = GET_HASH_VALUE(pHashN->Locale, LOC_TBL_SIZE);                  \
                                                                           \
    /*                                                                     \
     *  Enter table pointers critical section.                             \
     */                                                                    \
    RtlEnterCriticalSection(&gcsTblPtrs);                                  \
                                                                           \
    /*                                                                     \
     *  Make sure the hash node still doesn't exist in the table.          \
     */                                                                    \
    pSearch = (pTblPtrs->pLocHashTbl)[Index];                              \
    while ((pSearch != NULL) && (pSearch->Locale != pHashN->Locale))       \
    {                                                                      \
        pSearch = pSearch->pNext;                                          \
    }                                                                      \
                                                                           \
    /*                                                                     \
     *  If the hash node does not exist, insert the new one.               \
     *  Otherwise, free it.                                                \
     */                                                                    \
    if (pSearch == NULL)                                                   \
    {                                                                      \
        /*                                                                 \
         *  Insert hash node into hash table.                              \
         */                                                                \
        pHashN->pNext = (pTblPtrs->pLocHashTbl)[Index];                    \
        (pTblPtrs->pLocHashTbl)[Index] = pHashN;                           \
    }                                                                      \
    else                                                                   \
    {                                                                      \
        /*                                                                 \
         *  Free the resources allocated.                                  \
         */                                                                \
        if (pBaseAddr)                                                     \
        {                                                                  \
            UnMapSection(pBaseAddr);                                       \
        }                                                                  \
        if ((pHashN->pSortkey != pTblPtrs->pDefaultSortkey) &&             \
            (pHashN->pSortkey != NULL))                                    \
        {                                                                  \
            UnMapSection(((LPWORD)(pHashN->pSortkey)) - SORTKEY_HEADER);   \
        }                                                                  \
        NLS_FREE_MEM(pHashN);                                              \
    }                                                                      \
                                                                           \
    /*                                                                     \
     *  Leave table pointers critical section.                             \
     */                                                                    \
    RtlLeaveCriticalSection(&gcsTblPtrs);                                  \
}


////////////////////////////////////////////////////////////////////////////
//
//  GET_CP_SECTION_NAME
//
//  Gets the section name for a given code page.
//
//  NOTE: This macro may return if an error is encountered.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_CP_SECTION_NAME( CodePage,                                     \
                             pwszSecName,                                  \
                             cchSecName,                                   \
                             pObSecName )                                  \
{                                                                          \
    if (rc = GetNlsSectionName( CodePage,                                  \
                                10,                                        \
                                0,                                         \
                                NLS_SECTION_CPPREFIX,                      \
                                pwszSecName,                               \
                                cchSecName))                               \
    {                                                                      \
        return (rc);                                                       \
    }                                                                      \
    RtlInitUnicodeString(pObSecName, pwszSecName);                         \
}


////////////////////////////////////////////////////////////////////////////
//
//  GET_SORTKEY_SECTION_NAME
//
//  Gets the sortkey section name for a given locale.
//
//  NOTE: This macro may return if an error is encountered.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_SORTKEY_SECTION_NAME( Locale,                                  \
                                  pwszSecName,                             \
                                  cchSecName,                              \
                                  pObSecName )                             \
{                                                                          \
    if (rc = GetNlsSectionName( Locale,                                    \
                                16,                                        \
                                8,                                         \
                                NLS_SECTION_SORTKEY,                       \
                                pwszSecName,                               \
                                cchSecName))                               \
    {                                                                      \
        return (rc);                                                       \
    }                                                                      \
    RtlInitUnicodeString(pObSecName, pwszSecName);                         \
}


////////////////////////////////////////////////////////////////////////////
//
//  GET_LANG_SECTION_NAME
//
//  Gets the section name for a given language.
//
//  NOTE: This macro may return if an error is encountered.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_LANG_SECTION_NAME( Locale,                                     \
                               pwszSecName,                                \
                               cchSecName,                                 \
                               pObSecName )                                \
{                                                                          \
    if (rc = GetNlsSectionName( Locale,                                    \
                                16,                                        \
                                8,                                         \
                                NLS_SECTION_LANGPREFIX,                    \
                                pwszSecName,                               \
                                cchSecName))                               \
    {                                                                      \
        return (rc);                                                       \
    }                                                                      \
    RtlInitUnicodeString(pObSecName, pwszSecName);                         \
}





//-------------------------------------------------------------------------//
//                           EXTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  AllocTables
//
//  Allocates the global table pointers structure.  It then allocates the
//  code page and locale hash tables and saves the pointers to the tables
//  in the global table pointers structure.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG AllocTables()
{
    //
    //  Allocate global table pointers structure.
    //
    if ((pTblPtrs = (PTBL_PTRS)NLS_ALLOC_MEM(sizeof(TBL_PTRS))) == NULL)
    {
        KdPrint(("NLSAPI: Allocation for TABLE PTRS structure FAILED.\n"));
        return (ERROR_OUTOFMEMORY);
    }

    //
    //  Allocate code page hash table.
    //
    if ((pTblPtrs->pCPHashTbl =
         (PCP_HASH_TBL)NLS_ALLOC_MEM(sizeof(PCP_HASH) * CP_TBL_SIZE)) == NULL)
    {
        KdPrint(("NLSAPI: Allocation for CODE PAGE hash table FAILED.\n"));
        return (ERROR_OUTOFMEMORY);
    }

    //
    //  Allocate locale hash table.
    //
    if ((pTblPtrs->pLocHashTbl =
         (PLOC_HASH_TBL)NLS_ALLOC_MEM(sizeof(PLOC_HASH) * LOC_TBL_SIZE)) == NULL)
    {
        KdPrint(("NLSAPI: Allocation for LOCALE hash table FAILED.\n"));
        return (ERROR_OUTOFMEMORY);
    }

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetUnicodeFileInfo
//
//  Opens and Maps a view of the section for the unicode file.  It then
//  fills in the appropriate fields of the global table pointers structure.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG GetUnicodeFileInfo()
{
    HANDLE hSec = (HANDLE)0;      // section handle
    UNICODE_STRING ObSecName;     // section name
    LPWORD pBaseAddr;             // ptr to base address of section
    ULONG rc = 0L;                // return code

    WORD offCZ;                   // offset to FOLDCZONE table
    WORD offHG;                   // offset to HIRAGANA table
    WORD offKK;                   // offset to KATAKANA table
    WORD offHW;                   // offset to HALFWIDTH table
    WORD offFW;                   // offset to FULLWIDTH table
    WORD offTR;                   // offset to TRADITIONAL table
    WORD offSP;                   // offset to SIMPLIFIED table
    WORD offPre;                  // offset to PRECOMPOSED table
    WORD offComp;                 // offset to COMPOSITE table
    PCOMP_INFO pComp;             // ptr to COMP_INFO structure


    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    //
    //  Make sure the unicode information is not already there.
    //  If it is, return success.
    //
    //  Since we're already in the critical section here, there is no
    //  need to check ALL of the pointers set in this routine.  Just
    //  check one of them.
    //
    if (pTblPtrs->pADigit != NULL)
    {
        return (NO_ERROR);
    }

    //
    //  Open and Map a view of the section.
    //
    RtlInitUnicodeString(&ObSecName, NLS_SECTION_UNICODE);
    if (rc = OpenSection( &hSec,
                          &ObSecName,
                          (PVOID *)&pBaseAddr,
                          SECTION_MAP_READ,
                          TRUE ))
    {
        return (rc);
    }

    //
    //  Get the offsets.
    //
    offCZ   = pBaseAddr[0];
    offHG   = offCZ  + pBaseAddr[offCZ];
    offKK   = offHG  + pBaseAddr[offHG];
    offHW   = offKK  + pBaseAddr[offKK];
    offFW   = offHW  + pBaseAddr[offHW];
    offTR   = offFW  + pBaseAddr[offFW];
    offSP   = offTR  + pBaseAddr[offTR];
    offPre  = offSP  + pBaseAddr[offSP];
    offComp = offPre + pBaseAddr[offPre];

    //
    //  Allocate COMP_INFO structure.
    //
    if ((pComp = (PCOMP_INFO)NLS_ALLOC_MEM(sizeof(COMP_INFO))) == NULL)
    {
        return (ERROR_OUTOFMEMORY);
    }

    //
    //  Fill in the COMPOSITE information.
    //
    pComp->NumBase  = LOBYTE((pBaseAddr + offComp)[2]);
    pComp->NumNonSp = HIBYTE((pBaseAddr + offComp)[2]);
    pComp->pBase    = pBaseAddr + offComp + CO_HEADER;
    pComp->pNonSp   = pComp->pBase  + ((pBaseAddr + offComp)[0]);
    pComp->pGrid    = pComp->pNonSp + ((pBaseAddr + offComp)[1]);

    //
    //  Attach ASCIIDIGITS table to tbl ptrs structure.
    //
    pTblPtrs->pADigit = pBaseAddr + AD_HEADER;

    //
    //  Attach FOLDCZONE table to tbl ptrs structure.
    //
    pTblPtrs->pCZone = pBaseAddr + offCZ + CZ_HEADER;

    //
    //  Attach HIRAGANA table to tbl ptrs structure.
    //
    pTblPtrs->pHiragana = pBaseAddr + offHG + HG_HEADER;

    //
    //  Attach KATAKANA table to tbl ptrs structure.
    //
    pTblPtrs->pKatakana = pBaseAddr + offKK + KK_HEADER;

    //
    //  Attach HALFWIDTH table to tbl ptrs structure.
    //
    pTblPtrs->pHalfWidth = pBaseAddr + offHW + HW_HEADER;

    //
    //  Attach FULLWIDTH table to tbl ptrs structure.
    //
    pTblPtrs->pFullWidth = pBaseAddr + offFW + FW_HEADER;

    //
    //  Attach TRADITIONAL table to tbl ptrs structure.
    //
    pTblPtrs->pTraditional = pBaseAddr + offTR + TR_HEADER;

    //
    //  Attach SIMPLIFIED table to tbl ptrs structure.
    //
    pTblPtrs->pSimplified = pBaseAddr + offSP + SP_HEADER;

    //
    //  Attach PRECOMPOSED table to tbl ptrs structure.
    //
    pTblPtrs->pPreComposed = pBaseAddr + offPre + PC_HEADER;

    //
    //  Attach COMP_INFO to tbl ptrs structure.
    //
    pTblPtrs->pComposite = pComp;

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetGeoFileInfo
//
//  Opens and Maps a view of the section for the geo file.  It then
//  fills in the appropriate field of the global table pointers structure.
//  Before calling this function you should check pGeoInfo member.
//
////////////////////////////////////////////////////////////////////////////

ULONG GetGeoFileInfo()
{
    HANDLE hSec = (HANDLE)0;      // section handle
    UNICODE_STRING ObSecName;     // section name
    LPWORD pBaseAddr;             // ptr to base address of section
    ULONG rc = NO_ERROR;          // return code

    //
    //  Enter the critical section to set up the GEO tables.
    //
    RtlEnterCriticalSection(&gcsTblPtrs);

    //
    //  Make sure the Geographical Information table is
    //  not already there. If it is, return TRUE.
    //
    //  Since we're already in the critical section here, there is no
    //  need to check ALL of the pointers set in this routine.  Just
    //  check one of them.
    //
    if (pTblPtrs->pGeoInfo != NULL)
    {
        RtlLeaveCriticalSection(&gcsTblPtrs);
        return (NO_ERROR);
    }

    //
    //  Create and map the section, and then save the pointer.
    //
    if ((rc = CsrBasepNlsCreateSection(NLS_CREATE_SECTION_GEO, 0, &hSec)) == NO_ERROR)
    {
        //
        //  Map a View of the Section.
        //
        if ((rc = MapSection( hSec,
                              &pBaseAddr,
                              PAGE_READONLY,
                              TRUE )) != NO_ERROR)
        {
            RtlLeaveCriticalSection(&gcsTblPtrs);
            return (rc);
        }
    }
    else
    {
        RtlLeaveCriticalSection(&gcsTblPtrs);
        return (rc);
    }

    //
    //  Attach GeoInfo mapping table, GEO/LCID mapping table and
    //  GEO/ISO639 name mapping table to the tbl ptrs structure. We initialize
    //  the pGeoinfo member at the end so we don't get a race condition.
    //
    pTblPtrs->nGeoLCID = ((PGEOTABLEHDR)pBaseAddr)->nGeoLCID;
    pTblPtrs->pGeoLCID = (PGEOLCID)((PBYTE)pBaseAddr + ((PGEOTABLEHDR)pBaseAddr)->dwOffsetGeoLCID);
    pTblPtrs->nGeoInfo = ((PGEOTABLEHDR)pBaseAddr)->nGeoInfo;
    pTblPtrs->pGeoInfo = (PGEOINFO)((PBYTE)pBaseAddr + ((PGEOTABLEHDR)pBaseAddr)->dwOffsetGeoInfo);

    //
    //  Leave table pointers critical section.
    //
    RtlLeaveCriticalSection(&gcsTblPtrs);

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetCTypeFileInfo
//
//  Opens and Maps a view of the section for the given ctype.  It then
//  fills in the appropriate field of the global table pointers structure.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG GetCTypeFileInfo()
{
    HANDLE hSec = (HANDLE)0;      // section handle
    UNICODE_STRING ObSecName;     // section name
    LPWORD pBaseAddr;             // ptr to base address of section
    ULONG rc = 0L;                // return code


    //
    //  Make sure the ctype information is not already there.
    //  If it is, return success.
    //
    //  Must check the 844 table rather than the mapping table, since
    //  the 844 table is set AFTER the mapping table below.  Otherwise,
    //  there is a race condition, since we're not in a critical section.
    //
    if (pTblPtrs->pCType844 != NULL)
    {
        return (NO_ERROR);
    }

    //
    //  Enter table pointers critical section.
    //
    RtlEnterCriticalSection(&gcsTblPtrs);
    if (pTblPtrs->pCType844 != NULL)
    {
        RtlLeaveCriticalSection(&gcsTblPtrs);
        return (NO_ERROR);
    }

    //
    //  Open and Map a view of the section.
    //
    RtlInitUnicodeString(&ObSecName, NLS_SECTION_CTYPE);
    if (rc = OpenSection( &hSec,
                          &ObSecName,
                          (PVOID *)&pBaseAddr,
                          SECTION_MAP_READ,
                          TRUE ))
    {
        RtlLeaveCriticalSection(&gcsTblPtrs);
        return (rc);
    }

    //
    //  Attach CTYPE mapping table and 8:4:4 table to tbl ptrs structure.
    //
    //  The pCType844 value must be set LAST, since this is the pointer
    //  that is checked to see that the ctype information has been
    //  initialized.
    //
    pTblPtrs->pCTypeMap = (PCT_VALUES)(pBaseAddr + CT_HEADER);
    pTblPtrs->pCType844 = (PCTYPE)((LPBYTE)(pBaseAddr + 1) +
                                   ((PCTYPE_HDR)pBaseAddr)->MapSize);

    //
    //  Leave table pointers critical section.
    //
    RtlLeaveCriticalSection(&gcsTblPtrs);

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetDefaultSortkeyFileInfo
//
//  Opens and Maps a view of the section for the default sortkey table.  It
//  then stores the pointer to the table in the global pointer table.
//
//  NOTE: THIS ROUTINE SHOULD ONLY BE CALLED AT PROCESS STARTUP.  If it is
//        called from other than process startup, a critical section must
//        be placed around the assigning of the pointers to pTblPtrs.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG GetDefaultSortkeyFileInfo()
{
    HANDLE hSec = (HANDLE)0;           // section handle
    UNICODE_STRING ObSecName;          // section name
    LPWORD pBaseAddr;                  // ptr to base address of section
    ULONG rc = 0L;                     // return code
    SECTION_BASIC_INFORMATION SecInfo; // section information - query


    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    //
    //  Open and Map a view of the section if it hasn't been done yet.
    //
    if (pTblPtrs->pDefaultSortkey != NULL)
    {
        return (NO_ERROR);
    }

    RtlInitUnicodeString(&ObSecName, NLS_SECTION_SORTKEY);
    if (rc = OpenSection( &hSec,
                          &ObSecName,
                          (PVOID *)&pBaseAddr,
                          SECTION_MAP_READ | SECTION_QUERY,
                          FALSE ))
    {
        KdPrint(("NLSAPI: Could NOT Open Section %wZ - %lx.\n", &ObSecName, rc));
        return (rc);
    }

    //
    //  Query size of default section.
    //
    rc = NtQuerySection( hSec,
                         SectionBasicInformation,
                         &SecInfo,
                         sizeof(SecInfo),
                         NULL );

    //
    //   Close the section handle.
    //
    NtClose(hSec);

    //
    //  Check for error from NtQuerySection.
    //
    if (!NT_SUCCESS(rc))
    {
        KdPrint(("NLSAPI: Could NOT Query Section %wZ - %lx.\n", &ObSecName, rc));
        return (rc);
    }

    //
    //  Get Default Sortkey Information.
    //
    pTblPtrs->pDefaultSortkey = (PSORTKEY)(pBaseAddr + SORTKEY_HEADER);
    pTblPtrs->DefaultSortkeySize = SecInfo.MaximumSize;

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetDefaultSortTablesFileInfo
//
//  Opens and Maps a view of the section for the sort tables.  It then
//  stores the pointers to the various tables in the global pointer table.
//
//  NOTE: THIS ROUTINE SHOULD ONLY BE CALLED AT PROCESS STARTUP.  If it is
//        called from other than process startup, a critical section must
//        be placed around the assigning of the pointers to pTblPtrs.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG GetDefaultSortTablesFileInfo()
{
    HANDLE hSec = (HANDLE)0;      // section handle
    UNICODE_STRING ObSecName;     // section name
    LPWORD pBaseAddr;             // word ptr to base address of section
    DWORD Num;                    // number of entries in table
    PCOMPRESS_HDR pCompressHdr;   // ptr to compression header
    PEXCEPT_HDR pExceptHdr;       // ptr to exception header
    ULONG rc = 0L;                // return code


    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    //
    //  Open and Map a view of the section if it hasn't been done yet.
    //
    //  Since we're already in the critical section here, there is no
    //  need to check ALL of the pointers set in this routine.  Just
    //  check one of them.
    //
    if (pTblPtrs->pReverseDW != NULL)
    {
        return (NO_ERROR);
    }

    RtlInitUnicodeString(&ObSecName, NLS_SECTION_SORTTBLS);
    if (rc = OpenSection( &hSec,
                          &ObSecName,
                          (PVOID *)&pBaseAddr,
                          SECTION_MAP_READ,
                          TRUE ))
    {
        return (rc);
    }

    //
    //  Get Reverse Diacritic Information.
    //
    Num = *((LPDWORD)pBaseAddr);
    if (Num > 0)
    {
        pTblPtrs->NumReverseDW   = Num;
        pTblPtrs->pReverseDW     = (PREVERSE_DW)(pBaseAddr + REV_DW_HEADER);
    }
    pBaseAddr += REV_DW_HEADER + (Num * (sizeof(REVERSE_DW) / sizeof(WORD)));

    //
    //  Get Double Compression Information.
    //
    Num = *((LPDWORD)pBaseAddr);
    if (Num > 0)
    {
        pTblPtrs->NumDblCompression = Num;
        pTblPtrs->pDblCompression   = (PDBL_COMPRESS)(pBaseAddr + DBL_COMP_HEADER);
    }
    pBaseAddr += DBL_COMP_HEADER + (Num * (sizeof(DBL_COMPRESS) / sizeof(WORD)));

    //
    //  Get Ideograph Lcid Exception Information.
    //
    Num = *((LPDWORD)pBaseAddr);
    if (Num > 0)
    {
        pTblPtrs->NumIdeographLcid = Num;
        pTblPtrs->pIdeographLcid   = (PIDEOGRAPH_LCID)(pBaseAddr + IDEO_LCID_HEADER);
    }
    pBaseAddr += IDEO_LCID_HEADER + (Num * (sizeof(IDEOGRAPH_LCID) / sizeof(WORD)));

    //
    //  Get Expansion Information.
    //
    Num = *((LPDWORD)pBaseAddr);
    if (Num > 0)
    {
        pTblPtrs->NumExpansion   = Num;
        pTblPtrs->pExpansion     = (PEXPAND)(pBaseAddr + EXPAND_HEADER);
    }
    pBaseAddr += EXPAND_HEADER + (Num * (sizeof(EXPAND) / sizeof(WORD)));

    //
    //  Get Compression Information.
    //
    Num = *((LPDWORD)pBaseAddr);
    if (Num > 0)
    {
        pTblPtrs->NumCompression = Num;
        pTblPtrs->pCompressHdr   = (PCOMPRESS_HDR)(pBaseAddr + COMPRESS_HDR_OFFSET);
        pTblPtrs->pCompression   = (PCOMPRESS)(pBaseAddr + COMPRESS_HDR_OFFSET +
                                     (Num * (sizeof(COMPRESS_HDR) /
                                             sizeof(WORD))));
    }
    pCompressHdr = pTblPtrs->pCompressHdr;
    pBaseAddr = (LPWORD)(pTblPtrs->pCompression) +
                        (pCompressHdr[Num - 1]).Offset;

    pBaseAddr += (((pCompressHdr[Num - 1]).Num2) *
                  (sizeof(COMPRESS_2) / sizeof(WORD)));

    pBaseAddr += (((pCompressHdr[Num - 1]).Num3) *
                  (sizeof(COMPRESS_3) / sizeof(WORD)));

    //
    //  Get Exception Information.
    //
    Num = *((LPDWORD)pBaseAddr);
    if (Num > 0)
    {
        pTblPtrs->NumException = Num;
        pTblPtrs->pExceptHdr   = (PEXCEPT_HDR)(pBaseAddr + EXCEPT_HDR_OFFSET);
        pTblPtrs->pException   = (PEXCEPT)(pBaseAddr + EXCEPT_HDR_OFFSET +
                                   (Num * (sizeof(EXCEPT_HDR) /
                                           sizeof(WORD))));
    }
    pExceptHdr = pTblPtrs->pExceptHdr;
    pBaseAddr = (LPWORD)(pTblPtrs->pException) +
                        (pExceptHdr[Num - 1]).Offset;
    pBaseAddr += (((pExceptHdr[Num - 1]).NumEntries) *
                  (sizeof(EXCEPT) / sizeof(WORD)));

    //
    //  Get Multiple Weights Information.
    //
    Num = (DWORD)(*pBaseAddr);
    if (Num > 0)
    {
        pTblPtrs->NumMultiWeight = Num;
        pTblPtrs->pMultiWeight   = (PMULTI_WT)(pBaseAddr + MULTI_WT_HEADER);
    }
    pBaseAddr += MULTI_WT_HEADER + (Num * (sizeof(MULTI_WT) / sizeof(WORD)));

    //
    //  Get Jamo Index Table.
    //
    Num = (DWORD)(*pBaseAddr);
    if (Num > 0)
    {
        //
        //  The Jamo Index table size is (Num) bytes.
        //
        pTblPtrs->NumJamoIndex = Num;
        pTblPtrs->pJamoIndex = (PJAMO_TABLE)(pBaseAddr + JAMO_INDEX_HEADER);
    }
    pBaseAddr += JAMO_INDEX_HEADER + (Num * (sizeof(JAMO_TABLE) / sizeof(WORD)));

    //
    //  Get Jamo Composition State Machine Table.
    //
    Num = (DWORD)(*pBaseAddr);
    if (Num > 0)
    {
        pTblPtrs->NumJamoComposition = Num;
        pTblPtrs->pJamoComposition = (PJAMO_COMPOSE_STATE)(pBaseAddr + JAMO_COMPOSITION_HEADER);
    }
    //
    //  The following line is used to move pBaseAddr to the next field.
    //  Uncomment it if you are adding more fields.
    //
    //  pBaseAddr += JAMO_COMPOSITION_HEADER + (Num * (sizeof(JAMO_COMPOSE_STATE) / sizeof(WORD)));

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetSortkeyFileInfo
//
//  Opens and Maps a view of the section for the sortkey file.  It then
//  fills in the appropriate field of the global table pointers structure.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG GetSortkeyFileInfo(
    LCID Locale,
    PLOC_HASH pHashN)
{
    HANDLE hSec = (HANDLE)0;      // section handle
    UNICODE_STRING ObSecName;     // section name
    LPWORD pBaseAddr;             // ptr to base address of section
    ULONG rc = 0L;                // return code

    PEXCEPT_HDR pExceptHdr;       // ptr to exception header
    PEXCEPT pExceptTbl;           // ptr to exception table
    PVOID pIdeograph;             // ptr to ideograph exception table

    WCHAR wszSecName[MAX_SMALL_BUF_LEN];      // Place for the section name string                                                                          \

    NTSTATUS Status;

    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    //
    //  Make sure the default sortkey table is loaded.  If it's not, then
    //  we shouldn't bother to continue here since the sorting table won't
    //  be created properly.  pHashN->pSortkey will already be NULL, so
    //  we don't need to set it.  Return NO_ERROR here to allow kernel32
    //  to initialize in case this is winlogon.
    //
    if (pTblPtrs->pDefaultSortkey == NULL)
    {
        KdPrint(("NLSAPI: No Default Sorting Table Loaded.\n"));
        return (NO_ERROR);
    }

    //
    //  Try to Open and Map a view of the section (read only).
    //
    GET_SORTKEY_SECTION_NAME(Locale, wszSecName, MAX_SMALL_BUF_LEN, &ObSecName);

    if (rc = OpenSection( &hSec,
                          &ObSecName,
                          (PVOID *)&pBaseAddr,
                          SECTION_MAP_READ,
                          FALSE ))
    {
        //
        //  Open failed.
        //  See if any exceptions exist for given Locale ID.
        //
        rc = NO_ERROR;
        if (!FindExceptionPointers( Locale,
                                    &pExceptHdr,
                                    &pExceptTbl,
                                    &pIdeograph,
                                    &rc ))
        {
            //
            //  No exceptions for locale, so attach the default sortkey
            //  table pointer to the hash node and return success.
            //
            pHashN->pSortkey = pTblPtrs->pDefaultSortkey;
            return (NO_ERROR);
        }
        else
        {
            //
            //  See if an error occurred.
            //
            if (rc != NO_ERROR)
            {
                //
                //  This occurs if the ideograph exception file could not be
                //  created or mapped.  Return an error in this case.
                //
                //  return (rc);
                //
                //  On second thought, don't return an error.  Returning an
                //  error can cause kernel32 to not initialize (which, if this
                //  is winlogon, leads to an unbootable system).  Let's just
                //  patch things up and move on.
                //
                //  LATER -- log an error in the logfile.
                //
                pHashN->IfIdeographFailure = TRUE;
                pHashN->pSortkey = pTblPtrs->pDefaultSortkey;
                return (NO_ERROR);
            }

            //
            //  Exceptions from default sortkey table exist for the given
            //  locale.  Need to get the correct sortkey table.
            //  Create a section and call the server to lock it in.
            //
            Status = CsrBasepNlsCreateSection( NLS_CREATE_SORT_SECTION,
                                               Locale,
                                               &hSec );

            //
            //  Check return from server call.
            //
            rc = (ULONG)Status;

            if (!NT_SUCCESS(rc))
            {
                if (hSec != NULL)
                {
                    NtClose(hSec);
                }
                return (rc);
            }

            //
            //  Map the section for ReadWrite.
            //
            if (rc = MapSection( hSec,
                                 (PVOID *)&pBaseAddr,
                                 PAGE_READWRITE,
                                 FALSE ))
            {
                NtClose(hSec);
                return (rc);
            }

            //
            //  Copy the Default Sortkey Table to the New Section.
            //
            RtlMoveMemory( (PVOID)pBaseAddr,
                           (PVOID)((LPWORD)(pTblPtrs->pDefaultSortkey) -
                                   SORTKEY_HEADER),
                           (ULONG)(pTblPtrs->DefaultSortkeySize.LowPart) );

            //
            //  Copy exception information to the table.
            //
            CopyExceptionInfo( (PSORTKEY)(pBaseAddr + SORTKEY_HEADER),
                               pExceptHdr,
                               pExceptTbl,
                               pIdeograph);

            //
            //  Write a 1 to the WORD semaphore (table may now be read).
            //
            *pBaseAddr = 1;

            //
            //  Unmap the section for Write and remap it for Read.
            //
            if ((rc = UnMapSection(pBaseAddr)) ||
                (rc = MapSection( hSec,
                                  (PVOID *)&pBaseAddr,
                                  PAGE_READONLY,
                                  FALSE )))
            {
                NtClose(hSec);
                return (rc);
            }
        }
    }

    //
    //  Close the section handle.
    //
    NtClose(hSec);

    //
    //  Check semaphore bit in file.  Make sure that the open
    //  succeeded AFTER all exceptions were added to the memory
    //  mapped section.
    //
    if (*pBaseAddr == 0)
    {
        //
        //  Another process is still adding the appropriate exception
        //  information.  Must wait for its completion.
        //
        if (rc = WaitOnEvent(pBaseAddr))
        {
            UnMapSection(pBaseAddr);
            return (rc);
        }
    }

    //
    //  Save pointer in hash node.
    //
    pHashN->pSortkey = (PSORTKEY)(pBaseAddr + SORTKEY_HEADER);

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetSortTablesFileInfo
//
//  Stores the appropriate sort table pointers for the given locale in
//  the given locale hash node.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

void GetSortTablesFileInfo(
    LCID Locale,
    PLOC_HASH pHashN)
{
    DWORD ctr;                    // loop counter
    PREVERSE_DW pRevDW;           // ptr to reverse diacritic table
    PDBL_COMPRESS pDblComp;       // ptr to double compression table
    PCOMPRESS_HDR pCompHdr;       // ptr to compression header


    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    //
    //  Check for Reverse Diacritic Locale.
    //
    pRevDW = pTblPtrs->pReverseDW;
    for (ctr = pTblPtrs->NumReverseDW; ctr > 0; ctr--, pRevDW++)
    {
        if (*pRevDW == (DWORD)Locale)
        {
            pHashN->IfReverseDW = TRUE;
            break;
        }
    }

    //
    //  Check for Compression.
    //
    pCompHdr = pTblPtrs->pCompressHdr;
    for (ctr = pTblPtrs->NumCompression; ctr > 0; ctr--, pCompHdr++)
    {
        if (pCompHdr->Locale == (DWORD)Locale)
        {
            pHashN->IfCompression = TRUE;
            pHashN->pCompHdr = pCompHdr;
            if (pCompHdr->Num2 > 0)
            {
                pHashN->pCompress2 = (PCOMPRESS_2)
                                       (((LPWORD)(pTblPtrs->pCompression)) +
                                        (pCompHdr->Offset));
            }
            if (pCompHdr->Num3 > 0)
            {
                pHashN->pCompress3 = (PCOMPRESS_3)
                                       (((LPWORD)(pTblPtrs->pCompression)) +
                                        (pCompHdr->Offset) +
                                        (pCompHdr->Num2 *
                                          (sizeof(COMPRESS_2) / sizeof(WORD))));
            }
            break;
        }
    }

    //
    //  Check for Double Compression.
    //
    if (pHashN->IfCompression)
    {
        pDblComp = pTblPtrs->pDblCompression;
        for (ctr = pTblPtrs->NumDblCompression; ctr > 0; ctr--, pDblComp++)
        {
            if (*pDblComp == (DWORD)Locale)
            {
                pHashN->IfDblCompression = TRUE;
                break;
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  LoadCodePageAsDLL
//
//  Try to load a code page as a DLL. If succeeded, the CodePage procedure
//  is set.
//
//  05-27-99    SamerA    Created.
////////////////////////////////////////////////////////////////////////////

ULONG LoadCodePageAsDLL(
    UINT CodePage,
    LPFN_CP_PROC *ppfnCPProc)
{
    WCHAR pDllName[MAX_PATH_LEN];         // ptr to DLL name
    HANDLE hModCPDll;                      // module handle of code page DLL
    ULONG rc = ERROR_INVALID_PARAMETER;   // return code
    UINT ErrorMode;                         // error mode


    //
    //  Get the DLL name to load.
    //
    pDllName[0] = 0;
    *ppfnCPProc = NULL;
    
    if (NO_ERROR == GetCodePageDLLPathName(CodePage, pDllName, MAX_PATH_LEN) && 
        NlsIsDll(pDllName))
    {
        //
        //  Load the DLL and get the procedure address.
        //  Turn off hard error popups.
        //
        ErrorMode = SetErrorMode(SEM_NOERROR);
        SetErrorMode(SEM_NOERROR | ErrorMode);

        hModCPDll = LoadLibrary(pDllName);

        SetErrorMode(ErrorMode);

        if (hModCPDll)
        {
            *ppfnCPProc =
                (LPFN_CP_PROC)GetProcAddress( hModCPDll,
                                              NLS_CP_DLL_PROC_NAME );
        }

        if (*ppfnCPProc == NULL)
        {
            if (hModCPDll)
            {
                rc = TYPE_E_DLLFUNCTIONNOTFOUND;
                FreeLibrary(hModCPDll);
            }
            else
            {
                rc = TYPE_E_CANTLOADLIBRARY;
            }
        }
        else
        {
            rc = NO_ERROR;
        }
    }

    return (rc);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetCodePageFileInfo
//
//  Opens and Maps a view of the section for the given code page.  It then
//  creates and inserts a hash node into the global CP hash table.
//
//  If the section cannot be opened, it then queries the registry to see if
//  the information has been added since the initialization of the DLL.  If
//  so, then it creates the section and then opens and maps a view of it.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG GetCodePageFileInfo(
    UINT CodePage,
    PCP_HASH *ppNode)
{
    HANDLE hSec = (HANDLE)0;      // section handle
    UNICODE_STRING ObSecName;     // section name
    LPWORD pBaseAddr = NULL;      // ptr to base address of section
    ULONG rc = 0L;                // return code
    BOOL IsDLL;                   // true if dll instead of data file
    LPFN_CP_PROC pfnCPProc;       // Code Page DLL Procedure
    WCHAR wszSecName[MAX_SMALL_BUF_LEN];      // Place for the section name string                                                                          \

    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    //
    //  See if we're dealing with a DLL or an NLS data file.
    //
    IsDLL = ((CodePage >= NLS_CP_DLL_RANGE) &&
             (CodePage <  NLS_CP_ALGORITHM_RANGE));

    if (IsDLL)
    {
        //
        // Try loading the codepage DLL
        //
        ULONG _rc = LoadCodePageAsDLL(CodePage, &pfnCPProc);

        if (_rc)
        {
        
            if (ERROR_INVALID_PARAMETER == _rc)
            {
                //
                // Not a valid DLL, try loading it as a normal data file
                //
                IsDLL = FALSE;
            }
            else
            {
                //
                // Failed to load the DLL or can't find the function entry
                // Return the error code
                //
                return (rc);
            }
        }
    }

    if (!IsDLL)
    {
        //
        //  Open and Map a view of the section.
        //
        GET_CP_SECTION_NAME(CodePage, wszSecName, MAX_SMALL_BUF_LEN, &ObSecName);

        rc = OpenSection( &hSec,
                          &ObSecName,
                          (PVOID *)&pBaseAddr,
                          SECTION_MAP_READ,
                          TRUE );
        
        if (!NT_SUCCESS(rc))
        {
            //
            //  Open failed, so try to create the section.
            //  If the creation is successful, the section will be mapped
            //  to the current process.
            //

            rc = CsrBasepNlsCreateSection(NLS_CREATE_CODEPAGE_SECTION, CodePage,
                                               &hSec );

            if (NT_SUCCESS(rc))
            {
                rc = MapSection( hSec,
                         &pBaseAddr,
                         PAGE_READONLY,
                         TRUE );                // Close handle, even if fail
            }

            if (!NT_SUCCESS(rc))
            {
                //
                //  Allow the default ACP and default OEMCP to work if
                //  it's only the registry that is corrupt.  If there is
                //  still an error, return the error code that was returned
                //  from the OpenSection call.
                //
                if (CodePage == NLS_DEFAULT_ACP)
                {
                    //
                    //  Create the default ACP section.
                    //
                    if (!NT_SUCCESS(CsrBasepNlsCreateSection(NLS_CREATE_SECTION_DEFAULT_ACP, 0,
                                               &hSec )))
                    {
                        return (rc);
                    }
                    else
                    {
                        //
                        //  Map the section.
                        //
                        if (!NT_SUCCESS(MapSection( hSec,
                                                    (PVOID *)&pBaseAddr,
                                                    PAGE_READONLY,
                                                    TRUE )))
                        {
                            return (rc);
                        }
                        KdPrint(("NLSAPI: Registry is corrupt - Default ACP.\n"));
                    }
                }
                else if (CodePage == NLS_DEFAULT_OEMCP)
                {
                    //
                    //  Create the default OEMCP section.
                    //
                    if (!NT_SUCCESS(CsrBasepNlsCreateSection( NLS_CREATE_SECTION_DEFAULT_OEMCP, 0,
                                               &hSec )))
                    {
                        return (rc);
                    }
                    else
                    {
                        //
                        //  Map the section.
                        //
                        if (!NT_SUCCESS(MapSection( hSec,
                                                    (PVOID *)&pBaseAddr,
                                                    PAGE_READONLY,
                                                    TRUE )))
                        {
                            return (rc);
                        }
                        KdPrint(("NLSAPI: Registry is corrupt - Default OEMCP.\n"));
                    }
                }
                else
                {
                    //
                    //  Return the error code that was returned from the
                    //  OpenSection call.
                    //
                    return (rc);
                }
            }
        }
    }

    //
    //  Make the hash node and return the result.
    //
    return (MakeCPHashNode( CodePage,
                            pBaseAddr,
                            ppNode,
                            IsDLL,
                            pfnCPProc ));
}


////////////////////////////////////////////////////////////////////////////
//
//  GetLanguageFileInfo
//
//  Opens and Maps a view of the section for the casing tables and sorting
//  tables for the given locale.
//
//  If the section cannot be opened, it then queries the registry to see if
//  the information has been added since the initialization of the DLL.  If
//  so, then it creates the section and then opens and maps a view of it.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG GetLanguageFileInfo(
    LCID Locale,
    PLOC_HASH *ppNode,
    BOOLEAN fCreateNode,
    DWORD dwFlags)
{
    LPWORD pBaseAddr = NULL;      // ptr to base address of section
    MEMORY_BASIC_INFORMATION MemoryBasicInfo;


    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    //
    //  See if the default language table has been stored yet.
    //
    if (pTblPtrs->pDefaultLanguage == NULL)
    {
        //
        //  Save the default language table and its size in the
        //  table pointers structure.
        //
        pTblPtrs->pDefaultLanguage = NtCurrentPeb()->UnicodeCaseTableData;

        NtQueryVirtualMemory( NtCurrentProcess(),
                              pTblPtrs->pDefaultLanguage,
                              MemoryBasicInformation,
                              &MemoryBasicInfo,
                              sizeof(MEMORY_BASIC_INFORMATION),
                              NULL );
        pTblPtrs->LinguistLangSize.QuadPart = MemoryBasicInfo.RegionSize;
        ASSERT(MemoryBasicInfo.RegionSize > 0);
    }

    //
    //  See if we should load the culturally correct language table.
    //
    if (dwFlags)
    {
        if (pTblPtrs->pLangException == NULL)
        {
            GetLanguageExceptionInfo();
        }

        //
        //  Get the default linguistic language table for the given locale.
        //
        pBaseAddr = GetLinguisticLanguageInfo(Locale);
    }

    //
    //  Get the casing table and sorting table pointers.
    //
    return (MakeLangHashNode( Locale,
                              pBaseAddr,
                              ppNode,
                              fCreateNode ));
}


////////////////////////////////////////////////////////////////////////////
//
//  GetLocaleFileInfo
//
//  Opens and Maps a view of the section for the given locale.  It then
//  creates and inserts a hash node into the global LOCALE hash table.
//
//  If the section cannot be opened, it then queries the registry to see if
//  the information has been added since the initialization of the DLL.  If
//  so, then it creates the section and then opens and maps a view of it.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG GetLocaleFileInfo(
    LCID Locale,
    PLOC_HASH *ppNode,
    BOOLEAN fCreateNode)
{
    HANDLE hSec = (HANDLE)0;      // section handle
    UNICODE_STRING ObSecName;     // section name
    LPWORD pBaseAddr;             // ptr to base address of section
    ULONG rc = 0L;                // return code


    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    //
    //  Open and Map a view of the section if it hasn't been done yet.
    //
    if ((pBaseAddr = pTblPtrs->pLocaleInfo) == NULL)
    {
        //
        //  Get the locale file section pointer.
        //
        RtlInitUnicodeString(&ObSecName, NLS_SECTION_LOCALE);
        if (rc = OpenSection( &hSec,
                              &ObSecName,
                              (PVOID *)&pBaseAddr,
                              SECTION_MAP_READ,
                              TRUE ))
        {
            return (rc);
        }

        //
        //  Store pointer to locale file and calendar info in table
        //  structure.
        //
        pTblPtrs->pLocaleInfo = pBaseAddr;

        pTblPtrs->NumCalendars = ((PLOC_CAL_HDR)pBaseAddr)->NumCalendars;
        pTblPtrs->pCalendarInfo = pBaseAddr +
                                  ((PLOC_CAL_HDR)pBaseAddr)->CalOffset;
    }

    //
    //  Make the hash node and return the result.
    //
    return (MakeLocHashNode( Locale,
                             pBaseAddr,
                             ppNode,
                             fCreateNode ));
}


////////////////////////////////////////////////////////////////////////////
//
//  MakeCPHashNode
//
//  Creates the hash node for the code page and assigns the fields of the
//  hash node to point at the appropriate places in the file.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG MakeCPHashNode(
    UINT CodePage,
    LPWORD pBaseAddr,
    PCP_HASH *ppNode,
    BOOL IsDLL,
    LPFN_CP_PROC pfnCPProc)
{
    PCP_HASH pHashN;                   // ptr to CP hash node
    WORD offMB;                        // offset to MB table
    WORD offWC;                        // offset to WC table
    PGLYPH_TABLE pGlyph;               // ptr to glyph table info
    PDBCS_RANGE pRange;                // ptr to DBCS range


    //
    //  Allocate CP_HASH structure and fill in the CodePage value.
    //
    CREATE_CODEPAGE_HASH_NODE(CodePage, pHashN);

    //
    //  See if we're dealing with a DLL or an NLS data file.
    //
    if (IsDLL)
    {
        if (pfnCPProc == NULL)
        {
            NLS_FREE_MEM(pHashN);
            return (ERROR_INVALID_PARAMETER);
        }

        pHashN->pfnCPProc = pfnCPProc;
    }
    else
    {
        //
        //  Get the offsets.
        //
        offMB = pBaseAddr[0];
        offWC = offMB + pBaseAddr[offMB];

        //
        //  Attach CP Info to CP hash node.
        //
        pHashN->pCPInfo = (PCP_TABLE)(pBaseAddr + CP_HEADER);

        //
        //  Attach MB table to CP hash node.
        //
        pHashN->pMBTbl = pBaseAddr + offMB + MB_HEADER;

        //
        //  Attach Glyph table to CP hash node (if it exists).
        //  Also, set the pointer to the DBCS ranges based on whether or
        //  not the GLYPH table is present.
        //
        pGlyph = pHashN->pMBTbl + MB_TBL_SIZE;
        if (pGlyph[0] != 0)
        {
            pHashN->pGlyphTbl = pGlyph + GLYPH_HEADER;
            pRange = pHashN->pDBCSRanges = pHashN->pGlyphTbl + GLYPH_TBL_SIZE;
        }
        else
        {
            pRange = pHashN->pDBCSRanges = pGlyph + GLYPH_HEADER;
        }

        //
        //  Attach DBCS information to CP hash node.
        //
        if (pRange[0] > 0)
        {
            //
            //  Set the pointer to the offsets section.
            //
            pHashN->pDBCSOffsets = pRange + DBCS_HEADER;
        }

        //
        //  Attach WC table to CP hash node.
        //
        pHashN->pWC = pBaseAddr + offWC + WC_HEADER;
    }

    //
    //  Insert hash node into hash table.
    //
    INSERT_CP_HASH_NODE(pHashN, pBaseAddr);

    //
    //  Save the pointer to the hash node.
    //
    if (ppNode != NULL)
    {
        *ppNode = pHashN;
    }

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  MakeLangHashNode
//
//  Gets the pointers to the casing tables and the sorting tables and
//  stores them in the locale hash node given.
//
//  If fCreateNode is FALSE, then *ppNode should contain a valid pointer
//  to a LOC hash node.  Also, the table critical section must be entered
//  before calling this routine.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG MakeLangHashNode(
    LCID Locale,
    LPWORD pBaseAddr,
    PLOC_HASH *ppNode,
    BOOLEAN fCreateNode)
{
    LPWORD pBaseDefault;          // ptr to default language section
    PLOC_HASH pHashN;             // ptr to LOC hash node
    ULONG rc = 0L;                // return code


    //
    //  If fCreateNode is TRUE, then allocate LOC_HASH structure.
    //
    if (fCreateNode)
    {
        CREATE_LOCALE_HASH_NODE(Locale, pHashN);
    }
    else
    {
        pHashN = *ppNode;
    }

    //
    //  See if the sorting tables still need to be attached.
    //
    if (pHashN->pSortkey == NULL)
    {
        //
        //  Get the sortkey table and attach it to the hash node.
        //
        if (rc = GetSortkeyFileInfo(Locale, pHashN))
        {
            if (fCreateNode)
            {
                NLS_FREE_MEM(pHashN);
            }
            return (rc);
        }

        //
        //  Get the appropriate sorting tables for the locale.
        //
        GetSortTablesFileInfo(Locale, pHashN);
    }

    //
    //  See if the default casing tables still need to be attached.
    //
    if (!EXIST_LANGUAGE_INFO(pHashN))
    {
        //
        //  Get the pointer to the base of the default table.
        //
        pBaseDefault = pTblPtrs->pDefaultLanguage;

        //
        //  Attach the UPPERCASE table to the hash node.
        //
        pHashN->pUpperCase = pBaseDefault + LANG_HEADER + UP_HEADER;

        //
        //  Attach the LOWERCASE table to the hash node.
        //
        //  This value must be set LAST, since this is the pointer that
        //  is checked to see that the language information has been
        //  initialized.
        //
        pHashN->pLowerCase = pBaseDefault + LANG_HEADER +
                             pBaseDefault[LANG_HEADER] + LO_HEADER;
    }

    //
    //  See if there is a linguistic table to attach.
    //
    if (pBaseAddr)
    {
        //
        //  Attach the UPPERCASE Linguistic table to the hash node.
        //
        pHashN->pUpperLinguist = pBaseAddr + LANG_HEADER + UP_HEADER;

        //
        //  Attach the LOWERCASE Linguistic table to the hash node.
        //
        //  This value must be set LAST, since this is the pointer that
        //  is checked to see that the language information has been
        //  initialized.
        //
        pHashN->pLowerLinguist = pBaseAddr + LANG_HEADER +
                                 pBaseAddr[LANG_HEADER] + LO_HEADER;
    }

    //
    //  If fCreateNode is TRUE, then insert hash node and save pointer.
    //
    if (fCreateNode)
    {
        //
        //  Insert LOC hash node into hash table.
        //
        INSERT_LOC_HASH_NODE(pHashN, pBaseAddr);

        //
        //  Save the pointer to the hash node.
        //
        if (ppNode != NULL)
        {
            *ppNode = pHashN;
        }
    }

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  MakeLocHashNode
//
//  Gets the pointers to the locale tables and stores them in the locale
//  hash node given.
//
//  NOTE:  If a critical section is needed to touch pHashN, then the
//         critical section must be entered before calling this routine.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG MakeLocHashNode(
    LCID Locale,
    LPWORD pBaseAddr,
    PLOC_HASH *ppNode,
    BOOLEAN fCreateNode)
{
    LANGID Language;              // language id
    PLOC_HASH pHashN;             // ptr to LOC hash node
    DWORD Num;                    // total number of locales
    PLOCALE_HDR pFileHdr;         // ptr to locale header entry
    ULONG rc = 0L;                // return code


    //
    //  Save the language id.
    //
    Language = LANGIDFROMLCID(Locale);

    //
    //  Search for the right locale id information.
    //
    Num = ((PLOC_CAL_HDR)pBaseAddr)->NumLocales;
    pFileHdr = (PLOCALE_HDR)(pBaseAddr + LOCALE_HDR_OFFSET);
    for (; (Num != 0) && (pFileHdr->Locale != Language); Num--, pFileHdr++)
        ;

    //
    //  See if the locale was found in the file.
    //
    if (Num != 0)
    {
        //
        //  Locale id was found, so increment the pointer to point at
        //  the beginning of the locale information.
        //
        pBaseAddr += pFileHdr->Offset;
    }
    else
    {
        //
        //  Return an error.  The given locale is not supported.
        //
        return (ERROR_INVALID_PARAMETER);
    }

    //
    //  If fCreateNode is TRUE, then allocate LOC_HASH structure.
    //
    if (fCreateNode)
    {
        CREATE_LOCALE_HASH_NODE(Locale, pHashN);
    }
    else
    {
        pHashN = *ppNode;
    }

    //
    //  Attach Information to structure.
    //
    //  The pLocaleFixed value must be set LAST, since this is the pointer
    //  that is checked to see that the locale information has been
    //  initialized.
    //
    pHashN->pLocaleHdr   = (PLOCALE_VAR)pBaseAddr;
    pHashN->pLocaleFixed = (PLOCALE_FIXED)(pBaseAddr +
                                           (sizeof(LOCALE_VAR) / sizeof(WORD)));

    //
    //  If fCreateNode is TRUE, then insert hash node and save pointer.
    //
    if (fCreateNode)
    {
        //
        //  Insert LOC hash node into hash table.
        //
        INSERT_LOC_HASH_NODE(pHashN, pBaseAddr);

        //
        //  Save the pointer to the hash node.
        //
        if (ppNode != NULL)
        {
            *ppNode = pHashN;
        }
    }

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetCPHashNode
//
//  Returns a pointer to the appropriate CP hash node given the codepage.
//  If no table could be found for the given codepage, NULL is returned.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

PCP_HASH FASTCALL GetCPHashNode(
    UINT CodePage)
{
    PCP_HASH pHashN;              // ptr to CP hash node


    //
    //  Get hash node.
    //
    FIND_CP_HASH_NODE(CodePage, pHashN);

    //
    //  If the hash node does not exist, try to get the tables
    //  from the appropriate data file.
    //
    //  NOTE:  No need to check error code from GetCodePageFileInfo,
    //         because pHashN is not touched if there was an
    //         error.  Thus, pHashN will still be NULL, and an
    //         "error" will be returned from this routine.
    //
    if (pHashN == NULL)
    {
        //
        //  Hash node does NOT exist.
        //
        RtlEnterCriticalSection(&gcsTblPtrs);
        FIND_CP_HASH_NODE(CodePage, pHashN);
        if (pHashN == NULL)
        {
            GetCodePageFileInfo(CodePage, &pHashN);
        }
        RtlLeaveCriticalSection(&gcsTblPtrs);
    }

    //
    //  Return pointer to hash node.
    //
    return (pHashN);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetLangHashNode
//
//  Returns a pointer to the appropriate LOC hash node given the locale.
//  If no table could be found for the given locale, NULL is returned.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

PLOC_HASH FASTCALL GetLangHashNode(
    LCID Locale,
    DWORD dwFlags)
{
    PLOC_HASH pHashN;             // ptr to LOC hash node


    //
    //  Get hash node.
    //
    FIND_LOCALE_HASH_NODE(Locale, pHashN);

    //
    //  If the hash node does not exist, try to get the tables
    //  from the appropriate data file.
    //
    //  NOTE:  No need to check error code from GetLanguageFileInfo,
    //         because pHashN is not touched if there was an
    //         error.  Thus, pHashN will still be NULL, and an
    //         "error" will be returned from this routine.
    //
    if (pHashN == NULL)
    {
        //
        //  If a sort id exists, make sure it's valid.
        //
        if (SORTIDFROMLCID(Locale))
        {
            if (!IsValidSortId(Locale))
            {
                return (NULL);
            }
        }

        //
        //  Hash node does NOT exist.
        //
        RtlEnterCriticalSection(&gcsTblPtrs);
        FIND_LOCALE_HASH_NODE(Locale, pHashN);
        if (pHashN == NULL)
        {
            //
            //  Hash node still does NOT exist.
            //
            GetLanguageFileInfo(Locale, &pHashN, TRUE, dwFlags);
            RtlLeaveCriticalSection(&gcsTblPtrs);
            return (pHashN);
        }
        RtlLeaveCriticalSection(&gcsTblPtrs);
    }

    //
    //  Hash node DOES exist.
    //
    if (!EXIST_LANGUAGE_INFO(pHashN) ||
        ((dwFlags != 0) && !EXIST_LINGUIST_LANGUAGE_INFO(pHashN)))
    {
        //
        //  Casing tables and sorting tables not yet stored in
        //  hash node.
        //
        RtlEnterCriticalSection(&gcsTblPtrs);
        if (!EXIST_LANGUAGE_INFO(pHashN) ||
            ((dwFlags != 0) && !EXIST_LINGUIST_LANGUAGE_INFO(pHashN)))
        {
            if (GetLanguageFileInfo(Locale, &pHashN, FALSE, dwFlags))
            {
                RtlLeaveCriticalSection(&gcsTblPtrs);
                return (NULL);
            }
        }
        RtlLeaveCriticalSection(&gcsTblPtrs);
    }

    //
    //  Return pointer to hash node.
    //
    return (pHashN);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetLocHashNode
//
//  Returns a pointer to the appropriate LOC hash node given the locale.
//  If no table could be found for the given locale, NULL is returned.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

PLOC_HASH FASTCALL GetLocHashNode(
    LCID Locale)
{
    PLOC_HASH pHashN;             // ptr to LOC hash node


    //
    //  Get hash node.
    //
    FIND_LOCALE_HASH_NODE(Locale, pHashN);

    //
    //  If the hash node does not exist, try to get the table
    //  from locale.nls.
    //
    //  NOTE:  No need to check error code from GetLocaleFileInfo,
    //         because pHashN is not touched if there was an
    //         error.  Thus, pHashN will still be NULL, and an
    //         "error" will be returned from this routine.
    //
    if (pHashN == NULL)
    {
        //
        //  If a sort id exists, make sure it's valid.
        //
        if (SORTIDFROMLCID(Locale))
        {
            if (!IsValidSortId(Locale))
            {
                return (NULL);
            }
        }

        //
        //  Hash node does NOT exist.
        //
        RtlEnterCriticalSection(&gcsTblPtrs);
        FIND_LOCALE_HASH_NODE(Locale, pHashN);
        if (pHashN == NULL)
        {
            //
            //  Hash node still does NOT exist.
            //
            GetLocaleFileInfo(Locale, &pHashN, TRUE);
            RtlLeaveCriticalSection(&gcsTblPtrs);
            return (pHashN);
        }
        RtlLeaveCriticalSection(&gcsTblPtrs);
    }

    //
    //  Hash node DOES exist.
    //
    if (!EXIST_LOCALE_INFO(pHashN))
    {
        //
        //  Locale tables not yet stored in hash node.
        //
        RtlEnterCriticalSection(&gcsTblPtrs);
        if (!EXIST_LOCALE_INFO(pHashN))
        {
            if (GetLocaleFileInfo(Locale, &pHashN, FALSE))
            {
                RtlLeaveCriticalSection(&gcsTblPtrs);
                return (NULL);
            }
        }
        RtlLeaveCriticalSection(&gcsTblPtrs);
    }

    //
    //  Return pointer to hash node.
    //
    return (pHashN);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetCalendar
//
//  Gets the pointer to the specific calendar table.  It stores it in the
//  calendar information array in the global table pointers structure if it
//  was not done yet.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG GetCalendar(
    CALID Calendar,
    PCAL_INFO *ppCalInfo)
{
    PCALENDAR_HDR pCalHdr;        // ptr to beginning of calendar header
    DWORD Num;                    // total number of calendars


    //
    //  Get number of calendars.
    //
    Num = pTblPtrs->NumCalendars;

    //
    //  Make sure calendar id is within the appropriate range.
    //
    if (Calendar > Num)
    {
        return (ERROR_INVALID_PARAMETER);
    }

    //
    //  Check to see if calendar info has already been found.
    //
    if ((*ppCalInfo = (pTblPtrs->pCalTbl)[Calendar]) != NULL)
    {
        //
        //  Return success.  Calendar info was found.
        //
        return (NO_ERROR);
    }

    RtlEnterCriticalSection(&gcsTblPtrs);

    if ((*ppCalInfo = (pTblPtrs->pCalTbl)[Calendar]) != NULL)
    {
        //
        //  Return success.  Calendar info was found.
        //
        RtlLeaveCriticalSection(&gcsTblPtrs);
        return (NO_ERROR);
    }

    //
    //  Search for the appropriate calendar id information.
    //
    pCalHdr = (PCALENDAR_HDR)(pTblPtrs->pCalendarInfo);
    while ((Num != 0) && (pCalHdr->Calendar != Calendar))
    {
        Num--;
        pCalHdr++;
    }

    //
    //  See if the calendar was found in the file.
    //
    if (Num != 0)
    {
        //
        //  Calendar id was found.
        //
        //  Store the pointer to the beginning of the calendar info
        //  in the calendar table array.
        //
        *ppCalInfo = (PCAL_INFO)((LPWORD)(pTblPtrs->pCalendarInfo) +
                                 pCalHdr->Offset);
        (pTblPtrs->pCalTbl)[Calendar] = *ppCalInfo;

        //
        //  Return success.  Calendar info was found.
        //
        RtlLeaveCriticalSection(&gcsTblPtrs);
        return (NO_ERROR);
    }

    RtlLeaveCriticalSection(&gcsTblPtrs);

    //
    //  Calendar id was not found in the locale.nls file.
    //  Return an error.  The given calendar is not supported.
    //
    return (ERROR_INVALID_PARAMETER);
}





//-------------------------------------------------------------------------//
//                           INTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  IsValidSortId
//
//  Checks to see if the given locale has a valid sort id.
//
//  11-15-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL IsValidSortId(
    LCID Locale)
{
    WCHAR pTmpBuf[MAX_PATH];                     // temp buffer
    PKEY_VALUE_FULL_INFORMATION pKeyValueFull;   // ptr to query info
    BYTE pStatic[MAX_KEY_VALUE_FULLINFO];        // ptr to static buffer
    BOOL IfAlloc = FALSE;                        // if buffer was allocated
    ULONG rc = 0L;                               // return code


    //
    //  Make sure there is a sort id.
    //
    if (!SORTIDFROMLCID(Locale))
    {
        return (TRUE);
    }

    //
    //  Open the Alternate Sorts registry key.
    //
    OPEN_ALT_SORTS_KEY(FALSE);


    //
    //  Convert locale value to Unicode string.
    //
    if (NlsConvertIntegerToString(Locale, 16, 8, pTmpBuf, MAX_PATH))
    {
        return (FALSE);
    }

    //
    //  Query the registry for the value.
    //
    pKeyValueFull = (PKEY_VALUE_FULL_INFORMATION)pStatic;
    if (rc = QueryRegValue( hAltSortsKey,
                            pTmpBuf,
                            &pKeyValueFull,
                            MAX_KEY_VALUE_FULLINFO,
                            &IfAlloc ))
    {
        return (FALSE);
    }

    //
    //  Free the buffer used for the query.
    //
    if (IfAlloc)
    {
        NLS_FREE_MEM(pKeyValueFull);
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetLanguageExceptionInfo
//
//  Opens and Maps a view of the section for the language exception file.
//  It then fills in the appropriate fields of the global table pointers
//  structure.
//
//  08-30-95    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG GetLanguageExceptionInfo()
{
    HANDLE hSec = (HANDLE)0;           // section handle
    LPWORD pBaseAddr;                  // ptr to base address of section
    DWORD Num;                         // number of entries in table
    ULONG rc = 0L;                     // return code


    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    //
    //  Make sure the table isn't already there.
    //
    if (pTblPtrs->pLangException != NULL)
    {
        return (NO_ERROR);
    }

    //
    //  Create and map the section, and then save the pointer.
    //
    if ((rc = CsrBasepNlsCreateSection( NLS_CREATE_SECTION_LANG_EXCEPT, 0,
                                               &hSec )) == NO_ERROR)
    {
        //
        //  Map a View of the Section.
        //
        if ((rc = MapSection( hSec,
                              &pBaseAddr,
                              PAGE_READONLY,
                              TRUE )) != NO_ERROR)
        {
            return (rc);
        }
    }
    else
    {
        return (rc);
    }

    //
    //  Save the pointers to the exception information.
    //
    Num = *((LPDWORD)pBaseAddr);
    if (Num > 0)
    {
        pTblPtrs->NumLangException = Num;
        pTblPtrs->pLangExceptHdr   = (PL_EXCEPT_HDR)(pBaseAddr +
                                                     L_EXCEPT_HDR_OFFSET);
        pTblPtrs->pLangException   = (PL_EXCEPT)(pBaseAddr +
                                                 L_EXCEPT_HDR_OFFSET +
                                                 (Num * (sizeof(L_EXCEPT_HDR) /
                                                         sizeof(WORD))));
    }

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetLinguisticLanguageInfo
//
//  Opens and Maps a view of the section for the default linguistic language
//  table.  It then stores the pointer to the table in the global pointer
//  table.
//
//  08-30-95    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

LPWORD GetLinguisticLanguageInfo(
    LCID Locale)
{
    HANDLE hSec = (HANDLE)0;           // section handle
    UNICODE_STRING ObSecName;          // section name
    LPWORD pBaseAddr;                  // ptr to base address of section
    ULONG rc = 0L;                     // return code
    SECTION_BASIC_INFORMATION SecInfo; // section information - query


    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    //
    //  Create/Open and Map a view of the section if it hasn't been done yet.
    //
    if (pTblPtrs->pLinguistLanguage == NULL)
    {
        //
        //  See if we can simply open the section.
        //
        RtlInitUnicodeString(&ObSecName, NLS_SECTION_LANG_INTL);
        if (rc = OpenSection( &hSec,
                              &ObSecName,
                              (PVOID *)&pBaseAddr,
                              SECTION_MAP_READ,
                              TRUE ))
        {
            //
            //  Need to create the default linguistic language section.
            //
            if (CreateAndCopyLanguageExceptions(0L, &pBaseAddr))
            {
                return (NULL);
            }
        }

        //
        //  Get Default Linguistic Language Information.
        //
        pTblPtrs->pLinguistLanguage = (P844_TABLE)(pBaseAddr);
    }

    //
    //  Now see if there are any exceptions for the given locale.
    //
    if (CreateAndCopyLanguageExceptions(Locale, &pBaseAddr))
    {
        return (pTblPtrs->pLinguistLanguage);
    }

    //
    //  Return success.
    //
    return (pBaseAddr);
}


////////////////////////////////////////////////////////////////////////////
//
//  CreateAndCopyLanguageExceptions
//
//  Creates the section for the new language table (if necessary) and then
//  copies the exceptions to the table.
//
//  08-30-95    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG CreateAndCopyLanguageExceptions(
    LCID Locale,
    LPWORD *ppBaseAddr)

{
    HANDLE hSec = (HANDLE)0;      // section handle
    UNICODE_STRING ObSecName;     // section name
    LPWORD pBaseAddr;             // ptr to base address of section
    P844_TABLE pLangDefault;      // ptr to default table to copy from
    ULONG rc = 0L;                // return code

    PL_EXCEPT_HDR pExceptHdr;     // ptr to exception header
    PL_EXCEPT pExceptTbl;         // ptr to exception table

    WCHAR wszSecName[MAX_SMALL_BUF_LEN];      // Place for the section name string                                                                          \

    NTSTATUS Status;

    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    if (Locale == 0)
    {
        //
        //  Creating the default section.
        //
        RtlInitUnicodeString(&ObSecName, NLS_SECTION_LANG_INTL);
        pLangDefault = pTblPtrs->pDefaultLanguage;

    }
    else
    {
        GET_LANG_SECTION_NAME(Locale, wszSecName, MAX_SMALL_BUF_LEN, &ObSecName);
        pLangDefault = pTblPtrs->pLinguistLanguage;
    }

    //
    //  Try to Open and Map a view of the section (read only).
    //
    if (rc = OpenSection( &hSec,
                          &ObSecName,
                          (PVOID *)&pBaseAddr,
                          SECTION_MAP_READ,
                          FALSE ))
    {
        //
        //  Open failed.
        //  See if any exceptions exist for given Locale ID.
        //
        if (!FindLanguageExceptionPointers( Locale,
                                            &pExceptHdr,
                                            &pExceptTbl ) &&
            (Locale != 0))
        {
            //
            //  No exceptions for locale and we're not trying to create
            //  the default table, so return the pointer to the default
            //  table (which should always be created at this point).
            //
            *ppBaseAddr = pTblPtrs->pLinguistLanguage;
            return (NO_ERROR);
        }
        else
        {
            //
            //  Exceptions exist for the given locale.  Need to create the
            //  new section (and call the server to make it permanent).
            //

            Status = CsrBasepNlsCreateSection( NLS_CREATE_LANG_EXCEPTION_SECTION,
                                               Locale,
                                               &hSec );
            //
            //  Check return from server call.
            //
            rc = (ULONG)Status;

            if (!NT_SUCCESS(rc))
            {
                if (hSec != NULL)
                {
                    NtClose(hSec);
                }
                return (rc);
            }

            //
            //  Map the section for ReadWrite.
            //
            if (rc = MapSection( hSec,
                                 (PVOID *)&pBaseAddr,
                                 PAGE_READWRITE,
                                 FALSE ))
            {
                NtClose(hSec);
                return (rc);
            }

            //
            //  Put a 0 in the semaphore part to denote that the file
            //  is not ready yet.
            //
            *pBaseAddr = 0;

            //
            //  Copy the Default Language Table to the New Section.
            //
            RtlMoveMemory( (PVOID)((LPWORD)pBaseAddr + LANG_HEADER),
                           (PVOID)((LPWORD)(pLangDefault) + LANG_HEADER),
                           (ULONG)(pTblPtrs->LinguistLangSize.LowPart -
                                   (LANG_HEADER * sizeof(WORD))) );

            //
            //  Copy exception information to the table.
            //
            CopyLanguageExceptionInfo( pBaseAddr,
                                       pExceptHdr,
                                       pExceptTbl );

            //
            //  Write a 1 to the WORD semaphore (table may now be read).
            //
            *pBaseAddr = 1;

            //
            //  Unmap the section for Write and remap it for Read.
            //
            if ((rc = UnMapSection(pBaseAddr)) ||
                (rc = MapSection( hSec,
                                  (PVOID *)&pBaseAddr,
                                  PAGE_READONLY,
                                  FALSE )))
            {
                NtClose(hSec);
                return (rc);
            }
        }
    }

    //
    //   Close the section handle.
    //
    NtClose(hSec);

    //
    //  Check semaphore bit in file.  Make sure that the open
    //  succeeded AFTER all exceptions were added to the memory
    //  mapped section.
    //
    if (*pBaseAddr == 0)
    {
        //
        //  Another process is still adding the appropriate exception
        //  information.  Must wait for its completion.
        //
        if (rc = WaitOnEvent(pBaseAddr))
        {
            UnMapSection(pBaseAddr);
            return (rc);
        }
    }

    //
    //  Return the pointer to the section.
    //
    *ppBaseAddr = pBaseAddr;

    //
    //  Return success.
    //
    return (NO_ERROR);
}


////////////////////////////////////////////////////////////////////////////
//
//  FindLanguageExceptionPointers
//
//  Checks to see if any exceptions exist for the given locale id.  If
//  exceptions exist, then TRUE is returned and the pointer to the exception
//  header and the pointer to the exception table are stored in the given
//  parameters.
//
//  08-30-95    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL FASTCALL FindLanguageExceptionPointers(
    LCID Locale,
    PL_EXCEPT_HDR *ppExceptHdr,
    PL_EXCEPT *ppExceptTbl)
{
    DWORD ctr;                         // loop counter
    PL_EXCEPT_HDR pHdr;                // ptr to exception header
    BOOL rc = FALSE;                   // return value


    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    //
    //  Initialize pointers.
    //
    *ppExceptHdr = NULL;
    *ppExceptTbl = NULL;

    //
    //  Need to search down the exception header for the given locale.
    //
    pHdr = pTblPtrs->pLangExceptHdr;
    for (ctr = pTblPtrs->NumLangException; ctr > 0; ctr--, pHdr++)
    {
        if (pHdr->Locale == (DWORD)Locale)
        {
            //
            //  Found the locale id, so set the pointers.
            //
            *ppExceptHdr = pHdr;
            *ppExceptTbl = (PL_EXCEPT)(((LPWORD)(pTblPtrs->pLangException)) +
                                       pHdr->Offset);

            //
            //  Set the return code for success.
            //
            rc = TRUE;
            break;
        }
    }

    //
    //  Return the value in rc.
    //
    return (rc);
}


////////////////////////////////////////////////////////////////////////////
//
//  CopyLanguageExceptionInfo
//
//  Copies the language exception information to the given language table.
//
//  08-30-95    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

void FASTCALL CopyLanguageExceptionInfo(
    LPWORD pBaseAddr,
    PL_EXCEPT_HDR pExceptHdr,
    PL_EXCEPT pExceptTbl)
{
    DWORD ctr;                    // loop counter
    P844_TABLE pUpCase;           // ptr to upper case table
    P844_TABLE pLoCase;           // ptr to lower case table


    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    if (pExceptTbl)
    {
        //
        //  Get the pointers to the upper and lower case table.
        //
        pUpCase = pBaseAddr + LANG_HEADER + UP_HEADER;
        pLoCase = pBaseAddr + LANG_HEADER + pBaseAddr[LANG_HEADER] + LO_HEADER;

        //
        //  For each entry in the exception table, copy the information to the
        //  sortkey table.
        //
        for (ctr = pExceptHdr->NumUpEntries; ctr > 0; ctr--, pExceptTbl++)
        {
            TRAVERSE_844_W(pUpCase, pExceptTbl->UCP) = pExceptTbl->AddAmount;
        }
        for (ctr = pExceptHdr->NumLoEntries; ctr > 0; ctr--, pExceptTbl++)
        {
            TRAVERSE_844_W(pLoCase, pExceptTbl->UCP) = pExceptTbl->AddAmount;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  FindExceptionPointers
//
//  Checks to see if any exceptions exist for the given locale id.  If
//  exceptions exist, then TRUE is returned and the pointer to the exception
//  header and the pointer to the exception table are stored in the given
//  parameters.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL FASTCALL FindExceptionPointers(
    LCID Locale,
    PEXCEPT_HDR *ppExceptHdr,
    PEXCEPT *ppExceptTbl,
    PVOID *ppIdeograph,
    PULONG pReturn)
{
    HANDLE hSec = (HANDLE)0;           // section handle
    DWORD ctr;                         // loop counter
    PEXCEPT_HDR pHdr;                  // ptr to exception header
    BOOL bFound = FALSE;               // if an exception is found

    PIDEOGRAPH_LCID pIdeoLcid;         // ptr to ideograph lcid entry
    PVOID pBaseAddr;                   // ptr to base address of section


    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    //
    //  Initialize pointers.
    //
    *ppExceptHdr = NULL;
    *ppExceptTbl = NULL;
    *ppIdeograph = NULL;
    *pReturn = NO_ERROR;

    //
    //  Need to search down the exception header for the given locale.
    //
    pHdr = pTblPtrs->pExceptHdr;
    for (ctr = pTblPtrs->NumException; ctr > 0; ctr--, pHdr++)
    {
        if (pHdr->Locale == (DWORD)Locale)
        {
            //
            //  Found the locale id, so set the pointers.
            //
            *ppExceptHdr = pHdr;
            *ppExceptTbl = (PEXCEPT)(((LPWORD)(pTblPtrs->pException)) +
                                     pHdr->Offset);

            //
            //  Set the return code to show that an exception has been
            //  found.
            //
            bFound = TRUE;
            break;
        }
    }

    //
    //  Need to search down the ideograph lcid exception list for the
    //  given locale.
    //
    pIdeoLcid = pTblPtrs->pIdeographLcid;
    for (ctr = pTblPtrs->NumIdeographLcid; ctr > 0; ctr--, pIdeoLcid++)
    {
        if (pIdeoLcid->Locale == (DWORD)Locale)
        {
            //
            //  Found the locale id, so create/open and map the section
            //  for the appropriate file.
            //
            if (*pReturn = CreateSectionTemp(&hSec, pIdeoLcid->pFileName))
            {
                //
                //  Ideograph file section could not be created, so return
                //  the error.
                //
                return (TRUE);
            }
            if (*pReturn = MapSection(hSec, &pBaseAddr, PAGE_READONLY, TRUE))
            {
                //
                //  Ideograph file section could not be mapped, so close
                //  the created section and return the error.
                //
                NtClose(hSec);
                return (TRUE);
            }

            //
            //  Set the pointer to the ideograph information.
            //
            *ppIdeograph = pBaseAddr;

            //
            //  Set the return code to show that an exception has been
            //  found.
            //
            bFound = TRUE;
            break;
        }
    }

    //
    //  Return the appropriate value.
    //
    return (bFound);
}


////////////////////////////////////////////////////////////////////////////
//
//  CopyExceptionInfo
//
//  Copies the exception information to the given sortkey table.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

void FASTCALL CopyExceptionInfo(
    PSORTKEY pSortkey,
    PEXCEPT_HDR pExceptHdr,
    PEXCEPT pExceptTbl,
    PVOID pIdeograph)
{
    DWORD ctr;                    // loop counter
    PIDEOGRAPH_EXCEPT_HDR pHdrIG; // ptr to ideograph exception header
    PIDEOGRAPH_EXCEPT pEntryIG;   // ptr to ideograph exception entry
    PEXCEPT pEntryIGEx;           // ptr to ideograph exception entry ex


    //
    //  Make sure we're in the critical section when entering this call.
    //
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread == gcsTblPtrs.OwningThread);

    //
    //  For each entry in the exception table, copy the information to the
    //  sortkey table.
    //
    if (pExceptTbl)
    {
        for (ctr = pExceptHdr->NumEntries; ctr > 0; ctr--, pExceptTbl++)
        {
            (pSortkey[pExceptTbl->UCP]).UW.Unicode = pExceptTbl->Unicode;
            (pSortkey[pExceptTbl->UCP]).Diacritic  = pExceptTbl->Diacritic;
            (pSortkey[pExceptTbl->UCP]).Case       = pExceptTbl->Case;
        }
    }

    //
    //  For each entry in the ideograph exception table, copy the
    //  information to the sortkey table.
    //
    if (pIdeograph)
    {
        pHdrIG = (PIDEOGRAPH_EXCEPT_HDR)pIdeograph;
        ctr = pHdrIG->NumEntries;

        if (pHdrIG->NumColumns == 2)
        {
            pEntryIG = (PIDEOGRAPH_EXCEPT)( ((LPBYTE)pIdeograph) +
                                            sizeof(IDEOGRAPH_EXCEPT_HDR) );
            for (; ctr > 0; ctr--, pEntryIG++)
            {
                (pSortkey[pEntryIG->UCP]).UW.Unicode = pEntryIG->Unicode;
            }
        }
        else
        {
            pEntryIGEx = (PEXCEPT)( ((LPBYTE)pIdeograph) +
                                    sizeof(IDEOGRAPH_EXCEPT_HDR) );
            for (; ctr > 0; ctr--, pEntryIGEx++)
            {
                (pSortkey[pEntryIGEx->UCP]).UW.Unicode = pEntryIGEx->Unicode;
                (pSortkey[pEntryIGEx->UCP]).Diacritic  = pEntryIGEx->Diacritic;
                (pSortkey[pEntryIGEx->UCP]).Case       = pEntryIGEx->Case;
            }
        }

        //
        //  Unmap and Close the ideograph section.
        //
        UnMapSection(pIdeograph);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  WaitOnEvent
//
//  Waits (via timeout) for the semaphore dword to be set to a non-zero
//  value.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG WaitOnEvent(
    LPWORD pSem)
{
    TIME TimeOut;                 // ptr to timeout


    //
    //  Set up the TIME structure.
    //
    TimeOut.QuadPart = -100000;

    //
    //  Wait on the event until the semaphore is set to non-zero.
    //  Use a timeout on the wait.
    //
    do
    {
        NtDelayExecution(FALSE, &TimeOut);

    } while (*pSem == 0);

    //
    //  Return success.
    //
    return (NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\utf.c ===
/*++

Copyright (c) 1991-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    utf.c

Abstract:

    This file contains functions that convert UTF strings to Unicode
    strings and Unicode string to UTF strings.

    External Routines found in this file:
      UTFCPInfo
      UTFToUnicode
      UnicodeToUTF

Revision History:

    02-06-96    JulieB    Created.
    03-20-99    SamerA    Surrogate support.
--*/



//
//  Include Files.
//

#include "nls.h"
#include "utf.h"




//
//  Forward Declarations.
//

int
UTF7ToUnicode(
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest);

int
UTF8ToUnicode(
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest,
    DWORD dwFlags);

int
UnicodeToUTF7(
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest);

int
UnicodeToUTF8(
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest);





//-------------------------------------------------------------------------//
//                           EXTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  UTFCPInfo
//
//  Gets the CPInfo for the given UTF code page.
//
//  10-23-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL UTFCPInfo(
    UINT CodePage,
    LPCPINFO lpCPInfo,
    BOOL fExVer)
{
    int ctr;


    //
    //  Invalid Parameter Check:
    //     - validate code page
    //     - lpCPInfo is NULL
    //
    if ( (CodePage < CP_UTF7) || (CodePage > CP_UTF8) ||
         (lpCPInfo == NULL) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    switch (CodePage)
    {
        case ( CP_UTF7 ) :
        {
            lpCPInfo->MaxCharSize = 5;
            break;
        }
        case ( CP_UTF8 ) :
        {
            lpCPInfo->MaxCharSize = 4;
            break;
        }
    }

    (lpCPInfo->DefaultChar)[0] = '?';
    (lpCPInfo->DefaultChar)[1] = (BYTE)0;

    for (ctr = 0; ctr < MAX_LEADBYTES; ctr++)
    {
        (lpCPInfo->LeadByte)[ctr] = (BYTE)0;
    }

    if (fExVer)
    {
        LPCPINFOEXW lpCPInfoEx = (LPCPINFOEXW)lpCPInfo;

        lpCPInfoEx->UnicodeDefaultChar = L'?';
        lpCPInfoEx->CodePage = CodePage;
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  UTFToUnicode
//
//  Maps a UTF character string to its wide character string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UTFToUnicode(
    UINT CodePage,
    DWORD dwFlags,
    LPCSTR lpMultiByteStr,
    int cbMultiByte,
    LPWSTR lpWideCharStr,
    int cchWideChar)
{
    int rc = 0;


    //
    //  Invalid Parameter Check:
    //     - validate code page
    //     - length of MB string is 0
    //     - wide char buffer size is negative
    //     - MB string is NULL
    //     - length of WC string is NOT zero AND
    //         (WC string is NULL OR src and dest pointers equal)
    //
    if ( (CodePage < CP_UTF7) || (CodePage > CP_UTF8) ||
         (cbMultiByte == 0) || (cchWideChar < 0) ||
         (lpMultiByteStr == NULL) ||
         ((cchWideChar != 0) &&
          ((lpWideCharStr == NULL) ||
           (lpMultiByteStr == (LPSTR)lpWideCharStr))) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Invalid Flags Check:
    //     - UTF7: flags not 0.
    //     - UTF8: flags not 0 nor MB_ERR_INVALID_CHARS.
    //
    if (CodePage == CP_UTF8) 
    {
        // UTF8        
        if ((dwFlags & ~MB_ERR_INVALID_CHARS) != 0)
        {
            SetLastError(ERROR_INVALID_FLAGS);
            return (0);
        }
    } 
    else if (dwFlags != 0)
    {
        // UTF7
        SetLastError(ERROR_INVALID_FLAGS);
        return (0);
    }

    //
    //  If cbMultiByte is -1, then the string is null terminated and we
    //  need to get the length of the string.  Add one to the length to
    //  include the null termination.  (This will always be at least 1.)
    //
    if (cbMultiByte <= -1)
    {
        cbMultiByte = strlen(lpMultiByteStr) + 1;
    }

    switch (CodePage)
    {
        case ( CP_UTF7 ) :
        {
            rc = UTF7ToUnicode( lpMultiByteStr,
                                cbMultiByte,
                                lpWideCharStr,
                                cchWideChar );
            break;
        }
        case ( CP_UTF8 ) :
        {
            rc = UTF8ToUnicode( lpMultiByteStr,
                                cbMultiByte,
                                lpWideCharStr,
                                cchWideChar,
                                dwFlags);
            break;
        }
    }

    return (rc);
}


////////////////////////////////////////////////////////////////////////////
//
//  UnicodeToUTF
//
//  Maps a Unicode character string to its UTF string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UnicodeToUTF(
    UINT CodePage,
    DWORD dwFlags,
    LPCWSTR lpWideCharStr,
    int cchWideChar,
    LPSTR lpMultiByteStr,
    int cbMultiByte,
    LPCSTR lpDefaultChar,
    LPBOOL lpUsedDefaultChar)
{
    int rc = 0;


    //
    //  Invalid Parameter Check:
    //     - validate code page
    //     - length of WC string is 0
    //     - multibyte buffer size is negative
    //     - WC string is NULL
    //     - length of WC string is NOT zero AND
    //         (MB string is NULL OR src and dest pointers equal)
    //     - lpDefaultChar and lpUsedDefaultChar not NULL
    //
    if ( (CodePage < CP_UTF7) || (CodePage > CP_UTF8) ||
         (cchWideChar == 0) || (cbMultiByte < 0) ||
         (lpWideCharStr == NULL) ||
         ((cbMultiByte != 0) &&
          ((lpMultiByteStr == NULL) ||
           (lpWideCharStr == (LPWSTR)lpMultiByteStr))) ||
         (lpDefaultChar != NULL) || (lpUsedDefaultChar != NULL) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Invalid Flags Check:
    //     - flags not 0
    //
    if (dwFlags != 0)
    {
        SetLastError(ERROR_INVALID_FLAGS);
        return (0);
    }

    //
    //  If cchWideChar is -1, then the string is null terminated and we
    //  need to get the length of the string.  Add one to the length to
    //  include the null termination.  (This will always be at least 1.)
    //
    if (cchWideChar <= -1)
    {
        cchWideChar = NlsStrLenW(lpWideCharStr) + 1;
    }

    switch (CodePage)
    {
        case ( CP_UTF7 ) :
        {
            rc = UnicodeToUTF7( lpWideCharStr,
                                cchWideChar,
                                lpMultiByteStr,
                                cbMultiByte );
            break;
        }
        case ( CP_UTF8 ) :
        {
            rc = UnicodeToUTF8( lpWideCharStr,
                                cchWideChar,
                                lpMultiByteStr,
                                cbMultiByte );
            break;
        }
    }

    return (rc);
}




//-------------------------------------------------------------------------//
//                           INTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  UTF7ToUnicode
//
//  Maps a UTF-7 character string to its wide character string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UTF7ToUnicode(
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest)
{
    //CHAR is signed, so we have to cast lpSrcStr to an unsigned char below.
    BYTE* pUTF7 = (BYTE*)lpSrcStr;    
    BOOL fShift = FALSE;
    DWORD dwBit = 0;              // 32-bit buffer to hold temporary bits
    int iPos = 0;                 // 6-bit position pointer in the buffer
    int cchWC = 0;                // # of Unicode code points generated


    while ((cchSrc--) && ((cchDest == 0) || (cchWC < cchDest)))
    {
        if (*pUTF7 > ASCII)
        {
            //
            //  Error - non ASCII char, so zero extend it.
            //
            if (cchDest)
            {
                lpDestStr[cchWC] = (WCHAR)*pUTF7;
            }
            cchWC++;
            // Terminate the shifted sequence.
            fShift = FALSE;
        }
        else if (!fShift)
        {
            //
            //  Not in shifted sequence.
            //
            if (*pUTF7 == SHIFT_IN)
            {
                if (cchSrc && (pUTF7[1] == SHIFT_OUT))
                {
                    //
                    //  "+-" means "+"
                    //
                    if (cchDest)
                    {
                        lpDestStr[cchWC] = (WCHAR)*pUTF7;
                    }
                    pUTF7++;
                    cchSrc--;
                    cchWC++;
                }
                else
                {
                    //
                    //  Start a new shift sequence.
                    //
                    fShift = TRUE;
                }
            }
            else
            {
                //
                //  No need to shift.
                //
                if (cchDest)
                {
                    lpDestStr[cchWC] = (WCHAR)*pUTF7;
                }
                cchWC++;
            }
        }
        else
        {
            //
            //  Already in shifted sequence.
            //
            if (nBitBase64[*pUTF7] == -1)
            {
                //
                //  Any non Base64 char also ends shift state.
                //
                if (*pUTF7 != SHIFT_OUT)
                {
                    //
                    //  Not "-", so write it to the buffer.
                    //
                    if (cchDest)
                    {
                        lpDestStr[cchWC] = (WCHAR)*pUTF7;
                    }
                    cchWC++;
                }

                //
                //  Reset bits.
                //
                fShift = FALSE;
                dwBit = 0;
                iPos = 0;
            }
            else
            {
                //
                //  Store the bits in the 6-bit buffer and adjust the
                //  position pointer.
                //
                dwBit |= ((DWORD)nBitBase64[*pUTF7]) << (26 - iPos);
                iPos += 6;
            }

            //
            //  Output the 16-bit Unicode value.
            //
            while (iPos >= 16)
            {
                if (cchDest)
                {
                    if (cchWC < cchDest)
                    {
                        lpDestStr[cchWC] = (WCHAR)(dwBit >> 16);
                    }
                    else
                    {
                        break;
                    }
                }
                cchWC++;

                dwBit <<= 16;
                iPos -= 16;
            }
            if (iPos >= 16)
            {
                //
                //  Error - buffer too small.
                //
                cchSrc++;
                break;
            }
        }

        pUTF7++;
    }

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        if (cchSrc == 0 && fShift && *(pUTF7--) == SHIFT_OUT)
        {
            //
            // Do nothing here.
            // If we are in shift-in mode previously, and the last byte is a shift-out byte ('-'),
            // we should absorb this byte.  So don't set error.
            //
        } else
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return (0);
        }
    }

    //
    //  Return the number of Unicode characters written.
    //
    return (cchWC);
}


////////////////////////////////////////////////////////////////////////////
//
//  UTF8ToUnicode
//
//  Maps a UTF-8 character string to its wide character string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UTF8ToUnicode(
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest,
    DWORD dwFlags
    )
{
    int nTB = 0;                   // # trail bytes to follow
    int cchWC = 0;                 // # of Unicode code points generated
    CONST BYTE* pUTF8 = (CONST BYTE*)lpSrcStr;
    DWORD dwSurrogateChar;         // Full surrogate char
    BOOL bSurrogatePair = FALSE;   // Indicate we'r collecting a surrogate pair
    BOOL bCheckInvalidBytes = (dwFlags & MB_ERR_INVALID_CHARS);
    BYTE UTF8;


    while ((cchSrc--) && ((cchDest == 0) || (cchWC < cchDest)))
    {
        //
        //  See if there are any trail bytes.
        //
        if (BIT7(*pUTF8) == 0)
        {
            //
            //  Found ASCII.
            //
            if (cchDest)
            {
                lpDestStr[cchWC] = (WCHAR)*pUTF8;
            }
            nTB = bSurrogatePair = 0;
            cchWC++;
        }
        else if (BIT6(*pUTF8) == 0)
        {
            //
            //  Found a trail byte.
            //  Note : Ignore the trail byte if there was no lead byte.
            //
            if (nTB != 0)
            {
                //
                //  Decrement the trail byte counter.
                //
                nTB--;

                if (bSurrogatePair)
                {
                    dwSurrogateChar <<= 6;
                    dwSurrogateChar |= LOWER_6_BIT(*pUTF8);

                    if (nTB == 0)
                    {
                        if (cchDest)
                        {
                            if ((cchWC + 1) < cchDest)
                            {
                                lpDestStr[cchWC]   = (WCHAR)
                                                     (((dwSurrogateChar - 0x10000) >> 10) + HIGH_SURROGATE_START);

                                lpDestStr[cchWC+1] = (WCHAR)
                                                     ((dwSurrogateChar - 0x10000)%0x400 + LOW_SURROGATE_START);
                            }
                            else
                            {
                                // Error : Buffer too small
                                cchSrc++;
                                break;
                            }
                        }

                        cchWC += 2;
                        bSurrogatePair = FALSE;
                    }
                }
                else
                {
                    //
                    //  Make room for the trail byte and add the trail byte
                    //  value.
                    //
                    if (cchDest)
                    {
                        lpDestStr[cchWC] <<= 6;
                        lpDestStr[cchWC] |= LOWER_6_BIT(*pUTF8);
                        
                    }

                    if (nTB == 0)
                    {
                        //
                        //  End of sequence.  Advance the output counter.
                        //
                        cchWC++;
                    }
                }
            }
            else
            {
                if (bCheckInvalidBytes) 
                {
                    SetLastError(ERROR_NO_UNICODE_TRANSLATION);
                    return (0);
                }
                // error - not expecting a trail byte. That is, there is a trailing byte without leading byte.
                bSurrogatePair = FALSE;
            }
        }
        else
        {
            //
            //  Found a lead byte.
            //
            if (nTB > 0)
            {
                // error - A leading byte before the previous sequence is completed.
                if (bCheckInvalidBytes) 
                {
                    SetLastError(ERROR_NO_UNICODE_TRANSLATION);
                    return (0);
                }            
                //
                //  Error - previous sequence not finished.
                //
                nTB = 0;
                bSurrogatePair = FALSE;
                // Put this character back so that we can start over another sequence.
                cchSrc++;
                pUTF8--;
            }
            else
            {
                //
                //  Calculate the number of bytes to follow.
                //  Look for the first 0 from left to right.
                //
                UTF8 = *pUTF8;
                while (BIT7(UTF8) != 0)
                {
                    UTF8 <<= 1;
                    nTB++;
                }

                //
                // Check for non-shortest form.
                // 
                switch (nTB) {
                    case 1:
                        nTB = 0;
                        break;
                    case 2:
                        // Make sure that bit 8 ~ bit 11 is not all zero.
                        // 110XXXXx 10xxxxxx
                        if ((*pUTF8 & 0x1e) == 0)
                        {
                            nTB = 0;
                        }
                        break;
                    case 3:
                        // Look ahead to check for non-shortest form.
                        // 1110XXXX 10Xxxxxx 10xxxxxx
                        if (cchSrc >= 2)
                        {
                            if (((*pUTF8 & 0x0f) == 0) && (*(pUTF8 + 1) & 0x20) == 0)
                            {
                                nTB = 0;
                            }
                        }
                        break;
                    case 4:                    
                        //
                        // This is a surrogate unicode pair
                        //
                        if (cchSrc >= 3)
                        {
                            WORD word = (((WORD)*pUTF8) << 8) | *(pUTF8 + 1);
                            // Look ahead to check for non-shortest form.
                            // 11110XXX 10XXxxxx 10xxxxxx 10xxxxxx                        
                            // Check for the 5 bits are not all zero.
                            // 0x0730 == 00000111 11000000
                            if ((word & 0x0730) == 0) 
                            {
                                nTB = 0;
                            } else if ((word & 0x0400) == 0x0400)
                            {
                                // The 21st bit is 1.
                                // Make sure that the resulting Unicode is within the valid surrogate range.
                                // The 4 byte code sequence can hold up to 21 bits, and the maximum valid code point ragne
                                // that Unicode (with surrogate) could represent are from U+000000 ~ U+10FFFF.
                                // Therefore, if the 21 bit (the most significant bit) is 1, we should verify that the 17 ~ 20
                                // bit are all zero.
                                // I.e., in 11110XXX 10XXxxxx 10xxxxxx 10xxxxxx,
                                // XXXXX can only be 10000.

                                // 0x0330 = 0000 0011 0011 0000
                                if ((word & 0x0330) != 0) 
                                {
                                    nTB = 0;
                                }  
                            }

                            if (nTB != 0)
                            { 
                                dwSurrogateChar = UTF8 >> nTB;
                                bSurrogatePair = TRUE;
                            }
                        }                        
                        break;
                    default:                    
                        // 
                        // If the bits is greater than 4, this is an invalid
                        // UTF8 lead byte.
                        //
                        nTB = 0;
                        break;
                }

                if (nTB != 0) 
                {
                    //
                    //  Store the value from the first byte and decrement
                    //  the number of bytes to follow.
                    //
                    if (cchDest)
                    {
                        lpDestStr[cchWC] = UTF8 >> nTB;
                    }
                    nTB--;
                } else 
                {
                    if (bCheckInvalidBytes) 
                    {
                        SetLastError(ERROR_NO_UNICODE_TRANSLATION);
                        return (0);
                    }                 
                }
            }
        }
        pUTF8++;
    }

    if ((bCheckInvalidBytes && nTB != 0) || (cchWC == 0)) 
    {
        // About (cchWC == 0):
        // Because we now throw away non-shortest form, it is possible that we generate 0 chars.
        // In this case, we have to set error to ERROR_NO_UNICODE_TRANSLATION so that we conform
        // to the spec of MultiByteToWideChar.
        SetLastError(ERROR_NO_UNICODE_TRANSLATION);
        return (0);
    }
    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }


    //
    //  Return the number of Unicode characters written.
    //
    return (cchWC);
}


////////////////////////////////////////////////////////////////////////////
//
//  UnicodeToUTF7
//
//  Maps a Unicode character string to its UTF-7 string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UnicodeToUTF7(
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest)
{
    LPCWSTR lpWC = lpSrcStr;
    BOOL fShift = FALSE;
    DWORD dwBit = 0;              // 32-bit buffer
    int iPos = 0;                 // 6-bit position in buffer
    int cchU7 = 0;                // # of UTF7 chars generated


    while ((cchSrc--) && ((cchDest == 0) || (cchU7 < cchDest)))
    {
        if ((*lpWC > ASCII) || (fShiftChar[*lpWC]))
        {
            //
            //  Need shift.  Store 16 bits in buffer.
            //
            dwBit |= ((DWORD)*lpWC) << (16 - iPos);
            iPos += 16;

            if (!fShift)
            {
                //
                //  Not in shift state, so add "+".
                //
                if (cchDest)
                {
                    lpDestStr[cchU7] = SHIFT_IN;
                }
                cchU7++;

                //
                //  Go into shift state.
                //
                fShift = TRUE;
            }

            //
            //  Output 6 bits at a time as Base64 chars.
            //
            while (iPos >= 6)
            {
                if (cchDest)
                {
                    if (cchU7 < cchDest)
                    {
                        //
                        //  26 = 32 - 6
                        //
                        lpDestStr[cchU7] = cBase64[(int)(dwBit >> 26)];
                    }
                    else
                    {
                        break;
                    }
                }

                cchU7++;
                dwBit <<= 6;           // remove from bit buffer
                iPos -= 6;             // adjust position pointer
            }
            if (iPos >= 6)
            {
                //
                //  Error - buffer too small.
                //
                cchSrc++;
                break;
            }
        }
        else
        {
            //
            //  No need to shift.
            //
            if (fShift)
            {
                //
                //  End the shift sequence.
                //
                fShift = FALSE;

                if (iPos != 0)
                {
                    //
                    //  Some bits left in dwBit.
                    //
                    if (cchDest)
                    {
                        if ((cchU7 + 1) < cchDest)
                        {
                            lpDestStr[cchU7++] = cBase64[(int)(dwBit >> 26)];
                            lpDestStr[cchU7++] = SHIFT_OUT;
                        }
                        else
                        {
                            //
                            //  Error - buffer too small.
                            //
                            cchSrc++;
                            break;
                        }
                    }
                    else
                    {
                        cchU7 += 2;
                    }

                    dwBit = 0;         // reset bit buffer
                    iPos  = 0;         // reset postion pointer
                }
                else
                {
                    //
                    //  Simply end the shift sequence.
                    //
                    if (cchDest)
                    {
                        lpDestStr[cchU7++] = SHIFT_OUT;
                    }
                    else
                    {
                        cchU7++;
                    }
                }
            }

            //
            //  Write the character to the buffer.
            //  If the character is "+", then write "+-".
            //
            if (cchDest)
            {
                if (cchU7 < cchDest)
                {
                    lpDestStr[cchU7++] = (char)*lpWC;

                    if (*lpWC == SHIFT_IN)
                    {
                        if (cchU7 < cchDest)
                        {
                            lpDestStr[cchU7++] = SHIFT_OUT;
                        }
                        else
                        {
                            //
                            //  Error - buffer too small.
                            //
                            cchSrc++;
                            break;
                        }
                    }
                }
                else
                {
                    //
                    //  Error - buffer too small.
                    //
                    cchSrc++;
                    break;
                }
            }
            else
            {
                cchU7++;

                if (*lpWC == SHIFT_IN)
                {
                    cchU7++;
                }
            }
        }

        lpWC++;
    }

    //
    //  See if we're still in the shift state.
    //
    if (fShift)
    {
        if (iPos != 0)
        {
            //
            //  Some bits left in dwBit.
            //
            if (cchDest)
            {
                if ((cchU7 + 1) < cchDest)
                {
                    lpDestStr[cchU7++] = cBase64[(int)(dwBit >> 26)];
                    lpDestStr[cchU7++] = SHIFT_OUT;
                }
                else
                {
                    //
                    //  Error - buffer too small.
                    //
                    cchSrc++;
                }
            }
            else
            {
                cchU7 += 2;
            }
        }
        else
        {
            //
            //  Simply end the shift sequence.
            //
            if (cchDest)
            {
                if (cchU7 < cchDest) 
                {
                    lpDestStr[cchU7++] = SHIFT_OUT;
                } 
                else 
                {
                    //
                    //  Error - buffer too small.
                    //
                    cchSrc++;
                }
            }
            else
            {
                cchU7++;
            }
        }
    }

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Return the number of UTF-7 characters written.
    //
    return (cchU7);
}


////////////////////////////////////////////////////////////////////////////
//
//  UnicodeToUTF8
//
//  Maps a Unicode character string to its UTF-8 string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int UnicodeToUTF8(
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest)
{
    LPCWSTR lpWC = lpSrcStr;
    int     cchU8 = 0;                // # of UTF8 chars generated
    DWORD   dwSurrogateChar;
    WCHAR   wchHighSurrogate = 0;
    BOOL    bHandled;


    while ((cchSrc--) && ((cchDest == 0) || (cchU8 < cchDest)))
    {
        bHandled = FALSE;

        //
        // Check if high surrogate is available
        //
        if ((*lpWC >= HIGH_SURROGATE_START) && (*lpWC <= HIGH_SURROGATE_END))
        {
            if (cchDest)
            {
                // Another high surrogate, then treat the 1st as normal
                // Unicode character.
                if (wchHighSurrogate)
                {
                    if ((cchU8 + 2) < cchDest)
                    {
                        lpDestStr[cchU8++] = UTF8_1ST_OF_3 | HIGHER_6_BIT(wchHighSurrogate);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(wchHighSurrogate);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(wchHighSurrogate);
                    }
                    else
                    {
                        // not enough buffer
                        cchSrc++;
                        break;
                    }
                }
            }
            else
            {
                cchU8 += 3;
            }
            wchHighSurrogate = *lpWC;
            bHandled = TRUE;
        }

        if (!bHandled && wchHighSurrogate)
        {
            if ((*lpWC >= LOW_SURROGATE_START) && (*lpWC <= LOW_SURROGATE_END))
            {
                 // wheee, valid surrogate pairs

                 if (cchDest)
                 {
                     if ((cchU8 + 3) < cchDest)
                     {
                         dwSurrogateChar = (((wchHighSurrogate-0xD800) << 10) + (*lpWC - 0xDC00) + 0x10000);

                         lpDestStr[cchU8++] = (UTF8_1ST_OF_4 |
                                               (unsigned char)(dwSurrogateChar >> 18));           // 3 bits from 1st byte

                         lpDestStr[cchU8++] =  (UTF8_TRAIL |
                                                (unsigned char)((dwSurrogateChar >> 12) & 0x3f)); // 6 bits from 2nd byte

                         lpDestStr[cchU8++] = (UTF8_TRAIL |
                                               (unsigned char)((dwSurrogateChar >> 6) & 0x3f));   // 6 bits from 3rd byte

                         lpDestStr[cchU8++] = (UTF8_TRAIL |
                                               (unsigned char)(0x3f & dwSurrogateChar));          // 6 bits from 4th byte
                     }
                     else
                     {
                        // not enough buffer
                        cchSrc++;
                        break;
                     }
                 }
                 else
                 {
                     // we already counted 3 previously (in high surrogate)
                     cchU8 ++;
                 }

                 bHandled = TRUE;
            }
            else
            {
                 // Bad Surrogate pair : ERROR
                 // Just process wchHighSurrogate , and the code below will
                 // process the current code point
                 if (cchDest)
                 {
                     if ((cchU8 + 2) < cchDest)
                     {
                        lpDestStr[cchU8++] = UTF8_1ST_OF_3 | HIGHER_6_BIT(wchHighSurrogate);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(wchHighSurrogate);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(wchHighSurrogate);
                     }
                     else
                     {
                        // not enough buffer
                        cchSrc++;
                        break;
                     }
                 }
            }

            wchHighSurrogate = 0;
        }

        if (!bHandled)
        {
            if (*lpWC <= ASCII)
            {
                //
                //  Found ASCII.
                //
                if (cchDest)
                {
                    if (cchU8 < cchDest) 
                    {
                        lpDestStr[cchU8] = (char)*lpWC;
                    } 
                    else 
                    {
                        //
                        //  Error - buffer too small.
                        //
                        cchSrc++;
                        break;
                    }
                }
                cchU8++;
            }
            else if (*lpWC <= UTF8_2_MAX)
            {
                //
                //  Found 2 byte sequence if < 0x07ff (11 bits).
                //
                if (cchDest)
                {
                    if ((cchU8 + 1) < cchDest)
                    {
                        //
                        //  Use upper 5 bits in first byte.
                        //  Use lower 6 bits in second byte.
                        //
                        lpDestStr[cchU8++] = UTF8_1ST_OF_2 | (*lpWC >> 6);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(*lpWC);
                    }
                    else
                    {
                        //
                        //  Error - buffer too small.
                        //
                        cchSrc++;
                        break;
                    }
                }
                else
                {
                    cchU8 += 2;
                }
            }
            else
            {
                //
                //  Found 3 byte sequence.
                //
                if (cchDest)
                {
                    if ((cchU8 + 2) < cchDest)
                    {
                        //
                        //  Use upper  4 bits in first byte.
                        //  Use middle 6 bits in second byte.
                        //  Use lower  6 bits in third byte.
                        //
                        lpDestStr[cchU8++] = UTF8_1ST_OF_3 | HIGHER_6_BIT(*lpWC);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(*lpWC);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(*lpWC);
                    }
                    else
                    {
                        //
                        //  Error - buffer too small.
                        //
                        cchSrc++;
                        break;
                    }
                }
                else
                {
                    cchU8 += 3;
                }
            }
        }

        lpWC++;
    }

    //
    // If the last character was a high surrogate, then handle it as a normal
    // unicode character.
    //
    if ((cchSrc < 0) && (wchHighSurrogate != 0))
    {
        if (cchDest)
        {
            if ((cchU8 + 2) < cchDest)
            {
                lpDestStr[cchU8++] = UTF8_1ST_OF_3 | HIGHER_6_BIT(wchHighSurrogate);
                lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(wchHighSurrogate);
                lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(wchHighSurrogate);
            }
            else
            {
                cchSrc++;
            }
        }
    }

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Return the number of UTF-8 characters written.
    //
    return (cchU8);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\string.c ===
/*++

Copyright (c) 1991-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    string.c

Abstract:

    This file contains functions that deal with characters and strings.

    APIs found in this file:
      CompareStringW
      GetStringTypeExW
      GetStringTypeW

Revision History:

    05-31-91    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nls.h"
#include "jamo.h"




//
//  Constant Declarations.
//

//
//  State Table.
//
#define STATE_DW                  1    // normal diacritic weight state
#define STATE_REVERSE_DW          2    // reverse diacritic weight state
#define STATE_CW                  4    // case weight state
#define STATE_JAMO_WEIGHT         8    // jamo weight state


//
//  Invalid weight value.
//
#define CMP_INVALID_WEIGHT        0xffffffff
#define CMP_INVALID_FAREAST       0xffff0000
#define CMP_INVALID_UW            0xffff




//
//  Forward Declarations.
//

int
LongCompareStringW(
    PLOC_HASH pHashN,
    DWORD dwCmpFlags,
    LPCWSTR lpString1,
    int cchCount1,
    LPCWSTR lpString2,
    int cchCount2,
    BOOL fModify);

int
FindJamoDifference(
    PLOC_HASH pHashN,
    LPCWSTR* ppString1,
    int* ctr1,
    int cchCount1,
    DWORD* pWeight1,
    LPCWSTR* ppString2,
    int* ctr2,
    int cchCount2,
    DWORD* pWeight2,
    LPCWSTR* pLastJamo,
    WORD* uw1,
    WORD* uw2,
    int* pState,
    int* WhichJamo,
    BOOL fModify);





//-------------------------------------------------------------------------//
//                           INTERNAL MACROS                               //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  NOT_END_STRING
//
//  Checks to see if the search has reached the end of the string.
//  It returns TRUE if the counter is not at zero (counting backwards) and
//  the null termination has not been reached (if -1 was passed in the count
//  parameter.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NOT_END_STRING(ct, ptr, cchIn)                                     \
    ((ct != 0) && (!((*(ptr) == 0) && (cchIn == -2))))


////////////////////////////////////////////////////////////////////////////
//
//  AT_STRING_END
//
//  Checks to see if the pointer is at the end of the string.
//  It returns TRUE if the counter is zero or if the null termination
//  has been reached (if -2 was passed in the count parameter).
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define AT_STRING_END(ct, ptr, cchIn)                                      \
    ((ct == 0) || ((*(ptr) == 0) && (cchIn == -2)))


////////////////////////////////////////////////////////////////////////////
//
//  REMOVE_STATE
//
//  Removes the current state from the state table.  This should only be
//  called when the current state should not be entered for the remainder
//  of the comparison.  It decrements the counter going through the state
//  table and decrements the number of states in the table.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define REMOVE_STATE(value)            (State &= ~value)


////////////////////////////////////////////////////////////////////////////
//
//  POINTER_FIXUP
//
//  Fixup the string pointers if expansion characters were found.
//  Then, advance the string pointers and decrement the string counters.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define POINTER_FIXUP()                                                    \
{                                                                          \
    /*                                                                     \
     *  Fixup the pointers (if necessary).                                 \
     */                                                                    \
    if (pSave1 && (--cExpChar1 == 0))                                      \
    {                                                                      \
        /*                                                                 \
         *  Done using expansion temporary buffer.                         \
         */                                                                \
        pString1 = pSave1;                                                 \
        pSave1 = NULL;                                                     \
    }                                                                      \
                                                                           \
    if (pSave2 && (--cExpChar2 == 0))                                      \
    {                                                                      \
        /*                                                                 \
         *  Done using expansion temporary buffer.                         \
         */                                                                \
        pString2 = pSave2;                                                 \
        pSave2 = NULL;                                                     \
    }                                                                      \
                                                                           \
    /*                                                                     \
     *  Advance the string pointers.                                       \
     */                                                                    \
    pString1++;                                                            \
    pString2++;                                                            \
}


////////////////////////////////////////////////////////////////////////////
//
//  SCAN_LONGER_STRING
//
//  Scans the longer string for diacritic, case, and special weights.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define SCAN_LONGER_STRING( ct,                                            \
                            ptr,                                           \
                            cchIn,                                         \
                            ret )                                          \
{                                                                          \
    /*                                                                     \
     *  Search through the rest of the longer string to make sure          \
     *  all characters are not to be ignored.  If find a character that    \
     *  should not be ignored, return the given return value immediately.  \
     *                                                                     \
     *  The only exception to this is when a nonspace mark is found.  If   \
     *  another DW difference has been found earlier, then use that.       \
     */                                                                    \
    while (NOT_END_STRING(ct, ptr, cchIn))                                 \
    {                                                                      \
        Weight1 = GET_DWORD_WEIGHT(pHashN, *ptr);                          \
        switch (GET_SCRIPT_MEMBER(&Weight1))                               \
        {                                                                  \
            case ( UNSORTABLE ):                                           \
            {                                                              \
                break;                                                     \
            }                                                              \
            case ( NONSPACE_MARK ):                                        \
            {                                                              \
                if ((!fIgnoreDiacritic) && (!WhichDiacritic))              \
                {                                                          \
                    return (ret);                                          \
                }                                                          \
                break;                                                     \
            }                                                              \
            case ( PUNCTUATION ) :                                         \
            case ( SYMBOL_1 ) :                                            \
            case ( SYMBOL_2 ) :                                            \
            case ( SYMBOL_3 ) :                                            \
            case ( SYMBOL_4 ) :                                            \
            case ( SYMBOL_5 ) :                                            \
            {                                                              \
                if (!fIgnoreSymbol)                                        \
                {                                                          \
                    return (ret);                                          \
                }                                                          \
                break;                                                     \
            }                                                              \
            case ( EXPANSION ) :                                           \
            case ( FAREAST_SPECIAL ) :                                     \
            case ( JAMO_SPECIAL ) :                                        \
            case ( EXTENSION_A ) :                                         \
            default :                                                      \
            {                                                              \
                return (ret);                                              \
            }                                                              \
        }                                                                  \
                                                                           \
        /*                                                                 \
         *  Advance pointer and decrement counter.                         \
         */                                                                \
        ptr++;                                                             \
        ct--;                                                              \
    }                                                                      \
                                                                           \
    /*                                                                     \
     *  Need to check diacritic, case, extra, and special weights for      \
     *  final return value.  Still could be equal if the longer part of    \
     *  the string contained only characters to be ignored.                \
     *                                                                     \
     *  NOTE:  The following checks MUST REMAIN IN THIS ORDER:             \
     *            Diacritic, Case, Extra, Punctuation.                     \
     */                                                                    \
    if (WhichDiacritic)                                                    \
    {                                                                      \
        return (WhichDiacritic);                                           \
    }                                                                      \
    if (WhichCase)                                                         \
    {                                                                      \
        return (WhichCase);                                                \
    }                                                                      \
    if (WhichExtra)                                                        \
    {                                                                      \
        if (!fIgnoreDiacritic)                                             \
        {                                                                  \
            if (GET_WT_FOUR(&WhichExtra))                                  \
            {                                                              \
                return (GET_WT_FOUR(&WhichExtra));                         \
            }                                                              \
            if (GET_WT_FIVE(&WhichExtra))                                  \
            {                                                              \
                return (GET_WT_FIVE(&WhichExtra));                         \
            }                                                              \
        }                                                                  \
        if (GET_WT_SIX(&WhichExtra))                                       \
        {                                                                  \
            return (GET_WT_SIX(&WhichExtra));                              \
        }                                                                  \
        if (GET_WT_SEVEN(&WhichExtra))                                     \
        {                                                                  \
            return (GET_WT_SEVEN(&WhichExtra));                            \
        }                                                                  \
    }                                                                      \
    if (WhichJamo)                                                         \
    {                                                                      \
        return (WhichJamo);                                                \
    }                                                                      \
    if (WhichPunct1)                                                       \
    {                                                                      \
        return (WhichPunct1);                                              \
    }                                                                      \
    if (WhichPunct2)                                                       \
    {                                                                      \
        return (WhichPunct2);                                              \
    }                                                                      \
                                                                           \
    return (CSTR_EQUAL);                                                   \
}


////////////////////////////////////////////////////////////////////////////
//
//  QUICK_SCAN_LONGER_STRING
//
//  Scans the longer string for diacritic, case, and special weights.
//  Assumes that both strings are null-terminated.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define QUICK_SCAN_LONGER_STRING( ptr,                                     \
                                  ret )                                    \
{                                                                          \
    /*                                                                     \
     *  Search through the rest of the longer string to make sure          \
     *  all characters are not to be ignored.  If find a character that    \
     *  should not be ignored, return the given return value immediately.  \
     *                                                                     \
     *  The only exception to this is when a nonspace mark is found.  If   \
     *  another DW difference has been found earlier, then use that.       \
     */                                                                    \
    while (*ptr != 0)                                                      \
    {                                                                      \
        switch (GET_SCRIPT_MEMBER(&(pHashN->pSortkey[*ptr])))              \
        {                                                                  \
            case ( UNSORTABLE ):                                           \
            {                                                              \
                break;                                                     \
            }                                                              \
            case ( NONSPACE_MARK ):                                        \
            {                                                              \
                if (!WhichDiacritic)                                       \
                {                                                          \
                    return (ret);                                          \
                }                                                          \
                break;                                                     \
            }                                                              \
            default :                                                      \
            {                                                              \
                return (ret);                                              \
            }                                                              \
        }                                                                  \
                                                                           \
        /*                                                                 \
         *  Advance pointer.                                               \
         */                                                                \
        ptr++;                                                             \
    }                                                                      \
                                                                           \
    /*                                                                     \
     *  Need to check diacritic, case, extra, and special weights for      \
     *  final return value.  Still could be equal if the longer part of    \
     *  the string contained only unsortable characters.                   \
     *                                                                     \
     *  NOTE:  The following checks MUST REMAIN IN THIS ORDER:             \
     *            Diacritic, Case, Extra, Punctuation.                     \
     */                                                                    \
    if (WhichDiacritic)                                                    \
    {                                                                      \
        return (WhichDiacritic);                                           \
    }                                                                      \
    if (WhichCase)                                                         \
    {                                                                      \
        return (WhichCase);                                                \
    }                                                                      \
    if (WhichExtra)                                                        \
    {                                                                      \
        if (GET_WT_FOUR(&WhichExtra))                                      \
        {                                                                  \
            return (GET_WT_FOUR(&WhichExtra));                             \
        }                                                                  \
        if (GET_WT_FIVE(&WhichExtra))                                      \
        {                                                                  \
            return (GET_WT_FIVE(&WhichExtra));                             \
        }                                                                  \
        if (GET_WT_SIX(&WhichExtra))                                       \
        {                                                                  \
            return (GET_WT_SIX(&WhichExtra));                              \
        }                                                                  \
        if (GET_WT_SEVEN(&WhichExtra))                                     \
        {                                                                  \
            return (GET_WT_SEVEN(&WhichExtra));                            \
        }                                                                  \
    }                                                                      \
    if (WhichJamo)                                                         \
    {                                                                      \
        return (WhichJamo);                                                \
    }                                                                      \
    if (WhichPunct1)                                                       \
    {                                                                      \
        return (WhichPunct1);                                              \
    }                                                                      \
    if (WhichPunct2)                                                       \
    {                                                                      \
        return (WhichPunct2);                                              \
    }                                                                      \
                                                                           \
    return (CSTR_EQUAL);                                                   \
}


////////////////////////////////////////////////////////////////////////////
//
//  GET_FAREAST_WEIGHT
//
//  Returns the weight for the far east special case in "wt".  This currently
//  includes the Cho-on, the Repeat, and the Kana characters.
//
//  08-19-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define GET_FAREAST_WEIGHT( wt,                                            \
                            uw,                                            \
                            mask,                                          \
                            pBegin,                                        \
                            pCur,                                          \
                            ExtraWt,                                       \
                            fModify )                                      \
{                                                                          \
    int ct;                       /* loop counter */                       \
    BYTE PrevSM;                  /* previous script member value */       \
    BYTE PrevAW;                  /* previous alphanumeric value */        \
    BYTE PrevCW;                  /* previous case value */                \
    BYTE AW;                      /* alphanumeric value */                 \
    BYTE CW;                      /* case value */                         \
    DWORD PrevWt;                 /* previous weight */                    \
                                                                           \
                                                                           \
    /*                                                                     \
     *  Get the alphanumeric weight and the case weight of the             \
     *  current code point.                                                \
     */                                                                    \
    AW = GET_ALPHA_NUMERIC(&wt);                                           \
    CW = GET_CASE(&wt);                                                    \
    ExtraWt = (DWORD)0;                                                    \
                                                                           \
    /*                                                                     \
     *  Special case Repeat and Cho-On.                                    \
     *    AW = 0  =>  Repeat                                               \
     *    AW = 1  =>  Cho-On                                               \
     *    AW = 2+ =>  Kana                                                 \
     */                                                                    \
    if (AW <= MAX_SPECIAL_AW)                                              \
    {                                                                      \
        /*                                                                 \
         *  If the script member of the previous character is              \
         *  invalid, then give the special character an                    \
         *  invalid weight (highest possible weight) so that it            \
         *  will sort AFTER everything else.                               \
         */                                                                \
        ct = 1;                                                            \
        PrevWt = CMP_INVALID_FAREAST;                                      \
        while ((pCur - ct) >= pBegin)                                      \
        {                                                                  \
            PrevWt = GET_DWORD_WEIGHT(pHashN, *(pCur - ct));               \
            PrevWt &= mask;                                                \
            PrevSM = GET_SCRIPT_MEMBER(&PrevWt);                           \
            if (PrevSM < FAREAST_SPECIAL)                                  \
            {                                                              \
                if (PrevSM == EXPANSION)                                   \
                {                                                          \
                    PrevWt = CMP_INVALID_FAREAST;                          \
                }                                                          \
                else                                                       \
                {                                                          \
                    /*                                                     \
                     *  UNSORTABLE or NONSPACE_MARK.                       \
                     *                                                     \
                     *  Just ignore these, since we only care about the    \
                     *  previous UW value.                                 \
                     */                                                    \
                    PrevWt = CMP_INVALID_FAREAST;                          \
                    ct++;                                                  \
                    continue;                                              \
                }                                                          \
            }                                                              \
            else if (PrevSM == FAREAST_SPECIAL)                            \
            {                                                              \
                PrevAW = GET_ALPHA_NUMERIC(&PrevWt);                       \
                if (PrevAW <= MAX_SPECIAL_AW)                              \
                {                                                          \
                    /*                                                     \
                     *  Handle case where two special chars follow         \
                     *  each other.  Keep going back in the string.        \
                     */                                                    \
                    PrevWt = CMP_INVALID_FAREAST;                          \
                    ct++;                                                  \
                    continue;                                              \
                }                                                          \
                                                                           \
                UNICODE_WT(&PrevWt) =                                      \
                    MAKE_UNICODE_WT(KANA, PrevAW, fModify);                \
                                                                           \
                /*                                                         \
                 *  Only build weights 4, 5, 6, and 7 if the               \
                 *  previous character is KANA.                            \
                 *                                                         \
                 *  Always:                                                \
                 *    4W = previous CW  &  ISOLATE_SMALL                   \
                 *    6W = previous CW  &  ISOLATE_KANA                    \
                 *                                                         \
                 */                                                        \
                PrevCW = GET_CASE(&PrevWt);                                \
                GET_WT_FOUR(&ExtraWt) = PrevCW & ISOLATE_SMALL;            \
                GET_WT_SIX(&ExtraWt)  = PrevCW & ISOLATE_KANA;             \
                                                                           \
                if (AW == AW_REPEAT)                                       \
                {                                                          \
                    /*                                                     \
                     *  Repeat:                                            \
                     *    UW = previous UW                                 \
                     *    5W = WT_FIVE_REPEAT                              \
                     *    7W = previous CW  &  ISOLATE_WIDTH               \
                     */                                                    \
                    uw = UNICODE_WT(&PrevWt);                              \
                    GET_WT_FIVE(&ExtraWt)  = WT_FIVE_REPEAT;               \
                    GET_WT_SEVEN(&ExtraWt) = PrevCW & ISOLATE_WIDTH;       \
                }                                                          \
                else                                                       \
                {                                                          \
                    /*                                                     \
                     *  Cho-On:                                            \
                     *    UW = previous UW  &  CHO_ON_UW_MASK              \
                     *    5W = WT_FIVE_CHO_ON                              \
                     *    7W = current  CW  &  ISOLATE_WIDTH               \
                     */                                                    \
                    uw = UNICODE_WT(&PrevWt) & CHO_ON_UW_MASK;             \
                    GET_WT_FIVE(&ExtraWt)  = WT_FIVE_CHO_ON;               \
                    GET_WT_SEVEN(&ExtraWt) = CW & ISOLATE_WIDTH;           \
                }                                                          \
            }                                                              \
            else                                                           \
            {                                                              \
                uw = GET_UNICODE_MOD(&PrevWt, fModify);                    \
            }                                                              \
                                                                           \
            break;                                                         \
        }                                                                  \
    }                                                                      \
    else                                                                   \
    {                                                                      \
        /*                                                                 \
         *  Kana:                                                          \
         *    SM = KANA                                                    \
         *    AW = current AW                                              \
         *    4W = current CW  &  ISOLATE_SMALL                            \
         *    5W = WT_FIVE_KANA                                            \
         *    6W = current CW  &  ISOLATE_KANA                             \
         *    7W = current CW  &  ISOLATE_WIDTH                            \
         */                                                                \
        uw = MAKE_UNICODE_WT(KANA, AW, fModify);                           \
        GET_WT_FOUR(&ExtraWt)  = CW & ISOLATE_SMALL;                       \
        GET_WT_FIVE(&ExtraWt)  = WT_FIVE_KANA;                             \
        GET_WT_SIX(&ExtraWt)   = CW & ISOLATE_KANA;                        \
        GET_WT_SEVEN(&ExtraWt) = CW & ISOLATE_WIDTH;                       \
    }                                                                      \
                                                                           \
    /*                                                                     \
     *  Get the weight for the far east special case and store it in wt.   \
     */                                                                    \
    if ((AW > MAX_SPECIAL_AW) || (PrevWt != CMP_INVALID_FAREAST))          \
    {                                                                      \
        /*                                                                 \
         *  Always:                                                        \
         *    DW = current DW                                              \
         *    CW = minimum CW                                              \
         */                                                                \
        UNICODE_WT(&wt) = uw;                                              \
        CASE_WT(&wt) = MIN_CW;                                             \
    }                                                                      \
    else                                                                   \
    {                                                                      \
        uw = CMP_INVALID_UW;                                               \
        wt = CMP_INVALID_FAREAST;                                          \
        ExtraWt = 0;                                                       \
    }                                                                      \
}




//-------------------------------------------------------------------------//
//                             API ROUTINES                                //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  CompareStringW
//
//  Compares two wide character strings of the same locale according to the
//  supplied locale handle.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WINAPI CompareStringW(
    LCID Locale,
    DWORD dwCmpFlags,
    LPCWSTR lpString1,
    int cchCount1,
    LPCWSTR lpString2,
    int cchCount2)
{
    register LPWSTR pString1;     // ptr to go thru string 1
    register LPWSTR pString2;     // ptr to go thru string 2
    PLOC_HASH pHashN;             // ptr to LOC hash node
    BOOL fIgnorePunct;            // flag to ignore punctuation (not symbol)
    BOOL fModify;                 // flag to use modified script member weights
    DWORD State;                  // state table
    DWORD Mask;                   // mask for weights
    DWORD Weight1;                // full weight of char - string 1
    DWORD Weight2;                // full weight of char - string 2

    int JamoFlag = FALSE;
    LPCWSTR pLastJamo = lpString1;

    int WhichDiacritic;           // DW => 1 = str1 smaller, 3 = str2 smaller
    int WhichCase;                // CW => 1 = str1 smaller, 3 = str2 smaller
    int WhichJamo;                // XW for Jamo
    int WhichPunct1;              // SW => 1 = str1 smaller, 3 = str2 smaller
    int WhichPunct2;              // SW => 1 = str1 smaller, 3 = str2 smaller
    LPWSTR pSave1;                // ptr to saved pString1
    LPWSTR pSave2;                // ptr to saved pString2
    int cExpChar1, cExpChar2;     // ct of expansions in tmp

    DWORD ExtraWt1, ExtraWt2;     // extra weight values (for far east)
    DWORD WhichExtra;             // XW => wts 4, 5, 6, 7 (for far east)

    //
    //  Invalid Parameter Check:
    //    - validate LCID
    //    - either string is null
    //
    VALIDATE_LANGUAGE(Locale, pHashN, 0, TRUE);
    if ((pHashN == NULL) ||
        (lpString1 == NULL) || (lpString2 == NULL))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Make sure the appropriate sorting tables are available.  If not,
    //  return an error.
    //
    if ((pHashN->pSortkey == NULL) ||
        (pHashN->IfIdeographFailure == TRUE))
    {
        KdPrint(("NLSAPI: Appropriate Sorting Tables Not Loaded.\n"));
        SetLastError(ERROR_FILE_NOT_FOUND);
        return (0);
    }

    //
    //  Call longer compare string if any of the following is true:
    //     - compression locale
    //     - either count is not -1
    //     - dwCmpFlags is not 0 or ignore case   (see NOTE below)
    //     - locale is Korean - script member weight adjustment needed
    //
    //  NOTE:  If the value of NORM_IGNORECASE ever changes, this
    //         code should check for:
    //            ( (dwCmpFlags != 0)  &&  (dwCmpFlags != NORM_IGNORECASE) )
    //         Since NORM_IGNORECASE is equal to 1, we can optimize this
    //         by checking for > 1.
    //
    dwCmpFlags &= (~LOCALE_USE_CP_ACP);
    fModify = IS_KOREAN(Locale);
    if ( (pHashN->IfCompression) ||
         (cchCount1 > -1) || (cchCount2 > -1) ||
         (dwCmpFlags > NORM_IGNORECASE) ||
         (fModify == TRUE) )
    {
        return (LongCompareStringW( pHashN,
                                    dwCmpFlags,
                                    lpString1,
                                    ((cchCount1 <= -1) ? -2 : cchCount1),
                                    lpString2,
                                    ((cchCount2 <= -1) ? -2 : cchCount2),
                                    fModify ));
    }

    //
    //  Initialize string pointers.
    //
    pString1 = (LPWSTR)lpString1;
    pString2 = (LPWSTR)lpString2;

    //
    //  Do a wchar by wchar compare.
    //
    while (TRUE)
    {
        //
        //  See if characters are equal.
        //  If characters are equal, increment pointers and continue
        //  string compare.
        //
        //  NOTE: Loop is unrolled 8 times for performance.
        //
        if ((*pString1 != *pString2) || (*pString1 == 0))
        {
            break;
        }
        pString1++;
        pString2++;

        if ((*pString1 != *pString2) || (*pString1 == 0))
        {
            break;
        }
        pString1++;
        pString2++;

        if ((*pString1 != *pString2) || (*pString1 == 0))
        {
            break;
        }
        pString1++;
        pString2++;

        if ((*pString1 != *pString2) || (*pString1 == 0))
        {
            break;
        }
        pString1++;
        pString2++;

        if ((*pString1 != *pString2) || (*pString1 == 0))
        {
            break;
        }
        pString1++;
        pString2++;

        if ((*pString1 != *pString2) || (*pString1 == 0))
        {
            break;
        }
        pString1++;
        pString2++;

        if ((*pString1 != *pString2) || (*pString1 == 0))
        {
            break;
        }
        pString1++;
        pString2++;

        if ((*pString1 != *pString2) || (*pString1 == 0))
        {
            break;
        }
        pString1++;
        pString2++;
    }

    //
    //  If strings are both at null terminators, return equal.
    //
    if (*pString1 == *pString2)
    {
        return (CSTR_EQUAL);
    }

    //
    //  Initialize flags, pointers, and counters.
    //
    fIgnorePunct = FALSE;
    WhichDiacritic = 0;
    WhichCase = 0;
    WhichJamo = 0;
    WhichPunct1 = 0;
    WhichPunct2 = 0;
    pSave1 = NULL;
    pSave2 = NULL;
    ExtraWt1 = (DWORD)0;
    WhichExtra = (DWORD)0;

    //
    //  Switch on the different flag options.  This will speed up
    //  the comparisons of two strings that are different.
    //
    //  The only two possibilities in this optimized section are
    //  no flags and the ignore case flag.
    //
    if (dwCmpFlags == 0)
    {
        Mask = CMP_MASKOFF_NONE;
    }
    else
    {
        Mask = CMP_MASKOFF_CW;
    }
    State = (pHashN->IfReverseDW) ? STATE_REVERSE_DW : STATE_DW;
    State |= (STATE_CW | STATE_JAMO_WEIGHT);

    //
    //  Compare each character's sortkey weight in the two strings.
    //
    while ((*pString1 != 0) && (*pString2 != 0))
    {
        Weight1 = GET_DWORD_WEIGHT(pHashN, *pString1);
        Weight2 = GET_DWORD_WEIGHT(pHashN, *pString2);
        Weight1 &= Mask;
        Weight2 &= Mask;

        if (Weight1 != Weight2)
        {
            BYTE sm1 = GET_SCRIPT_MEMBER(&Weight1);     // script member 1
            BYTE sm2 = GET_SCRIPT_MEMBER(&Weight2);     // script member 2
            WORD uw1 = GET_UNICODE_SM(&Weight1, sm1);   // unicode weight 1
            WORD uw2 = GET_UNICODE_SM(&Weight2, sm2);   // unicode weight 2
            BYTE dw1;                                   // diacritic weight 1
            BYTE dw2;                                   // diacritic weight 2
            BOOL fContinue;                             // flag to continue loop
            DWORD Wt;                                   // temp weight holder
            WCHAR pTmpBuf1[MAX_TBL_EXPANSION];          // temp buffer for exp 1
            WCHAR pTmpBuf2[MAX_TBL_EXPANSION];          // temp buffer for exp 2


            //
            //  If Unicode Weights are different and no special cases,
            //  then we're done.  Otherwise, we need to do extra checking.
            //
            //  Must check ENTIRE string for any possibility of Unicode Weight
            //  differences.  As soon as a Unicode Weight difference is found,
            //  then we're done.  If no UW difference is found, then the
            //  first Diacritic Weight difference is used.  If no DW difference
            //  is found, then use the first Case Difference.  If no CW
            //  difference is found, then use the first Extra Weight
            //  difference.  If no XW difference is found, then use the first
            //  Special Weight difference.
            //
            if ((uw1 != uw2) ||
                (sm1 == FAREAST_SPECIAL) ||
                (sm1 == EXTENSION_A))
            {
                //
                //  Initialize the continue flag.
                //
                fContinue = FALSE;

                //
                //  Check for Unsortable characters and skip them.
                //  This needs to be outside the switch statement.  If EITHER
                //  character is unsortable, must skip it and start over.
                //
                if (sm1 == UNSORTABLE)
                {
                    pString1++;
                    fContinue = TRUE;
                }
                if (sm2 == UNSORTABLE)
                {
                    pString2++;
                    fContinue = TRUE;
                }
                if (fContinue)
                {
                    continue;
                }

                //
                //  Switch on the script member of string 1 and take care
                //  of any special cases.
                //
                switch (sm1)
                {
                    case ( NONSPACE_MARK ) :
                    {
                        //
                        //  Nonspace only - look at diacritic weight only.
                        //
                        if ((WhichDiacritic == 0) ||
                            (State & STATE_REVERSE_DW))
                        {
                            WhichDiacritic = CSTR_GREATER_THAN;

                            //
                            //  Remove state from state machine.
                            //
                            REMOVE_STATE(STATE_DW);
                        }

                        //
                        //  Adjust pointer and set flags.
                        //
                        pString1++;
                        fContinue = TRUE;

                        break;
                    }
                    case ( PUNCTUATION ) :
                    {
                        //
                        //  If the ignore punctuation flag is set, then skip
                        //  over the punctuation.
                        //
                        if (fIgnorePunct)
                        {
                            pString1++;
                            fContinue = TRUE;
                        }
                        else if (sm2 != PUNCTUATION)
                        {
                            //
                            //  The character in the second string is
                            //  NOT punctuation.
                            //
                            if (WhichPunct2)
                            {
                                //
                                //  Set WP 2 to show that string 2 is smaller,
                                //  since a punctuation char had already been
                                //  found at an earlier position in string 2.
                                //
                                //  Set the Ignore Punctuation flag so we just
                                //  skip over any other punctuation chars in
                                //  the string.
                                //
                                WhichPunct2 = CSTR_GREATER_THAN;
                                fIgnorePunct = TRUE;
                            }
                            else
                            {
                                //
                                //  Set WP 1 to show that string 2 is smaller,
                                //  and that string 1 has had a punctuation
                                //  char - since no punctuation chars have
                                //  been found in string 2.
                                //
                                WhichPunct1 = CSTR_GREATER_THAN;
                            }

                            //
                            //  Advance pointer 1, and set flag to true.
                            //
                            pString1++;
                            fContinue = TRUE;
                        }

                        //
                        //  Do NOT want to advance the pointer in string 1 if
                        //  string 2 is also a punctuation char.  This will
                        //  be done later.
                        //
                        break;
                    }
                    case ( EXPANSION ) :
                    {
                        //
                        //  Save pointer in pString1 so that it can be
                        //  restored.
                        //
                        if (pSave1 == NULL)
                        {
                            pSave1 = pString1;
                        }
                        pString1 = pTmpBuf1;

                        //
                        //  Expand character into temporary buffer.
                        //
                        pTmpBuf1[0] = GET_EXPANSION_1(&Weight1);
                        pTmpBuf1[1] = GET_EXPANSION_2(&Weight1);

                        //
                        //  Set cExpChar1 to the number of expansion characters
                        //  stored.
                        //
                        cExpChar1 = MAX_TBL_EXPANSION;

                        fContinue = TRUE;

                        break;
                    }
                    case ( FAREAST_SPECIAL ) :
                    {
                        if (sm2 != EXPANSION) 
                        {
                            //
                            //  Get the weight for the far east special case
                            //  and store it in Weight1.
                            //
                            GET_FAREAST_WEIGHT( Weight1,
                                                uw1,
                                                Mask,
                                                lpString1,
                                                pString1,
                                                ExtraWt1,
                                                FALSE );

                            if (sm2 != FAREAST_SPECIAL)
                            {
                                //
                                //  The character in the second string is
                                //  NOT a fareast special char.
                                //
                                //  Set each of weights 4, 5, 6, and 7 to show
                                //  that string 2 is smaller (if not already set).
                                //
                                if ((GET_WT_FOUR(&WhichExtra) == 0) &&
                                    (GET_WT_FOUR(&ExtraWt1) != 0))
                                {
                                    GET_WT_FOUR(&WhichExtra) = CSTR_GREATER_THAN;
                                }
                                if ((GET_WT_FIVE(&WhichExtra) == 0) &&
                                    (GET_WT_FIVE(&ExtraWt1) != 0))
                                {
                                    GET_WT_FIVE(&WhichExtra) = CSTR_GREATER_THAN;
                                }
                                if ((GET_WT_SIX(&WhichExtra) == 0) &&
                                    (GET_WT_SIX(&ExtraWt1) != 0))
                                {
                                    GET_WT_SIX(&WhichExtra) = CSTR_GREATER_THAN;
                                }
                                if ((GET_WT_SEVEN(&WhichExtra) == 0) &&
                                    (GET_WT_SEVEN(&ExtraWt1) != 0))
                                {
                                    GET_WT_SEVEN(&WhichExtra) = CSTR_GREATER_THAN;
                                }
                            }
                        }
                        break;
                    }
                    case ( JAMO_SPECIAL ) :
                    {
                        int ctr1;     // dummy variables for FindJamoDifference
                        LPWSTR pStr1 = pString1;
                        LPWSTR pStr2 = pString2;

                        //
                        //  Set the JamoFlag so we don't handle it again.
                        //
                        JamoFlag = TRUE;
                        fContinue = FindJamoDifference(
                            pHashN,
                            &pStr1, &ctr1, -2, &Weight1,
                            &pStr2, &ctr1, -2, &Weight2,
                            &pLastJamo,
                            &uw1, &uw2,
                            &State,
                            &WhichJamo,
                            fModify );
                        if (WhichJamo)
                        {
                            return (WhichJamo);
                        }    

                        pString1 = pStr1;
                        pString2 = pStr2;

                        break;
                    }
                    case ( EXTENSION_A ) :
                    {
                        //
                        //  Compare the weights.
                        //
                        if (Weight1 == Weight2)
                        {
                            //
                            //  Adjust pointers and set flag.
                            //
                            pString1++;  pString2++;
                            fContinue = TRUE;
                        }
                        else
                        {
                            //
                            //  Get the actual UW to compare.
                            //
                            if (sm2 == EXTENSION_A)
                            {
                                //
                                //  Set the UW values to be the AW and DW since
                                //  both strings contain an extension A char.
                                //
                                uw1 = MAKE_UNICODE_WT( GET_ALPHA_NUMERIC(&Weight1),
                                                       GET_DIACRITIC(&Weight1),
                                                       FALSE );
                                uw2 = MAKE_UNICODE_WT( GET_ALPHA_NUMERIC(&Weight2),
                                                       GET_DIACRITIC(&Weight2),
                                                       FALSE );
                            }
                            else
                            {
                                //
                                //  Only string1 contains an extension A char,
                                //  so set the UW value to be the first UW
                                //  value for extension A (default values):
                                //    SM_EXT_A, AW_EXT_A
                                //
                                uw1 = MAKE_UNICODE_WT(SM_EXT_A, AW_EXT_A, fModify);
                            }
                        }

                        break;
                    }
                    case ( UNSORTABLE ) :
                    {
                        //
                        //  Fill out the case statement so the compiler
                        //  will use a jump table.
                        //
                        break;
                    }
                }

                //
                //  Switch on the script member of string 2 and take care
                //  of any special cases.
                //
                switch (sm2)
                {
                    case ( NONSPACE_MARK ) :
                    {
                        //
                        //  Nonspace only - look at diacritic weight only.
                        //
                        if ((WhichDiacritic == 0) ||
                            (State & STATE_REVERSE_DW))
                        {
                            WhichDiacritic = CSTR_LESS_THAN;

                            //
                            //  Remove state from state machine.
                            //
                            REMOVE_STATE(STATE_DW);
                        }

                        //
                        //  Adjust pointer and set flags.
                        //
                        pString2++;
                        fContinue = TRUE;

                        break;
                    }
                    case ( PUNCTUATION ) :
                    {
                        //
                        //  If the ignore punctuation flag is set, then skip
                        //  over the punctuation.
                        //
                        if (fIgnorePunct)
                        {
                            //
                            //  Pointer 2 will be advanced after if-else
                            //  statement.
                            //
                            ;
                        }
                        else if (sm1 != PUNCTUATION)
                        {
                            //
                            //  The character in the first string is
                            //  NOT punctuation.
                            //
                            if (WhichPunct1)
                            {
                                //
                                //  Set WP 1 to show that string 1 is smaller,
                                //  since a punctuation char had already
                                //  been found at an earlier position in
                                //  string 1.
                                //
                                //  Set the Ignore Punctuation flag so we just
                                //  skip over any other punctuation in the
                                //  string.
                                //
                                WhichPunct1 = CSTR_LESS_THAN;
                                fIgnorePunct = TRUE;
                            }
                            else
                            {
                                //
                                //  Set WP 2 to show that string 1 is smaller,
                                //  and that string 2 has had a punctuation
                                //  char - since no punctuation chars have
                                //  been found in string 1.
                                //
                                WhichPunct2 = CSTR_LESS_THAN;
                            }

                            //
                            //  Pointer 2 will be advanced after if-else
                            //  statement.
                            //
                        }
                        else
                        {
                            //
                            //  Both code points are punctuation.
                            //
                            //  See if either of the strings has encountered
                            //  punctuation chars previous to this.
                            //
                            if (WhichPunct1)
                            {
                                //
                                //  String 1 has had a punctuation char, so
                                //  it should be the smaller string (since
                                //  both have punctuation chars).
                                //
                                WhichPunct1 = CSTR_LESS_THAN;
                            }
                            else if (WhichPunct2)
                            {
                                //
                                //  String 2 has had a punctuation char, so
                                //  it should be the smaller string (since
                                //  both have punctuation chars).
                                //
                                WhichPunct2 = CSTR_GREATER_THAN;
                            }
                            else
                            {
                                //
                                //  Position is the same, so compare the
                                //  special weights.  Set WhichPunct1 to
                                //  the smaller special weight.
                                //
                                WhichPunct1 = (((GET_ALPHA_NUMERIC(&Weight1) <
                                                 GET_ALPHA_NUMERIC(&Weight2)))
                                                 ? CSTR_LESS_THAN
                                                 : CSTR_GREATER_THAN);
                            }

                            //
                            //  Set the Ignore Punctuation flag so we just
                            //  skip over any other punctuation in the string.
                            //
                            fIgnorePunct = TRUE;

                            //
                            //  Advance pointer 1.  Pointer 2 will be
                            //  advanced after if-else statement.
                            //
                            pString1++;
                        }

                        //
                        //  Advance pointer 2 and set flag to true.
                        //
                        pString2++;
                        fContinue = TRUE;

                        break;
                    }
                    case ( EXPANSION ) :
                    {
                        //
                        //  Save pointer in pString1 so that it can be
                        //  restored.
                        //
                        if (pSave2 == NULL)
                        {
                            pSave2 = pString2;
                        }
                        pString2 = pTmpBuf2;

                        //
                        //  Expand character into temporary buffer.
                        //
                        pTmpBuf2[0] = GET_EXPANSION_1(&Weight2);
                        pTmpBuf2[1] = GET_EXPANSION_2(&Weight2);

                        //
                        //  Set cExpChar2 to the number of expansion characters
                        //  stored.
                        //
                        cExpChar2 = MAX_TBL_EXPANSION;

                        fContinue = TRUE;

                        break;
                    }
                    case ( FAREAST_SPECIAL ) :
                    {
                        if (sm1 != EXPANSION) 
                        {
                            //
                            //  Get the weight for the far east special case
                            //  and store it in Weight2.
                            //
                            GET_FAREAST_WEIGHT( Weight2,
                                                uw2,
                                                Mask,
                                                lpString2,
                                                pString2,
                                                ExtraWt2,
                                                FALSE );

                            if (sm1 != FAREAST_SPECIAL)
                            {
                                //
                                //  The character in the first string is
                                //  NOT a fareast special char.
                                //
                                //  Set each of weights 4, 5, 6, and 7 to show
                                //  that string 1 is smaller (if not already set).
                                //
                                if ((GET_WT_FOUR(&WhichExtra) == 0) &&
                                    (GET_WT_FOUR(&ExtraWt2) != 0))
                                {
                                    GET_WT_FOUR(&WhichExtra) = CSTR_LESS_THAN;
                                }
                                if ((GET_WT_FIVE(&WhichExtra) == 0) &&
                                    (GET_WT_FIVE(&ExtraWt2) != 0))
                                {
                                    GET_WT_FIVE(&WhichExtra) = CSTR_LESS_THAN;
                                }
                                if ((GET_WT_SIX(&WhichExtra) == 0) &&
                                    (GET_WT_SIX(&ExtraWt2) != 0))
                                {
                                    GET_WT_SIX(&WhichExtra) = CSTR_LESS_THAN;
                                }
                                if ((GET_WT_SEVEN(&WhichExtra) == 0) &&
                                    (GET_WT_SEVEN(&ExtraWt2) != 0))
                                {
                                    GET_WT_SEVEN(&WhichExtra) = CSTR_LESS_THAN;
                                }
                            }
                            else
                            {
                                //
                                //  Characters in both strings are fareast
                                //  special chars.
                                //
                                //  Set each of weights 4, 5, 6, and 7
                                //  appropriately (if not already set).
                                //
                                if ( (GET_WT_FOUR(&WhichExtra) == 0) &&
                                     ( GET_WT_FOUR(&ExtraWt1) !=
                                       GET_WT_FOUR(&ExtraWt2) ) )
                                {
                                    GET_WT_FOUR(&WhichExtra) =
                                      ( GET_WT_FOUR(&ExtraWt1) <
                                        GET_WT_FOUR(&ExtraWt2) )
                                      ? CSTR_LESS_THAN
                                      : CSTR_GREATER_THAN;
                                }
                                if ( (GET_WT_FIVE(&WhichExtra) == 0) &&
                                     ( GET_WT_FIVE(&ExtraWt1) !=
                                       GET_WT_FIVE(&ExtraWt2) ) )
                                {
                                    GET_WT_FIVE(&WhichExtra) =
                                      ( GET_WT_FIVE(&ExtraWt1) <
                                        GET_WT_FIVE(&ExtraWt2) )
                                      ? CSTR_LESS_THAN
                                      : CSTR_GREATER_THAN;
                                }
                                if ( (GET_WT_SIX(&WhichExtra) == 0) &&
                                     ( GET_WT_SIX(&ExtraWt1) !=
                                       GET_WT_SIX(&ExtraWt2) ) )
                                {
                                    GET_WT_SIX(&WhichExtra) =
                                      ( GET_WT_SIX(&ExtraWt1) <
                                        GET_WT_SIX(&ExtraWt2) )
                                      ? CSTR_LESS_THAN
                                      : CSTR_GREATER_THAN;
                                }
                                if ( (GET_WT_SEVEN(&WhichExtra) == 0) &&
                                     ( GET_WT_SEVEN(&ExtraWt1) !=
                                       GET_WT_SEVEN(&ExtraWt2) ) )
                                {
                                    GET_WT_SEVEN(&WhichExtra) =
                                      ( GET_WT_SEVEN(&ExtraWt1) <
                                        GET_WT_SEVEN(&ExtraWt2) )
                                      ? CSTR_LESS_THAN
                                      : CSTR_GREATER_THAN;
                                }
                            }
                        }
                        break;
                    }
                    case ( JAMO_SPECIAL ) :
                    {
                        if (!JamoFlag)
                        {
                            int ctr1, ctr2;   // dummy variables for FindJamoDifference
                            LPWSTR pStr1 = pString1;
                            LPWSTR pStr2 = pString2;

                            //
                            //  Set the JamoFlag so we don't handle it again.
                            //
                            JamoFlag = TRUE;
                            fContinue = FindJamoDifference(
                                pHashN,
                                &pStr1, &ctr1, -2, &Weight1,
                                &pStr2, &ctr2, -2, &Weight2,
                                &pLastJamo,
                                &uw1, &uw2,
                                &State,
                                &WhichJamo,
                                fModify );
                            if (WhichJamo)
                            {
                                return (WhichJamo);
                            }
                            pString1 = pStr1;
                            pString2 = pStr2;
                        }
                        else
                        {
                            JamoFlag = FALSE;
                        }

                        break;
                    }
                    case ( EXTENSION_A ) :
                    {
                        //
                        //  If sm1 is an extension A character, then
                        //  both sm1 and sm2 have been handled.  We should
                        //  only get here when either sm1 is not an
                        //  extension A character or the two extension A
                        //  characters are different.
                        //
                        if (sm1 != EXTENSION_A)
                        {
                            //
                            //  Get the actual UW to compare.
                            //
                            //  Only string2 contains an extension A char,
                            //  so set the UW value to be the first UW
                            //  value for extension A (default values):
                            //    SM_EXT_A, AW_EXT_A
                            //
                            uw2 = MAKE_UNICODE_WT(SM_EXT_A, AW_EXT_A, fModify);
                        }

                        //
                        //  We should then fall through to the comparison
                        //  of the Unicode weights.
                        //

                        break;
                    }
                    case ( UNSORTABLE ) :
                    {
                        //
                        //  Fill out the case statement so the compiler
                        //  will use a jump table.
                        //
                        break;
                    }
                }

                //
                //  See if the comparison should start again.
                //
                if (fContinue)
                {
                    continue;
                }

                //
                //  We're not supposed to drop down into the state table if
                //  unicode weights are different, so stop comparison and
                //  return result of unicode weight comparison.
                //
                if (uw1 != uw2)
                {
                    return ((uw1 < uw2) ? CSTR_LESS_THAN : CSTR_GREATER_THAN);
                }
            }

            //
            //  For each state in the state table, do the appropriate
            //  comparisons.     (UW1 == UW2)
            //
            if (State & (STATE_DW | STATE_REVERSE_DW))
            {
                //
                //  Get the diacritic weights.
                //
                dw1 = GET_DIACRITIC(&Weight1);
                dw2 = GET_DIACRITIC(&Weight2);

                if (dw1 != dw2)
                {
                    //
                    //  Look ahead to see if diacritic follows a
                    //  minimum diacritic weight.  If so, get the
                    //  diacritic weight of the nonspace mark.
                    //
                    while (*(pString1 + 1) != 0)
                    {
                        Wt = GET_DWORD_WEIGHT(pHashN, *(pString1 + 1));
                        if (GET_SCRIPT_MEMBER(&Wt) == NONSPACE_MARK)
                        {
                            dw1 += GET_DIACRITIC(&Wt);
                            pString1++;
                        }
                        else
                        {
                            break;
                        }
                    }

                    while (*(pString2 + 1) != 0)
                    {
                        Wt = GET_DWORD_WEIGHT(pHashN, *(pString2 + 1));
                        if (GET_SCRIPT_MEMBER(&Wt) == NONSPACE_MARK)
                        {
                            dw2 += GET_DIACRITIC(&Wt);
                            pString2++;
                        }
                        else
                        {
                            break;
                        }
                    }

                    //
                    //  Save which string has the smaller diacritic
                    //  weight if the diacritic weights are still
                    //  different.
                    //
                    if (dw1 != dw2)
                    {
                        WhichDiacritic = (dw1 < dw2)
                                           ? CSTR_LESS_THAN
                                           : CSTR_GREATER_THAN;

                        //
                        //  Remove state from state machine.
                        //
                        REMOVE_STATE(STATE_DW);
                    }
                }
            }
            if (State & STATE_CW)
            {
                //
                //  Get the case weights.
                //
                if (GET_CASE(&Weight1) != GET_CASE(&Weight2))
                {
                    //
                    //  Save which string has the smaller case weight.
                    //
                    WhichCase = (GET_CASE(&Weight1) < GET_CASE(&Weight2))
                                  ? CSTR_LESS_THAN
                                  : CSTR_GREATER_THAN;

                    //
                    //  Remove state from state machine.
                    //
                    REMOVE_STATE(STATE_CW);
                }
            }
        }

        //
        //  Fixup the pointers.
        //
        POINTER_FIXUP();
    }

    //
    //  If the end of BOTH strings has been reached, then the unicode
    //  weights match exactly.  Check the diacritic, case and special
    //  weights.  If all are zero, then return success.  Otherwise,
    //  return the result of the weight difference.
    //
    //  NOTE:  The following checks MUST REMAIN IN THIS ORDER:
    //            Diacritic, Case, Punctuation.
    //
    if (*pString1 == 0)
    {
        if (*pString2 == 0)
        {
            if (WhichDiacritic)
            {
                return (WhichDiacritic);
            }
            if (WhichCase)
            {
                return (WhichCase);
            }
            if (WhichExtra)
            {
                if (GET_WT_FOUR(&WhichExtra))
                {
                    return (GET_WT_FOUR(&WhichExtra));
                }
                if (GET_WT_FIVE(&WhichExtra))
                {
                    return (GET_WT_FIVE(&WhichExtra));
                }
                if (GET_WT_SIX(&WhichExtra))
                {
                    return (GET_WT_SIX(&WhichExtra));
                }
                if (GET_WT_SEVEN(&WhichExtra))
                {
                    return (GET_WT_SEVEN(&WhichExtra));
                }
            }
            if (WhichPunct1)
            {
                return (WhichPunct1);
            }
            if (WhichPunct2)
            {
                return (WhichPunct2);
            }

            return (CSTR_EQUAL);
        }
        else
        {
            //
            //  String 2 is longer.
            //
            pString1 = pString2;
        }
    }

    //
    //  Scan to the end of the longer string.
    //
    QUICK_SCAN_LONGER_STRING( pString1,
                              ((*pString2 == 0)
                                ? CSTR_GREATER_THAN
                                : CSTR_LESS_THAN) );
}


////////////////////////////////////////////////////////////////////////////
//
//  GetStringTypeExW
//
//  Returns character type information about a particular Unicode string.
//
//  01-18-94    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI GetStringTypeExW(
    LCID Locale,
    DWORD dwInfoType,
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPWORD lpCharType)
{
    PLOC_HASH pHashN;             // ptr to LOC hash node


    //
    //  Invalid Parameter Check:
    //    - Validate LCID
    //
    VALIDATE_LOCALE(Locale, pHashN, FALSE);
    if (pHashN == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    //
    //  Return the result of GetStringTypeW.
    //
    return (GetStringTypeW( dwInfoType,
                            lpSrcStr,
                            cchSrc,
                            lpCharType ));
}


////////////////////////////////////////////////////////////////////////////
//
//  GetStringTypeW
//
//  Returns character type information about a particular Unicode string.
//
//  NOTE:  The number of parameters is different from GetStringTypeA.
//         The 16-bit OLE product shipped GetStringTypeA with the wrong
//         parameters (ported from Chicago) and now we must support it.
//
//         Use GetStringTypeEx to get the same set of parameters between
//         the A and W version.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI GetStringTypeW(
    DWORD dwInfoType,
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPWORD lpCharType)
{
    int Ctr;                      // loop counter


    //
    //  Invalid Parameter Check:
    //    - lpSrcStr NULL
    //    - cchSrc is 0
    //    - lpCharType NULL
    //    - same buffer - src and destination
    //    - (flags will be checked in switch statement below)
    //
    if ( (lpSrcStr == NULL) || (cchSrc == 0) ||
         (lpCharType == NULL) || (lpSrcStr == lpCharType) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    //  If cchSrc is -1, then the source string is null terminated and we
    //  need to get the length of the source string.  Add one to the
    //  length to include the null termination.
    //  (This will always be at least 1.)
    //
    if (cchSrc <= -1)
    {
        cchSrc = NlsStrLenW(lpSrcStr) + 1;
    }

    //
    //  Make sure the ctype table is mapped in.
    //
    if (GetCTypeFileInfo())
    {
        SetLastError(ERROR_FILE_NOT_FOUND);
        return (FALSE);
    }

    //
    //  Return the appropriate information in the lpCharType parameter
    //  based on the dwInfoType parameter.
    //
    switch (dwInfoType)
    {
        case ( CT_CTYPE1 ) :
        {
            //
            //  Return the ctype 1 information for the string.
            //
            for (Ctr = 0; Ctr < cchSrc; Ctr++)
            {
                lpCharType[Ctr] = GET_CTYPE(lpSrcStr[Ctr], CType1);
            }
            break;
        }
        case ( CT_CTYPE2 ) :
        {
            //
            //  Return the ctype 2 information.
            //
            for (Ctr = 0; Ctr < cchSrc; Ctr++)
            {
                lpCharType[Ctr] = GET_CTYPE(lpSrcStr[Ctr], CType2);
            }
            break;
        }
        case ( CT_CTYPE3 ) :
        {
            //
            //  Return the ctype 3 information.
            //
            for (Ctr = 0; Ctr < cchSrc; Ctr++)
            {
                lpCharType[Ctr] = GET_CTYPE(lpSrcStr[Ctr], CType3);
            }
            break;
        }
        default :
        {
            //
            //  Invalid flag parameter, so return failure.
            //
            SetLastError(ERROR_INVALID_FLAGS);
            return (FALSE);
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}




//-------------------------------------------------------------------------//
//                           INTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  LongCompareStringW
//
//  Compares two wide character strings of the same locale according to the
//  supplied locale handle.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int LongCompareStringW(
    PLOC_HASH pHashN,
    DWORD dwCmpFlags,
    LPCWSTR lpString1,
    int cchCount1,
    LPCWSTR lpString2,
    int cchCount2,
    BOOL fModify)
{
    int ctr1 = cchCount1;         // loop counter for string 1
    int ctr2 = cchCount2;         // loop counter for string 2
    register LPWSTR pString1;     // ptr to go thru string 1
    register LPWSTR pString2;     // ptr to go thru string 2
    BOOL IfCompress;              // if compression in locale
    BOOL IfDblCompress1;          // if double compression in string 1
    BOOL IfDblCompress2;          // if double compression in string 2
    BOOL fEnd1;                   // if at end of string 1
    BOOL fIgnorePunct;            // flag to ignore punctuation (not symbol)
    BOOL fIgnoreDiacritic;        // flag to ignore diacritics
    BOOL fIgnoreSymbol;           // flag to ignore symbols
    BOOL fStringSort;             // flag to use string sort
    DWORD State;                  // state table
    DWORD Mask;                   // mask for weights
    DWORD Weight1;                // full weight of char - string 1
    DWORD Weight2;                // full weight of char - string 2

    int JamoFlag = FALSE;
    LPCWSTR pLastJamo = lpString1;

    int WhichDiacritic;           // DW => 1 = str1 smaller, 3 = str2 smaller
    int WhichCase;                // CW => 1 = str1 smaller, 3 = str2 smaller
    int WhichJamo;                // XW for Jamo
    int WhichPunct1;              // SW => 1 = str1 smaller, 3 = str2 smaller
    int WhichPunct2;              // SW => 1 = str1 smaller, 3 = str2 smaller
    LPWSTR pSave1;                // ptr to saved pString1
    LPWSTR pSave2;                // ptr to saved pString2
    int cExpChar1, cExpChar2;     // ct of expansions in tmp

    DWORD ExtraWt1, ExtraWt2;     // extra weight values (for far east)
    DWORD WhichExtra;             // XW => wts 4, 5, 6, 7 (for far east)

    //
    //  Initialize string pointers.
    //
    pString1 = (LPWSTR)lpString1;
    pString2 = (LPWSTR)lpString2;

    //
    //  Invalid Flags Check:
    //    - invalid flags
    //
    if (dwCmpFlags & CS_INVALID_FLAG)
    {
        SetLastError(ERROR_INVALID_FLAGS);
        return (0);
    }

    //
    //  See if we should stop on the null terminator regardless of the
    //  count values.  The original count values are stored in ctr1 and ctr2
    //  above, so it's ok to set these here.
    //
    if (dwCmpFlags & NORM_STOP_ON_NULL)
    {
        cchCount1 = cchCount2 = -2;
    }

    //
    //  Check if compression in the given locale.  If not, then
    //  try a wchar by wchar compare.  If strings are equal, this
    //  will be quick.
    //
    if ((IfCompress = pHashN->IfCompression) == FALSE)
    {
        //
        //  Compare each wide character in the two strings.
        //
        while ( NOT_END_STRING(ctr1, pString1, cchCount1) &&
                NOT_END_STRING(ctr2, pString2, cchCount2) )
        {
            //
            //  See if characters are equal.
            //
            if (*pString1 == *pString2)
            {
                //
                //  Characters are equal, so increment pointers,
                //  decrement counters, and continue string compare.
                //
                pString1++;
                pString2++;
                ctr1--;
                ctr2--;
            }
            else
            {
                //
                //  Difference was found.  Fall into the sortkey
                //  check below.
                //
                break;
            }
        }

        //
        //  If the end of BOTH strings has been reached, then the strings
        //  match exactly.  Return success.
        //
        if ( AT_STRING_END(ctr1, pString1, cchCount1) &&
             AT_STRING_END(ctr2, pString2, cchCount2) )
        {
            return (CSTR_EQUAL);
        }
    }

    //
    //  Initialize flags, pointers, and counters.
    //
    fIgnorePunct = dwCmpFlags & NORM_IGNORESYMBOLS;
    fIgnoreDiacritic = dwCmpFlags & NORM_IGNORENONSPACE;
    fIgnoreSymbol = fIgnorePunct;
    fStringSort = dwCmpFlags & SORT_STRINGSORT;
    WhichDiacritic = 0;
    WhichCase = 0;
    WhichJamo = 0;
    WhichPunct1 = 0;
    WhichPunct2 = 0;
    pSave1 = NULL;
    pSave2 = NULL;
    ExtraWt1 = (DWORD)0;
    WhichExtra = (DWORD)0;

    //
    //  Set the weights to be invalid.  This flags whether or not to
    //  recompute the weights next time through the loop.  It also flags
    //  whether or not to start over (continue) in the loop.
    //
    Weight1 = CMP_INVALID_WEIGHT;
    Weight2 = CMP_INVALID_WEIGHT;

    //
    //  Switch on the different flag options.  This will speed up
    //  the comparisons of two strings that are different.
    //
    State = STATE_CW | STATE_JAMO_WEIGHT;
    switch (dwCmpFlags & (NORM_IGNORECASE | NORM_IGNORENONSPACE))
    {
        case ( 0 ) :
        {
            Mask = CMP_MASKOFF_NONE;
            State |= (pHashN->IfReverseDW) ? STATE_REVERSE_DW : STATE_DW;

            break;
        }

        case ( NORM_IGNORECASE ) :
        {
            Mask = CMP_MASKOFF_CW;
            State |= (pHashN->IfReverseDW) ? STATE_REVERSE_DW : STATE_DW;

            break;
        }

        case ( NORM_IGNORENONSPACE ) :
        {
            Mask = CMP_MASKOFF_DW;

            break;
        }

        case ( NORM_IGNORECASE | NORM_IGNORENONSPACE ) :
        {
            Mask = CMP_MASKOFF_DW_CW;

            break;
        }
    }

    switch (dwCmpFlags & (NORM_IGNOREKANATYPE | NORM_IGNOREWIDTH))
    {
        case ( 0 ) :
        {
            break;
        }

        case ( NORM_IGNOREKANATYPE ) :
        {
            Mask &= CMP_MASKOFF_KANA;

            break;
        }

        case ( NORM_IGNOREWIDTH ) :
        {
            Mask &= CMP_MASKOFF_WIDTH;

            if (dwCmpFlags & NORM_IGNORECASE)
            {
                REMOVE_STATE(STATE_CW);
            }

            break;
        }

        case ( NORM_IGNOREKANATYPE | NORM_IGNOREWIDTH ) :
        {
            Mask &= CMP_MASKOFF_KANA_WIDTH;

            if (dwCmpFlags & NORM_IGNORECASE)
            {
                REMOVE_STATE(STATE_CW);
            }

            break;
        }
    }

    //
    //  Compare each character's sortkey weight in the two strings.
    //
    while ( NOT_END_STRING(ctr1, pString1, cchCount1) &&
            NOT_END_STRING(ctr2, pString2, cchCount2) )
    {
        if (Weight1 == CMP_INVALID_WEIGHT)
        {
            Weight1 = GET_DWORD_WEIGHT(pHashN, *pString1);
            Weight1 &= Mask;
        }
        if (Weight2 == CMP_INVALID_WEIGHT)
        {
            Weight2 = GET_DWORD_WEIGHT(pHashN, *pString2);
            Weight2 &= Mask;
        }

        //
        //  If compression locale, then need to check for compression
        //  characters even if the weights are equal.  If it's not a
        //  compression locale, then we don't need to check anything
        //  if the weights are equal.
        //
        if ( (IfCompress) &&
             (GET_COMPRESSION(&Weight1) || GET_COMPRESSION(&Weight2)) )
        {
            int ctr;                   // loop counter
            PCOMPRESS_3 pComp3;        // ptr to compress 3 table
            PCOMPRESS_2 pComp2;        // ptr to compress 2 table
            int If1;                   // if compression found in string 1
            int If2;                   // if compression found in string 2
            int CompVal;               // compression value
            int IfEnd1;                // if exists 1 more char in string 1
            int IfEnd2;                // if exists 1 more char in string 2


            //
            //  Check for compression in the weights.
            //
            If1 = GET_COMPRESSION(&Weight1);
            If2 = GET_COMPRESSION(&Weight2);
            CompVal = ((If1 > If2) ? If1 : If2);

            IfEnd1 = AT_STRING_END(ctr1 - 1, pString1 + 1, cchCount1);
            IfEnd2 = AT_STRING_END(ctr2 - 1, pString2 + 1, cchCount2);

            if (pHashN->IfDblCompression == FALSE)
            {
                //
                //  NO double compression, so don't check for it.
                //
                switch (CompVal)
                {
                    //
                    //  Check for 3 characters compressing to 1.
                    //
                    case ( COMPRESS_3_MASK ) :
                    {
                        //
                        //  Check character in string 1 and string 2.
                        //
                        if ( ((If1) && (!IfEnd1) &&
                              !AT_STRING_END(ctr1 - 2, pString1 + 2, cchCount1)) ||
                             ((If2) && (!IfEnd2) &&
                              !AT_STRING_END(ctr2 - 2, pString2 + 2, cchCount2)) )
                        {
                            ctr = pHashN->pCompHdr->Num3;
                            pComp3 = pHashN->pCompress3;
                            for (; ctr > 0; ctr--, pComp3++)
                            {
                                //
                                //  Check character in string 1.
                                //
                                if ( (If1) && (!IfEnd1) &&
                                     !AT_STRING_END(ctr1 - 2, pString1 + 2, cchCount1) &&
                                     (pComp3->UCP1 == *pString1) &&
                                     (pComp3->UCP2 == *(pString1 + 1)) &&
                                     (pComp3->UCP3 == *(pString1 + 2)) )
                                {
                                    //
                                    //  Found compression for string 1.
                                    //  Get new weight and mask it.
                                    //  Increment pointer and decrement counter.
                                    //
                                    Weight1 = MAKE_SORTKEY_DWORD(pComp3->Weights);
                                    Weight1 &= Mask;
                                    pString1 += 2;
                                    ctr1 -= 2;

                                    //
                                    //  Set boolean for string 1 - search is
                                    //  complete.
                                    //
                                    If1 = 0;

                                    //
                                    //  Break out of loop if both searches are
                                    //  done.
                                    //
                                    if (If2 == 0)
                                    {
                                        break;
                                    }
                                }

                                //
                                //  Check character in string 2.
                                //
                                if ( (If2) && (!IfEnd2) &&
                                     !AT_STRING_END(ctr2 - 2, pString2 + 2, cchCount2) &&
                                     (pComp3->UCP1 == *pString2) &&
                                     (pComp3->UCP2 == *(pString2 + 1)) &&
                                     (pComp3->UCP3 == *(pString2 + 2)) )
                                {
                                    //
                                    //  Found compression for string 2.
                                    //  Get new weight and mask it.
                                    //  Increment pointer and decrement counter.
                                    //
                                    Weight2 = MAKE_SORTKEY_DWORD(pComp3->Weights);
                                    Weight2 &= Mask;
                                    pString2 += 2;
                                    ctr2 -= 2;

                                    //
                                    //  Set boolean for string 2 - search is
                                    //  complete.
                                    //
                                    If2 = 0;

                                    //
                                    //  Break out of loop if both searches are
                                    //  done.
                                    //
                                    if (If1 == 0)
                                    {
                                        break;
                                    }
                                }
                            }
                            if (ctr > 0)
                            {
                                break;
                            }
                        }
                        //
                        //  Fall through if not found.
                        //
                    }

                    //
                    //  Check for 2 characters compressing to 1.
                    //
                    case ( COMPRESS_2_MASK ) :
                    {
                        //
                        //  Check character in string 1 and string 2.
                        //
                        if ( ((If1) && (!IfEnd1)) ||
                             ((If2) && (!IfEnd2)) )
                        {
                            ctr = pHashN->pCompHdr->Num2;
                            pComp2 = pHashN->pCompress2;
                            for (; ((ctr > 0) && (If1 || If2)); ctr--, pComp2++)
                            {
                                //
                                //  Check character in string 1.
                                //
                                if ( (If1) &&
                                     (!IfEnd1) &&
                                     (pComp2->UCP1 == *pString1) &&
                                     (pComp2->UCP2 == *(pString1 + 1)) )
                                {
                                    //
                                    //  Found compression for string 1.
                                    //  Get new weight and mask it.
                                    //  Increment pointer and decrement counter.
                                    //
                                    Weight1 = MAKE_SORTKEY_DWORD(pComp2->Weights);
                                    Weight1 &= Mask;
                                    pString1++;
                                    ctr1--;

                                    //
                                    //  Set boolean for string 1 - search is
                                    //  complete.
                                    //
                                    If1 = 0;

                                    //
                                    //  Break out of loop if both searches are
                                    //  done.
                                    //
                                    if (If2 == 0)
                                    {
                                        break;
                                    }
                                }

                                //
                                //  Check character in string 2.
                                //
                                if ( (If2) &&
                                     (!IfEnd2) &&
                                     (pComp2->UCP1 == *pString2) &&
                                     (pComp2->UCP2 == *(pString2 + 1)) )
                                {
                                    //
                                    //  Found compression for string 2.
                                    //  Get new weight and mask it.
                                    //  Increment pointer and decrement counter.
                                    //
                                    Weight2 = MAKE_SORTKEY_DWORD(pComp2->Weights);
                                    Weight2 &= Mask;
                                    pString2++;
                                    ctr2--;

                                    //
                                    //  Set boolean for string 2 - search is
                                    //  complete.
                                    //
                                    If2 = 0;

                                    //
                                    //  Break out of loop if both searches are
                                    //  done.
                                    //
                                    if (If1 == 0)
                                    {
                                        break;
                                    }
                                }
                            }
                            if (ctr > 0)
                            {
                                break;
                            }
                        }
                    }
                }
            }
            else if (!IfEnd1 && !IfEnd2)
            {
                //
                //  Double Compression exists, so must check for it.
                //
                if (IfDblCompress1 =
                       ((GET_DWORD_WEIGHT(pHashN, *pString1) & CMP_MASKOFF_CW) ==
                        (GET_DWORD_WEIGHT(pHashN, *(pString1 + 1)) & CMP_MASKOFF_CW)))
                {
                    //
                    //  Advance past the first code point to get to the
                    //  compression character.
                    //
                    pString1++;
                    ctr1--;
                    IfEnd1 = AT_STRING_END(ctr1 - 1, pString1 + 1, cchCount1);
                }

                if (IfDblCompress2 =
                       ((GET_DWORD_WEIGHT(pHashN, *pString2) & CMP_MASKOFF_CW) ==
                        (GET_DWORD_WEIGHT(pHashN, *(pString2 + 1)) & CMP_MASKOFF_CW)))
                {
                    //
                    //  Advance past the first code point to get to the
                    //  compression character.
                    //
                    pString2++;
                    ctr2--;
                    IfEnd2 = AT_STRING_END(ctr2 - 1, pString2 + 1, cchCount2);
                }

                switch (CompVal)
                {
                    //
                    //  Check for 3 characters compressing to 1.
                    //
                    case ( COMPRESS_3_MASK ) :
                    {
                        //
                        //  Check character in string 1.
                        //
                        if ( (If1) && (!IfEnd1) &&
                             !AT_STRING_END(ctr1 - 2, pString1 + 2, cchCount1) )
                        {
                            ctr = pHashN->pCompHdr->Num3;
                            pComp3 = pHashN->pCompress3;
                            for (; ctr > 0; ctr--, pComp3++)
                            {
                                //
                                //  Check character in string 1.
                                //
                                if ( (pComp3->UCP1 == *pString1) &&
                                     (pComp3->UCP2 == *(pString1 + 1)) &&
                                     (pComp3->UCP3 == *(pString1 + 2)) )
                                {
                                    //
                                    //  Found compression for string 1.
                                    //  Get new weight and mask it.
                                    //  Increment pointer and decrement counter.
                                    //
                                    Weight1 = MAKE_SORTKEY_DWORD(pComp3->Weights);
                                    Weight1 &= Mask;
                                    if (!IfDblCompress1)
                                    {
                                        pString1 += 2;
                                        ctr1 -= 2;
                                    }

                                    //
                                    //  Set boolean for string 1 - search is
                                    //  complete.
                                    //
                                    If1 = 0;

                                    break;
                                }
                            }
                        }

                        //
                        //  Check character in string 2.
                        //
                        if ( (If2) && (!IfEnd2) &&
                             !AT_STRING_END(ctr2 - 2, pString2 + 2, cchCount2) )
                        {
                            ctr = pHashN->pCompHdr->Num3;
                            pComp3 = pHashN->pCompress3;
                            for (; ctr > 0; ctr--, pComp3++)
                            {
                                //
                                //  Check character in string 2.
                                //
                                if ( (pComp3->UCP1 == *pString2) &&
                                     (pComp3->UCP2 == *(pString2 + 1)) &&
                                     (pComp3->UCP3 == *(pString2 + 2)) )
                                {
                                    //
                                    //  Found compression for string 2.
                                    //  Get new weight and mask it.
                                    //  Increment pointer and decrement counter.
                                    //
                                    Weight2 = MAKE_SORTKEY_DWORD(pComp3->Weights);
                                    Weight2 &= Mask;
                                    if (!IfDblCompress2)
                                    {
                                        pString2 += 2;
                                        ctr2 -= 2;
                                    }

                                    //
                                    //  Set boolean for string 2 - search is
                                    //  complete.
                                    //
                                    If2 = 0;

                                    break;
                                }
                            }
                        }

                        //
                        //  Fall through if not found.
                        //
                        if ((If1 == 0) && (If2 == 0))
                        {
                            break;
                        }
                    }

                    //
                    //  Check for 2 characters compressing to 1.
                    //
                    case ( COMPRESS_2_MASK ) :
                    {
                        //
                        //  Check character in string 1.
                        //
                        if ((If1) && (!IfEnd1))
                        {
                            ctr = pHashN->pCompHdr->Num2;
                            pComp2 = pHashN->pCompress2;
                            for (; ctr > 0; ctr--, pComp2++)
                            {
                                //
                                //  Check character in string 1.
                                //
                                if ((pComp2->UCP1 == *pString1) &&
                                    (pComp2->UCP2 == *(pString1 + 1)))
                                {
                                    //
                                    //  Found compression for string 1.
                                    //  Get new weight and mask it.
                                    //  Increment pointer and decrement counter.
                                    //
                                    Weight1 = MAKE_SORTKEY_DWORD(pComp2->Weights);
                                    Weight1 &= Mask;
                                    if (!IfDblCompress1)
                                    {
                                        pString1++;
                                        ctr1--;
                                    }

                                    //
                                    //  Set boolean for string 1 - search is
                                    //  complete.
                                    //
                                    If1 = 0;

                                    break;
                                }
                            }
                        }

                        //
                        //  Check character in string 2.
                        //
                        if ((If2) && (!IfEnd2))
                        {
                            ctr = pHashN->pCompHdr->Num2;
                            pComp2 = pHashN->pCompress2;
                            for (; ctr > 0; ctr--, pComp2++)
                            {
                                //
                                //  Check character in string 2.
                                //
                                if ((pComp2->UCP1 == *pString2) &&
                                    (pComp2->UCP2 == *(pString2 + 1)))
                                {
                                    //
                                    //  Found compression for string 2.
                                    //  Get new weight and mask it.
                                    //  Increment pointer and decrement counter.
                                    //
                                    Weight2 = MAKE_SORTKEY_DWORD(pComp2->Weights);
                                    Weight2 &= Mask;
                                    if (!IfDblCompress2)
                                    {
                                        pString2++;
                                        ctr2--;
                                    }

                                    //
                                    //  Set boolean for string 2 - search is
                                    //  complete.
                                    //
                                    If2 = 0;

                                    break;
                                }
                            }
                        }
                    }
                }

                //
                //  Reset the pointer back to the beginning of the double
                //  compression.  Pointer fixup at the end will advance
                //  them correctly.
                //
                //  If double compression, we advanced the pointer at
                //  the beginning of the switch statement.  If double
                //  compression character was actually found, the pointer
                //  was NOT advanced.  We now want to decrement the pointer
                //  to put it back to where it was.
                //
                //  The next time through, the pointer will be pointing to
                //  the regular compression part of the string.
                //
                if (IfDblCompress1)
                {
                    pString1--;
                    ctr1++;
                }
                if (IfDblCompress2)
                {
                    pString2--;
                    ctr2++;
                }
            }
        }

        //
        //  Check the weights again.
        //
        if ((Weight1 != Weight2) ||
            (GET_SCRIPT_MEMBER(&Weight1) == EXTENSION_A))
        {
            //
            //  Weights are still not equal, even after compression
            //  check, so compare the different weights.
            //
            BYTE sm1 = GET_SCRIPT_MEMBER(&Weight1);                // script member 1
            BYTE sm2 = GET_SCRIPT_MEMBER(&Weight2);                // script member 2
            WORD uw1 = GET_UNICODE_SM_MOD(&Weight1, sm1, fModify); // unicode weight 1
            WORD uw2 = GET_UNICODE_SM_MOD(&Weight2, sm2, fModify); // unicode weight 2
            BYTE dw1;                                              // diacritic weight 1
            BYTE dw2;                                              // diacritic weight 2
            DWORD Wt;                                              // temp weight holder
            WCHAR pTmpBuf1[MAX_TBL_EXPANSION];                     // temp buffer for exp 1
            WCHAR pTmpBuf2[MAX_TBL_EXPANSION];                     // temp buffer for exp 2


            //
            //  If Unicode Weights are different and no special cases,
            //  then we're done.  Otherwise, we need to do extra checking.
            //
            //  Must check ENTIRE string for any possibility of Unicode Weight
            //  differences.  As soon as a Unicode Weight difference is found,
            //  then we're done.  If no UW difference is found, then the
            //  first Diacritic Weight difference is used.  If no DW difference
            //  is found, then use the first Case Difference.  If no CW
            //  difference is found, then use the first Extra Weight
            //  difference.  If no XW difference is found, then use the first
            //  Special Weight difference.
            //
            if ((uw1 != uw2) ||
                ((sm1 <= SYMBOL_5) && (sm1 >= FAREAST_SPECIAL)))
            {
                //
                //  Check for Unsortable characters and skip them.
                //  This needs to be outside the switch statement.  If EITHER
                //  character is unsortable, must skip it and start over.
                //
                if (sm1 == UNSORTABLE)
                {
                    pString1++;
                    ctr1--;
                    Weight1 = CMP_INVALID_WEIGHT;
                }
                if (sm2 == UNSORTABLE)
                {
                    pString2++;
                    ctr2--;
                    Weight2 = CMP_INVALID_WEIGHT;
                }

                //
                //  Check for Ignore Nonspace and Ignore Symbol.  If
                //  Ignore Nonspace is set and either character is a
                //  nonspace mark only, then we need to advance the
                //  pointer to skip over the character and continue.
                //  If Ignore Symbol is set and either character is a
                //  punctuation char, then we need to advance the
                //  pointer to skip over the character and continue.
                //
                //  This step is necessary so that a string with a
                //  nonspace mark and a punctuation char following one
                //  another are properly ignored when one or both of
                //  the ignore flags is set.
                //
                if (fIgnoreDiacritic)
                {
                    if (sm1 == NONSPACE_MARK)
                    {
                        pString1++;
                        ctr1--;
                        Weight1 = CMP_INVALID_WEIGHT;
                    }
                    if (sm2 == NONSPACE_MARK)
                    {
                        pString2++;
                        ctr2--;
                        Weight2 = CMP_INVALID_WEIGHT;
                    }
                }
                if (fIgnoreSymbol)
                {
                    if (sm1 == PUNCTUATION)
                    {
                        pString1++;
                        ctr1--;
                        Weight1 = CMP_INVALID_WEIGHT;
                    }
                    if (sm2 == PUNCTUATION)
                    {
                        pString2++;
                        ctr2--;
                        Weight2 = CMP_INVALID_WEIGHT;
                    }
                }
                if ((Weight1 == CMP_INVALID_WEIGHT) || (Weight2 == CMP_INVALID_WEIGHT))
                {
                    continue;
                }

                //
                //  Switch on the script member of string 1 and take care
                //  of any special cases.
                //
                switch (sm1)
                {
                    case ( NONSPACE_MARK ) :
                    {
                        //
                        //  Nonspace only - look at diacritic weight only.
                        //
                        if (!fIgnoreDiacritic)
                        {
                            if ((WhichDiacritic == 0) ||
                                (State & STATE_REVERSE_DW))
                            {
                                WhichDiacritic = CSTR_GREATER_THAN;

                                //
                                //  Remove state from state machine.
                                //
                                REMOVE_STATE(STATE_DW);
                            }
                        }

                        //
                        //  Adjust pointer and counter and set flags.
                        //
                        pString1++;
                        ctr1--;
                        Weight1 = CMP_INVALID_WEIGHT;

                        break;
                    }
                    case ( SYMBOL_1 ) :
                    case ( SYMBOL_2 ) :
                    case ( SYMBOL_3 ) :
                    case ( SYMBOL_4 ) :
                    case ( SYMBOL_5 ) :
                    {
                        //
                        //  If the ignore symbol flag is set, then skip over
                        //  the symbol.
                        //
                        if (fIgnoreSymbol)
                        {
                            pString1++;
                            ctr1--;
                            Weight1 = CMP_INVALID_WEIGHT;
                        }

                        break;
                    }
                    case ( PUNCTUATION ) :
                    {
                        //
                        //  If the ignore punctuation flag is set, then skip
                        //  over the punctuation char.
                        //
                        if (fIgnorePunct)
                        {
                            pString1++;
                            ctr1--;
                            Weight1 = CMP_INVALID_WEIGHT;
                        }
                        else if (!fStringSort)
                        {
                            //
                            //  Use WORD sort method.
                            //
                            if (sm2 != PUNCTUATION)
                            {
                                //
                                //  The character in the second string is
                                //  NOT punctuation.
                                //
                                if (WhichPunct2)
                                {
                                    //
                                    //  Set WP 2 to show that string 2 is
                                    //  smaller, since a punctuation char had
                                    //  already been found at an earlier
                                    //  position in string 2.
                                    //
                                    //  Set the Ignore Punctuation flag so we
                                    //  just skip over any other punctuation
                                    //  chars in the string.
                                    //
                                    WhichPunct2 = CSTR_GREATER_THAN;
                                    fIgnorePunct = TRUE;
                                }
                                else
                                {
                                    //
                                    //  Set WP 1 to show that string 2 is
                                    //  smaller, and that string 1 has had
                                    //  a punctuation char - since no
                                    //  punctuation chars have been found
                                    //  in string 2.
                                    //
                                    WhichPunct1 = CSTR_GREATER_THAN;
                                }

                                //
                                //  Advance pointer 1 and decrement counter 1.
                                //
                                pString1++;
                                ctr1--;
                                Weight1 = CMP_INVALID_WEIGHT;
                            }

                            //
                            //  Do NOT want to advance the pointer in string 1
                            //  if string 2 is also a punctuation char.  This
                            //  will be done later.
                            //
                        }

                        break;
                    }
                    case ( EXPANSION ) :
                    {
                        //
                        //  Save pointer in pString1 so that it can be
                        //  restored.
                        //
                        if (pSave1 == NULL)
                        {
                            pSave1 = pString1;
                        }
                        pString1 = pTmpBuf1;

                        //
                        //  Add one to counter so that subtraction doesn't end
                        //  comparison prematurely.
                        //
                        ctr1++;

                        //
                        //  Expand character into temporary buffer.
                        //
                        pTmpBuf1[0] = GET_EXPANSION_1(&Weight1);
                        pTmpBuf1[1] = GET_EXPANSION_2(&Weight1);

                        //
                        //  Set cExpChar1 to the number of expansion characters
                        //  stored.
                        //
                        cExpChar1 = MAX_TBL_EXPANSION;

                        Weight1 = CMP_INVALID_WEIGHT;

                        break;
                    }
                    case ( FAREAST_SPECIAL ) :
                    {
                        if (sm2 != EXPANSION) 
                        {
                            //
                            //  Get the weight for the far east special case
                            //  and store it in Weight1.
                            //
                            GET_FAREAST_WEIGHT( Weight1,
                                                uw1,
                                                Mask,
                                                lpString1,
                                                pString1,
                                                ExtraWt1,
                                                fModify );

                            if (sm2 != FAREAST_SPECIAL)
                            {
                                //
                                //  The character in the second string is
                                //  NOT a fareast special char.
                                //
                                //  Set each of weights 4, 5, 6, and 7 to show
                                //  that string 2 is smaller (if not already set).
                                //
                                if ((GET_WT_FOUR(&WhichExtra) == 0) &&
                                    (GET_WT_FOUR(&ExtraWt1) != 0))
                                {
                                    GET_WT_FOUR(&WhichExtra) = CSTR_GREATER_THAN;
                                }
                                if ((GET_WT_FIVE(&WhichExtra) == 0) &&
                                    (GET_WT_FIVE(&ExtraWt1) != 0))
                                {
                                    GET_WT_FIVE(&WhichExtra) = CSTR_GREATER_THAN;
                                }
                                if ((GET_WT_SIX(&WhichExtra) == 0) &&
                                    (GET_WT_SIX(&ExtraWt1) != 0))
                                {
                                    GET_WT_SIX(&WhichExtra) = CSTR_GREATER_THAN;
                                }
                                if ((GET_WT_SEVEN(&WhichExtra) == 0) &&
                                    (GET_WT_SEVEN(&ExtraWt1) != 0))
                                {
                                    GET_WT_SEVEN(&WhichExtra) = CSTR_GREATER_THAN;
                                }
                            }
                        }
                        break;
                    }
                    case ( JAMO_SPECIAL ) :
                    {
                        LPWSTR pStr1 = pString1;
                        LPWSTR pStr2 = pString2;

                        //
                        //  Set the JamoFlag so we don't handle it again.
                        //
                        JamoFlag = TRUE;
                        FindJamoDifference(
                            pHashN,
                            &pStr1, &ctr1, cchCount1, &Weight1,
                            &pStr2, &ctr2, cchCount2, &Weight2,
                            &pLastJamo,
                            &uw1, &uw2,
                            &State,
                            &WhichJamo,
                            fModify );

                        if (WhichJamo) 
                        {
                            return (WhichJamo);
                        }                            
                        pString1 = pStr1;
                        pString2 = pStr2;

                        break;
                    }
                    case ( EXTENSION_A ) :
                    {
                        //
                        //  Get the full weight in case DW got masked.
                        //
                        Weight1 = GET_DWORD_WEIGHT(pHashN, *pString1);
                        if (sm2 == EXTENSION_A)
                        {
                            Weight2 = GET_DWORD_WEIGHT(pHashN, *pString2);
                        }

                        //
                        //  Compare the weights.
                        //
                        if (Weight1 == Weight2)
                        {
                            //
                            //  Adjust pointers and counters and set flags.
                            //
                            pString1++;  pString2++;
                            ctr1--;  ctr2--;
                            Weight1 = CMP_INVALID_WEIGHT;
                            Weight2 = CMP_INVALID_WEIGHT;
                        }
                        else
                        {
                            //
                            //  Get the actual UW to compare.
                            //
                            if (sm2 == EXTENSION_A)
                            {
                                //
                                //  Set the UW values to be the AW and DW since
                                //  both strings contain an extension A char.
                                //
                                uw1 = MAKE_UNICODE_WT( GET_ALPHA_NUMERIC(&Weight1),
                                                       GET_DIACRITIC(&Weight1),
                                                       FALSE );
                                uw2 = MAKE_UNICODE_WT( GET_ALPHA_NUMERIC(&Weight2),
                                                       GET_DIACRITIC(&Weight2),
                                                       FALSE );
                            }
                            else
                            {
                                //
                                //  Only string1 contains an extension A char,
                                //  so set the UW value to be the first UW
                                //  value for extension A (default values):
                                //    SM_EXT_A, AW_EXT_A
                                //
                                uw1 = MAKE_UNICODE_WT(SM_EXT_A, AW_EXT_A, fModify);
                            }
                        }

                        break;
                    }
                    case ( UNSORTABLE ) :
                    {
                        //
                        //  Fill out the case statement so the compiler
                        //  will use a jump table.
                        //
                        break;
                    }
                }

                //
                //  Switch on the script member of string 2 and take care
                //  of any special cases.
                //
                switch (sm2)
                {
                    case ( NONSPACE_MARK ) :
                    {
                        //
                        //  Nonspace only - look at diacritic weight only.
                        //
                        if (!fIgnoreDiacritic)
                        {
                            if ((WhichDiacritic == 0) ||
                                (State & STATE_REVERSE_DW))

                            {
                                WhichDiacritic = CSTR_LESS_THAN;

                                //
                                //  Remove state from state machine.
                                //
                                REMOVE_STATE(STATE_DW);
                            }
                        }

                        //
                        //  Adjust pointer and counter and set flags.
                        //
                        pString2++;
                        ctr2--;
                        Weight2 = CMP_INVALID_WEIGHT;

                        break;
                    }
                    case ( SYMBOL_1 ) :
                    case ( SYMBOL_2 ) :
                    case ( SYMBOL_3 ) :
                    case ( SYMBOL_4 ) :
                    case ( SYMBOL_5 ) :
                    {
                        //
                        //  If the ignore symbol flag is set, then skip over
                        //  the symbol.
                        //
                        if (fIgnoreSymbol)
                        {
                            pString2++;
                            ctr2--;
                            Weight2 = CMP_INVALID_WEIGHT;
                        }

                        break;
                    }
                    case ( PUNCTUATION ) :
                    {
                        //
                        //  If the ignore punctuation flag is set, then
                        //  skip over the punctuation char.
                        //
                        if (fIgnorePunct)
                        {
                            //
                            //  Advance pointer 2 and decrement counter 2.
                            //
                            pString2++;
                            ctr2--;
                            Weight2 = CMP_INVALID_WEIGHT;
                        }
                        else if (!fStringSort)
                        {
                            //
                            //  Use WORD sort method.
                            //
                            if (sm1 != PUNCTUATION)
                            {
                                //
                                //  The character in the first string is
                                //  NOT punctuation.
                                //
                                if (WhichPunct1)
                                {
                                    //
                                    //  Set WP 1 to show that string 1 is
                                    //  smaller, since a punctuation char had
                                    //  already been found at an earlier
                                    //  position in string 1.
                                    //
                                    //  Set the Ignore Punctuation flag so we
                                    //  just skip over any other punctuation
                                    //  chars in the string.
                                    //
                                    WhichPunct1 = CSTR_LESS_THAN;
                                    fIgnorePunct = TRUE;
                                }
                                else
                                {
                                    //
                                    //  Set WP 2 to show that string 1 is
                                    //  smaller, and that string 2 has had
                                    //  a punctuation char - since no
                                    //  punctuation chars have been found
                                    //  in string 1.
                                    //
                                    WhichPunct2 = CSTR_LESS_THAN;
                                }

                                //
                                //  Pointer 2 and counter 2 will be updated
                                //  after if-else statement.
                                //
                            }
                            else
                            {
                                //
                                //  Both code points are punctuation chars.
                                //
                                //  See if either of the strings has encountered
                                //  punctuation chars previous to this.
                                //
                                if (WhichPunct1)
                                {
                                    //
                                    //  String 1 has had a punctuation char, so
                                    //  it should be the smaller string (since
                                    //  both have punctuation chars).
                                    //
                                    WhichPunct1 = CSTR_LESS_THAN;
                                }
                                else if (WhichPunct2)
                                {
                                    //
                                    //  String 2 has had a punctuation char, so
                                    //  it should be the smaller string (since
                                    //  both have punctuation chars).
                                    //
                                    WhichPunct2 = CSTR_GREATER_THAN;
                                }
                                else
                                {
                                    BYTE aw1 = GET_ALPHA_NUMERIC(&Weight1);
                                    BYTE aw2 = GET_ALPHA_NUMERIC(&Weight2);

                                    if (aw1 == aw2) 
                                    {
                                        BYTE cw1 = GET_CASE(&Weight1);
                                        BYTE cw2 = GET_CASE(&Weight2);
                                        if (cw1 < cw2) 
                                        {
                                            WhichPunct1 = CSTR_LESS_THAN;
                                        } else if (cw1 > cw2)
                                        {
                                            WhichPunct1 = CSTR_GREATER_THAN;
                                        }
                                    } else 
                                    {                                
                                        //
                                        //  Position is the same, so compare the
                                        //  special weights.   Set WhichPunct1 to
                                        //  the smaller special weight.
                                        //
                                        WhichPunct1 = (aw1 < aw2
                                                        ? CSTR_LESS_THAN
                                                        : CSTR_GREATER_THAN);
                                    }
                                }

                                //
                                //  Set the Ignore Punctuation flag.
                                //
                                fIgnorePunct = TRUE;

                                //
                                //  Advance pointer 1 and decrement counter 1.
                                //  Pointer 2 and counter 2 will be updated
                                //  after if-else statement.
                                //
                                pString1++;
                                ctr1--;
                                Weight1 = CMP_INVALID_WEIGHT;
                            }

                            //
                            //  Advance pointer 2 and decrement counter 2.
                            //
                            pString2++;
                            ctr2--;
                            Weight2 = CMP_INVALID_WEIGHT;
                        }

                        break;
                    }
                    case ( EXPANSION ) :
                    {
                        //
                        //  Save pointer in pString1 so that it can be restored.
                        //
                        if (pSave2 == NULL)
                        {
                            pSave2 = pString2;
                        }
                        pString2 = pTmpBuf2;

                        //
                        //  Add one to counter so that subtraction doesn't end
                        //  comparison prematurely.
                        //
                        ctr2++;

                        //
                        //  Expand character into temporary buffer.
                        //
                        pTmpBuf2[0] = GET_EXPANSION_1(&Weight2);
                        pTmpBuf2[1] = GET_EXPANSION_2(&Weight2);

                        //
                        //  Set cExpChar2 to the number of expansion characters
                        //  stored.
                        //
                        cExpChar2 = MAX_TBL_EXPANSION;

                        Weight2 = CMP_INVALID_WEIGHT;

                        break;
                    }
                    case ( FAREAST_SPECIAL ) :
                    {
                        if (sm1 != EXPANSION) 
                        {                        
                            //
                            //  Get the weight for the far east special case
                            //  and store it in Weight2.
                            //
                            GET_FAREAST_WEIGHT( Weight2,
                                                uw2,
                                                Mask,
                                                lpString2,
                                                pString2,
                                                ExtraWt2,
                                                fModify );

                            if (sm1 != FAREAST_SPECIAL)
                            {
                                //
                                //  The character in the first string is
                                //  NOT a fareast special char.
                                //
                                //  Set each of weights 4, 5, 6, and 7 to show
                                //  that string 1 is smaller (if not already set).
                                //
                                if ((GET_WT_FOUR(&WhichExtra) == 0) &&
                                    (GET_WT_FOUR(&ExtraWt2) != 0))
                                {
                                    GET_WT_FOUR(&WhichExtra) = CSTR_LESS_THAN;
                                }
                                if ((GET_WT_FIVE(&WhichExtra) == 0) &&
                                    (GET_WT_FIVE(&ExtraWt2) != 0))
                                {
                                    GET_WT_FIVE(&WhichExtra) = CSTR_LESS_THAN;
                                }
                                if ((GET_WT_SIX(&WhichExtra) == 0) &&
                                    (GET_WT_SIX(&ExtraWt2) != 0))
                                {
                                    GET_WT_SIX(&WhichExtra) = CSTR_LESS_THAN;
                                }
                                if ((GET_WT_SEVEN(&WhichExtra) == 0) &&
                                    (GET_WT_SEVEN(&ExtraWt2) != 0))
                                {
                                    GET_WT_SEVEN(&WhichExtra) = CSTR_LESS_THAN;
                                }
                            }
                            else
                            {
                                //
                                //  Characters in both strings are fareast
                                //  special chars.
                                //
                                //  Set each of weights 4, 5, 6, and 7
                                //  appropriately (if not already set).
                                //
                                if ( (GET_WT_FOUR(&WhichExtra) == 0) &&
                                     ( GET_WT_FOUR(&ExtraWt1) !=
                                       GET_WT_FOUR(&ExtraWt2) ) )
                                {
                                    GET_WT_FOUR(&WhichExtra) =
                                      ( GET_WT_FOUR(&ExtraWt1) <
                                        GET_WT_FOUR(&ExtraWt2) )
                                      ? CSTR_LESS_THAN
                                      : CSTR_GREATER_THAN;
                                }
                                if ( (GET_WT_FIVE(&WhichExtra) == 0) &&
                                     ( GET_WT_FIVE(&ExtraWt1) !=
                                       GET_WT_FIVE(&ExtraWt2) ) )
                                {
                                    GET_WT_FIVE(&WhichExtra) =
                                      ( GET_WT_FIVE(&ExtraWt1) <
                                        GET_WT_FIVE(&ExtraWt2) )
                                      ? CSTR_LESS_THAN
                                      : CSTR_GREATER_THAN;
                                }
                                if ( (GET_WT_SIX(&WhichExtra) == 0) &&
                                     ( GET_WT_SIX(&ExtraWt1) !=
                                       GET_WT_SIX(&ExtraWt2) ) )
                                {
                                    GET_WT_SIX(&WhichExtra) =
                                      ( GET_WT_SIX(&ExtraWt1) <
                                        GET_WT_SIX(&ExtraWt2) )
                                      ? CSTR_LESS_THAN
                                      : CSTR_GREATER_THAN;
                                }
                                if ( (GET_WT_SEVEN(&WhichExtra) == 0) &&
                                     ( GET_WT_SEVEN(&ExtraWt1) !=
                                       GET_WT_SEVEN(&ExtraWt2) ) )
                                {
                                    GET_WT_SEVEN(&WhichExtra) =
                                      ( GET_WT_SEVEN(&ExtraWt1) <
                                        GET_WT_SEVEN(&ExtraWt2) )
                                      ? CSTR_LESS_THAN
                                      : CSTR_GREATER_THAN;
                                }
                            }
                        }
                        break;
                    }
                    case ( JAMO_SPECIAL ) :
                    {
                        if (!JamoFlag)
                        {
                            LPWSTR pStr1 = pString1;
                            LPWSTR pStr2 = pString2;

                            FindJamoDifference(
                                pHashN,
                                &pStr1, &ctr1, cchCount1, &Weight1,
                                &pStr2, &ctr2, cchCount2, &Weight2,
                                &pLastJamo,
                                &uw1, &uw2,
                                &State,
                                &WhichJamo,
                                fModify );
                            if (WhichJamo) 
                            {
                                return (WhichJamo);
                            }                                                            
                            pString1 = pStr1;
                            pString2 = pStr2;
                        }
                        else
                        {
                            //
                            //  Reset the Jamo flag.
                            //
                            JamoFlag = FALSE;
                        }

                        break;
                    }
                    case ( EXTENSION_A ) :
                    {
                        //
                        //  If sm1 is an extension A character, then
                        //  both sm1 and sm2 have been handled.  We should
                        //  only get here when either sm1 is not an
                        //  extension A character or the two extension A
                        //  characters are different.
                        //
                        if (sm1 != EXTENSION_A)
                        {
                            //
                            //  Get the full weight in case DW got masked.
                            //  Also, get the actual UW to compare.
                            //
                            //  Only string2 contains an extension A char,
                            //  so set the UW value to be the first UW
                            //  value for extension A (default values):
                            //    SM_EXT_A, AW_EXT_A
                            //
                            Weight2 = GET_DWORD_WEIGHT(pHashN, *pString2);
                            uw2 = MAKE_UNICODE_WT(SM_EXT_A, AW_EXT_A, fModify);
                        }

                        //
                        //  We should then fall through to the comparison
                        //  of the Unicode weights.
                        //

                        break;
                    }
                    case ( UNSORTABLE ) :
                    {
                        //
                        //  Fill out the case statement so the compiler
                        //  will use a jump table.
                        //
                        break;
                    }
                }

                //
                //  See if the comparison should start again.
                //
                if ((Weight1 == CMP_INVALID_WEIGHT) || (Weight2 == CMP_INVALID_WEIGHT))
                {
                    //
                    //  Check to see if we're modifying the script value.
                    //  If so, then we need to reset the fareast weight
                    //  (if applicable) so that it doesn't get modified
                    //  again.
                    //
                    if (fModify == TRUE)
                    {
                        if (sm1 == FAREAST_SPECIAL)
                        {
                            Weight1 = CMP_INVALID_WEIGHT;
                        }
                        else if (sm2 == FAREAST_SPECIAL)
                        {
                            Weight2 = CMP_INVALID_WEIGHT;
                        }
                    }
                    continue;
                }

                //
                //  We're not supposed to drop down into the state table if
                //  the unicode weights are different, so stop comparison
                //  and return result of unicode weight comparison.
                //
                if (uw1 != uw2)
                {
                    return ((uw1 < uw2) ? CSTR_LESS_THAN : CSTR_GREATER_THAN);
                }
            }

            //
            //  For each state in the state table, do the appropriate
            //  comparisons.
            //
            if (State & (STATE_DW | STATE_REVERSE_DW))
            {
                //
                //  Get the diacritic weights.
                //
                dw1 = GET_DIACRITIC(&Weight1);
                dw2 = GET_DIACRITIC(&Weight2);

                if (dw1 != dw2)
                {
                    //
                    //  Look ahead to see if diacritic follows a
                    //  minimum diacritic weight.  If so, get the
                    //  diacritic weight of the nonspace mark.
                    //
                    while (!AT_STRING_END(ctr1 - 1, pString1 + 1, cchCount1))
                    {
                        Wt = GET_DWORD_WEIGHT(pHashN, *(pString1 + 1));
                        if (GET_SCRIPT_MEMBER(&Wt) == NONSPACE_MARK)
                        {
                            dw1 += GET_DIACRITIC(&Wt);
                            pString1++;
                            ctr1--;
                        }
                        else
                        {
                            break;
                        }
                    }

                    while (!AT_STRING_END(ctr2 - 1, pString2 + 1, cchCount2))
                    {
                        Wt = GET_DWORD_WEIGHT(pHashN, *(pString2 + 1));
                        if (GET_SCRIPT_MEMBER(&Wt) == NONSPACE_MARK)
                        {
                            dw2 += GET_DIACRITIC(&Wt);
                            pString2++;
                            ctr2--;
                        }
                        else
                        {
                            break;
                        }
                    }

                    //
                    //  Save which string has the smaller diacritic
                    //  weight if the diacritic weights are still
                    //  different.
                    //
                    if (dw1 != dw2)
                    {
                        WhichDiacritic = (dw1 < dw2)
                                           ? CSTR_LESS_THAN
                                           : CSTR_GREATER_THAN;

                        //
                        //  Remove state from state machine.
                        //
                        REMOVE_STATE(STATE_DW);
                    }
                }
            }
            if (State & STATE_CW)
            {
                //
                //  Get the case weights.
                //
                if (GET_CASE(&Weight1) != GET_CASE(&Weight2))
                {
                    //
                    //  Save which string has the smaller case weight.
                    //
                    WhichCase = (GET_CASE(&Weight1) < GET_CASE(&Weight2))
                                  ? CSTR_LESS_THAN
                                  : CSTR_GREATER_THAN;

                    //
                    //  Remove state from state machine.
                    //
                    REMOVE_STATE(STATE_CW);
                }
            }
        }

        //
        //  Fixup the pointers and counters.
        //
        POINTER_FIXUP();
        ctr1--;
        ctr2--;

        //
        //  Reset the weights to be invalid.
        //
        Weight1 = CMP_INVALID_WEIGHT;
        Weight2 = CMP_INVALID_WEIGHT;
    }

    //
    //  If the end of BOTH strings has been reached, then the unicode
    //  weights match exactly.  Check the diacritic, case and special
    //  weights.  If all are zero, then return success.  Otherwise,
    //  return the result of the weight difference.
    //
    //  NOTE:  The following checks MUST REMAIN IN THIS ORDER:
    //            Diacritic, Case, Punctuation.
    //
    if (AT_STRING_END(ctr1, pString1, cchCount1))
    {
        if (AT_STRING_END(ctr2, pString2, cchCount2))
        {
            if (WhichDiacritic)
            {
                return (WhichDiacritic);
            }
            if (WhichCase)
            {
                return (WhichCase);
            }
            if (WhichExtra)
            {
                if (!fIgnoreDiacritic)
                {
                    if (GET_WT_FOUR(&WhichExtra))
                    {
                        return (GET_WT_FOUR(&WhichExtra));
                    }
                    if (GET_WT_FIVE(&WhichExtra))
                    {
                        return (GET_WT_FIVE(&WhichExtra));
                    }
                }
                if (GET_WT_SIX(&WhichExtra))
                {
                    return (GET_WT_SIX(&WhichExtra));
                }
                if (GET_WT_SEVEN(&WhichExtra))
                {
                    return (GET_WT_SEVEN(&WhichExtra));
                }
            }
            if (WhichPunct1)
            {
                return (WhichPunct1);
            }
            if (WhichPunct2)
            {
                return (WhichPunct2);
            }

            return (CSTR_EQUAL);
        }
        else
        {
            //
            //  String 2 is longer.
            //
            pString1 = pString2;
            ctr1 = ctr2;
            cchCount1 = cchCount2;
            fEnd1 = CSTR_LESS_THAN;
        }
    }
    else
    {
        fEnd1 = CSTR_GREATER_THAN;
    }

    //
    //  Scan to the end of the longer string.
    //
    SCAN_LONGER_STRING( ctr1,
                        pString1,
                        cchCount1,
                        fEnd1 );
}


////////////////////////////////////////////////////////////////////////////
//
//  FindJamoDifference
//
////////////////////////////////////////////////////////////////////////////

int FindJamoDifference(
    PLOC_HASH pHashN,
    LPCWSTR* ppString1, int* ctr1, int cchCount1, DWORD* pWeight1,
    LPCWSTR* ppString2, int* ctr2, int cchCount2, DWORD* pWeight2,
    LPCWSTR* pLastJamo,
    WORD* uw1,
    WORD* uw2,
    int* pState,
    int* WhichJamo,
    BOOL fModify)
{
    int bRestart = 0;            // if string compare should restart again
    int oldHangulsFound1 = 0;    // # of valid old Hangul Jamo compositions found
    int oldHangulsFound2 = 0;    // # of valid old Hangul Jamo compositions found
    WORD UW;
    BYTE JamoWeight1[3];         // extra weight for first old Hangul composition
    BYTE JamoWeight2[3];         // extra weight for second old Hangul composition

    //
    //  Roll back to the first Jamo.  We know that these Jamos in both strings
    //  should be equal, so we can decrement both strings at once.
    //
    while ((*ppString1 > *pLastJamo) && IsJamo(*(*ppString1 - 1)))
    {
        (*ppString1)--; (*ppString2)--; (*ctr1)++; (*ctr2)++;
    }

    //
    //  Now we are at the beginning of two groups of Jamo characters.
    //  Compare Jamo unit (either a single Jamo or a valid old Hangul Jamo
    //  composition) until we run out Jamo units in either strings.
    //  We also exit when we reach the ends of either string.
    //
    //  while (NOT_END_STRING(*ctr1, *ppString1, cchCount1) &&
    //         NOT_END_STRING(*ctr2, *ppString2, cchCount2))
    //
    for (;;)
    {
        if (IsJamo(**ppString1))
        {
            if (IsLeadingJamo(**ppString1))
            {
                if ((oldHangulsFound1 = MapOldHangulSortKey( pHashN,
                                                             *ppString1,
                                                             *ctr1,
                                                             &UW,
                                                             JamoWeight1,
                                                             fModify )) > 0)
                {
                    *uw1 = UW;

                    //
                    //  Mark *pWeight1 so that it is not CMP_INVALID_WEIGHT.
                    //  0202 is the DW/CW.
                    //
                    *pWeight1 = ((DWORD)UW | 0x02020000);

                    //
                    //  We always increment ppString1/ctr1 at the end of the
                    //  loop, so we need to subtract 1 here.
                    //
                    *ppString1 += (oldHangulsFound1 - 1);
                    *ctr1 -= (oldHangulsFound1 - 1);
                }
            }
            if (oldHangulsFound1 == 0)
            {
                //
                //  No valid old Hangul compositions are found.  Get the UW
                //  for the Jamo instead.
                //
                *pWeight1 = GET_DWORD_WEIGHT(pHashN, **ppString1);

                //
                //  The SMs in PSORTKEY for Jamos are not really SMs. They
                //  are all 4 (for JAMO_SPECIAL).
                //  Here we get the real Jamo Unicode weight. The actual SM
                //  is stored in DW.
                //
                *uw1 = MAKE_UNICODE_WT( GET_DIACRITIC(pWeight1),
                                        GET_ALPHA_NUMERIC(pWeight1),
                                        fModify );
                ((PSORTKEY)pWeight1)->Diacritic = MIN_DW;
            }
        }

        if (IsJamo(**ppString2))
        {
            if (IsLeadingJamo(**ppString2))
            {
                if ((oldHangulsFound2 = MapOldHangulSortKey( pHashN,
                                                             *ppString2,
                                                             *ctr2,
                                                             &UW,
                                                             JamoWeight2,
                                                             fModify )) > 0)
                {
                    *uw2 = UW;
                    *pWeight2 = ((DWORD)UW | 0x02020000);
                    *ppString2 += (oldHangulsFound2 - 1);
                    *ctr2 -= (oldHangulsFound2 - 1);
                }
            }
            if (oldHangulsFound2 == 0)
            {
                *pWeight2 = GET_DWORD_WEIGHT(pHashN, **ppString2);
                *uw2 = MAKE_UNICODE_WT( GET_DIACRITIC(pWeight2),
                                        GET_ALPHA_NUMERIC(pWeight2),
                                        fModify );
                ((PSORTKEY)pWeight2)->Diacritic = MIN_DW;                                        
            }
        }

        //
        //  See if either weight is invalid.
        // A weight can be invalid when the character is not a Jamo.
        //
        if (*pWeight1 == CMP_INVALID_WEIGHT)
        {
            //
            //  The current character is not a Jamo.  Set the Weight to
            //  be CMP_INVALID_WEIGHT, so that the string comparision can
            //  restart within the loop of CompareString().
            //
            *pWeight1 = CMP_INVALID_WEIGHT;
            bRestart = 1;
            goto FindJamoDifferenceExit;
        }
        if (*pWeight2 == CMP_INVALID_WEIGHT)
        {
            //
            //  The current character is not a Jamo.  Set the Weight to
            //  be CMP_INVALID_WEIGHT, so that the string comparision can
            //  restart within the loop of CompareString().
            //
            *pWeight2 = CMP_INVALID_WEIGHT;
            bRestart = 1;
            goto FindJamoDifferenceExit;
        }
        if (*uw1 != *uw2)
        {
            //
            //  Found differences in Unicode weight.  We can stop the
            //  processing now.
            //
            goto FindJamoDifferenceExit;
        }

        //
        //  When we get here, we know that we have the same Unicode Weight.
        //  Check if we need to record the WhichJamo.
        //
        if ((*pState & STATE_JAMO_WEIGHT) &&
            ((oldHangulsFound1 > 0) || (oldHangulsFound2 > 0)))
        {
            if ((oldHangulsFound1 > 0) && (oldHangulsFound2 > 0))
            {
                *WhichJamo = (int)memcmp( JamoWeight1,
                                                    JamoWeight2,
                                                    sizeof(JamoWeight1) ) + 2;
            }
            else if (oldHangulsFound1 > 0)
            {
                *WhichJamo = CSTR_GREATER_THAN;
            }
            else
            {
                *WhichJamo = CSTR_LESS_THAN;
            }
            *pState &= ~STATE_JAMO_WEIGHT;
            oldHangulsFound1 = oldHangulsFound2 = 0;
        }
        (*ppString1)++; (*ctr1)--;
        (*ppString2)++; (*ctr2)--;

        if (AT_STRING_END(*ctr1, *ppString1, cchCount1) ||
            AT_STRING_END(*ctr2, *ppString2, cchCount2))
        {
            break;
        }
        *pWeight1 = *pWeight2 = CMP_INVALID_WEIGHT;
    }

    //
    //  If we drop out of the while loop because we reach the end of strings,
    //  decrement the pointers by one because loops in CompareString() will
    //  increase the pointers at the end of the loop.
    //
    //  If we drop out of the while loop because the goto's in it, we are
    //  already off by one.
    //
    if (AT_STRING_END(*ctr1, *ppString1, cchCount1))
    {
        (*ppString1)--; (*ctr1)++;
    }
    if (AT_STRING_END(*ctr2, *ppString2, cchCount2))
    {
        (*ppString2)--; (*ctr2)++;
    }

FindJamoDifferenceExit:
    *pLastJamo = *ppString1;
    return (bRestart);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\utf.h ===
/*++

Copyright (c) 1991-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    utf.h

Abstract:

    This file contains the header information for the UTF module of NLS.

Revision History:

    02-06-96    JulieB    Created.

--*/



//
//  Constant Declarations.
//

#define ASCII                 0x007f

#define SHIFT_IN              '+'     // beginning of a shift sequence
#define SHIFT_OUT             '-'     // end       of a shift sequence

#define UTF8_2_MAX            0x07ff  // max UTF8 2-byte sequence (32 * 64 = 2048)
#define UTF8_1ST_OF_2         0xc0    // 110x xxxx
#define UTF8_1ST_OF_3         0xe0    // 1110 xxxx
#define UTF8_1ST_OF_4         0xf0    // 1111 xxxx
#define UTF8_TRAIL            0x80    // 10xx xxxx

#define HIGHER_6_BIT(u)       ((u) >> 12)
#define MIDDLE_6_BIT(u)       (((u) & 0x0fc0) >> 6)
#define LOWER_6_BIT(u)        ((u) & 0x003f)

#define BIT7(a)               ((a) & 0x80)
#define BIT6(a)               ((a) & 0x40)

#define HIGH_SURROGATE_START  0xd800
#define HIGH_SURROGATE_END    0xdbff
#define LOW_SURROGATE_START   0xdc00
#define LOW_SURROGATE_END     0xdfff

/////////////////////////
//                     //
//  Unicode -> UTF-7   //
//                     //
/////////////////////////

//
//  Convert one Unicode to 2 2/3 Base64 chars in a shifted sequence.
//  Each char represents a 6-bit portion of the 16-bit Unicode char.
//
CONST char cBase64[] =

  "ABCDEFGHIJKLMNOPQRSTUVWXYZ"  // A : 000000 .... 011001  ( 0 - 25)
  "abcdefghijklmnopqrstuvwxyz"  // a : 011010 .... 110011  (26 - 51)
  "0123456789"                  // 0 : 110100 .... 111101  (52 - 61)
  "+/";                         // + : 111110, / : 111111  (62 - 63)

//
//  To determine if an ASCII char needs to be shifted.
//    1 :     to be shifted
//    0 : not to be shifted
//
CONST BOOLEAN fShiftChar[] =
{
  0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1,    // Null, Tab, LF, CR
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0,    // Space '() +,-./
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,    // 0123456789:    ?
  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  ABCDEFGHIJKLMNO
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,    // PQRSTUVWXYZ
  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    //  abcdefghijklmno
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1     // pqrstuvwxyz
};




/////////////////////////
//                     //
//  UTF-7 -> Unicode   //
//                     //
/////////////////////////

//
//  Convert a Base64 char in a shifted sequence to a 6-bit portion of a
//  Unicode char.
//  -1 means it is not a Base64
//
CONST char nBitBase64[] =
{
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,   //            +   /
  52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1,   // 0123456789
  -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,   //  ABCDEFGHIJKLMNO
  15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,   // PQRSTUVWXYZ
  -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,   //  abcdefghijklmno
  41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1    // pqrstuvwxyz
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\util.c ===
/*++

Copyright (c) 1991-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    util.c

Abstract:

    This file contains utility functions that are shared across NLS's code
    modules, but are not necessarily part of any of the existing code
    modules.

    Private APIs found in this file:
      NlsGetCacheUpdateCount

    External Routines found in this file:
      IsValidSeparatorString
      IsValidGroupingString
      IsValidCalendarType
      IsValidCalendarTypeStr
      GetUserInfo
      GetPreComposedChar
      GetCompositeChars
      InsertPreComposedForm
      InsertFullWidthPreComposedForm
      InsertCompositeForm
      NlsConvertIntegerToString
      NlsConvertIntegerToHexStringW
      NlsConvertStringToIntegerW      
      NlsStrCpyW
      NlsStrCatW
      NlsStrLenW
      NlsStrNCatW
      NlsStrEqualW
      NlsStrNEqualW
      GetStringTableEntry
      NlsIsDll
      
      
Revision History:

    05-31-91    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nls.h"





//-------------------------------------------------------------------------//
//                         PRIVATE API ROUTINES                            //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  NlsGetCacheUpdateCount
//
//  Returns the current cache update count.  The cache update count is
//  updated whenever the HKCU\Control Panel\International settings are
//  modified.  This count allows the caller to see if the cache has been
//  updated since the last time this function was called.
//
//  This private api is needed by the Complex Script Language Pack
//  (CSLPK) to enable it to quickly see if the international section of
//  the registry has been modified.
//
////////////////////////////////////////////////////////////////////////////

ULONG WINAPI NlsGetCacheUpdateCount(void)
{
    return (pNlsUserInfo->ulCacheUpdateCount);
}





//-------------------------------------------------------------------------//
//                           EXTERNAL ROUTINES                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  IsValidSeparatorString
//
//  Returns TRUE if the given string is valid.  Otherwise, it returns FALSE.
//
//  A valid string is one that does NOT contain any code points between
//  L'0' and L'9', and does NOT have a length greater than the maximum.
//
//  NOTE:  The string must be a null terminated string.
//
//  10-12-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL IsValidSeparatorString(
    LPCWSTR pString,
    ULONG MaxLength,
    BOOL fCheckZeroLen)
{
    ULONG Length;            // string length
    LPWSTR pCur;             // ptr to current position in string


    //
    //  Search down the string to see if the chars are valid.
    //  Save the length of the string.
    //
    pCur = (LPWSTR)pString;
    while (*pCur)
    {
        if ((*pCur >= NLS_CHAR_ZERO) && (*pCur <= NLS_CHAR_NINE))
        {
            //
            //  String is NOT valid.
            //
            return (FALSE);
        }
        pCur++;
    }
    Length = (ULONG)(pCur - (LPWSTR)pString);

    //
    //  Make sure the length is not greater than the maximum allowed.
    //  Also, check for 0 length string (if appropriate).
    //
    if ((Length >= MaxLength) ||
        ((fCheckZeroLen) && (Length == 0)))
    {
        //
        //  String is NOT valid.
        //
        return (FALSE);
    }

    //
    //  String is valid.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  IsValidGroupingString
//
//  Returns TRUE if the given string is valid.  Otherwise, it returns FALSE.
//
//  A valid string is one that begins and ends with a number between
//  L'0' and L'9', alternates between a number and a semicolon, and does
//  NOT have a length greater than the maximum.
//        (eg. 3;2;0  or  3;0  or  0  or  3)
//
//  NOTE:  The string must be a null terminated string.
//
//  01-05-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL IsValidGroupingString(
    LPCWSTR pString,
    ULONG MaxLength,
    BOOL fCheckZeroLen)
{
    ULONG Length;            // string length
    LPWSTR pCur;             // ptr to current position in string


    //
    //  Search down the string to see if the chars are valid.
    //  Save the length of the string.
    //
    pCur = (LPWSTR)pString;
    while (*pCur)
    {
        if ((*pCur < NLS_CHAR_ZERO) || (*pCur > NLS_CHAR_NINE))
        {
            //
            //  String is NOT valid.
            //
            return (FALSE);
        }
        pCur++;

        if (*pCur)
        {
            if ((*pCur != NLS_CHAR_SEMICOLON) || (*(pCur + 1) == 0))
            {
                //
                //  String is NOT valid.
                //
                return (FALSE);
            }
            pCur++;
        }
    }
    Length = (ULONG)(pCur - (LPWSTR)pString);

    //
    //  Make sure the length is not greater than the maximum allowed.
    //  Also, check for 0 length string (if appropriate).
    //
    if ((Length >= MaxLength) ||
        ((fCheckZeroLen) && (Length == 0)))
    {
        //
        //  String is NOT valid.
        //
        return (FALSE);
    }

    //
    //  String is valid.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  IsValidCalendarType
//
//  Returns the pointer to the optional calendar structure if the given
//  calendar type is valid for the given locale.  Otherwise, it returns
//  NULL.
//
//  10-12-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

LPWORD IsValidCalendarType(
    PLOC_HASH pHashN,
    CALID CalId)
{
    LPWORD pOptCal;          // ptr to list of optional calendars
    LPWORD pEndOptCal;       // ptr to end of list of optional calendars


    //
    //  Make sure the Cal Id is not zero, since that may be in the
    //  optional calendar section (meaning no optional calendars).
    //
    if (CalId == 0)
    {
        return (NULL);
    }

    //
    //  Search down the list of optional calendars.
    //
    pOptCal = (LPWORD)(pHashN->pLocaleHdr) + pHashN->pLocaleHdr->IOptionalCal;
    pEndOptCal = (LPWORD)(pHashN->pLocaleHdr) + pHashN->pLocaleHdr->SDayName1;
    while (pOptCal < pEndOptCal)
    {
        //
        //  Check the calendar ids.
        //
        if (CalId == ((POPT_CAL)pOptCal)->CalId)
        {
            //
            //  Calendar id is valid for the given locale.
            //
            return (pOptCal);
        }

        //
        //  Increment to the next optional calendar.
        //
        pOptCal += ((POPT_CAL)pOptCal)->Offset;
    }

    //
    //  Calendar id is NOT valid if this point is reached.
    //
    return (NULL);
}


////////////////////////////////////////////////////////////////////////////
//
//  IsValidCalendarTypeStr
//
//  Converts the calendar string to an integer and validates the calendar
//  id for the given locale.  It return a pointer to the optional calendar
//  structure, or null if the calendar id was invalid.
//
//  10-19-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

LPWORD IsValidCalendarTypeStr(
    PLOC_HASH pHashN,
    LPCWSTR pCalStr)
{
    UNICODE_STRING ObUnicodeStr;       // value string
    CALID CalNum;                      // calendar id


    //
    //  Convert the string to an integer value.
    //
    RtlInitUnicodeString(&ObUnicodeStr, pCalStr);
    if (RtlUnicodeStringToInteger(&ObUnicodeStr, 10, &CalNum))
    {
        return (NULL);
    }

    //
    //  Validate the calendar id and return the pointer to the
    //  optional calendar structure.
    //
    return (IsValidCalendarType(pHashN, CalNum));
}

////////////////////////////////////////////////////////////////////////////
//
//  GetCPFileNameFromRegistry
//
//  Gets the name of the code page file from the registry.  If pResultBuf
//  or Size == 0, then just return true if it exists in the registry, but
//  don't return the actual value.
//
//  05-31-2002  ShawnSte    Created.
////////////////////////////////////////////////////////////////////////////

BOOL GetCPFileNameFromRegistry(
    UINT    CodePage,
    LPWSTR  pResultBuf,
    UINT    Size)
{
    // Working things.
    WCHAR pTmpBuf[MAX_SMALL_BUF_LEN];            // temp buffer
    PKEY_VALUE_FULL_INFORMATION pKeyValueFull;   // ptr to query info
    BYTE pStatic[MAX_KEY_VALUE_FULLINFO];        // ptr to static buffer

    //
    //  Convert value to unicode string.
    //
    if (!NT_SUCCESS(NlsConvertIntegerToString( CodePage,
                                               10,
                                               0,
                                               pTmpBuf,
                                               MAX_SMALL_BUF_LEN )))
    {
        // Didn't work.  (Don't bother closing key though, its used globally)
        return (FALSE);
    }

    // Open hCodePageKey, return false if it fails
    OPEN_CODEPAGE_KEY(FALSE);

    //
    //  Query the registry value for that code page.
    //    
    pKeyValueFull = (PKEY_VALUE_FULL_INFORMATION)pStatic; 
    if ( NO_ERROR != QueryRegValue( hCodePageKey,
                                    pTmpBuf,
                                    &pKeyValueFull,
                                    MAX_KEY_VALUE_FULLINFO,
                                    NULL ) )
    {
        // Didn't work.  (Don't bother closing key though, its used globally)
        return (FALSE);
    }                     

    //
    //  Make sure there is data with this value.
    //
    if (GET_VALUE_DATA_PTR(pKeyValueFull)[0] == 0)
    {
        // Nope, no file name for this code page.  (Not installed).
        return (FALSE);
    }      

    // It worked, see if that's all they wanted.
    if (!pResultBuf || Size == 0)
    {
        // Caller didn't want the name, just to know if it was there
        return (TRUE);
    }

    // Now we have to copy the name to their buffer for them.
    NlsStrCpyW(pResultBuf, GET_VALUE_DATA_PTR(pKeyValueFull));

    // Yea, it worked
    return (TRUE);
}

////////////////////////////////////////////////////////////////////////////
//
//  GetUserInfoFromRegistry
//
//  Gets the information from the registry for the given value entry.
//
//  06-11-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL GetUserInfoFromRegistry(
    LPWSTR pValue,
    LPWSTR pOutput,
    LCID Locale)
{
    PKEY_VALUE_FULL_INFORMATION pKeyValueFull;   // ptr to query info
    BYTE pStatic[MAX_KEY_VALUE_FULLINFO];        // ptr to static buffer
    HANDLE hKey = NULL;                          // handle to intl key
    ULONG rc = 0L;                               // return code


    //
    //  Open the Control Panel International registry key.
    //
    OPEN_CPANEL_INTL_KEY(hKey, FALSE, KEY_READ);

    //
    //  Initialize the output string.
    //
    *pOutput = 0;

    pKeyValueFull = (PKEY_VALUE_FULL_INFORMATION)pStatic;

    //
    //  Check to be sure the current user is running in the given locale.
    //    
    if (Locale)
    {
        if (NO_ERROR == QueryRegValue( hKey,
                    L"Locale",
                    &pKeyValueFull,
                    MAX_KEY_VALUE_FULLINFO,
                    NULL ))
        {
            UINT uiLocale;
            
            if (NlsConvertStringToIntegerW(GET_VALUE_DATA_PTR(pKeyValueFull), 16, -1, &uiLocale) &&
               uiLocale != Locale)
            {
                CLOSE_REG_KEY(hKey);
                return FALSE;
            }
        }            
    }

    //
    //  Query the registry value.
    //    
    rc = QueryRegValue( hKey,
                        pValue,
                        &pKeyValueFull,
                        MAX_KEY_VALUE_FULLINFO,
                        NULL );

    //
    //  Close the registry key.
    //
    CLOSE_REG_KEY(hKey);

    //
    //  If the query failed or if the output buffer is not large enough,
    //  then return failure.
    //
    if ((rc != NO_ERROR) ||
        (pKeyValueFull->DataLength > (MAX_REG_VAL_SIZE * sizeof(WCHAR))))
    {
        return (FALSE);
    }

    //
    //  Save the string in pOutput.
    //
    NlsStrCpyW(pOutput, GET_VALUE_DATA_PTR(pKeyValueFull));

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetUserInfo
//
//  Gets the information from the registry for the given locale and user
//  value entry.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL GetUserInfo(
    LCID Locale,
    LCTYPE LCType,
    SIZE_T CacheOffset,
    LPWSTR pValue,
    LPWSTR pOutput,
    size_t cchOutput,
    BOOL fCheckNull)
{
    LCID UserLocale; 
    HRESULT hr;                   // return val for string copy


    //
    // Check if the current thread/process is impersonating
    // or running in the context of a user other than the
    // interactive one.
    //
    if (NT_SUCCESS( NlsGetCurrentUserNlsInfo( Locale,
                                              LCType,
                                              pValue,
                                              pOutput,
                                              FALSE )))
    {
        //
        //  See if we need to check for a null string.
        //
        if ((fCheckNull) && (*pOutput == 0))
        {
            return (FALSE);
        }

        return (TRUE);
    }

    //
    // Running in the same security context as the logged-on user.
    //

    //  Go to server side (csrss.exe) by calling CsrBasepNlsGetUserInfo(). The server side will enter a critical section to 
    // protect the cache reading, and Copy the data to the output buffer.

    // NOTENOTE: CsrBasepNlsGetUserInfo takes the buffer size in BYTE, so
    // we have to multiply cchOutput by sizeof(WCHAR)
    
    if (!NT_SUCCESS(CsrBasepNlsGetUserInfo(Locale, CacheOffset, pOutput, cchOutput * sizeof(WCHAR))))
    {
        //
        //  Make sure the cache is valid.
        //
        //  Also, check for an invalid entry.  An invalid entry is marked
        //  with NLS_INVALID_INFO_CHAR in the first position of the string
        //  array.
        //
        //
        //  The cache is invalid, so try getting the information directly
        //  from the registry.
        //
        if (GetUserInfoFromRegistry(pValue, pOutput, Locale) == FALSE)
        {
            return (FALSE);
        }
    }

    //
    //  See if we need to check for a null string.
    //
    if ((fCheckNull) && (*pOutput == 0))
    {
        return (FALSE);
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetPreComposedChar
//
//  Gets the precomposed character form of a given base character and
//  nonspacing character.  If there is no precomposed form for the given
//  character, it returns 0.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

WCHAR FASTCALL GetPreComposedChar(
    WCHAR wcNonSp,
    WCHAR wcBase)
{
    PCOMP_INFO pComp;             // ptr to composite information
    WORD BSOff = 0;               // offset of base char in grid
    WORD NSOff = 0;               // offset of nonspace char in grid
    int Index;                    // index into grid


    //
    //  Store the ptr to the composite information.  No need to check if
    //  it's a NULL pointer since all tables in the Unicode file are
    //  constructed during initialization.
    //
    pComp = pTblPtrs->pComposite;

    //
    //  Traverse 8:4:4 table for Base character offset.
    //
    BSOff = TRAVERSE_844_W(pComp->pBase, wcBase);
    if (!BSOff)
    {
        return (0);
    }

    //
    //  Traverse 8:4:4 table for NonSpace character offset.
    //
    NSOff = TRAVERSE_844_W(pComp->pNonSp, wcNonSp);
    if (!NSOff)
    {
        return (0);
    }

    //
    //  Get wide character value out of 2D grid.
    //  If there is no precomposed character at the location in the
    //  grid, it will return 0.
    //
    Index = (BSOff - 1) * pComp->NumNonSp + (NSOff - 1);
    return ((pComp->pGrid)[Index]);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetCompositeChars
//
//  Gets the composite characters of a given wide character.  If the
//  composite form is found, it returns TRUE.  Otherwise, it returns
//  FALSE.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL FASTCALL GetCompositeChars(
    WCHAR wch,
    WCHAR *pNonSp,
    WCHAR *pBase)
{
    PPRECOMP pPreComp;            // ptr to precomposed information


    //
    //  Store the ptr to the precomposed information.  No need to check if
    //  it's a NULL pointer since all tables in the Unicode file are
    //  constructed during initialization.
    //
    pPreComp = pTblPtrs->pPreComposed;

    //
    //  Traverse 8:4:4 table for base and nonspace character translation.
    //
    TRAVERSE_844_D(pPreComp, wch, *pNonSp, *pBase);

    //
    //  Return success if found.  Otherwise, error.
    //
    return ((*pNonSp) && (*pBase));
}


////////////////////////////////////////////////////////////////////////////
//
//  InsertPreComposedForm
//
//  Gets the precomposed form of a given wide character string, places it in
//  the given wide character, and returns the number of composite characters
//  used to form the precomposed form.  If there is no precomposed form for
//  the given character, nothing is written into pPreComp and it returns 1
//  for the number of characters used.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int FASTCALL InsertPreComposedForm(
    LPCWSTR pWCStr,
    LPWSTR pEndWCStr,
    LPWSTR pPreComp)
{
    WCHAR wch;                    // precomposed character
    LPWSTR pPos;                  // ptr to position in string


    //
    //  If no precomposed form can be found, return 1 character used
    //  (base character).
    //
    if (((pWCStr + 1) >= pEndWCStr) ||
        (!(wch = GetPreComposedChar(*(pWCStr + 1), *pWCStr))))
    {
        return (1);
    }

    //
    //  Get the precomposed character from the given wide character string.
    //  Must check for multiple nonspacing characters for the same
    //  precomposed character.
    //
    *pPreComp = wch;
    pPos = (LPWSTR)pWCStr + 2;
    while ((pPos < pEndWCStr) &&
           (wch = GetPreComposedChar(*pPos, *pPreComp)))
    {
        *pPreComp = wch;
        pPos++;
    }

    //
    //  Return the number of characters used to form the precomposed
    //  character.
    //
    return ((int)(pPos - (LPWSTR)pWCStr));
}


////////////////////////////////////////////////////////////////////////////
//
//  InsertFullWidthPreComposedForm
//
//  Gets the full width precomposed form of a given wide character string,
//  places it in the given wide character, and returns the number of
//  composite characters used to form the precomposed form.  If there is
//  no precomposed form for the given character, only the full width conversion
//  of the first code point is written into pPreComp and it returns 1 for
//  the number of characters used.
//
//  11-04-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int FASTCALL InsertFullWidthPreComposedForm(
    LPCWSTR pWCStr,
    LPWSTR pEndWCStr,
    LPWSTR pPreComp,
    PCASE pCase)
{
    WCHAR wch;                    // nonspace character
    LPWSTR pPos;                  // ptr to position in string


    //
    //  Get the case (if necessary).
    //
    *pPreComp = (pCase) ? GET_LOWER_UPPER_CASE(pCase, *pWCStr) : *pWCStr;

    //
    //  Get the full width.
    //
    *pPreComp = GET_FULL_WIDTH(pTblPtrs->pFullWidth, *pPreComp);

    if ((pPos = ((LPWSTR)pWCStr + 1)) >= pEndWCStr)
    {
        return (1);
    }

    while (pPos < pEndWCStr)
    {
        wch = (pCase) ? GET_LOWER_UPPER_CASE(pCase, *pPos) : *pPos;
        wch = GET_FULL_WIDTH(pTblPtrs->pFullWidth, wch);
        if (wch = GetPreComposedChar(wch, *pPreComp))
        {
            *pPreComp = wch;
            pPos++;
        }
        else
        {
            break;
        }
    }

    //
    //  Return the number of characters used to form the precomposed
    //  character.
    //
    return ((int)(pPos - (LPWSTR)pWCStr));
}


////////////////////////////////////////////////////////////////////////////
//
//  InsertCompositeForm
//
//  Gets the composite form of a given wide character, places it in the
//  wide character string, and returns the number of characters written.
//  If there is no composite form for the given character, the wide character
//  string is not touched.  It will return 1 for the number of characters
//  written, since the base character was already written.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int FASTCALL InsertCompositeForm(
    LPWSTR pWCStr,
    LPWSTR pEndWCStr)
{
    WCHAR Base;                   // base character
    WCHAR NonSp;                  // non space character
    int wcCount = 0;              // number of wide characters written
    LPWSTR pEndComp;              // ptr to end of composite form
    int ctr;                      // loop counter


    //
    //  If no composite form can be found, return 1 for the base
    //  character that was already written.
    //
    if (!GetCompositeChars(*pWCStr, &NonSp, &Base))
    {
        return (1);
    }

    //
    //  Get the composite characters and write them to the pWCStr
    //  buffer.  Must check for multiple breakdowns of the precomposed
    //  character into more than 2 characters (multiple nonspacing
    //  characters).
    //
    pEndComp = pWCStr;
    do
    {
        //
        //  Make sure pWCStr is big enough to hold the nonspacing
        //  character.
        //
        if (pEndComp < (pEndWCStr - 1))
        {
            //
            //  Addition of next breakdown of nonspacing characters
            //  are to be added right after the base character.  So,
            //  move all nonspacing characters ahead one position
            //  to make room for the next nonspacing character.
            //
            pEndComp++;
            for (ctr = 0; ctr < wcCount; ctr++)
            {
                *(pEndComp - ctr) = *(pEndComp - (ctr + 1));
            }

            //
            //  Fill in the new base form and the new nonspacing character.
            //
            *pWCStr = Base;
            *(pWCStr + 1) = NonSp;
            wcCount++;
        }
        else
        {
            //
            //  Make sure we don't get into an infinite loop if the
            //  destination buffer isn't large enough.
            //
            break;
        }
    } while (GetCompositeChars(*pWCStr, &NonSp, &Base));

    //
    //  Return number of wide characters written.  Add 1 to include the
    //  base character.
    //
    return (wcCount + 1);
}


////////////////////////////////////////////////////////////////////////////
//
//  NlsConvertIntegerToString
//
//  This routine converts an integer to a Unicode string.
//
//  11-15-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ULONG NlsConvertIntegerToString(
    UINT Value,
    UINT Base,
    UINT Padding,
    LPWSTR pResultBuf,
    UINT Size)
{
    UNICODE_STRING ObString;                // value string
    UINT ctr;                               // loop counter
    LPWSTR pBufPtr;                         // ptr to result buffer
    WCHAR pTmpBuf[MAX_PATH_LEN];            // ptr to temp buffer
    ULONG rc = 0L;                          // return code


    //
    //  Set up the Unicode string structure.
    //
    ObString.Length = (USHORT)(Size * sizeof(WCHAR));
    ObString.MaximumLength = (USHORT)(Size * sizeof(WCHAR));
    ObString.Buffer = pTmpBuf;

    //
    //  Get the value as a string.
    //
    if (rc = RtlIntegerToUnicodeString(Value, Base, &ObString))
    {
        return (rc);
    }

    //
    //  Pad the string with the appropriate number of zeros.
    //
    pBufPtr = pResultBuf;
    for (ctr = GET_WC_COUNT(ObString.Length);
         ctr < Padding;
         ctr++, pBufPtr++)
    {
        *pBufPtr = NLS_CHAR_ZERO;
    }
    NlsStrCpyW(pBufPtr, ObString.Buffer);

    //
    //  Return success.
    //
    return (NO_ERROR);
}

////////////////////////////////////////////////////////////////////////////
//
//  NlsConvertIntegerToHexStringW
//      Convert an integer value to an Unicode null-terminated string WITH 
//      leading zeros.  E.g. 0x409 with Width 5 will be converted to L"0409".
//      This function is faster than NlsConvertIntegerToString(), but it
//      only supports hex numbers.
//
//  Parameters:
//      Value   The number to be converted.
//      UpperCase   If TRUE, the hex digit will be uppercase.
//      Str     The buffer for the converted Unicode string.
//      Width   The character count of the buffer.  The value should be the total 
//              heximal digit number plus one for null-terminiated.
//              E.g. if the value is from 0x0000 - 0xffff, the Width should be 5.
//
//  Return:
//      TRUE if successful.  FALSE if the width is not big enough to hold the converted string.    
//
////////////////////////////////////////////////////////////////////////////

BOOL FASTCALL NlsConvertIntegerToHexStringW(UINT Value, BOOL UpperCase, PWSTR Str, UINT CharCount)
{
    int Digit;
    PWSTR p;

    if(Str == NULL)
    {
        return (FALSE);
    }
    
    p = Str + CharCount - 1;
    *p-- = L'\0';
    while (p >= Str)
    {
        Digit = Value & 0xf;
        if (Digit < 10)
        {
            Digit = Digit + L'0';
        }
        else
        {
            Digit = Digit - 10 + (UpperCase ? L'A' : L'a');
        }
        *p-- = (WCHAR)Digit;
        Value >>= 4;
    }    

    if (Value > 0)
    {
        //
        // There are still digit remaining.
        //
        return (FALSE);
    }
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  NlsConvertStringToIntegerW
//
//  Parameters:
//      Str     the hex string to be converted.
//      Base    base
//      CharCount   
//              the character count of the string (excluding the terminiated-null, if any). 
//              If the value is -1, this function assumes that
//              Str is a null-terminated string.
//      Result  the pointer to the result.
//
//  Result:
//      TRUE if the operation is successful.  FALSE if there is non-hex
//      character in the string.
//
////////////////////////////////////////////////////////////////////////////

BOOL FASTCALL NlsConvertStringToIntegerW(PWSTR Str, UINT Base, int CharCount, UINT* Result)
{
    int i;
    WCHAR Digit;
    WCHAR c;

    if (Str == NULL || Result == NULL)
    {
        return (FALSE);
    }
    
    *Result = 0;

    if (CharCount == -1)
    {
        while (c = *Str)
        {
            c = *Str;
            if (c >= L'0' && c <= L'9') 
            {
                Digit = c - L'0';
            }
            else if(Base == 16)
            {
                if (c >= L'A' && c <= L'F') 
                {
                    Digit = c - L'A' + 10;
                }
                else if (c >= L'a' && c <= L'f') 
                {
                    Digit = c - L'a' + 10;
                }
                else 
                {
                    return (FALSE);
                }
            }
            else
            {
                return (FALSE);
            }

            if (Base == 16)
            {
                *Result = (*Result << 4) | Digit;
            }
            else
            {
                *Result = *Result*10 + Digit;
            }

            Str++;
        }
    } else
    {
        for (i=0; i< CharCount; i++) {
            c = *Str++;
            if (c >= L'0' && c <= L'9') 
            {
                Digit = c - L'0';
            }
            else if(Base == 16)
            {
                if (c >= L'A' && c <= L'F') 
                {
                    Digit = c - L'A' + 10;
                }
                else if (c >= L'a' && c <= L'f') 
                {
                    Digit = c - L'a' + 10;
                }
                else 
                {
                    return (FALSE);
                }
            }
            else
            {
                return (FALSE);
            }

            if (Base == 16)
            {
                *Result = (*Result << 4) | Digit;
            }
            else
            {
                *Result = *Result*10 + Digit;
            }
        }
    }
    return (TRUE);
}

////////////////////////////////////////////////////////////////////////////
//
//  NlsStrCpyW
//
//  This routine copies the source wide character string to the destination
//  wide character string buffer.
//
//  NOTE: This routine is here to avoid any dependencies on other DLLs
//        during initialization.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

LPWSTR FASTCALL NlsStrCpyW(
    LPWSTR pwszDest,
    LPCWSTR pwszSrc)
{
    LPWSTR pwszRet = pwszDest;         // ptr to beginning of string

    loop:
        if (!(pwszDest[0x0] = pwszSrc[0x0]))   goto done;
        if (!(pwszDest[0x1] = pwszSrc[0x1]))   goto done;
        if (!(pwszDest[0x2] = pwszSrc[0x2]))   goto done;
        if (!(pwszDest[0x3] = pwszSrc[0x3]))   goto done;
        if (!(pwszDest[0x4] = pwszSrc[0x4]))   goto done;
        if (!(pwszDest[0x5] = pwszSrc[0x5]))   goto done;
        if (!(pwszDest[0x6] = pwszSrc[0x6]))   goto done;
        if (!(pwszDest[0x7] = pwszSrc[0x7]))   goto done;
        if (!(pwszDest[0x8] = pwszSrc[0x8]))   goto done;
        if (!(pwszDest[0x9] = pwszSrc[0x9]))   goto done;
        if (!(pwszDest[0xA] = pwszSrc[0xA]))   goto done;
        if (!(pwszDest[0xB] = pwszSrc[0xB]))   goto done;
        if (!(pwszDest[0xC] = pwszSrc[0xC]))   goto done;
        if (!(pwszDest[0xD] = pwszSrc[0xD]))   goto done;
        if (!(pwszDest[0xE] = pwszSrc[0xE]))   goto done;
        if (!(pwszDest[0xF] = pwszSrc[0xF]))   goto done;

        pwszDest+= 0x10;
        pwszSrc+= 0x10;

        goto loop;

    done:
        return (pwszRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  NlsStrCatW
//
//  This routine attaches the second string to the first string.
//
//  NOTE: This routine is here to avoid any dependencies on other DLLs
//        during initialization.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

LPWSTR FASTCALL NlsStrCatW(
    LPWSTR pwsz1,
    LPCWSTR pwsz2)
{
    LPWSTR pwszRet = pwsz1;            // ptr to beginning of string

    strlen_loop:
        if (*pwsz1) pwsz1++;   else goto cat_loop;
        if (*pwsz1) pwsz1++;   else goto cat_loop;
        if (*pwsz1) pwsz1++;   else goto cat_loop;
        if (*pwsz1) pwsz1++;   else goto cat_loop;
        if (*pwsz1) pwsz1++;   else goto cat_loop;
        if (*pwsz1) pwsz1++;   else goto cat_loop;
        if (*pwsz1) pwsz1++;   else goto cat_loop;
        if (*pwsz1) pwsz1++;   else goto cat_loop;
        if (*pwsz1) pwsz1++;   else goto cat_loop;
        if (*pwsz1) pwsz1++;   else goto cat_loop;
        if (*pwsz1) pwsz1++;   else goto cat_loop;
        if (*pwsz1) pwsz1++;   else goto cat_loop;
        if (*pwsz1) pwsz1++;   else goto cat_loop;
        if (*pwsz1) pwsz1++;   else goto cat_loop;
        if (*pwsz1) pwsz1++;   else goto cat_loop;
        if (*pwsz1) pwsz1++;   else goto cat_loop;

        goto  strlen_loop;

    cat_loop:
        if (!(pwsz1[0x00] = pwsz2[0x00]))   goto done;
        if (!(pwsz1[0x01] = pwsz2[0x01]))   goto done;
        if (!(pwsz1[0x02] = pwsz2[0x02]))   goto done;
        if (!(pwsz1[0x03] = pwsz2[0x03]))   goto done;
        if (!(pwsz1[0x04] = pwsz2[0x04]))   goto done;
        if (!(pwsz1[0x05] = pwsz2[0x05]))   goto done;
        if (!(pwsz1[0x06] = pwsz2[0x06]))   goto done;
        if (!(pwsz1[0x07] = pwsz2[0x07]))   goto done;
        if (!(pwsz1[0x08] = pwsz2[0x08]))   goto done;
        if (!(pwsz1[0x09] = pwsz2[0x09]))   goto done;
        if (!(pwsz1[0x0A] = pwsz2[0x0A]))   goto done;
        if (!(pwsz1[0x0B] = pwsz2[0x0B]))   goto done;
        if (!(pwsz1[0x0C] = pwsz2[0x0C]))   goto done;
        if (!(pwsz1[0x0D] = pwsz2[0x0D]))   goto done;
        if (!(pwsz1[0x0E] = pwsz2[0x0E]))   goto done;
        if (!(pwsz1[0x0F] = pwsz2[0x0F]))   goto done;

        pwsz1 += 0x10;
        pwsz2 += 0x10;
        goto cat_loop;

    done:
        return (pwszRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  NlsStrLenW
//
//  This routine returns the length of the given wide character string.
//  The length does NOT include the null terminator.
//
//  NOTE: This routine is here to avoid any dependencies on other DLLs
//        during initialization.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int FASTCALL NlsStrLenW(
    LPCWSTR pwsz)
{
    LPCWSTR pwszStart = pwsz;          // ptr to beginning of string

    loop:
        if (*pwsz) pwsz++;   else goto done;
        if (*pwsz) pwsz++;   else goto done;
        if (*pwsz) pwsz++;   else goto done;
        if (*pwsz) pwsz++;   else goto done;
        if (*pwsz) pwsz++;   else goto done;
        if (*pwsz) pwsz++;   else goto done;
        if (*pwsz) pwsz++;   else goto done;
        if (*pwsz) pwsz++;   else goto done;
        if (*pwsz) pwsz++;   else goto done;
        if (*pwsz) pwsz++;   else goto done;
        if (*pwsz) pwsz++;   else goto done;
        if (*pwsz) pwsz++;   else goto done;
        if (*pwsz) pwsz++;   else goto done;
        if (*pwsz) pwsz++;   else goto done;
        if (*pwsz) pwsz++;   else goto done;
        if (*pwsz) pwsz++;   else goto done;

        goto loop;

    done:
        return ((int)(pwsz - pwszStart));
}


////////////////////////////////////////////////////////////////////////////
//
//  NlsStrNCatW
//
//  This routine concatenates two wide character strings for the count of
//  characters given.  It copies "Count" characters from the back string to
//  the end of the "front" string.
//
//  NOTE: This routine is here to avoid any dependencies on other DLLs
//        during initialization.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

LPWSTR FASTCALL NlsStrNCatW(
    LPWSTR pwszFront,
    LPCWSTR pwszBack,
    int Count)
{
    LPWSTR pwszStart = pwszFront;      // ptr to beginning of string

    strlen_loop:
        if (*pwszFront) pwszFront++;   goto cat_loop;
        if (*pwszFront) pwszFront++;   goto cat_loop;
        if (*pwszFront) pwszFront++;   goto cat_loop;
        if (*pwszFront) pwszFront++;   goto cat_loop;
        if (*pwszFront) pwszFront++;   goto cat_loop;
        if (*pwszFront) pwszFront++;   goto cat_loop;
        if (*pwszFront) pwszFront++;   goto cat_loop;
        if (*pwszFront) pwszFront++;   goto cat_loop;

        goto strlen_loop;

    cat_loop:
        if (Count == 0 || !(*pwszFront = *pwszBack))   goto done;
        pwszFront++;   pwszBack++;   Count--;
        if (Count == 0 || !(*pwszFront = *pwszBack))   goto done;
        pwszFront++;   pwszBack++;   Count--;
        if (Count == 0 || !(*pwszFront = *pwszBack))   goto done;
        pwszFront++;   pwszBack++;   Count--;
        if (Count == 0 || !(*pwszFront = *pwszBack))   goto done;
        pwszFront++;   pwszBack++;   Count--;
        if (Count == 0 || !(*pwszFront = *pwszBack))   goto done;
        pwszFront++;   pwszBack++;   Count--;
        if (Count == 0 || !(*pwszFront = *pwszBack))   goto done;
        pwszFront++;   pwszBack++;   Count--;
        if (Count == 0 || !(*pwszFront = *pwszBack))   goto done;
        pwszFront++;   pwszBack++;   Count--;
        if (Count == 0 || !(*pwszFront = *pwszBack))   goto done;
        pwszFront++;   pwszBack++;   Count--;

        goto cat_loop;

    done:
        *pwszFront = (WCHAR)0;
        return (pwszStart);
}


////////////////////////////////////////////////////////////////////////////
//
//  NlsStrEqualW
//
//  This routine compares two strings to see if they are exactly identical.
//  It returns 1 if they are identical, 0 if they are different.
//
//  NOTE: This routine is here to avoid any dependencies on other DLLs
//        during initialization.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int FASTCALL NlsStrEqualW(
    LPCWSTR pwszFirst,
    LPCWSTR pwszSecond)
{
    loop:
        if (*pwszFirst != *pwszSecond)   goto error;
        if (!*pwszFirst)                 return (1);
        pwszFirst++;
        pwszSecond++;

        if (*pwszFirst != *pwszSecond)   goto error;
        if (!*pwszFirst)                 return (1);
        pwszFirst++;
        pwszSecond++;

        if (*pwszFirst != *pwszSecond)   goto error;
        if (!*pwszFirst)                 return (1);
        pwszFirst++;
        pwszSecond++;

        if (*pwszFirst != *pwszSecond)   goto error;
        if (!*pwszFirst)                 return (1);
        pwszFirst++;
        pwszSecond++;

        if (*pwszFirst != *pwszSecond)   goto error;
        if (!*pwszFirst)                 return (1);
        pwszFirst++;
        pwszSecond++;

        if (*pwszFirst != *pwszSecond)   goto error;
        if (!*pwszFirst)                 return (1);
        pwszFirst++;
        pwszSecond++;

        if (*pwszFirst != *pwszSecond)   goto error;
        if (!*pwszFirst)                 return (1);
        pwszFirst++;
        pwszSecond++;

        if (*pwszFirst != *pwszSecond)   goto error;
        if (!*pwszFirst)                 return (1);
        pwszFirst++;
        pwszSecond++;

        goto loop;

    error:
        //
        //  Return error.
        //
        return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  NlsStrNEqualW
//
//  This routine compares two strings to see if they are exactly identical
//  for the count of characters given.
//  It returns 1 if they are identical, 0 if they are different.
//
//  NOTE: This routine is here to avoid any dependencies on other DLLs
//        during initialization.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int FASTCALL NlsStrNEqualW(
    LPCWSTR pwszFirst,
    LPCWSTR pwszSecond,
    int Count)
{
    loop:
        if (Count == 0)                  return (1);
        if (*pwszFirst != *pwszSecond)   goto error;
        if (!*pwszFirst)                 return (1);
        pwszFirst++;
        pwszSecond++;
        Count--;

        if (Count == 0)                  return (1);
        if (*pwszFirst != *pwszSecond)   goto error;
        if (!*pwszFirst)                 return (1);
        pwszFirst++;
        pwszSecond++;
        Count--;

        if (Count == 0)                  return (1);
        if (*pwszFirst != *pwszSecond)   goto error;
        if (!*pwszFirst)                 return (1);
        pwszFirst++;
        pwszSecond++;
        Count--;

        if (Count == 0)                  return (1);
        if (*pwszFirst != *pwszSecond)   goto error;
        if (!*pwszFirst)                 return (1);
        pwszFirst++;
        pwszSecond++;
        Count--;

        if (Count == 0)                  return (1);
        if (*pwszFirst != *pwszSecond)   goto error;
        if (!*pwszFirst)                 return (1);
        pwszFirst++;
        pwszSecond++;
        Count--;

        if (Count == 0)                  return (1);
        if (*pwszFirst != *pwszSecond)   goto error;
        if (!*pwszFirst)                 return (1);
        pwszFirst++;
        pwszSecond++;
        Count--;

        if (Count == 0)                  return (1);
        if (*pwszFirst != *pwszSecond)   goto error;
        if (!*pwszFirst)                 return (1);
        pwszFirst++;
        pwszSecond++;
        Count--;

        if (Count == 0)                  return (1);
        if (*pwszFirst != *pwszSecond)   goto error;
        if (!*pwszFirst)                 return (1);
        pwszFirst++;
        pwszSecond++;
        Count--;

        goto loop;

    error:
        //
        //  Return error.
        //
        return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetDefaultSortkeySize
//
////////////////////////////////////////////////////////////////////////////

ULONG GetDefaultSortkeySize(
    PLARGE_INTEGER pSize)
{
    *pSize = pTblPtrs->DefaultSortkeySize;
    return (STATUS_SUCCESS);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetLinguistLangSize
//
////////////////////////////////////////////////////////////////////////////

ULONG GetLinguistLangSize(
    PLARGE_INTEGER pSize)
{
    *pSize = pTblPtrs->LinguistLangSize;
    return (STATUS_SUCCESS);
}


////////////////////////////////////////////////////////////////////////////
//
//  ValidateLocale
//
//  Internal routine, called from server.  Validates that a locale is
//  present in the registry.  This code comes from IsValidLocale, but
//  does not check the internal data to prevent recursive calls to the
//  server.
//
////////////////////////////////////////////////////////////////////////////

BOOL ValidateLocale(
    LCID Locale)
{
    PKEY_VALUE_FULL_INFORMATION pKeyValueFull;
    BYTE pStatic1[MAX_KEY_VALUE_FULLINFO];
    BYTE pStatic2[MAX_KEY_VALUE_FULLINFO];

    WCHAR pTmpBuf[MAX_PATH];           // temp buffer
    UNICODE_STRING ObUnicodeStr;       // registry data value string
    DWORD Data;                        // registry data value
    LPWSTR pData;                      // ptr to registry data
    BOOL bResult = FALSE;              // result value

    //
    //  Invalid Locale Check.
    //
    if (IS_INVALID_LOCALE(Locale))
    {
        return (FALSE);
    }

    //
    //  Open the Locale, the Alternate Sorts, and the Language Groups
    //  registry keys.
    //
    OPEN_LOCALE_KEY(FALSE);
    OPEN_ALT_SORTS_KEY(FALSE);
    OPEN_LANG_GROUPS_KEY(FALSE);

    //
    //  Convert locale value to Unicode string.
    //
    if (NlsConvertIntegerToString(Locale, 16, 8, pTmpBuf, MAX_PATH))
    {
        return (FALSE);
    }

    //
    //  Query the registry for the value.
    //
    pKeyValueFull = (PKEY_VALUE_FULL_INFORMATION)pStatic1;
    if (((QueryRegValue( hLocaleKey,
                         pTmpBuf,
                         &pKeyValueFull,
                         MAX_KEY_VALUE_FULLINFO,
                         NULL ) == NO_ERROR) ||
         (QueryRegValue( hAltSortsKey,
                         pTmpBuf,
                         &pKeyValueFull,
                         MAX_KEY_VALUE_FULLINFO,
                         NULL ) == NO_ERROR)) &&
        (pKeyValueFull->DataLength > 2))
    {
        RtlInitUnicodeString(&ObUnicodeStr, GET_VALUE_DATA_PTR(pKeyValueFull));
        if ((RtlUnicodeStringToInteger(&ObUnicodeStr, 16, &Data) == NO_ERROR) &&
            (Data != 0))
        {
            pKeyValueFull = (PKEY_VALUE_FULL_INFORMATION)pStatic2;
            if ((QueryRegValue( hLangGroupsKey,
                                ObUnicodeStr.Buffer,
                                &pKeyValueFull,
                                MAX_KEY_VALUE_FULLINFO,
                                NULL ) == NO_ERROR) &&
                (pKeyValueFull->DataLength > 2))
            {
                pData = GET_VALUE_DATA_PTR(pKeyValueFull);
                if ((pData[0] == L'1') && (pData[1] == 0))
                {
                    bResult = TRUE;
                }
            }
        }
    }

    //
    //  Return the result.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  ValidateLCType
//
//  This routine is called from the server (and also from locale.c) in
//  order to get a Registry key name and a field pointer in the NlsInfo
//  structure given an LCType.
//
////////////////////////////////////////////////////////////////////////////

BOOL ValidateLCType(
    PNLS_USER_INFO pInfo,
    LCTYPE LCType,
    LPWSTR *ppwReg,
    LPWSTR *ppwCache)
{
    switch (LCType)
    {
        case ( LOCALE_IFIRSTWEEKOFYEAR ) :
        {
            *ppwReg = NLS_VALUE_IFIRSTWEEKOFYEAR;
            *ppwCache = pInfo->iFirstWeek;
            break;
        }
        case ( LOCALE_IFIRSTDAYOFWEEK ) :
        {
            *ppwReg = NLS_VALUE_IFIRSTDAYOFWEEK;
            *ppwCache = pInfo->iFirstDay;
            break;
        }
        case ( LOCALE_ICALENDARTYPE ) :
        {
            *ppwReg = NLS_VALUE_ICALENDARTYPE;
            *ppwCache = pInfo->iCalType;
            break;
        }
        case ( LOCALE_SLONGDATE ) :
        {
            *ppwReg = NLS_VALUE_SLONGDATE;
            *ppwCache = pInfo->sLongDate;
            break;
        }
        case ( LOCALE_SYEARMONTH ) :
        {
            *ppwReg = NLS_VALUE_SYEARMONTH;
            *ppwCache = pInfo->sYearMonth;
            break;
        }
        case ( LOCALE_S1159 ) :
        {
            *ppwReg = NLS_VALUE_S1159;
            *ppwCache = pInfo->s1159;
            break;
        }
        case ( LOCALE_SNEGATIVESIGN ) :
        {
            *ppwReg = NLS_VALUE_SNEGATIVESIGN;
            *ppwCache = pInfo->sNegSign;
            break;
        }
        case ( LOCALE_SPOSITIVESIGN ) :
        {
            *ppwReg = NLS_VALUE_SPOSITIVESIGN;
            *ppwCache = pInfo->sPosSign;
            break;
        }
        case ( LOCALE_INEGCURR ) :
        {
            *ppwReg = NLS_VALUE_INEGCURR;
            *ppwCache = pInfo->iNegCurr;
            break;
        }
        case ( LOCALE_ICURRENCY ) :
        {
            *ppwReg = NLS_VALUE_ICURRENCY;
            *ppwCache = pInfo->iCurrency;
            break;
        }
        case ( LOCALE_ICURRDIGITS ) :
        {
            *ppwReg = NLS_VALUE_ICURRDIGITS;
            *ppwCache = pInfo->iCurrDigits;
            break;
        }
        case ( LOCALE_SMONGROUPING ) :
        {
            *ppwReg = NLS_VALUE_SMONGROUPING;
            *ppwCache = pInfo->sMonGrouping;
            break;
        }
        case ( LOCALE_SMONTHOUSANDSEP ) :
        {
            *ppwReg = NLS_VALUE_SMONTHOUSANDSEP;
            *ppwCache = pInfo->sMonThouSep;
            break;
        }
        case ( LOCALE_SMONDECIMALSEP ) :
        {
            *ppwReg = NLS_VALUE_SMONDECIMALSEP;
            *ppwCache = pInfo->sMonDecSep;
            break;
        }
        case ( LOCALE_SCURRENCY ) :
        {
            *ppwReg = NLS_VALUE_SCURRENCY;
            *ppwCache = pInfo->sCurrency;
            break;
        }
        case ( LOCALE_IDIGITSUBSTITUTION ) :
        {
            *ppwReg = NLS_VALUE_IDIGITSUBST;
            *ppwCache = pInfo->iDigitSubstitution;
            break;
        }
        case ( LOCALE_SNATIVEDIGITS ) :
        {
            *ppwReg = NLS_VALUE_SNATIVEDIGITS;
            *ppwCache = pInfo->sNativeDigits;
            break;
        }
        case ( LOCALE_INEGNUMBER ) :
        {
            *ppwReg = NLS_VALUE_INEGNUMBER;
            *ppwCache = pInfo->iNegNumber;
            break;
        }
        case ( LOCALE_ILZERO ) :
        {
            *ppwReg = NLS_VALUE_ILZERO;
            *ppwCache = pInfo->iLZero;
            break;
        }
        case ( LOCALE_IDIGITS ) :
        {
            *ppwReg = NLS_VALUE_IDIGITS;
            *ppwCache = pInfo->iDigits;
            break;
        }
        case ( LOCALE_SGROUPING ) :
        {
            *ppwReg = NLS_VALUE_SGROUPING;
            *ppwCache = pInfo->sGrouping;
            break;
        }
        case ( LOCALE_STHOUSAND ) :
        {
            *ppwReg = NLS_VALUE_STHOUSAND;
            *ppwCache = pInfo->sThousand;
            break;
        }
        case ( LOCALE_SDECIMAL ) :
        {
            *ppwReg = NLS_VALUE_SDECIMAL;
            *ppwCache = pInfo->sDecimal;
            break;
        }
        case ( LOCALE_IPAPERSIZE ) :
        {
            *ppwReg = NLS_VALUE_IPAPERSIZE;
            *ppwCache = pInfo->iPaperSize;
            break;
        }
        case ( LOCALE_IMEASURE ) :
        {
            *ppwReg = NLS_VALUE_IMEASURE;
            *ppwCache = pInfo->iMeasure;
            break;
        }
        case ( LOCALE_SLIST ) :
        {
            *ppwReg = NLS_VALUE_SLIST;
            *ppwCache = pInfo->sList;
            break;
        }
        case ( LOCALE_S2359 ) :
        {
            *ppwReg = NLS_VALUE_S2359;
            *ppwCache = pInfo->s2359;
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetStringTableEntry
//
//  Returns the localized version of the strings for the given resource
//  id.  It gets the information from the resource file in the language that
//  the current user is using.
//
//  The string table contains a series of strings in the following order:
//      Language Name
//      Country Name
//      Language Group Name
//      Code Page Name               (decimal values converted to hex values)
//      Region (Geo) Friendly Name   (decimal values converted to hex values)
//      Region (Geo) Official Name   (decimal values converted to hex values)
//      Sorting Names                (in order starting with 0, separated by $)
//
//  Each string is separated by $.  The final string is terminated with
//  a null.
//
//  The sorting names are in order of the sort ids, starting with 0.
//
//  For example,
//    "Language$Country$LangGrp$CodePage$Geo1$Geo2$Sort0$Sort1"      or
//    "Language$Country"                                             or
//    "$$LangGrp$CodePage"                                           or
//    "$$$CodePage"                                                  or
//    "$$$$Geo1$Geo2"
//
//  11-17-00    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetStringTableEntry(
    UINT ResourceID,
    LANGID UILangId,
    LPWSTR pBuffer,
    int cchBuffer,
    int WhichString)
{
    HANDLE hFindRes;                   // handle from find resource
    HANDLE hLoadRes;                   // handle from load resource
    LPWSTR pSearch, pSearchEnd;        // ptrs to search for correct string
    LPWSTR pString;                    // ptr to final string
    int cchCount = 0;                  // count of characters


    //
    //  Make sure the buffer is ok.
    //
    if ((pBuffer == NULL) || (cchBuffer == 0))
    {
        return (0);
    }

    //
    //  Make sure we're not hitting the GEO ID that is out of bounds.
    //
    //  !!! NOTE !!! This is needed because the East Timor Geo Id
    //               is out of bounds and wraps to 0x60e7.
    //
    if (ResourceID == 0x60e7)
    {
        return (0);
    }

    //
    //  Set the UI Language Id.
    //
    if (UILangId == 0)
    {
        UILangId = GetUserDefaultUILanguage();
    }

    //
    //  String Tables are broken up into 16 string segments.  Find the
    //  resource containing the string we want.
    //
    if ((!(hFindRes = FindResourceExW( hModule,
                                       RT_STRING,
                                       (LPWSTR)UlongToPtr((ULONG)(((USHORT)ResourceID >> 4) + 1)),
                                       (WORD)UILangId ))))
    {
        //
        //  Could not find resource.  Try NEUTRAL language id.
        //
        if ((!(hFindRes = FindResourceExW( hModule,
                                           RT_STRING,
                                           (LPWSTR)UlongToPtr((ULONG)(((USHORT)ResourceID >> 4) + 1)),
                                           (WORD)0 ))))
        {
            //
            //  Could not find resource.  Return 0.
            //
            return (0);
        }
    }

    //
    //  Load the resource.
    //
    if (hLoadRes = LoadResource(hModule, hFindRes))
    {
        //
        //  Lock the resource.  Store the found pointer in the given
        //  pointer.
        //
        if (pSearch = (LPWSTR)LockResource(hLoadRes))
        {
            //
            //  Move past the other strings in this segment.
            //     (16 strings in a segment -> & 0x0F)
            //
            ResourceID &= 0x0F;

            //
            //  Find the correct string in this segment.
            //
            while (TRUE)
            {
                cchCount = *((WORD *)pSearch++);
                if (ResourceID-- == 0)
                {
                    break;
                }
                pSearch += cchCount;
            }

            //
            //  Mark the end of the resource string since it is not
            //  NULL terminated.
            //
            pSearchEnd = pSearch + cchCount;

            //
            //  Get to the appropriate string.
            //
            while ((WhichString > 0) && (pSearch < pSearchEnd))
            {
                do
                {
                    if (*pSearch == RC_STRING_SEPARATOR)
                    {
                        pSearch++;
                        break;
                    }
                    pSearch++;

                } while (pSearch < pSearchEnd);

                WhichString--;
            }

            //
            //  Count the number of characters for this string.
            //
            pString = pSearch;
            cchCount = 0;
            while ((pSearch < pSearchEnd) && (*pSearch != RC_STRING_SEPARATOR))
            {
                pSearch++;
                cchCount++;
            }

            //
            //  See if there is anything to copy.
            //
            if (cchCount > 0)
            {
                //
                //  Don't copy more than the max allowed.
                //
                if (cchCount >= cchBuffer)
                {
                    cchCount = cchBuffer - 1;
                }

                //
                //  Copy the string into the buffer and NULL terminate it.
                //
                CopyMemory(pBuffer, pString, cchCount * sizeof(WCHAR));
                pBuffer[cchCount] = 0;

                //
                //  Return the number of characters in the string, not
                //  including the NULL terminator.
                //
                return (cchCount);
            }
        }
    }

    //
    //  Return failure.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  NlsIsDll
//
//  Check if file extension is DLL
//
////////////////////////////////////////////////////////////////////////////

BOOL FASTCALL NlsIsDll(
    LPCWSTR pFileName
)
{
    BOOL bIsDll = FALSE;
    

    if (pFileName)
    {
        int iLen = NlsStrLenW(pFileName);
        
        //
        // Check DLL extension, save the trouble of calling lstrcmp
        //        
        if (iLen > 4)
        {
            pFileName += iLen-4;
            
            if ((*pFileName++ == L'.') &&
               (*pFileName == L'D' || *pFileName++ == L'd') &&
               (*pFileName == L'L' || *pFileName++ == L'l') &&
               (*pFileName == L'L' || *pFileName++ == L'l'))            
            {
               bIsDll = TRUE;
            }
        }
    }

    return bIsDll;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\data\dlls\share.h ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    share.h

Abstract:

    This file contains the header information shared by all of code page
    DLL modules.

Revision History:

    10-30-96    JulieB    Created.

--*/



#ifndef _NLS_DLLS_
#define _NLS_DLLS_




////////////////////////////////////////////////////////////////////////////
//
//  RTL Includes Files.
//
////////////////////////////////////////////////////////////////////////////

#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif




////////////////////////////////////////////////////////////////////////////
//
//  Include Files.
//
////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <winnlsp.h>




////////////////////////////////////////////////////////////////////////////
//
//  Constant Declarations.
//
////////////////////////////////////////////////////////////////////////////




////////////////////////////////////////////////////////////////////////////
//
//  Typedef Declarations.
//
////////////////////////////////////////////////////////////////////////////




////////////////////////////////////////////////////////////////////////////
//
//  Macro Definitions.
//
////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////
//
//  NLS_ALLOC_MEM
//
//  Allocates the given number of bytes of memory from the process heap,
//  zeros the memory buffer, and returns the handle.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NLS_ALLOC_MEM(dwBytes)                                             \
    ( RtlAllocateHeap( RtlProcessHeap(),                                   \
                       HEAP_ZERO_MEMORY,                                   \
                       dwBytes ) )


////////////////////////////////////////////////////////////////////////////
//
//  NLS_FREE_MEM
//
//  Frees the memory of the given handle from the process heap.
//
//  DEFINED AS A MACRO.
//
//  05-31-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define NLS_FREE_MEM(hMem)                                                 \
    ( (hMem) ? (RtlFreeHeap( RtlProcessHeap(),                             \
                             0,                                            \
                             (PVOID)hMem ))                                \
             : 0 )




////////////////////////////////////////////////////////////////////////////
//
//  Function Prototypes
//
////////////////////////////////////////////////////////////////////////////




////////////////////////////////////////////////////////////////////////////
//
//  Global Variables
//
//  Globals are included last because they may require some of the types
//  being defined above.
//
////////////////////////////////////////////////////////////////////////////



#endif   // _NLS_DLLS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\data\dlls\gb18030\c_gb18030.h ===
#ifndef C_GB18030_H
#define C_GB18030_H

#define CODEPAGE_GBK 936
#define GB18030_CODEPAGE 54936
#define GB18030_MAX_CHAR_SIZE 4
#define GB18030_DEFAULT_UNICODE_CHAR L'\x003f'
#define GB18030_DEFAULT_CHAR '\x3f'

//
// Lead byte = 0x81 ~ 0xfe
//
#define IS_GB_LEAD_BYTE(ch) ((ch) >= 0x81 && (ch) <= 0xfe)

//
// Trailing byte for two-byte GB18030: 0x40 ~ 0x7e, 0x80 ~ 0xfe
//
#define IS_GB_TWO_BYTES_TRAILING(ch) \
    (((ch) >= 0x40 && (ch) <= 0x7e) || \
     ((ch) >= 0x80 && (ch) <= 0xfe))

#define GBK2K_BYTE1_MIN     0x81
#define GBK2K_BYTE1_MAX     0xfe

#define GBK2K_BYTE2_MIN     0x30
#define GBK2K_BYTE2_MAX     0x39

#define GBK2K_BYTE3_MIN     0x81
#define GBK2K_BYTE3_MAX     0xfe

#define GBK2K_BYTE4_MIN     0x30
#define GBK2K_BYTE4_MAX     0x39

#define GBK2K_BYTE1_RANGE   (GBK2K_BYTE1_MAX - GBK2K_BYTE1_MIN + 1)
#define GBK2K_BYTE2_RANGE   (GBK2K_BYTE2_MAX - GBK2K_BYTE2_MIN + 1)
#define GBK2K_BYTE3_RANGE   (GBK2K_BYTE3_MAX - GBK2K_BYTE3_MIN + 1)
#define GBK2K_BYTE4_RANGE   (GBK2K_BYTE4_MAX - GBK2K_BYTE4_MIN + 1)

//
// Trailing byte for four-byte GB18030: 0x30 ~ 0x39
//
#define IS_GB_FOUR_BYTES_TRAILING(ch) ((ch) >= 0x30 && (ch) <= 0x39)

#define GET_FOUR_BYTES_OFFSET(offset1, offset2, offset3, offset4) \
    ((offset1) * GBK2K_BYTE2_RANGE * GBK2K_BYTE3_RANGE * GBK2K_BYTE4_RANGE + \
     (offset2) * GBK2K_BYTE3_RANGE * GBK2K_BYTE4_RANGE + \
     (offset3) * GBK2K_BYTE4_RANGE + offset4)

#define GET_FOUR_BYTES_OFFSET_FROM_BYTES(byte1, byte2, byte3, byte4) \
    (((byte1) - GBK2K_BYTE1_MIN) * GBK2K_BYTE2_RANGE * GBK2K_BYTE3_RANGE * GBK2K_BYTE4_RANGE + \
     ((byte2) - GBK2K_BYTE2_MIN) * GBK2K_BYTE3_RANGE * GBK2K_BYTE4_RANGE + \
     ((byte3) - GBK2K_BYTE3_MIN) * GBK2K_BYTE4_RANGE + \
     ((byte4) - GBK2K_BYTE4_MIN))

#define IS_HIGH_SURROGATE(wch) (((wch) >= 0xd800) && ((wch) <= 0xdbff))
#define IS_LOW_SURROGATE(wch)  (((wch) >= 0xdc00) && ((wch) <= 0xdfff))

extern const BYTE g_wUnicodeToGBTwoBytes[];
extern const WORD g_wUnicodeToGB[];
extern const WORD g_wMax4BytesOffset;
extern const DWORD g_dwSurrogateOffset;
extern const WORD g_wGBFourBytesToUnicode[];
extern const WORD g_wGBLeadByteOffset[];
extern const WORD g_wUnicodeFromGBTwoBytes[];

DWORD GetBytesToUnicodeCount(
    BYTE* lpMultiByteStr,
    int cchMultiByte,
    BOOL bSupportDecoder);

STDAPI_(DWORD) BytesToUnicode(
    BYTE* lpMultiByteStr,
    UINT cchMultiByte,
    UINT* pcchLeftOverBytes,
    LPWSTR lpWideCharStr,
    UINT cchWideChar);

DWORD GetUnicodeToBytesCount(
    LPWSTR lpWideCharStr,
    int cchWideChar);

STDAPI_(DWORD) UnicodeToBytes(
    LPWSTR lpWideCharStr,
    UINT cchWideChar,
    LPSTR lpMultiByteStr,
    UINT cchMultiByte);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\data\dlls\gb18030\c_gb18030.cpp ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    c_gb18030.c

Abstract:

    This file contains functions to convert GB18030-2000 (code page 54936) into Unicode, and vice versa.
    The target module is c_g18030.dll.  This will be the external DLL used by WideCharToMultiByte()
    and MultiByteToWideChar() to perform the conversion for GB18030 codepage.

    External Routines in this file:
      DllEntry
      NlsDllCodePageTranslation

Notes:
    GB18030-2000 (aka GBK2K) is designed to be mostly compatible with GBK (codepage 936), 
    while supports the full range of Unicode code points (BMP + 16 supplementary planes).

    The structure for GB18030 is:
        * Single byte: 
            0x00 ~ 0x7f
        * Two-byte: 
            0x81 ~ 0xfe, 0x40 ~ 0x7e    (leading byte, trailing byte)
            0x81 ~ 0xfe, 0x80 ~ 0xfe    (leading byte, trailing byte)
        * Four-byte:
            0x81 ~ 0xfe, 0x30 ~ 0x39, 0x81 ~ 0xfe, 0x30 ~ 0x39.
    
Revision History:

    02-20-2001    YSLin    Created.
    
--*/




//
//  Include Files.
//

#include <share.h>
#include "c_gb18030.h"

//
//  Constant Declarations.
//


//
// Structure used in GetCPInfo().
//
CPINFO g_CPInfo = 
{
    //UINT    MaxCharSize;
    4,
    //BYTE    DefaultChar[MAX_DEFAULTCHAR];
    {0x3f, 0x00},
    //BYTE    LeadByte[MAX_LEADBYTES];
    // Since GBK2K can have up to 4 bytes, we don't return
    // 0x81-0xfe as lead bytes here.
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00},    
};

#define SURROGATE_OFFSET GET_FOUR_BYTES_OFFSET_FROM_BYTES(0x90, 0x30, 0x81, 0x30)


//-------------------------------------------------------------------------//
//                            EXTERNAL ROUTINES                            //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  NlsDllCodePageTranslation
//
//  This routine is the main exported procedure for the functionality in
//  this DLL.  All calls to this DLL must go through this function.
//
//  02-20-2001    YSLin    Created.
////////////////////////////////////////////////////////////////////////////

STDAPI_(DWORD) NlsDllCodePageTranslation(
    DWORD CodePage,
    DWORD dwFlags,
    LPSTR lpMultiByteStr,
    int cchMultiByte,
    LPWSTR lpWideCharStr,
    int cchWideChar,
    LPCPINFO lpCPInfo)
{

    //
    //  Error out if internally needed c_*.nls file is not installed.
    //
    if (!IsValidCodePage(CODEPAGE_GBK))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    switch (dwFlags)
    {
        case ( NLS_CP_CPINFO ) :
        {
            memcpy(lpCPInfo, &g_CPInfo, sizeof(CPINFO));
            return (TRUE);
        }
        case ( NLS_CP_MBTOWC ) :
        {
            return (BytesToUnicode((BYTE*)lpMultiByteStr, cchMultiByte, NULL, lpWideCharStr, cchWideChar));
        }
        case ( NLS_CP_WCTOMB ) :
        {
            return (UnicodeToBytes(lpWideCharStr, cchWideChar, lpMultiByteStr, cchMultiByte));
        }
    }

    //
    //  This shouldn't happen since this gets called by the NLS APIs.
    //
    SetLastError(ERROR_INVALID_PARAMETER);
    return (0);
}

//-------------------------------------------------------------------------//
//                            INTERNAL ROUTINES                            //
//-------------------------------------------------------------------------//

////////////////////////////////////////////////////////////////////////////
//
//  GetBytesToUnicodeCount
//
//  Return the Unicode character count needed to convert the specified
//  GB18030 multi-byte string.
//
//  Parameters:
//      lpMultiByteStr  The multi-byte string to be converted.
//      cchMultiByte    The byte size of the multi-byte string to be converted
//      bSupportEncoder If TRUE and we have a lead byte at the end of string,
//                      we will not convert that lead byte.  Otherwise,
//                      convert it to the default character.
//
//  02-21-2001    YSLin    Created.
////////////////////////////////////////////////////////////////////////////

DWORD GetBytesToUnicodeCount(BYTE* lpMultiByteStr, int cchMultiByte, BOOL bSupportEncoder)
{
    int i = 0;
    BYTE ch;
    DWORD cchWCCount = 0;
    WORD wOffset;
    BYTE offset1, offset2, offset3, offset4;
    DWORD dwFourBytesOffset;
    
    if (cchMultiByte == -1)
    {
        cchMultiByte = strlen((LPSTR)lpMultiByteStr);
    }
    
    while (i < cchMultiByte)
    {
        ch = lpMultiByteStr[i];
        if (ch <= 0x7f)
        {
            cchWCCount++;
            i++;
        } else if (IS_GB_LEAD_BYTE(ch))
        {
            offset1 = (ch - GBK2K_BYTE1_MIN);
            //
            // If this is a lead byte, look ahead to see if this is
            // a two-byte GB18030 or four-byte GB18030.
            //
            if (i+1 < cchMultiByte)
            {
                if (IS_GB_TWO_BYTES_TRAILING(lpMultiByteStr[i+1]))
                {
                    
                    //
                    // The trailing byte is a GB18030 two-byte.
                    //
                    cchWCCount++;
                    i += 2;                        
                } else if (i+3 < cchMultiByte) 
                {
                    //
                    // Check if this is a four-byte GB18030.
                    //
                    if (IS_GB_FOUR_BYTES_TRAILING(lpMultiByteStr[i+1]) &&
                        IS_GB_LEAD_BYTE(lpMultiByteStr[i+2]) &&
                        IS_GB_FOUR_BYTES_TRAILING(lpMultiByteStr[i+3]))
                    {
                        offset2 = lpMultiByteStr[i+1] - GBK2K_BYTE2_MIN;
                        offset3 = lpMultiByteStr[i+2] - GBK2K_BYTE3_MIN;
                        offset4 = lpMultiByteStr[i+3] - GBK2K_BYTE4_MIN;
                        //
                        // Four-byte GB18030
                        //
                        dwFourBytesOffset = GET_FOUR_BYTES_OFFSET(offset1, offset2, offset3, offset4);
                        if (dwFourBytesOffset <= g_wMax4BytesOffset) 
                        {
                            //
                            // The Unicode will be in the BMP range.
                            //
                            cchWCCount++;
                            i += 4;
                        } else if (dwFourBytesOffset >= SURROGATE_OFFSET)
                        {
                            //
                            // This will be converted to a surrogate pair.
                            //
                            cchWCCount+=2;
                            i += 4;
                        } else {
                            //
                            // Undefined GBK2K code point.
                            //
                            cchWCCount++;
                            i++;
                        }                        
                    } else 
                    {
                        if (bSupportEncoder)
                        {
                            // Set i to cchMultiByte so that we will bail out the while loop.
                            i = cchMultiByte;
                        } else 
                        {
                            //
                            // We have a lead byte, but do have have a valid trailing byte.
                            //
                            // Use default Unicode char.
                            i++;
                            cchWCCount++;
                        }                    
                    }
                }else
                {
                    if (bSupportEncoder)
                    {
                        // Set i to cchMultiByte so that we will bail out the while loop.
                        i = cchMultiByte;
                    } else 
                    {
                        //
                        // We have a lead byte, but do have have a valid trailing byte.
                        //
                        // Use default Unicode char.
                        i++;
                        cchWCCount++;
                    }
                }
            } else
            {
                //
                // We have a lead byte at the end of the string.
                //
                if (bSupportEncoder)
                {
                    i++;
                } else
                {
                    // Use default Unicode char.
                    i++;
                    cchWCCount++;
                }
            }
        }else
        {
            //
            // This byte is NOT between 0x00 ~ 0x7f, and not a lead byte.
            // Use the default character.
            //
            i++;
            cchWCCount++;
        }
    }

    return (cchWCCount);
    
}

BOOL __forceinline PutDefaultCharacter(UINT* pCchWCCount, UINT cchWideChar, LPWSTR lpWideCharStr)
{
    //
    // This byte is NOT between 0x00 ~ 0x7f, not a lead byte.
    //
    if (*pCchWCCount >= cchWideChar)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (FALSE);
    }
    lpWideCharStr[(*pCchWCCount)++] = GB18030_DEFAULT_UNICODE_CHAR; 
    return (TRUE);
}

STDAPI_(DWORD) BytesToUnicode(
    BYTE* lpMultiByteStr,
    UINT cchMultiByte,
    UINT* pcchLeftOverBytes,
    LPWSTR lpWideCharStr,
    UINT cchWideChar)
{

    UINT i = 0;
    BYTE ch;
    UINT cchWCCount = 0;
    BYTE offset1, offset2, offset3, offset4;
    WORD wOffset;
    DWORD dwOffset;
    int nResult;
    
    if (lpWideCharStr == NULL)
    {
        return (GetBytesToUnicodeCount(lpMultiByteStr, cchMultiByte, (pcchLeftOverBytes != NULL)));
    }
    
    if (cchMultiByte == -1)
    {
        cchMultiByte = strlen((LPSTR)lpMultiByteStr);
    }

    if (pcchLeftOverBytes != NULL)
    {
        *pcchLeftOverBytes = 0;
    }

    //
    // NOTENOTE YSLin:
    // If you make fix in the following code, remember to make the appropriate fix
    // in GetBytesToUnicodeCount() as well.
    //
    while (i < cchMultiByte)
    {
        ch = lpMultiByteStr[i];
        if (ch <= 0x7f)
        {
            // 
            // This byte is from 0x00 ~ 0x7f.
            //
            if (cchWCCount >= cchWideChar)
            {
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                return (0);
            }                
            lpWideCharStr[cchWCCount++] = ch;
            i++;
        } else if (IS_GB_LEAD_BYTE(ch))
        {
            offset1 = ch - GBK2K_BYTE1_MIN;
            //
            // If this is a lead byte, just look ahead to see if this is
            // a two-byte GB18030 or four-byte GB18030.
            //
            if (i+1 < cchMultiByte)
            {
                if (IS_GB_TWO_BYTES_TRAILING(lpMultiByteStr[i+1]))
                {
                    //
                    // The trailing byte is a GB18030 two-byte.
                    //
                
                    //
                    // Look up the table to see if we have the table for
                    // the mapping Unicode character.
                    //                
                    wOffset = g_wGBLeadByteOffset[ch - 0x80];
                    if (wOffset == 0x0000)
                    {
                        if (cchWCCount == cchWideChar)
                        {
                            SetLastError(ERROR_INSUFFICIENT_BUFFER);
                            return (0);
                        }
                        //
                        // We don't have the table, because this is a GBK compatible two-byte GB18030.
                        //
                        
                        //
                        // Two-byte GB18030
                        //
                        nResult = MultiByteToWideChar(CODEPAGE_GBK, 0, (LPCSTR)(lpMultiByteStr+i), 2, lpWideCharStr+cchWCCount, 1);
                        if (nResult == 0)
                        {
                            return (0);
                        }
                        cchWCCount++; 
                        i += 2;                        
                    } else
                    {
                        if (cchWCCount == cchWideChar)
                        {
                            SetLastError(ERROR_INSUFFICIENT_BUFFER);
                            return (0);
                        }                                    
                        wOffset -= 0x0100;
                        lpWideCharStr[cchWCCount++] = g_wUnicodeFromGBTwoBytes[wOffset + lpMultiByteStr[i+1]];
                        i+= 2;
                    }                
                } else if (i+3 < cchMultiByte) 
                {
                    if (IS_GB_FOUR_BYTES_TRAILING(lpMultiByteStr[i+1]) &&
                        IS_GB_LEAD_BYTE(lpMultiByteStr[i+2]) &&
                        IS_GB_FOUR_BYTES_TRAILING(lpMultiByteStr[i+3]))
                    {
                        offset2 = lpMultiByteStr[i+1] - GBK2K_BYTE2_MIN;
                        offset3 = lpMultiByteStr[i+2] - GBK2K_BYTE3_MIN;
                        offset4 = lpMultiByteStr[i+3] - GBK2K_BYTE4_MIN;
                        
                        //
                        // Four-byte GB18030
                        //
                        dwOffset = GET_FOUR_BYTES_OFFSET(offset1, offset2, offset3, offset4);
                        if (dwOffset <= g_wMax4BytesOffset) 
                        {
                            if (cchWCCount == cchWideChar)
                            {
                                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                                return (0);
                            }                                    
                        
                            //
                            // The Unicode will be in the BMP range.
                            //
                            lpWideCharStr[cchWCCount++] = g_wGBFourBytesToUnicode[dwOffset];
                            i += 4;
                        } else if (dwOffset >= SURROGATE_OFFSET) 
                        {
                            if (cchWCCount + 2 > cchWideChar)
                            {
                                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                                return (0);
                            }                                    
                            //
                            // This will be converted to a surrogate pair.
                            //
                            dwOffset -= SURROGATE_OFFSET;
                            lpWideCharStr[cchWCCount++] = 0xd800 + (WORD)(dwOffset / 0x400);
                            lpWideCharStr[cchWCCount++] = 0xdc00 + (WORD)(dwOffset % 0x400);
                            i += 4;
                        } else
                        {
                            //
                            // Undefined GBK2K code point.
                            //
                            if (!PutDefaultCharacter(&cchWCCount, cchWideChar, lpWideCharStr))
                            {
                                return (0);
                            }    
                            i++;
                        }   
                    }else
                    {
                        if (!PutDefaultCharacter(&cchWCCount, cchWideChar, lpWideCharStr))
                        {
                            return (0);
                        }
                        i++;
                    }                    
                }else
                {
                    if (pcchLeftOverBytes != NULL)
                    {
                        *pcchLeftOverBytes = cchMultiByte - i;
                        // Set i to cchMultiByte so that we will bail out the while loop.
                        i = cchMultiByte;
                    } else 
                    {
                        //
                        // We have a lead byte, but do have have a valid trailing byte.
                        //
                        // Use default Unicode char.
                        if (!PutDefaultCharacter(&cchWCCount, cchWideChar, lpWideCharStr))
                        {
                            return (0);
                        }
                        i++;
                    }
                }
            } else
            {
                if (pcchLeftOverBytes != NULL) 
                {
                    *pcchLeftOverBytes = 1;
                    i++;
                } else
                {
                    // We have a lead byte, but do have have a trailing byte.
                    // Use default Unicode char.
                    if (!PutDefaultCharacter(&cchWCCount, cchWideChar, lpWideCharStr))
                    {
                        return (0);
                    }
                    i++;
                }
            }
        } else 
        {
            if (!PutDefaultCharacter(&cchWCCount, cchWideChar, lpWideCharStr))
            {
                return (0);
            }
            i++;
        }
    }
    return (cchWCCount);
}

DWORD GetUnicodeToBytesCount(LPWSTR lpWideCharStr, int cchWideChar)
{
    int i;
    WORD wch;
    int cchMBCount = 0;
    DWORD wOffset;

    if (cchWideChar == -1)
    {
        cchWideChar = wcslen(lpWideCharStr);
    }
    
    for (i = 0; i < cchWideChar; i++) 
    {
        wch = lpWideCharStr[i];

        if (wch <= 0x7f)
        {
            // One-byte GB18030.
            cchMBCount++;
        } else if (IS_HIGH_SURROGATE(wch))
        {
            //
            // Look ahead one character to see if the next char is a low surrogate.
            //
            if (i + 1 < cchWideChar)
            {
                if (IS_LOW_SURROGATE(lpWideCharStr[ i+1 ]))
                {
                    //
                    // Found a surrogate pair.  This will be a four-byte GB18030.
                    //
                    cchMBCount += 4;    
                    i++;
                } else
                {
                    //
                    // A High surrogate character without a trailing low surrogate character.
                    // In this case, we will convert this character to a default character.
                    //
                    cchMBCount++;
                }
            } else
            {
                //
                // A High surrogate character without a valid trailing low surrogate character.
                // In this case, we will convert this character to a default character.  
                //
                cchMBCount++;
            }
        } else if (IS_LOW_SURROGATE(wch))
        {
            //
            // Only a low surrogate character without a leading high surrogate.
            // In this case, we will convert this character to a default character.  
            //
            cchMBCount++;
        } else
        {
            //
            // Not a surrogate character.  Look up the table to see this BMP Unicode character
            // will be converted to a two-byte GB18030 or four-byte GB18030.
            //
            wOffset = g_wUnicodeToGB[wch];

            if (wOffset == 0xFFFF)
            {
                //
                // This Unicode character will be converted to GBK compatible two-byte code.
                //
                cchMBCount += 2;
            } else if (wOffset <= g_wMax4BytesOffset)
            {
                //
                // This Unicode character will be converted to four-byte GB18030.
                //
                cchMBCount += 4;                    
            } else
            {
                //
                // This Unicode character will be converted to two-byte GB18030, which is not compatible
                // with GBK.
                //
                cchMBCount += 2;
            }
        }                
    }
    return (cchMBCount);
}

STDAPI_(DWORD) UnicodeToBytes(
    LPWSTR lpWideCharStr,
    UINT cchWideChar,
    LPSTR lpMultiByteStr,
    UINT cchMultiByte)
{
    UINT i;
    WORD wch;
    UINT cchMBCount = 0;
    CHAR MBTwoBytes[2];
    BYTE MBFourBytes[4];
    WORD wOffset;
    DWORD dwSurrogateOffset;
    int nResult;

    if (lpMultiByteStr == NULL)
    {
        return (GetUnicodeToBytesCount(lpWideCharStr, cchWideChar));
    }

    if (cchWideChar == -1)
    {
        cchWideChar = wcslen(lpWideCharStr);
    }
    //
    // NOTENOTE YSLin:
    // If you make fix in the following code, remember to make the appropriate fix
    // in GetUnicodeToBytesCount() as well.
    //
    for (i = 0; i < cchWideChar; i++) 
    {
        wch = lpWideCharStr[i];

        if (wch <= 0x7f)
        {
            if (cchMBCount == cchMultiByte)
            {
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                return (0);
            }
            lpMultiByteStr[cchMBCount++] = (BYTE)wch;
        } else if (IS_HIGH_SURROGATE(wch))
        {
            //
            // Look ahead one character to see if the next char is a low surrogate.
            //
            if (i + 1 < cchWideChar)
            {
                if (IS_LOW_SURROGATE(lpWideCharStr[ i+1 ]))
                {
                    if (cchMBCount + 4 > cchMultiByte)
                    {
                        SetLastError(ERROR_INSUFFICIENT_BUFFER);
                        return (0);
                    }
                
                    i++;
                    //
                    // A surrogate pair will be converted to GB 18030 four-byte from
                    // 0x90308130 ~ 0xe339fe39.
                    //                
                    dwSurrogateOffset = (wch - 0xd800) * 0x0400 + (lpWideCharStr[i] - 0xdc00);
                    lpMultiByteStr[cchMBCount+3] = (BYTE)(dwSurrogateOffset % GBK2K_BYTE4_RANGE) + GBK2K_BYTE4_MIN;
                    dwSurrogateOffset /= GBK2K_BYTE4_RANGE;
                    lpMultiByteStr[cchMBCount+2] = (BYTE)(dwSurrogateOffset % GBK2K_BYTE3_RANGE) + GBK2K_BYTE3_MIN;
                    dwSurrogateOffset /= GBK2K_BYTE3_RANGE;
                    lpMultiByteStr[cchMBCount+1] = (BYTE)(dwSurrogateOffset % GBK2K_BYTE2_RANGE) + GBK2K_BYTE2_MIN;
                    dwSurrogateOffset /= GBK2K_BYTE2_RANGE;
                    lpMultiByteStr[cchMBCount]   = (BYTE)(dwSurrogateOffset % GBK2K_BYTE1_RANGE) + 0x90;

                    cchMBCount += 4;   
                } else
                {
                    if (cchMBCount == cchMultiByte)
                    {
                        SetLastError(ERROR_INSUFFICIENT_BUFFER);
                        return (0);
                    }
                    //
                    // A High surrogate character is at the end of string.
                    // In this case, we will convert this character to a default character.  
                    //
                    lpMultiByteStr[cchMBCount++] = GB18030_DEFAULT_CHAR;
                }
            }else
            {
                if (cchMBCount >= cchMultiByte)
                {
                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    return (0);
                }
                //
                // A High surrogate character without a valid trailing low surrogate character.
                // In this case, we will convert this character to a default character.  
                //
                lpMultiByteStr[cchMBCount++] = GB18030_DEFAULT_CHAR;
            }
        } else if (IS_LOW_SURROGATE(wch))
        {
            if (cchMBCount == cchMultiByte)
            {
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                return (0);
            }
            //
            // Only a low surrogate character without a leading high surrogate.
            // In this case, we will convert this character to a default character.  
            //
            lpMultiByteStr[cchMBCount++] = GB18030_DEFAULT_CHAR;
        } else
        {
            //
            // This character is not below 0x7f, not a surrogate character.
            // Check the table to see how this Unicode character should be
            // converted.  It could be:
            //  1. Two-byte GB18030, which is compatible with GBK.  (wOffset == 0xffff)
            //  2. Two-byte GB18030, which is NOT compatible with GBK. (wOffset = 0xfffe and below)
            //  3. Four-byte GB18030. (wOffset >= 0 && wOffset < g_wMax4BytesOffset)
            //
            wOffset = g_wUnicodeToGB[wch];

            if (wOffset == 0xffff)
            {
                // 
                // This Unicode character will be converted to the same two-byte GBK code, so use GBK table.
                //
                if (cchMBCount + 2 > cchMultiByte) 
                {
                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    return (0);
                }
                nResult = WideCharToMultiByte(CODEPAGE_GBK, 0, lpWideCharStr+i, 1, lpMultiByteStr+cchMBCount, 2, NULL, NULL);
                if (nResult == 0) 
                {
                    return (0);
                }
                if (cchMBCount + nResult > cchMultiByte)
                {
                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    return (0);
                }                
                cchMBCount += nResult;
            } else if (wOffset <= g_wMax4BytesOffset)
            {
                if (cchMBCount + 4 > cchMultiByte)
                {
                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    return (0);
                }                
            
                //
                // This Unicode character will be converted to four-byte GB18030.
                //
                lpMultiByteStr[cchMBCount+3] = (wOffset % GBK2K_BYTE4_RANGE) + GBK2K_BYTE4_MIN;
                wOffset /= GBK2K_BYTE4_RANGE;
                lpMultiByteStr[cchMBCount+2] = (wOffset % GBK2K_BYTE3_RANGE) + GBK2K_BYTE3_MIN;
                wOffset /= GBK2K_BYTE3_RANGE;
                lpMultiByteStr[cchMBCount+1] = (wOffset % GBK2K_BYTE2_RANGE) + GBK2K_BYTE2_MIN;
                wOffset /= GBK2K_BYTE2_RANGE;
                lpMultiByteStr[cchMBCount]   = (wOffset % GBK2K_BYTE1_RANGE) + GBK2K_BYTE1_MIN;

                cchMBCount += 4;                    
            } else
            {
                if (cchMBCount + 2 > cchMultiByte)
                {
                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    return (0);
                }             
                //
                // This Unicode character will be converted to two-byte GB18030, which is not compatible
                // with GBK.
                //
                wOffset = 0xfffe - wOffset;
                CopyMemory(lpMultiByteStr+cchMBCount, &g_wUnicodeToGBTwoBytes[wOffset * 2], 2);
                cchMBCount += 2;
            }
        }                
    }
            
    return (cchMBCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\data\dlls\euc_db\c_eucdb.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    c_eucdb.c

Abstract:

    This file contains the main functions for this module.

    External Routines in this file:
      DllEntry
      NlsDllCodePageTranslation

Revision History:

    10-30-96    JulieB    Created.

--*/



////////////////////////////////////////////////////////////////////////////
//
//  EUC DBCS<->Unicode conversions :
//
//  51932 (Japanese) ............................. calls c_20932.nls
//  51949 (Korean) ............................... calls c_20949.nls
//  51950 (Taiwanese Traditional Chinese) ........ calls c_20950.nls
//  51936 (Chinese   Simplified  Chinese) ........ calls c_20936.nls
//
////////////////////////////////////////////////////////////////////////////



//
//  Include Files.
//

#include <share.h>




//
//  Constant Declarations.
//

#define EUC_J  51932
#define INTERNAL_CODEPAGE(cp)  ((cp) - 31000)





//-------------------------------------------------------------------------//
//                             DLL ENTRY POINT                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  DllEntry
//
//  DLL Entry initialization procedure.
//
//  10-30-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL DllEntry(
    HANDLE hModule,
    DWORD dwReason,
    LPVOID lpRes)
{
    switch (dwReason)
    {
        case ( DLL_THREAD_ATTACH ) :
        {
            return (TRUE);
        }
        case ( DLL_THREAD_DETACH ) :
        {
            return (TRUE);
        }
        case ( DLL_PROCESS_ATTACH ) :
        {
            return (TRUE);
        }
        case ( DLL_PROCESS_DETACH ) :
        {
            return (TRUE);
        }
    }

    return (FALSE);
    hModule;
    lpRes;
}





//-------------------------------------------------------------------------//
//                            EXTERNAL ROUTINES                            //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  NlsDllCodePageTranslation
//
//  This routine is the main exported procedure for the functionality in
//  this DLL.  All calls to this DLL must go through this function.
//
//  10-30-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

DWORD NlsDllCodePageTranslation(
    DWORD CodePage,
    DWORD dwFlags,
    LPSTR lpMultiByteStr,
    int cchMultiByte,
    LPWSTR lpWideCharStr,
    int cchWideChar,
    LPCPINFO lpCPInfo)
{
    int ctr;
    int cchMBTemp, cchMBCount;
    LPSTR lpMBTempStr;

    //
    //  Error out if internally needed c_*.nls file is not installed.
    //
    if (!IsValidCodePage(INTERNAL_CODEPAGE(CodePage)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    switch (dwFlags)
    {
        case ( NLS_CP_CPINFO ) :
        {
            GetCPInfo(CodePage, lpCPInfo);

            if (CodePage == EUC_J)
            {
                lpCPInfo->MaxCharSize = 3;
            }

            return (TRUE);
        }
        case ( NLS_CP_MBTOWC ) :
        {
            if (CodePage != EUC_J)
            {
                return (MultiByteToWideChar( INTERNAL_CODEPAGE(CodePage),
                                             0,
                                             lpMultiByteStr,
                                             cchMultiByte,
                                             lpWideCharStr,
                                             cchWideChar ));
            }

            //
            //  CodePage == EUC_J
            //
            //  JIS X 0212-1990
            //  0x8F is the first-byte of a 3-byte char :
            //    Remove 0x8F
            //    If there is no third byte
            //       remove the second byte as well,
            //    else
            //       leave the second byte unchanged.
            //    Mask off MSB of the third byte (Byte3 & 0x7F).
            //    Example : 0x8FA2EF -> 0xA26F
            //
            if (cchMultiByte == -1)
            {
                cchMultiByte = strlen(lpMultiByteStr) + 1;
            }

            lpMBTempStr = (LPSTR)NLS_ALLOC_MEM(cchMultiByte);
            if (lpMBTempStr == NULL)
            {
                SetLastError(ERROR_OUTOFMEMORY);
                return (0);
            }

            for (ctr = 0, cchMBTemp = 0; ctr < cchMultiByte; ctr++, cchMBTemp++)
            {
                if (lpMultiByteStr[ctr] == (char)0x8F)
                {
                    ctr++;
                    if (ctr >= (cchMultiByte - 1))
                    {
                        //
                        //  Missing second or third byte.
                        //
                        break;
                    }

                    lpMBTempStr[cchMBTemp++] = lpMultiByteStr[ctr++];
                    lpMBTempStr[cchMBTemp]   = (lpMultiByteStr[ctr] & 0x7F);
                }
                else
                {
                    lpMBTempStr[cchMBTemp] = lpMultiByteStr[ctr];
                }
            }

            cchMBCount = MultiByteToWideChar( INTERNAL_CODEPAGE(CodePage),
                                              0,
                                              lpMBTempStr,
                                              cchMBTemp,
                                              lpWideCharStr,
                                              cchWideChar );
            NLS_FREE_MEM(lpMBTempStr);

            return (cchMBCount);
        }
        case ( NLS_CP_WCTOMB ) :
        {
            if (CodePage != EUC_J)
            {
                return (WideCharToMultiByte( INTERNAL_CODEPAGE(CodePage),
                                             WC_NO_BEST_FIT_CHARS,
                                             lpWideCharStr,
                                             cchWideChar,
                                             lpMultiByteStr,
                                             cchMultiByte,
                                             NULL,
                                             NULL ));
            }

            //
            //  CodePage == EUC_J
            //
            //  Check char for JIS X 0212-1990
            //  if a lead-byte (>= 0x80) followed by a trail-byte (< 0x80)
            //  then
            //    insert 0x8F which is the first byte of a 3-byte char
            //    lead-byte becomes the second byte
            //    turns on MSB of trail-byte which becomes the third byte
            //    Example : 0xA26F -> 0x8FA2EF
            //
            if (cchWideChar == -1)
            {
                cchWideChar = wcslen(lpWideCharStr);
            }

            cchMBTemp = cchWideChar * (sizeof(WCHAR) + 1) + 1;
            lpMBTempStr = (LPSTR)NLS_ALLOC_MEM(cchMBTemp);
            if (lpMBTempStr == NULL)
            {
                SetLastError(ERROR_OUTOFMEMORY);
                return (0);
            }

            cchMBCount = WideCharToMultiByte( INTERNAL_CODEPAGE(CodePage),
                                              WC_NO_BEST_FIT_CHARS,
                                              lpWideCharStr,
                                              cchWideChar,
                                              lpMBTempStr,
                                              cchMBTemp,
                                              NULL,
                                              NULL );

            for (ctr = 0, cchMBTemp = 0;
                 ctr < cchMBCount, cchMBTemp < cchMultiByte;
                 ctr++, cchMBTemp++)
            {
                if (lpMBTempStr[ctr] & 0x80)
                {
                    //
                    //  It's a lead byte.
                    //
                    if (lpMBTempStr[ctr + 1] & 0x80)
                    {
                        //
                        //  It's a non JIS X 0212-1990 char.
                        //
                        if (cchMultiByte)
                        {
                            if (cchMBTemp < (cchMultiByte - 1))
                            {
                                lpMultiByteStr[cchMBTemp]     = lpMBTempStr[ctr];
                                lpMultiByteStr[cchMBTemp + 1] = lpMBTempStr[ctr + 1];
                            }
                            else
                            {
                                //
                                //  No room for trail byte.
                                //
                                lpMultiByteStr[cchMBTemp++] = '?';
                                break;
                            }
                        }
                    }
                    else
                    {
                        //
                        //  It's a JIS X 0212-1990 char.
                        //
                        if (cchMultiByte)
                        {
                            if (cchMBTemp < (cchMultiByte - 2))
                            {
                                lpMultiByteStr[cchMBTemp]     = (char) 0x8F;
                                lpMultiByteStr[cchMBTemp + 1] = lpMBTempStr[ctr];
                                lpMultiByteStr[cchMBTemp + 2] = (lpMBTempStr[ctr + 1] | 0x80);
                            }
                            else
                            {
                                //
                                //  No room for two trail bytes.
                                //
                                lpMultiByteStr[cchMBTemp++] = '?';
                                break;
                            }
                        }
                        cchMBTemp++;
                    }
                    cchMBTemp++;
                    ctr++;
                }
                else
                {
                    if (cchMultiByte && (cchMBTemp < cchMultiByte))
                    {
                        lpMultiByteStr[cchMBTemp] = lpMBTempStr[ctr];
                    }
                }
            }

            //
            //  See if the output buffer is too small.
            //
            if (cchMultiByte && (cchMBTemp >= cchMultiByte))
            {
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                return (0);
            }

            NLS_FREE_MEM (lpMBTempStr);

            return (cchMBTemp);
        }
    }

    //
    //  This shouldn't happen since this gets called by the NLS APIs.
    //
    SetLastError(ERROR_INVALID_PARAMETER);
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\data\dlls\iscii\tables.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    tables.c

Abstract:

    This file contains the table information for this module.

Revision History:

      2-28-98    KChang    Created.

--*/



//
//  Include Files.
//

#include <share.h>
#include "c_iscii.h"




////////////////////////////////////////////////////////////////////////////
//
//  Devanagari
//
////////////////////////////////////////////////////////////////////////////

WCHAR pwcDEV[] =
{
//     a0,     a1,     a2,     a3,     a4,     a5,     a6,     a7,
   0x003F, 0x0901, 0x0902, 0x0903, 0x0905, 0x0906, 0x0907, 0x0908,
//     a8,     a9,     aa,     ab,     ac,     ad,     ae,     af,
   0x0909, 0x090a, 0x090b, 0x090e, 0x090f, 0x0910, 0x090d, 0x0912,
//     b0,     b1,     b2,     b3,     b4,     b5,     b6,     b7,
   0x0913, 0x0914, 0x0911, 0x0915, 0x0916, 0x0917, 0x0918, 0x0919,
//     b8,     b9,     ba,     bb,     bc,     bd,     be,     bf,
   0x091a, 0x091b, 0x091c, 0x091d, 0x091e, 0x091f, 0x0920, 0x0921,
//     c0,     c1,     c2,     c3,     c4,     c5,     c6,     c7,
   0x0922, 0x0923, 0x0924, 0x0925, 0x0926, 0x0927, 0x0928, 0x0929,
//     c8,     c9,     ca,     cb,     cc,     cd,     ce,     cf,
   0x092a, 0x092b, 0x092c, 0x092d, 0x092e, 0x092f, 0x095f, 0x0930,
//     d0,     d1,     d2,     d3,     d4,     d5,     d6,     d7,
   0x0931, 0x0932, 0x0933, 0x0934, 0x0935, 0x0936, 0x0937, 0x0938,
//     d8,     d9,     da,     db,     dc,     dd,     de,     df,
   0x0939, 0x003F, 0x093e, 0x093f, 0x0940, 0x0941, 0x0942, 0x0943,
//     e0,     e1,     e2,     e3,     e4,     e5,     e6,     e7,
   0x0946, 0x0947, 0x0948, 0x0945, 0x094a, 0x094b, 0x094c, 0x0949,
//     e8,     e9,     ea,     eb,     ec,     ed,     ee,     ef,
   0x094d, 0x093c, 0x0964, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F,
//     f0,     f1,     f2,     f3,     f4,     f5,     f6,     f7,
   0x003F, 0x0966, 0x0967, 0x0968, 0x0969, 0x096a, 0x096b, 0x096c,
//     f8,     f9,     fa,     fb,     fc,     fd,     fe,     ff
   0x096d, 0x096e, 0x096f, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F
};


WCHAR pwcDEV2[] =
{
//     a0,     a1,     a2,     a3,     a4,     a5,     a6,     a7,
        0, 0x0950,      0,      0,      0,      0, 0x090c, 0x0961,
//     a8,     a9,     aa,     ab,     ac,     ad,     ae,     af,
        0,      0, 0x0960,      0,      0,      0,      0,      0,
//     b0,     b1,     b2,     b3,     b4,     b5,     b6,     b7,
        0,      0,      0, 0x0958, 0x0959, 0x095a,      0,      0,
//     b8,     b9,     ba,     bb,     bc,     bd,     be,     bf,
        0,      0, 0x095b,      0,      0,      0,      0, 0x095c,
//     c0,     c1,     c2,     c3,     c4,     c5,     c6,     c7,
   0x095d,      0,      0,      0,      0,      0,      0,      0,
//     c8,     c9,     ca,     cb,     cc,     cd,     ce,     cf,
        0, 0x095e,      0,      0,      0,      0,      0,      0,
//     d0,     d1,     d2,     d3,     d4,     d5,     d6,     d7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     d8,     d9,     da,     db,     dc,     dd,     de,     df,
        0,      0,      0, 0x0962, 0x0963,      0,      0, 0x0944,
//     e0,     e1,     e2,     e3,     e4,     e5,     e6,     e7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     e8,     e9,     ea,     eb,     ec,     ed,     ee,     ef,
   0x200C, 0x200D, 0x093d,      0,      0,      0,      0,      0,
//     f0,     f1,     f2,     f3,     f4,     f5,     f6,     f7,
   0xB8BF,      0,      0,      0,      0,      0,      0,      0,
//     f8,     f9,     fa,     fb,     fc,     fd,     fe,     ff
        0,      0,      0,      0,      0,      0,      0,      0,
};


////////////////////////////////////////////////////////////////////////////
//
//  Bengali
//
////////////////////////////////////////////////////////////////////////////

WCHAR pwcBNG[] =
{
//     a0,     a1,     a2,     a3,     a4,     a5,     a6,     a7,
   0x003F, 0x0981, 0x0982, 0x0983, 0x0985, 0x0986, 0x0987, 0x0988,
//     a8,     a9,     aa,     ab,     ac,     ad,     ae,     af,
   0x0989, 0x098a, 0x098b, 0x098f, 0x098f, 0x0990, 0x0990, 0x0993,
//     b0,     b1,     b2,     b3,     b4,     b5,     b6,     b7,
   0x0993, 0x0994, 0x0994, 0x0995, 0x0996, 0x0997, 0x0998, 0x0999,
//     b8,     b9,     ba,     bb,     bc,     bd,     be,     bf,
   0x099a, 0x099b, 0x099c, 0x099d, 0x099e, 0x099f, 0x09a0, 0x09a1,
//     c0,     c1,     c2,     c3,     c4,     c5,     c6,     c7,
   0x09a2, 0x09a3, 0x09a4, 0x09a5, 0x09a6, 0x09a7, 0x09a8, 0x09a8,
//     c8,     c9,     ca,     cb,     cc,     cd,     ce,     cf,
   0x09aa, 0x09ab, 0x09ac, 0x09ad, 0x09ae, 0x09af, 0x09df, 0x09b0,
//     d0,     d1,     d2,     d3,     d4,     d5,     d6,     d7,
   0x09b0, 0x09b2, 0x09b2, 0x09b2, 0x09ac, 0x09b6, 0x09b7, 0x09b8,
//     d8,     d9,     da,     db,     dc,     dd,     de,     df,
   0x09b9, 0x003F, 0x09be, 0x09bf, 0x09c0, 0x09c1, 0x09c2, 0x09c3,
//     e0,     e1,     e2,     e3,     e4,     e5,     e6,     e7,
   0x09c7, 0x09c7, 0x09c8, 0x09c8, 0x09cb, 0x09cb, 0x09cc, 0x09cc,
//     e8,     e9,     ea,     eb,     ec,     ed,     ee,     ef,
   0x09cd, 0x09bc, 0x002e, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F,
//     f0,     f1,     f2,     f3,     f4,     f5,     f6,     f7,
   0x003F, 0x09e6, 0x09e7, 0x09e8, 0x09e9, 0x09ea, 0x09eb, 0x09ec,
//     f8,     f9,     fa,     fb,     fc,     fd,     fe,     ff
   0x09ed, 0x09ee, 0x09ef, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F
};


WCHAR pwcBNG2[] =
{
//     a0,     a1,     a2,     a3,     a4,     a5,     a6,     a7,
        0,      0,      0,      0,      0,      0, 0x098c, 0x09e1,
//     a8,     a9,     aa,     ab,     ac,     ad,     ae,     af,
        0,      0, 0x09e0,      0,      0,      0,      0,      0,
//     b0,     b1,     b2,     b3,     b4,     b5,     b6,     b7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     b8,     b9,     ba,     bb,     bc,     bd,     be,     bf,
        0,      0,      0,      0,      0,      0,      0, 0x09dc,
//     c0,     c1,     c2,     c3,     c4,     c5,     c6,     c7,
   0x09dd,      0,      0,      0,      0,      0,      0,      0,
//     c8,     c9,     ca,     cb,     cc,     cd,     ce,     cf,
        0,      0,      0,      0,      0,      0,      0,      0,
//     d0,     d1,     d2,     d3,     d4,     d5,     d6,     d7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     d8,     d9,     da,     db,     dc,     dd,     de,     df,
        0,      0,      0, 0x09e2, 0x09e3,      0,      0, 0x09c4,
//     e0,     e1,     e2,     e3,     e4,     e5,     e6,     e7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     e8,     e9,     ea,     eb,     ec,     ed,     ee,     ef,
   0x200C, 0x200D,      0,      0,      0,      0,      0,      0,
//     f0,     f1,     f2,     f3,     f4,     f5,     f6,     f7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     f8,     f9,     fa,     fb,     fc,     fd,     fe,     ff
        0,      0,      0,      0,      0,      0,      0,      0,
};


////////////////////////////////////////////////////////////////////////////
//
//  Tamil
//
////////////////////////////////////////////////////////////////////////////

WCHAR pwcTML[] =
{
//     a0,     a1,     a2,     a3,     a4,     a5,     a6,     a7,
   0x003F, 0x003F, 0x0b82, 0x0b83, 0x0b85, 0x0b86, 0x0b87, 0x0b88,
//     a8,     a9,     aa,     ab,     ac,     ad,     ae,     af,
   0x0b89, 0x0b8a, 0x003F, 0x0b8f, 0x0b8f, 0x0b90, 0x0b90, 0x0b92,
//     b0,     b1,     b2,     b3,     b4,     b5,     b6,     b7,
   0x0b93, 0x0b94, 0x0b94, 0x0b95, 0x0b95, 0x0b95, 0x0b95, 0x0b99,
//     b8,     b9,     ba,     bb,     bc,     bd,     be,     bf,
   0x0b9a, 0x0b9a, 0x0b9c, 0x0b9c, 0x0b9e, 0x0b9f, 0x0b9f, 0x0b9f,
//     c0,     c1,     c2,     c3,     c4,     c5,     c6,     c7,
   0x0b9f, 0x0ba3, 0x0ba4, 0x0ba4, 0x0ba4, 0x0ba4, 0x0ba8, 0x0ba9,
//     c8,     c9,     ca,     cb,     cc,     cd,     ce,     cf,
   0x0baa, 0x0baa, 0x0baa, 0x0baa, 0x0bae, 0x0baf, 0x0baf, 0x0bb0,
//     d0,     d1,     d2,     d3,     d4,     d5,     d6,     d7,
   0x0bb1, 0x0bb2, 0x0bb3, 0x0bb4, 0x0bb5, 0x0bb7, 0x0bb7, 0x0bb8,
//     d8,     d9,     da,     db,     dc,     dd,     de,     df,
   0x0bb9, 0x003F, 0x0bbe, 0x0bbf, 0x0bc0, 0x0bc1, 0x0bc2, 0x003F,
//     e0,     e1,     e2,     e3,     e4,     e5,     e6,     e7,
   0x0bc6, 0x0bc7, 0x0bc8, 0x0bc8, 0x0bca, 0x0bcb, 0x0bcc, 0x0bcc,
//     e8,     e9,     ea,     eb,     ec,     ed,     ee,     ef,
   0x0bcd, 0x003F, 0x002e, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F,
//     f0,     f1,     f2,     f3,     f4,     f5,     f6,     f7,
   0x003F, 0x0030, 0x0be7, 0x0be8, 0x0be9, 0x0bea, 0x0beb, 0x0bec,
//     f8,     f9,     fa,     fb,     fc,     fd,     fe,     ff
   0x0bed, 0x0bee, 0x0bef, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F
};


WCHAR pwcTML2[]=
{
//     a0,     a1,     a2,     a3,     a4,     a5,     a6,     a7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     a8,     a9,     aa,     ab,     ac,     ad,     ae,     af,
        0,      0,      0,      0,      0,      0,      0,      0,
//     b0,     b1,     b2,     b3,     b4,     b5,     b6,     b7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     b8,     b9,     ba,     bb,     bc,     bd,     be,     bf,
        0,      0,      0,      0,      0,      0,      0,      0,
//     c0,     c1,     c2,     c3,     c4,     c5,     c6,     c7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     c8,     c9,     ca,     cb,     cc,     cd,     ce,     cf,
        0,      0,      0,      0,      0,      0,      0,      0,
//     d0,     d1,     d2,     d3,     d4,     d5,     d6,     d7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     d8,     d9,     da,     db,     dc,     dd,     de,     df,
        0,      0,      0,      0,      0,      0,      0,      0,
//     e0,     e1,     e2,     e3,     e4,     e5,     e6,     e7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     e8,     e9,     ea,     eb,     ec,     ed,     ee,     ef,
   0x200C, 0x200D,      0,      0,      0,      0,      0,      0,
//     f0,     f1,     f2,     f3,     f4,     f5,     f6,     f7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     f8,     f9,     fa,     fb,     fc,     fd,     fe,     ff
        0,      0,      0,      0,      0,      0,      0,      0,
};


////////////////////////////////////////////////////////////////////////////
//
//  Telugu
//
////////////////////////////////////////////////////////////////////////////

WCHAR pwcTLG[] =
{
//     a0,     a1,     a2,     a3,     a4,     a5,     a6,     a7,
   0x003F, 0x0c01, 0x0c02, 0x0c03, 0x0c05, 0x0c06, 0x0c07, 0x0c08,
//     a8,     a9,     aa,     ab,     ac,     ad,     ae,     af,
   0x0c09, 0x0c0a, 0x0c0b, 0x0c0e, 0x0c0f, 0x0c10, 0x0c10, 0x0c12,
//     b0,     b1,     b2,     b3,     b4,     b5,     b6,     b7,
   0x0c13, 0x0c14, 0x0c14, 0x0c15, 0x0c16, 0x0c17, 0x0c18, 0x0c19,
//     b8,     b9,     ba,     bb,     bc,     bd,     be,     bf,
   0x0c1a, 0x0c1b, 0x0c1c, 0x0c1d, 0x0c1e, 0x0c1f, 0x0c20, 0x0c21,
//     c0,     c1,     c2,     c3,     c4,     c5,     c6,     c7,
   0x0c22, 0x0c23, 0x0c24, 0x0c25, 0x0c26, 0x0c27, 0x0c28, 0x0c28,
//     c8,     c9,     ca,     cb,     cc,     cd,     ce,     cf,
   0x0c2a, 0x0c2b, 0x0c2c, 0x0c2d, 0x0c2e, 0x0c2f, 0x0c2f, 0x0c30,
//     d0,     d1,     d2,     d3,     d4,     d5,     d6,     d7,
   0x0c31, 0x0c32, 0x0c33, 0x0c33, 0x0c35, 0x0c36, 0x0c37, 0x0c38,
//     d8,     d9,     da,     db,     dc,     dd,     de,     df,
   0x0c39, 0x003F, 0x0c3e, 0x0c3f, 0x0c40, 0x0c41, 0x0c42, 0x0c43,
//     e0,     e1,     e2,     e3,     e4,     e5,     e6,     e7,
   0x0c46, 0x0c47, 0x0c48, 0x0c48, 0x0c4a, 0x0c4b, 0x0c4c, 0x0c4c,
//     e8,     e9,     ea,     eb,     ec,     ed,     ee,     ef,
   0x0c4d, 0x003F, 0x002e, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F,
//     f0,     f1,     f2,     f3,     f4,     f5,     f6,     f7,
   0x003F, 0x0c66, 0x0c67, 0x0c68, 0x0c69, 0x0c6a, 0x0c6b, 0x0c6c,
//     f8,     f9,     fa,     fb,     fc,     fd,     fe,     ff
   0x0c6d, 0x0c6e, 0x0c6f, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F
};


WCHAR pwcTLG2[] =
{
//     a0,     a1,     a2,     a3,     a4,     a5,     a6,     a7,
        0,      0,      0,      0,      0,      0, 0x0c0c, 0x0c61,
//     a8,     a9,     aa,     ab,     ac,     ad,     ae,     af,
        0,      0, 0x0c60,      0,      0,      0,      0,      0,
//     b0,     b1,     b2,     b3,     b4,     b5,     b6,     b7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     b8,     b9,     ba,     bb,     bc,     bd,     be,     bf,
        0,      0,      0,      0,      0,      0,      0,      0,
//     c0,     c1,     c2,     c3,     c4,     c5,     c6,     c7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     c8,     c9,     ca,     cb,     cc,     cd,     ce,     cf,
        0,      0,      0,      0,      0,      0,      0,      0,
//     d0,     d1,     d2,     d3,     d4,     d5,     d6,     d7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     d8,     d9,     da,     db,     dc,     dd,     de,     df,
        0,      0,      0,      0,      0,      0,      0, 0x0c44,
//     e0,     e1,     e2,     e3,     e4,     e5,     e6,     e7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     e8,     e9,     ea,     eb,     ec,     ed,     ee,     ef,
   0x200C, 0x200D,      0,      0,      0,      0,      0,      0,
//     f0,     f1,     f2,     f3,     f4,     f5,     f6,     f7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     f8,     f9,     fa,     fb,     fc,     fd,     fe,     ff
        0,      0,      0,      0,      0,      0,      0,      0,
};


////////////////////////////////////////////////////////////////////////////
//
//  Oriya
//
////////////////////////////////////////////////////////////////////////////

WCHAR pwcORI[] =
{
//     a0,     a1,     a2,     a3,     a4,     a5,     a6,     a7,
   0x003F, 0x0b01, 0x0b02, 0x0b03, 0x0b05, 0x0b06, 0x0b07, 0x0b08,
//     a8,     a9,     aa,     ab,     ac,     ad,     ae,     af,
   0x0b09, 0x0b0a, 0x0b0b, 0x0b0f, 0x0b0f, 0x0b10, 0x0b10, 0x0b10,
//     b0,     b1,     b2,     b3,     b4,     b5,     b6,     b7,
   0x0b13, 0x0b14, 0x0b14, 0x0b15, 0x0b16, 0x0b17, 0x0b18, 0x0b19,
//     b8,     b9,     ba,     bb,     bc,     bd,     be,     bf,
   0x0b1a, 0x0b1b, 0x0b1c, 0x0b1d, 0x0b1e, 0x0b1f, 0x0b20, 0x0b21,
//     c0,     c1,     c2,     c3,     c4,     c5,     c6,     c7,
   0x0b22, 0x0b23, 0x0b24, 0x0b25, 0x0b26, 0x0b27, 0x0b28, 0x0b28,
//     c8,     c9,     ca,     cb,     cc,     cd,     ce,     cf,
   0x0b2a, 0x0b2b, 0x0b2c, 0x0b2d, 0x0b2e, 0x0b2f, 0x0b5f, 0x0b30,
//     d0,     d1,     d2,     d3,     d4,     d5,     d6,     d7,
   0x0b30, 0x0b32, 0x0b33, 0x0b33, 0x0b2c, 0x0b36, 0x0b37, 0x0b38,
//     d8,     d9,     da,     db,     dc,     dd,     de,     df,
   0x0b39, 0x003F, 0x0b3e, 0x0b3f, 0x0b40, 0x0b41, 0x0b42, 0x0b43,
//     e0,     e1,     e2,     e3,     e4,     e5,     e6,     e7,
   0x0b47, 0x0b47, 0x0b48, 0x0b48, 0x0b4b, 0x0b4b, 0x0b4c, 0x0b4c,
//     e8,     e9,     ea,     eb,     ec,     ed,     ee,     ef,
   0x0b4d, 0x0b3c, 0x002e, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F,
//     f0,     f1,     f2,     f3,     f4,     f5,     f6,     f7,
   0x003F, 0x0b66, 0x0b67, 0x0b68, 0x0b69, 0x0b6a, 0x0b6b, 0x0b6c,
//     f8,     f9,     fa,     fb,     fc,     fd,     fe,     ff
   0x0b6d, 0x0b6e, 0x0b6f, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F
};


WCHAR pwcORI2[] =
{
//     a0,     a1,     a2,     a3,     a4,     a5,     a6,     a7,
        0,      0,      0,      0,      0,      0, 0x0c0c, 0x0c61,
//     a8,     a9,     aa,     ab,     ac,     ad,     ae,     af,
        0,      0, 0x0c60,      0,      0,      0,      0,      0,
//     b0,     b1,     b2,     b3,     b4,     b5,     b6,     b7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     b8,     b9,     ba,     bb,     bc,     bd,     be,     bf,
        0,      0,      0,      0,      0,      0,      0, 0x0b5c,
//     c0,     c1,     c2,     c3,     c4,     c5,     c6,     c7,
   0x0b5d,      0,      0,      0,      0,      0,      0,      0,
//     c8,     c9,     ca,     cb,     cc,     cd,     ce,     cf,
        0,      0,      0,      0,      0,      0,      0,      0,
//     d0,     d1,     d2,     d3,     d4,     d5,     d6,     d7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     d8,     d9,     da,     db,     dc,     dd,     de,     df,
        0,      0,      0,      0,      0,      0,      0, 0x0c44,
//     e0,     e1,     e2,     e3,     e4,     e5,     e6,     e7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     e8,     e9,     ea,     eb,     ec,     ed,     ee,     ef,
   0x200C, 0x200D, 0x0b3d,      0,      0,      0,      0,      0,
//     f0,     f1,     f2,     f3,     f4,     f5,     f6,     f7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     f8,     f9,     fa,     fb,     fc,     fd,     fe,     ff
        0,      0,      0,      0,      0,      0,      0,      0,
};


////////////////////////////////////////////////////////////////////////////
//
//  Kannada
//
////////////////////////////////////////////////////////////////////////////

WCHAR pwcKND[] =
{
//     a0,     a1,     a2,     a3,     a4,     a5,     a6,     a7,
   0x003F, 0x003F, 0x0c82, 0x0c83, 0x0c85, 0x0c86, 0x0c87, 0x0c88,
//     a8,     a9,     aa,     ab,     ac,     ad,     ae,     af,
   0x0c89, 0x0c8a, 0x0c8b, 0x0c8e, 0x0c8f, 0x0c90, 0x0c90, 0x0c92,
//     b0,     b1,     b2,     b3,     b4,     b5,     b6,     b7,
   0x0c93, 0x0c94, 0x0c94, 0x0c95, 0x0c96, 0x0c97, 0x0c98, 0x0c99,
//     b8,     b9,     ba,     bb,     bc,     bd,     be,     bf,
   0x0c9a, 0x0c9b, 0x0c9c, 0x0c9d, 0x0c9e, 0x0c9f, 0x0ca0, 0x0ca1,
//     c0,     c1,     c2,     c3,     c4,     c5,     c6,     c7,
   0x0ca2, 0x0ca3, 0x0ca4, 0x0ca5, 0x0ca6, 0x0ca7, 0x0ca8, 0x0ca8,
//     c8,     c9,     ca,     cb,     cc,     cd,     ce,     cf,
   0x0caa, 0x0cab, 0x0cac, 0x0cad, 0x0cae, 0x0caf, 0x0caf, 0x0cb0,
//     d0,     d1,     d2,     d3,     d4,     d5,     d6,     d7,
   0x0cb1, 0x0cb2, 0x0cb3, 0x0cb3, 0x0cb5, 0x0cb6, 0x0cb7, 0x0cb8,
//     d8,     d9,     da,     db,     dc,     dd,     de,     df,
   0x0cb9, 0x003F, 0x0cbe, 0x0cbf, 0x0cc0, 0x0cc1, 0x0cc2, 0x0cc3,
//     e0,     e1,     e2,     e3,     e4,     e5,     e6,     e7,
   0x0cc6, 0x0cc7, 0x0cc8, 0x0cc8, 0x0cca, 0x0ccb, 0x0ccc, 0x0ccc,
//     e8,     e9,     ea,     eb,     ec,     ed,     ee,     ef,
   0x0ccd, 0x003F, 0x002e, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F,
//     f0,     f1,     f2,     f3,     f4,     f5,     f6,     f7,
   0x003F, 0x0ce6, 0x0ce7, 0x0ce8, 0x0ce9, 0x0cea, 0x0ceb, 0x0cec,
//     f8,     f9,     fa,     fb,     fc,     fd,     fe,     ff
   0x0ced, 0x0cee, 0x0cef, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F
};


WCHAR pwcKND2[] =
{
//     a0,     a1,     a2,     a3,     a4,     a5,     a6,     a7,
        0,      0,      0,      0,      0,      0, 0x0c8c, 0x0ce1,
//     a8,     a9,     aa,     ab,     ac,     ad,     ae,     af,
        0,      0, 0x0ce0,      0,      0,      0,      0,      0,
//     b0,     b1,     b2,     b3,     b4,     b5,     b6,     b7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     b8,     b9,     ba,     bb,     bc,     bd,     be,     bf,
        0,      0,      0,      0,      0,      0,      0,      0,
//     c0,     c1,     c2,     c3,     c4,     c5,     c6,     c7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     c8,     c9,     ca,     cb,     cc,     cd,     ce,     cf,
        0, 0x0cde,      0,      0,      0,      0,      0,      0,
//     d0,     d1,     d2,     d3,     d4,     d5,     d6,     d7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     d8,     d9,     da,     db,     dc,     dd,     de,     df,
        0,      0,      0,      0,      0,      0,      0, 0x0cc4,
//     e0,     e1,     e2,     e3,     e4,     e5,     e6,     e7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     e8,     e9,     ea,     eb,     ec,     ed,     ee,     ef,
   0x200C, 0x200D,      0,      0,      0,      0,      0,      0,
//     f0,     f1,     f2,     f3,     f4,     f5,     f6,     f7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     f8,     f9,     fa,     fb,     fc,     fd,     fe,     ff
        0,      0,      0,      0,      0,      0,      0,      0,
};


////////////////////////////////////////////////////////////////////////////
//
//  Malayalam
//
////////////////////////////////////////////////////////////////////////////

WCHAR pwcMLM[] =
{
//     a0,     a1,     a2,     a3,     a4,     a5,     a6,     a7,
   0x003F, 0x003F, 0x0d02, 0x0d03, 0x0d05, 0x0d06, 0x0d07, 0x0d08,
//     a8,     a9,     aa,     ab,     ac,     ad,     ae,     af,
   0x0d09, 0x0d0a, 0x0d0b, 0x0d0e, 0x0d0f, 0x0d10, 0x0d10, 0x0d12,
//     b0,     b1,     b2,     b3,     b4,     b5,     b6,     b7,
   0x0d13, 0x0d14, 0x0d14, 0x0d15, 0x0d16, 0x0d17, 0x0d18, 0x0d19,
//     b8,     b9,     ba,     bb,     bc,     bd,     be,     bf,
   0x0d1a, 0x0d1b, 0x0d1c, 0x0d1d, 0x0d1e, 0x0d1f, 0x0d20, 0x0d21,
//     c0,     c1,     c2,     c3,     c4,     c5,     c6,     c7,
   0x0d22, 0x0d23, 0x0d24, 0x0d25, 0x0d26, 0x0d27, 0x0d28, 0x0d28,
//     c8,     c9,     ca,     cb,     cc,     cd,     ce,     cf,
   0x0d2a, 0x0d2b, 0x0d2c, 0x0d2d, 0x0d2e, 0x0d2f, 0x0d2f, 0x0d30,
//     d0,     d1,     d2,     d3,     d4,     d5,     d6,     d7,
   0x0d31, 0x0d32, 0x0d33, 0x0d34, 0x0d35, 0x0d36, 0x0d37, 0x0d38,
//     d8,     d9,     da,     db,     dc,     dd,     de,     df,
   0x0d39, 0x003F, 0x0d3e, 0x0d3f, 0x0d40, 0x0d41, 0x0d42, 0x0d43,
//     e0,     e1,     e2,     e3,     e4,     e5,     e6,     e7,
   0x0d46, 0x0d47, 0x0d48, 0x0d48, 0x0d4a, 0x0d4b, 0x0d4c, 0x0d4c,
//     e8,     e9,     ea,     eb,     ec,     ed,     ee,     ef,
   0x0d4d, 0x003F, 0x002e, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F,
//     f0,     f1,     f2,     f3,     f4,     f5,     f6,     f7,
   0x003F, 0x0d66, 0x0d67, 0x0d68, 0x0d69, 0x0d6a, 0x0d6b, 0x0d6c,
//     f8,     f9,     fa,     fb,     fc,     fd,     fe,     ff
   0x0d6d, 0x0d6e, 0x0d6f, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F
};


WCHAR pwcMLM2[] =
{
//     a0,     a1,     a2,     a3,     a4,     a5,     a6,     a7,
        0,      0,      0,      0,      0,      0, 0x0d0c, 0x0d61,
//     a8,     a9,     aa,     ab,     ac,     ad,     ae,     af,
        0,      0, 0x0d60,      0,      0,      0,      0,      0,
//     b0,     b1,     b2,     b3,     b4,     b5,     b6,     b7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     b8,     b9,     ba,     bb,     bc,     bd,     be,     bf,
        0,      0,      0,      0,      0,      0,      0,      0,
//     c0,     c1,     c2,     c3,     c4,     c5,     c6,     c7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     c8,     c9,     ca,     cb,     cc,     cd,     ce,     cf,
        0,      0,      0,      0,      0,      0,      0,      0,
//     d0,     d1,     d2,     d3,     d4,     d5,     d6,     d7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     d8,     d9,     da,     db,     dc,     dd,     de,     df,
        0,      0,      0,      0,      0,      0,      0,      0,
//     e0,     e1,     e2,     e3,     e4,     e5,     e6,     e7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     e8,     e9,     ea,     eb,     ec,     ed,     ee,     ef,
   0x200C, 0x200D,      0,      0,      0,      0,      0,      0,
//     f0,     f1,     f2,     f3,     f4,     f5,     f6,     f7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     f8,     f9,     fa,     fb,     fc,     fd,     fe,     ff
        0,      0,      0,      0,      0,      0,      0,      0,
};


////////////////////////////////////////////////////////////////////////////
//
//  Gujarati
//
////////////////////////////////////////////////////////////////////////////

WCHAR pwcGJR[] =
{
//     a0,     a1,     a2,     a3,     a4,     a5,     a6,     a7,
   0x003F, 0x0a81, 0x0a82, 0x0a83, 0x0a85, 0x0a86, 0x0a87, 0x0a88,
//     a8,     a9,     aa,     ab,     ac,     ad,     ae,     af,
   0x0a89, 0x0a8a, 0x0a8b, 0x0a8f, 0x0a8f, 0x0a90, 0x0a8d, 0x0a8d,
//     b0,     b1,     b2,     b3,     b4,     b5,     b6,     b7,
   0x0a93, 0x0a94, 0x0a91, 0x0a95, 0x0a96, 0x0a97, 0x0a98, 0x0a99,
//     b8,     b9,     ba,     bb,     bc,     bd,     be,     bf,
   0x0a9a, 0x0a9b, 0x0a9c, 0x0a9d, 0x0a9e, 0x0a9f, 0x0aa0, 0x0aa1,
//     c0,     c1,     c2,     c3,     c4,     c5,     c6,     c7,
   0x0aa2, 0x0aa3, 0x0aa4, 0x0aa5, 0x0aa6, 0x0aa7, 0x0aa8, 0x0aa8,
//     c8,     c9,     ca,     cb,     cc,     cd,     ce,     cf,
   0x0aaa, 0x0aab, 0x0aac, 0x0aad, 0x0aae, 0x0aaf, 0x0aaf, 0x0ab0,
//     d0,     d1,     d2,     d3,     d4,     d5,     d6,     d7,
   0x0ab0, 0x0ab2, 0x0ab3, 0x0ab3, 0x0ab5, 0x0ab6, 0x0ab7, 0x0ab8,
//     d8,     d9,     da,     db,     dc,     dd,     de,     df,
   0x0ab9, 0x003F, 0x0abe, 0x0abf, 0x0ac0, 0x0ac1, 0x0ac2, 0x0ac3,
//     e0,     e1,     e2,     e3,     e4,     e5,     e6,     e7,
   0x0ac7, 0x0ac7, 0x0ac8, 0x0ac5, 0x0acb, 0x0acb, 0x0acc, 0x0ac9,
//     e8,     e9,     ea,     eb,     ec,     ed,     ee,     ef,
   0x0acd, 0x0abc, 0x002e, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F,
//     f0,     f1,     f2,     f3,     f4,     f5,     f6,     f7,
   0x003F, 0x0ae6, 0x0ae7, 0x0ae8, 0x0ae9, 0x0aea, 0x0aeb, 0x0aec,
//     f8,     f9,     fa,     fb,     fc,     fd,     fe,     ff
   0x0aed, 0x0aee, 0x0aef, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F
};


WCHAR pwcGJR2[] =
{
//     a0,     a1,     a2,     a3,     a4,     a5,     a6,     a7,
        0, 0x0ad0,      0,      0,      0,      0,      0,      0,
//     a8,     a9,     aa,     ab,     ac,     ad,     ae,     af,
        0,      0, 0x0ae0,      0,      0,      0,      0,      0,
//     b0,     b1,     b2,     b3,     b4,     b5,     b6,     b7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     b8,     b9,     ba,     bb,     bc,     bd,     be,     bf,
        0,      0,      0,      0,      0,      0,      0,      0,
//     c0,     c1,     c2,     c3,     c4,     c5,     c6,     c7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     c8,     c9,     ca,     cb,     cc,     cd,     ce,     cf,
        0,      0,      0,      0,      0,      0,      0,      0,
//     d0,     d1,     d2,     d3,     d4,     d5,     d6,     d7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     d8,     d9,     da,     db,     dc,     dd,     de,     df,
        0,      0,      0,      0,      0,      0,      0, 0x0ac4,
//     e0,     e1,     e2,     e3,     e4,     e5,     e6,     e7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     e8,     e9,     ea,     eb,     ec,     ed,     ee,     ef,
   0x200C, 0x200D, 0x0abd,      0,      0,      0,      0,      0,
//     f0,     f1,     f2,     f3,     f4,     f5,     f6,     f7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     f8,     f9,     fa,     fb,     fc,     fd,     fe,     ff
        0,      0,      0,      0,      0,      0,      0,      0,
};


////////////////////////////////////////////////////////////////////////////
//
//  Punjabi (Gurmukhi)
//
////////////////////////////////////////////////////////////////////////////

WCHAR pwcPNJ[] =
{
//     a0,     a1,     a2,     a3,     a4,     a5,     a6,     a7,
   0x003F, 0x003F, 0x0a02, 0x003F, 0x0a05, 0x0a06, 0x0a07, 0x0a08,
//     a8,     a9,     aa,     ab,     ac,     ad,     ae,     af,
   0x0a09, 0x0a0a, 0x003F, 0x0a0f, 0x0a0f, 0x0a10, 0x0a10, 0x0a10,
//     b0,     b1,     b2,     b3,     b4,     b5,     b6,     b7,
   0x0a13, 0x0a14, 0x0a14, 0x0a15, 0x0a16, 0x0a17, 0x0a18, 0x0a19,
//     b8,     b9,     ba,     bb,     bc,     bd,     be,     bf,
   0x0a1a, 0x0a1b, 0x0a1c, 0x0a1d, 0x0a1e, 0x0a1f, 0x0a20, 0x0a21,
//     c0,     c1,     c2,     c3,     c4,     c5,     c6,     c7,
   0x0a22, 0x0a23, 0x0a24, 0x0a25, 0x0a26, 0x0a27, 0x0a28, 0x0a28,
//     c8,     c9,     ca,     cb,     cc,     cd,     ce,     cf,
   0x0a2a, 0x0a2b, 0x0a2c, 0x0a2d, 0x0a2e, 0x0a2f, 0x0a2f, 0x0a30,
//     d0,     d1,     d2,     d3,     d4,     d5,     d6,     d7,
   0x0a30, 0x0a32, 0x0a33, 0x0a33, 0x0a35, 0x0a36, 0x0a36, 0x0a38,
//     d8,     d9,     da,     db,     dc,     dd,     de,     df,
   0x0a39, 0x003F, 0x0a3e, 0x0a3f, 0x0a40, 0x0a41, 0x0a42, 0x003F,
//     e0,     e1,     e2,     e3,     e4,     e5,     e6,     e7,
   0x0a47, 0x0a47, 0x0a48, 0x0a48, 0x0a4b, 0x0a4b, 0x0a4c, 0x0a4c,
//     e8,     e9,     ea,     eb,     ec,     ed,     ee,     ef,
   0x0a4d, 0x0a3c, 0x002e, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F,
//     f0,     f1,     f2,     f3,     f4,     f5,     f6,     f7,
   0x003F, 0x0a66, 0x0a67, 0x0a68, 0x0a69, 0x0a6a, 0x0a6b, 0x0a6c,
//     f8,     f9,     fa,     fb,     fc,     fd,     fe,     ff
   0x0a6d, 0x0a6e, 0x0a6f, 0x003F, 0x003F, 0x003F, 0x003F, 0x003F
};


WCHAR pwcPNJ2[] =
{
//     a0,     a1,     a2,     a3,     a4,     a5,     a6,     a7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     a8,     a9,     aa,     ab,     ac,     ad,     ae,     af,
        0,      0,      0,      0,      0,      0,      0,      0,
//     b0,     b1,     b2,     b3,     b4,     b5,     b6,     b7,
        0,      0,      0,      0, 0x0a59, 0x0a5a,      0,      0,
//     b8,     b9,     ba,     bb,     bc,     bd,     be,     bf,
        0,      0, 0x0a5b,      0,      0,      0,      0,      0,
//     c0,     c1,     c2,     c3,     c4,     c5,     c6,     c7,
   0x0a5c,      0,      0,      0,      0,      0,      0,      0,
//     c8,     c9,     ca,     cb,     cc,     cd,     ce,     cf,
        0, 0x0a5e,      0,      0,      0,      0,      0,      0,
//     d0,     d1,     d2,     d3,     d4,     d5,     d6,     d7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     d8,     d9,     da,     db,     dc,     dd,     de,     df,
        0,      0,      0,      0,      0,      0,      0,      0,
//     e0,     e1,     e2,     e3,     e4,     e5,     e6,     e7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     e8,     e9,     ea,     eb,     ec,     ed,     ee,     ef,
   0x200C, 0x200D,      0,      0,      0,      0,      0,      0,
//     f0,     f1,     f2,     f3,     f4,     f5,     f6,     f7,
        0,      0,      0,      0,      0,      0,      0,      0,
//     f8,     f9,     fa,     fb,     fc,     fd,     fe,     ff
        0,      0,      0,      0,      0,      0,      0,      0,
};


////////////////////////////////////////////////////////////////////////////
//
//  MultiByteToWideChar
//
////////////////////////////////////////////////////////////////////////////

WCHAR *ppwcIndic[] =
{
    NULL,          //  0 DEF 0X40 Default
    NULL,          //  1 RMN 0X41 Roman
    pwcDEV,        //  2 DEV 0X42 Devanagari
    pwcBNG,        //  3 BNG 0X43 Bengali
    pwcTML,        //  4 TML 0X44 Tamil
    pwcTLG,        //  5 TLG 0X45 Telugu
    pwcBNG,        //  6 ASM 0X46 Assamese (Bengali)
    pwcORI,        //  7 ORI 0X47 Oriya
    pwcKND,        //  8 KND 0X48 Kannada
    pwcMLM,        //  9 MLM 0X49 Malayalam
    pwcGJR,        // 10 GJR 0X4A Gujarati
    pwcPNJ         // 11 PNJ 0X4B Punjabi (Gurmukhi)
};


WCHAR *ppwcIndic2[] =                     // 2 MB char -> 1 Unicode
{                                         // second MB == 0xe9
    NULL,          //  0 DEF 0X40 Default
    NULL,          //  1 RMN 0X41 Roman
    pwcDEV2,       //  2 DEV 0X42 Devanagari
    pwcBNG2,       //  3 BNG 0X43 Bengali
    pwcTML2,       //  4 TML 0X44 Tamil (does not have 2-to-1)
    pwcTLG2,       //  5 TLG 0X45 Telugu
    pwcBNG2,       //  6 ASM 0X46 Assamese (Bengali)
    pwcORI2,       //  7 ORI 0X47 Oriya
    pwcKND2,       //  8 KND 0X48 Kannada
    pwcMLM2,       //  9 MLM 0X49 Malayalam
    pwcGJR2,       // 10 GJR 0X4A Gujarati
    pwcPNJ2        // 11 PNJ 0X4B Punjabi (Gurmukhi)
};


//
//  EXT
//     0xf0_0xb8 == U+0952
//     0xf0_0xbf == U+0970

ExtMB ExtMBList[] =
{
    { 0xb8, 0x0952 },    // Devanagari Stress Sign Anudatta
    { 0xbf, 0x0970 }     // Devanagari Abbreviation Sign
};


////////////////////////////////////////////////////////////////////////////
//
//  WideCharToMultiByte
//
////////////////////////////////////////////////////////////////////////////

WCHAR IndiChar[] =
{
    0x02a1,  // U+0901 : Devanagari Sign Candrabindu
    0x02a2,  // U+0902 : Devanagari Sign Anusvara
    0x02a3,  // U+0903 : Devanagari Sign Visarga
    0x003F,  // U+0904 : Undefined
    0x02a4,  // U+0905 : Devanagari Letter A
    0x02a5,  // U+0906 : Devanagari Letter Aa
    0x02a6,  // U+0907 : Devanagari Letter I
    0x02a7,  // U+0908 : Devanagari Letter Ii
    0x02a8,  // U+0909 : Devanagari Letter U
    0x02a9,  // U+090a : Devanagari Letter Uu
    0x02aa,  // U+090b : Devanagari Letter Vocalic R
    0x12a6,  // U+090c : Devanagari Letter Vocalic L
    0x02ae,  // U+090d : Devanagari Letter Candra E
    0x02ab,  // U+090e : Devanagari Letter Short E
    0x02ac,  // U+090f : Devanagari Letter E
    0x02ad,  // U+0910 : Devanagari Letter Ai
    0x02b2,  // U+0911 : Devanagari Letter Candra O
    0x02af,  // U+0912 : Devanagari Letter Short O
    0x02b0,  // U+0913 : Devanagari Letter O
    0x02b1,  // U+0914 : Devanagari Letter Au
    0x02b3,  // U+0915 : Devanagari Letter Ka
    0x02b4,  // U+0916 : Devanagari Letter Kha
    0x02b5,  // U+0917 : Devanagari Letter Ga
    0x02b6,  // U+0918 : Devanagari Letter Gha
    0x02b7,  // U+0919 : Devanagari Letter Nga
    0x02b8,  // U+091a : Devanagari Letter Ca
    0x02b9,  // U+091b : Devanagari Letter Cha
    0x02ba,  // U+091c : Devanagari Letter Ja
    0x02bb,  // U+091d : Devanagari Letter Jha
    0x02bc,  // U+091e : Devanagari Letter Nya
    0x02bd,  // U+091f : Devanagari Letter Tta
    0x02be,  // U+0920 : Devanagari Letter Ttha
    0x02bf,  // U+0921 : Devanagari Letter Dda
    0x02c0,  // U+0922 : Devanagari Letter Ddha
    0x02c1,  // U+0923 : Devanagari Letter Nna
    0x02c2,  // U+0924 : Devanagari Letter Ta
    0x02c3,  // U+0925 : Devanagari Letter Tha
    0x02c4,  // U+0926 : Devanagari Letter Da
    0x02c5,  // U+0927 : Devanagari Letter Dha
    0x02c6,  // U+0928 : Devanagari Letter Na
    0x02c7,  // U+0929 : Devanagari Letter Nnna
    0x02c8,  // U+092a : Devanagari Letter Pa
    0x02c9,  // U+092b : Devanagari Letter Pha
    0x02ca,  // U+092c : Devanagari Letter Ba
    0x02cb,  // U+092d : Devanagari Letter Bha
    0x02cc,  // U+092e : Devanagari Letter Ma
    0x02cd,  // U+092f : Devanagari Letter Ya
    0x02cf,  // U+0930 : Devanagari Letter Ra
    0x02d0,  // U+0931 : Devanagari Letter Rra
    0x02d1,  // U+0932 : Devanagari Letter La
    0x02d2,  // U+0933 : Devanagari Letter Lla
    0x02d3,  // U+0934 : Devanagari Letter Llla
    0x02d4,  // U+0935 : Devanagari Letter Va
    0x02d5,  // U+0936 : Devanagari Letter Sha
    0x02d6,  // U+0937 : Devanagari Letter Ssa
    0x02d7,  // U+0938 : Devanagari Letter Sa
    0x02d8,  // U+0939 : Devanagari Letter Ha
    0x003F,  // U+093a : Undefined
    0x003F,  // U+093b : Undefined
    0x02e9,  // U+093c : Devanagari Sign Nukta
    0x12ea,  // U+093d : Devanagari Sign Avagraha
    0x02da,  // U+093e : Devanagari Vowel Sign Aa
    0x02db,  // U+093f : Devanagari Vowel Sign I
    0x02dc,  // U+0940 : Devanagari Vowel Sign Ii
    0x02dd,  // U+0941 : Devanagari Vowel Sign U
    0x02de,  // U+0942 : Devanagari Vowel Sign Uu
    0x02df,  // U+0943 : Devanagari Vowel Sign Vocalic R
    0x12df,  // U+0944 : Devanagari Vowel Sign Vocalic Rr
    0x02e3,  // U+0945 : Devanagari Vowel Sign Candra E
    0x02e0,  // U+0946 : Devanagari Vowel Sign Short E
    0x02e1,  // U+0947 : Devanagari Vowel Sign E
    0x02e2,  // U+0948 : Devanagari Vowel Sign Ai
    0x02e7,  // U+0949 : Devanagari Vowel Sign Candra O
    0x02e4,  // U+094a : Devanagari Vowel Sign Short O
    0x02e5,  // U+094b : Devanagari Vowel Sign O
    0x02e6,  // U+094c : Devanagari Vowel Sign Au
    0x02e8,  // U+094d : Devanagari Sign Virama
    0x003F,  // U+094e : Undefined
    0x003F,  // U+094f : Undefined
    0x12a1,  // U+0950 : Devanagari Om
    0x003F,  // U+0951 : Devanagari Stress Sign Udatta
    0x22f0,  // U+0952 : Devanagari Stress Sign Anudatta
    0x003F,  // U+0953 : Devanagari Grave Accent
    0x003F,  // U+0954 : Devanagari Acute Accent
    0x003F,  // U+0955 : Undefined
    0x003F,  // U+0956 : Undefined
    0x003F,  // U+0957 : Undefined
    0x12b3,  // U+0958 : Devanagari Letter Qa
    0x12b4,  // U+0959 : Devanagari Letter Khha
    0x12b5,  // U+095a : Devanagari Letter Ghha
    0x12ba,  // U+095b : Devanagari Letter Za
    0x12bf,  // U+095c : Devanagari Letter Dddha
    0x12c0,  // U+095d : Devanagari Letter Rha
    0x12c9,  // U+095e : Devanagari Letter Fa
    0x02ce,  // U+095f : Devanagari Letter Yya
    0x12aa,  // U+0960 : Devanagari Letter Vocalic Rr
    0x12a7,  // U+0961 : Devanagari Letter Vocalic Ll
    0x12db,  // U+0962 : Devanagari Vowel Sign Vocalic L
    0x12dc,  // U+0963 : Devanagari Vowel Sign Vocalic Ll
    0x02ea,  // U+0964 : Devanagari Danda
    0x003F,  // U+0965 : Devanagari Double Danda
    0x02f1,  // U+0966 : Devanagari Digit Zero
    0x02f2,  // U+0967 : Devanagari Digit One
    0x02f3,  // U+0968 : Devanagari Digit Two
    0x02f4,  // U+0969 : Devanagari Digit Three
    0x02f5,  // U+096a : Devanagari Digit Four
    0x02f6,  // U+096b : Devanagari Digit Five
    0x02f7,  // U+096c : Devanagari Digit Six
    0x02f8,  // U+096d : Devanagari Digit Seven
    0x02f9,  // U+096e : Devanagari Digit Eight
    0x02fa,  // U+096f : Devanagari Digit Nine
    0x32f0,  // U+0970 : Devanagari Abbreviation Sign
    0x003F,  // U+0971 : Undefined
    0x003F,  // U+0972 : Undefined
    0x003F,  // U+0973 : Undefined
    0x003F,  // U+0974 : Undefined
    0x003F,  // U+0975 : Undefined
    0x003F,  // U+0976 : Undefined
    0x003F,  // U+0977 : Undefined
    0x003F,  // U+0978 : Undefined
    0x003F,  // U+0979 : Undefined
    0x003F,  // U+097a : Undefined
    0x003F,  // U+097b : Undefined
    0x003F,  // U+097c : Undefined
    0x003F,  // U+097d : Undefined
    0x003F,  // U+097e : Undefined
    0x003F,  // U+097f : Undefined
    0x003F,  // U+0980 : Undefined
    0x03a1,  // U+0981 : Bengali Sign Candrabindu
    0x03a2,  // U+0982 : Bengali Sign Anusvara
    0x03a3,  // U+0983 : Bengali Sign Visarga
    0x003F,  // U+0984 : Undefined
    0x03a4,  // U+0985 : Bengali Letter A
    0x03a5,  // U+0986 : Bengali Letter Aa
    0x03a6,  // U+0987 : Bengali Letter I
    0x03a7,  // U+0988 : Bengali Letter Ii
    0x03a8,  // U+0989 : Bengali Letter U
    0x03a9,  // U+098a : Bengali Letter Uu
    0x03aa,  // U+098b : Bengali Letter Vocalic R
    0x13a6,  // U+098c : Bengali Letter Vocalic L
    0x003F,  // U+098d : Undefined
    0x003F,  // U+098e : Undefined
    0x03ab,  // U+098f : Bengali Letter E
    0x03ad,  // U+0990 : Bengali Letter Ai
    0x003F,  // U+0991 : Undefined
    0x003F,  // U+0992 : Undefined
    0x03af,  // U+0993 : Bengali Letter O
    0x03b1,  // U+0994 : Bengali Letter Au
    0x03b3,  // U+0995 : Bengali Letter Ka
    0x03b4,  // U+0996 : Bengali Letter Kha
    0x03b5,  // U+0997 : Bengali Letter Ga
    0x03b6,  // U+0998 : Bengali Letter Gha
    0x03b7,  // U+0999 : Bengali Letter Nga
    0x03b8,  // U+099a : Bengali Letter Ca
    0x03b9,  // U+099b : Bengali Letter Cha
    0x03ba,  // U+099c : Bengali Letter Ja
    0x03bb,  // U+099d : Bengali Letter Jha
    0x03bc,  // U+099e : Bengali Letter Nya
    0x03bd,  // U+099f : Bengali Letter Tta
    0x03be,  // U+09a0 : Bengali Letter Ttha
    0x03bf,  // U+09a1 : Bengali Letter Dda
    0x03c0,  // U+09a2 : Bengali Letter Ddha
    0x03c1,  // U+09a3 : Bengali Letter Nna
    0x03c2,  // U+09a4 : Bengali Letter Ta
    0x03c3,  // U+09a5 : Bengali Letter Tha
    0x03c4,  // U+09a6 : Bengali Letter Da
    0x03c5,  // U+09a7 : Bengali Letter Dha
    0x03c6,  // U+09a8 : Bengali Letter Na
    0x003F,  // U+09a9 : Undefined
    0x03c8,  // U+09aa : Bengali Letter Pa
    0x03c9,  // U+09ab : Bengali Letter Pha
    0x03ca,  // U+09ac : Bengali Letter Ba
    0x03cb,  // U+09ad : Bengali Letter Bha
    0x03cc,  // U+09ae : Bengali Letter Ma
    0x03cd,  // U+09af : Bengali Letter Ya
    0x03cf,  // U+09b0 : Bengali Letter Ra
    0x003F,  // U+09b1 : Undefined
    0x03d1,  // U+09b2 : Bengali Letter La
    0x003F,  // U+09b3 : Undefined
    0x003F,  // U+09b4 : Undefined
    0x003F,  // U+09b5 : Undefined
    0x03d5,  // U+09b6 : Bengali Letter Sha
    0x03d6,  // U+09b7 : Bengali Letter Ssa
    0x03d7,  // U+09b8 : Bengali Letter Sa
    0x03d8,  // U+09b9 : Bengali Letter Ha
    0x003F,  // U+09ba : Undefined
    0x003F,  // U+09bb : Undefined
    0x03e9,  // U+09bc : Bengali Sign Nukta
    0x003F,  // U+09bd : Undefined
    0x03da,  // U+09be : Bengali Vowel Sign Aa
    0x03db,  // U+09bf : Bengali Vowel Sign I
    0x03dc,  // U+09c0 : Bengali Vowel Sign Ii
    0x03dd,  // U+09c1 : Bengali Vowel Sign U
    0x03de,  // U+09c2 : Bengali Vowel Sign Uu
    0x03df,  // U+09c3 : Bengali Vowel Sign Vocalic R
    0x13df,  // U+09c4 : Bengali Vowel Sign Vocalic Rr
    0x003F,  // U+09c5 : Undefined
    0x003F,  // U+09c6 : Undefined
    0x03e0,  // U+09c7 : Bengali Vowel Sign E
    0x03e2,  // U+09c8 : Bengali Vowel Sign Ai
    0x003F,  // U+09c9 : Undefined
    0x003F,  // U+09ca : Undefined
    0x03e4,  // U+09cb : Bengali Vowel Sign O
    0x03e6,  // U+09cc : Bengali Vowel Sign Au
    0x03e8,  // U+09cd : Bengali Sign Virama
    0x003F,  // U+09ce : Undefined
    0x003F,  // U+09cf : Undefined
    0x003F,  // U+09d0 : Undefined
    0x003F,  // U+09d1 : Undefined
    0x003F,  // U+09d2 : Undefined
    0x003F,  // U+09d3 : Undefined
    0x003F,  // U+09d4 : Undefined
    0x003F,  // U+09d5 : Undefined
    0x003F,  // U+09d6 : Undefined
    0x003F,  // U+09d7 : Bengali Au Length Mark
    0x003F,  // U+09d8 : Undefined
    0x003F,  // U+09d9 : Undefined
    0x003F,  // U+09da : Undefined
    0x003F,  // U+09db : Undefined
    0x13bf,  // U+09dc : Bengali Letter Rra
    0x13c0,  // U+09dd : Bengali Letter Rha
    0x003F,  // U+09de : Undefined
    0x03ce,  // U+09df : Bengali Letter Yya
    0x13aa,  // U+09e0 : Bengali Letter Vocalic Rr
    0x13a7,  // U+09e1 : Bengali Letter Vocalic Ll
    0x13db,  // U+09e2 : Bengali Vowel Sign Vocalic L
    0x13dc,  // U+09e3 : Bengali Vowel Sign Vocalic Ll
    0x003F,  // U+09e4 : Undefined
    0x003F,  // U+09e5 : Undefined
    0x03f1,  // U+09e6 : Bengali Digit Zero
    0x03f2,  // U+09e7 : Bengali Digit One
    0x03f3,  // U+09e8 : Bengali Digit Two
    0x03f4,  // U+09e9 : Bengali Digit Three
    0x03f5,  // U+09ea : Bengali Digit Four
    0x03f6,  // U+09eb : Bengali Digit Five
    0x03f7,  // U+09ec : Bengali Digit Six
    0x03f8,  // U+09ed : Bengali Digit Seven
    0x03f9,  // U+09ee : Bengali Digit Eight
    0x03fa,  // U+09ef : Bengali Digit Nine
    0x003F,  // U+09f0 : Bengali Letter Ra With Middle Diagonal
    0x003F,  // U+09f1 : Bengali Letter Ra With Lower Diagonal
    0x003F,  // U+09f2 : Bengali Rupee Mark
    0x003F,  // U+09f3 : Bengali Rupee Sign
    0x003F,  // U+09f4 : Bengali Currency Numerator One
    0x003F,  // U+09f5 : Bengali Currency Numerator Two
    0x003F,  // U+09f6 : Bengali Currency Numerator Three
    0x003F,  // U+09f7 : Bengali Currency Numerator Four
    0x003F,  // U+09f8 : Bengali Currency Numerator One Less Than The Denominator
    0x003F,  // U+09f9 : Bengali Currency Denominator Sixteen
    0x003F,  // U+09fa : Bengali Isshar
    0x003F,  // U+09fb : Undefined
    0x003F,  // U+09fc : Undefined
    0x003F,  // U+09fd : Undefined
    0x003F,  // U+09fe : Undefined
    0x003F,  // U+09ff : Undefined
    0x003F,  // U+0a00 : Undefined
    0x003F,  // U+0a01 : Undefined
    0x0ba2,  // U+0a02 : Gurmukhi Sign Bindi
    0x003F,  // U+0a03 : Undefined
    0x003F,  // U+0a04 : Undefined
    0x0ba4,  // U+0a05 : Gurmukhi Letter A
    0x0ba5,  // U+0a06 : Gurmukhi Letter Aa
    0x0ba6,  // U+0a07 : Gurmukhi Letter I
    0x0ba7,  // U+0a08 : Gurmukhi Letter Ii
    0x0ba8,  // U+0a09 : Gurmukhi Letter U
    0x0ba9,  // U+0a0a : Gurmukhi Letter Uu
    0x003F,  // U+0a0b : Undefined
    0x003F,  // U+0a0c : Undefined
    0x003F,  // U+0a0d : Undefined
    0x003F,  // U+0a0e : Undefined
    0x0bab,  // U+0a0f : Gurmukhi Letter Ee
    0x0bad,  // U+0a10 : Gurmukhi Letter Ai
    0x003F,  // U+0a11 : Undefined
    0x003F,  // U+0a12 : Undefined
    0x0bb0,  // U+0a13 : Gurmukhi Letter Oo
    0x0bb1,  // U+0a14 : Gurmukhi Letter Au
    0x0bb3,  // U+0a15 : Gurmukhi Letter Ka
    0x0bb4,  // U+0a16 : Gurmukhi Letter Kha
    0x0bb5,  // U+0a17 : Gurmukhi Letter Ga
    0x0bb6,  // U+0a18 : Gurmukhi Letter Gha
    0x0bb7,  // U+0a19 : Gurmukhi Letter Nga
    0x0bb8,  // U+0a1a : Gurmukhi Letter Ca
    0x0bb9,  // U+0a1b : Gurmukhi Letter Cha
    0x0bba,  // U+0a1c : Gurmukhi Letter Ja
    0x0bbb,  // U+0a1d : Gurmukhi Letter Jha
    0x0bbc,  // U+0a1e : Gurmukhi Letter Nya
    0x0bbd,  // U+0a1f : Gurmukhi Letter Tta
    0x0bbe,  // U+0a20 : Gurmukhi Letter Ttha
    0x0bbf,  // U+0a21 : Gurmukhi Letter Dda
    0x0bc0,  // U+0a22 : Gurmukhi Letter Ddha
    0x0bc1,  // U+0a23 : Gurmukhi Letter Nna
    0x0bc2,  // U+0a24 : Gurmukhi Letter Ta
    0x0bc3,  // U+0a25 : Gurmukhi Letter Tha
    0x0bc4,  // U+0a26 : Gurmukhi Letter Da
    0x0bc5,  // U+0a27 : Gurmukhi Letter Dha
    0x0bc6,  // U+0a28 : Gurmukhi Letter Na
    0x003F,  // U+0a29 : Undefined
    0x0bc8,  // U+0a2a : Gurmukhi Letter Pa
    0x0bc9,  // U+0a2b : Gurmukhi Letter Pha
    0x0bca,  // U+0a2c : Gurmukhi Letter Ba
    0x0bcb,  // U+0a2d : Gurmukhi Letter Bha
    0x0bcc,  // U+0a2e : Gurmukhi Letter Ma
    0x0bcd,  // U+0a2f : Gurmukhi Letter Ya
    0x0bcf,  // U+0a30 : Gurmukhi Letter Ra
    0x003F,  // U+0a31 : Undefined
    0x0bd1,  // U+0a32 : Gurmukhi Letter La
    0x0bd2,  // U+0a33 : Gurmukhi Letter Lla
    0x003F,  // U+0a34 : Undefined
    0x0bd4,  // U+0a35 : Gurmukhi Letter Va
    0x0bd5,  // U+0a36 : Gurmukhi Letter Sha
    0x003F,  // U+0a37 : Undefined
    0x0bd7,  // U+0a38 : Gurmukhi Letter Sa
    0x0bd8,  // U+0a39 : Gurmukhi Letter Ha
    0x003F,  // U+0a3a : Undefined
    0x003F,  // U+0a3b : Undefined
    0x0be9,  // U+0a3c : Gurmukhi Sign Nukta
    0x003F,  // U+0a3d : Undefined
    0x0bda,  // U+0a3e : Gurmukhi Vowel Sign Aa
    0x0bdb,  // U+0a3f : Gurmukhi Vowel Sign I
    0x0bdc,  // U+0a40 : Gurmukhi Vowel Sign Ii
    0x0bdd,  // U+0a41 : Gurmukhi Vowel Sign U
    0x0bde,  // U+0a42 : Gurmukhi Vowel Sign Uu
    0x003F,  // U+0a43 : Undefined
    0x003F,  // U+0a44 : Undefined
    0x003F,  // U+0a45 : Undefined
    0x003F,  // U+0a46 : Undefined
    0x0be0,  // U+0a47 : Gurmukhi Vowel Sign Ee
    0x0be2,  // U+0a48 : Gurmukhi Vowel Sign Ai
    0x003F,  // U+0a49 : Undefined
    0x003F,  // U+0a4a : Undefined
    0x0be4,  // U+0a4b : Gurmukhi Vowel Sign Oo
    0x0be6,  // U+0a4c : Gurmukhi Vowel Sign Au
    0x0be8,  // U+0a4d : Gurmukhi Sign Virama
    0x003F,  // U+0a4e : Undefined
    0x003F,  // U+0a4f : Undefined
    0x003F,  // U+0a50 : Undefined
    0x003F,  // U+0a51 : Undefined
    0x003F,  // U+0a52 : Undefined
    0x003F,  // U+0a53 : Undefined
    0x003F,  // U+0a54 : Undefined
    0x003F,  // U+0a55 : Undefined
    0x003F,  // U+0a56 : Undefined
    0x003F,  // U+0a57 : Undefined
    0x003F,  // U+0a58 : Undefined
    0x1bb4,  // U+0a59 : Gurmukhi Letter Khha
    0x1bb5,  // U+0a5a : Gurmukhi Letter Ghha
    0x1bba,  // U+0a5b : Gurmukhi Letter Za
    0x1bc0,  // U+0a5c : Gurmukhi Letter Rra
    0x003F,  // U+0a5d : Undefined
    0x1bc9,  // U+0a5e : Gurmukhi Letter Fa
    0x003F,  // U+0a5f : Undefined
    0x003F,  // U+0a60 : Undefined
    0x003F,  // U+0a61 : Undefined
    0x003F,  // U+0a62 : Undefined
    0x003F,  // U+0a63 : Undefined
    0x003F,  // U+0a64 : Undefined
    0x003F,  // U+0a65 : Undefined
    0x0bf1,  // U+0a66 : Gurmukhi Digit Zero
    0x0bf2,  // U+0a67 : Gurmukhi Digit One
    0x0bf3,  // U+0a68 : Gurmukhi Digit Two
    0x0bf4,  // U+0a69 : Gurmukhi Digit Three
    0x0bf5,  // U+0a6a : Gurmukhi Digit Four
    0x0bf6,  // U+0a6b : Gurmukhi Digit Five
    0x0bf7,  // U+0a6c : Gurmukhi Digit Six
    0x0bf8,  // U+0a6d : Gurmukhi Digit Seven
    0x0bf9,  // U+0a6e : Gurmukhi Digit Eight
    0x0bfa,  // U+0a6f : Gurmukhi Digit Nine
    0x003F,  // U+0a70 : Gurmukhi Tippi
    0x003F,  // U+0a71 : Gurmukhi Addak
    0x003F,  // U+0a72 : Gurmukhi Iri
    0x003F,  // U+0a73 : Gurmukhi Ura
    0x003F,  // U+0a74 : Gurmukhi Ek Onkar
    0x003F,  // U+0a75 : Undefined
    0x003F,  // U+0a76 : Undefined
    0x003F,  // U+0a77 : Undefined
    0x003F,  // U+0a78 : Undefined
    0x003F,  // U+0a79 : Undefined
    0x003F,  // U+0a7a : Undefined
    0x003F,  // U+0a7b : Undefined
    0x003F,  // U+0a7c : Undefined
    0x003F,  // U+0a7d : Undefined
    0x003F,  // U+0a7e : Undefined
    0x003F,  // U+0a7f : Undefined
    0x003F,  // U+0a80 : Undefined
    0x0aa1,  // U+0a81 : Gujarati Sign Candrabindu
    0x0aa2,  // U+0a82 : Gujarati Sign Anusvara
    0x0aa3,  // U+0a83 : Gujarati Sign Visarga
    0x003F,  // U+0a84 : Undefined
    0x0aa4,  // U+0a85 : Gujarati Letter A
    0x0aa5,  // U+0a86 : Gujarati Letter Aa
    0x0aa6,  // U+0a87 : Gujarati Letter I
    0x0aa7,  // U+0a88 : Gujarati Letter Ii
    0x0aa8,  // U+0a89 : Gujarati Letter U
    0x0aa9,  // U+0a8a : Gujarati Letter Uu
    0x0aaa,  // U+0a8b : Gujarati Letter Vocalic R
    0x003F,  // U+0a8c : Undefined
    0x0aae,  // U+0a8d : Gujarati Vowel Candra E
    0x003F,  // U+0a8e : Undefined
    0x0aab,  // U+0a8f : Gujarati Letter E
    0x0aad,  // U+0a90 : Gujarati Letter Ai
    0x0ab2,  // U+0a91 : Gujarati Vowel Candra O
    0x003F,  // U+0a92 : Undefined
    0x0ab0,  // U+0a93 : Gujarati Letter O
    0x0ab1,  // U+0a94 : Gujarati Letter Au
    0x0ab3,  // U+0a95 : Gujarati Letter Ka
    0x0ab4,  // U+0a96 : Gujarati Letter Kha
    0x0ab5,  // U+0a97 : Gujarati Letter Ga
    0x0ab6,  // U+0a98 : Gujarati Letter Gha
    0x0ab7,  // U+0a99 : Gujarati Letter Nga
    0x0ab8,  // U+0a9a : Gujarati Letter Ca
    0x0ab9,  // U+0a9b : Gujarati Letter Cha
    0x0aba,  // U+0a9c : Gujarati Letter Ja
    0x0abb,  // U+0a9d : Gujarati Letter Jha
    0x0abc,  // U+0a9e : Gujarati Letter Nya
    0x0abd,  // U+0a9f : Gujarati Letter Tta
    0x0abe,  // U+0aa0 : Gujarati Letter Ttha
    0x0abf,  // U+0aa1 : Gujarati Letter Dda
    0x0ac0,  // U+0aa2 : Gujarati Letter Ddha
    0x0ac1,  // U+0aa3 : Gujarati Letter Nna
    0x0ac2,  // U+0aa4 : Gujarati Letter Ta
    0x0ac3,  // U+0aa5 : Gujarati Letter Tha
    0x0ac4,  // U+0aa6 : Gujarati Letter Da
    0x0ac5,  // U+0aa7 : Gujarati Letter Dha
    0x0ac6,  // U+0aa8 : Gujarati Letter Na
    0x003F,  // U+0aa9 : Undefined
    0x0ac8,  // U+0aaa : Gujarati Letter Pa
    0x0ac9,  // U+0aab : Gujarati Letter Pha
    0x0aca,  // U+0aac : Gujarati Letter Ba
    0x0acb,  // U+0aad : Gujarati Letter Bha
    0x0acc,  // U+0aae : Gujarati Letter Ma
    0x0acd,  // U+0aaf : Gujarati Letter Ya
    0x0acf,  // U+0ab0 : Gujarati Letter Ra
    0x003F,  // U+0ab1 : Undefined
    0x0ad1,  // U+0ab2 : Gujarati Letter La
    0x0ad2,  // U+0ab3 : Gujarati Letter Lla
    0x003F,  // U+0ab4 : Undefined
    0x0ad4,  // U+0ab5 : Gujarati Letter Va
    0x0ad5,  // U+0ab6 : Gujarati Letter Sha
    0x0ad6,  // U+0ab7 : Gujarati Letter Ssa
    0x0ad7,  // U+0ab8 : Gujarati Letter Sa
    0x0ad8,  // U+0ab9 : Gujarati Letter Ha
    0x003F,  // U+0aba : Undefined
    0x003F,  // U+0abb : Undefined
    0x0ae9,  // U+0abc : Gujarati Sign Nukta
    0x1aea,  // U+0abd : Gujarati Sign Avagraha
    0x0ada,  // U+0abe : Gujarati Vowel Sign Aa
    0x0adb,  // U+0abf : Gujarati Vowel Sign I
    0x0adc,  // U+0ac0 : Gujarati Vowel Sign Ii
    0x0add,  // U+0ac1 : Gujarati Vowel Sign U
    0x0ade,  // U+0ac2 : Gujarati Vowel Sign Uu
    0x0adf,  // U+0ac3 : Gujarati Vowel Sign Vocalic R
    0x1adf,  // U+0ac4 : Gujarati Vowel Sign Vocalic Rr
    0x0ae3,  // U+0ac5 : Gujarati Vowel Sign Candra E
    0x003F,  // U+0ac6 : Undefined
    0x0ae0,  // U+0ac7 : Gujarati Vowel Sign E
    0x0ae2,  // U+0ac8 : Gujarati Vowel Sign Ai
    0x0ae7,  // U+0ac9 : Gujarati Vowel Sign Candra O
    0x003F,  // U+0aca : Undefined
    0x0ae4,  // U+0acb : Gujarati Vowel Sign O
    0x0ae6,  // U+0acc : Gujarati Vowel Sign Au
    0x0ae8,  // U+0acd : Gujarati Sign Virama
    0x003F,  // U+0ace : Undefined
    0x003F,  // U+0acf : Undefined
    0x1aa1,  // U+0ad0 : Gujarati Om
    0x003F,  // U+0ad1 : Undefined
    0x003F,  // U+0ad2 : Undefined
    0x003F,  // U+0ad3 : Undefined
    0x003F,  // U+0ad4 : Undefined
    0x003F,  // U+0ad5 : Undefined
    0x003F,  // U+0ad6 : Undefined
    0x003F,  // U+0ad7 : Undefined
    0x003F,  // U+0ad8 : Undefined
    0x003F,  // U+0ad9 : Undefined
    0x003F,  // U+0ada : Undefined
    0x003F,  // U+0adb : Undefined
    0x003F,  // U+0adc : Undefined
    0x003F,  // U+0add : Undefined
    0x003F,  // U+0ade : Undefined
    0x003F,  // U+0adf : Undefined
    0x1aaa,  // U+0ae0 : Gujarati Letter Vocalic Rr
    0x003F,  // U+0ae1 : Undefined
    0x003F,  // U+0ae2 : Undefined
    0x003F,  // U+0ae3 : Undefined
    0x003F,  // U+0ae4 : Undefined
    0x003F,  // U+0ae5 : Undefined
    0x0af1,  // U+0ae6 : Gujarati Digit Zero
    0x0af2,  // U+0ae7 : Gujarati Digit One
    0x0af3,  // U+0ae8 : Gujarati Digit Two
    0x0af4,  // U+0ae9 : Gujarati Digit Three
    0x0af5,  // U+0aea : Gujarati Digit Four
    0x0af6,  // U+0aeb : Gujarati Digit Five
    0x0af7,  // U+0aec : Gujarati Digit Six
    0x0af8,  // U+0aed : Gujarati Digit Seven
    0x0af9,  // U+0aee : Gujarati Digit Eight
    0x0afa,  // U+0aef : Gujarati Digit Nine
    0x003F,  // U+0af0 : Undefined
    0x003F,  // U+0af1 : Undefined
    0x003F,  // U+0af2 : Undefined
    0x003F,  // U+0af3 : Undefined
    0x003F,  // U+0af4 : Undefined
    0x003F,  // U+0af5 : Undefined
    0x003F,  // U+0af6 : Undefined
    0x003F,  // U+0af7 : Undefined
    0x003F,  // U+0af8 : Undefined
    0x003F,  // U+0af9 : Undefined
    0x003F,  // U+0afa : Undefined
    0x003F,  // U+0afb : Undefined
    0x003F,  // U+0afc : Undefined
    0x003F,  // U+0afd : Undefined
    0x003F,  // U+0afe : Undefined
    0x003F,  // U+0aff : Undefined
    0x003F,  // U+0b00 : Undefined
    0x07a1,  // U+0b01 : Oriya Sign Candrabindu
    0x07a2,  // U+0b02 : Oriya Sign Anusvara
    0x07a3,  // U+0b03 : Oriya Sign Visarga
    0x003F,  // U+0b04 : Undefined
    0x07a4,  // U+0b05 : Oriya Letter A
    0x07a5,  // U+0b06 : Oriya Letter Aa
    0x07a6,  // U+0b07 : Oriya Letter I
    0x07a7,  // U+0b08 : Oriya Letter Ii
    0x07a8,  // U+0b09 : Oriya Letter U
    0x07a9,  // U+0b0a : Oriya Letter Uu
    0x07aa,  // U+0b0b : Oriya Letter Vocalic R
    0x17a6,  // U+0b0c : Oriya Letter Vocalic L
    0x003F,  // U+0b0d : Undefined
    0x003F,  // U+0b0e : Undefined
    0x07ab,  // U+0b0f : Oriya Letter E
    0x07ad,  // U+0b10 : Oriya Letter Ai
    0x003F,  // U+0b11 : Undefined
    0x003F,  // U+0b12 : Undefined
    0x07b0,  // U+0b13 : Oriya Letter O
    0x07b1,  // U+0b14 : Oriya Letter Au
    0x07b3,  // U+0b15 : Oriya Letter Ka
    0x07b4,  // U+0b16 : Oriya Letter Kha
    0x07b5,  // U+0b17 : Oriya Letter Ga
    0x07b6,  // U+0b18 : Oriya Letter Gha
    0x07b7,  // U+0b19 : Oriya Letter Nga
    0x07b8,  // U+0b1a : Oriya Letter Ca
    0x07b9,  // U+0b1b : Oriya Letter Cha
    0x07ba,  // U+0b1c : Oriya Letter Ja
    0x07bb,  // U+0b1d : Oriya Letter Jha
    0x07bc,  // U+0b1e : Oriya Letter Nya
    0x07bd,  // U+0b1f : Oriya Letter Tta
    0x07be,  // U+0b20 : Oriya Letter Ttha
    0x07bf,  // U+0b21 : Oriya Letter Dda
    0x07c0,  // U+0b22 : Oriya Letter Ddha
    0x07c1,  // U+0b23 : Oriya Letter Nna
    0x07c2,  // U+0b24 : Oriya Letter Ta
    0x07c3,  // U+0b25 : Oriya Letter Tha
    0x07c4,  // U+0b26 : Oriya Letter Da
    0x07c5,  // U+0b27 : Oriya Letter Dha
    0x07c6,  // U+0b28 : Oriya Letter Na
    0x003F,  // U+0b29 : Undefined
    0x07c8,  // U+0b2a : Oriya Letter Pa
    0x07c9,  // U+0b2b : Oriya Letter Pha
    0x07ca,  // U+0b2c : Oriya Letter Ba
    0x07cb,  // U+0b2d : Oriya Letter Bha
    0x07cc,  // U+0b2e : Oriya Letter Ma
    0x07cd,  // U+0b2f : Oriya Letter Ya
    0x07cf,  // U+0b30 : Oriya Letter Ra
    0x003F,  // U+0b31 : Undefined
    0x07d1,  // U+0b32 : Oriya Letter La
    0x07d2,  // U+0b33 : Oriya Letter Lla
    0x003F,  // U+0b34 : Undefined
    0x003F,  // U+0b35 : Undefined
    0x07d5,  // U+0b36 : Oriya Letter Sha
    0x07d6,  // U+0b37 : Oriya Letter Ssa
    0x07d7,  // U+0b38 : Oriya Letter Sa
    0x07d8,  // U+0b39 : Oriya Letter Ha
    0x003F,  // U+0b3a : Undefined
    0x003F,  // U+0b3b : Undefined
    0x07e9,  // U+0b3c : Oriya Sign Nukta
    0x17ea,  // U+0b3d : Oriya Sign Avagraha
    0x07da,  // U+0b3e : Oriya Vowel Sign Aa
    0x07db,  // U+0b3f : Oriya Vowel Sign I
    0x07dc,  // U+0b40 : Oriya Vowel Sign Ii
    0x07dd,  // U+0b41 : Oriya Vowel Sign U
    0x07de,  // U+0b42 : Oriya Vowel Sign Uu
    0x07df,  // U+0b43 : Oriya Vowel Sign Vocalic R
    0x003F,  // U+0b44 : Undefined
    0x003F,  // U+0b45 : Undefined
    0x003F,  // U+0b46 : Undefined
    0x07e0,  // U+0b47 : Oriya Vowel Sign E
    0x07e2,  // U+0b48 : Oriya Vowel Sign Ai
    0x003F,  // U+0b49 : Undefined
    0x003F,  // U+0b4a : Undefined
    0x07e4,  // U+0b4b : Oriya Vowel Sign O
    0x07e6,  // U+0b4c : Oriya Vowel Sign Au
    0x07e8,  // U+0b4d : Oriya Sign Virama
    0x003F,  // U+0b4e : Undefined
    0x003F,  // U+0b4f : Undefined
    0x003F,  // U+0b50 : Undefined
    0x003F,  // U+0b51 : Undefined
    0x003F,  // U+0b52 : Undefined
    0x003F,  // U+0b53 : Undefined
    0x003F,  // U+0b54 : Undefined
    0x003F,  // U+0b55 : Undefined
    0x003F,  // U+0b56 : Oriya Ai Length Mark
    0x003F,  // U+0b57 : Oriya Au Length Mark
    0x003F,  // U+0b58 : Undefined
    0x003F,  // U+0b59 : Undefined
    0x003F,  // U+0b5a : Undefined
    0x003F,  // U+0b5b : Undefined
    0x17bf,  // U+0b5c : Oriya Letter Rra
    0x17c0,  // U+0b5d : Oriya Letter Rha
    0x003F,  // U+0b5e : Undefined
    0x07ce,  // U+0b5f : Oriya Letter Yya
    0x17aa,  // U+0b60 : Oriya Letter Vocalic Rr
    0x17a7,  // U+0b61 : Oriya Letter Vocalic Ll
    0x003F,  // U+0b62 : Undefined
    0x003F,  // U+0b63 : Undefined
    0x003F,  // U+0b64 : Undefined
    0x003F,  // U+0b65 : Undefined
    0x07f1,  // U+0b66 : Oriya Digit Zero
    0x07f2,  // U+0b67 : Oriya Digit One
    0x07f3,  // U+0b68 : Oriya Digit Two
    0x07f4,  // U+0b69 : Oriya Digit Three
    0x07f5,  // U+0b6a : Oriya Digit Four
    0x07f6,  // U+0b6b : Oriya Digit Five
    0x07f7,  // U+0b6c : Oriya Digit Six
    0x07f8,  // U+0b6d : Oriya Digit Seven
    0x07f9,  // U+0b6e : Oriya Digit Eight
    0x07fa,  // U+0b6f : Oriya Digit Nine
    0x003F,  // U+0b70 : Oriya Isshar
    0x003F,  // U+0b71 : Undefined
    0x003F,  // U+0b72 : Undefined
    0x003F,  // U+0b73 : Undefined
    0x003F,  // U+0b74 : Undefined
    0x003F,  // U+0b75 : Undefined
    0x003F,  // U+0b76 : Undefined
    0x003F,  // U+0b77 : Undefined
    0x003F,  // U+0b78 : Undefined
    0x003F,  // U+0b79 : Undefined
    0x003F,  // U+0b7a : Undefined
    0x003F,  // U+0b7b : Undefined
    0x003F,  // U+0b7c : Undefined
    0x003F,  // U+0b7d : Undefined
    0x003F,  // U+0b7e : Undefined
    0x003F,  // U+0b7f : Undefined
    0x003F,  // U+0b80 : Undefined
    0x003F,  // U+0b81 : Undefined
    0x04a2,  // U+0b82 : Tamil Sign Anusvara
    0x04a3,  // U+0b83 : Tamil Sign Visarga
    0x003F,  // U+0b84 : Undefined
    0x04a4,  // U+0b85 : Tamil Letter A
    0x04a5,  // U+0b86 : Tamil Letter Aa
    0x04a6,  // U+0b87 : Tamil Letter I
    0x04a7,  // U+0b88 : Tamil Letter Ii
    0x04a8,  // U+0b89 : Tamil Letter U
    0x04a9,  // U+0b8a : Tamil Letter Uu
    0x003F,  // U+0b8b : Undefined
    0x003F,  // U+0b8c : Undefined
    0x003F,  // U+0b8d : Undefined
    0x003F,  // U+0b8e : Tamil Letter E
    0x04ab,  // U+0b8f : Tamil Letter Ee
    0x04ad,  // U+0b90 : Tamil Letter Ai
    0x003F,  // U+0b91 : Undefined
    0x04af,  // U+0b92 : Tamil Letter O
    0x04b0,  // U+0b93 : Tamil Letter Oo
    0x04b1,  // U+0b94 : Tamil Letter Au
    0x04b3,  // U+0b95 : Tamil Letter Ka
    0x003F,  // U+0b96 : Undefined
    0x003F,  // U+0b97 : Undefined
    0x003F,  // U+0b98 : Undefined
    0x04b7,  // U+0b99 : Tamil Letter Nga
    0x04b8,  // U+0b9a : Tamil Letter Ca
    0x003F,  // U+0b9b : Undefined
    0x04ba,  // U+0b9c : Tamil Letter Ja
    0x003F,  // U+0b9d : Undefined
    0x04bc,  // U+0b9e : Tamil Letter Nya
    0x04bd,  // U+0b9f : Tamil Letter Tta
    0x003F,  // U+0ba0 : Undefined
    0x003F,  // U+0ba1 : Undefined
    0x003F,  // U+0ba2 : Undefined
    0x04c1,  // U+0ba3 : Tamil Letter Nna
    0x04c2,  // U+0ba4 : Tamil Letter Ta
    0x003F,  // U+0ba5 : Undefined
    0x003F,  // U+0ba6 : Undefined
    0x003F,  // U+0ba7 : Undefined
    0x04c6,  // U+0ba8 : Tamil Letter Na
    0x04c7,  // U+0ba9 : Tamil Letter Nnna
    0x04c8,  // U+0baa : Tamil Letter Pa
    0x003F,  // U+0bab : Undefined
    0x003F,  // U+0bac : Undefined
    0x003F,  // U+0bad : Undefined
    0x04cc,  // U+0bae : Tamil Letter Ma
    0x04cd,  // U+0baf : Tamil Letter Ya
    0x04cf,  // U+0bb0 : Tamil Letter Ra
    0x04d0,  // U+0bb1 : Tamil Letter Rra
    0x04d1,  // U+0bb2 : Tamil Letter La
    0x04d2,  // U+0bb3 : Tamil Letter Lla
    0x04d3,  // U+0bb4 : Tamil Letter Llla
    0x04d4,  // U+0bb5 : Tamil Letter Va
    0x003F,  // U+0bb6 : Undefined
    0x04d5,  // U+0bb7 : Tamil Letter Ssa
    0x04d7,  // U+0bb8 : Tamil Letter Sa
    0x04d8,  // U+0bb9 : Tamil Letter Ha
    0x003F,  // U+0bba : Undefined
    0x003F,  // U+0bbb : Undefined
    0x003F,  // U+0bbc : Undefined
    0x003F,  // U+0bbd : Undefined
    0x04da,  // U+0bbe : Tamil Vowel Sign Aa
    0x04db,  // U+0bbf : Tamil Vowel Sign I
    0x04dc,  // U+0bc0 : Tamil Vowel Sign Ii
    0x04dd,  // U+0bc1 : Tamil Vowel Sign U
    0x04de,  // U+0bc2 : Tamil Vowel Sign Uu
    0x003F,  // U+0bc3 : Undefined
    0x003F,  // U+0bc4 : Undefined
    0x003F,  // U+0bc5 : Undefined
    0x04e0,  // U+0bc6 : Tamil Vowel Sign E
    0x04e1,  // U+0bc7 : Tamil Vowel Sign Ee
    0x04e2,  // U+0bc8 : Tamil Vowel Sign Ai
    0x003F,  // U+0bc9 : Undefined
    0x04e4,  // U+0bca : Tamil Vowel Sign O
    0x04e5,  // U+0bcb : Tamil Vowel Sign Oo
    0x04e6,  // U+0bcc : Tamil Vowel Sign Au
    0x04e8,  // U+0bcd : Tamil Sign Virama
    0x003F,  // U+0bce : Undefined
    0x003F,  // U+0bcf : Undefined
    0x003F,  // U+0bd0 : Undefined
    0x003F,  // U+0bd1 : Undefined
    0x003F,  // U+0bd2 : Undefined
    0x003F,  // U+0bd3 : Undefined
    0x003F,  // U+0bd4 : Undefined
    0x003F,  // U+0bd5 : Undefined
    0x003F,  // U+0bd6 : Undefined
    0x003F,  // U+0bd7 : Tamil Au Length Mark
    0x003F,  // U+0bd8 : Undefined
    0x003F,  // U+0bd9 : Undefined
    0x003F,  // U+0bda : Undefined
    0x003F,  // U+0bdb : Undefined
    0x003F,  // U+0bdc : Undefined
    0x003F,  // U+0bdd : Undefined
    0x003F,  // U+0bde : Undefined
    0x003F,  // U+0bdf : Undefined
    0x003F,  // U+0be0 : Undefined
    0x003F,  // U+0be1 : Undefined
    0x003F,  // U+0be2 : Undefined
    0x003F,  // U+0be3 : Undefined
    0x003F,  // U+0be4 : Undefined
    0x003F,  // U+0be5 : Undefined
    0x003F,  // U+0be6 : Undefined
    0x04f2,  // U+0be7 : Tamil Digit One
    0x04f3,  // U+0be8 : Tamil Digit Two
    0x04f4,  // U+0be9 : Tamil Digit Three
    0x04f5,  // U+0bea : Tamil Digit Four
    0x04f6,  // U+0beb : Tamil Digit Five
    0x04f7,  // U+0bec : Tamil Digit Six
    0x04f8,  // U+0bed : Tamil Digit Seven
    0x04f9,  // U+0bee : Tamil Digit Eight
    0x04fa,  // U+0bef : Tamil Digit Nine
    0x003F,  // U+0bf0 : Tamil Number Ten
    0x003F,  // U+0bf1 : Tamil Number One Hundred
    0x003F,  // U+0bf2 : Tamil Number One Thousand
    0x003F,  // U+0bf3 : Undefined
    0x003F,  // U+0bf4 : Undefined
    0x003F,  // U+0bf5 : Undefined
    0x003F,  // U+0bf6 : Undefined
    0x003F,  // U+0bf7 : Undefined
    0x003F,  // U+0bf8 : Undefined
    0x003F,  // U+0bf9 : Undefined
    0x003F,  // U+0bfa : Undefined
    0x003F,  // U+0bfb : Undefined
    0x003F,  // U+0bfc : Undefined
    0x003F,  // U+0bfd : Undefined
    0x003F,  // U+0bfe : Undefined
    0x003F,  // U+0bff : Undefined
    0x003F,  // U+0c00 : Undefined
    0x05a1,  // U+0c01 : Telugu Sign Candrabindu
    0x05a2,  // U+0c02 : Telugu Sign Anusvara
    0x05a3,  // U+0c03 : Telugu Sign Visarga
    0x003F,  // U+0c04 : Undefined
    0x05a4,  // U+0c05 : Telugu Letter A
    0x05a5,  // U+0c06 : Telugu Letter Aa
    0x05a6,  // U+0c07 : Telugu Letter I
    0x05a7,  // U+0c08 : Telugu Letter Ii
    0x05a8,  // U+0c09 : Telugu Letter U
    0x05a9,  // U+0c0a : Telugu Letter Uu
    0x05aa,  // U+0c0b : Telugu Letter Vocalic R
    0x15a6,  // U+0c0c : Telugu Letter Vocalic L
    0x003F,  // U+0c0d : Undefined
    0x05ab,  // U+0c0e : Telugu Letter E
    0x05ac,  // U+0c0f : Telugu Letter Ee
    0x05ad,  // U+0c10 : Telugu Letter Ai
    0x003F,  // U+0c11 : Undefined
    0x05af,  // U+0c12 : Telugu Letter O
    0x05b0,  // U+0c13 : Telugu Letter Oo
    0x05b1,  // U+0c14 : Telugu Letter Au
    0x05b3,  // U+0c15 : Telugu Letter Ka
    0x05b4,  // U+0c16 : Telugu Letter Kha
    0x05b5,  // U+0c17 : Telugu Letter Ga
    0x05b6,  // U+0c18 : Telugu Letter Gha
    0x05b7,  // U+0c19 : Telugu Letter Nga
    0x05b8,  // U+0c1a : Telugu Letter Ca
    0x05b9,  // U+0c1b : Telugu Letter Cha
    0x05ba,  // U+0c1c : Telugu Letter Ja
    0x05bb,  // U+0c1d : Telugu Letter Jha
    0x05bc,  // U+0c1e : Telugu Letter Nya
    0x05bd,  // U+0c1f : Telugu Letter Tta
    0x05be,  // U+0c20 : Telugu Letter Ttha
    0x05bf,  // U+0c21 : Telugu Letter Dda
    0x05c0,  // U+0c22 : Telugu Letter Ddha
    0x05c1,  // U+0c23 : Telugu Letter Nna
    0x05c2,  // U+0c24 : Telugu Letter Ta
    0x05c3,  // U+0c25 : Telugu Letter Tha
    0x05c4,  // U+0c26 : Telugu Letter Da
    0x05c5,  // U+0c27 : Telugu Letter Dha
    0x05c6,  // U+0c28 : Telugu Letter Na
    0x003F,  // U+0c29 : Undefined
    0x05c8,  // U+0c2a : Telugu Letter Pa
    0x05c9,  // U+0c2b : Telugu Letter Pha
    0x05ca,  // U+0c2c : Telugu Letter Ba
    0x05cb,  // U+0c2d : Telugu Letter Bha
    0x05cc,  // U+0c2e : Telugu Letter Ma
    0x05cd,  // U+0c2f : Telugu Letter Ya
    0x05cf,  // U+0c30 : Telugu Letter Ra
    0x05d0,  // U+0c31 : Telugu Letter Rra
    0x05d1,  // U+0c32 : Telugu Letter La
    0x05d2,  // U+0c33 : Telugu Letter Lla
    0x003F,  // U+0c34 : Undefined
    0x05d4,  // U+0c35 : Telugu Letter Va
    0x05d5,  // U+0c36 : Telugu Letter Sha
    0x05d6,  // U+0c37 : Telugu Letter Ssa
    0x05d7,  // U+0c38 : Telugu Letter Sa
    0x05d8,  // U+0c39 : Telugu Letter Ha
    0x003F,  // U+0c3a : Undefined
    0x003F,  // U+0c3b : Undefined
    0x003F,  // U+0c3c : Undefined
    0x003F,  // U+0c3d : Undefined
    0x05da,  // U+0c3e : Telugu Vowel Sign Aa
    0x05db,  // U+0c3f : Telugu Vowel Sign I
    0x05dc,  // U+0c40 : Telugu Vowel Sign Ii
    0x05dd,  // U+0c41 : Telugu Vowel Sign U
    0x05de,  // U+0c42 : Telugu Vowel Sign Uu
    0x05df,  // U+0c43 : Telugu Vowel Sign Vocalic R
    0x15df,  // U+0c44 : Telugu Vowel Sign Vocalic Rr
    0x003F,  // U+0c45 : Undefined
    0x05e0,  // U+0c46 : Telugu Vowel Sign E
    0x05e1,  // U+0c47 : Telugu Vowel Sign Ee
    0x05e2,  // U+0c48 : Telugu Vowel Sign Ai
    0x003F,  // U+0c49 : Undefined
    0x05e4,  // U+0c4a : Telugu Vowel Sign O
    0x05e5,  // U+0c4b : Telugu Vowel Sign Oo
    0x05e6,  // U+0c4c : Telugu Vowel Sign Au
    0x05e8,  // U+0c4d : Telugu Sign Virama
    0x003F,  // U+0c4e : Undefined
    0x003F,  // U+0c4f : Undefined
    0x003F,  // U+0c50 : Undefined
    0x003F,  // U+0c51 : Undefined
    0x003F,  // U+0c52 : Undefined
    0x003F,  // U+0c53 : Undefined
    0x003F,  // U+0c54 : Undefined
    0x003F,  // U+0c55 : Telugu Length Mark
    0x003F,  // U+0c56 : Telugu Ai Length Mark
    0x003F,  // U+0c57 : Undefined
    0x003F,  // U+0c58 : Undefined
    0x003F,  // U+0c59 : Undefined
    0x003F,  // U+0c5a : Undefined
    0x003F,  // U+0c5b : Undefined
    0x003F,  // U+0c5c : Undefined
    0x003F,  // U+0c5d : Undefined
    0x003F,  // U+0c5e : Undefined
    0x003F,  // U+0c5f : Undefined
    0x15aa,  // U+0c60 : Telugu Letter Vocalic Rr
    0x15a7,  // U+0c61 : Telugu Letter Vocalic Ll
    0x003F,  // U+0c62 : Undefined
    0x003F,  // U+0c63 : Undefined
    0x003F,  // U+0c64 : Undefined
    0x003F,  // U+0c65 : Undefined
    0x05f1,  // U+0c66 : Telugu Digit Zero
    0x05f2,  // U+0c67 : Telugu Digit One
    0x05f3,  // U+0c68 : Telugu Digit Two
    0x05f4,  // U+0c69 : Telugu Digit Three
    0x05f5,  // U+0c6a : Telugu Digit Four
    0x05f6,  // U+0c6b : Telugu Digit Five
    0x05f7,  // U+0c6c : Telugu Digit Six
    0x05f8,  // U+0c6d : Telugu Digit Seven
    0x05f9,  // U+0c6e : Telugu Digit Eight
    0x05fa,  // U+0c6f : Telugu Digit Nine
    0x003F,  // U+0c70 : Undefined
    0x003F,  // U+0c71 : Undefined
    0x003F,  // U+0c72 : Undefined
    0x003F,  // U+0c73 : Undefined
    0x003F,  // U+0c74 : Undefined
    0x003F,  // U+0c75 : Undefined
    0x003F,  // U+0c76 : Undefined
    0x003F,  // U+0c77 : Undefined
    0x003F,  // U+0c78 : Undefined
    0x003F,  // U+0c79 : Undefined
    0x003F,  // U+0c7a : Undefined
    0x003F,  // U+0c7b : Undefined
    0x003F,  // U+0c7c : Undefined
    0x003F,  // U+0c7d : Undefined
    0x003F,  // U+0c7e : Undefined
    0x003F,  // U+0c7f : Undefined
    0x003F,  // U+0c80 : Undefined
    0x003F,  // U+0c81 : Undefined
    0x08a2,  // U+0c82 : Kannada Sign Anusvara
    0x08a3,  // U+0c83 : Kannada Sign Visarga
    0x003F,  // U+0c84 : Undefined
    0x08a4,  // U+0c85 : Kannada Letter A
    0x08a5,  // U+0c86 : Kannada Letter Aa
    0x08a6,  // U+0c87 : Kannada Letter I
    0x08a7,  // U+0c88 : Kannada Letter Ii
    0x08a8,  // U+0c89 : Kannada Letter U
    0x08a9,  // U+0c8a : Kannada Letter Uu
    0x08aa,  // U+0c8b : Kannada Letter Vocalic R
    0x18a6,  // U+0c8c : Kannada Letter Vocalic L
    0x003F,  // U+0c8d : Undefined
    0x08ab,  // U+0c8e : Kannada Letter E
    0x08ac,  // U+0c8f : Kannada Letter Ee
    0x08ad,  // U+0c90 : Kannada Letter Ai
    0x003F,  // U+0c91 : Undefined
    0x08af,  // U+0c92 : Kannada Letter O
    0x08b0,  // U+0c93 : Kannada Letter Oo
    0x08b1,  // U+0c94 : Kannada Letter Au
    0x08b3,  // U+0c95 : Kannada Letter Ka
    0x08b4,  // U+0c96 : Kannada Letter Kha
    0x08b5,  // U+0c97 : Kannada Letter Ga
    0x08b6,  // U+0c98 : Kannada Letter Gha
    0x08b7,  // U+0c99 : Kannada Letter Nga
    0x08b8,  // U+0c9a : Kannada Letter Ca
    0x08b9,  // U+0c9b : Kannada Letter Cha
    0x08ba,  // U+0c9c : Kannada Letter Ja
    0x08bb,  // U+0c9d : Kannada Letter Jha
    0x08bc,  // U+0c9e : Kannada Letter Nya
    0x08bd,  // U+0c9f : Kannada Letter Tta
    0x08be,  // U+0ca0 : Kannada Letter Ttha
    0x08bf,  // U+0ca1 : Kannada Letter Dda
    0x08c0,  // U+0ca2 : Kannada Letter Ddha
    0x08c1,  // U+0ca3 : Kannada Letter Nna
    0x08c2,  // U+0ca4 : Kannada Letter Ta
    0x08c3,  // U+0ca5 : Kannada Letter Tha
    0x08c4,  // U+0ca6 : Kannada Letter Da
    0x08c5,  // U+0ca7 : Kannada Letter Dha
    0x08c6,  // U+0ca8 : Kannada Letter Na
    0x003F,  // U+0ca9 : Undefined
    0x08c8,  // U+0caa : Kannada Letter Pa
    0x08c9,  // U+0cab : Kannada Letter Pha
    0x08ca,  // U+0cac : Kannada Letter Ba
    0x08cb,  // U+0cad : Kannada Letter Bha
    0x08cc,  // U+0cae : Kannada Letter Ma
    0x08cd,  // U+0caf : Kannada Letter Ya
    0x08cf,  // U+0cb0 : Kannada Letter Ra
    0x08d0,  // U+0cb1 : Kannada Letter Rra
    0x08d1,  // U+0cb2 : Kannada Letter La
    0x08d2,  // U+0cb3 : Kannada Letter Lla
    0x003F,  // U+0cb4 : Undefined
    0x08d4,  // U+0cb5 : Kannada Letter Va
    0x08d5,  // U+0cb6 : Kannada Letter Sha
    0x08d6,  // U+0cb7 : Kannada Letter Ssa
    0x08d7,  // U+0cb8 : Kannada Letter Sa
    0x08d8,  // U+0cb9 : Kannada Letter Ha
    0x003F,  // U+0cba : Undefined
    0x003F,  // U+0cbb : Undefined
    0x003F,  // U+0cbc : Undefined
    0x003F,  // U+0cbd : Undefined
    0x08da,  // U+0cbe : Kannada Vowel Sign Aa
    0x08db,  // U+0cbf : Kannada Vowel Sign I
    0x08dc,  // U+0cc0 : Kannada Vowel Sign Ii
    0x08dd,  // U+0cc1 : Kannada Vowel Sign U
    0x08de,  // U+0cc2 : Kannada Vowel Sign Uu
    0x08df,  // U+0cc3 : Kannada Vowel Sign Vocalic R
    0x18df,  // U+0cc4 : Kannada Vowel Sign Vocalic Rr
    0x003F,  // U+0cc5 : Undefined
    0x08e0,  // U+0cc6 : Kannada Vowel Sign E
    0x08e1,  // U+0cc7 : Kannada Vowel Sign Ee
    0x08e2,  // U+0cc8 : Kannada Vowel Sign Ai
    0x003F,  // U+0cc9 : Undefined
    0x08e4,  // U+0cca : Kannada Vowel Sign O
    0x08e5,  // U+0ccb : Kannada Vowel Sign Oo
    0x08e6,  // U+0ccc : Kannada Vowel Sign Au
    0x08e8,  // U+0ccd : Kannada Sign Virama
    0x003F,  // U+0cce : Undefined
    0x003F,  // U+0ccf : Undefined
    0x003F,  // U+0cd0 : Undefined
    0x003F,  // U+0cd1 : Undefined
    0x003F,  // U+0cd2 : Undefined
    0x003F,  // U+0cd3 : Undefined
    0x003F,  // U+0cd4 : Undefined
    0x003F,  // U+0cd5 : Kannada Length Mark
    0x003F,  // U+0cd6 : Kannada Ai Length Mark
    0x003F,  // U+0cd7 : Undefined
    0x003F,  // U+0cd8 : Undefined
    0x003F,  // U+0cd9 : Undefined
    0x003F,  // U+0cda : Undefined
    0x003F,  // U+0cdb : Undefined
    0x003F,  // U+0cdc : Undefined
    0x003F,  // U+0cdd : Undefined
    0x18c9,  // U+0cde : Kannada Letter Fa
    0x003F,  // U+0cdf : Undefined
    0x18aa,  // U+0ce0 : Kannada Letter Vocalic Rr
    0x18a7,  // U+0ce1 : Kannada Letter Vocalic Ll
    0x003F,  // U+0ce2 : Undefined
    0x003F,  // U+0ce3 : Undefined
    0x003F,  // U+0ce4 : Undefined
    0x003F,  // U+0ce5 : Undefined
    0x08f1,  // U+0ce6 : Kannada Digit Zero
    0x08f2,  // U+0ce7 : Kannada Digit One
    0x08f3,  // U+0ce8 : Kannada Digit Two
    0x08f4,  // U+0ce9 : Kannada Digit Three
    0x08f5,  // U+0cea : Kannada Digit Four
    0x08f6,  // U+0ceb : Kannada Digit Five
    0x08f7,  // U+0cec : Kannada Digit Six
    0x08f8,  // U+0ced : Kannada Digit Seven
    0x08f9,  // U+0cee : Kannada Digit Eight
    0x08fa,  // U+0cef : Kannada Digit Nine
    0x003F,  // U+0cf0 : Undefined
    0x003F,  // U+0cf1 : Undefined
    0x003F,  // U+0cf2 : Undefined
    0x003F,  // U+0cf3 : Undefined
    0x003F,  // U+0cf4 : Undefined
    0x003F,  // U+0cf5 : Undefined
    0x003F,  // U+0cf6 : Undefined
    0x003F,  // U+0cf7 : Undefined
    0x003F,  // U+0cf8 : Undefined
    0x003F,  // U+0cf9 : Undefined
    0x003F,  // U+0cfa : Undefined
    0x003F,  // U+0cfb : Undefined
    0x003F,  // U+0cfc : Undefined
    0x003F,  // U+0cfd : Undefined
    0x003F,  // U+0cfe : Undefined
    0x003F,  // U+0cff : Undefined
    0x003F,  // U+0d00 : Undefined
    0x003F,  // U+0d01 : Undefined
    0x09a2,  // U+0d02 : Malayalam Sign Anusvara
    0x09a3,  // U+0d03 : Malayalam Sign Visarga
    0x003F,  // U+0d04 : Undefined
    0x09a4,  // U+0d05 : Malayalam Letter A
    0x09a5,  // U+0d06 : Malayalam Letter Aa
    0x09a6,  // U+0d07 : Malayalam Letter I
    0x09a7,  // U+0d08 : Malayalam Letter Ii
    0x09a8,  // U+0d09 : Malayalam Letter U
    0x09a9,  // U+0d0a : Malayalam Letter Uu
    0x09aa,  // U+0d0b : Malayalam Letter Vocalic R
    0x19a6,  // U+0d0c : Malayalam Letter Vocalic L
    0x003F,  // U+0d0d : Undefined
    0x09ab,  // U+0d0e : Malayalam Letter E
    0x09ac,  // U+0d0f : Malayalam Letter Ee
    0x09ad,  // U+0d10 : Malayalam Letter Ai
    0x003F,  // U+0d11 : Undefined
    0x09af,  // U+0d12 : Malayalam Letter O
    0x09b0,  // U+0d13 : Malayalam Letter Oo
    0x09b1,  // U+0d14 : Malayalam Letter Au
    0x09b3,  // U+0d15 : Malayalam Letter Ka
    0x09b4,  // U+0d16 : Malayalam Letter Kha
    0x09b5,  // U+0d17 : Malayalam Letter Ga
    0x09b6,  // U+0d18 : Malayalam Letter Gha
    0x09b7,  // U+0d19 : Malayalam Letter Nga
    0x09b8,  // U+0d1a : Malayalam Letter Ca
    0x09b9,  // U+0d1b : Malayalam Letter Cha
    0x09ba,  // U+0d1c : Malayalam Letter Ja
    0x09bb,  // U+0d1d : Malayalam Letter Jha
    0x09bc,  // U+0d1e : Malayalam Letter Nya
    0x09bd,  // U+0d1f : Malayalam Letter Tta
    0x09be,  // U+0d20 : Malayalam Letter Ttha
    0x09bf,  // U+0d21 : Malayalam Letter Dda
    0x09c0,  // U+0d22 : Malayalam Letter Ddha
    0x09c1,  // U+0d23 : Malayalam Letter Nna
    0x09c2,  // U+0d24 : Malayalam Letter Ta
    0x09c3,  // U+0d25 : Malayalam Letter Tha
    0x09c4,  // U+0d26 : Malayalam Letter Da
    0x09c5,  // U+0d27 : Malayalam Letter Dha
    0x09c6,  // U+0d28 : Malayalam Letter Na
    0x003F,  // U+0d29 : Undefined
    0x09c8,  // U+0d2a : Malayalam Letter Pa
    0x09c9,  // U+0d2b : Malayalam Letter Pha
    0x09ca,  // U+0d2c : Malayalam Letter Ba
    0x09cb,  // U+0d2d : Malayalam Letter Bha
    0x09cc,  // U+0d2e : Malayalam Letter Ma
    0x09cd,  // U+0d2f : Malayalam Letter Ya
    0x09cf,  // U+0d30 : Malayalam Letter Ra
    0x09d0,  // U+0d31 : Malayalam Letter Rra
    0x09d1,  // U+0d32 : Malayalam Letter La
    0x09d2,  // U+0d33 : Malayalam Letter Lla
    0x09d3,  // U+0d34 : Malayalam Letter Llla
    0x09d4,  // U+0d35 : Malayalam Letter Va
    0x09d5,  // U+0d36 : Malayalam Letter Sha
    0x09d6,  // U+0d37 : Malayalam Letter Ssa
    0x09d7,  // U+0d38 : Malayalam Letter Sa
    0x09d8,  // U+0d39 : Malayalam Letter Ha
    0x003F,  // U+0d3a : Undefined
    0x003F,  // U+0d3b : Undefined
    0x003F,  // U+0d3c : Undefined
    0x003F,  // U+0d3d : Undefined
    0x09da,  // U+0d3e : Malayalam Vowel Sign Aa
    0x09db,  // U+0d3f : Malayalam Vowel Sign I
    0x09dc,  // U+0d40 : Malayalam Vowel Sign Ii
    0x09dd,  // U+0d41 : Malayalam Vowel Sign U
    0x09de,  // U+0d42 : Malayalam Vowel Sign Uu
    0x09df,  // U+0d43 : Malayalam Vowel Sign Vocalic R
    0x003F,  // U+0d44 : Undefined
    0x003F,  // U+0d45 : Undefined
    0x09e0,  // U+0d46 : Malayalam Vowel Sign E
    0x09e1,  // U+0d47 : Malayalam Vowel Sign Ee
    0x09e2,  // U+0d48 : Malayalam Vowel Sign Ai
    0x003F,  // U+0d49 : Undefined
    0x09e4,  // U+0d4a : Malayalam Vowel Sign O
    0x09e5,  // U+0d4b : Malayalam Vowel Sign Oo
    0x09e6,  // U+0d4c : Malayalam Vowel Sign Au
    0x09e8,  // U+0d4d : Malayalam Sign Virama
    0x003F,  // U+0d4e : Undefined
    0x003F,  // U+0d4f : Undefined
    0x003F,  // U+0d50 : Undefined
    0x003F,  // U+0d51 : Undefined
    0x003F,  // U+0d52 : Undefined
    0x003F,  // U+0d53 : Undefined
    0x003F,  // U+0d54 : Undefined
    0x003F,  // U+0d55 : Undefined
    0x003F,  // U+0d56 : Undefined
    0x003F,  // U+0d57 : Malayalam Au Length Mark
    0x003F,  // U+0d58 : Undefined
    0x003F,  // U+0d59 : Undefined
    0x003F,  // U+0d5a : Undefined
    0x003F,  // U+0d5b : Undefined
    0x003F,  // U+0d5c : Undefined
    0x003F,  // U+0d5d : Undefined
    0x003F,  // U+0d5e : Undefined
    0x003F,  // U+0d5f : Undefined
    0x19aa,  // U+0d60 : Malayalam Letter Vocalic Rr
    0x19a7,  // U+0d61 : Malayalam Letter Vocalic Ll
    0x003F,  // U+0d62 : Undefined
    0x003F,  // U+0d63 : Undefined
    0x003F,  // U+0d64 : Undefined
    0x003F,  // U+0d65 : Undefined
    0x09f1,  // U+0d66 : Malayalam Digit Zero
    0x09f2,  // U+0d67 : Malayalam Digit One
    0x09f3,  // U+0d68 : Malayalam Digit Two
    0x09f4,  // U+0d69 : Malayalam Digit Three
    0x09f5,  // U+0d6a : Malayalam Digit Four
    0x09f6,  // U+0d6b : Malayalam Digit Five
    0x09f7,  // U+0d6c : Malayalam Digit Six
    0x09f8,  // U+0d6d : Malayalam Digit Seven
    0x09f9,  // U+0d6e : Malayalam Digit Eight
    0x09fa   // U+0d6f : Malayalam Digit Nine
};


BYTE SecondByte[] =
{
    0x00,
    0xe9,
    0xb8,             // U+0952 == 0xf0_0xb8
    0xbf              // U+0970 == 0xf0_0xbf
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\data\dlls\iscii\c_iscii.h ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    c_iscii.h

Abstract:

    This file contains the header information for this module.

Revision History:

      2-28-98    KChang    Created.

--*/



//
//  Include Files.
//




//
//  Typedefs.
//

typedef struct
{
    BYTE  mb;
    WCHAR wc;
} ExtMB;




//
//  Extern Declarations.
//  Pointers to access tables.
//

extern WCHAR* ppwcIndic[];
extern WCHAR* ppwcIndic2[];
extern WCHAR  IndiChar[];
extern BYTE   SecondByte[];
extern ExtMB  ExtMBList[];




//
//  Constant Declarations.
//

#define DEF       0          // 0x40         Default
#define RMN       1          // 0x41         Roman
#define DEV       2          // 0x42  57002  Devanagari
#define BNG       3          // 0x43  57003  Bengali
#define TML       4          // 0x44  57004  Tamil
#define TLG       5          // 0x45  57005  Telugu
#define ASM       6          // 0x46  57006  Assamese (Bengali)
#define ORI       7          // 0x47  57007  Oriya
#define KND       8          // 0x48  57008  Kannada
#define MLM       9          // 0x49  57009  Malayalam
#define GJR      10          // 0x4a  57010  Gujarati
#define PNJ      11          // 0x4b  57011  Punjabi (Gurmukhi)

#define MB_Beg   ((BYTE)0xa0)
#define SUB      ((BYTE)0x3f)
#define VIRAMA   ((BYTE)0xe8)
#define NUKTA    ((BYTE)0xe9)
#define ATR      ((BYTE)0xef)
#define EXT      ((BYTE)0xf0)

#define WC_Beg   ((WCHAR)0x0901)
#define WC_End   ((WCHAR)0x0d6f)
#define ZWNJ     ((WCHAR)0x200c)
#define ZWJ      ((WCHAR)0x200d)




//
//  Macros.
//

#define UniChar(Script, MBChr)  (ppwcIndic [Script][MBChr - MB_Beg])
#define TwoTo1U(Script, MBChr)  (ppwcIndic2[Script][MBChr - MB_Beg])

#define MBChar(Unicode)         ((BYTE)(IndiChar[Unicode - WC_Beg]))
#define Script(Unicode)         (0x000f & (IndiChar[Unicode - WC_Beg] >> 8))
#define OneU_2M(Unicode)        (0xf000 & (IndiChar[Unicode - WC_Beg]))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\data\dlls\gb18030\tables.cpp ===
#include <share.h>
#include "c_gb18030.h"

const BYTE g_wUnicodeToGBTwoBytes[] = 
{

0xa8,0xbf, 0xa2,0xe3, 0xfe,0x50, 0xfe,0x54, 0xfe,0x57, 0xfe,0x58, 0xfe,0x5d, 0xfe,0x5e, 
0xfe,0x6b, 0xfe,0x6e, 0xfe,0x71, 0xfe,0x73, 0xfe,0x74, 0xfe,0x75, 0xfe,0x79, 0xfe,0x84, 
0xa9,0x8a, 0xa9,0x8b, 0xa9,0x8c, 0xa9,0x8d, 0xa9,0x8e, 0xa9,0x8f, 0xa9,0x90, 0xa9,0x91, 
0xa9,0x92, 0xa9,0x93, 0xa9,0x94, 0xa9,0x95, 0xa9,0x89, 0xfe,0x56, 0xfe,0x55, 0xfe,0x5a, 
0xfe,0x5c, 0xfe,0x5b, 0xfe,0x60, 0xfe,0x5f, 0xfe,0x62, 0xfe,0x65, 0xfe,0x63, 0xfe,0x64, 
0xfe,0x68, 0xfe,0x69, 0xfe,0x6a, 0xfe,0x6f, 0xfe,0x70, 0xfe,0x72, 0xfe,0x78, 0xfe,0x77, 
0xfe,0x7a, 0xfe,0x7b, 0xfe,0x7d, 0xfe,0x7c, 0xfe,0x80, 0xfe,0x81, 0xfe,0x82, 0xfe,0x83, 
0xfe,0x85, 0xfe,0x86, 0xfe,0x87, 0xfe,0x88, 0xfe,0x89, 0xfe,0x8a, 0xfe,0x8b, 0xfe,0x8d, 
0xfe,0x8c, 0xfe,0x8f, 0xfe,0x8e, 0xfe,0x96, 0xfe,0x93, 0xfe,0x94, 0xfe,0x95, 0xfe,0x97, 
0xfe,0x92, 0xfe,0x98, 0xfe,0x99, 0xfe,0x9a, 0xfe,0x9b, 0xfe,0x9c, 0xfe,0x9d, 0xfe,0x9e, 
0xfe,0x9f, 

};

const WORD g_wMax4BytesOffset = 0x9a4d;  // 39501 

const WORD g_wUnicodeToGB[] = 
{
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+0000 ~ U+0007
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+0008 ~ U+000f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+0010 ~ U+0017
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+0018 ~ U+001f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+0020 ~ U+0027
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+0028 ~ U+002f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+0030 ~ U+0037
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+0038 ~ U+003f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+0040 ~ U+0047
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+0048 ~ U+004f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+0050 ~ U+0057
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+0058 ~ U+005f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+0060 ~ U+0067
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+0068 ~ U+006f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+0070 ~ U+0077
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+0078 ~ U+007f
0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,   // U+0080 ~ U+0087
0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f,   // U+0088 ~ U+008f
0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,   // U+0090 ~ U+0097
0x0018, 0x0019, 0x001a, 0x001b, 0x001c, 0x001d, 0x001e, 0x001f,   // U+0098 ~ U+009f
0x0020, 0x0021, 0x0022, 0x0023, 0xffff, 0x0024, 0x0025, 0xffff,   // U+00a0 ~ U+00a7
0xffff, 0x0026, 0x0027, 0x0028, 0x0029, 0x002a, 0x002b, 0x002c,   // U+00a8 ~ U+00af
0xffff, 0xffff, 0x002d, 0x002e, 0x002f, 0x0030, 0x0031, 0xffff,   // U+00b0 ~ U+00b7
0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039,   // U+00b8 ~ U+00bf
0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f, 0x0040, 0x0041,   // U+00c0 ~ U+00c7
0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049,   // U+00c8 ~ U+00cf
0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f, 0x0050, 0xffff,   // U+00d0 ~ U+00d7
0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058,   // U+00d8 ~ U+00df
0xffff, 0xffff, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e,   // U+00e0 ~ U+00e7
0xffff, 0xffff, 0xffff, 0x005f, 0xffff, 0xffff, 0x0060, 0x0061,   // U+00e8 ~ U+00ef
0x0062, 0x0063, 0xffff, 0xffff, 0x0064, 0x0065, 0x0066, 0xffff,   // U+00f0 ~ U+00f7
0x0067, 0xffff, 0xffff, 0x0068, 0xffff, 0x0069, 0x006a, 0x006b,   // U+00f8 ~ U+00ff
0x006c, 0xffff, 0x006d, 0x006e, 0x006f, 0x0070, 0x0071, 0x0072,   // U+0100 ~ U+0107
0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, 0x007a,   // U+0108 ~ U+010f
0x007b, 0x007c, 0x007d, 0xffff, 0x007e, 0x007f, 0x0080, 0x0081,   // U+0110 ~ U+0117
0x0082, 0x0083, 0x0084, 0xffff, 0x0085, 0x0086, 0x0087, 0x0088,   // U+0118 ~ U+011f
0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f, 0x0090,   // U+0120 ~ U+0127
0x0091, 0x0092, 0x0093, 0xffff, 0x0094, 0x0095, 0x0096, 0x0097,   // U+0128 ~ U+012f
0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,   // U+0130 ~ U+0137
0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7,   // U+0138 ~ U+013f
0x00a8, 0x00a9, 0x00aa, 0x00ab, 0xffff, 0x00ac, 0x00ad, 0x00ae,   // U+0140 ~ U+0147
0xffff, 0x00af, 0x00b0, 0x00b1, 0x00b2, 0xffff, 0x00b3, 0x00b4,   // U+0148 ~ U+014f
0x00b5, 0x00b6, 0x00b7, 0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc,   // U+0150 ~ U+0157
0x00bd, 0x00be, 0x00bf, 0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4,   // U+0158 ~ U+015f
0x00c5, 0x00c6, 0x00c7, 0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc,   // U+0160 ~ U+0167
0x00cd, 0x00ce, 0x00cf, 0xffff, 0x00d0, 0x00d1, 0x00d2, 0x00d3,   // U+0168 ~ U+016f
0x00d4, 0x00d5, 0x00d6, 0x00d7, 0x00d8, 0x00d9, 0x00da, 0x00db,   // U+0170 ~ U+0177
0x00dc, 0x00dd, 0x00de, 0x00df, 0x00e0, 0x00e1, 0x00e2, 0x00e3,   // U+0178 ~ U+017f
0x00e4, 0x00e5, 0x00e6, 0x00e7, 0x00e8, 0x00e9, 0x00ea, 0x00eb,   // U+0180 ~ U+0187
0x00ec, 0x00ed, 0x00ee, 0x00ef, 0x00f0, 0x00f1, 0x00f2, 0x00f3,   // U+0188 ~ U+018f
0x00f4, 0x00f5, 0x00f6, 0x00f7, 0x00f8, 0x00f9, 0x00fa, 0x00fb,   // U+0190 ~ U+0197
0x00fc, 0x00fd, 0x00fe, 0x00ff, 0x0100, 0x0101, 0x0102, 0x0103,   // U+0198 ~ U+019f
0x0104, 0x0105, 0x0106, 0x0107, 0x0108, 0x0109, 0x010a, 0x010b,   // U+01a0 ~ U+01a7
0x010c, 0x010d, 0x010e, 0x010f, 0x0110, 0x0111, 0x0112, 0x0113,   // U+01a8 ~ U+01af
0x0114, 0x0115, 0x0116, 0x0117, 0x0118, 0x0119, 0x011a, 0x011b,   // U+01b0 ~ U+01b7
0x011c, 0x011d, 0x011e, 0x011f, 0x0120, 0x0121, 0x0122, 0x0123,   // U+01b8 ~ U+01bf
0x0124, 0x0125, 0x0126, 0x0127, 0x0128, 0x0129, 0x012a, 0x012b,   // U+01c0 ~ U+01c7
0x012c, 0x012d, 0x012e, 0x012f, 0x0130, 0x0131, 0xffff, 0x0132,   // U+01c8 ~ U+01cf
0xffff, 0x0133, 0xffff, 0x0134, 0xffff, 0x0135, 0xffff, 0x0136,   // U+01d0 ~ U+01d7
0xffff, 0x0137, 0xffff, 0x0138, 0xffff, 0x0139, 0x013a, 0x013b,   // U+01d8 ~ U+01df
0x013c, 0x013d, 0x013e, 0x013f, 0x0140, 0x0141, 0x0142, 0x0143,   // U+01e0 ~ U+01e7
0x0144, 0x0145, 0x0146, 0x0147, 0x0148, 0x0149, 0x014a, 0x014b,   // U+01e8 ~ U+01ef
0x014c, 0x014d, 0x014e, 0x014f, 0x0150, 0x0151, 0x0152, 0x0153,   // U+01f0 ~ U+01f7
0x0154, 0xfffe, 0x0155, 0x0156, 0x0157, 0x0158, 0x0159, 0x015a,   // U+01f8 ~ U+01ff
0x015b, 0x015c, 0x015d, 0x015e, 0x015f, 0x0160, 0x0161, 0x0162,   // U+0200 ~ U+0207
0x0163, 0x0164, 0x0165, 0x0166, 0x0167, 0x0168, 0x0169, 0x016a,   // U+0208 ~ U+020f
0x016b, 0x016c, 0x016d, 0x016e, 0x016f, 0x0170, 0x0171, 0x0172,   // U+0210 ~ U+0217
0x0173, 0x0174, 0x0175, 0x0176, 0x0177, 0x0178, 0x0179, 0x017a,   // U+0218 ~ U+021f
0x017b, 0x017c, 0x017d, 0x017e, 0x017f, 0x0180, 0x0181, 0x0182,   // U+0220 ~ U+0227
0x0183, 0x0184, 0x0185, 0x0186, 0x0187, 0x0188, 0x0189, 0x018a,   // U+0228 ~ U+022f
0x018b, 0x018c, 0x018d, 0x018e, 0x018f, 0x0190, 0x0191, 0x0192,   // U+0230 ~ U+0237
0x0193, 0x0194, 0x0195, 0x0196, 0x0197, 0x0198, 0x0199, 0x019a,   // U+0238 ~ U+023f
0x019b, 0x019c, 0x019d, 0x019e, 0x019f, 0x01a0, 0x01a1, 0x01a2,   // U+0240 ~ U+0247
0x01a3, 0x01a4, 0x01a5, 0x01a6, 0x01a7, 0x01a8, 0x01a9, 0x01aa,   // U+0248 ~ U+024f
0x01ab, 0xffff, 0x01ac, 0x01ad, 0x01ae, 0x01af, 0x01b0, 0x01b1,   // U+0250 ~ U+0257
0x01b2, 0x01b3, 0x01b4, 0x01b5, 0x01b6, 0x01b7, 0x01b8, 0x01b9,   // U+0258 ~ U+025f
0x01ba, 0xffff, 0x01bb, 0x01bc, 0x01bd, 0x01be, 0x01bf, 0x01c0,   // U+0260 ~ U+0267
0x01c1, 0x01c2, 0x01c3, 0x01c4, 0x01c5, 0x01c6, 0x01c7, 0x01c8,   // U+0268 ~ U+026f
0x01c9, 0x01ca, 0x01cb, 0x01cc, 0x01cd, 0x01ce, 0x01cf, 0x01d0,   // U+0270 ~ U+0277
0x01d1, 0x01d2, 0x01d3, 0x01d4, 0x01d5, 0x01d6, 0x01d7, 0x01d8,   // U+0278 ~ U+027f
0x01d9, 0x01da, 0x01db, 0x01dc, 0x01dd, 0x01de, 0x01df, 0x01e0,   // U+0280 ~ U+0287
0x01e1, 0x01e2, 0x01e3, 0x01e4, 0x01e5, 0x01e6, 0x01e7, 0x01e8,   // U+0288 ~ U+028f
0x01e9, 0x01ea, 0x01eb, 0x01ec, 0x01ed, 0x01ee, 0x01ef, 0x01f0,   // U+0290 ~ U+0297
0x01f1, 0x01f2, 0x01f3, 0x01f4, 0x01f5, 0x01f6, 0x01f7, 0x01f8,   // U+0298 ~ U+029f
0x01f9, 0x01fa, 0x01fb, 0x01fc, 0x01fd, 0x01fe, 0x01ff, 0x0200,   // U+02a0 ~ U+02a7
0x0201, 0x0202, 0x0203, 0x0204, 0x0205, 0x0206, 0x0207, 0x0208,   // U+02a8 ~ U+02af
0x0209, 0x020a, 0x020b, 0x020c, 0x020d, 0x020e, 0x020f, 0x0210,   // U+02b0 ~ U+02b7
0x0211, 0x0212, 0x0213, 0x0214, 0x0215, 0x0216, 0x0217, 0x0218,   // U+02b8 ~ U+02bf
0x0219, 0x021a, 0x021b, 0x021c, 0x021d, 0x021e, 0x021f, 0xffff,   // U+02c0 ~ U+02c7
0x0220, 0xffff, 0xffff, 0xffff, 0x0221, 0x0222, 0x0223, 0x0224,   // U+02c8 ~ U+02cf
0x0225, 0x0226, 0x0227, 0x0228, 0x0229, 0x022a, 0x022b, 0x022c,   // U+02d0 ~ U+02d7
0x022d, 0xffff, 0x022e, 0x022f, 0x0230, 0x0231, 0x0232, 0x0233,   // U+02d8 ~ U+02df
0x0234, 0x0235, 0x0236, 0x0237, 0x0238, 0x0239, 0x023a, 0x023b,   // U+02e0 ~ U+02e7
0x023c, 0x023d, 0x023e, 0x023f, 0x0240, 0x0241, 0x0242, 0x0243,   // U+02e8 ~ U+02ef
0x0244, 0x0245, 0x0246, 0x0247, 0x0248, 0x0249, 0x024a, 0x024b,   // U+02f0 ~ U+02f7
0x024c, 0x024d, 0x024e, 0x024f, 0x0250, 0x0251, 0x0252, 0x0253,   // U+02f8 ~ U+02ff
0x0254, 0x0255, 0x0256, 0x0257, 0x0258, 0x0259, 0x025a, 0x025b,   // U+0300 ~ U+0307
0x025c, 0x025d, 0x025e, 0x025f, 0x0260, 0x0261, 0x0262, 0x0263,   // U+0308 ~ U+030f
0x0264, 0x0265, 0x0266, 0x0267, 0x0268, 0x0269, 0x026a, 0x026b,   // U+0310 ~ U+0317
0x026c, 0x026d, 0x026e, 0x026f, 0x0270, 0x0271, 0x0272, 0x0273,   // U+0318 ~ U+031f
0x0274, 0x0275, 0x0276, 0x0277, 0x0278, 0x0279, 0x027a, 0x027b,   // U+0320 ~ U+0327
0x027c, 0x027d, 0x027e, 0x027f, 0x0280, 0x0281, 0x0282, 0x0283,   // U+0328 ~ U+032f
0x0284, 0x0285, 0x0286, 0x0287, 0x0288, 0x0289, 0x028a, 0x028b,   // U+0330 ~ U+0337
0x028c, 0x028d, 0x028e, 0x028f, 0x0290, 0x0291, 0x0292, 0x0293,   // U+0338 ~ U+033f
0x0294, 0x0295, 0x0296, 0x0297, 0x0298, 0x0299, 0x029a, 0x029b,   // U+0340 ~ U+0347
0x029c, 0x029d, 0x029e, 0x029f, 0x02a0, 0x02a1, 0x02a2, 0x02a3,   // U+0348 ~ U+034f
0x02a4, 0x02a5, 0x02a6, 0x02a7, 0x02a8, 0x02a9, 0x02aa, 0x02ab,   // U+0350 ~ U+0357
0x02ac, 0x02ad, 0x02ae, 0x02af, 0x02b0, 0x02b1, 0x02b2, 0x02b3,   // U+0358 ~ U+035f
0x02b4, 0x02b5, 0x02b6, 0x02b7, 0x02b8, 0x02b9, 0x02ba, 0x02bb,   // U+0360 ~ U+0367
0x02bc, 0x02bd, 0x02be, 0x02bf, 0x02c0, 0x02c1, 0x02c2, 0x02c3,   // U+0368 ~ U+036f
0x02c4, 0x02c5, 0x02c6, 0x02c7, 0x02c8, 0x02c9, 0x02ca, 0x02cb,   // U+0370 ~ U+0377
0x02cc, 0x02cd, 0x02ce, 0x02cf, 0x02d0, 0x02d1, 0x02d2, 0x02d3,   // U+0378 ~ U+037f
0x02d4, 0x02d5, 0x02d6, 0x02d7, 0x02d8, 0x02d9, 0x02da, 0x02db,   // U+0380 ~ U+0387
0x02dc, 0x02dd, 0x02de, 0x02df, 0x02e0, 0x02e1, 0x02e2, 0x02e3,   // U+0388 ~ U+038f
0x02e4, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+0390 ~ U+0397
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+0398 ~ U+039f
0xffff, 0xffff, 0x02e5, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+03a0 ~ U+03a7
0xffff, 0xffff, 0x02e6, 0x02e7, 0x02e8, 0x02e9, 0x02ea, 0x02eb,   // U+03a8 ~ U+03af
0x02ec, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+03b0 ~ U+03b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+03b8 ~ U+03bf
0xffff, 0xffff, 0x02ed, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+03c0 ~ U+03c7
0xffff, 0xffff, 0x02ee, 0x02ef, 0x02f0, 0x02f1, 0x02f2, 0x02f3,   // U+03c8 ~ U+03cf
0x02f4, 0x02f5, 0x02f6, 0x02f7, 0x02f8, 0x02f9, 0x02fa, 0x02fb,   // U+03d0 ~ U+03d7
0x02fc, 0x02fd, 0x02fe, 0x02ff, 0x0300, 0x0301, 0x0302, 0x0303,   // U+03d8 ~ U+03df
0x0304, 0x0305, 0x0306, 0x0307, 0x0308, 0x0309, 0x030a, 0x030b,   // U+03e0 ~ U+03e7
0x030c, 0x030d, 0x030e, 0x030f, 0x0310, 0x0311, 0x0312, 0x0313,   // U+03e8 ~ U+03ef
0x0314, 0x0315, 0x0316, 0x0317, 0x0318, 0x0319, 0x031a, 0x031b,   // U+03f0 ~ U+03f7
0x031c, 0x031d, 0x031e, 0x031f, 0x0320, 0x0321, 0x0322, 0x0323,   // U+03f8 ~ U+03ff
0x0324, 0xffff, 0x0325, 0x0326, 0x0327, 0x0328, 0x0329, 0x032a,   // U+0400 ~ U+0407
0x032b, 0x032c, 0x032d, 0x032e, 0x032f, 0x0330, 0x0331, 0x0332,   // U+0408 ~ U+040f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+0410 ~ U+0417
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+0418 ~ U+041f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+0420 ~ U+0427
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+0428 ~ U+042f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+0430 ~ U+0437
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+0438 ~ U+043f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+0440 ~ U+0447
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+0448 ~ U+044f
0x0333, 0xffff, 0x0334, 0x0335, 0x0336, 0x0337, 0x0338, 0x0339,   // U+0450 ~ U+0457
0x033a, 0x033b, 0x033c, 0x033d, 0x033e, 0x033f, 0x0340, 0x0341,   // U+0458 ~ U+045f
0x0342, 0x0343, 0x0344, 0x0345, 0x0346, 0x0347, 0x0348, 0x0349,   // U+0460 ~ U+0467
0x034a, 0x034b, 0x034c, 0x034d, 0x034e, 0x034f, 0x0350, 0x0351,   // U+0468 ~ U+046f
0x0352, 0x0353, 0x0354, 0x0355, 0x0356, 0x0357, 0x0358, 0x0359,   // U+0470 ~ U+0477
0x035a, 0x035b, 0x035c, 0x035d, 0x035e, 0x035f, 0x0360, 0x0361,   // U+0478 ~ U+047f
0x0362, 0x0363, 0x0364, 0x0365, 0x0366, 0x0367, 0x0368, 0x0369,   // U+0480 ~ U+0487
0x036a, 0x036b, 0x036c, 0x036d, 0x036e, 0x036f, 0x0370, 0x0371,   // U+0488 ~ U+048f
0x0372, 0x0373, 0x0374, 0x0375, 0x0376, 0x0377, 0x0378, 0x0379,   // U+0490 ~ U+0497
0x037a, 0x037b, 0x037c, 0x037d, 0x037e, 0x037f, 0x0380, 0x0381,   // U+0498 ~ U+049f
0x0382, 0x0383, 0x0384, 0x0385, 0x0386, 0x0387, 0x0388, 0x0389,   // U+04a0 ~ U+04a7
0x038a, 0x038b, 0x038c, 0x038d, 0x038e, 0x038f, 0x0390, 0x0391,   // U+04a8 ~ U+04af
0x0392, 0x0393, 0x0394, 0x0395, 0x0396, 0x0397, 0x0398, 0x0399,   // U+04b0 ~ U+04b7
0x039a, 0x039b, 0x039c, 0x039d, 0x039e, 0x039f, 0x03a0, 0x03a1,   // U+04b8 ~ U+04bf
0x03a2, 0x03a3, 0x03a4, 0x03a5, 0x03a6, 0x03a7, 0x03a8, 0x03a9,   // U+04c0 ~ U+04c7
0x03aa, 0x03ab, 0x03ac, 0x03ad, 0x03ae, 0x03af, 0x03b0, 0x03b1,   // U+04c8 ~ U+04cf
0x03b2, 0x03b3, 0x03b4, 0x03b5, 0x03b6, 0x03b7, 0x03b8, 0x03b9,   // U+04d0 ~ U+04d7
0x03ba, 0x03bb, 0x03bc, 0x03bd, 0x03be, 0x03bf, 0x03c0, 0x03c1,   // U+04d8 ~ U+04df
0x03c2, 0x03c3, 0x03c4, 0x03c5, 0x03c6, 0x03c7, 0x03c8, 0x03c9,   // U+04e0 ~ U+04e7
0x03ca, 0x03cb, 0x03cc, 0x03cd, 0x03ce, 0x03cf, 0x03d0, 0x03d1,   // U+04e8 ~ U+04ef
0x03d2, 0x03d3, 0x03d4, 0x03d5, 0x03d6, 0x03d7, 0x03d8, 0x03d9,   // U+04f0 ~ U+04f7
0x03da, 0x03db, 0x03dc, 0x03dd, 0x03de, 0x03df, 0x03e0, 0x03e1,   // U+04f8 ~ U+04ff
0x03e2, 0x03e3, 0x03e4, 0x03e5, 0x03e6, 0x03e7, 0x03e8, 0x03e9,   // U+0500 ~ U+0507
0x03ea, 0x03eb, 0x03ec, 0x03ed, 0x03ee, 0x03ef, 0x03f0, 0x03f1,   // U+0508 ~ U+050f
0x03f2, 0x03f3, 0x03f4, 0x03f5, 0x03f6, 0x03f7, 0x03f8, 0x03f9,   // U+0510 ~ U+0517
0x03fa, 0x03fb, 0x03fc, 0x03fd, 0x03fe, 0x03ff, 0x0400, 0x0401,   // U+0518 ~ U+051f
0x0402, 0x0403, 0x0404, 0x0405, 0x0406, 0x0407, 0x0408, 0x0409,   // U+0520 ~ U+0527
0x040a, 0x040b, 0x040c, 0x040d, 0x040e, 0x040f, 0x0410, 0x0411,   // U+0528 ~ U+052f
0x0412, 0x0413, 0x0414, 0x0415, 0x0416, 0x0417, 0x0418, 0x0419,   // U+0530 ~ U+0537
0x041a, 0x041b, 0x041c, 0x041d, 0x041e, 0x041f, 0x0420, 0x0421,   // U+0538 ~ U+053f
0x0422, 0x0423, 0x0424, 0x0425, 0x0426, 0x0427, 0x0428, 0x0429,   // U+0540 ~ U+0547
0x042a, 0x042b, 0x042c, 0x042d, 0x042e, 0x042f, 0x0430, 0x0431,   // U+0548 ~ U+054f
0x0432, 0x0433, 0x0434, 0x0435, 0x0436, 0x0437, 0x0438, 0x0439,   // U+0550 ~ U+0557
0x043a, 0x043b, 0x043c, 0x043d, 0x043e, 0x043f, 0x0440, 0x0441,   // U+0558 ~ U+055f
0x0442, 0x0443, 0x0444, 0x0445, 0x0446, 0x0447, 0x0448, 0x0449,   // U+0560 ~ U+0567
0x044a, 0x044b, 0x044c, 0x044d, 0x044e, 0x044f, 0x0450, 0x0451,   // U+0568 ~ U+056f
0x0452, 0x0453, 0x0454, 0x0455, 0x0456, 0x0457, 0x0458, 0x0459,   // U+0570 ~ U+0577
0x045a, 0x045b, 0x045c, 0x045d, 0x045e, 0x045f, 0x0460, 0x0461,   // U+0578 ~ U+057f
0x0462, 0x0463, 0x0464, 0x0465, 0x0466, 0x0467, 0x0468, 0x0469,   // U+0580 ~ U+0587
0x046a, 0x046b, 0x046c, 0x046d, 0x046e, 0x046f, 0x0470, 0x0471,   // U+0588 ~ U+058f
0x0472, 0x0473, 0x0474, 0x0475, 0x0476, 0x0477, 0x0478, 0x0479,   // U+0590 ~ U+0597
0x047a, 0x047b, 0x047c, 0x047d, 0x047e, 0x047f, 0x0480, 0x0481,   // U+0598 ~ U+059f
0x0482, 0x0483, 0x0484, 0x0485, 0x0486, 0x0487, 0x0488, 0x0489,   // U+05a0 ~ U+05a7
0x048a, 0x048b, 0x048c, 0x048d, 0x048e, 0x048f, 0x0490, 0x0491,   // U+05a8 ~ U+05af
0x0492, 0x0493, 0x0494, 0x0495, 0x0496, 0x0497, 0x0498, 0x0499,   // U+05b0 ~ U+05b7
0x049a, 0x049b, 0x049c, 0x049d, 0x049e, 0x049f, 0x04a0, 0x04a1,   // U+05b8 ~ U+05bf
0x04a2, 0x04a3, 0x04a4, 0x04a5, 0x04a6, 0x04a7, 0x04a8, 0x04a9,   // U+05c0 ~ U+05c7
0x04aa, 0x04ab, 0x04ac, 0x04ad, 0x04ae, 0x04af, 0x04b0, 0x04b1,   // U+05c8 ~ U+05cf
0x04b2, 0x04b3, 0x04b4, 0x04b5, 0x04b6, 0x04b7, 0x04b8, 0x04b9,   // U+05d0 ~ U+05d7
0x04ba, 0x04bb, 0x04bc, 0x04bd, 0x04be, 0x04bf, 0x04c0, 0x04c1,   // U+05d8 ~ U+05df
0x04c2, 0x04c3, 0x04c4, 0x04c5, 0x04c6, 0x04c7, 0x04c8, 0x04c9,   // U+05e0 ~ U+05e7
0x04ca, 0x04cb, 0x04cc, 0x04cd, 0x04ce, 0x04cf, 0x04d0, 0x04d1,   // U+05e8 ~ U+05ef
0x04d2, 0x04d3, 0x04d4, 0x04d5, 0x04d6, 0x04d7, 0x04d8, 0x04d9,   // U+05f0 ~ U+05f7
0x04da, 0x04db, 0x04dc, 0x04dd, 0x04de, 0x04df, 0x04e0, 0x04e1,   // U+05f8 ~ U+05ff
0x04e2, 0x04e3, 0x04e4, 0x04e5, 0x04e6, 0x04e7, 0x04e8, 0x04e9,   // U+0600 ~ U+0607
0x04ea, 0x04eb, 0x04ec, 0x04ed, 0x04ee, 0x04ef, 0x04f0, 0x04f1,   // U+0608 ~ U+060f
0x04f2, 0x04f3, 0x04f4, 0x04f5, 0x04f6, 0x04f7, 0x04f8, 0x04f9,   // U+0610 ~ U+0617
0x04fa, 0x04fb, 0x04fc, 0x04fd, 0x04fe, 0x04ff, 0x0500, 0x0501,   // U+0618 ~ U+061f
0x0502, 0x0503, 0x0504, 0x0505, 0x0506, 0x0507, 0x0508, 0x0509,   // U+0620 ~ U+0627
0x050a, 0x050b, 0x050c, 0x050d, 0x050e, 0x050f, 0x0510, 0x0511,   // U+0628 ~ U+062f
0x0512, 0x0513, 0x0514, 0x0515, 0x0516, 0x0517, 0x0518, 0x0519,   // U+0630 ~ U+0637
0x051a, 0x051b, 0x051c, 0x051d, 0x051e, 0x051f, 0x0520, 0x0521,   // U+0638 ~ U+063f
0x0522, 0x0523, 0x0524, 0x0525, 0x0526, 0x0527, 0x0528, 0x0529,   // U+0640 ~ U+0647
0x052a, 0x052b, 0x052c, 0x052d, 0x052e, 0x052f, 0x0530, 0x0531,   // U+0648 ~ U+064f
0x0532, 0x0533, 0x0534, 0x0535, 0x0536, 0x0537, 0x0538, 0x0539,   // U+0650 ~ U+0657
0x053a, 0x053b, 0x053c, 0x053d, 0x053e, 0x053f, 0x0540, 0x0541,   // U+0658 ~ U+065f
0x0542, 0x0543, 0x0544, 0x0545, 0x0546, 0x0547, 0x0548, 0x0549,   // U+0660 ~ U+0667
0x054a, 0x054b, 0x054c, 0x054d, 0x054e, 0x054f, 0x0550, 0x0551,   // U+0668 ~ U+066f
0x0552, 0x0553, 0x0554, 0x0555, 0x0556, 0x0557, 0x0558, 0x0559,   // U+0670 ~ U+0677
0x055a, 0x055b, 0x055c, 0x055d, 0x055e, 0x055f, 0x0560, 0x0561,   // U+0678 ~ U+067f
0x0562, 0x0563, 0x0564, 0x0565, 0x0566, 0x0567, 0x0568, 0x0569,   // U+0680 ~ U+0687
0x056a, 0x056b, 0x056c, 0x056d, 0x056e, 0x056f, 0x0570, 0x0571,   // U+0688 ~ U+068f
0x0572, 0x0573, 0x0574, 0x0575, 0x0576, 0x0577, 0x0578, 0x0579,   // U+0690 ~ U+0697
0x057a, 0x057b, 0x057c, 0x057d, 0x057e, 0x057f, 0x0580, 0x0581,   // U+0698 ~ U+069f
0x0582, 0x0583, 0x0584, 0x0585, 0x0586, 0x0587, 0x0588, 0x0589,   // U+06a0 ~ U+06a7
0x058a, 0x058b, 0x058c, 0x058d, 0x058e, 0x058f, 0x0590, 0x0591,   // U+06a8 ~ U+06af
0x0592, 0x0593, 0x0594, 0x0595, 0x0596, 0x0597, 0x0598, 0x0599,   // U+06b0 ~ U+06b7
0x059a, 0x059b, 0x059c, 0x059d, 0x059e, 0x059f, 0x05a0, 0x05a1,   // U+06b8 ~ U+06bf
0x05a2, 0x05a3, 0x05a4, 0x05a5, 0x05a6, 0x05a7, 0x05a8, 0x05a9,   // U+06c0 ~ U+06c7
0x05aa, 0x05ab, 0x05ac, 0x05ad, 0x05ae, 0x05af, 0x05b0, 0x05b1,   // U+06c8 ~ U+06cf
0x05b2, 0x05b3, 0x05b4, 0x05b5, 0x05b6, 0x05b7, 0x05b8, 0x05b9,   // U+06d0 ~ U+06d7
0x05ba, 0x05bb, 0x05bc, 0x05bd, 0x05be, 0x05bf, 0x05c0, 0x05c1,   // U+06d8 ~ U+06df
0x05c2, 0x05c3, 0x05c4, 0x05c5, 0x05c6, 0x05c7, 0x05c8, 0x05c9,   // U+06e0 ~ U+06e7
0x05ca, 0x05cb, 0x05cc, 0x05cd, 0x05ce, 0x05cf, 0x05d0, 0x05d1,   // U+06e8 ~ U+06ef
0x05d2, 0x05d3, 0x05d4, 0x05d5, 0x05d6, 0x05d7, 0x05d8, 0x05d9,   // U+06f0 ~ U+06f7
0x05da, 0x05db, 0x05dc, 0x05dd, 0x05de, 0x05df, 0x05e0, 0x05e1,   // U+06f8 ~ U+06ff
0x05e2, 0x05e3, 0x05e4, 0x05e5, 0x05e6, 0x05e7, 0x05e8, 0x05e9,   // U+0700 ~ U+0707
0x05ea, 0x05eb, 0x05ec, 0x05ed, 0x05ee, 0x05ef, 0x05f0, 0x05f1,   // U+0708 ~ U+070f
0x05f2, 0x05f3, 0x05f4, 0x05f5, 0x05f6, 0x05f7, 0x05f8, 0x05f9,   // U+0710 ~ U+0717
0x05fa, 0x05fb, 0x05fc, 0x05fd, 0x05fe, 0x05ff, 0x0600, 0x0601,   // U+0718 ~ U+071f
0x0602, 0x0603, 0x0604, 0x0605, 0x0606, 0x0607, 0x0608, 0x0609,   // U+0720 ~ U+0727
0x060a, 0x060b, 0x060c, 0x060d, 0x060e, 0x060f, 0x0610, 0x0611,   // U+0728 ~ U+072f
0x0612, 0x0613, 0x0614, 0x0615, 0x0616, 0x0617, 0x0618, 0x0619,   // U+0730 ~ U+0737
0x061a, 0x061b, 0x061c, 0x061d, 0x061e, 0x061f, 0x0620, 0x0621,   // U+0738 ~ U+073f
0x0622, 0x0623, 0x0624, 0x0625, 0x0626, 0x0627, 0x0628, 0x0629,   // U+0740 ~ U+0747
0x062a, 0x062b, 0x062c, 0x062d, 0x062e, 0x062f, 0x0630, 0x0631,   // U+0748 ~ U+074f
0x0632, 0x0633, 0x0634, 0x0635, 0x0636, 0x0637, 0x0638, 0x0639,   // U+0750 ~ U+0757
0x063a, 0x063b, 0x063c, 0x063d, 0x063e, 0x063f, 0x0640, 0x0641,   // U+0758 ~ U+075f
0x0642, 0x0643, 0x0644, 0x0645, 0x0646, 0x0647, 0x0648, 0x0649,   // U+0760 ~ U+0767
0x064a, 0x064b, 0x064c, 0x064d, 0x064e, 0x064f, 0x0650, 0x0651,   // U+0768 ~ U+076f
0x0652, 0x0653, 0x0654, 0x0655, 0x0656, 0x0657, 0x0658, 0x0659,   // U+0770 ~ U+0777
0x065a, 0x065b, 0x065c, 0x065d, 0x065e, 0x065f, 0x0660, 0x0661,   // U+0778 ~ U+077f
0x0662, 0x0663, 0x0664, 0x0665, 0x0666, 0x0667, 0x0668, 0x0669,   // U+0780 ~ U+0787
0x066a, 0x066b, 0x066c, 0x066d, 0x066e, 0x066f, 0x0670, 0x0671,   // U+0788 ~ U+078f
0x0672, 0x0673, 0x0674, 0x0675, 0x0676, 0x0677, 0x0678, 0x0679,   // U+0790 ~ U+0797
0x067a, 0x067b, 0x067c, 0x067d, 0x067e, 0x067f, 0x0680, 0x0681,   // U+0798 ~ U+079f
0x0682, 0x0683, 0x0684, 0x0685, 0x0686, 0x0687, 0x0688, 0x0689,   // U+07a0 ~ U+07a7
0x068a, 0x068b, 0x068c, 0x068d, 0x068e, 0x068f, 0x0690, 0x0691,   // U+07a8 ~ U+07af
0x0692, 0x0693, 0x0694, 0x0695, 0x0696, 0x0697, 0x0698, 0x0699,   // U+07b0 ~ U+07b7
0x069a, 0x069b, 0x069c, 0x069d, 0x069e, 0x069f, 0x06a0, 0x06a1,   // U+07b8 ~ U+07bf
0x06a2, 0x06a3, 0x06a4, 0x06a5, 0x06a6, 0x06a7, 0x06a8, 0x06a9,   // U+07c0 ~ U+07c7
0x06aa, 0x06ab, 0x06ac, 0x06ad, 0x06ae, 0x06af, 0x06b0, 0x06b1,   // U+07c8 ~ U+07cf
0x06b2, 0x06b3, 0x06b4, 0x06b5, 0x06b6, 0x06b7, 0x06b8, 0x06b9,   // U+07d0 ~ U+07d7
0x06ba, 0x06bb, 0x06bc, 0x06bd, 0x06be, 0x06bf, 0x06c0, 0x06c1,   // U+07d8 ~ U+07df
0x06c2, 0x06c3, 0x06c4, 0x06c5, 0x06c6, 0x06c7, 0x06c8, 0x06c9,   // U+07e0 ~ U+07e7
0x06ca, 0x06cb, 0x06cc, 0x06cd, 0x06ce, 0x06cf, 0x06d0, 0x06d1,   // U+07e8 ~ U+07ef
0x06d2, 0x06d3, 0x06d4, 0x06d5, 0x06d6, 0x06d7, 0x06d8, 0x06d9,   // U+07f0 ~ U+07f7
0x06da, 0x06db, 0x06dc, 0x06dd, 0x06de, 0x06df, 0x06e0, 0x06e1,   // U+07f8 ~ U+07ff
0x06e2, 0x06e3, 0x06e4, 0x06e5, 0x06e6, 0x06e7, 0x06e8, 0x06e9,   // U+0800 ~ U+0807
0x06ea, 0x06eb, 0x06ec, 0x06ed, 0x06ee, 0x06ef, 0x06f0, 0x06f1,   // U+0808 ~ U+080f
0x06f2, 0x06f3, 0x06f4, 0x06f5, 0x06f6, 0x06f7, 0x06f8, 0x06f9,   // U+0810 ~ U+0817
0x06fa, 0x06fb, 0x06fc, 0x06fd, 0x06fe, 0x06ff, 0x0700, 0x0701,   // U+0818 ~ U+081f
0x0702, 0x0703, 0x0704, 0x0705, 0x0706, 0x0707, 0x0708, 0x0709,   // U+0820 ~ U+0827
0x070a, 0x070b, 0x070c, 0x070d, 0x070e, 0x070f, 0x0710, 0x0711,   // U+0828 ~ U+082f
0x0712, 0x0713, 0x0714, 0x0715, 0x0716, 0x0717, 0x0718, 0x0719,   // U+0830 ~ U+0837
0x071a, 0x071b, 0x071c, 0x071d, 0x071e, 0x071f, 0x0720, 0x0721,   // U+0838 ~ U+083f
0x0722, 0x0723, 0x0724, 0x0725, 0x0726, 0x0727, 0x0728, 0x0729,   // U+0840 ~ U+0847
0x072a, 0x072b, 0x072c, 0x072d, 0x072e, 0x072f, 0x0730, 0x0731,   // U+0848 ~ U+084f
0x0732, 0x0733, 0x0734, 0x0735, 0x0736, 0x0737, 0x0738, 0x0739,   // U+0850 ~ U+0857
0x073a, 0x073b, 0x073c, 0x073d, 0x073e, 0x073f, 0x0740, 0x0741,   // U+0858 ~ U+085f
0x0742, 0x0743, 0x0744, 0x0745, 0x0746, 0x0747, 0x0748, 0x0749,   // U+0860 ~ U+0867
0x074a, 0x074b, 0x074c, 0x074d, 0x074e, 0x074f, 0x0750, 0x0751,   // U+0868 ~ U+086f
0x0752, 0x0753, 0x0754, 0x0755, 0x0756, 0x0757, 0x0758, 0x0759,   // U+0870 ~ U+0877
0x075a, 0x075b, 0x075c, 0x075d, 0x075e, 0x075f, 0x0760, 0x0761,   // U+0878 ~ U+087f
0x0762, 0x0763, 0x0764, 0x0765, 0x0766, 0x0767, 0x0768, 0x0769,   // U+0880 ~ U+0887
0x076a, 0x076b, 0x076c, 0x076d, 0x076e, 0x076f, 0x0770, 0x0771,   // U+0888 ~ U+088f
0x0772, 0x0773, 0x0774, 0x0775, 0x0776, 0x0777, 0x0778, 0x0779,   // U+0890 ~ U+0897
0x077a, 0x077b, 0x077c, 0x077d, 0x077e, 0x077f, 0x0780, 0x0781,   // U+0898 ~ U+089f
0x0782, 0x0783, 0x0784, 0x0785, 0x0786, 0x0787, 0x0788, 0x0789,   // U+08a0 ~ U+08a7
0x078a, 0x078b, 0x078c, 0x078d, 0x078e, 0x078f, 0x0790, 0x0791,   // U+08a8 ~ U+08af
0x0792, 0x0793, 0x0794, 0x0795, 0x0796, 0x0797, 0x0798, 0x0799,   // U+08b0 ~ U+08b7
0x079a, 0x079b, 0x079c, 0x079d, 0x079e, 0x079f, 0x07a0, 0x07a1,   // U+08b8 ~ U+08bf
0x07a2, 0x07a3, 0x07a4, 0x07a5, 0x07a6, 0x07a7, 0x07a8, 0x07a9,   // U+08c0 ~ U+08c7
0x07aa, 0x07ab, 0x07ac, 0x07ad, 0x07ae, 0x07af, 0x07b0, 0x07b1,   // U+08c8 ~ U+08cf
0x07b2, 0x07b3, 0x07b4, 0x07b5, 0x07b6, 0x07b7, 0x07b8, 0x07b9,   // U+08d0 ~ U+08d7
0x07ba, 0x07bb, 0x07bc, 0x07bd, 0x07be, 0x07bf, 0x07c0, 0x07c1,   // U+08d8 ~ U+08df
0x07c2, 0x07c3, 0x07c4, 0x07c5, 0x07c6, 0x07c7, 0x07c8, 0x07c9,   // U+08e0 ~ U+08e7
0x07ca, 0x07cb, 0x07cc, 0x07cd, 0x07ce, 0x07cf, 0x07d0, 0x07d1,   // U+08e8 ~ U+08ef
0x07d2, 0x07d3, 0x07d4, 0x07d5, 0x07d6, 0x07d7, 0x07d8, 0x07d9,   // U+08f0 ~ U+08f7
0x07da, 0x07db, 0x07dc, 0x07dd, 0x07de, 0x07df, 0x07e0, 0x07e1,   // U+08f8 ~ U+08ff
0x07e2, 0x07e3, 0x07e4, 0x07e5, 0x07e6, 0x07e7, 0x07e8, 0x07e9,   // U+0900 ~ U+0907
0x07ea, 0x07eb, 0x07ec, 0x07ed, 0x07ee, 0x07ef, 0x07f0, 0x07f1,   // U+0908 ~ U+090f
0x07f2, 0x07f3, 0x07f4, 0x07f5, 0x07f6, 0x07f7, 0x07f8, 0x07f9,   // U+0910 ~ U+0917
0x07fa, 0x07fb, 0x07fc, 0x07fd, 0x07fe, 0x07ff, 0x0800, 0x0801,   // U+0918 ~ U+091f
0x0802, 0x0803, 0x0804, 0x0805, 0x0806, 0x0807, 0x0808, 0x0809,   // U+0920 ~ U+0927
0x080a, 0x080b, 0x080c, 0x080d, 0x080e, 0x080f, 0x0810, 0x0811,   // U+0928 ~ U+092f
0x0812, 0x0813, 0x0814, 0x0815, 0x0816, 0x0817, 0x0818, 0x0819,   // U+0930 ~ U+0937
0x081a, 0x081b, 0x081c, 0x081d, 0x081e, 0x081f, 0x0820, 0x0821,   // U+0938 ~ U+093f
0x0822, 0x0823, 0x0824, 0x0825, 0x0826, 0x0827, 0x0828, 0x0829,   // U+0940 ~ U+0947
0x082a, 0x082b, 0x082c, 0x082d, 0x082e, 0x082f, 0x0830, 0x0831,   // U+0948 ~ U+094f
0x0832, 0x0833, 0x0834, 0x0835, 0x0836, 0x0837, 0x0838, 0x0839,   // U+0950 ~ U+0957
0x083a, 0x083b, 0x083c, 0x083d, 0x083e, 0x083f, 0x0840, 0x0841,   // U+0958 ~ U+095f
0x0842, 0x0843, 0x0844, 0x0845, 0x0846, 0x0847, 0x0848, 0x0849,   // U+0960 ~ U+0967
0x084a, 0x084b, 0x084c, 0x084d, 0x084e, 0x084f, 0x0850, 0x0851,   // U+0968 ~ U+096f
0x0852, 0x0853, 0x0854, 0x0855, 0x0856, 0x0857, 0x0858, 0x0859,   // U+0970 ~ U+0977
0x085a, 0x085b, 0x085c, 0x085d, 0x085e, 0x085f, 0x0860, 0x0861,   // U+0978 ~ U+097f
0x0862, 0x0863, 0x0864, 0x0865, 0x0866, 0x0867, 0x0868, 0x0869,   // U+0980 ~ U+0987
0x086a, 0x086b, 0x086c, 0x086d, 0x086e, 0x086f, 0x0870, 0x0871,   // U+0988 ~ U+098f
0x0872, 0x0873, 0x0874, 0x0875, 0x0876, 0x0877, 0x0878, 0x0879,   // U+0990 ~ U+0997
0x087a, 0x087b, 0x087c, 0x087d, 0x087e, 0x087f, 0x0880, 0x0881,   // U+0998 ~ U+099f
0x0882, 0x0883, 0x0884, 0x0885, 0x0886, 0x0887, 0x0888, 0x0889,   // U+09a0 ~ U+09a7
0x088a, 0x088b, 0x088c, 0x088d, 0x088e, 0x088f, 0x0890, 0x0891,   // U+09a8 ~ U+09af
0x0892, 0x0893, 0x0894, 0x0895, 0x0896, 0x0897, 0x0898, 0x0899,   // U+09b0 ~ U+09b7
0x089a, 0x089b, 0x089c, 0x089d, 0x089e, 0x089f, 0x08a0, 0x08a1,   // U+09b8 ~ U+09bf
0x08a2, 0x08a3, 0x08a4, 0x08a5, 0x08a6, 0x08a7, 0x08a8, 0x08a9,   // U+09c0 ~ U+09c7
0x08aa, 0x08ab, 0x08ac, 0x08ad, 0x08ae, 0x08af, 0x08b0, 0x08b1,   // U+09c8 ~ U+09cf
0x08b2, 0x08b3, 0x08b4, 0x08b5, 0x08b6, 0x08b7, 0x08b8, 0x08b9,   // U+09d0 ~ U+09d7
0x08ba, 0x08bb, 0x08bc, 0x08bd, 0x08be, 0x08bf, 0x08c0, 0x08c1,   // U+09d8 ~ U+09df
0x08c2, 0x08c3, 0x08c4, 0x08c5, 0x08c6, 0x08c7, 0x08c8, 0x08c9,   // U+09e0 ~ U+09e7
0x08ca, 0x08cb, 0x08cc, 0x08cd, 0x08ce, 0x08cf, 0x08d0, 0x08d1,   // U+09e8 ~ U+09ef
0x08d2, 0x08d3, 0x08d4, 0x08d5, 0x08d6, 0x08d7, 0x08d8, 0x08d9,   // U+09f0 ~ U+09f7
0x08da, 0x08db, 0x08dc, 0x08dd, 0x08de, 0x08df, 0x08e0, 0x08e1,   // U+09f8 ~ U+09ff
0x08e2, 0x08e3, 0x08e4, 0x08e5, 0x08e6, 0x08e7, 0x08e8, 0x08e9,   // U+0a00 ~ U+0a07
0x08ea, 0x08eb, 0x08ec, 0x08ed, 0x08ee, 0x08ef, 0x08f0, 0x08f1,   // U+0a08 ~ U+0a0f
0x08f2, 0x08f3, 0x08f4, 0x08f5, 0x08f6, 0x08f7, 0x08f8, 0x08f9,   // U+0a10 ~ U+0a17
0x08fa, 0x08fb, 0x08fc, 0x08fd, 0x08fe, 0x08ff, 0x0900, 0x0901,   // U+0a18 ~ U+0a1f
0x0902, 0x0903, 0x0904, 0x0905, 0x0906, 0x0907, 0x0908, 0x0909,   // U+0a20 ~ U+0a27
0x090a, 0x090b, 0x090c, 0x090d, 0x090e, 0x090f, 0x0910, 0x0911,   // U+0a28 ~ U+0a2f
0x0912, 0x0913, 0x0914, 0x0915, 0x0916, 0x0917, 0x0918, 0x0919,   // U+0a30 ~ U+0a37
0x091a, 0x091b, 0x091c, 0x091d, 0x091e, 0x091f, 0x0920, 0x0921,   // U+0a38 ~ U+0a3f
0x0922, 0x0923, 0x0924, 0x0925, 0x0926, 0x0927, 0x0928, 0x0929,   // U+0a40 ~ U+0a47
0x092a, 0x092b, 0x092c, 0x092d, 0x092e, 0x092f, 0x0930, 0x0931,   // U+0a48 ~ U+0a4f
0x0932, 0x0933, 0x0934, 0x0935, 0x0936, 0x0937, 0x0938, 0x0939,   // U+0a50 ~ U+0a57
0x093a, 0x093b, 0x093c, 0x093d, 0x093e, 0x093f, 0x0940, 0x0941,   // U+0a58 ~ U+0a5f
0x0942, 0x0943, 0x0944, 0x0945, 0x0946, 0x0947, 0x0948, 0x0949,   // U+0a60 ~ U+0a67
0x094a, 0x094b, 0x094c, 0x094d, 0x094e, 0x094f, 0x0950, 0x0951,   // U+0a68 ~ U+0a6f
0x0952, 0x0953, 0x0954, 0x0955, 0x0956, 0x0957, 0x0958, 0x0959,   // U+0a70 ~ U+0a77
0x095a, 0x095b, 0x095c, 0x095d, 0x095e, 0x095f, 0x0960, 0x0961,   // U+0a78 ~ U+0a7f
0x0962, 0x0963, 0x0964, 0x0965, 0x0966, 0x0967, 0x0968, 0x0969,   // U+0a80 ~ U+0a87
0x096a, 0x096b, 0x096c, 0x096d, 0x096e, 0x096f, 0x0970, 0x0971,   // U+0a88 ~ U+0a8f
0x0972, 0x0973, 0x0974, 0x0975, 0x0976, 0x0977, 0x0978, 0x0979,   // U+0a90 ~ U+0a97
0x097a, 0x097b, 0x097c, 0x097d, 0x097e, 0x097f, 0x0980, 0x0981,   // U+0a98 ~ U+0a9f
0x0982, 0x0983, 0x0984, 0x0985, 0x0986, 0x0987, 0x0988, 0x0989,   // U+0aa0 ~ U+0aa7
0x098a, 0x098b, 0x098c, 0x098d, 0x098e, 0x098f, 0x0990, 0x0991,   // U+0aa8 ~ U+0aaf
0x0992, 0x0993, 0x0994, 0x0995, 0x0996, 0x0997, 0x0998, 0x0999,   // U+0ab0 ~ U+0ab7
0x099a, 0x099b, 0x099c, 0x099d, 0x099e, 0x099f, 0x09a0, 0x09a1,   // U+0ab8 ~ U+0abf
0x09a2, 0x09a3, 0x09a4, 0x09a5, 0x09a6, 0x09a7, 0x09a8, 0x09a9,   // U+0ac0 ~ U+0ac7
0x09aa, 0x09ab, 0x09ac, 0x09ad, 0x09ae, 0x09af, 0x09b0, 0x09b1,   // U+0ac8 ~ U+0acf
0x09b2, 0x09b3, 0x09b4, 0x09b5, 0x09b6, 0x09b7, 0x09b8, 0x09b9,   // U+0ad0 ~ U+0ad7
0x09ba, 0x09bb, 0x09bc, 0x09bd, 0x09be, 0x09bf, 0x09c0, 0x09c1,   // U+0ad8 ~ U+0adf
0x09c2, 0x09c3, 0x09c4, 0x09c5, 0x09c6, 0x09c7, 0x09c8, 0x09c9,   // U+0ae0 ~ U+0ae7
0x09ca, 0x09cb, 0x09cc, 0x09cd, 0x09ce, 0x09cf, 0x09d0, 0x09d1,   // U+0ae8 ~ U+0aef
0x09d2, 0x09d3, 0x09d4, 0x09d5, 0x09d6, 0x09d7, 0x09d8, 0x09d9,   // U+0af0 ~ U+0af7
0x09da, 0x09db, 0x09dc, 0x09dd, 0x09de, 0x09df, 0x09e0, 0x09e1,   // U+0af8 ~ U+0aff
0x09e2, 0x09e3, 0x09e4, 0x09e5, 0x09e6, 0x09e7, 0x09e8, 0x09e9,   // U+0b00 ~ U+0b07
0x09ea, 0x09eb, 0x09ec, 0x09ed, 0x09ee, 0x09ef, 0x09f0, 0x09f1,   // U+0b08 ~ U+0b0f
0x09f2, 0x09f3, 0x09f4, 0x09f5, 0x09f6, 0x09f7, 0x09f8, 0x09f9,   // U+0b10 ~ U+0b17
0x09fa, 0x09fb, 0x09fc, 0x09fd, 0x09fe, 0x09ff, 0x0a00, 0x0a01,   // U+0b18 ~ U+0b1f
0x0a02, 0x0a03, 0x0a04, 0x0a05, 0x0a06, 0x0a07, 0x0a08, 0x0a09,   // U+0b20 ~ U+0b27
0x0a0a, 0x0a0b, 0x0a0c, 0x0a0d, 0x0a0e, 0x0a0f, 0x0a10, 0x0a11,   // U+0b28 ~ U+0b2f
0x0a12, 0x0a13, 0x0a14, 0x0a15, 0x0a16, 0x0a17, 0x0a18, 0x0a19,   // U+0b30 ~ U+0b37
0x0a1a, 0x0a1b, 0x0a1c, 0x0a1d, 0x0a1e, 0x0a1f, 0x0a20, 0x0a21,   // U+0b38 ~ U+0b3f
0x0a22, 0x0a23, 0x0a24, 0x0a25, 0x0a26, 0x0a27, 0x0a28, 0x0a29,   // U+0b40 ~ U+0b47
0x0a2a, 0x0a2b, 0x0a2c, 0x0a2d, 0x0a2e, 0x0a2f, 0x0a30, 0x0a31,   // U+0b48 ~ U+0b4f
0x0a32, 0x0a33, 0x0a34, 0x0a35, 0x0a36, 0x0a37, 0x0a38, 0x0a39,   // U+0b50 ~ U+0b57
0x0a3a, 0x0a3b, 0x0a3c, 0x0a3d, 0x0a3e, 0x0a3f, 0x0a40, 0x0a41,   // U+0b58 ~ U+0b5f
0x0a42, 0x0a43, 0x0a44, 0x0a45, 0x0a46, 0x0a47, 0x0a48, 0x0a49,   // U+0b60 ~ U+0b67
0x0a4a, 0x0a4b, 0x0a4c, 0x0a4d, 0x0a4e, 0x0a4f, 0x0a50, 0x0a51,   // U+0b68 ~ U+0b6f
0x0a52, 0x0a53, 0x0a54, 0x0a55, 0x0a56, 0x0a57, 0x0a58, 0x0a59,   // U+0b70 ~ U+0b77
0x0a5a, 0x0a5b, 0x0a5c, 0x0a5d, 0x0a5e, 0x0a5f, 0x0a60, 0x0a61,   // U+0b78 ~ U+0b7f
0x0a62, 0x0a63, 0x0a64, 0x0a65, 0x0a66, 0x0a67, 0x0a68, 0x0a69,   // U+0b80 ~ U+0b87
0x0a6a, 0x0a6b, 0x0a6c, 0x0a6d, 0x0a6e, 0x0a6f, 0x0a70, 0x0a71,   // U+0b88 ~ U+0b8f
0x0a72, 0x0a73, 0x0a74, 0x0a75, 0x0a76, 0x0a77, 0x0a78, 0x0a79,   // U+0b90 ~ U+0b97
0x0a7a, 0x0a7b, 0x0a7c, 0x0a7d, 0x0a7e, 0x0a7f, 0x0a80, 0x0a81,   // U+0b98 ~ U+0b9f
0x0a82, 0x0a83, 0x0a84, 0x0a85, 0x0a86, 0x0a87, 0x0a88, 0x0a89,   // U+0ba0 ~ U+0ba7
0x0a8a, 0x0a8b, 0x0a8c, 0x0a8d, 0x0a8e, 0x0a8f, 0x0a90, 0x0a91,   // U+0ba8 ~ U+0baf
0x0a92, 0x0a93, 0x0a94, 0x0a95, 0x0a96, 0x0a97, 0x0a98, 0x0a99,   // U+0bb0 ~ U+0bb7
0x0a9a, 0x0a9b, 0x0a9c, 0x0a9d, 0x0a9e, 0x0a9f, 0x0aa0, 0x0aa1,   // U+0bb8 ~ U+0bbf
0x0aa2, 0x0aa3, 0x0aa4, 0x0aa5, 0x0aa6, 0x0aa7, 0x0aa8, 0x0aa9,   // U+0bc0 ~ U+0bc7
0x0aaa, 0x0aab, 0x0aac, 0x0aad, 0x0aae, 0x0aaf, 0x0ab0, 0x0ab1,   // U+0bc8 ~ U+0bcf
0x0ab2, 0x0ab3, 0x0ab4, 0x0ab5, 0x0ab6, 0x0ab7, 0x0ab8, 0x0ab9,   // U+0bd0 ~ U+0bd7
0x0aba, 0x0abb, 0x0abc, 0x0abd, 0x0abe, 0x0abf, 0x0ac0, 0x0ac1,   // U+0bd8 ~ U+0bdf
0x0ac2, 0x0ac3, 0x0ac4, 0x0ac5, 0x0ac6, 0x0ac7, 0x0ac8, 0x0ac9,   // U+0be0 ~ U+0be7
0x0aca, 0x0acb, 0x0acc, 0x0acd, 0x0ace, 0x0acf, 0x0ad0, 0x0ad1,   // U+0be8 ~ U+0bef
0x0ad2, 0x0ad3, 0x0ad4, 0x0ad5, 0x0ad6, 0x0ad7, 0x0ad8, 0x0ad9,   // U+0bf0 ~ U+0bf7
0x0ada, 0x0adb, 0x0adc, 0x0add, 0x0ade, 0x0adf, 0x0ae0, 0x0ae1,   // U+0bf8 ~ U+0bff
0x0ae2, 0x0ae3, 0x0ae4, 0x0ae5, 0x0ae6, 0x0ae7, 0x0ae8, 0x0ae9,   // U+0c00 ~ U+0c07
0x0aea, 0x0aeb, 0x0aec, 0x0aed, 0x0aee, 0x0aef, 0x0af0, 0x0af1,   // U+0c08 ~ U+0c0f
0x0af2, 0x0af3, 0x0af4, 0x0af5, 0x0af6, 0x0af7, 0x0af8, 0x0af9,   // U+0c10 ~ U+0c17
0x0afa, 0x0afb, 0x0afc, 0x0afd, 0x0afe, 0x0aff, 0x0b00, 0x0b01,   // U+0c18 ~ U+0c1f
0x0b02, 0x0b03, 0x0b04, 0x0b05, 0x0b06, 0x0b07, 0x0b08, 0x0b09,   // U+0c20 ~ U+0c27
0x0b0a, 0x0b0b, 0x0b0c, 0x0b0d, 0x0b0e, 0x0b0f, 0x0b10, 0x0b11,   // U+0c28 ~ U+0c2f
0x0b12, 0x0b13, 0x0b14, 0x0b15, 0x0b16, 0x0b17, 0x0b18, 0x0b19,   // U+0c30 ~ U+0c37
0x0b1a, 0x0b1b, 0x0b1c, 0x0b1d, 0x0b1e, 0x0b1f, 0x0b20, 0x0b21,   // U+0c38 ~ U+0c3f
0x0b22, 0x0b23, 0x0b24, 0x0b25, 0x0b26, 0x0b27, 0x0b28, 0x0b29,   // U+0c40 ~ U+0c47
0x0b2a, 0x0b2b, 0x0b2c, 0x0b2d, 0x0b2e, 0x0b2f, 0x0b30, 0x0b31,   // U+0c48 ~ U+0c4f
0x0b32, 0x0b33, 0x0b34, 0x0b35, 0x0b36, 0x0b37, 0x0b38, 0x0b39,   // U+0c50 ~ U+0c57
0x0b3a, 0x0b3b, 0x0b3c, 0x0b3d, 0x0b3e, 0x0b3f, 0x0b40, 0x0b41,   // U+0c58 ~ U+0c5f
0x0b42, 0x0b43, 0x0b44, 0x0b45, 0x0b46, 0x0b47, 0x0b48, 0x0b49,   // U+0c60 ~ U+0c67
0x0b4a, 0x0b4b, 0x0b4c, 0x0b4d, 0x0b4e, 0x0b4f, 0x0b50, 0x0b51,   // U+0c68 ~ U+0c6f
0x0b52, 0x0b53, 0x0b54, 0x0b55, 0x0b56, 0x0b57, 0x0b58, 0x0b59,   // U+0c70 ~ U+0c77
0x0b5a, 0x0b5b, 0x0b5c, 0x0b5d, 0x0b5e, 0x0b5f, 0x0b60, 0x0b61,   // U+0c78 ~ U+0c7f
0x0b62, 0x0b63, 0x0b64, 0x0b65, 0x0b66, 0x0b67, 0x0b68, 0x0b69,   // U+0c80 ~ U+0c87
0x0b6a, 0x0b6b, 0x0b6c, 0x0b6d, 0x0b6e, 0x0b6f, 0x0b70, 0x0b71,   // U+0c88 ~ U+0c8f
0x0b72, 0x0b73, 0x0b74, 0x0b75, 0x0b76, 0x0b77, 0x0b78, 0x0b79,   // U+0c90 ~ U+0c97
0x0b7a, 0x0b7b, 0x0b7c, 0x0b7d, 0x0b7e, 0x0b7f, 0x0b80, 0x0b81,   // U+0c98 ~ U+0c9f
0x0b82, 0x0b83, 0x0b84, 0x0b85, 0x0b86, 0x0b87, 0x0b88, 0x0b89,   // U+0ca0 ~ U+0ca7
0x0b8a, 0x0b8b, 0x0b8c, 0x0b8d, 0x0b8e, 0x0b8f, 0x0b90, 0x0b91,   // U+0ca8 ~ U+0caf
0x0b92, 0x0b93, 0x0b94, 0x0b95, 0x0b96, 0x0b97, 0x0b98, 0x0b99,   // U+0cb0 ~ U+0cb7
0x0b9a, 0x0b9b, 0x0b9c, 0x0b9d, 0x0b9e, 0x0b9f, 0x0ba0, 0x0ba1,   // U+0cb8 ~ U+0cbf
0x0ba2, 0x0ba3, 0x0ba4, 0x0ba5, 0x0ba6, 0x0ba7, 0x0ba8, 0x0ba9,   // U+0cc0 ~ U+0cc7
0x0baa, 0x0bab, 0x0bac, 0x0bad, 0x0bae, 0x0baf, 0x0bb0, 0x0bb1,   // U+0cc8 ~ U+0ccf
0x0bb2, 0x0bb3, 0x0bb4, 0x0bb5, 0x0bb6, 0x0bb7, 0x0bb8, 0x0bb9,   // U+0cd0 ~ U+0cd7
0x0bba, 0x0bbb, 0x0bbc, 0x0bbd, 0x0bbe, 0x0bbf, 0x0bc0, 0x0bc1,   // U+0cd8 ~ U+0cdf
0x0bc2, 0x0bc3, 0x0bc4, 0x0bc5, 0x0bc6, 0x0bc7, 0x0bc8, 0x0bc9,   // U+0ce0 ~ U+0ce7
0x0bca, 0x0bcb, 0x0bcc, 0x0bcd, 0x0bce, 0x0bcf, 0x0bd0, 0x0bd1,   // U+0ce8 ~ U+0cef
0x0bd2, 0x0bd3, 0x0bd4, 0x0bd5, 0x0bd6, 0x0bd7, 0x0bd8, 0x0bd9,   // U+0cf0 ~ U+0cf7
0x0bda, 0x0bdb, 0x0bdc, 0x0bdd, 0x0bde, 0x0bdf, 0x0be0, 0x0be1,   // U+0cf8 ~ U+0cff
0x0be2, 0x0be3, 0x0be4, 0x0be5, 0x0be6, 0x0be7, 0x0be8, 0x0be9,   // U+0d00 ~ U+0d07
0x0bea, 0x0beb, 0x0bec, 0x0bed, 0x0bee, 0x0bef, 0x0bf0, 0x0bf1,   // U+0d08 ~ U+0d0f
0x0bf2, 0x0bf3, 0x0bf4, 0x0bf5, 0x0bf6, 0x0bf7, 0x0bf8, 0x0bf9,   // U+0d10 ~ U+0d17
0x0bfa, 0x0bfb, 0x0bfc, 0x0bfd, 0x0bfe, 0x0bff, 0x0c00, 0x0c01,   // U+0d18 ~ U+0d1f
0x0c02, 0x0c03, 0x0c04, 0x0c05, 0x0c06, 0x0c07, 0x0c08, 0x0c09,   // U+0d20 ~ U+0d27
0x0c0a, 0x0c0b, 0x0c0c, 0x0c0d, 0x0c0e, 0x0c0f, 0x0c10, 0x0c11,   // U+0d28 ~ U+0d2f
0x0c12, 0x0c13, 0x0c14, 0x0c15, 0x0c16, 0x0c17, 0x0c18, 0x0c19,   // U+0d30 ~ U+0d37
0x0c1a, 0x0c1b, 0x0c1c, 0x0c1d, 0x0c1e, 0x0c1f, 0x0c20, 0x0c21,   // U+0d38 ~ U+0d3f
0x0c22, 0x0c23, 0x0c24, 0x0c25, 0x0c26, 0x0c27, 0x0c28, 0x0c29,   // U+0d40 ~ U+0d47
0x0c2a, 0x0c2b, 0x0c2c, 0x0c2d, 0x0c2e, 0x0c2f, 0x0c30, 0x0c31,   // U+0d48 ~ U+0d4f
0x0c32, 0x0c33, 0x0c34, 0x0c35, 0x0c36, 0x0c37, 0x0c38, 0x0c39,   // U+0d50 ~ U+0d57
0x0c3a, 0x0c3b, 0x0c3c, 0x0c3d, 0x0c3e, 0x0c3f, 0x0c40, 0x0c41,   // U+0d58 ~ U+0d5f
0x0c42, 0x0c43, 0x0c44, 0x0c45, 0x0c46, 0x0c47, 0x0c48, 0x0c49,   // U+0d60 ~ U+0d67
0x0c4a, 0x0c4b, 0x0c4c, 0x0c4d, 0x0c4e, 0x0c4f, 0x0c50, 0x0c51,   // U+0d68 ~ U+0d6f
0x0c52, 0x0c53, 0x0c54, 0x0c55, 0x0c56, 0x0c57, 0x0c58, 0x0c59,   // U+0d70 ~ U+0d77
0x0c5a, 0x0c5b, 0x0c5c, 0x0c5d, 0x0c5e, 0x0c5f, 0x0c60, 0x0c61,   // U+0d78 ~ U+0d7f
0x0c62, 0x0c63, 0x0c64, 0x0c65, 0x0c66, 0x0c67, 0x0c68, 0x0c69,   // U+0d80 ~ U+0d87
0x0c6a, 0x0c6b, 0x0c6c, 0x0c6d, 0x0c6e, 0x0c6f, 0x0c70, 0x0c71,   // U+0d88 ~ U+0d8f
0x0c72, 0x0c73, 0x0c74, 0x0c75, 0x0c76, 0x0c77, 0x0c78, 0x0c79,   // U+0d90 ~ U+0d97
0x0c7a, 0x0c7b, 0x0c7c, 0x0c7d, 0x0c7e, 0x0c7f, 0x0c80, 0x0c81,   // U+0d98 ~ U+0d9f
0x0c82, 0x0c83, 0x0c84, 0x0c85, 0x0c86, 0x0c87, 0x0c88, 0x0c89,   // U+0da0 ~ U+0da7
0x0c8a, 0x0c8b, 0x0c8c, 0x0c8d, 0x0c8e, 0x0c8f, 0x0c90, 0x0c91,   // U+0da8 ~ U+0daf
0x0c92, 0x0c93, 0x0c94, 0x0c95, 0x0c96, 0x0c97, 0x0c98, 0x0c99,   // U+0db0 ~ U+0db7
0x0c9a, 0x0c9b, 0x0c9c, 0x0c9d, 0x0c9e, 0x0c9f, 0x0ca0, 0x0ca1,   // U+0db8 ~ U+0dbf
0x0ca2, 0x0ca3, 0x0ca4, 0x0ca5, 0x0ca6, 0x0ca7, 0x0ca8, 0x0ca9,   // U+0dc0 ~ U+0dc7
0x0caa, 0x0cab, 0x0cac, 0x0cad, 0x0cae, 0x0caf, 0x0cb0, 0x0cb1,   // U+0dc8 ~ U+0dcf
0x0cb2, 0x0cb3, 0x0cb4, 0x0cb5, 0x0cb6, 0x0cb7, 0x0cb8, 0x0cb9,   // U+0dd0 ~ U+0dd7
0x0cba, 0x0cbb, 0x0cbc, 0x0cbd, 0x0cbe, 0x0cbf, 0x0cc0, 0x0cc1,   // U+0dd8 ~ U+0ddf
0x0cc2, 0x0cc3, 0x0cc4, 0x0cc5, 0x0cc6, 0x0cc7, 0x0cc8, 0x0cc9,   // U+0de0 ~ U+0de7
0x0cca, 0x0ccb, 0x0ccc, 0x0ccd, 0x0cce, 0x0ccf, 0x0cd0, 0x0cd1,   // U+0de8 ~ U+0def
0x0cd2, 0x0cd3, 0x0cd4, 0x0cd5, 0x0cd6, 0x0cd7, 0x0cd8, 0x0cd9,   // U+0df0 ~ U+0df7
0x0cda, 0x0cdb, 0x0cdc, 0x0cdd, 0x0cde, 0x0cdf, 0x0ce0, 0x0ce1,   // U+0df8 ~ U+0dff
0x0ce2, 0x0ce3, 0x0ce4, 0x0ce5, 0x0ce6, 0x0ce7, 0x0ce8, 0x0ce9,   // U+0e00 ~ U+0e07
0x0cea, 0x0ceb, 0x0cec, 0x0ced, 0x0cee, 0x0cef, 0x0cf0, 0x0cf1,   // U+0e08 ~ U+0e0f
0x0cf2, 0x0cf3, 0x0cf4, 0x0cf5, 0x0cf6, 0x0cf7, 0x0cf8, 0x0cf9,   // U+0e10 ~ U+0e17
0x0cfa, 0x0cfb, 0x0cfc, 0x0cfd, 0x0cfe, 0x0cff, 0x0d00, 0x0d01,   // U+0e18 ~ U+0e1f
0x0d02, 0x0d03, 0x0d04, 0x0d05, 0x0d06, 0x0d07, 0x0d08, 0x0d09,   // U+0e20 ~ U+0e27
0x0d0a, 0x0d0b, 0x0d0c, 0x0d0d, 0x0d0e, 0x0d0f, 0x0d10, 0x0d11,   // U+0e28 ~ U+0e2f
0x0d12, 0x0d13, 0x0d14, 0x0d15, 0x0d16, 0x0d17, 0x0d18, 0x0d19,   // U+0e30 ~ U+0e37
0x0d1a, 0x0d1b, 0x0d1c, 0x0d1d, 0x0d1e, 0x0d1f, 0x0d20, 0x0d21,   // U+0e38 ~ U+0e3f
0x0d22, 0x0d23, 0x0d24, 0x0d25, 0x0d26, 0x0d27, 0x0d28, 0x0d29,   // U+0e40 ~ U+0e47
0x0d2a, 0x0d2b, 0x0d2c, 0x0d2d, 0x0d2e, 0x0d2f, 0x0d30, 0x0d31,   // U+0e48 ~ U+0e4f
0x0d32, 0x0d33, 0x0d34, 0x0d35, 0x0d36, 0x0d37, 0x0d38, 0x0d39,   // U+0e50 ~ U+0e57
0x0d3a, 0x0d3b, 0x0d3c, 0x0d3d, 0x0d3e, 0x0d3f, 0x0d40, 0x0d41,   // U+0e58 ~ U+0e5f
0x0d42, 0x0d43, 0x0d44, 0x0d45, 0x0d46, 0x0d47, 0x0d48, 0x0d49,   // U+0e60 ~ U+0e67
0x0d4a, 0x0d4b, 0x0d4c, 0x0d4d, 0x0d4e, 0x0d4f, 0x0d50, 0x0d51,   // U+0e68 ~ U+0e6f
0x0d52, 0x0d53, 0x0d54, 0x0d55, 0x0d56, 0x0d57, 0x0d58, 0x0d59,   // U+0e70 ~ U+0e77
0x0d5a, 0x0d5b, 0x0d5c, 0x0d5d, 0x0d5e, 0x0d5f, 0x0d60, 0x0d61,   // U+0e78 ~ U+0e7f
0x0d62, 0x0d63, 0x0d64, 0x0d65, 0x0d66, 0x0d67, 0x0d68, 0x0d69,   // U+0e80 ~ U+0e87
0x0d6a, 0x0d6b, 0x0d6c, 0x0d6d, 0x0d6e, 0x0d6f, 0x0d70, 0x0d71,   // U+0e88 ~ U+0e8f
0x0d72, 0x0d73, 0x0d74, 0x0d75, 0x0d76, 0x0d77, 0x0d78, 0x0d79,   // U+0e90 ~ U+0e97
0x0d7a, 0x0d7b, 0x0d7c, 0x0d7d, 0x0d7e, 0x0d7f, 0x0d80, 0x0d81,   // U+0e98 ~ U+0e9f
0x0d82, 0x0d83, 0x0d84, 0x0d85, 0x0d86, 0x0d87, 0x0d88, 0x0d89,   // U+0ea0 ~ U+0ea7
0x0d8a, 0x0d8b, 0x0d8c, 0x0d8d, 0x0d8e, 0x0d8f, 0x0d90, 0x0d91,   // U+0ea8 ~ U+0eaf
0x0d92, 0x0d93, 0x0d94, 0x0d95, 0x0d96, 0x0d97, 0x0d98, 0x0d99,   // U+0eb0 ~ U+0eb7
0x0d9a, 0x0d9b, 0x0d9c, 0x0d9d, 0x0d9e, 0x0d9f, 0x0da0, 0x0da1,   // U+0eb8 ~ U+0ebf
0x0da2, 0x0da3, 0x0da4, 0x0da5, 0x0da6, 0x0da7, 0x0da8, 0x0da9,   // U+0ec0 ~ U+0ec7
0x0daa, 0x0dab, 0x0dac, 0x0dad, 0x0dae, 0x0daf, 0x0db0, 0x0db1,   // U+0ec8 ~ U+0ecf
0x0db2, 0x0db3, 0x0db4, 0x0db5, 0x0db6, 0x0db7, 0x0db8, 0x0db9,   // U+0ed0 ~ U+0ed7
0x0dba, 0x0dbb, 0x0dbc, 0x0dbd, 0x0dbe, 0x0dbf, 0x0dc0, 0x0dc1,   // U+0ed8 ~ U+0edf
0x0dc2, 0x0dc3, 0x0dc4, 0x0dc5, 0x0dc6, 0x0dc7, 0x0dc8, 0x0dc9,   // U+0ee0 ~ U+0ee7
0x0dca, 0x0dcb, 0x0dcc, 0x0dcd, 0x0dce, 0x0dcf, 0x0dd0, 0x0dd1,   // U+0ee8 ~ U+0eef
0x0dd2, 0x0dd3, 0x0dd4, 0x0dd5, 0x0dd6, 0x0dd7, 0x0dd8, 0x0dd9,   // U+0ef0 ~ U+0ef7
0x0dda, 0x0ddb, 0x0ddc, 0x0ddd, 0x0dde, 0x0ddf, 0x0de0, 0x0de1,   // U+0ef8 ~ U+0eff
0x0de2, 0x0de3, 0x0de4, 0x0de5, 0x0de6, 0x0de7, 0x0de8, 0x0de9,   // U+0f00 ~ U+0f07
0x0dea, 0x0deb, 0x0dec, 0x0ded, 0x0dee, 0x0def, 0x0df0, 0x0df1,   // U+0f08 ~ U+0f0f
0x0df2, 0x0df3, 0x0df4, 0x0df5, 0x0df6, 0x0df7, 0x0df8, 0x0df9,   // U+0f10 ~ U+0f17
0x0dfa, 0x0dfb, 0x0dfc, 0x0dfd, 0x0dfe, 0x0dff, 0x0e00, 0x0e01,   // U+0f18 ~ U+0f1f
0x0e02, 0x0e03, 0x0e04, 0x0e05, 0x0e06, 0x0e07, 0x0e08, 0x0e09,   // U+0f20 ~ U+0f27
0x0e0a, 0x0e0b, 0x0e0c, 0x0e0d, 0x0e0e, 0x0e0f, 0x0e10, 0x0e11,   // U+0f28 ~ U+0f2f
0x0e12, 0x0e13, 0x0e14, 0x0e15, 0x0e16, 0x0e17, 0x0e18, 0x0e19,   // U+0f30 ~ U+0f37
0x0e1a, 0x0e1b, 0x0e1c, 0x0e1d, 0x0e1e, 0x0e1f, 0x0e20, 0x0e21,   // U+0f38 ~ U+0f3f
0x0e22, 0x0e23, 0x0e24, 0x0e25, 0x0e26, 0x0e27, 0x0e28, 0x0e29,   // U+0f40 ~ U+0f47
0x0e2a, 0x0e2b, 0x0e2c, 0x0e2d, 0x0e2e, 0x0e2f, 0x0e30, 0x0e31,   // U+0f48 ~ U+0f4f
0x0e32, 0x0e33, 0x0e34, 0x0e35, 0x0e36, 0x0e37, 0x0e38, 0x0e39,   // U+0f50 ~ U+0f57
0x0e3a, 0x0e3b, 0x0e3c, 0x0e3d, 0x0e3e, 0x0e3f, 0x0e40, 0x0e41,   // U+0f58 ~ U+0f5f
0x0e42, 0x0e43, 0x0e44, 0x0e45, 0x0e46, 0x0e47, 0x0e48, 0x0e49,   // U+0f60 ~ U+0f67
0x0e4a, 0x0e4b, 0x0e4c, 0x0e4d, 0x0e4e, 0x0e4f, 0x0e50, 0x0e51,   // U+0f68 ~ U+0f6f
0x0e52, 0x0e53, 0x0e54, 0x0e55, 0x0e56, 0x0e57, 0x0e58, 0x0e59,   // U+0f70 ~ U+0f77
0x0e5a, 0x0e5b, 0x0e5c, 0x0e5d, 0x0e5e, 0x0e5f, 0x0e60, 0x0e61,   // U+0f78 ~ U+0f7f
0x0e62, 0x0e63, 0x0e64, 0x0e65, 0x0e66, 0x0e67, 0x0e68, 0x0e69,   // U+0f80 ~ U+0f87
0x0e6a, 0x0e6b, 0x0e6c, 0x0e6d, 0x0e6e, 0x0e6f, 0x0e70, 0x0e71,   // U+0f88 ~ U+0f8f
0x0e72, 0x0e73, 0x0e74, 0x0e75, 0x0e76, 0x0e77, 0x0e78, 0x0e79,   // U+0f90 ~ U+0f97
0x0e7a, 0x0e7b, 0x0e7c, 0x0e7d, 0x0e7e, 0x0e7f, 0x0e80, 0x0e81,   // U+0f98 ~ U+0f9f
0x0e82, 0x0e83, 0x0e84, 0x0e85, 0x0e86, 0x0e87, 0x0e88, 0x0e89,   // U+0fa0 ~ U+0fa7
0x0e8a, 0x0e8b, 0x0e8c, 0x0e8d, 0x0e8e, 0x0e8f, 0x0e90, 0x0e91,   // U+0fa8 ~ U+0faf
0x0e92, 0x0e93, 0x0e94, 0x0e95, 0x0e96, 0x0e97, 0x0e98, 0x0e99,   // U+0fb0 ~ U+0fb7
0x0e9a, 0x0e9b, 0x0e9c, 0x0e9d, 0x0e9e, 0x0e9f, 0x0ea0, 0x0ea1,   // U+0fb8 ~ U+0fbf
0x0ea2, 0x0ea3, 0x0ea4, 0x0ea5, 0x0ea6, 0x0ea7, 0x0ea8, 0x0ea9,   // U+0fc0 ~ U+0fc7
0x0eaa, 0x0eab, 0x0eac, 0x0ead, 0x0eae, 0x0eaf, 0x0eb0, 0x0eb1,   // U+0fc8 ~ U+0fcf
0x0eb2, 0x0eb3, 0x0eb4, 0x0eb5, 0x0eb6, 0x0eb7, 0x0eb8, 0x0eb9,   // U+0fd0 ~ U+0fd7
0x0eba, 0x0ebb, 0x0ebc, 0x0ebd, 0x0ebe, 0x0ebf, 0x0ec0, 0x0ec1,   // U+0fd8 ~ U+0fdf
0x0ec2, 0x0ec3, 0x0ec4, 0x0ec5, 0x0ec6, 0x0ec7, 0x0ec8, 0x0ec9,   // U+0fe0 ~ U+0fe7
0x0eca, 0x0ecb, 0x0ecc, 0x0ecd, 0x0ece, 0x0ecf, 0x0ed0, 0x0ed1,   // U+0fe8 ~ U+0fef
0x0ed2, 0x0ed3, 0x0ed4, 0x0ed5, 0x0ed6, 0x0ed7, 0x0ed8, 0x0ed9,   // U+0ff0 ~ U+0ff7
0x0eda, 0x0edb, 0x0edc, 0x0edd, 0x0ede, 0x0edf, 0x0ee0, 0x0ee1,   // U+0ff8 ~ U+0fff
0x0ee2, 0x0ee3, 0x0ee4, 0x0ee5, 0x0ee6, 0x0ee7, 0x0ee8, 0x0ee9,   // U+1000 ~ U+1007
0x0eea, 0x0eeb, 0x0eec, 0x0eed, 0x0eee, 0x0eef, 0x0ef0, 0x0ef1,   // U+1008 ~ U+100f
0x0ef2, 0x0ef3, 0x0ef4, 0x0ef5, 0x0ef6, 0x0ef7, 0x0ef8, 0x0ef9,   // U+1010 ~ U+1017
0x0efa, 0x0efb, 0x0efc, 0x0efd, 0x0efe, 0x0eff, 0x0f00, 0x0f01,   // U+1018 ~ U+101f
0x0f02, 0x0f03, 0x0f04, 0x0f05, 0x0f06, 0x0f07, 0x0f08, 0x0f09,   // U+1020 ~ U+1027
0x0f0a, 0x0f0b, 0x0f0c, 0x0f0d, 0x0f0e, 0x0f0f, 0x0f10, 0x0f11,   // U+1028 ~ U+102f
0x0f12, 0x0f13, 0x0f14, 0x0f15, 0x0f16, 0x0f17, 0x0f18, 0x0f19,   // U+1030 ~ U+1037
0x0f1a, 0x0f1b, 0x0f1c, 0x0f1d, 0x0f1e, 0x0f1f, 0x0f20, 0x0f21,   // U+1038 ~ U+103f
0x0f22, 0x0f23, 0x0f24, 0x0f25, 0x0f26, 0x0f27, 0x0f28, 0x0f29,   // U+1040 ~ U+1047
0x0f2a, 0x0f2b, 0x0f2c, 0x0f2d, 0x0f2e, 0x0f2f, 0x0f30, 0x0f31,   // U+1048 ~ U+104f
0x0f32, 0x0f33, 0x0f34, 0x0f35, 0x0f36, 0x0f37, 0x0f38, 0x0f39,   // U+1050 ~ U+1057
0x0f3a, 0x0f3b, 0x0f3c, 0x0f3d, 0x0f3e, 0x0f3f, 0x0f40, 0x0f41,   // U+1058 ~ U+105f
0x0f42, 0x0f43, 0x0f44, 0x0f45, 0x0f46, 0x0f47, 0x0f48, 0x0f49,   // U+1060 ~ U+1067
0x0f4a, 0x0f4b, 0x0f4c, 0x0f4d, 0x0f4e, 0x0f4f, 0x0f50, 0x0f51,   // U+1068 ~ U+106f
0x0f52, 0x0f53, 0x0f54, 0x0f55, 0x0f56, 0x0f57, 0x0f58, 0x0f59,   // U+1070 ~ U+1077
0x0f5a, 0x0f5b, 0x0f5c, 0x0f5d, 0x0f5e, 0x0f5f, 0x0f60, 0x0f61,   // U+1078 ~ U+107f
0x0f62, 0x0f63, 0x0f64, 0x0f65, 0x0f66, 0x0f67, 0x0f68, 0x0f69,   // U+1080 ~ U+1087
0x0f6a, 0x0f6b, 0x0f6c, 0x0f6d, 0x0f6e, 0x0f6f, 0x0f70, 0x0f71,   // U+1088 ~ U+108f
0x0f72, 0x0f73, 0x0f74, 0x0f75, 0x0f76, 0x0f77, 0x0f78, 0x0f79,   // U+1090 ~ U+1097
0x0f7a, 0x0f7b, 0x0f7c, 0x0f7d, 0x0f7e, 0x0f7f, 0x0f80, 0x0f81,   // U+1098 ~ U+109f
0x0f82, 0x0f83, 0x0f84, 0x0f85, 0x0f86, 0x0f87, 0x0f88, 0x0f89,   // U+10a0 ~ U+10a7
0x0f8a, 0x0f8b, 0x0f8c, 0x0f8d, 0x0f8e, 0x0f8f, 0x0f90, 0x0f91,   // U+10a8 ~ U+10af
0x0f92, 0x0f93, 0x0f94, 0x0f95, 0x0f96, 0x0f97, 0x0f98, 0x0f99,   // U+10b0 ~ U+10b7
0x0f9a, 0x0f9b, 0x0f9c, 0x0f9d, 0x0f9e, 0x0f9f, 0x0fa0, 0x0fa1,   // U+10b8 ~ U+10bf
0x0fa2, 0x0fa3, 0x0fa4, 0x0fa5, 0x0fa6, 0x0fa7, 0x0fa8, 0x0fa9,   // U+10c0 ~ U+10c7
0x0faa, 0x0fab, 0x0fac, 0x0fad, 0x0fae, 0x0faf, 0x0fb0, 0x0fb1,   // U+10c8 ~ U+10cf
0x0fb2, 0x0fb3, 0x0fb4, 0x0fb5, 0x0fb6, 0x0fb7, 0x0fb8, 0x0fb9,   // U+10d0 ~ U+10d7
0x0fba, 0x0fbb, 0x0fbc, 0x0fbd, 0x0fbe, 0x0fbf, 0x0fc0, 0x0fc1,   // U+10d8 ~ U+10df
0x0fc2, 0x0fc3, 0x0fc4, 0x0fc5, 0x0fc6, 0x0fc7, 0x0fc8, 0x0fc9,   // U+10e0 ~ U+10e7
0x0fca, 0x0fcb, 0x0fcc, 0x0fcd, 0x0fce, 0x0fcf, 0x0fd0, 0x0fd1,   // U+10e8 ~ U+10ef
0x0fd2, 0x0fd3, 0x0fd4, 0x0fd5, 0x0fd6, 0x0fd7, 0x0fd8, 0x0fd9,   // U+10f0 ~ U+10f7
0x0fda, 0x0fdb, 0x0fdc, 0x0fdd, 0x0fde, 0x0fdf, 0x0fe0, 0x0fe1,   // U+10f8 ~ U+10ff
0x0fe2, 0x0fe3, 0x0fe4, 0x0fe5, 0x0fe6, 0x0fe7, 0x0fe8, 0x0fe9,   // U+1100 ~ U+1107
0x0fea, 0x0feb, 0x0fec, 0x0fed, 0x0fee, 0x0fef, 0x0ff0, 0x0ff1,   // U+1108 ~ U+110f
0x0ff2, 0x0ff3, 0x0ff4, 0x0ff5, 0x0ff6, 0x0ff7, 0x0ff8, 0x0ff9,   // U+1110 ~ U+1117
0x0ffa, 0x0ffb, 0x0ffc, 0x0ffd, 0x0ffe, 0x0fff, 0x1000, 0x1001,   // U+1118 ~ U+111f
0x1002, 0x1003, 0x1004, 0x1005, 0x1006, 0x1007, 0x1008, 0x1009,   // U+1120 ~ U+1127
0x100a, 0x100b, 0x100c, 0x100d, 0x100e, 0x100f, 0x1010, 0x1011,   // U+1128 ~ U+112f
0x1012, 0x1013, 0x1014, 0x1015, 0x1016, 0x1017, 0x1018, 0x1019,   // U+1130 ~ U+1137
0x101a, 0x101b, 0x101c, 0x101d, 0x101e, 0x101f, 0x1020, 0x1021,   // U+1138 ~ U+113f
0x1022, 0x1023, 0x1024, 0x1025, 0x1026, 0x1027, 0x1028, 0x1029,   // U+1140 ~ U+1147
0x102a, 0x102b, 0x102c, 0x102d, 0x102e, 0x102f, 0x1030, 0x1031,   // U+1148 ~ U+114f
0x1032, 0x1033, 0x1034, 0x1035, 0x1036, 0x1037, 0x1038, 0x1039,   // U+1150 ~ U+1157
0x103a, 0x103b, 0x103c, 0x103d, 0x103e, 0x103f, 0x1040, 0x1041,   // U+1158 ~ U+115f
0x1042, 0x1043, 0x1044, 0x1045, 0x1046, 0x1047, 0x1048, 0x1049,   // U+1160 ~ U+1167
0x104a, 0x104b, 0x104c, 0x104d, 0x104e, 0x104f, 0x1050, 0x1051,   // U+1168 ~ U+116f
0x1052, 0x1053, 0x1054, 0x1055, 0x1056, 0x1057, 0x1058, 0x1059,   // U+1170 ~ U+1177
0x105a, 0x105b, 0x105c, 0x105d, 0x105e, 0x105f, 0x1060, 0x1061,   // U+1178 ~ U+117f
0x1062, 0x1063, 0x1064, 0x1065, 0x1066, 0x1067, 0x1068, 0x1069,   // U+1180 ~ U+1187
0x106a, 0x106b, 0x106c, 0x106d, 0x106e, 0x106f, 0x1070, 0x1071,   // U+1188 ~ U+118f
0x1072, 0x1073, 0x1074, 0x1075, 0x1076, 0x1077, 0x1078, 0x1079,   // U+1190 ~ U+1197
0x107a, 0x107b, 0x107c, 0x107d, 0x107e, 0x107f, 0x1080, 0x1081,   // U+1198 ~ U+119f
0x1082, 0x1083, 0x1084, 0x1085, 0x1086, 0x1087, 0x1088, 0x1089,   // U+11a0 ~ U+11a7
0x108a, 0x108b, 0x108c, 0x108d, 0x108e, 0x108f, 0x1090, 0x1091,   // U+11a8 ~ U+11af
0x1092, 0x1093, 0x1094, 0x1095, 0x1096, 0x1097, 0x1098, 0x1099,   // U+11b0 ~ U+11b7
0x109a, 0x109b, 0x109c, 0x109d, 0x109e, 0x109f, 0x10a0, 0x10a1,   // U+11b8 ~ U+11bf
0x10a2, 0x10a3, 0x10a4, 0x10a5, 0x10a6, 0x10a7, 0x10a8, 0x10a9,   // U+11c0 ~ U+11c7
0x10aa, 0x10ab, 0x10ac, 0x10ad, 0x10ae, 0x10af, 0x10b0, 0x10b1,   // U+11c8 ~ U+11cf
0x10b2, 0x10b3, 0x10b4, 0x10b5, 0x10b6, 0x10b7, 0x10b8, 0x10b9,   // U+11d0 ~ U+11d7
0x10ba, 0x10bb, 0x10bc, 0x10bd, 0x10be, 0x10bf, 0x10c0, 0x10c1,   // U+11d8 ~ U+11df
0x10c2, 0x10c3, 0x10c4, 0x10c5, 0x10c6, 0x10c7, 0x10c8, 0x10c9,   // U+11e0 ~ U+11e7
0x10ca, 0x10cb, 0x10cc, 0x10cd, 0x10ce, 0x10cf, 0x10d0, 0x10d1,   // U+11e8 ~ U+11ef
0x10d2, 0x10d3, 0x10d4, 0x10d5, 0x10d6, 0x10d7, 0x10d8, 0x10d9,   // U+11f0 ~ U+11f7
0x10da, 0x10db, 0x10dc, 0x10dd, 0x10de, 0x10df, 0x10e0, 0x10e1,   // U+11f8 ~ U+11ff
0x10e2, 0x10e3, 0x10e4, 0x10e5, 0x10e6, 0x10e7, 0x10e8, 0x10e9,   // U+1200 ~ U+1207
0x10ea, 0x10eb, 0x10ec, 0x10ed, 0x10ee, 0x10ef, 0x10f0, 0x10f1,   // U+1208 ~ U+120f
0x10f2, 0x10f3, 0x10f4, 0x10f5, 0x10f6, 0x10f7, 0x10f8, 0x10f9,   // U+1210 ~ U+1217
0x10fa, 0x10fb, 0x10fc, 0x10fd, 0x10fe, 0x10ff, 0x1100, 0x1101,   // U+1218 ~ U+121f
0x1102, 0x1103, 0x1104, 0x1105, 0x1106, 0x1107, 0x1108, 0x1109,   // U+1220 ~ U+1227
0x110a, 0x110b, 0x110c, 0x110d, 0x110e, 0x110f, 0x1110, 0x1111,   // U+1228 ~ U+122f
0x1112, 0x1113, 0x1114, 0x1115, 0x1116, 0x1117, 0x1118, 0x1119,   // U+1230 ~ U+1237
0x111a, 0x111b, 0x111c, 0x111d, 0x111e, 0x111f, 0x1120, 0x1121,   // U+1238 ~ U+123f
0x1122, 0x1123, 0x1124, 0x1125, 0x1126, 0x1127, 0x1128, 0x1129,   // U+1240 ~ U+1247
0x112a, 0x112b, 0x112c, 0x112d, 0x112e, 0x112f, 0x1130, 0x1131,   // U+1248 ~ U+124f
0x1132, 0x1133, 0x1134, 0x1135, 0x1136, 0x1137, 0x1138, 0x1139,   // U+1250 ~ U+1257
0x113a, 0x113b, 0x113c, 0x113d, 0x113e, 0x113f, 0x1140, 0x1141,   // U+1258 ~ U+125f
0x1142, 0x1143, 0x1144, 0x1145, 0x1146, 0x1147, 0x1148, 0x1149,   // U+1260 ~ U+1267
0x114a, 0x114b, 0x114c, 0x114d, 0x114e, 0x114f, 0x1150, 0x1151,   // U+1268 ~ U+126f
0x1152, 0x1153, 0x1154, 0x1155, 0x1156, 0x1157, 0x1158, 0x1159,   // U+1270 ~ U+1277
0x115a, 0x115b, 0x115c, 0x115d, 0x115e, 0x115f, 0x1160, 0x1161,   // U+1278 ~ U+127f
0x1162, 0x1163, 0x1164, 0x1165, 0x1166, 0x1167, 0x1168, 0x1169,   // U+1280 ~ U+1287
0x116a, 0x116b, 0x116c, 0x116d, 0x116e, 0x116f, 0x1170, 0x1171,   // U+1288 ~ U+128f
0x1172, 0x1173, 0x1174, 0x1175, 0x1176, 0x1177, 0x1178, 0x1179,   // U+1290 ~ U+1297
0x117a, 0x117b, 0x117c, 0x117d, 0x117e, 0x117f, 0x1180, 0x1181,   // U+1298 ~ U+129f
0x1182, 0x1183, 0x1184, 0x1185, 0x1186, 0x1187, 0x1188, 0x1189,   // U+12a0 ~ U+12a7
0x118a, 0x118b, 0x118c, 0x118d, 0x118e, 0x118f, 0x1190, 0x1191,   // U+12a8 ~ U+12af
0x1192, 0x1193, 0x1194, 0x1195, 0x1196, 0x1197, 0x1198, 0x1199,   // U+12b0 ~ U+12b7
0x119a, 0x119b, 0x119c, 0x119d, 0x119e, 0x119f, 0x11a0, 0x11a1,   // U+12b8 ~ U+12bf
0x11a2, 0x11a3, 0x11a4, 0x11a5, 0x11a6, 0x11a7, 0x11a8, 0x11a9,   // U+12c0 ~ U+12c7
0x11aa, 0x11ab, 0x11ac, 0x11ad, 0x11ae, 0x11af, 0x11b0, 0x11b1,   // U+12c8 ~ U+12cf
0x11b2, 0x11b3, 0x11b4, 0x11b5, 0x11b6, 0x11b7, 0x11b8, 0x11b9,   // U+12d0 ~ U+12d7
0x11ba, 0x11bb, 0x11bc, 0x11bd, 0x11be, 0x11bf, 0x11c0, 0x11c1,   // U+12d8 ~ U+12df
0x11c2, 0x11c3, 0x11c4, 0x11c5, 0x11c6, 0x11c7, 0x11c8, 0x11c9,   // U+12e0 ~ U+12e7
0x11ca, 0x11cb, 0x11cc, 0x11cd, 0x11ce, 0x11cf, 0x11d0, 0x11d1,   // U+12e8 ~ U+12ef
0x11d2, 0x11d3, 0x11d4, 0x11d5, 0x11d6, 0x11d7, 0x11d8, 0x11d9,   // U+12f0 ~ U+12f7
0x11da, 0x11db, 0x11dc, 0x11dd, 0x11de, 0x11df, 0x11e0, 0x11e1,   // U+12f8 ~ U+12ff
0x11e2, 0x11e3, 0x11e4, 0x11e5, 0x11e6, 0x11e7, 0x11e8, 0x11e9,   // U+1300 ~ U+1307
0x11ea, 0x11eb, 0x11ec, 0x11ed, 0x11ee, 0x11ef, 0x11f0, 0x11f1,   // U+1308 ~ U+130f
0x11f2, 0x11f3, 0x11f4, 0x11f5, 0x11f6, 0x11f7, 0x11f8, 0x11f9,   // U+1310 ~ U+1317
0x11fa, 0x11fb, 0x11fc, 0x11fd, 0x11fe, 0x11ff, 0x1200, 0x1201,   // U+1318 ~ U+131f
0x1202, 0x1203, 0x1204, 0x1205, 0x1206, 0x1207, 0x1208, 0x1209,   // U+1320 ~ U+1327
0x120a, 0x120b, 0x120c, 0x120d, 0x120e, 0x120f, 0x1210, 0x1211,   // U+1328 ~ U+132f
0x1212, 0x1213, 0x1214, 0x1215, 0x1216, 0x1217, 0x1218, 0x1219,   // U+1330 ~ U+1337
0x121a, 0x121b, 0x121c, 0x121d, 0x121e, 0x121f, 0x1220, 0x1221,   // U+1338 ~ U+133f
0x1222, 0x1223, 0x1224, 0x1225, 0x1226, 0x1227, 0x1228, 0x1229,   // U+1340 ~ U+1347
0x122a, 0x122b, 0x122c, 0x122d, 0x122e, 0x122f, 0x1230, 0x1231,   // U+1348 ~ U+134f
0x1232, 0x1233, 0x1234, 0x1235, 0x1236, 0x1237, 0x1238, 0x1239,   // U+1350 ~ U+1357
0x123a, 0x123b, 0x123c, 0x123d, 0x123e, 0x123f, 0x1240, 0x1241,   // U+1358 ~ U+135f
0x1242, 0x1243, 0x1244, 0x1245, 0x1246, 0x1247, 0x1248, 0x1249,   // U+1360 ~ U+1367
0x124a, 0x124b, 0x124c, 0x124d, 0x124e, 0x124f, 0x1250, 0x1251,   // U+1368 ~ U+136f
0x1252, 0x1253, 0x1254, 0x1255, 0x1256, 0x1257, 0x1258, 0x1259,   // U+1370 ~ U+1377
0x125a, 0x125b, 0x125c, 0x125d, 0x125e, 0x125f, 0x1260, 0x1261,   // U+1378 ~ U+137f
0x1262, 0x1263, 0x1264, 0x1265, 0x1266, 0x1267, 0x1268, 0x1269,   // U+1380 ~ U+1387
0x126a, 0x126b, 0x126c, 0x126d, 0x126e, 0x126f, 0x1270, 0x1271,   // U+1388 ~ U+138f
0x1272, 0x1273, 0x1274, 0x1275, 0x1276, 0x1277, 0x1278, 0x1279,   // U+1390 ~ U+1397
0x127a, 0x127b, 0x127c, 0x127d, 0x127e, 0x127f, 0x1280, 0x1281,   // U+1398 ~ U+139f
0x1282, 0x1283, 0x1284, 0x1285, 0x1286, 0x1287, 0x1288, 0x1289,   // U+13a0 ~ U+13a7
0x128a, 0x128b, 0x128c, 0x128d, 0x128e, 0x128f, 0x1290, 0x1291,   // U+13a8 ~ U+13af
0x1292, 0x1293, 0x1294, 0x1295, 0x1296, 0x1297, 0x1298, 0x1299,   // U+13b0 ~ U+13b7
0x129a, 0x129b, 0x129c, 0x129d, 0x129e, 0x129f, 0x12a0, 0x12a1,   // U+13b8 ~ U+13bf
0x12a2, 0x12a3, 0x12a4, 0x12a5, 0x12a6, 0x12a7, 0x12a8, 0x12a9,   // U+13c0 ~ U+13c7
0x12aa, 0x12ab, 0x12ac, 0x12ad, 0x12ae, 0x12af, 0x12b0, 0x12b1,   // U+13c8 ~ U+13cf
0x12b2, 0x12b3, 0x12b4, 0x12b5, 0x12b6, 0x12b7, 0x12b8, 0x12b9,   // U+13d0 ~ U+13d7
0x12ba, 0x12bb, 0x12bc, 0x12bd, 0x12be, 0x12bf, 0x12c0, 0x12c1,   // U+13d8 ~ U+13df
0x12c2, 0x12c3, 0x12c4, 0x12c5, 0x12c6, 0x12c7, 0x12c8, 0x12c9,   // U+13e0 ~ U+13e7
0x12ca, 0x12cb, 0x12cc, 0x12cd, 0x12ce, 0x12cf, 0x12d0, 0x12d1,   // U+13e8 ~ U+13ef
0x12d2, 0x12d3, 0x12d4, 0x12d5, 0x12d6, 0x12d7, 0x12d8, 0x12d9,   // U+13f0 ~ U+13f7
0x12da, 0x12db, 0x12dc, 0x12dd, 0x12de, 0x12df, 0x12e0, 0x12e1,   // U+13f8 ~ U+13ff
0x12e2, 0x12e3, 0x12e4, 0x12e5, 0x12e6, 0x12e7, 0x12e8, 0x12e9,   // U+1400 ~ U+1407
0x12ea, 0x12eb, 0x12ec, 0x12ed, 0x12ee, 0x12ef, 0x12f0, 0x12f1,   // U+1408 ~ U+140f
0x12f2, 0x12f3, 0x12f4, 0x12f5, 0x12f6, 0x12f7, 0x12f8, 0x12f9,   // U+1410 ~ U+1417
0x12fa, 0x12fb, 0x12fc, 0x12fd, 0x12fe, 0x12ff, 0x1300, 0x1301,   // U+1418 ~ U+141f
0x1302, 0x1303, 0x1304, 0x1305, 0x1306, 0x1307, 0x1308, 0x1309,   // U+1420 ~ U+1427
0x130a, 0x130b, 0x130c, 0x130d, 0x130e, 0x130f, 0x1310, 0x1311,   // U+1428 ~ U+142f
0x1312, 0x1313, 0x1314, 0x1315, 0x1316, 0x1317, 0x1318, 0x1319,   // U+1430 ~ U+1437
0x131a, 0x131b, 0x131c, 0x131d, 0x131e, 0x131f, 0x1320, 0x1321,   // U+1438 ~ U+143f
0x1322, 0x1323, 0x1324, 0x1325, 0x1326, 0x1327, 0x1328, 0x1329,   // U+1440 ~ U+1447
0x132a, 0x132b, 0x132c, 0x132d, 0x132e, 0x132f, 0x1330, 0x1331,   // U+1448 ~ U+144f
0x1332, 0x1333, 0x1334, 0x1335, 0x1336, 0x1337, 0x1338, 0x1339,   // U+1450 ~ U+1457
0x133a, 0x133b, 0x133c, 0x133d, 0x133e, 0x133f, 0x1340, 0x1341,   // U+1458 ~ U+145f
0x1342, 0x1343, 0x1344, 0x1345, 0x1346, 0x1347, 0x1348, 0x1349,   // U+1460 ~ U+1467
0x134a, 0x134b, 0x134c, 0x134d, 0x134e, 0x134f, 0x1350, 0x1351,   // U+1468 ~ U+146f
0x1352, 0x1353, 0x1354, 0x1355, 0x1356, 0x1357, 0x1358, 0x1359,   // U+1470 ~ U+1477
0x135a, 0x135b, 0x135c, 0x135d, 0x135e, 0x135f, 0x1360, 0x1361,   // U+1478 ~ U+147f
0x1362, 0x1363, 0x1364, 0x1365, 0x1366, 0x1367, 0x1368, 0x1369,   // U+1480 ~ U+1487
0x136a, 0x136b, 0x136c, 0x136d, 0x136e, 0x136f, 0x1370, 0x1371,   // U+1488 ~ U+148f
0x1372, 0x1373, 0x1374, 0x1375, 0x1376, 0x1377, 0x1378, 0x1379,   // U+1490 ~ U+1497
0x137a, 0x137b, 0x137c, 0x137d, 0x137e, 0x137f, 0x1380, 0x1381,   // U+1498 ~ U+149f
0x1382, 0x1383, 0x1384, 0x1385, 0x1386, 0x1387, 0x1388, 0x1389,   // U+14a0 ~ U+14a7
0x138a, 0x138b, 0x138c, 0x138d, 0x138e, 0x138f, 0x1390, 0x1391,   // U+14a8 ~ U+14af
0x1392, 0x1393, 0x1394, 0x1395, 0x1396, 0x1397, 0x1398, 0x1399,   // U+14b0 ~ U+14b7
0x139a, 0x139b, 0x139c, 0x139d, 0x139e, 0x139f, 0x13a0, 0x13a1,   // U+14b8 ~ U+14bf
0x13a2, 0x13a3, 0x13a4, 0x13a5, 0x13a6, 0x13a7, 0x13a8, 0x13a9,   // U+14c0 ~ U+14c7
0x13aa, 0x13ab, 0x13ac, 0x13ad, 0x13ae, 0x13af, 0x13b0, 0x13b1,   // U+14c8 ~ U+14cf
0x13b2, 0x13b3, 0x13b4, 0x13b5, 0x13b6, 0x13b7, 0x13b8, 0x13b9,   // U+14d0 ~ U+14d7
0x13ba, 0x13bb, 0x13bc, 0x13bd, 0x13be, 0x13bf, 0x13c0, 0x13c1,   // U+14d8 ~ U+14df
0x13c2, 0x13c3, 0x13c4, 0x13c5, 0x13c6, 0x13c7, 0x13c8, 0x13c9,   // U+14e0 ~ U+14e7
0x13ca, 0x13cb, 0x13cc, 0x13cd, 0x13ce, 0x13cf, 0x13d0, 0x13d1,   // U+14e8 ~ U+14ef
0x13d2, 0x13d3, 0x13d4, 0x13d5, 0x13d6, 0x13d7, 0x13d8, 0x13d9,   // U+14f0 ~ U+14f7
0x13da, 0x13db, 0x13dc, 0x13dd, 0x13de, 0x13df, 0x13e0, 0x13e1,   // U+14f8 ~ U+14ff
0x13e2, 0x13e3, 0x13e4, 0x13e5, 0x13e6, 0x13e7, 0x13e8, 0x13e9,   // U+1500 ~ U+1507
0x13ea, 0x13eb, 0x13ec, 0x13ed, 0x13ee, 0x13ef, 0x13f0, 0x13f1,   // U+1508 ~ U+150f
0x13f2, 0x13f3, 0x13f4, 0x13f5, 0x13f6, 0x13f7, 0x13f8, 0x13f9,   // U+1510 ~ U+1517
0x13fa, 0x13fb, 0x13fc, 0x13fd, 0x13fe, 0x13ff, 0x1400, 0x1401,   // U+1518 ~ U+151f
0x1402, 0x1403, 0x1404, 0x1405, 0x1406, 0x1407, 0x1408, 0x1409,   // U+1520 ~ U+1527
0x140a, 0x140b, 0x140c, 0x140d, 0x140e, 0x140f, 0x1410, 0x1411,   // U+1528 ~ U+152f
0x1412, 0x1413, 0x1414, 0x1415, 0x1416, 0x1417, 0x1418, 0x1419,   // U+1530 ~ U+1537
0x141a, 0x141b, 0x141c, 0x141d, 0x141e, 0x141f, 0x1420, 0x1421,   // U+1538 ~ U+153f
0x1422, 0x1423, 0x1424, 0x1425, 0x1426, 0x1427, 0x1428, 0x1429,   // U+1540 ~ U+1547
0x142a, 0x142b, 0x142c, 0x142d, 0x142e, 0x142f, 0x1430, 0x1431,   // U+1548 ~ U+154f
0x1432, 0x1433, 0x1434, 0x1435, 0x1436, 0x1437, 0x1438, 0x1439,   // U+1550 ~ U+1557
0x143a, 0x143b, 0x143c, 0x143d, 0x143e, 0x143f, 0x1440, 0x1441,   // U+1558 ~ U+155f
0x1442, 0x1443, 0x1444, 0x1445, 0x1446, 0x1447, 0x1448, 0x1449,   // U+1560 ~ U+1567
0x144a, 0x144b, 0x144c, 0x144d, 0x144e, 0x144f, 0x1450, 0x1451,   // U+1568 ~ U+156f
0x1452, 0x1453, 0x1454, 0x1455, 0x1456, 0x1457, 0x1458, 0x1459,   // U+1570 ~ U+1577
0x145a, 0x145b, 0x145c, 0x145d, 0x145e, 0x145f, 0x1460, 0x1461,   // U+1578 ~ U+157f
0x1462, 0x1463, 0x1464, 0x1465, 0x1466, 0x1467, 0x1468, 0x1469,   // U+1580 ~ U+1587
0x146a, 0x146b, 0x146c, 0x146d, 0x146e, 0x146f, 0x1470, 0x1471,   // U+1588 ~ U+158f
0x1472, 0x1473, 0x1474, 0x1475, 0x1476, 0x1477, 0x1478, 0x1479,   // U+1590 ~ U+1597
0x147a, 0x147b, 0x147c, 0x147d, 0x147e, 0x147f, 0x1480, 0x1481,   // U+1598 ~ U+159f
0x1482, 0x1483, 0x1484, 0x1485, 0x1486, 0x1487, 0x1488, 0x1489,   // U+15a0 ~ U+15a7
0x148a, 0x148b, 0x148c, 0x148d, 0x148e, 0x148f, 0x1490, 0x1491,   // U+15a8 ~ U+15af
0x1492, 0x1493, 0x1494, 0x1495, 0x1496, 0x1497, 0x1498, 0x1499,   // U+15b0 ~ U+15b7
0x149a, 0x149b, 0x149c, 0x149d, 0x149e, 0x149f, 0x14a0, 0x14a1,   // U+15b8 ~ U+15bf
0x14a2, 0x14a3, 0x14a4, 0x14a5, 0x14a6, 0x14a7, 0x14a8, 0x14a9,   // U+15c0 ~ U+15c7
0x14aa, 0x14ab, 0x14ac, 0x14ad, 0x14ae, 0x14af, 0x14b0, 0x14b1,   // U+15c8 ~ U+15cf
0x14b2, 0x14b3, 0x14b4, 0x14b5, 0x14b6, 0x14b7, 0x14b8, 0x14b9,   // U+15d0 ~ U+15d7
0x14ba, 0x14bb, 0x14bc, 0x14bd, 0x14be, 0x14bf, 0x14c0, 0x14c1,   // U+15d8 ~ U+15df
0x14c2, 0x14c3, 0x14c4, 0x14c5, 0x14c6, 0x14c7, 0x14c8, 0x14c9,   // U+15e0 ~ U+15e7
0x14ca, 0x14cb, 0x14cc, 0x14cd, 0x14ce, 0x14cf, 0x14d0, 0x14d1,   // U+15e8 ~ U+15ef
0x14d2, 0x14d3, 0x14d4, 0x14d5, 0x14d6, 0x14d7, 0x14d8, 0x14d9,   // U+15f0 ~ U+15f7
0x14da, 0x14db, 0x14dc, 0x14dd, 0x14de, 0x14df, 0x14e0, 0x14e1,   // U+15f8 ~ U+15ff
0x14e2, 0x14e3, 0x14e4, 0x14e5, 0x14e6, 0x14e7, 0x14e8, 0x14e9,   // U+1600 ~ U+1607
0x14ea, 0x14eb, 0x14ec, 0x14ed, 0x14ee, 0x14ef, 0x14f0, 0x14f1,   // U+1608 ~ U+160f
0x14f2, 0x14f3, 0x14f4, 0x14f5, 0x14f6, 0x14f7, 0x14f8, 0x14f9,   // U+1610 ~ U+1617
0x14fa, 0x14fb, 0x14fc, 0x14fd, 0x14fe, 0x14ff, 0x1500, 0x1501,   // U+1618 ~ U+161f
0x1502, 0x1503, 0x1504, 0x1505, 0x1506, 0x1507, 0x1508, 0x1509,   // U+1620 ~ U+1627
0x150a, 0x150b, 0x150c, 0x150d, 0x150e, 0x150f, 0x1510, 0x1511,   // U+1628 ~ U+162f
0x1512, 0x1513, 0x1514, 0x1515, 0x1516, 0x1517, 0x1518, 0x1519,   // U+1630 ~ U+1637
0x151a, 0x151b, 0x151c, 0x151d, 0x151e, 0x151f, 0x1520, 0x1521,   // U+1638 ~ U+163f
0x1522, 0x1523, 0x1524, 0x1525, 0x1526, 0x1527, 0x1528, 0x1529,   // U+1640 ~ U+1647
0x152a, 0x152b, 0x152c, 0x152d, 0x152e, 0x152f, 0x1530, 0x1531,   // U+1648 ~ U+164f
0x1532, 0x1533, 0x1534, 0x1535, 0x1536, 0x1537, 0x1538, 0x1539,   // U+1650 ~ U+1657
0x153a, 0x153b, 0x153c, 0x153d, 0x153e, 0x153f, 0x1540, 0x1541,   // U+1658 ~ U+165f
0x1542, 0x1543, 0x1544, 0x1545, 0x1546, 0x1547, 0x1548, 0x1549,   // U+1660 ~ U+1667
0x154a, 0x154b, 0x154c, 0x154d, 0x154e, 0x154f, 0x1550, 0x1551,   // U+1668 ~ U+166f
0x1552, 0x1553, 0x1554, 0x1555, 0x1556, 0x1557, 0x1558, 0x1559,   // U+1670 ~ U+1677
0x155a, 0x155b, 0x155c, 0x155d, 0x155e, 0x155f, 0x1560, 0x1561,   // U+1678 ~ U+167f
0x1562, 0x1563, 0x1564, 0x1565, 0x1566, 0x1567, 0x1568, 0x1569,   // U+1680 ~ U+1687
0x156a, 0x156b, 0x156c, 0x156d, 0x156e, 0x156f, 0x1570, 0x1571,   // U+1688 ~ U+168f
0x1572, 0x1573, 0x1574, 0x1575, 0x1576, 0x1577, 0x1578, 0x1579,   // U+1690 ~ U+1697
0x157a, 0x157b, 0x157c, 0x157d, 0x157e, 0x157f, 0x1580, 0x1581,   // U+1698 ~ U+169f
0x1582, 0x1583, 0x1584, 0x1585, 0x1586, 0x1587, 0x1588, 0x1589,   // U+16a0 ~ U+16a7
0x158a, 0x158b, 0x158c, 0x158d, 0x158e, 0x158f, 0x1590, 0x1591,   // U+16a8 ~ U+16af
0x1592, 0x1593, 0x1594, 0x1595, 0x1596, 0x1597, 0x1598, 0x1599,   // U+16b0 ~ U+16b7
0x159a, 0x159b, 0x159c, 0x159d, 0x159e, 0x159f, 0x15a0, 0x15a1,   // U+16b8 ~ U+16bf
0x15a2, 0x15a3, 0x15a4, 0x15a5, 0x15a6, 0x15a7, 0x15a8, 0x15a9,   // U+16c0 ~ U+16c7
0x15aa, 0x15ab, 0x15ac, 0x15ad, 0x15ae, 0x15af, 0x15b0, 0x15b1,   // U+16c8 ~ U+16cf
0x15b2, 0x15b3, 0x15b4, 0x15b5, 0x15b6, 0x15b7, 0x15b8, 0x15b9,   // U+16d0 ~ U+16d7
0x15ba, 0x15bb, 0x15bc, 0x15bd, 0x15be, 0x15bf, 0x15c0, 0x15c1,   // U+16d8 ~ U+16df
0x15c2, 0x15c3, 0x15c4, 0x15c5, 0x15c6, 0x15c7, 0x15c8, 0x15c9,   // U+16e0 ~ U+16e7
0x15ca, 0x15cb, 0x15cc, 0x15cd, 0x15ce, 0x15cf, 0x15d0, 0x15d1,   // U+16e8 ~ U+16ef
0x15d2, 0x15d3, 0x15d4, 0x15d5, 0x15d6, 0x15d7, 0x15d8, 0x15d9,   // U+16f0 ~ U+16f7
0x15da, 0x15db, 0x15dc, 0x15dd, 0x15de, 0x15df, 0x15e0, 0x15e1,   // U+16f8 ~ U+16ff
0x15e2, 0x15e3, 0x15e4, 0x15e5, 0x15e6, 0x15e7, 0x15e8, 0x15e9,   // U+1700 ~ U+1707
0x15ea, 0x15eb, 0x15ec, 0x15ed, 0x15ee, 0x15ef, 0x15f0, 0x15f1,   // U+1708 ~ U+170f
0x15f2, 0x15f3, 0x15f4, 0x15f5, 0x15f6, 0x15f7, 0x15f8, 0x15f9,   // U+1710 ~ U+1717
0x15fa, 0x15fb, 0x15fc, 0x15fd, 0x15fe, 0x15ff, 0x1600, 0x1601,   // U+1718 ~ U+171f
0x1602, 0x1603, 0x1604, 0x1605, 0x1606, 0x1607, 0x1608, 0x1609,   // U+1720 ~ U+1727
0x160a, 0x160b, 0x160c, 0x160d, 0x160e, 0x160f, 0x1610, 0x1611,   // U+1728 ~ U+172f
0x1612, 0x1613, 0x1614, 0x1615, 0x1616, 0x1617, 0x1618, 0x1619,   // U+1730 ~ U+1737
0x161a, 0x161b, 0x161c, 0x161d, 0x161e, 0x161f, 0x1620, 0x1621,   // U+1738 ~ U+173f
0x1622, 0x1623, 0x1624, 0x1625, 0x1626, 0x1627, 0x1628, 0x1629,   // U+1740 ~ U+1747
0x162a, 0x162b, 0x162c, 0x162d, 0x162e, 0x162f, 0x1630, 0x1631,   // U+1748 ~ U+174f
0x1632, 0x1633, 0x1634, 0x1635, 0x1636, 0x1637, 0x1638, 0x1639,   // U+1750 ~ U+1757
0x163a, 0x163b, 0x163c, 0x163d, 0x163e, 0x163f, 0x1640, 0x1641,   // U+1758 ~ U+175f
0x1642, 0x1643, 0x1644, 0x1645, 0x1646, 0x1647, 0x1648, 0x1649,   // U+1760 ~ U+1767
0x164a, 0x164b, 0x164c, 0x164d, 0x164e, 0x164f, 0x1650, 0x1651,   // U+1768 ~ U+176f
0x1652, 0x1653, 0x1654, 0x1655, 0x1656, 0x1657, 0x1658, 0x1659,   // U+1770 ~ U+1777
0x165a, 0x165b, 0x165c, 0x165d, 0x165e, 0x165f, 0x1660, 0x1661,   // U+1778 ~ U+177f
0x1662, 0x1663, 0x1664, 0x1665, 0x1666, 0x1667, 0x1668, 0x1669,   // U+1780 ~ U+1787
0x166a, 0x166b, 0x166c, 0x166d, 0x166e, 0x166f, 0x1670, 0x1671,   // U+1788 ~ U+178f
0x1672, 0x1673, 0x1674, 0x1675, 0x1676, 0x1677, 0x1678, 0x1679,   // U+1790 ~ U+1797
0x167a, 0x167b, 0x167c, 0x167d, 0x167e, 0x167f, 0x1680, 0x1681,   // U+1798 ~ U+179f
0x1682, 0x1683, 0x1684, 0x1685, 0x1686, 0x1687, 0x1688, 0x1689,   // U+17a0 ~ U+17a7
0x168a, 0x168b, 0x168c, 0x168d, 0x168e, 0x168f, 0x1690, 0x1691,   // U+17a8 ~ U+17af
0x1692, 0x1693, 0x1694, 0x1695, 0x1696, 0x1697, 0x1698, 0x1699,   // U+17b0 ~ U+17b7
0x169a, 0x169b, 0x169c, 0x169d, 0x169e, 0x169f, 0x16a0, 0x16a1,   // U+17b8 ~ U+17bf
0x16a2, 0x16a3, 0x16a4, 0x16a5, 0x16a6, 0x16a7, 0x16a8, 0x16a9,   // U+17c0 ~ U+17c7
0x16aa, 0x16ab, 0x16ac, 0x16ad, 0x16ae, 0x16af, 0x16b0, 0x16b1,   // U+17c8 ~ U+17cf
0x16b2, 0x16b3, 0x16b4, 0x16b5, 0x16b6, 0x16b7, 0x16b8, 0x16b9,   // U+17d0 ~ U+17d7
0x16ba, 0x16bb, 0x16bc, 0x16bd, 0x16be, 0x16bf, 0x16c0, 0x16c1,   // U+17d8 ~ U+17df
0x16c2, 0x16c3, 0x16c4, 0x16c5, 0x16c6, 0x16c7, 0x16c8, 0x16c9,   // U+17e0 ~ U+17e7
0x16ca, 0x16cb, 0x16cc, 0x16cd, 0x16ce, 0x16cf, 0x16d0, 0x16d1,   // U+17e8 ~ U+17ef
0x16d2, 0x16d3, 0x16d4, 0x16d5, 0x16d6, 0x16d7, 0x16d8, 0x16d9,   // U+17f0 ~ U+17f7
0x16da, 0x16db, 0x16dc, 0x16dd, 0x16de, 0x16df, 0x16e0, 0x16e1,   // U+17f8 ~ U+17ff
0x16e2, 0x16e3, 0x16e4, 0x16e5, 0x16e6, 0x16e7, 0x16e8, 0x16e9,   // U+1800 ~ U+1807
0x16ea, 0x16eb, 0x16ec, 0x16ed, 0x16ee, 0x16ef, 0x16f0, 0x16f1,   // U+1808 ~ U+180f
0x16f2, 0x16f3, 0x16f4, 0x16f5, 0x16f6, 0x16f7, 0x16f8, 0x16f9,   // U+1810 ~ U+1817
0x16fa, 0x16fb, 0x16fc, 0x16fd, 0x16fe, 0x16ff, 0x1700, 0x1701,   // U+1818 ~ U+181f
0x1702, 0x1703, 0x1704, 0x1705, 0x1706, 0x1707, 0x1708, 0x1709,   // U+1820 ~ U+1827
0x170a, 0x170b, 0x170c, 0x170d, 0x170e, 0x170f, 0x1710, 0x1711,   // U+1828 ~ U+182f
0x1712, 0x1713, 0x1714, 0x1715, 0x1716, 0x1717, 0x1718, 0x1719,   // U+1830 ~ U+1837
0x171a, 0x171b, 0x171c, 0x171d, 0x171e, 0x171f, 0x1720, 0x1721,   // U+1838 ~ U+183f
0x1722, 0x1723, 0x1724, 0x1725, 0x1726, 0x1727, 0x1728, 0x1729,   // U+1840 ~ U+1847
0x172a, 0x172b, 0x172c, 0x172d, 0x172e, 0x172f, 0x1730, 0x1731,   // U+1848 ~ U+184f
0x1732, 0x1733, 0x1734, 0x1735, 0x1736, 0x1737, 0x1738, 0x1739,   // U+1850 ~ U+1857
0x173a, 0x173b, 0x173c, 0x173d, 0x173e, 0x173f, 0x1740, 0x1741,   // U+1858 ~ U+185f
0x1742, 0x1743, 0x1744, 0x1745, 0x1746, 0x1747, 0x1748, 0x1749,   // U+1860 ~ U+1867
0x174a, 0x174b, 0x174c, 0x174d, 0x174e, 0x174f, 0x1750, 0x1751,   // U+1868 ~ U+186f
0x1752, 0x1753, 0x1754, 0x1755, 0x1756, 0x1757, 0x1758, 0x1759,   // U+1870 ~ U+1877
0x175a, 0x175b, 0x175c, 0x175d, 0x175e, 0x175f, 0x1760, 0x1761,   // U+1878 ~ U+187f
0x1762, 0x1763, 0x1764, 0x1765, 0x1766, 0x1767, 0x1768, 0x1769,   // U+1880 ~ U+1887
0x176a, 0x176b, 0x176c, 0x176d, 0x176e, 0x176f, 0x1770, 0x1771,   // U+1888 ~ U+188f
0x1772, 0x1773, 0x1774, 0x1775, 0x1776, 0x1777, 0x1778, 0x1779,   // U+1890 ~ U+1897
0x177a, 0x177b, 0x177c, 0x177d, 0x177e, 0x177f, 0x1780, 0x1781,   // U+1898 ~ U+189f
0x1782, 0x1783, 0x1784, 0x1785, 0x1786, 0x1787, 0x1788, 0x1789,   // U+18a0 ~ U+18a7
0x178a, 0x178b, 0x178c, 0x178d, 0x178e, 0x178f, 0x1790, 0x1791,   // U+18a8 ~ U+18af
0x1792, 0x1793, 0x1794, 0x1795, 0x1796, 0x1797, 0x1798, 0x1799,   // U+18b0 ~ U+18b7
0x179a, 0x179b, 0x179c, 0x179d, 0x179e, 0x179f, 0x17a0, 0x17a1,   // U+18b8 ~ U+18bf
0x17a2, 0x17a3, 0x17a4, 0x17a5, 0x17a6, 0x17a7, 0x17a8, 0x17a9,   // U+18c0 ~ U+18c7
0x17aa, 0x17ab, 0x17ac, 0x17ad, 0x17ae, 0x17af, 0x17b0, 0x17b1,   // U+18c8 ~ U+18cf
0x17b2, 0x17b3, 0x17b4, 0x17b5, 0x17b6, 0x17b7, 0x17b8, 0x17b9,   // U+18d0 ~ U+18d7
0x17ba, 0x17bb, 0x17bc, 0x17bd, 0x17be, 0x17bf, 0x17c0, 0x17c1,   // U+18d8 ~ U+18df
0x17c2, 0x17c3, 0x17c4, 0x17c5, 0x17c6, 0x17c7, 0x17c8, 0x17c9,   // U+18e0 ~ U+18e7
0x17ca, 0x17cb, 0x17cc, 0x17cd, 0x17ce, 0x17cf, 0x17d0, 0x17d1,   // U+18e8 ~ U+18ef
0x17d2, 0x17d3, 0x17d4, 0x17d5, 0x17d6, 0x17d7, 0x17d8, 0x17d9,   // U+18f0 ~ U+18f7
0x17da, 0x17db, 0x17dc, 0x17dd, 0x17de, 0x17df, 0x17e0, 0x17e1,   // U+18f8 ~ U+18ff
0x17e2, 0x17e3, 0x17e4, 0x17e5, 0x17e6, 0x17e7, 0x17e8, 0x17e9,   // U+1900 ~ U+1907
0x17ea, 0x17eb, 0x17ec, 0x17ed, 0x17ee, 0x17ef, 0x17f0, 0x17f1,   // U+1908 ~ U+190f
0x17f2, 0x17f3, 0x17f4, 0x17f5, 0x17f6, 0x17f7, 0x17f8, 0x17f9,   // U+1910 ~ U+1917
0x17fa, 0x17fb, 0x17fc, 0x17fd, 0x17fe, 0x17ff, 0x1800, 0x1801,   // U+1918 ~ U+191f
0x1802, 0x1803, 0x1804, 0x1805, 0x1806, 0x1807, 0x1808, 0x1809,   // U+1920 ~ U+1927
0x180a, 0x180b, 0x180c, 0x180d, 0x180e, 0x180f, 0x1810, 0x1811,   // U+1928 ~ U+192f
0x1812, 0x1813, 0x1814, 0x1815, 0x1816, 0x1817, 0x1818, 0x1819,   // U+1930 ~ U+1937
0x181a, 0x181b, 0x181c, 0x181d, 0x181e, 0x181f, 0x1820, 0x1821,   // U+1938 ~ U+193f
0x1822, 0x1823, 0x1824, 0x1825, 0x1826, 0x1827, 0x1828, 0x1829,   // U+1940 ~ U+1947
0x182a, 0x182b, 0x182c, 0x182d, 0x182e, 0x182f, 0x1830, 0x1831,   // U+1948 ~ U+194f
0x1832, 0x1833, 0x1834, 0x1835, 0x1836, 0x1837, 0x1838, 0x1839,   // U+1950 ~ U+1957
0x183a, 0x183b, 0x183c, 0x183d, 0x183e, 0x183f, 0x1840, 0x1841,   // U+1958 ~ U+195f
0x1842, 0x1843, 0x1844, 0x1845, 0x1846, 0x1847, 0x1848, 0x1849,   // U+1960 ~ U+1967
0x184a, 0x184b, 0x184c, 0x184d, 0x184e, 0x184f, 0x1850, 0x1851,   // U+1968 ~ U+196f
0x1852, 0x1853, 0x1854, 0x1855, 0x1856, 0x1857, 0x1858, 0x1859,   // U+1970 ~ U+1977
0x185a, 0x185b, 0x185c, 0x185d, 0x185e, 0x185f, 0x1860, 0x1861,   // U+1978 ~ U+197f
0x1862, 0x1863, 0x1864, 0x1865, 0x1866, 0x1867, 0x1868, 0x1869,   // U+1980 ~ U+1987
0x186a, 0x186b, 0x186c, 0x186d, 0x186e, 0x186f, 0x1870, 0x1871,   // U+1988 ~ U+198f
0x1872, 0x1873, 0x1874, 0x1875, 0x1876, 0x1877, 0x1878, 0x1879,   // U+1990 ~ U+1997
0x187a, 0x187b, 0x187c, 0x187d, 0x187e, 0x187f, 0x1880, 0x1881,   // U+1998 ~ U+199f
0x1882, 0x1883, 0x1884, 0x1885, 0x1886, 0x1887, 0x1888, 0x1889,   // U+19a0 ~ U+19a7
0x188a, 0x188b, 0x188c, 0x188d, 0x188e, 0x188f, 0x1890, 0x1891,   // U+19a8 ~ U+19af
0x1892, 0x1893, 0x1894, 0x1895, 0x1896, 0x1897, 0x1898, 0x1899,   // U+19b0 ~ U+19b7
0x189a, 0x189b, 0x189c, 0x189d, 0x189e, 0x189f, 0x18a0, 0x18a1,   // U+19b8 ~ U+19bf
0x18a2, 0x18a3, 0x18a4, 0x18a5, 0x18a6, 0x18a7, 0x18a8, 0x18a9,   // U+19c0 ~ U+19c7
0x18aa, 0x18ab, 0x18ac, 0x18ad, 0x18ae, 0x18af, 0x18b0, 0x18b1,   // U+19c8 ~ U+19cf
0x18b2, 0x18b3, 0x18b4, 0x18b5, 0x18b6, 0x18b7, 0x18b8, 0x18b9,   // U+19d0 ~ U+19d7
0x18ba, 0x18bb, 0x18bc, 0x18bd, 0x18be, 0x18bf, 0x18c0, 0x18c1,   // U+19d8 ~ U+19df
0x18c2, 0x18c3, 0x18c4, 0x18c5, 0x18c6, 0x18c7, 0x18c8, 0x18c9,   // U+19e0 ~ U+19e7
0x18ca, 0x18cb, 0x18cc, 0x18cd, 0x18ce, 0x18cf, 0x18d0, 0x18d1,   // U+19e8 ~ U+19ef
0x18d2, 0x18d3, 0x18d4, 0x18d5, 0x18d6, 0x18d7, 0x18d8, 0x18d9,   // U+19f0 ~ U+19f7
0x18da, 0x18db, 0x18dc, 0x18dd, 0x18de, 0x18df, 0x18e0, 0x18e1,   // U+19f8 ~ U+19ff
0x18e2, 0x18e3, 0x18e4, 0x18e5, 0x18e6, 0x18e7, 0x18e8, 0x18e9,   // U+1a00 ~ U+1a07
0x18ea, 0x18eb, 0x18ec, 0x18ed, 0x18ee, 0x18ef, 0x18f0, 0x18f1,   // U+1a08 ~ U+1a0f
0x18f2, 0x18f3, 0x18f4, 0x18f5, 0x18f6, 0x18f7, 0x18f8, 0x18f9,   // U+1a10 ~ U+1a17
0x18fa, 0x18fb, 0x18fc, 0x18fd, 0x18fe, 0x18ff, 0x1900, 0x1901,   // U+1a18 ~ U+1a1f
0x1902, 0x1903, 0x1904, 0x1905, 0x1906, 0x1907, 0x1908, 0x1909,   // U+1a20 ~ U+1a27
0x190a, 0x190b, 0x190c, 0x190d, 0x190e, 0x190f, 0x1910, 0x1911,   // U+1a28 ~ U+1a2f
0x1912, 0x1913, 0x1914, 0x1915, 0x1916, 0x1917, 0x1918, 0x1919,   // U+1a30 ~ U+1a37
0x191a, 0x191b, 0x191c, 0x191d, 0x191e, 0x191f, 0x1920, 0x1921,   // U+1a38 ~ U+1a3f
0x1922, 0x1923, 0x1924, 0x1925, 0x1926, 0x1927, 0x1928, 0x1929,   // U+1a40 ~ U+1a47
0x192a, 0x192b, 0x192c, 0x192d, 0x192e, 0x192f, 0x1930, 0x1931,   // U+1a48 ~ U+1a4f
0x1932, 0x1933, 0x1934, 0x1935, 0x1936, 0x1937, 0x1938, 0x1939,   // U+1a50 ~ U+1a57
0x193a, 0x193b, 0x193c, 0x193d, 0x193e, 0x193f, 0x1940, 0x1941,   // U+1a58 ~ U+1a5f
0x1942, 0x1943, 0x1944, 0x1945, 0x1946, 0x1947, 0x1948, 0x1949,   // U+1a60 ~ U+1a67
0x194a, 0x194b, 0x194c, 0x194d, 0x194e, 0x194f, 0x1950, 0x1951,   // U+1a68 ~ U+1a6f
0x1952, 0x1953, 0x1954, 0x1955, 0x1956, 0x1957, 0x1958, 0x1959,   // U+1a70 ~ U+1a77
0x195a, 0x195b, 0x195c, 0x195d, 0x195e, 0x195f, 0x1960, 0x1961,   // U+1a78 ~ U+1a7f
0x1962, 0x1963, 0x1964, 0x1965, 0x1966, 0x1967, 0x1968, 0x1969,   // U+1a80 ~ U+1a87
0x196a, 0x196b, 0x196c, 0x196d, 0x196e, 0x196f, 0x1970, 0x1971,   // U+1a88 ~ U+1a8f
0x1972, 0x1973, 0x1974, 0x1975, 0x1976, 0x1977, 0x1978, 0x1979,   // U+1a90 ~ U+1a97
0x197a, 0x197b, 0x197c, 0x197d, 0x197e, 0x197f, 0x1980, 0x1981,   // U+1a98 ~ U+1a9f
0x1982, 0x1983, 0x1984, 0x1985, 0x1986, 0x1987, 0x1988, 0x1989,   // U+1aa0 ~ U+1aa7
0x198a, 0x198b, 0x198c, 0x198d, 0x198e, 0x198f, 0x1990, 0x1991,   // U+1aa8 ~ U+1aaf
0x1992, 0x1993, 0x1994, 0x1995, 0x1996, 0x1997, 0x1998, 0x1999,   // U+1ab0 ~ U+1ab7
0x199a, 0x199b, 0x199c, 0x199d, 0x199e, 0x199f, 0x19a0, 0x19a1,   // U+1ab8 ~ U+1abf
0x19a2, 0x19a3, 0x19a4, 0x19a5, 0x19a6, 0x19a7, 0x19a8, 0x19a9,   // U+1ac0 ~ U+1ac7
0x19aa, 0x19ab, 0x19ac, 0x19ad, 0x19ae, 0x19af, 0x19b0, 0x19b1,   // U+1ac8 ~ U+1acf
0x19b2, 0x19b3, 0x19b4, 0x19b5, 0x19b6, 0x19b7, 0x19b8, 0x19b9,   // U+1ad0 ~ U+1ad7
0x19ba, 0x19bb, 0x19bc, 0x19bd, 0x19be, 0x19bf, 0x19c0, 0x19c1,   // U+1ad8 ~ U+1adf
0x19c2, 0x19c3, 0x19c4, 0x19c5, 0x19c6, 0x19c7, 0x19c8, 0x19c9,   // U+1ae0 ~ U+1ae7
0x19ca, 0x19cb, 0x19cc, 0x19cd, 0x19ce, 0x19cf, 0x19d0, 0x19d1,   // U+1ae8 ~ U+1aef
0x19d2, 0x19d3, 0x19d4, 0x19d5, 0x19d6, 0x19d7, 0x19d8, 0x19d9,   // U+1af0 ~ U+1af7
0x19da, 0x19db, 0x19dc, 0x19dd, 0x19de, 0x19df, 0x19e0, 0x19e1,   // U+1af8 ~ U+1aff
0x19e2, 0x19e3, 0x19e4, 0x19e5, 0x19e6, 0x19e7, 0x19e8, 0x19e9,   // U+1b00 ~ U+1b07
0x19ea, 0x19eb, 0x19ec, 0x19ed, 0x19ee, 0x19ef, 0x19f0, 0x19f1,   // U+1b08 ~ U+1b0f
0x19f2, 0x19f3, 0x19f4, 0x19f5, 0x19f6, 0x19f7, 0x19f8, 0x19f9,   // U+1b10 ~ U+1b17
0x19fa, 0x19fb, 0x19fc, 0x19fd, 0x19fe, 0x19ff, 0x1a00, 0x1a01,   // U+1b18 ~ U+1b1f
0x1a02, 0x1a03, 0x1a04, 0x1a05, 0x1a06, 0x1a07, 0x1a08, 0x1a09,   // U+1b20 ~ U+1b27
0x1a0a, 0x1a0b, 0x1a0c, 0x1a0d, 0x1a0e, 0x1a0f, 0x1a10, 0x1a11,   // U+1b28 ~ U+1b2f
0x1a12, 0x1a13, 0x1a14, 0x1a15, 0x1a16, 0x1a17, 0x1a18, 0x1a19,   // U+1b30 ~ U+1b37
0x1a1a, 0x1a1b, 0x1a1c, 0x1a1d, 0x1a1e, 0x1a1f, 0x1a20, 0x1a21,   // U+1b38 ~ U+1b3f
0x1a22, 0x1a23, 0x1a24, 0x1a25, 0x1a26, 0x1a27, 0x1a28, 0x1a29,   // U+1b40 ~ U+1b47
0x1a2a, 0x1a2b, 0x1a2c, 0x1a2d, 0x1a2e, 0x1a2f, 0x1a30, 0x1a31,   // U+1b48 ~ U+1b4f
0x1a32, 0x1a33, 0x1a34, 0x1a35, 0x1a36, 0x1a37, 0x1a38, 0x1a39,   // U+1b50 ~ U+1b57
0x1a3a, 0x1a3b, 0x1a3c, 0x1a3d, 0x1a3e, 0x1a3f, 0x1a40, 0x1a41,   // U+1b58 ~ U+1b5f
0x1a42, 0x1a43, 0x1a44, 0x1a45, 0x1a46, 0x1a47, 0x1a48, 0x1a49,   // U+1b60 ~ U+1b67
0x1a4a, 0x1a4b, 0x1a4c, 0x1a4d, 0x1a4e, 0x1a4f, 0x1a50, 0x1a51,   // U+1b68 ~ U+1b6f
0x1a52, 0x1a53, 0x1a54, 0x1a55, 0x1a56, 0x1a57, 0x1a58, 0x1a59,   // U+1b70 ~ U+1b77
0x1a5a, 0x1a5b, 0x1a5c, 0x1a5d, 0x1a5e, 0x1a5f, 0x1a60, 0x1a61,   // U+1b78 ~ U+1b7f
0x1a62, 0x1a63, 0x1a64, 0x1a65, 0x1a66, 0x1a67, 0x1a68, 0x1a69,   // U+1b80 ~ U+1b87
0x1a6a, 0x1a6b, 0x1a6c, 0x1a6d, 0x1a6e, 0x1a6f, 0x1a70, 0x1a71,   // U+1b88 ~ U+1b8f
0x1a72, 0x1a73, 0x1a74, 0x1a75, 0x1a76, 0x1a77, 0x1a78, 0x1a79,   // U+1b90 ~ U+1b97
0x1a7a, 0x1a7b, 0x1a7c, 0x1a7d, 0x1a7e, 0x1a7f, 0x1a80, 0x1a81,   // U+1b98 ~ U+1b9f
0x1a82, 0x1a83, 0x1a84, 0x1a85, 0x1a86, 0x1a87, 0x1a88, 0x1a89,   // U+1ba0 ~ U+1ba7
0x1a8a, 0x1a8b, 0x1a8c, 0x1a8d, 0x1a8e, 0x1a8f, 0x1a90, 0x1a91,   // U+1ba8 ~ U+1baf
0x1a92, 0x1a93, 0x1a94, 0x1a95, 0x1a96, 0x1a97, 0x1a98, 0x1a99,   // U+1bb0 ~ U+1bb7
0x1a9a, 0x1a9b, 0x1a9c, 0x1a9d, 0x1a9e, 0x1a9f, 0x1aa0, 0x1aa1,   // U+1bb8 ~ U+1bbf
0x1aa2, 0x1aa3, 0x1aa4, 0x1aa5, 0x1aa6, 0x1aa7, 0x1aa8, 0x1aa9,   // U+1bc0 ~ U+1bc7
0x1aaa, 0x1aab, 0x1aac, 0x1aad, 0x1aae, 0x1aaf, 0x1ab0, 0x1ab1,   // U+1bc8 ~ U+1bcf
0x1ab2, 0x1ab3, 0x1ab4, 0x1ab5, 0x1ab6, 0x1ab7, 0x1ab8, 0x1ab9,   // U+1bd0 ~ U+1bd7
0x1aba, 0x1abb, 0x1abc, 0x1abd, 0x1abe, 0x1abf, 0x1ac0, 0x1ac1,   // U+1bd8 ~ U+1bdf
0x1ac2, 0x1ac3, 0x1ac4, 0x1ac5, 0x1ac6, 0x1ac7, 0x1ac8, 0x1ac9,   // U+1be0 ~ U+1be7
0x1aca, 0x1acb, 0x1acc, 0x1acd, 0x1ace, 0x1acf, 0x1ad0, 0x1ad1,   // U+1be8 ~ U+1bef
0x1ad2, 0x1ad3, 0x1ad4, 0x1ad5, 0x1ad6, 0x1ad7, 0x1ad8, 0x1ad9,   // U+1bf0 ~ U+1bf7
0x1ada, 0x1adb, 0x1adc, 0x1add, 0x1ade, 0x1adf, 0x1ae0, 0x1ae1,   // U+1bf8 ~ U+1bff
0x1ae2, 0x1ae3, 0x1ae4, 0x1ae5, 0x1ae6, 0x1ae7, 0x1ae8, 0x1ae9,   // U+1c00 ~ U+1c07
0x1aea, 0x1aeb, 0x1aec, 0x1aed, 0x1aee, 0x1aef, 0x1af0, 0x1af1,   // U+1c08 ~ U+1c0f
0x1af2, 0x1af3, 0x1af4, 0x1af5, 0x1af6, 0x1af7, 0x1af8, 0x1af9,   // U+1c10 ~ U+1c17
0x1afa, 0x1afb, 0x1afc, 0x1afd, 0x1afe, 0x1aff, 0x1b00, 0x1b01,   // U+1c18 ~ U+1c1f
0x1b02, 0x1b03, 0x1b04, 0x1b05, 0x1b06, 0x1b07, 0x1b08, 0x1b09,   // U+1c20 ~ U+1c27
0x1b0a, 0x1b0b, 0x1b0c, 0x1b0d, 0x1b0e, 0x1b0f, 0x1b10, 0x1b11,   // U+1c28 ~ U+1c2f
0x1b12, 0x1b13, 0x1b14, 0x1b15, 0x1b16, 0x1b17, 0x1b18, 0x1b19,   // U+1c30 ~ U+1c37
0x1b1a, 0x1b1b, 0x1b1c, 0x1b1d, 0x1b1e, 0x1b1f, 0x1b20, 0x1b21,   // U+1c38 ~ U+1c3f
0x1b22, 0x1b23, 0x1b24, 0x1b25, 0x1b26, 0x1b27, 0x1b28, 0x1b29,   // U+1c40 ~ U+1c47
0x1b2a, 0x1b2b, 0x1b2c, 0x1b2d, 0x1b2e, 0x1b2f, 0x1b30, 0x1b31,   // U+1c48 ~ U+1c4f
0x1b32, 0x1b33, 0x1b34, 0x1b35, 0x1b36, 0x1b37, 0x1b38, 0x1b39,   // U+1c50 ~ U+1c57
0x1b3a, 0x1b3b, 0x1b3c, 0x1b3d, 0x1b3e, 0x1b3f, 0x1b40, 0x1b41,   // U+1c58 ~ U+1c5f
0x1b42, 0x1b43, 0x1b44, 0x1b45, 0x1b46, 0x1b47, 0x1b48, 0x1b49,   // U+1c60 ~ U+1c67
0x1b4a, 0x1b4b, 0x1b4c, 0x1b4d, 0x1b4e, 0x1b4f, 0x1b50, 0x1b51,   // U+1c68 ~ U+1c6f
0x1b52, 0x1b53, 0x1b54, 0x1b55, 0x1b56, 0x1b57, 0x1b58, 0x1b59,   // U+1c70 ~ U+1c77
0x1b5a, 0x1b5b, 0x1b5c, 0x1b5d, 0x1b5e, 0x1b5f, 0x1b60, 0x1b61,   // U+1c78 ~ U+1c7f
0x1b62, 0x1b63, 0x1b64, 0x1b65, 0x1b66, 0x1b67, 0x1b68, 0x1b69,   // U+1c80 ~ U+1c87
0x1b6a, 0x1b6b, 0x1b6c, 0x1b6d, 0x1b6e, 0x1b6f, 0x1b70, 0x1b71,   // U+1c88 ~ U+1c8f
0x1b72, 0x1b73, 0x1b74, 0x1b75, 0x1b76, 0x1b77, 0x1b78, 0x1b79,   // U+1c90 ~ U+1c97
0x1b7a, 0x1b7b, 0x1b7c, 0x1b7d, 0x1b7e, 0x1b7f, 0x1b80, 0x1b81,   // U+1c98 ~ U+1c9f
0x1b82, 0x1b83, 0x1b84, 0x1b85, 0x1b86, 0x1b87, 0x1b88, 0x1b89,   // U+1ca0 ~ U+1ca7
0x1b8a, 0x1b8b, 0x1b8c, 0x1b8d, 0x1b8e, 0x1b8f, 0x1b90, 0x1b91,   // U+1ca8 ~ U+1caf
0x1b92, 0x1b93, 0x1b94, 0x1b95, 0x1b96, 0x1b97, 0x1b98, 0x1b99,   // U+1cb0 ~ U+1cb7
0x1b9a, 0x1b9b, 0x1b9c, 0x1b9d, 0x1b9e, 0x1b9f, 0x1ba0, 0x1ba1,   // U+1cb8 ~ U+1cbf
0x1ba2, 0x1ba3, 0x1ba4, 0x1ba5, 0x1ba6, 0x1ba7, 0x1ba8, 0x1ba9,   // U+1cc0 ~ U+1cc7
0x1baa, 0x1bab, 0x1bac, 0x1bad, 0x1bae, 0x1baf, 0x1bb0, 0x1bb1,   // U+1cc8 ~ U+1ccf
0x1bb2, 0x1bb3, 0x1bb4, 0x1bb5, 0x1bb6, 0x1bb7, 0x1bb8, 0x1bb9,   // U+1cd0 ~ U+1cd7
0x1bba, 0x1bbb, 0x1bbc, 0x1bbd, 0x1bbe, 0x1bbf, 0x1bc0, 0x1bc1,   // U+1cd8 ~ U+1cdf
0x1bc2, 0x1bc3, 0x1bc4, 0x1bc5, 0x1bc6, 0x1bc7, 0x1bc8, 0x1bc9,   // U+1ce0 ~ U+1ce7
0x1bca, 0x1bcb, 0x1bcc, 0x1bcd, 0x1bce, 0x1bcf, 0x1bd0, 0x1bd1,   // U+1ce8 ~ U+1cef
0x1bd2, 0x1bd3, 0x1bd4, 0x1bd5, 0x1bd6, 0x1bd7, 0x1bd8, 0x1bd9,   // U+1cf0 ~ U+1cf7
0x1bda, 0x1bdb, 0x1bdc, 0x1bdd, 0x1bde, 0x1bdf, 0x1be0, 0x1be1,   // U+1cf8 ~ U+1cff
0x1be2, 0x1be3, 0x1be4, 0x1be5, 0x1be6, 0x1be7, 0x1be8, 0x1be9,   // U+1d00 ~ U+1d07
0x1bea, 0x1beb, 0x1bec, 0x1bed, 0x1bee, 0x1bef, 0x1bf0, 0x1bf1,   // U+1d08 ~ U+1d0f
0x1bf2, 0x1bf3, 0x1bf4, 0x1bf5, 0x1bf6, 0x1bf7, 0x1bf8, 0x1bf9,   // U+1d10 ~ U+1d17
0x1bfa, 0x1bfb, 0x1bfc, 0x1bfd, 0x1bfe, 0x1bff, 0x1c00, 0x1c01,   // U+1d18 ~ U+1d1f
0x1c02, 0x1c03, 0x1c04, 0x1c05, 0x1c06, 0x1c07, 0x1c08, 0x1c09,   // U+1d20 ~ U+1d27
0x1c0a, 0x1c0b, 0x1c0c, 0x1c0d, 0x1c0e, 0x1c0f, 0x1c10, 0x1c11,   // U+1d28 ~ U+1d2f
0x1c12, 0x1c13, 0x1c14, 0x1c15, 0x1c16, 0x1c17, 0x1c18, 0x1c19,   // U+1d30 ~ U+1d37
0x1c1a, 0x1c1b, 0x1c1c, 0x1c1d, 0x1c1e, 0x1c1f, 0x1c20, 0x1c21,   // U+1d38 ~ U+1d3f
0x1c22, 0x1c23, 0x1c24, 0x1c25, 0x1c26, 0x1c27, 0x1c28, 0x1c29,   // U+1d40 ~ U+1d47
0x1c2a, 0x1c2b, 0x1c2c, 0x1c2d, 0x1c2e, 0x1c2f, 0x1c30, 0x1c31,   // U+1d48 ~ U+1d4f
0x1c32, 0x1c33, 0x1c34, 0x1c35, 0x1c36, 0x1c37, 0x1c38, 0x1c39,   // U+1d50 ~ U+1d57
0x1c3a, 0x1c3b, 0x1c3c, 0x1c3d, 0x1c3e, 0x1c3f, 0x1c40, 0x1c41,   // U+1d58 ~ U+1d5f
0x1c42, 0x1c43, 0x1c44, 0x1c45, 0x1c46, 0x1c47, 0x1c48, 0x1c49,   // U+1d60 ~ U+1d67
0x1c4a, 0x1c4b, 0x1c4c, 0x1c4d, 0x1c4e, 0x1c4f, 0x1c50, 0x1c51,   // U+1d68 ~ U+1d6f
0x1c52, 0x1c53, 0x1c54, 0x1c55, 0x1c56, 0x1c57, 0x1c58, 0x1c59,   // U+1d70 ~ U+1d77
0x1c5a, 0x1c5b, 0x1c5c, 0x1c5d, 0x1c5e, 0x1c5f, 0x1c60, 0x1c61,   // U+1d78 ~ U+1d7f
0x1c62, 0x1c63, 0x1c64, 0x1c65, 0x1c66, 0x1c67, 0x1c68, 0x1c69,   // U+1d80 ~ U+1d87
0x1c6a, 0x1c6b, 0x1c6c, 0x1c6d, 0x1c6e, 0x1c6f, 0x1c70, 0x1c71,   // U+1d88 ~ U+1d8f
0x1c72, 0x1c73, 0x1c74, 0x1c75, 0x1c76, 0x1c77, 0x1c78, 0x1c79,   // U+1d90 ~ U+1d97
0x1c7a, 0x1c7b, 0x1c7c, 0x1c7d, 0x1c7e, 0x1c7f, 0x1c80, 0x1c81,   // U+1d98 ~ U+1d9f
0x1c82, 0x1c83, 0x1c84, 0x1c85, 0x1c86, 0x1c87, 0x1c88, 0x1c89,   // U+1da0 ~ U+1da7
0x1c8a, 0x1c8b, 0x1c8c, 0x1c8d, 0x1c8e, 0x1c8f, 0x1c90, 0x1c91,   // U+1da8 ~ U+1daf
0x1c92, 0x1c93, 0x1c94, 0x1c95, 0x1c96, 0x1c97, 0x1c98, 0x1c99,   // U+1db0 ~ U+1db7
0x1c9a, 0x1c9b, 0x1c9c, 0x1c9d, 0x1c9e, 0x1c9f, 0x1ca0, 0x1ca1,   // U+1db8 ~ U+1dbf
0x1ca2, 0x1ca3, 0x1ca4, 0x1ca5, 0x1ca6, 0x1ca7, 0x1ca8, 0x1ca9,   // U+1dc0 ~ U+1dc7
0x1caa, 0x1cab, 0x1cac, 0x1cad, 0x1cae, 0x1caf, 0x1cb0, 0x1cb1,   // U+1dc8 ~ U+1dcf
0x1cb2, 0x1cb3, 0x1cb4, 0x1cb5, 0x1cb6, 0x1cb7, 0x1cb8, 0x1cb9,   // U+1dd0 ~ U+1dd7
0x1cba, 0x1cbb, 0x1cbc, 0x1cbd, 0x1cbe, 0x1cbf, 0x1cc0, 0x1cc1,   // U+1dd8 ~ U+1ddf
0x1cc2, 0x1cc3, 0x1cc4, 0x1cc5, 0x1cc6, 0x1cc7, 0x1cc8, 0x1cc9,   // U+1de0 ~ U+1de7
0x1cca, 0x1ccb, 0x1ccc, 0x1ccd, 0x1cce, 0x1ccf, 0x1cd0, 0x1cd1,   // U+1de8 ~ U+1def
0x1cd2, 0x1cd3, 0x1cd4, 0x1cd5, 0x1cd6, 0x1cd7, 0x1cd8, 0x1cd9,   // U+1df0 ~ U+1df7
0x1cda, 0x1cdb, 0x1cdc, 0x1cdd, 0x1cde, 0x1cdf, 0x1ce0, 0x1ce1,   // U+1df8 ~ U+1dff
0x1ce2, 0x1ce3, 0x1ce4, 0x1ce5, 0x1ce6, 0x1ce7, 0x1ce8, 0x1ce9,   // U+1e00 ~ U+1e07
0x1cea, 0x1ceb, 0x1cec, 0x1ced, 0x1cee, 0x1cef, 0x1cf0, 0x1cf1,   // U+1e08 ~ U+1e0f
0x1cf2, 0x1cf3, 0x1cf4, 0x1cf5, 0x1cf6, 0x1cf7, 0x1cf8, 0x1cf9,   // U+1e10 ~ U+1e17
0x1cfa, 0x1cfb, 0x1cfc, 0x1cfd, 0x1cfe, 0x1cff, 0x1d00, 0x1d01,   // U+1e18 ~ U+1e1f
0x1d02, 0x1d03, 0x1d04, 0x1d05, 0x1d06, 0x1d07, 0x1d08, 0x1d09,   // U+1e20 ~ U+1e27
0x1d0a, 0x1d0b, 0x1d0c, 0x1d0d, 0x1d0e, 0x1d0f, 0x1d10, 0x1d11,   // U+1e28 ~ U+1e2f
0x1d12, 0x1d13, 0x1d14, 0x1d15, 0x1d16, 0x1d17, 0x1d18, 0x1d19,   // U+1e30 ~ U+1e37
0x1d1a, 0x1d1b, 0x1d1c, 0x1d1d, 0x1d1e, 0x1d1f, 0x1d20, 0x1d21,   // U+1e38 ~ U+1e3f
0x1d22, 0x1d23, 0x1d24, 0x1d25, 0x1d26, 0x1d27, 0x1d28, 0x1d29,   // U+1e40 ~ U+1e47
0x1d2a, 0x1d2b, 0x1d2c, 0x1d2d, 0x1d2e, 0x1d2f, 0x1d30, 0x1d31,   // U+1e48 ~ U+1e4f
0x1d32, 0x1d33, 0x1d34, 0x1d35, 0x1d36, 0x1d37, 0x1d38, 0x1d39,   // U+1e50 ~ U+1e57
0x1d3a, 0x1d3b, 0x1d3c, 0x1d3d, 0x1d3e, 0x1d3f, 0x1d40, 0x1d41,   // U+1e58 ~ U+1e5f
0x1d42, 0x1d43, 0x1d44, 0x1d45, 0x1d46, 0x1d47, 0x1d48, 0x1d49,   // U+1e60 ~ U+1e67
0x1d4a, 0x1d4b, 0x1d4c, 0x1d4d, 0x1d4e, 0x1d4f, 0x1d50, 0x1d51,   // U+1e68 ~ U+1e6f
0x1d52, 0x1d53, 0x1d54, 0x1d55, 0x1d56, 0x1d57, 0x1d58, 0x1d59,   // U+1e70 ~ U+1e77
0x1d5a, 0x1d5b, 0x1d5c, 0x1d5d, 0x1d5e, 0x1d5f, 0x1d60, 0x1d61,   // U+1e78 ~ U+1e7f
0x1d62, 0x1d63, 0x1d64, 0x1d65, 0x1d66, 0x1d67, 0x1d68, 0x1d69,   // U+1e80 ~ U+1e87
0x1d6a, 0x1d6b, 0x1d6c, 0x1d6d, 0x1d6e, 0x1d6f, 0x1d70, 0x1d71,   // U+1e88 ~ U+1e8f
0x1d72, 0x1d73, 0x1d74, 0x1d75, 0x1d76, 0x1d77, 0x1d78, 0x1d79,   // U+1e90 ~ U+1e97
0x1d7a, 0x1d7b, 0x1d7c, 0x1d7d, 0x1d7e, 0x1d7f, 0x1d80, 0x1d81,   // U+1e98 ~ U+1e9f
0x1d82, 0x1d83, 0x1d84, 0x1d85, 0x1d86, 0x1d87, 0x1d88, 0x1d89,   // U+1ea0 ~ U+1ea7
0x1d8a, 0x1d8b, 0x1d8c, 0x1d8d, 0x1d8e, 0x1d8f, 0x1d90, 0x1d91,   // U+1ea8 ~ U+1eaf
0x1d92, 0x1d93, 0x1d94, 0x1d95, 0x1d96, 0x1d97, 0x1d98, 0x1d99,   // U+1eb0 ~ U+1eb7
0x1d9a, 0x1d9b, 0x1d9c, 0x1d9d, 0x1d9e, 0x1d9f, 0x1da0, 0x1da1,   // U+1eb8 ~ U+1ebf
0x1da2, 0x1da3, 0x1da4, 0x1da5, 0x1da6, 0x1da7, 0x1da8, 0x1da9,   // U+1ec0 ~ U+1ec7
0x1daa, 0x1dab, 0x1dac, 0x1dad, 0x1dae, 0x1daf, 0x1db0, 0x1db1,   // U+1ec8 ~ U+1ecf
0x1db2, 0x1db3, 0x1db4, 0x1db5, 0x1db6, 0x1db7, 0x1db8, 0x1db9,   // U+1ed0 ~ U+1ed7
0x1dba, 0x1dbb, 0x1dbc, 0x1dbd, 0x1dbe, 0x1dbf, 0x1dc0, 0x1dc1,   // U+1ed8 ~ U+1edf
0x1dc2, 0x1dc3, 0x1dc4, 0x1dc5, 0x1dc6, 0x1dc7, 0x1dc8, 0x1dc9,   // U+1ee0 ~ U+1ee7
0x1dca, 0x1dcb, 0x1dcc, 0x1dcd, 0x1dce, 0x1dcf, 0x1dd0, 0x1dd1,   // U+1ee8 ~ U+1eef
0x1dd2, 0x1dd3, 0x1dd4, 0x1dd5, 0x1dd6, 0x1dd7, 0x1dd8, 0x1dd9,   // U+1ef0 ~ U+1ef7
0x1dda, 0x1ddb, 0x1ddc, 0x1ddd, 0x1dde, 0x1ddf, 0x1de0, 0x1de1,   // U+1ef8 ~ U+1eff
0x1de2, 0x1de3, 0x1de4, 0x1de5, 0x1de6, 0x1de7, 0x1de8, 0x1de9,   // U+1f00 ~ U+1f07
0x1dea, 0x1deb, 0x1dec, 0x1ded, 0x1dee, 0x1def, 0x1df0, 0x1df1,   // U+1f08 ~ U+1f0f
0x1df2, 0x1df3, 0x1df4, 0x1df5, 0x1df6, 0x1df7, 0x1df8, 0x1df9,   // U+1f10 ~ U+1f17
0x1dfa, 0x1dfb, 0x1dfc, 0x1dfd, 0x1dfe, 0x1dff, 0x1e00, 0x1e01,   // U+1f18 ~ U+1f1f
0x1e02, 0x1e03, 0x1e04, 0x1e05, 0x1e06, 0x1e07, 0x1e08, 0x1e09,   // U+1f20 ~ U+1f27
0x1e0a, 0x1e0b, 0x1e0c, 0x1e0d, 0x1e0e, 0x1e0f, 0x1e10, 0x1e11,   // U+1f28 ~ U+1f2f
0x1e12, 0x1e13, 0x1e14, 0x1e15, 0x1e16, 0x1e17, 0x1e18, 0x1e19,   // U+1f30 ~ U+1f37
0x1e1a, 0x1e1b, 0x1e1c, 0x1e1d, 0x1e1e, 0x1e1f, 0x1e20, 0x1e21,   // U+1f38 ~ U+1f3f
0x1e22, 0x1e23, 0x1e24, 0x1e25, 0x1e26, 0x1e27, 0x1e28, 0x1e29,   // U+1f40 ~ U+1f47
0x1e2a, 0x1e2b, 0x1e2c, 0x1e2d, 0x1e2e, 0x1e2f, 0x1e30, 0x1e31,   // U+1f48 ~ U+1f4f
0x1e32, 0x1e33, 0x1e34, 0x1e35, 0x1e36, 0x1e37, 0x1e38, 0x1e39,   // U+1f50 ~ U+1f57
0x1e3a, 0x1e3b, 0x1e3c, 0x1e3d, 0x1e3e, 0x1e3f, 0x1e40, 0x1e41,   // U+1f58 ~ U+1f5f
0x1e42, 0x1e43, 0x1e44, 0x1e45, 0x1e46, 0x1e47, 0x1e48, 0x1e49,   // U+1f60 ~ U+1f67
0x1e4a, 0x1e4b, 0x1e4c, 0x1e4d, 0x1e4e, 0x1e4f, 0x1e50, 0x1e51,   // U+1f68 ~ U+1f6f
0x1e52, 0x1e53, 0x1e54, 0x1e55, 0x1e56, 0x1e57, 0x1e58, 0x1e59,   // U+1f70 ~ U+1f77
0x1e5a, 0x1e5b, 0x1e5c, 0x1e5d, 0x1e5e, 0x1e5f, 0x1e60, 0x1e61,   // U+1f78 ~ U+1f7f
0x1e62, 0x1e63, 0x1e64, 0x1e65, 0x1e66, 0x1e67, 0x1e68, 0x1e69,   // U+1f80 ~ U+1f87
0x1e6a, 0x1e6b, 0x1e6c, 0x1e6d, 0x1e6e, 0x1e6f, 0x1e70, 0x1e71,   // U+1f88 ~ U+1f8f
0x1e72, 0x1e73, 0x1e74, 0x1e75, 0x1e76, 0x1e77, 0x1e78, 0x1e79,   // U+1f90 ~ U+1f97
0x1e7a, 0x1e7b, 0x1e7c, 0x1e7d, 0x1e7e, 0x1e7f, 0x1e80, 0x1e81,   // U+1f98 ~ U+1f9f
0x1e82, 0x1e83, 0x1e84, 0x1e85, 0x1e86, 0x1e87, 0x1e88, 0x1e89,   // U+1fa0 ~ U+1fa7
0x1e8a, 0x1e8b, 0x1e8c, 0x1e8d, 0x1e8e, 0x1e8f, 0x1e90, 0x1e91,   // U+1fa8 ~ U+1faf
0x1e92, 0x1e93, 0x1e94, 0x1e95, 0x1e96, 0x1e97, 0x1e98, 0x1e99,   // U+1fb0 ~ U+1fb7
0x1e9a, 0x1e9b, 0x1e9c, 0x1e9d, 0x1e9e, 0x1e9f, 0x1ea0, 0x1ea1,   // U+1fb8 ~ U+1fbf
0x1ea2, 0x1ea3, 0x1ea4, 0x1ea5, 0x1ea6, 0x1ea7, 0x1ea8, 0x1ea9,   // U+1fc0 ~ U+1fc7
0x1eaa, 0x1eab, 0x1eac, 0x1ead, 0x1eae, 0x1eaf, 0x1eb0, 0x1eb1,   // U+1fc8 ~ U+1fcf
0x1eb2, 0x1eb3, 0x1eb4, 0x1eb5, 0x1eb6, 0x1eb7, 0x1eb8, 0x1eb9,   // U+1fd0 ~ U+1fd7
0x1eba, 0x1ebb, 0x1ebc, 0x1ebd, 0x1ebe, 0x1ebf, 0x1ec0, 0x1ec1,   // U+1fd8 ~ U+1fdf
0x1ec2, 0x1ec3, 0x1ec4, 0x1ec5, 0x1ec6, 0x1ec7, 0x1ec8, 0x1ec9,   // U+1fe0 ~ U+1fe7
0x1eca, 0x1ecb, 0x1ecc, 0x1ecd, 0x1ece, 0x1ecf, 0x1ed0, 0x1ed1,   // U+1fe8 ~ U+1fef
0x1ed2, 0x1ed3, 0x1ed4, 0x1ed5, 0x1ed6, 0x1ed7, 0x1ed8, 0x1ed9,   // U+1ff0 ~ U+1ff7
0x1eda, 0x1edb, 0x1edc, 0x1edd, 0x1ede, 0x1edf, 0x1ee0, 0x1ee1,   // U+1ff8 ~ U+1fff
0x1ee2, 0x1ee3, 0x1ee4, 0x1ee5, 0x1ee6, 0x1ee7, 0x1ee8, 0x1ee9,   // U+2000 ~ U+2007
0x1eea, 0x1eeb, 0x1eec, 0x1eed, 0x1eee, 0x1eef, 0x1ef0, 0x1ef1,   // U+2008 ~ U+200f
0xffff, 0x1ef2, 0x1ef3, 0xffff, 0xffff, 0xffff, 0xffff, 0x1ef4,   // U+2010 ~ U+2017
0xffff, 0xffff, 0x1ef5, 0x1ef6, 0xffff, 0xffff, 0x1ef7, 0x1ef8,   // U+2018 ~ U+201f
0x1ef9, 0x1efa, 0x1efb, 0x1efc, 0x1efd, 0xffff, 0xffff, 0x1efe,   // U+2020 ~ U+2027
0x1eff, 0x1f00, 0x1f01, 0x1f02, 0x1f03, 0x1f04, 0x1f05, 0x1f06,   // U+2028 ~ U+202f
0xffff, 0x1f07, 0xffff, 0xffff, 0x1f08, 0xffff, 0x1f09, 0x1f0a,   // U+2030 ~ U+2037
0x1f0b, 0x1f0c, 0x1f0d, 0xffff, 0x1f0e, 0x1f0f, 0x1f10, 0x1f11,   // U+2038 ~ U+203f
0x1f12, 0x1f13, 0x1f14, 0x1f15, 0x1f16, 0x1f17, 0x1f18, 0x1f19,   // U+2040 ~ U+2047
0x1f1a, 0x1f1b, 0x1f1c, 0x1f1d, 0x1f1e, 0x1f1f, 0x1f20, 0x1f21,   // U+2048 ~ U+204f
0x1f22, 0x1f23, 0x1f24, 0x1f25, 0x1f26, 0x1f27, 0x1f28, 0x1f29,   // U+2050 ~ U+2057
0x1f2a, 0x1f2b, 0x1f2c, 0x1f2d, 0x1f2e, 0x1f2f, 0x1f30, 0x1f31,   // U+2058 ~ U+205f
0x1f32, 0x1f33, 0x1f34, 0x1f35, 0x1f36, 0x1f37, 0x1f38, 0x1f39,   // U+2060 ~ U+2067
0x1f3a, 0x1f3b, 0x1f3c, 0x1f3d, 0x1f3e, 0x1f3f, 0x1f40, 0x1f41,   // U+2068 ~ U+206f
0x1f42, 0x1f43, 0x1f44, 0x1f45, 0x1f46, 0x1f47, 0x1f48, 0x1f49,   // U+2070 ~ U+2077
0x1f4a, 0x1f4b, 0x1f4c, 0x1f4d, 0x1f4e, 0x1f4f, 0x1f50, 0x1f51,   // U+2078 ~ U+207f
0x1f52, 0x1f53, 0x1f54, 0x1f55, 0x1f56, 0x1f57, 0x1f58, 0x1f59,   // U+2080 ~ U+2087
0x1f5a, 0x1f5b, 0x1f5c, 0x1f5d, 0x1f5e, 0x1f5f, 0x1f60, 0x1f61,   // U+2088 ~ U+208f
0x1f62, 0x1f63, 0x1f64, 0x1f65, 0x1f66, 0x1f67, 0x1f68, 0x1f69,   // U+2090 ~ U+2097
0x1f6a, 0x1f6b, 0x1f6c, 0x1f6d, 0x1f6e, 0x1f6f, 0x1f70, 0x1f71,   // U+2098 ~ U+209f
0x1f72, 0x1f73, 0x1f74, 0x1f75, 0x1f76, 0x1f77, 0x1f78, 0x1f79,   // U+20a0 ~ U+20a7
0x1f7a, 0x1f7b, 0x1f7c, 0x1f7d, 0xfffd, 0x1f7e, 0x1f7f, 0x1f80,   // U+20a8 ~ U+20af
0x1f81, 0x1f82, 0x1f83, 0x1f84, 0x1f85, 0x1f86, 0x1f87, 0x1f88,   // U+20b0 ~ U+20b7
0x1f89, 0x1f8a, 0x1f8b, 0x1f8c, 0x1f8d, 0x1f8e, 0x1f8f, 0x1f90,   // U+20b8 ~ U+20bf
0x1f91, 0x1f92, 0x1f93, 0x1f94, 0x1f95, 0x1f96, 0x1f97, 0x1f98,   // U+20c0 ~ U+20c7
0x1f99, 0x1f9a, 0x1f9b, 0x1f9c, 0x1f9d, 0x1f9e, 0x1f9f, 0x1fa0,   // U+20c8 ~ U+20cf
0x1fa1, 0x1fa2, 0x1fa3, 0x1fa4, 0x1fa5, 0x1fa6, 0x1fa7, 0x1fa8,   // U+20d0 ~ U+20d7
0x1fa9, 0x1faa, 0x1fab, 0x1fac, 0x1fad, 0x1fae, 0x1faf, 0x1fb0,   // U+20d8 ~ U+20df
0x1fb1, 0x1fb2, 0x1fb3, 0x1fb4, 0x1fb5, 0x1fb6, 0x1fb7, 0x1fb8,   // U+20e0 ~ U+20e7
0x1fb9, 0x1fba, 0x1fbb, 0x1fbc, 0x1fbd, 0x1fbe, 0x1fbf, 0x1fc0,   // U+20e8 ~ U+20ef
0x1fc1, 0x1fc2, 0x1fc3, 0x1fc4, 0x1fc5, 0x1fc6, 0x1fc7, 0x1fc8,   // U+20f0 ~ U+20f7
0x1fc9, 0x1fca, 0x1fcb, 0x1fcc, 0x1fcd, 0x1fce, 0x1fcf, 0x1fd0,   // U+20f8 ~ U+20ff
0x1fd1, 0x1fd2, 0x1fd3, 0xffff, 0x1fd4, 0xffff, 0x1fd5, 0x1fd6,   // U+2100 ~ U+2107
0x1fd7, 0xffff, 0x1fd8, 0x1fd9, 0x1fda, 0x1fdb, 0x1fdc, 0x1fdd,   // U+2108 ~ U+210f
0x1fde, 0x1fdf, 0x1fe0, 0x1fe1, 0x1fe2, 0x1fe3, 0xffff, 0x1fe4,   // U+2110 ~ U+2117
0x1fe5, 0x1fe6, 0x1fe7, 0x1fe8, 0x1fe9, 0x1fea, 0x1feb, 0x1fec,   // U+2118 ~ U+211f
0x1fed, 0xffff, 0x1fee, 0x1fef, 0x1ff0, 0x1ff1, 0x1ff2, 0x1ff3,   // U+2120 ~ U+2127
0x1ff4, 0x1ff5, 0x1ff6, 0x1ff7, 0x1ff8, 0x1ff9, 0x1ffa, 0x1ffb,   // U+2128 ~ U+212f
0x1ffc, 0x1ffd, 0x1ffe, 0x1fff, 0x2000, 0x2001, 0x2002, 0x2003,   // U+2130 ~ U+2137
0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200a, 0x200b,   // U+2138 ~ U+213f
0x200c, 0x200d, 0x200e, 0x200f, 0x2010, 0x2011, 0x2012, 0x2013,   // U+2140 ~ U+2147
0x2014, 0x2015, 0x2016, 0x2017, 0x2018, 0x2019, 0x201a, 0x201b,   // U+2148 ~ U+214f
0x201c, 0x201d, 0x201e, 0x201f, 0x2020, 0x2021, 0x2022, 0x2023,   // U+2150 ~ U+2157
0x2024, 0x2025, 0x2026, 0x2027, 0x2028, 0x2029, 0x202a, 0x202b,   // U+2158 ~ U+215f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+2160 ~ U+2167
0xffff, 0xffff, 0xffff, 0xffff, 0x202c, 0x202d, 0x202e, 0x202f,   // U+2168 ~ U+216f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+2170 ~ U+2177
0xffff, 0xffff, 0x2030, 0x2031, 0x2032, 0x2033, 0x2034, 0x2035,   // U+2178 ~ U+217f
0x2036, 0x2037, 0x2038, 0x2039, 0x203a, 0x203b, 0x203c, 0x203d,   // U+2180 ~ U+2187
0x203e, 0x203f, 0x2040, 0x2041, 0x2042, 0x2043, 0x2044, 0x2045,   // U+2188 ~ U+218f
0xffff, 0xffff, 0xffff, 0xffff, 0x2046, 0x2047, 0xffff, 0xffff,   // U+2190 ~ U+2197
0xffff, 0xffff, 0x2048, 0x2049, 0x204a, 0x204b, 0x204c, 0x204d,   // U+2198 ~ U+219f
0x204e, 0x204f, 0x2050, 0x2051, 0x2052, 0x2053, 0x2054, 0x2055,   // U+21a0 ~ U+21a7
0x2056, 0x2057, 0x2058, 0x2059, 0x205a, 0x205b, 0x205c, 0x205d,   // U+21a8 ~ U+21af
0x205e, 0x205f, 0x2060, 0x2061, 0x2062, 0x2063, 0x2064, 0x2065,   // U+21b0 ~ U+21b7
0x2066, 0x2067, 0x2068, 0x2069, 0x206a, 0x206b, 0x206c, 0x206d,   // U+21b8 ~ U+21bf
0x206e, 0x206f, 0x2070, 0x2071, 0x2072, 0x2073, 0x2074, 0x2075,   // U+21c0 ~ U+21c7
0x2076, 0x2077, 0x2078, 0x2079, 0x207a, 0x207b, 0x207c, 0x207d,   // U+21c8 ~ U+21cf
0x207e, 0x207f, 0x2080, 0x2081, 0x2082, 0x2083, 0x2084, 0x2085,   // U+21d0 ~ U+21d7
0x2086, 0x2087, 0x2088, 0x2089, 0x208a, 0x208b, 0x208c, 0x208d,   // U+21d8 ~ U+21df
0x208e, 0x208f, 0x2090, 0x2091, 0x2092, 0x2093, 0x2094, 0x2095,   // U+21e0 ~ U+21e7
0x2096, 0x2097, 0x2098, 0x2099, 0x209a, 0x209b, 0x209c, 0x209d,   // U+21e8 ~ U+21ef
0x209e, 0x209f, 0x20a0, 0x20a1, 0x20a2, 0x20a3, 0x20a4, 0x20a5,   // U+21f0 ~ U+21f7
0x20a6, 0x20a7, 0x20a8, 0x20a9, 0x20aa, 0x20ab, 0x20ac, 0x20ad,   // U+21f8 ~ U+21ff
0x20ae, 0x20af, 0x20b0, 0x20b1, 0x20b2, 0x20b3, 0x20b4, 0x20b5,   // U+2200 ~ U+2207
0xffff, 0x20b6, 0x20b7, 0x20b8, 0x20b9, 0x20ba, 0x20bb, 0xffff,   // U+2208 ~ U+220f
0x20bc, 0xffff, 0x20bd, 0x20be, 0x20bf, 0xffff, 0x20c0, 0x20c1,   // U+2210 ~ U+2217
0x20c2, 0x20c3, 0xffff, 0x20c4, 0x20c5, 0xffff, 0xffff, 0xffff,   // U+2218 ~ U+221f
0xffff, 0x20c6, 0x20c7, 0xffff, 0x20c8, 0xffff, 0x20c9, 0xffff,   // U+2220 ~ U+2227
0xffff, 0xffff, 0xffff, 0xffff, 0x20ca, 0x20cb, 0xffff, 0x20cc,   // U+2228 ~ U+222f
0x20cd, 0x20ce, 0x20cf, 0x20d0, 0xffff, 0xffff, 0xffff, 0xffff,   // U+2230 ~ U+2237
0x20d1, 0x20d2, 0x20d3, 0x20d4, 0x20d5, 0xffff, 0x20d6, 0x20d7,   // U+2238 ~ U+223f
0x20d8, 0x20d9, 0x20da, 0x20db, 0x20dc, 0x20dd, 0x20de, 0x20df,   // U+2240 ~ U+2247
0xffff, 0x20e0, 0x20e1, 0x20e2, 0xffff, 0x20e3, 0x20e4, 0x20e5,   // U+2248 ~ U+224f
0x20e6, 0x20e7, 0xffff, 0x20e8, 0x20e9, 0x20ea, 0x20eb, 0x20ec,   // U+2250 ~ U+2257
0x20ed, 0x20ee, 0x20ef, 0x20f0, 0x20f1, 0x20f2, 0x20f3, 0x20f4,   // U+2258 ~ U+225f
0xffff, 0xffff, 0x20f5, 0x20f6, 0xffff, 0xffff, 0xffff, 0xffff,   // U+2260 ~ U+2267
0x20f7, 0x20f8, 0x20f9, 0x20fa, 0x20fb, 0x20fc, 0xffff, 0xffff,   // U+2268 ~ U+226f
0x20fd, 0x20fe, 0x20ff, 0x2100, 0x2101, 0x2102, 0x2103, 0x2104,   // U+2270 ~ U+2277
0x2105, 0x2106, 0x2107, 0x2108, 0x2109, 0x210a, 0x210b, 0x210c,   // U+2278 ~ U+227f
0x210d, 0x210e, 0x210f, 0x2110, 0x2111, 0x2112, 0x2113, 0x2114,   // U+2280 ~ U+2287
0x2115, 0x2116, 0x2117, 0x2118, 0x2119, 0x211a, 0x211b, 0x211c,   // U+2288 ~ U+228f
0x211d, 0x211e, 0x211f, 0x2120, 0x2121, 0xffff, 0x2122, 0x2123,   // U+2290 ~ U+2297
0x2124, 0xffff, 0x2125, 0x2126, 0x2127, 0x2128, 0x2129, 0x212a,   // U+2298 ~ U+229f
0x212b, 0x212c, 0x212d, 0x212e, 0x212f, 0xffff, 0x2130, 0x2131,   // U+22a0 ~ U+22a7
0x2132, 0x2133, 0x2134, 0x2135, 0x2136, 0x2137, 0x2138, 0x2139,   // U+22a8 ~ U+22af
0x213a, 0x213b, 0x213c, 0x213d, 0x213e, 0x213f, 0x2140, 0x2141,   // U+22b0 ~ U+22b7
0x2142, 0x2143, 0x2144, 0x2145, 0x2146, 0x2147, 0x2148, 0xffff,   // U+22b8 ~ U+22bf
0x2149, 0x214a, 0x214b, 0x214c, 0x214d, 0x214e, 0x214f, 0x2150,   // U+22c0 ~ U+22c7
0x2151, 0x2152, 0x2153, 0x2154, 0x2155, 0x2156, 0x2157, 0x2158,   // U+22c8 ~ U+22cf
0x2159, 0x215a, 0x215b, 0x215c, 0x215d, 0x215e, 0x215f, 0x2160,   // U+22d0 ~ U+22d7
0x2161, 0x2162, 0x2163, 0x2164, 0x2165, 0x2166, 0x2167, 0x2168,   // U+22d8 ~ U+22df
0x2169, 0x216a, 0x216b, 0x216c, 0x216d, 0x216e, 0x216f, 0x2170,   // U+22e0 ~ U+22e7
0x2171, 0x2172, 0x2173, 0x2174, 0x2175, 0x2176, 0x2177, 0x2178,   // U+22e8 ~ U+22ef
0x2179, 0x217a, 0x217b, 0x217c, 0x217d, 0x217e, 0x217f, 0x2180,   // U+22f0 ~ U+22f7
0x2181, 0x2182, 0x2183, 0x2184, 0x2185, 0x2186, 0x2187, 0x2188,   // U+22f8 ~ U+22ff
0x2189, 0x218a, 0x218b, 0x218c, 0x218d, 0x218e, 0x218f, 0x2190,   // U+2300 ~ U+2307
0x2191, 0x2192, 0x2193, 0x2194, 0x2195, 0x2196, 0x2197, 0x2198,   // U+2308 ~ U+230f
0x2199, 0x219a, 0xffff, 0x219b, 0x219c, 0x219d, 0x219e, 0x219f,   // U+2310 ~ U+2317
0x21a0, 0x21a1, 0x21a2, 0x21a3, 0x21a4, 0x21a5, 0x21a6, 0x21a7,   // U+2318 ~ U+231f
0x21a8, 0x21a9, 0x21aa, 0x21ab, 0x21ac, 0x21ad, 0x21ae, 0x21af,   // U+2320 ~ U+2327
0x21b0, 0x21b1, 0x21b2, 0x21b3, 0x21b4, 0x21b5, 0x21b6, 0x21b7,   // U+2328 ~ U+232f
0x21b8, 0x21b9, 0x21ba, 0x21bb, 0x21bc, 0x21bd, 0x21be, 0x21bf,   // U+2330 ~ U+2337
0x21c0, 0x21c1, 0x21c2, 0x21c3, 0x21c4, 0x21c5, 0x21c6, 0x21c7,   // U+2338 ~ U+233f
0x21c8, 0x21c9, 0x21ca, 0x21cb, 0x21cc, 0x21cd, 0x21ce, 0x21cf,   // U+2340 ~ U+2347
0x21d0, 0x21d1, 0x21d2, 0x21d3, 0x21d4, 0x21d5, 0x21d6, 0x21d7,   // U+2348 ~ U+234f
0x21d8, 0x21d9, 0x21da, 0x21db, 0x21dc, 0x21dd, 0x21de, 0x21df,   // U+2350 ~ U+2357
0x21e0, 0x21e1, 0x21e2, 0x21e3, 0x21e4, 0x21e5, 0x21e6, 0x21e7,   // U+2358 ~ U+235f
0x21e8, 0x21e9, 0x21ea, 0x21eb, 0x21ec, 0x21ed, 0x21ee, 0x21ef,   // U+2360 ~ U+2367
0x21f0, 0x21f1, 0x21f2, 0x21f3, 0x21f4, 0x21f5, 0x21f6, 0x21f7,   // U+2368 ~ U+236f
0x21f8, 0x21f9, 0x21fa, 0x21fb, 0x21fc, 0x21fd, 0x21fe, 0x21ff,   // U+2370 ~ U+2377
0x2200, 0x2201, 0x2202, 0x2203, 0x2204, 0x2205, 0x2206, 0x2207,   // U+2378 ~ U+237f
0x2208, 0x2209, 0x220a, 0x220b, 0x220c, 0x220d, 0x220e, 0x220f,   // U+2380 ~ U+2387
0x2210, 0x2211, 0x2212, 0x2213, 0x2214, 0x2215, 0x2216, 0x2217,   // U+2388 ~ U+238f
0x2218, 0x2219, 0x221a, 0x221b, 0x221c, 0x221d, 0x221e, 0x221f,   // U+2390 ~ U+2397
0x2220, 0x2221, 0x2222, 0x2223, 0x2224, 0x2225, 0x2226, 0x2227,   // U+2398 ~ U+239f
0x2228, 0x2229, 0x222a, 0x222b, 0x222c, 0x222d, 0x222e, 0x222f,   // U+23a0 ~ U+23a7
0x2230, 0x2231, 0x2232, 0x2233, 0x2234, 0x2235, 0x2236, 0x2237,   // U+23a8 ~ U+23af
0x2238, 0x2239, 0x223a, 0x223b, 0x223c, 0x223d, 0x223e, 0x223f,   // U+23b0 ~ U+23b7
0x2240, 0x2241, 0x2242, 0x2243, 0x2244, 0x2245, 0x2246, 0x2247,   // U+23b8 ~ U+23bf
0x2248, 0x2249, 0x224a, 0x224b, 0x224c, 0x224d, 0x224e, 0x224f,   // U+23c0 ~ U+23c7
0x2250, 0x2251, 0x2252, 0x2253, 0x2254, 0x2255, 0x2256, 0x2257,   // U+23c8 ~ U+23cf
0x2258, 0x2259, 0x225a, 0x225b, 0x225c, 0x225d, 0x225e, 0x225f,   // U+23d0 ~ U+23d7
0x2260, 0x2261, 0x2262, 0x2263, 0x2264, 0x2265, 0x2266, 0x2267,   // U+23d8 ~ U+23df
0x2268, 0x2269, 0x226a, 0x226b, 0x226c, 0x226d, 0x226e, 0x226f,   // U+23e0 ~ U+23e7
0x2270, 0x2271, 0x2272, 0x2273, 0x2274, 0x2275, 0x2276, 0x2277,   // U+23e8 ~ U+23ef
0x2278, 0x2279, 0x227a, 0x227b, 0x227c, 0x227d, 0x227e, 0x227f,   // U+23f0 ~ U+23f7
0x2280, 0x2281, 0x2282, 0x2283, 0x2284, 0x2285, 0x2286, 0x2287,   // U+23f8 ~ U+23ff
0x2288, 0x2289, 0x228a, 0x228b, 0x228c, 0x228d, 0x228e, 0x228f,   // U+2400 ~ U+2407
0x2290, 0x2291, 0x2292, 0x2293, 0x2294, 0x2295, 0x2296, 0x2297,   // U+2408 ~ U+240f
0x2298, 0x2299, 0x229a, 0x229b, 0x229c, 0x229d, 0x229e, 0x229f,   // U+2410 ~ U+2417
0x22a0, 0x22a1, 0x22a2, 0x22a3, 0x22a4, 0x22a5, 0x22a6, 0x22a7,   // U+2418 ~ U+241f
0x22a8, 0x22a9, 0x22aa, 0x22ab, 0x22ac, 0x22ad, 0x22ae, 0x22af,   // U+2420 ~ U+2427
0x22b0, 0x22b1, 0x22b2, 0x22b3, 0x22b4, 0x22b5, 0x22b6, 0x22b7,   // U+2428 ~ U+242f
0x22b8, 0x22b9, 0x22ba, 0x22bb, 0x22bc, 0x22bd, 0x22be, 0x22bf,   // U+2430 ~ U+2437
0x22c0, 0x22c1, 0x22c2, 0x22c3, 0x22c4, 0x22c5, 0x22c6, 0x22c7,   // U+2438 ~ U+243f
0x22c8, 0x22c9, 0x22ca, 0x22cb, 0x22cc, 0x22cd, 0x22ce, 0x22cf,   // U+2440 ~ U+2447
0x22d0, 0x22d1, 0x22d2, 0x22d3, 0x22d4, 0x22d5, 0x22d6, 0x22d7,   // U+2448 ~ U+244f
0x22d8, 0x22d9, 0x22da, 0x22db, 0x22dc, 0x22dd, 0x22de, 0x22df,   // U+2450 ~ U+2457
0x22e0, 0x22e1, 0x22e2, 0x22e3, 0x22e4, 0x22e5, 0x22e6, 0x22e7,   // U+2458 ~ U+245f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+2460 ~ U+2467
0xffff, 0xffff, 0x22e8, 0x22e9, 0x22ea, 0x22eb, 0x22ec, 0x22ed,   // U+2468 ~ U+246f
0x22ee, 0x22ef, 0x22f0, 0x22f1, 0xffff, 0xffff, 0xffff, 0xffff,   // U+2470 ~ U+2477
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+2478 ~ U+247f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+2480 ~ U+2487
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+2488 ~ U+248f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+2490 ~ U+2497
0xffff, 0xffff, 0xffff, 0xffff, 0x22f2, 0x22f3, 0x22f4, 0x22f5,   // U+2498 ~ U+249f
0x22f6, 0x22f7, 0x22f8, 0x22f9, 0x22fa, 0x22fb, 0x22fc, 0x22fd,   // U+24a0 ~ U+24a7
0x22fe, 0x22ff, 0x2300, 0x2301, 0x2302, 0x2303, 0x2304, 0x2305,   // U+24a8 ~ U+24af
0x2306, 0x2307, 0x2308, 0x2309, 0x230a, 0x230b, 0x230c, 0x230d,   // U+24b0 ~ U+24b7
0x230e, 0x230f, 0x2310, 0x2311, 0x2312, 0x2313, 0x2314, 0x2315,   // U+24b8 ~ U+24bf
0x2316, 0x2317, 0x2318, 0x2319, 0x231a, 0x231b, 0x231c, 0x231d,   // U+24c0 ~ U+24c7
0x231e, 0x231f, 0x2320, 0x2321, 0x2322, 0x2323, 0x2324, 0x2325,   // U+24c8 ~ U+24cf
0x2326, 0x2327, 0x2328, 0x2329, 0x232a, 0x232b, 0x232c, 0x232d,   // U+24d0 ~ U+24d7
0x232e, 0x232f, 0x2330, 0x2331, 0x2332, 0x2333, 0x2334, 0x2335,   // U+24d8 ~ U+24df
0x2336, 0x2337, 0x2338, 0x2339, 0x233a, 0x233b, 0x233c, 0x233d,   // U+24e0 ~ U+24e7
0x233e, 0x233f, 0x2340, 0x2341, 0x2342, 0x2343, 0x2344, 0x2345,   // U+24e8 ~ U+24ef
0x2346, 0x2347, 0x2348, 0x2349, 0x234a, 0x234b, 0x234c, 0x234d,   // U+24f0 ~ U+24f7
0x234e, 0x234f, 0x2350, 0x2351, 0x2352, 0x2353, 0x2354, 0x2355,   // U+24f8 ~ U+24ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+2500 ~ U+2507
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+2508 ~ U+250f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+2510 ~ U+2517
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+2518 ~ U+251f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+2520 ~ U+2527
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+2528 ~ U+252f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+2530 ~ U+2537
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+2538 ~ U+253f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+2540 ~ U+2547
0xffff, 0xffff, 0xffff, 0xffff, 0x2356, 0x2357, 0x2358, 0x2359,   // U+2548 ~ U+254f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+2550 ~ U+2557
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+2558 ~ U+255f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+2560 ~ U+2567
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+2568 ~ U+256f
0xffff, 0xffff, 0xffff, 0xffff, 0x235a, 0x235b, 0x235c, 0x235d,   // U+2570 ~ U+2577
0x235e, 0x235f, 0x2360, 0x2361, 0x2362, 0x2363, 0x2364, 0x2365,   // U+2578 ~ U+257f
0x2366, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+2580 ~ U+2587
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+2588 ~ U+258f
0x2367, 0x2368, 0x2369, 0xffff, 0xffff, 0xffff, 0x236a, 0x236b,   // U+2590 ~ U+2597
0x236c, 0x236d, 0x236e, 0x236f, 0x2370, 0x2371, 0x2372, 0x2373,   // U+2598 ~ U+259f
0xffff, 0xffff, 0x2374, 0x2375, 0x2376, 0x2377, 0x2378, 0x2379,   // U+25a0 ~ U+25a7
0x237a, 0x237b, 0x237c, 0x237d, 0x237e, 0x237f, 0x2380, 0x2381,   // U+25a8 ~ U+25af
0x2382, 0x2383, 0xffff, 0xffff, 0x2384, 0x2385, 0x2386, 0x2387,   // U+25b0 ~ U+25b7
0x2388, 0x2389, 0x238a, 0x238b, 0xffff, 0xffff, 0x238c, 0x238d,   // U+25b8 ~ U+25bf
0x238e, 0x238f, 0x2390, 0x2391, 0x2392, 0x2393, 0xffff, 0xffff,   // U+25c0 ~ U+25c7
0x2394, 0x2395, 0x2396, 0xffff, 0x2397, 0x2398, 0xffff, 0xffff,   // U+25c8 ~ U+25cf
0x2399, 0x239a, 0x239b, 0x239c, 0x239d, 0x239e, 0x239f, 0x23a0,   // U+25d0 ~ U+25d7
0x23a1, 0x23a2, 0x23a3, 0x23a4, 0x23a5, 0x23a6, 0x23a7, 0x23a8,   // U+25d8 ~ U+25df
0x23a9, 0x23aa, 0xffff, 0xffff, 0xffff, 0xffff, 0x23ab, 0x23ac,   // U+25e0 ~ U+25e7
0x23ad, 0x23ae, 0x23af, 0x23b0, 0x23b1, 0x23b2, 0x23b3, 0x23b4,   // U+25e8 ~ U+25ef
0x23b5, 0x23b6, 0x23b7, 0x23b8, 0x23b9, 0x23ba, 0x23bb, 0x23bc,   // U+25f0 ~ U+25f7
0x23bd, 0x23be, 0x23bf, 0x23c0, 0x23c1, 0x23c2, 0x23c3, 0x23c4,   // U+25f8 ~ U+25ff
0x23c5, 0x23c6, 0x23c7, 0x23c8, 0x23c9, 0xffff, 0xffff, 0x23ca,   // U+2600 ~ U+2607
0x23cb, 0xffff, 0x23cc, 0x23cd, 0x23ce, 0x23cf, 0x23d0, 0x23d1,   // U+2608 ~ U+260f
0x23d2, 0x23d3, 0x23d4, 0x23d5, 0x23d6, 0x23d7, 0x23d8, 0x23d9,   // U+2610 ~ U+2617
0x23da, 0x23db, 0x23dc, 0x23dd, 0x23de, 0x23df, 0x23e0, 0x23e1,   // U+2618 ~ U+261f
0x23e2, 0x23e3, 0x23e4, 0x23e5, 0x23e6, 0x23e7, 0x23e8, 0x23e9,   // U+2620 ~ U+2627
0x23ea, 0x23eb, 0x23ec, 0x23ed, 0x23ee, 0x23ef, 0x23f0, 0x23f1,   // U+2628 ~ U+262f
0x23f2, 0x23f3, 0x23f4, 0x23f5, 0x23f6, 0x23f7, 0x23f8, 0x23f9,   // U+2630 ~ U+2637
0x23fa, 0x23fb, 0x23fc, 0x23fd, 0x23fe, 0x23ff, 0x2400, 0x2401,   // U+2638 ~ U+263f
0xffff, 0x2402, 0xffff, 0x2403, 0x2404, 0x2405, 0x2406, 0x2407,   // U+2640 ~ U+2647
0x2408, 0x2409, 0x240a, 0x240b, 0x240c, 0x240d, 0x240e, 0x240f,   // U+2648 ~ U+264f
0x2410, 0x2411, 0x2412, 0x2413, 0x2414, 0x2415, 0x2416, 0x2417,   // U+2650 ~ U+2657
0x2418, 0x2419, 0x241a, 0x241b, 0x241c, 0x241d, 0x241e, 0x241f,   // U+2658 ~ U+265f
0x2420, 0x2421, 0x2422, 0x2423, 0x2424, 0x2425, 0x2426, 0x2427,   // U+2660 ~ U+2667
0x2428, 0x2429, 0x242a, 0x242b, 0x242c, 0x242d, 0x242e, 0x242f,   // U+2668 ~ U+266f
0x2430, 0x2431, 0x2432, 0x2433, 0x2434, 0x2435, 0x2436, 0x2437,   // U+2670 ~ U+2677
0x2438, 0x2439, 0x243a, 0x243b, 0x243c, 0x243d, 0x243e, 0x243f,   // U+2678 ~ U+267f
0x2440, 0x2441, 0x2442, 0x2443, 0x2444, 0x2445, 0x2446, 0x2447,   // U+2680 ~ U+2687
0x2448, 0x2449, 0x244a, 0x244b, 0x244c, 0x244d, 0x244e, 0x244f,   // U+2688 ~ U+268f
0x2450, 0x2451, 0x2452, 0x2453, 0x2454, 0x2455, 0x2456, 0x2457,   // U+2690 ~ U+2697
0x2458, 0x2459, 0x245a, 0x245b, 0x245c, 0x245d, 0x245e, 0x245f,   // U+2698 ~ U+269f
0x2460, 0x2461, 0x2462, 0x2463, 0x2464, 0x2465, 0x2466, 0x2467,   // U+26a0 ~ U+26a7
0x2468, 0x2469, 0x246a, 0x246b, 0x246c, 0x246d, 0x246e, 0x246f,   // U+26a8 ~ U+26af
0x2470, 0x2471, 0x2472, 0x2473, 0x2474, 0x2475, 0x2476, 0x2477,   // U+26b0 ~ U+26b7
0x2478, 0x2479, 0x247a, 0x247b, 0x247c, 0x247d, 0x247e, 0x247f,   // U+26b8 ~ U+26bf
0x2480, 0x2481, 0x2482, 0x2483, 0x2484, 0x2485, 0x2486, 0x2487,   // U+26c0 ~ U+26c7
0x2488, 0x2489, 0x248a, 0x248b, 0x248c, 0x248d, 0x248e, 0x248f,   // U+26c8 ~ U+26cf
0x2490, 0x2491, 0x2492, 0x2493, 0x2494, 0x2495, 0x2496, 0x2497,   // U+26d0 ~ U+26d7
0x2498, 0x2499, 0x249a, 0x249b, 0x249c, 0x249d, 0x249e, 0x249f,   // U+26d8 ~ U+26df
0x24a0, 0x24a1, 0x24a2, 0x24a3, 0x24a4, 0x24a5, 0x24a6, 0x24a7,   // U+26e0 ~ U+26e7
0x24a8, 0x24a9, 0x24aa, 0x24ab, 0x24ac, 0x24ad, 0x24ae, 0x24af,   // U+26e8 ~ U+26ef
0x24b0, 0x24b1, 0x24b2, 0x24b3, 0x24b4, 0x24b5, 0x24b6, 0x24b7,   // U+26f0 ~ U+26f7
0x24b8, 0x24b9, 0x24ba, 0x24bb, 0x24bc, 0x24bd, 0x24be, 0x24bf,   // U+26f8 ~ U+26ff
0x24c0, 0x24c1, 0x24c2, 0x24c3, 0x24c4, 0x24c5, 0x24c6, 0x24c7,   // U+2700 ~ U+2707
0x24c8, 0x24c9, 0x24ca, 0x24cb, 0x24cc, 0x24cd, 0x24ce, 0x24cf,   // U+2708 ~ U+270f
0x24d0, 0x24d1, 0x24d2, 0x24d3, 0x24d4, 0x24d5, 0x24d6, 0x24d7,   // U+2710 ~ U+2717
0x24d8, 0x24d9, 0x24da, 0x24db, 0x24dc, 0x24dd, 0x24de, 0x24df,   // U+2718 ~ U+271f
0x24e0, 0x24e1, 0x24e2, 0x24e3, 0x24e4, 0x24e5, 0x24e6, 0x24e7,   // U+2720 ~ U+2727
0x24e8, 0x24e9, 0x24ea, 0x24eb, 0x24ec, 0x24ed, 0x24ee, 0x24ef,   // U+2728 ~ U+272f
0x24f0, 0x24f1, 0x24f2, 0x24f3, 0x24f4, 0x24f5, 0x24f6, 0x24f7,   // U+2730 ~ U+2737
0x24f8, 0x24f9, 0x24fa, 0x24fb, 0x24fc, 0x24fd, 0x24fe, 0x24ff,   // U+2738 ~ U+273f
0x2500, 0x2501, 0x2502, 0x2503, 0x2504, 0x2505, 0x2506, 0x2507,   // U+2740 ~ U+2747
0x2508, 0x2509, 0x250a, 0x250b, 0x250c, 0x250d, 0x250e, 0x250f,   // U+2748 ~ U+274f
0x2510, 0x2511, 0x2512, 0x2513, 0x2514, 0x2515, 0x2516, 0x2517,   // U+2750 ~ U+2757
0x2518, 0x2519, 0x251a, 0x251b, 0x251c, 0x251d, 0x251e, 0x251f,   // U+2758 ~ U+275f
0x2520, 0x2521, 0x2522, 0x2523, 0x2524, 0x2525, 0x2526, 0x2527,   // U+2760 ~ U+2767
0x2528, 0x2529, 0x252a, 0x252b, 0x252c, 0x252d, 0x252e, 0x252f,   // U+2768 ~ U+276f
0x2530, 0x2531, 0x2532, 0x2533, 0x2534, 0x2535, 0x2536, 0x2537,   // U+2770 ~ U+2777
0x2538, 0x2539, 0x253a, 0x253b, 0x253c, 0x253d, 0x253e, 0x253f,   // U+2778 ~ U+277f
0x2540, 0x2541, 0x2542, 0x2543, 0x2544, 0x2545, 0x2546, 0x2547,   // U+2780 ~ U+2787
0x2548, 0x2549, 0x254a, 0x254b, 0x254c, 0x254d, 0x254e, 0x254f,   // U+2788 ~ U+278f
0x2550, 0x2551, 0x2552, 0x2553, 0x2554, 0x2555, 0x2556, 0x2557,   // U+2790 ~ U+2797
0x2558, 0x2559, 0x255a, 0x255b, 0x255c, 0x255d, 0x255e, 0x255f,   // U+2798 ~ U+279f
0x2560, 0x2561, 0x2562, 0x2563, 0x2564, 0x2565, 0x2566, 0x2567,   // U+27a0 ~ U+27a7
0x2568, 0x2569, 0x256a, 0x256b, 0x256c, 0x256d, 0x256e, 0x256f,   // U+27a8 ~ U+27af
0x2570, 0x2571, 0x2572, 0x2573, 0x2574, 0x2575, 0x2576, 0x2577,   // U+27b0 ~ U+27b7
0x2578, 0x2579, 0x257a, 0x257b, 0x257c, 0x257d, 0x257e, 0x257f,   // U+27b8 ~ U+27bf
0x2580, 0x2581, 0x2582, 0x2583, 0x2584, 0x2585, 0x2586, 0x2587,   // U+27c0 ~ U+27c7
0x2588, 0x2589, 0x258a, 0x258b, 0x258c, 0x258d, 0x258e, 0x258f,   // U+27c8 ~ U+27cf
0x2590, 0x2591, 0x2592, 0x2593, 0x2594, 0x2595, 0x2596, 0x2597,   // U+27d0 ~ U+27d7
0x2598, 0x2599, 0x259a, 0x259b, 0x259c, 0x259d, 0x259e, 0x259f,   // U+27d8 ~ U+27df
0x25a0, 0x25a1, 0x25a2, 0x25a3, 0x25a4, 0x25a5, 0x25a6, 0x25a7,   // U+27e0 ~ U+27e7
0x25a8, 0x25a9, 0x25aa, 0x25ab, 0x25ac, 0x25ad, 0x25ae, 0x25af,   // U+27e8 ~ U+27ef
0x25b0, 0x25b1, 0x25b2, 0x25b3, 0x25b4, 0x25b5, 0x25b6, 0x25b7,   // U+27f0 ~ U+27f7
0x25b8, 0x25b9, 0x25ba, 0x25bb, 0x25bc, 0x25bd, 0x25be, 0x25bf,   // U+27f8 ~ U+27ff
0x25c0, 0x25c1, 0x25c2, 0x25c3, 0x25c4, 0x25c5, 0x25c6, 0x25c7,   // U+2800 ~ U+2807
0x25c8, 0x25c9, 0x25ca, 0x25cb, 0x25cc, 0x25cd, 0x25ce, 0x25cf,   // U+2808 ~ U+280f
0x25d0, 0x25d1, 0x25d2, 0x25d3, 0x25d4, 0x25d5, 0x25d6, 0x25d7,   // U+2810 ~ U+2817
0x25d8, 0x25d9, 0x25da, 0x25db, 0x25dc, 0x25dd, 0x25de, 0x25df,   // U+2818 ~ U+281f
0x25e0, 0x25e1, 0x25e2, 0x25e3, 0x25e4, 0x25e5, 0x25e6, 0x25e7,   // U+2820 ~ U+2827
0x25e8, 0x25e9, 0x25ea, 0x25eb, 0x25ec, 0x25ed, 0x25ee, 0x25ef,   // U+2828 ~ U+282f
0x25f0, 0x25f1, 0x25f2, 0x25f3, 0x25f4, 0x25f5, 0x25f6, 0x25f7,   // U+2830 ~ U+2837
0x25f8, 0x25f9, 0x25fa, 0x25fb, 0x25fc, 0x25fd, 0x25fe, 0x25ff,   // U+2838 ~ U+283f
0x2600, 0x2601, 0x2602, 0x2603, 0x2604, 0x2605, 0x2606, 0x2607,   // U+2840 ~ U+2847
0x2608, 0x2609, 0x260a, 0x260b, 0x260c, 0x260d, 0x260e, 0x260f,   // U+2848 ~ U+284f
0x2610, 0x2611, 0x2612, 0x2613, 0x2614, 0x2615, 0x2616, 0x2617,   // U+2850 ~ U+2857
0x2618, 0x2619, 0x261a, 0x261b, 0x261c, 0x261d, 0x261e, 0x261f,   // U+2858 ~ U+285f
0x2620, 0x2621, 0x2622, 0x2623, 0x2624, 0x2625, 0x2626, 0x2627,   // U+2860 ~ U+2867
0x2628, 0x2629, 0x262a, 0x262b, 0x262c, 0x262d, 0x262e, 0x262f,   // U+2868 ~ U+286f
0x2630, 0x2631, 0x2632, 0x2633, 0x2634, 0x2635, 0x2636, 0x2637,   // U+2870 ~ U+2877
0x2638, 0x2639, 0x263a, 0x263b, 0x263c, 0x263d, 0x263e, 0x263f,   // U+2878 ~ U+287f
0x2640, 0x2641, 0x2642, 0x2643, 0x2644, 0x2645, 0x2646, 0x2647,   // U+2880 ~ U+2887
0x2648, 0x2649, 0x264a, 0x264b, 0x264c, 0x264d, 0x264e, 0x264f,   // U+2888 ~ U+288f
0x2650, 0x2651, 0x2652, 0x2653, 0x2654, 0x2655, 0x2656, 0x2657,   // U+2890 ~ U+2897
0x2658, 0x2659, 0x265a, 0x265b, 0x265c, 0x265d, 0x265e, 0x265f,   // U+2898 ~ U+289f
0x2660, 0x2661, 0x2662, 0x2663, 0x2664, 0x2665, 0x2666, 0x2667,   // U+28a0 ~ U+28a7
0x2668, 0x2669, 0x266a, 0x266b, 0x266c, 0x266d, 0x266e, 0x266f,   // U+28a8 ~ U+28af
0x2670, 0x2671, 0x2672, 0x2673, 0x2674, 0x2675, 0x2676, 0x2677,   // U+28b0 ~ U+28b7
0x2678, 0x2679, 0x267a, 0x267b, 0x267c, 0x267d, 0x267e, 0x267f,   // U+28b8 ~ U+28bf
0x2680, 0x2681, 0x2682, 0x2683, 0x2684, 0x2685, 0x2686, 0x2687,   // U+28c0 ~ U+28c7
0x2688, 0x2689, 0x268a, 0x268b, 0x268c, 0x268d, 0x268e, 0x268f,   // U+28c8 ~ U+28cf
0x2690, 0x2691, 0x2692, 0x2693, 0x2694, 0x2695, 0x2696, 0x2697,   // U+28d0 ~ U+28d7
0x2698, 0x2699, 0x269a, 0x269b, 0x269c, 0x269d, 0x269e, 0x269f,   // U+28d8 ~ U+28df
0x26a0, 0x26a1, 0x26a2, 0x26a3, 0x26a4, 0x26a5, 0x26a6, 0x26a7,   // U+28e0 ~ U+28e7
0x26a8, 0x26a9, 0x26aa, 0x26ab, 0x26ac, 0x26ad, 0x26ae, 0x26af,   // U+28e8 ~ U+28ef
0x26b0, 0x26b1, 0x26b2, 0x26b3, 0x26b4, 0x26b5, 0x26b6, 0x26b7,   // U+28f0 ~ U+28f7
0x26b8, 0x26b9, 0x26ba, 0x26bb, 0x26bc, 0x26bd, 0x26be, 0x26bf,   // U+28f8 ~ U+28ff
0x26c0, 0x26c1, 0x26c2, 0x26c3, 0x26c4, 0x26c5, 0x26c6, 0x26c7,   // U+2900 ~ U+2907
0x26c8, 0x26c9, 0x26ca, 0x26cb, 0x26cc, 0x26cd, 0x26ce, 0x26cf,   // U+2908 ~ U+290f
0x26d0, 0x26d1, 0x26d2, 0x26d3, 0x26d4, 0x26d5, 0x26d6, 0x26d7,   // U+2910 ~ U+2917
0x26d8, 0x26d9, 0x26da, 0x26db, 0x26dc, 0x26dd, 0x26de, 0x26df,   // U+2918 ~ U+291f
0x26e0, 0x26e1, 0x26e2, 0x26e3, 0x26e4, 0x26e5, 0x26e6, 0x26e7,   // U+2920 ~ U+2927
0x26e8, 0x26e9, 0x26ea, 0x26eb, 0x26ec, 0x26ed, 0x26ee, 0x26ef,   // U+2928 ~ U+292f
0x26f0, 0x26f1, 0x26f2, 0x26f3, 0x26f4, 0x26f5, 0x26f6, 0x26f7,   // U+2930 ~ U+2937
0x26f8, 0x26f9, 0x26fa, 0x26fb, 0x26fc, 0x26fd, 0x26fe, 0x26ff,   // U+2938 ~ U+293f
0x2700, 0x2701, 0x2702, 0x2703, 0x2704, 0x2705, 0x2706, 0x2707,   // U+2940 ~ U+2947
0x2708, 0x2709, 0x270a, 0x270b, 0x270c, 0x270d, 0x270e, 0x270f,   // U+2948 ~ U+294f
0x2710, 0x2711, 0x2712, 0x2713, 0x2714, 0x2715, 0x2716, 0x2717,   // U+2950 ~ U+2957
0x2718, 0x2719, 0x271a, 0x271b, 0x271c, 0x271d, 0x271e, 0x271f,   // U+2958 ~ U+295f
0x2720, 0x2721, 0x2722, 0x2723, 0x2724, 0x2725, 0x2726, 0x2727,   // U+2960 ~ U+2967
0x2728, 0x2729, 0x272a, 0x272b, 0x272c, 0x272d, 0x272e, 0x272f,   // U+2968 ~ U+296f
0x2730, 0x2731, 0x2732, 0x2733, 0x2734, 0x2735, 0x2736, 0x2737,   // U+2970 ~ U+2977
0x2738, 0x2739, 0x273a, 0x273b, 0x273c, 0x273d, 0x273e, 0x273f,   // U+2978 ~ U+297f
0x2740, 0x2741, 0x2742, 0x2743, 0x2744, 0x2745, 0x2746, 0x2747,   // U+2980 ~ U+2987
0x2748, 0x2749, 0x274a, 0x274b, 0x274c, 0x274d, 0x274e, 0x274f,   // U+2988 ~ U+298f
0x2750, 0x2751, 0x2752, 0x2753, 0x2754, 0x2755, 0x2756, 0x2757,   // U+2990 ~ U+2997
0x2758, 0x2759, 0x275a, 0x275b, 0x275c, 0x275d, 0x275e, 0x275f,   // U+2998 ~ U+299f
0x2760, 0x2761, 0x2762, 0x2763, 0x2764, 0x2765, 0x2766, 0x2767,   // U+29a0 ~ U+29a7
0x2768, 0x2769, 0x276a, 0x276b, 0x276c, 0x276d, 0x276e, 0x276f,   // U+29a8 ~ U+29af
0x2770, 0x2771, 0x2772, 0x2773, 0x2774, 0x2775, 0x2776, 0x2777,   // U+29b0 ~ U+29b7
0x2778, 0x2779, 0x277a, 0x277b, 0x277c, 0x277d, 0x277e, 0x277f,   // U+29b8 ~ U+29bf
0x2780, 0x2781, 0x2782, 0x2783, 0x2784, 0x2785, 0x2786, 0x2787,   // U+29c0 ~ U+29c7
0x2788, 0x2789, 0x278a, 0x278b, 0x278c, 0x278d, 0x278e, 0x278f,   // U+29c8 ~ U+29cf
0x2790, 0x2791, 0x2792, 0x2793, 0x2794, 0x2795, 0x2796, 0x2797,   // U+29d0 ~ U+29d7
0x2798, 0x2799, 0x279a, 0x279b, 0x279c, 0x279d, 0x279e, 0x279f,   // U+29d8 ~ U+29df
0x27a0, 0x27a1, 0x27a2, 0x27a3, 0x27a4, 0x27a5, 0x27a6, 0x27a7,   // U+29e0 ~ U+29e7
0x27a8, 0x27a9, 0x27aa, 0x27ab, 0x27ac, 0x27ad, 0x27ae, 0x27af,   // U+29e8 ~ U+29ef
0x27b0, 0x27b1, 0x27b2, 0x27b3, 0x27b4, 0x27b5, 0x27b6, 0x27b7,   // U+29f0 ~ U+29f7
0x27b8, 0x27b9, 0x27ba, 0x27bb, 0x27bc, 0x27bd, 0x27be, 0x27bf,   // U+29f8 ~ U+29ff
0x27c0, 0x27c1, 0x27c2, 0x27c3, 0x27c4, 0x27c5, 0x27c6, 0x27c7,   // U+2a00 ~ U+2a07
0x27c8, 0x27c9, 0x27ca, 0x27cb, 0x27cc, 0x27cd, 0x27ce, 0x27cf,   // U+2a08 ~ U+2a0f
0x27d0, 0x27d1, 0x27d2, 0x27d3, 0x27d4, 0x27d5, 0x27d6, 0x27d7,   // U+2a10 ~ U+2a17
0x27d8, 0x27d9, 0x27da, 0x27db, 0x27dc, 0x27dd, 0x27de, 0x27df,   // U+2a18 ~ U+2a1f
0x27e0, 0x27e1, 0x27e2, 0x27e3, 0x27e4, 0x27e5, 0x27e6, 0x27e7,   // U+2a20 ~ U+2a27
0x27e8, 0x27e9, 0x27ea, 0x27eb, 0x27ec, 0x27ed, 0x27ee, 0x27ef,   // U+2a28 ~ U+2a2f
0x27f0, 0x27f1, 0x27f2, 0x27f3, 0x27f4, 0x27f5, 0x27f6, 0x27f7,   // U+2a30 ~ U+2a37
0x27f8, 0x27f9, 0x27fa, 0x27fb, 0x27fc, 0x27fd, 0x27fe, 0x27ff,   // U+2a38 ~ U+2a3f
0x2800, 0x2801, 0x2802, 0x2803, 0x2804, 0x2805, 0x2806, 0x2807,   // U+2a40 ~ U+2a47
0x2808, 0x2809, 0x280a, 0x280b, 0x280c, 0x280d, 0x280e, 0x280f,   // U+2a48 ~ U+2a4f
0x2810, 0x2811, 0x2812, 0x2813, 0x2814, 0x2815, 0x2816, 0x2817,   // U+2a50 ~ U+2a57
0x2818, 0x2819, 0x281a, 0x281b, 0x281c, 0x281d, 0x281e, 0x281f,   // U+2a58 ~ U+2a5f
0x2820, 0x2821, 0x2822, 0x2823, 0x2824, 0x2825, 0x2826, 0x2827,   // U+2a60 ~ U+2a67
0x2828, 0x2829, 0x282a, 0x282b, 0x282c, 0x282d, 0x282e, 0x282f,   // U+2a68 ~ U+2a6f
0x2830, 0x2831, 0x2832, 0x2833, 0x2834, 0x2835, 0x2836, 0x2837,   // U+2a70 ~ U+2a77
0x2838, 0x2839, 0x283a, 0x283b, 0x283c, 0x283d, 0x283e, 0x283f,   // U+2a78 ~ U+2a7f
0x2840, 0x2841, 0x2842, 0x2843, 0x2844, 0x2845, 0x2846, 0x2847,   // U+2a80 ~ U+2a87
0x2848, 0x2849, 0x284a, 0x284b, 0x284c, 0x284d, 0x284e, 0x284f,   // U+2a88 ~ U+2a8f
0x2850, 0x2851, 0x2852, 0x2853, 0x2854, 0x2855, 0x2856, 0x2857,   // U+2a90 ~ U+2a97
0x2858, 0x2859, 0x285a, 0x285b, 0x285c, 0x285d, 0x285e, 0x285f,   // U+2a98 ~ U+2a9f
0x2860, 0x2861, 0x2862, 0x2863, 0x2864, 0x2865, 0x2866, 0x2867,   // U+2aa0 ~ U+2aa7
0x2868, 0x2869, 0x286a, 0x286b, 0x286c, 0x286d, 0x286e, 0x286f,   // U+2aa8 ~ U+2aaf
0x2870, 0x2871, 0x2872, 0x2873, 0x2874, 0x2875, 0x2876, 0x2877,   // U+2ab0 ~ U+2ab7
0x2878, 0x2879, 0x287a, 0x287b, 0x287c, 0x287d, 0x287e, 0x287f,   // U+2ab8 ~ U+2abf
0x2880, 0x2881, 0x2882, 0x2883, 0x2884, 0x2885, 0x2886, 0x2887,   // U+2ac0 ~ U+2ac7
0x2888, 0x2889, 0x288a, 0x288b, 0x288c, 0x288d, 0x288e, 0x288f,   // U+2ac8 ~ U+2acf
0x2890, 0x2891, 0x2892, 0x2893, 0x2894, 0x2895, 0x2896, 0x2897,   // U+2ad0 ~ U+2ad7
0x2898, 0x2899, 0x289a, 0x289b, 0x289c, 0x289d, 0x289e, 0x289f,   // U+2ad8 ~ U+2adf
0x28a0, 0x28a1, 0x28a2, 0x28a3, 0x28a4, 0x28a5, 0x28a6, 0x28a7,   // U+2ae0 ~ U+2ae7
0x28a8, 0x28a9, 0x28aa, 0x28ab, 0x28ac, 0x28ad, 0x28ae, 0x28af,   // U+2ae8 ~ U+2aef
0x28b0, 0x28b1, 0x28b2, 0x28b3, 0x28b4, 0x28b5, 0x28b6, 0x28b7,   // U+2af0 ~ U+2af7
0x28b8, 0x28b9, 0x28ba, 0x28bb, 0x28bc, 0x28bd, 0x28be, 0x28bf,   // U+2af8 ~ U+2aff
0x28c0, 0x28c1, 0x28c2, 0x28c3, 0x28c4, 0x28c5, 0x28c6, 0x28c7,   // U+2b00 ~ U+2b07
0x28c8, 0x28c9, 0x28ca, 0x28cb, 0x28cc, 0x28cd, 0x28ce, 0x28cf,   // U+2b08 ~ U+2b0f
0x28d0, 0x28d1, 0x28d2, 0x28d3, 0x28d4, 0x28d5, 0x28d6, 0x28d7,   // U+2b10 ~ U+2b17
0x28d8, 0x28d9, 0x28da, 0x28db, 0x28dc, 0x28dd, 0x28de, 0x28df,   // U+2b18 ~ U+2b1f
0x28e0, 0x28e1, 0x28e2, 0x28e3, 0x28e4, 0x28e5, 0x28e6, 0x28e7,   // U+2b20 ~ U+2b27
0x28e8, 0x28e9, 0x28ea, 0x28eb, 0x28ec, 0x28ed, 0x28ee, 0x28ef,   // U+2b28 ~ U+2b2f
0x28f0, 0x28f1, 0x28f2, 0x28f3, 0x28f4, 0x28f5, 0x28f6, 0x28f7,   // U+2b30 ~ U+2b37
0x28f8, 0x28f9, 0x28fa, 0x28fb, 0x28fc, 0x28fd, 0x28fe, 0x28ff,   // U+2b38 ~ U+2b3f
0x2900, 0x2901, 0x2902, 0x2903, 0x2904, 0x2905, 0x2906, 0x2907,   // U+2b40 ~ U+2b47
0x2908, 0x2909, 0x290a, 0x290b, 0x290c, 0x290d, 0x290e, 0x290f,   // U+2b48 ~ U+2b4f
0x2910, 0x2911, 0x2912, 0x2913, 0x2914, 0x2915, 0x2916, 0x2917,   // U+2b50 ~ U+2b57
0x2918, 0x2919, 0x291a, 0x291b, 0x291c, 0x291d, 0x291e, 0x291f,   // U+2b58 ~ U+2b5f
0x2920, 0x2921, 0x2922, 0x2923, 0x2924, 0x2925, 0x2926, 0x2927,   // U+2b60 ~ U+2b67
0x2928, 0x2929, 0x292a, 0x292b, 0x292c, 0x292d, 0x292e, 0x292f,   // U+2b68 ~ U+2b6f
0x2930, 0x2931, 0x2932, 0x2933, 0x2934, 0x2935, 0x2936, 0x2937,   // U+2b70 ~ U+2b77
0x2938, 0x2939, 0x293a, 0x293b, 0x293c, 0x293d, 0x293e, 0x293f,   // U+2b78 ~ U+2b7f
0x2940, 0x2941, 0x2942, 0x2943, 0x2944, 0x2945, 0x2946, 0x2947,   // U+2b80 ~ U+2b87
0x2948, 0x2949, 0x294a, 0x294b, 0x294c, 0x294d, 0x294e, 0x294f,   // U+2b88 ~ U+2b8f
0x2950, 0x2951, 0x2952, 0x2953, 0x2954, 0x2955, 0x2956, 0x2957,   // U+2b90 ~ U+2b97
0x2958, 0x2959, 0x295a, 0x295b, 0x295c, 0x295d, 0x295e, 0x295f,   // U+2b98 ~ U+2b9f
0x2960, 0x2961, 0x2962, 0x2963, 0x2964, 0x2965, 0x2966, 0x2967,   // U+2ba0 ~ U+2ba7
0x2968, 0x2969, 0x296a, 0x296b, 0x296c, 0x296d, 0x296e, 0x296f,   // U+2ba8 ~ U+2baf
0x2970, 0x2971, 0x2972, 0x2973, 0x2974, 0x2975, 0x2976, 0x2977,   // U+2bb0 ~ U+2bb7
0x2978, 0x2979, 0x297a, 0x297b, 0x297c, 0x297d, 0x297e, 0x297f,   // U+2bb8 ~ U+2bbf
0x2980, 0x2981, 0x2982, 0x2983, 0x2984, 0x2985, 0x2986, 0x2987,   // U+2bc0 ~ U+2bc7
0x2988, 0x2989, 0x298a, 0x298b, 0x298c, 0x298d, 0x298e, 0x298f,   // U+2bc8 ~ U+2bcf
0x2990, 0x2991, 0x2992, 0x2993, 0x2994, 0x2995, 0x2996, 0x2997,   // U+2bd0 ~ U+2bd7
0x2998, 0x2999, 0x299a, 0x299b, 0x299c, 0x299d, 0x299e, 0x299f,   // U+2bd8 ~ U+2bdf
0x29a0, 0x29a1, 0x29a2, 0x29a3, 0x29a4, 0x29a5, 0x29a6, 0x29a7,   // U+2be0 ~ U+2be7
0x29a8, 0x29a9, 0x29aa, 0x29ab, 0x29ac, 0x29ad, 0x29ae, 0x29af,   // U+2be8 ~ U+2bef
0x29b0, 0x29b1, 0x29b2, 0x29b3, 0x29b4, 0x29b5, 0x29b6, 0x29b7,   // U+2bf0 ~ U+2bf7
0x29b8, 0x29b9, 0x29ba, 0x29bb, 0x29bc, 0x29bd, 0x29be, 0x29bf,   // U+2bf8 ~ U+2bff
0x29c0, 0x29c1, 0x29c2, 0x29c3, 0x29c4, 0x29c5, 0x29c6, 0x29c7,   // U+2c00 ~ U+2c07
0x29c8, 0x29c9, 0x29ca, 0x29cb, 0x29cc, 0x29cd, 0x29ce, 0x29cf,   // U+2c08 ~ U+2c0f
0x29d0, 0x29d1, 0x29d2, 0x29d3, 0x29d4, 0x29d5, 0x29d6, 0x29d7,   // U+2c10 ~ U+2c17
0x29d8, 0x29d9, 0x29da, 0x29db, 0x29dc, 0x29dd, 0x29de, 0x29df,   // U+2c18 ~ U+2c1f
0x29e0, 0x29e1, 0x29e2, 0x29e3, 0x29e4, 0x29e5, 0x29e6, 0x29e7,   // U+2c20 ~ U+2c27
0x29e8, 0x29e9, 0x29ea, 0x29eb, 0x29ec, 0x29ed, 0x29ee, 0x29ef,   // U+2c28 ~ U+2c2f
0x29f0, 0x29f1, 0x29f2, 0x29f3, 0x29f4, 0x29f5, 0x29f6, 0x29f7,   // U+2c30 ~ U+2c37
0x29f8, 0x29f9, 0x29fa, 0x29fb, 0x29fc, 0x29fd, 0x29fe, 0x29ff,   // U+2c38 ~ U+2c3f
0x2a00, 0x2a01, 0x2a02, 0x2a03, 0x2a04, 0x2a05, 0x2a06, 0x2a07,   // U+2c40 ~ U+2c47
0x2a08, 0x2a09, 0x2a0a, 0x2a0b, 0x2a0c, 0x2a0d, 0x2a0e, 0x2a0f,   // U+2c48 ~ U+2c4f
0x2a10, 0x2a11, 0x2a12, 0x2a13, 0x2a14, 0x2a15, 0x2a16, 0x2a17,   // U+2c50 ~ U+2c57
0x2a18, 0x2a19, 0x2a1a, 0x2a1b, 0x2a1c, 0x2a1d, 0x2a1e, 0x2a1f,   // U+2c58 ~ U+2c5f
0x2a20, 0x2a21, 0x2a22, 0x2a23, 0x2a24, 0x2a25, 0x2a26, 0x2a27,   // U+2c60 ~ U+2c67
0x2a28, 0x2a29, 0x2a2a, 0x2a2b, 0x2a2c, 0x2a2d, 0x2a2e, 0x2a2f,   // U+2c68 ~ U+2c6f
0x2a30, 0x2a31, 0x2a32, 0x2a33, 0x2a34, 0x2a35, 0x2a36, 0x2a37,   // U+2c70 ~ U+2c77
0x2a38, 0x2a39, 0x2a3a, 0x2a3b, 0x2a3c, 0x2a3d, 0x2a3e, 0x2a3f,   // U+2c78 ~ U+2c7f
0x2a40, 0x2a41, 0x2a42, 0x2a43, 0x2a44, 0x2a45, 0x2a46, 0x2a47,   // U+2c80 ~ U+2c87
0x2a48, 0x2a49, 0x2a4a, 0x2a4b, 0x2a4c, 0x2a4d, 0x2a4e, 0x2a4f,   // U+2c88 ~ U+2c8f
0x2a50, 0x2a51, 0x2a52, 0x2a53, 0x2a54, 0x2a55, 0x2a56, 0x2a57,   // U+2c90 ~ U+2c97
0x2a58, 0x2a59, 0x2a5a, 0x2a5b, 0x2a5c, 0x2a5d, 0x2a5e, 0x2a5f,   // U+2c98 ~ U+2c9f
0x2a60, 0x2a61, 0x2a62, 0x2a63, 0x2a64, 0x2a65, 0x2a66, 0x2a67,   // U+2ca0 ~ U+2ca7
0x2a68, 0x2a69, 0x2a6a, 0x2a6b, 0x2a6c, 0x2a6d, 0x2a6e, 0x2a6f,   // U+2ca8 ~ U+2caf
0x2a70, 0x2a71, 0x2a72, 0x2a73, 0x2a74, 0x2a75, 0x2a76, 0x2a77,   // U+2cb0 ~ U+2cb7
0x2a78, 0x2a79, 0x2a7a, 0x2a7b, 0x2a7c, 0x2a7d, 0x2a7e, 0x2a7f,   // U+2cb8 ~ U+2cbf
0x2a80, 0x2a81, 0x2a82, 0x2a83, 0x2a84, 0x2a85, 0x2a86, 0x2a87,   // U+2cc0 ~ U+2cc7
0x2a88, 0x2a89, 0x2a8a, 0x2a8b, 0x2a8c, 0x2a8d, 0x2a8e, 0x2a8f,   // U+2cc8 ~ U+2ccf
0x2a90, 0x2a91, 0x2a92, 0x2a93, 0x2a94, 0x2a95, 0x2a96, 0x2a97,   // U+2cd0 ~ U+2cd7
0x2a98, 0x2a99, 0x2a9a, 0x2a9b, 0x2a9c, 0x2a9d, 0x2a9e, 0x2a9f,   // U+2cd8 ~ U+2cdf
0x2aa0, 0x2aa1, 0x2aa2, 0x2aa3, 0x2aa4, 0x2aa5, 0x2aa6, 0x2aa7,   // U+2ce0 ~ U+2ce7
0x2aa8, 0x2aa9, 0x2aaa, 0x2aab, 0x2aac, 0x2aad, 0x2aae, 0x2aaf,   // U+2ce8 ~ U+2cef
0x2ab0, 0x2ab1, 0x2ab2, 0x2ab3, 0x2ab4, 0x2ab5, 0x2ab6, 0x2ab7,   // U+2cf0 ~ U+2cf7
0x2ab8, 0x2ab9, 0x2aba, 0x2abb, 0x2abc, 0x2abd, 0x2abe, 0x2abf,   // U+2cf8 ~ U+2cff
0x2ac0, 0x2ac1, 0x2ac2, 0x2ac3, 0x2ac4, 0x2ac5, 0x2ac6, 0x2ac7,   // U+2d00 ~ U+2d07
0x2ac8, 0x2ac9, 0x2aca, 0x2acb, 0x2acc, 0x2acd, 0x2ace, 0x2acf,   // U+2d08 ~ U+2d0f
0x2ad0, 0x2ad1, 0x2ad2, 0x2ad3, 0x2ad4, 0x2ad5, 0x2ad6, 0x2ad7,   // U+2d10 ~ U+2d17
0x2ad8, 0x2ad9, 0x2ada, 0x2adb, 0x2adc, 0x2add, 0x2ade, 0x2adf,   // U+2d18 ~ U+2d1f
0x2ae0, 0x2ae1, 0x2ae2, 0x2ae3, 0x2ae4, 0x2ae5, 0x2ae6, 0x2ae7,   // U+2d20 ~ U+2d27
0x2ae8, 0x2ae9, 0x2aea, 0x2aeb, 0x2aec, 0x2aed, 0x2aee, 0x2aef,   // U+2d28 ~ U+2d2f
0x2af0, 0x2af1, 0x2af2, 0x2af3, 0x2af4, 0x2af5, 0x2af6, 0x2af7,   // U+2d30 ~ U+2d37
0x2af8, 0x2af9, 0x2afa, 0x2afb, 0x2afc, 0x2afd, 0x2afe, 0x2aff,   // U+2d38 ~ U+2d3f
0x2b00, 0x2b01, 0x2b02, 0x2b03, 0x2b04, 0x2b05, 0x2b06, 0x2b07,   // U+2d40 ~ U+2d47
0x2b08, 0x2b09, 0x2b0a, 0x2b0b, 0x2b0c, 0x2b0d, 0x2b0e, 0x2b0f,   // U+2d48 ~ U+2d4f
0x2b10, 0x2b11, 0x2b12, 0x2b13, 0x2b14, 0x2b15, 0x2b16, 0x2b17,   // U+2d50 ~ U+2d57
0x2b18, 0x2b19, 0x2b1a, 0x2b1b, 0x2b1c, 0x2b1d, 0x2b1e, 0x2b1f,   // U+2d58 ~ U+2d5f
0x2b20, 0x2b21, 0x2b22, 0x2b23, 0x2b24, 0x2b25, 0x2b26, 0x2b27,   // U+2d60 ~ U+2d67
0x2b28, 0x2b29, 0x2b2a, 0x2b2b, 0x2b2c, 0x2b2d, 0x2b2e, 0x2b2f,   // U+2d68 ~ U+2d6f
0x2b30, 0x2b31, 0x2b32, 0x2b33, 0x2b34, 0x2b35, 0x2b36, 0x2b37,   // U+2d70 ~ U+2d77
0x2b38, 0x2b39, 0x2b3a, 0x2b3b, 0x2b3c, 0x2b3d, 0x2b3e, 0x2b3f,   // U+2d78 ~ U+2d7f
0x2b40, 0x2b41, 0x2b42, 0x2b43, 0x2b44, 0x2b45, 0x2b46, 0x2b47,   // U+2d80 ~ U+2d87
0x2b48, 0x2b49, 0x2b4a, 0x2b4b, 0x2b4c, 0x2b4d, 0x2b4e, 0x2b4f,   // U+2d88 ~ U+2d8f
0x2b50, 0x2b51, 0x2b52, 0x2b53, 0x2b54, 0x2b55, 0x2b56, 0x2b57,   // U+2d90 ~ U+2d97
0x2b58, 0x2b59, 0x2b5a, 0x2b5b, 0x2b5c, 0x2b5d, 0x2b5e, 0x2b5f,   // U+2d98 ~ U+2d9f
0x2b60, 0x2b61, 0x2b62, 0x2b63, 0x2b64, 0x2b65, 0x2b66, 0x2b67,   // U+2da0 ~ U+2da7
0x2b68, 0x2b69, 0x2b6a, 0x2b6b, 0x2b6c, 0x2b6d, 0x2b6e, 0x2b6f,   // U+2da8 ~ U+2daf
0x2b70, 0x2b71, 0x2b72, 0x2b73, 0x2b74, 0x2b75, 0x2b76, 0x2b77,   // U+2db0 ~ U+2db7
0x2b78, 0x2b79, 0x2b7a, 0x2b7b, 0x2b7c, 0x2b7d, 0x2b7e, 0x2b7f,   // U+2db8 ~ U+2dbf
0x2b80, 0x2b81, 0x2b82, 0x2b83, 0x2b84, 0x2b85, 0x2b86, 0x2b87,   // U+2dc0 ~ U+2dc7
0x2b88, 0x2b89, 0x2b8a, 0x2b8b, 0x2b8c, 0x2b8d, 0x2b8e, 0x2b8f,   // U+2dc8 ~ U+2dcf
0x2b90, 0x2b91, 0x2b92, 0x2b93, 0x2b94, 0x2b95, 0x2b96, 0x2b97,   // U+2dd0 ~ U+2dd7
0x2b98, 0x2b99, 0x2b9a, 0x2b9b, 0x2b9c, 0x2b9d, 0x2b9e, 0x2b9f,   // U+2dd8 ~ U+2ddf
0x2ba0, 0x2ba1, 0x2ba2, 0x2ba3, 0x2ba4, 0x2ba5, 0x2ba6, 0x2ba7,   // U+2de0 ~ U+2de7
0x2ba8, 0x2ba9, 0x2baa, 0x2bab, 0x2bac, 0x2bad, 0x2bae, 0x2baf,   // U+2de8 ~ U+2def
0x2bb0, 0x2bb1, 0x2bb2, 0x2bb3, 0x2bb4, 0x2bb5, 0x2bb6, 0x2bb7,   // U+2df0 ~ U+2df7
0x2bb8, 0x2bb9, 0x2bba, 0x2bbb, 0x2bbc, 0x2bbd, 0x2bbe, 0x2bbf,   // U+2df8 ~ U+2dff
0x2bc0, 0x2bc1, 0x2bc2, 0x2bc3, 0x2bc4, 0x2bc5, 0x2bc6, 0x2bc7,   // U+2e00 ~ U+2e07
0x2bc8, 0x2bc9, 0x2bca, 0x2bcb, 0x2bcc, 0x2bcd, 0x2bce, 0x2bcf,   // U+2e08 ~ U+2e0f
0x2bd0, 0x2bd1, 0x2bd2, 0x2bd3, 0x2bd4, 0x2bd5, 0x2bd6, 0x2bd7,   // U+2e10 ~ U+2e17
0x2bd8, 0x2bd9, 0x2bda, 0x2bdb, 0x2bdc, 0x2bdd, 0x2bde, 0x2bdf,   // U+2e18 ~ U+2e1f
0x2be0, 0x2be1, 0x2be2, 0x2be3, 0x2be4, 0x2be5, 0x2be6, 0x2be7,   // U+2e20 ~ U+2e27
0x2be8, 0x2be9, 0x2bea, 0x2beb, 0x2bec, 0x2bed, 0x2bee, 0x2bef,   // U+2e28 ~ U+2e2f
0x2bf0, 0x2bf1, 0x2bf2, 0x2bf3, 0x2bf4, 0x2bf5, 0x2bf6, 0x2bf7,   // U+2e30 ~ U+2e37
0x2bf8, 0x2bf9, 0x2bfa, 0x2bfb, 0x2bfc, 0x2bfd, 0x2bfe, 0x2bff,   // U+2e38 ~ U+2e3f
0x2c00, 0x2c01, 0x2c02, 0x2c03, 0x2c04, 0x2c05, 0x2c06, 0x2c07,   // U+2e40 ~ U+2e47
0x2c08, 0x2c09, 0x2c0a, 0x2c0b, 0x2c0c, 0x2c0d, 0x2c0e, 0x2c0f,   // U+2e48 ~ U+2e4f
0x2c10, 0x2c11, 0x2c12, 0x2c13, 0x2c14, 0x2c15, 0x2c16, 0x2c17,   // U+2e50 ~ U+2e57
0x2c18, 0x2c19, 0x2c1a, 0x2c1b, 0x2c1c, 0x2c1d, 0x2c1e, 0x2c1f,   // U+2e58 ~ U+2e5f
0x2c20, 0x2c21, 0x2c22, 0x2c23, 0x2c24, 0x2c25, 0x2c26, 0x2c27,   // U+2e60 ~ U+2e67
0x2c28, 0x2c29, 0x2c2a, 0x2c2b, 0x2c2c, 0x2c2d, 0x2c2e, 0x2c2f,   // U+2e68 ~ U+2e6f
0x2c30, 0x2c31, 0x2c32, 0x2c33, 0x2c34, 0x2c35, 0x2c36, 0x2c37,   // U+2e70 ~ U+2e77
0x2c38, 0x2c39, 0x2c3a, 0x2c3b, 0x2c3c, 0x2c3d, 0x2c3e, 0x2c3f,   // U+2e78 ~ U+2e7f
0x2c40, 0xfffc, 0x2c41, 0x2c42, 0xfffb, 0x2c43, 0x2c44, 0x2c45,   // U+2e80 ~ U+2e87
0xfffa, 0x2c46, 0x2c47, 0xfff9, 0xfff8, 0x2c48, 0x2c49, 0x2c4a,   // U+2e88 ~ U+2e8f
0x2c4b, 0x2c4c, 0x2c4d, 0x2c4e, 0x2c4f, 0x2c50, 0x2c51, 0xfff7,   // U+2e90 ~ U+2e97
0x2c52, 0x2c53, 0x2c54, 0x2c55, 0x2c56, 0x2c57, 0x2c58, 0x2c59,   // U+2e98 ~ U+2e9f
0x2c5a, 0x2c5b, 0x2c5c, 0x2c5d, 0x2c5e, 0x2c5f, 0x2c60, 0xfff6,   // U+2ea0 ~ U+2ea7
0x2c61, 0x2c62, 0xfff5, 0x2c63, 0x2c64, 0x2c65, 0xfff4, 0x2c66,   // U+2ea8 ~ U+2eaf
0x2c67, 0x2c68, 0x2c69, 0xfff3, 0x2c6a, 0x2c6b, 0xfff2, 0xfff1,   // U+2eb0 ~ U+2eb7
0x2c6c, 0x2c6d, 0x2c6e, 0xfff0, 0x2c6f, 0x2c70, 0x2c71, 0x2c72,   // U+2eb8 ~ U+2ebf
0x2c73, 0x2c74, 0x2c75, 0x2c76, 0x2c77, 0x2c78, 0x2c79, 0x2c7a,   // U+2ec0 ~ U+2ec7
0x2c7b, 0x2c7c, 0xffef, 0x2c7d, 0x2c7e, 0x2c7f, 0x2c80, 0x2c81,   // U+2ec8 ~ U+2ecf
0x2c82, 0x2c83, 0x2c84, 0x2c85, 0x2c86, 0x2c87, 0x2c88, 0x2c89,   // U+2ed0 ~ U+2ed7
0x2c8a, 0x2c8b, 0x2c8c, 0x2c8d, 0x2c8e, 0x2c8f, 0x2c90, 0x2c91,   // U+2ed8 ~ U+2edf
0x2c92, 0x2c93, 0x2c94, 0x2c95, 0x2c96, 0x2c97, 0x2c98, 0x2c99,   // U+2ee0 ~ U+2ee7
0x2c9a, 0x2c9b, 0x2c9c, 0x2c9d, 0x2c9e, 0x2c9f, 0x2ca0, 0x2ca1,   // U+2ee8 ~ U+2eef
0x2ca2, 0x2ca3, 0x2ca4, 0x2ca5, 0x2ca6, 0x2ca7, 0x2ca8, 0x2ca9,   // U+2ef0 ~ U+2ef7
0x2caa, 0x2cab, 0x2cac, 0x2cad, 0x2cae, 0x2caf, 0x2cb0, 0x2cb1,   // U+2ef8 ~ U+2eff
0x2cb2, 0x2cb3, 0x2cb4, 0x2cb5, 0x2cb6, 0x2cb7, 0x2cb8, 0x2cb9,   // U+2f00 ~ U+2f07
0x2cba, 0x2cbb, 0x2cbc, 0x2cbd, 0x2cbe, 0x2cbf, 0x2cc0, 0x2cc1,   // U+2f08 ~ U+2f0f
0x2cc2, 0x2cc3, 0x2cc4, 0x2cc5, 0x2cc6, 0x2cc7, 0x2cc8, 0x2cc9,   // U+2f10 ~ U+2f17
0x2cca, 0x2ccb, 0x2ccc, 0x2ccd, 0x2cce, 0x2ccf, 0x2cd0, 0x2cd1,   // U+2f18 ~ U+2f1f
0x2cd2, 0x2cd3, 0x2cd4, 0x2cd5, 0x2cd6, 0x2cd7, 0x2cd8, 0x2cd9,   // U+2f20 ~ U+2f27
0x2cda, 0x2cdb, 0x2cdc, 0x2cdd, 0x2cde, 0x2cdf, 0x2ce0, 0x2ce1,   // U+2f28 ~ U+2f2f
0x2ce2, 0x2ce3, 0x2ce4, 0x2ce5, 0x2ce6, 0x2ce7, 0x2ce8, 0x2ce9,   // U+2f30 ~ U+2f37
0x2cea, 0x2ceb, 0x2cec, 0x2ced, 0x2cee, 0x2cef, 0x2cf0, 0x2cf1,   // U+2f38 ~ U+2f3f
0x2cf2, 0x2cf3, 0x2cf4, 0x2cf5, 0x2cf6, 0x2cf7, 0x2cf8, 0x2cf9,   // U+2f40 ~ U+2f47
0x2cfa, 0x2cfb, 0x2cfc, 0x2cfd, 0x2cfe, 0x2cff, 0x2d00, 0x2d01,   // U+2f48 ~ U+2f4f
0x2d02, 0x2d03, 0x2d04, 0x2d05, 0x2d06, 0x2d07, 0x2d08, 0x2d09,   // U+2f50 ~ U+2f57
0x2d0a, 0x2d0b, 0x2d0c, 0x2d0d, 0x2d0e, 0x2d0f, 0x2d10, 0x2d11,   // U+2f58 ~ U+2f5f
0x2d12, 0x2d13, 0x2d14, 0x2d15, 0x2d16, 0x2d17, 0x2d18, 0x2d19,   // U+2f60 ~ U+2f67
0x2d1a, 0x2d1b, 0x2d1c, 0x2d1d, 0x2d1e, 0x2d1f, 0x2d20, 0x2d21,   // U+2f68 ~ U+2f6f
0x2d22, 0x2d23, 0x2d24, 0x2d25, 0x2d26, 0x2d27, 0x2d28, 0x2d29,   // U+2f70 ~ U+2f77
0x2d2a, 0x2d2b, 0x2d2c, 0x2d2d, 0x2d2e, 0x2d2f, 0x2d30, 0x2d31,   // U+2f78 ~ U+2f7f
0x2d32, 0x2d33, 0x2d34, 0x2d35, 0x2d36, 0x2d37, 0x2d38, 0x2d39,   // U+2f80 ~ U+2f87
0x2d3a, 0x2d3b, 0x2d3c, 0x2d3d, 0x2d3e, 0x2d3f, 0x2d40, 0x2d41,   // U+2f88 ~ U+2f8f
0x2d42, 0x2d43, 0x2d44, 0x2d45, 0x2d46, 0x2d47, 0x2d48, 0x2d49,   // U+2f90 ~ U+2f97
0x2d4a, 0x2d4b, 0x2d4c, 0x2d4d, 0x2d4e, 0x2d4f, 0x2d50, 0x2d51,   // U+2f98 ~ U+2f9f
0x2d52, 0x2d53, 0x2d54, 0x2d55, 0x2d56, 0x2d57, 0x2d58, 0x2d59,   // U+2fa0 ~ U+2fa7
0x2d5a, 0x2d5b, 0x2d5c, 0x2d5d, 0x2d5e, 0x2d5f, 0x2d60, 0x2d61,   // U+2fa8 ~ U+2faf
0x2d62, 0x2d63, 0x2d64, 0x2d65, 0x2d66, 0x2d67, 0x2d68, 0x2d69,   // U+2fb0 ~ U+2fb7
0x2d6a, 0x2d6b, 0x2d6c, 0x2d6d, 0x2d6e, 0x2d6f, 0x2d70, 0x2d71,   // U+2fb8 ~ U+2fbf
0x2d72, 0x2d73, 0x2d74, 0x2d75, 0x2d76, 0x2d77, 0x2d78, 0x2d79,   // U+2fc0 ~ U+2fc7
0x2d7a, 0x2d7b, 0x2d7c, 0x2d7d, 0x2d7e, 0x2d7f, 0x2d80, 0x2d81,   // U+2fc8 ~ U+2fcf
0x2d82, 0x2d83, 0x2d84, 0x2d85, 0x2d86, 0x2d87, 0x2d88, 0x2d89,   // U+2fd0 ~ U+2fd7
0x2d8a, 0x2d8b, 0x2d8c, 0x2d8d, 0x2d8e, 0x2d8f, 0x2d90, 0x2d91,   // U+2fd8 ~ U+2fdf
0x2d92, 0x2d93, 0x2d94, 0x2d95, 0x2d96, 0x2d97, 0x2d98, 0x2d99,   // U+2fe0 ~ U+2fe7
0x2d9a, 0x2d9b, 0x2d9c, 0x2d9d, 0x2d9e, 0x2d9f, 0x2da0, 0x2da1,   // U+2fe8 ~ U+2fef
0xffee, 0xffed, 0xffec, 0xffeb, 0xffea, 0xffe9, 0xffe8, 0xffe7,   // U+2ff0 ~ U+2ff7
0xffe6, 0xffe5, 0xffe4, 0xffe3, 0x2da2, 0x2da3, 0x2da4, 0x2da5,   // U+2ff8 ~ U+2fff
0xffff, 0xffff, 0xffff, 0xffff, 0x2da6, 0xffff, 0xffff, 0xffff,   // U+3000 ~ U+3007
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+3008 ~ U+300f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+3010 ~ U+3017
0x2da7, 0x2da8, 0x2da9, 0x2daa, 0x2dab, 0xffff, 0xffff, 0x2dac,   // U+3018 ~ U+301f
0x2dad, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+3020 ~ U+3027
0xffff, 0xffff, 0x2dae, 0x2daf, 0x2db0, 0x2db1, 0x2db2, 0x2db3,   // U+3028 ~ U+302f
0x2db4, 0x2db5, 0x2db6, 0x2db7, 0x2db8, 0x2db9, 0x2dba, 0x2dbb,   // U+3030 ~ U+3037
0x2dbc, 0x2dbd, 0x2dbe, 0x2dbf, 0x2dc0, 0x2dc1, 0xffe2, 0x2dc2,   // U+3038 ~ U+303f
0x2dc3, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+3040 ~ U+3047
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+3048 ~ U+304f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+3050 ~ U+3057
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+3058 ~ U+305f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+3060 ~ U+3067
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+3068 ~ U+306f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+3070 ~ U+3077
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+3078 ~ U+307f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+3080 ~ U+3087
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+3088 ~ U+308f
0xffff, 0xffff, 0xffff, 0xffff, 0x2dc4, 0x2dc5, 0x2dc6, 0x2dc7,   // U+3090 ~ U+3097
0x2dc8, 0x2dc9, 0x2dca, 0xffff, 0xffff, 0xffff, 0xffff, 0x2dcb,   // U+3098 ~ U+309f
0x2dcc, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+30a0 ~ U+30a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+30a8 ~ U+30af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+30b0 ~ U+30b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+30b8 ~ U+30bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+30c0 ~ U+30c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+30c8 ~ U+30cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+30d0 ~ U+30d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+30d8 ~ U+30df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+30e0 ~ U+30e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+30e8 ~ U+30ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x2dcd,   // U+30f0 ~ U+30f7
0x2dce, 0x2dcf, 0x2dd0, 0x2dd1, 0xffff, 0xffff, 0xffff, 0x2dd2,   // U+30f8 ~ U+30ff
0x2dd3, 0x2dd4, 0x2dd5, 0x2dd6, 0x2dd7, 0xffff, 0xffff, 0xffff,   // U+3100 ~ U+3107
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+3108 ~ U+310f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+3110 ~ U+3117
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+3118 ~ U+311f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+3120 ~ U+3127
0xffff, 0xffff, 0x2dd8, 0x2dd9, 0x2dda, 0x2ddb, 0x2ddc, 0x2ddd,   // U+3128 ~ U+312f
0x2dde, 0x2ddf, 0x2de0, 0x2de1, 0x2de2, 0x2de3, 0x2de4, 0x2de5,   // U+3130 ~ U+3137
0x2de6, 0x2de7, 0x2de8, 0x2de9, 0x2dea, 0x2deb, 0x2dec, 0x2ded,   // U+3138 ~ U+313f
0x2dee, 0x2def, 0x2df0, 0x2df1, 0x2df2, 0x2df3, 0x2df4, 0x2df5,   // U+3140 ~ U+3147
0x2df6, 0x2df7, 0x2df8, 0x2df9, 0x2dfa, 0x2dfb, 0x2dfc, 0x2dfd,   // U+3148 ~ U+314f
0x2dfe, 0x2dff, 0x2e00, 0x2e01, 0x2e02, 0x2e03, 0x2e04, 0x2e05,   // U+3150 ~ U+3157
0x2e06, 0x2e07, 0x2e08, 0x2e09, 0x2e0a, 0x2e0b, 0x2e0c, 0x2e0d,   // U+3158 ~ U+315f
0x2e0e, 0x2e0f, 0x2e10, 0x2e11, 0x2e12, 0x2e13, 0x2e14, 0x2e15,   // U+3160 ~ U+3167
0x2e16, 0x2e17, 0x2e18, 0x2e19, 0x2e1a, 0x2e1b, 0x2e1c, 0x2e1d,   // U+3168 ~ U+316f
0x2e1e, 0x2e1f, 0x2e20, 0x2e21, 0x2e22, 0x2e23, 0x2e24, 0x2e25,   // U+3170 ~ U+3177
0x2e26, 0x2e27, 0x2e28, 0x2e29, 0x2e2a, 0x2e2b, 0x2e2c, 0x2e2d,   // U+3178 ~ U+317f
0x2e2e, 0x2e2f, 0x2e30, 0x2e31, 0x2e32, 0x2e33, 0x2e34, 0x2e35,   // U+3180 ~ U+3187
0x2e36, 0x2e37, 0x2e38, 0x2e39, 0x2e3a, 0x2e3b, 0x2e3c, 0x2e3d,   // U+3188 ~ U+318f
0x2e3e, 0x2e3f, 0x2e40, 0x2e41, 0x2e42, 0x2e43, 0x2e44, 0x2e45,   // U+3190 ~ U+3197
0x2e46, 0x2e47, 0x2e48, 0x2e49, 0x2e4a, 0x2e4b, 0x2e4c, 0x2e4d,   // U+3198 ~ U+319f
0x2e4e, 0x2e4f, 0x2e50, 0x2e51, 0x2e52, 0x2e53, 0x2e54, 0x2e55,   // U+31a0 ~ U+31a7
0x2e56, 0x2e57, 0x2e58, 0x2e59, 0x2e5a, 0x2e5b, 0x2e5c, 0x2e5d,   // U+31a8 ~ U+31af
0x2e5e, 0x2e5f, 0x2e60, 0x2e61, 0x2e62, 0x2e63, 0x2e64, 0x2e65,   // U+31b0 ~ U+31b7
0x2e66, 0x2e67, 0x2e68, 0x2e69, 0x2e6a, 0x2e6b, 0x2e6c, 0x2e6d,   // U+31b8 ~ U+31bf
0x2e6e, 0x2e6f, 0x2e70, 0x2e71, 0x2e72, 0x2e73, 0x2e74, 0x2e75,   // U+31c0 ~ U+31c7
0x2e76, 0x2e77, 0x2e78, 0x2e79, 0x2e7a, 0x2e7b, 0x2e7c, 0x2e7d,   // U+31c8 ~ U+31cf
0x2e7e, 0x2e7f, 0x2e80, 0x2e81, 0x2e82, 0x2e83, 0x2e84, 0x2e85,   // U+31d0 ~ U+31d7
0x2e86, 0x2e87, 0x2e88, 0x2e89, 0x2e8a, 0x2e8b, 0x2e8c, 0x2e8d,   // U+31d8 ~ U+31df
0x2e8e, 0x2e8f, 0x2e90, 0x2e91, 0x2e92, 0x2e93, 0x2e94, 0x2e95,   // U+31e0 ~ U+31e7
0x2e96, 0x2e97, 0x2e98, 0x2e99, 0x2e9a, 0x2e9b, 0x2e9c, 0x2e9d,   // U+31e8 ~ U+31ef
0x2e9e, 0x2e9f, 0x2ea0, 0x2ea1, 0x2ea2, 0x2ea3, 0x2ea4, 0x2ea5,   // U+31f0 ~ U+31f7
0x2ea6, 0x2ea7, 0x2ea8, 0x2ea9, 0x2eaa, 0x2eab, 0x2eac, 0x2ead,   // U+31f8 ~ U+31ff
0x2eae, 0x2eaf, 0x2eb0, 0x2eb1, 0x2eb2, 0x2eb3, 0x2eb4, 0x2eb5,   // U+3200 ~ U+3207
0x2eb6, 0x2eb7, 0x2eb8, 0x2eb9, 0x2eba, 0x2ebb, 0x2ebc, 0x2ebd,   // U+3208 ~ U+320f
0x2ebe, 0x2ebf, 0x2ec0, 0x2ec1, 0x2ec2, 0x2ec3, 0x2ec4, 0x2ec5,   // U+3210 ~ U+3217
0x2ec6, 0x2ec7, 0x2ec8, 0x2ec9, 0x2eca, 0x2ecb, 0x2ecc, 0x2ecd,   // U+3218 ~ U+321f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+3220 ~ U+3227
0xffff, 0xffff, 0x2ece, 0x2ecf, 0x2ed0, 0x2ed1, 0x2ed2, 0x2ed3,   // U+3228 ~ U+322f
0x2ed4, 0xffff, 0x2ed5, 0x2ed6, 0x2ed7, 0x2ed8, 0x2ed9, 0x2eda,   // U+3230 ~ U+3237
0x2edb, 0x2edc, 0x2edd, 0x2ede, 0x2edf, 0x2ee0, 0x2ee1, 0x2ee2,   // U+3238 ~ U+323f
0x2ee3, 0x2ee4, 0x2ee5, 0x2ee6, 0x2ee7, 0x2ee8, 0x2ee9, 0x2eea,   // U+3240 ~ U+3247
0x2eeb, 0x2eec, 0x2eed, 0x2eee, 0x2eef, 0x2ef0, 0x2ef1, 0x2ef2,   // U+3248 ~ U+324f
0x2ef3, 0x2ef4, 0x2ef5, 0x2ef6, 0x2ef7, 0x2ef8, 0x2ef9, 0x2efa,   // U+3250 ~ U+3257
0x2efb, 0x2efc, 0x2efd, 0x2efe, 0x2eff, 0x2f00, 0x2f01, 0x2f02,   // U+3258 ~ U+325f
0x2f03, 0x2f04, 0x2f05, 0x2f06, 0x2f07, 0x2f08, 0x2f09, 0x2f0a,   // U+3260 ~ U+3267
0x2f0b, 0x2f0c, 0x2f0d, 0x2f0e, 0x2f0f, 0x2f10, 0x2f11, 0x2f12,   // U+3268 ~ U+326f
0x2f13, 0x2f14, 0x2f15, 0x2f16, 0x2f17, 0x2f18, 0x2f19, 0x2f1a,   // U+3270 ~ U+3277
0x2f1b, 0x2f1c, 0x2f1d, 0x2f1e, 0x2f1f, 0x2f20, 0x2f21, 0x2f22,   // U+3278 ~ U+327f
0x2f23, 0x2f24, 0x2f25, 0x2f26, 0x2f27, 0x2f28, 0x2f29, 0x2f2a,   // U+3280 ~ U+3287
0x2f2b, 0x2f2c, 0x2f2d, 0x2f2e, 0x2f2f, 0x2f30, 0x2f31, 0x2f32,   // U+3288 ~ U+328f
0x2f33, 0x2f34, 0x2f35, 0x2f36, 0x2f37, 0x2f38, 0x2f39, 0x2f3a,   // U+3290 ~ U+3297
0x2f3b, 0x2f3c, 0x2f3d, 0x2f3e, 0x2f3f, 0x2f40, 0x2f41, 0x2f42,   // U+3298 ~ U+329f
0x2f43, 0x2f44, 0x2f45, 0xffff, 0x2f46, 0x2f47, 0x2f48, 0x2f49,   // U+32a0 ~ U+32a7
0x2f4a, 0x2f4b, 0x2f4c, 0x2f4d, 0x2f4e, 0x2f4f, 0x2f50, 0x2f51,   // U+32a8 ~ U+32af
0x2f52, 0x2f53, 0x2f54, 0x2f55, 0x2f56, 0x2f57, 0x2f58, 0x2f59,   // U+32b0 ~ U+32b7
0x2f5a, 0x2f5b, 0x2f5c, 0x2f5d, 0x2f5e, 0x2f5f, 0x2f60, 0x2f61,   // U+32b8 ~ U+32bf
0x2f62, 0x2f63, 0x2f64, 0x2f65, 0x2f66, 0x2f67, 0x2f68, 0x2f69,   // U+32c0 ~ U+32c7
0x2f6a, 0x2f6b, 0x2f6c, 0x2f6d, 0x2f6e, 0x2f6f, 0x2f70, 0x2f71,   // U+32c8 ~ U+32cf
0x2f72, 0x2f73, 0x2f74, 0x2f75, 0x2f76, 0x2f77, 0x2f78, 0x2f79,   // U+32d0 ~ U+32d7
0x2f7a, 0x2f7b, 0x2f7c, 0x2f7d, 0x2f7e, 0x2f7f, 0x2f80, 0x2f81,   // U+32d8 ~ U+32df
0x2f82, 0x2f83, 0x2f84, 0x2f85, 0x2f86, 0x2f87, 0x2f88, 0x2f89,   // U+32e0 ~ U+32e7
0x2f8a, 0x2f8b, 0x2f8c, 0x2f8d, 0x2f8e, 0x2f8f, 0x2f90, 0x2f91,   // U+32e8 ~ U+32ef
0x2f92, 0x2f93, 0x2f94, 0x2f95, 0x2f96, 0x2f97, 0x2f98, 0x2f99,   // U+32f0 ~ U+32f7
0x2f9a, 0x2f9b, 0x2f9c, 0x2f9d, 0x2f9e, 0x2f9f, 0x2fa0, 0x2fa1,   // U+32f8 ~ U+32ff
0x2fa2, 0x2fa3, 0x2fa4, 0x2fa5, 0x2fa6, 0x2fa7, 0x2fa8, 0x2fa9,   // U+3300 ~ U+3307
0x2faa, 0x2fab, 0x2fac, 0x2fad, 0x2fae, 0x2faf, 0x2fb0, 0x2fb1,   // U+3308 ~ U+330f
0x2fb2, 0x2fb3, 0x2fb4, 0x2fb5, 0x2fb6, 0x2fb7, 0x2fb8, 0x2fb9,   // U+3310 ~ U+3317
0x2fba, 0x2fbb, 0x2fbc, 0x2fbd, 0x2fbe, 0x2fbf, 0x2fc0, 0x2fc1,   // U+3318 ~ U+331f
0x2fc2, 0x2fc3, 0x2fc4, 0x2fc5, 0x2fc6, 0x2fc7, 0x2fc8, 0x2fc9,   // U+3320 ~ U+3327
0x2fca, 0x2fcb, 0x2fcc, 0x2fcd, 0x2fce, 0x2fcf, 0x2fd0, 0x2fd1,   // U+3328 ~ U+332f
0x2fd2, 0x2fd3, 0x2fd4, 0x2fd5, 0x2fd6, 0x2fd7, 0x2fd8, 0x2fd9,   // U+3330 ~ U+3337
0x2fda, 0x2fdb, 0x2fdc, 0x2fdd, 0x2fde, 0x2fdf, 0x2fe0, 0x2fe1,   // U+3338 ~ U+333f
0x2fe2, 0x2fe3, 0x2fe4, 0x2fe5, 0x2fe6, 0x2fe7, 0x2fe8, 0x2fe9,   // U+3340 ~ U+3347
0x2fea, 0x2feb, 0x2fec, 0x2fed, 0x2fee, 0x2fef, 0x2ff0, 0x2ff1,   // U+3348 ~ U+334f
0x2ff2, 0x2ff3, 0x2ff4, 0x2ff5, 0x2ff6, 0x2ff7, 0x2ff8, 0x2ff9,   // U+3350 ~ U+3357
0x2ffa, 0x2ffb, 0x2ffc, 0x2ffd, 0x2ffe, 0x2fff, 0x3000, 0x3001,   // U+3358 ~ U+335f
0x3002, 0x3003, 0x3004, 0x3005, 0x3006, 0x3007, 0x3008, 0x3009,   // U+3360 ~ U+3367
0x300a, 0x300b, 0x300c, 0x300d, 0x300e, 0x300f, 0x3010, 0x3011,   // U+3368 ~ U+336f
0x3012, 0x3013, 0x3014, 0x3015, 0x3016, 0x3017, 0x3018, 0x3019,   // U+3370 ~ U+3377
0x301a, 0x301b, 0x301c, 0x301d, 0x301e, 0x301f, 0x3020, 0x3021,   // U+3378 ~ U+337f
0x3022, 0x3023, 0x3024, 0x3025, 0x3026, 0x3027, 0x3028, 0x3029,   // U+3380 ~ U+3387
0x302a, 0x302b, 0x302c, 0x302d, 0x302e, 0x302f, 0xffff, 0xffff,   // U+3388 ~ U+338f
0x3030, 0x3031, 0x3032, 0x3033, 0x3034, 0x3035, 0x3036, 0x3037,   // U+3390 ~ U+3397
0x3038, 0x3039, 0x303a, 0x303b, 0xffff, 0xffff, 0xffff, 0x303c,   // U+3398 ~ U+339f
0x303d, 0xffff, 0x303e, 0x303f, 0x3040, 0x3041, 0x3042, 0x3043,   // U+33a0 ~ U+33a7
0x3044, 0x3045, 0x3046, 0x3047, 0x3048, 0x3049, 0x304a, 0x304b,   // U+33a8 ~ U+33af
0x304c, 0x304d, 0x304e, 0x304f, 0x3050, 0x3051, 0x3052, 0x3053,   // U+33b0 ~ U+33b7
0x3054, 0x3055, 0x3056, 0x3057, 0x3058, 0x3059, 0x305a, 0x305b,   // U+33b8 ~ U+33bf
0x305c, 0x305d, 0x305e, 0x305f, 0xffff, 0x3060, 0x3061, 0x3062,   // U+33c0 ~ U+33c7
0x3063, 0x3064, 0x3065, 0x3066, 0x3067, 0x3068, 0xffff, 0x3069,   // U+33c8 ~ U+33cf
0x306a, 0xffff, 0xffff, 0x306b, 0x306c, 0xffff, 0x306d, 0x306e,   // U+33d0 ~ U+33d7
0x306f, 0x3070, 0x3071, 0x3072, 0x3073, 0x3074, 0x3075, 0x3076,   // U+33d8 ~ U+33df
0x3077, 0x3078, 0x3079, 0x307a, 0x307b, 0x307c, 0x307d, 0x307e,   // U+33e0 ~ U+33e7
0x307f, 0x3080, 0x3081, 0x3082, 0x3083, 0x3084, 0x3085, 0x3086,   // U+33e8 ~ U+33ef
0x3087, 0x3088, 0x3089, 0x308a, 0x308b, 0x308c, 0x308d, 0x308e,   // U+33f0 ~ U+33f7
0x308f, 0x3090, 0x3091, 0x3092, 0x3093, 0x3094, 0x3095, 0x3096,   // U+33f8 ~ U+33ff
0x3097, 0x3098, 0x3099, 0x309a, 0x309b, 0x309c, 0x309d, 0x309e,   // U+3400 ~ U+3407
0x309f, 0x30a0, 0x30a1, 0x30a2, 0x30a3, 0x30a4, 0x30a5, 0x30a6,   // U+3408 ~ U+340f
0x30a7, 0x30a8, 0x30a9, 0x30aa, 0x30ab, 0x30ac, 0x30ad, 0x30ae,   // U+3410 ~ U+3417
0x30af, 0x30b0, 0x30b1, 0x30b2, 0x30b3, 0x30b4, 0x30b5, 0x30b6,   // U+3418 ~ U+341f
0x30b7, 0x30b8, 0x30b9, 0x30ba, 0x30bb, 0x30bc, 0x30bd, 0x30be,   // U+3420 ~ U+3427
0x30bf, 0x30c0, 0x30c1, 0x30c2, 0x30c3, 0x30c4, 0x30c5, 0x30c6,   // U+3428 ~ U+342f
0x30c7, 0x30c8, 0x30c9, 0x30ca, 0x30cb, 0x30cc, 0x30cd, 0x30ce,   // U+3430 ~ U+3437
0x30cf, 0x30d0, 0x30d1, 0x30d2, 0x30d3, 0x30d4, 0x30d5, 0x30d6,   // U+3438 ~ U+343f
0x30d7, 0x30d8, 0x30d9, 0x30da, 0x30db, 0x30dc, 0x30dd, 0xffe1,   // U+3440 ~ U+3447
0x30de, 0x30df, 0x30e0, 0x30e1, 0x30e2, 0x30e3, 0x30e4, 0x30e5,   // U+3448 ~ U+344f
0x30e6, 0x30e7, 0x30e8, 0x30e9, 0x30ea, 0x30eb, 0x30ec, 0x30ed,   // U+3450 ~ U+3457
0x30ee, 0x30ef, 0x30f0, 0x30f1, 0x30f2, 0x30f3, 0x30f4, 0x30f5,   // U+3458 ~ U+345f
0x30f6, 0x30f7, 0x30f8, 0x30f9, 0x30fa, 0x30fb, 0x30fc, 0x30fd,   // U+3460 ~ U+3467
0x30fe, 0x30ff, 0x3100, 0x3101, 0x3102, 0x3103, 0x3104, 0x3105,   // U+3468 ~ U+346f
0x3106, 0x3107, 0x3108, 0xffe0, 0x3109, 0x310a, 0x310b, 0x310c,   // U+3470 ~ U+3477
0x310d, 0x310e, 0x310f, 0x3110, 0x3111, 0x3112, 0x3113, 0x3114,   // U+3478 ~ U+347f
0x3115, 0x3116, 0x3117, 0x3118, 0x3119, 0x311a, 0x311b, 0x311c,   // U+3480 ~ U+3487
0x311d, 0x311e, 0x311f, 0x3120, 0x3121, 0x3122, 0x3123, 0x3124,   // U+3488 ~ U+348f
0x3125, 0x3126, 0x3127, 0x3128, 0x3129, 0x312a, 0x312b, 0x312c,   // U+3490 ~ U+3497
0x312d, 0x312e, 0x312f, 0x3130, 0x3131, 0x3132, 0x3133, 0x3134,   // U+3498 ~ U+349f
0x3135, 0x3136, 0x3137, 0x3138, 0x3139, 0x313a, 0x313b, 0x313c,   // U+34a0 ~ U+34a7
0x313d, 0x313e, 0x313f, 0x3140, 0x3141, 0x3142, 0x3143, 0x3144,   // U+34a8 ~ U+34af
0x3145, 0x3146, 0x3147, 0x3148, 0x3149, 0x314a, 0x314b, 0x314c,   // U+34b0 ~ U+34b7
0x314d, 0x314e, 0x314f, 0x3150, 0x3151, 0x3152, 0x3153, 0x3154,   // U+34b8 ~ U+34bf
0x3155, 0x3156, 0x3157, 0x3158, 0x3159, 0x315a, 0x315b, 0x315c,   // U+34c0 ~ U+34c7
0x315d, 0x315e, 0x315f, 0x3160, 0x3161, 0x3162, 0x3163, 0x3164,   // U+34c8 ~ U+34cf
0x3165, 0x3166, 0x3167, 0x3168, 0x3169, 0x316a, 0x316b, 0x316c,   // U+34d0 ~ U+34d7
0x316d, 0x316e, 0x316f, 0x3170, 0x3171, 0x3172, 0x3173, 0x3174,   // U+34d8 ~ U+34df
0x3175, 0x3176, 0x3177, 0x3178, 0x3179, 0x317a, 0x317b, 0x317c,   // U+34e0 ~ U+34e7
0x317d, 0x317e, 0x317f, 0x3180, 0x3181, 0x3182, 0x3183, 0x3184,   // U+34e8 ~ U+34ef
0x3185, 0x3186, 0x3187, 0x3188, 0x3189, 0x318a, 0x318b, 0x318c,   // U+34f0 ~ U+34f7
0x318d, 0x318e, 0x318f, 0x3190, 0x3191, 0x3192, 0x3193, 0x3194,   // U+34f8 ~ U+34ff
0x3195, 0x3196, 0x3197, 0x3198, 0x3199, 0x319a, 0x319b, 0x319c,   // U+3500 ~ U+3507
0x319d, 0x319e, 0x319f, 0x31a0, 0x31a1, 0x31a2, 0x31a3, 0x31a4,   // U+3508 ~ U+350f
0x31a5, 0x31a6, 0x31a7, 0x31a8, 0x31a9, 0x31aa, 0x31ab, 0x31ac,   // U+3510 ~ U+3517
0x31ad, 0x31ae, 0x31af, 0x31b0, 0x31b1, 0x31b2, 0x31b3, 0x31b4,   // U+3518 ~ U+351f
0x31b5, 0x31b6, 0x31b7, 0x31b8, 0x31b9, 0x31ba, 0x31bb, 0x31bc,   // U+3520 ~ U+3527
0x31bd, 0x31be, 0x31bf, 0x31c0, 0x31c1, 0x31c2, 0x31c3, 0x31c4,   // U+3528 ~ U+352f
0x31c5, 0x31c6, 0x31c7, 0x31c8, 0x31c9, 0x31ca, 0x31cb, 0x31cc,   // U+3530 ~ U+3537
0x31cd, 0x31ce, 0x31cf, 0x31d0, 0x31d1, 0x31d2, 0x31d3, 0x31d4,   // U+3538 ~ U+353f
0x31d5, 0x31d6, 0x31d7, 0x31d8, 0x31d9, 0x31da, 0x31db, 0x31dc,   // U+3540 ~ U+3547
0x31dd, 0x31de, 0x31df, 0x31e0, 0x31e1, 0x31e2, 0x31e3, 0x31e4,   // U+3548 ~ U+354f
0x31e5, 0x31e6, 0x31e7, 0x31e8, 0x31e9, 0x31ea, 0x31eb, 0x31ec,   // U+3550 ~ U+3557
0x31ed, 0x31ee, 0x31ef, 0x31f0, 0x31f1, 0x31f2, 0x31f3, 0x31f4,   // U+3558 ~ U+355f
0x31f5, 0x31f6, 0x31f7, 0x31f8, 0x31f9, 0x31fa, 0x31fb, 0x31fc,   // U+3560 ~ U+3567
0x31fd, 0x31fe, 0x31ff, 0x3200, 0x3201, 0x3202, 0x3203, 0x3204,   // U+3568 ~ U+356f
0x3205, 0x3206, 0x3207, 0x3208, 0x3209, 0x320a, 0x320b, 0x320c,   // U+3570 ~ U+3577
0x320d, 0x320e, 0x320f, 0x3210, 0x3211, 0x3212, 0x3213, 0x3214,   // U+3578 ~ U+357f
0x3215, 0x3216, 0x3217, 0x3218, 0x3219, 0x321a, 0x321b, 0x321c,   // U+3580 ~ U+3587
0x321d, 0x321e, 0x321f, 0x3220, 0x3221, 0x3222, 0x3223, 0x3224,   // U+3588 ~ U+358f
0x3225, 0x3226, 0x3227, 0x3228, 0x3229, 0x322a, 0x322b, 0x322c,   // U+3590 ~ U+3597
0x322d, 0x322e, 0x322f, 0x3230, 0x3231, 0x3232, 0xffdf, 0x3233,   // U+3598 ~ U+359f
0x3234, 0x3235, 0x3236, 0x3237, 0x3238, 0x3239, 0x323a, 0x323b,   // U+35a0 ~ U+35a7
0x323c, 0x323d, 0x323e, 0x323f, 0x3240, 0x3241, 0x3242, 0x3243,   // U+35a8 ~ U+35af
0x3244, 0x3245, 0x3246, 0x3247, 0x3248, 0x3249, 0x324a, 0x324b,   // U+35b0 ~ U+35b7
0x324c, 0x324d, 0x324e, 0x324f, 0x3250, 0x3251, 0x3252, 0x3253,   // U+35b8 ~ U+35bf
0x3254, 0x3255, 0x3256, 0x3257, 0x3258, 0x3259, 0x325a, 0x325b,   // U+35c0 ~ U+35c7
0x325c, 0x325d, 0x325e, 0x325f, 0x3260, 0x3261, 0x3262, 0x3263,   // U+35c8 ~ U+35cf
0x3264, 0x3265, 0x3266, 0x3267, 0x3268, 0x3269, 0x326a, 0x326b,   // U+35d0 ~ U+35d7
0x326c, 0x326d, 0x326e, 0x326f, 0x3270, 0x3271, 0x3272, 0x3273,   // U+35d8 ~ U+35df
0x3274, 0x3275, 0x3276, 0x3277, 0x3278, 0x3279, 0x327a, 0x327b,   // U+35e0 ~ U+35e7
0x327c, 0x327d, 0x327e, 0x327f, 0x3280, 0x3281, 0x3282, 0x3283,   // U+35e8 ~ U+35ef
0x3284, 0x3285, 0x3286, 0x3287, 0x3288, 0x3289, 0x328a, 0x328b,   // U+35f0 ~ U+35f7
0x328c, 0x328d, 0x328e, 0x328f, 0x3290, 0x3291, 0x3292, 0x3293,   // U+35f8 ~ U+35ff
0x3294, 0x3295, 0x3296, 0x3297, 0x3298, 0x3299, 0x329a, 0x329b,   // U+3600 ~ U+3607
0x329c, 0x329d, 0x329e, 0x329f, 0x32a0, 0x32a1, 0xffde, 0x32a2,   // U+3608 ~ U+360f
0x32a3, 0x32a4, 0x32a5, 0x32a6, 0x32a7, 0x32a8, 0x32a9, 0x32aa,   // U+3610 ~ U+3617
0x32ab, 0x32ac, 0xffdd, 0x32ad, 0x32ae, 0x32af, 0x32b0, 0x32b1,   // U+3618 ~ U+361f
0x32b2, 0x32b3, 0x32b4, 0x32b5, 0x32b6, 0x32b7, 0x32b8, 0x32b9,   // U+3620 ~ U+3627
0x32ba, 0x32bb, 0x32bc, 0x32bd, 0x32be, 0x32bf, 0x32c0, 0x32c1,   // U+3628 ~ U+362f
0x32c2, 0x32c3, 0x32c4, 0x32c5, 0x32c6, 0x32c7, 0x32c8, 0x32c9,   // U+3630 ~ U+3637
0x32ca, 0x32cb, 0x32cc, 0x32cd, 0x32ce, 0x32cf, 0x32d0, 0x32d1,   // U+3638 ~ U+363f
0x32d2, 0x32d3, 0x32d4, 0x32d5, 0x32d6, 0x32d7, 0x32d8, 0x32d9,   // U+3640 ~ U+3647
0x32da, 0x32db, 0x32dc, 0x32dd, 0x32de, 0x32df, 0x32e0, 0x32e1,   // U+3648 ~ U+364f
0x32e2, 0x32e3, 0x32e4, 0x32e5, 0x32e6, 0x32e7, 0x32e8, 0x32e9,   // U+3650 ~ U+3657
0x32ea, 0x32eb, 0x32ec, 0x32ed, 0x32ee, 0x32ef, 0x32f0, 0x32f1,   // U+3658 ~ U+365f
0x32f2, 0x32f3, 0x32f4, 0x32f5, 0x32f6, 0x32f7, 0x32f8, 0x32f9,   // U+3660 ~ U+3667
0x32fa, 0x32fb, 0x32fc, 0x32fd, 0x32fe, 0x32ff, 0x3300, 0x3301,   // U+3668 ~ U+366f
0x3302, 0x3303, 0x3304, 0x3305, 0x3306, 0x3307, 0x3308, 0x3309,   // U+3670 ~ U+3677
0x330a, 0x330b, 0x330c, 0x330d, 0x330e, 0x330f, 0x3310, 0x3311,   // U+3678 ~ U+367f
0x3312, 0x3313, 0x3314, 0x3315, 0x3316, 0x3317, 0x3318, 0x3319,   // U+3680 ~ U+3687
0x331a, 0x331b, 0x331c, 0x331d, 0x331e, 0x331f, 0x3320, 0x3321,   // U+3688 ~ U+368f
0x3322, 0x3323, 0x3324, 0x3325, 0x3326, 0x3327, 0x3328, 0x3329,   // U+3690 ~ U+3697
0x332a, 0x332b, 0x332c, 0x332d, 0x332e, 0x332f, 0x3330, 0x3331,   // U+3698 ~ U+369f
0x3332, 0x3333, 0x3334, 0x3335, 0x3336, 0x3337, 0x3338, 0x3339,   // U+36a0 ~ U+36a7
0x333a, 0x333b, 0x333c, 0x333d, 0x333e, 0x333f, 0x3340, 0x3341,   // U+36a8 ~ U+36af
0x3342, 0x3343, 0x3344, 0x3345, 0x3346, 0x3347, 0x3348, 0x3349,   // U+36b0 ~ U+36b7
0x334a, 0x334b, 0x334c, 0x334d, 0x334e, 0x334f, 0x3350, 0x3351,   // U+36b8 ~ U+36bf
0x3352, 0x3353, 0x3354, 0x3355, 0x3356, 0x3357, 0x3358, 0x3359,   // U+36c0 ~ U+36c7
0x335a, 0x335b, 0x335c, 0x335d, 0x335e, 0x335f, 0x3360, 0x3361,   // U+36c8 ~ U+36cf
0x3362, 0x3363, 0x3364, 0x3365, 0x3366, 0x3367, 0x3368, 0x3369,   // U+36d0 ~ U+36d7
0x336a, 0x336b, 0x336c, 0x336d, 0x336e, 0x336f, 0x3370, 0x3371,   // U+36d8 ~ U+36df
0x3372, 0x3373, 0x3374, 0x3375, 0x3376, 0x3377, 0x3378, 0x3379,   // U+36e0 ~ U+36e7
0x337a, 0x337b, 0x337c, 0x337d, 0x337e, 0x337f, 0x3380, 0x3381,   // U+36e8 ~ U+36ef
0x3382, 0x3383, 0x3384, 0x3385, 0x3386, 0x3387, 0x3388, 0x3389,   // U+36f0 ~ U+36f7
0x338a, 0x338b, 0x338c, 0x338d, 0x338e, 0x338f, 0x3390, 0x3391,   // U+36f8 ~ U+36ff
0x3392, 0x3393, 0x3394, 0x3395, 0x3396, 0x3397, 0x3398, 0x3399,   // U+3700 ~ U+3707
0x339a, 0x339b, 0x339c, 0x339d, 0x339e, 0x339f, 0x33a0, 0x33a1,   // U+3708 ~ U+370f
0x33a2, 0x33a3, 0x33a4, 0x33a5, 0x33a6, 0x33a7, 0x33a8, 0x33a9,   // U+3710 ~ U+3717
0x33aa, 0x33ab, 0x33ac, 0x33ad, 0x33ae, 0x33af, 0x33b0, 0x33b1,   // U+3718 ~ U+371f
0x33b2, 0x33b3, 0x33b4, 0x33b5, 0x33b6, 0x33b7, 0x33b8, 0x33b9,   // U+3720 ~ U+3727
0x33ba, 0x33bb, 0x33bc, 0x33bd, 0x33be, 0x33bf, 0x33c0, 0x33c1,   // U+3728 ~ U+372f
0x33c2, 0x33c3, 0x33c4, 0x33c5, 0x33c6, 0x33c7, 0x33c8, 0x33c9,   // U+3730 ~ U+3737
0x33ca, 0x33cb, 0x33cc, 0x33cd, 0x33ce, 0x33cf, 0x33d0, 0x33d1,   // U+3738 ~ U+373f
0x33d2, 0x33d3, 0x33d4, 0x33d5, 0x33d6, 0x33d7, 0x33d8, 0x33d9,   // U+3740 ~ U+3747
0x33da, 0x33db, 0x33dc, 0x33dd, 0x33de, 0x33df, 0x33e0, 0x33e1,   // U+3748 ~ U+374f
0x33e2, 0x33e3, 0x33e4, 0x33e5, 0x33e6, 0x33e7, 0x33e8, 0x33e9,   // U+3750 ~ U+3757
0x33ea, 0x33eb, 0x33ec, 0x33ed, 0x33ee, 0x33ef, 0x33f0, 0x33f1,   // U+3758 ~ U+375f
0x33f2, 0x33f3, 0x33f4, 0x33f5, 0x33f6, 0x33f7, 0x33f8, 0x33f9,   // U+3760 ~ U+3767
0x33fa, 0x33fb, 0x33fc, 0x33fd, 0x33fe, 0x33ff, 0x3400, 0x3401,   // U+3768 ~ U+376f
0x3402, 0x3403, 0x3404, 0x3405, 0x3406, 0x3407, 0x3408, 0x3409,   // U+3770 ~ U+3777
0x340a, 0x340b, 0x340c, 0x340d, 0x340e, 0x340f, 0x3410, 0x3411,   // U+3778 ~ U+377f
0x3412, 0x3413, 0x3414, 0x3415, 0x3416, 0x3417, 0x3418, 0x3419,   // U+3780 ~ U+3787
0x341a, 0x341b, 0x341c, 0x341d, 0x341e, 0x341f, 0x3420, 0x3421,   // U+3788 ~ U+378f
0x3422, 0x3423, 0x3424, 0x3425, 0x3426, 0x3427, 0x3428, 0x3429,   // U+3790 ~ U+3797
0x342a, 0x342b, 0x342c, 0x342d, 0x342e, 0x342f, 0x3430, 0x3431,   // U+3798 ~ U+379f
0x3432, 0x3433, 0x3434, 0x3435, 0x3436, 0x3437, 0x3438, 0x3439,   // U+37a0 ~ U+37a7
0x343a, 0x343b, 0x343c, 0x343d, 0x343e, 0x343f, 0x3440, 0x3441,   // U+37a8 ~ U+37af
0x3442, 0x3443, 0x3444, 0x3445, 0x3446, 0x3447, 0x3448, 0x3449,   // U+37b0 ~ U+37b7
0x344a, 0x344b, 0x344c, 0x344d, 0x344e, 0x344f, 0x3450, 0x3451,   // U+37b8 ~ U+37bf
0x3452, 0x3453, 0x3454, 0x3455, 0x3456, 0x3457, 0x3458, 0x3459,   // U+37c0 ~ U+37c7
0x345a, 0x345b, 0x345c, 0x345d, 0x345e, 0x345f, 0x3460, 0x3461,   // U+37c8 ~ U+37cf
0x3462, 0x3463, 0x3464, 0x3465, 0x3466, 0x3467, 0x3468, 0x3469,   // U+37d0 ~ U+37d7
0x346a, 0x346b, 0x346c, 0x346d, 0x346e, 0x346f, 0x3470, 0x3471,   // U+37d8 ~ U+37df
0x3472, 0x3473, 0x3474, 0x3475, 0x3476, 0x3477, 0x3478, 0x3479,   // U+37e0 ~ U+37e7
0x347a, 0x347b, 0x347c, 0x347d, 0x347e, 0x347f, 0x3480, 0x3481,   // U+37e8 ~ U+37ef
0x3482, 0x3483, 0x3484, 0x3485, 0x3486, 0x3487, 0x3488, 0x3489,   // U+37f0 ~ U+37f7
0x348a, 0x348b, 0x348c, 0x348d, 0x348e, 0x348f, 0x3490, 0x3491,   // U+37f8 ~ U+37ff
0x3492, 0x3493, 0x3494, 0x3495, 0x3496, 0x3497, 0x3498, 0x3499,   // U+3800 ~ U+3807
0x349a, 0x349b, 0x349c, 0x349d, 0x349e, 0x349f, 0x34a0, 0x34a1,   // U+3808 ~ U+380f
0x34a2, 0x34a3, 0x34a4, 0x34a5, 0x34a6, 0x34a7, 0x34a8, 0x34a9,   // U+3810 ~ U+3817
0x34aa, 0x34ab, 0x34ac, 0x34ad, 0x34ae, 0x34af, 0x34b0, 0x34b1,   // U+3818 ~ U+381f
0x34b2, 0x34b3, 0x34b4, 0x34b5, 0x34b6, 0x34b7, 0x34b8, 0x34b9,   // U+3820 ~ U+3827
0x34ba, 0x34bb, 0x34bc, 0x34bd, 0x34be, 0x34bf, 0x34c0, 0x34c1,   // U+3828 ~ U+382f
0x34c2, 0x34c3, 0x34c4, 0x34c5, 0x34c6, 0x34c7, 0x34c8, 0x34c9,   // U+3830 ~ U+3837
0x34ca, 0x34cb, 0x34cc, 0x34cd, 0x34ce, 0x34cf, 0x34d0, 0x34d1,   // U+3838 ~ U+383f
0x34d2, 0x34d3, 0x34d4, 0x34d5, 0x34d6, 0x34d7, 0x34d8, 0x34d9,   // U+3840 ~ U+3847
0x34da, 0x34db, 0x34dc, 0x34dd, 0x34de, 0x34df, 0x34e0, 0x34e1,   // U+3848 ~ U+384f
0x34e2, 0x34e3, 0x34e4, 0x34e5, 0x34e6, 0x34e7, 0x34e8, 0x34e9,   // U+3850 ~ U+3857
0x34ea, 0x34eb, 0x34ec, 0x34ed, 0x34ee, 0x34ef, 0x34f0, 0x34f1,   // U+3858 ~ U+385f
0x34f2, 0x34f3, 0x34f4, 0x34f5, 0x34f6, 0x34f7, 0x34f8, 0x34f9,   // U+3860 ~ U+3867
0x34fa, 0x34fb, 0x34fc, 0x34fd, 0x34fe, 0x34ff, 0x3500, 0x3501,   // U+3868 ~ U+386f
0x3502, 0x3503, 0x3504, 0x3505, 0x3506, 0x3507, 0x3508, 0x3509,   // U+3870 ~ U+3877
0x350a, 0x350b, 0x350c, 0x350d, 0x350e, 0x350f, 0x3510, 0x3511,   // U+3878 ~ U+387f
0x3512, 0x3513, 0x3514, 0x3515, 0x3516, 0x3517, 0x3518, 0x3519,   // U+3880 ~ U+3887
0x351a, 0x351b, 0x351c, 0x351d, 0x351e, 0x351f, 0x3520, 0x3521,   // U+3888 ~ U+388f
0x3522, 0x3523, 0x3524, 0x3525, 0x3526, 0x3527, 0x3528, 0x3529,   // U+3890 ~ U+3897
0x352a, 0x352b, 0x352c, 0x352d, 0x352e, 0x352f, 0x3530, 0x3531,   // U+3898 ~ U+389f
0x3532, 0x3533, 0x3534, 0x3535, 0x3536, 0x3537, 0x3538, 0x3539,   // U+38a0 ~ U+38a7
0x353a, 0x353b, 0x353c, 0x353d, 0x353e, 0x353f, 0x3540, 0x3541,   // U+38a8 ~ U+38af
0x3542, 0x3543, 0x3544, 0x3545, 0x3546, 0x3547, 0x3548, 0x3549,   // U+38b0 ~ U+38b7
0x354a, 0x354b, 0x354c, 0x354d, 0x354e, 0x354f, 0x3550, 0x3551,   // U+38b8 ~ U+38bf
0x3552, 0x3553, 0x3554, 0x3555, 0x3556, 0x3557, 0x3558, 0x3559,   // U+38c0 ~ U+38c7
0x355a, 0x355b, 0x355c, 0x355d, 0x355e, 0x355f, 0x3560, 0x3561,   // U+38c8 ~ U+38cf
0x3562, 0x3563, 0x3564, 0x3565, 0x3566, 0x3567, 0x3568, 0x3569,   // U+38d0 ~ U+38d7
0x356a, 0x356b, 0x356c, 0x356d, 0x356e, 0x356f, 0x3570, 0x3571,   // U+38d8 ~ U+38df
0x3572, 0x3573, 0x3574, 0x3575, 0x3576, 0x3577, 0x3578, 0x3579,   // U+38e0 ~ U+38e7
0x357a, 0x357b, 0x357c, 0x357d, 0x357e, 0x357f, 0x3580, 0x3581,   // U+38e8 ~ U+38ef
0x3582, 0x3583, 0x3584, 0x3585, 0x3586, 0x3587, 0x3588, 0x3589,   // U+38f0 ~ U+38f7
0x358a, 0x358b, 0x358c, 0x358d, 0x358e, 0x358f, 0x3590, 0x3591,   // U+38f8 ~ U+38ff
0x3592, 0x3593, 0x3594, 0x3595, 0x3596, 0x3597, 0x3598, 0x3599,   // U+3900 ~ U+3907
0x359a, 0x359b, 0x359c, 0x359d, 0x359e, 0x359f, 0x35a0, 0x35a1,   // U+3908 ~ U+390f
0x35a2, 0x35a3, 0x35a4, 0x35a5, 0x35a6, 0x35a7, 0x35a8, 0x35a9,   // U+3910 ~ U+3917
0xffdc, 0x35aa, 0x35ab, 0x35ac, 0x35ad, 0x35ae, 0x35af, 0x35b0,   // U+3918 ~ U+391f
0x35b1, 0x35b2, 0x35b3, 0x35b4, 0x35b5, 0x35b6, 0x35b7, 0x35b8,   // U+3920 ~ U+3927
0x35b9, 0x35ba, 0x35bb, 0x35bc, 0x35bd, 0x35be, 0x35bf, 0x35c0,   // U+3928 ~ U+392f
0x35c1, 0x35c2, 0x35c3, 0x35c4, 0x35c5, 0x35c6, 0x35c7, 0x35c8,   // U+3930 ~ U+3937
0x35c9, 0x35ca, 0x35cb, 0x35cc, 0x35cd, 0x35ce, 0x35cf, 0x35d0,   // U+3938 ~ U+393f
0x35d1, 0x35d2, 0x35d3, 0x35d4, 0x35d5, 0x35d6, 0x35d7, 0x35d8,   // U+3940 ~ U+3947
0x35d9, 0x35da, 0x35db, 0x35dc, 0x35dd, 0x35de, 0x35df, 0x35e0,   // U+3948 ~ U+394f
0x35e1, 0x35e2, 0x35e3, 0x35e4, 0x35e5, 0x35e6, 0x35e7, 0x35e8,   // U+3950 ~ U+3957
0x35e9, 0x35ea, 0x35eb, 0x35ec, 0x35ed, 0x35ee, 0x35ef, 0x35f0,   // U+3958 ~ U+395f
0x35f1, 0x35f2, 0x35f3, 0x35f4, 0x35f5, 0x35f6, 0x35f7, 0x35f8,   // U+3960 ~ U+3967
0x35f9, 0x35fa, 0x35fb, 0x35fc, 0x35fd, 0x35fe, 0xffdb, 0x35ff,   // U+3968 ~ U+396f
0x3600, 0x3601, 0x3602, 0x3603, 0x3604, 0x3605, 0x3606, 0x3607,   // U+3970 ~ U+3977
0x3608, 0x3609, 0x360a, 0x360b, 0x360c, 0x360d, 0x360e, 0x360f,   // U+3978 ~ U+397f
0x3610, 0x3611, 0x3612, 0x3613, 0x3614, 0x3615, 0x3616, 0x3617,   // U+3980 ~ U+3987
0x3618, 0x3619, 0x361a, 0x361b, 0x361c, 0x361d, 0x361e, 0x361f,   // U+3988 ~ U+398f
0x3620, 0x3621, 0x3622, 0x3623, 0x3624, 0x3625, 0x3626, 0x3627,   // U+3990 ~ U+3997
0x3628, 0x3629, 0x362a, 0x362b, 0x362c, 0x362d, 0x362e, 0x362f,   // U+3998 ~ U+399f
0x3630, 0x3631, 0x3632, 0x3633, 0x3634, 0x3635, 0x3636, 0x3637,   // U+39a0 ~ U+39a7
0x3638, 0x3639, 0x363a, 0x363b, 0x363c, 0x363d, 0x363e, 0x363f,   // U+39a8 ~ U+39af
0x3640, 0x3641, 0x3642, 0x3643, 0x3644, 0x3645, 0x3646, 0x3647,   // U+39b0 ~ U+39b7
0x3648, 0x3649, 0x364a, 0x364b, 0x364c, 0x364d, 0x364e, 0x364f,   // U+39b8 ~ U+39bf
0x3650, 0x3651, 0x3652, 0x3653, 0x3654, 0x3655, 0x3656, 0x3657,   // U+39c0 ~ U+39c7
0x3658, 0x3659, 0x365a, 0x365b, 0x365c, 0x365d, 0x365e, 0xffda,   // U+39c8 ~ U+39cf
0xffd9, 0x365f, 0x3660, 0x3661, 0x3662, 0x3663, 0x3664, 0x3665,   // U+39d0 ~ U+39d7
0x3666, 0x3667, 0x3668, 0x3669, 0x366a, 0x366b, 0x366c, 0xffd8,   // U+39d8 ~ U+39df
0x366d, 0x366e, 0x366f, 0x3670, 0x3671, 0x3672, 0x3673, 0x3674,   // U+39e0 ~ U+39e7
0x3675, 0x3676, 0x3677, 0x3678, 0x3679, 0x367a, 0x367b, 0x367c,   // U+39e8 ~ U+39ef
0x367d, 0x367e, 0x367f, 0x3680, 0x3681, 0x3682, 0x3683, 0x3684,   // U+39f0 ~ U+39f7
0x3685, 0x3686, 0x3687, 0x3688, 0x3689, 0x368a, 0x368b, 0x368c,   // U+39f8 ~ U+39ff
0x368d, 0x368e, 0x368f, 0x3690, 0x3691, 0x3692, 0x3693, 0x3694,   // U+3a00 ~ U+3a07
0x3695, 0x3696, 0x3697, 0x3698, 0x3699, 0x369a, 0x369b, 0x369c,   // U+3a08 ~ U+3a0f
0x369d, 0x369e, 0x369f, 0x36a0, 0x36a1, 0x36a2, 0x36a3, 0x36a4,   // U+3a10 ~ U+3a17
0x36a5, 0x36a6, 0x36a7, 0x36a8, 0x36a9, 0x36aa, 0x36ab, 0x36ac,   // U+3a18 ~ U+3a1f
0x36ad, 0x36ae, 0x36af, 0x36b0, 0x36b1, 0x36b2, 0x36b3, 0x36b4,   // U+3a20 ~ U+3a27
0x36b5, 0x36b6, 0x36b7, 0x36b8, 0x36b9, 0x36ba, 0x36bb, 0x36bc,   // U+3a28 ~ U+3a2f
0x36bd, 0x36be, 0x36bf, 0x36c0, 0x36c1, 0x36c2, 0x36c3, 0x36c4,   // U+3a30 ~ U+3a37
0x36c5, 0x36c6, 0x36c7, 0x36c8, 0x36c9, 0x36ca, 0x36cb, 0x36cc,   // U+3a38 ~ U+3a3f
0x36cd, 0x36ce, 0x36cf, 0x36d0, 0x36d1, 0x36d2, 0x36d3, 0x36d4,   // U+3a40 ~ U+3a47
0x36d5, 0x36d6, 0x36d7, 0x36d8, 0x36d9, 0x36da, 0x36db, 0x36dc,   // U+3a48 ~ U+3a4f
0x36dd, 0x36de, 0x36df, 0x36e0, 0x36e1, 0x36e2, 0x36e3, 0x36e4,   // U+3a50 ~ U+3a57
0x36e5, 0x36e6, 0x36e7, 0x36e8, 0x36e9, 0x36ea, 0x36eb, 0x36ec,   // U+3a58 ~ U+3a5f
0x36ed, 0x36ee, 0x36ef, 0x36f0, 0x36f1, 0x36f2, 0x36f3, 0x36f4,   // U+3a60 ~ U+3a67
0x36f5, 0x36f6, 0x36f7, 0x36f8, 0x36f9, 0x36fa, 0x36fb, 0x36fc,   // U+3a68 ~ U+3a6f
0x36fd, 0x36fe, 0x36ff, 0xffd7, 0x3700, 0x3701, 0x3702, 0x3703,   // U+3a70 ~ U+3a77
0x3704, 0x3705, 0x3706, 0x3707, 0x3708, 0x3709, 0x370a, 0x370b,   // U+3a78 ~ U+3a7f
0x370c, 0x370d, 0x370e, 0x370f, 0x3710, 0x3711, 0x3712, 0x3713,   // U+3a80 ~ U+3a87
0x3714, 0x3715, 0x3716, 0x3717, 0x3718, 0x3719, 0x371a, 0x371b,   // U+3a88 ~ U+3a8f
0x371c, 0x371d, 0x371e, 0x371f, 0x3720, 0x3721, 0x3722, 0x3723,   // U+3a90 ~ U+3a97
0x3724, 0x3725, 0x3726, 0x3727, 0x3728, 0x3729, 0x372a, 0x372b,   // U+3a98 ~ U+3a9f
0x372c, 0x372d, 0x372e, 0x372f, 0x3730, 0x3731, 0x3732, 0x3733,   // U+3aa0 ~ U+3aa7
0x3734, 0x3735, 0x3736, 0x3737, 0x3738, 0x3739, 0x373a, 0x373b,   // U+3aa8 ~ U+3aaf
0x373c, 0x373d, 0x373e, 0x373f, 0x3740, 0x3741, 0x3742, 0x3743,   // U+3ab0 ~ U+3ab7
0x3744, 0x3745, 0x3746, 0x3747, 0x3748, 0x3749, 0x374a, 0x374b,   // U+3ab8 ~ U+3abf
0x374c, 0x374d, 0x374e, 0x374f, 0x3750, 0x3751, 0x3752, 0x3753,   // U+3ac0 ~ U+3ac7
0x3754, 0x3755, 0x3756, 0x3757, 0x3758, 0x3759, 0x375a, 0x375b,   // U+3ac8 ~ U+3acf
0x375c, 0x375d, 0x375e, 0x375f, 0x3760, 0x3761, 0x3762, 0x3763,   // U+3ad0 ~ U+3ad7
0x3764, 0x3765, 0x3766, 0x3767, 0x3768, 0x3769, 0x376a, 0x376b,   // U+3ad8 ~ U+3adf
0x376c, 0x376d, 0x376e, 0x376f, 0x3770, 0x3771, 0x3772, 0x3773,   // U+3ae0 ~ U+3ae7
0x3774, 0x3775, 0x3776, 0x3777, 0x3778, 0x3779, 0x377a, 0x377b,   // U+3ae8 ~ U+3aef
0x377c, 0x377d, 0x377e, 0x377f, 0x3780, 0x3781, 0x3782, 0x3783,   // U+3af0 ~ U+3af7
0x3784, 0x3785, 0x3786, 0x3787, 0x3788, 0x3789, 0x378a, 0x378b,   // U+3af8 ~ U+3aff
0x378c, 0x378d, 0x378e, 0x378f, 0x3790, 0x3791, 0x3792, 0x3793,   // U+3b00 ~ U+3b07
0x3794, 0x3795, 0x3796, 0x3797, 0x3798, 0x3799, 0x379a, 0x379b,   // U+3b08 ~ U+3b0f
0x379c, 0x379d, 0x379e, 0x379f, 0x37a0, 0x37a1, 0x37a2, 0x37a3,   // U+3b10 ~ U+3b17
0x37a4, 0x37a5, 0x37a6, 0x37a7, 0x37a8, 0x37a9, 0x37aa, 0x37ab,   // U+3b18 ~ U+3b1f
0x37ac, 0x37ad, 0x37ae, 0x37af, 0x37b0, 0x37b1, 0x37b2, 0x37b3,   // U+3b20 ~ U+3b27
0x37b4, 0x37b5, 0x37b6, 0x37b7, 0x37b8, 0x37b9, 0x37ba, 0x37bb,   // U+3b28 ~ U+3b2f
0x37bc, 0x37bd, 0x37be, 0x37bf, 0x37c0, 0x37c1, 0x37c2, 0x37c3,   // U+3b30 ~ U+3b37
0x37c4, 0x37c5, 0x37c6, 0x37c7, 0x37c8, 0x37c9, 0x37ca, 0x37cb,   // U+3b38 ~ U+3b3f
0x37cc, 0x37cd, 0x37ce, 0x37cf, 0x37d0, 0x37d1, 0x37d2, 0x37d3,   // U+3b40 ~ U+3b47
0x37d4, 0x37d5, 0x37d6, 0x37d7, 0x37d8, 0x37d9, 0xffd6, 0x37da,   // U+3b48 ~ U+3b4f
0x37db, 0x37dc, 0x37dd, 0x37de, 0x37df, 0x37e0, 0x37e1, 0x37e2,   // U+3b50 ~ U+3b57
0x37e3, 0x37e4, 0x37e5, 0x37e6, 0x37e7, 0x37e8, 0x37e9, 0x37ea,   // U+3b58 ~ U+3b5f
0x37eb, 0x37ec, 0x37ed, 0x37ee, 0x37ef, 0x37f0, 0x37f1, 0x37f2,   // U+3b60 ~ U+3b67
0x37f3, 0x37f4, 0x37f5, 0x37f6, 0x37f7, 0x37f8, 0x37f9, 0x37fa,   // U+3b68 ~ U+3b6f
0x37fb, 0x37fc, 0x37fd, 0x37fe, 0x37ff, 0x3800, 0x3801, 0x3802,   // U+3b70 ~ U+3b77
0x3803, 0x3804, 0x3805, 0x3806, 0x3807, 0x3808, 0x3809, 0x380a,   // U+3b78 ~ U+3b7f
0x380b, 0x380c, 0x380d, 0x380e, 0x380f, 0x3810, 0x3811, 0x3812,   // U+3b80 ~ U+3b87
0x3813, 0x3814, 0x3815, 0x3816, 0x3817, 0x3818, 0x3819, 0x381a,   // U+3b88 ~ U+3b8f
0x381b, 0x381c, 0x381d, 0x381e, 0x381f, 0x3820, 0x3821, 0x3822,   // U+3b90 ~ U+3b97
0x3823, 0x3824, 0x3825, 0x3826, 0x3827, 0x3828, 0x3829, 0x382a,   // U+3b98 ~ U+3b9f
0x382b, 0x382c, 0x382d, 0x382e, 0x382f, 0x3830, 0x3831, 0x3832,   // U+3ba0 ~ U+3ba7
0x3833, 0x3834, 0x3835, 0x3836, 0x3837, 0x3838, 0x3839, 0x383a,   // U+3ba8 ~ U+3baf
0x383b, 0x383c, 0x383d, 0x383e, 0x383f, 0x3840, 0x3841, 0x3842,   // U+3bb0 ~ U+3bb7
0x3843, 0x3844, 0x3845, 0x3846, 0x3847, 0x3848, 0x3849, 0x384a,   // U+3bb8 ~ U+3bbf
0x384b, 0x384c, 0x384d, 0x384e, 0x384f, 0x3850, 0x3851, 0x3852,   // U+3bc0 ~ U+3bc7
0x3853, 0x3854, 0x3855, 0x3856, 0x3857, 0x3858, 0x3859, 0x385a,   // U+3bc8 ~ U+3bcf
0x385b, 0x385c, 0x385d, 0x385e, 0x385f, 0x3860, 0x3861, 0x3862,   // U+3bd0 ~ U+3bd7
0x3863, 0x3864, 0x3865, 0x3866, 0x3867, 0x3868, 0x3869, 0x386a,   // U+3bd8 ~ U+3bdf
0x386b, 0x386c, 0x386d, 0x386e, 0x386f, 0x3870, 0x3871, 0x3872,   // U+3be0 ~ U+3be7
0x3873, 0x3874, 0x3875, 0x3876, 0x3877, 0x3878, 0x3879, 0x387a,   // U+3be8 ~ U+3bef
0x387b, 0x387c, 0x387d, 0x387e, 0x387f, 0x3880, 0x3881, 0x3882,   // U+3bf0 ~ U+3bf7
0x3883, 0x3884, 0x3885, 0x3886, 0x3887, 0x3888, 0x3889, 0x388a,   // U+3bf8 ~ U+3bff
0x388b, 0x388c, 0x388d, 0x388e, 0x388f, 0x3890, 0x3891, 0x3892,   // U+3c00 ~ U+3c07
0x3893, 0x3894, 0x3895, 0x3896, 0x3897, 0x3898, 0x3899, 0x389a,   // U+3c08 ~ U+3c0f
0x389b, 0x389c, 0x389d, 0x389e, 0x389f, 0x38a0, 0x38a1, 0x38a2,   // U+3c10 ~ U+3c17
0x38a3, 0x38a4, 0x38a5, 0x38a6, 0x38a7, 0x38a8, 0x38a9, 0x38aa,   // U+3c18 ~ U+3c1f
0x38ab, 0x38ac, 0x38ad, 0x38ae, 0x38af, 0x38b0, 0x38b1, 0x38b2,   // U+3c20 ~ U+3c27
0x38b3, 0x38b4, 0x38b5, 0x38b6, 0x38b7, 0x38b8, 0x38b9, 0x38ba,   // U+3c28 ~ U+3c2f
0x38bb, 0x38bc, 0x38bd, 0x38be, 0x38bf, 0x38c0, 0x38c1, 0x38c2,   // U+3c30 ~ U+3c37
0x38c3, 0x38c4, 0x38c5, 0x38c6, 0x38c7, 0x38c8, 0x38c9, 0x38ca,   // U+3c38 ~ U+3c3f
0x38cb, 0x38cc, 0x38cd, 0x38ce, 0x38cf, 0x38d0, 0x38d1, 0x38d2,   // U+3c40 ~ U+3c47
0x38d3, 0x38d4, 0x38d5, 0x38d6, 0x38d7, 0x38d8, 0x38d9, 0x38da,   // U+3c48 ~ U+3c4f
0x38db, 0x38dc, 0x38dd, 0x38de, 0x38df, 0x38e0, 0x38e1, 0x38e2,   // U+3c50 ~ U+3c57
0x38e3, 0x38e4, 0x38e5, 0x38e6, 0x38e7, 0x38e8, 0x38e9, 0x38ea,   // U+3c58 ~ U+3c5f
0x38eb, 0x38ec, 0x38ed, 0x38ee, 0x38ef, 0x38f0, 0x38f1, 0x38f2,   // U+3c60 ~ U+3c67
0x38f3, 0x38f4, 0x38f5, 0x38f6, 0x38f7, 0x38f8, 0xffd5, 0x38f9,   // U+3c68 ~ U+3c6f
0x38fa, 0x38fb, 0x38fc, 0x38fd, 0x38fe, 0x38ff, 0x3900, 0x3901,   // U+3c70 ~ U+3c77
0x3902, 0x3903, 0x3904, 0x3905, 0x3906, 0x3907, 0x3908, 0x3909,   // U+3c78 ~ U+3c7f
0x390a, 0x390b, 0x390c, 0x390d, 0x390e, 0x390f, 0x3910, 0x3911,   // U+3c80 ~ U+3c87
0x3912, 0x3913, 0x3914, 0x3915, 0x3916, 0x3917, 0x3918, 0x3919,   // U+3c88 ~ U+3c8f
0x391a, 0x391b, 0x391c, 0x391d, 0x391e, 0x391f, 0x3920, 0x3921,   // U+3c90 ~ U+3c97
0x3922, 0x3923, 0x3924, 0x3925, 0x3926, 0x3927, 0x3928, 0x3929,   // U+3c98 ~ U+3c9f
0x392a, 0x392b, 0x392c, 0x392d, 0x392e, 0x392f, 0x3930, 0x3931,   // U+3ca0 ~ U+3ca7
0x3932, 0x3933, 0x3934, 0x3935, 0x3936, 0x3937, 0x3938, 0x3939,   // U+3ca8 ~ U+3caf
0x393a, 0x393b, 0x393c, 0x393d, 0x393e, 0x393f, 0x3940, 0x3941,   // U+3cb0 ~ U+3cb7
0x3942, 0x3943, 0x3944, 0x3945, 0x3946, 0x3947, 0x3948, 0x3949,   // U+3cb8 ~ U+3cbf
0x394a, 0x394b, 0x394c, 0x394d, 0x394e, 0x394f, 0x3950, 0x3951,   // U+3cc0 ~ U+3cc7
0x3952, 0x3953, 0x3954, 0x3955, 0x3956, 0x3957, 0x3958, 0x3959,   // U+3cc8 ~ U+3ccf
0x395a, 0x395b, 0x395c, 0x395d, 0x395e, 0x395f, 0x3960, 0x3961,   // U+3cd0 ~ U+3cd7
0x3962, 0x3963, 0x3964, 0x3965, 0x3966, 0x3967, 0x3968, 0x3969,   // U+3cd8 ~ U+3cdf
0xffd4, 0x396a, 0x396b, 0x396c, 0x396d, 0x396e, 0x396f, 0x3970,   // U+3ce0 ~ U+3ce7
0x3971, 0x3972, 0x3973, 0x3974, 0x3975, 0x3976, 0x3977, 0x3978,   // U+3ce8 ~ U+3cef
0x3979, 0x397a, 0x397b, 0x397c, 0x397d, 0x397e, 0x397f, 0x3980,   // U+3cf0 ~ U+3cf7
0x3981, 0x3982, 0x3983, 0x3984, 0x3985, 0x3986, 0x3987, 0x3988,   // U+3cf8 ~ U+3cff
0x3989, 0x398a, 0x398b, 0x398c, 0x398d, 0x398e, 0x398f, 0x3990,   // U+3d00 ~ U+3d07
0x3991, 0x3992, 0x3993, 0x3994, 0x3995, 0x3996, 0x3997, 0x3998,   // U+3d08 ~ U+3d0f
0x3999, 0x399a, 0x399b, 0x399c, 0x399d, 0x399e, 0x399f, 0x39a0,   // U+3d10 ~ U+3d17
0x39a1, 0x39a2, 0x39a3, 0x39a4, 0x39a5, 0x39a6, 0x39a7, 0x39a8,   // U+3d18 ~ U+3d1f
0x39a9, 0x39aa, 0x39ab, 0x39ac, 0x39ad, 0x39ae, 0x39af, 0x39b0,   // U+3d20 ~ U+3d27
0x39b1, 0x39b2, 0x39b3, 0x39b4, 0x39b5, 0x39b6, 0x39b7, 0x39b8,   // U+3d28 ~ U+3d2f
0x39b9, 0x39ba, 0x39bb, 0x39bc, 0x39bd, 0x39be, 0x39bf, 0x39c0,   // U+3d30 ~ U+3d37
0x39c1, 0x39c2, 0x39c3, 0x39c4, 0x39c5, 0x39c6, 0x39c7, 0x39c8,   // U+3d38 ~ U+3d3f
0x39c9, 0x39ca, 0x39cb, 0x39cc, 0x39cd, 0x39ce, 0x39cf, 0x39d0,   // U+3d40 ~ U+3d47
0x39d1, 0x39d2, 0x39d3, 0x39d4, 0x39d5, 0x39d6, 0x39d7, 0x39d8,   // U+3d48 ~ U+3d4f
0x39d9, 0x39da, 0x39db, 0x39dc, 0x39dd, 0x39de, 0x39df, 0x39e0,   // U+3d50 ~ U+3d57
0x39e1, 0x39e2, 0x39e3, 0x39e4, 0x39e5, 0x39e6, 0x39e7, 0x39e8,   // U+3d58 ~ U+3d5f
0x39e9, 0x39ea, 0x39eb, 0x39ec, 0x39ed, 0x39ee, 0x39ef, 0x39f0,   // U+3d60 ~ U+3d67
0x39f1, 0x39f2, 0x39f3, 0x39f4, 0x39f5, 0x39f6, 0x39f7, 0x39f8,   // U+3d68 ~ U+3d6f
0x39f9, 0x39fa, 0x39fb, 0x39fc, 0x39fd, 0x39fe, 0x39ff, 0x3a00,   // U+3d70 ~ U+3d77
0x3a01, 0x3a02, 0x3a03, 0x3a04, 0x3a05, 0x3a06, 0x3a07, 0x3a08,   // U+3d78 ~ U+3d7f
0x3a09, 0x3a0a, 0x3a0b, 0x3a0c, 0x3a0d, 0x3a0e, 0x3a0f, 0x3a10,   // U+3d80 ~ U+3d87
0x3a11, 0x3a12, 0x3a13, 0x3a14, 0x3a15, 0x3a16, 0x3a17, 0x3a18,   // U+3d88 ~ U+3d8f
0x3a19, 0x3a1a, 0x3a1b, 0x3a1c, 0x3a1d, 0x3a1e, 0x3a1f, 0x3a20,   // U+3d90 ~ U+3d97
0x3a21, 0x3a22, 0x3a23, 0x3a24, 0x3a25, 0x3a26, 0x3a27, 0x3a28,   // U+3d98 ~ U+3d9f
0x3a29, 0x3a2a, 0x3a2b, 0x3a2c, 0x3a2d, 0x3a2e, 0x3a2f, 0x3a30,   // U+3da0 ~ U+3da7
0x3a31, 0x3a32, 0x3a33, 0x3a34, 0x3a35, 0x3a36, 0x3a37, 0x3a38,   // U+3da8 ~ U+3daf
0x3a39, 0x3a3a, 0x3a3b, 0x3a3c, 0x3a3d, 0x3a3e, 0x3a3f, 0x3a40,   // U+3db0 ~ U+3db7
0x3a41, 0x3a42, 0x3a43, 0x3a44, 0x3a45, 0x3a46, 0x3a47, 0x3a48,   // U+3db8 ~ U+3dbf
0x3a49, 0x3a4a, 0x3a4b, 0x3a4c, 0x3a4d, 0x3a4e, 0x3a4f, 0x3a50,   // U+3dc0 ~ U+3dc7
0x3a51, 0x3a52, 0x3a53, 0x3a54, 0x3a55, 0x3a56, 0x3a57, 0x3a58,   // U+3dc8 ~ U+3dcf
0x3a59, 0x3a5a, 0x3a5b, 0x3a5c, 0x3a5d, 0x3a5e, 0x3a5f, 0x3a60,   // U+3dd0 ~ U+3dd7
0x3a61, 0x3a62, 0x3a63, 0x3a64, 0x3a65, 0x3a66, 0x3a67, 0x3a68,   // U+3dd8 ~ U+3ddf
0x3a69, 0x3a6a, 0x3a6b, 0x3a6c, 0x3a6d, 0x3a6e, 0x3a6f, 0x3a70,   // U+3de0 ~ U+3de7
0x3a71, 0x3a72, 0x3a73, 0x3a74, 0x3a75, 0x3a76, 0x3a77, 0x3a78,   // U+3de8 ~ U+3def
0x3a79, 0x3a7a, 0x3a7b, 0x3a7c, 0x3a7d, 0x3a7e, 0x3a7f, 0x3a80,   // U+3df0 ~ U+3df7
0x3a81, 0x3a82, 0x3a83, 0x3a84, 0x3a85, 0x3a86, 0x3a87, 0x3a88,   // U+3df8 ~ U+3dff
0x3a89, 0x3a8a, 0x3a8b, 0x3a8c, 0x3a8d, 0x3a8e, 0x3a8f, 0x3a90,   // U+3e00 ~ U+3e07
0x3a91, 0x3a92, 0x3a93, 0x3a94, 0x3a95, 0x3a96, 0x3a97, 0x3a98,   // U+3e08 ~ U+3e0f
0x3a99, 0x3a9a, 0x3a9b, 0x3a9c, 0x3a9d, 0x3a9e, 0x3a9f, 0x3aa0,   // U+3e10 ~ U+3e17
0x3aa1, 0x3aa2, 0x3aa3, 0x3aa4, 0x3aa5, 0x3aa6, 0x3aa7, 0x3aa8,   // U+3e18 ~ U+3e1f
0x3aa9, 0x3aaa, 0x3aab, 0x3aac, 0x3aad, 0x3aae, 0x3aaf, 0x3ab0,   // U+3e20 ~ U+3e27
0x3ab1, 0x3ab2, 0x3ab3, 0x3ab4, 0x3ab5, 0x3ab6, 0x3ab7, 0x3ab8,   // U+3e28 ~ U+3e2f
0x3ab9, 0x3aba, 0x3abb, 0x3abc, 0x3abd, 0x3abe, 0x3abf, 0x3ac0,   // U+3e30 ~ U+3e37
0x3ac1, 0x3ac2, 0x3ac3, 0x3ac4, 0x3ac5, 0x3ac6, 0x3ac7, 0x3ac8,   // U+3e38 ~ U+3e3f
0x3ac9, 0x3aca, 0x3acb, 0x3acc, 0x3acd, 0x3ace, 0x3acf, 0x3ad0,   // U+3e40 ~ U+3e47
0x3ad1, 0x3ad2, 0x3ad3, 0x3ad4, 0x3ad5, 0x3ad6, 0x3ad7, 0x3ad8,   // U+3e48 ~ U+3e4f
0x3ad9, 0x3ada, 0x3adb, 0x3adc, 0x3add, 0x3ade, 0x3adf, 0x3ae0,   // U+3e50 ~ U+3e57
0x3ae1, 0x3ae2, 0x3ae3, 0x3ae4, 0x3ae5, 0x3ae6, 0x3ae7, 0x3ae8,   // U+3e58 ~ U+3e5f
0x3ae9, 0x3aea, 0x3aeb, 0x3aec, 0x3aed, 0x3aee, 0x3aef, 0x3af0,   // U+3e60 ~ U+3e67
0x3af1, 0x3af2, 0x3af3, 0x3af4, 0x3af5, 0x3af6, 0x3af7, 0x3af8,   // U+3e68 ~ U+3e6f
0x3af9, 0x3afa, 0x3afb, 0x3afc, 0x3afd, 0x3afe, 0x3aff, 0x3b00,   // U+3e70 ~ U+3e77
0x3b01, 0x3b02, 0x3b03, 0x3b04, 0x3b05, 0x3b06, 0x3b07, 0x3b08,   // U+3e78 ~ U+3e7f
0x3b09, 0x3b0a, 0x3b0b, 0x3b0c, 0x3b0d, 0x3b0e, 0x3b0f, 0x3b10,   // U+3e80 ~ U+3e87
0x3b11, 0x3b12, 0x3b13, 0x3b14, 0x3b15, 0x3b16, 0x3b17, 0x3b18,   // U+3e88 ~ U+3e8f
0x3b19, 0x3b1a, 0x3b1b, 0x3b1c, 0x3b1d, 0x3b1e, 0x3b1f, 0x3b20,   // U+3e90 ~ U+3e97
0x3b21, 0x3b22, 0x3b23, 0x3b24, 0x3b25, 0x3b26, 0x3b27, 0x3b28,   // U+3e98 ~ U+3e9f
0x3b29, 0x3b2a, 0x3b2b, 0x3b2c, 0x3b2d, 0x3b2e, 0x3b2f, 0x3b30,   // U+3ea0 ~ U+3ea7
0x3b31, 0x3b32, 0x3b33, 0x3b34, 0x3b35, 0x3b36, 0x3b37, 0x3b38,   // U+3ea8 ~ U+3eaf
0x3b39, 0x3b3a, 0x3b3b, 0x3b3c, 0x3b3d, 0x3b3e, 0x3b3f, 0x3b40,   // U+3eb0 ~ U+3eb7
0x3b41, 0x3b42, 0x3b43, 0x3b44, 0x3b45, 0x3b46, 0x3b47, 0x3b48,   // U+3eb8 ~ U+3ebf
0x3b49, 0x3b4a, 0x3b4b, 0x3b4c, 0x3b4d, 0x3b4e, 0x3b4f, 0x3b50,   // U+3ec0 ~ U+3ec7
0x3b51, 0x3b52, 0x3b53, 0x3b54, 0x3b55, 0x3b56, 0x3b57, 0x3b58,   // U+3ec8 ~ U+3ecf
0x3b59, 0x3b5a, 0x3b5b, 0x3b5c, 0x3b5d, 0x3b5e, 0x3b5f, 0x3b60,   // U+3ed0 ~ U+3ed7
0x3b61, 0x3b62, 0x3b63, 0x3b64, 0x3b65, 0x3b66, 0x3b67, 0x3b68,   // U+3ed8 ~ U+3edf
0x3b69, 0x3b6a, 0x3b6b, 0x3b6c, 0x3b6d, 0x3b6e, 0x3b6f, 0x3b70,   // U+3ee0 ~ U+3ee7
0x3b71, 0x3b72, 0x3b73, 0x3b74, 0x3b75, 0x3b76, 0x3b77, 0x3b78,   // U+3ee8 ~ U+3eef
0x3b79, 0x3b7a, 0x3b7b, 0x3b7c, 0x3b7d, 0x3b7e, 0x3b7f, 0x3b80,   // U+3ef0 ~ U+3ef7
0x3b81, 0x3b82, 0x3b83, 0x3b84, 0x3b85, 0x3b86, 0x3b87, 0x3b88,   // U+3ef8 ~ U+3eff
0x3b89, 0x3b8a, 0x3b8b, 0x3b8c, 0x3b8d, 0x3b8e, 0x3b8f, 0x3b90,   // U+3f00 ~ U+3f07
0x3b91, 0x3b92, 0x3b93, 0x3b94, 0x3b95, 0x3b96, 0x3b97, 0x3b98,   // U+3f08 ~ U+3f0f
0x3b99, 0x3b9a, 0x3b9b, 0x3b9c, 0x3b9d, 0x3b9e, 0x3b9f, 0x3ba0,   // U+3f10 ~ U+3f17
0x3ba1, 0x3ba2, 0x3ba3, 0x3ba4, 0x3ba5, 0x3ba6, 0x3ba7, 0x3ba8,   // U+3f18 ~ U+3f1f
0x3ba9, 0x3baa, 0x3bab, 0x3bac, 0x3bad, 0x3bae, 0x3baf, 0x3bb0,   // U+3f20 ~ U+3f27
0x3bb1, 0x3bb2, 0x3bb3, 0x3bb4, 0x3bb5, 0x3bb6, 0x3bb7, 0x3bb8,   // U+3f28 ~ U+3f2f
0x3bb9, 0x3bba, 0x3bbb, 0x3bbc, 0x3bbd, 0x3bbe, 0x3bbf, 0x3bc0,   // U+3f30 ~ U+3f37
0x3bc1, 0x3bc2, 0x3bc3, 0x3bc4, 0x3bc5, 0x3bc6, 0x3bc7, 0x3bc8,   // U+3f38 ~ U+3f3f
0x3bc9, 0x3bca, 0x3bcb, 0x3bcc, 0x3bcd, 0x3bce, 0x3bcf, 0x3bd0,   // U+3f40 ~ U+3f47
0x3bd1, 0x3bd2, 0x3bd3, 0x3bd4, 0x3bd5, 0x3bd6, 0x3bd7, 0x3bd8,   // U+3f48 ~ U+3f4f
0x3bd9, 0x3bda, 0x3bdb, 0x3bdc, 0x3bdd, 0x3bde, 0x3bdf, 0x3be0,   // U+3f50 ~ U+3f57
0x3be1, 0x3be2, 0x3be3, 0x3be4, 0x3be5, 0x3be6, 0x3be7, 0x3be8,   // U+3f58 ~ U+3f5f
0x3be9, 0x3bea, 0x3beb, 0x3bec, 0x3bed, 0x3bee, 0x3bef, 0x3bf0,   // U+3f60 ~ U+3f67
0x3bf1, 0x3bf2, 0x3bf3, 0x3bf4, 0x3bf5, 0x3bf6, 0x3bf7, 0x3bf8,   // U+3f68 ~ U+3f6f
0x3bf9, 0x3bfa, 0x3bfb, 0x3bfc, 0x3bfd, 0x3bfe, 0x3bff, 0x3c00,   // U+3f70 ~ U+3f77
0x3c01, 0x3c02, 0x3c03, 0x3c04, 0x3c05, 0x3c06, 0x3c07, 0x3c08,   // U+3f78 ~ U+3f7f
0x3c09, 0x3c0a, 0x3c0b, 0x3c0c, 0x3c0d, 0x3c0e, 0x3c0f, 0x3c10,   // U+3f80 ~ U+3f87
0x3c11, 0x3c12, 0x3c13, 0x3c14, 0x3c15, 0x3c16, 0x3c17, 0x3c18,   // U+3f88 ~ U+3f8f
0x3c19, 0x3c1a, 0x3c1b, 0x3c1c, 0x3c1d, 0x3c1e, 0x3c1f, 0x3c20,   // U+3f90 ~ U+3f97
0x3c21, 0x3c22, 0x3c23, 0x3c24, 0x3c25, 0x3c26, 0x3c27, 0x3c28,   // U+3f98 ~ U+3f9f
0x3c29, 0x3c2a, 0x3c2b, 0x3c2c, 0x3c2d, 0x3c2e, 0x3c2f, 0x3c30,   // U+3fa0 ~ U+3fa7
0x3c31, 0x3c32, 0x3c33, 0x3c34, 0x3c35, 0x3c36, 0x3c37, 0x3c38,   // U+3fa8 ~ U+3faf
0x3c39, 0x3c3a, 0x3c3b, 0x3c3c, 0x3c3d, 0x3c3e, 0x3c3f, 0x3c40,   // U+3fb0 ~ U+3fb7
0x3c41, 0x3c42, 0x3c43, 0x3c44, 0x3c45, 0x3c46, 0x3c47, 0x3c48,   // U+3fb8 ~ U+3fbf
0x3c49, 0x3c4a, 0x3c4b, 0x3c4c, 0x3c4d, 0x3c4e, 0x3c4f, 0x3c50,   // U+3fc0 ~ U+3fc7
0x3c51, 0x3c52, 0x3c53, 0x3c54, 0x3c55, 0x3c56, 0x3c57, 0x3c58,   // U+3fc8 ~ U+3fcf
0x3c59, 0x3c5a, 0x3c5b, 0x3c5c, 0x3c5d, 0x3c5e, 0x3c5f, 0x3c60,   // U+3fd0 ~ U+3fd7
0x3c61, 0x3c62, 0x3c63, 0x3c64, 0x3c65, 0x3c66, 0x3c67, 0x3c68,   // U+3fd8 ~ U+3fdf
0x3c69, 0x3c6a, 0x3c6b, 0x3c6c, 0x3c6d, 0x3c6e, 0x3c6f, 0x3c70,   // U+3fe0 ~ U+3fe7
0x3c71, 0x3c72, 0x3c73, 0x3c74, 0x3c75, 0x3c76, 0x3c77, 0x3c78,   // U+3fe8 ~ U+3fef
0x3c79, 0x3c7a, 0x3c7b, 0x3c7c, 0x3c7d, 0x3c7e, 0x3c7f, 0x3c80,   // U+3ff0 ~ U+3ff7
0x3c81, 0x3c82, 0x3c83, 0x3c84, 0x3c85, 0x3c86, 0x3c87, 0x3c88,   // U+3ff8 ~ U+3fff
0x3c89, 0x3c8a, 0x3c8b, 0x3c8c, 0x3c8d, 0x3c8e, 0x3c8f, 0x3c90,   // U+4000 ~ U+4007
0x3c91, 0x3c92, 0x3c93, 0x3c94, 0x3c95, 0x3c96, 0x3c97, 0x3c98,   // U+4008 ~ U+400f
0x3c99, 0x3c9a, 0x3c9b, 0x3c9c, 0x3c9d, 0x3c9e, 0x3c9f, 0x3ca0,   // U+4010 ~ U+4017
0x3ca1, 0x3ca2, 0x3ca3, 0x3ca4, 0x3ca5, 0x3ca6, 0x3ca7, 0x3ca8,   // U+4018 ~ U+401f
0x3ca9, 0x3caa, 0x3cab, 0x3cac, 0x3cad, 0x3cae, 0x3caf, 0x3cb0,   // U+4020 ~ U+4027
0x3cb1, 0x3cb2, 0x3cb3, 0x3cb4, 0x3cb5, 0x3cb6, 0x3cb7, 0x3cb8,   // U+4028 ~ U+402f
0x3cb9, 0x3cba, 0x3cbb, 0x3cbc, 0x3cbd, 0x3cbe, 0x3cbf, 0x3cc0,   // U+4030 ~ U+4037
0x3cc1, 0x3cc2, 0x3cc3, 0x3cc4, 0x3cc5, 0x3cc6, 0x3cc7, 0x3cc8,   // U+4038 ~ U+403f
0x3cc9, 0x3cca, 0x3ccb, 0x3ccc, 0x3ccd, 0x3cce, 0x3ccf, 0x3cd0,   // U+4040 ~ U+4047
0x3cd1, 0x3cd2, 0x3cd3, 0x3cd4, 0x3cd5, 0x3cd6, 0x3cd7, 0x3cd8,   // U+4048 ~ U+404f
0x3cd9, 0x3cda, 0x3cdb, 0x3cdc, 0x3cdd, 0x3cde, 0xffd3, 0x3cdf,   // U+4050 ~ U+4057
0x3ce0, 0x3ce1, 0x3ce2, 0x3ce3, 0x3ce4, 0x3ce5, 0x3ce6, 0x3ce7,   // U+4058 ~ U+405f
0x3ce8, 0x3ce9, 0x3cea, 0x3ceb, 0x3cec, 0x3ced, 0x3cee, 0x3cef,   // U+4060 ~ U+4067
0x3cf0, 0x3cf1, 0x3cf2, 0x3cf3, 0x3cf4, 0x3cf5, 0x3cf6, 0x3cf7,   // U+4068 ~ U+406f
0x3cf8, 0x3cf9, 0x3cfa, 0x3cfb, 0x3cfc, 0x3cfd, 0x3cfe, 0x3cff,   // U+4070 ~ U+4077
0x3d00, 0x3d01, 0x3d02, 0x3d03, 0x3d04, 0x3d05, 0x3d06, 0x3d07,   // U+4078 ~ U+407f
0x3d08, 0x3d09, 0x3d0a, 0x3d0b, 0x3d0c, 0x3d0d, 0x3d0e, 0x3d0f,   // U+4080 ~ U+4087
0x3d10, 0x3d11, 0x3d12, 0x3d13, 0x3d14, 0x3d15, 0x3d16, 0x3d17,   // U+4088 ~ U+408f
0x3d18, 0x3d19, 0x3d1a, 0x3d1b, 0x3d1c, 0x3d1d, 0x3d1e, 0x3d1f,   // U+4090 ~ U+4097
0x3d20, 0x3d21, 0x3d22, 0x3d23, 0x3d24, 0x3d25, 0x3d26, 0x3d27,   // U+4098 ~ U+409f
0x3d28, 0x3d29, 0x3d2a, 0x3d2b, 0x3d2c, 0x3d2d, 0x3d2e, 0x3d2f,   // U+40a0 ~ U+40a7
0x3d30, 0x3d31, 0x3d32, 0x3d33, 0x3d34, 0x3d35, 0x3d36, 0x3d37,   // U+40a8 ~ U+40af
0x3d38, 0x3d39, 0x3d3a, 0x3d3b, 0x3d3c, 0x3d3d, 0x3d3e, 0x3d3f,   // U+40b0 ~ U+40b7
0x3d40, 0x3d41, 0x3d42, 0x3d43, 0x3d44, 0x3d45, 0x3d46, 0x3d47,   // U+40b8 ~ U+40bf
0x3d48, 0x3d49, 0x3d4a, 0x3d4b, 0x3d4c, 0x3d4d, 0x3d4e, 0x3d4f,   // U+40c0 ~ U+40c7
0x3d50, 0x3d51, 0x3d52, 0x3d53, 0x3d54, 0x3d55, 0x3d56, 0x3d57,   // U+40c8 ~ U+40cf
0x3d58, 0x3d59, 0x3d5a, 0x3d5b, 0x3d5c, 0x3d5d, 0x3d5e, 0x3d5f,   // U+40d0 ~ U+40d7
0x3d60, 0x3d61, 0x3d62, 0x3d63, 0x3d64, 0x3d65, 0x3d66, 0x3d67,   // U+40d8 ~ U+40df
0x3d68, 0x3d69, 0x3d6a, 0x3d6b, 0x3d6c, 0x3d6d, 0x3d6e, 0x3d6f,   // U+40e0 ~ U+40e7
0x3d70, 0x3d71, 0x3d72, 0x3d73, 0x3d74, 0x3d75, 0x3d76, 0x3d77,   // U+40e8 ~ U+40ef
0x3d78, 0x3d79, 0x3d7a, 0x3d7b, 0x3d7c, 0x3d7d, 0x3d7e, 0x3d7f,   // U+40f0 ~ U+40f7
0x3d80, 0x3d81, 0x3d82, 0x3d83, 0x3d84, 0x3d85, 0x3d86, 0x3d87,   // U+40f8 ~ U+40ff
0x3d88, 0x3d89, 0x3d8a, 0x3d8b, 0x3d8c, 0x3d8d, 0x3d8e, 0x3d8f,   // U+4100 ~ U+4107
0x3d90, 0x3d91, 0x3d92, 0x3d93, 0x3d94, 0x3d95, 0x3d96, 0x3d97,   // U+4108 ~ U+410f
0x3d98, 0x3d99, 0x3d9a, 0x3d9b, 0x3d9c, 0x3d9d, 0x3d9e, 0x3d9f,   // U+4110 ~ U+4117
0x3da0, 0x3da1, 0x3da2, 0x3da3, 0x3da4, 0x3da5, 0x3da6, 0x3da7,   // U+4118 ~ U+411f
0x3da8, 0x3da9, 0x3daa, 0x3dab, 0x3dac, 0x3dad, 0x3dae, 0x3daf,   // U+4120 ~ U+4127
0x3db0, 0x3db1, 0x3db2, 0x3db3, 0x3db4, 0x3db5, 0x3db6, 0x3db7,   // U+4128 ~ U+412f
0x3db8, 0x3db9, 0x3dba, 0x3dbb, 0x3dbc, 0x3dbd, 0x3dbe, 0x3dbf,   // U+4130 ~ U+4137
0x3dc0, 0x3dc1, 0x3dc2, 0x3dc3, 0x3dc4, 0x3dc5, 0x3dc6, 0x3dc7,   // U+4138 ~ U+413f
0x3dc8, 0x3dc9, 0x3dca, 0x3dcb, 0x3dcc, 0x3dcd, 0x3dce, 0x3dcf,   // U+4140 ~ U+4147
0x3dd0, 0x3dd1, 0x3dd2, 0x3dd3, 0x3dd4, 0x3dd5, 0x3dd6, 0x3dd7,   // U+4148 ~ U+414f
0x3dd8, 0x3dd9, 0x3dda, 0x3ddb, 0x3ddc, 0x3ddd, 0x3dde, 0x3ddf,   // U+4150 ~ U+4157
0x3de0, 0x3de1, 0x3de2, 0x3de3, 0x3de4, 0x3de5, 0x3de6, 0xffd2,   // U+4158 ~ U+415f
0x3de7, 0x3de8, 0x3de9, 0x3dea, 0x3deb, 0x3dec, 0x3ded, 0x3dee,   // U+4160 ~ U+4167
0x3def, 0x3df0, 0x3df1, 0x3df2, 0x3df3, 0x3df4, 0x3df5, 0x3df6,   // U+4168 ~ U+416f
0x3df7, 0x3df8, 0x3df9, 0x3dfa, 0x3dfb, 0x3dfc, 0x3dfd, 0x3dfe,   // U+4170 ~ U+4177
0x3dff, 0x3e00, 0x3e01, 0x3e02, 0x3e03, 0x3e04, 0x3e05, 0x3e06,   // U+4178 ~ U+417f
0x3e07, 0x3e08, 0x3e09, 0x3e0a, 0x3e0b, 0x3e0c, 0x3e0d, 0x3e0e,   // U+4180 ~ U+4187
0x3e0f, 0x3e10, 0x3e11, 0x3e12, 0x3e13, 0x3e14, 0x3e15, 0x3e16,   // U+4188 ~ U+418f
0x3e17, 0x3e18, 0x3e19, 0x3e1a, 0x3e1b, 0x3e1c, 0x3e1d, 0x3e1e,   // U+4190 ~ U+4197
0x3e1f, 0x3e20, 0x3e21, 0x3e22, 0x3e23, 0x3e24, 0x3e25, 0x3e26,   // U+4198 ~ U+419f
0x3e27, 0x3e28, 0x3e29, 0x3e2a, 0x3e2b, 0x3e2c, 0x3e2d, 0x3e2e,   // U+41a0 ~ U+41a7
0x3e2f, 0x3e30, 0x3e31, 0x3e32, 0x3e33, 0x3e34, 0x3e35, 0x3e36,   // U+41a8 ~ U+41af
0x3e37, 0x3e38, 0x3e39, 0x3e3a, 0x3e3b, 0x3e3c, 0x3e3d, 0x3e3e,   // U+41b0 ~ U+41b7
0x3e3f, 0x3e40, 0x3e41, 0x3e42, 0x3e43, 0x3e44, 0x3e45, 0x3e46,   // U+41b8 ~ U+41bf
0x3e47, 0x3e48, 0x3e49, 0x3e4a, 0x3e4b, 0x3e4c, 0x3e4d, 0x3e4e,   // U+41c0 ~ U+41c7
0x3e4f, 0x3e50, 0x3e51, 0x3e52, 0x3e53, 0x3e54, 0x3e55, 0x3e56,   // U+41c8 ~ U+41cf
0x3e57, 0x3e58, 0x3e59, 0x3e5a, 0x3e5b, 0x3e5c, 0x3e5d, 0x3e5e,   // U+41d0 ~ U+41d7
0x3e5f, 0x3e60, 0x3e61, 0x3e62, 0x3e63, 0x3e64, 0x3e65, 0x3e66,   // U+41d8 ~ U+41df
0x3e67, 0x3e68, 0x3e69, 0x3e6a, 0x3e6b, 0x3e6c, 0x3e6d, 0x3e6e,   // U+41e0 ~ U+41e7
0x3e6f, 0x3e70, 0x3e71, 0x3e72, 0x3e73, 0x3e74, 0x3e75, 0x3e76,   // U+41e8 ~ U+41ef
0x3e77, 0x3e78, 0x3e79, 0x3e7a, 0x3e7b, 0x3e7c, 0x3e7d, 0x3e7e,   // U+41f0 ~ U+41f7
0x3e7f, 0x3e80, 0x3e81, 0x3e82, 0x3e83, 0x3e84, 0x3e85, 0x3e86,   // U+41f8 ~ U+41ff
0x3e87, 0x3e88, 0x3e89, 0x3e8a, 0x3e8b, 0x3e8c, 0x3e8d, 0x3e8e,   // U+4200 ~ U+4207
0x3e8f, 0x3e90, 0x3e91, 0x3e92, 0x3e93, 0x3e94, 0x3e95, 0x3e96,   // U+4208 ~ U+420f
0x3e97, 0x3e98, 0x3e99, 0x3e9a, 0x3e9b, 0x3e9c, 0x3e9d, 0x3e9e,   // U+4210 ~ U+4217
0x3e9f, 0x3ea0, 0x3ea1, 0x3ea2, 0x3ea3, 0x3ea4, 0x3ea5, 0x3ea6,   // U+4218 ~ U+421f
0x3ea7, 0x3ea8, 0x3ea9, 0x3eaa, 0x3eab, 0x3eac, 0x3ead, 0x3eae,   // U+4220 ~ U+4227
0x3eaf, 0x3eb0, 0x3eb1, 0x3eb2, 0x3eb3, 0x3eb4, 0x3eb5, 0x3eb6,   // U+4228 ~ U+422f
0x3eb7, 0x3eb8, 0x3eb9, 0x3eba, 0x3ebb, 0x3ebc, 0x3ebd, 0x3ebe,   // U+4230 ~ U+4237
0x3ebf, 0x3ec0, 0x3ec1, 0x3ec2, 0x3ec3, 0x3ec4, 0x3ec5, 0x3ec6,   // U+4238 ~ U+423f
0x3ec7, 0x3ec8, 0x3ec9, 0x3eca, 0x3ecb, 0x3ecc, 0x3ecd, 0x3ece,   // U+4240 ~ U+4247
0x3ecf, 0x3ed0, 0x3ed1, 0x3ed2, 0x3ed3, 0x3ed4, 0x3ed5, 0x3ed6,   // U+4248 ~ U+424f
0x3ed7, 0x3ed8, 0x3ed9, 0x3eda, 0x3edb, 0x3edc, 0x3edd, 0x3ede,   // U+4250 ~ U+4257
0x3edf, 0x3ee0, 0x3ee1, 0x3ee2, 0x3ee3, 0x3ee4, 0x3ee5, 0x3ee6,   // U+4258 ~ U+425f
0x3ee7, 0x3ee8, 0x3ee9, 0x3eea, 0x3eeb, 0x3eec, 0x3eed, 0x3eee,   // U+4260 ~ U+4267
0x3eef, 0x3ef0, 0x3ef1, 0x3ef2, 0x3ef3, 0x3ef4, 0x3ef5, 0x3ef6,   // U+4268 ~ U+426f
0x3ef7, 0x3ef8, 0x3ef9, 0x3efa, 0x3efb, 0x3efc, 0x3efd, 0x3efe,   // U+4270 ~ U+4277
0x3eff, 0x3f00, 0x3f01, 0x3f02, 0x3f03, 0x3f04, 0x3f05, 0x3f06,   // U+4278 ~ U+427f
0x3f07, 0x3f08, 0x3f09, 0x3f0a, 0x3f0b, 0x3f0c, 0x3f0d, 0x3f0e,   // U+4280 ~ U+4287
0x3f0f, 0x3f10, 0x3f11, 0x3f12, 0x3f13, 0x3f14, 0x3f15, 0x3f16,   // U+4288 ~ U+428f
0x3f17, 0x3f18, 0x3f19, 0x3f1a, 0x3f1b, 0x3f1c, 0x3f1d, 0x3f1e,   // U+4290 ~ U+4297
0x3f1f, 0x3f20, 0x3f21, 0x3f22, 0x3f23, 0x3f24, 0x3f25, 0x3f26,   // U+4298 ~ U+429f
0x3f27, 0x3f28, 0x3f29, 0x3f2a, 0x3f2b, 0x3f2c, 0x3f2d, 0x3f2e,   // U+42a0 ~ U+42a7
0x3f2f, 0x3f30, 0x3f31, 0x3f32, 0x3f33, 0x3f34, 0x3f35, 0x3f36,   // U+42a8 ~ U+42af
0x3f37, 0x3f38, 0x3f39, 0x3f3a, 0x3f3b, 0x3f3c, 0x3f3d, 0x3f3e,   // U+42b0 ~ U+42b7
0x3f3f, 0x3f40, 0x3f41, 0x3f42, 0x3f43, 0x3f44, 0x3f45, 0x3f46,   // U+42b8 ~ U+42bf
0x3f47, 0x3f48, 0x3f49, 0x3f4a, 0x3f4b, 0x3f4c, 0x3f4d, 0x3f4e,   // U+42c0 ~ U+42c7
0x3f4f, 0x3f50, 0x3f51, 0x3f52, 0x3f53, 0x3f54, 0x3f55, 0x3f56,   // U+42c8 ~ U+42cf
0x3f57, 0x3f58, 0x3f59, 0x3f5a, 0x3f5b, 0x3f5c, 0x3f5d, 0x3f5e,   // U+42d0 ~ U+42d7
0x3f5f, 0x3f60, 0x3f61, 0x3f62, 0x3f63, 0x3f64, 0x3f65, 0x3f66,   // U+42d8 ~ U+42df
0x3f67, 0x3f68, 0x3f69, 0x3f6a, 0x3f6b, 0x3f6c, 0x3f6d, 0x3f6e,   // U+42e0 ~ U+42e7
0x3f6f, 0x3f70, 0x3f71, 0x3f72, 0x3f73, 0x3f74, 0x3f75, 0x3f76,   // U+42e8 ~ U+42ef
0x3f77, 0x3f78, 0x3f79, 0x3f7a, 0x3f7b, 0x3f7c, 0x3f7d, 0x3f7e,   // U+42f0 ~ U+42f7
0x3f7f, 0x3f80, 0x3f81, 0x3f82, 0x3f83, 0x3f84, 0x3f85, 0x3f86,   // U+42f8 ~ U+42ff
0x3f87, 0x3f88, 0x3f89, 0x3f8a, 0x3f8b, 0x3f8c, 0x3f8d, 0x3f8e,   // U+4300 ~ U+4307
0x3f8f, 0x3f90, 0x3f91, 0x3f92, 0x3f93, 0x3f94, 0x3f95, 0x3f96,   // U+4308 ~ U+430f
0x3f97, 0x3f98, 0x3f99, 0x3f9a, 0x3f9b, 0x3f9c, 0x3f9d, 0x3f9e,   // U+4310 ~ U+4317
0x3f9f, 0x3fa0, 0x3fa1, 0x3fa2, 0x3fa3, 0x3fa4, 0x3fa5, 0x3fa6,   // U+4318 ~ U+431f
0x3fa7, 0x3fa8, 0x3fa9, 0x3faa, 0x3fab, 0x3fac, 0x3fad, 0x3fae,   // U+4320 ~ U+4327
0x3faf, 0x3fb0, 0x3fb1, 0x3fb2, 0x3fb3, 0x3fb4, 0x3fb5, 0x3fb6,   // U+4328 ~ U+432f
0x3fb7, 0x3fb8, 0x3fb9, 0x3fba, 0x3fbb, 0x3fbc, 0x3fbd, 0xffd1,   // U+4330 ~ U+4337
0x3fbe, 0x3fbf, 0x3fc0, 0x3fc1, 0x3fc2, 0x3fc3, 0x3fc4, 0x3fc5,   // U+4338 ~ U+433f
0x3fc6, 0x3fc7, 0x3fc8, 0x3fc9, 0x3fca, 0x3fcb, 0x3fcc, 0x3fcd,   // U+4340 ~ U+4347
0x3fce, 0x3fcf, 0x3fd0, 0x3fd1, 0x3fd2, 0x3fd3, 0x3fd4, 0x3fd5,   // U+4348 ~ U+434f
0x3fd6, 0x3fd7, 0x3fd8, 0x3fd9, 0x3fda, 0x3fdb, 0x3fdc, 0x3fdd,   // U+4350 ~ U+4357
0x3fde, 0x3fdf, 0x3fe0, 0x3fe1, 0x3fe2, 0x3fe3, 0x3fe4, 0x3fe5,   // U+4358 ~ U+435f
0x3fe6, 0x3fe7, 0x3fe8, 0x3fe9, 0x3fea, 0x3feb, 0x3fec, 0x3fed,   // U+4360 ~ U+4367
0x3fee, 0x3fef, 0x3ff0, 0x3ff1, 0x3ff2, 0x3ff3, 0x3ff4, 0x3ff5,   // U+4368 ~ U+436f
0x3ff6, 0x3ff7, 0x3ff8, 0x3ff9, 0x3ffa, 0x3ffb, 0x3ffc, 0x3ffd,   // U+4370 ~ U+4377
0x3ffe, 0x3fff, 0x4000, 0x4001, 0x4002, 0x4003, 0x4004, 0x4005,   // U+4378 ~ U+437f
0x4006, 0x4007, 0x4008, 0x4009, 0x400a, 0x400b, 0x400c, 0x400d,   // U+4380 ~ U+4387
0x400e, 0x400f, 0x4010, 0x4011, 0x4012, 0x4013, 0x4014, 0x4015,   // U+4388 ~ U+438f
0x4016, 0x4017, 0x4018, 0x4019, 0x401a, 0x401b, 0x401c, 0x401d,   // U+4390 ~ U+4397
0x401e, 0x401f, 0x4020, 0x4021, 0x4022, 0x4023, 0x4024, 0x4025,   // U+4398 ~ U+439f
0x4026, 0x4027, 0x4028, 0x4029, 0x402a, 0x402b, 0x402c, 0x402d,   // U+43a0 ~ U+43a7
0x402e, 0x402f, 0x4030, 0x4031, 0xffd0, 0x4032, 0x4033, 0x4034,   // U+43a8 ~ U+43af
0x4035, 0xffcf, 0x4036, 0x4037, 0x4038, 0x4039, 0x403a, 0x403b,   // U+43b0 ~ U+43b7
0x403c, 0x403d, 0x403e, 0x403f, 0x4040, 0x4041, 0x4042, 0x4043,   // U+43b8 ~ U+43bf
0x4044, 0x4045, 0x4046, 0x4047, 0x4048, 0x4049, 0x404a, 0x404b,   // U+43c0 ~ U+43c7
0x404c, 0x404d, 0x404e, 0x404f, 0x4050, 0x4051, 0x4052, 0x4053,   // U+43c8 ~ U+43cf
0x4054, 0x4055, 0x4056, 0x4057, 0x4058, 0x4059, 0x405a, 0x405b,   // U+43d0 ~ U+43d7
0x405c, 0x405d, 0x405e, 0x405f, 0x4060, 0xffce, 0x4061, 0x4062,   // U+43d8 ~ U+43df
0x4063, 0x4064, 0x4065, 0x4066, 0x4067, 0x4068, 0x4069, 0x406a,   // U+43e0 ~ U+43e7
0x406b, 0x406c, 0x406d, 0x406e, 0x406f, 0x4070, 0x4071, 0x4072,   // U+43e8 ~ U+43ef
0x4073, 0x4074, 0x4075, 0x4076, 0x4077, 0x4078, 0x4079, 0x407a,   // U+43f0 ~ U+43f7
0x407b, 0x407c, 0x407d, 0x407e, 0x407f, 0x4080, 0x4081, 0x4082,   // U+43f8 ~ U+43ff
0x4083, 0x4084, 0x4085, 0x4086, 0x4087, 0x4088, 0x4089, 0x408a,   // U+4400 ~ U+4407
0x408b, 0x408c, 0x408d, 0x408e, 0x408f, 0x4090, 0x4091, 0x4092,   // U+4408 ~ U+440f
0x4093, 0x4094, 0x4095, 0x4096, 0x4097, 0x4098, 0x4099, 0x409a,   // U+4410 ~ U+4417
0x409b, 0x409c, 0x409d, 0x409e, 0x409f, 0x40a0, 0x40a1, 0x40a2,   // U+4418 ~ U+441f
0x40a3, 0x40a4, 0x40a5, 0x40a6, 0x40a7, 0x40a8, 0x40a9, 0x40aa,   // U+4420 ~ U+4427
0x40ab, 0x40ac, 0x40ad, 0x40ae, 0x40af, 0x40b0, 0x40b1, 0x40b2,   // U+4428 ~ U+442f
0x40b3, 0x40b4, 0x40b5, 0x40b6, 0x40b7, 0x40b8, 0x40b9, 0x40ba,   // U+4430 ~ U+4437
0x40bb, 0x40bc, 0x40bd, 0x40be, 0x40bf, 0x40c0, 0x40c1, 0x40c2,   // U+4438 ~ U+443f
0x40c3, 0x40c4, 0x40c5, 0x40c6, 0x40c7, 0x40c8, 0x40c9, 0x40ca,   // U+4440 ~ U+4447
0x40cb, 0x40cc, 0x40cd, 0x40ce, 0x40cf, 0x40d0, 0x40d1, 0x40d2,   // U+4448 ~ U+444f
0x40d3, 0x40d4, 0x40d5, 0x40d6, 0x40d7, 0x40d8, 0x40d9, 0x40da,   // U+4450 ~ U+4457
0x40db, 0x40dc, 0x40dd, 0x40de, 0x40df, 0x40e0, 0x40e1, 0x40e2,   // U+4458 ~ U+445f
0x40e3, 0x40e4, 0x40e5, 0x40e6, 0x40e7, 0x40e8, 0x40e9, 0x40ea,   // U+4460 ~ U+4467
0x40eb, 0x40ec, 0x40ed, 0x40ee, 0x40ef, 0x40f0, 0x40f1, 0x40f2,   // U+4468 ~ U+446f
0x40f3, 0x40f4, 0x40f5, 0x40f6, 0x40f7, 0x40f8, 0x40f9, 0x40fa,   // U+4470 ~ U+4477
0x40fb, 0x40fc, 0x40fd, 0x40fe, 0x40ff, 0x4100, 0x4101, 0x4102,   // U+4478 ~ U+447f
0x4103, 0x4104, 0x4105, 0x4106, 0x4107, 0x4108, 0x4109, 0x410a,   // U+4480 ~ U+4487
0x410b, 0x410c, 0x410d, 0x410e, 0x410f, 0x4110, 0x4111, 0x4112,   // U+4488 ~ U+448f
0x4113, 0x4114, 0x4115, 0x4116, 0x4117, 0x4118, 0x4119, 0x411a,   // U+4490 ~ U+4497
0x411b, 0x411c, 0x411d, 0x411e, 0x411f, 0x4120, 0x4121, 0x4122,   // U+4498 ~ U+449f
0x4123, 0x4124, 0x4125, 0x4126, 0x4127, 0x4128, 0x4129, 0x412a,   // U+44a0 ~ U+44a7
0x412b, 0x412c, 0x412d, 0x412e, 0x412f, 0x4130, 0x4131, 0x4132,   // U+44a8 ~ U+44af
0x4133, 0x4134, 0x4135, 0x4136, 0x4137, 0x4138, 0x4139, 0x413a,   // U+44b0 ~ U+44b7
0x413b, 0x413c, 0x413d, 0x413e, 0x413f, 0x4140, 0x4141, 0x4142,   // U+44b8 ~ U+44bf
0x4143, 0x4144, 0x4145, 0x4146, 0x4147, 0x4148, 0x4149, 0x414a,   // U+44c0 ~ U+44c7
0x414b, 0x414c, 0x414d, 0x414e, 0x414f, 0x4150, 0x4151, 0x4152,   // U+44c8 ~ U+44cf
0x4153, 0x4154, 0x4155, 0x4156, 0x4157, 0x4158, 0xffcd, 0x4159,   // U+44d0 ~ U+44d7
0x415a, 0x415b, 0x415c, 0x415d, 0x415e, 0x415f, 0x4160, 0x4161,   // U+44d8 ~ U+44df
0x4162, 0x4163, 0x4164, 0x4165, 0x4166, 0x4167, 0x4168, 0x4169,   // U+44e0 ~ U+44e7
0x416a, 0x416b, 0x416c, 0x416d, 0x416e, 0x416f, 0x4170, 0x4171,   // U+44e8 ~ U+44ef
0x4172, 0x4173, 0x4174, 0x4175, 0x4176, 0x4177, 0x4178, 0x4179,   // U+44f0 ~ U+44f7
0x417a, 0x417b, 0x417c, 0x417d, 0x417e, 0x417f, 0x4180, 0x4181,   // U+44f8 ~ U+44ff
0x4182, 0x4183, 0x4184, 0x4185, 0x4186, 0x4187, 0x4188, 0x4189,   // U+4500 ~ U+4507
0x418a, 0x418b, 0x418c, 0x418d, 0x418e, 0x418f, 0x4190, 0x4191,   // U+4508 ~ U+450f
0x4192, 0x4193, 0x4194, 0x4195, 0x4196, 0x4197, 0x4198, 0x4199,   // U+4510 ~ U+4517
0x419a, 0x419b, 0x419c, 0x419d, 0x419e, 0x419f, 0x41a0, 0x41a1,   // U+4518 ~ U+451f
0x41a2, 0x41a3, 0x41a4, 0x41a5, 0x41a6, 0x41a7, 0x41a8, 0x41a9,   // U+4520 ~ U+4527
0x41aa, 0x41ab, 0x41ac, 0x41ad, 0x41ae, 0x41af, 0x41b0, 0x41b1,   // U+4528 ~ U+452f
0x41b2, 0x41b3, 0x41b4, 0x41b5, 0x41b6, 0x41b7, 0x41b8, 0x41b9,   // U+4530 ~ U+4537
0x41ba, 0x41bb, 0x41bc, 0x41bd, 0x41be, 0x41bf, 0x41c0, 0x41c1,   // U+4538 ~ U+453f
0x41c2, 0x41c3, 0x41c4, 0x41c5, 0x41c6, 0x41c7, 0x41c8, 0x41c9,   // U+4540 ~ U+4547
0x41ca, 0x41cb, 0x41cc, 0x41cd, 0x41ce, 0x41cf, 0x41d0, 0x41d1,   // U+4548 ~ U+454f
0x41d2, 0x41d3, 0x41d4, 0x41d5, 0x41d6, 0x41d7, 0x41d8, 0x41d9,   // U+4550 ~ U+4557
0x41da, 0x41db, 0x41dc, 0x41dd, 0x41de, 0x41df, 0x41e0, 0x41e1,   // U+4558 ~ U+455f
0x41e2, 0x41e3, 0x41e4, 0x41e5, 0x41e6, 0x41e7, 0x41e8, 0x41e9,   // U+4560 ~ U+4567
0x41ea, 0x41eb, 0x41ec, 0x41ed, 0x41ee, 0x41ef, 0x41f0, 0x41f1,   // U+4568 ~ U+456f
0x41f2, 0x41f3, 0x41f4, 0x41f5, 0x41f6, 0x41f7, 0x41f8, 0x41f9,   // U+4570 ~ U+4577
0x41fa, 0x41fb, 0x41fc, 0x41fd, 0x41fe, 0x41ff, 0x4200, 0x4201,   // U+4578 ~ U+457f
0x4202, 0x4203, 0x4204, 0x4205, 0x4206, 0x4207, 0x4208, 0x4209,   // U+4580 ~ U+4587
0x420a, 0x420b, 0x420c, 0x420d, 0x420e, 0x420f, 0x4210, 0x4211,   // U+4588 ~ U+458f
0x4212, 0x4213, 0x4214, 0x4215, 0x4216, 0x4217, 0x4218, 0x4219,   // U+4590 ~ U+4597
0x421a, 0x421b, 0x421c, 0x421d, 0x421e, 0x421f, 0x4220, 0x4221,   // U+4598 ~ U+459f
0x4222, 0x4223, 0x4224, 0x4225, 0x4226, 0x4227, 0x4228, 0x4229,   // U+45a0 ~ U+45a7
0x422a, 0x422b, 0x422c, 0x422d, 0x422e, 0x422f, 0x4230, 0x4231,   // U+45a8 ~ U+45af
0x4232, 0x4233, 0x4234, 0x4235, 0x4236, 0x4237, 0x4238, 0x4239,   // U+45b0 ~ U+45b7
0x423a, 0x423b, 0x423c, 0x423d, 0x423e, 0x423f, 0x4240, 0x4241,   // U+45b8 ~ U+45bf
0x4242, 0x4243, 0x4244, 0x4245, 0x4246, 0x4247, 0x4248, 0x4249,   // U+45c0 ~ U+45c7
0x424a, 0x424b, 0x424c, 0x424d, 0x424e, 0x424f, 0x4250, 0x4251,   // U+45c8 ~ U+45cf
0x4252, 0x4253, 0x4254, 0x4255, 0x4256, 0x4257, 0x4258, 0x4259,   // U+45d0 ~ U+45d7
0x425a, 0x425b, 0x425c, 0x425d, 0x425e, 0x425f, 0x4260, 0x4261,   // U+45d8 ~ U+45df
0x4262, 0x4263, 0x4264, 0x4265, 0x4266, 0x4267, 0x4268, 0x4269,   // U+45e0 ~ U+45e7
0x426a, 0x426b, 0x426c, 0x426d, 0x426e, 0x426f, 0x4270, 0x4271,   // U+45e8 ~ U+45ef
0x4272, 0x4273, 0x4274, 0x4275, 0x4276, 0x4277, 0x4278, 0x4279,   // U+45f0 ~ U+45f7
0x427a, 0x427b, 0x427c, 0x427d, 0x427e, 0x427f, 0x4280, 0x4281,   // U+45f8 ~ U+45ff
0x4282, 0x4283, 0x4284, 0x4285, 0x4286, 0x4287, 0x4288, 0x4289,   // U+4600 ~ U+4607
0x428a, 0x428b, 0x428c, 0x428d, 0x428e, 0x428f, 0x4290, 0x4291,   // U+4608 ~ U+460f
0x4292, 0x4293, 0x4294, 0x4295, 0x4296, 0x4297, 0x4298, 0x4299,   // U+4610 ~ U+4617
0x429a, 0x429b, 0x429c, 0x429d, 0x429e, 0x429f, 0x42a0, 0x42a1,   // U+4618 ~ U+461f
0x42a2, 0x42a3, 0x42a4, 0x42a5, 0x42a6, 0x42a7, 0x42a8, 0x42a9,   // U+4620 ~ U+4627
0x42aa, 0x42ab, 0x42ac, 0x42ad, 0x42ae, 0x42af, 0x42b0, 0x42b1,   // U+4628 ~ U+462f
0x42b2, 0x42b3, 0x42b4, 0x42b5, 0x42b6, 0x42b7, 0x42b8, 0x42b9,   // U+4630 ~ U+4637
0x42ba, 0x42bb, 0x42bc, 0x42bd, 0x42be, 0x42bf, 0x42c0, 0x42c1,   // U+4638 ~ U+463f
0x42c2, 0x42c3, 0x42c4, 0x42c5, 0x42c6, 0x42c7, 0x42c8, 0x42c9,   // U+4640 ~ U+4647
0x42ca, 0x42cb, 0x42cc, 0x42cd, 0xffcc, 0x42ce, 0x42cf, 0x42d0,   // U+4648 ~ U+464f
0x42d1, 0x42d2, 0x42d3, 0x42d4, 0x42d5, 0x42d6, 0x42d7, 0x42d8,   // U+4650 ~ U+4657
0x42d9, 0x42da, 0x42db, 0x42dc, 0x42dd, 0x42de, 0x42df, 0x42e0,   // U+4658 ~ U+465f
0x42e1, 0xffcb, 0x42e2, 0x42e3, 0x42e4, 0x42e5, 0x42e6, 0x42e7,   // U+4660 ~ U+4667
0x42e8, 0x42e9, 0x42ea, 0x42eb, 0x42ec, 0x42ed, 0x42ee, 0x42ef,   // U+4668 ~ U+466f
0x42f0, 0x42f1, 0x42f2, 0x42f3, 0x42f4, 0x42f5, 0x42f6, 0x42f7,   // U+4670 ~ U+4677
0x42f8, 0x42f9, 0x42fa, 0x42fb, 0x42fc, 0x42fd, 0x42fe, 0x42ff,   // U+4678 ~ U+467f
0x4300, 0x4301, 0x4302, 0x4303, 0x4304, 0x4305, 0x4306, 0x4307,   // U+4680 ~ U+4687
0x4308, 0x4309, 0x430a, 0x430b, 0x430c, 0x430d, 0x430e, 0x430f,   // U+4688 ~ U+468f
0x4310, 0x4311, 0x4312, 0x4313, 0x4314, 0x4315, 0x4316, 0x4317,   // U+4690 ~ U+4697
0x4318, 0x4319, 0x431a, 0x431b, 0x431c, 0x431d, 0x431e, 0x431f,   // U+4698 ~ U+469f
0x4320, 0x4321, 0x4322, 0x4323, 0x4324, 0x4325, 0x4326, 0x4327,   // U+46a0 ~ U+46a7
0x4328, 0x4329, 0x432a, 0x432b, 0x432c, 0x432d, 0x432e, 0x432f,   // U+46a8 ~ U+46af
0x4330, 0x4331, 0x4332, 0x4333, 0x4334, 0x4335, 0x4336, 0x4337,   // U+46b0 ~ U+46b7
0x4338, 0x4339, 0x433a, 0x433b, 0x433c, 0x433d, 0x433e, 0x433f,   // U+46b8 ~ U+46bf
0x4340, 0x4341, 0x4342, 0x4343, 0x4344, 0x4345, 0x4346, 0x4347,   // U+46c0 ~ U+46c7
0x4348, 0x4349, 0x434a, 0x434b, 0x434c, 0x434d, 0x434e, 0x434f,   // U+46c8 ~ U+46cf
0x4350, 0x4351, 0x4352, 0x4353, 0x4354, 0x4355, 0x4356, 0x4357,   // U+46d0 ~ U+46d7
0x4358, 0x4359, 0x435a, 0x435b, 0x435c, 0x435d, 0x435e, 0x435f,   // U+46d8 ~ U+46df
0x4360, 0x4361, 0x4362, 0x4363, 0x4364, 0x4365, 0x4366, 0x4367,   // U+46e0 ~ U+46e7
0x4368, 0x4369, 0x436a, 0x436b, 0x436c, 0x436d, 0x436e, 0x436f,   // U+46e8 ~ U+46ef
0x4370, 0x4371, 0x4372, 0x4373, 0x4374, 0x4375, 0x4376, 0x4377,   // U+46f0 ~ U+46f7
0x4378, 0x4379, 0x437a, 0x437b, 0x437c, 0x437d, 0x437e, 0x437f,   // U+46f8 ~ U+46ff
0x4380, 0x4381, 0x4382, 0x4383, 0x4384, 0x4385, 0x4386, 0x4387,   // U+4700 ~ U+4707
0x4388, 0x4389, 0x438a, 0x438b, 0x438c, 0x438d, 0x438e, 0x438f,   // U+4708 ~ U+470f
0x4390, 0x4391, 0x4392, 0x4393, 0x4394, 0x4395, 0x4396, 0x4397,   // U+4710 ~ U+4717
0x4398, 0x4399, 0x439a, 0x439b, 0x439c, 0x439d, 0x439e, 0x439f,   // U+4718 ~ U+471f
0x43a0, 0x43a1, 0x43a2, 0xffca, 0x43a3, 0x43a4, 0x43a5, 0x43a6,   // U+4720 ~ U+4727
0x43a7, 0xffc9, 0x43a8, 0x43a9, 0x43aa, 0x43ab, 0x43ac, 0x43ad,   // U+4728 ~ U+472f
0x43ae, 0x43af, 0x43b0, 0x43b1, 0x43b2, 0x43b3, 0x43b4, 0x43b5,   // U+4730 ~ U+4737
0x43b6, 0x43b7, 0x43b8, 0x43b9, 0x43ba, 0x43bb, 0x43bc, 0x43bd,   // U+4738 ~ U+473f
0x43be, 0x43bf, 0x43c0, 0x43c1, 0x43c2, 0x43c3, 0x43c4, 0x43c5,   // U+4740 ~ U+4747
0x43c6, 0x43c7, 0x43c8, 0x43c9, 0x43ca, 0x43cb, 0x43cc, 0x43cd,   // U+4748 ~ U+474f
0x43ce, 0x43cf, 0x43d0, 0x43d1, 0x43d2, 0x43d3, 0x43d4, 0x43d5,   // U+4750 ~ U+4757
0x43d6, 0x43d7, 0x43d8, 0x43d9, 0x43da, 0x43db, 0x43dc, 0x43dd,   // U+4758 ~ U+475f
0x43de, 0x43df, 0x43e0, 0x43e1, 0x43e2, 0x43e3, 0x43e4, 0x43e5,   // U+4760 ~ U+4767
0x43e6, 0x43e7, 0x43e8, 0x43e9, 0x43ea, 0x43eb, 0x43ec, 0x43ed,   // U+4768 ~ U+476f
0x43ee, 0x43ef, 0x43f0, 0x43f1, 0x43f2, 0x43f3, 0x43f4, 0x43f5,   // U+4770 ~ U+4777
0x43f6, 0x43f7, 0x43f8, 0x43f9, 0xffc8, 0x43fa, 0x43fb, 0x43fc,   // U+4778 ~ U+477f
0x43fd, 0x43fe, 0x43ff, 0x4400, 0x4401, 0x4402, 0x4403, 0x4404,   // U+4780 ~ U+4787
0x4405, 0x4406, 0x4407, 0x4408, 0x4409, 0xffc7, 0x440a, 0x440b,   // U+4788 ~ U+478f
0x440c, 0x440d, 0x440e, 0x440f, 0x4410, 0x4411, 0x4412, 0x4413,   // U+4790 ~ U+4797
0x4414, 0x4415, 0x4416, 0x4417, 0x4418, 0x4419, 0x441a, 0x441b,   // U+4798 ~ U+479f
0x441c, 0x441d, 0x441e, 0x441f, 0x4420, 0x4421, 0x4422, 0x4423,   // U+47a0 ~ U+47a7
0x4424, 0x4425, 0x4426, 0x4427, 0x4428, 0x4429, 0x442a, 0x442b,   // U+47a8 ~ U+47af
0x442c, 0x442d, 0x442e, 0x442f, 0x4430, 0x4431, 0x4432, 0x4433,   // U+47b0 ~ U+47b7
0x4434, 0x4435, 0x4436, 0x4437, 0x4438, 0x4439, 0x443a, 0x443b,   // U+47b8 ~ U+47bf
0x443c, 0x443d, 0x443e, 0x443f, 0x4440, 0x4441, 0x4442, 0x4443,   // U+47c0 ~ U+47c7
0x4444, 0x4445, 0x4446, 0x4447, 0x4448, 0x4449, 0x444a, 0x444b,   // U+47c8 ~ U+47cf
0x444c, 0x444d, 0x444e, 0x444f, 0x4450, 0x4451, 0x4452, 0x4453,   // U+47d0 ~ U+47d7
0x4454, 0x4455, 0x4456, 0x4457, 0x4458, 0x4459, 0x445a, 0x445b,   // U+47d8 ~ U+47df
0x445c, 0x445d, 0x445e, 0x445f, 0x4460, 0x4461, 0x4462, 0x4463,   // U+47e0 ~ U+47e7
0x4464, 0x4465, 0x4466, 0x4467, 0x4468, 0x4469, 0x446a, 0x446b,   // U+47e8 ~ U+47ef
0x446c, 0x446d, 0x446e, 0x446f, 0x4470, 0x4471, 0x4472, 0x4473,   // U+47f0 ~ U+47f7
0x4474, 0x4475, 0x4476, 0x4477, 0x4478, 0x4479, 0x447a, 0x447b,   // U+47f8 ~ U+47ff
0x447c, 0x447d, 0x447e, 0x447f, 0x4480, 0x4481, 0x4482, 0x4483,   // U+4800 ~ U+4807
0x4484, 0x4485, 0x4486, 0x4487, 0x4488, 0x4489, 0x448a, 0x448b,   // U+4808 ~ U+480f
0x448c, 0x448d, 0x448e, 0x448f, 0x4490, 0x4491, 0x4492, 0x4493,   // U+4810 ~ U+4817
0x4494, 0x4495, 0x4496, 0x4497, 0x4498, 0x4499, 0x449a, 0x449b,   // U+4818 ~ U+481f
0x449c, 0x449d, 0x449e, 0x449f, 0x44a0, 0x44a1, 0x44a2, 0x44a3,   // U+4820 ~ U+4827
0x44a4, 0x44a5, 0x44a6, 0x44a7, 0x44a8, 0x44a9, 0x44aa, 0x44ab,   // U+4828 ~ U+482f
0x44ac, 0x44ad, 0x44ae, 0x44af, 0x44b0, 0x44b1, 0x44b2, 0x44b3,   // U+4830 ~ U+4837
0x44b4, 0x44b5, 0x44b6, 0x44b7, 0x44b8, 0x44b9, 0x44ba, 0x44bb,   // U+4838 ~ U+483f
0x44bc, 0x44bd, 0x44be, 0x44bf, 0x44c0, 0x44c1, 0x44c2, 0x44c3,   // U+4840 ~ U+4847
0x44c4, 0x44c5, 0x44c6, 0x44c7, 0x44c8, 0x44c9, 0x44ca, 0x44cb,   // U+4848 ~ U+484f
0x44cc, 0x44cd, 0x44ce, 0x44cf, 0x44d0, 0x44d1, 0x44d2, 0x44d3,   // U+4850 ~ U+4857
0x44d4, 0x44d5, 0x44d6, 0x44d7, 0x44d8, 0x44d9, 0x44da, 0x44db,   // U+4858 ~ U+485f
0x44dc, 0x44dd, 0x44de, 0x44df, 0x44e0, 0x44e1, 0x44e2, 0x44e3,   // U+4860 ~ U+4867
0x44e4, 0x44e5, 0x44e6, 0x44e7, 0x44e8, 0x44e9, 0x44ea, 0x44eb,   // U+4868 ~ U+486f
0x44ec, 0x44ed, 0x44ee, 0x44ef, 0x44f0, 0x44f1, 0x44f2, 0x44f3,   // U+4870 ~ U+4877
0x44f4, 0x44f5, 0x44f6, 0x44f7, 0x44f8, 0x44f9, 0x44fa, 0x44fb,   // U+4878 ~ U+487f
0x44fc, 0x44fd, 0x44fe, 0x44ff, 0x4500, 0x4501, 0x4502, 0x4503,   // U+4880 ~ U+4887
0x4504, 0x4505, 0x4506, 0x4507, 0x4508, 0x4509, 0x450a, 0x450b,   // U+4888 ~ U+488f
0x450c, 0x450d, 0x450e, 0x450f, 0x4510, 0x4511, 0x4512, 0x4513,   // U+4890 ~ U+4897
0x4514, 0x4515, 0x4516, 0x4517, 0x4518, 0x4519, 0x451a, 0x451b,   // U+4898 ~ U+489f
0x451c, 0x451d, 0x451e, 0x451f, 0x4520, 0x4521, 0x4522, 0x4523,   // U+48a0 ~ U+48a7
0x4524, 0x4525, 0x4526, 0x4527, 0x4528, 0x4529, 0x452a, 0x452b,   // U+48a8 ~ U+48af
0x452c, 0x452d, 0x452e, 0x452f, 0x4530, 0x4531, 0x4532, 0x4533,   // U+48b0 ~ U+48b7
0x4534, 0x4535, 0x4536, 0x4537, 0x4538, 0x4539, 0x453a, 0x453b,   // U+48b8 ~ U+48bf
0x453c, 0x453d, 0x453e, 0x453f, 0x4540, 0x4541, 0x4542, 0x4543,   // U+48c0 ~ U+48c7
0x4544, 0x4545, 0x4546, 0x4547, 0x4548, 0x4549, 0x454a, 0x454b,   // U+48c8 ~ U+48cf
0x454c, 0x454d, 0x454e, 0x454f, 0x4550, 0x4551, 0x4552, 0x4553,   // U+48d0 ~ U+48d7
0x4554, 0x4555, 0x4556, 0x4557, 0x4558, 0x4559, 0x455a, 0x455b,   // U+48d8 ~ U+48df
0x455c, 0x455d, 0x455e, 0x455f, 0x4560, 0x4561, 0x4562, 0x4563,   // U+48e0 ~ U+48e7
0x4564, 0x4565, 0x4566, 0x4567, 0x4568, 0x4569, 0x456a, 0x456b,   // U+48e8 ~ U+48ef
0x456c, 0x456d, 0x456e, 0x456f, 0x4570, 0x4571, 0x4572, 0x4573,   // U+48f0 ~ U+48f7
0x4574, 0x4575, 0x4576, 0x4577, 0x4578, 0x4579, 0x457a, 0x457b,   // U+48f8 ~ U+48ff
0x457c, 0x457d, 0x457e, 0x457f, 0x4580, 0x4581, 0x4582, 0x4583,   // U+4900 ~ U+4907
0x4584, 0x4585, 0x4586, 0x4587, 0x4588, 0x4589, 0x458a, 0x458b,   // U+4908 ~ U+490f
0x458c, 0x458d, 0x458e, 0x458f, 0x4590, 0x4591, 0x4592, 0x4593,   // U+4910 ~ U+4917
0x4594, 0x4595, 0x4596, 0x4597, 0x4598, 0x4599, 0x459a, 0x459b,   // U+4918 ~ U+491f
0x459c, 0x459d, 0x459e, 0x459f, 0x45a0, 0x45a1, 0x45a2, 0x45a3,   // U+4920 ~ U+4927
0x45a4, 0x45a5, 0x45a6, 0x45a7, 0x45a8, 0x45a9, 0x45aa, 0x45ab,   // U+4928 ~ U+492f
0x45ac, 0x45ad, 0x45ae, 0x45af, 0x45b0, 0x45b1, 0x45b2, 0x45b3,   // U+4930 ~ U+4937
0x45b4, 0x45b5, 0x45b6, 0x45b7, 0x45b8, 0x45b9, 0x45ba, 0x45bb,   // U+4938 ~ U+493f
0x45bc, 0x45bd, 0x45be, 0x45bf, 0x45c0, 0x45c1, 0x45c2, 0xffc6,   // U+4940 ~ U+4947
0x45c3, 0x45c4, 0x45c5, 0x45c6, 0x45c7, 0x45c8, 0x45c9, 0x45ca,   // U+4948 ~ U+494f
0x45cb, 0x45cc, 0x45cd, 0x45ce, 0x45cf, 0x45d0, 0x45d1, 0x45d2,   // U+4950 ~ U+4957
0x45d3, 0x45d4, 0x45d5, 0x45d6, 0x45d7, 0x45d8, 0x45d9, 0x45da,   // U+4958 ~ U+495f
0x45db, 0x45dc, 0x45dd, 0x45de, 0x45df, 0x45e0, 0x45e1, 0x45e2,   // U+4960 ~ U+4967
0x45e3, 0x45e4, 0x45e5, 0x45e6, 0x45e7, 0x45e8, 0x45e9, 0x45ea,   // U+4968 ~ U+496f
0x45eb, 0x45ec, 0x45ed, 0x45ee, 0x45ef, 0x45f0, 0x45f1, 0x45f2,   // U+4970 ~ U+4977
0x45f3, 0x45f4, 0xffc5, 0x45f5, 0x45f6, 0xffc4, 0x45f7, 0x45f8,   // U+4978 ~ U+497f
0x45f9, 0x45fa, 0xffc3, 0xffc2, 0x45fb, 0xffc1, 0xffc0, 0x45fc,   // U+4980 ~ U+4987
0x45fd, 0x45fe, 0x45ff, 0x4600, 0x4601, 0x4602, 0x4603, 0x4604,   // U+4988 ~ U+498f
0x4605, 0x4606, 0x4607, 0x4608, 0x4609, 0x460a, 0x460b, 0x460c,   // U+4990 ~ U+4997
0x460d, 0x460e, 0x460f, 0xffbf, 0x4610, 0x4611, 0x4612, 0xffbe,   // U+4998 ~ U+499f
0x4613, 0x4614, 0x4615, 0x4616, 0x4617, 0x4618, 0x4619, 0x461a,   // U+49a0 ~ U+49a7
0x461b, 0x461c, 0x461d, 0x461e, 0x461f, 0x4620, 0x4621, 0x4622,   // U+49a8 ~ U+49af
0x4623, 0x4624, 0x4625, 0x4626, 0x4627, 0x4628, 0xffbd, 0xffbc,   // U+49b0 ~ U+49b7
0x4629, 0x462a, 0x462b, 0x462c, 0x462d, 0x462e, 0x462f, 0x4630,   // U+49b8 ~ U+49bf
0x4631, 0x4632, 0x4633, 0x4634, 0x4635, 0x4636, 0x4637, 0x4638,   // U+49c0 ~ U+49c7
0x4639, 0x463a, 0x463b, 0x463c, 0x463d, 0x463e, 0x463f, 0x4640,   // U+49c8 ~ U+49cf
0x4641, 0x4642, 0x4643, 0x4644, 0x4645, 0x4646, 0x4647, 0x4648,   // U+49d0 ~ U+49d7
0x4649, 0x464a, 0x464b, 0x464c, 0x464d, 0x464e, 0x464f, 0x4650,   // U+49d8 ~ U+49df
0x4651, 0x4652, 0x4653, 0x4654, 0x4655, 0x4656, 0x4657, 0x4658,   // U+49e0 ~ U+49e7
0x4659, 0x465a, 0x465b, 0x465c, 0x465d, 0x465e, 0x465f, 0x4660,   // U+49e8 ~ U+49ef
0x4661, 0x4662, 0x4663, 0x4664, 0x4665, 0x4666, 0x4667, 0x4668,   // U+49f0 ~ U+49f7
0x4669, 0x466a, 0x466b, 0x466c, 0x466d, 0x466e, 0x466f, 0x4670,   // U+49f8 ~ U+49ff
0x4671, 0x4672, 0x4673, 0x4674, 0x4675, 0x4676, 0x4677, 0x4678,   // U+4a00 ~ U+4a07
0x4679, 0x467a, 0x467b, 0x467c, 0x467d, 0x467e, 0x467f, 0x4680,   // U+4a08 ~ U+4a0f
0x4681, 0x4682, 0x4683, 0x4684, 0x4685, 0x4686, 0x4687, 0x4688,   // U+4a10 ~ U+4a17
0x4689, 0x468a, 0x468b, 0x468c, 0x468d, 0x468e, 0x468f, 0x4690,   // U+4a18 ~ U+4a1f
0x4691, 0x4692, 0x4693, 0x4694, 0x4695, 0x4696, 0x4697, 0x4698,   // U+4a20 ~ U+4a27
0x4699, 0x469a, 0x469b, 0x469c, 0x469d, 0x469e, 0x469f, 0x46a0,   // U+4a28 ~ U+4a2f
0x46a1, 0x46a2, 0x46a3, 0x46a4, 0x46a5, 0x46a6, 0x46a7, 0x46a8,   // U+4a30 ~ U+4a37
0x46a9, 0x46aa, 0x46ab, 0x46ac, 0x46ad, 0x46ae, 0x46af, 0x46b0,   // U+4a38 ~ U+4a3f
0x46b1, 0x46b2, 0x46b3, 0x46b4, 0x46b5, 0x46b6, 0x46b7, 0x46b8,   // U+4a40 ~ U+4a47
0x46b9, 0x46ba, 0x46bb, 0x46bc, 0x46bd, 0x46be, 0x46bf, 0x46c0,   // U+4a48 ~ U+4a4f
0x46c1, 0x46c2, 0x46c3, 0x46c4, 0x46c5, 0x46c6, 0x46c7, 0x46c8,   // U+4a50 ~ U+4a57
0x46c9, 0x46ca, 0x46cb, 0x46cc, 0x46cd, 0x46ce, 0x46cf, 0x46d0,   // U+4a58 ~ U+4a5f
0x46d1, 0x46d2, 0x46d3, 0x46d4, 0x46d5, 0x46d6, 0x46d7, 0x46d8,   // U+4a60 ~ U+4a67
0x46d9, 0x46da, 0x46db, 0x46dc, 0x46dd, 0x46de, 0x46df, 0x46e0,   // U+4a68 ~ U+4a6f
0x46e1, 0x46e2, 0x46e3, 0x46e4, 0x46e5, 0x46e6, 0x46e7, 0x46e8,   // U+4a70 ~ U+4a77
0x46e9, 0x46ea, 0x46eb, 0x46ec, 0x46ed, 0x46ee, 0x46ef, 0x46f0,   // U+4a78 ~ U+4a7f
0x46f1, 0x46f2, 0x46f3, 0x46f4, 0x46f5, 0x46f6, 0x46f7, 0x46f8,   // U+4a80 ~ U+4a87
0x46f9, 0x46fa, 0x46fb, 0x46fc, 0x46fd, 0x46fe, 0x46ff, 0x4700,   // U+4a88 ~ U+4a8f
0x4701, 0x4702, 0x4703, 0x4704, 0x4705, 0x4706, 0x4707, 0x4708,   // U+4a90 ~ U+4a97
0x4709, 0x470a, 0x470b, 0x470c, 0x470d, 0x470e, 0x470f, 0x4710,   // U+4a98 ~ U+4a9f
0x4711, 0x4712, 0x4713, 0x4714, 0x4715, 0x4716, 0x4717, 0x4718,   // U+4aa0 ~ U+4aa7
0x4719, 0x471a, 0x471b, 0x471c, 0x471d, 0x471e, 0x471f, 0x4720,   // U+4aa8 ~ U+4aaf
0x4721, 0x4722, 0x4723, 0x4724, 0x4725, 0x4726, 0x4727, 0x4728,   // U+4ab0 ~ U+4ab7
0x4729, 0x472a, 0x472b, 0x472c, 0x472d, 0x472e, 0x472f, 0x4730,   // U+4ab8 ~ U+4abf
0x4731, 0x4732, 0x4733, 0x4734, 0x4735, 0x4736, 0x4737, 0x4738,   // U+4ac0 ~ U+4ac7
0x4739, 0x473a, 0x473b, 0x473c, 0x473d, 0x473e, 0x473f, 0x4740,   // U+4ac8 ~ U+4acf
0x4741, 0x4742, 0x4743, 0x4744, 0x4745, 0x4746, 0x4747, 0x4748,   // U+4ad0 ~ U+4ad7
0x4749, 0x474a, 0x474b, 0x474c, 0x474d, 0x474e, 0x474f, 0x4750,   // U+4ad8 ~ U+4adf
0x4751, 0x4752, 0x4753, 0x4754, 0x4755, 0x4756, 0x4757, 0x4758,   // U+4ae0 ~ U+4ae7
0x4759, 0x475a, 0x475b, 0x475c, 0x475d, 0x475e, 0x475f, 0x4760,   // U+4ae8 ~ U+4aef
0x4761, 0x4762, 0x4763, 0x4764, 0x4765, 0x4766, 0x4767, 0x4768,   // U+4af0 ~ U+4af7
0x4769, 0x476a, 0x476b, 0x476c, 0x476d, 0x476e, 0x476f, 0x4770,   // U+4af8 ~ U+4aff
0x4771, 0x4772, 0x4773, 0x4774, 0x4775, 0x4776, 0x4777, 0x4778,   // U+4b00 ~ U+4b07
0x4779, 0x477a, 0x477b, 0x477c, 0x477d, 0x477e, 0x477f, 0x4780,   // U+4b08 ~ U+4b0f
0x4781, 0x4782, 0x4783, 0x4784, 0x4785, 0x4786, 0x4787, 0x4788,   // U+4b10 ~ U+4b17
0x4789, 0x478a, 0x478b, 0x478c, 0x478d, 0x478e, 0x478f, 0x4790,   // U+4b18 ~ U+4b1f
0x4791, 0x4792, 0x4793, 0x4794, 0x4795, 0x4796, 0x4797, 0x4798,   // U+4b20 ~ U+4b27
0x4799, 0x479a, 0x479b, 0x479c, 0x479d, 0x479e, 0x479f, 0x47a0,   // U+4b28 ~ U+4b2f
0x47a1, 0x47a2, 0x47a3, 0x47a4, 0x47a5, 0x47a6, 0x47a7, 0x47a8,   // U+4b30 ~ U+4b37
0x47a9, 0x47aa, 0x47ab, 0x47ac, 0x47ad, 0x47ae, 0x47af, 0x47b0,   // U+4b38 ~ U+4b3f
0x47b1, 0x47b2, 0x47b3, 0x47b4, 0x47b5, 0x47b6, 0x47b7, 0x47b8,   // U+4b40 ~ U+4b47
0x47b9, 0x47ba, 0x47bb, 0x47bc, 0x47bd, 0x47be, 0x47bf, 0x47c0,   // U+4b48 ~ U+4b4f
0x47c1, 0x47c2, 0x47c3, 0x47c4, 0x47c5, 0x47c6, 0x47c7, 0x47c8,   // U+4b50 ~ U+4b57
0x47c9, 0x47ca, 0x47cb, 0x47cc, 0x47cd, 0x47ce, 0x47cf, 0x47d0,   // U+4b58 ~ U+4b5f
0x47d1, 0x47d2, 0x47d3, 0x47d4, 0x47d5, 0x47d6, 0x47d7, 0x47d8,   // U+4b60 ~ U+4b67
0x47d9, 0x47da, 0x47db, 0x47dc, 0x47dd, 0x47de, 0x47df, 0x47e0,   // U+4b68 ~ U+4b6f
0x47e1, 0x47e2, 0x47e3, 0x47e4, 0x47e5, 0x47e6, 0x47e7, 0x47e8,   // U+4b70 ~ U+4b77
0x47e9, 0x47ea, 0x47eb, 0x47ec, 0x47ed, 0x47ee, 0x47ef, 0x47f0,   // U+4b78 ~ U+4b7f
0x47f1, 0x47f2, 0x47f3, 0x47f4, 0x47f5, 0x47f6, 0x47f7, 0x47f8,   // U+4b80 ~ U+4b87
0x47f9, 0x47fa, 0x47fb, 0x47fc, 0x47fd, 0x47fe, 0x47ff, 0x4800,   // U+4b88 ~ U+4b8f
0x4801, 0x4802, 0x4803, 0x4804, 0x4805, 0x4806, 0x4807, 0x4808,   // U+4b90 ~ U+4b97
0x4809, 0x480a, 0x480b, 0x480c, 0x480d, 0x480e, 0x480f, 0x4810,   // U+4b98 ~ U+4b9f
0x4811, 0x4812, 0x4813, 0x4814, 0x4815, 0x4816, 0x4817, 0x4818,   // U+4ba0 ~ U+4ba7
0x4819, 0x481a, 0x481b, 0x481c, 0x481d, 0x481e, 0x481f, 0x4820,   // U+4ba8 ~ U+4baf
0x4821, 0x4822, 0x4823, 0x4824, 0x4825, 0x4826, 0x4827, 0x4828,   // U+4bb0 ~ U+4bb7
0x4829, 0x482a, 0x482b, 0x482c, 0x482d, 0x482e, 0x482f, 0x4830,   // U+4bb8 ~ U+4bbf
0x4831, 0x4832, 0x4833, 0x4834, 0x4835, 0x4836, 0x4837, 0x4838,   // U+4bc0 ~ U+4bc7
0x4839, 0x483a, 0x483b, 0x483c, 0x483d, 0x483e, 0x483f, 0x4840,   // U+4bc8 ~ U+4bcf
0x4841, 0x4842, 0x4843, 0x4844, 0x4845, 0x4846, 0x4847, 0x4848,   // U+4bd0 ~ U+4bd7
0x4849, 0x484a, 0x484b, 0x484c, 0x484d, 0x484e, 0x484f, 0x4850,   // U+4bd8 ~ U+4bdf
0x4851, 0x4852, 0x4853, 0x4854, 0x4855, 0x4856, 0x4857, 0x4858,   // U+4be0 ~ U+4be7
0x4859, 0x485a, 0x485b, 0x485c, 0x485d, 0x485e, 0x485f, 0x4860,   // U+4be8 ~ U+4bef
0x4861, 0x4862, 0x4863, 0x4864, 0x4865, 0x4866, 0x4867, 0x4868,   // U+4bf0 ~ U+4bf7
0x4869, 0x486a, 0x486b, 0x486c, 0x486d, 0x486e, 0x486f, 0x4870,   // U+4bf8 ~ U+4bff
0x4871, 0x4872, 0x4873, 0x4874, 0x4875, 0x4876, 0x4877, 0x4878,   // U+4c00 ~ U+4c07
0x4879, 0x487a, 0x487b, 0x487c, 0x487d, 0x487e, 0x487f, 0x4880,   // U+4c08 ~ U+4c0f
0x4881, 0x4882, 0x4883, 0x4884, 0x4885, 0x4886, 0x4887, 0x4888,   // U+4c10 ~ U+4c17
0x4889, 0x488a, 0x488b, 0x488c, 0x488d, 0x488e, 0x488f, 0x4890,   // U+4c18 ~ U+4c1f
0x4891, 0x4892, 0x4893, 0x4894, 0x4895, 0x4896, 0x4897, 0x4898,   // U+4c20 ~ U+4c27
0x4899, 0x489a, 0x489b, 0x489c, 0x489d, 0x489e, 0x489f, 0x48a0,   // U+4c28 ~ U+4c2f
0x48a1, 0x48a2, 0x48a3, 0x48a4, 0x48a5, 0x48a6, 0x48a7, 0x48a8,   // U+4c30 ~ U+4c37
0x48a9, 0x48aa, 0x48ab, 0x48ac, 0x48ad, 0x48ae, 0x48af, 0x48b0,   // U+4c38 ~ U+4c3f
0x48b1, 0x48b2, 0x48b3, 0x48b4, 0x48b5, 0x48b6, 0x48b7, 0x48b8,   // U+4c40 ~ U+4c47
0x48b9, 0x48ba, 0x48bb, 0x48bc, 0x48bd, 0x48be, 0x48bf, 0x48c0,   // U+4c48 ~ U+4c4f
0x48c1, 0x48c2, 0x48c3, 0x48c4, 0x48c5, 0x48c6, 0x48c7, 0x48c8,   // U+4c50 ~ U+4c57
0x48c9, 0x48ca, 0x48cb, 0x48cc, 0x48cd, 0x48ce, 0x48cf, 0x48d0,   // U+4c58 ~ U+4c5f
0x48d1, 0x48d2, 0x48d3, 0x48d4, 0x48d5, 0x48d6, 0x48d7, 0x48d8,   // U+4c60 ~ U+4c67
0x48d9, 0x48da, 0x48db, 0x48dc, 0x48dd, 0x48de, 0x48df, 0x48e0,   // U+4c68 ~ U+4c6f
0x48e1, 0x48e2, 0x48e3, 0x48e4, 0x48e5, 0x48e6, 0x48e7, 0xffbb,   // U+4c70 ~ U+4c77
0x48e8, 0x48e9, 0x48ea, 0x48eb, 0x48ec, 0x48ed, 0x48ee, 0x48ef,   // U+4c78 ~ U+4c7f
0x48f0, 0x48f1, 0x48f2, 0x48f3, 0x48f4, 0x48f5, 0x48f6, 0x48f7,   // U+4c80 ~ U+4c87
0x48f8, 0x48f9, 0x48fa, 0x48fb, 0x48fc, 0x48fd, 0x48fe, 0x48ff,   // U+4c88 ~ U+4c8f
0x4900, 0x4901, 0x4902, 0x4903, 0x4904, 0x4905, 0x4906, 0x4907,   // U+4c90 ~ U+4c97
0x4908, 0x4909, 0x490a, 0x490b, 0x490c, 0x490d, 0x490e, 0xffba,   // U+4c98 ~ U+4c9f
0xffb9, 0xffb8, 0xffb7, 0xffb6, 0x490f, 0x4910, 0x4911, 0x4912,   // U+4ca0 ~ U+4ca7
0x4913, 0x4914, 0x4915, 0x4916, 0x4917, 0x4918, 0x4919, 0x491a,   // U+4ca8 ~ U+4caf
0x491b, 0x491c, 0x491d, 0x491e, 0x491f, 0x4920, 0x4921, 0x4922,   // U+4cb0 ~ U+4cb7
0x4923, 0x4924, 0x4925, 0x4926, 0x4927, 0x4928, 0x4929, 0x492a,   // U+4cb8 ~ U+4cbf
0x492b, 0x492c, 0x492d, 0x492e, 0x492f, 0x4930, 0x4931, 0x4932,   // U+4cc0 ~ U+4cc7
0x4933, 0x4934, 0x4935, 0x4936, 0x4937, 0x4938, 0x4939, 0x493a,   // U+4cc8 ~ U+4ccf
0x493b, 0x493c, 0x493d, 0x493e, 0x493f, 0x4940, 0x4941, 0x4942,   // U+4cd0 ~ U+4cd7
0x4943, 0x4944, 0x4945, 0x4946, 0x4947, 0x4948, 0x4949, 0x494a,   // U+4cd8 ~ U+4cdf
0x494b, 0x494c, 0x494d, 0x494e, 0x494f, 0x4950, 0x4951, 0x4952,   // U+4ce0 ~ U+4ce7
0x4953, 0x4954, 0x4955, 0x4956, 0x4957, 0x4958, 0x4959, 0x495a,   // U+4ce8 ~ U+4cef
0x495b, 0x495c, 0x495d, 0x495e, 0x495f, 0x4960, 0x4961, 0x4962,   // U+4cf0 ~ U+4cf7
0x4963, 0x4964, 0x4965, 0x4966, 0x4967, 0x4968, 0x4969, 0x496a,   // U+4cf8 ~ U+4cff
0x496b, 0x496c, 0x496d, 0x496e, 0x496f, 0x4970, 0x4971, 0x4972,   // U+4d00 ~ U+4d07
0x4973, 0x4974, 0x4975, 0x4976, 0x4977, 0x4978, 0x4979, 0x497a,   // U+4d08 ~ U+4d0f
0x497b, 0x497c, 0x497d, 0xffb5, 0xffb4, 0xffb3, 0xffb2, 0xffb1,   // U+4d10 ~ U+4d17
0xffb0, 0xffaf, 0x497e, 0x497f, 0x4980, 0x4981, 0x4982, 0x4983,   // U+4d18 ~ U+4d1f
0x4984, 0x4985, 0x4986, 0x4987, 0x4988, 0x4989, 0x498a, 0x498b,   // U+4d20 ~ U+4d27
0x498c, 0x498d, 0x498e, 0x498f, 0x4990, 0x4991, 0x4992, 0x4993,   // U+4d28 ~ U+4d2f
0x4994, 0x4995, 0x4996, 0x4997, 0x4998, 0x4999, 0x499a, 0x499b,   // U+4d30 ~ U+4d37
0x499c, 0x499d, 0x499e, 0x499f, 0x49a0, 0x49a1, 0x49a2, 0x49a3,   // U+4d38 ~ U+4d3f
0x49a4, 0x49a5, 0x49a6, 0x49a7, 0x49a8, 0x49a9, 0x49aa, 0x49ab,   // U+4d40 ~ U+4d47
0x49ac, 0x49ad, 0x49ae, 0x49af, 0x49b0, 0x49b1, 0x49b2, 0x49b3,   // U+4d48 ~ U+4d4f
0x49b4, 0x49b5, 0x49b6, 0x49b7, 0x49b8, 0x49b9, 0x49ba, 0x49bb,   // U+4d50 ~ U+4d57
0x49bc, 0x49bd, 0x49be, 0x49bf, 0x49c0, 0x49c1, 0x49c2, 0x49c3,   // U+4d58 ~ U+4d5f
0x49c4, 0x49c5, 0x49c6, 0x49c7, 0x49c8, 0x49c9, 0x49ca, 0x49cb,   // U+4d60 ~ U+4d67
0x49cc, 0x49cd, 0x49ce, 0x49cf, 0x49d0, 0x49d1, 0x49d2, 0x49d3,   // U+4d68 ~ U+4d6f
0x49d4, 0x49d5, 0x49d6, 0x49d7, 0x49d8, 0x49d9, 0x49da, 0x49db,   // U+4d70 ~ U+4d77
0x49dc, 0x49dd, 0x49de, 0x49df, 0x49e0, 0x49e1, 0x49e2, 0x49e3,   // U+4d78 ~ U+4d7f
0x49e4, 0x49e5, 0x49e6, 0x49e7, 0x49e8, 0x49e9, 0x49ea, 0x49eb,   // U+4d80 ~ U+4d87
0x49ec, 0x49ed, 0x49ee, 0x49ef, 0x49f0, 0x49f1, 0x49f2, 0x49f3,   // U+4d88 ~ U+4d8f
0x49f4, 0x49f5, 0x49f6, 0x49f7, 0x49f8, 0x49f9, 0x49fa, 0x49fb,   // U+4d90 ~ U+4d97
0x49fc, 0x49fd, 0x49fe, 0x49ff, 0x4a00, 0x4a01, 0x4a02, 0x4a03,   // U+4d98 ~ U+4d9f
0x4a04, 0x4a05, 0x4a06, 0x4a07, 0x4a08, 0x4a09, 0x4a0a, 0x4a0b,   // U+4da0 ~ U+4da7
0x4a0c, 0x4a0d, 0x4a0e, 0x4a0f, 0x4a10, 0x4a11, 0xffae, 0x4a12,   // U+4da8 ~ U+4daf
0x4a13, 0x4a14, 0x4a15, 0x4a16, 0x4a17, 0x4a18, 0x4a19, 0x4a1a,   // U+4db0 ~ U+4db7
0x4a1b, 0x4a1c, 0x4a1d, 0x4a1e, 0x4a1f, 0x4a20, 0x4a21, 0x4a22,   // U+4db8 ~ U+4dbf
0x4a23, 0x4a24, 0x4a25, 0x4a26, 0x4a27, 0x4a28, 0x4a29, 0x4a2a,   // U+4dc0 ~ U+4dc7
0x4a2b, 0x4a2c, 0x4a2d, 0x4a2e, 0x4a2f, 0x4a30, 0x4a31, 0x4a32,   // U+4dc8 ~ U+4dcf
0x4a33, 0x4a34, 0x4a35, 0x4a36, 0x4a37, 0x4a38, 0x4a39, 0x4a3a,   // U+4dd0 ~ U+4dd7
0x4a3b, 0x4a3c, 0x4a3d, 0x4a3e, 0x4a3f, 0x4a40, 0x4a41, 0x4a42,   // U+4dd8 ~ U+4ddf
0x4a43, 0x4a44, 0x4a45, 0x4a46, 0x4a47, 0x4a48, 0x4a49, 0x4a4a,   // U+4de0 ~ U+4de7
0x4a4b, 0x4a4c, 0x4a4d, 0x4a4e, 0x4a4f, 0x4a50, 0x4a51, 0x4a52,   // U+4de8 ~ U+4def
0x4a53, 0x4a54, 0x4a55, 0x4a56, 0x4a57, 0x4a58, 0x4a59, 0x4a5a,   // U+4df0 ~ U+4df7
0x4a5b, 0x4a5c, 0x4a5d, 0x4a5e, 0x4a5f, 0x4a60, 0x4a61, 0x4a62,   // U+4df8 ~ U+4dff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4e00 ~ U+4e07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4e08 ~ U+4e0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4e10 ~ U+4e17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4e18 ~ U+4e1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4e20 ~ U+4e27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4e28 ~ U+4e2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4e30 ~ U+4e37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4e38 ~ U+4e3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4e40 ~ U+4e47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4e48 ~ U+4e4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4e50 ~ U+4e57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4e58 ~ U+4e5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4e60 ~ U+4e67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4e68 ~ U+4e6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4e70 ~ U+4e77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4e78 ~ U+4e7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4e80 ~ U+4e87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4e88 ~ U+4e8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4e90 ~ U+4e97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4e98 ~ U+4e9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4ea0 ~ U+4ea7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4ea8 ~ U+4eaf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4eb0 ~ U+4eb7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4eb8 ~ U+4ebf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4ec0 ~ U+4ec7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4ec8 ~ U+4ecf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4ed0 ~ U+4ed7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4ed8 ~ U+4edf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4ee0 ~ U+4ee7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4ee8 ~ U+4eef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4ef0 ~ U+4ef7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4ef8 ~ U+4eff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4f00 ~ U+4f07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4f08 ~ U+4f0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4f10 ~ U+4f17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4f18 ~ U+4f1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4f20 ~ U+4f27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4f28 ~ U+4f2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4f30 ~ U+4f37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4f38 ~ U+4f3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4f40 ~ U+4f47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4f48 ~ U+4f4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4f50 ~ U+4f57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4f58 ~ U+4f5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4f60 ~ U+4f67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4f68 ~ U+4f6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4f70 ~ U+4f77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4f78 ~ U+4f7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4f80 ~ U+4f87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4f88 ~ U+4f8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4f90 ~ U+4f97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4f98 ~ U+4f9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4fa0 ~ U+4fa7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4fa8 ~ U+4faf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4fb0 ~ U+4fb7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4fb8 ~ U+4fbf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4fc0 ~ U+4fc7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4fc8 ~ U+4fcf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4fd0 ~ U+4fd7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4fd8 ~ U+4fdf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4fe0 ~ U+4fe7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4fe8 ~ U+4fef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4ff0 ~ U+4ff7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+4ff8 ~ U+4fff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5000 ~ U+5007
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5008 ~ U+500f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5010 ~ U+5017
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5018 ~ U+501f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5020 ~ U+5027
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5028 ~ U+502f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5030 ~ U+5037
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5038 ~ U+503f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5040 ~ U+5047
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5048 ~ U+504f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5050 ~ U+5057
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5058 ~ U+505f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5060 ~ U+5067
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5068 ~ U+506f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5070 ~ U+5077
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5078 ~ U+507f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5080 ~ U+5087
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5088 ~ U+508f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5090 ~ U+5097
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5098 ~ U+509f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+50a0 ~ U+50a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+50a8 ~ U+50af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+50b0 ~ U+50b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+50b8 ~ U+50bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+50c0 ~ U+50c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+50c8 ~ U+50cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+50d0 ~ U+50d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+50d8 ~ U+50df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+50e0 ~ U+50e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+50e8 ~ U+50ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+50f0 ~ U+50f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+50f8 ~ U+50ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5100 ~ U+5107
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5108 ~ U+510f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5110 ~ U+5117
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5118 ~ U+511f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5120 ~ U+5127
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5128 ~ U+512f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5130 ~ U+5137
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5138 ~ U+513f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5140 ~ U+5147
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5148 ~ U+514f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5150 ~ U+5157
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5158 ~ U+515f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5160 ~ U+5167
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5168 ~ U+516f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5170 ~ U+5177
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5178 ~ U+517f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5180 ~ U+5187
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5188 ~ U+518f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5190 ~ U+5197
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5198 ~ U+519f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+51a0 ~ U+51a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+51a8 ~ U+51af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+51b0 ~ U+51b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+51b8 ~ U+51bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+51c0 ~ U+51c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+51c8 ~ U+51cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+51d0 ~ U+51d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+51d8 ~ U+51df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+51e0 ~ U+51e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+51e8 ~ U+51ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+51f0 ~ U+51f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+51f8 ~ U+51ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5200 ~ U+5207
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5208 ~ U+520f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5210 ~ U+5217
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5218 ~ U+521f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5220 ~ U+5227
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5228 ~ U+522f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5230 ~ U+5237
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5238 ~ U+523f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5240 ~ U+5247
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5248 ~ U+524f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5250 ~ U+5257
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5258 ~ U+525f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5260 ~ U+5267
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5268 ~ U+526f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5270 ~ U+5277
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5278 ~ U+527f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5280 ~ U+5287
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5288 ~ U+528f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5290 ~ U+5297
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5298 ~ U+529f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+52a0 ~ U+52a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+52a8 ~ U+52af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+52b0 ~ U+52b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+52b8 ~ U+52bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+52c0 ~ U+52c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+52c8 ~ U+52cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+52d0 ~ U+52d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+52d8 ~ U+52df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+52e0 ~ U+52e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+52e8 ~ U+52ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+52f0 ~ U+52f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+52f8 ~ U+52ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5300 ~ U+5307
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5308 ~ U+530f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5310 ~ U+5317
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5318 ~ U+531f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5320 ~ U+5327
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5328 ~ U+532f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5330 ~ U+5337
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5338 ~ U+533f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5340 ~ U+5347
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5348 ~ U+534f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5350 ~ U+5357
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5358 ~ U+535f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5360 ~ U+5367
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5368 ~ U+536f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5370 ~ U+5377
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5378 ~ U+537f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5380 ~ U+5387
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5388 ~ U+538f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5390 ~ U+5397
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5398 ~ U+539f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+53a0 ~ U+53a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+53a8 ~ U+53af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+53b0 ~ U+53b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+53b8 ~ U+53bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+53c0 ~ U+53c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+53c8 ~ U+53cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+53d0 ~ U+53d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+53d8 ~ U+53df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+53e0 ~ U+53e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+53e8 ~ U+53ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+53f0 ~ U+53f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+53f8 ~ U+53ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5400 ~ U+5407
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5408 ~ U+540f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5410 ~ U+5417
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5418 ~ U+541f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5420 ~ U+5427
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5428 ~ U+542f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5430 ~ U+5437
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5438 ~ U+543f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5440 ~ U+5447
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5448 ~ U+544f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5450 ~ U+5457
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5458 ~ U+545f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5460 ~ U+5467
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5468 ~ U+546f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5470 ~ U+5477
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5478 ~ U+547f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5480 ~ U+5487
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5488 ~ U+548f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5490 ~ U+5497
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5498 ~ U+549f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+54a0 ~ U+54a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+54a8 ~ U+54af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+54b0 ~ U+54b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+54b8 ~ U+54bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+54c0 ~ U+54c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+54c8 ~ U+54cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+54d0 ~ U+54d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+54d8 ~ U+54df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+54e0 ~ U+54e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+54e8 ~ U+54ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+54f0 ~ U+54f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+54f8 ~ U+54ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5500 ~ U+5507
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5508 ~ U+550f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5510 ~ U+5517
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5518 ~ U+551f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5520 ~ U+5527
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5528 ~ U+552f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5530 ~ U+5537
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5538 ~ U+553f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5540 ~ U+5547
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5548 ~ U+554f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5550 ~ U+5557
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5558 ~ U+555f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5560 ~ U+5567
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5568 ~ U+556f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5570 ~ U+5577
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5578 ~ U+557f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5580 ~ U+5587
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5588 ~ U+558f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5590 ~ U+5597
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5598 ~ U+559f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+55a0 ~ U+55a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+55a8 ~ U+55af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+55b0 ~ U+55b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+55b8 ~ U+55bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+55c0 ~ U+55c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+55c8 ~ U+55cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+55d0 ~ U+55d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+55d8 ~ U+55df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+55e0 ~ U+55e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+55e8 ~ U+55ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+55f0 ~ U+55f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+55f8 ~ U+55ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5600 ~ U+5607
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5608 ~ U+560f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5610 ~ U+5617
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5618 ~ U+561f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5620 ~ U+5627
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5628 ~ U+562f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5630 ~ U+5637
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5638 ~ U+563f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5640 ~ U+5647
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5648 ~ U+564f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5650 ~ U+5657
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5658 ~ U+565f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5660 ~ U+5667
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5668 ~ U+566f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5670 ~ U+5677
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5678 ~ U+567f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5680 ~ U+5687
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5688 ~ U+568f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5690 ~ U+5697
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5698 ~ U+569f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+56a0 ~ U+56a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+56a8 ~ U+56af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+56b0 ~ U+56b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+56b8 ~ U+56bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+56c0 ~ U+56c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+56c8 ~ U+56cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+56d0 ~ U+56d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+56d8 ~ U+56df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+56e0 ~ U+56e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+56e8 ~ U+56ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+56f0 ~ U+56f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+56f8 ~ U+56ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5700 ~ U+5707
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5708 ~ U+570f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5710 ~ U+5717
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5718 ~ U+571f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5720 ~ U+5727
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5728 ~ U+572f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5730 ~ U+5737
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5738 ~ U+573f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5740 ~ U+5747
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5748 ~ U+574f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5750 ~ U+5757
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5758 ~ U+575f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5760 ~ U+5767
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5768 ~ U+576f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5770 ~ U+5777
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5778 ~ U+577f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5780 ~ U+5787
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5788 ~ U+578f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5790 ~ U+5797
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5798 ~ U+579f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+57a0 ~ U+57a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+57a8 ~ U+57af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+57b0 ~ U+57b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+57b8 ~ U+57bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+57c0 ~ U+57c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+57c8 ~ U+57cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+57d0 ~ U+57d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+57d8 ~ U+57df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+57e0 ~ U+57e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+57e8 ~ U+57ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+57f0 ~ U+57f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+57f8 ~ U+57ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5800 ~ U+5807
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5808 ~ U+580f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5810 ~ U+5817
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5818 ~ U+581f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5820 ~ U+5827
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5828 ~ U+582f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5830 ~ U+5837
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5838 ~ U+583f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5840 ~ U+5847
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5848 ~ U+584f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5850 ~ U+5857
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5858 ~ U+585f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5860 ~ U+5867
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5868 ~ U+586f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5870 ~ U+5877
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5878 ~ U+587f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5880 ~ U+5887
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5888 ~ U+588f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5890 ~ U+5897
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5898 ~ U+589f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+58a0 ~ U+58a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+58a8 ~ U+58af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+58b0 ~ U+58b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+58b8 ~ U+58bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+58c0 ~ U+58c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+58c8 ~ U+58cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+58d0 ~ U+58d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+58d8 ~ U+58df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+58e0 ~ U+58e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+58e8 ~ U+58ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+58f0 ~ U+58f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+58f8 ~ U+58ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5900 ~ U+5907
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5908 ~ U+590f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5910 ~ U+5917
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5918 ~ U+591f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5920 ~ U+5927
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5928 ~ U+592f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5930 ~ U+5937
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5938 ~ U+593f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5940 ~ U+5947
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5948 ~ U+594f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5950 ~ U+5957
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5958 ~ U+595f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5960 ~ U+5967
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5968 ~ U+596f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5970 ~ U+5977
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5978 ~ U+597f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5980 ~ U+5987
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5988 ~ U+598f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5990 ~ U+5997
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5998 ~ U+599f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+59a0 ~ U+59a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+59a8 ~ U+59af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+59b0 ~ U+59b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+59b8 ~ U+59bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+59c0 ~ U+59c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+59c8 ~ U+59cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+59d0 ~ U+59d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+59d8 ~ U+59df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+59e0 ~ U+59e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+59e8 ~ U+59ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+59f0 ~ U+59f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+59f8 ~ U+59ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5a00 ~ U+5a07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5a08 ~ U+5a0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5a10 ~ U+5a17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5a18 ~ U+5a1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5a20 ~ U+5a27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5a28 ~ U+5a2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5a30 ~ U+5a37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5a38 ~ U+5a3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5a40 ~ U+5a47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5a48 ~ U+5a4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5a50 ~ U+5a57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5a58 ~ U+5a5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5a60 ~ U+5a67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5a68 ~ U+5a6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5a70 ~ U+5a77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5a78 ~ U+5a7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5a80 ~ U+5a87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5a88 ~ U+5a8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5a90 ~ U+5a97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5a98 ~ U+5a9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5aa0 ~ U+5aa7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5aa8 ~ U+5aaf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5ab0 ~ U+5ab7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5ab8 ~ U+5abf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5ac0 ~ U+5ac7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5ac8 ~ U+5acf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5ad0 ~ U+5ad7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5ad8 ~ U+5adf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5ae0 ~ U+5ae7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5ae8 ~ U+5aef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5af0 ~ U+5af7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5af8 ~ U+5aff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5b00 ~ U+5b07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5b08 ~ U+5b0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5b10 ~ U+5b17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5b18 ~ U+5b1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5b20 ~ U+5b27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5b28 ~ U+5b2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5b30 ~ U+5b37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5b38 ~ U+5b3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5b40 ~ U+5b47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5b48 ~ U+5b4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5b50 ~ U+5b57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5b58 ~ U+5b5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5b60 ~ U+5b67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5b68 ~ U+5b6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5b70 ~ U+5b77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5b78 ~ U+5b7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5b80 ~ U+5b87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5b88 ~ U+5b8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5b90 ~ U+5b97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5b98 ~ U+5b9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5ba0 ~ U+5ba7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5ba8 ~ U+5baf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5bb0 ~ U+5bb7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5bb8 ~ U+5bbf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5bc0 ~ U+5bc7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5bc8 ~ U+5bcf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5bd0 ~ U+5bd7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5bd8 ~ U+5bdf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5be0 ~ U+5be7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5be8 ~ U+5bef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5bf0 ~ U+5bf7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5bf8 ~ U+5bff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5c00 ~ U+5c07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5c08 ~ U+5c0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5c10 ~ U+5c17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5c18 ~ U+5c1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5c20 ~ U+5c27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5c28 ~ U+5c2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5c30 ~ U+5c37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5c38 ~ U+5c3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5c40 ~ U+5c47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5c48 ~ U+5c4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5c50 ~ U+5c57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5c58 ~ U+5c5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5c60 ~ U+5c67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5c68 ~ U+5c6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5c70 ~ U+5c77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5c78 ~ U+5c7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5c80 ~ U+5c87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5c88 ~ U+5c8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5c90 ~ U+5c97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5c98 ~ U+5c9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5ca0 ~ U+5ca7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5ca8 ~ U+5caf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5cb0 ~ U+5cb7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5cb8 ~ U+5cbf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5cc0 ~ U+5cc7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5cc8 ~ U+5ccf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5cd0 ~ U+5cd7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5cd8 ~ U+5cdf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5ce0 ~ U+5ce7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5ce8 ~ U+5cef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5cf0 ~ U+5cf7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5cf8 ~ U+5cff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5d00 ~ U+5d07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5d08 ~ U+5d0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5d10 ~ U+5d17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5d18 ~ U+5d1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5d20 ~ U+5d27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5d28 ~ U+5d2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5d30 ~ U+5d37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5d38 ~ U+5d3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5d40 ~ U+5d47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5d48 ~ U+5d4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5d50 ~ U+5d57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5d58 ~ U+5d5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5d60 ~ U+5d67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5d68 ~ U+5d6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5d70 ~ U+5d77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5d78 ~ U+5d7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5d80 ~ U+5d87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5d88 ~ U+5d8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5d90 ~ U+5d97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5d98 ~ U+5d9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5da0 ~ U+5da7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5da8 ~ U+5daf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5db0 ~ U+5db7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5db8 ~ U+5dbf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5dc0 ~ U+5dc7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5dc8 ~ U+5dcf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5dd0 ~ U+5dd7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5dd8 ~ U+5ddf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5de0 ~ U+5de7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5de8 ~ U+5def
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5df0 ~ U+5df7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5df8 ~ U+5dff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5e00 ~ U+5e07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5e08 ~ U+5e0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5e10 ~ U+5e17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5e18 ~ U+5e1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5e20 ~ U+5e27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5e28 ~ U+5e2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5e30 ~ U+5e37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5e38 ~ U+5e3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5e40 ~ U+5e47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5e48 ~ U+5e4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5e50 ~ U+5e57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5e58 ~ U+5e5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5e60 ~ U+5e67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5e68 ~ U+5e6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5e70 ~ U+5e77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5e78 ~ U+5e7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5e80 ~ U+5e87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5e88 ~ U+5e8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5e90 ~ U+5e97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5e98 ~ U+5e9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5ea0 ~ U+5ea7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5ea8 ~ U+5eaf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5eb0 ~ U+5eb7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5eb8 ~ U+5ebf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5ec0 ~ U+5ec7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5ec8 ~ U+5ecf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5ed0 ~ U+5ed7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5ed8 ~ U+5edf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5ee0 ~ U+5ee7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5ee8 ~ U+5eef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5ef0 ~ U+5ef7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5ef8 ~ U+5eff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5f00 ~ U+5f07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5f08 ~ U+5f0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5f10 ~ U+5f17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5f18 ~ U+5f1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5f20 ~ U+5f27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5f28 ~ U+5f2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5f30 ~ U+5f37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5f38 ~ U+5f3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5f40 ~ U+5f47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5f48 ~ U+5f4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5f50 ~ U+5f57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5f58 ~ U+5f5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5f60 ~ U+5f67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5f68 ~ U+5f6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5f70 ~ U+5f77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5f78 ~ U+5f7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5f80 ~ U+5f87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5f88 ~ U+5f8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5f90 ~ U+5f97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5f98 ~ U+5f9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5fa0 ~ U+5fa7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5fa8 ~ U+5faf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5fb0 ~ U+5fb7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5fb8 ~ U+5fbf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5fc0 ~ U+5fc7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5fc8 ~ U+5fcf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5fd0 ~ U+5fd7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5fd8 ~ U+5fdf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5fe0 ~ U+5fe7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5fe8 ~ U+5fef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5ff0 ~ U+5ff7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+5ff8 ~ U+5fff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6000 ~ U+6007
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6008 ~ U+600f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6010 ~ U+6017
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6018 ~ U+601f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6020 ~ U+6027
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6028 ~ U+602f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6030 ~ U+6037
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6038 ~ U+603f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6040 ~ U+6047
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6048 ~ U+604f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6050 ~ U+6057
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6058 ~ U+605f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6060 ~ U+6067
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6068 ~ U+606f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6070 ~ U+6077
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6078 ~ U+607f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6080 ~ U+6087
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6088 ~ U+608f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6090 ~ U+6097
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6098 ~ U+609f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+60a0 ~ U+60a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+60a8 ~ U+60af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+60b0 ~ U+60b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+60b8 ~ U+60bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+60c0 ~ U+60c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+60c8 ~ U+60cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+60d0 ~ U+60d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+60d8 ~ U+60df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+60e0 ~ U+60e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+60e8 ~ U+60ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+60f0 ~ U+60f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+60f8 ~ U+60ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6100 ~ U+6107
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6108 ~ U+610f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6110 ~ U+6117
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6118 ~ U+611f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6120 ~ U+6127
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6128 ~ U+612f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6130 ~ U+6137
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6138 ~ U+613f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6140 ~ U+6147
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6148 ~ U+614f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6150 ~ U+6157
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6158 ~ U+615f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6160 ~ U+6167
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6168 ~ U+616f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6170 ~ U+6177
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6178 ~ U+617f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6180 ~ U+6187
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6188 ~ U+618f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6190 ~ U+6197
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6198 ~ U+619f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+61a0 ~ U+61a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+61a8 ~ U+61af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+61b0 ~ U+61b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+61b8 ~ U+61bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+61c0 ~ U+61c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+61c8 ~ U+61cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+61d0 ~ U+61d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+61d8 ~ U+61df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+61e0 ~ U+61e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+61e8 ~ U+61ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+61f0 ~ U+61f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+61f8 ~ U+61ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6200 ~ U+6207
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6208 ~ U+620f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6210 ~ U+6217
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6218 ~ U+621f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6220 ~ U+6227
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6228 ~ U+622f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6230 ~ U+6237
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6238 ~ U+623f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6240 ~ U+6247
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6248 ~ U+624f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6250 ~ U+6257
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6258 ~ U+625f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6260 ~ U+6267
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6268 ~ U+626f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6270 ~ U+6277
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6278 ~ U+627f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6280 ~ U+6287
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6288 ~ U+628f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6290 ~ U+6297
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6298 ~ U+629f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+62a0 ~ U+62a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+62a8 ~ U+62af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+62b0 ~ U+62b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+62b8 ~ U+62bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+62c0 ~ U+62c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+62c8 ~ U+62cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+62d0 ~ U+62d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+62d8 ~ U+62df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+62e0 ~ U+62e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+62e8 ~ U+62ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+62f0 ~ U+62f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+62f8 ~ U+62ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6300 ~ U+6307
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6308 ~ U+630f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6310 ~ U+6317
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6318 ~ U+631f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6320 ~ U+6327
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6328 ~ U+632f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6330 ~ U+6337
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6338 ~ U+633f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6340 ~ U+6347
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6348 ~ U+634f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6350 ~ U+6357
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6358 ~ U+635f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6360 ~ U+6367
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6368 ~ U+636f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6370 ~ U+6377
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6378 ~ U+637f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6380 ~ U+6387
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6388 ~ U+638f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6390 ~ U+6397
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6398 ~ U+639f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+63a0 ~ U+63a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+63a8 ~ U+63af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+63b0 ~ U+63b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+63b8 ~ U+63bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+63c0 ~ U+63c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+63c8 ~ U+63cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+63d0 ~ U+63d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+63d8 ~ U+63df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+63e0 ~ U+63e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+63e8 ~ U+63ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+63f0 ~ U+63f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+63f8 ~ U+63ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6400 ~ U+6407
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6408 ~ U+640f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6410 ~ U+6417
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6418 ~ U+641f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6420 ~ U+6427
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6428 ~ U+642f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6430 ~ U+6437
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6438 ~ U+643f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6440 ~ U+6447
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6448 ~ U+644f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6450 ~ U+6457
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6458 ~ U+645f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6460 ~ U+6467
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6468 ~ U+646f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6470 ~ U+6477
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6478 ~ U+647f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6480 ~ U+6487
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6488 ~ U+648f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6490 ~ U+6497
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6498 ~ U+649f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+64a0 ~ U+64a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+64a8 ~ U+64af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+64b0 ~ U+64b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+64b8 ~ U+64bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+64c0 ~ U+64c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+64c8 ~ U+64cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+64d0 ~ U+64d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+64d8 ~ U+64df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+64e0 ~ U+64e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+64e8 ~ U+64ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+64f0 ~ U+64f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+64f8 ~ U+64ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6500 ~ U+6507
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6508 ~ U+650f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6510 ~ U+6517
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6518 ~ U+651f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6520 ~ U+6527
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6528 ~ U+652f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6530 ~ U+6537
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6538 ~ U+653f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6540 ~ U+6547
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6548 ~ U+654f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6550 ~ U+6557
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6558 ~ U+655f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6560 ~ U+6567
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6568 ~ U+656f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6570 ~ U+6577
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6578 ~ U+657f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6580 ~ U+6587
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6588 ~ U+658f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6590 ~ U+6597
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6598 ~ U+659f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+65a0 ~ U+65a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+65a8 ~ U+65af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+65b0 ~ U+65b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+65b8 ~ U+65bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+65c0 ~ U+65c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+65c8 ~ U+65cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+65d0 ~ U+65d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+65d8 ~ U+65df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+65e0 ~ U+65e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+65e8 ~ U+65ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+65f0 ~ U+65f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+65f8 ~ U+65ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6600 ~ U+6607
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6608 ~ U+660f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6610 ~ U+6617
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6618 ~ U+661f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6620 ~ U+6627
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6628 ~ U+662f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6630 ~ U+6637
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6638 ~ U+663f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6640 ~ U+6647
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6648 ~ U+664f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6650 ~ U+6657
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6658 ~ U+665f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6660 ~ U+6667
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6668 ~ U+666f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6670 ~ U+6677
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6678 ~ U+667f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6680 ~ U+6687
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6688 ~ U+668f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6690 ~ U+6697
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6698 ~ U+669f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+66a0 ~ U+66a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+66a8 ~ U+66af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+66b0 ~ U+66b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+66b8 ~ U+66bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+66c0 ~ U+66c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+66c8 ~ U+66cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+66d0 ~ U+66d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+66d8 ~ U+66df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+66e0 ~ U+66e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+66e8 ~ U+66ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+66f0 ~ U+66f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+66f8 ~ U+66ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6700 ~ U+6707
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6708 ~ U+670f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6710 ~ U+6717
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6718 ~ U+671f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6720 ~ U+6727
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6728 ~ U+672f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6730 ~ U+6737
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6738 ~ U+673f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6740 ~ U+6747
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6748 ~ U+674f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6750 ~ U+6757
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6758 ~ U+675f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6760 ~ U+6767
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6768 ~ U+676f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6770 ~ U+6777
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6778 ~ U+677f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6780 ~ U+6787
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6788 ~ U+678f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6790 ~ U+6797
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6798 ~ U+679f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+67a0 ~ U+67a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+67a8 ~ U+67af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+67b0 ~ U+67b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+67b8 ~ U+67bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+67c0 ~ U+67c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+67c8 ~ U+67cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+67d0 ~ U+67d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+67d8 ~ U+67df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+67e0 ~ U+67e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+67e8 ~ U+67ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+67f0 ~ U+67f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+67f8 ~ U+67ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6800 ~ U+6807
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6808 ~ U+680f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6810 ~ U+6817
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6818 ~ U+681f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6820 ~ U+6827
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6828 ~ U+682f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6830 ~ U+6837
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6838 ~ U+683f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6840 ~ U+6847
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6848 ~ U+684f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6850 ~ U+6857
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6858 ~ U+685f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6860 ~ U+6867
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6868 ~ U+686f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6870 ~ U+6877
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6878 ~ U+687f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6880 ~ U+6887
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6888 ~ U+688f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6890 ~ U+6897
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6898 ~ U+689f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+68a0 ~ U+68a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+68a8 ~ U+68af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+68b0 ~ U+68b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+68b8 ~ U+68bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+68c0 ~ U+68c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+68c8 ~ U+68cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+68d0 ~ U+68d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+68d8 ~ U+68df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+68e0 ~ U+68e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+68e8 ~ U+68ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+68f0 ~ U+68f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+68f8 ~ U+68ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6900 ~ U+6907
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6908 ~ U+690f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6910 ~ U+6917
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6918 ~ U+691f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6920 ~ U+6927
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6928 ~ U+692f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6930 ~ U+6937
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6938 ~ U+693f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6940 ~ U+6947
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6948 ~ U+694f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6950 ~ U+6957
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6958 ~ U+695f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6960 ~ U+6967
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6968 ~ U+696f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6970 ~ U+6977
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6978 ~ U+697f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6980 ~ U+6987
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6988 ~ U+698f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6990 ~ U+6997
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6998 ~ U+699f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+69a0 ~ U+69a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+69a8 ~ U+69af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+69b0 ~ U+69b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+69b8 ~ U+69bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+69c0 ~ U+69c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+69c8 ~ U+69cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+69d0 ~ U+69d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+69d8 ~ U+69df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+69e0 ~ U+69e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+69e8 ~ U+69ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+69f0 ~ U+69f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+69f8 ~ U+69ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6a00 ~ U+6a07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6a08 ~ U+6a0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6a10 ~ U+6a17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6a18 ~ U+6a1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6a20 ~ U+6a27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6a28 ~ U+6a2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6a30 ~ U+6a37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6a38 ~ U+6a3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6a40 ~ U+6a47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6a48 ~ U+6a4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6a50 ~ U+6a57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6a58 ~ U+6a5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6a60 ~ U+6a67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6a68 ~ U+6a6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6a70 ~ U+6a77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6a78 ~ U+6a7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6a80 ~ U+6a87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6a88 ~ U+6a8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6a90 ~ U+6a97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6a98 ~ U+6a9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6aa0 ~ U+6aa7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6aa8 ~ U+6aaf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6ab0 ~ U+6ab7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6ab8 ~ U+6abf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6ac0 ~ U+6ac7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6ac8 ~ U+6acf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6ad0 ~ U+6ad7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6ad8 ~ U+6adf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6ae0 ~ U+6ae7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6ae8 ~ U+6aef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6af0 ~ U+6af7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6af8 ~ U+6aff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6b00 ~ U+6b07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6b08 ~ U+6b0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6b10 ~ U+6b17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6b18 ~ U+6b1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6b20 ~ U+6b27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6b28 ~ U+6b2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6b30 ~ U+6b37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6b38 ~ U+6b3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6b40 ~ U+6b47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6b48 ~ U+6b4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6b50 ~ U+6b57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6b58 ~ U+6b5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6b60 ~ U+6b67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6b68 ~ U+6b6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6b70 ~ U+6b77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6b78 ~ U+6b7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6b80 ~ U+6b87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6b88 ~ U+6b8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6b90 ~ U+6b97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6b98 ~ U+6b9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6ba0 ~ U+6ba7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6ba8 ~ U+6baf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6bb0 ~ U+6bb7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6bb8 ~ U+6bbf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6bc0 ~ U+6bc7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6bc8 ~ U+6bcf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6bd0 ~ U+6bd7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6bd8 ~ U+6bdf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6be0 ~ U+6be7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6be8 ~ U+6bef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6bf0 ~ U+6bf7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6bf8 ~ U+6bff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6c00 ~ U+6c07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6c08 ~ U+6c0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6c10 ~ U+6c17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6c18 ~ U+6c1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6c20 ~ U+6c27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6c28 ~ U+6c2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6c30 ~ U+6c37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6c38 ~ U+6c3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6c40 ~ U+6c47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6c48 ~ U+6c4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6c50 ~ U+6c57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6c58 ~ U+6c5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6c60 ~ U+6c67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6c68 ~ U+6c6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6c70 ~ U+6c77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6c78 ~ U+6c7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6c80 ~ U+6c87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6c88 ~ U+6c8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6c90 ~ U+6c97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6c98 ~ U+6c9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6ca0 ~ U+6ca7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6ca8 ~ U+6caf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6cb0 ~ U+6cb7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6cb8 ~ U+6cbf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6cc0 ~ U+6cc7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6cc8 ~ U+6ccf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6cd0 ~ U+6cd7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6cd8 ~ U+6cdf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6ce0 ~ U+6ce7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6ce8 ~ U+6cef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6cf0 ~ U+6cf7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6cf8 ~ U+6cff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6d00 ~ U+6d07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6d08 ~ U+6d0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6d10 ~ U+6d17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6d18 ~ U+6d1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6d20 ~ U+6d27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6d28 ~ U+6d2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6d30 ~ U+6d37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6d38 ~ U+6d3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6d40 ~ U+6d47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6d48 ~ U+6d4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6d50 ~ U+6d57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6d58 ~ U+6d5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6d60 ~ U+6d67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6d68 ~ U+6d6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6d70 ~ U+6d77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6d78 ~ U+6d7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6d80 ~ U+6d87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6d88 ~ U+6d8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6d90 ~ U+6d97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6d98 ~ U+6d9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6da0 ~ U+6da7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6da8 ~ U+6daf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6db0 ~ U+6db7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6db8 ~ U+6dbf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6dc0 ~ U+6dc7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6dc8 ~ U+6dcf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6dd0 ~ U+6dd7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6dd8 ~ U+6ddf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6de0 ~ U+6de7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6de8 ~ U+6def
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6df0 ~ U+6df7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6df8 ~ U+6dff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6e00 ~ U+6e07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6e08 ~ U+6e0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6e10 ~ U+6e17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6e18 ~ U+6e1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6e20 ~ U+6e27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6e28 ~ U+6e2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6e30 ~ U+6e37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6e38 ~ U+6e3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6e40 ~ U+6e47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6e48 ~ U+6e4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6e50 ~ U+6e57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6e58 ~ U+6e5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6e60 ~ U+6e67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6e68 ~ U+6e6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6e70 ~ U+6e77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6e78 ~ U+6e7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6e80 ~ U+6e87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6e88 ~ U+6e8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6e90 ~ U+6e97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6e98 ~ U+6e9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6ea0 ~ U+6ea7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6ea8 ~ U+6eaf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6eb0 ~ U+6eb7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6eb8 ~ U+6ebf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6ec0 ~ U+6ec7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6ec8 ~ U+6ecf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6ed0 ~ U+6ed7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6ed8 ~ U+6edf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6ee0 ~ U+6ee7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6ee8 ~ U+6eef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6ef0 ~ U+6ef7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6ef8 ~ U+6eff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6f00 ~ U+6f07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6f08 ~ U+6f0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6f10 ~ U+6f17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6f18 ~ U+6f1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6f20 ~ U+6f27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6f28 ~ U+6f2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6f30 ~ U+6f37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6f38 ~ U+6f3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6f40 ~ U+6f47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6f48 ~ U+6f4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6f50 ~ U+6f57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6f58 ~ U+6f5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6f60 ~ U+6f67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6f68 ~ U+6f6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6f70 ~ U+6f77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6f78 ~ U+6f7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6f80 ~ U+6f87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6f88 ~ U+6f8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6f90 ~ U+6f97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6f98 ~ U+6f9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6fa0 ~ U+6fa7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6fa8 ~ U+6faf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6fb0 ~ U+6fb7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6fb8 ~ U+6fbf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6fc0 ~ U+6fc7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6fc8 ~ U+6fcf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6fd0 ~ U+6fd7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6fd8 ~ U+6fdf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6fe0 ~ U+6fe7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6fe8 ~ U+6fef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6ff0 ~ U+6ff7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+6ff8 ~ U+6fff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7000 ~ U+7007
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7008 ~ U+700f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7010 ~ U+7017
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7018 ~ U+701f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7020 ~ U+7027
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7028 ~ U+702f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7030 ~ U+7037
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7038 ~ U+703f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7040 ~ U+7047
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7048 ~ U+704f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7050 ~ U+7057
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7058 ~ U+705f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7060 ~ U+7067
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7068 ~ U+706f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7070 ~ U+7077
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7078 ~ U+707f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7080 ~ U+7087
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7088 ~ U+708f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7090 ~ U+7097
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7098 ~ U+709f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+70a0 ~ U+70a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+70a8 ~ U+70af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+70b0 ~ U+70b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+70b8 ~ U+70bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+70c0 ~ U+70c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+70c8 ~ U+70cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+70d0 ~ U+70d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+70d8 ~ U+70df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+70e0 ~ U+70e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+70e8 ~ U+70ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+70f0 ~ U+70f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+70f8 ~ U+70ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7100 ~ U+7107
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7108 ~ U+710f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7110 ~ U+7117
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7118 ~ U+711f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7120 ~ U+7127
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7128 ~ U+712f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7130 ~ U+7137
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7138 ~ U+713f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7140 ~ U+7147
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7148 ~ U+714f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7150 ~ U+7157
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7158 ~ U+715f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7160 ~ U+7167
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7168 ~ U+716f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7170 ~ U+7177
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7178 ~ U+717f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7180 ~ U+7187
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7188 ~ U+718f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7190 ~ U+7197
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7198 ~ U+719f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+71a0 ~ U+71a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+71a8 ~ U+71af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+71b0 ~ U+71b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+71b8 ~ U+71bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+71c0 ~ U+71c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+71c8 ~ U+71cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+71d0 ~ U+71d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+71d8 ~ U+71df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+71e0 ~ U+71e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+71e8 ~ U+71ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+71f0 ~ U+71f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+71f8 ~ U+71ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7200 ~ U+7207
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7208 ~ U+720f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7210 ~ U+7217
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7218 ~ U+721f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7220 ~ U+7227
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7228 ~ U+722f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7230 ~ U+7237
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7238 ~ U+723f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7240 ~ U+7247
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7248 ~ U+724f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7250 ~ U+7257
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7258 ~ U+725f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7260 ~ U+7267
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7268 ~ U+726f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7270 ~ U+7277
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7278 ~ U+727f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7280 ~ U+7287
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7288 ~ U+728f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7290 ~ U+7297
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7298 ~ U+729f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+72a0 ~ U+72a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+72a8 ~ U+72af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+72b0 ~ U+72b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+72b8 ~ U+72bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+72c0 ~ U+72c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+72c8 ~ U+72cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+72d0 ~ U+72d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+72d8 ~ U+72df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+72e0 ~ U+72e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+72e8 ~ U+72ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+72f0 ~ U+72f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+72f8 ~ U+72ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7300 ~ U+7307
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7308 ~ U+730f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7310 ~ U+7317
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7318 ~ U+731f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7320 ~ U+7327
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7328 ~ U+732f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7330 ~ U+7337
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7338 ~ U+733f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7340 ~ U+7347
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7348 ~ U+734f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7350 ~ U+7357
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7358 ~ U+735f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7360 ~ U+7367
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7368 ~ U+736f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7370 ~ U+7377
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7378 ~ U+737f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7380 ~ U+7387
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7388 ~ U+738f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7390 ~ U+7397
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7398 ~ U+739f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+73a0 ~ U+73a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+73a8 ~ U+73af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+73b0 ~ U+73b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+73b8 ~ U+73bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+73c0 ~ U+73c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+73c8 ~ U+73cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+73d0 ~ U+73d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+73d8 ~ U+73df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+73e0 ~ U+73e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+73e8 ~ U+73ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+73f0 ~ U+73f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+73f8 ~ U+73ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7400 ~ U+7407
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7408 ~ U+740f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7410 ~ U+7417
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7418 ~ U+741f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7420 ~ U+7427
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7428 ~ U+742f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7430 ~ U+7437
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7438 ~ U+743f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7440 ~ U+7447
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7448 ~ U+744f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7450 ~ U+7457
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7458 ~ U+745f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7460 ~ U+7467
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7468 ~ U+746f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7470 ~ U+7477
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7478 ~ U+747f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7480 ~ U+7487
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7488 ~ U+748f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7490 ~ U+7497
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7498 ~ U+749f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+74a0 ~ U+74a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+74a8 ~ U+74af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+74b0 ~ U+74b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+74b8 ~ U+74bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+74c0 ~ U+74c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+74c8 ~ U+74cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+74d0 ~ U+74d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+74d8 ~ U+74df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+74e0 ~ U+74e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+74e8 ~ U+74ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+74f0 ~ U+74f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+74f8 ~ U+74ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7500 ~ U+7507
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7508 ~ U+750f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7510 ~ U+7517
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7518 ~ U+751f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7520 ~ U+7527
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7528 ~ U+752f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7530 ~ U+7537
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7538 ~ U+753f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7540 ~ U+7547
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7548 ~ U+754f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7550 ~ U+7557
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7558 ~ U+755f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7560 ~ U+7567
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7568 ~ U+756f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7570 ~ U+7577
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7578 ~ U+757f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7580 ~ U+7587
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7588 ~ U+758f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7590 ~ U+7597
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7598 ~ U+759f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+75a0 ~ U+75a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+75a8 ~ U+75af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+75b0 ~ U+75b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+75b8 ~ U+75bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+75c0 ~ U+75c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+75c8 ~ U+75cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+75d0 ~ U+75d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+75d8 ~ U+75df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+75e0 ~ U+75e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+75e8 ~ U+75ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+75f0 ~ U+75f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+75f8 ~ U+75ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7600 ~ U+7607
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7608 ~ U+760f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7610 ~ U+7617
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7618 ~ U+761f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7620 ~ U+7627
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7628 ~ U+762f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7630 ~ U+7637
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7638 ~ U+763f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7640 ~ U+7647
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7648 ~ U+764f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7650 ~ U+7657
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7658 ~ U+765f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7660 ~ U+7667
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7668 ~ U+766f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7670 ~ U+7677
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7678 ~ U+767f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7680 ~ U+7687
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7688 ~ U+768f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7690 ~ U+7697
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7698 ~ U+769f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+76a0 ~ U+76a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+76a8 ~ U+76af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+76b0 ~ U+76b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+76b8 ~ U+76bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+76c0 ~ U+76c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+76c8 ~ U+76cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+76d0 ~ U+76d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+76d8 ~ U+76df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+76e0 ~ U+76e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+76e8 ~ U+76ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+76f0 ~ U+76f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+76f8 ~ U+76ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7700 ~ U+7707
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7708 ~ U+770f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7710 ~ U+7717
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7718 ~ U+771f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7720 ~ U+7727
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7728 ~ U+772f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7730 ~ U+7737
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7738 ~ U+773f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7740 ~ U+7747
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7748 ~ U+774f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7750 ~ U+7757
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7758 ~ U+775f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7760 ~ U+7767
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7768 ~ U+776f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7770 ~ U+7777
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7778 ~ U+777f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7780 ~ U+7787
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7788 ~ U+778f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7790 ~ U+7797
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7798 ~ U+779f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+77a0 ~ U+77a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+77a8 ~ U+77af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+77b0 ~ U+77b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+77b8 ~ U+77bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+77c0 ~ U+77c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+77c8 ~ U+77cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+77d0 ~ U+77d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+77d8 ~ U+77df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+77e0 ~ U+77e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+77e8 ~ U+77ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+77f0 ~ U+77f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+77f8 ~ U+77ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7800 ~ U+7807
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7808 ~ U+780f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7810 ~ U+7817
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7818 ~ U+781f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7820 ~ U+7827
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7828 ~ U+782f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7830 ~ U+7837
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7838 ~ U+783f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7840 ~ U+7847
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7848 ~ U+784f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7850 ~ U+7857
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7858 ~ U+785f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7860 ~ U+7867
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7868 ~ U+786f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7870 ~ U+7877
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7878 ~ U+787f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7880 ~ U+7887
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7888 ~ U+788f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7890 ~ U+7897
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7898 ~ U+789f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+78a0 ~ U+78a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+78a8 ~ U+78af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+78b0 ~ U+78b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+78b8 ~ U+78bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+78c0 ~ U+78c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+78c8 ~ U+78cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+78d0 ~ U+78d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+78d8 ~ U+78df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+78e0 ~ U+78e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+78e8 ~ U+78ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+78f0 ~ U+78f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+78f8 ~ U+78ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7900 ~ U+7907
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7908 ~ U+790f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7910 ~ U+7917
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7918 ~ U+791f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7920 ~ U+7927
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7928 ~ U+792f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7930 ~ U+7937
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7938 ~ U+793f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7940 ~ U+7947
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7948 ~ U+794f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7950 ~ U+7957
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7958 ~ U+795f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7960 ~ U+7967
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7968 ~ U+796f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7970 ~ U+7977
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7978 ~ U+797f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7980 ~ U+7987
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7988 ~ U+798f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7990 ~ U+7997
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7998 ~ U+799f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+79a0 ~ U+79a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+79a8 ~ U+79af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+79b0 ~ U+79b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+79b8 ~ U+79bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+79c0 ~ U+79c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+79c8 ~ U+79cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+79d0 ~ U+79d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+79d8 ~ U+79df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+79e0 ~ U+79e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+79e8 ~ U+79ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+79f0 ~ U+79f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+79f8 ~ U+79ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7a00 ~ U+7a07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7a08 ~ U+7a0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7a10 ~ U+7a17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7a18 ~ U+7a1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7a20 ~ U+7a27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7a28 ~ U+7a2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7a30 ~ U+7a37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7a38 ~ U+7a3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7a40 ~ U+7a47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7a48 ~ U+7a4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7a50 ~ U+7a57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7a58 ~ U+7a5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7a60 ~ U+7a67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7a68 ~ U+7a6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7a70 ~ U+7a77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7a78 ~ U+7a7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7a80 ~ U+7a87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7a88 ~ U+7a8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7a90 ~ U+7a97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7a98 ~ U+7a9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7aa0 ~ U+7aa7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7aa8 ~ U+7aaf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7ab0 ~ U+7ab7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7ab8 ~ U+7abf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7ac0 ~ U+7ac7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7ac8 ~ U+7acf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7ad0 ~ U+7ad7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7ad8 ~ U+7adf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7ae0 ~ U+7ae7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7ae8 ~ U+7aef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7af0 ~ U+7af7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7af8 ~ U+7aff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7b00 ~ U+7b07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7b08 ~ U+7b0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7b10 ~ U+7b17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7b18 ~ U+7b1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7b20 ~ U+7b27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7b28 ~ U+7b2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7b30 ~ U+7b37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7b38 ~ U+7b3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7b40 ~ U+7b47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7b48 ~ U+7b4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7b50 ~ U+7b57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7b58 ~ U+7b5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7b60 ~ U+7b67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7b68 ~ U+7b6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7b70 ~ U+7b77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7b78 ~ U+7b7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7b80 ~ U+7b87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7b88 ~ U+7b8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7b90 ~ U+7b97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7b98 ~ U+7b9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7ba0 ~ U+7ba7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7ba8 ~ U+7baf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7bb0 ~ U+7bb7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7bb8 ~ U+7bbf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7bc0 ~ U+7bc7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7bc8 ~ U+7bcf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7bd0 ~ U+7bd7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7bd8 ~ U+7bdf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7be0 ~ U+7be7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7be8 ~ U+7bef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7bf0 ~ U+7bf7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7bf8 ~ U+7bff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7c00 ~ U+7c07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7c08 ~ U+7c0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7c10 ~ U+7c17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7c18 ~ U+7c1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7c20 ~ U+7c27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7c28 ~ U+7c2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7c30 ~ U+7c37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7c38 ~ U+7c3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7c40 ~ U+7c47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7c48 ~ U+7c4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7c50 ~ U+7c57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7c58 ~ U+7c5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7c60 ~ U+7c67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7c68 ~ U+7c6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7c70 ~ U+7c77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7c78 ~ U+7c7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7c80 ~ U+7c87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7c88 ~ U+7c8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7c90 ~ U+7c97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7c98 ~ U+7c9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7ca0 ~ U+7ca7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7ca8 ~ U+7caf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7cb0 ~ U+7cb7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7cb8 ~ U+7cbf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7cc0 ~ U+7cc7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7cc8 ~ U+7ccf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7cd0 ~ U+7cd7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7cd8 ~ U+7cdf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7ce0 ~ U+7ce7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7ce8 ~ U+7cef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7cf0 ~ U+7cf7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7cf8 ~ U+7cff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7d00 ~ U+7d07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7d08 ~ U+7d0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7d10 ~ U+7d17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7d18 ~ U+7d1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7d20 ~ U+7d27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7d28 ~ U+7d2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7d30 ~ U+7d37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7d38 ~ U+7d3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7d40 ~ U+7d47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7d48 ~ U+7d4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7d50 ~ U+7d57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7d58 ~ U+7d5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7d60 ~ U+7d67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7d68 ~ U+7d6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7d70 ~ U+7d77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7d78 ~ U+7d7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7d80 ~ U+7d87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7d88 ~ U+7d8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7d90 ~ U+7d97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7d98 ~ U+7d9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7da0 ~ U+7da7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7da8 ~ U+7daf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7db0 ~ U+7db7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7db8 ~ U+7dbf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7dc0 ~ U+7dc7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7dc8 ~ U+7dcf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7dd0 ~ U+7dd7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7dd8 ~ U+7ddf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7de0 ~ U+7de7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7de8 ~ U+7def
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7df0 ~ U+7df7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7df8 ~ U+7dff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7e00 ~ U+7e07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7e08 ~ U+7e0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7e10 ~ U+7e17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7e18 ~ U+7e1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7e20 ~ U+7e27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7e28 ~ U+7e2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7e30 ~ U+7e37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7e38 ~ U+7e3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7e40 ~ U+7e47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7e48 ~ U+7e4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7e50 ~ U+7e57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7e58 ~ U+7e5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7e60 ~ U+7e67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7e68 ~ U+7e6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7e70 ~ U+7e77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7e78 ~ U+7e7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7e80 ~ U+7e87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7e88 ~ U+7e8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7e90 ~ U+7e97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7e98 ~ U+7e9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7ea0 ~ U+7ea7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7ea8 ~ U+7eaf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7eb0 ~ U+7eb7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7eb8 ~ U+7ebf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7ec0 ~ U+7ec7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7ec8 ~ U+7ecf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7ed0 ~ U+7ed7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7ed8 ~ U+7edf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7ee0 ~ U+7ee7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7ee8 ~ U+7eef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7ef0 ~ U+7ef7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7ef8 ~ U+7eff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7f00 ~ U+7f07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7f08 ~ U+7f0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7f10 ~ U+7f17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7f18 ~ U+7f1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7f20 ~ U+7f27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7f28 ~ U+7f2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7f30 ~ U+7f37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7f38 ~ U+7f3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7f40 ~ U+7f47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7f48 ~ U+7f4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7f50 ~ U+7f57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7f58 ~ U+7f5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7f60 ~ U+7f67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7f68 ~ U+7f6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7f70 ~ U+7f77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7f78 ~ U+7f7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7f80 ~ U+7f87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7f88 ~ U+7f8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7f90 ~ U+7f97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7f98 ~ U+7f9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7fa0 ~ U+7fa7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7fa8 ~ U+7faf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7fb0 ~ U+7fb7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7fb8 ~ U+7fbf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7fc0 ~ U+7fc7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7fc8 ~ U+7fcf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7fd0 ~ U+7fd7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7fd8 ~ U+7fdf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7fe0 ~ U+7fe7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7fe8 ~ U+7fef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7ff0 ~ U+7ff7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+7ff8 ~ U+7fff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8000 ~ U+8007
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8008 ~ U+800f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8010 ~ U+8017
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8018 ~ U+801f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8020 ~ U+8027
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8028 ~ U+802f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8030 ~ U+8037
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8038 ~ U+803f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8040 ~ U+8047
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8048 ~ U+804f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8050 ~ U+8057
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8058 ~ U+805f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8060 ~ U+8067
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8068 ~ U+806f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8070 ~ U+8077
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8078 ~ U+807f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8080 ~ U+8087
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8088 ~ U+808f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8090 ~ U+8097
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8098 ~ U+809f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+80a0 ~ U+80a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+80a8 ~ U+80af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+80b0 ~ U+80b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+80b8 ~ U+80bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+80c0 ~ U+80c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+80c8 ~ U+80cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+80d0 ~ U+80d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+80d8 ~ U+80df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+80e0 ~ U+80e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+80e8 ~ U+80ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+80f0 ~ U+80f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+80f8 ~ U+80ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8100 ~ U+8107
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8108 ~ U+810f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8110 ~ U+8117
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8118 ~ U+811f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8120 ~ U+8127
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8128 ~ U+812f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8130 ~ U+8137
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8138 ~ U+813f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8140 ~ U+8147
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8148 ~ U+814f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8150 ~ U+8157
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8158 ~ U+815f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8160 ~ U+8167
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8168 ~ U+816f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8170 ~ U+8177
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8178 ~ U+817f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8180 ~ U+8187
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8188 ~ U+818f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8190 ~ U+8197
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8198 ~ U+819f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+81a0 ~ U+81a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+81a8 ~ U+81af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+81b0 ~ U+81b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+81b8 ~ U+81bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+81c0 ~ U+81c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+81c8 ~ U+81cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+81d0 ~ U+81d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+81d8 ~ U+81df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+81e0 ~ U+81e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+81e8 ~ U+81ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+81f0 ~ U+81f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+81f8 ~ U+81ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8200 ~ U+8207
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8208 ~ U+820f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8210 ~ U+8217
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8218 ~ U+821f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8220 ~ U+8227
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8228 ~ U+822f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8230 ~ U+8237
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8238 ~ U+823f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8240 ~ U+8247
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8248 ~ U+824f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8250 ~ U+8257
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8258 ~ U+825f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8260 ~ U+8267
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8268 ~ U+826f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8270 ~ U+8277
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8278 ~ U+827f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8280 ~ U+8287
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8288 ~ U+828f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8290 ~ U+8297
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8298 ~ U+829f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+82a0 ~ U+82a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+82a8 ~ U+82af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+82b0 ~ U+82b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+82b8 ~ U+82bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+82c0 ~ U+82c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+82c8 ~ U+82cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+82d0 ~ U+82d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+82d8 ~ U+82df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+82e0 ~ U+82e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+82e8 ~ U+82ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+82f0 ~ U+82f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+82f8 ~ U+82ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8300 ~ U+8307
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8308 ~ U+830f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8310 ~ U+8317
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8318 ~ U+831f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8320 ~ U+8327
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8328 ~ U+832f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8330 ~ U+8337
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8338 ~ U+833f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8340 ~ U+8347
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8348 ~ U+834f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8350 ~ U+8357
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8358 ~ U+835f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8360 ~ U+8367
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8368 ~ U+836f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8370 ~ U+8377
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8378 ~ U+837f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8380 ~ U+8387
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8388 ~ U+838f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8390 ~ U+8397
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8398 ~ U+839f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+83a0 ~ U+83a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+83a8 ~ U+83af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+83b0 ~ U+83b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+83b8 ~ U+83bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+83c0 ~ U+83c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+83c8 ~ U+83cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+83d0 ~ U+83d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+83d8 ~ U+83df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+83e0 ~ U+83e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+83e8 ~ U+83ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+83f0 ~ U+83f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+83f8 ~ U+83ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8400 ~ U+8407
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8408 ~ U+840f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8410 ~ U+8417
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8418 ~ U+841f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8420 ~ U+8427
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8428 ~ U+842f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8430 ~ U+8437
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8438 ~ U+843f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8440 ~ U+8447
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8448 ~ U+844f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8450 ~ U+8457
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8458 ~ U+845f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8460 ~ U+8467
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8468 ~ U+846f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8470 ~ U+8477
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8478 ~ U+847f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8480 ~ U+8487
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8488 ~ U+848f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8490 ~ U+8497
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8498 ~ U+849f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+84a0 ~ U+84a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+84a8 ~ U+84af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+84b0 ~ U+84b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+84b8 ~ U+84bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+84c0 ~ U+84c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+84c8 ~ U+84cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+84d0 ~ U+84d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+84d8 ~ U+84df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+84e0 ~ U+84e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+84e8 ~ U+84ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+84f0 ~ U+84f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+84f8 ~ U+84ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8500 ~ U+8507
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8508 ~ U+850f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8510 ~ U+8517
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8518 ~ U+851f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8520 ~ U+8527
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8528 ~ U+852f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8530 ~ U+8537
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8538 ~ U+853f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8540 ~ U+8547
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8548 ~ U+854f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8550 ~ U+8557
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8558 ~ U+855f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8560 ~ U+8567
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8568 ~ U+856f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8570 ~ U+8577
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8578 ~ U+857f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8580 ~ U+8587
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8588 ~ U+858f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8590 ~ U+8597
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8598 ~ U+859f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+85a0 ~ U+85a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+85a8 ~ U+85af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+85b0 ~ U+85b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+85b8 ~ U+85bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+85c0 ~ U+85c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+85c8 ~ U+85cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+85d0 ~ U+85d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+85d8 ~ U+85df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+85e0 ~ U+85e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+85e8 ~ U+85ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+85f0 ~ U+85f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+85f8 ~ U+85ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8600 ~ U+8607
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8608 ~ U+860f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8610 ~ U+8617
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8618 ~ U+861f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8620 ~ U+8627
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8628 ~ U+862f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8630 ~ U+8637
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8638 ~ U+863f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8640 ~ U+8647
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8648 ~ U+864f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8650 ~ U+8657
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8658 ~ U+865f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8660 ~ U+8667
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8668 ~ U+866f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8670 ~ U+8677
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8678 ~ U+867f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8680 ~ U+8687
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8688 ~ U+868f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8690 ~ U+8697
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8698 ~ U+869f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+86a0 ~ U+86a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+86a8 ~ U+86af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+86b0 ~ U+86b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+86b8 ~ U+86bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+86c0 ~ U+86c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+86c8 ~ U+86cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+86d0 ~ U+86d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+86d8 ~ U+86df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+86e0 ~ U+86e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+86e8 ~ U+86ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+86f0 ~ U+86f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+86f8 ~ U+86ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8700 ~ U+8707
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8708 ~ U+870f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8710 ~ U+8717
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8718 ~ U+871f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8720 ~ U+8727
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8728 ~ U+872f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8730 ~ U+8737
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8738 ~ U+873f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8740 ~ U+8747
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8748 ~ U+874f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8750 ~ U+8757
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8758 ~ U+875f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8760 ~ U+8767
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8768 ~ U+876f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8770 ~ U+8777
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8778 ~ U+877f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8780 ~ U+8787
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8788 ~ U+878f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8790 ~ U+8797
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8798 ~ U+879f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+87a0 ~ U+87a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+87a8 ~ U+87af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+87b0 ~ U+87b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+87b8 ~ U+87bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+87c0 ~ U+87c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+87c8 ~ U+87cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+87d0 ~ U+87d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+87d8 ~ U+87df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+87e0 ~ U+87e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+87e8 ~ U+87ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+87f0 ~ U+87f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+87f8 ~ U+87ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8800 ~ U+8807
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8808 ~ U+880f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8810 ~ U+8817
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8818 ~ U+881f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8820 ~ U+8827
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8828 ~ U+882f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8830 ~ U+8837
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8838 ~ U+883f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8840 ~ U+8847
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8848 ~ U+884f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8850 ~ U+8857
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8858 ~ U+885f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8860 ~ U+8867
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8868 ~ U+886f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8870 ~ U+8877
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8878 ~ U+887f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8880 ~ U+8887
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8888 ~ U+888f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8890 ~ U+8897
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8898 ~ U+889f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+88a0 ~ U+88a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+88a8 ~ U+88af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+88b0 ~ U+88b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+88b8 ~ U+88bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+88c0 ~ U+88c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+88c8 ~ U+88cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+88d0 ~ U+88d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+88d8 ~ U+88df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+88e0 ~ U+88e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+88e8 ~ U+88ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+88f0 ~ U+88f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+88f8 ~ U+88ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8900 ~ U+8907
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8908 ~ U+890f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8910 ~ U+8917
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8918 ~ U+891f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8920 ~ U+8927
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8928 ~ U+892f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8930 ~ U+8937
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8938 ~ U+893f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8940 ~ U+8947
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8948 ~ U+894f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8950 ~ U+8957
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8958 ~ U+895f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8960 ~ U+8967
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8968 ~ U+896f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8970 ~ U+8977
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8978 ~ U+897f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8980 ~ U+8987
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8988 ~ U+898f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8990 ~ U+8997
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8998 ~ U+899f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+89a0 ~ U+89a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+89a8 ~ U+89af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+89b0 ~ U+89b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+89b8 ~ U+89bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+89c0 ~ U+89c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+89c8 ~ U+89cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+89d0 ~ U+89d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+89d8 ~ U+89df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+89e0 ~ U+89e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+89e8 ~ U+89ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+89f0 ~ U+89f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+89f8 ~ U+89ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8a00 ~ U+8a07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8a08 ~ U+8a0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8a10 ~ U+8a17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8a18 ~ U+8a1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8a20 ~ U+8a27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8a28 ~ U+8a2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8a30 ~ U+8a37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8a38 ~ U+8a3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8a40 ~ U+8a47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8a48 ~ U+8a4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8a50 ~ U+8a57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8a58 ~ U+8a5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8a60 ~ U+8a67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8a68 ~ U+8a6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8a70 ~ U+8a77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8a78 ~ U+8a7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8a80 ~ U+8a87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8a88 ~ U+8a8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8a90 ~ U+8a97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8a98 ~ U+8a9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8aa0 ~ U+8aa7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8aa8 ~ U+8aaf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8ab0 ~ U+8ab7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8ab8 ~ U+8abf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8ac0 ~ U+8ac7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8ac8 ~ U+8acf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8ad0 ~ U+8ad7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8ad8 ~ U+8adf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8ae0 ~ U+8ae7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8ae8 ~ U+8aef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8af0 ~ U+8af7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8af8 ~ U+8aff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8b00 ~ U+8b07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8b08 ~ U+8b0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8b10 ~ U+8b17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8b18 ~ U+8b1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8b20 ~ U+8b27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8b28 ~ U+8b2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8b30 ~ U+8b37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8b38 ~ U+8b3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8b40 ~ U+8b47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8b48 ~ U+8b4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8b50 ~ U+8b57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8b58 ~ U+8b5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8b60 ~ U+8b67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8b68 ~ U+8b6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8b70 ~ U+8b77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8b78 ~ U+8b7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8b80 ~ U+8b87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8b88 ~ U+8b8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8b90 ~ U+8b97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8b98 ~ U+8b9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8ba0 ~ U+8ba7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8ba8 ~ U+8baf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8bb0 ~ U+8bb7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8bb8 ~ U+8bbf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8bc0 ~ U+8bc7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8bc8 ~ U+8bcf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8bd0 ~ U+8bd7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8bd8 ~ U+8bdf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8be0 ~ U+8be7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8be8 ~ U+8bef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8bf0 ~ U+8bf7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8bf8 ~ U+8bff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8c00 ~ U+8c07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8c08 ~ U+8c0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8c10 ~ U+8c17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8c18 ~ U+8c1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8c20 ~ U+8c27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8c28 ~ U+8c2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8c30 ~ U+8c37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8c38 ~ U+8c3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8c40 ~ U+8c47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8c48 ~ U+8c4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8c50 ~ U+8c57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8c58 ~ U+8c5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8c60 ~ U+8c67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8c68 ~ U+8c6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8c70 ~ U+8c77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8c78 ~ U+8c7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8c80 ~ U+8c87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8c88 ~ U+8c8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8c90 ~ U+8c97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8c98 ~ U+8c9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8ca0 ~ U+8ca7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8ca8 ~ U+8caf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8cb0 ~ U+8cb7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8cb8 ~ U+8cbf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8cc0 ~ U+8cc7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8cc8 ~ U+8ccf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8cd0 ~ U+8cd7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8cd8 ~ U+8cdf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8ce0 ~ U+8ce7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8ce8 ~ U+8cef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8cf0 ~ U+8cf7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8cf8 ~ U+8cff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8d00 ~ U+8d07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8d08 ~ U+8d0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8d10 ~ U+8d17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8d18 ~ U+8d1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8d20 ~ U+8d27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8d28 ~ U+8d2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8d30 ~ U+8d37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8d38 ~ U+8d3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8d40 ~ U+8d47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8d48 ~ U+8d4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8d50 ~ U+8d57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8d58 ~ U+8d5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8d60 ~ U+8d67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8d68 ~ U+8d6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8d70 ~ U+8d77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8d78 ~ U+8d7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8d80 ~ U+8d87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8d88 ~ U+8d8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8d90 ~ U+8d97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8d98 ~ U+8d9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8da0 ~ U+8da7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8da8 ~ U+8daf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8db0 ~ U+8db7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8db8 ~ U+8dbf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8dc0 ~ U+8dc7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8dc8 ~ U+8dcf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8dd0 ~ U+8dd7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8dd8 ~ U+8ddf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8de0 ~ U+8de7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8de8 ~ U+8def
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8df0 ~ U+8df7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8df8 ~ U+8dff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8e00 ~ U+8e07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8e08 ~ U+8e0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8e10 ~ U+8e17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8e18 ~ U+8e1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8e20 ~ U+8e27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8e28 ~ U+8e2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8e30 ~ U+8e37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8e38 ~ U+8e3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8e40 ~ U+8e47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8e48 ~ U+8e4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8e50 ~ U+8e57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8e58 ~ U+8e5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8e60 ~ U+8e67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8e68 ~ U+8e6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8e70 ~ U+8e77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8e78 ~ U+8e7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8e80 ~ U+8e87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8e88 ~ U+8e8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8e90 ~ U+8e97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8e98 ~ U+8e9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8ea0 ~ U+8ea7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8ea8 ~ U+8eaf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8eb0 ~ U+8eb7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8eb8 ~ U+8ebf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8ec0 ~ U+8ec7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8ec8 ~ U+8ecf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8ed0 ~ U+8ed7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8ed8 ~ U+8edf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8ee0 ~ U+8ee7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8ee8 ~ U+8eef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8ef0 ~ U+8ef7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8ef8 ~ U+8eff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8f00 ~ U+8f07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8f08 ~ U+8f0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8f10 ~ U+8f17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8f18 ~ U+8f1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8f20 ~ U+8f27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8f28 ~ U+8f2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8f30 ~ U+8f37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8f38 ~ U+8f3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8f40 ~ U+8f47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8f48 ~ U+8f4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8f50 ~ U+8f57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8f58 ~ U+8f5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8f60 ~ U+8f67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8f68 ~ U+8f6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8f70 ~ U+8f77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8f78 ~ U+8f7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8f80 ~ U+8f87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8f88 ~ U+8f8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8f90 ~ U+8f97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8f98 ~ U+8f9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8fa0 ~ U+8fa7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8fa8 ~ U+8faf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8fb0 ~ U+8fb7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8fb8 ~ U+8fbf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8fc0 ~ U+8fc7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8fc8 ~ U+8fcf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8fd0 ~ U+8fd7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8fd8 ~ U+8fdf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8fe0 ~ U+8fe7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8fe8 ~ U+8fef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8ff0 ~ U+8ff7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+8ff8 ~ U+8fff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9000 ~ U+9007
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9008 ~ U+900f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9010 ~ U+9017
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9018 ~ U+901f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9020 ~ U+9027
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9028 ~ U+902f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9030 ~ U+9037
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9038 ~ U+903f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9040 ~ U+9047
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9048 ~ U+904f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9050 ~ U+9057
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9058 ~ U+905f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9060 ~ U+9067
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9068 ~ U+906f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9070 ~ U+9077
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9078 ~ U+907f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9080 ~ U+9087
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9088 ~ U+908f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9090 ~ U+9097
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9098 ~ U+909f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+90a0 ~ U+90a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+90a8 ~ U+90af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+90b0 ~ U+90b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+90b8 ~ U+90bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+90c0 ~ U+90c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+90c8 ~ U+90cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+90d0 ~ U+90d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+90d8 ~ U+90df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+90e0 ~ U+90e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+90e8 ~ U+90ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+90f0 ~ U+90f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+90f8 ~ U+90ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9100 ~ U+9107
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9108 ~ U+910f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9110 ~ U+9117
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9118 ~ U+911f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9120 ~ U+9127
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9128 ~ U+912f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9130 ~ U+9137
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9138 ~ U+913f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9140 ~ U+9147
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9148 ~ U+914f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9150 ~ U+9157
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9158 ~ U+915f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9160 ~ U+9167
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9168 ~ U+916f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9170 ~ U+9177
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9178 ~ U+917f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9180 ~ U+9187
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9188 ~ U+918f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9190 ~ U+9197
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9198 ~ U+919f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+91a0 ~ U+91a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+91a8 ~ U+91af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+91b0 ~ U+91b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+91b8 ~ U+91bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+91c0 ~ U+91c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+91c8 ~ U+91cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+91d0 ~ U+91d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+91d8 ~ U+91df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+91e0 ~ U+91e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+91e8 ~ U+91ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+91f0 ~ U+91f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+91f8 ~ U+91ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9200 ~ U+9207
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9208 ~ U+920f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9210 ~ U+9217
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9218 ~ U+921f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9220 ~ U+9227
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9228 ~ U+922f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9230 ~ U+9237
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9238 ~ U+923f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9240 ~ U+9247
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9248 ~ U+924f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9250 ~ U+9257
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9258 ~ U+925f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9260 ~ U+9267
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9268 ~ U+926f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9270 ~ U+9277
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9278 ~ U+927f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9280 ~ U+9287
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9288 ~ U+928f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9290 ~ U+9297
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9298 ~ U+929f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+92a0 ~ U+92a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+92a8 ~ U+92af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+92b0 ~ U+92b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+92b8 ~ U+92bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+92c0 ~ U+92c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+92c8 ~ U+92cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+92d0 ~ U+92d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+92d8 ~ U+92df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+92e0 ~ U+92e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+92e8 ~ U+92ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+92f0 ~ U+92f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+92f8 ~ U+92ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9300 ~ U+9307
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9308 ~ U+930f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9310 ~ U+9317
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9318 ~ U+931f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9320 ~ U+9327
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9328 ~ U+932f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9330 ~ U+9337
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9338 ~ U+933f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9340 ~ U+9347
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9348 ~ U+934f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9350 ~ U+9357
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9358 ~ U+935f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9360 ~ U+9367
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9368 ~ U+936f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9370 ~ U+9377
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9378 ~ U+937f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9380 ~ U+9387
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9388 ~ U+938f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9390 ~ U+9397
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9398 ~ U+939f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+93a0 ~ U+93a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+93a8 ~ U+93af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+93b0 ~ U+93b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+93b8 ~ U+93bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+93c0 ~ U+93c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+93c8 ~ U+93cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+93d0 ~ U+93d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+93d8 ~ U+93df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+93e0 ~ U+93e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+93e8 ~ U+93ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+93f0 ~ U+93f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+93f8 ~ U+93ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9400 ~ U+9407
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9408 ~ U+940f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9410 ~ U+9417
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9418 ~ U+941f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9420 ~ U+9427
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9428 ~ U+942f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9430 ~ U+9437
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9438 ~ U+943f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9440 ~ U+9447
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9448 ~ U+944f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9450 ~ U+9457
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9458 ~ U+945f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9460 ~ U+9467
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9468 ~ U+946f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9470 ~ U+9477
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9478 ~ U+947f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9480 ~ U+9487
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9488 ~ U+948f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9490 ~ U+9497
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9498 ~ U+949f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+94a0 ~ U+94a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+94a8 ~ U+94af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+94b0 ~ U+94b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+94b8 ~ U+94bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+94c0 ~ U+94c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+94c8 ~ U+94cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+94d0 ~ U+94d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+94d8 ~ U+94df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+94e0 ~ U+94e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+94e8 ~ U+94ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+94f0 ~ U+94f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+94f8 ~ U+94ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9500 ~ U+9507
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9508 ~ U+950f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9510 ~ U+9517
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9518 ~ U+951f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9520 ~ U+9527
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9528 ~ U+952f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9530 ~ U+9537
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9538 ~ U+953f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9540 ~ U+9547
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9548 ~ U+954f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9550 ~ U+9557
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9558 ~ U+955f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9560 ~ U+9567
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9568 ~ U+956f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9570 ~ U+9577
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9578 ~ U+957f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9580 ~ U+9587
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9588 ~ U+958f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9590 ~ U+9597
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9598 ~ U+959f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+95a0 ~ U+95a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+95a8 ~ U+95af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+95b0 ~ U+95b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+95b8 ~ U+95bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+95c0 ~ U+95c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+95c8 ~ U+95cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+95d0 ~ U+95d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+95d8 ~ U+95df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+95e0 ~ U+95e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+95e8 ~ U+95ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+95f0 ~ U+95f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+95f8 ~ U+95ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9600 ~ U+9607
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9608 ~ U+960f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9610 ~ U+9617
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9618 ~ U+961f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9620 ~ U+9627
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9628 ~ U+962f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9630 ~ U+9637
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9638 ~ U+963f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9640 ~ U+9647
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9648 ~ U+964f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9650 ~ U+9657
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9658 ~ U+965f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9660 ~ U+9667
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9668 ~ U+966f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9670 ~ U+9677
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9678 ~ U+967f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9680 ~ U+9687
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9688 ~ U+968f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9690 ~ U+9697
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9698 ~ U+969f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+96a0 ~ U+96a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+96a8 ~ U+96af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+96b0 ~ U+96b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+96b8 ~ U+96bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+96c0 ~ U+96c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+96c8 ~ U+96cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+96d0 ~ U+96d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+96d8 ~ U+96df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+96e0 ~ U+96e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+96e8 ~ U+96ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+96f0 ~ U+96f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+96f8 ~ U+96ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9700 ~ U+9707
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9708 ~ U+970f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9710 ~ U+9717
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9718 ~ U+971f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9720 ~ U+9727
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9728 ~ U+972f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9730 ~ U+9737
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9738 ~ U+973f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9740 ~ U+9747
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9748 ~ U+974f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9750 ~ U+9757
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9758 ~ U+975f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9760 ~ U+9767
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9768 ~ U+976f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9770 ~ U+9777
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9778 ~ U+977f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9780 ~ U+9787
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9788 ~ U+978f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9790 ~ U+9797
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9798 ~ U+979f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+97a0 ~ U+97a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+97a8 ~ U+97af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+97b0 ~ U+97b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+97b8 ~ U+97bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+97c0 ~ U+97c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+97c8 ~ U+97cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+97d0 ~ U+97d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+97d8 ~ U+97df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+97e0 ~ U+97e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+97e8 ~ U+97ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+97f0 ~ U+97f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+97f8 ~ U+97ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9800 ~ U+9807
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9808 ~ U+980f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9810 ~ U+9817
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9818 ~ U+981f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9820 ~ U+9827
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9828 ~ U+982f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9830 ~ U+9837
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9838 ~ U+983f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9840 ~ U+9847
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9848 ~ U+984f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9850 ~ U+9857
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9858 ~ U+985f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9860 ~ U+9867
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9868 ~ U+986f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9870 ~ U+9877
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9878 ~ U+987f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9880 ~ U+9887
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9888 ~ U+988f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9890 ~ U+9897
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9898 ~ U+989f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+98a0 ~ U+98a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+98a8 ~ U+98af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+98b0 ~ U+98b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+98b8 ~ U+98bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+98c0 ~ U+98c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+98c8 ~ U+98cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+98d0 ~ U+98d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+98d8 ~ U+98df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+98e0 ~ U+98e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+98e8 ~ U+98ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+98f0 ~ U+98f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+98f8 ~ U+98ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9900 ~ U+9907
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9908 ~ U+990f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9910 ~ U+9917
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9918 ~ U+991f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9920 ~ U+9927
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9928 ~ U+992f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9930 ~ U+9937
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9938 ~ U+993f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9940 ~ U+9947
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9948 ~ U+994f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9950 ~ U+9957
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9958 ~ U+995f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9960 ~ U+9967
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9968 ~ U+996f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9970 ~ U+9977
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9978 ~ U+997f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9980 ~ U+9987
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9988 ~ U+998f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9990 ~ U+9997
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9998 ~ U+999f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+99a0 ~ U+99a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+99a8 ~ U+99af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+99b0 ~ U+99b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+99b8 ~ U+99bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+99c0 ~ U+99c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+99c8 ~ U+99cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+99d0 ~ U+99d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+99d8 ~ U+99df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+99e0 ~ U+99e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+99e8 ~ U+99ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+99f0 ~ U+99f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+99f8 ~ U+99ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9a00 ~ U+9a07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9a08 ~ U+9a0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9a10 ~ U+9a17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9a18 ~ U+9a1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9a20 ~ U+9a27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9a28 ~ U+9a2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9a30 ~ U+9a37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9a38 ~ U+9a3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9a40 ~ U+9a47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9a48 ~ U+9a4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9a50 ~ U+9a57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9a58 ~ U+9a5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9a60 ~ U+9a67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9a68 ~ U+9a6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9a70 ~ U+9a77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9a78 ~ U+9a7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9a80 ~ U+9a87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9a88 ~ U+9a8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9a90 ~ U+9a97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9a98 ~ U+9a9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9aa0 ~ U+9aa7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9aa8 ~ U+9aaf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9ab0 ~ U+9ab7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9ab8 ~ U+9abf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9ac0 ~ U+9ac7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9ac8 ~ U+9acf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9ad0 ~ U+9ad7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9ad8 ~ U+9adf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9ae0 ~ U+9ae7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9ae8 ~ U+9aef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9af0 ~ U+9af7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9af8 ~ U+9aff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9b00 ~ U+9b07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9b08 ~ U+9b0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9b10 ~ U+9b17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9b18 ~ U+9b1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9b20 ~ U+9b27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9b28 ~ U+9b2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9b30 ~ U+9b37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9b38 ~ U+9b3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9b40 ~ U+9b47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9b48 ~ U+9b4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9b50 ~ U+9b57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9b58 ~ U+9b5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9b60 ~ U+9b67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9b68 ~ U+9b6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9b70 ~ U+9b77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9b78 ~ U+9b7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9b80 ~ U+9b87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9b88 ~ U+9b8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9b90 ~ U+9b97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9b98 ~ U+9b9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9ba0 ~ U+9ba7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9ba8 ~ U+9baf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9bb0 ~ U+9bb7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9bb8 ~ U+9bbf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9bc0 ~ U+9bc7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9bc8 ~ U+9bcf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9bd0 ~ U+9bd7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9bd8 ~ U+9bdf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9be0 ~ U+9be7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9be8 ~ U+9bef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9bf0 ~ U+9bf7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9bf8 ~ U+9bff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9c00 ~ U+9c07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9c08 ~ U+9c0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9c10 ~ U+9c17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9c18 ~ U+9c1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9c20 ~ U+9c27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9c28 ~ U+9c2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9c30 ~ U+9c37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9c38 ~ U+9c3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9c40 ~ U+9c47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9c48 ~ U+9c4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9c50 ~ U+9c57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9c58 ~ U+9c5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9c60 ~ U+9c67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9c68 ~ U+9c6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9c70 ~ U+9c77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9c78 ~ U+9c7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9c80 ~ U+9c87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9c88 ~ U+9c8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9c90 ~ U+9c97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9c98 ~ U+9c9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9ca0 ~ U+9ca7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9ca8 ~ U+9caf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9cb0 ~ U+9cb7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9cb8 ~ U+9cbf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9cc0 ~ U+9cc7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9cc8 ~ U+9ccf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9cd0 ~ U+9cd7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9cd8 ~ U+9cdf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9ce0 ~ U+9ce7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9ce8 ~ U+9cef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9cf0 ~ U+9cf7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9cf8 ~ U+9cff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9d00 ~ U+9d07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9d08 ~ U+9d0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9d10 ~ U+9d17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9d18 ~ U+9d1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9d20 ~ U+9d27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9d28 ~ U+9d2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9d30 ~ U+9d37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9d38 ~ U+9d3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9d40 ~ U+9d47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9d48 ~ U+9d4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9d50 ~ U+9d57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9d58 ~ U+9d5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9d60 ~ U+9d67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9d68 ~ U+9d6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9d70 ~ U+9d77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9d78 ~ U+9d7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9d80 ~ U+9d87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9d88 ~ U+9d8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9d90 ~ U+9d97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9d98 ~ U+9d9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9da0 ~ U+9da7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9da8 ~ U+9daf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9db0 ~ U+9db7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9db8 ~ U+9dbf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9dc0 ~ U+9dc7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9dc8 ~ U+9dcf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9dd0 ~ U+9dd7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9dd8 ~ U+9ddf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9de0 ~ U+9de7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9de8 ~ U+9def
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9df0 ~ U+9df7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9df8 ~ U+9dff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9e00 ~ U+9e07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9e08 ~ U+9e0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9e10 ~ U+9e17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9e18 ~ U+9e1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9e20 ~ U+9e27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9e28 ~ U+9e2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9e30 ~ U+9e37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9e38 ~ U+9e3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9e40 ~ U+9e47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9e48 ~ U+9e4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9e50 ~ U+9e57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9e58 ~ U+9e5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9e60 ~ U+9e67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9e68 ~ U+9e6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9e70 ~ U+9e77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9e78 ~ U+9e7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9e80 ~ U+9e87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9e88 ~ U+9e8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9e90 ~ U+9e97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9e98 ~ U+9e9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9ea0 ~ U+9ea7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9ea8 ~ U+9eaf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9eb0 ~ U+9eb7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9eb8 ~ U+9ebf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9ec0 ~ U+9ec7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9ec8 ~ U+9ecf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9ed0 ~ U+9ed7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9ed8 ~ U+9edf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9ee0 ~ U+9ee7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9ee8 ~ U+9eef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9ef0 ~ U+9ef7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9ef8 ~ U+9eff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9f00 ~ U+9f07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9f08 ~ U+9f0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9f10 ~ U+9f17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9f18 ~ U+9f1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9f20 ~ U+9f27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9f28 ~ U+9f2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9f30 ~ U+9f37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9f38 ~ U+9f3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9f40 ~ U+9f47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9f48 ~ U+9f4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9f50 ~ U+9f57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9f58 ~ U+9f5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9f60 ~ U+9f67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9f68 ~ U+9f6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9f70 ~ U+9f77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9f78 ~ U+9f7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9f80 ~ U+9f87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9f88 ~ U+9f8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9f90 ~ U+9f97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+9f98 ~ U+9f9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x4a63, 0x4a64,   // U+9fa0 ~ U+9fa7
0x4a65, 0x4a66, 0x4a67, 0x4a68, 0x4a69, 0x4a6a, 0x4a6b, 0x4a6c,   // U+9fa8 ~ U+9faf
0x4a6d, 0x4a6e, 0x4a6f, 0x4a70, 0x4a71, 0x4a72, 0x4a73, 0x4a74,   // U+9fb0 ~ U+9fb7
0x4a75, 0x4a76, 0x4a77, 0x4a78, 0x4a79, 0x4a7a, 0x4a7b, 0x4a7c,   // U+9fb8 ~ U+9fbf
0x4a7d, 0x4a7e, 0x4a7f, 0x4a80, 0x4a81, 0x4a82, 0x4a83, 0x4a84,   // U+9fc0 ~ U+9fc7
0x4a85, 0x4a86, 0x4a87, 0x4a88, 0x4a89, 0x4a8a, 0x4a8b, 0x4a8c,   // U+9fc8 ~ U+9fcf
0x4a8d, 0x4a8e, 0x4a8f, 0x4a90, 0x4a91, 0x4a92, 0x4a93, 0x4a94,   // U+9fd0 ~ U+9fd7
0x4a95, 0x4a96, 0x4a97, 0x4a98, 0x4a99, 0x4a9a, 0x4a9b, 0x4a9c,   // U+9fd8 ~ U+9fdf
0x4a9d, 0x4a9e, 0x4a9f, 0x4aa0, 0x4aa1, 0x4aa2, 0x4aa3, 0x4aa4,   // U+9fe0 ~ U+9fe7
0x4aa5, 0x4aa6, 0x4aa7, 0x4aa8, 0x4aa9, 0x4aaa, 0x4aab, 0x4aac,   // U+9fe8 ~ U+9fef
0x4aad, 0x4aae, 0x4aaf, 0x4ab0, 0x4ab1, 0x4ab2, 0x4ab3, 0x4ab4,   // U+9ff0 ~ U+9ff7
0x4ab5, 0x4ab6, 0x4ab7, 0x4ab8, 0x4ab9, 0x4aba, 0x4abb, 0x4abc,   // U+9ff8 ~ U+9fff
0x4abd, 0x4abe, 0x4abf, 0x4ac0, 0x4ac1, 0x4ac2, 0x4ac3, 0x4ac4,   // U+a000 ~ U+a007
0x4ac5, 0x4ac6, 0x4ac7, 0x4ac8, 0x4ac9, 0x4aca, 0x4acb, 0x4acc,   // U+a008 ~ U+a00f
0x4acd, 0x4ace, 0x4acf, 0x4ad0, 0x4ad1, 0x4ad2, 0x4ad3, 0x4ad4,   // U+a010 ~ U+a017
0x4ad5, 0x4ad6, 0x4ad7, 0x4ad8, 0x4ad9, 0x4ada, 0x4adb, 0x4adc,   // U+a018 ~ U+a01f
0x4add, 0x4ade, 0x4adf, 0x4ae0, 0x4ae1, 0x4ae2, 0x4ae3, 0x4ae4,   // U+a020 ~ U+a027
0x4ae5, 0x4ae6, 0x4ae7, 0x4ae8, 0x4ae9, 0x4aea, 0x4aeb, 0x4aec,   // U+a028 ~ U+a02f
0x4aed, 0x4aee, 0x4aef, 0x4af0, 0x4af1, 0x4af2, 0x4af3, 0x4af4,   // U+a030 ~ U+a037
0x4af5, 0x4af6, 0x4af7, 0x4af8, 0x4af9, 0x4afa, 0x4afb, 0x4afc,   // U+a038 ~ U+a03f
0x4afd, 0x4afe, 0x4aff, 0x4b00, 0x4b01, 0x4b02, 0x4b03, 0x4b04,   // U+a040 ~ U+a047
0x4b05, 0x4b06, 0x4b07, 0x4b08, 0x4b09, 0x4b0a, 0x4b0b, 0x4b0c,   // U+a048 ~ U+a04f
0x4b0d, 0x4b0e, 0x4b0f, 0x4b10, 0x4b11, 0x4b12, 0x4b13, 0x4b14,   // U+a050 ~ U+a057
0x4b15, 0x4b16, 0x4b17, 0x4b18, 0x4b19, 0x4b1a, 0x4b1b, 0x4b1c,   // U+a058 ~ U+a05f
0x4b1d, 0x4b1e, 0x4b1f, 0x4b20, 0x4b21, 0x4b22, 0x4b23, 0x4b24,   // U+a060 ~ U+a067
0x4b25, 0x4b26, 0x4b27, 0x4b28, 0x4b29, 0x4b2a, 0x4b2b, 0x4b2c,   // U+a068 ~ U+a06f
0x4b2d, 0x4b2e, 0x4b2f, 0x4b30, 0x4b31, 0x4b32, 0x4b33, 0x4b34,   // U+a070 ~ U+a077
0x4b35, 0x4b36, 0x4b37, 0x4b38, 0x4b39, 0x4b3a, 0x4b3b, 0x4b3c,   // U+a078 ~ U+a07f
0x4b3d, 0x4b3e, 0x4b3f, 0x4b40, 0x4b41, 0x4b42, 0x4b43, 0x4b44,   // U+a080 ~ U+a087
0x4b45, 0x4b46, 0x4b47, 0x4b48, 0x4b49, 0x4b4a, 0x4b4b, 0x4b4c,   // U+a088 ~ U+a08f
0x4b4d, 0x4b4e, 0x4b4f, 0x4b50, 0x4b51, 0x4b52, 0x4b53, 0x4b54,   // U+a090 ~ U+a097
0x4b55, 0x4b56, 0x4b57, 0x4b58, 0x4b59, 0x4b5a, 0x4b5b, 0x4b5c,   // U+a098 ~ U+a09f
0x4b5d, 0x4b5e, 0x4b5f, 0x4b60, 0x4b61, 0x4b62, 0x4b63, 0x4b64,   // U+a0a0 ~ U+a0a7
0x4b65, 0x4b66, 0x4b67, 0x4b68, 0x4b69, 0x4b6a, 0x4b6b, 0x4b6c,   // U+a0a8 ~ U+a0af
0x4b6d, 0x4b6e, 0x4b6f, 0x4b70, 0x4b71, 0x4b72, 0x4b73, 0x4b74,   // U+a0b0 ~ U+a0b7
0x4b75, 0x4b76, 0x4b77, 0x4b78, 0x4b79, 0x4b7a, 0x4b7b, 0x4b7c,   // U+a0b8 ~ U+a0bf
0x4b7d, 0x4b7e, 0x4b7f, 0x4b80, 0x4b81, 0x4b82, 0x4b83, 0x4b84,   // U+a0c0 ~ U+a0c7
0x4b85, 0x4b86, 0x4b87, 0x4b88, 0x4b89, 0x4b8a, 0x4b8b, 0x4b8c,   // U+a0c8 ~ U+a0cf
0x4b8d, 0x4b8e, 0x4b8f, 0x4b90, 0x4b91, 0x4b92, 0x4b93, 0x4b94,   // U+a0d0 ~ U+a0d7
0x4b95, 0x4b96, 0x4b97, 0x4b98, 0x4b99, 0x4b9a, 0x4b9b, 0x4b9c,   // U+a0d8 ~ U+a0df
0x4b9d, 0x4b9e, 0x4b9f, 0x4ba0, 0x4ba1, 0x4ba2, 0x4ba3, 0x4ba4,   // U+a0e0 ~ U+a0e7
0x4ba5, 0x4ba6, 0x4ba7, 0x4ba8, 0x4ba9, 0x4baa, 0x4bab, 0x4bac,   // U+a0e8 ~ U+a0ef
0x4bad, 0x4bae, 0x4baf, 0x4bb0, 0x4bb1, 0x4bb2, 0x4bb3, 0x4bb4,   // U+a0f0 ~ U+a0f7
0x4bb5, 0x4bb6, 0x4bb7, 0x4bb8, 0x4bb9, 0x4bba, 0x4bbb, 0x4bbc,   // U+a0f8 ~ U+a0ff
0x4bbd, 0x4bbe, 0x4bbf, 0x4bc0, 0x4bc1, 0x4bc2, 0x4bc3, 0x4bc4,   // U+a100 ~ U+a107
0x4bc5, 0x4bc6, 0x4bc7, 0x4bc8, 0x4bc9, 0x4bca, 0x4bcb, 0x4bcc,   // U+a108 ~ U+a10f
0x4bcd, 0x4bce, 0x4bcf, 0x4bd0, 0x4bd1, 0x4bd2, 0x4bd3, 0x4bd4,   // U+a110 ~ U+a117
0x4bd5, 0x4bd6, 0x4bd7, 0x4bd8, 0x4bd9, 0x4bda, 0x4bdb, 0x4bdc,   // U+a118 ~ U+a11f
0x4bdd, 0x4bde, 0x4bdf, 0x4be0, 0x4be1, 0x4be2, 0x4be3, 0x4be4,   // U+a120 ~ U+a127
0x4be5, 0x4be6, 0x4be7, 0x4be8, 0x4be9, 0x4bea, 0x4beb, 0x4bec,   // U+a128 ~ U+a12f
0x4bed, 0x4bee, 0x4bef, 0x4bf0, 0x4bf1, 0x4bf2, 0x4bf3, 0x4bf4,   // U+a130 ~ U+a137
0x4bf5, 0x4bf6, 0x4bf7, 0x4bf8, 0x4bf9, 0x4bfa, 0x4bfb, 0x4bfc,   // U+a138 ~ U+a13f
0x4bfd, 0x4bfe, 0x4bff, 0x4c00, 0x4c01, 0x4c02, 0x4c03, 0x4c04,   // U+a140 ~ U+a147
0x4c05, 0x4c06, 0x4c07, 0x4c08, 0x4c09, 0x4c0a, 0x4c0b, 0x4c0c,   // U+a148 ~ U+a14f
0x4c0d, 0x4c0e, 0x4c0f, 0x4c10, 0x4c11, 0x4c12, 0x4c13, 0x4c14,   // U+a150 ~ U+a157
0x4c15, 0x4c16, 0x4c17, 0x4c18, 0x4c19, 0x4c1a, 0x4c1b, 0x4c1c,   // U+a158 ~ U+a15f
0x4c1d, 0x4c1e, 0x4c1f, 0x4c20, 0x4c21, 0x4c22, 0x4c23, 0x4c24,   // U+a160 ~ U+a167
0x4c25, 0x4c26, 0x4c27, 0x4c28, 0x4c29, 0x4c2a, 0x4c2b, 0x4c2c,   // U+a168 ~ U+a16f
0x4c2d, 0x4c2e, 0x4c2f, 0x4c30, 0x4c31, 0x4c32, 0x4c33, 0x4c34,   // U+a170 ~ U+a177
0x4c35, 0x4c36, 0x4c37, 0x4c38, 0x4c39, 0x4c3a, 0x4c3b, 0x4c3c,   // U+a178 ~ U+a17f
0x4c3d, 0x4c3e, 0x4c3f, 0x4c40, 0x4c41, 0x4c42, 0x4c43, 0x4c44,   // U+a180 ~ U+a187
0x4c45, 0x4c46, 0x4c47, 0x4c48, 0x4c49, 0x4c4a, 0x4c4b, 0x4c4c,   // U+a188 ~ U+a18f
0x4c4d, 0x4c4e, 0x4c4f, 0x4c50, 0x4c51, 0x4c52, 0x4c53, 0x4c54,   // U+a190 ~ U+a197
0x4c55, 0x4c56, 0x4c57, 0x4c58, 0x4c59, 0x4c5a, 0x4c5b, 0x4c5c,   // U+a198 ~ U+a19f
0x4c5d, 0x4c5e, 0x4c5f, 0x4c60, 0x4c61, 0x4c62, 0x4c63, 0x4c64,   // U+a1a0 ~ U+a1a7
0x4c65, 0x4c66, 0x4c67, 0x4c68, 0x4c69, 0x4c6a, 0x4c6b, 0x4c6c,   // U+a1a8 ~ U+a1af
0x4c6d, 0x4c6e, 0x4c6f, 0x4c70, 0x4c71, 0x4c72, 0x4c73, 0x4c74,   // U+a1b0 ~ U+a1b7
0x4c75, 0x4c76, 0x4c77, 0x4c78, 0x4c79, 0x4c7a, 0x4c7b, 0x4c7c,   // U+a1b8 ~ U+a1bf
0x4c7d, 0x4c7e, 0x4c7f, 0x4c80, 0x4c81, 0x4c82, 0x4c83, 0x4c84,   // U+a1c0 ~ U+a1c7
0x4c85, 0x4c86, 0x4c87, 0x4c88, 0x4c89, 0x4c8a, 0x4c8b, 0x4c8c,   // U+a1c8 ~ U+a1cf
0x4c8d, 0x4c8e, 0x4c8f, 0x4c90, 0x4c91, 0x4c92, 0x4c93, 0x4c94,   // U+a1d0 ~ U+a1d7
0x4c95, 0x4c96, 0x4c97, 0x4c98, 0x4c99, 0x4c9a, 0x4c9b, 0x4c9c,   // U+a1d8 ~ U+a1df
0x4c9d, 0x4c9e, 0x4c9f, 0x4ca0, 0x4ca1, 0x4ca2, 0x4ca3, 0x4ca4,   // U+a1e0 ~ U+a1e7
0x4ca5, 0x4ca6, 0x4ca7, 0x4ca8, 0x4ca9, 0x4caa, 0x4cab, 0x4cac,   // U+a1e8 ~ U+a1ef
0x4cad, 0x4cae, 0x4caf, 0x4cb0, 0x4cb1, 0x4cb2, 0x4cb3, 0x4cb4,   // U+a1f0 ~ U+a1f7
0x4cb5, 0x4cb6, 0x4cb7, 0x4cb8, 0x4cb9, 0x4cba, 0x4cbb, 0x4cbc,   // U+a1f8 ~ U+a1ff
0x4cbd, 0x4cbe, 0x4cbf, 0x4cc0, 0x4cc1, 0x4cc2, 0x4cc3, 0x4cc4,   // U+a200 ~ U+a207
0x4cc5, 0x4cc6, 0x4cc7, 0x4cc8, 0x4cc9, 0x4cca, 0x4ccb, 0x4ccc,   // U+a208 ~ U+a20f
0x4ccd, 0x4cce, 0x4ccf, 0x4cd0, 0x4cd1, 0x4cd2, 0x4cd3, 0x4cd4,   // U+a210 ~ U+a217
0x4cd5, 0x4cd6, 0x4cd7, 0x4cd8, 0x4cd9, 0x4cda, 0x4cdb, 0x4cdc,   // U+a218 ~ U+a21f
0x4cdd, 0x4cde, 0x4cdf, 0x4ce0, 0x4ce1, 0x4ce2, 0x4ce3, 0x4ce4,   // U+a220 ~ U+a227
0x4ce5, 0x4ce6, 0x4ce7, 0x4ce8, 0x4ce9, 0x4cea, 0x4ceb, 0x4cec,   // U+a228 ~ U+a22f
0x4ced, 0x4cee, 0x4cef, 0x4cf0, 0x4cf1, 0x4cf2, 0x4cf3, 0x4cf4,   // U+a230 ~ U+a237
0x4cf5, 0x4cf6, 0x4cf7, 0x4cf8, 0x4cf9, 0x4cfa, 0x4cfb, 0x4cfc,   // U+a238 ~ U+a23f
0x4cfd, 0x4cfe, 0x4cff, 0x4d00, 0x4d01, 0x4d02, 0x4d03, 0x4d04,   // U+a240 ~ U+a247
0x4d05, 0x4d06, 0x4d07, 0x4d08, 0x4d09, 0x4d0a, 0x4d0b, 0x4d0c,   // U+a248 ~ U+a24f
0x4d0d, 0x4d0e, 0x4d0f, 0x4d10, 0x4d11, 0x4d12, 0x4d13, 0x4d14,   // U+a250 ~ U+a257
0x4d15, 0x4d16, 0x4d17, 0x4d18, 0x4d19, 0x4d1a, 0x4d1b, 0x4d1c,   // U+a258 ~ U+a25f
0x4d1d, 0x4d1e, 0x4d1f, 0x4d20, 0x4d21, 0x4d22, 0x4d23, 0x4d24,   // U+a260 ~ U+a267
0x4d25, 0x4d26, 0x4d27, 0x4d28, 0x4d29, 0x4d2a, 0x4d2b, 0x4d2c,   // U+a268 ~ U+a26f
0x4d2d, 0x4d2e, 0x4d2f, 0x4d30, 0x4d31, 0x4d32, 0x4d33, 0x4d34,   // U+a270 ~ U+a277
0x4d35, 0x4d36, 0x4d37, 0x4d38, 0x4d39, 0x4d3a, 0x4d3b, 0x4d3c,   // U+a278 ~ U+a27f
0x4d3d, 0x4d3e, 0x4d3f, 0x4d40, 0x4d41, 0x4d42, 0x4d43, 0x4d44,   // U+a280 ~ U+a287
0x4d45, 0x4d46, 0x4d47, 0x4d48, 0x4d49, 0x4d4a, 0x4d4b, 0x4d4c,   // U+a288 ~ U+a28f
0x4d4d, 0x4d4e, 0x4d4f, 0x4d50, 0x4d51, 0x4d52, 0x4d53, 0x4d54,   // U+a290 ~ U+a297
0x4d55, 0x4d56, 0x4d57, 0x4d58, 0x4d59, 0x4d5a, 0x4d5b, 0x4d5c,   // U+a298 ~ U+a29f
0x4d5d, 0x4d5e, 0x4d5f, 0x4d60, 0x4d61, 0x4d62, 0x4d63, 0x4d64,   // U+a2a0 ~ U+a2a7
0x4d65, 0x4d66, 0x4d67, 0x4d68, 0x4d69, 0x4d6a, 0x4d6b, 0x4d6c,   // U+a2a8 ~ U+a2af
0x4d6d, 0x4d6e, 0x4d6f, 0x4d70, 0x4d71, 0x4d72, 0x4d73, 0x4d74,   // U+a2b0 ~ U+a2b7
0x4d75, 0x4d76, 0x4d77, 0x4d78, 0x4d79, 0x4d7a, 0x4d7b, 0x4d7c,   // U+a2b8 ~ U+a2bf
0x4d7d, 0x4d7e, 0x4d7f, 0x4d80, 0x4d81, 0x4d82, 0x4d83, 0x4d84,   // U+a2c0 ~ U+a2c7
0x4d85, 0x4d86, 0x4d87, 0x4d88, 0x4d89, 0x4d8a, 0x4d8b, 0x4d8c,   // U+a2c8 ~ U+a2cf
0x4d8d, 0x4d8e, 0x4d8f, 0x4d90, 0x4d91, 0x4d92, 0x4d93, 0x4d94,   // U+a2d0 ~ U+a2d7
0x4d95, 0x4d96, 0x4d97, 0x4d98, 0x4d99, 0x4d9a, 0x4d9b, 0x4d9c,   // U+a2d8 ~ U+a2df
0x4d9d, 0x4d9e, 0x4d9f, 0x4da0, 0x4da1, 0x4da2, 0x4da3, 0x4da4,   // U+a2e0 ~ U+a2e7
0x4da5, 0x4da6, 0x4da7, 0x4da8, 0x4da9, 0x4daa, 0x4dab, 0x4dac,   // U+a2e8 ~ U+a2ef
0x4dad, 0x4dae, 0x4daf, 0x4db0, 0x4db1, 0x4db2, 0x4db3, 0x4db4,   // U+a2f0 ~ U+a2f7
0x4db5, 0x4db6, 0x4db7, 0x4db8, 0x4db9, 0x4dba, 0x4dbb, 0x4dbc,   // U+a2f8 ~ U+a2ff
0x4dbd, 0x4dbe, 0x4dbf, 0x4dc0, 0x4dc1, 0x4dc2, 0x4dc3, 0x4dc4,   // U+a300 ~ U+a307
0x4dc5, 0x4dc6, 0x4dc7, 0x4dc8, 0x4dc9, 0x4dca, 0x4dcb, 0x4dcc,   // U+a308 ~ U+a30f
0x4dcd, 0x4dce, 0x4dcf, 0x4dd0, 0x4dd1, 0x4dd2, 0x4dd3, 0x4dd4,   // U+a310 ~ U+a317
0x4dd5, 0x4dd6, 0x4dd7, 0x4dd8, 0x4dd9, 0x4dda, 0x4ddb, 0x4ddc,   // U+a318 ~ U+a31f
0x4ddd, 0x4dde, 0x4ddf, 0x4de0, 0x4de1, 0x4de2, 0x4de3, 0x4de4,   // U+a320 ~ U+a327
0x4de5, 0x4de6, 0x4de7, 0x4de8, 0x4de9, 0x4dea, 0x4deb, 0x4dec,   // U+a328 ~ U+a32f
0x4ded, 0x4dee, 0x4def, 0x4df0, 0x4df1, 0x4df2, 0x4df3, 0x4df4,   // U+a330 ~ U+a337
0x4df5, 0x4df6, 0x4df7, 0x4df8, 0x4df9, 0x4dfa, 0x4dfb, 0x4dfc,   // U+a338 ~ U+a33f
0x4dfd, 0x4dfe, 0x4dff, 0x4e00, 0x4e01, 0x4e02, 0x4e03, 0x4e04,   // U+a340 ~ U+a347
0x4e05, 0x4e06, 0x4e07, 0x4e08, 0x4e09, 0x4e0a, 0x4e0b, 0x4e0c,   // U+a348 ~ U+a34f
0x4e0d, 0x4e0e, 0x4e0f, 0x4e10, 0x4e11, 0x4e12, 0x4e13, 0x4e14,   // U+a350 ~ U+a357
0x4e15, 0x4e16, 0x4e17, 0x4e18, 0x4e19, 0x4e1a, 0x4e1b, 0x4e1c,   // U+a358 ~ U+a35f
0x4e1d, 0x4e1e, 0x4e1f, 0x4e20, 0x4e21, 0x4e22, 0x4e23, 0x4e24,   // U+a360 ~ U+a367
0x4e25, 0x4e26, 0x4e27, 0x4e28, 0x4e29, 0x4e2a, 0x4e2b, 0x4e2c,   // U+a368 ~ U+a36f
0x4e2d, 0x4e2e, 0x4e2f, 0x4e30, 0x4e31, 0x4e32, 0x4e33, 0x4e34,   // U+a370 ~ U+a377
0x4e35, 0x4e36, 0x4e37, 0x4e38, 0x4e39, 0x4e3a, 0x4e3b, 0x4e3c,   // U+a378 ~ U+a37f
0x4e3d, 0x4e3e, 0x4e3f, 0x4e40, 0x4e41, 0x4e42, 0x4e43, 0x4e44,   // U+a380 ~ U+a387
0x4e45, 0x4e46, 0x4e47, 0x4e48, 0x4e49, 0x4e4a, 0x4e4b, 0x4e4c,   // U+a388 ~ U+a38f
0x4e4d, 0x4e4e, 0x4e4f, 0x4e50, 0x4e51, 0x4e52, 0x4e53, 0x4e54,   // U+a390 ~ U+a397
0x4e55, 0x4e56, 0x4e57, 0x4e58, 0x4e59, 0x4e5a, 0x4e5b, 0x4e5c,   // U+a398 ~ U+a39f
0x4e5d, 0x4e5e, 0x4e5f, 0x4e60, 0x4e61, 0x4e62, 0x4e63, 0x4e64,   // U+a3a0 ~ U+a3a7
0x4e65, 0x4e66, 0x4e67, 0x4e68, 0x4e69, 0x4e6a, 0x4e6b, 0x4e6c,   // U+a3a8 ~ U+a3af
0x4e6d, 0x4e6e, 0x4e6f, 0x4e70, 0x4e71, 0x4e72, 0x4e73, 0x4e74,   // U+a3b0 ~ U+a3b7
0x4e75, 0x4e76, 0x4e77, 0x4e78, 0x4e79, 0x4e7a, 0x4e7b, 0x4e7c,   // U+a3b8 ~ U+a3bf
0x4e7d, 0x4e7e, 0x4e7f, 0x4e80, 0x4e81, 0x4e82, 0x4e83, 0x4e84,   // U+a3c0 ~ U+a3c7
0x4e85, 0x4e86, 0x4e87, 0x4e88, 0x4e89, 0x4e8a, 0x4e8b, 0x4e8c,   // U+a3c8 ~ U+a3cf
0x4e8d, 0x4e8e, 0x4e8f, 0x4e90, 0x4e91, 0x4e92, 0x4e93, 0x4e94,   // U+a3d0 ~ U+a3d7
0x4e95, 0x4e96, 0x4e97, 0x4e98, 0x4e99, 0x4e9a, 0x4e9b, 0x4e9c,   // U+a3d8 ~ U+a3df
0x4e9d, 0x4e9e, 0x4e9f, 0x4ea0, 0x4ea1, 0x4ea2, 0x4ea3, 0x4ea4,   // U+a3e0 ~ U+a3e7
0x4ea5, 0x4ea6, 0x4ea7, 0x4ea8, 0x4ea9, 0x4eaa, 0x4eab, 0x4eac,   // U+a3e8 ~ U+a3ef
0x4ead, 0x4eae, 0x4eaf, 0x4eb0, 0x4eb1, 0x4eb2, 0x4eb3, 0x4eb4,   // U+a3f0 ~ U+a3f7
0x4eb5, 0x4eb6, 0x4eb7, 0x4eb8, 0x4eb9, 0x4eba, 0x4ebb, 0x4ebc,   // U+a3f8 ~ U+a3ff
0x4ebd, 0x4ebe, 0x4ebf, 0x4ec0, 0x4ec1, 0x4ec2, 0x4ec3, 0x4ec4,   // U+a400 ~ U+a407
0x4ec5, 0x4ec6, 0x4ec7, 0x4ec8, 0x4ec9, 0x4eca, 0x4ecb, 0x4ecc,   // U+a408 ~ U+a40f
0x4ecd, 0x4ece, 0x4ecf, 0x4ed0, 0x4ed1, 0x4ed2, 0x4ed3, 0x4ed4,   // U+a410 ~ U+a417
0x4ed5, 0x4ed6, 0x4ed7, 0x4ed8, 0x4ed9, 0x4eda, 0x4edb, 0x4edc,   // U+a418 ~ U+a41f
0x4edd, 0x4ede, 0x4edf, 0x4ee0, 0x4ee1, 0x4ee2, 0x4ee3, 0x4ee4,   // U+a420 ~ U+a427
0x4ee5, 0x4ee6, 0x4ee7, 0x4ee8, 0x4ee9, 0x4eea, 0x4eeb, 0x4eec,   // U+a428 ~ U+a42f
0x4eed, 0x4eee, 0x4eef, 0x4ef0, 0x4ef1, 0x4ef2, 0x4ef3, 0x4ef4,   // U+a430 ~ U+a437
0x4ef5, 0x4ef6, 0x4ef7, 0x4ef8, 0x4ef9, 0x4efa, 0x4efb, 0x4efc,   // U+a438 ~ U+a43f
0x4efd, 0x4efe, 0x4eff, 0x4f00, 0x4f01, 0x4f02, 0x4f03, 0x4f04,   // U+a440 ~ U+a447
0x4f05, 0x4f06, 0x4f07, 0x4f08, 0x4f09, 0x4f0a, 0x4f0b, 0x4f0c,   // U+a448 ~ U+a44f
0x4f0d, 0x4f0e, 0x4f0f, 0x4f10, 0x4f11, 0x4f12, 0x4f13, 0x4f14,   // U+a450 ~ U+a457
0x4f15, 0x4f16, 0x4f17, 0x4f18, 0x4f19, 0x4f1a, 0x4f1b, 0x4f1c,   // U+a458 ~ U+a45f
0x4f1d, 0x4f1e, 0x4f1f, 0x4f20, 0x4f21, 0x4f22, 0x4f23, 0x4f24,   // U+a460 ~ U+a467
0x4f25, 0x4f26, 0x4f27, 0x4f28, 0x4f29, 0x4f2a, 0x4f2b, 0x4f2c,   // U+a468 ~ U+a46f
0x4f2d, 0x4f2e, 0x4f2f, 0x4f30, 0x4f31, 0x4f32, 0x4f33, 0x4f34,   // U+a470 ~ U+a477
0x4f35, 0x4f36, 0x4f37, 0x4f38, 0x4f39, 0x4f3a, 0x4f3b, 0x4f3c,   // U+a478 ~ U+a47f
0x4f3d, 0x4f3e, 0x4f3f, 0x4f40, 0x4f41, 0x4f42, 0x4f43, 0x4f44,   // U+a480 ~ U+a487
0x4f45, 0x4f46, 0x4f47, 0x4f48, 0x4f49, 0x4f4a, 0x4f4b, 0x4f4c,   // U+a488 ~ U+a48f
0x4f4d, 0x4f4e, 0x4f4f, 0x4f50, 0x4f51, 0x4f52, 0x4f53, 0x4f54,   // U+a490 ~ U+a497
0x4f55, 0x4f56, 0x4f57, 0x4f58, 0x4f59, 0x4f5a, 0x4f5b, 0x4f5c,   // U+a498 ~ U+a49f
0x4f5d, 0x4f5e, 0x4f5f, 0x4f60, 0x4f61, 0x4f62, 0x4f63, 0x4f64,   // U+a4a0 ~ U+a4a7
0x4f65, 0x4f66, 0x4f67, 0x4f68, 0x4f69, 0x4f6a, 0x4f6b, 0x4f6c,   // U+a4a8 ~ U+a4af
0x4f6d, 0x4f6e, 0x4f6f, 0x4f70, 0x4f71, 0x4f72, 0x4f73, 0x4f74,   // U+a4b0 ~ U+a4b7
0x4f75, 0x4f76, 0x4f77, 0x4f78, 0x4f79, 0x4f7a, 0x4f7b, 0x4f7c,   // U+a4b8 ~ U+a4bf
0x4f7d, 0x4f7e, 0x4f7f, 0x4f80, 0x4f81, 0x4f82, 0x4f83, 0x4f84,   // U+a4c0 ~ U+a4c7
0x4f85, 0x4f86, 0x4f87, 0x4f88, 0x4f89, 0x4f8a, 0x4f8b, 0x4f8c,   // U+a4c8 ~ U+a4cf
0x4f8d, 0x4f8e, 0x4f8f, 0x4f90, 0x4f91, 0x4f92, 0x4f93, 0x4f94,   // U+a4d0 ~ U+a4d7
0x4f95, 0x4f96, 0x4f97, 0x4f98, 0x4f99, 0x4f9a, 0x4f9b, 0x4f9c,   // U+a4d8 ~ U+a4df
0x4f9d, 0x4f9e, 0x4f9f, 0x4fa0, 0x4fa1, 0x4fa2, 0x4fa3, 0x4fa4,   // U+a4e0 ~ U+a4e7
0x4fa5, 0x4fa6, 0x4fa7, 0x4fa8, 0x4fa9, 0x4faa, 0x4fab, 0x4fac,   // U+a4e8 ~ U+a4ef
0x4fad, 0x4fae, 0x4faf, 0x4fb0, 0x4fb1, 0x4fb2, 0x4fb3, 0x4fb4,   // U+a4f0 ~ U+a4f7
0x4fb5, 0x4fb6, 0x4fb7, 0x4fb8, 0x4fb9, 0x4fba, 0x4fbb, 0x4fbc,   // U+a4f8 ~ U+a4ff
0x4fbd, 0x4fbe, 0x4fbf, 0x4fc0, 0x4fc1, 0x4fc2, 0x4fc3, 0x4fc4,   // U+a500 ~ U+a507
0x4fc5, 0x4fc6, 0x4fc7, 0x4fc8, 0x4fc9, 0x4fca, 0x4fcb, 0x4fcc,   // U+a508 ~ U+a50f
0x4fcd, 0x4fce, 0x4fcf, 0x4fd0, 0x4fd1, 0x4fd2, 0x4fd3, 0x4fd4,   // U+a510 ~ U+a517
0x4fd5, 0x4fd6, 0x4fd7, 0x4fd8, 0x4fd9, 0x4fda, 0x4fdb, 0x4fdc,   // U+a518 ~ U+a51f
0x4fdd, 0x4fde, 0x4fdf, 0x4fe0, 0x4fe1, 0x4fe2, 0x4fe3, 0x4fe4,   // U+a520 ~ U+a527
0x4fe5, 0x4fe6, 0x4fe7, 0x4fe8, 0x4fe9, 0x4fea, 0x4feb, 0x4fec,   // U+a528 ~ U+a52f
0x4fed, 0x4fee, 0x4fef, 0x4ff0, 0x4ff1, 0x4ff2, 0x4ff3, 0x4ff4,   // U+a530 ~ U+a537
0x4ff5, 0x4ff6, 0x4ff7, 0x4ff8, 0x4ff9, 0x4ffa, 0x4ffb, 0x4ffc,   // U+a538 ~ U+a53f
0x4ffd, 0x4ffe, 0x4fff, 0x5000, 0x5001, 0x5002, 0x5003, 0x5004,   // U+a540 ~ U+a547
0x5005, 0x5006, 0x5007, 0x5008, 0x5009, 0x500a, 0x500b, 0x500c,   // U+a548 ~ U+a54f
0x500d, 0x500e, 0x500f, 0x5010, 0x5011, 0x5012, 0x5013, 0x5014,   // U+a550 ~ U+a557
0x5015, 0x5016, 0x5017, 0x5018, 0x5019, 0x501a, 0x501b, 0x501c,   // U+a558 ~ U+a55f
0x501d, 0x501e, 0x501f, 0x5020, 0x5021, 0x5022, 0x5023, 0x5024,   // U+a560 ~ U+a567
0x5025, 0x5026, 0x5027, 0x5028, 0x5029, 0x502a, 0x502b, 0x502c,   // U+a568 ~ U+a56f
0x502d, 0x502e, 0x502f, 0x5030, 0x5031, 0x5032, 0x5033, 0x5034,   // U+a570 ~ U+a577
0x5035, 0x5036, 0x5037, 0x5038, 0x5039, 0x503a, 0x503b, 0x503c,   // U+a578 ~ U+a57f
0x503d, 0x503e, 0x503f, 0x5040, 0x5041, 0x5042, 0x5043, 0x5044,   // U+a580 ~ U+a587
0x5045, 0x5046, 0x5047, 0x5048, 0x5049, 0x504a, 0x504b, 0x504c,   // U+a588 ~ U+a58f
0x504d, 0x504e, 0x504f, 0x5050, 0x5051, 0x5052, 0x5053, 0x5054,   // U+a590 ~ U+a597
0x5055, 0x5056, 0x5057, 0x5058, 0x5059, 0x505a, 0x505b, 0x505c,   // U+a598 ~ U+a59f
0x505d, 0x505e, 0x505f, 0x5060, 0x5061, 0x5062, 0x5063, 0x5064,   // U+a5a0 ~ U+a5a7
0x5065, 0x5066, 0x5067, 0x5068, 0x5069, 0x506a, 0x506b, 0x506c,   // U+a5a8 ~ U+a5af
0x506d, 0x506e, 0x506f, 0x5070, 0x5071, 0x5072, 0x5073, 0x5074,   // U+a5b0 ~ U+a5b7
0x5075, 0x5076, 0x5077, 0x5078, 0x5079, 0x507a, 0x507b, 0x507c,   // U+a5b8 ~ U+a5bf
0x507d, 0x507e, 0x507f, 0x5080, 0x5081, 0x5082, 0x5083, 0x5084,   // U+a5c0 ~ U+a5c7
0x5085, 0x5086, 0x5087, 0x5088, 0x5089, 0x508a, 0x508b, 0x508c,   // U+a5c8 ~ U+a5cf
0x508d, 0x508e, 0x508f, 0x5090, 0x5091, 0x5092, 0x5093, 0x5094,   // U+a5d0 ~ U+a5d7
0x5095, 0x5096, 0x5097, 0x5098, 0x5099, 0x509a, 0x509b, 0x509c,   // U+a5d8 ~ U+a5df
0x509d, 0x509e, 0x509f, 0x50a0, 0x50a1, 0x50a2, 0x50a3, 0x50a4,   // U+a5e0 ~ U+a5e7
0x50a5, 0x50a6, 0x50a7, 0x50a8, 0x50a9, 0x50aa, 0x50ab, 0x50ac,   // U+a5e8 ~ U+a5ef
0x50ad, 0x50ae, 0x50af, 0x50b0, 0x50b1, 0x50b2, 0x50b3, 0x50b4,   // U+a5f0 ~ U+a5f7
0x50b5, 0x50b6, 0x50b7, 0x50b8, 0x50b9, 0x50ba, 0x50bb, 0x50bc,   // U+a5f8 ~ U+a5ff
0x50bd, 0x50be, 0x50bf, 0x50c0, 0x50c1, 0x50c2, 0x50c3, 0x50c4,   // U+a600 ~ U+a607
0x50c5, 0x50c6, 0x50c7, 0x50c8, 0x50c9, 0x50ca, 0x50cb, 0x50cc,   // U+a608 ~ U+a60f
0x50cd, 0x50ce, 0x50cf, 0x50d0, 0x50d1, 0x50d2, 0x50d3, 0x50d4,   // U+a610 ~ U+a617
0x50d5, 0x50d6, 0x50d7, 0x50d8, 0x50d9, 0x50da, 0x50db, 0x50dc,   // U+a618 ~ U+a61f
0x50dd, 0x50de, 0x50df, 0x50e0, 0x50e1, 0x50e2, 0x50e3, 0x50e4,   // U+a620 ~ U+a627
0x50e5, 0x50e6, 0x50e7, 0x50e8, 0x50e9, 0x50ea, 0x50eb, 0x50ec,   // U+a628 ~ U+a62f
0x50ed, 0x50ee, 0x50ef, 0x50f0, 0x50f1, 0x50f2, 0x50f3, 0x50f4,   // U+a630 ~ U+a637
0x50f5, 0x50f6, 0x50f7, 0x50f8, 0x50f9, 0x50fa, 0x50fb, 0x50fc,   // U+a638 ~ U+a63f
0x50fd, 0x50fe, 0x50ff, 0x5100, 0x5101, 0x5102, 0x5103, 0x5104,   // U+a640 ~ U+a647
0x5105, 0x5106, 0x5107, 0x5108, 0x5109, 0x510a, 0x510b, 0x510c,   // U+a648 ~ U+a64f
0x510d, 0x510e, 0x510f, 0x5110, 0x5111, 0x5112, 0x5113, 0x5114,   // U+a650 ~ U+a657
0x5115, 0x5116, 0x5117, 0x5118, 0x5119, 0x511a, 0x511b, 0x511c,   // U+a658 ~ U+a65f
0x511d, 0x511e, 0x511f, 0x5120, 0x5121, 0x5122, 0x5123, 0x5124,   // U+a660 ~ U+a667
0x5125, 0x5126, 0x5127, 0x5128, 0x5129, 0x512a, 0x512b, 0x512c,   // U+a668 ~ U+a66f
0x512d, 0x512e, 0x512f, 0x5130, 0x5131, 0x5132, 0x5133, 0x5134,   // U+a670 ~ U+a677
0x5135, 0x5136, 0x5137, 0x5138, 0x5139, 0x513a, 0x513b, 0x513c,   // U+a678 ~ U+a67f
0x513d, 0x513e, 0x513f, 0x5140, 0x5141, 0x5142, 0x5143, 0x5144,   // U+a680 ~ U+a687
0x5145, 0x5146, 0x5147, 0x5148, 0x5149, 0x514a, 0x514b, 0x514c,   // U+a688 ~ U+a68f
0x514d, 0x514e, 0x514f, 0x5150, 0x5151, 0x5152, 0x5153, 0x5154,   // U+a690 ~ U+a697
0x5155, 0x5156, 0x5157, 0x5158, 0x5159, 0x515a, 0x515b, 0x515c,   // U+a698 ~ U+a69f
0x515d, 0x515e, 0x515f, 0x5160, 0x5161, 0x5162, 0x5163, 0x5164,   // U+a6a0 ~ U+a6a7
0x5165, 0x5166, 0x5167, 0x5168, 0x5169, 0x516a, 0x516b, 0x516c,   // U+a6a8 ~ U+a6af
0x516d, 0x516e, 0x516f, 0x5170, 0x5171, 0x5172, 0x5173, 0x5174,   // U+a6b0 ~ U+a6b7
0x5175, 0x5176, 0x5177, 0x5178, 0x5179, 0x517a, 0x517b, 0x517c,   // U+a6b8 ~ U+a6bf
0x517d, 0x517e, 0x517f, 0x5180, 0x5181, 0x5182, 0x5183, 0x5184,   // U+a6c0 ~ U+a6c7
0x5185, 0x5186, 0x5187, 0x5188, 0x5189, 0x518a, 0x518b, 0x518c,   // U+a6c8 ~ U+a6cf
0x518d, 0x518e, 0x518f, 0x5190, 0x5191, 0x5192, 0x5193, 0x5194,   // U+a6d0 ~ U+a6d7
0x5195, 0x5196, 0x5197, 0x5198, 0x5199, 0x519a, 0x519b, 0x519c,   // U+a6d8 ~ U+a6df
0x519d, 0x519e, 0x519f, 0x51a0, 0x51a1, 0x51a2, 0x51a3, 0x51a4,   // U+a6e0 ~ U+a6e7
0x51a5, 0x51a6, 0x51a7, 0x51a8, 0x51a9, 0x51aa, 0x51ab, 0x51ac,   // U+a6e8 ~ U+a6ef
0x51ad, 0x51ae, 0x51af, 0x51b0, 0x51b1, 0x51b2, 0x51b3, 0x51b4,   // U+a6f0 ~ U+a6f7
0x51b5, 0x51b6, 0x51b7, 0x51b8, 0x51b9, 0x51ba, 0x51bb, 0x51bc,   // U+a6f8 ~ U+a6ff
0x51bd, 0x51be, 0x51bf, 0x51c0, 0x51c1, 0x51c2, 0x51c3, 0x51c4,   // U+a700 ~ U+a707
0x51c5, 0x51c6, 0x51c7, 0x51c8, 0x51c9, 0x51ca, 0x51cb, 0x51cc,   // U+a708 ~ U+a70f
0x51cd, 0x51ce, 0x51cf, 0x51d0, 0x51d1, 0x51d2, 0x51d3, 0x51d4,   // U+a710 ~ U+a717
0x51d5, 0x51d6, 0x51d7, 0x51d8, 0x51d9, 0x51da, 0x51db, 0x51dc,   // U+a718 ~ U+a71f
0x51dd, 0x51de, 0x51df, 0x51e0, 0x51e1, 0x51e2, 0x51e3, 0x51e4,   // U+a720 ~ U+a727
0x51e5, 0x51e6, 0x51e7, 0x51e8, 0x51e9, 0x51ea, 0x51eb, 0x51ec,   // U+a728 ~ U+a72f
0x51ed, 0x51ee, 0x51ef, 0x51f0, 0x51f1, 0x51f2, 0x51f3, 0x51f4,   // U+a730 ~ U+a737
0x51f5, 0x51f6, 0x51f7, 0x51f8, 0x51f9, 0x51fa, 0x51fb, 0x51fc,   // U+a738 ~ U+a73f
0x51fd, 0x51fe, 0x51ff, 0x5200, 0x5201, 0x5202, 0x5203, 0x5204,   // U+a740 ~ U+a747
0x5205, 0x5206, 0x5207, 0x5208, 0x5209, 0x520a, 0x520b, 0x520c,   // U+a748 ~ U+a74f
0x520d, 0x520e, 0x520f, 0x5210, 0x5211, 0x5212, 0x5213, 0x5214,   // U+a750 ~ U+a757
0x5215, 0x5216, 0x5217, 0x5218, 0x5219, 0x521a, 0x521b, 0x521c,   // U+a758 ~ U+a75f
0x521d, 0x521e, 0x521f, 0x5220, 0x5221, 0x5222, 0x5223, 0x5224,   // U+a760 ~ U+a767
0x5225, 0x5226, 0x5227, 0x5228, 0x5229, 0x522a, 0x522b, 0x522c,   // U+a768 ~ U+a76f
0x522d, 0x522e, 0x522f, 0x5230, 0x5231, 0x5232, 0x5233, 0x5234,   // U+a770 ~ U+a777
0x5235, 0x5236, 0x5237, 0x5238, 0x5239, 0x523a, 0x523b, 0x523c,   // U+a778 ~ U+a77f
0x523d, 0x523e, 0x523f, 0x5240, 0x5241, 0x5242, 0x5243, 0x5244,   // U+a780 ~ U+a787
0x5245, 0x5246, 0x5247, 0x5248, 0x5249, 0x524a, 0x524b, 0x524c,   // U+a788 ~ U+a78f
0x524d, 0x524e, 0x524f, 0x5250, 0x5251, 0x5252, 0x5253, 0x5254,   // U+a790 ~ U+a797
0x5255, 0x5256, 0x5257, 0x5258, 0x5259, 0x525a, 0x525b, 0x525c,   // U+a798 ~ U+a79f
0x525d, 0x525e, 0x525f, 0x5260, 0x5261, 0x5262, 0x5263, 0x5264,   // U+a7a0 ~ U+a7a7
0x5265, 0x5266, 0x5267, 0x5268, 0x5269, 0x526a, 0x526b, 0x526c,   // U+a7a8 ~ U+a7af
0x526d, 0x526e, 0x526f, 0x5270, 0x5271, 0x5272, 0x5273, 0x5274,   // U+a7b0 ~ U+a7b7
0x5275, 0x5276, 0x5277, 0x5278, 0x5279, 0x527a, 0x527b, 0x527c,   // U+a7b8 ~ U+a7bf
0x527d, 0x527e, 0x527f, 0x5280, 0x5281, 0x5282, 0x5283, 0x5284,   // U+a7c0 ~ U+a7c7
0x5285, 0x5286, 0x5287, 0x5288, 0x5289, 0x528a, 0x528b, 0x528c,   // U+a7c8 ~ U+a7cf
0x528d, 0x528e, 0x528f, 0x5290, 0x5291, 0x5292, 0x5293, 0x5294,   // U+a7d0 ~ U+a7d7
0x5295, 0x5296, 0x5297, 0x5298, 0x5299, 0x529a, 0x529b, 0x529c,   // U+a7d8 ~ U+a7df
0x529d, 0x529e, 0x529f, 0x52a0, 0x52a1, 0x52a2, 0x52a3, 0x52a4,   // U+a7e0 ~ U+a7e7
0x52a5, 0x52a6, 0x52a7, 0x52a8, 0x52a9, 0x52aa, 0x52ab, 0x52ac,   // U+a7e8 ~ U+a7ef
0x52ad, 0x52ae, 0x52af, 0x52b0, 0x52b1, 0x52b2, 0x52b3, 0x52b4,   // U+a7f0 ~ U+a7f7
0x52b5, 0x52b6, 0x52b7, 0x52b8, 0x52b9, 0x52ba, 0x52bb, 0x52bc,   // U+a7f8 ~ U+a7ff
0x52bd, 0x52be, 0x52bf, 0x52c0, 0x52c1, 0x52c2, 0x52c3, 0x52c4,   // U+a800 ~ U+a807
0x52c5, 0x52c6, 0x52c7, 0x52c8, 0x52c9, 0x52ca, 0x52cb, 0x52cc,   // U+a808 ~ U+a80f
0x52cd, 0x52ce, 0x52cf, 0x52d0, 0x52d1, 0x52d2, 0x52d3, 0x52d4,   // U+a810 ~ U+a817
0x52d5, 0x52d6, 0x52d7, 0x52d8, 0x52d9, 0x52da, 0x52db, 0x52dc,   // U+a818 ~ U+a81f
0x52dd, 0x52de, 0x52df, 0x52e0, 0x52e1, 0x52e2, 0x52e3, 0x52e4,   // U+a820 ~ U+a827
0x52e5, 0x52e6, 0x52e7, 0x52e8, 0x52e9, 0x52ea, 0x52eb, 0x52ec,   // U+a828 ~ U+a82f
0x52ed, 0x52ee, 0x52ef, 0x52f0, 0x52f1, 0x52f2, 0x52f3, 0x52f4,   // U+a830 ~ U+a837
0x52f5, 0x52f6, 0x52f7, 0x52f8, 0x52f9, 0x52fa, 0x52fb, 0x52fc,   // U+a838 ~ U+a83f
0x52fd, 0x52fe, 0x52ff, 0x5300, 0x5301, 0x5302, 0x5303, 0x5304,   // U+a840 ~ U+a847
0x5305, 0x5306, 0x5307, 0x5308, 0x5309, 0x530a, 0x530b, 0x530c,   // U+a848 ~ U+a84f
0x530d, 0x530e, 0x530f, 0x5310, 0x5311, 0x5312, 0x5313, 0x5314,   // U+a850 ~ U+a857
0x5315, 0x5316, 0x5317, 0x5318, 0x5319, 0x531a, 0x531b, 0x531c,   // U+a858 ~ U+a85f
0x531d, 0x531e, 0x531f, 0x5320, 0x5321, 0x5322, 0x5323, 0x5324,   // U+a860 ~ U+a867
0x5325, 0x5326, 0x5327, 0x5328, 0x5329, 0x532a, 0x532b, 0x532c,   // U+a868 ~ U+a86f
0x532d, 0x532e, 0x532f, 0x5330, 0x5331, 0x5332, 0x5333, 0x5334,   // U+a870 ~ U+a877
0x5335, 0x5336, 0x5337, 0x5338, 0x5339, 0x533a, 0x533b, 0x533c,   // U+a878 ~ U+a87f
0x533d, 0x533e, 0x533f, 0x5340, 0x5341, 0x5342, 0x5343, 0x5344,   // U+a880 ~ U+a887
0x5345, 0x5346, 0x5347, 0x5348, 0x5349, 0x534a, 0x534b, 0x534c,   // U+a888 ~ U+a88f
0x534d, 0x534e, 0x534f, 0x5350, 0x5351, 0x5352, 0x5353, 0x5354,   // U+a890 ~ U+a897
0x5355, 0x5356, 0x5357, 0x5358, 0x5359, 0x535a, 0x535b, 0x535c,   // U+a898 ~ U+a89f
0x535d, 0x535e, 0x535f, 0x5360, 0x5361, 0x5362, 0x5363, 0x5364,   // U+a8a0 ~ U+a8a7
0x5365, 0x5366, 0x5367, 0x5368, 0x5369, 0x536a, 0x536b, 0x536c,   // U+a8a8 ~ U+a8af
0x536d, 0x536e, 0x536f, 0x5370, 0x5371, 0x5372, 0x5373, 0x5374,   // U+a8b0 ~ U+a8b7
0x5375, 0x5376, 0x5377, 0x5378, 0x5379, 0x537a, 0x537b, 0x537c,   // U+a8b8 ~ U+a8bf
0x537d, 0x537e, 0x537f, 0x5380, 0x5381, 0x5382, 0x5383, 0x5384,   // U+a8c0 ~ U+a8c7
0x5385, 0x5386, 0x5387, 0x5388, 0x5389, 0x538a, 0x538b, 0x538c,   // U+a8c8 ~ U+a8cf
0x538d, 0x538e, 0x538f, 0x5390, 0x5391, 0x5392, 0x5393, 0x5394,   // U+a8d0 ~ U+a8d7
0x5395, 0x5396, 0x5397, 0x5398, 0x5399, 0x539a, 0x539b, 0x539c,   // U+a8d8 ~ U+a8df
0x539d, 0x539e, 0x539f, 0x53a0, 0x53a1, 0x53a2, 0x53a3, 0x53a4,   // U+a8e0 ~ U+a8e7
0x53a5, 0x53a6, 0x53a7, 0x53a8, 0x53a9, 0x53aa, 0x53ab, 0x53ac,   // U+a8e8 ~ U+a8ef
0x53ad, 0x53ae, 0x53af, 0x53b0, 0x53b1, 0x53b2, 0x53b3, 0x53b4,   // U+a8f0 ~ U+a8f7
0x53b5, 0x53b6, 0x53b7, 0x53b8, 0x53b9, 0x53ba, 0x53bb, 0x53bc,   // U+a8f8 ~ U+a8ff
0x53bd, 0x53be, 0x53bf, 0x53c0, 0x53c1, 0x53c2, 0x53c3, 0x53c4,   // U+a900 ~ U+a907
0x53c5, 0x53c6, 0x53c7, 0x53c8, 0x53c9, 0x53ca, 0x53cb, 0x53cc,   // U+a908 ~ U+a90f
0x53cd, 0x53ce, 0x53cf, 0x53d0, 0x53d1, 0x53d2, 0x53d3, 0x53d4,   // U+a910 ~ U+a917
0x53d5, 0x53d6, 0x53d7, 0x53d8, 0x53d9, 0x53da, 0x53db, 0x53dc,   // U+a918 ~ U+a91f
0x53dd, 0x53de, 0x53df, 0x53e0, 0x53e1, 0x53e2, 0x53e3, 0x53e4,   // U+a920 ~ U+a927
0x53e5, 0x53e6, 0x53e7, 0x53e8, 0x53e9, 0x53ea, 0x53eb, 0x53ec,   // U+a928 ~ U+a92f
0x53ed, 0x53ee, 0x53ef, 0x53f0, 0x53f1, 0x53f2, 0x53f3, 0x53f4,   // U+a930 ~ U+a937
0x53f5, 0x53f6, 0x53f7, 0x53f8, 0x53f9, 0x53fa, 0x53fb, 0x53fc,   // U+a938 ~ U+a93f
0x53fd, 0x53fe, 0x53ff, 0x5400, 0x5401, 0x5402, 0x5403, 0x5404,   // U+a940 ~ U+a947
0x5405, 0x5406, 0x5407, 0x5408, 0x5409, 0x540a, 0x540b, 0x540c,   // U+a948 ~ U+a94f
0x540d, 0x540e, 0x540f, 0x5410, 0x5411, 0x5412, 0x5413, 0x5414,   // U+a950 ~ U+a957
0x5415, 0x5416, 0x5417, 0x5418, 0x5419, 0x541a, 0x541b, 0x541c,   // U+a958 ~ U+a95f
0x541d, 0x541e, 0x541f, 0x5420, 0x5421, 0x5422, 0x5423, 0x5424,   // U+a960 ~ U+a967
0x5425, 0x5426, 0x5427, 0x5428, 0x5429, 0x542a, 0x542b, 0x542c,   // U+a968 ~ U+a96f
0x542d, 0x542e, 0x542f, 0x5430, 0x5431, 0x5432, 0x5433, 0x5434,   // U+a970 ~ U+a977
0x5435, 0x5436, 0x5437, 0x5438, 0x5439, 0x543a, 0x543b, 0x543c,   // U+a978 ~ U+a97f
0x543d, 0x543e, 0x543f, 0x5440, 0x5441, 0x5442, 0x5443, 0x5444,   // U+a980 ~ U+a987
0x5445, 0x5446, 0x5447, 0x5448, 0x5449, 0x544a, 0x544b, 0x544c,   // U+a988 ~ U+a98f
0x544d, 0x544e, 0x544f, 0x5450, 0x5451, 0x5452, 0x5453, 0x5454,   // U+a990 ~ U+a997
0x5455, 0x5456, 0x5457, 0x5458, 0x5459, 0x545a, 0x545b, 0x545c,   // U+a998 ~ U+a99f
0x545d, 0x545e, 0x545f, 0x5460, 0x5461, 0x5462, 0x5463, 0x5464,   // U+a9a0 ~ U+a9a7
0x5465, 0x5466, 0x5467, 0x5468, 0x5469, 0x546a, 0x546b, 0x546c,   // U+a9a8 ~ U+a9af
0x546d, 0x546e, 0x546f, 0x5470, 0x5471, 0x5472, 0x5473, 0x5474,   // U+a9b0 ~ U+a9b7
0x5475, 0x5476, 0x5477, 0x5478, 0x5479, 0x547a, 0x547b, 0x547c,   // U+a9b8 ~ U+a9bf
0x547d, 0x547e, 0x547f, 0x5480, 0x5481, 0x5482, 0x5483, 0x5484,   // U+a9c0 ~ U+a9c7
0x5485, 0x5486, 0x5487, 0x5488, 0x5489, 0x548a, 0x548b, 0x548c,   // U+a9c8 ~ U+a9cf
0x548d, 0x548e, 0x548f, 0x5490, 0x5491, 0x5492, 0x5493, 0x5494,   // U+a9d0 ~ U+a9d7
0x5495, 0x5496, 0x5497, 0x5498, 0x5499, 0x549a, 0x549b, 0x549c,   // U+a9d8 ~ U+a9df
0x549d, 0x549e, 0x549f, 0x54a0, 0x54a1, 0x54a2, 0x54a3, 0x54a4,   // U+a9e0 ~ U+a9e7
0x54a5, 0x54a6, 0x54a7, 0x54a8, 0x54a9, 0x54aa, 0x54ab, 0x54ac,   // U+a9e8 ~ U+a9ef
0x54ad, 0x54ae, 0x54af, 0x54b0, 0x54b1, 0x54b2, 0x54b3, 0x54b4,   // U+a9f0 ~ U+a9f7
0x54b5, 0x54b6, 0x54b7, 0x54b8, 0x54b9, 0x54ba, 0x54bb, 0x54bc,   // U+a9f8 ~ U+a9ff
0x54bd, 0x54be, 0x54bf, 0x54c0, 0x54c1, 0x54c2, 0x54c3, 0x54c4,   // U+aa00 ~ U+aa07
0x54c5, 0x54c6, 0x54c7, 0x54c8, 0x54c9, 0x54ca, 0x54cb, 0x54cc,   // U+aa08 ~ U+aa0f
0x54cd, 0x54ce, 0x54cf, 0x54d0, 0x54d1, 0x54d2, 0x54d3, 0x54d4,   // U+aa10 ~ U+aa17
0x54d5, 0x54d6, 0x54d7, 0x54d8, 0x54d9, 0x54da, 0x54db, 0x54dc,   // U+aa18 ~ U+aa1f
0x54dd, 0x54de, 0x54df, 0x54e0, 0x54e1, 0x54e2, 0x54e3, 0x54e4,   // U+aa20 ~ U+aa27
0x54e5, 0x54e6, 0x54e7, 0x54e8, 0x54e9, 0x54ea, 0x54eb, 0x54ec,   // U+aa28 ~ U+aa2f
0x54ed, 0x54ee, 0x54ef, 0x54f0, 0x54f1, 0x54f2, 0x54f3, 0x54f4,   // U+aa30 ~ U+aa37
0x54f5, 0x54f6, 0x54f7, 0x54f8, 0x54f9, 0x54fa, 0x54fb, 0x54fc,   // U+aa38 ~ U+aa3f
0x54fd, 0x54fe, 0x54ff, 0x5500, 0x5501, 0x5502, 0x5503, 0x5504,   // U+aa40 ~ U+aa47
0x5505, 0x5506, 0x5507, 0x5508, 0x5509, 0x550a, 0x550b, 0x550c,   // U+aa48 ~ U+aa4f
0x550d, 0x550e, 0x550f, 0x5510, 0x5511, 0x5512, 0x5513, 0x5514,   // U+aa50 ~ U+aa57
0x5515, 0x5516, 0x5517, 0x5518, 0x5519, 0x551a, 0x551b, 0x551c,   // U+aa58 ~ U+aa5f
0x551d, 0x551e, 0x551f, 0x5520, 0x5521, 0x5522, 0x5523, 0x5524,   // U+aa60 ~ U+aa67
0x5525, 0x5526, 0x5527, 0x5528, 0x5529, 0x552a, 0x552b, 0x552c,   // U+aa68 ~ U+aa6f
0x552d, 0x552e, 0x552f, 0x5530, 0x5531, 0x5532, 0x5533, 0x5534,   // U+aa70 ~ U+aa77
0x5535, 0x5536, 0x5537, 0x5538, 0x5539, 0x553a, 0x553b, 0x553c,   // U+aa78 ~ U+aa7f
0x553d, 0x553e, 0x553f, 0x5540, 0x5541, 0x5542, 0x5543, 0x5544,   // U+aa80 ~ U+aa87
0x5545, 0x5546, 0x5547, 0x5548, 0x5549, 0x554a, 0x554b, 0x554c,   // U+aa88 ~ U+aa8f
0x554d, 0x554e, 0x554f, 0x5550, 0x5551, 0x5552, 0x5553, 0x5554,   // U+aa90 ~ U+aa97
0x5555, 0x5556, 0x5557, 0x5558, 0x5559, 0x555a, 0x555b, 0x555c,   // U+aa98 ~ U+aa9f
0x555d, 0x555e, 0x555f, 0x5560, 0x5561, 0x5562, 0x5563, 0x5564,   // U+aaa0 ~ U+aaa7
0x5565, 0x5566, 0x5567, 0x5568, 0x5569, 0x556a, 0x556b, 0x556c,   // U+aaa8 ~ U+aaaf
0x556d, 0x556e, 0x556f, 0x5570, 0x5571, 0x5572, 0x5573, 0x5574,   // U+aab0 ~ U+aab7
0x5575, 0x5576, 0x5577, 0x5578, 0x5579, 0x557a, 0x557b, 0x557c,   // U+aab8 ~ U+aabf
0x557d, 0x557e, 0x557f, 0x5580, 0x5581, 0x5582, 0x5583, 0x5584,   // U+aac0 ~ U+aac7
0x5585, 0x5586, 0x5587, 0x5588, 0x5589, 0x558a, 0x558b, 0x558c,   // U+aac8 ~ U+aacf
0x558d, 0x558e, 0x558f, 0x5590, 0x5591, 0x5592, 0x5593, 0x5594,   // U+aad0 ~ U+aad7
0x5595, 0x5596, 0x5597, 0x5598, 0x5599, 0x559a, 0x559b, 0x559c,   // U+aad8 ~ U+aadf
0x559d, 0x559e, 0x559f, 0x55a0, 0x55a1, 0x55a2, 0x55a3, 0x55a4,   // U+aae0 ~ U+aae7
0x55a5, 0x55a6, 0x55a7, 0x55a8, 0x55a9, 0x55aa, 0x55ab, 0x55ac,   // U+aae8 ~ U+aaef
0x55ad, 0x55ae, 0x55af, 0x55b0, 0x55b1, 0x55b2, 0x55b3, 0x55b4,   // U+aaf0 ~ U+aaf7
0x55b5, 0x55b6, 0x55b7, 0x55b8, 0x55b9, 0x55ba, 0x55bb, 0x55bc,   // U+aaf8 ~ U+aaff
0x55bd, 0x55be, 0x55bf, 0x55c0, 0x55c1, 0x55c2, 0x55c3, 0x55c4,   // U+ab00 ~ U+ab07
0x55c5, 0x55c6, 0x55c7, 0x55c8, 0x55c9, 0x55ca, 0x55cb, 0x55cc,   // U+ab08 ~ U+ab0f
0x55cd, 0x55ce, 0x55cf, 0x55d0, 0x55d1, 0x55d2, 0x55d3, 0x55d4,   // U+ab10 ~ U+ab17
0x55d5, 0x55d6, 0x55d7, 0x55d8, 0x55d9, 0x55da, 0x55db, 0x55dc,   // U+ab18 ~ U+ab1f
0x55dd, 0x55de, 0x55df, 0x55e0, 0x55e1, 0x55e2, 0x55e3, 0x55e4,   // U+ab20 ~ U+ab27
0x55e5, 0x55e6, 0x55e7, 0x55e8, 0x55e9, 0x55ea, 0x55eb, 0x55ec,   // U+ab28 ~ U+ab2f
0x55ed, 0x55ee, 0x55ef, 0x55f0, 0x55f1, 0x55f2, 0x55f3, 0x55f4,   // U+ab30 ~ U+ab37
0x55f5, 0x55f6, 0x55f7, 0x55f8, 0x55f9, 0x55fa, 0x55fb, 0x55fc,   // U+ab38 ~ U+ab3f
0x55fd, 0x55fe, 0x55ff, 0x5600, 0x5601, 0x5602, 0x5603, 0x5604,   // U+ab40 ~ U+ab47
0x5605, 0x5606, 0x5607, 0x5608, 0x5609, 0x560a, 0x560b, 0x560c,   // U+ab48 ~ U+ab4f
0x560d, 0x560e, 0x560f, 0x5610, 0x5611, 0x5612, 0x5613, 0x5614,   // U+ab50 ~ U+ab57
0x5615, 0x5616, 0x5617, 0x5618, 0x5619, 0x561a, 0x561b, 0x561c,   // U+ab58 ~ U+ab5f
0x561d, 0x561e, 0x561f, 0x5620, 0x5621, 0x5622, 0x5623, 0x5624,   // U+ab60 ~ U+ab67
0x5625, 0x5626, 0x5627, 0x5628, 0x5629, 0x562a, 0x562b, 0x562c,   // U+ab68 ~ U+ab6f
0x562d, 0x562e, 0x562f, 0x5630, 0x5631, 0x5632, 0x5633, 0x5634,   // U+ab70 ~ U+ab77
0x5635, 0x5636, 0x5637, 0x5638, 0x5639, 0x563a, 0x563b, 0x563c,   // U+ab78 ~ U+ab7f
0x563d, 0x563e, 0x563f, 0x5640, 0x5641, 0x5642, 0x5643, 0x5644,   // U+ab80 ~ U+ab87
0x5645, 0x5646, 0x5647, 0x5648, 0x5649, 0x564a, 0x564b, 0x564c,   // U+ab88 ~ U+ab8f
0x564d, 0x564e, 0x564f, 0x5650, 0x5651, 0x5652, 0x5653, 0x5654,   // U+ab90 ~ U+ab97
0x5655, 0x5656, 0x5657, 0x5658, 0x5659, 0x565a, 0x565b, 0x565c,   // U+ab98 ~ U+ab9f
0x565d, 0x565e, 0x565f, 0x5660, 0x5661, 0x5662, 0x5663, 0x5664,   // U+aba0 ~ U+aba7
0x5665, 0x5666, 0x5667, 0x5668, 0x5669, 0x566a, 0x566b, 0x566c,   // U+aba8 ~ U+abaf
0x566d, 0x566e, 0x566f, 0x5670, 0x5671, 0x5672, 0x5673, 0x5674,   // U+abb0 ~ U+abb7
0x5675, 0x5676, 0x5677, 0x5678, 0x5679, 0x567a, 0x567b, 0x567c,   // U+abb8 ~ U+abbf
0x567d, 0x567e, 0x567f, 0x5680, 0x5681, 0x5682, 0x5683, 0x5684,   // U+abc0 ~ U+abc7
0x5685, 0x5686, 0x5687, 0x5688, 0x5689, 0x568a, 0x568b, 0x568c,   // U+abc8 ~ U+abcf
0x568d, 0x568e, 0x568f, 0x5690, 0x5691, 0x5692, 0x5693, 0x5694,   // U+abd0 ~ U+abd7
0x5695, 0x5696, 0x5697, 0x5698, 0x5699, 0x569a, 0x569b, 0x569c,   // U+abd8 ~ U+abdf
0x569d, 0x569e, 0x569f, 0x56a0, 0x56a1, 0x56a2, 0x56a3, 0x56a4,   // U+abe0 ~ U+abe7
0x56a5, 0x56a6, 0x56a7, 0x56a8, 0x56a9, 0x56aa, 0x56ab, 0x56ac,   // U+abe8 ~ U+abef
0x56ad, 0x56ae, 0x56af, 0x56b0, 0x56b1, 0x56b2, 0x56b3, 0x56b4,   // U+abf0 ~ U+abf7
0x56b5, 0x56b6, 0x56b7, 0x56b8, 0x56b9, 0x56ba, 0x56bb, 0x56bc,   // U+abf8 ~ U+abff
0x56bd, 0x56be, 0x56bf, 0x56c0, 0x56c1, 0x56c2, 0x56c3, 0x56c4,   // U+ac00 ~ U+ac07
0x56c5, 0x56c6, 0x56c7, 0x56c8, 0x56c9, 0x56ca, 0x56cb, 0x56cc,   // U+ac08 ~ U+ac0f
0x56cd, 0x56ce, 0x56cf, 0x56d0, 0x56d1, 0x56d2, 0x56d3, 0x56d4,   // U+ac10 ~ U+ac17
0x56d5, 0x56d6, 0x56d7, 0x56d8, 0x56d9, 0x56da, 0x56db, 0x56dc,   // U+ac18 ~ U+ac1f
0x56dd, 0x56de, 0x56df, 0x56e0, 0x56e1, 0x56e2, 0x56e3, 0x56e4,   // U+ac20 ~ U+ac27
0x56e5, 0x56e6, 0x56e7, 0x56e8, 0x56e9, 0x56ea, 0x56eb, 0x56ec,   // U+ac28 ~ U+ac2f
0x56ed, 0x56ee, 0x56ef, 0x56f0, 0x56f1, 0x56f2, 0x56f3, 0x56f4,   // U+ac30 ~ U+ac37
0x56f5, 0x56f6, 0x56f7, 0x56f8, 0x56f9, 0x56fa, 0x56fb, 0x56fc,   // U+ac38 ~ U+ac3f
0x56fd, 0x56fe, 0x56ff, 0x5700, 0x5701, 0x5702, 0x5703, 0x5704,   // U+ac40 ~ U+ac47
0x5705, 0x5706, 0x5707, 0x5708, 0x5709, 0x570a, 0x570b, 0x570c,   // U+ac48 ~ U+ac4f
0x570d, 0x570e, 0x570f, 0x5710, 0x5711, 0x5712, 0x5713, 0x5714,   // U+ac50 ~ U+ac57
0x5715, 0x5716, 0x5717, 0x5718, 0x5719, 0x571a, 0x571b, 0x571c,   // U+ac58 ~ U+ac5f
0x571d, 0x571e, 0x571f, 0x5720, 0x5721, 0x5722, 0x5723, 0x5724,   // U+ac60 ~ U+ac67
0x5725, 0x5726, 0x5727, 0x5728, 0x5729, 0x572a, 0x572b, 0x572c,   // U+ac68 ~ U+ac6f
0x572d, 0x572e, 0x572f, 0x5730, 0x5731, 0x5732, 0x5733, 0x5734,   // U+ac70 ~ U+ac77
0x5735, 0x5736, 0x5737, 0x5738, 0x5739, 0x573a, 0x573b, 0x573c,   // U+ac78 ~ U+ac7f
0x573d, 0x573e, 0x573f, 0x5740, 0x5741, 0x5742, 0x5743, 0x5744,   // U+ac80 ~ U+ac87
0x5745, 0x5746, 0x5747, 0x5748, 0x5749, 0x574a, 0x574b, 0x574c,   // U+ac88 ~ U+ac8f
0x574d, 0x574e, 0x574f, 0x5750, 0x5751, 0x5752, 0x5753, 0x5754,   // U+ac90 ~ U+ac97
0x5755, 0x5756, 0x5757, 0x5758, 0x5759, 0x575a, 0x575b, 0x575c,   // U+ac98 ~ U+ac9f
0x575d, 0x575e, 0x575f, 0x5760, 0x5761, 0x5762, 0x5763, 0x5764,   // U+aca0 ~ U+aca7
0x5765, 0x5766, 0x5767, 0x5768, 0x5769, 0x576a, 0x576b, 0x576c,   // U+aca8 ~ U+acaf
0x576d, 0x576e, 0x576f, 0x5770, 0x5771, 0x5772, 0x5773, 0x5774,   // U+acb0 ~ U+acb7
0x5775, 0x5776, 0x5777, 0x5778, 0x5779, 0x577a, 0x577b, 0x577c,   // U+acb8 ~ U+acbf
0x577d, 0x577e, 0x577f, 0x5780, 0x5781, 0x5782, 0x5783, 0x5784,   // U+acc0 ~ U+acc7
0x5785, 0x5786, 0x5787, 0x5788, 0x5789, 0x578a, 0x578b, 0x578c,   // U+acc8 ~ U+accf
0x578d, 0x578e, 0x578f, 0x5790, 0x5791, 0x5792, 0x5793, 0x5794,   // U+acd0 ~ U+acd7
0x5795, 0x5796, 0x5797, 0x5798, 0x5799, 0x579a, 0x579b, 0x579c,   // U+acd8 ~ U+acdf
0x579d, 0x579e, 0x579f, 0x57a0, 0x57a1, 0x57a2, 0x57a3, 0x57a4,   // U+ace0 ~ U+ace7
0x57a5, 0x57a6, 0x57a7, 0x57a8, 0x57a9, 0x57aa, 0x57ab, 0x57ac,   // U+ace8 ~ U+acef
0x57ad, 0x57ae, 0x57af, 0x57b0, 0x57b1, 0x57b2, 0x57b3, 0x57b4,   // U+acf0 ~ U+acf7
0x57b5, 0x57b6, 0x57b7, 0x57b8, 0x57b9, 0x57ba, 0x57bb, 0x57bc,   // U+acf8 ~ U+acff
0x57bd, 0x57be, 0x57bf, 0x57c0, 0x57c1, 0x57c2, 0x57c3, 0x57c4,   // U+ad00 ~ U+ad07
0x57c5, 0x57c6, 0x57c7, 0x57c8, 0x57c9, 0x57ca, 0x57cb, 0x57cc,   // U+ad08 ~ U+ad0f
0x57cd, 0x57ce, 0x57cf, 0x57d0, 0x57d1, 0x57d2, 0x57d3, 0x57d4,   // U+ad10 ~ U+ad17
0x57d5, 0x57d6, 0x57d7, 0x57d8, 0x57d9, 0x57da, 0x57db, 0x57dc,   // U+ad18 ~ U+ad1f
0x57dd, 0x57de, 0x57df, 0x57e0, 0x57e1, 0x57e2, 0x57e3, 0x57e4,   // U+ad20 ~ U+ad27
0x57e5, 0x57e6, 0x57e7, 0x57e8, 0x57e9, 0x57ea, 0x57eb, 0x57ec,   // U+ad28 ~ U+ad2f
0x57ed, 0x57ee, 0x57ef, 0x57f0, 0x57f1, 0x57f2, 0x57f3, 0x57f4,   // U+ad30 ~ U+ad37
0x57f5, 0x57f6, 0x57f7, 0x57f8, 0x57f9, 0x57fa, 0x57fb, 0x57fc,   // U+ad38 ~ U+ad3f
0x57fd, 0x57fe, 0x57ff, 0x5800, 0x5801, 0x5802, 0x5803, 0x5804,   // U+ad40 ~ U+ad47
0x5805, 0x5806, 0x5807, 0x5808, 0x5809, 0x580a, 0x580b, 0x580c,   // U+ad48 ~ U+ad4f
0x580d, 0x580e, 0x580f, 0x5810, 0x5811, 0x5812, 0x5813, 0x5814,   // U+ad50 ~ U+ad57
0x5815, 0x5816, 0x5817, 0x5818, 0x5819, 0x581a, 0x581b, 0x581c,   // U+ad58 ~ U+ad5f
0x581d, 0x581e, 0x581f, 0x5820, 0x5821, 0x5822, 0x5823, 0x5824,   // U+ad60 ~ U+ad67
0x5825, 0x5826, 0x5827, 0x5828, 0x5829, 0x582a, 0x582b, 0x582c,   // U+ad68 ~ U+ad6f
0x582d, 0x582e, 0x582f, 0x5830, 0x5831, 0x5832, 0x5833, 0x5834,   // U+ad70 ~ U+ad77
0x5835, 0x5836, 0x5837, 0x5838, 0x5839, 0x583a, 0x583b, 0x583c,   // U+ad78 ~ U+ad7f
0x583d, 0x583e, 0x583f, 0x5840, 0x5841, 0x5842, 0x5843, 0x5844,   // U+ad80 ~ U+ad87
0x5845, 0x5846, 0x5847, 0x5848, 0x5849, 0x584a, 0x584b, 0x584c,   // U+ad88 ~ U+ad8f
0x584d, 0x584e, 0x584f, 0x5850, 0x5851, 0x5852, 0x5853, 0x5854,   // U+ad90 ~ U+ad97
0x5855, 0x5856, 0x5857, 0x5858, 0x5859, 0x585a, 0x585b, 0x585c,   // U+ad98 ~ U+ad9f
0x585d, 0x585e, 0x585f, 0x5860, 0x5861, 0x5862, 0x5863, 0x5864,   // U+ada0 ~ U+ada7
0x5865, 0x5866, 0x5867, 0x5868, 0x5869, 0x586a, 0x586b, 0x586c,   // U+ada8 ~ U+adaf
0x586d, 0x586e, 0x586f, 0x5870, 0x5871, 0x5872, 0x5873, 0x5874,   // U+adb0 ~ U+adb7
0x5875, 0x5876, 0x5877, 0x5878, 0x5879, 0x587a, 0x587b, 0x587c,   // U+adb8 ~ U+adbf
0x587d, 0x587e, 0x587f, 0x5880, 0x5881, 0x5882, 0x5883, 0x5884,   // U+adc0 ~ U+adc7
0x5885, 0x5886, 0x5887, 0x5888, 0x5889, 0x588a, 0x588b, 0x588c,   // U+adc8 ~ U+adcf
0x588d, 0x588e, 0x588f, 0x5890, 0x5891, 0x5892, 0x5893, 0x5894,   // U+add0 ~ U+add7
0x5895, 0x5896, 0x5897, 0x5898, 0x5899, 0x589a, 0x589b, 0x589c,   // U+add8 ~ U+addf
0x589d, 0x589e, 0x589f, 0x58a0, 0x58a1, 0x58a2, 0x58a3, 0x58a4,   // U+ade0 ~ U+ade7
0x58a5, 0x58a6, 0x58a7, 0x58a8, 0x58a9, 0x58aa, 0x58ab, 0x58ac,   // U+ade8 ~ U+adef
0x58ad, 0x58ae, 0x58af, 0x58b0, 0x58b1, 0x58b2, 0x58b3, 0x58b4,   // U+adf0 ~ U+adf7
0x58b5, 0x58b6, 0x58b7, 0x58b8, 0x58b9, 0x58ba, 0x58bb, 0x58bc,   // U+adf8 ~ U+adff
0x58bd, 0x58be, 0x58bf, 0x58c0, 0x58c1, 0x58c2, 0x58c3, 0x58c4,   // U+ae00 ~ U+ae07
0x58c5, 0x58c6, 0x58c7, 0x58c8, 0x58c9, 0x58ca, 0x58cb, 0x58cc,   // U+ae08 ~ U+ae0f
0x58cd, 0x58ce, 0x58cf, 0x58d0, 0x58d1, 0x58d2, 0x58d3, 0x58d4,   // U+ae10 ~ U+ae17
0x58d5, 0x58d6, 0x58d7, 0x58d8, 0x58d9, 0x58da, 0x58db, 0x58dc,   // U+ae18 ~ U+ae1f
0x58dd, 0x58de, 0x58df, 0x58e0, 0x58e1, 0x58e2, 0x58e3, 0x58e4,   // U+ae20 ~ U+ae27
0x58e5, 0x58e6, 0x58e7, 0x58e8, 0x58e9, 0x58ea, 0x58eb, 0x58ec,   // U+ae28 ~ U+ae2f
0x58ed, 0x58ee, 0x58ef, 0x58f0, 0x58f1, 0x58f2, 0x58f3, 0x58f4,   // U+ae30 ~ U+ae37
0x58f5, 0x58f6, 0x58f7, 0x58f8, 0x58f9, 0x58fa, 0x58fb, 0x58fc,   // U+ae38 ~ U+ae3f
0x58fd, 0x58fe, 0x58ff, 0x5900, 0x5901, 0x5902, 0x5903, 0x5904,   // U+ae40 ~ U+ae47
0x5905, 0x5906, 0x5907, 0x5908, 0x5909, 0x590a, 0x590b, 0x590c,   // U+ae48 ~ U+ae4f
0x590d, 0x590e, 0x590f, 0x5910, 0x5911, 0x5912, 0x5913, 0x5914,   // U+ae50 ~ U+ae57
0x5915, 0x5916, 0x5917, 0x5918, 0x5919, 0x591a, 0x591b, 0x591c,   // U+ae58 ~ U+ae5f
0x591d, 0x591e, 0x591f, 0x5920, 0x5921, 0x5922, 0x5923, 0x5924,   // U+ae60 ~ U+ae67
0x5925, 0x5926, 0x5927, 0x5928, 0x5929, 0x592a, 0x592b, 0x592c,   // U+ae68 ~ U+ae6f
0x592d, 0x592e, 0x592f, 0x5930, 0x5931, 0x5932, 0x5933, 0x5934,   // U+ae70 ~ U+ae77
0x5935, 0x5936, 0x5937, 0x5938, 0x5939, 0x593a, 0x593b, 0x593c,   // U+ae78 ~ U+ae7f
0x593d, 0x593e, 0x593f, 0x5940, 0x5941, 0x5942, 0x5943, 0x5944,   // U+ae80 ~ U+ae87
0x5945, 0x5946, 0x5947, 0x5948, 0x5949, 0x594a, 0x594b, 0x594c,   // U+ae88 ~ U+ae8f
0x594d, 0x594e, 0x594f, 0x5950, 0x5951, 0x5952, 0x5953, 0x5954,   // U+ae90 ~ U+ae97
0x5955, 0x5956, 0x5957, 0x5958, 0x5959, 0x595a, 0x595b, 0x595c,   // U+ae98 ~ U+ae9f
0x595d, 0x595e, 0x595f, 0x5960, 0x5961, 0x5962, 0x5963, 0x5964,   // U+aea0 ~ U+aea7
0x5965, 0x5966, 0x5967, 0x5968, 0x5969, 0x596a, 0x596b, 0x596c,   // U+aea8 ~ U+aeaf
0x596d, 0x596e, 0x596f, 0x5970, 0x5971, 0x5972, 0x5973, 0x5974,   // U+aeb0 ~ U+aeb7
0x5975, 0x5976, 0x5977, 0x5978, 0x5979, 0x597a, 0x597b, 0x597c,   // U+aeb8 ~ U+aebf
0x597d, 0x597e, 0x597f, 0x5980, 0x5981, 0x5982, 0x5983, 0x5984,   // U+aec0 ~ U+aec7
0x5985, 0x5986, 0x5987, 0x5988, 0x5989, 0x598a, 0x598b, 0x598c,   // U+aec8 ~ U+aecf
0x598d, 0x598e, 0x598f, 0x5990, 0x5991, 0x5992, 0x5993, 0x5994,   // U+aed0 ~ U+aed7
0x5995, 0x5996, 0x5997, 0x5998, 0x5999, 0x599a, 0x599b, 0x599c,   // U+aed8 ~ U+aedf
0x599d, 0x599e, 0x599f, 0x59a0, 0x59a1, 0x59a2, 0x59a3, 0x59a4,   // U+aee0 ~ U+aee7
0x59a5, 0x59a6, 0x59a7, 0x59a8, 0x59a9, 0x59aa, 0x59ab, 0x59ac,   // U+aee8 ~ U+aeef
0x59ad, 0x59ae, 0x59af, 0x59b0, 0x59b1, 0x59b2, 0x59b3, 0x59b4,   // U+aef0 ~ U+aef7
0x59b5, 0x59b6, 0x59b7, 0x59b8, 0x59b9, 0x59ba, 0x59bb, 0x59bc,   // U+aef8 ~ U+aeff
0x59bd, 0x59be, 0x59bf, 0x59c0, 0x59c1, 0x59c2, 0x59c3, 0x59c4,   // U+af00 ~ U+af07
0x59c5, 0x59c6, 0x59c7, 0x59c8, 0x59c9, 0x59ca, 0x59cb, 0x59cc,   // U+af08 ~ U+af0f
0x59cd, 0x59ce, 0x59cf, 0x59d0, 0x59d1, 0x59d2, 0x59d3, 0x59d4,   // U+af10 ~ U+af17
0x59d5, 0x59d6, 0x59d7, 0x59d8, 0x59d9, 0x59da, 0x59db, 0x59dc,   // U+af18 ~ U+af1f
0x59dd, 0x59de, 0x59df, 0x59e0, 0x59e1, 0x59e2, 0x59e3, 0x59e4,   // U+af20 ~ U+af27
0x59e5, 0x59e6, 0x59e7, 0x59e8, 0x59e9, 0x59ea, 0x59eb, 0x59ec,   // U+af28 ~ U+af2f
0x59ed, 0x59ee, 0x59ef, 0x59f0, 0x59f1, 0x59f2, 0x59f3, 0x59f4,   // U+af30 ~ U+af37
0x59f5, 0x59f6, 0x59f7, 0x59f8, 0x59f9, 0x59fa, 0x59fb, 0x59fc,   // U+af38 ~ U+af3f
0x59fd, 0x59fe, 0x59ff, 0x5a00, 0x5a01, 0x5a02, 0x5a03, 0x5a04,   // U+af40 ~ U+af47
0x5a05, 0x5a06, 0x5a07, 0x5a08, 0x5a09, 0x5a0a, 0x5a0b, 0x5a0c,   // U+af48 ~ U+af4f
0x5a0d, 0x5a0e, 0x5a0f, 0x5a10, 0x5a11, 0x5a12, 0x5a13, 0x5a14,   // U+af50 ~ U+af57
0x5a15, 0x5a16, 0x5a17, 0x5a18, 0x5a19, 0x5a1a, 0x5a1b, 0x5a1c,   // U+af58 ~ U+af5f
0x5a1d, 0x5a1e, 0x5a1f, 0x5a20, 0x5a21, 0x5a22, 0x5a23, 0x5a24,   // U+af60 ~ U+af67
0x5a25, 0x5a26, 0x5a27, 0x5a28, 0x5a29, 0x5a2a, 0x5a2b, 0x5a2c,   // U+af68 ~ U+af6f
0x5a2d, 0x5a2e, 0x5a2f, 0x5a30, 0x5a31, 0x5a32, 0x5a33, 0x5a34,   // U+af70 ~ U+af77
0x5a35, 0x5a36, 0x5a37, 0x5a38, 0x5a39, 0x5a3a, 0x5a3b, 0x5a3c,   // U+af78 ~ U+af7f
0x5a3d, 0x5a3e, 0x5a3f, 0x5a40, 0x5a41, 0x5a42, 0x5a43, 0x5a44,   // U+af80 ~ U+af87
0x5a45, 0x5a46, 0x5a47, 0x5a48, 0x5a49, 0x5a4a, 0x5a4b, 0x5a4c,   // U+af88 ~ U+af8f
0x5a4d, 0x5a4e, 0x5a4f, 0x5a50, 0x5a51, 0x5a52, 0x5a53, 0x5a54,   // U+af90 ~ U+af97
0x5a55, 0x5a56, 0x5a57, 0x5a58, 0x5a59, 0x5a5a, 0x5a5b, 0x5a5c,   // U+af98 ~ U+af9f
0x5a5d, 0x5a5e, 0x5a5f, 0x5a60, 0x5a61, 0x5a62, 0x5a63, 0x5a64,   // U+afa0 ~ U+afa7
0x5a65, 0x5a66, 0x5a67, 0x5a68, 0x5a69, 0x5a6a, 0x5a6b, 0x5a6c,   // U+afa8 ~ U+afaf
0x5a6d, 0x5a6e, 0x5a6f, 0x5a70, 0x5a71, 0x5a72, 0x5a73, 0x5a74,   // U+afb0 ~ U+afb7
0x5a75, 0x5a76, 0x5a77, 0x5a78, 0x5a79, 0x5a7a, 0x5a7b, 0x5a7c,   // U+afb8 ~ U+afbf
0x5a7d, 0x5a7e, 0x5a7f, 0x5a80, 0x5a81, 0x5a82, 0x5a83, 0x5a84,   // U+afc0 ~ U+afc7
0x5a85, 0x5a86, 0x5a87, 0x5a88, 0x5a89, 0x5a8a, 0x5a8b, 0x5a8c,   // U+afc8 ~ U+afcf
0x5a8d, 0x5a8e, 0x5a8f, 0x5a90, 0x5a91, 0x5a92, 0x5a93, 0x5a94,   // U+afd0 ~ U+afd7
0x5a95, 0x5a96, 0x5a97, 0x5a98, 0x5a99, 0x5a9a, 0x5a9b, 0x5a9c,   // U+afd8 ~ U+afdf
0x5a9d, 0x5a9e, 0x5a9f, 0x5aa0, 0x5aa1, 0x5aa2, 0x5aa3, 0x5aa4,   // U+afe0 ~ U+afe7
0x5aa5, 0x5aa6, 0x5aa7, 0x5aa8, 0x5aa9, 0x5aaa, 0x5aab, 0x5aac,   // U+afe8 ~ U+afef
0x5aad, 0x5aae, 0x5aaf, 0x5ab0, 0x5ab1, 0x5ab2, 0x5ab3, 0x5ab4,   // U+aff0 ~ U+aff7
0x5ab5, 0x5ab6, 0x5ab7, 0x5ab8, 0x5ab9, 0x5aba, 0x5abb, 0x5abc,   // U+aff8 ~ U+afff
0x5abd, 0x5abe, 0x5abf, 0x5ac0, 0x5ac1, 0x5ac2, 0x5ac3, 0x5ac4,   // U+b000 ~ U+b007
0x5ac5, 0x5ac6, 0x5ac7, 0x5ac8, 0x5ac9, 0x5aca, 0x5acb, 0x5acc,   // U+b008 ~ U+b00f
0x5acd, 0x5ace, 0x5acf, 0x5ad0, 0x5ad1, 0x5ad2, 0x5ad3, 0x5ad4,   // U+b010 ~ U+b017
0x5ad5, 0x5ad6, 0x5ad7, 0x5ad8, 0x5ad9, 0x5ada, 0x5adb, 0x5adc,   // U+b018 ~ U+b01f
0x5add, 0x5ade, 0x5adf, 0x5ae0, 0x5ae1, 0x5ae2, 0x5ae3, 0x5ae4,   // U+b020 ~ U+b027
0x5ae5, 0x5ae6, 0x5ae7, 0x5ae8, 0x5ae9, 0x5aea, 0x5aeb, 0x5aec,   // U+b028 ~ U+b02f
0x5aed, 0x5aee, 0x5aef, 0x5af0, 0x5af1, 0x5af2, 0x5af3, 0x5af4,   // U+b030 ~ U+b037
0x5af5, 0x5af6, 0x5af7, 0x5af8, 0x5af9, 0x5afa, 0x5afb, 0x5afc,   // U+b038 ~ U+b03f
0x5afd, 0x5afe, 0x5aff, 0x5b00, 0x5b01, 0x5b02, 0x5b03, 0x5b04,   // U+b040 ~ U+b047
0x5b05, 0x5b06, 0x5b07, 0x5b08, 0x5b09, 0x5b0a, 0x5b0b, 0x5b0c,   // U+b048 ~ U+b04f
0x5b0d, 0x5b0e, 0x5b0f, 0x5b10, 0x5b11, 0x5b12, 0x5b13, 0x5b14,   // U+b050 ~ U+b057
0x5b15, 0x5b16, 0x5b17, 0x5b18, 0x5b19, 0x5b1a, 0x5b1b, 0x5b1c,   // U+b058 ~ U+b05f
0x5b1d, 0x5b1e, 0x5b1f, 0x5b20, 0x5b21, 0x5b22, 0x5b23, 0x5b24,   // U+b060 ~ U+b067
0x5b25, 0x5b26, 0x5b27, 0x5b28, 0x5b29, 0x5b2a, 0x5b2b, 0x5b2c,   // U+b068 ~ U+b06f
0x5b2d, 0x5b2e, 0x5b2f, 0x5b30, 0x5b31, 0x5b32, 0x5b33, 0x5b34,   // U+b070 ~ U+b077
0x5b35, 0x5b36, 0x5b37, 0x5b38, 0x5b39, 0x5b3a, 0x5b3b, 0x5b3c,   // U+b078 ~ U+b07f
0x5b3d, 0x5b3e, 0x5b3f, 0x5b40, 0x5b41, 0x5b42, 0x5b43, 0x5b44,   // U+b080 ~ U+b087
0x5b45, 0x5b46, 0x5b47, 0x5b48, 0x5b49, 0x5b4a, 0x5b4b, 0x5b4c,   // U+b088 ~ U+b08f
0x5b4d, 0x5b4e, 0x5b4f, 0x5b50, 0x5b51, 0x5b52, 0x5b53, 0x5b54,   // U+b090 ~ U+b097
0x5b55, 0x5b56, 0x5b57, 0x5b58, 0x5b59, 0x5b5a, 0x5b5b, 0x5b5c,   // U+b098 ~ U+b09f
0x5b5d, 0x5b5e, 0x5b5f, 0x5b60, 0x5b61, 0x5b62, 0x5b63, 0x5b64,   // U+b0a0 ~ U+b0a7
0x5b65, 0x5b66, 0x5b67, 0x5b68, 0x5b69, 0x5b6a, 0x5b6b, 0x5b6c,   // U+b0a8 ~ U+b0af
0x5b6d, 0x5b6e, 0x5b6f, 0x5b70, 0x5b71, 0x5b72, 0x5b73, 0x5b74,   // U+b0b0 ~ U+b0b7
0x5b75, 0x5b76, 0x5b77, 0x5b78, 0x5b79, 0x5b7a, 0x5b7b, 0x5b7c,   // U+b0b8 ~ U+b0bf
0x5b7d, 0x5b7e, 0x5b7f, 0x5b80, 0x5b81, 0x5b82, 0x5b83, 0x5b84,   // U+b0c0 ~ U+b0c7
0x5b85, 0x5b86, 0x5b87, 0x5b88, 0x5b89, 0x5b8a, 0x5b8b, 0x5b8c,   // U+b0c8 ~ U+b0cf
0x5b8d, 0x5b8e, 0x5b8f, 0x5b90, 0x5b91, 0x5b92, 0x5b93, 0x5b94,   // U+b0d0 ~ U+b0d7
0x5b95, 0x5b96, 0x5b97, 0x5b98, 0x5b99, 0x5b9a, 0x5b9b, 0x5b9c,   // U+b0d8 ~ U+b0df
0x5b9d, 0x5b9e, 0x5b9f, 0x5ba0, 0x5ba1, 0x5ba2, 0x5ba3, 0x5ba4,   // U+b0e0 ~ U+b0e7
0x5ba5, 0x5ba6, 0x5ba7, 0x5ba8, 0x5ba9, 0x5baa, 0x5bab, 0x5bac,   // U+b0e8 ~ U+b0ef
0x5bad, 0x5bae, 0x5baf, 0x5bb0, 0x5bb1, 0x5bb2, 0x5bb3, 0x5bb4,   // U+b0f0 ~ U+b0f7
0x5bb5, 0x5bb6, 0x5bb7, 0x5bb8, 0x5bb9, 0x5bba, 0x5bbb, 0x5bbc,   // U+b0f8 ~ U+b0ff
0x5bbd, 0x5bbe, 0x5bbf, 0x5bc0, 0x5bc1, 0x5bc2, 0x5bc3, 0x5bc4,   // U+b100 ~ U+b107
0x5bc5, 0x5bc6, 0x5bc7, 0x5bc8, 0x5bc9, 0x5bca, 0x5bcb, 0x5bcc,   // U+b108 ~ U+b10f
0x5bcd, 0x5bce, 0x5bcf, 0x5bd0, 0x5bd1, 0x5bd2, 0x5bd3, 0x5bd4,   // U+b110 ~ U+b117
0x5bd5, 0x5bd6, 0x5bd7, 0x5bd8, 0x5bd9, 0x5bda, 0x5bdb, 0x5bdc,   // U+b118 ~ U+b11f
0x5bdd, 0x5bde, 0x5bdf, 0x5be0, 0x5be1, 0x5be2, 0x5be3, 0x5be4,   // U+b120 ~ U+b127
0x5be5, 0x5be6, 0x5be7, 0x5be8, 0x5be9, 0x5bea, 0x5beb, 0x5bec,   // U+b128 ~ U+b12f
0x5bed, 0x5bee, 0x5bef, 0x5bf0, 0x5bf1, 0x5bf2, 0x5bf3, 0x5bf4,   // U+b130 ~ U+b137
0x5bf5, 0x5bf6, 0x5bf7, 0x5bf8, 0x5bf9, 0x5bfa, 0x5bfb, 0x5bfc,   // U+b138 ~ U+b13f
0x5bfd, 0x5bfe, 0x5bff, 0x5c00, 0x5c01, 0x5c02, 0x5c03, 0x5c04,   // U+b140 ~ U+b147
0x5c05, 0x5c06, 0x5c07, 0x5c08, 0x5c09, 0x5c0a, 0x5c0b, 0x5c0c,   // U+b148 ~ U+b14f
0x5c0d, 0x5c0e, 0x5c0f, 0x5c10, 0x5c11, 0x5c12, 0x5c13, 0x5c14,   // U+b150 ~ U+b157
0x5c15, 0x5c16, 0x5c17, 0x5c18, 0x5c19, 0x5c1a, 0x5c1b, 0x5c1c,   // U+b158 ~ U+b15f
0x5c1d, 0x5c1e, 0x5c1f, 0x5c20, 0x5c21, 0x5c22, 0x5c23, 0x5c24,   // U+b160 ~ U+b167
0x5c25, 0x5c26, 0x5c27, 0x5c28, 0x5c29, 0x5c2a, 0x5c2b, 0x5c2c,   // U+b168 ~ U+b16f
0x5c2d, 0x5c2e, 0x5c2f, 0x5c30, 0x5c31, 0x5c32, 0x5c33, 0x5c34,   // U+b170 ~ U+b177
0x5c35, 0x5c36, 0x5c37, 0x5c38, 0x5c39, 0x5c3a, 0x5c3b, 0x5c3c,   // U+b178 ~ U+b17f
0x5c3d, 0x5c3e, 0x5c3f, 0x5c40, 0x5c41, 0x5c42, 0x5c43, 0x5c44,   // U+b180 ~ U+b187
0x5c45, 0x5c46, 0x5c47, 0x5c48, 0x5c49, 0x5c4a, 0x5c4b, 0x5c4c,   // U+b188 ~ U+b18f
0x5c4d, 0x5c4e, 0x5c4f, 0x5c50, 0x5c51, 0x5c52, 0x5c53, 0x5c54,   // U+b190 ~ U+b197
0x5c55, 0x5c56, 0x5c57, 0x5c58, 0x5c59, 0x5c5a, 0x5c5b, 0x5c5c,   // U+b198 ~ U+b19f
0x5c5d, 0x5c5e, 0x5c5f, 0x5c60, 0x5c61, 0x5c62, 0x5c63, 0x5c64,   // U+b1a0 ~ U+b1a7
0x5c65, 0x5c66, 0x5c67, 0x5c68, 0x5c69, 0x5c6a, 0x5c6b, 0x5c6c,   // U+b1a8 ~ U+b1af
0x5c6d, 0x5c6e, 0x5c6f, 0x5c70, 0x5c71, 0x5c72, 0x5c73, 0x5c74,   // U+b1b0 ~ U+b1b7
0x5c75, 0x5c76, 0x5c77, 0x5c78, 0x5c79, 0x5c7a, 0x5c7b, 0x5c7c,   // U+b1b8 ~ U+b1bf
0x5c7d, 0x5c7e, 0x5c7f, 0x5c80, 0x5c81, 0x5c82, 0x5c83, 0x5c84,   // U+b1c0 ~ U+b1c7
0x5c85, 0x5c86, 0x5c87, 0x5c88, 0x5c89, 0x5c8a, 0x5c8b, 0x5c8c,   // U+b1c8 ~ U+b1cf
0x5c8d, 0x5c8e, 0x5c8f, 0x5c90, 0x5c91, 0x5c92, 0x5c93, 0x5c94,   // U+b1d0 ~ U+b1d7
0x5c95, 0x5c96, 0x5c97, 0x5c98, 0x5c99, 0x5c9a, 0x5c9b, 0x5c9c,   // U+b1d8 ~ U+b1df
0x5c9d, 0x5c9e, 0x5c9f, 0x5ca0, 0x5ca1, 0x5ca2, 0x5ca3, 0x5ca4,   // U+b1e0 ~ U+b1e7
0x5ca5, 0x5ca6, 0x5ca7, 0x5ca8, 0x5ca9, 0x5caa, 0x5cab, 0x5cac,   // U+b1e8 ~ U+b1ef
0x5cad, 0x5cae, 0x5caf, 0x5cb0, 0x5cb1, 0x5cb2, 0x5cb3, 0x5cb4,   // U+b1f0 ~ U+b1f7
0x5cb5, 0x5cb6, 0x5cb7, 0x5cb8, 0x5cb9, 0x5cba, 0x5cbb, 0x5cbc,   // U+b1f8 ~ U+b1ff
0x5cbd, 0x5cbe, 0x5cbf, 0x5cc0, 0x5cc1, 0x5cc2, 0x5cc3, 0x5cc4,   // U+b200 ~ U+b207
0x5cc5, 0x5cc6, 0x5cc7, 0x5cc8, 0x5cc9, 0x5cca, 0x5ccb, 0x5ccc,   // U+b208 ~ U+b20f
0x5ccd, 0x5cce, 0x5ccf, 0x5cd0, 0x5cd1, 0x5cd2, 0x5cd3, 0x5cd4,   // U+b210 ~ U+b217
0x5cd5, 0x5cd6, 0x5cd7, 0x5cd8, 0x5cd9, 0x5cda, 0x5cdb, 0x5cdc,   // U+b218 ~ U+b21f
0x5cdd, 0x5cde, 0x5cdf, 0x5ce0, 0x5ce1, 0x5ce2, 0x5ce3, 0x5ce4,   // U+b220 ~ U+b227
0x5ce5, 0x5ce6, 0x5ce7, 0x5ce8, 0x5ce9, 0x5cea, 0x5ceb, 0x5cec,   // U+b228 ~ U+b22f
0x5ced, 0x5cee, 0x5cef, 0x5cf0, 0x5cf1, 0x5cf2, 0x5cf3, 0x5cf4,   // U+b230 ~ U+b237
0x5cf5, 0x5cf6, 0x5cf7, 0x5cf8, 0x5cf9, 0x5cfa, 0x5cfb, 0x5cfc,   // U+b238 ~ U+b23f
0x5cfd, 0x5cfe, 0x5cff, 0x5d00, 0x5d01, 0x5d02, 0x5d03, 0x5d04,   // U+b240 ~ U+b247
0x5d05, 0x5d06, 0x5d07, 0x5d08, 0x5d09, 0x5d0a, 0x5d0b, 0x5d0c,   // U+b248 ~ U+b24f
0x5d0d, 0x5d0e, 0x5d0f, 0x5d10, 0x5d11, 0x5d12, 0x5d13, 0x5d14,   // U+b250 ~ U+b257
0x5d15, 0x5d16, 0x5d17, 0x5d18, 0x5d19, 0x5d1a, 0x5d1b, 0x5d1c,   // U+b258 ~ U+b25f
0x5d1d, 0x5d1e, 0x5d1f, 0x5d20, 0x5d21, 0x5d22, 0x5d23, 0x5d24,   // U+b260 ~ U+b267
0x5d25, 0x5d26, 0x5d27, 0x5d28, 0x5d29, 0x5d2a, 0x5d2b, 0x5d2c,   // U+b268 ~ U+b26f
0x5d2d, 0x5d2e, 0x5d2f, 0x5d30, 0x5d31, 0x5d32, 0x5d33, 0x5d34,   // U+b270 ~ U+b277
0x5d35, 0x5d36, 0x5d37, 0x5d38, 0x5d39, 0x5d3a, 0x5d3b, 0x5d3c,   // U+b278 ~ U+b27f
0x5d3d, 0x5d3e, 0x5d3f, 0x5d40, 0x5d41, 0x5d42, 0x5d43, 0x5d44,   // U+b280 ~ U+b287
0x5d45, 0x5d46, 0x5d47, 0x5d48, 0x5d49, 0x5d4a, 0x5d4b, 0x5d4c,   // U+b288 ~ U+b28f
0x5d4d, 0x5d4e, 0x5d4f, 0x5d50, 0x5d51, 0x5d52, 0x5d53, 0x5d54,   // U+b290 ~ U+b297
0x5d55, 0x5d56, 0x5d57, 0x5d58, 0x5d59, 0x5d5a, 0x5d5b, 0x5d5c,   // U+b298 ~ U+b29f
0x5d5d, 0x5d5e, 0x5d5f, 0x5d60, 0x5d61, 0x5d62, 0x5d63, 0x5d64,   // U+b2a0 ~ U+b2a7
0x5d65, 0x5d66, 0x5d67, 0x5d68, 0x5d69, 0x5d6a, 0x5d6b, 0x5d6c,   // U+b2a8 ~ U+b2af
0x5d6d, 0x5d6e, 0x5d6f, 0x5d70, 0x5d71, 0x5d72, 0x5d73, 0x5d74,   // U+b2b0 ~ U+b2b7
0x5d75, 0x5d76, 0x5d77, 0x5d78, 0x5d79, 0x5d7a, 0x5d7b, 0x5d7c,   // U+b2b8 ~ U+b2bf
0x5d7d, 0x5d7e, 0x5d7f, 0x5d80, 0x5d81, 0x5d82, 0x5d83, 0x5d84,   // U+b2c0 ~ U+b2c7
0x5d85, 0x5d86, 0x5d87, 0x5d88, 0x5d89, 0x5d8a, 0x5d8b, 0x5d8c,   // U+b2c8 ~ U+b2cf
0x5d8d, 0x5d8e, 0x5d8f, 0x5d90, 0x5d91, 0x5d92, 0x5d93, 0x5d94,   // U+b2d0 ~ U+b2d7
0x5d95, 0x5d96, 0x5d97, 0x5d98, 0x5d99, 0x5d9a, 0x5d9b, 0x5d9c,   // U+b2d8 ~ U+b2df
0x5d9d, 0x5d9e, 0x5d9f, 0x5da0, 0x5da1, 0x5da2, 0x5da3, 0x5da4,   // U+b2e0 ~ U+b2e7
0x5da5, 0x5da6, 0x5da7, 0x5da8, 0x5da9, 0x5daa, 0x5dab, 0x5dac,   // U+b2e8 ~ U+b2ef
0x5dad, 0x5dae, 0x5daf, 0x5db0, 0x5db1, 0x5db2, 0x5db3, 0x5db4,   // U+b2f0 ~ U+b2f7
0x5db5, 0x5db6, 0x5db7, 0x5db8, 0x5db9, 0x5dba, 0x5dbb, 0x5dbc,   // U+b2f8 ~ U+b2ff
0x5dbd, 0x5dbe, 0x5dbf, 0x5dc0, 0x5dc1, 0x5dc2, 0x5dc3, 0x5dc4,   // U+b300 ~ U+b307
0x5dc5, 0x5dc6, 0x5dc7, 0x5dc8, 0x5dc9, 0x5dca, 0x5dcb, 0x5dcc,   // U+b308 ~ U+b30f
0x5dcd, 0x5dce, 0x5dcf, 0x5dd0, 0x5dd1, 0x5dd2, 0x5dd3, 0x5dd4,   // U+b310 ~ U+b317
0x5dd5, 0x5dd6, 0x5dd7, 0x5dd8, 0x5dd9, 0x5dda, 0x5ddb, 0x5ddc,   // U+b318 ~ U+b31f
0x5ddd, 0x5dde, 0x5ddf, 0x5de0, 0x5de1, 0x5de2, 0x5de3, 0x5de4,   // U+b320 ~ U+b327
0x5de5, 0x5de6, 0x5de7, 0x5de8, 0x5de9, 0x5dea, 0x5deb, 0x5dec,   // U+b328 ~ U+b32f
0x5ded, 0x5dee, 0x5def, 0x5df0, 0x5df1, 0x5df2, 0x5df3, 0x5df4,   // U+b330 ~ U+b337
0x5df5, 0x5df6, 0x5df7, 0x5df8, 0x5df9, 0x5dfa, 0x5dfb, 0x5dfc,   // U+b338 ~ U+b33f
0x5dfd, 0x5dfe, 0x5dff, 0x5e00, 0x5e01, 0x5e02, 0x5e03, 0x5e04,   // U+b340 ~ U+b347
0x5e05, 0x5e06, 0x5e07, 0x5e08, 0x5e09, 0x5e0a, 0x5e0b, 0x5e0c,   // U+b348 ~ U+b34f
0x5e0d, 0x5e0e, 0x5e0f, 0x5e10, 0x5e11, 0x5e12, 0x5e13, 0x5e14,   // U+b350 ~ U+b357
0x5e15, 0x5e16, 0x5e17, 0x5e18, 0x5e19, 0x5e1a, 0x5e1b, 0x5e1c,   // U+b358 ~ U+b35f
0x5e1d, 0x5e1e, 0x5e1f, 0x5e20, 0x5e21, 0x5e22, 0x5e23, 0x5e24,   // U+b360 ~ U+b367
0x5e25, 0x5e26, 0x5e27, 0x5e28, 0x5e29, 0x5e2a, 0x5e2b, 0x5e2c,   // U+b368 ~ U+b36f
0x5e2d, 0x5e2e, 0x5e2f, 0x5e30, 0x5e31, 0x5e32, 0x5e33, 0x5e34,   // U+b370 ~ U+b377
0x5e35, 0x5e36, 0x5e37, 0x5e38, 0x5e39, 0x5e3a, 0x5e3b, 0x5e3c,   // U+b378 ~ U+b37f
0x5e3d, 0x5e3e, 0x5e3f, 0x5e40, 0x5e41, 0x5e42, 0x5e43, 0x5e44,   // U+b380 ~ U+b387
0x5e45, 0x5e46, 0x5e47, 0x5e48, 0x5e49, 0x5e4a, 0x5e4b, 0x5e4c,   // U+b388 ~ U+b38f
0x5e4d, 0x5e4e, 0x5e4f, 0x5e50, 0x5e51, 0x5e52, 0x5e53, 0x5e54,   // U+b390 ~ U+b397
0x5e55, 0x5e56, 0x5e57, 0x5e58, 0x5e59, 0x5e5a, 0x5e5b, 0x5e5c,   // U+b398 ~ U+b39f
0x5e5d, 0x5e5e, 0x5e5f, 0x5e60, 0x5e61, 0x5e62, 0x5e63, 0x5e64,   // U+b3a0 ~ U+b3a7
0x5e65, 0x5e66, 0x5e67, 0x5e68, 0x5e69, 0x5e6a, 0x5e6b, 0x5e6c,   // U+b3a8 ~ U+b3af
0x5e6d, 0x5e6e, 0x5e6f, 0x5e70, 0x5e71, 0x5e72, 0x5e73, 0x5e74,   // U+b3b0 ~ U+b3b7
0x5e75, 0x5e76, 0x5e77, 0x5e78, 0x5e79, 0x5e7a, 0x5e7b, 0x5e7c,   // U+b3b8 ~ U+b3bf
0x5e7d, 0x5e7e, 0x5e7f, 0x5e80, 0x5e81, 0x5e82, 0x5e83, 0x5e84,   // U+b3c0 ~ U+b3c7
0x5e85, 0x5e86, 0x5e87, 0x5e88, 0x5e89, 0x5e8a, 0x5e8b, 0x5e8c,   // U+b3c8 ~ U+b3cf
0x5e8d, 0x5e8e, 0x5e8f, 0x5e90, 0x5e91, 0x5e92, 0x5e93, 0x5e94,   // U+b3d0 ~ U+b3d7
0x5e95, 0x5e96, 0x5e97, 0x5e98, 0x5e99, 0x5e9a, 0x5e9b, 0x5e9c,   // U+b3d8 ~ U+b3df
0x5e9d, 0x5e9e, 0x5e9f, 0x5ea0, 0x5ea1, 0x5ea2, 0x5ea3, 0x5ea4,   // U+b3e0 ~ U+b3e7
0x5ea5, 0x5ea6, 0x5ea7, 0x5ea8, 0x5ea9, 0x5eaa, 0x5eab, 0x5eac,   // U+b3e8 ~ U+b3ef
0x5ead, 0x5eae, 0x5eaf, 0x5eb0, 0x5eb1, 0x5eb2, 0x5eb3, 0x5eb4,   // U+b3f0 ~ U+b3f7
0x5eb5, 0x5eb6, 0x5eb7, 0x5eb8, 0x5eb9, 0x5eba, 0x5ebb, 0x5ebc,   // U+b3f8 ~ U+b3ff
0x5ebd, 0x5ebe, 0x5ebf, 0x5ec0, 0x5ec1, 0x5ec2, 0x5ec3, 0x5ec4,   // U+b400 ~ U+b407
0x5ec5, 0x5ec6, 0x5ec7, 0x5ec8, 0x5ec9, 0x5eca, 0x5ecb, 0x5ecc,   // U+b408 ~ U+b40f
0x5ecd, 0x5ece, 0x5ecf, 0x5ed0, 0x5ed1, 0x5ed2, 0x5ed3, 0x5ed4,   // U+b410 ~ U+b417
0x5ed5, 0x5ed6, 0x5ed7, 0x5ed8, 0x5ed9, 0x5eda, 0x5edb, 0x5edc,   // U+b418 ~ U+b41f
0x5edd, 0x5ede, 0x5edf, 0x5ee0, 0x5ee1, 0x5ee2, 0x5ee3, 0x5ee4,   // U+b420 ~ U+b427
0x5ee5, 0x5ee6, 0x5ee7, 0x5ee8, 0x5ee9, 0x5eea, 0x5eeb, 0x5eec,   // U+b428 ~ U+b42f
0x5eed, 0x5eee, 0x5eef, 0x5ef0, 0x5ef1, 0x5ef2, 0x5ef3, 0x5ef4,   // U+b430 ~ U+b437
0x5ef5, 0x5ef6, 0x5ef7, 0x5ef8, 0x5ef9, 0x5efa, 0x5efb, 0x5efc,   // U+b438 ~ U+b43f
0x5efd, 0x5efe, 0x5eff, 0x5f00, 0x5f01, 0x5f02, 0x5f03, 0x5f04,   // U+b440 ~ U+b447
0x5f05, 0x5f06, 0x5f07, 0x5f08, 0x5f09, 0x5f0a, 0x5f0b, 0x5f0c,   // U+b448 ~ U+b44f
0x5f0d, 0x5f0e, 0x5f0f, 0x5f10, 0x5f11, 0x5f12, 0x5f13, 0x5f14,   // U+b450 ~ U+b457
0x5f15, 0x5f16, 0x5f17, 0x5f18, 0x5f19, 0x5f1a, 0x5f1b, 0x5f1c,   // U+b458 ~ U+b45f
0x5f1d, 0x5f1e, 0x5f1f, 0x5f20, 0x5f21, 0x5f22, 0x5f23, 0x5f24,   // U+b460 ~ U+b467
0x5f25, 0x5f26, 0x5f27, 0x5f28, 0x5f29, 0x5f2a, 0x5f2b, 0x5f2c,   // U+b468 ~ U+b46f
0x5f2d, 0x5f2e, 0x5f2f, 0x5f30, 0x5f31, 0x5f32, 0x5f33, 0x5f34,   // U+b470 ~ U+b477
0x5f35, 0x5f36, 0x5f37, 0x5f38, 0x5f39, 0x5f3a, 0x5f3b, 0x5f3c,   // U+b478 ~ U+b47f
0x5f3d, 0x5f3e, 0x5f3f, 0x5f40, 0x5f41, 0x5f42, 0x5f43, 0x5f44,   // U+b480 ~ U+b487
0x5f45, 0x5f46, 0x5f47, 0x5f48, 0x5f49, 0x5f4a, 0x5f4b, 0x5f4c,   // U+b488 ~ U+b48f
0x5f4d, 0x5f4e, 0x5f4f, 0x5f50, 0x5f51, 0x5f52, 0x5f53, 0x5f54,   // U+b490 ~ U+b497
0x5f55, 0x5f56, 0x5f57, 0x5f58, 0x5f59, 0x5f5a, 0x5f5b, 0x5f5c,   // U+b498 ~ U+b49f
0x5f5d, 0x5f5e, 0x5f5f, 0x5f60, 0x5f61, 0x5f62, 0x5f63, 0x5f64,   // U+b4a0 ~ U+b4a7
0x5f65, 0x5f66, 0x5f67, 0x5f68, 0x5f69, 0x5f6a, 0x5f6b, 0x5f6c,   // U+b4a8 ~ U+b4af
0x5f6d, 0x5f6e, 0x5f6f, 0x5f70, 0x5f71, 0x5f72, 0x5f73, 0x5f74,   // U+b4b0 ~ U+b4b7
0x5f75, 0x5f76, 0x5f77, 0x5f78, 0x5f79, 0x5f7a, 0x5f7b, 0x5f7c,   // U+b4b8 ~ U+b4bf
0x5f7d, 0x5f7e, 0x5f7f, 0x5f80, 0x5f81, 0x5f82, 0x5f83, 0x5f84,   // U+b4c0 ~ U+b4c7
0x5f85, 0x5f86, 0x5f87, 0x5f88, 0x5f89, 0x5f8a, 0x5f8b, 0x5f8c,   // U+b4c8 ~ U+b4cf
0x5f8d, 0x5f8e, 0x5f8f, 0x5f90, 0x5f91, 0x5f92, 0x5f93, 0x5f94,   // U+b4d0 ~ U+b4d7
0x5f95, 0x5f96, 0x5f97, 0x5f98, 0x5f99, 0x5f9a, 0x5f9b, 0x5f9c,   // U+b4d8 ~ U+b4df
0x5f9d, 0x5f9e, 0x5f9f, 0x5fa0, 0x5fa1, 0x5fa2, 0x5fa3, 0x5fa4,   // U+b4e0 ~ U+b4e7
0x5fa5, 0x5fa6, 0x5fa7, 0x5fa8, 0x5fa9, 0x5faa, 0x5fab, 0x5fac,   // U+b4e8 ~ U+b4ef
0x5fad, 0x5fae, 0x5faf, 0x5fb0, 0x5fb1, 0x5fb2, 0x5fb3, 0x5fb4,   // U+b4f0 ~ U+b4f7
0x5fb5, 0x5fb6, 0x5fb7, 0x5fb8, 0x5fb9, 0x5fba, 0x5fbb, 0x5fbc,   // U+b4f8 ~ U+b4ff
0x5fbd, 0x5fbe, 0x5fbf, 0x5fc0, 0x5fc1, 0x5fc2, 0x5fc3, 0x5fc4,   // U+b500 ~ U+b507
0x5fc5, 0x5fc6, 0x5fc7, 0x5fc8, 0x5fc9, 0x5fca, 0x5fcb, 0x5fcc,   // U+b508 ~ U+b50f
0x5fcd, 0x5fce, 0x5fcf, 0x5fd0, 0x5fd1, 0x5fd2, 0x5fd3, 0x5fd4,   // U+b510 ~ U+b517
0x5fd5, 0x5fd6, 0x5fd7, 0x5fd8, 0x5fd9, 0x5fda, 0x5fdb, 0x5fdc,   // U+b518 ~ U+b51f
0x5fdd, 0x5fde, 0x5fdf, 0x5fe0, 0x5fe1, 0x5fe2, 0x5fe3, 0x5fe4,   // U+b520 ~ U+b527
0x5fe5, 0x5fe6, 0x5fe7, 0x5fe8, 0x5fe9, 0x5fea, 0x5feb, 0x5fec,   // U+b528 ~ U+b52f
0x5fed, 0x5fee, 0x5fef, 0x5ff0, 0x5ff1, 0x5ff2, 0x5ff3, 0x5ff4,   // U+b530 ~ U+b537
0x5ff5, 0x5ff6, 0x5ff7, 0x5ff8, 0x5ff9, 0x5ffa, 0x5ffb, 0x5ffc,   // U+b538 ~ U+b53f
0x5ffd, 0x5ffe, 0x5fff, 0x6000, 0x6001, 0x6002, 0x6003, 0x6004,   // U+b540 ~ U+b547
0x6005, 0x6006, 0x6007, 0x6008, 0x6009, 0x600a, 0x600b, 0x600c,   // U+b548 ~ U+b54f
0x600d, 0x600e, 0x600f, 0x6010, 0x6011, 0x6012, 0x6013, 0x6014,   // U+b550 ~ U+b557
0x6015, 0x6016, 0x6017, 0x6018, 0x6019, 0x601a, 0x601b, 0x601c,   // U+b558 ~ U+b55f
0x601d, 0x601e, 0x601f, 0x6020, 0x6021, 0x6022, 0x6023, 0x6024,   // U+b560 ~ U+b567
0x6025, 0x6026, 0x6027, 0x6028, 0x6029, 0x602a, 0x602b, 0x602c,   // U+b568 ~ U+b56f
0x602d, 0x602e, 0x602f, 0x6030, 0x6031, 0x6032, 0x6033, 0x6034,   // U+b570 ~ U+b577
0x6035, 0x6036, 0x6037, 0x6038, 0x6039, 0x603a, 0x603b, 0x603c,   // U+b578 ~ U+b57f
0x603d, 0x603e, 0x603f, 0x6040, 0x6041, 0x6042, 0x6043, 0x6044,   // U+b580 ~ U+b587
0x6045, 0x6046, 0x6047, 0x6048, 0x6049, 0x604a, 0x604b, 0x604c,   // U+b588 ~ U+b58f
0x604d, 0x604e, 0x604f, 0x6050, 0x6051, 0x6052, 0x6053, 0x6054,   // U+b590 ~ U+b597
0x6055, 0x6056, 0x6057, 0x6058, 0x6059, 0x605a, 0x605b, 0x605c,   // U+b598 ~ U+b59f
0x605d, 0x605e, 0x605f, 0x6060, 0x6061, 0x6062, 0x6063, 0x6064,   // U+b5a0 ~ U+b5a7
0x6065, 0x6066, 0x6067, 0x6068, 0x6069, 0x606a, 0x606b, 0x606c,   // U+b5a8 ~ U+b5af
0x606d, 0x606e, 0x606f, 0x6070, 0x6071, 0x6072, 0x6073, 0x6074,   // U+b5b0 ~ U+b5b7
0x6075, 0x6076, 0x6077, 0x6078, 0x6079, 0x607a, 0x607b, 0x607c,   // U+b5b8 ~ U+b5bf
0x607d, 0x607e, 0x607f, 0x6080, 0x6081, 0x6082, 0x6083, 0x6084,   // U+b5c0 ~ U+b5c7
0x6085, 0x6086, 0x6087, 0x6088, 0x6089, 0x608a, 0x608b, 0x608c,   // U+b5c8 ~ U+b5cf
0x608d, 0x608e, 0x608f, 0x6090, 0x6091, 0x6092, 0x6093, 0x6094,   // U+b5d0 ~ U+b5d7
0x6095, 0x6096, 0x6097, 0x6098, 0x6099, 0x609a, 0x609b, 0x609c,   // U+b5d8 ~ U+b5df
0x609d, 0x609e, 0x609f, 0x60a0, 0x60a1, 0x60a2, 0x60a3, 0x60a4,   // U+b5e0 ~ U+b5e7
0x60a5, 0x60a6, 0x60a7, 0x60a8, 0x60a9, 0x60aa, 0x60ab, 0x60ac,   // U+b5e8 ~ U+b5ef
0x60ad, 0x60ae, 0x60af, 0x60b0, 0x60b1, 0x60b2, 0x60b3, 0x60b4,   // U+b5f0 ~ U+b5f7
0x60b5, 0x60b6, 0x60b7, 0x60b8, 0x60b9, 0x60ba, 0x60bb, 0x60bc,   // U+b5f8 ~ U+b5ff
0x60bd, 0x60be, 0x60bf, 0x60c0, 0x60c1, 0x60c2, 0x60c3, 0x60c4,   // U+b600 ~ U+b607
0x60c5, 0x60c6, 0x60c7, 0x60c8, 0x60c9, 0x60ca, 0x60cb, 0x60cc,   // U+b608 ~ U+b60f
0x60cd, 0x60ce, 0x60cf, 0x60d0, 0x60d1, 0x60d2, 0x60d3, 0x60d4,   // U+b610 ~ U+b617
0x60d5, 0x60d6, 0x60d7, 0x60d8, 0x60d9, 0x60da, 0x60db, 0x60dc,   // U+b618 ~ U+b61f
0x60dd, 0x60de, 0x60df, 0x60e0, 0x60e1, 0x60e2, 0x60e3, 0x60e4,   // U+b620 ~ U+b627
0x60e5, 0x60e6, 0x60e7, 0x60e8, 0x60e9, 0x60ea, 0x60eb, 0x60ec,   // U+b628 ~ U+b62f
0x60ed, 0x60ee, 0x60ef, 0x60f0, 0x60f1, 0x60f2, 0x60f3, 0x60f4,   // U+b630 ~ U+b637
0x60f5, 0x60f6, 0x60f7, 0x60f8, 0x60f9, 0x60fa, 0x60fb, 0x60fc,   // U+b638 ~ U+b63f
0x60fd, 0x60fe, 0x60ff, 0x6100, 0x6101, 0x6102, 0x6103, 0x6104,   // U+b640 ~ U+b647
0x6105, 0x6106, 0x6107, 0x6108, 0x6109, 0x610a, 0x610b, 0x610c,   // U+b648 ~ U+b64f
0x610d, 0x610e, 0x610f, 0x6110, 0x6111, 0x6112, 0x6113, 0x6114,   // U+b650 ~ U+b657
0x6115, 0x6116, 0x6117, 0x6118, 0x6119, 0x611a, 0x611b, 0x611c,   // U+b658 ~ U+b65f
0x611d, 0x611e, 0x611f, 0x6120, 0x6121, 0x6122, 0x6123, 0x6124,   // U+b660 ~ U+b667
0x6125, 0x6126, 0x6127, 0x6128, 0x6129, 0x612a, 0x612b, 0x612c,   // U+b668 ~ U+b66f
0x612d, 0x612e, 0x612f, 0x6130, 0x6131, 0x6132, 0x6133, 0x6134,   // U+b670 ~ U+b677
0x6135, 0x6136, 0x6137, 0x6138, 0x6139, 0x613a, 0x613b, 0x613c,   // U+b678 ~ U+b67f
0x613d, 0x613e, 0x613f, 0x6140, 0x6141, 0x6142, 0x6143, 0x6144,   // U+b680 ~ U+b687
0x6145, 0x6146, 0x6147, 0x6148, 0x6149, 0x614a, 0x614b, 0x614c,   // U+b688 ~ U+b68f
0x614d, 0x614e, 0x614f, 0x6150, 0x6151, 0x6152, 0x6153, 0x6154,   // U+b690 ~ U+b697
0x6155, 0x6156, 0x6157, 0x6158, 0x6159, 0x615a, 0x615b, 0x615c,   // U+b698 ~ U+b69f
0x615d, 0x615e, 0x615f, 0x6160, 0x6161, 0x6162, 0x6163, 0x6164,   // U+b6a0 ~ U+b6a7
0x6165, 0x6166, 0x6167, 0x6168, 0x6169, 0x616a, 0x616b, 0x616c,   // U+b6a8 ~ U+b6af
0x616d, 0x616e, 0x616f, 0x6170, 0x6171, 0x6172, 0x6173, 0x6174,   // U+b6b0 ~ U+b6b7
0x6175, 0x6176, 0x6177, 0x6178, 0x6179, 0x617a, 0x617b, 0x617c,   // U+b6b8 ~ U+b6bf
0x617d, 0x617e, 0x617f, 0x6180, 0x6181, 0x6182, 0x6183, 0x6184,   // U+b6c0 ~ U+b6c7
0x6185, 0x6186, 0x6187, 0x6188, 0x6189, 0x618a, 0x618b, 0x618c,   // U+b6c8 ~ U+b6cf
0x618d, 0x618e, 0x618f, 0x6190, 0x6191, 0x6192, 0x6193, 0x6194,   // U+b6d0 ~ U+b6d7
0x6195, 0x6196, 0x6197, 0x6198, 0x6199, 0x619a, 0x619b, 0x619c,   // U+b6d8 ~ U+b6df
0x619d, 0x619e, 0x619f, 0x61a0, 0x61a1, 0x61a2, 0x61a3, 0x61a4,   // U+b6e0 ~ U+b6e7
0x61a5, 0x61a6, 0x61a7, 0x61a8, 0x61a9, 0x61aa, 0x61ab, 0x61ac,   // U+b6e8 ~ U+b6ef
0x61ad, 0x61ae, 0x61af, 0x61b0, 0x61b1, 0x61b2, 0x61b3, 0x61b4,   // U+b6f0 ~ U+b6f7
0x61b5, 0x61b6, 0x61b7, 0x61b8, 0x61b9, 0x61ba, 0x61bb, 0x61bc,   // U+b6f8 ~ U+b6ff
0x61bd, 0x61be, 0x61bf, 0x61c0, 0x61c1, 0x61c2, 0x61c3, 0x61c4,   // U+b700 ~ U+b707
0x61c5, 0x61c6, 0x61c7, 0x61c8, 0x61c9, 0x61ca, 0x61cb, 0x61cc,   // U+b708 ~ U+b70f
0x61cd, 0x61ce, 0x61cf, 0x61d0, 0x61d1, 0x61d2, 0x61d3, 0x61d4,   // U+b710 ~ U+b717
0x61d5, 0x61d6, 0x61d7, 0x61d8, 0x61d9, 0x61da, 0x61db, 0x61dc,   // U+b718 ~ U+b71f
0x61dd, 0x61de, 0x61df, 0x61e0, 0x61e1, 0x61e2, 0x61e3, 0x61e4,   // U+b720 ~ U+b727
0x61e5, 0x61e6, 0x61e7, 0x61e8, 0x61e9, 0x61ea, 0x61eb, 0x61ec,   // U+b728 ~ U+b72f
0x61ed, 0x61ee, 0x61ef, 0x61f0, 0x61f1, 0x61f2, 0x61f3, 0x61f4,   // U+b730 ~ U+b737
0x61f5, 0x61f6, 0x61f7, 0x61f8, 0x61f9, 0x61fa, 0x61fb, 0x61fc,   // U+b738 ~ U+b73f
0x61fd, 0x61fe, 0x61ff, 0x6200, 0x6201, 0x6202, 0x6203, 0x6204,   // U+b740 ~ U+b747
0x6205, 0x6206, 0x6207, 0x6208, 0x6209, 0x620a, 0x620b, 0x620c,   // U+b748 ~ U+b74f
0x620d, 0x620e, 0x620f, 0x6210, 0x6211, 0x6212, 0x6213, 0x6214,   // U+b750 ~ U+b757
0x6215, 0x6216, 0x6217, 0x6218, 0x6219, 0x621a, 0x621b, 0x621c,   // U+b758 ~ U+b75f
0x621d, 0x621e, 0x621f, 0x6220, 0x6221, 0x6222, 0x6223, 0x6224,   // U+b760 ~ U+b767
0x6225, 0x6226, 0x6227, 0x6228, 0x6229, 0x622a, 0x622b, 0x622c,   // U+b768 ~ U+b76f
0x622d, 0x622e, 0x622f, 0x6230, 0x6231, 0x6232, 0x6233, 0x6234,   // U+b770 ~ U+b777
0x6235, 0x6236, 0x6237, 0x6238, 0x6239, 0x623a, 0x623b, 0x623c,   // U+b778 ~ U+b77f
0x623d, 0x623e, 0x623f, 0x6240, 0x6241, 0x6242, 0x6243, 0x6244,   // U+b780 ~ U+b787
0x6245, 0x6246, 0x6247, 0x6248, 0x6249, 0x624a, 0x624b, 0x624c,   // U+b788 ~ U+b78f
0x624d, 0x624e, 0x624f, 0x6250, 0x6251, 0x6252, 0x6253, 0x6254,   // U+b790 ~ U+b797
0x6255, 0x6256, 0x6257, 0x6258, 0x6259, 0x625a, 0x625b, 0x625c,   // U+b798 ~ U+b79f
0x625d, 0x625e, 0x625f, 0x6260, 0x6261, 0x6262, 0x6263, 0x6264,   // U+b7a0 ~ U+b7a7
0x6265, 0x6266, 0x6267, 0x6268, 0x6269, 0x626a, 0x626b, 0x626c,   // U+b7a8 ~ U+b7af
0x626d, 0x626e, 0x626f, 0x6270, 0x6271, 0x6272, 0x6273, 0x6274,   // U+b7b0 ~ U+b7b7
0x6275, 0x6276, 0x6277, 0x6278, 0x6279, 0x627a, 0x627b, 0x627c,   // U+b7b8 ~ U+b7bf
0x627d, 0x627e, 0x627f, 0x6280, 0x6281, 0x6282, 0x6283, 0x6284,   // U+b7c0 ~ U+b7c7
0x6285, 0x6286, 0x6287, 0x6288, 0x6289, 0x628a, 0x628b, 0x628c,   // U+b7c8 ~ U+b7cf
0x628d, 0x628e, 0x628f, 0x6290, 0x6291, 0x6292, 0x6293, 0x6294,   // U+b7d0 ~ U+b7d7
0x6295, 0x6296, 0x6297, 0x6298, 0x6299, 0x629a, 0x629b, 0x629c,   // U+b7d8 ~ U+b7df
0x629d, 0x629e, 0x629f, 0x62a0, 0x62a1, 0x62a2, 0x62a3, 0x62a4,   // U+b7e0 ~ U+b7e7
0x62a5, 0x62a6, 0x62a7, 0x62a8, 0x62a9, 0x62aa, 0x62ab, 0x62ac,   // U+b7e8 ~ U+b7ef
0x62ad, 0x62ae, 0x62af, 0x62b0, 0x62b1, 0x62b2, 0x62b3, 0x62b4,   // U+b7f0 ~ U+b7f7
0x62b5, 0x62b6, 0x62b7, 0x62b8, 0x62b9, 0x62ba, 0x62bb, 0x62bc,   // U+b7f8 ~ U+b7ff
0x62bd, 0x62be, 0x62bf, 0x62c0, 0x62c1, 0x62c2, 0x62c3, 0x62c4,   // U+b800 ~ U+b807
0x62c5, 0x62c6, 0x62c7, 0x62c8, 0x62c9, 0x62ca, 0x62cb, 0x62cc,   // U+b808 ~ U+b80f
0x62cd, 0x62ce, 0x62cf, 0x62d0, 0x62d1, 0x62d2, 0x62d3, 0x62d4,   // U+b810 ~ U+b817
0x62d5, 0x62d6, 0x62d7, 0x62d8, 0x62d9, 0x62da, 0x62db, 0x62dc,   // U+b818 ~ U+b81f
0x62dd, 0x62de, 0x62df, 0x62e0, 0x62e1, 0x62e2, 0x62e3, 0x62e4,   // U+b820 ~ U+b827
0x62e5, 0x62e6, 0x62e7, 0x62e8, 0x62e9, 0x62ea, 0x62eb, 0x62ec,   // U+b828 ~ U+b82f
0x62ed, 0x62ee, 0x62ef, 0x62f0, 0x62f1, 0x62f2, 0x62f3, 0x62f4,   // U+b830 ~ U+b837
0x62f5, 0x62f6, 0x62f7, 0x62f8, 0x62f9, 0x62fa, 0x62fb, 0x62fc,   // U+b838 ~ U+b83f
0x62fd, 0x62fe, 0x62ff, 0x6300, 0x6301, 0x6302, 0x6303, 0x6304,   // U+b840 ~ U+b847
0x6305, 0x6306, 0x6307, 0x6308, 0x6309, 0x630a, 0x630b, 0x630c,   // U+b848 ~ U+b84f
0x630d, 0x630e, 0x630f, 0x6310, 0x6311, 0x6312, 0x6313, 0x6314,   // U+b850 ~ U+b857
0x6315, 0x6316, 0x6317, 0x6318, 0x6319, 0x631a, 0x631b, 0x631c,   // U+b858 ~ U+b85f
0x631d, 0x631e, 0x631f, 0x6320, 0x6321, 0x6322, 0x6323, 0x6324,   // U+b860 ~ U+b867
0x6325, 0x6326, 0x6327, 0x6328, 0x6329, 0x632a, 0x632b, 0x632c,   // U+b868 ~ U+b86f
0x632d, 0x632e, 0x632f, 0x6330, 0x6331, 0x6332, 0x6333, 0x6334,   // U+b870 ~ U+b877
0x6335, 0x6336, 0x6337, 0x6338, 0x6339, 0x633a, 0x633b, 0x633c,   // U+b878 ~ U+b87f
0x633d, 0x633e, 0x633f, 0x6340, 0x6341, 0x6342, 0x6343, 0x6344,   // U+b880 ~ U+b887
0x6345, 0x6346, 0x6347, 0x6348, 0x6349, 0x634a, 0x634b, 0x634c,   // U+b888 ~ U+b88f
0x634d, 0x634e, 0x634f, 0x6350, 0x6351, 0x6352, 0x6353, 0x6354,   // U+b890 ~ U+b897
0x6355, 0x6356, 0x6357, 0x6358, 0x6359, 0x635a, 0x635b, 0x635c,   // U+b898 ~ U+b89f
0x635d, 0x635e, 0x635f, 0x6360, 0x6361, 0x6362, 0x6363, 0x6364,   // U+b8a0 ~ U+b8a7
0x6365, 0x6366, 0x6367, 0x6368, 0x6369, 0x636a, 0x636b, 0x636c,   // U+b8a8 ~ U+b8af
0x636d, 0x636e, 0x636f, 0x6370, 0x6371, 0x6372, 0x6373, 0x6374,   // U+b8b0 ~ U+b8b7
0x6375, 0x6376, 0x6377, 0x6378, 0x6379, 0x637a, 0x637b, 0x637c,   // U+b8b8 ~ U+b8bf
0x637d, 0x637e, 0x637f, 0x6380, 0x6381, 0x6382, 0x6383, 0x6384,   // U+b8c0 ~ U+b8c7
0x6385, 0x6386, 0x6387, 0x6388, 0x6389, 0x638a, 0x638b, 0x638c,   // U+b8c8 ~ U+b8cf
0x638d, 0x638e, 0x638f, 0x6390, 0x6391, 0x6392, 0x6393, 0x6394,   // U+b8d0 ~ U+b8d7
0x6395, 0x6396, 0x6397, 0x6398, 0x6399, 0x639a, 0x639b, 0x639c,   // U+b8d8 ~ U+b8df
0x639d, 0x639e, 0x639f, 0x63a0, 0x63a1, 0x63a2, 0x63a3, 0x63a4,   // U+b8e0 ~ U+b8e7
0x63a5, 0x63a6, 0x63a7, 0x63a8, 0x63a9, 0x63aa, 0x63ab, 0x63ac,   // U+b8e8 ~ U+b8ef
0x63ad, 0x63ae, 0x63af, 0x63b0, 0x63b1, 0x63b2, 0x63b3, 0x63b4,   // U+b8f0 ~ U+b8f7
0x63b5, 0x63b6, 0x63b7, 0x63b8, 0x63b9, 0x63ba, 0x63bb, 0x63bc,   // U+b8f8 ~ U+b8ff
0x63bd, 0x63be, 0x63bf, 0x63c0, 0x63c1, 0x63c2, 0x63c3, 0x63c4,   // U+b900 ~ U+b907
0x63c5, 0x63c6, 0x63c7, 0x63c8, 0x63c9, 0x63ca, 0x63cb, 0x63cc,   // U+b908 ~ U+b90f
0x63cd, 0x63ce, 0x63cf, 0x63d0, 0x63d1, 0x63d2, 0x63d3, 0x63d4,   // U+b910 ~ U+b917
0x63d5, 0x63d6, 0x63d7, 0x63d8, 0x63d9, 0x63da, 0x63db, 0x63dc,   // U+b918 ~ U+b91f
0x63dd, 0x63de, 0x63df, 0x63e0, 0x63e1, 0x63e2, 0x63e3, 0x63e4,   // U+b920 ~ U+b927
0x63e5, 0x63e6, 0x63e7, 0x63e8, 0x63e9, 0x63ea, 0x63eb, 0x63ec,   // U+b928 ~ U+b92f
0x63ed, 0x63ee, 0x63ef, 0x63f0, 0x63f1, 0x63f2, 0x63f3, 0x63f4,   // U+b930 ~ U+b937
0x63f5, 0x63f6, 0x63f7, 0x63f8, 0x63f9, 0x63fa, 0x63fb, 0x63fc,   // U+b938 ~ U+b93f
0x63fd, 0x63fe, 0x63ff, 0x6400, 0x6401, 0x6402, 0x6403, 0x6404,   // U+b940 ~ U+b947
0x6405, 0x6406, 0x6407, 0x6408, 0x6409, 0x640a, 0x640b, 0x640c,   // U+b948 ~ U+b94f
0x640d, 0x640e, 0x640f, 0x6410, 0x6411, 0x6412, 0x6413, 0x6414,   // U+b950 ~ U+b957
0x6415, 0x6416, 0x6417, 0x6418, 0x6419, 0x641a, 0x641b, 0x641c,   // U+b958 ~ U+b95f
0x641d, 0x641e, 0x641f, 0x6420, 0x6421, 0x6422, 0x6423, 0x6424,   // U+b960 ~ U+b967
0x6425, 0x6426, 0x6427, 0x6428, 0x6429, 0x642a, 0x642b, 0x642c,   // U+b968 ~ U+b96f
0x642d, 0x642e, 0x642f, 0x6430, 0x6431, 0x6432, 0x6433, 0x6434,   // U+b970 ~ U+b977
0x6435, 0x6436, 0x6437, 0x6438, 0x6439, 0x643a, 0x643b, 0x643c,   // U+b978 ~ U+b97f
0x643d, 0x643e, 0x643f, 0x6440, 0x6441, 0x6442, 0x6443, 0x6444,   // U+b980 ~ U+b987
0x6445, 0x6446, 0x6447, 0x6448, 0x6449, 0x644a, 0x644b, 0x644c,   // U+b988 ~ U+b98f
0x644d, 0x644e, 0x644f, 0x6450, 0x6451, 0x6452, 0x6453, 0x6454,   // U+b990 ~ U+b997
0x6455, 0x6456, 0x6457, 0x6458, 0x6459, 0x645a, 0x645b, 0x645c,   // U+b998 ~ U+b99f
0x645d, 0x645e, 0x645f, 0x6460, 0x6461, 0x6462, 0x6463, 0x6464,   // U+b9a0 ~ U+b9a7
0x6465, 0x6466, 0x6467, 0x6468, 0x6469, 0x646a, 0x646b, 0x646c,   // U+b9a8 ~ U+b9af
0x646d, 0x646e, 0x646f, 0x6470, 0x6471, 0x6472, 0x6473, 0x6474,   // U+b9b0 ~ U+b9b7
0x6475, 0x6476, 0x6477, 0x6478, 0x6479, 0x647a, 0x647b, 0x647c,   // U+b9b8 ~ U+b9bf
0x647d, 0x647e, 0x647f, 0x6480, 0x6481, 0x6482, 0x6483, 0x6484,   // U+b9c0 ~ U+b9c7
0x6485, 0x6486, 0x6487, 0x6488, 0x6489, 0x648a, 0x648b, 0x648c,   // U+b9c8 ~ U+b9cf
0x648d, 0x648e, 0x648f, 0x6490, 0x6491, 0x6492, 0x6493, 0x6494,   // U+b9d0 ~ U+b9d7
0x6495, 0x6496, 0x6497, 0x6498, 0x6499, 0x649a, 0x649b, 0x649c,   // U+b9d8 ~ U+b9df
0x649d, 0x649e, 0x649f, 0x64a0, 0x64a1, 0x64a2, 0x64a3, 0x64a4,   // U+b9e0 ~ U+b9e7
0x64a5, 0x64a6, 0x64a7, 0x64a8, 0x64a9, 0x64aa, 0x64ab, 0x64ac,   // U+b9e8 ~ U+b9ef
0x64ad, 0x64ae, 0x64af, 0x64b0, 0x64b1, 0x64b2, 0x64b3, 0x64b4,   // U+b9f0 ~ U+b9f7
0x64b5, 0x64b6, 0x64b7, 0x64b8, 0x64b9, 0x64ba, 0x64bb, 0x64bc,   // U+b9f8 ~ U+b9ff
0x64bd, 0x64be, 0x64bf, 0x64c0, 0x64c1, 0x64c2, 0x64c3, 0x64c4,   // U+ba00 ~ U+ba07
0x64c5, 0x64c6, 0x64c7, 0x64c8, 0x64c9, 0x64ca, 0x64cb, 0x64cc,   // U+ba08 ~ U+ba0f
0x64cd, 0x64ce, 0x64cf, 0x64d0, 0x64d1, 0x64d2, 0x64d3, 0x64d4,   // U+ba10 ~ U+ba17
0x64d5, 0x64d6, 0x64d7, 0x64d8, 0x64d9, 0x64da, 0x64db, 0x64dc,   // U+ba18 ~ U+ba1f
0x64dd, 0x64de, 0x64df, 0x64e0, 0x64e1, 0x64e2, 0x64e3, 0x64e4,   // U+ba20 ~ U+ba27
0x64e5, 0x64e6, 0x64e7, 0x64e8, 0x64e9, 0x64ea, 0x64eb, 0x64ec,   // U+ba28 ~ U+ba2f
0x64ed, 0x64ee, 0x64ef, 0x64f0, 0x64f1, 0x64f2, 0x64f3, 0x64f4,   // U+ba30 ~ U+ba37
0x64f5, 0x64f6, 0x64f7, 0x64f8, 0x64f9, 0x64fa, 0x64fb, 0x64fc,   // U+ba38 ~ U+ba3f
0x64fd, 0x64fe, 0x64ff, 0x6500, 0x6501, 0x6502, 0x6503, 0x6504,   // U+ba40 ~ U+ba47
0x6505, 0x6506, 0x6507, 0x6508, 0x6509, 0x650a, 0x650b, 0x650c,   // U+ba48 ~ U+ba4f
0x650d, 0x650e, 0x650f, 0x6510, 0x6511, 0x6512, 0x6513, 0x6514,   // U+ba50 ~ U+ba57
0x6515, 0x6516, 0x6517, 0x6518, 0x6519, 0x651a, 0x651b, 0x651c,   // U+ba58 ~ U+ba5f
0x651d, 0x651e, 0x651f, 0x6520, 0x6521, 0x6522, 0x6523, 0x6524,   // U+ba60 ~ U+ba67
0x6525, 0x6526, 0x6527, 0x6528, 0x6529, 0x652a, 0x652b, 0x652c,   // U+ba68 ~ U+ba6f
0x652d, 0x652e, 0x652f, 0x6530, 0x6531, 0x6532, 0x6533, 0x6534,   // U+ba70 ~ U+ba77
0x6535, 0x6536, 0x6537, 0x6538, 0x6539, 0x653a, 0x653b, 0x653c,   // U+ba78 ~ U+ba7f
0x653d, 0x653e, 0x653f, 0x6540, 0x6541, 0x6542, 0x6543, 0x6544,   // U+ba80 ~ U+ba87
0x6545, 0x6546, 0x6547, 0x6548, 0x6549, 0x654a, 0x654b, 0x654c,   // U+ba88 ~ U+ba8f
0x654d, 0x654e, 0x654f, 0x6550, 0x6551, 0x6552, 0x6553, 0x6554,   // U+ba90 ~ U+ba97
0x6555, 0x6556, 0x6557, 0x6558, 0x6559, 0x655a, 0x655b, 0x655c,   // U+ba98 ~ U+ba9f
0x655d, 0x655e, 0x655f, 0x6560, 0x6561, 0x6562, 0x6563, 0x6564,   // U+baa0 ~ U+baa7
0x6565, 0x6566, 0x6567, 0x6568, 0x6569, 0x656a, 0x656b, 0x656c,   // U+baa8 ~ U+baaf
0x656d, 0x656e, 0x656f, 0x6570, 0x6571, 0x6572, 0x6573, 0x6574,   // U+bab0 ~ U+bab7
0x6575, 0x6576, 0x6577, 0x6578, 0x6579, 0x657a, 0x657b, 0x657c,   // U+bab8 ~ U+babf
0x657d, 0x657e, 0x657f, 0x6580, 0x6581, 0x6582, 0x6583, 0x6584,   // U+bac0 ~ U+bac7
0x6585, 0x6586, 0x6587, 0x6588, 0x6589, 0x658a, 0x658b, 0x658c,   // U+bac8 ~ U+bacf
0x658d, 0x658e, 0x658f, 0x6590, 0x6591, 0x6592, 0x6593, 0x6594,   // U+bad0 ~ U+bad7
0x6595, 0x6596, 0x6597, 0x6598, 0x6599, 0x659a, 0x659b, 0x659c,   // U+bad8 ~ U+badf
0x659d, 0x659e, 0x659f, 0x65a0, 0x65a1, 0x65a2, 0x65a3, 0x65a4,   // U+bae0 ~ U+bae7
0x65a5, 0x65a6, 0x65a7, 0x65a8, 0x65a9, 0x65aa, 0x65ab, 0x65ac,   // U+bae8 ~ U+baef
0x65ad, 0x65ae, 0x65af, 0x65b0, 0x65b1, 0x65b2, 0x65b3, 0x65b4,   // U+baf0 ~ U+baf7
0x65b5, 0x65b6, 0x65b7, 0x65b8, 0x65b9, 0x65ba, 0x65bb, 0x65bc,   // U+baf8 ~ U+baff
0x65bd, 0x65be, 0x65bf, 0x65c0, 0x65c1, 0x65c2, 0x65c3, 0x65c4,   // U+bb00 ~ U+bb07
0x65c5, 0x65c6, 0x65c7, 0x65c8, 0x65c9, 0x65ca, 0x65cb, 0x65cc,   // U+bb08 ~ U+bb0f
0x65cd, 0x65ce, 0x65cf, 0x65d0, 0x65d1, 0x65d2, 0x65d3, 0x65d4,   // U+bb10 ~ U+bb17
0x65d5, 0x65d6, 0x65d7, 0x65d8, 0x65d9, 0x65da, 0x65db, 0x65dc,   // U+bb18 ~ U+bb1f
0x65dd, 0x65de, 0x65df, 0x65e0, 0x65e1, 0x65e2, 0x65e3, 0x65e4,   // U+bb20 ~ U+bb27
0x65e5, 0x65e6, 0x65e7, 0x65e8, 0x65e9, 0x65ea, 0x65eb, 0x65ec,   // U+bb28 ~ U+bb2f
0x65ed, 0x65ee, 0x65ef, 0x65f0, 0x65f1, 0x65f2, 0x65f3, 0x65f4,   // U+bb30 ~ U+bb37
0x65f5, 0x65f6, 0x65f7, 0x65f8, 0x65f9, 0x65fa, 0x65fb, 0x65fc,   // U+bb38 ~ U+bb3f
0x65fd, 0x65fe, 0x65ff, 0x6600, 0x6601, 0x6602, 0x6603, 0x6604,   // U+bb40 ~ U+bb47
0x6605, 0x6606, 0x6607, 0x6608, 0x6609, 0x660a, 0x660b, 0x660c,   // U+bb48 ~ U+bb4f
0x660d, 0x660e, 0x660f, 0x6610, 0x6611, 0x6612, 0x6613, 0x6614,   // U+bb50 ~ U+bb57
0x6615, 0x6616, 0x6617, 0x6618, 0x6619, 0x661a, 0x661b, 0x661c,   // U+bb58 ~ U+bb5f
0x661d, 0x661e, 0x661f, 0x6620, 0x6621, 0x6622, 0x6623, 0x6624,   // U+bb60 ~ U+bb67
0x6625, 0x6626, 0x6627, 0x6628, 0x6629, 0x662a, 0x662b, 0x662c,   // U+bb68 ~ U+bb6f
0x662d, 0x662e, 0x662f, 0x6630, 0x6631, 0x6632, 0x6633, 0x6634,   // U+bb70 ~ U+bb77
0x6635, 0x6636, 0x6637, 0x6638, 0x6639, 0x663a, 0x663b, 0x663c,   // U+bb78 ~ U+bb7f
0x663d, 0x663e, 0x663f, 0x6640, 0x6641, 0x6642, 0x6643, 0x6644,   // U+bb80 ~ U+bb87
0x6645, 0x6646, 0x6647, 0x6648, 0x6649, 0x664a, 0x664b, 0x664c,   // U+bb88 ~ U+bb8f
0x664d, 0x664e, 0x664f, 0x6650, 0x6651, 0x6652, 0x6653, 0x6654,   // U+bb90 ~ U+bb97
0x6655, 0x6656, 0x6657, 0x6658, 0x6659, 0x665a, 0x665b, 0x665c,   // U+bb98 ~ U+bb9f
0x665d, 0x665e, 0x665f, 0x6660, 0x6661, 0x6662, 0x6663, 0x6664,   // U+bba0 ~ U+bba7
0x6665, 0x6666, 0x6667, 0x6668, 0x6669, 0x666a, 0x666b, 0x666c,   // U+bba8 ~ U+bbaf
0x666d, 0x666e, 0x666f, 0x6670, 0x6671, 0x6672, 0x6673, 0x6674,   // U+bbb0 ~ U+bbb7
0x6675, 0x6676, 0x6677, 0x6678, 0x6679, 0x667a, 0x667b, 0x667c,   // U+bbb8 ~ U+bbbf
0x667d, 0x667e, 0x667f, 0x6680, 0x6681, 0x6682, 0x6683, 0x6684,   // U+bbc0 ~ U+bbc7
0x6685, 0x6686, 0x6687, 0x6688, 0x6689, 0x668a, 0x668b, 0x668c,   // U+bbc8 ~ U+bbcf
0x668d, 0x668e, 0x668f, 0x6690, 0x6691, 0x6692, 0x6693, 0x6694,   // U+bbd0 ~ U+bbd7
0x6695, 0x6696, 0x6697, 0x6698, 0x6699, 0x669a, 0x669b, 0x669c,   // U+bbd8 ~ U+bbdf
0x669d, 0x669e, 0x669f, 0x66a0, 0x66a1, 0x66a2, 0x66a3, 0x66a4,   // U+bbe0 ~ U+bbe7
0x66a5, 0x66a6, 0x66a7, 0x66a8, 0x66a9, 0x66aa, 0x66ab, 0x66ac,   // U+bbe8 ~ U+bbef
0x66ad, 0x66ae, 0x66af, 0x66b0, 0x66b1, 0x66b2, 0x66b3, 0x66b4,   // U+bbf0 ~ U+bbf7
0x66b5, 0x66b6, 0x66b7, 0x66b8, 0x66b9, 0x66ba, 0x66bb, 0x66bc,   // U+bbf8 ~ U+bbff
0x66bd, 0x66be, 0x66bf, 0x66c0, 0x66c1, 0x66c2, 0x66c3, 0x66c4,   // U+bc00 ~ U+bc07
0x66c5, 0x66c6, 0x66c7, 0x66c8, 0x66c9, 0x66ca, 0x66cb, 0x66cc,   // U+bc08 ~ U+bc0f
0x66cd, 0x66ce, 0x66cf, 0x66d0, 0x66d1, 0x66d2, 0x66d3, 0x66d4,   // U+bc10 ~ U+bc17
0x66d5, 0x66d6, 0x66d7, 0x66d8, 0x66d9, 0x66da, 0x66db, 0x66dc,   // U+bc18 ~ U+bc1f
0x66dd, 0x66de, 0x66df, 0x66e0, 0x66e1, 0x66e2, 0x66e3, 0x66e4,   // U+bc20 ~ U+bc27
0x66e5, 0x66e6, 0x66e7, 0x66e8, 0x66e9, 0x66ea, 0x66eb, 0x66ec,   // U+bc28 ~ U+bc2f
0x66ed, 0x66ee, 0x66ef, 0x66f0, 0x66f1, 0x66f2, 0x66f3, 0x66f4,   // U+bc30 ~ U+bc37
0x66f5, 0x66f6, 0x66f7, 0x66f8, 0x66f9, 0x66fa, 0x66fb, 0x66fc,   // U+bc38 ~ U+bc3f
0x66fd, 0x66fe, 0x66ff, 0x6700, 0x6701, 0x6702, 0x6703, 0x6704,   // U+bc40 ~ U+bc47
0x6705, 0x6706, 0x6707, 0x6708, 0x6709, 0x670a, 0x670b, 0x670c,   // U+bc48 ~ U+bc4f
0x670d, 0x670e, 0x670f, 0x6710, 0x6711, 0x6712, 0x6713, 0x6714,   // U+bc50 ~ U+bc57
0x6715, 0x6716, 0x6717, 0x6718, 0x6719, 0x671a, 0x671b, 0x671c,   // U+bc58 ~ U+bc5f
0x671d, 0x671e, 0x671f, 0x6720, 0x6721, 0x6722, 0x6723, 0x6724,   // U+bc60 ~ U+bc67
0x6725, 0x6726, 0x6727, 0x6728, 0x6729, 0x672a, 0x672b, 0x672c,   // U+bc68 ~ U+bc6f
0x672d, 0x672e, 0x672f, 0x6730, 0x6731, 0x6732, 0x6733, 0x6734,   // U+bc70 ~ U+bc77
0x6735, 0x6736, 0x6737, 0x6738, 0x6739, 0x673a, 0x673b, 0x673c,   // U+bc78 ~ U+bc7f
0x673d, 0x673e, 0x673f, 0x6740, 0x6741, 0x6742, 0x6743, 0x6744,   // U+bc80 ~ U+bc87
0x6745, 0x6746, 0x6747, 0x6748, 0x6749, 0x674a, 0x674b, 0x674c,   // U+bc88 ~ U+bc8f
0x674d, 0x674e, 0x674f, 0x6750, 0x6751, 0x6752, 0x6753, 0x6754,   // U+bc90 ~ U+bc97
0x6755, 0x6756, 0x6757, 0x6758, 0x6759, 0x675a, 0x675b, 0x675c,   // U+bc98 ~ U+bc9f
0x675d, 0x675e, 0x675f, 0x6760, 0x6761, 0x6762, 0x6763, 0x6764,   // U+bca0 ~ U+bca7
0x6765, 0x6766, 0x6767, 0x6768, 0x6769, 0x676a, 0x676b, 0x676c,   // U+bca8 ~ U+bcaf
0x676d, 0x676e, 0x676f, 0x6770, 0x6771, 0x6772, 0x6773, 0x6774,   // U+bcb0 ~ U+bcb7
0x6775, 0x6776, 0x6777, 0x6778, 0x6779, 0x677a, 0x677b, 0x677c,   // U+bcb8 ~ U+bcbf
0x677d, 0x677e, 0x677f, 0x6780, 0x6781, 0x6782, 0x6783, 0x6784,   // U+bcc0 ~ U+bcc7
0x6785, 0x6786, 0x6787, 0x6788, 0x6789, 0x678a, 0x678b, 0x678c,   // U+bcc8 ~ U+bccf
0x678d, 0x678e, 0x678f, 0x6790, 0x6791, 0x6792, 0x6793, 0x6794,   // U+bcd0 ~ U+bcd7
0x6795, 0x6796, 0x6797, 0x6798, 0x6799, 0x679a, 0x679b, 0x679c,   // U+bcd8 ~ U+bcdf
0x679d, 0x679e, 0x679f, 0x67a0, 0x67a1, 0x67a2, 0x67a3, 0x67a4,   // U+bce0 ~ U+bce7
0x67a5, 0x67a6, 0x67a7, 0x67a8, 0x67a9, 0x67aa, 0x67ab, 0x67ac,   // U+bce8 ~ U+bcef
0x67ad, 0x67ae, 0x67af, 0x67b0, 0x67b1, 0x67b2, 0x67b3, 0x67b4,   // U+bcf0 ~ U+bcf7
0x67b5, 0x67b6, 0x67b7, 0x67b8, 0x67b9, 0x67ba, 0x67bb, 0x67bc,   // U+bcf8 ~ U+bcff
0x67bd, 0x67be, 0x67bf, 0x67c0, 0x67c1, 0x67c2, 0x67c3, 0x67c4,   // U+bd00 ~ U+bd07
0x67c5, 0x67c6, 0x67c7, 0x67c8, 0x67c9, 0x67ca, 0x67cb, 0x67cc,   // U+bd08 ~ U+bd0f
0x67cd, 0x67ce, 0x67cf, 0x67d0, 0x67d1, 0x67d2, 0x67d3, 0x67d4,   // U+bd10 ~ U+bd17
0x67d5, 0x67d6, 0x67d7, 0x67d8, 0x67d9, 0x67da, 0x67db, 0x67dc,   // U+bd18 ~ U+bd1f
0x67dd, 0x67de, 0x67df, 0x67e0, 0x67e1, 0x67e2, 0x67e3, 0x67e4,   // U+bd20 ~ U+bd27
0x67e5, 0x67e6, 0x67e7, 0x67e8, 0x67e9, 0x67ea, 0x67eb, 0x67ec,   // U+bd28 ~ U+bd2f
0x67ed, 0x67ee, 0x67ef, 0x67f0, 0x67f1, 0x67f2, 0x67f3, 0x67f4,   // U+bd30 ~ U+bd37
0x67f5, 0x67f6, 0x67f7, 0x67f8, 0x67f9, 0x67fa, 0x67fb, 0x67fc,   // U+bd38 ~ U+bd3f
0x67fd, 0x67fe, 0x67ff, 0x6800, 0x6801, 0x6802, 0x6803, 0x6804,   // U+bd40 ~ U+bd47
0x6805, 0x6806, 0x6807, 0x6808, 0x6809, 0x680a, 0x680b, 0x680c,   // U+bd48 ~ U+bd4f
0x680d, 0x680e, 0x680f, 0x6810, 0x6811, 0x6812, 0x6813, 0x6814,   // U+bd50 ~ U+bd57
0x6815, 0x6816, 0x6817, 0x6818, 0x6819, 0x681a, 0x681b, 0x681c,   // U+bd58 ~ U+bd5f
0x681d, 0x681e, 0x681f, 0x6820, 0x6821, 0x6822, 0x6823, 0x6824,   // U+bd60 ~ U+bd67
0x6825, 0x6826, 0x6827, 0x6828, 0x6829, 0x682a, 0x682b, 0x682c,   // U+bd68 ~ U+bd6f
0x682d, 0x682e, 0x682f, 0x6830, 0x6831, 0x6832, 0x6833, 0x6834,   // U+bd70 ~ U+bd77
0x6835, 0x6836, 0x6837, 0x6838, 0x6839, 0x683a, 0x683b, 0x683c,   // U+bd78 ~ U+bd7f
0x683d, 0x683e, 0x683f, 0x6840, 0x6841, 0x6842, 0x6843, 0x6844,   // U+bd80 ~ U+bd87
0x6845, 0x6846, 0x6847, 0x6848, 0x6849, 0x684a, 0x684b, 0x684c,   // U+bd88 ~ U+bd8f
0x684d, 0x684e, 0x684f, 0x6850, 0x6851, 0x6852, 0x6853, 0x6854,   // U+bd90 ~ U+bd97
0x6855, 0x6856, 0x6857, 0x6858, 0x6859, 0x685a, 0x685b, 0x685c,   // U+bd98 ~ U+bd9f
0x685d, 0x685e, 0x685f, 0x6860, 0x6861, 0x6862, 0x6863, 0x6864,   // U+bda0 ~ U+bda7
0x6865, 0x6866, 0x6867, 0x6868, 0x6869, 0x686a, 0x686b, 0x686c,   // U+bda8 ~ U+bdaf
0x686d, 0x686e, 0x686f, 0x6870, 0x6871, 0x6872, 0x6873, 0x6874,   // U+bdb0 ~ U+bdb7
0x6875, 0x6876, 0x6877, 0x6878, 0x6879, 0x687a, 0x687b, 0x687c,   // U+bdb8 ~ U+bdbf
0x687d, 0x687e, 0x687f, 0x6880, 0x6881, 0x6882, 0x6883, 0x6884,   // U+bdc0 ~ U+bdc7
0x6885, 0x6886, 0x6887, 0x6888, 0x6889, 0x688a, 0x688b, 0x688c,   // U+bdc8 ~ U+bdcf
0x688d, 0x688e, 0x688f, 0x6890, 0x6891, 0x6892, 0x6893, 0x6894,   // U+bdd0 ~ U+bdd7
0x6895, 0x6896, 0x6897, 0x6898, 0x6899, 0x689a, 0x689b, 0x689c,   // U+bdd8 ~ U+bddf
0x689d, 0x689e, 0x689f, 0x68a0, 0x68a1, 0x68a2, 0x68a3, 0x68a4,   // U+bde0 ~ U+bde7
0x68a5, 0x68a6, 0x68a7, 0x68a8, 0x68a9, 0x68aa, 0x68ab, 0x68ac,   // U+bde8 ~ U+bdef
0x68ad, 0x68ae, 0x68af, 0x68b0, 0x68b1, 0x68b2, 0x68b3, 0x68b4,   // U+bdf0 ~ U+bdf7
0x68b5, 0x68b6, 0x68b7, 0x68b8, 0x68b9, 0x68ba, 0x68bb, 0x68bc,   // U+bdf8 ~ U+bdff
0x68bd, 0x68be, 0x68bf, 0x68c0, 0x68c1, 0x68c2, 0x68c3, 0x68c4,   // U+be00 ~ U+be07
0x68c5, 0x68c6, 0x68c7, 0x68c8, 0x68c9, 0x68ca, 0x68cb, 0x68cc,   // U+be08 ~ U+be0f
0x68cd, 0x68ce, 0x68cf, 0x68d0, 0x68d1, 0x68d2, 0x68d3, 0x68d4,   // U+be10 ~ U+be17
0x68d5, 0x68d6, 0x68d7, 0x68d8, 0x68d9, 0x68da, 0x68db, 0x68dc,   // U+be18 ~ U+be1f
0x68dd, 0x68de, 0x68df, 0x68e0, 0x68e1, 0x68e2, 0x68e3, 0x68e4,   // U+be20 ~ U+be27
0x68e5, 0x68e6, 0x68e7, 0x68e8, 0x68e9, 0x68ea, 0x68eb, 0x68ec,   // U+be28 ~ U+be2f
0x68ed, 0x68ee, 0x68ef, 0x68f0, 0x68f1, 0x68f2, 0x68f3, 0x68f4,   // U+be30 ~ U+be37
0x68f5, 0x68f6, 0x68f7, 0x68f8, 0x68f9, 0x68fa, 0x68fb, 0x68fc,   // U+be38 ~ U+be3f
0x68fd, 0x68fe, 0x68ff, 0x6900, 0x6901, 0x6902, 0x6903, 0x6904,   // U+be40 ~ U+be47
0x6905, 0x6906, 0x6907, 0x6908, 0x6909, 0x690a, 0x690b, 0x690c,   // U+be48 ~ U+be4f
0x690d, 0x690e, 0x690f, 0x6910, 0x6911, 0x6912, 0x6913, 0x6914,   // U+be50 ~ U+be57
0x6915, 0x6916, 0x6917, 0x6918, 0x6919, 0x691a, 0x691b, 0x691c,   // U+be58 ~ U+be5f
0x691d, 0x691e, 0x691f, 0x6920, 0x6921, 0x6922, 0x6923, 0x6924,   // U+be60 ~ U+be67
0x6925, 0x6926, 0x6927, 0x6928, 0x6929, 0x692a, 0x692b, 0x692c,   // U+be68 ~ U+be6f
0x692d, 0x692e, 0x692f, 0x6930, 0x6931, 0x6932, 0x6933, 0x6934,   // U+be70 ~ U+be77
0x6935, 0x6936, 0x6937, 0x6938, 0x6939, 0x693a, 0x693b, 0x693c,   // U+be78 ~ U+be7f
0x693d, 0x693e, 0x693f, 0x6940, 0x6941, 0x6942, 0x6943, 0x6944,   // U+be80 ~ U+be87
0x6945, 0x6946, 0x6947, 0x6948, 0x6949, 0x694a, 0x694b, 0x694c,   // U+be88 ~ U+be8f
0x694d, 0x694e, 0x694f, 0x6950, 0x6951, 0x6952, 0x6953, 0x6954,   // U+be90 ~ U+be97
0x6955, 0x6956, 0x6957, 0x6958, 0x6959, 0x695a, 0x695b, 0x695c,   // U+be98 ~ U+be9f
0x695d, 0x695e, 0x695f, 0x6960, 0x6961, 0x6962, 0x6963, 0x6964,   // U+bea0 ~ U+bea7
0x6965, 0x6966, 0x6967, 0x6968, 0x6969, 0x696a, 0x696b, 0x696c,   // U+bea8 ~ U+beaf
0x696d, 0x696e, 0x696f, 0x6970, 0x6971, 0x6972, 0x6973, 0x6974,   // U+beb0 ~ U+beb7
0x6975, 0x6976, 0x6977, 0x6978, 0x6979, 0x697a, 0x697b, 0x697c,   // U+beb8 ~ U+bebf
0x697d, 0x697e, 0x697f, 0x6980, 0x6981, 0x6982, 0x6983, 0x6984,   // U+bec0 ~ U+bec7
0x6985, 0x6986, 0x6987, 0x6988, 0x6989, 0x698a, 0x698b, 0x698c,   // U+bec8 ~ U+becf
0x698d, 0x698e, 0x698f, 0x6990, 0x6991, 0x6992, 0x6993, 0x6994,   // U+bed0 ~ U+bed7
0x6995, 0x6996, 0x6997, 0x6998, 0x6999, 0x699a, 0x699b, 0x699c,   // U+bed8 ~ U+bedf
0x699d, 0x699e, 0x699f, 0x69a0, 0x69a1, 0x69a2, 0x69a3, 0x69a4,   // U+bee0 ~ U+bee7
0x69a5, 0x69a6, 0x69a7, 0x69a8, 0x69a9, 0x69aa, 0x69ab, 0x69ac,   // U+bee8 ~ U+beef
0x69ad, 0x69ae, 0x69af, 0x69b0, 0x69b1, 0x69b2, 0x69b3, 0x69b4,   // U+bef0 ~ U+bef7
0x69b5, 0x69b6, 0x69b7, 0x69b8, 0x69b9, 0x69ba, 0x69bb, 0x69bc,   // U+bef8 ~ U+beff
0x69bd, 0x69be, 0x69bf, 0x69c0, 0x69c1, 0x69c2, 0x69c3, 0x69c4,   // U+bf00 ~ U+bf07
0x69c5, 0x69c6, 0x69c7, 0x69c8, 0x69c9, 0x69ca, 0x69cb, 0x69cc,   // U+bf08 ~ U+bf0f
0x69cd, 0x69ce, 0x69cf, 0x69d0, 0x69d1, 0x69d2, 0x69d3, 0x69d4,   // U+bf10 ~ U+bf17
0x69d5, 0x69d6, 0x69d7, 0x69d8, 0x69d9, 0x69da, 0x69db, 0x69dc,   // U+bf18 ~ U+bf1f
0x69dd, 0x69de, 0x69df, 0x69e0, 0x69e1, 0x69e2, 0x69e3, 0x69e4,   // U+bf20 ~ U+bf27
0x69e5, 0x69e6, 0x69e7, 0x69e8, 0x69e9, 0x69ea, 0x69eb, 0x69ec,   // U+bf28 ~ U+bf2f
0x69ed, 0x69ee, 0x69ef, 0x69f0, 0x69f1, 0x69f2, 0x69f3, 0x69f4,   // U+bf30 ~ U+bf37
0x69f5, 0x69f6, 0x69f7, 0x69f8, 0x69f9, 0x69fa, 0x69fb, 0x69fc,   // U+bf38 ~ U+bf3f
0x69fd, 0x69fe, 0x69ff, 0x6a00, 0x6a01, 0x6a02, 0x6a03, 0x6a04,   // U+bf40 ~ U+bf47
0x6a05, 0x6a06, 0x6a07, 0x6a08, 0x6a09, 0x6a0a, 0x6a0b, 0x6a0c,   // U+bf48 ~ U+bf4f
0x6a0d, 0x6a0e, 0x6a0f, 0x6a10, 0x6a11, 0x6a12, 0x6a13, 0x6a14,   // U+bf50 ~ U+bf57
0x6a15, 0x6a16, 0x6a17, 0x6a18, 0x6a19, 0x6a1a, 0x6a1b, 0x6a1c,   // U+bf58 ~ U+bf5f
0x6a1d, 0x6a1e, 0x6a1f, 0x6a20, 0x6a21, 0x6a22, 0x6a23, 0x6a24,   // U+bf60 ~ U+bf67
0x6a25, 0x6a26, 0x6a27, 0x6a28, 0x6a29, 0x6a2a, 0x6a2b, 0x6a2c,   // U+bf68 ~ U+bf6f
0x6a2d, 0x6a2e, 0x6a2f, 0x6a30, 0x6a31, 0x6a32, 0x6a33, 0x6a34,   // U+bf70 ~ U+bf77
0x6a35, 0x6a36, 0x6a37, 0x6a38, 0x6a39, 0x6a3a, 0x6a3b, 0x6a3c,   // U+bf78 ~ U+bf7f
0x6a3d, 0x6a3e, 0x6a3f, 0x6a40, 0x6a41, 0x6a42, 0x6a43, 0x6a44,   // U+bf80 ~ U+bf87
0x6a45, 0x6a46, 0x6a47, 0x6a48, 0x6a49, 0x6a4a, 0x6a4b, 0x6a4c,   // U+bf88 ~ U+bf8f
0x6a4d, 0x6a4e, 0x6a4f, 0x6a50, 0x6a51, 0x6a52, 0x6a53, 0x6a54,   // U+bf90 ~ U+bf97
0x6a55, 0x6a56, 0x6a57, 0x6a58, 0x6a59, 0x6a5a, 0x6a5b, 0x6a5c,   // U+bf98 ~ U+bf9f
0x6a5d, 0x6a5e, 0x6a5f, 0x6a60, 0x6a61, 0x6a62, 0x6a63, 0x6a64,   // U+bfa0 ~ U+bfa7
0x6a65, 0x6a66, 0x6a67, 0x6a68, 0x6a69, 0x6a6a, 0x6a6b, 0x6a6c,   // U+bfa8 ~ U+bfaf
0x6a6d, 0x6a6e, 0x6a6f, 0x6a70, 0x6a71, 0x6a72, 0x6a73, 0x6a74,   // U+bfb0 ~ U+bfb7
0x6a75, 0x6a76, 0x6a77, 0x6a78, 0x6a79, 0x6a7a, 0x6a7b, 0x6a7c,   // U+bfb8 ~ U+bfbf
0x6a7d, 0x6a7e, 0x6a7f, 0x6a80, 0x6a81, 0x6a82, 0x6a83, 0x6a84,   // U+bfc0 ~ U+bfc7
0x6a85, 0x6a86, 0x6a87, 0x6a88, 0x6a89, 0x6a8a, 0x6a8b, 0x6a8c,   // U+bfc8 ~ U+bfcf
0x6a8d, 0x6a8e, 0x6a8f, 0x6a90, 0x6a91, 0x6a92, 0x6a93, 0x6a94,   // U+bfd0 ~ U+bfd7
0x6a95, 0x6a96, 0x6a97, 0x6a98, 0x6a99, 0x6a9a, 0x6a9b, 0x6a9c,   // U+bfd8 ~ U+bfdf
0x6a9d, 0x6a9e, 0x6a9f, 0x6aa0, 0x6aa1, 0x6aa2, 0x6aa3, 0x6aa4,   // U+bfe0 ~ U+bfe7
0x6aa5, 0x6aa6, 0x6aa7, 0x6aa8, 0x6aa9, 0x6aaa, 0x6aab, 0x6aac,   // U+bfe8 ~ U+bfef
0x6aad, 0x6aae, 0x6aaf, 0x6ab0, 0x6ab1, 0x6ab2, 0x6ab3, 0x6ab4,   // U+bff0 ~ U+bff7
0x6ab5, 0x6ab6, 0x6ab7, 0x6ab8, 0x6ab9, 0x6aba, 0x6abb, 0x6abc,   // U+bff8 ~ U+bfff
0x6abd, 0x6abe, 0x6abf, 0x6ac0, 0x6ac1, 0x6ac2, 0x6ac3, 0x6ac4,   // U+c000 ~ U+c007
0x6ac5, 0x6ac6, 0x6ac7, 0x6ac8, 0x6ac9, 0x6aca, 0x6acb, 0x6acc,   // U+c008 ~ U+c00f
0x6acd, 0x6ace, 0x6acf, 0x6ad0, 0x6ad1, 0x6ad2, 0x6ad3, 0x6ad4,   // U+c010 ~ U+c017
0x6ad5, 0x6ad6, 0x6ad7, 0x6ad8, 0x6ad9, 0x6ada, 0x6adb, 0x6adc,   // U+c018 ~ U+c01f
0x6add, 0x6ade, 0x6adf, 0x6ae0, 0x6ae1, 0x6ae2, 0x6ae3, 0x6ae4,   // U+c020 ~ U+c027
0x6ae5, 0x6ae6, 0x6ae7, 0x6ae8, 0x6ae9, 0x6aea, 0x6aeb, 0x6aec,   // U+c028 ~ U+c02f
0x6aed, 0x6aee, 0x6aef, 0x6af0, 0x6af1, 0x6af2, 0x6af3, 0x6af4,   // U+c030 ~ U+c037
0x6af5, 0x6af6, 0x6af7, 0x6af8, 0x6af9, 0x6afa, 0x6afb, 0x6afc,   // U+c038 ~ U+c03f
0x6afd, 0x6afe, 0x6aff, 0x6b00, 0x6b01, 0x6b02, 0x6b03, 0x6b04,   // U+c040 ~ U+c047
0x6b05, 0x6b06, 0x6b07, 0x6b08, 0x6b09, 0x6b0a, 0x6b0b, 0x6b0c,   // U+c048 ~ U+c04f
0x6b0d, 0x6b0e, 0x6b0f, 0x6b10, 0x6b11, 0x6b12, 0x6b13, 0x6b14,   // U+c050 ~ U+c057
0x6b15, 0x6b16, 0x6b17, 0x6b18, 0x6b19, 0x6b1a, 0x6b1b, 0x6b1c,   // U+c058 ~ U+c05f
0x6b1d, 0x6b1e, 0x6b1f, 0x6b20, 0x6b21, 0x6b22, 0x6b23, 0x6b24,   // U+c060 ~ U+c067
0x6b25, 0x6b26, 0x6b27, 0x6b28, 0x6b29, 0x6b2a, 0x6b2b, 0x6b2c,   // U+c068 ~ U+c06f
0x6b2d, 0x6b2e, 0x6b2f, 0x6b30, 0x6b31, 0x6b32, 0x6b33, 0x6b34,   // U+c070 ~ U+c077
0x6b35, 0x6b36, 0x6b37, 0x6b38, 0x6b39, 0x6b3a, 0x6b3b, 0x6b3c,   // U+c078 ~ U+c07f
0x6b3d, 0x6b3e, 0x6b3f, 0x6b40, 0x6b41, 0x6b42, 0x6b43, 0x6b44,   // U+c080 ~ U+c087
0x6b45, 0x6b46, 0x6b47, 0x6b48, 0x6b49, 0x6b4a, 0x6b4b, 0x6b4c,   // U+c088 ~ U+c08f
0x6b4d, 0x6b4e, 0x6b4f, 0x6b50, 0x6b51, 0x6b52, 0x6b53, 0x6b54,   // U+c090 ~ U+c097
0x6b55, 0x6b56, 0x6b57, 0x6b58, 0x6b59, 0x6b5a, 0x6b5b, 0x6b5c,   // U+c098 ~ U+c09f
0x6b5d, 0x6b5e, 0x6b5f, 0x6b60, 0x6b61, 0x6b62, 0x6b63, 0x6b64,   // U+c0a0 ~ U+c0a7
0x6b65, 0x6b66, 0x6b67, 0x6b68, 0x6b69, 0x6b6a, 0x6b6b, 0x6b6c,   // U+c0a8 ~ U+c0af
0x6b6d, 0x6b6e, 0x6b6f, 0x6b70, 0x6b71, 0x6b72, 0x6b73, 0x6b74,   // U+c0b0 ~ U+c0b7
0x6b75, 0x6b76, 0x6b77, 0x6b78, 0x6b79, 0x6b7a, 0x6b7b, 0x6b7c,   // U+c0b8 ~ U+c0bf
0x6b7d, 0x6b7e, 0x6b7f, 0x6b80, 0x6b81, 0x6b82, 0x6b83, 0x6b84,   // U+c0c0 ~ U+c0c7
0x6b85, 0x6b86, 0x6b87, 0x6b88, 0x6b89, 0x6b8a, 0x6b8b, 0x6b8c,   // U+c0c8 ~ U+c0cf
0x6b8d, 0x6b8e, 0x6b8f, 0x6b90, 0x6b91, 0x6b92, 0x6b93, 0x6b94,   // U+c0d0 ~ U+c0d7
0x6b95, 0x6b96, 0x6b97, 0x6b98, 0x6b99, 0x6b9a, 0x6b9b, 0x6b9c,   // U+c0d8 ~ U+c0df
0x6b9d, 0x6b9e, 0x6b9f, 0x6ba0, 0x6ba1, 0x6ba2, 0x6ba3, 0x6ba4,   // U+c0e0 ~ U+c0e7
0x6ba5, 0x6ba6, 0x6ba7, 0x6ba8, 0x6ba9, 0x6baa, 0x6bab, 0x6bac,   // U+c0e8 ~ U+c0ef
0x6bad, 0x6bae, 0x6baf, 0x6bb0, 0x6bb1, 0x6bb2, 0x6bb3, 0x6bb4,   // U+c0f0 ~ U+c0f7
0x6bb5, 0x6bb6, 0x6bb7, 0x6bb8, 0x6bb9, 0x6bba, 0x6bbb, 0x6bbc,   // U+c0f8 ~ U+c0ff
0x6bbd, 0x6bbe, 0x6bbf, 0x6bc0, 0x6bc1, 0x6bc2, 0x6bc3, 0x6bc4,   // U+c100 ~ U+c107
0x6bc5, 0x6bc6, 0x6bc7, 0x6bc8, 0x6bc9, 0x6bca, 0x6bcb, 0x6bcc,   // U+c108 ~ U+c10f
0x6bcd, 0x6bce, 0x6bcf, 0x6bd0, 0x6bd1, 0x6bd2, 0x6bd3, 0x6bd4,   // U+c110 ~ U+c117
0x6bd5, 0x6bd6, 0x6bd7, 0x6bd8, 0x6bd9, 0x6bda, 0x6bdb, 0x6bdc,   // U+c118 ~ U+c11f
0x6bdd, 0x6bde, 0x6bdf, 0x6be0, 0x6be1, 0x6be2, 0x6be3, 0x6be4,   // U+c120 ~ U+c127
0x6be5, 0x6be6, 0x6be7, 0x6be8, 0x6be9, 0x6bea, 0x6beb, 0x6bec,   // U+c128 ~ U+c12f
0x6bed, 0x6bee, 0x6bef, 0x6bf0, 0x6bf1, 0x6bf2, 0x6bf3, 0x6bf4,   // U+c130 ~ U+c137
0x6bf5, 0x6bf6, 0x6bf7, 0x6bf8, 0x6bf9, 0x6bfa, 0x6bfb, 0x6bfc,   // U+c138 ~ U+c13f
0x6bfd, 0x6bfe, 0x6bff, 0x6c00, 0x6c01, 0x6c02, 0x6c03, 0x6c04,   // U+c140 ~ U+c147
0x6c05, 0x6c06, 0x6c07, 0x6c08, 0x6c09, 0x6c0a, 0x6c0b, 0x6c0c,   // U+c148 ~ U+c14f
0x6c0d, 0x6c0e, 0x6c0f, 0x6c10, 0x6c11, 0x6c12, 0x6c13, 0x6c14,   // U+c150 ~ U+c157
0x6c15, 0x6c16, 0x6c17, 0x6c18, 0x6c19, 0x6c1a, 0x6c1b, 0x6c1c,   // U+c158 ~ U+c15f
0x6c1d, 0x6c1e, 0x6c1f, 0x6c20, 0x6c21, 0x6c22, 0x6c23, 0x6c24,   // U+c160 ~ U+c167
0x6c25, 0x6c26, 0x6c27, 0x6c28, 0x6c29, 0x6c2a, 0x6c2b, 0x6c2c,   // U+c168 ~ U+c16f
0x6c2d, 0x6c2e, 0x6c2f, 0x6c30, 0x6c31, 0x6c32, 0x6c33, 0x6c34,   // U+c170 ~ U+c177
0x6c35, 0x6c36, 0x6c37, 0x6c38, 0x6c39, 0x6c3a, 0x6c3b, 0x6c3c,   // U+c178 ~ U+c17f
0x6c3d, 0x6c3e, 0x6c3f, 0x6c40, 0x6c41, 0x6c42, 0x6c43, 0x6c44,   // U+c180 ~ U+c187
0x6c45, 0x6c46, 0x6c47, 0x6c48, 0x6c49, 0x6c4a, 0x6c4b, 0x6c4c,   // U+c188 ~ U+c18f
0x6c4d, 0x6c4e, 0x6c4f, 0x6c50, 0x6c51, 0x6c52, 0x6c53, 0x6c54,   // U+c190 ~ U+c197
0x6c55, 0x6c56, 0x6c57, 0x6c58, 0x6c59, 0x6c5a, 0x6c5b, 0x6c5c,   // U+c198 ~ U+c19f
0x6c5d, 0x6c5e, 0x6c5f, 0x6c60, 0x6c61, 0x6c62, 0x6c63, 0x6c64,   // U+c1a0 ~ U+c1a7
0x6c65, 0x6c66, 0x6c67, 0x6c68, 0x6c69, 0x6c6a, 0x6c6b, 0x6c6c,   // U+c1a8 ~ U+c1af
0x6c6d, 0x6c6e, 0x6c6f, 0x6c70, 0x6c71, 0x6c72, 0x6c73, 0x6c74,   // U+c1b0 ~ U+c1b7
0x6c75, 0x6c76, 0x6c77, 0x6c78, 0x6c79, 0x6c7a, 0x6c7b, 0x6c7c,   // U+c1b8 ~ U+c1bf
0x6c7d, 0x6c7e, 0x6c7f, 0x6c80, 0x6c81, 0x6c82, 0x6c83, 0x6c84,   // U+c1c0 ~ U+c1c7
0x6c85, 0x6c86, 0x6c87, 0x6c88, 0x6c89, 0x6c8a, 0x6c8b, 0x6c8c,   // U+c1c8 ~ U+c1cf
0x6c8d, 0x6c8e, 0x6c8f, 0x6c90, 0x6c91, 0x6c92, 0x6c93, 0x6c94,   // U+c1d0 ~ U+c1d7
0x6c95, 0x6c96, 0x6c97, 0x6c98, 0x6c99, 0x6c9a, 0x6c9b, 0x6c9c,   // U+c1d8 ~ U+c1df
0x6c9d, 0x6c9e, 0x6c9f, 0x6ca0, 0x6ca1, 0x6ca2, 0x6ca3, 0x6ca4,   // U+c1e0 ~ U+c1e7
0x6ca5, 0x6ca6, 0x6ca7, 0x6ca8, 0x6ca9, 0x6caa, 0x6cab, 0x6cac,   // U+c1e8 ~ U+c1ef
0x6cad, 0x6cae, 0x6caf, 0x6cb0, 0x6cb1, 0x6cb2, 0x6cb3, 0x6cb4,   // U+c1f0 ~ U+c1f7
0x6cb5, 0x6cb6, 0x6cb7, 0x6cb8, 0x6cb9, 0x6cba, 0x6cbb, 0x6cbc,   // U+c1f8 ~ U+c1ff
0x6cbd, 0x6cbe, 0x6cbf, 0x6cc0, 0x6cc1, 0x6cc2, 0x6cc3, 0x6cc4,   // U+c200 ~ U+c207
0x6cc5, 0x6cc6, 0x6cc7, 0x6cc8, 0x6cc9, 0x6cca, 0x6ccb, 0x6ccc,   // U+c208 ~ U+c20f
0x6ccd, 0x6cce, 0x6ccf, 0x6cd0, 0x6cd1, 0x6cd2, 0x6cd3, 0x6cd4,   // U+c210 ~ U+c217
0x6cd5, 0x6cd6, 0x6cd7, 0x6cd8, 0x6cd9, 0x6cda, 0x6cdb, 0x6cdc,   // U+c218 ~ U+c21f
0x6cdd, 0x6cde, 0x6cdf, 0x6ce0, 0x6ce1, 0x6ce2, 0x6ce3, 0x6ce4,   // U+c220 ~ U+c227
0x6ce5, 0x6ce6, 0x6ce7, 0x6ce8, 0x6ce9, 0x6cea, 0x6ceb, 0x6cec,   // U+c228 ~ U+c22f
0x6ced, 0x6cee, 0x6cef, 0x6cf0, 0x6cf1, 0x6cf2, 0x6cf3, 0x6cf4,   // U+c230 ~ U+c237
0x6cf5, 0x6cf6, 0x6cf7, 0x6cf8, 0x6cf9, 0x6cfa, 0x6cfb, 0x6cfc,   // U+c238 ~ U+c23f
0x6cfd, 0x6cfe, 0x6cff, 0x6d00, 0x6d01, 0x6d02, 0x6d03, 0x6d04,   // U+c240 ~ U+c247
0x6d05, 0x6d06, 0x6d07, 0x6d08, 0x6d09, 0x6d0a, 0x6d0b, 0x6d0c,   // U+c248 ~ U+c24f
0x6d0d, 0x6d0e, 0x6d0f, 0x6d10, 0x6d11, 0x6d12, 0x6d13, 0x6d14,   // U+c250 ~ U+c257
0x6d15, 0x6d16, 0x6d17, 0x6d18, 0x6d19, 0x6d1a, 0x6d1b, 0x6d1c,   // U+c258 ~ U+c25f
0x6d1d, 0x6d1e, 0x6d1f, 0x6d20, 0x6d21, 0x6d22, 0x6d23, 0x6d24,   // U+c260 ~ U+c267
0x6d25, 0x6d26, 0x6d27, 0x6d28, 0x6d29, 0x6d2a, 0x6d2b, 0x6d2c,   // U+c268 ~ U+c26f
0x6d2d, 0x6d2e, 0x6d2f, 0x6d30, 0x6d31, 0x6d32, 0x6d33, 0x6d34,   // U+c270 ~ U+c277
0x6d35, 0x6d36, 0x6d37, 0x6d38, 0x6d39, 0x6d3a, 0x6d3b, 0x6d3c,   // U+c278 ~ U+c27f
0x6d3d, 0x6d3e, 0x6d3f, 0x6d40, 0x6d41, 0x6d42, 0x6d43, 0x6d44,   // U+c280 ~ U+c287
0x6d45, 0x6d46, 0x6d47, 0x6d48, 0x6d49, 0x6d4a, 0x6d4b, 0x6d4c,   // U+c288 ~ U+c28f
0x6d4d, 0x6d4e, 0x6d4f, 0x6d50, 0x6d51, 0x6d52, 0x6d53, 0x6d54,   // U+c290 ~ U+c297
0x6d55, 0x6d56, 0x6d57, 0x6d58, 0x6d59, 0x6d5a, 0x6d5b, 0x6d5c,   // U+c298 ~ U+c29f
0x6d5d, 0x6d5e, 0x6d5f, 0x6d60, 0x6d61, 0x6d62, 0x6d63, 0x6d64,   // U+c2a0 ~ U+c2a7
0x6d65, 0x6d66, 0x6d67, 0x6d68, 0x6d69, 0x6d6a, 0x6d6b, 0x6d6c,   // U+c2a8 ~ U+c2af
0x6d6d, 0x6d6e, 0x6d6f, 0x6d70, 0x6d71, 0x6d72, 0x6d73, 0x6d74,   // U+c2b0 ~ U+c2b7
0x6d75, 0x6d76, 0x6d77, 0x6d78, 0x6d79, 0x6d7a, 0x6d7b, 0x6d7c,   // U+c2b8 ~ U+c2bf
0x6d7d, 0x6d7e, 0x6d7f, 0x6d80, 0x6d81, 0x6d82, 0x6d83, 0x6d84,   // U+c2c0 ~ U+c2c7
0x6d85, 0x6d86, 0x6d87, 0x6d88, 0x6d89, 0x6d8a, 0x6d8b, 0x6d8c,   // U+c2c8 ~ U+c2cf
0x6d8d, 0x6d8e, 0x6d8f, 0x6d90, 0x6d91, 0x6d92, 0x6d93, 0x6d94,   // U+c2d0 ~ U+c2d7
0x6d95, 0x6d96, 0x6d97, 0x6d98, 0x6d99, 0x6d9a, 0x6d9b, 0x6d9c,   // U+c2d8 ~ U+c2df
0x6d9d, 0x6d9e, 0x6d9f, 0x6da0, 0x6da1, 0x6da2, 0x6da3, 0x6da4,   // U+c2e0 ~ U+c2e7
0x6da5, 0x6da6, 0x6da7, 0x6da8, 0x6da9, 0x6daa, 0x6dab, 0x6dac,   // U+c2e8 ~ U+c2ef
0x6dad, 0x6dae, 0x6daf, 0x6db0, 0x6db1, 0x6db2, 0x6db3, 0x6db4,   // U+c2f0 ~ U+c2f7
0x6db5, 0x6db6, 0x6db7, 0x6db8, 0x6db9, 0x6dba, 0x6dbb, 0x6dbc,   // U+c2f8 ~ U+c2ff
0x6dbd, 0x6dbe, 0x6dbf, 0x6dc0, 0x6dc1, 0x6dc2, 0x6dc3, 0x6dc4,   // U+c300 ~ U+c307
0x6dc5, 0x6dc6, 0x6dc7, 0x6dc8, 0x6dc9, 0x6dca, 0x6dcb, 0x6dcc,   // U+c308 ~ U+c30f
0x6dcd, 0x6dce, 0x6dcf, 0x6dd0, 0x6dd1, 0x6dd2, 0x6dd3, 0x6dd4,   // U+c310 ~ U+c317
0x6dd5, 0x6dd6, 0x6dd7, 0x6dd8, 0x6dd9, 0x6dda, 0x6ddb, 0x6ddc,   // U+c318 ~ U+c31f
0x6ddd, 0x6dde, 0x6ddf, 0x6de0, 0x6de1, 0x6de2, 0x6de3, 0x6de4,   // U+c320 ~ U+c327
0x6de5, 0x6de6, 0x6de7, 0x6de8, 0x6de9, 0x6dea, 0x6deb, 0x6dec,   // U+c328 ~ U+c32f
0x6ded, 0x6dee, 0x6def, 0x6df0, 0x6df1, 0x6df2, 0x6df3, 0x6df4,   // U+c330 ~ U+c337
0x6df5, 0x6df6, 0x6df7, 0x6df8, 0x6df9, 0x6dfa, 0x6dfb, 0x6dfc,   // U+c338 ~ U+c33f
0x6dfd, 0x6dfe, 0x6dff, 0x6e00, 0x6e01, 0x6e02, 0x6e03, 0x6e04,   // U+c340 ~ U+c347
0x6e05, 0x6e06, 0x6e07, 0x6e08, 0x6e09, 0x6e0a, 0x6e0b, 0x6e0c,   // U+c348 ~ U+c34f
0x6e0d, 0x6e0e, 0x6e0f, 0x6e10, 0x6e11, 0x6e12, 0x6e13, 0x6e14,   // U+c350 ~ U+c357
0x6e15, 0x6e16, 0x6e17, 0x6e18, 0x6e19, 0x6e1a, 0x6e1b, 0x6e1c,   // U+c358 ~ U+c35f
0x6e1d, 0x6e1e, 0x6e1f, 0x6e20, 0x6e21, 0x6e22, 0x6e23, 0x6e24,   // U+c360 ~ U+c367
0x6e25, 0x6e26, 0x6e27, 0x6e28, 0x6e29, 0x6e2a, 0x6e2b, 0x6e2c,   // U+c368 ~ U+c36f
0x6e2d, 0x6e2e, 0x6e2f, 0x6e30, 0x6e31, 0x6e32, 0x6e33, 0x6e34,   // U+c370 ~ U+c377
0x6e35, 0x6e36, 0x6e37, 0x6e38, 0x6e39, 0x6e3a, 0x6e3b, 0x6e3c,   // U+c378 ~ U+c37f
0x6e3d, 0x6e3e, 0x6e3f, 0x6e40, 0x6e41, 0x6e42, 0x6e43, 0x6e44,   // U+c380 ~ U+c387
0x6e45, 0x6e46, 0x6e47, 0x6e48, 0x6e49, 0x6e4a, 0x6e4b, 0x6e4c,   // U+c388 ~ U+c38f
0x6e4d, 0x6e4e, 0x6e4f, 0x6e50, 0x6e51, 0x6e52, 0x6e53, 0x6e54,   // U+c390 ~ U+c397
0x6e55, 0x6e56, 0x6e57, 0x6e58, 0x6e59, 0x6e5a, 0x6e5b, 0x6e5c,   // U+c398 ~ U+c39f
0x6e5d, 0x6e5e, 0x6e5f, 0x6e60, 0x6e61, 0x6e62, 0x6e63, 0x6e64,   // U+c3a0 ~ U+c3a7
0x6e65, 0x6e66, 0x6e67, 0x6e68, 0x6e69, 0x6e6a, 0x6e6b, 0x6e6c,   // U+c3a8 ~ U+c3af
0x6e6d, 0x6e6e, 0x6e6f, 0x6e70, 0x6e71, 0x6e72, 0x6e73, 0x6e74,   // U+c3b0 ~ U+c3b7
0x6e75, 0x6e76, 0x6e77, 0x6e78, 0x6e79, 0x6e7a, 0x6e7b, 0x6e7c,   // U+c3b8 ~ U+c3bf
0x6e7d, 0x6e7e, 0x6e7f, 0x6e80, 0x6e81, 0x6e82, 0x6e83, 0x6e84,   // U+c3c0 ~ U+c3c7
0x6e85, 0x6e86, 0x6e87, 0x6e88, 0x6e89, 0x6e8a, 0x6e8b, 0x6e8c,   // U+c3c8 ~ U+c3cf
0x6e8d, 0x6e8e, 0x6e8f, 0x6e90, 0x6e91, 0x6e92, 0x6e93, 0x6e94,   // U+c3d0 ~ U+c3d7
0x6e95, 0x6e96, 0x6e97, 0x6e98, 0x6e99, 0x6e9a, 0x6e9b, 0x6e9c,   // U+c3d8 ~ U+c3df
0x6e9d, 0x6e9e, 0x6e9f, 0x6ea0, 0x6ea1, 0x6ea2, 0x6ea3, 0x6ea4,   // U+c3e0 ~ U+c3e7
0x6ea5, 0x6ea6, 0x6ea7, 0x6ea8, 0x6ea9, 0x6eaa, 0x6eab, 0x6eac,   // U+c3e8 ~ U+c3ef
0x6ead, 0x6eae, 0x6eaf, 0x6eb0, 0x6eb1, 0x6eb2, 0x6eb3, 0x6eb4,   // U+c3f0 ~ U+c3f7
0x6eb5, 0x6eb6, 0x6eb7, 0x6eb8, 0x6eb9, 0x6eba, 0x6ebb, 0x6ebc,   // U+c3f8 ~ U+c3ff
0x6ebd, 0x6ebe, 0x6ebf, 0x6ec0, 0x6ec1, 0x6ec2, 0x6ec3, 0x6ec4,   // U+c400 ~ U+c407
0x6ec5, 0x6ec6, 0x6ec7, 0x6ec8, 0x6ec9, 0x6eca, 0x6ecb, 0x6ecc,   // U+c408 ~ U+c40f
0x6ecd, 0x6ece, 0x6ecf, 0x6ed0, 0x6ed1, 0x6ed2, 0x6ed3, 0x6ed4,   // U+c410 ~ U+c417
0x6ed5, 0x6ed6, 0x6ed7, 0x6ed8, 0x6ed9, 0x6eda, 0x6edb, 0x6edc,   // U+c418 ~ U+c41f
0x6edd, 0x6ede, 0x6edf, 0x6ee0, 0x6ee1, 0x6ee2, 0x6ee3, 0x6ee4,   // U+c420 ~ U+c427
0x6ee5, 0x6ee6, 0x6ee7, 0x6ee8, 0x6ee9, 0x6eea, 0x6eeb, 0x6eec,   // U+c428 ~ U+c42f
0x6eed, 0x6eee, 0x6eef, 0x6ef0, 0x6ef1, 0x6ef2, 0x6ef3, 0x6ef4,   // U+c430 ~ U+c437
0x6ef5, 0x6ef6, 0x6ef7, 0x6ef8, 0x6ef9, 0x6efa, 0x6efb, 0x6efc,   // U+c438 ~ U+c43f
0x6efd, 0x6efe, 0x6eff, 0x6f00, 0x6f01, 0x6f02, 0x6f03, 0x6f04,   // U+c440 ~ U+c447
0x6f05, 0x6f06, 0x6f07, 0x6f08, 0x6f09, 0x6f0a, 0x6f0b, 0x6f0c,   // U+c448 ~ U+c44f
0x6f0d, 0x6f0e, 0x6f0f, 0x6f10, 0x6f11, 0x6f12, 0x6f13, 0x6f14,   // U+c450 ~ U+c457
0x6f15, 0x6f16, 0x6f17, 0x6f18, 0x6f19, 0x6f1a, 0x6f1b, 0x6f1c,   // U+c458 ~ U+c45f
0x6f1d, 0x6f1e, 0x6f1f, 0x6f20, 0x6f21, 0x6f22, 0x6f23, 0x6f24,   // U+c460 ~ U+c467
0x6f25, 0x6f26, 0x6f27, 0x6f28, 0x6f29, 0x6f2a, 0x6f2b, 0x6f2c,   // U+c468 ~ U+c46f
0x6f2d, 0x6f2e, 0x6f2f, 0x6f30, 0x6f31, 0x6f32, 0x6f33, 0x6f34,   // U+c470 ~ U+c477
0x6f35, 0x6f36, 0x6f37, 0x6f38, 0x6f39, 0x6f3a, 0x6f3b, 0x6f3c,   // U+c478 ~ U+c47f
0x6f3d, 0x6f3e, 0x6f3f, 0x6f40, 0x6f41, 0x6f42, 0x6f43, 0x6f44,   // U+c480 ~ U+c487
0x6f45, 0x6f46, 0x6f47, 0x6f48, 0x6f49, 0x6f4a, 0x6f4b, 0x6f4c,   // U+c488 ~ U+c48f
0x6f4d, 0x6f4e, 0x6f4f, 0x6f50, 0x6f51, 0x6f52, 0x6f53, 0x6f54,   // U+c490 ~ U+c497
0x6f55, 0x6f56, 0x6f57, 0x6f58, 0x6f59, 0x6f5a, 0x6f5b, 0x6f5c,   // U+c498 ~ U+c49f
0x6f5d, 0x6f5e, 0x6f5f, 0x6f60, 0x6f61, 0x6f62, 0x6f63, 0x6f64,   // U+c4a0 ~ U+c4a7
0x6f65, 0x6f66, 0x6f67, 0x6f68, 0x6f69, 0x6f6a, 0x6f6b, 0x6f6c,   // U+c4a8 ~ U+c4af
0x6f6d, 0x6f6e, 0x6f6f, 0x6f70, 0x6f71, 0x6f72, 0x6f73, 0x6f74,   // U+c4b0 ~ U+c4b7
0x6f75, 0x6f76, 0x6f77, 0x6f78, 0x6f79, 0x6f7a, 0x6f7b, 0x6f7c,   // U+c4b8 ~ U+c4bf
0x6f7d, 0x6f7e, 0x6f7f, 0x6f80, 0x6f81, 0x6f82, 0x6f83, 0x6f84,   // U+c4c0 ~ U+c4c7
0x6f85, 0x6f86, 0x6f87, 0x6f88, 0x6f89, 0x6f8a, 0x6f8b, 0x6f8c,   // U+c4c8 ~ U+c4cf
0x6f8d, 0x6f8e, 0x6f8f, 0x6f90, 0x6f91, 0x6f92, 0x6f93, 0x6f94,   // U+c4d0 ~ U+c4d7
0x6f95, 0x6f96, 0x6f97, 0x6f98, 0x6f99, 0x6f9a, 0x6f9b, 0x6f9c,   // U+c4d8 ~ U+c4df
0x6f9d, 0x6f9e, 0x6f9f, 0x6fa0, 0x6fa1, 0x6fa2, 0x6fa3, 0x6fa4,   // U+c4e0 ~ U+c4e7
0x6fa5, 0x6fa6, 0x6fa7, 0x6fa8, 0x6fa9, 0x6faa, 0x6fab, 0x6fac,   // U+c4e8 ~ U+c4ef
0x6fad, 0x6fae, 0x6faf, 0x6fb0, 0x6fb1, 0x6fb2, 0x6fb3, 0x6fb4,   // U+c4f0 ~ U+c4f7
0x6fb5, 0x6fb6, 0x6fb7, 0x6fb8, 0x6fb9, 0x6fba, 0x6fbb, 0x6fbc,   // U+c4f8 ~ U+c4ff
0x6fbd, 0x6fbe, 0x6fbf, 0x6fc0, 0x6fc1, 0x6fc2, 0x6fc3, 0x6fc4,   // U+c500 ~ U+c507
0x6fc5, 0x6fc6, 0x6fc7, 0x6fc8, 0x6fc9, 0x6fca, 0x6fcb, 0x6fcc,   // U+c508 ~ U+c50f
0x6fcd, 0x6fce, 0x6fcf, 0x6fd0, 0x6fd1, 0x6fd2, 0x6fd3, 0x6fd4,   // U+c510 ~ U+c517
0x6fd5, 0x6fd6, 0x6fd7, 0x6fd8, 0x6fd9, 0x6fda, 0x6fdb, 0x6fdc,   // U+c518 ~ U+c51f
0x6fdd, 0x6fde, 0x6fdf, 0x6fe0, 0x6fe1, 0x6fe2, 0x6fe3, 0x6fe4,   // U+c520 ~ U+c527
0x6fe5, 0x6fe6, 0x6fe7, 0x6fe8, 0x6fe9, 0x6fea, 0x6feb, 0x6fec,   // U+c528 ~ U+c52f
0x6fed, 0x6fee, 0x6fef, 0x6ff0, 0x6ff1, 0x6ff2, 0x6ff3, 0x6ff4,   // U+c530 ~ U+c537
0x6ff5, 0x6ff6, 0x6ff7, 0x6ff8, 0x6ff9, 0x6ffa, 0x6ffb, 0x6ffc,   // U+c538 ~ U+c53f
0x6ffd, 0x6ffe, 0x6fff, 0x7000, 0x7001, 0x7002, 0x7003, 0x7004,   // U+c540 ~ U+c547
0x7005, 0x7006, 0x7007, 0x7008, 0x7009, 0x700a, 0x700b, 0x700c,   // U+c548 ~ U+c54f
0x700d, 0x700e, 0x700f, 0x7010, 0x7011, 0x7012, 0x7013, 0x7014,   // U+c550 ~ U+c557
0x7015, 0x7016, 0x7017, 0x7018, 0x7019, 0x701a, 0x701b, 0x701c,   // U+c558 ~ U+c55f
0x701d, 0x701e, 0x701f, 0x7020, 0x7021, 0x7022, 0x7023, 0x7024,   // U+c560 ~ U+c567
0x7025, 0x7026, 0x7027, 0x7028, 0x7029, 0x702a, 0x702b, 0x702c,   // U+c568 ~ U+c56f
0x702d, 0x702e, 0x702f, 0x7030, 0x7031, 0x7032, 0x7033, 0x7034,   // U+c570 ~ U+c577
0x7035, 0x7036, 0x7037, 0x7038, 0x7039, 0x703a, 0x703b, 0x703c,   // U+c578 ~ U+c57f
0x703d, 0x703e, 0x703f, 0x7040, 0x7041, 0x7042, 0x7043, 0x7044,   // U+c580 ~ U+c587
0x7045, 0x7046, 0x7047, 0x7048, 0x7049, 0x704a, 0x704b, 0x704c,   // U+c588 ~ U+c58f
0x704d, 0x704e, 0x704f, 0x7050, 0x7051, 0x7052, 0x7053, 0x7054,   // U+c590 ~ U+c597
0x7055, 0x7056, 0x7057, 0x7058, 0x7059, 0x705a, 0x705b, 0x705c,   // U+c598 ~ U+c59f
0x705d, 0x705e, 0x705f, 0x7060, 0x7061, 0x7062, 0x7063, 0x7064,   // U+c5a0 ~ U+c5a7
0x7065, 0x7066, 0x7067, 0x7068, 0x7069, 0x706a, 0x706b, 0x706c,   // U+c5a8 ~ U+c5af
0x706d, 0x706e, 0x706f, 0x7070, 0x7071, 0x7072, 0x7073, 0x7074,   // U+c5b0 ~ U+c5b7
0x7075, 0x7076, 0x7077, 0x7078, 0x7079, 0x707a, 0x707b, 0x707c,   // U+c5b8 ~ U+c5bf
0x707d, 0x707e, 0x707f, 0x7080, 0x7081, 0x7082, 0x7083, 0x7084,   // U+c5c0 ~ U+c5c7
0x7085, 0x7086, 0x7087, 0x7088, 0x7089, 0x708a, 0x708b, 0x708c,   // U+c5c8 ~ U+c5cf
0x708d, 0x708e, 0x708f, 0x7090, 0x7091, 0x7092, 0x7093, 0x7094,   // U+c5d0 ~ U+c5d7
0x7095, 0x7096, 0x7097, 0x7098, 0x7099, 0x709a, 0x709b, 0x709c,   // U+c5d8 ~ U+c5df
0x709d, 0x709e, 0x709f, 0x70a0, 0x70a1, 0x70a2, 0x70a3, 0x70a4,   // U+c5e0 ~ U+c5e7
0x70a5, 0x70a6, 0x70a7, 0x70a8, 0x70a9, 0x70aa, 0x70ab, 0x70ac,   // U+c5e8 ~ U+c5ef
0x70ad, 0x70ae, 0x70af, 0x70b0, 0x70b1, 0x70b2, 0x70b3, 0x70b4,   // U+c5f0 ~ U+c5f7
0x70b5, 0x70b6, 0x70b7, 0x70b8, 0x70b9, 0x70ba, 0x70bb, 0x70bc,   // U+c5f8 ~ U+c5ff
0x70bd, 0x70be, 0x70bf, 0x70c0, 0x70c1, 0x70c2, 0x70c3, 0x70c4,   // U+c600 ~ U+c607
0x70c5, 0x70c6, 0x70c7, 0x70c8, 0x70c9, 0x70ca, 0x70cb, 0x70cc,   // U+c608 ~ U+c60f
0x70cd, 0x70ce, 0x70cf, 0x70d0, 0x70d1, 0x70d2, 0x70d3, 0x70d4,   // U+c610 ~ U+c617
0x70d5, 0x70d6, 0x70d7, 0x70d8, 0x70d9, 0x70da, 0x70db, 0x70dc,   // U+c618 ~ U+c61f
0x70dd, 0x70de, 0x70df, 0x70e0, 0x70e1, 0x70e2, 0x70e3, 0x70e4,   // U+c620 ~ U+c627
0x70e5, 0x70e6, 0x70e7, 0x70e8, 0x70e9, 0x70ea, 0x70eb, 0x70ec,   // U+c628 ~ U+c62f
0x70ed, 0x70ee, 0x70ef, 0x70f0, 0x70f1, 0x70f2, 0x70f3, 0x70f4,   // U+c630 ~ U+c637
0x70f5, 0x70f6, 0x70f7, 0x70f8, 0x70f9, 0x70fa, 0x70fb, 0x70fc,   // U+c638 ~ U+c63f
0x70fd, 0x70fe, 0x70ff, 0x7100, 0x7101, 0x7102, 0x7103, 0x7104,   // U+c640 ~ U+c647
0x7105, 0x7106, 0x7107, 0x7108, 0x7109, 0x710a, 0x710b, 0x710c,   // U+c648 ~ U+c64f
0x710d, 0x710e, 0x710f, 0x7110, 0x7111, 0x7112, 0x7113, 0x7114,   // U+c650 ~ U+c657
0x7115, 0x7116, 0x7117, 0x7118, 0x7119, 0x711a, 0x711b, 0x711c,   // U+c658 ~ U+c65f
0x711d, 0x711e, 0x711f, 0x7120, 0x7121, 0x7122, 0x7123, 0x7124,   // U+c660 ~ U+c667
0x7125, 0x7126, 0x7127, 0x7128, 0x7129, 0x712a, 0x712b, 0x712c,   // U+c668 ~ U+c66f
0x712d, 0x712e, 0x712f, 0x7130, 0x7131, 0x7132, 0x7133, 0x7134,   // U+c670 ~ U+c677
0x7135, 0x7136, 0x7137, 0x7138, 0x7139, 0x713a, 0x713b, 0x713c,   // U+c678 ~ U+c67f
0x713d, 0x713e, 0x713f, 0x7140, 0x7141, 0x7142, 0x7143, 0x7144,   // U+c680 ~ U+c687
0x7145, 0x7146, 0x7147, 0x7148, 0x7149, 0x714a, 0x714b, 0x714c,   // U+c688 ~ U+c68f
0x714d, 0x714e, 0x714f, 0x7150, 0x7151, 0x7152, 0x7153, 0x7154,   // U+c690 ~ U+c697
0x7155, 0x7156, 0x7157, 0x7158, 0x7159, 0x715a, 0x715b, 0x715c,   // U+c698 ~ U+c69f
0x715d, 0x715e, 0x715f, 0x7160, 0x7161, 0x7162, 0x7163, 0x7164,   // U+c6a0 ~ U+c6a7
0x7165, 0x7166, 0x7167, 0x7168, 0x7169, 0x716a, 0x716b, 0x716c,   // U+c6a8 ~ U+c6af
0x716d, 0x716e, 0x716f, 0x7170, 0x7171, 0x7172, 0x7173, 0x7174,   // U+c6b0 ~ U+c6b7
0x7175, 0x7176, 0x7177, 0x7178, 0x7179, 0x717a, 0x717b, 0x717c,   // U+c6b8 ~ U+c6bf
0x717d, 0x717e, 0x717f, 0x7180, 0x7181, 0x7182, 0x7183, 0x7184,   // U+c6c0 ~ U+c6c7
0x7185, 0x7186, 0x7187, 0x7188, 0x7189, 0x718a, 0x718b, 0x718c,   // U+c6c8 ~ U+c6cf
0x718d, 0x718e, 0x718f, 0x7190, 0x7191, 0x7192, 0x7193, 0x7194,   // U+c6d0 ~ U+c6d7
0x7195, 0x7196, 0x7197, 0x7198, 0x7199, 0x719a, 0x719b, 0x719c,   // U+c6d8 ~ U+c6df
0x719d, 0x719e, 0x719f, 0x71a0, 0x71a1, 0x71a2, 0x71a3, 0x71a4,   // U+c6e0 ~ U+c6e7
0x71a5, 0x71a6, 0x71a7, 0x71a8, 0x71a9, 0x71aa, 0x71ab, 0x71ac,   // U+c6e8 ~ U+c6ef
0x71ad, 0x71ae, 0x71af, 0x71b0, 0x71b1, 0x71b2, 0x71b3, 0x71b4,   // U+c6f0 ~ U+c6f7
0x71b5, 0x71b6, 0x71b7, 0x71b8, 0x71b9, 0x71ba, 0x71bb, 0x71bc,   // U+c6f8 ~ U+c6ff
0x71bd, 0x71be, 0x71bf, 0x71c0, 0x71c1, 0x71c2, 0x71c3, 0x71c4,   // U+c700 ~ U+c707
0x71c5, 0x71c6, 0x71c7, 0x71c8, 0x71c9, 0x71ca, 0x71cb, 0x71cc,   // U+c708 ~ U+c70f
0x71cd, 0x71ce, 0x71cf, 0x71d0, 0x71d1, 0x71d2, 0x71d3, 0x71d4,   // U+c710 ~ U+c717
0x71d5, 0x71d6, 0x71d7, 0x71d8, 0x71d9, 0x71da, 0x71db, 0x71dc,   // U+c718 ~ U+c71f
0x71dd, 0x71de, 0x71df, 0x71e0, 0x71e1, 0x71e2, 0x71e3, 0x71e4,   // U+c720 ~ U+c727
0x71e5, 0x71e6, 0x71e7, 0x71e8, 0x71e9, 0x71ea, 0x71eb, 0x71ec,   // U+c728 ~ U+c72f
0x71ed, 0x71ee, 0x71ef, 0x71f0, 0x71f1, 0x71f2, 0x71f3, 0x71f4,   // U+c730 ~ U+c737
0x71f5, 0x71f6, 0x71f7, 0x71f8, 0x71f9, 0x71fa, 0x71fb, 0x71fc,   // U+c738 ~ U+c73f
0x71fd, 0x71fe, 0x71ff, 0x7200, 0x7201, 0x7202, 0x7203, 0x7204,   // U+c740 ~ U+c747
0x7205, 0x7206, 0x7207, 0x7208, 0x7209, 0x720a, 0x720b, 0x720c,   // U+c748 ~ U+c74f
0x720d, 0x720e, 0x720f, 0x7210, 0x7211, 0x7212, 0x7213, 0x7214,   // U+c750 ~ U+c757
0x7215, 0x7216, 0x7217, 0x7218, 0x7219, 0x721a, 0x721b, 0x721c,   // U+c758 ~ U+c75f
0x721d, 0x721e, 0x721f, 0x7220, 0x7221, 0x7222, 0x7223, 0x7224,   // U+c760 ~ U+c767
0x7225, 0x7226, 0x7227, 0x7228, 0x7229, 0x722a, 0x722b, 0x722c,   // U+c768 ~ U+c76f
0x722d, 0x722e, 0x722f, 0x7230, 0x7231, 0x7232, 0x7233, 0x7234,   // U+c770 ~ U+c777
0x7235, 0x7236, 0x7237, 0x7238, 0x7239, 0x723a, 0x723b, 0x723c,   // U+c778 ~ U+c77f
0x723d, 0x723e, 0x723f, 0x7240, 0x7241, 0x7242, 0x7243, 0x7244,   // U+c780 ~ U+c787
0x7245, 0x7246, 0x7247, 0x7248, 0x7249, 0x724a, 0x724b, 0x724c,   // U+c788 ~ U+c78f
0x724d, 0x724e, 0x724f, 0x7250, 0x7251, 0x7252, 0x7253, 0x7254,   // U+c790 ~ U+c797
0x7255, 0x7256, 0x7257, 0x7258, 0x7259, 0x725a, 0x725b, 0x725c,   // U+c798 ~ U+c79f
0x725d, 0x725e, 0x725f, 0x7260, 0x7261, 0x7262, 0x7263, 0x7264,   // U+c7a0 ~ U+c7a7
0x7265, 0x7266, 0x7267, 0x7268, 0x7269, 0x726a, 0x726b, 0x726c,   // U+c7a8 ~ U+c7af
0x726d, 0x726e, 0x726f, 0x7270, 0x7271, 0x7272, 0x7273, 0x7274,   // U+c7b0 ~ U+c7b7
0x7275, 0x7276, 0x7277, 0x7278, 0x7279, 0x727a, 0x727b, 0x727c,   // U+c7b8 ~ U+c7bf
0x727d, 0x727e, 0x727f, 0x7280, 0x7281, 0x7282, 0x7283, 0x7284,   // U+c7c0 ~ U+c7c7
0x7285, 0x7286, 0x7287, 0x7288, 0x7289, 0x728a, 0x728b, 0x728c,   // U+c7c8 ~ U+c7cf
0x728d, 0x728e, 0x728f, 0x7290, 0x7291, 0x7292, 0x7293, 0x7294,   // U+c7d0 ~ U+c7d7
0x7295, 0x7296, 0x7297, 0x7298, 0x7299, 0x729a, 0x729b, 0x729c,   // U+c7d8 ~ U+c7df
0x729d, 0x729e, 0x729f, 0x72a0, 0x72a1, 0x72a2, 0x72a3, 0x72a4,   // U+c7e0 ~ U+c7e7
0x72a5, 0x72a6, 0x72a7, 0x72a8, 0x72a9, 0x72aa, 0x72ab, 0x72ac,   // U+c7e8 ~ U+c7ef
0x72ad, 0x72ae, 0x72af, 0x72b0, 0x72b1, 0x72b2, 0x72b3, 0x72b4,   // U+c7f0 ~ U+c7f7
0x72b5, 0x72b6, 0x72b7, 0x72b8, 0x72b9, 0x72ba, 0x72bb, 0x72bc,   // U+c7f8 ~ U+c7ff
0x72bd, 0x72be, 0x72bf, 0x72c0, 0x72c1, 0x72c2, 0x72c3, 0x72c4,   // U+c800 ~ U+c807
0x72c5, 0x72c6, 0x72c7, 0x72c8, 0x72c9, 0x72ca, 0x72cb, 0x72cc,   // U+c808 ~ U+c80f
0x72cd, 0x72ce, 0x72cf, 0x72d0, 0x72d1, 0x72d2, 0x72d3, 0x72d4,   // U+c810 ~ U+c817
0x72d5, 0x72d6, 0x72d7, 0x72d8, 0x72d9, 0x72da, 0x72db, 0x72dc,   // U+c818 ~ U+c81f
0x72dd, 0x72de, 0x72df, 0x72e0, 0x72e1, 0x72e2, 0x72e3, 0x72e4,   // U+c820 ~ U+c827
0x72e5, 0x72e6, 0x72e7, 0x72e8, 0x72e9, 0x72ea, 0x72eb, 0x72ec,   // U+c828 ~ U+c82f
0x72ed, 0x72ee, 0x72ef, 0x72f0, 0x72f1, 0x72f2, 0x72f3, 0x72f4,   // U+c830 ~ U+c837
0x72f5, 0x72f6, 0x72f7, 0x72f8, 0x72f9, 0x72fa, 0x72fb, 0x72fc,   // U+c838 ~ U+c83f
0x72fd, 0x72fe, 0x72ff, 0x7300, 0x7301, 0x7302, 0x7303, 0x7304,   // U+c840 ~ U+c847
0x7305, 0x7306, 0x7307, 0x7308, 0x7309, 0x730a, 0x730b, 0x730c,   // U+c848 ~ U+c84f
0x730d, 0x730e, 0x730f, 0x7310, 0x7311, 0x7312, 0x7313, 0x7314,   // U+c850 ~ U+c857
0x7315, 0x7316, 0x7317, 0x7318, 0x7319, 0x731a, 0x731b, 0x731c,   // U+c858 ~ U+c85f
0x731d, 0x731e, 0x731f, 0x7320, 0x7321, 0x7322, 0x7323, 0x7324,   // U+c860 ~ U+c867
0x7325, 0x7326, 0x7327, 0x7328, 0x7329, 0x732a, 0x732b, 0x732c,   // U+c868 ~ U+c86f
0x732d, 0x732e, 0x732f, 0x7330, 0x7331, 0x7332, 0x7333, 0x7334,   // U+c870 ~ U+c877
0x7335, 0x7336, 0x7337, 0x7338, 0x7339, 0x733a, 0x733b, 0x733c,   // U+c878 ~ U+c87f
0x733d, 0x733e, 0x733f, 0x7340, 0x7341, 0x7342, 0x7343, 0x7344,   // U+c880 ~ U+c887
0x7345, 0x7346, 0x7347, 0x7348, 0x7349, 0x734a, 0x734b, 0x734c,   // U+c888 ~ U+c88f
0x734d, 0x734e, 0x734f, 0x7350, 0x7351, 0x7352, 0x7353, 0x7354,   // U+c890 ~ U+c897
0x7355, 0x7356, 0x7357, 0x7358, 0x7359, 0x735a, 0x735b, 0x735c,   // U+c898 ~ U+c89f
0x735d, 0x735e, 0x735f, 0x7360, 0x7361, 0x7362, 0x7363, 0x7364,   // U+c8a0 ~ U+c8a7
0x7365, 0x7366, 0x7367, 0x7368, 0x7369, 0x736a, 0x736b, 0x736c,   // U+c8a8 ~ U+c8af
0x736d, 0x736e, 0x736f, 0x7370, 0x7371, 0x7372, 0x7373, 0x7374,   // U+c8b0 ~ U+c8b7
0x7375, 0x7376, 0x7377, 0x7378, 0x7379, 0x737a, 0x737b, 0x737c,   // U+c8b8 ~ U+c8bf
0x737d, 0x737e, 0x737f, 0x7380, 0x7381, 0x7382, 0x7383, 0x7384,   // U+c8c0 ~ U+c8c7
0x7385, 0x7386, 0x7387, 0x7388, 0x7389, 0x738a, 0x738b, 0x738c,   // U+c8c8 ~ U+c8cf
0x738d, 0x738e, 0x738f, 0x7390, 0x7391, 0x7392, 0x7393, 0x7394,   // U+c8d0 ~ U+c8d7
0x7395, 0x7396, 0x7397, 0x7398, 0x7399, 0x739a, 0x739b, 0x739c,   // U+c8d8 ~ U+c8df
0x739d, 0x739e, 0x739f, 0x73a0, 0x73a1, 0x73a2, 0x73a3, 0x73a4,   // U+c8e0 ~ U+c8e7
0x73a5, 0x73a6, 0x73a7, 0x73a8, 0x73a9, 0x73aa, 0x73ab, 0x73ac,   // U+c8e8 ~ U+c8ef
0x73ad, 0x73ae, 0x73af, 0x73b0, 0x73b1, 0x73b2, 0x73b3, 0x73b4,   // U+c8f0 ~ U+c8f7
0x73b5, 0x73b6, 0x73b7, 0x73b8, 0x73b9, 0x73ba, 0x73bb, 0x73bc,   // U+c8f8 ~ U+c8ff
0x73bd, 0x73be, 0x73bf, 0x73c0, 0x73c1, 0x73c2, 0x73c3, 0x73c4,   // U+c900 ~ U+c907
0x73c5, 0x73c6, 0x73c7, 0x73c8, 0x73c9, 0x73ca, 0x73cb, 0x73cc,   // U+c908 ~ U+c90f
0x73cd, 0x73ce, 0x73cf, 0x73d0, 0x73d1, 0x73d2, 0x73d3, 0x73d4,   // U+c910 ~ U+c917
0x73d5, 0x73d6, 0x73d7, 0x73d8, 0x73d9, 0x73da, 0x73db, 0x73dc,   // U+c918 ~ U+c91f
0x73dd, 0x73de, 0x73df, 0x73e0, 0x73e1, 0x73e2, 0x73e3, 0x73e4,   // U+c920 ~ U+c927
0x73e5, 0x73e6, 0x73e7, 0x73e8, 0x73e9, 0x73ea, 0x73eb, 0x73ec,   // U+c928 ~ U+c92f
0x73ed, 0x73ee, 0x73ef, 0x73f0, 0x73f1, 0x73f2, 0x73f3, 0x73f4,   // U+c930 ~ U+c937
0x73f5, 0x73f6, 0x73f7, 0x73f8, 0x73f9, 0x73fa, 0x73fb, 0x73fc,   // U+c938 ~ U+c93f
0x73fd, 0x73fe, 0x73ff, 0x7400, 0x7401, 0x7402, 0x7403, 0x7404,   // U+c940 ~ U+c947
0x7405, 0x7406, 0x7407, 0x7408, 0x7409, 0x740a, 0x740b, 0x740c,   // U+c948 ~ U+c94f
0x740d, 0x740e, 0x740f, 0x7410, 0x7411, 0x7412, 0x7413, 0x7414,   // U+c950 ~ U+c957
0x7415, 0x7416, 0x7417, 0x7418, 0x7419, 0x741a, 0x741b, 0x741c,   // U+c958 ~ U+c95f
0x741d, 0x741e, 0x741f, 0x7420, 0x7421, 0x7422, 0x7423, 0x7424,   // U+c960 ~ U+c967
0x7425, 0x7426, 0x7427, 0x7428, 0x7429, 0x742a, 0x742b, 0x742c,   // U+c968 ~ U+c96f
0x742d, 0x742e, 0x742f, 0x7430, 0x7431, 0x7432, 0x7433, 0x7434,   // U+c970 ~ U+c977
0x7435, 0x7436, 0x7437, 0x7438, 0x7439, 0x743a, 0x743b, 0x743c,   // U+c978 ~ U+c97f
0x743d, 0x743e, 0x743f, 0x7440, 0x7441, 0x7442, 0x7443, 0x7444,   // U+c980 ~ U+c987
0x7445, 0x7446, 0x7447, 0x7448, 0x7449, 0x744a, 0x744b, 0x744c,   // U+c988 ~ U+c98f
0x744d, 0x744e, 0x744f, 0x7450, 0x7451, 0x7452, 0x7453, 0x7454,   // U+c990 ~ U+c997
0x7455, 0x7456, 0x7457, 0x7458, 0x7459, 0x745a, 0x745b, 0x745c,   // U+c998 ~ U+c99f
0x745d, 0x745e, 0x745f, 0x7460, 0x7461, 0x7462, 0x7463, 0x7464,   // U+c9a0 ~ U+c9a7
0x7465, 0x7466, 0x7467, 0x7468, 0x7469, 0x746a, 0x746b, 0x746c,   // U+c9a8 ~ U+c9af
0x746d, 0x746e, 0x746f, 0x7470, 0x7471, 0x7472, 0x7473, 0x7474,   // U+c9b0 ~ U+c9b7
0x7475, 0x7476, 0x7477, 0x7478, 0x7479, 0x747a, 0x747b, 0x747c,   // U+c9b8 ~ U+c9bf
0x747d, 0x747e, 0x747f, 0x7480, 0x7481, 0x7482, 0x7483, 0x7484,   // U+c9c0 ~ U+c9c7
0x7485, 0x7486, 0x7487, 0x7488, 0x7489, 0x748a, 0x748b, 0x748c,   // U+c9c8 ~ U+c9cf
0x748d, 0x748e, 0x748f, 0x7490, 0x7491, 0x7492, 0x7493, 0x7494,   // U+c9d0 ~ U+c9d7
0x7495, 0x7496, 0x7497, 0x7498, 0x7499, 0x749a, 0x749b, 0x749c,   // U+c9d8 ~ U+c9df
0x749d, 0x749e, 0x749f, 0x74a0, 0x74a1, 0x74a2, 0x74a3, 0x74a4,   // U+c9e0 ~ U+c9e7
0x74a5, 0x74a6, 0x74a7, 0x74a8, 0x74a9, 0x74aa, 0x74ab, 0x74ac,   // U+c9e8 ~ U+c9ef
0x74ad, 0x74ae, 0x74af, 0x74b0, 0x74b1, 0x74b2, 0x74b3, 0x74b4,   // U+c9f0 ~ U+c9f7
0x74b5, 0x74b6, 0x74b7, 0x74b8, 0x74b9, 0x74ba, 0x74bb, 0x74bc,   // U+c9f8 ~ U+c9ff
0x74bd, 0x74be, 0x74bf, 0x74c0, 0x74c1, 0x74c2, 0x74c3, 0x74c4,   // U+ca00 ~ U+ca07
0x74c5, 0x74c6, 0x74c7, 0x74c8, 0x74c9, 0x74ca, 0x74cb, 0x74cc,   // U+ca08 ~ U+ca0f
0x74cd, 0x74ce, 0x74cf, 0x74d0, 0x74d1, 0x74d2, 0x74d3, 0x74d4,   // U+ca10 ~ U+ca17
0x74d5, 0x74d6, 0x74d7, 0x74d8, 0x74d9, 0x74da, 0x74db, 0x74dc,   // U+ca18 ~ U+ca1f
0x74dd, 0x74de, 0x74df, 0x74e0, 0x74e1, 0x74e2, 0x74e3, 0x74e4,   // U+ca20 ~ U+ca27
0x74e5, 0x74e6, 0x74e7, 0x74e8, 0x74e9, 0x74ea, 0x74eb, 0x74ec,   // U+ca28 ~ U+ca2f
0x74ed, 0x74ee, 0x74ef, 0x74f0, 0x74f1, 0x74f2, 0x74f3, 0x74f4,   // U+ca30 ~ U+ca37
0x74f5, 0x74f6, 0x74f7, 0x74f8, 0x74f9, 0x74fa, 0x74fb, 0x74fc,   // U+ca38 ~ U+ca3f
0x74fd, 0x74fe, 0x74ff, 0x7500, 0x7501, 0x7502, 0x7503, 0x7504,   // U+ca40 ~ U+ca47
0x7505, 0x7506, 0x7507, 0x7508, 0x7509, 0x750a, 0x750b, 0x750c,   // U+ca48 ~ U+ca4f
0x750d, 0x750e, 0x750f, 0x7510, 0x7511, 0x7512, 0x7513, 0x7514,   // U+ca50 ~ U+ca57
0x7515, 0x7516, 0x7517, 0x7518, 0x7519, 0x751a, 0x751b, 0x751c,   // U+ca58 ~ U+ca5f
0x751d, 0x751e, 0x751f, 0x7520, 0x7521, 0x7522, 0x7523, 0x7524,   // U+ca60 ~ U+ca67
0x7525, 0x7526, 0x7527, 0x7528, 0x7529, 0x752a, 0x752b, 0x752c,   // U+ca68 ~ U+ca6f
0x752d, 0x752e, 0x752f, 0x7530, 0x7531, 0x7532, 0x7533, 0x7534,   // U+ca70 ~ U+ca77
0x7535, 0x7536, 0x7537, 0x7538, 0x7539, 0x753a, 0x753b, 0x753c,   // U+ca78 ~ U+ca7f
0x753d, 0x753e, 0x753f, 0x7540, 0x7541, 0x7542, 0x7543, 0x7544,   // U+ca80 ~ U+ca87
0x7545, 0x7546, 0x7547, 0x7548, 0x7549, 0x754a, 0x754b, 0x754c,   // U+ca88 ~ U+ca8f
0x754d, 0x754e, 0x754f, 0x7550, 0x7551, 0x7552, 0x7553, 0x7554,   // U+ca90 ~ U+ca97
0x7555, 0x7556, 0x7557, 0x7558, 0x7559, 0x755a, 0x755b, 0x755c,   // U+ca98 ~ U+ca9f
0x755d, 0x755e, 0x755f, 0x7560, 0x7561, 0x7562, 0x7563, 0x7564,   // U+caa0 ~ U+caa7
0x7565, 0x7566, 0x7567, 0x7568, 0x7569, 0x756a, 0x756b, 0x756c,   // U+caa8 ~ U+caaf
0x756d, 0x756e, 0x756f, 0x7570, 0x7571, 0x7572, 0x7573, 0x7574,   // U+cab0 ~ U+cab7
0x7575, 0x7576, 0x7577, 0x7578, 0x7579, 0x757a, 0x757b, 0x757c,   // U+cab8 ~ U+cabf
0x757d, 0x757e, 0x757f, 0x7580, 0x7581, 0x7582, 0x7583, 0x7584,   // U+cac0 ~ U+cac7
0x7585, 0x7586, 0x7587, 0x7588, 0x7589, 0x758a, 0x758b, 0x758c,   // U+cac8 ~ U+cacf
0x758d, 0x758e, 0x758f, 0x7590, 0x7591, 0x7592, 0x7593, 0x7594,   // U+cad0 ~ U+cad7
0x7595, 0x7596, 0x7597, 0x7598, 0x7599, 0x759a, 0x759b, 0x759c,   // U+cad8 ~ U+cadf
0x759d, 0x759e, 0x759f, 0x75a0, 0x75a1, 0x75a2, 0x75a3, 0x75a4,   // U+cae0 ~ U+cae7
0x75a5, 0x75a6, 0x75a7, 0x75a8, 0x75a9, 0x75aa, 0x75ab, 0x75ac,   // U+cae8 ~ U+caef
0x75ad, 0x75ae, 0x75af, 0x75b0, 0x75b1, 0x75b2, 0x75b3, 0x75b4,   // U+caf0 ~ U+caf7
0x75b5, 0x75b6, 0x75b7, 0x75b8, 0x75b9, 0x75ba, 0x75bb, 0x75bc,   // U+caf8 ~ U+caff
0x75bd, 0x75be, 0x75bf, 0x75c0, 0x75c1, 0x75c2, 0x75c3, 0x75c4,   // U+cb00 ~ U+cb07
0x75c5, 0x75c6, 0x75c7, 0x75c8, 0x75c9, 0x75ca, 0x75cb, 0x75cc,   // U+cb08 ~ U+cb0f
0x75cd, 0x75ce, 0x75cf, 0x75d0, 0x75d1, 0x75d2, 0x75d3, 0x75d4,   // U+cb10 ~ U+cb17
0x75d5, 0x75d6, 0x75d7, 0x75d8, 0x75d9, 0x75da, 0x75db, 0x75dc,   // U+cb18 ~ U+cb1f
0x75dd, 0x75de, 0x75df, 0x75e0, 0x75e1, 0x75e2, 0x75e3, 0x75e4,   // U+cb20 ~ U+cb27
0x75e5, 0x75e6, 0x75e7, 0x75e8, 0x75e9, 0x75ea, 0x75eb, 0x75ec,   // U+cb28 ~ U+cb2f
0x75ed, 0x75ee, 0x75ef, 0x75f0, 0x75f1, 0x75f2, 0x75f3, 0x75f4,   // U+cb30 ~ U+cb37
0x75f5, 0x75f6, 0x75f7, 0x75f8, 0x75f9, 0x75fa, 0x75fb, 0x75fc,   // U+cb38 ~ U+cb3f
0x75fd, 0x75fe, 0x75ff, 0x7600, 0x7601, 0x7602, 0x7603, 0x7604,   // U+cb40 ~ U+cb47
0x7605, 0x7606, 0x7607, 0x7608, 0x7609, 0x760a, 0x760b, 0x760c,   // U+cb48 ~ U+cb4f
0x760d, 0x760e, 0x760f, 0x7610, 0x7611, 0x7612, 0x7613, 0x7614,   // U+cb50 ~ U+cb57
0x7615, 0x7616, 0x7617, 0x7618, 0x7619, 0x761a, 0x761b, 0x761c,   // U+cb58 ~ U+cb5f
0x761d, 0x761e, 0x761f, 0x7620, 0x7621, 0x7622, 0x7623, 0x7624,   // U+cb60 ~ U+cb67
0x7625, 0x7626, 0x7627, 0x7628, 0x7629, 0x762a, 0x762b, 0x762c,   // U+cb68 ~ U+cb6f
0x762d, 0x762e, 0x762f, 0x7630, 0x7631, 0x7632, 0x7633, 0x7634,   // U+cb70 ~ U+cb77
0x7635, 0x7636, 0x7637, 0x7638, 0x7639, 0x763a, 0x763b, 0x763c,   // U+cb78 ~ U+cb7f
0x763d, 0x763e, 0x763f, 0x7640, 0x7641, 0x7642, 0x7643, 0x7644,   // U+cb80 ~ U+cb87
0x7645, 0x7646, 0x7647, 0x7648, 0x7649, 0x764a, 0x764b, 0x764c,   // U+cb88 ~ U+cb8f
0x764d, 0x764e, 0x764f, 0x7650, 0x7651, 0x7652, 0x7653, 0x7654,   // U+cb90 ~ U+cb97
0x7655, 0x7656, 0x7657, 0x7658, 0x7659, 0x765a, 0x765b, 0x765c,   // U+cb98 ~ U+cb9f
0x765d, 0x765e, 0x765f, 0x7660, 0x7661, 0x7662, 0x7663, 0x7664,   // U+cba0 ~ U+cba7
0x7665, 0x7666, 0x7667, 0x7668, 0x7669, 0x766a, 0x766b, 0x766c,   // U+cba8 ~ U+cbaf
0x766d, 0x766e, 0x766f, 0x7670, 0x7671, 0x7672, 0x7673, 0x7674,   // U+cbb0 ~ U+cbb7
0x7675, 0x7676, 0x7677, 0x7678, 0x7679, 0x767a, 0x767b, 0x767c,   // U+cbb8 ~ U+cbbf
0x767d, 0x767e, 0x767f, 0x7680, 0x7681, 0x7682, 0x7683, 0x7684,   // U+cbc0 ~ U+cbc7
0x7685, 0x7686, 0x7687, 0x7688, 0x7689, 0x768a, 0x768b, 0x768c,   // U+cbc8 ~ U+cbcf
0x768d, 0x768e, 0x768f, 0x7690, 0x7691, 0x7692, 0x7693, 0x7694,   // U+cbd0 ~ U+cbd7
0x7695, 0x7696, 0x7697, 0x7698, 0x7699, 0x769a, 0x769b, 0x769c,   // U+cbd8 ~ U+cbdf
0x769d, 0x769e, 0x769f, 0x76a0, 0x76a1, 0x76a2, 0x76a3, 0x76a4,   // U+cbe0 ~ U+cbe7
0x76a5, 0x76a6, 0x76a7, 0x76a8, 0x76a9, 0x76aa, 0x76ab, 0x76ac,   // U+cbe8 ~ U+cbef
0x76ad, 0x76ae, 0x76af, 0x76b0, 0x76b1, 0x76b2, 0x76b3, 0x76b4,   // U+cbf0 ~ U+cbf7
0x76b5, 0x76b6, 0x76b7, 0x76b8, 0x76b9, 0x76ba, 0x76bb, 0x76bc,   // U+cbf8 ~ U+cbff
0x76bd, 0x76be, 0x76bf, 0x76c0, 0x76c1, 0x76c2, 0x76c3, 0x76c4,   // U+cc00 ~ U+cc07
0x76c5, 0x76c6, 0x76c7, 0x76c8, 0x76c9, 0x76ca, 0x76cb, 0x76cc,   // U+cc08 ~ U+cc0f
0x76cd, 0x76ce, 0x76cf, 0x76d0, 0x76d1, 0x76d2, 0x76d3, 0x76d4,   // U+cc10 ~ U+cc17
0x76d5, 0x76d6, 0x76d7, 0x76d8, 0x76d9, 0x76da, 0x76db, 0x76dc,   // U+cc18 ~ U+cc1f
0x76dd, 0x76de, 0x76df, 0x76e0, 0x76e1, 0x76e2, 0x76e3, 0x76e4,   // U+cc20 ~ U+cc27
0x76e5, 0x76e6, 0x76e7, 0x76e8, 0x76e9, 0x76ea, 0x76eb, 0x76ec,   // U+cc28 ~ U+cc2f
0x76ed, 0x76ee, 0x76ef, 0x76f0, 0x76f1, 0x76f2, 0x76f3, 0x76f4,   // U+cc30 ~ U+cc37
0x76f5, 0x76f6, 0x76f7, 0x76f8, 0x76f9, 0x76fa, 0x76fb, 0x76fc,   // U+cc38 ~ U+cc3f
0x76fd, 0x76fe, 0x76ff, 0x7700, 0x7701, 0x7702, 0x7703, 0x7704,   // U+cc40 ~ U+cc47
0x7705, 0x7706, 0x7707, 0x7708, 0x7709, 0x770a, 0x770b, 0x770c,   // U+cc48 ~ U+cc4f
0x770d, 0x770e, 0x770f, 0x7710, 0x7711, 0x7712, 0x7713, 0x7714,   // U+cc50 ~ U+cc57
0x7715, 0x7716, 0x7717, 0x7718, 0x7719, 0x771a, 0x771b, 0x771c,   // U+cc58 ~ U+cc5f
0x771d, 0x771e, 0x771f, 0x7720, 0x7721, 0x7722, 0x7723, 0x7724,   // U+cc60 ~ U+cc67
0x7725, 0x7726, 0x7727, 0x7728, 0x7729, 0x772a, 0x772b, 0x772c,   // U+cc68 ~ U+cc6f
0x772d, 0x772e, 0x772f, 0x7730, 0x7731, 0x7732, 0x7733, 0x7734,   // U+cc70 ~ U+cc77
0x7735, 0x7736, 0x7737, 0x7738, 0x7739, 0x773a, 0x773b, 0x773c,   // U+cc78 ~ U+cc7f
0x773d, 0x773e, 0x773f, 0x7740, 0x7741, 0x7742, 0x7743, 0x7744,   // U+cc80 ~ U+cc87
0x7745, 0x7746, 0x7747, 0x7748, 0x7749, 0x774a, 0x774b, 0x774c,   // U+cc88 ~ U+cc8f
0x774d, 0x774e, 0x774f, 0x7750, 0x7751, 0x7752, 0x7753, 0x7754,   // U+cc90 ~ U+cc97
0x7755, 0x7756, 0x7757, 0x7758, 0x7759, 0x775a, 0x775b, 0x775c,   // U+cc98 ~ U+cc9f
0x775d, 0x775e, 0x775f, 0x7760, 0x7761, 0x7762, 0x7763, 0x7764,   // U+cca0 ~ U+cca7
0x7765, 0x7766, 0x7767, 0x7768, 0x7769, 0x776a, 0x776b, 0x776c,   // U+cca8 ~ U+ccaf
0x776d, 0x776e, 0x776f, 0x7770, 0x7771, 0x7772, 0x7773, 0x7774,   // U+ccb0 ~ U+ccb7
0x7775, 0x7776, 0x7777, 0x7778, 0x7779, 0x777a, 0x777b, 0x777c,   // U+ccb8 ~ U+ccbf
0x777d, 0x777e, 0x777f, 0x7780, 0x7781, 0x7782, 0x7783, 0x7784,   // U+ccc0 ~ U+ccc7
0x7785, 0x7786, 0x7787, 0x7788, 0x7789, 0x778a, 0x778b, 0x778c,   // U+ccc8 ~ U+cccf
0x778d, 0x778e, 0x778f, 0x7790, 0x7791, 0x7792, 0x7793, 0x7794,   // U+ccd0 ~ U+ccd7
0x7795, 0x7796, 0x7797, 0x7798, 0x7799, 0x779a, 0x779b, 0x779c,   // U+ccd8 ~ U+ccdf
0x779d, 0x779e, 0x779f, 0x77a0, 0x77a1, 0x77a2, 0x77a3, 0x77a4,   // U+cce0 ~ U+cce7
0x77a5, 0x77a6, 0x77a7, 0x77a8, 0x77a9, 0x77aa, 0x77ab, 0x77ac,   // U+cce8 ~ U+ccef
0x77ad, 0x77ae, 0x77af, 0x77b0, 0x77b1, 0x77b2, 0x77b3, 0x77b4,   // U+ccf0 ~ U+ccf7
0x77b5, 0x77b6, 0x77b7, 0x77b8, 0x77b9, 0x77ba, 0x77bb, 0x77bc,   // U+ccf8 ~ U+ccff
0x77bd, 0x77be, 0x77bf, 0x77c0, 0x77c1, 0x77c2, 0x77c3, 0x77c4,   // U+cd00 ~ U+cd07
0x77c5, 0x77c6, 0x77c7, 0x77c8, 0x77c9, 0x77ca, 0x77cb, 0x77cc,   // U+cd08 ~ U+cd0f
0x77cd, 0x77ce, 0x77cf, 0x77d0, 0x77d1, 0x77d2, 0x77d3, 0x77d4,   // U+cd10 ~ U+cd17
0x77d5, 0x77d6, 0x77d7, 0x77d8, 0x77d9, 0x77da, 0x77db, 0x77dc,   // U+cd18 ~ U+cd1f
0x77dd, 0x77de, 0x77df, 0x77e0, 0x77e1, 0x77e2, 0x77e3, 0x77e4,   // U+cd20 ~ U+cd27
0x77e5, 0x77e6, 0x77e7, 0x77e8, 0x77e9, 0x77ea, 0x77eb, 0x77ec,   // U+cd28 ~ U+cd2f
0x77ed, 0x77ee, 0x77ef, 0x77f0, 0x77f1, 0x77f2, 0x77f3, 0x77f4,   // U+cd30 ~ U+cd37
0x77f5, 0x77f6, 0x77f7, 0x77f8, 0x77f9, 0x77fa, 0x77fb, 0x77fc,   // U+cd38 ~ U+cd3f
0x77fd, 0x77fe, 0x77ff, 0x7800, 0x7801, 0x7802, 0x7803, 0x7804,   // U+cd40 ~ U+cd47
0x7805, 0x7806, 0x7807, 0x7808, 0x7809, 0x780a, 0x780b, 0x780c,   // U+cd48 ~ U+cd4f
0x780d, 0x780e, 0x780f, 0x7810, 0x7811, 0x7812, 0x7813, 0x7814,   // U+cd50 ~ U+cd57
0x7815, 0x7816, 0x7817, 0x7818, 0x7819, 0x781a, 0x781b, 0x781c,   // U+cd58 ~ U+cd5f
0x781d, 0x781e, 0x781f, 0x7820, 0x7821, 0x7822, 0x7823, 0x7824,   // U+cd60 ~ U+cd67
0x7825, 0x7826, 0x7827, 0x7828, 0x7829, 0x782a, 0x782b, 0x782c,   // U+cd68 ~ U+cd6f
0x782d, 0x782e, 0x782f, 0x7830, 0x7831, 0x7832, 0x7833, 0x7834,   // U+cd70 ~ U+cd77
0x7835, 0x7836, 0x7837, 0x7838, 0x7839, 0x783a, 0x783b, 0x783c,   // U+cd78 ~ U+cd7f
0x783d, 0x783e, 0x783f, 0x7840, 0x7841, 0x7842, 0x7843, 0x7844,   // U+cd80 ~ U+cd87
0x7845, 0x7846, 0x7847, 0x7848, 0x7849, 0x784a, 0x784b, 0x784c,   // U+cd88 ~ U+cd8f
0x784d, 0x784e, 0x784f, 0x7850, 0x7851, 0x7852, 0x7853, 0x7854,   // U+cd90 ~ U+cd97
0x7855, 0x7856, 0x7857, 0x7858, 0x7859, 0x785a, 0x785b, 0x785c,   // U+cd98 ~ U+cd9f
0x785d, 0x785e, 0x785f, 0x7860, 0x7861, 0x7862, 0x7863, 0x7864,   // U+cda0 ~ U+cda7
0x7865, 0x7866, 0x7867, 0x7868, 0x7869, 0x786a, 0x786b, 0x786c,   // U+cda8 ~ U+cdaf
0x786d, 0x786e, 0x786f, 0x7870, 0x7871, 0x7872, 0x7873, 0x7874,   // U+cdb0 ~ U+cdb7
0x7875, 0x7876, 0x7877, 0x7878, 0x7879, 0x787a, 0x787b, 0x787c,   // U+cdb8 ~ U+cdbf
0x787d, 0x787e, 0x787f, 0x7880, 0x7881, 0x7882, 0x7883, 0x7884,   // U+cdc0 ~ U+cdc7
0x7885, 0x7886, 0x7887, 0x7888, 0x7889, 0x788a, 0x788b, 0x788c,   // U+cdc8 ~ U+cdcf
0x788d, 0x788e, 0x788f, 0x7890, 0x7891, 0x7892, 0x7893, 0x7894,   // U+cdd0 ~ U+cdd7
0x7895, 0x7896, 0x7897, 0x7898, 0x7899, 0x789a, 0x789b, 0x789c,   // U+cdd8 ~ U+cddf
0x789d, 0x789e, 0x789f, 0x78a0, 0x78a1, 0x78a2, 0x78a3, 0x78a4,   // U+cde0 ~ U+cde7
0x78a5, 0x78a6, 0x78a7, 0x78a8, 0x78a9, 0x78aa, 0x78ab, 0x78ac,   // U+cde8 ~ U+cdef
0x78ad, 0x78ae, 0x78af, 0x78b0, 0x78b1, 0x78b2, 0x78b3, 0x78b4,   // U+cdf0 ~ U+cdf7
0x78b5, 0x78b6, 0x78b7, 0x78b8, 0x78b9, 0x78ba, 0x78bb, 0x78bc,   // U+cdf8 ~ U+cdff
0x78bd, 0x78be, 0x78bf, 0x78c0, 0x78c1, 0x78c2, 0x78c3, 0x78c4,   // U+ce00 ~ U+ce07
0x78c5, 0x78c6, 0x78c7, 0x78c8, 0x78c9, 0x78ca, 0x78cb, 0x78cc,   // U+ce08 ~ U+ce0f
0x78cd, 0x78ce, 0x78cf, 0x78d0, 0x78d1, 0x78d2, 0x78d3, 0x78d4,   // U+ce10 ~ U+ce17
0x78d5, 0x78d6, 0x78d7, 0x78d8, 0x78d9, 0x78da, 0x78db, 0x78dc,   // U+ce18 ~ U+ce1f
0x78dd, 0x78de, 0x78df, 0x78e0, 0x78e1, 0x78e2, 0x78e3, 0x78e4,   // U+ce20 ~ U+ce27
0x78e5, 0x78e6, 0x78e7, 0x78e8, 0x78e9, 0x78ea, 0x78eb, 0x78ec,   // U+ce28 ~ U+ce2f
0x78ed, 0x78ee, 0x78ef, 0x78f0, 0x78f1, 0x78f2, 0x78f3, 0x78f4,   // U+ce30 ~ U+ce37
0x78f5, 0x78f6, 0x78f7, 0x78f8, 0x78f9, 0x78fa, 0x78fb, 0x78fc,   // U+ce38 ~ U+ce3f
0x78fd, 0x78fe, 0x78ff, 0x7900, 0x7901, 0x7902, 0x7903, 0x7904,   // U+ce40 ~ U+ce47
0x7905, 0x7906, 0x7907, 0x7908, 0x7909, 0x790a, 0x790b, 0x790c,   // U+ce48 ~ U+ce4f
0x790d, 0x790e, 0x790f, 0x7910, 0x7911, 0x7912, 0x7913, 0x7914,   // U+ce50 ~ U+ce57
0x7915, 0x7916, 0x7917, 0x7918, 0x7919, 0x791a, 0x791b, 0x791c,   // U+ce58 ~ U+ce5f
0x791d, 0x791e, 0x791f, 0x7920, 0x7921, 0x7922, 0x7923, 0x7924,   // U+ce60 ~ U+ce67
0x7925, 0x7926, 0x7927, 0x7928, 0x7929, 0x792a, 0x792b, 0x792c,   // U+ce68 ~ U+ce6f
0x792d, 0x792e, 0x792f, 0x7930, 0x7931, 0x7932, 0x7933, 0x7934,   // U+ce70 ~ U+ce77
0x7935, 0x7936, 0x7937, 0x7938, 0x7939, 0x793a, 0x793b, 0x793c,   // U+ce78 ~ U+ce7f
0x793d, 0x793e, 0x793f, 0x7940, 0x7941, 0x7942, 0x7943, 0x7944,   // U+ce80 ~ U+ce87
0x7945, 0x7946, 0x7947, 0x7948, 0x7949, 0x794a, 0x794b, 0x794c,   // U+ce88 ~ U+ce8f
0x794d, 0x794e, 0x794f, 0x7950, 0x7951, 0x7952, 0x7953, 0x7954,   // U+ce90 ~ U+ce97
0x7955, 0x7956, 0x7957, 0x7958, 0x7959, 0x795a, 0x795b, 0x795c,   // U+ce98 ~ U+ce9f
0x795d, 0x795e, 0x795f, 0x7960, 0x7961, 0x7962, 0x7963, 0x7964,   // U+cea0 ~ U+cea7
0x7965, 0x7966, 0x7967, 0x7968, 0x7969, 0x796a, 0x796b, 0x796c,   // U+cea8 ~ U+ceaf
0x796d, 0x796e, 0x796f, 0x7970, 0x7971, 0x7972, 0x7973, 0x7974,   // U+ceb0 ~ U+ceb7
0x7975, 0x7976, 0x7977, 0x7978, 0x7979, 0x797a, 0x797b, 0x797c,   // U+ceb8 ~ U+cebf
0x797d, 0x797e, 0x797f, 0x7980, 0x7981, 0x7982, 0x7983, 0x7984,   // U+cec0 ~ U+cec7
0x7985, 0x7986, 0x7987, 0x7988, 0x7989, 0x798a, 0x798b, 0x798c,   // U+cec8 ~ U+cecf
0x798d, 0x798e, 0x798f, 0x7990, 0x7991, 0x7992, 0x7993, 0x7994,   // U+ced0 ~ U+ced7
0x7995, 0x7996, 0x7997, 0x7998, 0x7999, 0x799a, 0x799b, 0x799c,   // U+ced8 ~ U+cedf
0x799d, 0x799e, 0x799f, 0x79a0, 0x79a1, 0x79a2, 0x79a3, 0x79a4,   // U+cee0 ~ U+cee7
0x79a5, 0x79a6, 0x79a7, 0x79a8, 0x79a9, 0x79aa, 0x79ab, 0x79ac,   // U+cee8 ~ U+ceef
0x79ad, 0x79ae, 0x79af, 0x79b0, 0x79b1, 0x79b2, 0x79b3, 0x79b4,   // U+cef0 ~ U+cef7
0x79b5, 0x79b6, 0x79b7, 0x79b8, 0x79b9, 0x79ba, 0x79bb, 0x79bc,   // U+cef8 ~ U+ceff
0x79bd, 0x79be, 0x79bf, 0x79c0, 0x79c1, 0x79c2, 0x79c3, 0x79c4,   // U+cf00 ~ U+cf07
0x79c5, 0x79c6, 0x79c7, 0x79c8, 0x79c9, 0x79ca, 0x79cb, 0x79cc,   // U+cf08 ~ U+cf0f
0x79cd, 0x79ce, 0x79cf, 0x79d0, 0x79d1, 0x79d2, 0x79d3, 0x79d4,   // U+cf10 ~ U+cf17
0x79d5, 0x79d6, 0x79d7, 0x79d8, 0x79d9, 0x79da, 0x79db, 0x79dc,   // U+cf18 ~ U+cf1f
0x79dd, 0x79de, 0x79df, 0x79e0, 0x79e1, 0x79e2, 0x79e3, 0x79e4,   // U+cf20 ~ U+cf27
0x79e5, 0x79e6, 0x79e7, 0x79e8, 0x79e9, 0x79ea, 0x79eb, 0x79ec,   // U+cf28 ~ U+cf2f
0x79ed, 0x79ee, 0x79ef, 0x79f0, 0x79f1, 0x79f2, 0x79f3, 0x79f4,   // U+cf30 ~ U+cf37
0x79f5, 0x79f6, 0x79f7, 0x79f8, 0x79f9, 0x79fa, 0x79fb, 0x79fc,   // U+cf38 ~ U+cf3f
0x79fd, 0x79fe, 0x79ff, 0x7a00, 0x7a01, 0x7a02, 0x7a03, 0x7a04,   // U+cf40 ~ U+cf47
0x7a05, 0x7a06, 0x7a07, 0x7a08, 0x7a09, 0x7a0a, 0x7a0b, 0x7a0c,   // U+cf48 ~ U+cf4f
0x7a0d, 0x7a0e, 0x7a0f, 0x7a10, 0x7a11, 0x7a12, 0x7a13, 0x7a14,   // U+cf50 ~ U+cf57
0x7a15, 0x7a16, 0x7a17, 0x7a18, 0x7a19, 0x7a1a, 0x7a1b, 0x7a1c,   // U+cf58 ~ U+cf5f
0x7a1d, 0x7a1e, 0x7a1f, 0x7a20, 0x7a21, 0x7a22, 0x7a23, 0x7a24,   // U+cf60 ~ U+cf67
0x7a25, 0x7a26, 0x7a27, 0x7a28, 0x7a29, 0x7a2a, 0x7a2b, 0x7a2c,   // U+cf68 ~ U+cf6f
0x7a2d, 0x7a2e, 0x7a2f, 0x7a30, 0x7a31, 0x7a32, 0x7a33, 0x7a34,   // U+cf70 ~ U+cf77
0x7a35, 0x7a36, 0x7a37, 0x7a38, 0x7a39, 0x7a3a, 0x7a3b, 0x7a3c,   // U+cf78 ~ U+cf7f
0x7a3d, 0x7a3e, 0x7a3f, 0x7a40, 0x7a41, 0x7a42, 0x7a43, 0x7a44,   // U+cf80 ~ U+cf87
0x7a45, 0x7a46, 0x7a47, 0x7a48, 0x7a49, 0x7a4a, 0x7a4b, 0x7a4c,   // U+cf88 ~ U+cf8f
0x7a4d, 0x7a4e, 0x7a4f, 0x7a50, 0x7a51, 0x7a52, 0x7a53, 0x7a54,   // U+cf90 ~ U+cf97
0x7a55, 0x7a56, 0x7a57, 0x7a58, 0x7a59, 0x7a5a, 0x7a5b, 0x7a5c,   // U+cf98 ~ U+cf9f
0x7a5d, 0x7a5e, 0x7a5f, 0x7a60, 0x7a61, 0x7a62, 0x7a63, 0x7a64,   // U+cfa0 ~ U+cfa7
0x7a65, 0x7a66, 0x7a67, 0x7a68, 0x7a69, 0x7a6a, 0x7a6b, 0x7a6c,   // U+cfa8 ~ U+cfaf
0x7a6d, 0x7a6e, 0x7a6f, 0x7a70, 0x7a71, 0x7a72, 0x7a73, 0x7a74,   // U+cfb0 ~ U+cfb7
0x7a75, 0x7a76, 0x7a77, 0x7a78, 0x7a79, 0x7a7a, 0x7a7b, 0x7a7c,   // U+cfb8 ~ U+cfbf
0x7a7d, 0x7a7e, 0x7a7f, 0x7a80, 0x7a81, 0x7a82, 0x7a83, 0x7a84,   // U+cfc0 ~ U+cfc7
0x7a85, 0x7a86, 0x7a87, 0x7a88, 0x7a89, 0x7a8a, 0x7a8b, 0x7a8c,   // U+cfc8 ~ U+cfcf
0x7a8d, 0x7a8e, 0x7a8f, 0x7a90, 0x7a91, 0x7a92, 0x7a93, 0x7a94,   // U+cfd0 ~ U+cfd7
0x7a95, 0x7a96, 0x7a97, 0x7a98, 0x7a99, 0x7a9a, 0x7a9b, 0x7a9c,   // U+cfd8 ~ U+cfdf
0x7a9d, 0x7a9e, 0x7a9f, 0x7aa0, 0x7aa1, 0x7aa2, 0x7aa3, 0x7aa4,   // U+cfe0 ~ U+cfe7
0x7aa5, 0x7aa6, 0x7aa7, 0x7aa8, 0x7aa9, 0x7aaa, 0x7aab, 0x7aac,   // U+cfe8 ~ U+cfef
0x7aad, 0x7aae, 0x7aaf, 0x7ab0, 0x7ab1, 0x7ab2, 0x7ab3, 0x7ab4,   // U+cff0 ~ U+cff7
0x7ab5, 0x7ab6, 0x7ab7, 0x7ab8, 0x7ab9, 0x7aba, 0x7abb, 0x7abc,   // U+cff8 ~ U+cfff
0x7abd, 0x7abe, 0x7abf, 0x7ac0, 0x7ac1, 0x7ac2, 0x7ac3, 0x7ac4,   // U+d000 ~ U+d007
0x7ac5, 0x7ac6, 0x7ac7, 0x7ac8, 0x7ac9, 0x7aca, 0x7acb, 0x7acc,   // U+d008 ~ U+d00f
0x7acd, 0x7ace, 0x7acf, 0x7ad0, 0x7ad1, 0x7ad2, 0x7ad3, 0x7ad4,   // U+d010 ~ U+d017
0x7ad5, 0x7ad6, 0x7ad7, 0x7ad8, 0x7ad9, 0x7ada, 0x7adb, 0x7adc,   // U+d018 ~ U+d01f
0x7add, 0x7ade, 0x7adf, 0x7ae0, 0x7ae1, 0x7ae2, 0x7ae3, 0x7ae4,   // U+d020 ~ U+d027
0x7ae5, 0x7ae6, 0x7ae7, 0x7ae8, 0x7ae9, 0x7aea, 0x7aeb, 0x7aec,   // U+d028 ~ U+d02f
0x7aed, 0x7aee, 0x7aef, 0x7af0, 0x7af1, 0x7af2, 0x7af3, 0x7af4,   // U+d030 ~ U+d037
0x7af5, 0x7af6, 0x7af7, 0x7af8, 0x7af9, 0x7afa, 0x7afb, 0x7afc,   // U+d038 ~ U+d03f
0x7afd, 0x7afe, 0x7aff, 0x7b00, 0x7b01, 0x7b02, 0x7b03, 0x7b04,   // U+d040 ~ U+d047
0x7b05, 0x7b06, 0x7b07, 0x7b08, 0x7b09, 0x7b0a, 0x7b0b, 0x7b0c,   // U+d048 ~ U+d04f
0x7b0d, 0x7b0e, 0x7b0f, 0x7b10, 0x7b11, 0x7b12, 0x7b13, 0x7b14,   // U+d050 ~ U+d057
0x7b15, 0x7b16, 0x7b17, 0x7b18, 0x7b19, 0x7b1a, 0x7b1b, 0x7b1c,   // U+d058 ~ U+d05f
0x7b1d, 0x7b1e, 0x7b1f, 0x7b20, 0x7b21, 0x7b22, 0x7b23, 0x7b24,   // U+d060 ~ U+d067
0x7b25, 0x7b26, 0x7b27, 0x7b28, 0x7b29, 0x7b2a, 0x7b2b, 0x7b2c,   // U+d068 ~ U+d06f
0x7b2d, 0x7b2e, 0x7b2f, 0x7b30, 0x7b31, 0x7b32, 0x7b33, 0x7b34,   // U+d070 ~ U+d077
0x7b35, 0x7b36, 0x7b37, 0x7b38, 0x7b39, 0x7b3a, 0x7b3b, 0x7b3c,   // U+d078 ~ U+d07f
0x7b3d, 0x7b3e, 0x7b3f, 0x7b40, 0x7b41, 0x7b42, 0x7b43, 0x7b44,   // U+d080 ~ U+d087
0x7b45, 0x7b46, 0x7b47, 0x7b48, 0x7b49, 0x7b4a, 0x7b4b, 0x7b4c,   // U+d088 ~ U+d08f
0x7b4d, 0x7b4e, 0x7b4f, 0x7b50, 0x7b51, 0x7b52, 0x7b53, 0x7b54,   // U+d090 ~ U+d097
0x7b55, 0x7b56, 0x7b57, 0x7b58, 0x7b59, 0x7b5a, 0x7b5b, 0x7b5c,   // U+d098 ~ U+d09f
0x7b5d, 0x7b5e, 0x7b5f, 0x7b60, 0x7b61, 0x7b62, 0x7b63, 0x7b64,   // U+d0a0 ~ U+d0a7
0x7b65, 0x7b66, 0x7b67, 0x7b68, 0x7b69, 0x7b6a, 0x7b6b, 0x7b6c,   // U+d0a8 ~ U+d0af
0x7b6d, 0x7b6e, 0x7b6f, 0x7b70, 0x7b71, 0x7b72, 0x7b73, 0x7b74,   // U+d0b0 ~ U+d0b7
0x7b75, 0x7b76, 0x7b77, 0x7b78, 0x7b79, 0x7b7a, 0x7b7b, 0x7b7c,   // U+d0b8 ~ U+d0bf
0x7b7d, 0x7b7e, 0x7b7f, 0x7b80, 0x7b81, 0x7b82, 0x7b83, 0x7b84,   // U+d0c0 ~ U+d0c7
0x7b85, 0x7b86, 0x7b87, 0x7b88, 0x7b89, 0x7b8a, 0x7b8b, 0x7b8c,   // U+d0c8 ~ U+d0cf
0x7b8d, 0x7b8e, 0x7b8f, 0x7b90, 0x7b91, 0x7b92, 0x7b93, 0x7b94,   // U+d0d0 ~ U+d0d7
0x7b95, 0x7b96, 0x7b97, 0x7b98, 0x7b99, 0x7b9a, 0x7b9b, 0x7b9c,   // U+d0d8 ~ U+d0df
0x7b9d, 0x7b9e, 0x7b9f, 0x7ba0, 0x7ba1, 0x7ba2, 0x7ba3, 0x7ba4,   // U+d0e0 ~ U+d0e7
0x7ba5, 0x7ba6, 0x7ba7, 0x7ba8, 0x7ba9, 0x7baa, 0x7bab, 0x7bac,   // U+d0e8 ~ U+d0ef
0x7bad, 0x7bae, 0x7baf, 0x7bb0, 0x7bb1, 0x7bb2, 0x7bb3, 0x7bb4,   // U+d0f0 ~ U+d0f7
0x7bb5, 0x7bb6, 0x7bb7, 0x7bb8, 0x7bb9, 0x7bba, 0x7bbb, 0x7bbc,   // U+d0f8 ~ U+d0ff
0x7bbd, 0x7bbe, 0x7bbf, 0x7bc0, 0x7bc1, 0x7bc2, 0x7bc3, 0x7bc4,   // U+d100 ~ U+d107
0x7bc5, 0x7bc6, 0x7bc7, 0x7bc8, 0x7bc9, 0x7bca, 0x7bcb, 0x7bcc,   // U+d108 ~ U+d10f
0x7bcd, 0x7bce, 0x7bcf, 0x7bd0, 0x7bd1, 0x7bd2, 0x7bd3, 0x7bd4,   // U+d110 ~ U+d117
0x7bd5, 0x7bd6, 0x7bd7, 0x7bd8, 0x7bd9, 0x7bda, 0x7bdb, 0x7bdc,   // U+d118 ~ U+d11f
0x7bdd, 0x7bde, 0x7bdf, 0x7be0, 0x7be1, 0x7be2, 0x7be3, 0x7be4,   // U+d120 ~ U+d127
0x7be5, 0x7be6, 0x7be7, 0x7be8, 0x7be9, 0x7bea, 0x7beb, 0x7bec,   // U+d128 ~ U+d12f
0x7bed, 0x7bee, 0x7bef, 0x7bf0, 0x7bf1, 0x7bf2, 0x7bf3, 0x7bf4,   // U+d130 ~ U+d137
0x7bf5, 0x7bf6, 0x7bf7, 0x7bf8, 0x7bf9, 0x7bfa, 0x7bfb, 0x7bfc,   // U+d138 ~ U+d13f
0x7bfd, 0x7bfe, 0x7bff, 0x7c00, 0x7c01, 0x7c02, 0x7c03, 0x7c04,   // U+d140 ~ U+d147
0x7c05, 0x7c06, 0x7c07, 0x7c08, 0x7c09, 0x7c0a, 0x7c0b, 0x7c0c,   // U+d148 ~ U+d14f
0x7c0d, 0x7c0e, 0x7c0f, 0x7c10, 0x7c11, 0x7c12, 0x7c13, 0x7c14,   // U+d150 ~ U+d157
0x7c15, 0x7c16, 0x7c17, 0x7c18, 0x7c19, 0x7c1a, 0x7c1b, 0x7c1c,   // U+d158 ~ U+d15f
0x7c1d, 0x7c1e, 0x7c1f, 0x7c20, 0x7c21, 0x7c22, 0x7c23, 0x7c24,   // U+d160 ~ U+d167
0x7c25, 0x7c26, 0x7c27, 0x7c28, 0x7c29, 0x7c2a, 0x7c2b, 0x7c2c,   // U+d168 ~ U+d16f
0x7c2d, 0x7c2e, 0x7c2f, 0x7c30, 0x7c31, 0x7c32, 0x7c33, 0x7c34,   // U+d170 ~ U+d177
0x7c35, 0x7c36, 0x7c37, 0x7c38, 0x7c39, 0x7c3a, 0x7c3b, 0x7c3c,   // U+d178 ~ U+d17f
0x7c3d, 0x7c3e, 0x7c3f, 0x7c40, 0x7c41, 0x7c42, 0x7c43, 0x7c44,   // U+d180 ~ U+d187
0x7c45, 0x7c46, 0x7c47, 0x7c48, 0x7c49, 0x7c4a, 0x7c4b, 0x7c4c,   // U+d188 ~ U+d18f
0x7c4d, 0x7c4e, 0x7c4f, 0x7c50, 0x7c51, 0x7c52, 0x7c53, 0x7c54,   // U+d190 ~ U+d197
0x7c55, 0x7c56, 0x7c57, 0x7c58, 0x7c59, 0x7c5a, 0x7c5b, 0x7c5c,   // U+d198 ~ U+d19f
0x7c5d, 0x7c5e, 0x7c5f, 0x7c60, 0x7c61, 0x7c62, 0x7c63, 0x7c64,   // U+d1a0 ~ U+d1a7
0x7c65, 0x7c66, 0x7c67, 0x7c68, 0x7c69, 0x7c6a, 0x7c6b, 0x7c6c,   // U+d1a8 ~ U+d1af
0x7c6d, 0x7c6e, 0x7c6f, 0x7c70, 0x7c71, 0x7c72, 0x7c73, 0x7c74,   // U+d1b0 ~ U+d1b7
0x7c75, 0x7c76, 0x7c77, 0x7c78, 0x7c79, 0x7c7a, 0x7c7b, 0x7c7c,   // U+d1b8 ~ U+d1bf
0x7c7d, 0x7c7e, 0x7c7f, 0x7c80, 0x7c81, 0x7c82, 0x7c83, 0x7c84,   // U+d1c0 ~ U+d1c7
0x7c85, 0x7c86, 0x7c87, 0x7c88, 0x7c89, 0x7c8a, 0x7c8b, 0x7c8c,   // U+d1c8 ~ U+d1cf
0x7c8d, 0x7c8e, 0x7c8f, 0x7c90, 0x7c91, 0x7c92, 0x7c93, 0x7c94,   // U+d1d0 ~ U+d1d7
0x7c95, 0x7c96, 0x7c97, 0x7c98, 0x7c99, 0x7c9a, 0x7c9b, 0x7c9c,   // U+d1d8 ~ U+d1df
0x7c9d, 0x7c9e, 0x7c9f, 0x7ca0, 0x7ca1, 0x7ca2, 0x7ca3, 0x7ca4,   // U+d1e0 ~ U+d1e7
0x7ca5, 0x7ca6, 0x7ca7, 0x7ca8, 0x7ca9, 0x7caa, 0x7cab, 0x7cac,   // U+d1e8 ~ U+d1ef
0x7cad, 0x7cae, 0x7caf, 0x7cb0, 0x7cb1, 0x7cb2, 0x7cb3, 0x7cb4,   // U+d1f0 ~ U+d1f7
0x7cb5, 0x7cb6, 0x7cb7, 0x7cb8, 0x7cb9, 0x7cba, 0x7cbb, 0x7cbc,   // U+d1f8 ~ U+d1ff
0x7cbd, 0x7cbe, 0x7cbf, 0x7cc0, 0x7cc1, 0x7cc2, 0x7cc3, 0x7cc4,   // U+d200 ~ U+d207
0x7cc5, 0x7cc6, 0x7cc7, 0x7cc8, 0x7cc9, 0x7cca, 0x7ccb, 0x7ccc,   // U+d208 ~ U+d20f
0x7ccd, 0x7cce, 0x7ccf, 0x7cd0, 0x7cd1, 0x7cd2, 0x7cd3, 0x7cd4,   // U+d210 ~ U+d217
0x7cd5, 0x7cd6, 0x7cd7, 0x7cd8, 0x7cd9, 0x7cda, 0x7cdb, 0x7cdc,   // U+d218 ~ U+d21f
0x7cdd, 0x7cde, 0x7cdf, 0x7ce0, 0x7ce1, 0x7ce2, 0x7ce3, 0x7ce4,   // U+d220 ~ U+d227
0x7ce5, 0x7ce6, 0x7ce7, 0x7ce8, 0x7ce9, 0x7cea, 0x7ceb, 0x7cec,   // U+d228 ~ U+d22f
0x7ced, 0x7cee, 0x7cef, 0x7cf0, 0x7cf1, 0x7cf2, 0x7cf3, 0x7cf4,   // U+d230 ~ U+d237
0x7cf5, 0x7cf6, 0x7cf7, 0x7cf8, 0x7cf9, 0x7cfa, 0x7cfb, 0x7cfc,   // U+d238 ~ U+d23f
0x7cfd, 0x7cfe, 0x7cff, 0x7d00, 0x7d01, 0x7d02, 0x7d03, 0x7d04,   // U+d240 ~ U+d247
0x7d05, 0x7d06, 0x7d07, 0x7d08, 0x7d09, 0x7d0a, 0x7d0b, 0x7d0c,   // U+d248 ~ U+d24f
0x7d0d, 0x7d0e, 0x7d0f, 0x7d10, 0x7d11, 0x7d12, 0x7d13, 0x7d14,   // U+d250 ~ U+d257
0x7d15, 0x7d16, 0x7d17, 0x7d18, 0x7d19, 0x7d1a, 0x7d1b, 0x7d1c,   // U+d258 ~ U+d25f
0x7d1d, 0x7d1e, 0x7d1f, 0x7d20, 0x7d21, 0x7d22, 0x7d23, 0x7d24,   // U+d260 ~ U+d267
0x7d25, 0x7d26, 0x7d27, 0x7d28, 0x7d29, 0x7d2a, 0x7d2b, 0x7d2c,   // U+d268 ~ U+d26f
0x7d2d, 0x7d2e, 0x7d2f, 0x7d30, 0x7d31, 0x7d32, 0x7d33, 0x7d34,   // U+d270 ~ U+d277
0x7d35, 0x7d36, 0x7d37, 0x7d38, 0x7d39, 0x7d3a, 0x7d3b, 0x7d3c,   // U+d278 ~ U+d27f
0x7d3d, 0x7d3e, 0x7d3f, 0x7d40, 0x7d41, 0x7d42, 0x7d43, 0x7d44,   // U+d280 ~ U+d287
0x7d45, 0x7d46, 0x7d47, 0x7d48, 0x7d49, 0x7d4a, 0x7d4b, 0x7d4c,   // U+d288 ~ U+d28f
0x7d4d, 0x7d4e, 0x7d4f, 0x7d50, 0x7d51, 0x7d52, 0x7d53, 0x7d54,   // U+d290 ~ U+d297
0x7d55, 0x7d56, 0x7d57, 0x7d58, 0x7d59, 0x7d5a, 0x7d5b, 0x7d5c,   // U+d298 ~ U+d29f
0x7d5d, 0x7d5e, 0x7d5f, 0x7d60, 0x7d61, 0x7d62, 0x7d63, 0x7d64,   // U+d2a0 ~ U+d2a7
0x7d65, 0x7d66, 0x7d67, 0x7d68, 0x7d69, 0x7d6a, 0x7d6b, 0x7d6c,   // U+d2a8 ~ U+d2af
0x7d6d, 0x7d6e, 0x7d6f, 0x7d70, 0x7d71, 0x7d72, 0x7d73, 0x7d74,   // U+d2b0 ~ U+d2b7
0x7d75, 0x7d76, 0x7d77, 0x7d78, 0x7d79, 0x7d7a, 0x7d7b, 0x7d7c,   // U+d2b8 ~ U+d2bf
0x7d7d, 0x7d7e, 0x7d7f, 0x7d80, 0x7d81, 0x7d82, 0x7d83, 0x7d84,   // U+d2c0 ~ U+d2c7
0x7d85, 0x7d86, 0x7d87, 0x7d88, 0x7d89, 0x7d8a, 0x7d8b, 0x7d8c,   // U+d2c8 ~ U+d2cf
0x7d8d, 0x7d8e, 0x7d8f, 0x7d90, 0x7d91, 0x7d92, 0x7d93, 0x7d94,   // U+d2d0 ~ U+d2d7
0x7d95, 0x7d96, 0x7d97, 0x7d98, 0x7d99, 0x7d9a, 0x7d9b, 0x7d9c,   // U+d2d8 ~ U+d2df
0x7d9d, 0x7d9e, 0x7d9f, 0x7da0, 0x7da1, 0x7da2, 0x7da3, 0x7da4,   // U+d2e0 ~ U+d2e7
0x7da5, 0x7da6, 0x7da7, 0x7da8, 0x7da9, 0x7daa, 0x7dab, 0x7dac,   // U+d2e8 ~ U+d2ef
0x7dad, 0x7dae, 0x7daf, 0x7db0, 0x7db1, 0x7db2, 0x7db3, 0x7db4,   // U+d2f0 ~ U+d2f7
0x7db5, 0x7db6, 0x7db7, 0x7db8, 0x7db9, 0x7dba, 0x7dbb, 0x7dbc,   // U+d2f8 ~ U+d2ff
0x7dbd, 0x7dbe, 0x7dbf, 0x7dc0, 0x7dc1, 0x7dc2, 0x7dc3, 0x7dc4,   // U+d300 ~ U+d307
0x7dc5, 0x7dc6, 0x7dc7, 0x7dc8, 0x7dc9, 0x7dca, 0x7dcb, 0x7dcc,   // U+d308 ~ U+d30f
0x7dcd, 0x7dce, 0x7dcf, 0x7dd0, 0x7dd1, 0x7dd2, 0x7dd3, 0x7dd4,   // U+d310 ~ U+d317
0x7dd5, 0x7dd6, 0x7dd7, 0x7dd8, 0x7dd9, 0x7dda, 0x7ddb, 0x7ddc,   // U+d318 ~ U+d31f
0x7ddd, 0x7dde, 0x7ddf, 0x7de0, 0x7de1, 0x7de2, 0x7de3, 0x7de4,   // U+d320 ~ U+d327
0x7de5, 0x7de6, 0x7de7, 0x7de8, 0x7de9, 0x7dea, 0x7deb, 0x7dec,   // U+d328 ~ U+d32f
0x7ded, 0x7dee, 0x7def, 0x7df0, 0x7df1, 0x7df2, 0x7df3, 0x7df4,   // U+d330 ~ U+d337
0x7df5, 0x7df6, 0x7df7, 0x7df8, 0x7df9, 0x7dfa, 0x7dfb, 0x7dfc,   // U+d338 ~ U+d33f
0x7dfd, 0x7dfe, 0x7dff, 0x7e00, 0x7e01, 0x7e02, 0x7e03, 0x7e04,   // U+d340 ~ U+d347
0x7e05, 0x7e06, 0x7e07, 0x7e08, 0x7e09, 0x7e0a, 0x7e0b, 0x7e0c,   // U+d348 ~ U+d34f
0x7e0d, 0x7e0e, 0x7e0f, 0x7e10, 0x7e11, 0x7e12, 0x7e13, 0x7e14,   // U+d350 ~ U+d357
0x7e15, 0x7e16, 0x7e17, 0x7e18, 0x7e19, 0x7e1a, 0x7e1b, 0x7e1c,   // U+d358 ~ U+d35f
0x7e1d, 0x7e1e, 0x7e1f, 0x7e20, 0x7e21, 0x7e22, 0x7e23, 0x7e24,   // U+d360 ~ U+d367
0x7e25, 0x7e26, 0x7e27, 0x7e28, 0x7e29, 0x7e2a, 0x7e2b, 0x7e2c,   // U+d368 ~ U+d36f
0x7e2d, 0x7e2e, 0x7e2f, 0x7e30, 0x7e31, 0x7e32, 0x7e33, 0x7e34,   // U+d370 ~ U+d377
0x7e35, 0x7e36, 0x7e37, 0x7e38, 0x7e39, 0x7e3a, 0x7e3b, 0x7e3c,   // U+d378 ~ U+d37f
0x7e3d, 0x7e3e, 0x7e3f, 0x7e40, 0x7e41, 0x7e42, 0x7e43, 0x7e44,   // U+d380 ~ U+d387
0x7e45, 0x7e46, 0x7e47, 0x7e48, 0x7e49, 0x7e4a, 0x7e4b, 0x7e4c,   // U+d388 ~ U+d38f
0x7e4d, 0x7e4e, 0x7e4f, 0x7e50, 0x7e51, 0x7e52, 0x7e53, 0x7e54,   // U+d390 ~ U+d397
0x7e55, 0x7e56, 0x7e57, 0x7e58, 0x7e59, 0x7e5a, 0x7e5b, 0x7e5c,   // U+d398 ~ U+d39f
0x7e5d, 0x7e5e, 0x7e5f, 0x7e60, 0x7e61, 0x7e62, 0x7e63, 0x7e64,   // U+d3a0 ~ U+d3a7
0x7e65, 0x7e66, 0x7e67, 0x7e68, 0x7e69, 0x7e6a, 0x7e6b, 0x7e6c,   // U+d3a8 ~ U+d3af
0x7e6d, 0x7e6e, 0x7e6f, 0x7e70, 0x7e71, 0x7e72, 0x7e73, 0x7e74,   // U+d3b0 ~ U+d3b7
0x7e75, 0x7e76, 0x7e77, 0x7e78, 0x7e79, 0x7e7a, 0x7e7b, 0x7e7c,   // U+d3b8 ~ U+d3bf
0x7e7d, 0x7e7e, 0x7e7f, 0x7e80, 0x7e81, 0x7e82, 0x7e83, 0x7e84,   // U+d3c0 ~ U+d3c7
0x7e85, 0x7e86, 0x7e87, 0x7e88, 0x7e89, 0x7e8a, 0x7e8b, 0x7e8c,   // U+d3c8 ~ U+d3cf
0x7e8d, 0x7e8e, 0x7e8f, 0x7e90, 0x7e91, 0x7e92, 0x7e93, 0x7e94,   // U+d3d0 ~ U+d3d7
0x7e95, 0x7e96, 0x7e97, 0x7e98, 0x7e99, 0x7e9a, 0x7e9b, 0x7e9c,   // U+d3d8 ~ U+d3df
0x7e9d, 0x7e9e, 0x7e9f, 0x7ea0, 0x7ea1, 0x7ea2, 0x7ea3, 0x7ea4,   // U+d3e0 ~ U+d3e7
0x7ea5, 0x7ea6, 0x7ea7, 0x7ea8, 0x7ea9, 0x7eaa, 0x7eab, 0x7eac,   // U+d3e8 ~ U+d3ef
0x7ead, 0x7eae, 0x7eaf, 0x7eb0, 0x7eb1, 0x7eb2, 0x7eb3, 0x7eb4,   // U+d3f0 ~ U+d3f7
0x7eb5, 0x7eb6, 0x7eb7, 0x7eb8, 0x7eb9, 0x7eba, 0x7ebb, 0x7ebc,   // U+d3f8 ~ U+d3ff
0x7ebd, 0x7ebe, 0x7ebf, 0x7ec0, 0x7ec1, 0x7ec2, 0x7ec3, 0x7ec4,   // U+d400 ~ U+d407
0x7ec5, 0x7ec6, 0x7ec7, 0x7ec8, 0x7ec9, 0x7eca, 0x7ecb, 0x7ecc,   // U+d408 ~ U+d40f
0x7ecd, 0x7ece, 0x7ecf, 0x7ed0, 0x7ed1, 0x7ed2, 0x7ed3, 0x7ed4,   // U+d410 ~ U+d417
0x7ed5, 0x7ed6, 0x7ed7, 0x7ed8, 0x7ed9, 0x7eda, 0x7edb, 0x7edc,   // U+d418 ~ U+d41f
0x7edd, 0x7ede, 0x7edf, 0x7ee0, 0x7ee1, 0x7ee2, 0x7ee3, 0x7ee4,   // U+d420 ~ U+d427
0x7ee5, 0x7ee6, 0x7ee7, 0x7ee8, 0x7ee9, 0x7eea, 0x7eeb, 0x7eec,   // U+d428 ~ U+d42f
0x7eed, 0x7eee, 0x7eef, 0x7ef0, 0x7ef1, 0x7ef2, 0x7ef3, 0x7ef4,   // U+d430 ~ U+d437
0x7ef5, 0x7ef6, 0x7ef7, 0x7ef8, 0x7ef9, 0x7efa, 0x7efb, 0x7efc,   // U+d438 ~ U+d43f
0x7efd, 0x7efe, 0x7eff, 0x7f00, 0x7f01, 0x7f02, 0x7f03, 0x7f04,   // U+d440 ~ U+d447
0x7f05, 0x7f06, 0x7f07, 0x7f08, 0x7f09, 0x7f0a, 0x7f0b, 0x7f0c,   // U+d448 ~ U+d44f
0x7f0d, 0x7f0e, 0x7f0f, 0x7f10, 0x7f11, 0x7f12, 0x7f13, 0x7f14,   // U+d450 ~ U+d457
0x7f15, 0x7f16, 0x7f17, 0x7f18, 0x7f19, 0x7f1a, 0x7f1b, 0x7f1c,   // U+d458 ~ U+d45f
0x7f1d, 0x7f1e, 0x7f1f, 0x7f20, 0x7f21, 0x7f22, 0x7f23, 0x7f24,   // U+d460 ~ U+d467
0x7f25, 0x7f26, 0x7f27, 0x7f28, 0x7f29, 0x7f2a, 0x7f2b, 0x7f2c,   // U+d468 ~ U+d46f
0x7f2d, 0x7f2e, 0x7f2f, 0x7f30, 0x7f31, 0x7f32, 0x7f33, 0x7f34,   // U+d470 ~ U+d477
0x7f35, 0x7f36, 0x7f37, 0x7f38, 0x7f39, 0x7f3a, 0x7f3b, 0x7f3c,   // U+d478 ~ U+d47f
0x7f3d, 0x7f3e, 0x7f3f, 0x7f40, 0x7f41, 0x7f42, 0x7f43, 0x7f44,   // U+d480 ~ U+d487
0x7f45, 0x7f46, 0x7f47, 0x7f48, 0x7f49, 0x7f4a, 0x7f4b, 0x7f4c,   // U+d488 ~ U+d48f
0x7f4d, 0x7f4e, 0x7f4f, 0x7f50, 0x7f51, 0x7f52, 0x7f53, 0x7f54,   // U+d490 ~ U+d497
0x7f55, 0x7f56, 0x7f57, 0x7f58, 0x7f59, 0x7f5a, 0x7f5b, 0x7f5c,   // U+d498 ~ U+d49f
0x7f5d, 0x7f5e, 0x7f5f, 0x7f60, 0x7f61, 0x7f62, 0x7f63, 0x7f64,   // U+d4a0 ~ U+d4a7
0x7f65, 0x7f66, 0x7f67, 0x7f68, 0x7f69, 0x7f6a, 0x7f6b, 0x7f6c,   // U+d4a8 ~ U+d4af
0x7f6d, 0x7f6e, 0x7f6f, 0x7f70, 0x7f71, 0x7f72, 0x7f73, 0x7f74,   // U+d4b0 ~ U+d4b7
0x7f75, 0x7f76, 0x7f77, 0x7f78, 0x7f79, 0x7f7a, 0x7f7b, 0x7f7c,   // U+d4b8 ~ U+d4bf
0x7f7d, 0x7f7e, 0x7f7f, 0x7f80, 0x7f81, 0x7f82, 0x7f83, 0x7f84,   // U+d4c0 ~ U+d4c7
0x7f85, 0x7f86, 0x7f87, 0x7f88, 0x7f89, 0x7f8a, 0x7f8b, 0x7f8c,   // U+d4c8 ~ U+d4cf
0x7f8d, 0x7f8e, 0x7f8f, 0x7f90, 0x7f91, 0x7f92, 0x7f93, 0x7f94,   // U+d4d0 ~ U+d4d7
0x7f95, 0x7f96, 0x7f97, 0x7f98, 0x7f99, 0x7f9a, 0x7f9b, 0x7f9c,   // U+d4d8 ~ U+d4df
0x7f9d, 0x7f9e, 0x7f9f, 0x7fa0, 0x7fa1, 0x7fa2, 0x7fa3, 0x7fa4,   // U+d4e0 ~ U+d4e7
0x7fa5, 0x7fa6, 0x7fa7, 0x7fa8, 0x7fa9, 0x7faa, 0x7fab, 0x7fac,   // U+d4e8 ~ U+d4ef
0x7fad, 0x7fae, 0x7faf, 0x7fb0, 0x7fb1, 0x7fb2, 0x7fb3, 0x7fb4,   // U+d4f0 ~ U+d4f7
0x7fb5, 0x7fb6, 0x7fb7, 0x7fb8, 0x7fb9, 0x7fba, 0x7fbb, 0x7fbc,   // U+d4f8 ~ U+d4ff
0x7fbd, 0x7fbe, 0x7fbf, 0x7fc0, 0x7fc1, 0x7fc2, 0x7fc3, 0x7fc4,   // U+d500 ~ U+d507
0x7fc5, 0x7fc6, 0x7fc7, 0x7fc8, 0x7fc9, 0x7fca, 0x7fcb, 0x7fcc,   // U+d508 ~ U+d50f
0x7fcd, 0x7fce, 0x7fcf, 0x7fd0, 0x7fd1, 0x7fd2, 0x7fd3, 0x7fd4,   // U+d510 ~ U+d517
0x7fd5, 0x7fd6, 0x7fd7, 0x7fd8, 0x7fd9, 0x7fda, 0x7fdb, 0x7fdc,   // U+d518 ~ U+d51f
0x7fdd, 0x7fde, 0x7fdf, 0x7fe0, 0x7fe1, 0x7fe2, 0x7fe3, 0x7fe4,   // U+d520 ~ U+d527
0x7fe5, 0x7fe6, 0x7fe7, 0x7fe8, 0x7fe9, 0x7fea, 0x7feb, 0x7fec,   // U+d528 ~ U+d52f
0x7fed, 0x7fee, 0x7fef, 0x7ff0, 0x7ff1, 0x7ff2, 0x7ff3, 0x7ff4,   // U+d530 ~ U+d537
0x7ff5, 0x7ff6, 0x7ff7, 0x7ff8, 0x7ff9, 0x7ffa, 0x7ffb, 0x7ffc,   // U+d538 ~ U+d53f
0x7ffd, 0x7ffe, 0x7fff, 0x8000, 0x8001, 0x8002, 0x8003, 0x8004,   // U+d540 ~ U+d547
0x8005, 0x8006, 0x8007, 0x8008, 0x8009, 0x800a, 0x800b, 0x800c,   // U+d548 ~ U+d54f
0x800d, 0x800e, 0x800f, 0x8010, 0x8011, 0x8012, 0x8013, 0x8014,   // U+d550 ~ U+d557
0x8015, 0x8016, 0x8017, 0x8018, 0x8019, 0x801a, 0x801b, 0x801c,   // U+d558 ~ U+d55f
0x801d, 0x801e, 0x801f, 0x8020, 0x8021, 0x8022, 0x8023, 0x8024,   // U+d560 ~ U+d567
0x8025, 0x8026, 0x8027, 0x8028, 0x8029, 0x802a, 0x802b, 0x802c,   // U+d568 ~ U+d56f
0x802d, 0x802e, 0x802f, 0x8030, 0x8031, 0x8032, 0x8033, 0x8034,   // U+d570 ~ U+d577
0x8035, 0x8036, 0x8037, 0x8038, 0x8039, 0x803a, 0x803b, 0x803c,   // U+d578 ~ U+d57f
0x803d, 0x803e, 0x803f, 0x8040, 0x8041, 0x8042, 0x8043, 0x8044,   // U+d580 ~ U+d587
0x8045, 0x8046, 0x8047, 0x8048, 0x8049, 0x804a, 0x804b, 0x804c,   // U+d588 ~ U+d58f
0x804d, 0x804e, 0x804f, 0x8050, 0x8051, 0x8052, 0x8053, 0x8054,   // U+d590 ~ U+d597
0x8055, 0x8056, 0x8057, 0x8058, 0x8059, 0x805a, 0x805b, 0x805c,   // U+d598 ~ U+d59f
0x805d, 0x805e, 0x805f, 0x8060, 0x8061, 0x8062, 0x8063, 0x8064,   // U+d5a0 ~ U+d5a7
0x8065, 0x8066, 0x8067, 0x8068, 0x8069, 0x806a, 0x806b, 0x806c,   // U+d5a8 ~ U+d5af
0x806d, 0x806e, 0x806f, 0x8070, 0x8071, 0x8072, 0x8073, 0x8074,   // U+d5b0 ~ U+d5b7
0x8075, 0x8076, 0x8077, 0x8078, 0x8079, 0x807a, 0x807b, 0x807c,   // U+d5b8 ~ U+d5bf
0x807d, 0x807e, 0x807f, 0x8080, 0x8081, 0x8082, 0x8083, 0x8084,   // U+d5c0 ~ U+d5c7
0x8085, 0x8086, 0x8087, 0x8088, 0x8089, 0x808a, 0x808b, 0x808c,   // U+d5c8 ~ U+d5cf
0x808d, 0x808e, 0x808f, 0x8090, 0x8091, 0x8092, 0x8093, 0x8094,   // U+d5d0 ~ U+d5d7
0x8095, 0x8096, 0x8097, 0x8098, 0x8099, 0x809a, 0x809b, 0x809c,   // U+d5d8 ~ U+d5df
0x809d, 0x809e, 0x809f, 0x80a0, 0x80a1, 0x80a2, 0x80a3, 0x80a4,   // U+d5e0 ~ U+d5e7
0x80a5, 0x80a6, 0x80a7, 0x80a8, 0x80a9, 0x80aa, 0x80ab, 0x80ac,   // U+d5e8 ~ U+d5ef
0x80ad, 0x80ae, 0x80af, 0x80b0, 0x80b1, 0x80b2, 0x80b3, 0x80b4,   // U+d5f0 ~ U+d5f7
0x80b5, 0x80b6, 0x80b7, 0x80b8, 0x80b9, 0x80ba, 0x80bb, 0x80bc,   // U+d5f8 ~ U+d5ff
0x80bd, 0x80be, 0x80bf, 0x80c0, 0x80c1, 0x80c2, 0x80c3, 0x80c4,   // U+d600 ~ U+d607
0x80c5, 0x80c6, 0x80c7, 0x80c8, 0x80c9, 0x80ca, 0x80cb, 0x80cc,   // U+d608 ~ U+d60f
0x80cd, 0x80ce, 0x80cf, 0x80d0, 0x80d1, 0x80d2, 0x80d3, 0x80d4,   // U+d610 ~ U+d617
0x80d5, 0x80d6, 0x80d7, 0x80d8, 0x80d9, 0x80da, 0x80db, 0x80dc,   // U+d618 ~ U+d61f
0x80dd, 0x80de, 0x80df, 0x80e0, 0x80e1, 0x80e2, 0x80e3, 0x80e4,   // U+d620 ~ U+d627
0x80e5, 0x80e6, 0x80e7, 0x80e8, 0x80e9, 0x80ea, 0x80eb, 0x80ec,   // U+d628 ~ U+d62f
0x80ed, 0x80ee, 0x80ef, 0x80f0, 0x80f1, 0x80f2, 0x80f3, 0x80f4,   // U+d630 ~ U+d637
0x80f5, 0x80f6, 0x80f7, 0x80f8, 0x80f9, 0x80fa, 0x80fb, 0x80fc,   // U+d638 ~ U+d63f
0x80fd, 0x80fe, 0x80ff, 0x8100, 0x8101, 0x8102, 0x8103, 0x8104,   // U+d640 ~ U+d647
0x8105, 0x8106, 0x8107, 0x8108, 0x8109, 0x810a, 0x810b, 0x810c,   // U+d648 ~ U+d64f
0x810d, 0x810e, 0x810f, 0x8110, 0x8111, 0x8112, 0x8113, 0x8114,   // U+d650 ~ U+d657
0x8115, 0x8116, 0x8117, 0x8118, 0x8119, 0x811a, 0x811b, 0x811c,   // U+d658 ~ U+d65f
0x811d, 0x811e, 0x811f, 0x8120, 0x8121, 0x8122, 0x8123, 0x8124,   // U+d660 ~ U+d667
0x8125, 0x8126, 0x8127, 0x8128, 0x8129, 0x812a, 0x812b, 0x812c,   // U+d668 ~ U+d66f
0x812d, 0x812e, 0x812f, 0x8130, 0x8131, 0x8132, 0x8133, 0x8134,   // U+d670 ~ U+d677
0x8135, 0x8136, 0x8137, 0x8138, 0x8139, 0x813a, 0x813b, 0x813c,   // U+d678 ~ U+d67f
0x813d, 0x813e, 0x813f, 0x8140, 0x8141, 0x8142, 0x8143, 0x8144,   // U+d680 ~ U+d687
0x8145, 0x8146, 0x8147, 0x8148, 0x8149, 0x814a, 0x814b, 0x814c,   // U+d688 ~ U+d68f
0x814d, 0x814e, 0x814f, 0x8150, 0x8151, 0x8152, 0x8153, 0x8154,   // U+d690 ~ U+d697
0x8155, 0x8156, 0x8157, 0x8158, 0x8159, 0x815a, 0x815b, 0x815c,   // U+d698 ~ U+d69f
0x815d, 0x815e, 0x815f, 0x8160, 0x8161, 0x8162, 0x8163, 0x8164,   // U+d6a0 ~ U+d6a7
0x8165, 0x8166, 0x8167, 0x8168, 0x8169, 0x816a, 0x816b, 0x816c,   // U+d6a8 ~ U+d6af
0x816d, 0x816e, 0x816f, 0x8170, 0x8171, 0x8172, 0x8173, 0x8174,   // U+d6b0 ~ U+d6b7
0x8175, 0x8176, 0x8177, 0x8178, 0x8179, 0x817a, 0x817b, 0x817c,   // U+d6b8 ~ U+d6bf
0x817d, 0x817e, 0x817f, 0x8180, 0x8181, 0x8182, 0x8183, 0x8184,   // U+d6c0 ~ U+d6c7
0x8185, 0x8186, 0x8187, 0x8188, 0x8189, 0x818a, 0x818b, 0x818c,   // U+d6c8 ~ U+d6cf
0x818d, 0x818e, 0x818f, 0x8190, 0x8191, 0x8192, 0x8193, 0x8194,   // U+d6d0 ~ U+d6d7
0x8195, 0x8196, 0x8197, 0x8198, 0x8199, 0x819a, 0x819b, 0x819c,   // U+d6d8 ~ U+d6df
0x819d, 0x819e, 0x819f, 0x81a0, 0x81a1, 0x81a2, 0x81a3, 0x81a4,   // U+d6e0 ~ U+d6e7
0x81a5, 0x81a6, 0x81a7, 0x81a8, 0x81a9, 0x81aa, 0x81ab, 0x81ac,   // U+d6e8 ~ U+d6ef
0x81ad, 0x81ae, 0x81af, 0x81b0, 0x81b1, 0x81b2, 0x81b3, 0x81b4,   // U+d6f0 ~ U+d6f7
0x81b5, 0x81b6, 0x81b7, 0x81b8, 0x81b9, 0x81ba, 0x81bb, 0x81bc,   // U+d6f8 ~ U+d6ff
0x81bd, 0x81be, 0x81bf, 0x81c0, 0x81c1, 0x81c2, 0x81c3, 0x81c4,   // U+d700 ~ U+d707
0x81c5, 0x81c6, 0x81c7, 0x81c8, 0x81c9, 0x81ca, 0x81cb, 0x81cc,   // U+d708 ~ U+d70f
0x81cd, 0x81ce, 0x81cf, 0x81d0, 0x81d1, 0x81d2, 0x81d3, 0x81d4,   // U+d710 ~ U+d717
0x81d5, 0x81d6, 0x81d7, 0x81d8, 0x81d9, 0x81da, 0x81db, 0x81dc,   // U+d718 ~ U+d71f
0x81dd, 0x81de, 0x81df, 0x81e0, 0x81e1, 0x81e2, 0x81e3, 0x81e4,   // U+d720 ~ U+d727
0x81e5, 0x81e6, 0x81e7, 0x81e8, 0x81e9, 0x81ea, 0x81eb, 0x81ec,   // U+d728 ~ U+d72f
0x81ed, 0x81ee, 0x81ef, 0x81f0, 0x81f1, 0x81f2, 0x81f3, 0x81f4,   // U+d730 ~ U+d737
0x81f5, 0x81f6, 0x81f7, 0x81f8, 0x81f9, 0x81fa, 0x81fb, 0x81fc,   // U+d738 ~ U+d73f
0x81fd, 0x81fe, 0x81ff, 0x8200, 0x8201, 0x8202, 0x8203, 0x8204,   // U+d740 ~ U+d747
0x8205, 0x8206, 0x8207, 0x8208, 0x8209, 0x820a, 0x820b, 0x820c,   // U+d748 ~ U+d74f
0x820d, 0x820e, 0x820f, 0x8210, 0x8211, 0x8212, 0x8213, 0x8214,   // U+d750 ~ U+d757
0x8215, 0x8216, 0x8217, 0x8218, 0x8219, 0x821a, 0x821b, 0x821c,   // U+d758 ~ U+d75f
0x821d, 0x821e, 0x821f, 0x8220, 0x8221, 0x8222, 0x8223, 0x8224,   // U+d760 ~ U+d767
0x8225, 0x8226, 0x8227, 0x8228, 0x8229, 0x822a, 0x822b, 0x822c,   // U+d768 ~ U+d76f
0x822d, 0x822e, 0x822f, 0x8230, 0x8231, 0x8232, 0x8233, 0x8234,   // U+d770 ~ U+d777
0x8235, 0x8236, 0x8237, 0x8238, 0x8239, 0x823a, 0x823b, 0x823c,   // U+d778 ~ U+d77f
0x823d, 0x823e, 0x823f, 0x8240, 0x8241, 0x8242, 0x8243, 0x8244,   // U+d780 ~ U+d787
0x8245, 0x8246, 0x8247, 0x8248, 0x8249, 0x824a, 0x824b, 0x824c,   // U+d788 ~ U+d78f
0x824d, 0x824e, 0x824f, 0x8250, 0x8251, 0x8252, 0x8253, 0x8254,   // U+d790 ~ U+d797
0x8255, 0x8256, 0x8257, 0x8258, 0x8259, 0x825a, 0x825b, 0x825c,   // U+d798 ~ U+d79f
0x825d, 0x825e, 0x825f, 0x8260, 0x8261, 0x8262, 0x8263, 0x8264,   // U+d7a0 ~ U+d7a7
0x8265, 0x8266, 0x8267, 0x8268, 0x8269, 0x826a, 0x826b, 0x826c,   // U+d7a8 ~ U+d7af
0x826d, 0x826e, 0x826f, 0x8270, 0x8271, 0x8272, 0x8273, 0x8274,   // U+d7b0 ~ U+d7b7
0x8275, 0x8276, 0x8277, 0x8278, 0x8279, 0x827a, 0x827b, 0x827c,   // U+d7b8 ~ U+d7bf
0x827d, 0x827e, 0x827f, 0x8280, 0x8281, 0x8282, 0x8283, 0x8284,   // U+d7c0 ~ U+d7c7
0x8285, 0x8286, 0x8287, 0x8288, 0x8289, 0x828a, 0x828b, 0x828c,   // U+d7c8 ~ U+d7cf
0x828d, 0x828e, 0x828f, 0x8290, 0x8291, 0x8292, 0x8293, 0x8294,   // U+d7d0 ~ U+d7d7
0x8295, 0x8296, 0x8297, 0x8298, 0x8299, 0x829a, 0x829b, 0x829c,   // U+d7d8 ~ U+d7df
0x829d, 0x829e, 0x829f, 0x82a0, 0x82a1, 0x82a2, 0x82a3, 0x82a4,   // U+d7e0 ~ U+d7e7
0x82a5, 0x82a6, 0x82a7, 0x82a8, 0x82a9, 0x82aa, 0x82ab, 0x82ac,   // U+d7e8 ~ U+d7ef
0x82ad, 0x82ae, 0x82af, 0x82b0, 0x82b1, 0x82b2, 0x82b3, 0x82b4,   // U+d7f0 ~ U+d7f7
0x82b5, 0x82b6, 0x82b7, 0x82b8, 0x82b9, 0x82ba, 0x82bb, 0x82bc,   // U+d7f8 ~ U+d7ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d800 ~ U+d807
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d808 ~ U+d80f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d810 ~ U+d817
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d818 ~ U+d81f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d820 ~ U+d827
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d828 ~ U+d82f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d830 ~ U+d837
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d838 ~ U+d83f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d840 ~ U+d847
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d848 ~ U+d84f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d850 ~ U+d857
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d858 ~ U+d85f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d860 ~ U+d867
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d868 ~ U+d86f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d870 ~ U+d877
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d878 ~ U+d87f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d880 ~ U+d887
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d888 ~ U+d88f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d890 ~ U+d897
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d898 ~ U+d89f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d8a0 ~ U+d8a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d8a8 ~ U+d8af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d8b0 ~ U+d8b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d8b8 ~ U+d8bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d8c0 ~ U+d8c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d8c8 ~ U+d8cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d8d0 ~ U+d8d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d8d8 ~ U+d8df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d8e0 ~ U+d8e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d8e8 ~ U+d8ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d8f0 ~ U+d8f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d8f8 ~ U+d8ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d900 ~ U+d907
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d908 ~ U+d90f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d910 ~ U+d917
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d918 ~ U+d91f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d920 ~ U+d927
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d928 ~ U+d92f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d930 ~ U+d937
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d938 ~ U+d93f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d940 ~ U+d947
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d948 ~ U+d94f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d950 ~ U+d957
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d958 ~ U+d95f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d960 ~ U+d967
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d968 ~ U+d96f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d970 ~ U+d977
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d978 ~ U+d97f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d980 ~ U+d987
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d988 ~ U+d98f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d990 ~ U+d997
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d998 ~ U+d99f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d9a0 ~ U+d9a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d9a8 ~ U+d9af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d9b0 ~ U+d9b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d9b8 ~ U+d9bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d9c0 ~ U+d9c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d9c8 ~ U+d9cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d9d0 ~ U+d9d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d9d8 ~ U+d9df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d9e0 ~ U+d9e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d9e8 ~ U+d9ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d9f0 ~ U+d9f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+d9f8 ~ U+d9ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+da00 ~ U+da07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+da08 ~ U+da0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+da10 ~ U+da17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+da18 ~ U+da1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+da20 ~ U+da27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+da28 ~ U+da2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+da30 ~ U+da37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+da38 ~ U+da3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+da40 ~ U+da47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+da48 ~ U+da4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+da50 ~ U+da57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+da58 ~ U+da5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+da60 ~ U+da67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+da68 ~ U+da6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+da70 ~ U+da77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+da78 ~ U+da7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+da80 ~ U+da87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+da88 ~ U+da8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+da90 ~ U+da97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+da98 ~ U+da9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+daa0 ~ U+daa7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+daa8 ~ U+daaf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dab0 ~ U+dab7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dab8 ~ U+dabf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dac0 ~ U+dac7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dac8 ~ U+dacf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dad0 ~ U+dad7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dad8 ~ U+dadf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dae0 ~ U+dae7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dae8 ~ U+daef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+daf0 ~ U+daf7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+daf8 ~ U+daff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+db00 ~ U+db07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+db08 ~ U+db0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+db10 ~ U+db17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+db18 ~ U+db1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+db20 ~ U+db27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+db28 ~ U+db2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+db30 ~ U+db37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+db38 ~ U+db3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+db40 ~ U+db47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+db48 ~ U+db4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+db50 ~ U+db57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+db58 ~ U+db5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+db60 ~ U+db67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+db68 ~ U+db6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+db70 ~ U+db77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+db78 ~ U+db7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+db80 ~ U+db87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+db88 ~ U+db8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+db90 ~ U+db97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+db98 ~ U+db9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dba0 ~ U+dba7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dba8 ~ U+dbaf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dbb0 ~ U+dbb7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dbb8 ~ U+dbbf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dbc0 ~ U+dbc7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dbc8 ~ U+dbcf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dbd0 ~ U+dbd7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dbd8 ~ U+dbdf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dbe0 ~ U+dbe7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dbe8 ~ U+dbef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dbf0 ~ U+dbf7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dbf8 ~ U+dbff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dc00 ~ U+dc07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dc08 ~ U+dc0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dc10 ~ U+dc17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dc18 ~ U+dc1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dc20 ~ U+dc27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dc28 ~ U+dc2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dc30 ~ U+dc37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dc38 ~ U+dc3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dc40 ~ U+dc47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dc48 ~ U+dc4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dc50 ~ U+dc57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dc58 ~ U+dc5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dc60 ~ U+dc67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dc68 ~ U+dc6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dc70 ~ U+dc77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dc78 ~ U+dc7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dc80 ~ U+dc87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dc88 ~ U+dc8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dc90 ~ U+dc97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dc98 ~ U+dc9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dca0 ~ U+dca7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dca8 ~ U+dcaf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dcb0 ~ U+dcb7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dcb8 ~ U+dcbf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dcc0 ~ U+dcc7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dcc8 ~ U+dccf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dcd0 ~ U+dcd7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dcd8 ~ U+dcdf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dce0 ~ U+dce7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dce8 ~ U+dcef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dcf0 ~ U+dcf7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dcf8 ~ U+dcff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dd00 ~ U+dd07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dd08 ~ U+dd0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dd10 ~ U+dd17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dd18 ~ U+dd1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dd20 ~ U+dd27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dd28 ~ U+dd2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dd30 ~ U+dd37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dd38 ~ U+dd3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dd40 ~ U+dd47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dd48 ~ U+dd4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dd50 ~ U+dd57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dd58 ~ U+dd5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dd60 ~ U+dd67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dd68 ~ U+dd6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dd70 ~ U+dd77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dd78 ~ U+dd7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dd80 ~ U+dd87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dd88 ~ U+dd8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dd90 ~ U+dd97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dd98 ~ U+dd9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dda0 ~ U+dda7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dda8 ~ U+ddaf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+ddb0 ~ U+ddb7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+ddb8 ~ U+ddbf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+ddc0 ~ U+ddc7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+ddc8 ~ U+ddcf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+ddd0 ~ U+ddd7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+ddd8 ~ U+dddf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dde0 ~ U+dde7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dde8 ~ U+ddef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+ddf0 ~ U+ddf7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+ddf8 ~ U+ddff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+de00 ~ U+de07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+de08 ~ U+de0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+de10 ~ U+de17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+de18 ~ U+de1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+de20 ~ U+de27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+de28 ~ U+de2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+de30 ~ U+de37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+de38 ~ U+de3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+de40 ~ U+de47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+de48 ~ U+de4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+de50 ~ U+de57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+de58 ~ U+de5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+de60 ~ U+de67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+de68 ~ U+de6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+de70 ~ U+de77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+de78 ~ U+de7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+de80 ~ U+de87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+de88 ~ U+de8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+de90 ~ U+de97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+de98 ~ U+de9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dea0 ~ U+dea7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dea8 ~ U+deaf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+deb0 ~ U+deb7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+deb8 ~ U+debf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dec0 ~ U+dec7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dec8 ~ U+decf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+ded0 ~ U+ded7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+ded8 ~ U+dedf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dee0 ~ U+dee7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dee8 ~ U+deef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+def0 ~ U+def7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+def8 ~ U+deff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+df00 ~ U+df07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+df08 ~ U+df0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+df10 ~ U+df17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+df18 ~ U+df1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+df20 ~ U+df27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+df28 ~ U+df2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+df30 ~ U+df37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+df38 ~ U+df3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+df40 ~ U+df47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+df48 ~ U+df4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+df50 ~ U+df57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+df58 ~ U+df5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+df60 ~ U+df67
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+df68 ~ U+df6f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+df70 ~ U+df77
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+df78 ~ U+df7f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+df80 ~ U+df87
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+df88 ~ U+df8f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+df90 ~ U+df97
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+df98 ~ U+df9f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dfa0 ~ U+dfa7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dfa8 ~ U+dfaf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dfb0 ~ U+dfb7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dfb8 ~ U+dfbf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dfc0 ~ U+dfc7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dfc8 ~ U+dfcf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dfd0 ~ U+dfd7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dfd8 ~ U+dfdf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dfe0 ~ U+dfe7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dfe8 ~ U+dfef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dff0 ~ U+dff7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+dff8 ~ U+dfff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e000 ~ U+e007
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e008 ~ U+e00f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e010 ~ U+e017
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e018 ~ U+e01f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e020 ~ U+e027
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e028 ~ U+e02f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e030 ~ U+e037
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e038 ~ U+e03f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e040 ~ U+e047
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e048 ~ U+e04f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e050 ~ U+e057
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e058 ~ U+e05f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e060 ~ U+e067
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e068 ~ U+e06f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e070 ~ U+e077
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e078 ~ U+e07f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e080 ~ U+e087
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e088 ~ U+e08f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e090 ~ U+e097
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e098 ~ U+e09f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e0a0 ~ U+e0a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e0a8 ~ U+e0af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e0b0 ~ U+e0b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e0b8 ~ U+e0bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e0c0 ~ U+e0c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e0c8 ~ U+e0cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e0d0 ~ U+e0d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e0d8 ~ U+e0df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e0e0 ~ U+e0e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e0e8 ~ U+e0ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e0f0 ~ U+e0f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e0f8 ~ U+e0ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e100 ~ U+e107
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e108 ~ U+e10f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e110 ~ U+e117
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e118 ~ U+e11f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e120 ~ U+e127
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e128 ~ U+e12f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e130 ~ U+e137
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e138 ~ U+e13f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e140 ~ U+e147
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e148 ~ U+e14f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e150 ~ U+e157
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e158 ~ U+e15f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e160 ~ U+e167
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e168 ~ U+e16f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e170 ~ U+e177
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e178 ~ U+e17f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e180 ~ U+e187
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e188 ~ U+e18f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e190 ~ U+e197
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e198 ~ U+e19f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e1a0 ~ U+e1a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e1a8 ~ U+e1af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e1b0 ~ U+e1b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e1b8 ~ U+e1bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e1c0 ~ U+e1c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e1c8 ~ U+e1cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e1d0 ~ U+e1d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e1d8 ~ U+e1df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e1e0 ~ U+e1e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e1e8 ~ U+e1ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e1f0 ~ U+e1f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e1f8 ~ U+e1ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e200 ~ U+e207
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e208 ~ U+e20f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e210 ~ U+e217
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e218 ~ U+e21f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e220 ~ U+e227
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e228 ~ U+e22f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e230 ~ U+e237
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e238 ~ U+e23f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e240 ~ U+e247
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e248 ~ U+e24f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e250 ~ U+e257
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e258 ~ U+e25f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e260 ~ U+e267
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e268 ~ U+e26f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e270 ~ U+e277
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e278 ~ U+e27f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e280 ~ U+e287
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e288 ~ U+e28f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e290 ~ U+e297
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e298 ~ U+e29f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e2a0 ~ U+e2a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e2a8 ~ U+e2af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e2b0 ~ U+e2b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e2b8 ~ U+e2bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e2c0 ~ U+e2c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e2c8 ~ U+e2cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e2d0 ~ U+e2d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e2d8 ~ U+e2df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e2e0 ~ U+e2e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e2e8 ~ U+e2ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e2f0 ~ U+e2f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e2f8 ~ U+e2ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e300 ~ U+e307
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e308 ~ U+e30f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e310 ~ U+e317
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e318 ~ U+e31f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e320 ~ U+e327
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e328 ~ U+e32f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e330 ~ U+e337
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e338 ~ U+e33f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e340 ~ U+e347
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e348 ~ U+e34f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e350 ~ U+e357
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e358 ~ U+e35f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e360 ~ U+e367
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e368 ~ U+e36f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e370 ~ U+e377
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e378 ~ U+e37f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e380 ~ U+e387
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e388 ~ U+e38f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e390 ~ U+e397
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e398 ~ U+e39f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e3a0 ~ U+e3a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e3a8 ~ U+e3af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e3b0 ~ U+e3b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e3b8 ~ U+e3bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e3c0 ~ U+e3c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e3c8 ~ U+e3cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e3d0 ~ U+e3d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e3d8 ~ U+e3df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e3e0 ~ U+e3e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e3e8 ~ U+e3ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e3f0 ~ U+e3f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e3f8 ~ U+e3ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e400 ~ U+e407
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e408 ~ U+e40f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e410 ~ U+e417
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e418 ~ U+e41f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e420 ~ U+e427
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e428 ~ U+e42f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e430 ~ U+e437
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e438 ~ U+e43f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e440 ~ U+e447
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e448 ~ U+e44f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e450 ~ U+e457
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e458 ~ U+e45f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e460 ~ U+e467
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e468 ~ U+e46f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e470 ~ U+e477
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e478 ~ U+e47f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e480 ~ U+e487
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e488 ~ U+e48f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e490 ~ U+e497
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e498 ~ U+e49f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e4a0 ~ U+e4a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e4a8 ~ U+e4af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e4b0 ~ U+e4b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e4b8 ~ U+e4bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e4c0 ~ U+e4c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e4c8 ~ U+e4cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e4d0 ~ U+e4d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e4d8 ~ U+e4df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e4e0 ~ U+e4e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e4e8 ~ U+e4ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e4f0 ~ U+e4f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e4f8 ~ U+e4ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e500 ~ U+e507
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e508 ~ U+e50f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e510 ~ U+e517
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e518 ~ U+e51f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e520 ~ U+e527
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e528 ~ U+e52f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e530 ~ U+e537
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e538 ~ U+e53f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e540 ~ U+e547
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e548 ~ U+e54f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e550 ~ U+e557
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e558 ~ U+e55f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e560 ~ U+e567
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e568 ~ U+e56f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e570 ~ U+e577
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e578 ~ U+e57f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e580 ~ U+e587
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e588 ~ U+e58f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e590 ~ U+e597
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e598 ~ U+e59f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e5a0 ~ U+e5a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e5a8 ~ U+e5af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e5b0 ~ U+e5b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e5b8 ~ U+e5bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e5c0 ~ U+e5c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e5c8 ~ U+e5cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e5d0 ~ U+e5d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e5d8 ~ U+e5df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e5e0 ~ U+e5e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e5e8 ~ U+e5ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e5f0 ~ U+e5f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e5f8 ~ U+e5ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e600 ~ U+e607
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e608 ~ U+e60f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e610 ~ U+e617
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e618 ~ U+e61f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e620 ~ U+e627
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e628 ~ U+e62f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e630 ~ U+e637
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e638 ~ U+e63f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e640 ~ U+e647
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e648 ~ U+e64f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e650 ~ U+e657
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e658 ~ U+e65f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e660 ~ U+e667
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e668 ~ U+e66f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e670 ~ U+e677
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e678 ~ U+e67f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e680 ~ U+e687
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e688 ~ U+e68f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e690 ~ U+e697
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e698 ~ U+e69f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e6a0 ~ U+e6a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e6a8 ~ U+e6af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e6b0 ~ U+e6b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e6b8 ~ U+e6bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e6c0 ~ U+e6c7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e6c8 ~ U+e6cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e6d0 ~ U+e6d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e6d8 ~ U+e6df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e6e0 ~ U+e6e7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e6e8 ~ U+e6ef
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e6f0 ~ U+e6f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e6f8 ~ U+e6ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e700 ~ U+e707
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e708 ~ U+e70f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e710 ~ U+e717
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e718 ~ U+e71f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e720 ~ U+e727
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e728 ~ U+e72f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e730 ~ U+e737
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e738 ~ U+e73f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e740 ~ U+e747
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e748 ~ U+e74f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e750 ~ U+e757
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e758 ~ U+e75f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e760 ~ U+e767
0xffff, 0xffff, 0xffff, 0xffff, 0x82bd, 0xffff, 0xffff, 0xffff,   // U+e768 ~ U+e76f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e770 ~ U+e777
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e778 ~ U+e77f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e780 ~ U+e787
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e788 ~ U+e78f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e790 ~ U+e797
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e798 ~ U+e79f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e7a0 ~ U+e7a7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e7a8 ~ U+e7af
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e7b0 ~ U+e7b7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e7b8 ~ U+e7bf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e7c0 ~ U+e7c7
0x82be, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e7c8 ~ U+e7cf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e7d0 ~ U+e7d7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e7d8 ~ U+e7df
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x82bf,   // U+e7e0 ~ U+e7e7
0x82c0, 0x82c1, 0x82c2, 0x82c3, 0x82c4, 0x82c5, 0x82c6, 0x82c7,   // U+e7e8 ~ U+e7ef
0x82c8, 0x82c9, 0x82ca, 0x82cb, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e7f0 ~ U+e7f7
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e7f8 ~ U+e7ff
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e800 ~ U+e807
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+e808 ~ U+e80f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x82cc, 0xffff, 0xffff,   // U+e810 ~ U+e817
0xffff, 0x82cd, 0x82ce, 0x82cf, 0x82d0, 0x82d1, 0xffff, 0x82d2,   // U+e818 ~ U+e81f
0x82d3, 0x82d4, 0x82d5, 0x82d6, 0x82d7, 0x82d8, 0xffff, 0x82d9,   // U+e820 ~ U+e827
0x82da, 0x82db, 0x82dc, 0xffff, 0xffff, 0x82dd, 0x82de, 0x82df,   // U+e828 ~ U+e82f
0x82e0, 0xffff, 0xffff, 0x82e1, 0x82e2, 0x82e3, 0x82e4, 0x82e5,   // U+e830 ~ U+e837
0x82e6, 0x82e7, 0x82e8, 0xffff, 0x82e9, 0x82ea, 0x82eb, 0x82ec,   // U+e838 ~ U+e83f
0x82ed, 0x82ee, 0x82ef, 0xffff, 0x82f0, 0x82f1, 0x82f2, 0x82f3,   // U+e840 ~ U+e847
0x82f4, 0x82f5, 0x82f6, 0x82f7, 0x82f8, 0x82f9, 0x82fa, 0x82fb,   // U+e848 ~ U+e84f
0x82fc, 0x82fd, 0x82fe, 0x82ff, 0xffff, 0xffff, 0x8300, 0x8301,   // U+e850 ~ U+e857
0x8302, 0x8303, 0x8304, 0x8305, 0x8306, 0x8307, 0x8308, 0x8309,   // U+e858 ~ U+e85f
0x830a, 0x830b, 0x830c, 0x830d, 0xffff, 0x830e, 0x830f, 0x8310,   // U+e860 ~ U+e867
0x8311, 0x8312, 0x8313, 0x8314, 0x8315, 0x8316, 0x8317, 0x8318,   // U+e868 ~ U+e86f
0x8319, 0x831a, 0x831b, 0x831c, 0x831d, 0x831e, 0x831f, 0x8320,   // U+e870 ~ U+e877
0x8321, 0x8322, 0x8323, 0x8324, 0x8325, 0x8326, 0x8327, 0x8328,   // U+e878 ~ U+e87f
0x8329, 0x832a, 0x832b, 0x832c, 0x832d, 0x832e, 0x832f, 0x8330,   // U+e880 ~ U+e887
0x8331, 0x8332, 0x8333, 0x8334, 0x8335, 0x8336, 0x8337, 0x8338,   // U+e888 ~ U+e88f
0x8339, 0x833a, 0x833b, 0x833c, 0x833d, 0x833e, 0x833f, 0x8340,   // U+e890 ~ U+e897
0x8341, 0x8342, 0x8343, 0x8344, 0x8345, 0x8346, 0x8347, 0x8348,   // U+e898 ~ U+e89f
0x8349, 0x834a, 0x834b, 0x834c, 0x834d, 0x834e, 0x834f, 0x8350,   // U+e8a0 ~ U+e8a7
0x8351, 0x8352, 0x8353, 0x8354, 0x8355, 0x8356, 0x8357, 0x8358,   // U+e8a8 ~ U+e8af
0x8359, 0x835a, 0x835b, 0x835c, 0x835d, 0x835e, 0x835f, 0x8360,   // U+e8b0 ~ U+e8b7
0x8361, 0x8362, 0x8363, 0x8364, 0x8365, 0x8366, 0x8367, 0x8368,   // U+e8b8 ~ U+e8bf
0x8369, 0x836a, 0x836b, 0x836c, 0x836d, 0x836e, 0x836f, 0x8370,   // U+e8c0 ~ U+e8c7
0x8371, 0x8372, 0x8373, 0x8374, 0x8375, 0x8376, 0x8377, 0x8378,   // U+e8c8 ~ U+e8cf
0x8379, 0x837a, 0x837b, 0x837c, 0x837d, 0x837e, 0x837f, 0x8380,   // U+e8d0 ~ U+e8d7
0x8381, 0x8382, 0x8383, 0x8384, 0x8385, 0x8386, 0x8387, 0x8388,   // U+e8d8 ~ U+e8df
0x8389, 0x838a, 0x838b, 0x838c, 0x838d, 0x838e, 0x838f, 0x8390,   // U+e8e0 ~ U+e8e7
0x8391, 0x8392, 0x8393, 0x8394, 0x8395, 0x8396, 0x8397, 0x8398,   // U+e8e8 ~ U+e8ef
0x8399, 0x839a, 0x839b, 0x839c, 0x839d, 0x839e, 0x839f, 0x83a0,   // U+e8f0 ~ U+e8f7
0x83a1, 0x83a2, 0x83a3, 0x83a4, 0x83a5, 0x83a6, 0x83a7, 0x83a8,   // U+e8f8 ~ U+e8ff
0x83a9, 0x83aa, 0x83ab, 0x83ac, 0x83ad, 0x83ae, 0x83af, 0x83b0,   // U+e900 ~ U+e907
0x83b1, 0x83b2, 0x83b3, 0x83b4, 0x83b5, 0x83b6, 0x83b7, 0x83b8,   // U+e908 ~ U+e90f
0x83b9, 0x83ba, 0x83bb, 0x83bc, 0x83bd, 0x83be, 0x83bf, 0x83c0,   // U+e910 ~ U+e917
0x83c1, 0x83c2, 0x83c3, 0x83c4, 0x83c5, 0x83c6, 0x83c7, 0x83c8,   // U+e918 ~ U+e91f
0x83c9, 0x83ca, 0x83cb, 0x83cc, 0x83cd, 0x83ce, 0x83cf, 0x83d0,   // U+e920 ~ U+e927
0x83d1, 0x83d2, 0x83d3, 0x83d4, 0x83d5, 0x83d6, 0x83d7, 0x83d8,   // U+e928 ~ U+e92f
0x83d9, 0x83da, 0x83db, 0x83dc, 0x83dd, 0x83de, 0x83df, 0x83e0,   // U+e930 ~ U+e937
0x83e1, 0x83e2, 0x83e3, 0x83e4, 0x83e5, 0x83e6, 0x83e7, 0x83e8,   // U+e938 ~ U+e93f
0x83e9, 0x83ea, 0x83eb, 0x83ec, 0x83ed, 0x83ee, 0x83ef, 0x83f0,   // U+e940 ~ U+e947
0x83f1, 0x83f2, 0x83f3, 0x83f4, 0x83f5, 0x83f6, 0x83f7, 0x83f8,   // U+e948 ~ U+e94f
0x83f9, 0x83fa, 0x83fb, 0x83fc, 0x83fd, 0x83fe, 0x83ff, 0x8400,   // U+e950 ~ U+e957
0x8401, 0x8402, 0x8403, 0x8404, 0x8405, 0x8406, 0x8407, 0x8408,   // U+e958 ~ U+e95f
0x8409, 0x840a, 0x840b, 0x840c, 0x840d, 0x840e, 0x840f, 0x8410,   // U+e960 ~ U+e967
0x8411, 0x8412, 0x8413, 0x8414, 0x8415, 0x8416, 0x8417, 0x8418,   // U+e968 ~ U+e96f
0x8419, 0x841a, 0x841b, 0x841c, 0x841d, 0x841e, 0x841f, 0x8420,   // U+e970 ~ U+e977
0x8421, 0x8422, 0x8423, 0x8424, 0x8425, 0x8426, 0x8427, 0x8428,   // U+e978 ~ U+e97f
0x8429, 0x842a, 0x842b, 0x842c, 0x842d, 0x842e, 0x842f, 0x8430,   // U+e980 ~ U+e987
0x8431, 0x8432, 0x8433, 0x8434, 0x8435, 0x8436, 0x8437, 0x8438,   // U+e988 ~ U+e98f
0x8439, 0x843a, 0x843b, 0x843c, 0x843d, 0x843e, 0x843f, 0x8440,   // U+e990 ~ U+e997
0x8441, 0x8442, 0x8443, 0x8444, 0x8445, 0x8446, 0x8447, 0x8448,   // U+e998 ~ U+e99f
0x8449, 0x844a, 0x844b, 0x844c, 0x844d, 0x844e, 0x844f, 0x8450,   // U+e9a0 ~ U+e9a7
0x8451, 0x8452, 0x8453, 0x8454, 0x8455, 0x8456, 0x8457, 0x8458,   // U+e9a8 ~ U+e9af
0x8459, 0x845a, 0x845b, 0x845c, 0x845d, 0x845e, 0x845f, 0x8460,   // U+e9b0 ~ U+e9b7
0x8461, 0x8462, 0x8463, 0x8464, 0x8465, 0x8466, 0x8467, 0x8468,   // U+e9b8 ~ U+e9bf
0x8469, 0x846a, 0x846b, 0x846c, 0x846d, 0x846e, 0x846f, 0x8470,   // U+e9c0 ~ U+e9c7
0x8471, 0x8472, 0x8473, 0x8474, 0x8475, 0x8476, 0x8477, 0x8478,   // U+e9c8 ~ U+e9cf
0x8479, 0x847a, 0x847b, 0x847c, 0x847d, 0x847e, 0x847f, 0x8480,   // U+e9d0 ~ U+e9d7
0x8481, 0x8482, 0x8483, 0x8484, 0x8485, 0x8486, 0x8487, 0x8488,   // U+e9d8 ~ U+e9df
0x8489, 0x848a, 0x848b, 0x848c, 0x848d, 0x848e, 0x848f, 0x8490,   // U+e9e0 ~ U+e9e7
0x8491, 0x8492, 0x8493, 0x8494, 0x8495, 0x8496, 0x8497, 0x8498,   // U+e9e8 ~ U+e9ef
0x8499, 0x849a, 0x849b, 0x849c, 0x849d, 0x849e, 0x849f, 0x84a0,   // U+e9f0 ~ U+e9f7
0x84a1, 0x84a2, 0x84a3, 0x84a4, 0x84a5, 0x84a6, 0x84a7, 0x84a8,   // U+e9f8 ~ U+e9ff
0x84a9, 0x84aa, 0x84ab, 0x84ac, 0x84ad, 0x84ae, 0x84af, 0x84b0,   // U+ea00 ~ U+ea07
0x84b1, 0x84b2, 0x84b3, 0x84b4, 0x84b5, 0x84b6, 0x84b7, 0x84b8,   // U+ea08 ~ U+ea0f
0x84b9, 0x84ba, 0x84bb, 0x84bc, 0x84bd, 0x84be, 0x84bf, 0x84c0,   // U+ea10 ~ U+ea17
0x84c1, 0x84c2, 0x84c3, 0x84c4, 0x84c5, 0x84c6, 0x84c7, 0x84c8,   // U+ea18 ~ U+ea1f
0x84c9, 0x84ca, 0x84cb, 0x84cc, 0x84cd, 0x84ce, 0x84cf, 0x84d0,   // U+ea20 ~ U+ea27
0x84d1, 0x84d2, 0x84d3, 0x84d4, 0x84d5, 0x84d6, 0x84d7, 0x84d8,   // U+ea28 ~ U+ea2f
0x84d9, 0x84da, 0x84db, 0x84dc, 0x84dd, 0x84de, 0x84df, 0x84e0,   // U+ea30 ~ U+ea37
0x84e1, 0x84e2, 0x84e3, 0x84e4, 0x84e5, 0x84e6, 0x84e7, 0x84e8,   // U+ea38 ~ U+ea3f
0x84e9, 0x84ea, 0x84eb, 0x84ec, 0x84ed, 0x84ee, 0x84ef, 0x84f0,   // U+ea40 ~ U+ea47
0x84f1, 0x84f2, 0x84f3, 0x84f4, 0x84f5, 0x84f6, 0x84f7, 0x84f8,   // U+ea48 ~ U+ea4f
0x84f9, 0x84fa, 0x84fb, 0x84fc, 0x84fd, 0x84fe, 0x84ff, 0x8500,   // U+ea50 ~ U+ea57
0x8501, 0x8502, 0x8503, 0x8504, 0x8505, 0x8506, 0x8507, 0x8508,   // U+ea58 ~ U+ea5f
0x8509, 0x850a, 0x850b, 0x850c, 0x850d, 0x850e, 0x850f, 0x8510,   // U+ea60 ~ U+ea67
0x8511, 0x8512, 0x8513, 0x8514, 0x8515, 0x8516, 0x8517, 0x8518,   // U+ea68 ~ U+ea6f
0x8519, 0x851a, 0x851b, 0x851c, 0x851d, 0x851e, 0x851f, 0x8520,   // U+ea70 ~ U+ea77
0x8521, 0x8522, 0x8523, 0x8524, 0x8525, 0x8526, 0x8527, 0x8528,   // U+ea78 ~ U+ea7f
0x8529, 0x852a, 0x852b, 0x852c, 0x852d, 0x852e, 0x852f, 0x8530,   // U+ea80 ~ U+ea87
0x8531, 0x8532, 0x8533, 0x8534, 0x8535, 0x8536, 0x8537, 0x8538,   // U+ea88 ~ U+ea8f
0x8539, 0x853a, 0x853b, 0x853c, 0x853d, 0x853e, 0x853f, 0x8540,   // U+ea90 ~ U+ea97
0x8541, 0x8542, 0x8543, 0x8544, 0x8545, 0x8546, 0x8547, 0x8548,   // U+ea98 ~ U+ea9f
0x8549, 0x854a, 0x854b, 0x854c, 0x854d, 0x854e, 0x854f, 0x8550,   // U+eaa0 ~ U+eaa7
0x8551, 0x8552, 0x8553, 0x8554, 0x8555, 0x8556, 0x8557, 0x8558,   // U+eaa8 ~ U+eaaf
0x8559, 0x855a, 0x855b, 0x855c, 0x855d, 0x855e, 0x855f, 0x8560,   // U+eab0 ~ U+eab7
0x8561, 0x8562, 0x8563, 0x8564, 0x8565, 0x8566, 0x8567, 0x8568,   // U+eab8 ~ U+eabf
0x8569, 0x856a, 0x856b, 0x856c, 0x856d, 0x856e, 0x856f, 0x8570,   // U+eac0 ~ U+eac7
0x8571, 0x8572, 0x8573, 0x8574, 0x8575, 0x8576, 0x8577, 0x8578,   // U+eac8 ~ U+eacf
0x8579, 0x857a, 0x857b, 0x857c, 0x857d, 0x857e, 0x857f, 0x8580,   // U+ead0 ~ U+ead7
0x8581, 0x8582, 0x8583, 0x8584, 0x8585, 0x8586, 0x8587, 0x8588,   // U+ead8 ~ U+eadf
0x8589, 0x858a, 0x858b, 0x858c, 0x858d, 0x858e, 0x858f, 0x8590,   // U+eae0 ~ U+eae7
0x8591, 0x8592, 0x8593, 0x8594, 0x8595, 0x8596, 0x8597, 0x8598,   // U+eae8 ~ U+eaef
0x8599, 0x859a, 0x859b, 0x859c, 0x859d, 0x859e, 0x859f, 0x85a0,   // U+eaf0 ~ U+eaf7
0x85a1, 0x85a2, 0x85a3, 0x85a4, 0x85a5, 0x85a6, 0x85a7, 0x85a8,   // U+eaf8 ~ U+eaff
0x85a9, 0x85aa, 0x85ab, 0x85ac, 0x85ad, 0x85ae, 0x85af, 0x85b0,   // U+eb00 ~ U+eb07
0x85b1, 0x85b2, 0x85b3, 0x85b4, 0x85b5, 0x85b6, 0x85b7, 0x85b8,   // U+eb08 ~ U+eb0f
0x85b9, 0x85ba, 0x85bb, 0x85bc, 0x85bd, 0x85be, 0x85bf, 0x85c0,   // U+eb10 ~ U+eb17
0x85c1, 0x85c2, 0x85c3, 0x85c4, 0x85c5, 0x85c6, 0x85c7, 0x85c8,   // U+eb18 ~ U+eb1f
0x85c9, 0x85ca, 0x85cb, 0x85cc, 0x85cd, 0x85ce, 0x85cf, 0x85d0,   // U+eb20 ~ U+eb27
0x85d1, 0x85d2, 0x85d3, 0x85d4, 0x85d5, 0x85d6, 0x85d7, 0x85d8,   // U+eb28 ~ U+eb2f
0x85d9, 0x85da, 0x85db, 0x85dc, 0x85dd, 0x85de, 0x85df, 0x85e0,   // U+eb30 ~ U+eb37
0x85e1, 0x85e2, 0x85e3, 0x85e4, 0x85e5, 0x85e6, 0x85e7, 0x85e8,   // U+eb38 ~ U+eb3f
0x85e9, 0x85ea, 0x85eb, 0x85ec, 0x85ed, 0x85ee, 0x85ef, 0x85f0,   // U+eb40 ~ U+eb47
0x85f1, 0x85f2, 0x85f3, 0x85f4, 0x85f5, 0x85f6, 0x85f7, 0x85f8,   // U+eb48 ~ U+eb4f
0x85f9, 0x85fa, 0x85fb, 0x85fc, 0x85fd, 0x85fe, 0x85ff, 0x8600,   // U+eb50 ~ U+eb57
0x8601, 0x8602, 0x8603, 0x8604, 0x8605, 0x8606, 0x8607, 0x8608,   // U+eb58 ~ U+eb5f
0x8609, 0x860a, 0x860b, 0x860c, 0x860d, 0x860e, 0x860f, 0x8610,   // U+eb60 ~ U+eb67
0x8611, 0x8612, 0x8613, 0x8614, 0x8615, 0x8616, 0x8617, 0x8618,   // U+eb68 ~ U+eb6f
0x8619, 0x861a, 0x861b, 0x861c, 0x861d, 0x861e, 0x861f, 0x8620,   // U+eb70 ~ U+eb77
0x8621, 0x8622, 0x8623, 0x8624, 0x8625, 0x8626, 0x8627, 0x8628,   // U+eb78 ~ U+eb7f
0x8629, 0x862a, 0x862b, 0x862c, 0x862d, 0x862e, 0x862f, 0x8630,   // U+eb80 ~ U+eb87
0x8631, 0x8632, 0x8633, 0x8634, 0x8635, 0x8636, 0x8637, 0x8638,   // U+eb88 ~ U+eb8f
0x8639, 0x863a, 0x863b, 0x863c, 0x863d, 0x863e, 0x863f, 0x8640,   // U+eb90 ~ U+eb97
0x8641, 0x8642, 0x8643, 0x8644, 0x8645, 0x8646, 0x8647, 0x8648,   // U+eb98 ~ U+eb9f
0x8649, 0x864a, 0x864b, 0x864c, 0x864d, 0x864e, 0x864f, 0x8650,   // U+eba0 ~ U+eba7
0x8651, 0x8652, 0x8653, 0x8654, 0x8655, 0x8656, 0x8657, 0x8658,   // U+eba8 ~ U+ebaf
0x8659, 0x865a, 0x865b, 0x865c, 0x865d, 0x865e, 0x865f, 0x8660,   // U+ebb0 ~ U+ebb7
0x8661, 0x8662, 0x8663, 0x8664, 0x8665, 0x8666, 0x8667, 0x8668,   // U+ebb8 ~ U+ebbf
0x8669, 0x866a, 0x866b, 0x866c, 0x866d, 0x866e, 0x866f, 0x8670,   // U+ebc0 ~ U+ebc7
0x8671, 0x8672, 0x8673, 0x8674, 0x8675, 0x8676, 0x8677, 0x8678,   // U+ebc8 ~ U+ebcf
0x8679, 0x867a, 0x867b, 0x867c, 0x867d, 0x867e, 0x867f, 0x8680,   // U+ebd0 ~ U+ebd7
0x8681, 0x8682, 0x8683, 0x8684, 0x8685, 0x8686, 0x8687, 0x8688,   // U+ebd8 ~ U+ebdf
0x8689, 0x868a, 0x868b, 0x868c, 0x868d, 0x868e, 0x868f, 0x8690,   // U+ebe0 ~ U+ebe7
0x8691, 0x8692, 0x8693, 0x8694, 0x8695, 0x8696, 0x8697, 0x8698,   // U+ebe8 ~ U+ebef
0x8699, 0x869a, 0x869b, 0x869c, 0x869d, 0x869e, 0x869f, 0x86a0,   // U+ebf0 ~ U+ebf7
0x86a1, 0x86a2, 0x86a3, 0x86a4, 0x86a5, 0x86a6, 0x86a7, 0x86a8,   // U+ebf8 ~ U+ebff
0x86a9, 0x86aa, 0x86ab, 0x86ac, 0x86ad, 0x86ae, 0x86af, 0x86b0,   // U+ec00 ~ U+ec07
0x86b1, 0x86b2, 0x86b3, 0x86b4, 0x86b5, 0x86b6, 0x86b7, 0x86b8,   // U+ec08 ~ U+ec0f
0x86b9, 0x86ba, 0x86bb, 0x86bc, 0x86bd, 0x86be, 0x86bf, 0x86c0,   // U+ec10 ~ U+ec17
0x86c1, 0x86c2, 0x86c3, 0x86c4, 0x86c5, 0x86c6, 0x86c7, 0x86c8,   // U+ec18 ~ U+ec1f
0x86c9, 0x86ca, 0x86cb, 0x86cc, 0x86cd, 0x86ce, 0x86cf, 0x86d0,   // U+ec20 ~ U+ec27
0x86d1, 0x86d2, 0x86d3, 0x86d4, 0x86d5, 0x86d6, 0x86d7, 0x86d8,   // U+ec28 ~ U+ec2f
0x86d9, 0x86da, 0x86db, 0x86dc, 0x86dd, 0x86de, 0x86df, 0x86e0,   // U+ec30 ~ U+ec37
0x86e1, 0x86e2, 0x86e3, 0x86e4, 0x86e5, 0x86e6, 0x86e7, 0x86e8,   // U+ec38 ~ U+ec3f
0x86e9, 0x86ea, 0x86eb, 0x86ec, 0x86ed, 0x86ee, 0x86ef, 0x86f0,   // U+ec40 ~ U+ec47
0x86f1, 0x86f2, 0x86f3, 0x86f4, 0x86f5, 0x86f6, 0x86f7, 0x86f8,   // U+ec48 ~ U+ec4f
0x86f9, 0x86fa, 0x86fb, 0x86fc, 0x86fd, 0x86fe, 0x86ff, 0x8700,   // U+ec50 ~ U+ec57
0x8701, 0x8702, 0x8703, 0x8704, 0x8705, 0x8706, 0x8707, 0x8708,   // U+ec58 ~ U+ec5f
0x8709, 0x870a, 0x870b, 0x870c, 0x870d, 0x870e, 0x870f, 0x8710,   // U+ec60 ~ U+ec67
0x8711, 0x8712, 0x8713, 0x8714, 0x8715, 0x8716, 0x8717, 0x8718,   // U+ec68 ~ U+ec6f
0x8719, 0x871a, 0x871b, 0x871c, 0x871d, 0x871e, 0x871f, 0x8720,   // U+ec70 ~ U+ec77
0x8721, 0x8722, 0x8723, 0x8724, 0x8725, 0x8726, 0x8727, 0x8728,   // U+ec78 ~ U+ec7f
0x8729, 0x872a, 0x872b, 0x872c, 0x872d, 0x872e, 0x872f, 0x8730,   // U+ec80 ~ U+ec87
0x8731, 0x8732, 0x8733, 0x8734, 0x8735, 0x8736, 0x8737, 0x8738,   // U+ec88 ~ U+ec8f
0x8739, 0x873a, 0x873b, 0x873c, 0x873d, 0x873e, 0x873f, 0x8740,   // U+ec90 ~ U+ec97
0x8741, 0x8742, 0x8743, 0x8744, 0x8745, 0x8746, 0x8747, 0x8748,   // U+ec98 ~ U+ec9f
0x8749, 0x874a, 0x874b, 0x874c, 0x874d, 0x874e, 0x874f, 0x8750,   // U+eca0 ~ U+eca7
0x8751, 0x8752, 0x8753, 0x8754, 0x8755, 0x8756, 0x8757, 0x8758,   // U+eca8 ~ U+ecaf
0x8759, 0x875a, 0x875b, 0x875c, 0x875d, 0x875e, 0x875f, 0x8760,   // U+ecb0 ~ U+ecb7
0x8761, 0x8762, 0x8763, 0x8764, 0x8765, 0x8766, 0x8767, 0x8768,   // U+ecb8 ~ U+ecbf
0x8769, 0x876a, 0x876b, 0x876c, 0x876d, 0x876e, 0x876f, 0x8770,   // U+ecc0 ~ U+ecc7
0x8771, 0x8772, 0x8773, 0x8774, 0x8775, 0x8776, 0x8777, 0x8778,   // U+ecc8 ~ U+eccf
0x8779, 0x877a, 0x877b, 0x877c, 0x877d, 0x877e, 0x877f, 0x8780,   // U+ecd0 ~ U+ecd7
0x8781, 0x8782, 0x8783, 0x8784, 0x8785, 0x8786, 0x8787, 0x8788,   // U+ecd8 ~ U+ecdf
0x8789, 0x878a, 0x878b, 0x878c, 0x878d, 0x878e, 0x878f, 0x8790,   // U+ece0 ~ U+ece7
0x8791, 0x8792, 0x8793, 0x8794, 0x8795, 0x8796, 0x8797, 0x8798,   // U+ece8 ~ U+ecef
0x8799, 0x879a, 0x879b, 0x879c, 0x879d, 0x879e, 0x879f, 0x87a0,   // U+ecf0 ~ U+ecf7
0x87a1, 0x87a2, 0x87a3, 0x87a4, 0x87a5, 0x87a6, 0x87a7, 0x87a8,   // U+ecf8 ~ U+ecff
0x87a9, 0x87aa, 0x87ab, 0x87ac, 0x87ad, 0x87ae, 0x87af, 0x87b0,   // U+ed00 ~ U+ed07
0x87b1, 0x87b2, 0x87b3, 0x87b4, 0x87b5, 0x87b6, 0x87b7, 0x87b8,   // U+ed08 ~ U+ed0f
0x87b9, 0x87ba, 0x87bb, 0x87bc, 0x87bd, 0x87be, 0x87bf, 0x87c0,   // U+ed10 ~ U+ed17
0x87c1, 0x87c2, 0x87c3, 0x87c4, 0x87c5, 0x87c6, 0x87c7, 0x87c8,   // U+ed18 ~ U+ed1f
0x87c9, 0x87ca, 0x87cb, 0x87cc, 0x87cd, 0x87ce, 0x87cf, 0x87d0,   // U+ed20 ~ U+ed27
0x87d1, 0x87d2, 0x87d3, 0x87d4, 0x87d5, 0x87d6, 0x87d7, 0x87d8,   // U+ed28 ~ U+ed2f
0x87d9, 0x87da, 0x87db, 0x87dc, 0x87dd, 0x87de, 0x87df, 0x87e0,   // U+ed30 ~ U+ed37
0x87e1, 0x87e2, 0x87e3, 0x87e4, 0x87e5, 0x87e6, 0x87e7, 0x87e8,   // U+ed38 ~ U+ed3f
0x87e9, 0x87ea, 0x87eb, 0x87ec, 0x87ed, 0x87ee, 0x87ef, 0x87f0,   // U+ed40 ~ U+ed47
0x87f1, 0x87f2, 0x87f3, 0x87f4, 0x87f5, 0x87f6, 0x87f7, 0x87f8,   // U+ed48 ~ U+ed4f
0x87f9, 0x87fa, 0x87fb, 0x87fc, 0x87fd, 0x87fe, 0x87ff, 0x8800,   // U+ed50 ~ U+ed57
0x8801, 0x8802, 0x8803, 0x8804, 0x8805, 0x8806, 0x8807, 0x8808,   // U+ed58 ~ U+ed5f
0x8809, 0x880a, 0x880b, 0x880c, 0x880d, 0x880e, 0x880f, 0x8810,   // U+ed60 ~ U+ed67
0x8811, 0x8812, 0x8813, 0x8814, 0x8815, 0x8816, 0x8817, 0x8818,   // U+ed68 ~ U+ed6f
0x8819, 0x881a, 0x881b, 0x881c, 0x881d, 0x881e, 0x881f, 0x8820,   // U+ed70 ~ U+ed77
0x8821, 0x8822, 0x8823, 0x8824, 0x8825, 0x8826, 0x8827, 0x8828,   // U+ed78 ~ U+ed7f
0x8829, 0x882a, 0x882b, 0x882c, 0x882d, 0x882e, 0x882f, 0x8830,   // U+ed80 ~ U+ed87
0x8831, 0x8832, 0x8833, 0x8834, 0x8835, 0x8836, 0x8837, 0x8838,   // U+ed88 ~ U+ed8f
0x8839, 0x883a, 0x883b, 0x883c, 0x883d, 0x883e, 0x883f, 0x8840,   // U+ed90 ~ U+ed97
0x8841, 0x8842, 0x8843, 0x8844, 0x8845, 0x8846, 0x8847, 0x8848,   // U+ed98 ~ U+ed9f
0x8849, 0x884a, 0x884b, 0x884c, 0x884d, 0x884e, 0x884f, 0x8850,   // U+eda0 ~ U+eda7
0x8851, 0x8852, 0x8853, 0x8854, 0x8855, 0x8856, 0x8857, 0x8858,   // U+eda8 ~ U+edaf
0x8859, 0x885a, 0x885b, 0x885c, 0x885d, 0x885e, 0x885f, 0x8860,   // U+edb0 ~ U+edb7
0x8861, 0x8862, 0x8863, 0x8864, 0x8865, 0x8866, 0x8867, 0x8868,   // U+edb8 ~ U+edbf
0x8869, 0x886a, 0x886b, 0x886c, 0x886d, 0x886e, 0x886f, 0x8870,   // U+edc0 ~ U+edc7
0x8871, 0x8872, 0x8873, 0x8874, 0x8875, 0x8876, 0x8877, 0x8878,   // U+edc8 ~ U+edcf
0x8879, 0x887a, 0x887b, 0x887c, 0x887d, 0x887e, 0x887f, 0x8880,   // U+edd0 ~ U+edd7
0x8881, 0x8882, 0x8883, 0x8884, 0x8885, 0x8886, 0x8887, 0x8888,   // U+edd8 ~ U+eddf
0x8889, 0x888a, 0x888b, 0x888c, 0x888d, 0x888e, 0x888f, 0x8890,   // U+ede0 ~ U+ede7
0x8891, 0x8892, 0x8893, 0x8894, 0x8895, 0x8896, 0x8897, 0x8898,   // U+ede8 ~ U+edef
0x8899, 0x889a, 0x889b, 0x889c, 0x889d, 0x889e, 0x889f, 0x88a0,   // U+edf0 ~ U+edf7
0x88a1, 0x88a2, 0x88a3, 0x88a4, 0x88a5, 0x88a6, 0x88a7, 0x88a8,   // U+edf8 ~ U+edff
0x88a9, 0x88aa, 0x88ab, 0x88ac, 0x88ad, 0x88ae, 0x88af, 0x88b0,   // U+ee00 ~ U+ee07
0x88b1, 0x88b2, 0x88b3, 0x88b4, 0x88b5, 0x88b6, 0x88b7, 0x88b8,   // U+ee08 ~ U+ee0f
0x88b9, 0x88ba, 0x88bb, 0x88bc, 0x88bd, 0x88be, 0x88bf, 0x88c0,   // U+ee10 ~ U+ee17
0x88c1, 0x88c2, 0x88c3, 0x88c4, 0x88c5, 0x88c6, 0x88c7, 0x88c8,   // U+ee18 ~ U+ee1f
0x88c9, 0x88ca, 0x88cb, 0x88cc, 0x88cd, 0x88ce, 0x88cf, 0x88d0,   // U+ee20 ~ U+ee27
0x88d1, 0x88d2, 0x88d3, 0x88d4, 0x88d5, 0x88d6, 0x88d7, 0x88d8,   // U+ee28 ~ U+ee2f
0x88d9, 0x88da, 0x88db, 0x88dc, 0x88dd, 0x88de, 0x88df, 0x88e0,   // U+ee30 ~ U+ee37
0x88e1, 0x88e2, 0x88e3, 0x88e4, 0x88e5, 0x88e6, 0x88e7, 0x88e8,   // U+ee38 ~ U+ee3f
0x88e9, 0x88ea, 0x88eb, 0x88ec, 0x88ed, 0x88ee, 0x88ef, 0x88f0,   // U+ee40 ~ U+ee47
0x88f1, 0x88f2, 0x88f3, 0x88f4, 0x88f5, 0x88f6, 0x88f7, 0x88f8,   // U+ee48 ~ U+ee4f
0x88f9, 0x88fa, 0x88fb, 0x88fc, 0x88fd, 0x88fe, 0x88ff, 0x8900,   // U+ee50 ~ U+ee57
0x8901, 0x8902, 0x8903, 0x8904, 0x8905, 0x8906, 0x8907, 0x8908,   // U+ee58 ~ U+ee5f
0x8909, 0x890a, 0x890b, 0x890c, 0x890d, 0x890e, 0x890f, 0x8910,   // U+ee60 ~ U+ee67
0x8911, 0x8912, 0x8913, 0x8914, 0x8915, 0x8916, 0x8917, 0x8918,   // U+ee68 ~ U+ee6f
0x8919, 0x891a, 0x891b, 0x891c, 0x891d, 0x891e, 0x891f, 0x8920,   // U+ee70 ~ U+ee77
0x8921, 0x8922, 0x8923, 0x8924, 0x8925, 0x8926, 0x8927, 0x8928,   // U+ee78 ~ U+ee7f
0x8929, 0x892a, 0x892b, 0x892c, 0x892d, 0x892e, 0x892f, 0x8930,   // U+ee80 ~ U+ee87
0x8931, 0x8932, 0x8933, 0x8934, 0x8935, 0x8936, 0x8937, 0x8938,   // U+ee88 ~ U+ee8f
0x8939, 0x893a, 0x893b, 0x893c, 0x893d, 0x893e, 0x893f, 0x8940,   // U+ee90 ~ U+ee97
0x8941, 0x8942, 0x8943, 0x8944, 0x8945, 0x8946, 0x8947, 0x8948,   // U+ee98 ~ U+ee9f
0x8949, 0x894a, 0x894b, 0x894c, 0x894d, 0x894e, 0x894f, 0x8950,   // U+eea0 ~ U+eea7
0x8951, 0x8952, 0x8953, 0x8954, 0x8955, 0x8956, 0x8957, 0x8958,   // U+eea8 ~ U+eeaf
0x8959, 0x895a, 0x895b, 0x895c, 0x895d, 0x895e, 0x895f, 0x8960,   // U+eeb0 ~ U+eeb7
0x8961, 0x8962, 0x8963, 0x8964, 0x8965, 0x8966, 0x8967, 0x8968,   // U+eeb8 ~ U+eebf
0x8969, 0x896a, 0x896b, 0x896c, 0x896d, 0x896e, 0x896f, 0x8970,   // U+eec0 ~ U+eec7
0x8971, 0x8972, 0x8973, 0x8974, 0x8975, 0x8976, 0x8977, 0x8978,   // U+eec8 ~ U+eecf
0x8979, 0x897a, 0x897b, 0x897c, 0x897d, 0x897e, 0x897f, 0x8980,   // U+eed0 ~ U+eed7
0x8981, 0x8982, 0x8983, 0x8984, 0x8985, 0x8986, 0x8987, 0x8988,   // U+eed8 ~ U+eedf
0x8989, 0x898a, 0x898b, 0x898c, 0x898d, 0x898e, 0x898f, 0x8990,   // U+eee0 ~ U+eee7
0x8991, 0x8992, 0x8993, 0x8994, 0x8995, 0x8996, 0x8997, 0x8998,   // U+eee8 ~ U+eeef
0x8999, 0x899a, 0x899b, 0x899c, 0x899d, 0x899e, 0x899f, 0x89a0,   // U+eef0 ~ U+eef7
0x89a1, 0x89a2, 0x89a3, 0x89a4, 0x89a5, 0x89a6, 0x89a7, 0x89a8,   // U+eef8 ~ U+eeff
0x89a9, 0x89aa, 0x89ab, 0x89ac, 0x89ad, 0x89ae, 0x89af, 0x89b0,   // U+ef00 ~ U+ef07
0x89b1, 0x89b2, 0x89b3, 0x89b4, 0x89b5, 0x89b6, 0x89b7, 0x89b8,   // U+ef08 ~ U+ef0f
0x89b9, 0x89ba, 0x89bb, 0x89bc, 0x89bd, 0x89be, 0x89bf, 0x89c0,   // U+ef10 ~ U+ef17
0x89c1, 0x89c2, 0x89c3, 0x89c4, 0x89c5, 0x89c6, 0x89c7, 0x89c8,   // U+ef18 ~ U+ef1f
0x89c9, 0x89ca, 0x89cb, 0x89cc, 0x89cd, 0x89ce, 0x89cf, 0x89d0,   // U+ef20 ~ U+ef27
0x89d1, 0x89d2, 0x89d3, 0x89d4, 0x89d5, 0x89d6, 0x89d7, 0x89d8,   // U+ef28 ~ U+ef2f
0x89d9, 0x89da, 0x89db, 0x89dc, 0x89dd, 0x89de, 0x89df, 0x89e0,   // U+ef30 ~ U+ef37
0x89e1, 0x89e2, 0x89e3, 0x89e4, 0x89e5, 0x89e6, 0x89e7, 0x89e8,   // U+ef38 ~ U+ef3f
0x89e9, 0x89ea, 0x89eb, 0x89ec, 0x89ed, 0x89ee, 0x89ef, 0x89f0,   // U+ef40 ~ U+ef47
0x89f1, 0x89f2, 0x89f3, 0x89f4, 0x89f5, 0x89f6, 0x89f7, 0x89f8,   // U+ef48 ~ U+ef4f
0x89f9, 0x89fa, 0x89fb, 0x89fc, 0x89fd, 0x89fe, 0x89ff, 0x8a00,   // U+ef50 ~ U+ef57
0x8a01, 0x8a02, 0x8a03, 0x8a04, 0x8a05, 0x8a06, 0x8a07, 0x8a08,   // U+ef58 ~ U+ef5f
0x8a09, 0x8a0a, 0x8a0b, 0x8a0c, 0x8a0d, 0x8a0e, 0x8a0f, 0x8a10,   // U+ef60 ~ U+ef67
0x8a11, 0x8a12, 0x8a13, 0x8a14, 0x8a15, 0x8a16, 0x8a17, 0x8a18,   // U+ef68 ~ U+ef6f
0x8a19, 0x8a1a, 0x8a1b, 0x8a1c, 0x8a1d, 0x8a1e, 0x8a1f, 0x8a20,   // U+ef70 ~ U+ef77
0x8a21, 0x8a22, 0x8a23, 0x8a24, 0x8a25, 0x8a26, 0x8a27, 0x8a28,   // U+ef78 ~ U+ef7f
0x8a29, 0x8a2a, 0x8a2b, 0x8a2c, 0x8a2d, 0x8a2e, 0x8a2f, 0x8a30,   // U+ef80 ~ U+ef87
0x8a31, 0x8a32, 0x8a33, 0x8a34, 0x8a35, 0x8a36, 0x8a37, 0x8a38,   // U+ef88 ~ U+ef8f
0x8a39, 0x8a3a, 0x8a3b, 0x8a3c, 0x8a3d, 0x8a3e, 0x8a3f, 0x8a40,   // U+ef90 ~ U+ef97
0x8a41, 0x8a42, 0x8a43, 0x8a44, 0x8a45, 0x8a46, 0x8a47, 0x8a48,   // U+ef98 ~ U+ef9f
0x8a49, 0x8a4a, 0x8a4b, 0x8a4c, 0x8a4d, 0x8a4e, 0x8a4f, 0x8a50,   // U+efa0 ~ U+efa7
0x8a51, 0x8a52, 0x8a53, 0x8a54, 0x8a55, 0x8a56, 0x8a57, 0x8a58,   // U+efa8 ~ U+efaf
0x8a59, 0x8a5a, 0x8a5b, 0x8a5c, 0x8a5d, 0x8a5e, 0x8a5f, 0x8a60,   // U+efb0 ~ U+efb7
0x8a61, 0x8a62, 0x8a63, 0x8a64, 0x8a65, 0x8a66, 0x8a67, 0x8a68,   // U+efb8 ~ U+efbf
0x8a69, 0x8a6a, 0x8a6b, 0x8a6c, 0x8a6d, 0x8a6e, 0x8a6f, 0x8a70,   // U+efc0 ~ U+efc7
0x8a71, 0x8a72, 0x8a73, 0x8a74, 0x8a75, 0x8a76, 0x8a77, 0x8a78,   // U+efc8 ~ U+efcf
0x8a79, 0x8a7a, 0x8a7b, 0x8a7c, 0x8a7d, 0x8a7e, 0x8a7f, 0x8a80,   // U+efd0 ~ U+efd7
0x8a81, 0x8a82, 0x8a83, 0x8a84, 0x8a85, 0x8a86, 0x8a87, 0x8a88,   // U+efd8 ~ U+efdf
0x8a89, 0x8a8a, 0x8a8b, 0x8a8c, 0x8a8d, 0x8a8e, 0x8a8f, 0x8a90,   // U+efe0 ~ U+efe7
0x8a91, 0x8a92, 0x8a93, 0x8a94, 0x8a95, 0x8a96, 0x8a97, 0x8a98,   // U+efe8 ~ U+efef
0x8a99, 0x8a9a, 0x8a9b, 0x8a9c, 0x8a9d, 0x8a9e, 0x8a9f, 0x8aa0,   // U+eff0 ~ U+eff7
0x8aa1, 0x8aa2, 0x8aa3, 0x8aa4, 0x8aa5, 0x8aa6, 0x8aa7, 0x8aa8,   // U+eff8 ~ U+efff
0x8aa9, 0x8aaa, 0x8aab, 0x8aac, 0x8aad, 0x8aae, 0x8aaf, 0x8ab0,   // U+f000 ~ U+f007
0x8ab1, 0x8ab2, 0x8ab3, 0x8ab4, 0x8ab5, 0x8ab6, 0x8ab7, 0x8ab8,   // U+f008 ~ U+f00f
0x8ab9, 0x8aba, 0x8abb, 0x8abc, 0x8abd, 0x8abe, 0x8abf, 0x8ac0,   // U+f010 ~ U+f017
0x8ac1, 0x8ac2, 0x8ac3, 0x8ac4, 0x8ac5, 0x8ac6, 0x8ac7, 0x8ac8,   // U+f018 ~ U+f01f
0x8ac9, 0x8aca, 0x8acb, 0x8acc, 0x8acd, 0x8ace, 0x8acf, 0x8ad0,   // U+f020 ~ U+f027
0x8ad1, 0x8ad2, 0x8ad3, 0x8ad4, 0x8ad5, 0x8ad6, 0x8ad7, 0x8ad8,   // U+f028 ~ U+f02f
0x8ad9, 0x8ada, 0x8adb, 0x8adc, 0x8add, 0x8ade, 0x8adf, 0x8ae0,   // U+f030 ~ U+f037
0x8ae1, 0x8ae2, 0x8ae3, 0x8ae4, 0x8ae5, 0x8ae6, 0x8ae7, 0x8ae8,   // U+f038 ~ U+f03f
0x8ae9, 0x8aea, 0x8aeb, 0x8aec, 0x8aed, 0x8aee, 0x8aef, 0x8af0,   // U+f040 ~ U+f047
0x8af1, 0x8af2, 0x8af3, 0x8af4, 0x8af5, 0x8af6, 0x8af7, 0x8af8,   // U+f048 ~ U+f04f
0x8af9, 0x8afa, 0x8afb, 0x8afc, 0x8afd, 0x8afe, 0x8aff, 0x8b00,   // U+f050 ~ U+f057
0x8b01, 0x8b02, 0x8b03, 0x8b04, 0x8b05, 0x8b06, 0x8b07, 0x8b08,   // U+f058 ~ U+f05f
0x8b09, 0x8b0a, 0x8b0b, 0x8b0c, 0x8b0d, 0x8b0e, 0x8b0f, 0x8b10,   // U+f060 ~ U+f067
0x8b11, 0x8b12, 0x8b13, 0x8b14, 0x8b15, 0x8b16, 0x8b17, 0x8b18,   // U+f068 ~ U+f06f
0x8b19, 0x8b1a, 0x8b1b, 0x8b1c, 0x8b1d, 0x8b1e, 0x8b1f, 0x8b20,   // U+f070 ~ U+f077
0x8b21, 0x8b22, 0x8b23, 0x8b24, 0x8b25, 0x8b26, 0x8b27, 0x8b28,   // U+f078 ~ U+f07f
0x8b29, 0x8b2a, 0x8b2b, 0x8b2c, 0x8b2d, 0x8b2e, 0x8b2f, 0x8b30,   // U+f080 ~ U+f087
0x8b31, 0x8b32, 0x8b33, 0x8b34, 0x8b35, 0x8b36, 0x8b37, 0x8b38,   // U+f088 ~ U+f08f
0x8b39, 0x8b3a, 0x8b3b, 0x8b3c, 0x8b3d, 0x8b3e, 0x8b3f, 0x8b40,   // U+f090 ~ U+f097
0x8b41, 0x8b42, 0x8b43, 0x8b44, 0x8b45, 0x8b46, 0x8b47, 0x8b48,   // U+f098 ~ U+f09f
0x8b49, 0x8b4a, 0x8b4b, 0x8b4c, 0x8b4d, 0x8b4e, 0x8b4f, 0x8b50,   // U+f0a0 ~ U+f0a7
0x8b51, 0x8b52, 0x8b53, 0x8b54, 0x8b55, 0x8b56, 0x8b57, 0x8b58,   // U+f0a8 ~ U+f0af
0x8b59, 0x8b5a, 0x8b5b, 0x8b5c, 0x8b5d, 0x8b5e, 0x8b5f, 0x8b60,   // U+f0b0 ~ U+f0b7
0x8b61, 0x8b62, 0x8b63, 0x8b64, 0x8b65, 0x8b66, 0x8b67, 0x8b68,   // U+f0b8 ~ U+f0bf
0x8b69, 0x8b6a, 0x8b6b, 0x8b6c, 0x8b6d, 0x8b6e, 0x8b6f, 0x8b70,   // U+f0c0 ~ U+f0c7
0x8b71, 0x8b72, 0x8b73, 0x8b74, 0x8b75, 0x8b76, 0x8b77, 0x8b78,   // U+f0c8 ~ U+f0cf
0x8b79, 0x8b7a, 0x8b7b, 0x8b7c, 0x8b7d, 0x8b7e, 0x8b7f, 0x8b80,   // U+f0d0 ~ U+f0d7
0x8b81, 0x8b82, 0x8b83, 0x8b84, 0x8b85, 0x8b86, 0x8b87, 0x8b88,   // U+f0d8 ~ U+f0df
0x8b89, 0x8b8a, 0x8b8b, 0x8b8c, 0x8b8d, 0x8b8e, 0x8b8f, 0x8b90,   // U+f0e0 ~ U+f0e7
0x8b91, 0x8b92, 0x8b93, 0x8b94, 0x8b95, 0x8b96, 0x8b97, 0x8b98,   // U+f0e8 ~ U+f0ef
0x8b99, 0x8b9a, 0x8b9b, 0x8b9c, 0x8b9d, 0x8b9e, 0x8b9f, 0x8ba0,   // U+f0f0 ~ U+f0f7
0x8ba1, 0x8ba2, 0x8ba3, 0x8ba4, 0x8ba5, 0x8ba6, 0x8ba7, 0x8ba8,   // U+f0f8 ~ U+f0ff
0x8ba9, 0x8baa, 0x8bab, 0x8bac, 0x8bad, 0x8bae, 0x8baf, 0x8bb0,   // U+f100 ~ U+f107
0x8bb1, 0x8bb2, 0x8bb3, 0x8bb4, 0x8bb5, 0x8bb6, 0x8bb7, 0x8bb8,   // U+f108 ~ U+f10f
0x8bb9, 0x8bba, 0x8bbb, 0x8bbc, 0x8bbd, 0x8bbe, 0x8bbf, 0x8bc0,   // U+f110 ~ U+f117
0x8bc1, 0x8bc2, 0x8bc3, 0x8bc4, 0x8bc5, 0x8bc6, 0x8bc7, 0x8bc8,   // U+f118 ~ U+f11f
0x8bc9, 0x8bca, 0x8bcb, 0x8bcc, 0x8bcd, 0x8bce, 0x8bcf, 0x8bd0,   // U+f120 ~ U+f127
0x8bd1, 0x8bd2, 0x8bd3, 0x8bd4, 0x8bd5, 0x8bd6, 0x8bd7, 0x8bd8,   // U+f128 ~ U+f12f
0x8bd9, 0x8bda, 0x8bdb, 0x8bdc, 0x8bdd, 0x8bde, 0x8bdf, 0x8be0,   // U+f130 ~ U+f137
0x8be1, 0x8be2, 0x8be3, 0x8be4, 0x8be5, 0x8be6, 0x8be7, 0x8be8,   // U+f138 ~ U+f13f
0x8be9, 0x8bea, 0x8beb, 0x8bec, 0x8bed, 0x8bee, 0x8bef, 0x8bf0,   // U+f140 ~ U+f147
0x8bf1, 0x8bf2, 0x8bf3, 0x8bf4, 0x8bf5, 0x8bf6, 0x8bf7, 0x8bf8,   // U+f148 ~ U+f14f
0x8bf9, 0x8bfa, 0x8bfb, 0x8bfc, 0x8bfd, 0x8bfe, 0x8bff, 0x8c00,   // U+f150 ~ U+f157
0x8c01, 0x8c02, 0x8c03, 0x8c04, 0x8c05, 0x8c06, 0x8c07, 0x8c08,   // U+f158 ~ U+f15f
0x8c09, 0x8c0a, 0x8c0b, 0x8c0c, 0x8c0d, 0x8c0e, 0x8c0f, 0x8c10,   // U+f160 ~ U+f167
0x8c11, 0x8c12, 0x8c13, 0x8c14, 0x8c15, 0x8c16, 0x8c17, 0x8c18,   // U+f168 ~ U+f16f
0x8c19, 0x8c1a, 0x8c1b, 0x8c1c, 0x8c1d, 0x8c1e, 0x8c1f, 0x8c20,   // U+f170 ~ U+f177
0x8c21, 0x8c22, 0x8c23, 0x8c24, 0x8c25, 0x8c26, 0x8c27, 0x8c28,   // U+f178 ~ U+f17f
0x8c29, 0x8c2a, 0x8c2b, 0x8c2c, 0x8c2d, 0x8c2e, 0x8c2f, 0x8c30,   // U+f180 ~ U+f187
0x8c31, 0x8c32, 0x8c33, 0x8c34, 0x8c35, 0x8c36, 0x8c37, 0x8c38,   // U+f188 ~ U+f18f
0x8c39, 0x8c3a, 0x8c3b, 0x8c3c, 0x8c3d, 0x8c3e, 0x8c3f, 0x8c40,   // U+f190 ~ U+f197
0x8c41, 0x8c42, 0x8c43, 0x8c44, 0x8c45, 0x8c46, 0x8c47, 0x8c48,   // U+f198 ~ U+f19f
0x8c49, 0x8c4a, 0x8c4b, 0x8c4c, 0x8c4d, 0x8c4e, 0x8c4f, 0x8c50,   // U+f1a0 ~ U+f1a7
0x8c51, 0x8c52, 0x8c53, 0x8c54, 0x8c55, 0x8c56, 0x8c57, 0x8c58,   // U+f1a8 ~ U+f1af
0x8c59, 0x8c5a, 0x8c5b, 0x8c5c, 0x8c5d, 0x8c5e, 0x8c5f, 0x8c60,   // U+f1b0 ~ U+f1b7
0x8c61, 0x8c62, 0x8c63, 0x8c64, 0x8c65, 0x8c66, 0x8c67, 0x8c68,   // U+f1b8 ~ U+f1bf
0x8c69, 0x8c6a, 0x8c6b, 0x8c6c, 0x8c6d, 0x8c6e, 0x8c6f, 0x8c70,   // U+f1c0 ~ U+f1c7
0x8c71, 0x8c72, 0x8c73, 0x8c74, 0x8c75, 0x8c76, 0x8c77, 0x8c78,   // U+f1c8 ~ U+f1cf
0x8c79, 0x8c7a, 0x8c7b, 0x8c7c, 0x8c7d, 0x8c7e, 0x8c7f, 0x8c80,   // U+f1d0 ~ U+f1d7
0x8c81, 0x8c82, 0x8c83, 0x8c84, 0x8c85, 0x8c86, 0x8c87, 0x8c88,   // U+f1d8 ~ U+f1df
0x8c89, 0x8c8a, 0x8c8b, 0x8c8c, 0x8c8d, 0x8c8e, 0x8c8f, 0x8c90,   // U+f1e0 ~ U+f1e7
0x8c91, 0x8c92, 0x8c93, 0x8c94, 0x8c95, 0x8c96, 0x8c97, 0x8c98,   // U+f1e8 ~ U+f1ef
0x8c99, 0x8c9a, 0x8c9b, 0x8c9c, 0x8c9d, 0x8c9e, 0x8c9f, 0x8ca0,   // U+f1f0 ~ U+f1f7
0x8ca1, 0x8ca2, 0x8ca3, 0x8ca4, 0x8ca5, 0x8ca6, 0x8ca7, 0x8ca8,   // U+f1f8 ~ U+f1ff
0x8ca9, 0x8caa, 0x8cab, 0x8cac, 0x8cad, 0x8cae, 0x8caf, 0x8cb0,   // U+f200 ~ U+f207
0x8cb1, 0x8cb2, 0x8cb3, 0x8cb4, 0x8cb5, 0x8cb6, 0x8cb7, 0x8cb8,   // U+f208 ~ U+f20f
0x8cb9, 0x8cba, 0x8cbb, 0x8cbc, 0x8cbd, 0x8cbe, 0x8cbf, 0x8cc0,   // U+f210 ~ U+f217
0x8cc1, 0x8cc2, 0x8cc3, 0x8cc4, 0x8cc5, 0x8cc6, 0x8cc7, 0x8cc8,   // U+f218 ~ U+f21f
0x8cc9, 0x8cca, 0x8ccb, 0x8ccc, 0x8ccd, 0x8cce, 0x8ccf, 0x8cd0,   // U+f220 ~ U+f227
0x8cd1, 0x8cd2, 0x8cd3, 0x8cd4, 0x8cd5, 0x8cd6, 0x8cd7, 0x8cd8,   // U+f228 ~ U+f22f
0x8cd9, 0x8cda, 0x8cdb, 0x8cdc, 0x8cdd, 0x8cde, 0x8cdf, 0x8ce0,   // U+f230 ~ U+f237
0x8ce1, 0x8ce2, 0x8ce3, 0x8ce4, 0x8ce5, 0x8ce6, 0x8ce7, 0x8ce8,   // U+f238 ~ U+f23f
0x8ce9, 0x8cea, 0x8ceb, 0x8cec, 0x8ced, 0x8cee, 0x8cef, 0x8cf0,   // U+f240 ~ U+f247
0x8cf1, 0x8cf2, 0x8cf3, 0x8cf4, 0x8cf5, 0x8cf6, 0x8cf7, 0x8cf8,   // U+f248 ~ U+f24f
0x8cf9, 0x8cfa, 0x8cfb, 0x8cfc, 0x8cfd, 0x8cfe, 0x8cff, 0x8d00,   // U+f250 ~ U+f257
0x8d01, 0x8d02, 0x8d03, 0x8d04, 0x8d05, 0x8d06, 0x8d07, 0x8d08,   // U+f258 ~ U+f25f
0x8d09, 0x8d0a, 0x8d0b, 0x8d0c, 0x8d0d, 0x8d0e, 0x8d0f, 0x8d10,   // U+f260 ~ U+f267
0x8d11, 0x8d12, 0x8d13, 0x8d14, 0x8d15, 0x8d16, 0x8d17, 0x8d18,   // U+f268 ~ U+f26f
0x8d19, 0x8d1a, 0x8d1b, 0x8d1c, 0x8d1d, 0x8d1e, 0x8d1f, 0x8d20,   // U+f270 ~ U+f277
0x8d21, 0x8d22, 0x8d23, 0x8d24, 0x8d25, 0x8d26, 0x8d27, 0x8d28,   // U+f278 ~ U+f27f
0x8d29, 0x8d2a, 0x8d2b, 0x8d2c, 0x8d2d, 0x8d2e, 0x8d2f, 0x8d30,   // U+f280 ~ U+f287
0x8d31, 0x8d32, 0x8d33, 0x8d34, 0x8d35, 0x8d36, 0x8d37, 0x8d38,   // U+f288 ~ U+f28f
0x8d39, 0x8d3a, 0x8d3b, 0x8d3c, 0x8d3d, 0x8d3e, 0x8d3f, 0x8d40,   // U+f290 ~ U+f297
0x8d41, 0x8d42, 0x8d43, 0x8d44, 0x8d45, 0x8d46, 0x8d47, 0x8d48,   // U+f298 ~ U+f29f
0x8d49, 0x8d4a, 0x8d4b, 0x8d4c, 0x8d4d, 0x8d4e, 0x8d4f, 0x8d50,   // U+f2a0 ~ U+f2a7
0x8d51, 0x8d52, 0x8d53, 0x8d54, 0x8d55, 0x8d56, 0x8d57, 0x8d58,   // U+f2a8 ~ U+f2af
0x8d59, 0x8d5a, 0x8d5b, 0x8d5c, 0x8d5d, 0x8d5e, 0x8d5f, 0x8d60,   // U+f2b0 ~ U+f2b7
0x8d61, 0x8d62, 0x8d63, 0x8d64, 0x8d65, 0x8d66, 0x8d67, 0x8d68,   // U+f2b8 ~ U+f2bf
0x8d69, 0x8d6a, 0x8d6b, 0x8d6c, 0x8d6d, 0x8d6e, 0x8d6f, 0x8d70,   // U+f2c0 ~ U+f2c7
0x8d71, 0x8d72, 0x8d73, 0x8d74, 0x8d75, 0x8d76, 0x8d77, 0x8d78,   // U+f2c8 ~ U+f2cf
0x8d79, 0x8d7a, 0x8d7b, 0x8d7c, 0x8d7d, 0x8d7e, 0x8d7f, 0x8d80,   // U+f2d0 ~ U+f2d7
0x8d81, 0x8d82, 0x8d83, 0x8d84, 0x8d85, 0x8d86, 0x8d87, 0x8d88,   // U+f2d8 ~ U+f2df
0x8d89, 0x8d8a, 0x8d8b, 0x8d8c, 0x8d8d, 0x8d8e, 0x8d8f, 0x8d90,   // U+f2e0 ~ U+f2e7
0x8d91, 0x8d92, 0x8d93, 0x8d94, 0x8d95, 0x8d96, 0x8d97, 0x8d98,   // U+f2e8 ~ U+f2ef
0x8d99, 0x8d9a, 0x8d9b, 0x8d9c, 0x8d9d, 0x8d9e, 0x8d9f, 0x8da0,   // U+f2f0 ~ U+f2f7
0x8da1, 0x8da2, 0x8da3, 0x8da4, 0x8da5, 0x8da6, 0x8da7, 0x8da8,   // U+f2f8 ~ U+f2ff
0x8da9, 0x8daa, 0x8dab, 0x8dac, 0x8dad, 0x8dae, 0x8daf, 0x8db0,   // U+f300 ~ U+f307
0x8db1, 0x8db2, 0x8db3, 0x8db4, 0x8db5, 0x8db6, 0x8db7, 0x8db8,   // U+f308 ~ U+f30f
0x8db9, 0x8dba, 0x8dbb, 0x8dbc, 0x8dbd, 0x8dbe, 0x8dbf, 0x8dc0,   // U+f310 ~ U+f317
0x8dc1, 0x8dc2, 0x8dc3, 0x8dc4, 0x8dc5, 0x8dc6, 0x8dc7, 0x8dc8,   // U+f318 ~ U+f31f
0x8dc9, 0x8dca, 0x8dcb, 0x8dcc, 0x8dcd, 0x8dce, 0x8dcf, 0x8dd0,   // U+f320 ~ U+f327
0x8dd1, 0x8dd2, 0x8dd3, 0x8dd4, 0x8dd5, 0x8dd6, 0x8dd7, 0x8dd8,   // U+f328 ~ U+f32f
0x8dd9, 0x8dda, 0x8ddb, 0x8ddc, 0x8ddd, 0x8dde, 0x8ddf, 0x8de0,   // U+f330 ~ U+f337
0x8de1, 0x8de2, 0x8de3, 0x8de4, 0x8de5, 0x8de6, 0x8de7, 0x8de8,   // U+f338 ~ U+f33f
0x8de9, 0x8dea, 0x8deb, 0x8dec, 0x8ded, 0x8dee, 0x8def, 0x8df0,   // U+f340 ~ U+f347
0x8df1, 0x8df2, 0x8df3, 0x8df4, 0x8df5, 0x8df6, 0x8df7, 0x8df8,   // U+f348 ~ U+f34f
0x8df9, 0x8dfa, 0x8dfb, 0x8dfc, 0x8dfd, 0x8dfe, 0x8dff, 0x8e00,   // U+f350 ~ U+f357
0x8e01, 0x8e02, 0x8e03, 0x8e04, 0x8e05, 0x8e06, 0x8e07, 0x8e08,   // U+f358 ~ U+f35f
0x8e09, 0x8e0a, 0x8e0b, 0x8e0c, 0x8e0d, 0x8e0e, 0x8e0f, 0x8e10,   // U+f360 ~ U+f367
0x8e11, 0x8e12, 0x8e13, 0x8e14, 0x8e15, 0x8e16, 0x8e17, 0x8e18,   // U+f368 ~ U+f36f
0x8e19, 0x8e1a, 0x8e1b, 0x8e1c, 0x8e1d, 0x8e1e, 0x8e1f, 0x8e20,   // U+f370 ~ U+f377
0x8e21, 0x8e22, 0x8e23, 0x8e24, 0x8e25, 0x8e26, 0x8e27, 0x8e28,   // U+f378 ~ U+f37f
0x8e29, 0x8e2a, 0x8e2b, 0x8e2c, 0x8e2d, 0x8e2e, 0x8e2f, 0x8e30,   // U+f380 ~ U+f387
0x8e31, 0x8e32, 0x8e33, 0x8e34, 0x8e35, 0x8e36, 0x8e37, 0x8e38,   // U+f388 ~ U+f38f
0x8e39, 0x8e3a, 0x8e3b, 0x8e3c, 0x8e3d, 0x8e3e, 0x8e3f, 0x8e40,   // U+f390 ~ U+f397
0x8e41, 0x8e42, 0x8e43, 0x8e44, 0x8e45, 0x8e46, 0x8e47, 0x8e48,   // U+f398 ~ U+f39f
0x8e49, 0x8e4a, 0x8e4b, 0x8e4c, 0x8e4d, 0x8e4e, 0x8e4f, 0x8e50,   // U+f3a0 ~ U+f3a7
0x8e51, 0x8e52, 0x8e53, 0x8e54, 0x8e55, 0x8e56, 0x8e57, 0x8e58,   // U+f3a8 ~ U+f3af
0x8e59, 0x8e5a, 0x8e5b, 0x8e5c, 0x8e5d, 0x8e5e, 0x8e5f, 0x8e60,   // U+f3b0 ~ U+f3b7
0x8e61, 0x8e62, 0x8e63, 0x8e64, 0x8e65, 0x8e66, 0x8e67, 0x8e68,   // U+f3b8 ~ U+f3bf
0x8e69, 0x8e6a, 0x8e6b, 0x8e6c, 0x8e6d, 0x8e6e, 0x8e6f, 0x8e70,   // U+f3c0 ~ U+f3c7
0x8e71, 0x8e72, 0x8e73, 0x8e74, 0x8e75, 0x8e76, 0x8e77, 0x8e78,   // U+f3c8 ~ U+f3cf
0x8e79, 0x8e7a, 0x8e7b, 0x8e7c, 0x8e7d, 0x8e7e, 0x8e7f, 0x8e80,   // U+f3d0 ~ U+f3d7
0x8e81, 0x8e82, 0x8e83, 0x8e84, 0x8e85, 0x8e86, 0x8e87, 0x8e88,   // U+f3d8 ~ U+f3df
0x8e89, 0x8e8a, 0x8e8b, 0x8e8c, 0x8e8d, 0x8e8e, 0x8e8f, 0x8e90,   // U+f3e0 ~ U+f3e7
0x8e91, 0x8e92, 0x8e93, 0x8e94, 0x8e95, 0x8e96, 0x8e97, 0x8e98,   // U+f3e8 ~ U+f3ef
0x8e99, 0x8e9a, 0x8e9b, 0x8e9c, 0x8e9d, 0x8e9e, 0x8e9f, 0x8ea0,   // U+f3f0 ~ U+f3f7
0x8ea1, 0x8ea2, 0x8ea3, 0x8ea4, 0x8ea5, 0x8ea6, 0x8ea7, 0x8ea8,   // U+f3f8 ~ U+f3ff
0x8ea9, 0x8eaa, 0x8eab, 0x8eac, 0x8ead, 0x8eae, 0x8eaf, 0x8eb0,   // U+f400 ~ U+f407
0x8eb1, 0x8eb2, 0x8eb3, 0x8eb4, 0x8eb5, 0x8eb6, 0x8eb7, 0x8eb8,   // U+f408 ~ U+f40f
0x8eb9, 0x8eba, 0x8ebb, 0x8ebc, 0x8ebd, 0x8ebe, 0x8ebf, 0x8ec0,   // U+f410 ~ U+f417
0x8ec1, 0x8ec2, 0x8ec3, 0x8ec4, 0x8ec5, 0x8ec6, 0x8ec7, 0x8ec8,   // U+f418 ~ U+f41f
0x8ec9, 0x8eca, 0x8ecb, 0x8ecc, 0x8ecd, 0x8ece, 0x8ecf, 0x8ed0,   // U+f420 ~ U+f427
0x8ed1, 0x8ed2, 0x8ed3, 0x8ed4, 0x8ed5, 0x8ed6, 0x8ed7, 0x8ed8,   // U+f428 ~ U+f42f
0x8ed9, 0x8eda, 0x8edb, 0x8edc, 0x8edd, 0x8ede, 0x8edf, 0x8ee0,   // U+f430 ~ U+f437
0x8ee1, 0x8ee2, 0x8ee3, 0x8ee4, 0x8ee5, 0x8ee6, 0x8ee7, 0x8ee8,   // U+f438 ~ U+f43f
0x8ee9, 0x8eea, 0x8eeb, 0x8eec, 0x8eed, 0x8eee, 0x8eef, 0x8ef0,   // U+f440 ~ U+f447
0x8ef1, 0x8ef2, 0x8ef3, 0x8ef4, 0x8ef5, 0x8ef6, 0x8ef7, 0x8ef8,   // U+f448 ~ U+f44f
0x8ef9, 0x8efa, 0x8efb, 0x8efc, 0x8efd, 0x8efe, 0x8eff, 0x8f00,   // U+f450 ~ U+f457
0x8f01, 0x8f02, 0x8f03, 0x8f04, 0x8f05, 0x8f06, 0x8f07, 0x8f08,   // U+f458 ~ U+f45f
0x8f09, 0x8f0a, 0x8f0b, 0x8f0c, 0x8f0d, 0x8f0e, 0x8f0f, 0x8f10,   // U+f460 ~ U+f467
0x8f11, 0x8f12, 0x8f13, 0x8f14, 0x8f15, 0x8f16, 0x8f17, 0x8f18,   // U+f468 ~ U+f46f
0x8f19, 0x8f1a, 0x8f1b, 0x8f1c, 0x8f1d, 0x8f1e, 0x8f1f, 0x8f20,   // U+f470 ~ U+f477
0x8f21, 0x8f22, 0x8f23, 0x8f24, 0x8f25, 0x8f26, 0x8f27, 0x8f28,   // U+f478 ~ U+f47f
0x8f29, 0x8f2a, 0x8f2b, 0x8f2c, 0x8f2d, 0x8f2e, 0x8f2f, 0x8f30,   // U+f480 ~ U+f487
0x8f31, 0x8f32, 0x8f33, 0x8f34, 0x8f35, 0x8f36, 0x8f37, 0x8f38,   // U+f488 ~ U+f48f
0x8f39, 0x8f3a, 0x8f3b, 0x8f3c, 0x8f3d, 0x8f3e, 0x8f3f, 0x8f40,   // U+f490 ~ U+f497
0x8f41, 0x8f42, 0x8f43, 0x8f44, 0x8f45, 0x8f46, 0x8f47, 0x8f48,   // U+f498 ~ U+f49f
0x8f49, 0x8f4a, 0x8f4b, 0x8f4c, 0x8f4d, 0x8f4e, 0x8f4f, 0x8f50,   // U+f4a0 ~ U+f4a7
0x8f51, 0x8f52, 0x8f53, 0x8f54, 0x8f55, 0x8f56, 0x8f57, 0x8f58,   // U+f4a8 ~ U+f4af
0x8f59, 0x8f5a, 0x8f5b, 0x8f5c, 0x8f5d, 0x8f5e, 0x8f5f, 0x8f60,   // U+f4b0 ~ U+f4b7
0x8f61, 0x8f62, 0x8f63, 0x8f64, 0x8f65, 0x8f66, 0x8f67, 0x8f68,   // U+f4b8 ~ U+f4bf
0x8f69, 0x8f6a, 0x8f6b, 0x8f6c, 0x8f6d, 0x8f6e, 0x8f6f, 0x8f70,   // U+f4c0 ~ U+f4c7
0x8f71, 0x8f72, 0x8f73, 0x8f74, 0x8f75, 0x8f76, 0x8f77, 0x8f78,   // U+f4c8 ~ U+f4cf
0x8f79, 0x8f7a, 0x8f7b, 0x8f7c, 0x8f7d, 0x8f7e, 0x8f7f, 0x8f80,   // U+f4d0 ~ U+f4d7
0x8f81, 0x8f82, 0x8f83, 0x8f84, 0x8f85, 0x8f86, 0x8f87, 0x8f88,   // U+f4d8 ~ U+f4df
0x8f89, 0x8f8a, 0x8f8b, 0x8f8c, 0x8f8d, 0x8f8e, 0x8f8f, 0x8f90,   // U+f4e0 ~ U+f4e7
0x8f91, 0x8f92, 0x8f93, 0x8f94, 0x8f95, 0x8f96, 0x8f97, 0x8f98,   // U+f4e8 ~ U+f4ef
0x8f99, 0x8f9a, 0x8f9b, 0x8f9c, 0x8f9d, 0x8f9e, 0x8f9f, 0x8fa0,   // U+f4f0 ~ U+f4f7
0x8fa1, 0x8fa2, 0x8fa3, 0x8fa4, 0x8fa5, 0x8fa6, 0x8fa7, 0x8fa8,   // U+f4f8 ~ U+f4ff
0x8fa9, 0x8faa, 0x8fab, 0x8fac, 0x8fad, 0x8fae, 0x8faf, 0x8fb0,   // U+f500 ~ U+f507
0x8fb1, 0x8fb2, 0x8fb3, 0x8fb4, 0x8fb5, 0x8fb6, 0x8fb7, 0x8fb8,   // U+f508 ~ U+f50f
0x8fb9, 0x8fba, 0x8fbb, 0x8fbc, 0x8fbd, 0x8fbe, 0x8fbf, 0x8fc0,   // U+f510 ~ U+f517
0x8fc1, 0x8fc2, 0x8fc3, 0x8fc4, 0x8fc5, 0x8fc6, 0x8fc7, 0x8fc8,   // U+f518 ~ U+f51f
0x8fc9, 0x8fca, 0x8fcb, 0x8fcc, 0x8fcd, 0x8fce, 0x8fcf, 0x8fd0,   // U+f520 ~ U+f527
0x8fd1, 0x8fd2, 0x8fd3, 0x8fd4, 0x8fd5, 0x8fd6, 0x8fd7, 0x8fd8,   // U+f528 ~ U+f52f
0x8fd9, 0x8fda, 0x8fdb, 0x8fdc, 0x8fdd, 0x8fde, 0x8fdf, 0x8fe0,   // U+f530 ~ U+f537
0x8fe1, 0x8fe2, 0x8fe3, 0x8fe4, 0x8fe5, 0x8fe6, 0x8fe7, 0x8fe8,   // U+f538 ~ U+f53f
0x8fe9, 0x8fea, 0x8feb, 0x8fec, 0x8fed, 0x8fee, 0x8fef, 0x8ff0,   // U+f540 ~ U+f547
0x8ff1, 0x8ff2, 0x8ff3, 0x8ff4, 0x8ff5, 0x8ff6, 0x8ff7, 0x8ff8,   // U+f548 ~ U+f54f
0x8ff9, 0x8ffa, 0x8ffb, 0x8ffc, 0x8ffd, 0x8ffe, 0x8fff, 0x9000,   // U+f550 ~ U+f557
0x9001, 0x9002, 0x9003, 0x9004, 0x9005, 0x9006, 0x9007, 0x9008,   // U+f558 ~ U+f55f
0x9009, 0x900a, 0x900b, 0x900c, 0x900d, 0x900e, 0x900f, 0x9010,   // U+f560 ~ U+f567
0x9011, 0x9012, 0x9013, 0x9014, 0x9015, 0x9016, 0x9017, 0x9018,   // U+f568 ~ U+f56f
0x9019, 0x901a, 0x901b, 0x901c, 0x901d, 0x901e, 0x901f, 0x9020,   // U+f570 ~ U+f577
0x9021, 0x9022, 0x9023, 0x9024, 0x9025, 0x9026, 0x9027, 0x9028,   // U+f578 ~ U+f57f
0x9029, 0x902a, 0x902b, 0x902c, 0x902d, 0x902e, 0x902f, 0x9030,   // U+f580 ~ U+f587
0x9031, 0x9032, 0x9033, 0x9034, 0x9035, 0x9036, 0x9037, 0x9038,   // U+f588 ~ U+f58f
0x9039, 0x903a, 0x903b, 0x903c, 0x903d, 0x903e, 0x903f, 0x9040,   // U+f590 ~ U+f597
0x9041, 0x9042, 0x9043, 0x9044, 0x9045, 0x9046, 0x9047, 0x9048,   // U+f598 ~ U+f59f
0x9049, 0x904a, 0x904b, 0x904c, 0x904d, 0x904e, 0x904f, 0x9050,   // U+f5a0 ~ U+f5a7
0x9051, 0x9052, 0x9053, 0x9054, 0x9055, 0x9056, 0x9057, 0x9058,   // U+f5a8 ~ U+f5af
0x9059, 0x905a, 0x905b, 0x905c, 0x905d, 0x905e, 0x905f, 0x9060,   // U+f5b0 ~ U+f5b7
0x9061, 0x9062, 0x9063, 0x9064, 0x9065, 0x9066, 0x9067, 0x9068,   // U+f5b8 ~ U+f5bf
0x9069, 0x906a, 0x906b, 0x906c, 0x906d, 0x906e, 0x906f, 0x9070,   // U+f5c0 ~ U+f5c7
0x9071, 0x9072, 0x9073, 0x9074, 0x9075, 0x9076, 0x9077, 0x9078,   // U+f5c8 ~ U+f5cf
0x9079, 0x907a, 0x907b, 0x907c, 0x907d, 0x907e, 0x907f, 0x9080,   // U+f5d0 ~ U+f5d7
0x9081, 0x9082, 0x9083, 0x9084, 0x9085, 0x9086, 0x9087, 0x9088,   // U+f5d8 ~ U+f5df
0x9089, 0x908a, 0x908b, 0x908c, 0x908d, 0x908e, 0x908f, 0x9090,   // U+f5e0 ~ U+f5e7
0x9091, 0x9092, 0x9093, 0x9094, 0x9095, 0x9096, 0x9097, 0x9098,   // U+f5e8 ~ U+f5ef
0x9099, 0x909a, 0x909b, 0x909c, 0x909d, 0x909e, 0x909f, 0x90a0,   // U+f5f0 ~ U+f5f7
0x90a1, 0x90a2, 0x90a3, 0x90a4, 0x90a5, 0x90a6, 0x90a7, 0x90a8,   // U+f5f8 ~ U+f5ff
0x90a9, 0x90aa, 0x90ab, 0x90ac, 0x90ad, 0x90ae, 0x90af, 0x90b0,   // U+f600 ~ U+f607
0x90b1, 0x90b2, 0x90b3, 0x90b4, 0x90b5, 0x90b6, 0x90b7, 0x90b8,   // U+f608 ~ U+f60f
0x90b9, 0x90ba, 0x90bb, 0x90bc, 0x90bd, 0x90be, 0x90bf, 0x90c0,   // U+f610 ~ U+f617
0x90c1, 0x90c2, 0x90c3, 0x90c4, 0x90c5, 0x90c6, 0x90c7, 0x90c8,   // U+f618 ~ U+f61f
0x90c9, 0x90ca, 0x90cb, 0x90cc, 0x90cd, 0x90ce, 0x90cf, 0x90d0,   // U+f620 ~ U+f627
0x90d1, 0x90d2, 0x90d3, 0x90d4, 0x90d5, 0x90d6, 0x90d7, 0x90d8,   // U+f628 ~ U+f62f
0x90d9, 0x90da, 0x90db, 0x90dc, 0x90dd, 0x90de, 0x90df, 0x90e0,   // U+f630 ~ U+f637
0x90e1, 0x90e2, 0x90e3, 0x90e4, 0x90e5, 0x90e6, 0x90e7, 0x90e8,   // U+f638 ~ U+f63f
0x90e9, 0x90ea, 0x90eb, 0x90ec, 0x90ed, 0x90ee, 0x90ef, 0x90f0,   // U+f640 ~ U+f647
0x90f1, 0x90f2, 0x90f3, 0x90f4, 0x90f5, 0x90f6, 0x90f7, 0x90f8,   // U+f648 ~ U+f64f
0x90f9, 0x90fa, 0x90fb, 0x90fc, 0x90fd, 0x90fe, 0x90ff, 0x9100,   // U+f650 ~ U+f657
0x9101, 0x9102, 0x9103, 0x9104, 0x9105, 0x9106, 0x9107, 0x9108,   // U+f658 ~ U+f65f
0x9109, 0x910a, 0x910b, 0x910c, 0x910d, 0x910e, 0x910f, 0x9110,   // U+f660 ~ U+f667
0x9111, 0x9112, 0x9113, 0x9114, 0x9115, 0x9116, 0x9117, 0x9118,   // U+f668 ~ U+f66f
0x9119, 0x911a, 0x911b, 0x911c, 0x911d, 0x911e, 0x911f, 0x9120,   // U+f670 ~ U+f677
0x9121, 0x9122, 0x9123, 0x9124, 0x9125, 0x9126, 0x9127, 0x9128,   // U+f678 ~ U+f67f
0x9129, 0x912a, 0x912b, 0x912c, 0x912d, 0x912e, 0x912f, 0x9130,   // U+f680 ~ U+f687
0x9131, 0x9132, 0x9133, 0x9134, 0x9135, 0x9136, 0x9137, 0x9138,   // U+f688 ~ U+f68f
0x9139, 0x913a, 0x913b, 0x913c, 0x913d, 0x913e, 0x913f, 0x9140,   // U+f690 ~ U+f697
0x9141, 0x9142, 0x9143, 0x9144, 0x9145, 0x9146, 0x9147, 0x9148,   // U+f698 ~ U+f69f
0x9149, 0x914a, 0x914b, 0x914c, 0x914d, 0x914e, 0x914f, 0x9150,   // U+f6a0 ~ U+f6a7
0x9151, 0x9152, 0x9153, 0x9154, 0x9155, 0x9156, 0x9157, 0x9158,   // U+f6a8 ~ U+f6af
0x9159, 0x915a, 0x915b, 0x915c, 0x915d, 0x915e, 0x915f, 0x9160,   // U+f6b0 ~ U+f6b7
0x9161, 0x9162, 0x9163, 0x9164, 0x9165, 0x9166, 0x9167, 0x9168,   // U+f6b8 ~ U+f6bf
0x9169, 0x916a, 0x916b, 0x916c, 0x916d, 0x916e, 0x916f, 0x9170,   // U+f6c0 ~ U+f6c7
0x9171, 0x9172, 0x9173, 0x9174, 0x9175, 0x9176, 0x9177, 0x9178,   // U+f6c8 ~ U+f6cf
0x9179, 0x917a, 0x917b, 0x917c, 0x917d, 0x917e, 0x917f, 0x9180,   // U+f6d0 ~ U+f6d7
0x9181, 0x9182, 0x9183, 0x9184, 0x9185, 0x9186, 0x9187, 0x9188,   // U+f6d8 ~ U+f6df
0x9189, 0x918a, 0x918b, 0x918c, 0x918d, 0x918e, 0x918f, 0x9190,   // U+f6e0 ~ U+f6e7
0x9191, 0x9192, 0x9193, 0x9194, 0x9195, 0x9196, 0x9197, 0x9198,   // U+f6e8 ~ U+f6ef
0x9199, 0x919a, 0x919b, 0x919c, 0x919d, 0x919e, 0x919f, 0x91a0,   // U+f6f0 ~ U+f6f7
0x91a1, 0x91a2, 0x91a3, 0x91a4, 0x91a5, 0x91a6, 0x91a7, 0x91a8,   // U+f6f8 ~ U+f6ff
0x91a9, 0x91aa, 0x91ab, 0x91ac, 0x91ad, 0x91ae, 0x91af, 0x91b0,   // U+f700 ~ U+f707
0x91b1, 0x91b2, 0x91b3, 0x91b4, 0x91b5, 0x91b6, 0x91b7, 0x91b8,   // U+f708 ~ U+f70f
0x91b9, 0x91ba, 0x91bb, 0x91bc, 0x91bd, 0x91be, 0x91bf, 0x91c0,   // U+f710 ~ U+f717
0x91c1, 0x91c2, 0x91c3, 0x91c4, 0x91c5, 0x91c6, 0x91c7, 0x91c8,   // U+f718 ~ U+f71f
0x91c9, 0x91ca, 0x91cb, 0x91cc, 0x91cd, 0x91ce, 0x91cf, 0x91d0,   // U+f720 ~ U+f727
0x91d1, 0x91d2, 0x91d3, 0x91d4, 0x91d5, 0x91d6, 0x91d7, 0x91d8,   // U+f728 ~ U+f72f
0x91d9, 0x91da, 0x91db, 0x91dc, 0x91dd, 0x91de, 0x91df, 0x91e0,   // U+f730 ~ U+f737
0x91e1, 0x91e2, 0x91e3, 0x91e4, 0x91e5, 0x91e6, 0x91e7, 0x91e8,   // U+f738 ~ U+f73f
0x91e9, 0x91ea, 0x91eb, 0x91ec, 0x91ed, 0x91ee, 0x91ef, 0x91f0,   // U+f740 ~ U+f747
0x91f1, 0x91f2, 0x91f3, 0x91f4, 0x91f5, 0x91f6, 0x91f7, 0x91f8,   // U+f748 ~ U+f74f
0x91f9, 0x91fa, 0x91fb, 0x91fc, 0x91fd, 0x91fe, 0x91ff, 0x9200,   // U+f750 ~ U+f757
0x9201, 0x9202, 0x9203, 0x9204, 0x9205, 0x9206, 0x9207, 0x9208,   // U+f758 ~ U+f75f
0x9209, 0x920a, 0x920b, 0x920c, 0x920d, 0x920e, 0x920f, 0x9210,   // U+f760 ~ U+f767
0x9211, 0x9212, 0x9213, 0x9214, 0x9215, 0x9216, 0x9217, 0x9218,   // U+f768 ~ U+f76f
0x9219, 0x921a, 0x921b, 0x921c, 0x921d, 0x921e, 0x921f, 0x9220,   // U+f770 ~ U+f777
0x9221, 0x9222, 0x9223, 0x9224, 0x9225, 0x9226, 0x9227, 0x9228,   // U+f778 ~ U+f77f
0x9229, 0x922a, 0x922b, 0x922c, 0x922d, 0x922e, 0x922f, 0x9230,   // U+f780 ~ U+f787
0x9231, 0x9232, 0x9233, 0x9234, 0x9235, 0x9236, 0x9237, 0x9238,   // U+f788 ~ U+f78f
0x9239, 0x923a, 0x923b, 0x923c, 0x923d, 0x923e, 0x923f, 0x9240,   // U+f790 ~ U+f797
0x9241, 0x9242, 0x9243, 0x9244, 0x9245, 0x9246, 0x9247, 0x9248,   // U+f798 ~ U+f79f
0x9249, 0x924a, 0x924b, 0x924c, 0x924d, 0x924e, 0x924f, 0x9250,   // U+f7a0 ~ U+f7a7
0x9251, 0x9252, 0x9253, 0x9254, 0x9255, 0x9256, 0x9257, 0x9258,   // U+f7a8 ~ U+f7af
0x9259, 0x925a, 0x925b, 0x925c, 0x925d, 0x925e, 0x925f, 0x9260,   // U+f7b0 ~ U+f7b7
0x9261, 0x9262, 0x9263, 0x9264, 0x9265, 0x9266, 0x9267, 0x9268,   // U+f7b8 ~ U+f7bf
0x9269, 0x926a, 0x926b, 0x926c, 0x926d, 0x926e, 0x926f, 0x9270,   // U+f7c0 ~ U+f7c7
0x9271, 0x9272, 0x9273, 0x9274, 0x9275, 0x9276, 0x9277, 0x9278,   // U+f7c8 ~ U+f7cf
0x9279, 0x927a, 0x927b, 0x927c, 0x927d, 0x927e, 0x927f, 0x9280,   // U+f7d0 ~ U+f7d7
0x9281, 0x9282, 0x9283, 0x9284, 0x9285, 0x9286, 0x9287, 0x9288,   // U+f7d8 ~ U+f7df
0x9289, 0x928a, 0x928b, 0x928c, 0x928d, 0x928e, 0x928f, 0x9290,   // U+f7e0 ~ U+f7e7
0x9291, 0x9292, 0x9293, 0x9294, 0x9295, 0x9296, 0x9297, 0x9298,   // U+f7e8 ~ U+f7ef
0x9299, 0x929a, 0x929b, 0x929c, 0x929d, 0x929e, 0x929f, 0x92a0,   // U+f7f0 ~ U+f7f7
0x92a1, 0x92a2, 0x92a3, 0x92a4, 0x92a5, 0x92a6, 0x92a7, 0x92a8,   // U+f7f8 ~ U+f7ff
0x92a9, 0x92aa, 0x92ab, 0x92ac, 0x92ad, 0x92ae, 0x92af, 0x92b0,   // U+f800 ~ U+f807
0x92b1, 0x92b2, 0x92b3, 0x92b4, 0x92b5, 0x92b6, 0x92b7, 0x92b8,   // U+f808 ~ U+f80f
0x92b9, 0x92ba, 0x92bb, 0x92bc, 0x92bd, 0x92be, 0x92bf, 0x92c0,   // U+f810 ~ U+f817
0x92c1, 0x92c2, 0x92c3, 0x92c4, 0x92c5, 0x92c6, 0x92c7, 0x92c8,   // U+f818 ~ U+f81f
0x92c9, 0x92ca, 0x92cb, 0x92cc, 0x92cd, 0x92ce, 0x92cf, 0x92d0,   // U+f820 ~ U+f827
0x92d1, 0x92d2, 0x92d3, 0x92d4, 0x92d5, 0x92d6, 0x92d7, 0x92d8,   // U+f828 ~ U+f82f
0x92d9, 0x92da, 0x92db, 0x92dc, 0x92dd, 0x92de, 0x92df, 0x92e0,   // U+f830 ~ U+f837
0x92e1, 0x92e2, 0x92e3, 0x92e4, 0x92e5, 0x92e6, 0x92e7, 0x92e8,   // U+f838 ~ U+f83f
0x92e9, 0x92ea, 0x92eb, 0x92ec, 0x92ed, 0x92ee, 0x92ef, 0x92f0,   // U+f840 ~ U+f847
0x92f1, 0x92f2, 0x92f3, 0x92f4, 0x92f5, 0x92f6, 0x92f7, 0x92f8,   // U+f848 ~ U+f84f
0x92f9, 0x92fa, 0x92fb, 0x92fc, 0x92fd, 0x92fe, 0x92ff, 0x9300,   // U+f850 ~ U+f857
0x9301, 0x9302, 0x9303, 0x9304, 0x9305, 0x9306, 0x9307, 0x9308,   // U+f858 ~ U+f85f
0x9309, 0x930a, 0x930b, 0x930c, 0x930d, 0x930e, 0x930f, 0x9310,   // U+f860 ~ U+f867
0x9311, 0x9312, 0x9313, 0x9314, 0x9315, 0x9316, 0x9317, 0x9318,   // U+f868 ~ U+f86f
0x9319, 0x931a, 0x931b, 0x931c, 0x931d, 0x931e, 0x931f, 0x9320,   // U+f870 ~ U+f877
0x9321, 0x9322, 0x9323, 0x9324, 0x9325, 0x9326, 0x9327, 0x9328,   // U+f878 ~ U+f87f
0x9329, 0x932a, 0x932b, 0x932c, 0x932d, 0x932e, 0x932f, 0x9330,   // U+f880 ~ U+f887
0x9331, 0x9332, 0x9333, 0x9334, 0x9335, 0x9336, 0x9337, 0x9338,   // U+f888 ~ U+f88f
0x9339, 0x933a, 0x933b, 0x933c, 0x933d, 0x933e, 0x933f, 0x9340,   // U+f890 ~ U+f897
0x9341, 0x9342, 0x9343, 0x9344, 0x9345, 0x9346, 0x9347, 0x9348,   // U+f898 ~ U+f89f
0x9349, 0x934a, 0x934b, 0x934c, 0x934d, 0x934e, 0x934f, 0x9350,   // U+f8a0 ~ U+f8a7
0x9351, 0x9352, 0x9353, 0x9354, 0x9355, 0x9356, 0x9357, 0x9358,   // U+f8a8 ~ U+f8af
0x9359, 0x935a, 0x935b, 0x935c, 0x935d, 0x935e, 0x935f, 0x9360,   // U+f8b0 ~ U+f8b7
0x9361, 0x9362, 0x9363, 0x9364, 0x9365, 0x9366, 0x9367, 0x9368,   // U+f8b8 ~ U+f8bf
0x9369, 0x936a, 0x936b, 0x936c, 0x936d, 0x936e, 0x936f, 0x9370,   // U+f8c0 ~ U+f8c7
0x9371, 0x9372, 0x9373, 0x9374, 0x9375, 0x9376, 0x9377, 0x9378,   // U+f8c8 ~ U+f8cf
0x9379, 0x937a, 0x937b, 0x937c, 0x937d, 0x937e, 0x937f, 0x9380,   // U+f8d0 ~ U+f8d7
0x9381, 0x9382, 0x9383, 0x9384, 0x9385, 0x9386, 0x9387, 0x9388,   // U+f8d8 ~ U+f8df
0x9389, 0x938a, 0x938b, 0x938c, 0x938d, 0x938e, 0x938f, 0x9390,   // U+f8e0 ~ U+f8e7
0x9391, 0x9392, 0x9393, 0x9394, 0x9395, 0x9396, 0x9397, 0x9398,   // U+f8e8 ~ U+f8ef
0x9399, 0x939a, 0x939b, 0x939c, 0x939d, 0x939e, 0x939f, 0x93a0,   // U+f8f0 ~ U+f8f7
0x93a1, 0x93a2, 0x93a3, 0x93a4, 0x93a5, 0x93a6, 0x93a7, 0x93a8,   // U+f8f8 ~ U+f8ff
0x93a9, 0x93aa, 0x93ab, 0x93ac, 0x93ad, 0x93ae, 0x93af, 0x93b0,   // U+f900 ~ U+f907
0x93b1, 0x93b2, 0x93b3, 0x93b4, 0x93b5, 0x93b6, 0x93b7, 0x93b8,   // U+f908 ~ U+f90f
0x93b9, 0x93ba, 0x93bb, 0x93bc, 0x93bd, 0x93be, 0x93bf, 0x93c0,   // U+f910 ~ U+f917
0x93c1, 0x93c2, 0x93c3, 0x93c4, 0x93c5, 0x93c6, 0x93c7, 0x93c8,   // U+f918 ~ U+f91f
0x93c9, 0x93ca, 0x93cb, 0x93cc, 0x93cd, 0x93ce, 0x93cf, 0x93d0,   // U+f920 ~ U+f927
0x93d1, 0x93d2, 0x93d3, 0x93d4, 0xffff, 0x93d5, 0x93d6, 0x93d7,   // U+f928 ~ U+f92f
0x93d8, 0x93d9, 0x93da, 0x93db, 0x93dc, 0x93dd, 0x93de, 0x93df,   // U+f930 ~ U+f937
0x93e0, 0x93e1, 0x93e2, 0x93e3, 0x93e4, 0x93e5, 0x93e6, 0x93e7,   // U+f938 ~ U+f93f
0x93e8, 0x93e9, 0x93ea, 0x93eb, 0x93ec, 0x93ed, 0x93ee, 0x93ef,   // U+f940 ~ U+f947
0x93f0, 0x93f1, 0x93f2, 0x93f3, 0x93f4, 0x93f5, 0x93f6, 0x93f7,   // U+f948 ~ U+f94f
0x93f8, 0x93f9, 0x93fa, 0x93fb, 0x93fc, 0x93fd, 0x93fe, 0x93ff,   // U+f950 ~ U+f957
0x9400, 0x9401, 0x9402, 0x9403, 0x9404, 0x9405, 0x9406, 0x9407,   // U+f958 ~ U+f95f
0x9408, 0x9409, 0x940a, 0x940b, 0x940c, 0x940d, 0x940e, 0x940f,   // U+f960 ~ U+f967
0x9410, 0x9411, 0x9412, 0x9413, 0x9414, 0x9415, 0x9416, 0x9417,   // U+f968 ~ U+f96f
0x9418, 0x9419, 0x941a, 0x941b, 0x941c, 0x941d, 0x941e, 0x941f,   // U+f970 ~ U+f977
0x9420, 0xffff, 0x9421, 0x9422, 0x9423, 0x9424, 0x9425, 0x9426,   // U+f978 ~ U+f97f
0x9427, 0x9428, 0x9429, 0x942a, 0x942b, 0x942c, 0x942d, 0x942e,   // U+f980 ~ U+f987
0x942f, 0x9430, 0x9431, 0x9432, 0x9433, 0x9434, 0x9435, 0x9436,   // U+f988 ~ U+f98f
0x9437, 0x9438, 0x9439, 0x943a, 0x943b, 0xffff, 0x943c, 0x943d,   // U+f990 ~ U+f997
0x943e, 0x943f, 0x9440, 0x9441, 0x9442, 0x9443, 0x9444, 0x9445,   // U+f998 ~ U+f99f
0x9446, 0x9447, 0x9448, 0x9449, 0x944a, 0x944b, 0x944c, 0x944d,   // U+f9a0 ~ U+f9a7
0x944e, 0x944f, 0x9450, 0x9451, 0x9452, 0x9453, 0x9454, 0x9455,   // U+f9a8 ~ U+f9af
0x9456, 0x9457, 0x9458, 0x9459, 0x945a, 0x945b, 0x945c, 0x945d,   // U+f9b0 ~ U+f9b7
0x945e, 0x945f, 0x9460, 0x9461, 0x9462, 0x9463, 0x9464, 0x9465,   // U+f9b8 ~ U+f9bf
0x9466, 0x9467, 0x9468, 0x9469, 0x946a, 0x946b, 0x946c, 0x946d,   // U+f9c0 ~ U+f9c7
0x946e, 0x946f, 0x9470, 0x9471, 0x9472, 0x9473, 0x9474, 0x9475,   // U+f9c8 ~ U+f9cf
0x9476, 0x9477, 0x9478, 0x9479, 0x947a, 0x947b, 0x947c, 0x947d,   // U+f9d0 ~ U+f9d7
0x947e, 0x947f, 0x9480, 0x9481, 0x9482, 0x9483, 0x9484, 0x9485,   // U+f9d8 ~ U+f9df
0x9486, 0x9487, 0x9488, 0x9489, 0x948a, 0x948b, 0x948c, 0xffff,   // U+f9e0 ~ U+f9e7
0x948d, 0x948e, 0x948f, 0x9490, 0x9491, 0x9492, 0x9493, 0x9494,   // U+f9e8 ~ U+f9ef
0x9495, 0xffff, 0x9496, 0x9497, 0x9498, 0x9499, 0x949a, 0x949b,   // U+f9f0 ~ U+f9f7
0x949c, 0x949d, 0x949e, 0x949f, 0x94a0, 0x94a1, 0x94a2, 0x94a3,   // U+f9f8 ~ U+f9ff
0x94a4, 0x94a5, 0x94a6, 0x94a7, 0x94a8, 0x94a9, 0x94aa, 0x94ab,   // U+fa00 ~ U+fa07
0x94ac, 0x94ad, 0x94ae, 0x94af, 0xffff, 0xffff, 0xffff, 0xffff,   // U+fa08 ~ U+fa0f
0x94b0, 0xffff, 0x94b1, 0xffff, 0xffff, 0x94b2, 0x94b3, 0x94b4,   // U+fa10 ~ U+fa17
0xffff, 0x94b5, 0x94b6, 0x94b7, 0x94b8, 0x94b9, 0x94ba, 0xffff,   // U+fa18 ~ U+fa1f
0xffff, 0xffff, 0x94bb, 0xffff, 0xffff, 0x94bc, 0x94bd, 0xffff,   // U+fa20 ~ U+fa27
0xffff, 0xffff, 0x94be, 0x94bf, 0x94c0, 0x94c1, 0x94c2, 0x94c3,   // U+fa28 ~ U+fa2f
0x94c4, 0x94c5, 0x94c6, 0x94c7, 0x94c8, 0x94c9, 0x94ca, 0x94cb,   // U+fa30 ~ U+fa37
0x94cc, 0x94cd, 0x94ce, 0x94cf, 0x94d0, 0x94d1, 0x94d2, 0x94d3,   // U+fa38 ~ U+fa3f
0x94d4, 0x94d5, 0x94d6, 0x94d7, 0x94d8, 0x94d9, 0x94da, 0x94db,   // U+fa40 ~ U+fa47
0x94dc, 0x94dd, 0x94de, 0x94df, 0x94e0, 0x94e1, 0x94e2, 0x94e3,   // U+fa48 ~ U+fa4f
0x94e4, 0x94e5, 0x94e6, 0x94e7, 0x94e8, 0x94e9, 0x94ea, 0x94eb,   // U+fa50 ~ U+fa57
0x94ec, 0x94ed, 0x94ee, 0x94ef, 0x94f0, 0x94f1, 0x94f2, 0x94f3,   // U+fa58 ~ U+fa5f
0x94f4, 0x94f5, 0x94f6, 0x94f7, 0x94f8, 0x94f9, 0x94fa, 0x94fb,   // U+fa60 ~ U+fa67
0x94fc, 0x94fd, 0x94fe, 0x94ff, 0x9500, 0x9501, 0x9502, 0x9503,   // U+fa68 ~ U+fa6f
0x9504, 0x9505, 0x9506, 0x9507, 0x9508, 0x9509, 0x950a, 0x950b,   // U+fa70 ~ U+fa77
0x950c, 0x950d, 0x950e, 0x950f, 0x9510, 0x9511, 0x9512, 0x9513,   // U+fa78 ~ U+fa7f
0x9514, 0x9515, 0x9516, 0x9517, 0x9518, 0x9519, 0x951a, 0x951b,   // U+fa80 ~ U+fa87
0x951c, 0x951d, 0x951e, 0x951f, 0x9520, 0x9521, 0x9522, 0x9523,   // U+fa88 ~ U+fa8f
0x9524, 0x9525, 0x9526, 0x9527, 0x9528, 0x9529, 0x952a, 0x952b,   // U+fa90 ~ U+fa97
0x952c, 0x952d, 0x952e, 0x952f, 0x9530, 0x9531, 0x9532, 0x9533,   // U+fa98 ~ U+fa9f
0x9534, 0x9535, 0x9536, 0x9537, 0x9538, 0x9539, 0x953a, 0x953b,   // U+faa0 ~ U+faa7
0x953c, 0x953d, 0x953e, 0x953f, 0x9540, 0x9541, 0x9542, 0x9543,   // U+faa8 ~ U+faaf
0x9544, 0x9545, 0x9546, 0x9547, 0x9548, 0x9549, 0x954a, 0x954b,   // U+fab0 ~ U+fab7
0x954c, 0x954d, 0x954e, 0x954f, 0x9550, 0x9551, 0x9552, 0x9553,   // U+fab8 ~ U+fabf
0x9554, 0x9555, 0x9556, 0x9557, 0x9558, 0x9559, 0x955a, 0x955b,   // U+fac0 ~ U+fac7
0x955c, 0x955d, 0x955e, 0x955f, 0x9560, 0x9561, 0x9562, 0x9563,   // U+fac8 ~ U+facf
0x9564, 0x9565, 0x9566, 0x9567, 0x9568, 0x9569, 0x956a, 0x956b,   // U+fad0 ~ U+fad7
0x956c, 0x956d, 0x956e, 0x956f, 0x9570, 0x9571, 0x9572, 0x9573,   // U+fad8 ~ U+fadf
0x9574, 0x9575, 0x9576, 0x9577, 0x9578, 0x9579, 0x957a, 0x957b,   // U+fae0 ~ U+fae7
0x957c, 0x957d, 0x957e, 0x957f, 0x9580, 0x9581, 0x9582, 0x9583,   // U+fae8 ~ U+faef
0x9584, 0x9585, 0x9586, 0x9587, 0x9588, 0x9589, 0x958a, 0x958b,   // U+faf0 ~ U+faf7
0x958c, 0x958d, 0x958e, 0x958f, 0x9590, 0x9591, 0x9592, 0x9593,   // U+faf8 ~ U+faff
0x9594, 0x9595, 0x9596, 0x9597, 0x9598, 0x9599, 0x959a, 0x959b,   // U+fb00 ~ U+fb07
0x959c, 0x959d, 0x959e, 0x959f, 0x95a0, 0x95a1, 0x95a2, 0x95a3,   // U+fb08 ~ U+fb0f
0x95a4, 0x95a5, 0x95a6, 0x95a7, 0x95a8, 0x95a9, 0x95aa, 0x95ab,   // U+fb10 ~ U+fb17
0x95ac, 0x95ad, 0x95ae, 0x95af, 0x95b0, 0x95b1, 0x95b2, 0x95b3,   // U+fb18 ~ U+fb1f
0x95b4, 0x95b5, 0x95b6, 0x95b7, 0x95b8, 0x95b9, 0x95ba, 0x95bb,   // U+fb20 ~ U+fb27
0x95bc, 0x95bd, 0x95be, 0x95bf, 0x95c0, 0x95c1, 0x95c2, 0x95c3,   // U+fb28 ~ U+fb2f
0x95c4, 0x95c5, 0x95c6, 0x95c7, 0x95c8, 0x95c9, 0x95ca, 0x95cb,   // U+fb30 ~ U+fb37
0x95cc, 0x95cd, 0x95ce, 0x95cf, 0x95d0, 0x95d1, 0x95d2, 0x95d3,   // U+fb38 ~ U+fb3f
0x95d4, 0x95d5, 0x95d6, 0x95d7, 0x95d8, 0x95d9, 0x95da, 0x95db,   // U+fb40 ~ U+fb47
0x95dc, 0x95dd, 0x95de, 0x95df, 0x95e0, 0x95e1, 0x95e2, 0x95e3,   // U+fb48 ~ U+fb4f
0x95e4, 0x95e5, 0x95e6, 0x95e7, 0x95e8, 0x95e9, 0x95ea, 0x95eb,   // U+fb50 ~ U+fb57
0x95ec, 0x95ed, 0x95ee, 0x95ef, 0x95f0, 0x95f1, 0x95f2, 0x95f3,   // U+fb58 ~ U+fb5f
0x95f4, 0x95f5, 0x95f6, 0x95f7, 0x95f8, 0x95f9, 0x95fa, 0x95fb,   // U+fb60 ~ U+fb67
0x95fc, 0x95fd, 0x95fe, 0x95ff, 0x9600, 0x9601, 0x9602, 0x9603,   // U+fb68 ~ U+fb6f
0x9604, 0x9605, 0x9606, 0x9607, 0x9608, 0x9609, 0x960a, 0x960b,   // U+fb70 ~ U+fb77
0x960c, 0x960d, 0x960e, 0x960f, 0x9610, 0x9611, 0x9612, 0x9613,   // U+fb78 ~ U+fb7f
0x9614, 0x9615, 0x9616, 0x9617, 0x9618, 0x9619, 0x961a, 0x961b,   // U+fb80 ~ U+fb87
0x961c, 0x961d, 0x961e, 0x961f, 0x9620, 0x9621, 0x9622, 0x9623,   // U+fb88 ~ U+fb8f
0x9624, 0x9625, 0x9626, 0x9627, 0x9628, 0x9629, 0x962a, 0x962b,   // U+fb90 ~ U+fb97
0x962c, 0x962d, 0x962e, 0x962f, 0x9630, 0x9631, 0x9632, 0x9633,   // U+fb98 ~ U+fb9f
0x9634, 0x9635, 0x9636, 0x9637, 0x9638, 0x9639, 0x963a, 0x963b,   // U+fba0 ~ U+fba7
0x963c, 0x963d, 0x963e, 0x963f, 0x9640, 0x9641, 0x9642, 0x9643,   // U+fba8 ~ U+fbaf
0x9644, 0x9645, 0x9646, 0x9647, 0x9648, 0x9649, 0x964a, 0x964b,   // U+fbb0 ~ U+fbb7
0x964c, 0x964d, 0x964e, 0x964f, 0x9650, 0x9651, 0x9652, 0x9653,   // U+fbb8 ~ U+fbbf
0x9654, 0x9655, 0x9656, 0x9657, 0x9658, 0x9659, 0x965a, 0x965b,   // U+fbc0 ~ U+fbc7
0x965c, 0x965d, 0x965e, 0x965f, 0x9660, 0x9661, 0x9662, 0x9663,   // U+fbc8 ~ U+fbcf
0x9664, 0x9665, 0x9666, 0x9667, 0x9668, 0x9669, 0x966a, 0x966b,   // U+fbd0 ~ U+fbd7
0x966c, 0x966d, 0x966e, 0x966f, 0x9670, 0x9671, 0x9672, 0x9673,   // U+fbd8 ~ U+fbdf
0x9674, 0x9675, 0x9676, 0x9677, 0x9678, 0x9679, 0x967a, 0x967b,   // U+fbe0 ~ U+fbe7
0x967c, 0x967d, 0x967e, 0x967f, 0x9680, 0x9681, 0x9682, 0x9683,   // U+fbe8 ~ U+fbef
0x9684, 0x9685, 0x9686, 0x9687, 0x9688, 0x9689, 0x968a, 0x968b,   // U+fbf0 ~ U+fbf7
0x968c, 0x968d, 0x968e, 0x968f, 0x9690, 0x9691, 0x9692, 0x9693,   // U+fbf8 ~ U+fbff
0x9694, 0x9695, 0x9696, 0x9697, 0x9698, 0x9699, 0x969a, 0x969b,   // U+fc00 ~ U+fc07
0x969c, 0x969d, 0x969e, 0x969f, 0x96a0, 0x96a1, 0x96a2, 0x96a3,   // U+fc08 ~ U+fc0f
0x96a4, 0x96a5, 0x96a6, 0x96a7, 0x96a8, 0x96a9, 0x96aa, 0x96ab,   // U+fc10 ~ U+fc17
0x96ac, 0x96ad, 0x96ae, 0x96af, 0x96b0, 0x96b1, 0x96b2, 0x96b3,   // U+fc18 ~ U+fc1f
0x96b4, 0x96b5, 0x96b6, 0x96b7, 0x96b8, 0x96b9, 0x96ba, 0x96bb,   // U+fc20 ~ U+fc27
0x96bc, 0x96bd, 0x96be, 0x96bf, 0x96c0, 0x96c1, 0x96c2, 0x96c3,   // U+fc28 ~ U+fc2f
0x96c4, 0x96c5, 0x96c6, 0x96c7, 0x96c8, 0x96c9, 0x96ca, 0x96cb,   // U+fc30 ~ U+fc37
0x96cc, 0x96cd, 0x96ce, 0x96cf, 0x96d0, 0x96d1, 0x96d2, 0x96d3,   // U+fc38 ~ U+fc3f
0x96d4, 0x96d5, 0x96d6, 0x96d7, 0x96d8, 0x96d9, 0x96da, 0x96db,   // U+fc40 ~ U+fc47
0x96dc, 0x96dd, 0x96de, 0x96df, 0x96e0, 0x96e1, 0x96e2, 0x96e3,   // U+fc48 ~ U+fc4f
0x96e4, 0x96e5, 0x96e6, 0x96e7, 0x96e8, 0x96e9, 0x96ea, 0x96eb,   // U+fc50 ~ U+fc57
0x96ec, 0x96ed, 0x96ee, 0x96ef, 0x96f0, 0x96f1, 0x96f2, 0x96f3,   // U+fc58 ~ U+fc5f
0x96f4, 0x96f5, 0x96f6, 0x96f7, 0x96f8, 0x96f9, 0x96fa, 0x96fb,   // U+fc60 ~ U+fc67
0x96fc, 0x96fd, 0x96fe, 0x96ff, 0x9700, 0x9701, 0x9702, 0x9703,   // U+fc68 ~ U+fc6f
0x9704, 0x9705, 0x9706, 0x9707, 0x9708, 0x9709, 0x970a, 0x970b,   // U+fc70 ~ U+fc77
0x970c, 0x970d, 0x970e, 0x970f, 0x9710, 0x9711, 0x9712, 0x9713,   // U+fc78 ~ U+fc7f
0x9714, 0x9715, 0x9716, 0x9717, 0x9718, 0x9719, 0x971a, 0x971b,   // U+fc80 ~ U+fc87
0x971c, 0x971d, 0x971e, 0x971f, 0x9720, 0x9721, 0x9722, 0x9723,   // U+fc88 ~ U+fc8f
0x9724, 0x9725, 0x9726, 0x9727, 0x9728, 0x9729, 0x972a, 0x972b,   // U+fc90 ~ U+fc97
0x972c, 0x972d, 0x972e, 0x972f, 0x9730, 0x9731, 0x9732, 0x9733,   // U+fc98 ~ U+fc9f
0x9734, 0x9735, 0x9736, 0x9737, 0x9738, 0x9739, 0x973a, 0x973b,   // U+fca0 ~ U+fca7
0x973c, 0x973d, 0x973e, 0x973f, 0x9740, 0x9741, 0x9742, 0x9743,   // U+fca8 ~ U+fcaf
0x9744, 0x9745, 0x9746, 0x9747, 0x9748, 0x9749, 0x974a, 0x974b,   // U+fcb0 ~ U+fcb7
0x974c, 0x974d, 0x974e, 0x974f, 0x9750, 0x9751, 0x9752, 0x9753,   // U+fcb8 ~ U+fcbf
0x9754, 0x9755, 0x9756, 0x9757, 0x9758, 0x9759, 0x975a, 0x975b,   // U+fcc0 ~ U+fcc7
0x975c, 0x975d, 0x975e, 0x975f, 0x9760, 0x9761, 0x9762, 0x9763,   // U+fcc8 ~ U+fccf
0x9764, 0x9765, 0x9766, 0x9767, 0x9768, 0x9769, 0x976a, 0x976b,   // U+fcd0 ~ U+fcd7
0x976c, 0x976d, 0x976e, 0x976f, 0x9770, 0x9771, 0x9772, 0x9773,   // U+fcd8 ~ U+fcdf
0x9774, 0x9775, 0x9776, 0x9777, 0x9778, 0x9779, 0x977a, 0x977b,   // U+fce0 ~ U+fce7
0x977c, 0x977d, 0x977e, 0x977f, 0x9780, 0x9781, 0x9782, 0x9783,   // U+fce8 ~ U+fcef
0x9784, 0x9785, 0x9786, 0x9787, 0x9788, 0x9789, 0x978a, 0x978b,   // U+fcf0 ~ U+fcf7
0x978c, 0x978d, 0x978e, 0x978f, 0x9790, 0x9791, 0x9792, 0x9793,   // U+fcf8 ~ U+fcff
0x9794, 0x9795, 0x9796, 0x9797, 0x9798, 0x9799, 0x979a, 0x979b,   // U+fd00 ~ U+fd07
0x979c, 0x979d, 0x979e, 0x979f, 0x97a0, 0x97a1, 0x97a2, 0x97a3,   // U+fd08 ~ U+fd0f
0x97a4, 0x97a5, 0x97a6, 0x97a7, 0x97a8, 0x97a9, 0x97aa, 0x97ab,   // U+fd10 ~ U+fd17
0x97ac, 0x97ad, 0x97ae, 0x97af, 0x97b0, 0x97b1, 0x97b2, 0x97b3,   // U+fd18 ~ U+fd1f
0x97b4, 0x97b5, 0x97b6, 0x97b7, 0x97b8, 0x97b9, 0x97ba, 0x97bb,   // U+fd20 ~ U+fd27
0x97bc, 0x97bd, 0x97be, 0x97bf, 0x97c0, 0x97c1, 0x97c2, 0x97c3,   // U+fd28 ~ U+fd2f
0x97c4, 0x97c5, 0x97c6, 0x97c7, 0x97c8, 0x97c9, 0x97ca, 0x97cb,   // U+fd30 ~ U+fd37
0x97cc, 0x97cd, 0x97ce, 0x97cf, 0x97d0, 0x97d1, 0x97d2, 0x97d3,   // U+fd38 ~ U+fd3f
0x97d4, 0x97d5, 0x97d6, 0x97d7, 0x97d8, 0x97d9, 0x97da, 0x97db,   // U+fd40 ~ U+fd47
0x97dc, 0x97dd, 0x97de, 0x97df, 0x97e0, 0x97e1, 0x97e2, 0x97e3,   // U+fd48 ~ U+fd4f
0x97e4, 0x97e5, 0x97e6, 0x97e7, 0x97e8, 0x97e9, 0x97ea, 0x97eb,   // U+fd50 ~ U+fd57
0x97ec, 0x97ed, 0x97ee, 0x97ef, 0x97f0, 0x97f1, 0x97f2, 0x97f3,   // U+fd58 ~ U+fd5f
0x97f4, 0x97f5, 0x97f6, 0x97f7, 0x97f8, 0x97f9, 0x97fa, 0x97fb,   // U+fd60 ~ U+fd67
0x97fc, 0x97fd, 0x97fe, 0x97ff, 0x9800, 0x9801, 0x9802, 0x9803,   // U+fd68 ~ U+fd6f
0x9804, 0x9805, 0x9806, 0x9807, 0x9808, 0x9809, 0x980a, 0x980b,   // U+fd70 ~ U+fd77
0x980c, 0x980d, 0x980e, 0x980f, 0x9810, 0x9811, 0x9812, 0x9813,   // U+fd78 ~ U+fd7f
0x9814, 0x9815, 0x9816, 0x9817, 0x9818, 0x9819, 0x981a, 0x981b,   // U+fd80 ~ U+fd87
0x981c, 0x981d, 0x981e, 0x981f, 0x9820, 0x9821, 0x9822, 0x9823,   // U+fd88 ~ U+fd8f
0x9824, 0x9825, 0x9826, 0x9827, 0x9828, 0x9829, 0x982a, 0x982b,   // U+fd90 ~ U+fd97
0x982c, 0x982d, 0x982e, 0x982f, 0x9830, 0x9831, 0x9832, 0x9833,   // U+fd98 ~ U+fd9f
0x9834, 0x9835, 0x9836, 0x9837, 0x9838, 0x9839, 0x983a, 0x983b,   // U+fda0 ~ U+fda7
0x983c, 0x983d, 0x983e, 0x983f, 0x9840, 0x9841, 0x9842, 0x9843,   // U+fda8 ~ U+fdaf
0x9844, 0x9845, 0x9846, 0x9847, 0x9848, 0x9849, 0x984a, 0x984b,   // U+fdb0 ~ U+fdb7
0x984c, 0x984d, 0x984e, 0x984f, 0x9850, 0x9851, 0x9852, 0x9853,   // U+fdb8 ~ U+fdbf
0x9854, 0x9855, 0x9856, 0x9857, 0x9858, 0x9859, 0x985a, 0x985b,   // U+fdc0 ~ U+fdc7
0x985c, 0x985d, 0x985e, 0x985f, 0x9860, 0x9861, 0x9862, 0x9863,   // U+fdc8 ~ U+fdcf
0x9864, 0x9865, 0x9866, 0x9867, 0x9868, 0x9869, 0x986a, 0x986b,   // U+fdd0 ~ U+fdd7
0x986c, 0x986d, 0x986e, 0x986f, 0x9870, 0x9871, 0x9872, 0x9873,   // U+fdd8 ~ U+fddf
0x9874, 0x9875, 0x9876, 0x9877, 0x9878, 0x9879, 0x987a, 0x987b,   // U+fde0 ~ U+fde7
0x987c, 0x987d, 0x987e, 0x987f, 0x9880, 0x9881, 0x9882, 0x9883,   // U+fde8 ~ U+fdef
0x9884, 0x9885, 0x9886, 0x9887, 0x9888, 0x9889, 0x988a, 0x988b,   // U+fdf0 ~ U+fdf7
0x988c, 0x988d, 0x988e, 0x988f, 0x9890, 0x9891, 0x9892, 0x9893,   // U+fdf8 ~ U+fdff
0x9894, 0x9895, 0x9896, 0x9897, 0x9898, 0x9899, 0x989a, 0x989b,   // U+fe00 ~ U+fe07
0x989c, 0x989d, 0x989e, 0x989f, 0x98a0, 0x98a1, 0x98a2, 0x98a3,   // U+fe08 ~ U+fe0f
0x98a4, 0x98a5, 0x98a6, 0x98a7, 0x98a8, 0x98a9, 0x98aa, 0x98ab,   // U+fe10 ~ U+fe17
0x98ac, 0x98ad, 0x98ae, 0x98af, 0x98b0, 0x98b1, 0x98b2, 0x98b3,   // U+fe18 ~ U+fe1f
0x98b4, 0x98b5, 0x98b6, 0x98b7, 0x98b8, 0x98b9, 0x98ba, 0x98bb,   // U+fe20 ~ U+fe27
0x98bc, 0x98bd, 0x98be, 0x98bf, 0x98c0, 0x98c1, 0x98c2, 0x98c3,   // U+fe28 ~ U+fe2f
0xffff, 0xffff, 0x98c4, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+fe30 ~ U+fe37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+fe38 ~ U+fe3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x98c5, 0x98c6, 0x98c7,   // U+fe40 ~ U+fe47
0x98c8, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+fe48 ~ U+fe4f
0xffff, 0xffff, 0xffff, 0x98c9, 0xffff, 0xffff, 0xffff, 0xffff,   // U+fe50 ~ U+fe57
0x98ca, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+fe58 ~ U+fe5f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x98cb,   // U+fe60 ~ U+fe67
0xffff, 0xffff, 0xffff, 0xffff, 0x98cc, 0x98cd, 0x98ce, 0x98cf,   // U+fe68 ~ U+fe6f
0x98d0, 0x98d1, 0x98d2, 0x98d3, 0x98d4, 0x98d5, 0x98d6, 0x98d7,   // U+fe70 ~ U+fe77
0x98d8, 0x98d9, 0x98da, 0x98db, 0x98dc, 0x98dd, 0x98de, 0x98df,   // U+fe78 ~ U+fe7f
0x98e0, 0x98e1, 0x98e2, 0x98e3, 0x98e4, 0x98e5, 0x98e6, 0x98e7,   // U+fe80 ~ U+fe87
0x98e8, 0x98e9, 0x98ea, 0x98eb, 0x98ec, 0x98ed, 0x98ee, 0x98ef,   // U+fe88 ~ U+fe8f
0x98f0, 0x98f1, 0x98f2, 0x98f3, 0x98f4, 0x98f5, 0x98f6, 0x98f7,   // U+fe90 ~ U+fe97
0x98f8, 0x98f9, 0x98fa, 0x98fb, 0x98fc, 0x98fd, 0x98fe, 0x98ff,   // U+fe98 ~ U+fe9f
0x9900, 0x9901, 0x9902, 0x9903, 0x9904, 0x9905, 0x9906, 0x9907,   // U+fea0 ~ U+fea7
0x9908, 0x9909, 0x990a, 0x990b, 0x990c, 0x990d, 0x990e, 0x990f,   // U+fea8 ~ U+feaf
0x9910, 0x9911, 0x9912, 0x9913, 0x9914, 0x9915, 0x9916, 0x9917,   // U+feb0 ~ U+feb7
0x9918, 0x9919, 0x991a, 0x991b, 0x991c, 0x991d, 0x991e, 0x991f,   // U+feb8 ~ U+febf
0x9920, 0x9921, 0x9922, 0x9923, 0x9924, 0x9925, 0x9926, 0x9927,   // U+fec0 ~ U+fec7
0x9928, 0x9929, 0x992a, 0x992b, 0x992c, 0x992d, 0x992e, 0x992f,   // U+fec8 ~ U+fecf
0x9930, 0x9931, 0x9932, 0x9933, 0x9934, 0x9935, 0x9936, 0x9937,   // U+fed0 ~ U+fed7
0x9938, 0x9939, 0x993a, 0x993b, 0x993c, 0x993d, 0x993e, 0x993f,   // U+fed8 ~ U+fedf
0x9940, 0x9941, 0x9942, 0x9943, 0x9944, 0x9945, 0x9946, 0x9947,   // U+fee0 ~ U+fee7
0x9948, 0x9949, 0x994a, 0x994b, 0x994c, 0x994d, 0x994e, 0x994f,   // U+fee8 ~ U+feef
0x9950, 0x9951, 0x9952, 0x9953, 0x9954, 0x9955, 0x9956, 0x9957,   // U+fef0 ~ U+fef7
0x9958, 0x9959, 0x995a, 0x995b, 0x995c, 0x995d, 0x995e, 0x995f,   // U+fef8 ~ U+feff
0x9960, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+ff00 ~ U+ff07
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+ff08 ~ U+ff0f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+ff10 ~ U+ff17
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+ff18 ~ U+ff1f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+ff20 ~ U+ff27
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+ff28 ~ U+ff2f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+ff30 ~ U+ff37
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+ff38 ~ U+ff3f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+ff40 ~ U+ff47
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+ff48 ~ U+ff4f
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,   // U+ff50 ~ U+ff57
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x9961,   // U+ff58 ~ U+ff5f
0x9962, 0x9963, 0x9964, 0x9965, 0x9966, 0x9967, 0x9968, 0x9969,   // U+ff60 ~ U+ff67
0x996a, 0x996b, 0x996c, 0x996d, 0x996e, 0x996f, 0x9970, 0x9971,   // U+ff68 ~ U+ff6f
0x9972, 0x9973, 0x9974, 0x9975, 0x9976, 0x9977, 0x9978, 0x9979,   // U+ff70 ~ U+ff77
0x997a, 0x997b, 0x997c, 0x997d, 0x997e, 0x997f, 0x9980, 0x9981,   // U+ff78 ~ U+ff7f
0x9982, 0x9983, 0x9984, 0x9985, 0x9986, 0x9987, 0x9988, 0x9989,   // U+ff80 ~ U+ff87
0x998a, 0x998b, 0x998c, 0x998d, 0x998e, 0x998f, 0x9990, 0x9991,   // U+ff88 ~ U+ff8f
0x9992, 0x9993, 0x9994, 0x9995, 0x9996, 0x9997, 0x9998, 0x9999,   // U+ff90 ~ U+ff97
0x999a, 0x999b, 0x999c, 0x999d, 0x999e, 0x999f, 0x99a0, 0x99a1,   // U+ff98 ~ U+ff9f
0x99a2, 0x99a3, 0x99a4, 0x99a5, 0x99a6, 0x99a7, 0x99a8, 0x99a9,   // U+ffa0 ~ U+ffa7
0x99aa, 0x99ab, 0x99ac, 0x99ad, 0x99ae, 0x99af, 0x99b0, 0x99b1,   // U+ffa8 ~ U+ffaf
0x99b2, 0x99b3, 0x99b4, 0x99b5, 0x99b6, 0x99b7, 0x99b8, 0x99b9,   // U+ffb0 ~ U+ffb7
0x99ba, 0x99bb, 0x99bc, 0x99bd, 0x99be, 0x99bf, 0x99c0, 0x99c1,   // U+ffb8 ~ U+ffbf
0x99c2, 0x99c3, 0x99c4, 0x99c5, 0x99c6, 0x99c7, 0x99c8, 0x99c9,   // U+ffc0 ~ U+ffc7
0x99ca, 0x99cb, 0x99cc, 0x99cd, 0x99ce, 0x99cf, 0x99d0, 0x99d1,   // U+ffc8 ~ U+ffcf
0x99d2, 0x99d3, 0x99d4, 0x99d5, 0x99d6, 0x99d7, 0x99d8, 0x99d9,   // U+ffd0 ~ U+ffd7
0x99da, 0x99db, 0x99dc, 0x99dd, 0x99de, 0x99df, 0x99e0, 0x99e1,   // U+ffd8 ~ U+ffdf
0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0x99e2, 0x99e3,   // U+ffe0 ~ U+ffe7
0x99e4, 0x99e5, 0x99e6, 0x99e7, 0x99e8, 0x99e9, 0x99ea, 0x99eb,   // U+ffe8 ~ U+ffef
0x99ec, 0x99ed, 0x99ee, 0x99ef, 0x99f0, 0x99f1, 0x99f2, 0x99f3,   // U+fff0 ~ U+fff7
0x99f4, 0x99f5, 0x99f6, 0x99f7, 0x99f8, 0x99f9, 0x99fa, 0x99fb,   // U+fff8 ~ U+ffff


};


const WORD g_wGBFourBytesToUnicode[] = {

0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,  // Offset: 0000 ~ 0007
0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,  // Offset: 0008 ~ 000f
0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,  // Offset: 0010 ~ 0017
0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,  // Offset: 0018 ~ 001f
0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x00a5, 0x00a6, 0x00a9, 0x00aa,  // Offset: 0020 ~ 0027
0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af, 0x00b2, 0x00b3, 0x00b4,  // Offset: 0028 ~ 002f
0x00b5, 0x00b6, 0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc, 0x00bd,  // Offset: 0030 ~ 0037
0x00be, 0x00bf, 0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5,  // Offset: 0038 ~ 003f
0x00c6, 0x00c7, 0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd,  // Offset: 0040 ~ 0047
0x00ce, 0x00cf, 0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5,  // Offset: 0048 ~ 004f
0x00d6, 0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de,  // Offset: 0050 ~ 0057
0x00df, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7, 0x00eb,  // Offset: 0058 ~ 005f
0x00ee, 0x00ef, 0x00f0, 0x00f1, 0x00f4, 0x00f5, 0x00f6, 0x00f8,  // Offset: 0060 ~ 0067
0x00fb, 0x00fd, 0x00fe, 0x00ff, 0x0100, 0x0102, 0x0103, 0x0104,  // Offset: 0068 ~ 006f
0x0105, 0x0106, 0x0107, 0x0108, 0x0109, 0x010a, 0x010b, 0x010c,  // Offset: 0070 ~ 0077
0x010d, 0x010e, 0x010f, 0x0110, 0x0111, 0x0112, 0x0114, 0x0115,  // Offset: 0078 ~ 007f
0x0116, 0x0117, 0x0118, 0x0119, 0x011a, 0x011c, 0x011d, 0x011e,  // Offset: 0080 ~ 0087
0x011f, 0x0120, 0x0121, 0x0122, 0x0123, 0x0124, 0x0125, 0x0126,  // Offset: 0088 ~ 008f
0x0127, 0x0128, 0x0129, 0x012a, 0x012c, 0x012d, 0x012e, 0x012f,  // Offset: 0090 ~ 0097
0x0130, 0x0131, 0x0132, 0x0133, 0x0134, 0x0135, 0x0136, 0x0137,  // Offset: 0098 ~ 009f
0x0138, 0x0139, 0x013a, 0x013b, 0x013c, 0x013d, 0x013e, 0x013f,  // Offset: 00a0 ~ 00a7
0x0140, 0x0141, 0x0142, 0x0143, 0x0145, 0x0146, 0x0147, 0x0149,  // Offset: 00a8 ~ 00af
0x014a, 0x014b, 0x014c, 0x014e, 0x014f, 0x0150, 0x0151, 0x0152,  // Offset: 00b0 ~ 00b7
0x0153, 0x0154, 0x0155, 0x0156, 0x0157, 0x0158, 0x0159, 0x015a,  // Offset: 00b8 ~ 00bf
0x015b, 0x015c, 0x015d, 0x015e, 0x015f, 0x0160, 0x0161, 0x0162,  // Offset: 00c0 ~ 00c7
0x0163, 0x0164, 0x0165, 0x0166, 0x0167, 0x0168, 0x0169, 0x016a,  // Offset: 00c8 ~ 00cf
0x016c, 0x016d, 0x016e, 0x016f, 0x0170, 0x0171, 0x0172, 0x0173,  // Offset: 00d0 ~ 00d7
0x0174, 0x0175, 0x0176, 0x0177, 0x0178, 0x0179, 0x017a, 0x017b,  // Offset: 00d8 ~ 00df
0x017c, 0x017d, 0x017e, 0x017f, 0x0180, 0x0181, 0x0182, 0x0183,  // Offset: 00e0 ~ 00e7
0x0184, 0x0185, 0x0186, 0x0187, 0x0188, 0x0189, 0x018a, 0x018b,  // Offset: 00e8 ~ 00ef
0x018c, 0x018d, 0x018e, 0x018f, 0x0190, 0x0191, 0x0192, 0x0193,  // Offset: 00f0 ~ 00f7
0x0194, 0x0195, 0x0196, 0x0197, 0x0198, 0x0199, 0x019a, 0x019b,  // Offset: 00f8 ~ 00ff
0x019c, 0x019d, 0x019e, 0x019f, 0x01a0, 0x01a1, 0x01a2, 0x01a3,  // Offset: 0100 ~ 0107
0x01a4, 0x01a5, 0x01a6, 0x01a7, 0x01a8, 0x01a9, 0x01aa, 0x01ab,  // Offset: 0108 ~ 010f
0x01ac, 0x01ad, 0x01ae, 0x01af, 0x01b0, 0x01b1, 0x01b2, 0x01b3,  // Offset: 0110 ~ 0117
0x01b4, 0x01b5, 0x01b6, 0x01b7, 0x01b8, 0x01b9, 0x01ba, 0x01bb,  // Offset: 0118 ~ 011f
0x01bc, 0x01bd, 0x01be, 0x01bf, 0x01c0, 0x01c1, 0x01c2, 0x01c3,  // Offset: 0120 ~ 0127
0x01c4, 0x01c5, 0x01c6, 0x01c7, 0x01c8, 0x01c9, 0x01ca, 0x01cb,  // Offset: 0128 ~ 012f
0x01cc, 0x01cd, 0x01cf, 0x01d1, 0x01d3, 0x01d5, 0x01d7, 0x01d9,  // Offset: 0130 ~ 0137
0x01db, 0x01dd, 0x01de, 0x01df, 0x01e0, 0x01e1, 0x01e2, 0x01e3,  // Offset: 0138 ~ 013f
0x01e4, 0x01e5, 0x01e6, 0x01e7, 0x01e8, 0x01e9, 0x01ea, 0x01eb,  // Offset: 0140 ~ 0147
0x01ec, 0x01ed, 0x01ee, 0x01ef, 0x01f0, 0x01f1, 0x01f2, 0x01f3,  // Offset: 0148 ~ 014f
0x01f4, 0x01f5, 0x01f6, 0x01f7, 0x01f8, 0x01fa, 0x01fb, 0x01fc,  // Offset: 0150 ~ 0157
0x01fd, 0x01fe, 0x01ff, 0x0200, 0x0201, 0x0202, 0x0203, 0x0204,  // Offset: 0158 ~ 015f
0x0205, 0x0206, 0x0207, 0x0208, 0x0209, 0x020a, 0x020b, 0x020c,  // Offset: 0160 ~ 0167
0x020d, 0x020e, 0x020f, 0x0210, 0x0211, 0x0212, 0x0213, 0x0214,  // Offset: 0168 ~ 016f
0x0215, 0x0216, 0x0217, 0x0218, 0x0219, 0x021a, 0x021b, 0x021c,  // Offset: 0170 ~ 0177
0x021d, 0x021e, 0x021f, 0x0220, 0x0221, 0x0222, 0x0223, 0x0224,  // Offset: 0178 ~ 017f
0x0225, 0x0226, 0x0227, 0x0228, 0x0229, 0x022a, 0x022b, 0x022c,  // Offset: 0180 ~ 0187
0x022d, 0x022e, 0x022f, 0x0230, 0x0231, 0x0232, 0x0233, 0x0234,  // Offset: 0188 ~ 018f
0x0235, 0x0236, 0x0237, 0x0238, 0x0239, 0x023a, 0x023b, 0x023c,  // Offset: 0190 ~ 0197
0x023d, 0x023e, 0x023f, 0x0240, 0x0241, 0x0242, 0x0243, 0x0244,  // Offset: 0198 ~ 019f
0x0245, 0x0246, 0x0247, 0x0248, 0x0249, 0x024a, 0x024b, 0x024c,  // Offset: 01a0 ~ 01a7
0x024d, 0x024e, 0x024f, 0x0250, 0x0252, 0x0253, 0x0254, 0x0255,  // Offset: 01a8 ~ 01af
0x0256, 0x0257, 0x0258, 0x0259, 0x025a, 0x025b, 0x025c, 0x025d,  // Offset: 01b0 ~ 01b7
0x025e, 0x025f, 0x0260, 0x0262, 0x0263, 0x0264, 0x0265, 0x0266,  // Offset: 01b8 ~ 01bf
0x0267, 0x0268, 0x0269, 0x026a, 0x026b, 0x026c, 0x026d, 0x026e,  // Offset: 01c0 ~ 01c7
0x026f, 0x0270, 0x0271, 0x0272, 0x0273, 0x0274, 0x0275, 0x0276,  // Offset: 01c8 ~ 01cf
0x0277, 0x0278, 0x0279, 0x027a, 0x027b, 0x027c, 0x027d, 0x027e,  // Offset: 01d0 ~ 01d7
0x027f, 0x0280, 0x0281, 0x0282, 0x0283, 0x0284, 0x0285, 0x0286,  // Offset: 01d8 ~ 01df
0x0287, 0x0288, 0x0289, 0x028a, 0x028b, 0x028c, 0x028d, 0x028e,  // Offset: 01e0 ~ 01e7
0x028f, 0x0290, 0x0291, 0x0292, 0x0293, 0x0294, 0x0295, 0x0296,  // Offset: 01e8 ~ 01ef
0x0297, 0x0298, 0x0299, 0x029a, 0x029b, 0x029c, 0x029d, 0x029e,  // Offset: 01f0 ~ 01f7
0x029f, 0x02a0, 0x02a1, 0x02a2, 0x02a3, 0x02a4, 0x02a5, 0x02a6,  // Offset: 01f8 ~ 01ff
0x02a7, 0x02a8, 0x02a9, 0x02aa, 0x02ab, 0x02ac, 0x02ad, 0x02ae,  // Offset: 0200 ~ 0207
0x02af, 0x02b0, 0x02b1, 0x02b2, 0x02b3, 0x02b4, 0x02b5, 0x02b6,  // Offset: 0208 ~ 020f
0x02b7, 0x02b8, 0x02b9, 0x02ba, 0x02bb, 0x02bc, 0x02bd, 0x02be,  // Offset: 0210 ~ 0217
0x02bf, 0x02c0, 0x02c1, 0x02c2, 0x02c3, 0x02c4, 0x02c5, 0x02c6,  // Offset: 0218 ~ 021f
0x02c8, 0x02cc, 0x02cd, 0x02ce, 0x02cf, 0x02d0, 0x02d1, 0x02d2,  // Offset: 0220 ~ 0227
0x02d3, 0x02d4, 0x02d5, 0x02d6, 0x02d7, 0x02d8, 0x02da, 0x02db,  // Offset: 0228 ~ 022f
0x02dc, 0x02dd, 0x02de, 0x02df, 0x02e0, 0x02e1, 0x02e2, 0x02e3,  // Offset: 0230 ~ 0237
0x02e4, 0x02e5, 0x02e6, 0x02e7, 0x02e8, 0x02e9, 0x02ea, 0x02eb,  // Offset: 0238 ~ 023f
0x02ec, 0x02ed, 0x02ee, 0x02ef, 0x02f0, 0x02f1, 0x02f2, 0x02f3,  // Offset: 0240 ~ 0247
0x02f4, 0x02f5, 0x02f6, 0x02f7, 0x02f8, 0x02f9, 0x02fa, 0x02fb,  // Offset: 0248 ~ 024f
0x02fc, 0x02fd, 0x02fe, 0x02ff, 0x0300, 0x0301, 0x0302, 0x0303,  // Offset: 0250 ~ 0257
0x0304, 0x0305, 0x0306, 0x0307, 0x0308, 0x0309, 0x030a, 0x030b,  // Offset: 0258 ~ 025f
0x030c, 0x030d, 0x030e, 0x030f, 0x0310, 0x0311, 0x0312, 0x0313,  // Offset: 0260 ~ 0267
0x0314, 0x0315, 0x0316, 0x0317, 0x0318, 0x0319, 0x031a, 0x031b,  // Offset: 0268 ~ 026f
0x031c, 0x031d, 0x031e, 0x031f, 0x0320, 0x0321, 0x0322, 0x0323,  // Offset: 0270 ~ 0277
0x0324, 0x0325, 0x0326, 0x0327, 0x0328, 0x0329, 0x032a, 0x032b,  // Offset: 0278 ~ 027f
0x032c, 0x032d, 0x032e, 0x032f, 0x0330, 0x0331, 0x0332, 0x0333,  // Offset: 0280 ~ 0287
0x0334, 0x0335, 0x0336, 0x0337, 0x0338, 0x0339, 0x033a, 0x033b,  // Offset: 0288 ~ 028f
0x033c, 0x033d, 0x033e, 0x033f, 0x0340, 0x0341, 0x0342, 0x0343,  // Offset: 0290 ~ 0297
0x0344, 0x0345, 0x0346, 0x0347, 0x0348, 0x0349, 0x034a, 0x034b,  // Offset: 0298 ~ 029f
0x034c, 0x034d, 0x034e, 0x034f, 0x0350, 0x0351, 0x0352, 0x0353,  // Offset: 02a0 ~ 02a7
0x0354, 0x0355, 0x0356, 0x0357, 0x0358, 0x0359, 0x035a, 0x035b,  // Offset: 02a8 ~ 02af
0x035c, 0x035d, 0x035e, 0x035f, 0x0360, 0x0361, 0x0362, 0x0363,  // Offset: 02b0 ~ 02b7
0x0364, 0x0365, 0x0366, 0x0367, 0x0368, 0x0369, 0x036a, 0x036b,  // Offset: 02b8 ~ 02bf
0x036c, 0x036d, 0x036e, 0x036f, 0x0370, 0x0371, 0x0372, 0x0373,  // Offset: 02c0 ~ 02c7
0x0374, 0x0375, 0x0376, 0x0377, 0x0378, 0x0379, 0x037a, 0x037b,  // Offset: 02c8 ~ 02cf
0x037c, 0x037d, 0x037e, 0x037f, 0x0380, 0x0381, 0x0382, 0x0383,  // Offset: 02d0 ~ 02d7
0x0384, 0x0385, 0x0386, 0x0387, 0x0388, 0x0389, 0x038a, 0x038b,  // Offset: 02d8 ~ 02df
0x038c, 0x038d, 0x038e, 0x038f, 0x0390, 0x03a2, 0x03aa, 0x03ab,  // Offset: 02e0 ~ 02e7
0x03ac, 0x03ad, 0x03ae, 0x03af, 0x03b0, 0x03c2, 0x03ca, 0x03cb,  // Offset: 02e8 ~ 02ef
0x03cc, 0x03cd, 0x03ce, 0x03cf, 0x03d0, 0x03d1, 0x03d2, 0x03d3,  // Offset: 02f0 ~ 02f7
0x03d4, 0x03d5, 0x03d6, 0x03d7, 0x03d8, 0x03d9, 0x03da, 0x03db,  // Offset: 02f8 ~ 02ff
0x03dc, 0x03dd, 0x03de, 0x03df, 0x03e0, 0x03e1, 0x03e2, 0x03e3,  // Offset: 0300 ~ 0307
0x03e4, 0x03e5, 0x03e6, 0x03e7, 0x03e8, 0x03e9, 0x03ea, 0x03eb,  // Offset: 0308 ~ 030f
0x03ec, 0x03ed, 0x03ee, 0x03ef, 0x03f0, 0x03f1, 0x03f2, 0x03f3,  // Offset: 0310 ~ 0317
0x03f4, 0x03f5, 0x03f6, 0x03f7, 0x03f8, 0x03f9, 0x03fa, 0x03fb,  // Offset: 0318 ~ 031f
0x03fc, 0x03fd, 0x03fe, 0x03ff, 0x0400, 0x0402, 0x0403, 0x0404,  // Offset: 0320 ~ 0327
0x0405, 0x0406, 0x0407, 0x0408, 0x0409, 0x040a, 0x040b, 0x040c,  // Offset: 0328 ~ 032f
0x040d, 0x040e, 0x040f, 0x0450, 0x0452, 0x0453, 0x0454, 0x0455,  // Offset: 0330 ~ 0337
0x0456, 0x0457, 0x0458, 0x0459, 0x045a, 0x045b, 0x045c, 0x045d,  // Offset: 0338 ~ 033f
0x045e, 0x045f, 0x0460, 0x0461, 0x0462, 0x0463, 0x0464, 0x0465,  // Offset: 0340 ~ 0347
0x0466, 0x0467, 0x0468, 0x0469, 0x046a, 0x046b, 0x046c, 0x046d,  // Offset: 0348 ~ 034f
0x046e, 0x046f, 0x0470, 0x0471, 0x0472, 0x0473, 0x0474, 0x0475,  // Offset: 0350 ~ 0357
0x0476, 0x0477, 0x0478, 0x0479, 0x047a, 0x047b, 0x047c, 0x047d,  // Offset: 0358 ~ 035f
0x047e, 0x047f, 0x0480, 0x0481, 0x0482, 0x0483, 0x0484, 0x0485,  // Offset: 0360 ~ 0367
0x0486, 0x0487, 0x0488, 0x0489, 0x048a, 0x048b, 0x048c, 0x048d,  // Offset: 0368 ~ 036f
0x048e, 0x048f, 0x0490, 0x0491, 0x0492, 0x0493, 0x0494, 0x0495,  // Offset: 0370 ~ 0377
0x0496, 0x0497, 0x0498, 0x0499, 0x049a, 0x049b, 0x049c, 0x049d,  // Offset: 0378 ~ 037f
0x049e, 0x049f, 0x04a0, 0x04a1, 0x04a2, 0x04a3, 0x04a4, 0x04a5,  // Offset: 0380 ~ 0387
0x04a6, 0x04a7, 0x04a8, 0x04a9, 0x04aa, 0x04ab, 0x04ac, 0x04ad,  // Offset: 0388 ~ 038f
0x04ae, 0x04af, 0x04b0, 0x04b1, 0x04b2, 0x04b3, 0x04b4, 0x04b5,  // Offset: 0390 ~ 0397
0x04b6, 0x04b7, 0x04b8, 0x04b9, 0x04ba, 0x04bb, 0x04bc, 0x04bd,  // Offset: 0398 ~ 039f
0x04be, 0x04bf, 0x04c0, 0x04c1, 0x04c2, 0x04c3, 0x04c4, 0x04c5,  // Offset: 03a0 ~ 03a7
0x04c6, 0x04c7, 0x04c8, 0x04c9, 0x04ca, 0x04cb, 0x04cc, 0x04cd,  // Offset: 03a8 ~ 03af
0x04ce, 0x04cf, 0x04d0, 0x04d1, 0x04d2, 0x04d3, 0x04d4, 0x04d5,  // Offset: 03b0 ~ 03b7
0x04d6, 0x04d7, 0x04d8, 0x04d9, 0x04da, 0x04db, 0x04dc, 0x04dd,  // Offset: 03b8 ~ 03bf
0x04de, 0x04df, 0x04e0, 0x04e1, 0x04e2, 0x04e3, 0x04e4, 0x04e5,  // Offset: 03c0 ~ 03c7
0x04e6, 0x04e7, 0x04e8, 0x04e9, 0x04ea, 0x04eb, 0x04ec, 0x04ed,  // Offset: 03c8 ~ 03cf
0x04ee, 0x04ef, 0x04f0, 0x04f1, 0x04f2, 0x04f3, 0x04f4, 0x04f5,  // Offset: 03d0 ~ 03d7
0x04f6, 0x04f7, 0x04f8, 0x04f9, 0x04fa, 0x04fb, 0x04fc, 0x04fd,  // Offset: 03d8 ~ 03df
0x04fe, 0x04ff, 0x0500, 0x0501, 0x0502, 0x0503, 0x0504, 0x0505,  // Offset: 03e0 ~ 03e7
0x0506, 0x0507, 0x0508, 0x0509, 0x050a, 0x050b, 0x050c, 0x050d,  // Offset: 03e8 ~ 03ef
0x050e, 0x050f, 0x0510, 0x0511, 0x0512, 0x0513, 0x0514, 0x0515,  // Offset: 03f0 ~ 03f7
0x0516, 0x0517, 0x0518, 0x0519, 0x051a, 0x051b, 0x051c, 0x051d,  // Offset: 03f8 ~ 03ff
0x051e, 0x051f, 0x0520, 0x0521, 0x0522, 0x0523, 0x0524, 0x0525,  // Offset: 0400 ~ 0407
0x0526, 0x0527, 0x0528, 0x0529, 0x052a, 0x052b, 0x052c, 0x052d,  // Offset: 0408 ~ 040f
0x052e, 0x052f, 0x0530, 0x0531, 0x0532, 0x0533, 0x0534, 0x0535,  // Offset: 0410 ~ 0417
0x0536, 0x0537, 0x0538, 0x0539, 0x053a, 0x053b, 0x053c, 0x053d,  // Offset: 0418 ~ 041f
0x053e, 0x053f, 0x0540, 0x0541, 0x0542, 0x0543, 0x0544, 0x0545,  // Offset: 0420 ~ 0427
0x0546, 0x0547, 0x0548, 0x0549, 0x054a, 0x054b, 0x054c, 0x054d,  // Offset: 0428 ~ 042f
0x054e, 0x054f, 0x0550, 0x0551, 0x0552, 0x0553, 0x0554, 0x0555,  // Offset: 0430 ~ 0437
0x0556, 0x0557, 0x0558, 0x0559, 0x055a, 0x055b, 0x055c, 0x055d,  // Offset: 0438 ~ 043f
0x055e, 0x055f, 0x0560, 0x0561, 0x0562, 0x0563, 0x0564, 0x0565,  // Offset: 0440 ~ 0447
0x0566, 0x0567, 0x0568, 0x0569, 0x056a, 0x056b, 0x056c, 0x056d,  // Offset: 0448 ~ 044f
0x056e, 0x056f, 0x0570, 0x0571, 0x0572, 0x0573, 0x0574, 0x0575,  // Offset: 0450 ~ 0457
0x0576, 0x0577, 0x0578, 0x0579, 0x057a, 0x057b, 0x057c, 0x057d,  // Offset: 0458 ~ 045f
0x057e, 0x057f, 0x0580, 0x0581, 0x0582, 0x0583, 0x0584, 0x0585,  // Offset: 0460 ~ 0467
0x0586, 0x0587, 0x0588, 0x0589, 0x058a, 0x058b, 0x058c, 0x058d,  // Offset: 0468 ~ 046f
0x058e, 0x058f, 0x0590, 0x0591, 0x0592, 0x0593, 0x0594, 0x0595,  // Offset: 0470 ~ 0477
0x0596, 0x0597, 0x0598, 0x0599, 0x059a, 0x059b, 0x059c, 0x059d,  // Offset: 0478 ~ 047f
0x059e, 0x059f, 0x05a0, 0x05a1, 0x05a2, 0x05a3, 0x05a4, 0x05a5,  // Offset: 0480 ~ 0487
0x05a6, 0x05a7, 0x05a8, 0x05a9, 0x05aa, 0x05ab, 0x05ac, 0x05ad,  // Offset: 0488 ~ 048f
0x05ae, 0x05af, 0x05b0, 0x05b1, 0x05b2, 0x05b3, 0x05b4, 0x05b5,  // Offset: 0490 ~ 0497
0x05b6, 0x05b7, 0x05b8, 0x05b9, 0x05ba, 0x05bb, 0x05bc, 0x05bd,  // Offset: 0498 ~ 049f
0x05be, 0x05bf, 0x05c0, 0x05c1, 0x05c2, 0x05c3, 0x05c4, 0x05c5,  // Offset: 04a0 ~ 04a7
0x05c6, 0x05c7, 0x05c8, 0x05c9, 0x05ca, 0x05cb, 0x05cc, 0x05cd,  // Offset: 04a8 ~ 04af
0x05ce, 0x05cf, 0x05d0, 0x05d1, 0x05d2, 0x05d3, 0x05d4, 0x05d5,  // Offset: 04b0 ~ 04b7
0x05d6, 0x05d7, 0x05d8, 0x05d9, 0x05da, 0x05db, 0x05dc, 0x05dd,  // Offset: 04b8 ~ 04bf
0x05de, 0x05df, 0x05e0, 0x05e1, 0x05e2, 0x05e3, 0x05e4, 0x05e5,  // Offset: 04c0 ~ 04c7
0x05e6, 0x05e7, 0x05e8, 0x05e9, 0x05ea, 0x05eb, 0x05ec, 0x05ed,  // Offset: 04c8 ~ 04cf
0x05ee, 0x05ef, 0x05f0, 0x05f1, 0x05f2, 0x05f3, 0x05f4, 0x05f5,  // Offset: 04d0 ~ 04d7
0x05f6, 0x05f7, 0x05f8, 0x05f9, 0x05fa, 0x05fb, 0x05fc, 0x05fd,  // Offset: 04d8 ~ 04df
0x05fe, 0x05ff, 0x0600, 0x0601, 0x0602, 0x0603, 0x0604, 0x0605,  // Offset: 04e0 ~ 04e7
0x0606, 0x0607, 0x0608, 0x0609, 0x060a, 0x060b, 0x060c, 0x060d,  // Offset: 04e8 ~ 04ef
0x060e, 0x060f, 0x0610, 0x0611, 0x0612, 0x0613, 0x0614, 0x0615,  // Offset: 04f0 ~ 04f7
0x0616, 0x0617, 0x0618, 0x0619, 0x061a, 0x061b, 0x061c, 0x061d,  // Offset: 04f8 ~ 04ff
0x061e, 0x061f, 0x0620, 0x0621, 0x0622, 0x0623, 0x0624, 0x0625,  // Offset: 0500 ~ 0507
0x0626, 0x0627, 0x0628, 0x0629, 0x062a, 0x062b, 0x062c, 0x062d,  // Offset: 0508 ~ 050f
0x062e, 0x062f, 0x0630, 0x0631, 0x0632, 0x0633, 0x0634, 0x0635,  // Offset: 0510 ~ 0517
0x0636, 0x0637, 0x0638, 0x0639, 0x063a, 0x063b, 0x063c, 0x063d,  // Offset: 0518 ~ 051f
0x063e, 0x063f, 0x0640, 0x0641, 0x0642, 0x0643, 0x0644, 0x0645,  // Offset: 0520 ~ 0527
0x0646, 0x0647, 0x0648, 0x0649, 0x064a, 0x064b, 0x064c, 0x064d,  // Offset: 0528 ~ 052f
0x064e, 0x064f, 0x0650, 0x0651, 0x0652, 0x0653, 0x0654, 0x0655,  // Offset: 0530 ~ 0537
0x0656, 0x0657, 0x0658, 0x0659, 0x065a, 0x065b, 0x065c, 0x065d,  // Offset: 0538 ~ 053f
0x065e, 0x065f, 0x0660, 0x0661, 0x0662, 0x0663, 0x0664, 0x0665,  // Offset: 0540 ~ 0547
0x0666, 0x0667, 0x0668, 0x0669, 0x066a, 0x066b, 0x066c, 0x066d,  // Offset: 0548 ~ 054f
0x066e, 0x066f, 0x0670, 0x0671, 0x0672, 0x0673, 0x0674, 0x0675,  // Offset: 0550 ~ 0557
0x0676, 0x0677, 0x0678, 0x0679, 0x067a, 0x067b, 0x067c, 0x067d,  // Offset: 0558 ~ 055f
0x067e, 0x067f, 0x0680, 0x0681, 0x0682, 0x0683, 0x0684, 0x0685,  // Offset: 0560 ~ 0567
0x0686, 0x0687, 0x0688, 0x0689, 0x068a, 0x068b, 0x068c, 0x068d,  // Offset: 0568 ~ 056f
0x068e, 0x068f, 0x0690, 0x0691, 0x0692, 0x0693, 0x0694, 0x0695,  // Offset: 0570 ~ 0577
0x0696, 0x0697, 0x0698, 0x0699, 0x069a, 0x069b, 0x069c, 0x069d,  // Offset: 0578 ~ 057f
0x069e, 0x069f, 0x06a0, 0x06a1, 0x06a2, 0x06a3, 0x06a4, 0x06a5,  // Offset: 0580 ~ 0587
0x06a6, 0x06a7, 0x06a8, 0x06a9, 0x06aa, 0x06ab, 0x06ac, 0x06ad,  // Offset: 0588 ~ 058f
0x06ae, 0x06af, 0x06b0, 0x06b1, 0x06b2, 0x06b3, 0x06b4, 0x06b5,  // Offset: 0590 ~ 0597
0x06b6, 0x06b7, 0x06b8, 0x06b9, 0x06ba, 0x06bb, 0x06bc, 0x06bd,  // Offset: 0598 ~ 059f
0x06be, 0x06bf, 0x06c0, 0x06c1, 0x06c2, 0x06c3, 0x06c4, 0x06c5,  // Offset: 05a0 ~ 05a7
0x06c6, 0x06c7, 0x06c8, 0x06c9, 0x06ca, 0x06cb, 0x06cc, 0x06cd,  // Offset: 05a8 ~ 05af
0x06ce, 0x06cf, 0x06d0, 0x06d1, 0x06d2, 0x06d3, 0x06d4, 0x06d5,  // Offset: 05b0 ~ 05b7
0x06d6, 0x06d7, 0x06d8, 0x06d9, 0x06da, 0x06db, 0x06dc, 0x06dd,  // Offset: 05b8 ~ 05bf
0x06de, 0x06df, 0x06e0, 0x06e1, 0x06e2, 0x06e3, 0x06e4, 0x06e5,  // Offset: 05c0 ~ 05c7
0x06e6, 0x06e7, 0x06e8, 0x06e9, 0x06ea, 0x06eb, 0x06ec, 0x06ed,  // Offset: 05c8 ~ 05cf
0x06ee, 0x06ef, 0x06f0, 0x06f1, 0x06f2, 0x06f3, 0x06f4, 0x06f5,  // Offset: 05d0 ~ 05d7
0x06f6, 0x06f7, 0x06f8, 0x06f9, 0x06fa, 0x06fb, 0x06fc, 0x06fd,  // Offset: 05d8 ~ 05df
0x06fe, 0x06ff, 0x0700, 0x0701, 0x0702, 0x0703, 0x0704, 0x0705,  // Offset: 05e0 ~ 05e7
0x0706, 0x0707, 0x0708, 0x0709, 0x070a, 0x070b, 0x070c, 0x070d,  // Offset: 05e8 ~ 05ef
0x070e, 0x070f, 0x0710, 0x0711, 0x0712, 0x0713, 0x0714, 0x0715,  // Offset: 05f0 ~ 05f7
0x0716, 0x0717, 0x0718, 0x0719, 0x071a, 0x071b, 0x071c, 0x071d,  // Offset: 05f8 ~ 05ff
0x071e, 0x071f, 0x0720, 0x0721, 0x0722, 0x0723, 0x0724, 0x0725,  // Offset: 0600 ~ 0607
0x0726, 0x0727, 0x0728, 0x0729, 0x072a, 0x072b, 0x072c, 0x072d,  // Offset: 0608 ~ 060f
0x072e, 0x072f, 0x0730, 0x0731, 0x0732, 0x0733, 0x0734, 0x0735,  // Offset: 0610 ~ 0617
0x0736, 0x0737, 0x0738, 0x0739, 0x073a, 0x073b, 0x073c, 0x073d,  // Offset: 0618 ~ 061f
0x073e, 0x073f, 0x0740, 0x0741, 0x0742, 0x0743, 0x0744, 0x0745,  // Offset: 0620 ~ 0627
0x0746, 0x0747, 0x0748, 0x0749, 0x074a, 0x074b, 0x074c, 0x074d,  // Offset: 0628 ~ 062f
0x074e, 0x074f, 0x0750, 0x0751, 0x0752, 0x0753, 0x0754, 0x0755,  // Offset: 0630 ~ 0637
0x0756, 0x0757, 0x0758, 0x0759, 0x075a, 0x075b, 0x075c, 0x075d,  // Offset: 0638 ~ 063f
0x075e, 0x075f, 0x0760, 0x0761, 0x0762, 0x0763, 0x0764, 0x0765,  // Offset: 0640 ~ 0647
0x0766, 0x0767, 0x0768, 0x0769, 0x076a, 0x076b, 0x076c, 0x076d,  // Offset: 0648 ~ 064f
0x076e, 0x076f, 0x0770, 0x0771, 0x0772, 0x0773, 0x0774, 0x0775,  // Offset: 0650 ~ 0657
0x0776, 0x0777, 0x0778, 0x0779, 0x077a, 0x077b, 0x077c, 0x077d,  // Offset: 0658 ~ 065f
0x077e, 0x077f, 0x0780, 0x0781, 0x0782, 0x0783, 0x0784, 0x0785,  // Offset: 0660 ~ 0667
0x0786, 0x0787, 0x0788, 0x0789, 0x078a, 0x078b, 0x078c, 0x078d,  // Offset: 0668 ~ 066f
0x078e, 0x078f, 0x0790, 0x0791, 0x0792, 0x0793, 0x0794, 0x0795,  // Offset: 0670 ~ 0677
0x0796, 0x0797, 0x0798, 0x0799, 0x079a, 0x079b, 0x079c, 0x079d,  // Offset: 0678 ~ 067f
0x079e, 0x079f, 0x07a0, 0x07a1, 0x07a2, 0x07a3, 0x07a4, 0x07a5,  // Offset: 0680 ~ 0687
0x07a6, 0x07a7, 0x07a8, 0x07a9, 0x07aa, 0x07ab, 0x07ac, 0x07ad,  // Offset: 0688 ~ 068f
0x07ae, 0x07af, 0x07b0, 0x07b1, 0x07b2, 0x07b3, 0x07b4, 0x07b5,  // Offset: 0690 ~ 0697
0x07b6, 0x07b7, 0x07b8, 0x07b9, 0x07ba, 0x07bb, 0x07bc, 0x07bd,  // Offset: 0698 ~ 069f
0x07be, 0x07bf, 0x07c0, 0x07c1, 0x07c2, 0x07c3, 0x07c4, 0x07c5,  // Offset: 06a0 ~ 06a7
0x07c6, 0x07c7, 0x07c8, 0x07c9, 0x07ca, 0x07cb, 0x07cc, 0x07cd,  // Offset: 06a8 ~ 06af
0x07ce, 0x07cf, 0x07d0, 0x07d1, 0x07d2, 0x07d3, 0x07d4, 0x07d5,  // Offset: 06b0 ~ 06b7
0x07d6, 0x07d7, 0x07d8, 0x07d9, 0x07da, 0x07db, 0x07dc, 0x07dd,  // Offset: 06b8 ~ 06bf
0x07de, 0x07df, 0x07e0, 0x07e1, 0x07e2, 0x07e3, 0x07e4, 0x07e5,  // Offset: 06c0 ~ 06c7
0x07e6, 0x07e7, 0x07e8, 0x07e9, 0x07ea, 0x07eb, 0x07ec, 0x07ed,  // Offset: 06c8 ~ 06cf
0x07ee, 0x07ef, 0x07f0, 0x07f1, 0x07f2, 0x07f3, 0x07f4, 0x07f5,  // Offset: 06d0 ~ 06d7
0x07f6, 0x07f7, 0x07f8, 0x07f9, 0x07fa, 0x07fb, 0x07fc, 0x07fd,  // Offset: 06d8 ~ 06df
0x07fe, 0x07ff, 0x0800, 0x0801, 0x0802, 0x0803, 0x0804, 0x0805,  // Offset: 06e0 ~ 06e7
0x0806, 0x0807, 0x0808, 0x0809, 0x080a, 0x080b, 0x080c, 0x080d,  // Offset: 06e8 ~ 06ef
0x080e, 0x080f, 0x0810, 0x0811, 0x0812, 0x0813, 0x0814, 0x0815,  // Offset: 06f0 ~ 06f7
0x0816, 0x0817, 0x0818, 0x0819, 0x081a, 0x081b, 0x081c, 0x081d,  // Offset: 06f8 ~ 06ff
0x081e, 0x081f, 0x0820, 0x0821, 0x0822, 0x0823, 0x0824, 0x0825,  // Offset: 0700 ~ 0707
0x0826, 0x0827, 0x0828, 0x0829, 0x082a, 0x082b, 0x082c, 0x082d,  // Offset: 0708 ~ 070f
0x082e, 0x082f, 0x0830, 0x0831, 0x0832, 0x0833, 0x0834, 0x0835,  // Offset: 0710 ~ 0717
0x0836, 0x0837, 0x0838, 0x0839, 0x083a, 0x083b, 0x083c, 0x083d,  // Offset: 0718 ~ 071f
0x083e, 0x083f, 0x0840, 0x0841, 0x0842, 0x0843, 0x0844, 0x0845,  // Offset: 0720 ~ 0727
0x0846, 0x0847, 0x0848, 0x0849, 0x084a, 0x084b, 0x084c, 0x084d,  // Offset: 0728 ~ 072f
0x084e, 0x084f, 0x0850, 0x0851, 0x0852, 0x0853, 0x0854, 0x0855,  // Offset: 0730 ~ 0737
0x0856, 0x0857, 0x0858, 0x0859, 0x085a, 0x085b, 0x085c, 0x085d,  // Offset: 0738 ~ 073f
0x085e, 0x085f, 0x0860, 0x0861, 0x0862, 0x0863, 0x0864, 0x0865,  // Offset: 0740 ~ 0747
0x0866, 0x0867, 0x0868, 0x0869, 0x086a, 0x086b, 0x086c, 0x086d,  // Offset: 0748 ~ 074f
0x086e, 0x086f, 0x0870, 0x0871, 0x0872, 0x0873, 0x0874, 0x0875,  // Offset: 0750 ~ 0757
0x0876, 0x0877, 0x0878, 0x0879, 0x087a, 0x087b, 0x087c, 0x087d,  // Offset: 0758 ~ 075f
0x087e, 0x087f, 0x0880, 0x0881, 0x0882, 0x0883, 0x0884, 0x0885,  // Offset: 0760 ~ 0767
0x0886, 0x0887, 0x0888, 0x0889, 0x088a, 0x088b, 0x088c, 0x088d,  // Offset: 0768 ~ 076f
0x088e, 0x088f, 0x0890, 0x0891, 0x0892, 0x0893, 0x0894, 0x0895,  // Offset: 0770 ~ 0777
0x0896, 0x0897, 0x0898, 0x0899, 0x089a, 0x089b, 0x089c, 0x089d,  // Offset: 0778 ~ 077f
0x089e, 0x089f, 0x08a0, 0x08a1, 0x08a2, 0x08a3, 0x08a4, 0x08a5,  // Offset: 0780 ~ 0787
0x08a6, 0x08a7, 0x08a8, 0x08a9, 0x08aa, 0x08ab, 0x08ac, 0x08ad,  // Offset: 0788 ~ 078f
0x08ae, 0x08af, 0x08b0, 0x08b1, 0x08b2, 0x08b3, 0x08b4, 0x08b5,  // Offset: 0790 ~ 0797
0x08b6, 0x08b7, 0x08b8, 0x08b9, 0x08ba, 0x08bb, 0x08bc, 0x08bd,  // Offset: 0798 ~ 079f
0x08be, 0x08bf, 0x08c0, 0x08c1, 0x08c2, 0x08c3, 0x08c4, 0x08c5,  // Offset: 07a0 ~ 07a7
0x08c6, 0x08c7, 0x08c8, 0x08c9, 0x08ca, 0x08cb, 0x08cc, 0x08cd,  // Offset: 07a8 ~ 07af
0x08ce, 0x08cf, 0x08d0, 0x08d1, 0x08d2, 0x08d3, 0x08d4, 0x08d5,  // Offset: 07b0 ~ 07b7
0x08d6, 0x08d7, 0x08d8, 0x08d9, 0x08da, 0x08db, 0x08dc, 0x08dd,  // Offset: 07b8 ~ 07bf
0x08de, 0x08df, 0x08e0, 0x08e1, 0x08e2, 0x08e3, 0x08e4, 0x08e5,  // Offset: 07c0 ~ 07c7
0x08e6, 0x08e7, 0x08e8, 0x08e9, 0x08ea, 0x08eb, 0x08ec, 0x08ed,  // Offset: 07c8 ~ 07cf
0x08ee, 0x08ef, 0x08f0, 0x08f1, 0x08f2, 0x08f3, 0x08f4, 0x08f5,  // Offset: 07d0 ~ 07d7
0x08f6, 0x08f7, 0x08f8, 0x08f9, 0x08fa, 0x08fb, 0x08fc, 0x08fd,  // Offset: 07d8 ~ 07df
0x08fe, 0x08ff, 0x0900, 0x0901, 0x0902, 0x0903, 0x0904, 0x0905,  // Offset: 07e0 ~ 07e7
0x0906, 0x0907, 0x0908, 0x0909, 0x090a, 0x090b, 0x090c, 0x090d,  // Offset: 07e8 ~ 07ef
0x090e, 0x090f, 0x0910, 0x0911, 0x0912, 0x0913, 0x0914, 0x0915,  // Offset: 07f0 ~ 07f7
0x0916, 0x0917, 0x0918, 0x0919, 0x091a, 0x091b, 0x091c, 0x091d,  // Offset: 07f8 ~ 07ff
0x091e, 0x091f, 0x0920, 0x0921, 0x0922, 0x0923, 0x0924, 0x0925,  // Offset: 0800 ~ 0807
0x0926, 0x0927, 0x0928, 0x0929, 0x092a, 0x092b, 0x092c, 0x092d,  // Offset: 0808 ~ 080f
0x092e, 0x092f, 0x0930, 0x0931, 0x0932, 0x0933, 0x0934, 0x0935,  // Offset: 0810 ~ 0817
0x0936, 0x0937, 0x0938, 0x0939, 0x093a, 0x093b, 0x093c, 0x093d,  // Offset: 0818 ~ 081f
0x093e, 0x093f, 0x0940, 0x0941, 0x0942, 0x0943, 0x0944, 0x0945,  // Offset: 0820 ~ 0827
0x0946, 0x0947, 0x0948, 0x0949, 0x094a, 0x094b, 0x094c, 0x094d,  // Offset: 0828 ~ 082f
0x094e, 0x094f, 0x0950, 0x0951, 0x0952, 0x0953, 0x0954, 0x0955,  // Offset: 0830 ~ 0837
0x0956, 0x0957, 0x0958, 0x0959, 0x095a, 0x095b, 0x095c, 0x095d,  // Offset: 0838 ~ 083f
0x095e, 0x095f, 0x0960, 0x0961, 0x0962, 0x0963, 0x0964, 0x0965,  // Offset: 0840 ~ 0847
0x0966, 0x0967, 0x0968, 0x0969, 0x096a, 0x096b, 0x096c, 0x096d,  // Offset: 0848 ~ 084f
0x096e, 0x096f, 0x0970, 0x0971, 0x0972, 0x0973, 0x0974, 0x0975,  // Offset: 0850 ~ 0857
0x0976, 0x0977, 0x0978, 0x0979, 0x097a, 0x097b, 0x097c, 0x097d,  // Offset: 0858 ~ 085f
0x097e, 0x097f, 0x0980, 0x0981, 0x0982, 0x0983, 0x0984, 0x0985,  // Offset: 0860 ~ 0867
0x0986, 0x0987, 0x0988, 0x0989, 0x098a, 0x098b, 0x098c, 0x098d,  // Offset: 0868 ~ 086f
0x098e, 0x098f, 0x0990, 0x0991, 0x0992, 0x0993, 0x0994, 0x0995,  // Offset: 0870 ~ 0877
0x0996, 0x0997, 0x0998, 0x0999, 0x099a, 0x099b, 0x099c, 0x099d,  // Offset: 0878 ~ 087f
0x099e, 0x099f, 0x09a0, 0x09a1, 0x09a2, 0x09a3, 0x09a4, 0x09a5,  // Offset: 0880 ~ 0887
0x09a6, 0x09a7, 0x09a8, 0x09a9, 0x09aa, 0x09ab, 0x09ac, 0x09ad,  // Offset: 0888 ~ 088f
0x09ae, 0x09af, 0x09b0, 0x09b1, 0x09b2, 0x09b3, 0x09b4, 0x09b5,  // Offset: 0890 ~ 0897
0x09b6, 0x09b7, 0x09b8, 0x09b9, 0x09ba, 0x09bb, 0x09bc, 0x09bd,  // Offset: 0898 ~ 089f
0x09be, 0x09bf, 0x09c0, 0x09c1, 0x09c2, 0x09c3, 0x09c4, 0x09c5,  // Offset: 08a0 ~ 08a7
0x09c6, 0x09c7, 0x09c8, 0x09c9, 0x09ca, 0x09cb, 0x09cc, 0x09cd,  // Offset: 08a8 ~ 08af
0x09ce, 0x09cf, 0x09d0, 0x09d1, 0x09d2, 0x09d3, 0x09d4, 0x09d5,  // Offset: 08b0 ~ 08b7
0x09d6, 0x09d7, 0x09d8, 0x09d9, 0x09da, 0x09db, 0x09dc, 0x09dd,  // Offset: 08b8 ~ 08bf
0x09de, 0x09df, 0x09e0, 0x09e1, 0x09e2, 0x09e3, 0x09e4, 0x09e5,  // Offset: 08c0 ~ 08c7
0x09e6, 0x09e7, 0x09e8, 0x09e9, 0x09ea, 0x09eb, 0x09ec, 0x09ed,  // Offset: 08c8 ~ 08cf
0x09ee, 0x09ef, 0x09f0, 0x09f1, 0x09f2, 0x09f3, 0x09f4, 0x09f5,  // Offset: 08d0 ~ 08d7
0x09f6, 0x09f7, 0x09f8, 0x09f9, 0x09fa, 0x09fb, 0x09fc, 0x09fd,  // Offset: 08d8 ~ 08df
0x09fe, 0x09ff, 0x0a00, 0x0a01, 0x0a02, 0x0a03, 0x0a04, 0x0a05,  // Offset: 08e0 ~ 08e7
0x0a06, 0x0a07, 0x0a08, 0x0a09, 0x0a0a, 0x0a0b, 0x0a0c, 0x0a0d,  // Offset: 08e8 ~ 08ef
0x0a0e, 0x0a0f, 0x0a10, 0x0a11, 0x0a12, 0x0a13, 0x0a14, 0x0a15,  // Offset: 08f0 ~ 08f7
0x0a16, 0x0a17, 0x0a18, 0x0a19, 0x0a1a, 0x0a1b, 0x0a1c, 0x0a1d,  // Offset: 08f8 ~ 08ff
0x0a1e, 0x0a1f, 0x0a20, 0x0a21, 0x0a22, 0x0a23, 0x0a24, 0x0a25,  // Offset: 0900 ~ 0907
0x0a26, 0x0a27, 0x0a28, 0x0a29, 0x0a2a, 0x0a2b, 0x0a2c, 0x0a2d,  // Offset: 0908 ~ 090f
0x0a2e, 0x0a2f, 0x0a30, 0x0a31, 0x0a32, 0x0a33, 0x0a34, 0x0a35,  // Offset: 0910 ~ 0917
0x0a36, 0x0a37, 0x0a38, 0x0a39, 0x0a3a, 0x0a3b, 0x0a3c, 0x0a3d,  // Offset: 0918 ~ 091f
0x0a3e, 0x0a3f, 0x0a40, 0x0a41, 0x0a42, 0x0a43, 0x0a44, 0x0a45,  // Offset: 0920 ~ 0927
0x0a46, 0x0a47, 0x0a48, 0x0a49, 0x0a4a, 0x0a4b, 0x0a4c, 0x0a4d,  // Offset: 0928 ~ 092f
0x0a4e, 0x0a4f, 0x0a50, 0x0a51, 0x0a52, 0x0a53, 0x0a54, 0x0a55,  // Offset: 0930 ~ 0937
0x0a56, 0x0a57, 0x0a58, 0x0a59, 0x0a5a, 0x0a5b, 0x0a5c, 0x0a5d,  // Offset: 0938 ~ 093f
0x0a5e, 0x0a5f, 0x0a60, 0x0a61, 0x0a62, 0x0a63, 0x0a64, 0x0a65,  // Offset: 0940 ~ 0947
0x0a66, 0x0a67, 0x0a68, 0x0a69, 0x0a6a, 0x0a6b, 0x0a6c, 0x0a6d,  // Offset: 0948 ~ 094f
0x0a6e, 0x0a6f, 0x0a70, 0x0a71, 0x0a72, 0x0a73, 0x0a74, 0x0a75,  // Offset: 0950 ~ 0957
0x0a76, 0x0a77, 0x0a78, 0x0a79, 0x0a7a, 0x0a7b, 0x0a7c, 0x0a7d,  // Offset: 0958 ~ 095f
0x0a7e, 0x0a7f, 0x0a80, 0x0a81, 0x0a82, 0x0a83, 0x0a84, 0x0a85,  // Offset: 0960 ~ 0967
0x0a86, 0x0a87, 0x0a88, 0x0a89, 0x0a8a, 0x0a8b, 0x0a8c, 0x0a8d,  // Offset: 0968 ~ 096f
0x0a8e, 0x0a8f, 0x0a90, 0x0a91, 0x0a92, 0x0a93, 0x0a94, 0x0a95,  // Offset: 0970 ~ 0977
0x0a96, 0x0a97, 0x0a98, 0x0a99, 0x0a9a, 0x0a9b, 0x0a9c, 0x0a9d,  // Offset: 0978 ~ 097f
0x0a9e, 0x0a9f, 0x0aa0, 0x0aa1, 0x0aa2, 0x0aa3, 0x0aa4, 0x0aa5,  // Offset: 0980 ~ 0987
0x0aa6, 0x0aa7, 0x0aa8, 0x0aa9, 0x0aaa, 0x0aab, 0x0aac, 0x0aad,  // Offset: 0988 ~ 098f
0x0aae, 0x0aaf, 0x0ab0, 0x0ab1, 0x0ab2, 0x0ab3, 0x0ab4, 0x0ab5,  // Offset: 0990 ~ 0997
0x0ab6, 0x0ab7, 0x0ab8, 0x0ab9, 0x0aba, 0x0abb, 0x0abc, 0x0abd,  // Offset: 0998 ~ 099f
0x0abe, 0x0abf, 0x0ac0, 0x0ac1, 0x0ac2, 0x0ac3, 0x0ac4, 0x0ac5,  // Offset: 09a0 ~ 09a7
0x0ac6, 0x0ac7, 0x0ac8, 0x0ac9, 0x0aca, 0x0acb, 0x0acc, 0x0acd,  // Offset: 09a8 ~ 09af
0x0ace, 0x0acf, 0x0ad0, 0x0ad1, 0x0ad2, 0x0ad3, 0x0ad4, 0x0ad5,  // Offset: 09b0 ~ 09b7
0x0ad6, 0x0ad7, 0x0ad8, 0x0ad9, 0x0ada, 0x0adb, 0x0adc, 0x0add,  // Offset: 09b8 ~ 09bf
0x0ade, 0x0adf, 0x0ae0, 0x0ae1, 0x0ae2, 0x0ae3, 0x0ae4, 0x0ae5,  // Offset: 09c0 ~ 09c7
0x0ae6, 0x0ae7, 0x0ae8, 0x0ae9, 0x0aea, 0x0aeb, 0x0aec, 0x0aed,  // Offset: 09c8 ~ 09cf
0x0aee, 0x0aef, 0x0af0, 0x0af1, 0x0af2, 0x0af3, 0x0af4, 0x0af5,  // Offset: 09d0 ~ 09d7
0x0af6, 0x0af7, 0x0af8, 0x0af9, 0x0afa, 0x0afb, 0x0afc, 0x0afd,  // Offset: 09d8 ~ 09df
0x0afe, 0x0aff, 0x0b00, 0x0b01, 0x0b02, 0x0b03, 0x0b04, 0x0b05,  // Offset: 09e0 ~ 09e7
0x0b06, 0x0b07, 0x0b08, 0x0b09, 0x0b0a, 0x0b0b, 0x0b0c, 0x0b0d,  // Offset: 09e8 ~ 09ef
0x0b0e, 0x0b0f, 0x0b10, 0x0b11, 0x0b12, 0x0b13, 0x0b14, 0x0b15,  // Offset: 09f0 ~ 09f7
0x0b16, 0x0b17, 0x0b18, 0x0b19, 0x0b1a, 0x0b1b, 0x0b1c, 0x0b1d,  // Offset: 09f8 ~ 09ff
0x0b1e, 0x0b1f, 0x0b20, 0x0b21, 0x0b22, 0x0b23, 0x0b24, 0x0b25,  // Offset: 0a00 ~ 0a07
0x0b26, 0x0b27, 0x0b28, 0x0b29, 0x0b2a, 0x0b2b, 0x0b2c, 0x0b2d,  // Offset: 0a08 ~ 0a0f
0x0b2e, 0x0b2f, 0x0b30, 0x0b31, 0x0b32, 0x0b33, 0x0b34, 0x0b35,  // Offset: 0a10 ~ 0a17
0x0b36, 0x0b37, 0x0b38, 0x0b39, 0x0b3a, 0x0b3b, 0x0b3c, 0x0b3d,  // Offset: 0a18 ~ 0a1f
0x0b3e, 0x0b3f, 0x0b40, 0x0b41, 0x0b42, 0x0b43, 0x0b44, 0x0b45,  // Offset: 0a20 ~ 0a27
0x0b46, 0x0b47, 0x0b48, 0x0b49, 0x0b4a, 0x0b4b, 0x0b4c, 0x0b4d,  // Offset: 0a28 ~ 0a2f
0x0b4e, 0x0b4f, 0x0b50, 0x0b51, 0x0b52, 0x0b53, 0x0b54, 0x0b55,  // Offset: 0a30 ~ 0a37
0x0b56, 0x0b57, 0x0b58, 0x0b59, 0x0b5a, 0x0b5b, 0x0b5c, 0x0b5d,  // Offset: 0a38 ~ 0a3f
0x0b5e, 0x0b5f, 0x0b60, 0x0b61, 0x0b62, 0x0b63, 0x0b64, 0x0b65,  // Offset: 0a40 ~ 0a47
0x0b66, 0x0b67, 0x0b68, 0x0b69, 0x0b6a, 0x0b6b, 0x0b6c, 0x0b6d,  // Offset: 0a48 ~ 0a4f
0x0b6e, 0x0b6f, 0x0b70, 0x0b71, 0x0b72, 0x0b73, 0x0b74, 0x0b75,  // Offset: 0a50 ~ 0a57
0x0b76, 0x0b77, 0x0b78, 0x0b79, 0x0b7a, 0x0b7b, 0x0b7c, 0x0b7d,  // Offset: 0a58 ~ 0a5f
0x0b7e, 0x0b7f, 0x0b80, 0x0b81, 0x0b82, 0x0b83, 0x0b84, 0x0b85,  // Offset: 0a60 ~ 0a67
0x0b86, 0x0b87, 0x0b88, 0x0b89, 0x0b8a, 0x0b8b, 0x0b8c, 0x0b8d,  // Offset: 0a68 ~ 0a6f
0x0b8e, 0x0b8f, 0x0b90, 0x0b91, 0x0b92, 0x0b93, 0x0b94, 0x0b95,  // Offset: 0a70 ~ 0a77
0x0b96, 0x0b97, 0x0b98, 0x0b99, 0x0b9a, 0x0b9b, 0x0b9c, 0x0b9d,  // Offset: 0a78 ~ 0a7f
0x0b9e, 0x0b9f, 0x0ba0, 0x0ba1, 0x0ba2, 0x0ba3, 0x0ba4, 0x0ba5,  // Offset: 0a80 ~ 0a87
0x0ba6, 0x0ba7, 0x0ba8, 0x0ba9, 0x0baa, 0x0bab, 0x0bac, 0x0bad,  // Offset: 0a88 ~ 0a8f
0x0bae, 0x0baf, 0x0bb0, 0x0bb1, 0x0bb2, 0x0bb3, 0x0bb4, 0x0bb5,  // Offset: 0a90 ~ 0a97
0x0bb6, 0x0bb7, 0x0bb8, 0x0bb9, 0x0bba, 0x0bbb, 0x0bbc, 0x0bbd,  // Offset: 0a98 ~ 0a9f
0x0bbe, 0x0bbf, 0x0bc0, 0x0bc1, 0x0bc2, 0x0bc3, 0x0bc4, 0x0bc5,  // Offset: 0aa0 ~ 0aa7
0x0bc6, 0x0bc7, 0x0bc8, 0x0bc9, 0x0bca, 0x0bcb, 0x0bcc, 0x0bcd,  // Offset: 0aa8 ~ 0aaf
0x0bce, 0x0bcf, 0x0bd0, 0x0bd1, 0x0bd2, 0x0bd3, 0x0bd4, 0x0bd5,  // Offset: 0ab0 ~ 0ab7
0x0bd6, 0x0bd7, 0x0bd8, 0x0bd9, 0x0bda, 0x0bdb, 0x0bdc, 0x0bdd,  // Offset: 0ab8 ~ 0abf
0x0bde, 0x0bdf, 0x0be0, 0x0be1, 0x0be2, 0x0be3, 0x0be4, 0x0be5,  // Offset: 0ac0 ~ 0ac7
0x0be6, 0x0be7, 0x0be8, 0x0be9, 0x0bea, 0x0beb, 0x0bec, 0x0bed,  // Offset: 0ac8 ~ 0acf
0x0bee, 0x0bef, 0x0bf0, 0x0bf1, 0x0bf2, 0x0bf3, 0x0bf4, 0x0bf5,  // Offset: 0ad0 ~ 0ad7
0x0bf6, 0x0bf7, 0x0bf8, 0x0bf9, 0x0bfa, 0x0bfb, 0x0bfc, 0x0bfd,  // Offset: 0ad8 ~ 0adf
0x0bfe, 0x0bff, 0x0c00, 0x0c01, 0x0c02, 0x0c03, 0x0c04, 0x0c05,  // Offset: 0ae0 ~ 0ae7
0x0c06, 0x0c07, 0x0c08, 0x0c09, 0x0c0a, 0x0c0b, 0x0c0c, 0x0c0d,  // Offset: 0ae8 ~ 0aef
0x0c0e, 0x0c0f, 0x0c10, 0x0c11, 0x0c12, 0x0c13, 0x0c14, 0x0c15,  // Offset: 0af0 ~ 0af7
0x0c16, 0x0c17, 0x0c18, 0x0c19, 0x0c1a, 0x0c1b, 0x0c1c, 0x0c1d,  // Offset: 0af8 ~ 0aff
0x0c1e, 0x0c1f, 0x0c20, 0x0c21, 0x0c22, 0x0c23, 0x0c24, 0x0c25,  // Offset: 0b00 ~ 0b07
0x0c26, 0x0c27, 0x0c28, 0x0c29, 0x0c2a, 0x0c2b, 0x0c2c, 0x0c2d,  // Offset: 0b08 ~ 0b0f
0x0c2e, 0x0c2f, 0x0c30, 0x0c31, 0x0c32, 0x0c33, 0x0c34, 0x0c35,  // Offset: 0b10 ~ 0b17
0x0c36, 0x0c37, 0x0c38, 0x0c39, 0x0c3a, 0x0c3b, 0x0c3c, 0x0c3d,  // Offset: 0b18 ~ 0b1f
0x0c3e, 0x0c3f, 0x0c40, 0x0c41, 0x0c42, 0x0c43, 0x0c44, 0x0c45,  // Offset: 0b20 ~ 0b27
0x0c46, 0x0c47, 0x0c48, 0x0c49, 0x0c4a, 0x0c4b, 0x0c4c, 0x0c4d,  // Offset: 0b28 ~ 0b2f
0x0c4e, 0x0c4f, 0x0c50, 0x0c51, 0x0c52, 0x0c53, 0x0c54, 0x0c55,  // Offset: 0b30 ~ 0b37
0x0c56, 0x0c57, 0x0c58, 0x0c59, 0x0c5a, 0x0c5b, 0x0c5c, 0x0c5d,  // Offset: 0b38 ~ 0b3f
0x0c5e, 0x0c5f, 0x0c60, 0x0c61, 0x0c62, 0x0c63, 0x0c64, 0x0c65,  // Offset: 0b40 ~ 0b47
0x0c66, 0x0c67, 0x0c68, 0x0c69, 0x0c6a, 0x0c6b, 0x0c6c, 0x0c6d,  // Offset: 0b48 ~ 0b4f
0x0c6e, 0x0c6f, 0x0c70, 0x0c71, 0x0c72, 0x0c73, 0x0c74, 0x0c75,  // Offset: 0b50 ~ 0b57
0x0c76, 0x0c77, 0x0c78, 0x0c79, 0x0c7a, 0x0c7b, 0x0c7c, 0x0c7d,  // Offset: 0b58 ~ 0b5f
0x0c7e, 0x0c7f, 0x0c80, 0x0c81, 0x0c82, 0x0c83, 0x0c84, 0x0c85,  // Offset: 0b60 ~ 0b67
0x0c86, 0x0c87, 0x0c88, 0x0c89, 0x0c8a, 0x0c8b, 0x0c8c, 0x0c8d,  // Offset: 0b68 ~ 0b6f
0x0c8e, 0x0c8f, 0x0c90, 0x0c91, 0x0c92, 0x0c93, 0x0c94, 0x0c95,  // Offset: 0b70 ~ 0b77
0x0c96, 0x0c97, 0x0c98, 0x0c99, 0x0c9a, 0x0c9b, 0x0c9c, 0x0c9d,  // Offset: 0b78 ~ 0b7f
0x0c9e, 0x0c9f, 0x0ca0, 0x0ca1, 0x0ca2, 0x0ca3, 0x0ca4, 0x0ca5,  // Offset: 0b80 ~ 0b87
0x0ca6, 0x0ca7, 0x0ca8, 0x0ca9, 0x0caa, 0x0cab, 0x0cac, 0x0cad,  // Offset: 0b88 ~ 0b8f
0x0cae, 0x0caf, 0x0cb0, 0x0cb1, 0x0cb2, 0x0cb3, 0x0cb4, 0x0cb5,  // Offset: 0b90 ~ 0b97
0x0cb6, 0x0cb7, 0x0cb8, 0x0cb9, 0x0cba, 0x0cbb, 0x0cbc, 0x0cbd,  // Offset: 0b98 ~ 0b9f
0x0cbe, 0x0cbf, 0x0cc0, 0x0cc1, 0x0cc2, 0x0cc3, 0x0cc4, 0x0cc5,  // Offset: 0ba0 ~ 0ba7
0x0cc6, 0x0cc7, 0x0cc8, 0x0cc9, 0x0cca, 0x0ccb, 0x0ccc, 0x0ccd,  // Offset: 0ba8 ~ 0baf
0x0cce, 0x0ccf, 0x0cd0, 0x0cd1, 0x0cd2, 0x0cd3, 0x0cd4, 0x0cd5,  // Offset: 0bb0 ~ 0bb7
0x0cd6, 0x0cd7, 0x0cd8, 0x0cd9, 0x0cda, 0x0cdb, 0x0cdc, 0x0cdd,  // Offset: 0bb8 ~ 0bbf
0x0cde, 0x0cdf, 0x0ce0, 0x0ce1, 0x0ce2, 0x0ce3, 0x0ce4, 0x0ce5,  // Offset: 0bc0 ~ 0bc7
0x0ce6, 0x0ce7, 0x0ce8, 0x0ce9, 0x0cea, 0x0ceb, 0x0cec, 0x0ced,  // Offset: 0bc8 ~ 0bcf
0x0cee, 0x0cef, 0x0cf0, 0x0cf1, 0x0cf2, 0x0cf3, 0x0cf4, 0x0cf5,  // Offset: 0bd0 ~ 0bd7
0x0cf6, 0x0cf7, 0x0cf8, 0x0cf9, 0x0cfa, 0x0cfb, 0x0cfc, 0x0cfd,  // Offset: 0bd8 ~ 0bdf
0x0cfe, 0x0cff, 0x0d00, 0x0d01, 0x0d02, 0x0d03, 0x0d04, 0x0d05,  // Offset: 0be0 ~ 0be7
0x0d06, 0x0d07, 0x0d08, 0x0d09, 0x0d0a, 0x0d0b, 0x0d0c, 0x0d0d,  // Offset: 0be8 ~ 0bef
0x0d0e, 0x0d0f, 0x0d10, 0x0d11, 0x0d12, 0x0d13, 0x0d14, 0x0d15,  // Offset: 0bf0 ~ 0bf7
0x0d16, 0x0d17, 0x0d18, 0x0d19, 0x0d1a, 0x0d1b, 0x0d1c, 0x0d1d,  // Offset: 0bf8 ~ 0bff
0x0d1e, 0x0d1f, 0x0d20, 0x0d21, 0x0d22, 0x0d23, 0x0d24, 0x0d25,  // Offset: 0c00 ~ 0c07
0x0d26, 0x0d27, 0x0d28, 0x0d29, 0x0d2a, 0x0d2b, 0x0d2c, 0x0d2d,  // Offset: 0c08 ~ 0c0f
0x0d2e, 0x0d2f, 0x0d30, 0x0d31, 0x0d32, 0x0d33, 0x0d34, 0x0d35,  // Offset: 0c10 ~ 0c17
0x0d36, 0x0d37, 0x0d38, 0x0d39, 0x0d3a, 0x0d3b, 0x0d3c, 0x0d3d,  // Offset: 0c18 ~ 0c1f
0x0d3e, 0x0d3f, 0x0d40, 0x0d41, 0x0d42, 0x0d43, 0x0d44, 0x0d45,  // Offset: 0c20 ~ 0c27
0x0d46, 0x0d47, 0x0d48, 0x0d49, 0x0d4a, 0x0d4b, 0x0d4c, 0x0d4d,  // Offset: 0c28 ~ 0c2f
0x0d4e, 0x0d4f, 0x0d50, 0x0d51, 0x0d52, 0x0d53, 0x0d54, 0x0d55,  // Offset: 0c30 ~ 0c37
0x0d56, 0x0d57, 0x0d58, 0x0d59, 0x0d5a, 0x0d5b, 0x0d5c, 0x0d5d,  // Offset: 0c38 ~ 0c3f
0x0d5e, 0x0d5f, 0x0d60, 0x0d61, 0x0d62, 0x0d63, 0x0d64, 0x0d65,  // Offset: 0c40 ~ 0c47
0x0d66, 0x0d67, 0x0d68, 0x0d69, 0x0d6a, 0x0d6b, 0x0d6c, 0x0d6d,  // Offset: 0c48 ~ 0c4f
0x0d6e, 0x0d6f, 0x0d70, 0x0d71, 0x0d72, 0x0d73, 0x0d74, 0x0d75,  // Offset: 0c50 ~ 0c57
0x0d76, 0x0d77, 0x0d78, 0x0d79, 0x0d7a, 0x0d7b, 0x0d7c, 0x0d7d,  // Offset: 0c58 ~ 0c5f
0x0d7e, 0x0d7f, 0x0d80, 0x0d81, 0x0d82, 0x0d83, 0x0d84, 0x0d85,  // Offset: 0c60 ~ 0c67
0x0d86, 0x0d87, 0x0d88, 0x0d89, 0x0d8a, 0x0d8b, 0x0d8c, 0x0d8d,  // Offset: 0c68 ~ 0c6f
0x0d8e, 0x0d8f, 0x0d90, 0x0d91, 0x0d92, 0x0d93, 0x0d94, 0x0d95,  // Offset: 0c70 ~ 0c77
0x0d96, 0x0d97, 0x0d98, 0x0d99, 0x0d9a, 0x0d9b, 0x0d9c, 0x0d9d,  // Offset: 0c78 ~ 0c7f
0x0d9e, 0x0d9f, 0x0da0, 0x0da1, 0x0da2, 0x0da3, 0x0da4, 0x0da5,  // Offset: 0c80 ~ 0c87
0x0da6, 0x0da7, 0x0da8, 0x0da9, 0x0daa, 0x0dab, 0x0dac, 0x0dad,  // Offset: 0c88 ~ 0c8f
0x0dae, 0x0daf, 0x0db0, 0x0db1, 0x0db2, 0x0db3, 0x0db4, 0x0db5,  // Offset: 0c90 ~ 0c97
0x0db6, 0x0db7, 0x0db8, 0x0db9, 0x0dba, 0x0dbb, 0x0dbc, 0x0dbd,  // Offset: 0c98 ~ 0c9f
0x0dbe, 0x0dbf, 0x0dc0, 0x0dc1, 0x0dc2, 0x0dc3, 0x0dc4, 0x0dc5,  // Offset: 0ca0 ~ 0ca7
0x0dc6, 0x0dc7, 0x0dc8, 0x0dc9, 0x0dca, 0x0dcb, 0x0dcc, 0x0dcd,  // Offset: 0ca8 ~ 0caf
0x0dce, 0x0dcf, 0x0dd0, 0x0dd1, 0x0dd2, 0x0dd3, 0x0dd4, 0x0dd5,  // Offset: 0cb0 ~ 0cb7
0x0dd6, 0x0dd7, 0x0dd8, 0x0dd9, 0x0dda, 0x0ddb, 0x0ddc, 0x0ddd,  // Offset: 0cb8 ~ 0cbf
0x0dde, 0x0ddf, 0x0de0, 0x0de1, 0x0de2, 0x0de3, 0x0de4, 0x0de5,  // Offset: 0cc0 ~ 0cc7
0x0de6, 0x0de7, 0x0de8, 0x0de9, 0x0dea, 0x0deb, 0x0dec, 0x0ded,  // Offset: 0cc8 ~ 0ccf
0x0dee, 0x0def, 0x0df0, 0x0df1, 0x0df2, 0x0df3, 0x0df4, 0x0df5,  // Offset: 0cd0 ~ 0cd7
0x0df6, 0x0df7, 0x0df8, 0x0df9, 0x0dfa, 0x0dfb, 0x0dfc, 0x0dfd,  // Offset: 0cd8 ~ 0cdf
0x0dfe, 0x0dff, 0x0e00, 0x0e01, 0x0e02, 0x0e03, 0x0e04, 0x0e05,  // Offset: 0ce0 ~ 0ce7
0x0e06, 0x0e07, 0x0e08, 0x0e09, 0x0e0a, 0x0e0b, 0x0e0c, 0x0e0d,  // Offset: 0ce8 ~ 0cef
0x0e0e, 0x0e0f, 0x0e10, 0x0e11, 0x0e12, 0x0e13, 0x0e14, 0x0e15,  // Offset: 0cf0 ~ 0cf7
0x0e16, 0x0e17, 0x0e18, 0x0e19, 0x0e1a, 0x0e1b, 0x0e1c, 0x0e1d,  // Offset: 0cf8 ~ 0cff
0x0e1e, 0x0e1f, 0x0e20, 0x0e21, 0x0e22, 0x0e23, 0x0e24, 0x0e25,  // Offset: 0d00 ~ 0d07
0x0e26, 0x0e27, 0x0e28, 0x0e29, 0x0e2a, 0x0e2b, 0x0e2c, 0x0e2d,  // Offset: 0d08 ~ 0d0f
0x0e2e, 0x0e2f, 0x0e30, 0x0e31, 0x0e32, 0x0e33, 0x0e34, 0x0e35,  // Offset: 0d10 ~ 0d17
0x0e36, 0x0e37, 0x0e38, 0x0e39, 0x0e3a, 0x0e3b, 0x0e3c, 0x0e3d,  // Offset: 0d18 ~ 0d1f
0x0e3e, 0x0e3f, 0x0e40, 0x0e41, 0x0e42, 0x0e43, 0x0e44, 0x0e45,  // Offset: 0d20 ~ 0d27
0x0e46, 0x0e47, 0x0e48, 0x0e49, 0x0e4a, 0x0e4b, 0x0e4c, 0x0e4d,  // Offset: 0d28 ~ 0d2f
0x0e4e, 0x0e4f, 0x0e50, 0x0e51, 0x0e52, 0x0e53, 0x0e54, 0x0e55,  // Offset: 0d30 ~ 0d37
0x0e56, 0x0e57, 0x0e58, 0x0e59, 0x0e5a, 0x0e5b, 0x0e5c, 0x0e5d,  // Offset: 0d38 ~ 0d3f
0x0e5e, 0x0e5f, 0x0e60, 0x0e61, 0x0e62, 0x0e63, 0x0e64, 0x0e65,  // Offset: 0d40 ~ 0d47
0x0e66, 0x0e67, 0x0e68, 0x0e69, 0x0e6a, 0x0e6b, 0x0e6c, 0x0e6d,  // Offset: 0d48 ~ 0d4f
0x0e6e, 0x0e6f, 0x0e70, 0x0e71, 0x0e72, 0x0e73, 0x0e74, 0x0e75,  // Offset: 0d50 ~ 0d57
0x0e76, 0x0e77, 0x0e78, 0x0e79, 0x0e7a, 0x0e7b, 0x0e7c, 0x0e7d,  // Offset: 0d58 ~ 0d5f
0x0e7e, 0x0e7f, 0x0e80, 0x0e81, 0x0e82, 0x0e83, 0x0e84, 0x0e85,  // Offset: 0d60 ~ 0d67
0x0e86, 0x0e87, 0x0e88, 0x0e89, 0x0e8a, 0x0e8b, 0x0e8c, 0x0e8d,  // Offset: 0d68 ~ 0d6f
0x0e8e, 0x0e8f, 0x0e90, 0x0e91, 0x0e92, 0x0e93, 0x0e94, 0x0e95,  // Offset: 0d70 ~ 0d77
0x0e96, 0x0e97, 0x0e98, 0x0e99, 0x0e9a, 0x0e9b, 0x0e9c, 0x0e9d,  // Offset: 0d78 ~ 0d7f
0x0e9e, 0x0e9f, 0x0ea0, 0x0ea1, 0x0ea2, 0x0ea3, 0x0ea4, 0x0ea5,  // Offset: 0d80 ~ 0d87
0x0ea6, 0x0ea7, 0x0ea8, 0x0ea9, 0x0eaa, 0x0eab, 0x0eac, 0x0ead,  // Offset: 0d88 ~ 0d8f
0x0eae, 0x0eaf, 0x0eb0, 0x0eb1, 0x0eb2, 0x0eb3, 0x0eb4, 0x0eb5,  // Offset: 0d90 ~ 0d97
0x0eb6, 0x0eb7, 0x0eb8, 0x0eb9, 0x0eba, 0x0ebb, 0x0ebc, 0x0ebd,  // Offset: 0d98 ~ 0d9f
0x0ebe, 0x0ebf, 0x0ec0, 0x0ec1, 0x0ec2, 0x0ec3, 0x0ec4, 0x0ec5,  // Offset: 0da0 ~ 0da7
0x0ec6, 0x0ec7, 0x0ec8, 0x0ec9, 0x0eca, 0x0ecb, 0x0ecc, 0x0ecd,  // Offset: 0da8 ~ 0daf
0x0ece, 0x0ecf, 0x0ed0, 0x0ed1, 0x0ed2, 0x0ed3, 0x0ed4, 0x0ed5,  // Offset: 0db0 ~ 0db7
0x0ed6, 0x0ed7, 0x0ed8, 0x0ed9, 0x0eda, 0x0edb, 0x0edc, 0x0edd,  // Offset: 0db8 ~ 0dbf
0x0ede, 0x0edf, 0x0ee0, 0x0ee1, 0x0ee2, 0x0ee3, 0x0ee4, 0x0ee5,  // Offset: 0dc0 ~ 0dc7
0x0ee6, 0x0ee7, 0x0ee8, 0x0ee9, 0x0eea, 0x0eeb, 0x0eec, 0x0eed,  // Offset: 0dc8 ~ 0dcf
0x0eee, 0x0eef, 0x0ef0, 0x0ef1, 0x0ef2, 0x0ef3, 0x0ef4, 0x0ef5,  // Offset: 0dd0 ~ 0dd7
0x0ef6, 0x0ef7, 0x0ef8, 0x0ef9, 0x0efa, 0x0efb, 0x0efc, 0x0efd,  // Offset: 0dd8 ~ 0ddf
0x0efe, 0x0eff, 0x0f00, 0x0f01, 0x0f02, 0x0f03, 0x0f04, 0x0f05,  // Offset: 0de0 ~ 0de7
0x0f06, 0x0f07, 0x0f08, 0x0f09, 0x0f0a, 0x0f0b, 0x0f0c, 0x0f0d,  // Offset: 0de8 ~ 0def
0x0f0e, 0x0f0f, 0x0f10, 0x0f11, 0x0f12, 0x0f13, 0x0f14, 0x0f15,  // Offset: 0df0 ~ 0df7
0x0f16, 0x0f17, 0x0f18, 0x0f19, 0x0f1a, 0x0f1b, 0x0f1c, 0x0f1d,  // Offset: 0df8 ~ 0dff
0x0f1e, 0x0f1f, 0x0f20, 0x0f21, 0x0f22, 0x0f23, 0x0f24, 0x0f25,  // Offset: 0e00 ~ 0e07
0x0f26, 0x0f27, 0x0f28, 0x0f29, 0x0f2a, 0x0f2b, 0x0f2c, 0x0f2d,  // Offset: 0e08 ~ 0e0f
0x0f2e, 0x0f2f, 0x0f30, 0x0f31, 0x0f32, 0x0f33, 0x0f34, 0x0f35,  // Offset: 0e10 ~ 0e17
0x0f36, 0x0f37, 0x0f38, 0x0f39, 0x0f3a, 0x0f3b, 0x0f3c, 0x0f3d,  // Offset: 0e18 ~ 0e1f
0x0f3e, 0x0f3f, 0x0f40, 0x0f41, 0x0f42, 0x0f43, 0x0f44, 0x0f45,  // Offset: 0e20 ~ 0e27
0x0f46, 0x0f47, 0x0f48, 0x0f49, 0x0f4a, 0x0f4b, 0x0f4c, 0x0f4d,  // Offset: 0e28 ~ 0e2f
0x0f4e, 0x0f4f, 0x0f50, 0x0f51, 0x0f52, 0x0f53, 0x0f54, 0x0f55,  // Offset: 0e30 ~ 0e37
0x0f56, 0x0f57, 0x0f58, 0x0f59, 0x0f5a, 0x0f5b, 0x0f5c, 0x0f5d,  // Offset: 0e38 ~ 0e3f
0x0f5e, 0x0f5f, 0x0f60, 0x0f61, 0x0f62, 0x0f63, 0x0f64, 0x0f65,  // Offset: 0e40 ~ 0e47
0x0f66, 0x0f67, 0x0f68, 0x0f69, 0x0f6a, 0x0f6b, 0x0f6c, 0x0f6d,  // Offset: 0e48 ~ 0e4f
0x0f6e, 0x0f6f, 0x0f70, 0x0f71, 0x0f72, 0x0f73, 0x0f74, 0x0f75,  // Offset: 0e50 ~ 0e57
0x0f76, 0x0f77, 0x0f78, 0x0f79, 0x0f7a, 0x0f7b, 0x0f7c, 0x0f7d,  // Offset: 0e58 ~ 0e5f
0x0f7e, 0x0f7f, 0x0f80, 0x0f81, 0x0f82, 0x0f83, 0x0f84, 0x0f85,  // Offset: 0e60 ~ 0e67
0x0f86, 0x0f87, 0x0f88, 0x0f89, 0x0f8a, 0x0f8b, 0x0f8c, 0x0f8d,  // Offset: 0e68 ~ 0e6f
0x0f8e, 0x0f8f, 0x0f90, 0x0f91, 0x0f92, 0x0f93, 0x0f94, 0x0f95,  // Offset: 0e70 ~ 0e77
0x0f96, 0x0f97, 0x0f98, 0x0f99, 0x0f9a, 0x0f9b, 0x0f9c, 0x0f9d,  // Offset: 0e78 ~ 0e7f
0x0f9e, 0x0f9f, 0x0fa0, 0x0fa1, 0x0fa2, 0x0fa3, 0x0fa4, 0x0fa5,  // Offset: 0e80 ~ 0e87
0x0fa6, 0x0fa7, 0x0fa8, 0x0fa9, 0x0faa, 0x0fab, 0x0fac, 0x0fad,  // Offset: 0e88 ~ 0e8f
0x0fae, 0x0faf, 0x0fb0, 0x0fb1, 0x0fb2, 0x0fb3, 0x0fb4, 0x0fb5,  // Offset: 0e90 ~ 0e97
0x0fb6, 0x0fb7, 0x0fb8, 0x0fb9, 0x0fba, 0x0fbb, 0x0fbc, 0x0fbd,  // Offset: 0e98 ~ 0e9f
0x0fbe, 0x0fbf, 0x0fc0, 0x0fc1, 0x0fc2, 0x0fc3, 0x0fc4, 0x0fc5,  // Offset: 0ea0 ~ 0ea7
0x0fc6, 0x0fc7, 0x0fc8, 0x0fc9, 0x0fca, 0x0fcb, 0x0fcc, 0x0fcd,  // Offset: 0ea8 ~ 0eaf
0x0fce, 0x0fcf, 0x0fd0, 0x0fd1, 0x0fd2, 0x0fd3, 0x0fd4, 0x0fd5,  // Offset: 0eb0 ~ 0eb7
0x0fd6, 0x0fd7, 0x0fd8, 0x0fd9, 0x0fda, 0x0fdb, 0x0fdc, 0x0fdd,  // Offset: 0eb8 ~ 0ebf
0x0fde, 0x0fdf, 0x0fe0, 0x0fe1, 0x0fe2, 0x0fe3, 0x0fe4, 0x0fe5,  // Offset: 0ec0 ~ 0ec7
0x0fe6, 0x0fe7, 0x0fe8, 0x0fe9, 0x0fea, 0x0feb, 0x0fec, 0x0fed,  // Offset: 0ec8 ~ 0ecf
0x0fee, 0x0fef, 0x0ff0, 0x0ff1, 0x0ff2, 0x0ff3, 0x0ff4, 0x0ff5,  // Offset: 0ed0 ~ 0ed7
0x0ff6, 0x0ff7, 0x0ff8, 0x0ff9, 0x0ffa, 0x0ffb, 0x0ffc, 0x0ffd,  // Offset: 0ed8 ~ 0edf
0x0ffe, 0x0fff, 0x1000, 0x1001, 0x1002, 0x1003, 0x1004, 0x1005,  // Offset: 0ee0 ~ 0ee7
0x1006, 0x1007, 0x1008, 0x1009, 0x100a, 0x100b, 0x100c, 0x100d,  // Offset: 0ee8 ~ 0eef
0x100e, 0x100f, 0x1010, 0x1011, 0x1012, 0x1013, 0x1014, 0x1015,  // Offset: 0ef0 ~ 0ef7
0x1016, 0x1017, 0x1018, 0x1019, 0x101a, 0x101b, 0x101c, 0x101d,  // Offset: 0ef8 ~ 0eff
0x101e, 0x101f, 0x1020, 0x1021, 0x1022, 0x1023, 0x1024, 0x1025,  // Offset: 0f00 ~ 0f07
0x1026, 0x1027, 0x1028, 0x1029, 0x102a, 0x102b, 0x102c, 0x102d,  // Offset: 0f08 ~ 0f0f
0x102e, 0x102f, 0x1030, 0x1031, 0x1032, 0x1033, 0x1034, 0x1035,  // Offset: 0f10 ~ 0f17
0x1036, 0x1037, 0x1038, 0x1039, 0x103a, 0x103b, 0x103c, 0x103d,  // Offset: 0f18 ~ 0f1f
0x103e, 0x103f, 0x1040, 0x1041, 0x1042, 0x1043, 0x1044, 0x1045,  // Offset: 0f20 ~ 0f27
0x1046, 0x1047, 0x1048, 0x1049, 0x104a, 0x104b, 0x104c, 0x104d,  // Offset: 0f28 ~ 0f2f
0x104e, 0x104f, 0x1050, 0x1051, 0x1052, 0x1053, 0x1054, 0x1055,  // Offset: 0f30 ~ 0f37
0x1056, 0x1057, 0x1058, 0x1059, 0x105a, 0x105b, 0x105c, 0x105d,  // Offset: 0f38 ~ 0f3f
0x105e, 0x105f, 0x1060, 0x1061, 0x1062, 0x1063, 0x1064, 0x1065,  // Offset: 0f40 ~ 0f47
0x1066, 0x1067, 0x1068, 0x1069, 0x106a, 0x106b, 0x106c, 0x106d,  // Offset: 0f48 ~ 0f4f
0x106e, 0x106f, 0x1070, 0x1071, 0x1072, 0x1073, 0x1074, 0x1075,  // Offset: 0f50 ~ 0f57
0x1076, 0x1077, 0x1078, 0x1079, 0x107a, 0x107b, 0x107c, 0x107d,  // Offset: 0f58 ~ 0f5f
0x107e, 0x107f, 0x1080, 0x1081, 0x1082, 0x1083, 0x1084, 0x1085,  // Offset: 0f60 ~ 0f67
0x1086, 0x1087, 0x1088, 0x1089, 0x108a, 0x108b, 0x108c, 0x108d,  // Offset: 0f68 ~ 0f6f
0x108e, 0x108f, 0x1090, 0x1091, 0x1092, 0x1093, 0x1094, 0x1095,  // Offset: 0f70 ~ 0f77
0x1096, 0x1097, 0x1098, 0x1099, 0x109a, 0x109b, 0x109c, 0x109d,  // Offset: 0f78 ~ 0f7f
0x109e, 0x109f, 0x10a0, 0x10a1, 0x10a2, 0x10a3, 0x10a4, 0x10a5,  // Offset: 0f80 ~ 0f87
0x10a6, 0x10a7, 0x10a8, 0x10a9, 0x10aa, 0x10ab, 0x10ac, 0x10ad,  // Offset: 0f88 ~ 0f8f
0x10ae, 0x10af, 0x10b0, 0x10b1, 0x10b2, 0x10b3, 0x10b4, 0x10b5,  // Offset: 0f90 ~ 0f97
0x10b6, 0x10b7, 0x10b8, 0x10b9, 0x10ba, 0x10bb, 0x10bc, 0x10bd,  // Offset: 0f98 ~ 0f9f
0x10be, 0x10bf, 0x10c0, 0x10c1, 0x10c2, 0x10c3, 0x10c4, 0x10c5,  // Offset: 0fa0 ~ 0fa7
0x10c6, 0x10c7, 0x10c8, 0x10c9, 0x10ca, 0x10cb, 0x10cc, 0x10cd,  // Offset: 0fa8 ~ 0faf
0x10ce, 0x10cf, 0x10d0, 0x10d1, 0x10d2, 0x10d3, 0x10d4, 0x10d5,  // Offset: 0fb0 ~ 0fb7
0x10d6, 0x10d7, 0x10d8, 0x10d9, 0x10da, 0x10db, 0x10dc, 0x10dd,  // Offset: 0fb8 ~ 0fbf
0x10de, 0x10df, 0x10e0, 0x10e1, 0x10e2, 0x10e3, 0x10e4, 0x10e5,  // Offset: 0fc0 ~ 0fc7
0x10e6, 0x10e7, 0x10e8, 0x10e9, 0x10ea, 0x10eb, 0x10ec, 0x10ed,  // Offset: 0fc8 ~ 0fcf
0x10ee, 0x10ef, 0x10f0, 0x10f1, 0x10f2, 0x10f3, 0x10f4, 0x10f5,  // Offset: 0fd0 ~ 0fd7
0x10f6, 0x10f7, 0x10f8, 0x10f9, 0x10fa, 0x10fb, 0x10fc, 0x10fd,  // Offset: 0fd8 ~ 0fdf
0x10fe, 0x10ff, 0x1100, 0x1101, 0x1102, 0x1103, 0x1104, 0x1105,  // Offset: 0fe0 ~ 0fe7
0x1106, 0x1107, 0x1108, 0x1109, 0x110a, 0x110b, 0x110c, 0x110d,  // Offset: 0fe8 ~ 0fef
0x110e, 0x110f, 0x1110, 0x1111, 0x1112, 0x1113, 0x1114, 0x1115,  // Offset: 0ff0 ~ 0ff7
0x1116, 0x1117, 0x1118, 0x1119, 0x111a, 0x111b, 0x111c, 0x111d,  // Offset: 0ff8 ~ 0fff
0x111e, 0x111f, 0x1120, 0x1121, 0x1122, 0x1123, 0x1124, 0x1125,  // Offset: 1000 ~ 1007
0x1126, 0x1127, 0x1128, 0x1129, 0x112a, 0x112b, 0x112c, 0x112d,  // Offset: 1008 ~ 100f
0x112e, 0x112f, 0x1130, 0x1131, 0x1132, 0x1133, 0x1134, 0x1135,  // Offset: 1010 ~ 1017
0x1136, 0x1137, 0x1138, 0x1139, 0x113a, 0x113b, 0x113c, 0x113d,  // Offset: 1018 ~ 101f
0x113e, 0x113f, 0x1140, 0x1141, 0x1142, 0x1143, 0x1144, 0x1145,  // Offset: 1020 ~ 1027
0x1146, 0x1147, 0x1148, 0x1149, 0x114a, 0x114b, 0x114c, 0x114d,  // Offset: 1028 ~ 102f
0x114e, 0x114f, 0x1150, 0x1151, 0x1152, 0x1153, 0x1154, 0x1155,  // Offset: 1030 ~ 1037
0x1156, 0x1157, 0x1158, 0x1159, 0x115a, 0x115b, 0x115c, 0x115d,  // Offset: 1038 ~ 103f
0x115e, 0x115f, 0x1160, 0x1161, 0x1162, 0x1163, 0x1164, 0x1165,  // Offset: 1040 ~ 1047
0x1166, 0x1167, 0x1168, 0x1169, 0x116a, 0x116b, 0x116c, 0x116d,  // Offset: 1048 ~ 104f
0x116e, 0x116f, 0x1170, 0x1171, 0x1172, 0x1173, 0x1174, 0x1175,  // Offset: 1050 ~ 1057
0x1176, 0x1177, 0x1178, 0x1179, 0x117a, 0x117b, 0x117c, 0x117d,  // Offset: 1058 ~ 105f
0x117e, 0x117f, 0x1180, 0x1181, 0x1182, 0x1183, 0x1184, 0x1185,  // Offset: 1060 ~ 1067
0x1186, 0x1187, 0x1188, 0x1189, 0x118a, 0x118b, 0x118c, 0x118d,  // Offset: 1068 ~ 106f
0x118e, 0x118f, 0x1190, 0x1191, 0x1192, 0x1193, 0x1194, 0x1195,  // Offset: 1070 ~ 1077
0x1196, 0x1197, 0x1198, 0x1199, 0x119a, 0x119b, 0x119c, 0x119d,  // Offset: 1078 ~ 107f
0x119e, 0x119f, 0x11a0, 0x11a1, 0x11a2, 0x11a3, 0x11a4, 0x11a5,  // Offset: 1080 ~ 1087
0x11a6, 0x11a7, 0x11a8, 0x11a9, 0x11aa, 0x11ab, 0x11ac, 0x11ad,  // Offset: 1088 ~ 108f
0x11ae, 0x11af, 0x11b0, 0x11b1, 0x11b2, 0x11b3, 0x11b4, 0x11b5,  // Offset: 1090 ~ 1097
0x11b6, 0x11b7, 0x11b8, 0x11b9, 0x11ba, 0x11bb, 0x11bc, 0x11bd,  // Offset: 1098 ~ 109f
0x11be, 0x11bf, 0x11c0, 0x11c1, 0x11c2, 0x11c3, 0x11c4, 0x11c5,  // Offset: 10a0 ~ 10a7
0x11c6, 0x11c7, 0x11c8, 0x11c9, 0x11ca, 0x11cb, 0x11cc, 0x11cd,  // Offset: 10a8 ~ 10af
0x11ce, 0x11cf, 0x11d0, 0x11d1, 0x11d2, 0x11d3, 0x11d4, 0x11d5,  // Offset: 10b0 ~ 10b7
0x11d6, 0x11d7, 0x11d8, 0x11d9, 0x11da, 0x11db, 0x11dc, 0x11dd,  // Offset: 10b8 ~ 10bf
0x11de, 0x11df, 0x11e0, 0x11e1, 0x11e2, 0x11e3, 0x11e4, 0x11e5,  // Offset: 10c0 ~ 10c7
0x11e6, 0x11e7, 0x11e8, 0x11e9, 0x11ea, 0x11eb, 0x11ec, 0x11ed,  // Offset: 10c8 ~ 10cf
0x11ee, 0x11ef, 0x11f0, 0x11f1, 0x11f2, 0x11f3, 0x11f4, 0x11f5,  // Offset: 10d0 ~ 10d7
0x11f6, 0x11f7, 0x11f8, 0x11f9, 0x11fa, 0x11fb, 0x11fc, 0x11fd,  // Offset: 10d8 ~ 10df
0x11fe, 0x11ff, 0x1200, 0x1201, 0x1202, 0x1203, 0x1204, 0x1205,  // Offset: 10e0 ~ 10e7
0x1206, 0x1207, 0x1208, 0x1209, 0x120a, 0x120b, 0x120c, 0x120d,  // Offset: 10e8 ~ 10ef
0x120e, 0x120f, 0x1210, 0x1211, 0x1212, 0x1213, 0x1214, 0x1215,  // Offset: 10f0 ~ 10f7
0x1216, 0x1217, 0x1218, 0x1219, 0x121a, 0x121b, 0x121c, 0x121d,  // Offset: 10f8 ~ 10ff
0x121e, 0x121f, 0x1220, 0x1221, 0x1222, 0x1223, 0x1224, 0x1225,  // Offset: 1100 ~ 1107
0x1226, 0x1227, 0x1228, 0x1229, 0x122a, 0x122b, 0x122c, 0x122d,  // Offset: 1108 ~ 110f
0x122e, 0x122f, 0x1230, 0x1231, 0x1232, 0x1233, 0x1234, 0x1235,  // Offset: 1110 ~ 1117
0x1236, 0x1237, 0x1238, 0x1239, 0x123a, 0x123b, 0x123c, 0x123d,  // Offset: 1118 ~ 111f
0x123e, 0x123f, 0x1240, 0x1241, 0x1242, 0x1243, 0x1244, 0x1245,  // Offset: 1120 ~ 1127
0x1246, 0x1247, 0x1248, 0x1249, 0x124a, 0x124b, 0x124c, 0x124d,  // Offset: 1128 ~ 112f
0x124e, 0x124f, 0x1250, 0x1251, 0x1252, 0x1253, 0x1254, 0x1255,  // Offset: 1130 ~ 1137
0x1256, 0x1257, 0x1258, 0x1259, 0x125a, 0x125b, 0x125c, 0x125d,  // Offset: 1138 ~ 113f
0x125e, 0x125f, 0x1260, 0x1261, 0x1262, 0x1263, 0x1264, 0x1265,  // Offset: 1140 ~ 1147
0x1266, 0x1267, 0x1268, 0x1269, 0x126a, 0x126b, 0x126c, 0x126d,  // Offset: 1148 ~ 114f
0x126e, 0x126f, 0x1270, 0x1271, 0x1272, 0x1273, 0x1274, 0x1275,  // Offset: 1150 ~ 1157
0x1276, 0x1277, 0x1278, 0x1279, 0x127a, 0x127b, 0x127c, 0x127d,  // Offset: 1158 ~ 115f
0x127e, 0x127f, 0x1280, 0x1281, 0x1282, 0x1283, 0x1284, 0x1285,  // Offset: 1160 ~ 1167
0x1286, 0x1287, 0x1288, 0x1289, 0x128a, 0x128b, 0x128c, 0x128d,  // Offset: 1168 ~ 116f
0x128e, 0x128f, 0x1290, 0x1291, 0x1292, 0x1293, 0x1294, 0x1295,  // Offset: 1170 ~ 1177
0x1296, 0x1297, 0x1298, 0x1299, 0x129a, 0x129b, 0x129c, 0x129d,  // Offset: 1178 ~ 117f
0x129e, 0x129f, 0x12a0, 0x12a1, 0x12a2, 0x12a3, 0x12a4, 0x12a5,  // Offset: 1180 ~ 1187
0x12a6, 0x12a7, 0x12a8, 0x12a9, 0x12aa, 0x12ab, 0x12ac, 0x12ad,  // Offset: 1188 ~ 118f
0x12ae, 0x12af, 0x12b0, 0x12b1, 0x12b2, 0x12b3, 0x12b4, 0x12b5,  // Offset: 1190 ~ 1197
0x12b6, 0x12b7, 0x12b8, 0x12b9, 0x12ba, 0x12bb, 0x12bc, 0x12bd,  // Offset: 1198 ~ 119f
0x12be, 0x12bf, 0x12c0, 0x12c1, 0x12c2, 0x12c3, 0x12c4, 0x12c5,  // Offset: 11a0 ~ 11a7
0x12c6, 0x12c7, 0x12c8, 0x12c9, 0x12ca, 0x12cb, 0x12cc, 0x12cd,  // Offset: 11a8 ~ 11af
0x12ce, 0x12cf, 0x12d0, 0x12d1, 0x12d2, 0x12d3, 0x12d4, 0x12d5,  // Offset: 11b0 ~ 11b7
0x12d6, 0x12d7, 0x12d8, 0x12d9, 0x12da, 0x12db, 0x12dc, 0x12dd,  // Offset: 11b8 ~ 11bf
0x12de, 0x12df, 0x12e0, 0x12e1, 0x12e2, 0x12e3, 0x12e4, 0x12e5,  // Offset: 11c0 ~ 11c7
0x12e6, 0x12e7, 0x12e8, 0x12e9, 0x12ea, 0x12eb, 0x12ec, 0x12ed,  // Offset: 11c8 ~ 11cf
0x12ee, 0x12ef, 0x12f0, 0x12f1, 0x12f2, 0x12f3, 0x12f4, 0x12f5,  // Offset: 11d0 ~ 11d7
0x12f6, 0x12f7, 0x12f8, 0x12f9, 0x12fa, 0x12fb, 0x12fc, 0x12fd,  // Offset: 11d8 ~ 11df
0x12fe, 0x12ff, 0x1300, 0x1301, 0x1302, 0x1303, 0x1304, 0x1305,  // Offset: 11e0 ~ 11e7
0x1306, 0x1307, 0x1308, 0x1309, 0x130a, 0x130b, 0x130c, 0x130d,  // Offset: 11e8 ~ 11ef
0x130e, 0x130f, 0x1310, 0x1311, 0x1312, 0x1313, 0x1314, 0x1315,  // Offset: 11f0 ~ 11f7
0x1316, 0x1317, 0x1318, 0x1319, 0x131a, 0x131b, 0x131c, 0x131d,  // Offset: 11f8 ~ 11ff
0x131e, 0x131f, 0x1320, 0x1321, 0x1322, 0x1323, 0x1324, 0x1325,  // Offset: 1200 ~ 1207
0x1326, 0x1327, 0x1328, 0x1329, 0x132a, 0x132b, 0x132c, 0x132d,  // Offset: 1208 ~ 120f
0x132e, 0x132f, 0x1330, 0x1331, 0x1332, 0x1333, 0x1334, 0x1335,  // Offset: 1210 ~ 1217
0x1336, 0x1337, 0x1338, 0x1339, 0x133a, 0x133b, 0x133c, 0x133d,  // Offset: 1218 ~ 121f
0x133e, 0x133f, 0x1340, 0x1341, 0x1342, 0x1343, 0x1344, 0x1345,  // Offset: 1220 ~ 1227
0x1346, 0x1347, 0x1348, 0x1349, 0x134a, 0x134b, 0x134c, 0x134d,  // Offset: 1228 ~ 122f
0x134e, 0x134f, 0x1350, 0x1351, 0x1352, 0x1353, 0x1354, 0x1355,  // Offset: 1230 ~ 1237
0x1356, 0x1357, 0x1358, 0x1359, 0x135a, 0x135b, 0x135c, 0x135d,  // Offset: 1238 ~ 123f
0x135e, 0x135f, 0x1360, 0x1361, 0x1362, 0x1363, 0x1364, 0x1365,  // Offset: 1240 ~ 1247
0x1366, 0x1367, 0x1368, 0x1369, 0x136a, 0x136b, 0x136c, 0x136d,  // Offset: 1248 ~ 124f
0x136e, 0x136f, 0x1370, 0x1371, 0x1372, 0x1373, 0x1374, 0x1375,  // Offset: 1250 ~ 1257
0x1376, 0x1377, 0x1378, 0x1379, 0x137a, 0x137b, 0x137c, 0x137d,  // Offset: 1258 ~ 125f
0x137e, 0x137f, 0x1380, 0x1381, 0x1382, 0x1383, 0x1384, 0x1385,  // Offset: 1260 ~ 1267
0x1386, 0x1387, 0x1388, 0x1389, 0x138a, 0x138b, 0x138c, 0x138d,  // Offset: 1268 ~ 126f
0x138e, 0x138f, 0x1390, 0x1391, 0x1392, 0x1393, 0x1394, 0x1395,  // Offset: 1270 ~ 1277
0x1396, 0x1397, 0x1398, 0x1399, 0x139a, 0x139b, 0x139c, 0x139d,  // Offset: 1278 ~ 127f
0x139e, 0x139f, 0x13a0, 0x13a1, 0x13a2, 0x13a3, 0x13a4, 0x13a5,  // Offset: 1280 ~ 1287
0x13a6, 0x13a7, 0x13a8, 0x13a9, 0x13aa, 0x13ab, 0x13ac, 0x13ad,  // Offset: 1288 ~ 128f
0x13ae, 0x13af, 0x13b0, 0x13b1, 0x13b2, 0x13b3, 0x13b4, 0x13b5,  // Offset: 1290 ~ 1297
0x13b6, 0x13b7, 0x13b8, 0x13b9, 0x13ba, 0x13bb, 0x13bc, 0x13bd,  // Offset: 1298 ~ 129f
0x13be, 0x13bf, 0x13c0, 0x13c1, 0x13c2, 0x13c3, 0x13c4, 0x13c5,  // Offset: 12a0 ~ 12a7
0x13c6, 0x13c7, 0x13c8, 0x13c9, 0x13ca, 0x13cb, 0x13cc, 0x13cd,  // Offset: 12a8 ~ 12af
0x13ce, 0x13cf, 0x13d0, 0x13d1, 0x13d2, 0x13d3, 0x13d4, 0x13d5,  // Offset: 12b0 ~ 12b7
0x13d6, 0x13d7, 0x13d8, 0x13d9, 0x13da, 0x13db, 0x13dc, 0x13dd,  // Offset: 12b8 ~ 12bf
0x13de, 0x13df, 0x13e0, 0x13e1, 0x13e2, 0x13e3, 0x13e4, 0x13e5,  // Offset: 12c0 ~ 12c7
0x13e6, 0x13e7, 0x13e8, 0x13e9, 0x13ea, 0x13eb, 0x13ec, 0x13ed,  // Offset: 12c8 ~ 12cf
0x13ee, 0x13ef, 0x13f0, 0x13f1, 0x13f2, 0x13f3, 0x13f4, 0x13f5,  // Offset: 12d0 ~ 12d7
0x13f6, 0x13f7, 0x13f8, 0x13f9, 0x13fa, 0x13fb, 0x13fc, 0x13fd,  // Offset: 12d8 ~ 12df
0x13fe, 0x13ff, 0x1400, 0x1401, 0x1402, 0x1403, 0x1404, 0x1405,  // Offset: 12e0 ~ 12e7
0x1406, 0x1407, 0x1408, 0x1409, 0x140a, 0x140b, 0x140c, 0x140d,  // Offset: 12e8 ~ 12ef
0x140e, 0x140f, 0x1410, 0x1411, 0x1412, 0x1413, 0x1414, 0x1415,  // Offset: 12f0 ~ 12f7
0x1416, 0x1417, 0x1418, 0x1419, 0x141a, 0x141b, 0x141c, 0x141d,  // Offset: 12f8 ~ 12ff
0x141e, 0x141f, 0x1420, 0x1421, 0x1422, 0x1423, 0x1424, 0x1425,  // Offset: 1300 ~ 1307
0x1426, 0x1427, 0x1428, 0x1429, 0x142a, 0x142b, 0x142c, 0x142d,  // Offset: 1308 ~ 130f
0x142e, 0x142f, 0x1430, 0x1431, 0x1432, 0x1433, 0x1434, 0x1435,  // Offset: 1310 ~ 1317
0x1436, 0x1437, 0x1438, 0x1439, 0x143a, 0x143b, 0x143c, 0x143d,  // Offset: 1318 ~ 131f
0x143e, 0x143f, 0x1440, 0x1441, 0x1442, 0x1443, 0x1444, 0x1445,  // Offset: 1320 ~ 1327
0x1446, 0x1447, 0x1448, 0x1449, 0x144a, 0x144b, 0x144c, 0x144d,  // Offset: 1328 ~ 132f
0x144e, 0x144f, 0x1450, 0x1451, 0x1452, 0x1453, 0x1454, 0x1455,  // Offset: 1330 ~ 1337
0x1456, 0x1457, 0x1458, 0x1459, 0x145a, 0x145b, 0x145c, 0x145d,  // Offset: 1338 ~ 133f
0x145e, 0x145f, 0x1460, 0x1461, 0x1462, 0x1463, 0x1464, 0x1465,  // Offset: 1340 ~ 1347
0x1466, 0x1467, 0x1468, 0x1469, 0x146a, 0x146b, 0x146c, 0x146d,  // Offset: 1348 ~ 134f
0x146e, 0x146f, 0x1470, 0x1471, 0x1472, 0x1473, 0x1474, 0x1475,  // Offset: 1350 ~ 1357
0x1476, 0x1477, 0x1478, 0x1479, 0x147a, 0x147b, 0x147c, 0x147d,  // Offset: 1358 ~ 135f
0x147e, 0x147f, 0x1480, 0x1481, 0x1482, 0x1483, 0x1484, 0x1485,  // Offset: 1360 ~ 1367
0x1486, 0x1487, 0x1488, 0x1489, 0x148a, 0x148b, 0x148c, 0x148d,  // Offset: 1368 ~ 136f
0x148e, 0x148f, 0x1490, 0x1491, 0x1492, 0x1493, 0x1494, 0x1495,  // Offset: 1370 ~ 1377
0x1496, 0x1497, 0x1498, 0x1499, 0x149a, 0x149b, 0x149c, 0x149d,  // Offset: 1378 ~ 137f
0x149e, 0x149f, 0x14a0, 0x14a1, 0x14a2, 0x14a3, 0x14a4, 0x14a5,  // Offset: 1380 ~ 1387
0x14a6, 0x14a7, 0x14a8, 0x14a9, 0x14aa, 0x14ab, 0x14ac, 0x14ad,  // Offset: 1388 ~ 138f
0x14ae, 0x14af, 0x14b0, 0x14b1, 0x14b2, 0x14b3, 0x14b4, 0x14b5,  // Offset: 1390 ~ 1397
0x14b6, 0x14b7, 0x14b8, 0x14b9, 0x14ba, 0x14bb, 0x14bc, 0x14bd,  // Offset: 1398 ~ 139f
0x14be, 0x14bf, 0x14c0, 0x14c1, 0x14c2, 0x14c3, 0x14c4, 0x14c5,  // Offset: 13a0 ~ 13a7
0x14c6, 0x14c7, 0x14c8, 0x14c9, 0x14ca, 0x14cb, 0x14cc, 0x14cd,  // Offset: 13a8 ~ 13af
0x14ce, 0x14cf, 0x14d0, 0x14d1, 0x14d2, 0x14d3, 0x14d4, 0x14d5,  // Offset: 13b0 ~ 13b7
0x14d6, 0x14d7, 0x14d8, 0x14d9, 0x14da, 0x14db, 0x14dc, 0x14dd,  // Offset: 13b8 ~ 13bf
0x14de, 0x14df, 0x14e0, 0x14e1, 0x14e2, 0x14e3, 0x14e4, 0x14e5,  // Offset: 13c0 ~ 13c7
0x14e6, 0x14e7, 0x14e8, 0x14e9, 0x14ea, 0x14eb, 0x14ec, 0x14ed,  // Offset: 13c8 ~ 13cf
0x14ee, 0x14ef, 0x14f0, 0x14f1, 0x14f2, 0x14f3, 0x14f4, 0x14f5,  // Offset: 13d0 ~ 13d7
0x14f6, 0x14f7, 0x14f8, 0x14f9, 0x14fa, 0x14fb, 0x14fc, 0x14fd,  // Offset: 13d8 ~ 13df
0x14fe, 0x14ff, 0x1500, 0x1501, 0x1502, 0x1503, 0x1504, 0x1505,  // Offset: 13e0 ~ 13e7
0x1506, 0x1507, 0x1508, 0x1509, 0x150a, 0x150b, 0x150c, 0x150d,  // Offset: 13e8 ~ 13ef
0x150e, 0x150f, 0x1510, 0x1511, 0x1512, 0x1513, 0x1514, 0x1515,  // Offset: 13f0 ~ 13f7
0x1516, 0x1517, 0x1518, 0x1519, 0x151a, 0x151b, 0x151c, 0x151d,  // Offset: 13f8 ~ 13ff
0x151e, 0x151f, 0x1520, 0x1521, 0x1522, 0x1523, 0x1524, 0x1525,  // Offset: 1400 ~ 1407
0x1526, 0x1527, 0x1528, 0x1529, 0x152a, 0x152b, 0x152c, 0x152d,  // Offset: 1408 ~ 140f
0x152e, 0x152f, 0x1530, 0x1531, 0x1532, 0x1533, 0x1534, 0x1535,  // Offset: 1410 ~ 1417
0x1536, 0x1537, 0x1538, 0x1539, 0x153a, 0x153b, 0x153c, 0x153d,  // Offset: 1418 ~ 141f
0x153e, 0x153f, 0x1540, 0x1541, 0x1542, 0x1543, 0x1544, 0x1545,  // Offset: 1420 ~ 1427
0x1546, 0x1547, 0x1548, 0x1549, 0x154a, 0x154b, 0x154c, 0x154d,  // Offset: 1428 ~ 142f
0x154e, 0x154f, 0x1550, 0x1551, 0x1552, 0x1553, 0x1554, 0x1555,  // Offset: 1430 ~ 1437
0x1556, 0x1557, 0x1558, 0x1559, 0x155a, 0x155b, 0x155c, 0x155d,  // Offset: 1438 ~ 143f
0x155e, 0x155f, 0x1560, 0x1561, 0x1562, 0x1563, 0x1564, 0x1565,  // Offset: 1440 ~ 1447
0x1566, 0x1567, 0x1568, 0x1569, 0x156a, 0x156b, 0x156c, 0x156d,  // Offset: 1448 ~ 144f
0x156e, 0x156f, 0x1570, 0x1571, 0x1572, 0x1573, 0x1574, 0x1575,  // Offset: 1450 ~ 1457
0x1576, 0x1577, 0x1578, 0x1579, 0x157a, 0x157b, 0x157c, 0x157d,  // Offset: 1458 ~ 145f
0x157e, 0x157f, 0x1580, 0x1581, 0x1582, 0x1583, 0x1584, 0x1585,  // Offset: 1460 ~ 1467
0x1586, 0x1587, 0x1588, 0x1589, 0x158a, 0x158b, 0x158c, 0x158d,  // Offset: 1468 ~ 146f
0x158e, 0x158f, 0x1590, 0x1591, 0x1592, 0x1593, 0x1594, 0x1595,  // Offset: 1470 ~ 1477
0x1596, 0x1597, 0x1598, 0x1599, 0x159a, 0x159b, 0x159c, 0x159d,  // Offset: 1478 ~ 147f
0x159e, 0x159f, 0x15a0, 0x15a1, 0x15a2, 0x15a3, 0x15a4, 0x15a5,  // Offset: 1480 ~ 1487
0x15a6, 0x15a7, 0x15a8, 0x15a9, 0x15aa, 0x15ab, 0x15ac, 0x15ad,  // Offset: 1488 ~ 148f
0x15ae, 0x15af, 0x15b0, 0x15b1, 0x15b2, 0x15b3, 0x15b4, 0x15b5,  // Offset: 1490 ~ 1497
0x15b6, 0x15b7, 0x15b8, 0x15b9, 0x15ba, 0x15bb, 0x15bc, 0x15bd,  // Offset: 1498 ~ 149f
0x15be, 0x15bf, 0x15c0, 0x15c1, 0x15c2, 0x15c3, 0x15c4, 0x15c5,  // Offset: 14a0 ~ 14a7
0x15c6, 0x15c7, 0x15c8, 0x15c9, 0x15ca, 0x15cb, 0x15cc, 0x15cd,  // Offset: 14a8 ~ 14af
0x15ce, 0x15cf, 0x15d0, 0x15d1, 0x15d2, 0x15d3, 0x15d4, 0x15d5,  // Offset: 14b0 ~ 14b7
0x15d6, 0x15d7, 0x15d8, 0x15d9, 0x15da, 0x15db, 0x15dc, 0x15dd,  // Offset: 14b8 ~ 14bf
0x15de, 0x15df, 0x15e0, 0x15e1, 0x15e2, 0x15e3, 0x15e4, 0x15e5,  // Offset: 14c0 ~ 14c7
0x15e6, 0x15e7, 0x15e8, 0x15e9, 0x15ea, 0x15eb, 0x15ec, 0x15ed,  // Offset: 14c8 ~ 14cf
0x15ee, 0x15ef, 0x15f0, 0x15f1, 0x15f2, 0x15f3, 0x15f4, 0x15f5,  // Offset: 14d0 ~ 14d7
0x15f6, 0x15f7, 0x15f8, 0x15f9, 0x15fa, 0x15fb, 0x15fc, 0x15fd,  // Offset: 14d8 ~ 14df
0x15fe, 0x15ff, 0x1600, 0x1601, 0x1602, 0x1603, 0x1604, 0x1605,  // Offset: 14e0 ~ 14e7
0x1606, 0x1607, 0x1608, 0x1609, 0x160a, 0x160b, 0x160c, 0x160d,  // Offset: 14e8 ~ 14ef
0x160e, 0x160f, 0x1610, 0x1611, 0x1612, 0x1613, 0x1614, 0x1615,  // Offset: 14f0 ~ 14f7
0x1616, 0x1617, 0x1618, 0x1619, 0x161a, 0x161b, 0x161c, 0x161d,  // Offset: 14f8 ~ 14ff
0x161e, 0x161f, 0x1620, 0x1621, 0x1622, 0x1623, 0x1624, 0x1625,  // Offset: 1500 ~ 1507
0x1626, 0x1627, 0x1628, 0x1629, 0x162a, 0x162b, 0x162c, 0x162d,  // Offset: 1508 ~ 150f
0x162e, 0x162f, 0x1630, 0x1631, 0x1632, 0x1633, 0x1634, 0x1635,  // Offset: 1510 ~ 1517
0x1636, 0x1637, 0x1638, 0x1639, 0x163a, 0x163b, 0x163c, 0x163d,  // Offset: 1518 ~ 151f
0x163e, 0x163f, 0x1640, 0x1641, 0x1642, 0x1643, 0x1644, 0x1645,  // Offset: 1520 ~ 1527
0x1646, 0x1647, 0x1648, 0x1649, 0x164a, 0x164b, 0x164c, 0x164d,  // Offset: 1528 ~ 152f
0x164e, 0x164f, 0x1650, 0x1651, 0x1652, 0x1653, 0x1654, 0x1655,  // Offset: 1530 ~ 1537
0x1656, 0x1657, 0x1658, 0x1659, 0x165a, 0x165b, 0x165c, 0x165d,  // Offset: 1538 ~ 153f
0x165e, 0x165f, 0x1660, 0x1661, 0x1662, 0x1663, 0x1664, 0x1665,  // Offset: 1540 ~ 1547
0x1666, 0x1667, 0x1668, 0x1669, 0x166a, 0x166b, 0x166c, 0x166d,  // Offset: 1548 ~ 154f
0x166e, 0x166f, 0x1670, 0x1671, 0x1672, 0x1673, 0x1674, 0x1675,  // Offset: 1550 ~ 1557
0x1676, 0x1677, 0x1678, 0x1679, 0x167a, 0x167b, 0x167c, 0x167d,  // Offset: 1558 ~ 155f
0x167e, 0x167f, 0x1680, 0x1681, 0x1682, 0x1683, 0x1684, 0x1685,  // Offset: 1560 ~ 1567
0x1686, 0x1687, 0x1688, 0x1689, 0x168a, 0x168b, 0x168c, 0x168d,  // Offset: 1568 ~ 156f
0x168e, 0x168f, 0x1690, 0x1691, 0x1692, 0x1693, 0x1694, 0x1695,  // Offset: 1570 ~ 1577
0x1696, 0x1697, 0x1698, 0x1699, 0x169a, 0x169b, 0x169c, 0x169d,  // Offset: 1578 ~ 157f
0x169e, 0x169f, 0x16a0, 0x16a1, 0x16a2, 0x16a3, 0x16a4, 0x16a5,  // Offset: 1580 ~ 1587
0x16a6, 0x16a7, 0x16a8, 0x16a9, 0x16aa, 0x16ab, 0x16ac, 0x16ad,  // Offset: 1588 ~ 158f
0x16ae, 0x16af, 0x16b0, 0x16b1, 0x16b2, 0x16b3, 0x16b4, 0x16b5,  // Offset: 1590 ~ 1597
0x16b6, 0x16b7, 0x16b8, 0x16b9, 0x16ba, 0x16bb, 0x16bc, 0x16bd,  // Offset: 1598 ~ 159f
0x16be, 0x16bf, 0x16c0, 0x16c1, 0x16c2, 0x16c3, 0x16c4, 0x16c5,  // Offset: 15a0 ~ 15a7
0x16c6, 0x16c7, 0x16c8, 0x16c9, 0x16ca, 0x16cb, 0x16cc, 0x16cd,  // Offset: 15a8 ~ 15af
0x16ce, 0x16cf, 0x16d0, 0x16d1, 0x16d2, 0x16d3, 0x16d4, 0x16d5,  // Offset: 15b0 ~ 15b7
0x16d6, 0x16d7, 0x16d8, 0x16d9, 0x16da, 0x16db, 0x16dc, 0x16dd,  // Offset: 15b8 ~ 15bf
0x16de, 0x16df, 0x16e0, 0x16e1, 0x16e2, 0x16e3, 0x16e4, 0x16e5,  // Offset: 15c0 ~ 15c7
0x16e6, 0x16e7, 0x16e8, 0x16e9, 0x16ea, 0x16eb, 0x16ec, 0x16ed,  // Offset: 15c8 ~ 15cf
0x16ee, 0x16ef, 0x16f0, 0x16f1, 0x16f2, 0x16f3, 0x16f4, 0x16f5,  // Offset: 15d0 ~ 15d7
0x16f6, 0x16f7, 0x16f8, 0x16f9, 0x16fa, 0x16fb, 0x16fc, 0x16fd,  // Offset: 15d8 ~ 15df
0x16fe, 0x16ff, 0x1700, 0x1701, 0x1702, 0x1703, 0x1704, 0x1705,  // Offset: 15e0 ~ 15e7
0x1706, 0x1707, 0x1708, 0x1709, 0x170a, 0x170b, 0x170c, 0x170d,  // Offset: 15e8 ~ 15ef
0x170e, 0x170f, 0x1710, 0x1711, 0x1712, 0x1713, 0x1714, 0x1715,  // Offset: 15f0 ~ 15f7
0x1716, 0x1717, 0x1718, 0x1719, 0x171a, 0x171b, 0x171c, 0x171d,  // Offset: 15f8 ~ 15ff
0x171e, 0x171f, 0x1720, 0x1721, 0x1722, 0x1723, 0x1724, 0x1725,  // Offset: 1600 ~ 1607
0x1726, 0x1727, 0x1728, 0x1729, 0x172a, 0x172b, 0x172c, 0x172d,  // Offset: 1608 ~ 160f
0x172e, 0x172f, 0x1730, 0x1731, 0x1732, 0x1733, 0x1734, 0x1735,  // Offset: 1610 ~ 1617
0x1736, 0x1737, 0x1738, 0x1739, 0x173a, 0x173b, 0x173c, 0x173d,  // Offset: 1618 ~ 161f
0x173e, 0x173f, 0x1740, 0x1741, 0x1742, 0x1743, 0x1744, 0x1745,  // Offset: 1620 ~ 1627
0x1746, 0x1747, 0x1748, 0x1749, 0x174a, 0x174b, 0x174c, 0x174d,  // Offset: 1628 ~ 162f
0x174e, 0x174f, 0x1750, 0x1751, 0x1752, 0x1753, 0x1754, 0x1755,  // Offset: 1630 ~ 1637
0x1756, 0x1757, 0x1758, 0x1759, 0x175a, 0x175b, 0x175c, 0x175d,  // Offset: 1638 ~ 163f
0x175e, 0x175f, 0x1760, 0x1761, 0x1762, 0x1763, 0x1764, 0x1765,  // Offset: 1640 ~ 1647
0x1766, 0x1767, 0x1768, 0x1769, 0x176a, 0x176b, 0x176c, 0x176d,  // Offset: 1648 ~ 164f
0x176e, 0x176f, 0x1770, 0x1771, 0x1772, 0x1773, 0x1774, 0x1775,  // Offset: 1650 ~ 1657
0x1776, 0x1777, 0x1778, 0x1779, 0x177a, 0x177b, 0x177c, 0x177d,  // Offset: 1658 ~ 165f
0x177e, 0x177f, 0x1780, 0x1781, 0x1782, 0x1783, 0x1784, 0x1785,  // Offset: 1660 ~ 1667
0x1786, 0x1787, 0x1788, 0x1789, 0x178a, 0x178b, 0x178c, 0x178d,  // Offset: 1668 ~ 166f
0x178e, 0x178f, 0x1790, 0x1791, 0x1792, 0x1793, 0x1794, 0x1795,  // Offset: 1670 ~ 1677
0x1796, 0x1797, 0x1798, 0x1799, 0x179a, 0x179b, 0x179c, 0x179d,  // Offset: 1678 ~ 167f
0x179e, 0x179f, 0x17a0, 0x17a1, 0x17a2, 0x17a3, 0x17a4, 0x17a5,  // Offset: 1680 ~ 1687
0x17a6, 0x17a7, 0x17a8, 0x17a9, 0x17aa, 0x17ab, 0x17ac, 0x17ad,  // Offset: 1688 ~ 168f
0x17ae, 0x17af, 0x17b0, 0x17b1, 0x17b2, 0x17b3, 0x17b4, 0x17b5,  // Offset: 1690 ~ 1697
0x17b6, 0x17b7, 0x17b8, 0x17b9, 0x17ba, 0x17bb, 0x17bc, 0x17bd,  // Offset: 1698 ~ 169f
0x17be, 0x17bf, 0x17c0, 0x17c1, 0x17c2, 0x17c3, 0x17c4, 0x17c5,  // Offset: 16a0 ~ 16a7
0x17c6, 0x17c7, 0x17c8, 0x17c9, 0x17ca, 0x17cb, 0x17cc, 0x17cd,  // Offset: 16a8 ~ 16af
0x17ce, 0x17cf, 0x17d0, 0x17d1, 0x17d2, 0x17d3, 0x17d4, 0x17d5,  // Offset: 16b0 ~ 16b7
0x17d6, 0x17d7, 0x17d8, 0x17d9, 0x17da, 0x17db, 0x17dc, 0x17dd,  // Offset: 16b8 ~ 16bf
0x17de, 0x17df, 0x17e0, 0x17e1, 0x17e2, 0x17e3, 0x17e4, 0x17e5,  // Offset: 16c0 ~ 16c7
0x17e6, 0x17e7, 0x17e8, 0x17e9, 0x17ea, 0x17eb, 0x17ec, 0x17ed,  // Offset: 16c8 ~ 16cf
0x17ee, 0x17ef, 0x17f0, 0x17f1, 0x17f2, 0x17f3, 0x17f4, 0x17f5,  // Offset: 16d0 ~ 16d7
0x17f6, 0x17f7, 0x17f8, 0x17f9, 0x17fa, 0x17fb, 0x17fc, 0x17fd,  // Offset: 16d8 ~ 16df
0x17fe, 0x17ff, 0x1800, 0x1801, 0x1802, 0x1803, 0x1804, 0x1805,  // Offset: 16e0 ~ 16e7
0x1806, 0x1807, 0x1808, 0x1809, 0x180a, 0x180b, 0x180c, 0x180d,  // Offset: 16e8 ~ 16ef
0x180e, 0x180f, 0x1810, 0x1811, 0x1812, 0x1813, 0x1814, 0x1815,  // Offset: 16f0 ~ 16f7
0x1816, 0x1817, 0x1818, 0x1819, 0x181a, 0x181b, 0x181c, 0x181d,  // Offset: 16f8 ~ 16ff
0x181e, 0x181f, 0x1820, 0x1821, 0x1822, 0x1823, 0x1824, 0x1825,  // Offset: 1700 ~ 1707
0x1826, 0x1827, 0x1828, 0x1829, 0x182a, 0x182b, 0x182c, 0x182d,  // Offset: 1708 ~ 170f
0x182e, 0x182f, 0x1830, 0x1831, 0x1832, 0x1833, 0x1834, 0x1835,  // Offset: 1710 ~ 1717
0x1836, 0x1837, 0x1838, 0x1839, 0x183a, 0x183b, 0x183c, 0x183d,  // Offset: 1718 ~ 171f
0x183e, 0x183f, 0x1840, 0x1841, 0x1842, 0x1843, 0x1844, 0x1845,  // Offset: 1720 ~ 1727
0x1846, 0x1847, 0x1848, 0x1849, 0x184a, 0x184b, 0x184c, 0x184d,  // Offset: 1728 ~ 172f
0x184e, 0x184f, 0x1850, 0x1851, 0x1852, 0x1853, 0x1854, 0x1855,  // Offset: 1730 ~ 1737
0x1856, 0x1857, 0x1858, 0x1859, 0x185a, 0x185b, 0x185c, 0x185d,  // Offset: 1738 ~ 173f
0x185e, 0x185f, 0x1860, 0x1861, 0x1862, 0x1863, 0x1864, 0x1865,  // Offset: 1740 ~ 1747
0x1866, 0x1867, 0x1868, 0x1869, 0x186a, 0x186b, 0x186c, 0x186d,  // Offset: 1748 ~ 174f
0x186e, 0x186f, 0x1870, 0x1871, 0x1872, 0x1873, 0x1874, 0x1875,  // Offset: 1750 ~ 1757
0x1876, 0x1877, 0x1878, 0x1879, 0x187a, 0x187b, 0x187c, 0x187d,  // Offset: 1758 ~ 175f
0x187e, 0x187f, 0x1880, 0x1881, 0x1882, 0x1883, 0x1884, 0x1885,  // Offset: 1760 ~ 1767
0x1886, 0x1887, 0x1888, 0x1889, 0x188a, 0x188b, 0x188c, 0x188d,  // Offset: 1768 ~ 176f
0x188e, 0x188f, 0x1890, 0x1891, 0x1892, 0x1893, 0x1894, 0x1895,  // Offset: 1770 ~ 1777
0x1896, 0x1897, 0x1898, 0x1899, 0x189a, 0x189b, 0x189c, 0x189d,  // Offset: 1778 ~ 177f
0x189e, 0x189f, 0x18a0, 0x18a1, 0x18a2, 0x18a3, 0x18a4, 0x18a5,  // Offset: 1780 ~ 1787
0x18a6, 0x18a7, 0x18a8, 0x18a9, 0x18aa, 0x18ab, 0x18ac, 0x18ad,  // Offset: 1788 ~ 178f
0x18ae, 0x18af, 0x18b0, 0x18b1, 0x18b2, 0x18b3, 0x18b4, 0x18b5,  // Offset: 1790 ~ 1797
0x18b6, 0x18b7, 0x18b8, 0x18b9, 0x18ba, 0x18bb, 0x18bc, 0x18bd,  // Offset: 1798 ~ 179f
0x18be, 0x18bf, 0x18c0, 0x18c1, 0x18c2, 0x18c3, 0x18c4, 0x18c5,  // Offset: 17a0 ~ 17a7
0x18c6, 0x18c7, 0x18c8, 0x18c9, 0x18ca, 0x18cb, 0x18cc, 0x18cd,  // Offset: 17a8 ~ 17af
0x18ce, 0x18cf, 0x18d0, 0x18d1, 0x18d2, 0x18d3, 0x18d4, 0x18d5,  // Offset: 17b0 ~ 17b7
0x18d6, 0x18d7, 0x18d8, 0x18d9, 0x18da, 0x18db, 0x18dc, 0x18dd,  // Offset: 17b8 ~ 17bf
0x18de, 0x18df, 0x18e0, 0x18e1, 0x18e2, 0x18e3, 0x18e4, 0x18e5,  // Offset: 17c0 ~ 17c7
0x18e6, 0x18e7, 0x18e8, 0x18e9, 0x18ea, 0x18eb, 0x18ec, 0x18ed,  // Offset: 17c8 ~ 17cf
0x18ee, 0x18ef, 0x18f0, 0x18f1, 0x18f2, 0x18f3, 0x18f4, 0x18f5,  // Offset: 17d0 ~ 17d7
0x18f6, 0x18f7, 0x18f8, 0x18f9, 0x18fa, 0x18fb, 0x18fc, 0x18fd,  // Offset: 17d8 ~ 17df
0x18fe, 0x18ff, 0x1900, 0x1901, 0x1902, 0x1903, 0x1904, 0x1905,  // Offset: 17e0 ~ 17e7
0x1906, 0x1907, 0x1908, 0x1909, 0x190a, 0x190b, 0x190c, 0x190d,  // Offset: 17e8 ~ 17ef
0x190e, 0x190f, 0x1910, 0x1911, 0x1912, 0x1913, 0x1914, 0x1915,  // Offset: 17f0 ~ 17f7
0x1916, 0x1917, 0x1918, 0x1919, 0x191a, 0x191b, 0x191c, 0x191d,  // Offset: 17f8 ~ 17ff
0x191e, 0x191f, 0x1920, 0x1921, 0x1922, 0x1923, 0x1924, 0x1925,  // Offset: 1800 ~ 1807
0x1926, 0x1927, 0x1928, 0x1929, 0x192a, 0x192b, 0x192c, 0x192d,  // Offset: 1808 ~ 180f
0x192e, 0x192f, 0x1930, 0x1931, 0x1932, 0x1933, 0x1934, 0x1935,  // Offset: 1810 ~ 1817
0x1936, 0x1937, 0x1938, 0x1939, 0x193a, 0x193b, 0x193c, 0x193d,  // Offset: 1818 ~ 181f
0x193e, 0x193f, 0x1940, 0x1941, 0x1942, 0x1943, 0x1944, 0x1945,  // Offset: 1820 ~ 1827
0x1946, 0x1947, 0x1948, 0x1949, 0x194a, 0x194b, 0x194c, 0x194d,  // Offset: 1828 ~ 182f
0x194e, 0x194f, 0x1950, 0x1951, 0x1952, 0x1953, 0x1954, 0x1955,  // Offset: 1830 ~ 1837
0x1956, 0x1957, 0x1958, 0x1959, 0x195a, 0x195b, 0x195c, 0x195d,  // Offset: 1838 ~ 183f
0x195e, 0x195f, 0x1960, 0x1961, 0x1962, 0x1963, 0x1964, 0x1965,  // Offset: 1840 ~ 1847
0x1966, 0x1967, 0x1968, 0x1969, 0x196a, 0x196b, 0x196c, 0x196d,  // Offset: 1848 ~ 184f
0x196e, 0x196f, 0x1970, 0x1971, 0x1972, 0x1973, 0x1974, 0x1975,  // Offset: 1850 ~ 1857
0x1976, 0x1977, 0x1978, 0x1979, 0x197a, 0x197b, 0x197c, 0x197d,  // Offset: 1858 ~ 185f
0x197e, 0x197f, 0x1980, 0x1981, 0x1982, 0x1983, 0x1984, 0x1985,  // Offset: 1860 ~ 1867
0x1986, 0x1987, 0x1988, 0x1989, 0x198a, 0x198b, 0x198c, 0x198d,  // Offset: 1868 ~ 186f
0x198e, 0x198f, 0x1990, 0x1991, 0x1992, 0x1993, 0x1994, 0x1995,  // Offset: 1870 ~ 1877
0x1996, 0x1997, 0x1998, 0x1999, 0x199a, 0x199b, 0x199c, 0x199d,  // Offset: 1878 ~ 187f
0x199e, 0x199f, 0x19a0, 0x19a1, 0x19a2, 0x19a3, 0x19a4, 0x19a5,  // Offset: 1880 ~ 1887
0x19a6, 0x19a7, 0x19a8, 0x19a9, 0x19aa, 0x19ab, 0x19ac, 0x19ad,  // Offset: 1888 ~ 188f
0x19ae, 0x19af, 0x19b0, 0x19b1, 0x19b2, 0x19b3, 0x19b4, 0x19b5,  // Offset: 1890 ~ 1897
0x19b6, 0x19b7, 0x19b8, 0x19b9, 0x19ba, 0x19bb, 0x19bc, 0x19bd,  // Offset: 1898 ~ 189f
0x19be, 0x19bf, 0x19c0, 0x19c1, 0x19c2, 0x19c3, 0x19c4, 0x19c5,  // Offset: 18a0 ~ 18a7
0x19c6, 0x19c7, 0x19c8, 0x19c9, 0x19ca, 0x19cb, 0x19cc, 0x19cd,  // Offset: 18a8 ~ 18af
0x19ce, 0x19cf, 0x19d0, 0x19d1, 0x19d2, 0x19d3, 0x19d4, 0x19d5,  // Offset: 18b0 ~ 18b7
0x19d6, 0x19d7, 0x19d8, 0x19d9, 0x19da, 0x19db, 0x19dc, 0x19dd,  // Offset: 18b8 ~ 18bf
0x19de, 0x19df, 0x19e0, 0x19e1, 0x19e2, 0x19e3, 0x19e4, 0x19e5,  // Offset: 18c0 ~ 18c7
0x19e6, 0x19e7, 0x19e8, 0x19e9, 0x19ea, 0x19eb, 0x19ec, 0x19ed,  // Offset: 18c8 ~ 18cf
0x19ee, 0x19ef, 0x19f0, 0x19f1, 0x19f2, 0x19f3, 0x19f4, 0x19f5,  // Offset: 18d0 ~ 18d7
0x19f6, 0x19f7, 0x19f8, 0x19f9, 0x19fa, 0x19fb, 0x19fc, 0x19fd,  // Offset: 18d8 ~ 18df
0x19fe, 0x19ff, 0x1a00, 0x1a01, 0x1a02, 0x1a03, 0x1a04, 0x1a05,  // Offset: 18e0 ~ 18e7
0x1a06, 0x1a07, 0x1a08, 0x1a09, 0x1a0a, 0x1a0b, 0x1a0c, 0x1a0d,  // Offset: 18e8 ~ 18ef
0x1a0e, 0x1a0f, 0x1a10, 0x1a11, 0x1a12, 0x1a13, 0x1a14, 0x1a15,  // Offset: 18f0 ~ 18f7
0x1a16, 0x1a17, 0x1a18, 0x1a19, 0x1a1a, 0x1a1b, 0x1a1c, 0x1a1d,  // Offset: 18f8 ~ 18ff
0x1a1e, 0x1a1f, 0x1a20, 0x1a21, 0x1a22, 0x1a23, 0x1a24, 0x1a25,  // Offset: 1900 ~ 1907
0x1a26, 0x1a27, 0x1a28, 0x1a29, 0x1a2a, 0x1a2b, 0x1a2c, 0x1a2d,  // Offset: 1908 ~ 190f
0x1a2e, 0x1a2f, 0x1a30, 0x1a31, 0x1a32, 0x1a33, 0x1a34, 0x1a35,  // Offset: 1910 ~ 1917
0x1a36, 0x1a37, 0x1a38, 0x1a39, 0x1a3a, 0x1a3b, 0x1a3c, 0x1a3d,  // Offset: 1918 ~ 191f
0x1a3e, 0x1a3f, 0x1a40, 0x1a41, 0x1a42, 0x1a43, 0x1a44, 0x1a45,  // Offset: 1920 ~ 1927
0x1a46, 0x1a47, 0x1a48, 0x1a49, 0x1a4a, 0x1a4b, 0x1a4c, 0x1a4d,  // Offset: 1928 ~ 192f
0x1a4e, 0x1a4f, 0x1a50, 0x1a51, 0x1a52, 0x1a53, 0x1a54, 0x1a55,  // Offset: 1930 ~ 1937
0x1a56, 0x1a57, 0x1a58, 0x1a59, 0x1a5a, 0x1a5b, 0x1a5c, 0x1a5d,  // Offset: 1938 ~ 193f
0x1a5e, 0x1a5f, 0x1a60, 0x1a61, 0x1a62, 0x1a63, 0x1a64, 0x1a65,  // Offset: 1940 ~ 1947
0x1a66, 0x1a67, 0x1a68, 0x1a69, 0x1a6a, 0x1a6b, 0x1a6c, 0x1a6d,  // Offset: 1948 ~ 194f
0x1a6e, 0x1a6f, 0x1a70, 0x1a71, 0x1a72, 0x1a73, 0x1a74, 0x1a75,  // Offset: 1950 ~ 1957
0x1a76, 0x1a77, 0x1a78, 0x1a79, 0x1a7a, 0x1a7b, 0x1a7c, 0x1a7d,  // Offset: 1958 ~ 195f
0x1a7e, 0x1a7f, 0x1a80, 0x1a81, 0x1a82, 0x1a83, 0x1a84, 0x1a85,  // Offset: 1960 ~ 1967
0x1a86, 0x1a87, 0x1a88, 0x1a89, 0x1a8a, 0x1a8b, 0x1a8c, 0x1a8d,  // Offset: 1968 ~ 196f
0x1a8e, 0x1a8f, 0x1a90, 0x1a91, 0x1a92, 0x1a93, 0x1a94, 0x1a95,  // Offset: 1970 ~ 1977
0x1a96, 0x1a97, 0x1a98, 0x1a99, 0x1a9a, 0x1a9b, 0x1a9c, 0x1a9d,  // Offset: 1978 ~ 197f
0x1a9e, 0x1a9f, 0x1aa0, 0x1aa1, 0x1aa2, 0x1aa3, 0x1aa4, 0x1aa5,  // Offset: 1980 ~ 1987
0x1aa6, 0x1aa7, 0x1aa8, 0x1aa9, 0x1aaa, 0x1aab, 0x1aac, 0x1aad,  // Offset: 1988 ~ 198f
0x1aae, 0x1aaf, 0x1ab0, 0x1ab1, 0x1ab2, 0x1ab3, 0x1ab4, 0x1ab5,  // Offset: 1990 ~ 1997
0x1ab6, 0x1ab7, 0x1ab8, 0x1ab9, 0x1aba, 0x1abb, 0x1abc, 0x1abd,  // Offset: 1998 ~ 199f
0x1abe, 0x1abf, 0x1ac0, 0x1ac1, 0x1ac2, 0x1ac3, 0x1ac4, 0x1ac5,  // Offset: 19a0 ~ 19a7
0x1ac6, 0x1ac7, 0x1ac8, 0x1ac9, 0x1aca, 0x1acb, 0x1acc, 0x1acd,  // Offset: 19a8 ~ 19af
0x1ace, 0x1acf, 0x1ad0, 0x1ad1, 0x1ad2, 0x1ad3, 0x1ad4, 0x1ad5,  // Offset: 19b0 ~ 19b7
0x1ad6, 0x1ad7, 0x1ad8, 0x1ad9, 0x1ada, 0x1adb, 0x1adc, 0x1add,  // Offset: 19b8 ~ 19bf
0x1ade, 0x1adf, 0x1ae0, 0x1ae1, 0x1ae2, 0x1ae3, 0x1ae4, 0x1ae5,  // Offset: 19c0 ~ 19c7
0x1ae6, 0x1ae7, 0x1ae8, 0x1ae9, 0x1aea, 0x1aeb, 0x1aec, 0x1aed,  // Offset: 19c8 ~ 19cf
0x1aee, 0x1aef, 0x1af0, 0x1af1, 0x1af2, 0x1af3, 0x1af4, 0x1af5,  // Offset: 19d0 ~ 19d7
0x1af6, 0x1af7, 0x1af8, 0x1af9, 0x1afa, 0x1afb, 0x1afc, 0x1afd,  // Offset: 19d8 ~ 19df
0x1afe, 0x1aff, 0x1b00, 0x1b01, 0x1b02, 0x1b03, 0x1b04, 0x1b05,  // Offset: 19e0 ~ 19e7
0x1b06, 0x1b07, 0x1b08, 0x1b09, 0x1b0a, 0x1b0b, 0x1b0c, 0x1b0d,  // Offset: 19e8 ~ 19ef
0x1b0e, 0x1b0f, 0x1b10, 0x1b11, 0x1b12, 0x1b13, 0x1b14, 0x1b15,  // Offset: 19f0 ~ 19f7
0x1b16, 0x1b17, 0x1b18, 0x1b19, 0x1b1a, 0x1b1b, 0x1b1c, 0x1b1d,  // Offset: 19f8 ~ 19ff
0x1b1e, 0x1b1f, 0x1b20, 0x1b21, 0x1b22, 0x1b23, 0x1b24, 0x1b25,  // Offset: 1a00 ~ 1a07
0x1b26, 0x1b27, 0x1b28, 0x1b29, 0x1b2a, 0x1b2b, 0x1b2c, 0x1b2d,  // Offset: 1a08 ~ 1a0f
0x1b2e, 0x1b2f, 0x1b30, 0x1b31, 0x1b32, 0x1b33, 0x1b34, 0x1b35,  // Offset: 1a10 ~ 1a17
0x1b36, 0x1b37, 0x1b38, 0x1b39, 0x1b3a, 0x1b3b, 0x1b3c, 0x1b3d,  // Offset: 1a18 ~ 1a1f
0x1b3e, 0x1b3f, 0x1b40, 0x1b41, 0x1b42, 0x1b43, 0x1b44, 0x1b45,  // Offset: 1a20 ~ 1a27
0x1b46, 0x1b47, 0x1b48, 0x1b49, 0x1b4a, 0x1b4b, 0x1b4c, 0x1b4d,  // Offset: 1a28 ~ 1a2f
0x1b4e, 0x1b4f, 0x1b50, 0x1b51, 0x1b52, 0x1b53, 0x1b54, 0x1b55,  // Offset: 1a30 ~ 1a37
0x1b56, 0x1b57, 0x1b58, 0x1b59, 0x1b5a, 0x1b5b, 0x1b5c, 0x1b5d,  // Offset: 1a38 ~ 1a3f
0x1b5e, 0x1b5f, 0x1b60, 0x1b61, 0x1b62, 0x1b63, 0x1b64, 0x1b65,  // Offset: 1a40 ~ 1a47
0x1b66, 0x1b67, 0x1b68, 0x1b69, 0x1b6a, 0x1b6b, 0x1b6c, 0x1b6d,  // Offset: 1a48 ~ 1a4f
0x1b6e, 0x1b6f, 0x1b70, 0x1b71, 0x1b72, 0x1b73, 0x1b74, 0x1b75,  // Offset: 1a50 ~ 1a57
0x1b76, 0x1b77, 0x1b78, 0x1b79, 0x1b7a, 0x1b7b, 0x1b7c, 0x1b7d,  // Offset: 1a58 ~ 1a5f
0x1b7e, 0x1b7f, 0x1b80, 0x1b81, 0x1b82, 0x1b83, 0x1b84, 0x1b85,  // Offset: 1a60 ~ 1a67
0x1b86, 0x1b87, 0x1b88, 0x1b89, 0x1b8a, 0x1b8b, 0x1b8c, 0x1b8d,  // Offset: 1a68 ~ 1a6f
0x1b8e, 0x1b8f, 0x1b90, 0x1b91, 0x1b92, 0x1b93, 0x1b94, 0x1b95,  // Offset: 1a70 ~ 1a77
0x1b96, 0x1b97, 0x1b98, 0x1b99, 0x1b9a, 0x1b9b, 0x1b9c, 0x1b9d,  // Offset: 1a78 ~ 1a7f
0x1b9e, 0x1b9f, 0x1ba0, 0x1ba1, 0x1ba2, 0x1ba3, 0x1ba4, 0x1ba5,  // Offset: 1a80 ~ 1a87
0x1ba6, 0x1ba7, 0x1ba8, 0x1ba9, 0x1baa, 0x1bab, 0x1bac, 0x1bad,  // Offset: 1a88 ~ 1a8f
0x1bae, 0x1baf, 0x1bb0, 0x1bb1, 0x1bb2, 0x1bb3, 0x1bb4, 0x1bb5,  // Offset: 1a90 ~ 1a97
0x1bb6, 0x1bb7, 0x1bb8, 0x1bb9, 0x1bba, 0x1bbb, 0x1bbc, 0x1bbd,  // Offset: 1a98 ~ 1a9f
0x1bbe, 0x1bbf, 0x1bc0, 0x1bc1, 0x1bc2, 0x1bc3, 0x1bc4, 0x1bc5,  // Offset: 1aa0 ~ 1aa7
0x1bc6, 0x1bc7, 0x1bc8, 0x1bc9, 0x1bca, 0x1bcb, 0x1bcc, 0x1bcd,  // Offset: 1aa8 ~ 1aaf
0x1bce, 0x1bcf, 0x1bd0, 0x1bd1, 0x1bd2, 0x1bd3, 0x1bd4, 0x1bd5,  // Offset: 1ab0 ~ 1ab7
0x1bd6, 0x1bd7, 0x1bd8, 0x1bd9, 0x1bda, 0x1bdb, 0x1bdc, 0x1bdd,  // Offset: 1ab8 ~ 1abf
0x1bde, 0x1bdf, 0x1be0, 0x1be1, 0x1be2, 0x1be3, 0x1be4, 0x1be5,  // Offset: 1ac0 ~ 1ac7
0x1be6, 0x1be7, 0x1be8, 0x1be9, 0x1bea, 0x1beb, 0x1bec, 0x1bed,  // Offset: 1ac8 ~ 1acf
0x1bee, 0x1bef, 0x1bf0, 0x1bf1, 0x1bf2, 0x1bf3, 0x1bf4, 0x1bf5,  // Offset: 1ad0 ~ 1ad7
0x1bf6, 0x1bf7, 0x1bf8, 0x1bf9, 0x1bfa, 0x1bfb, 0x1bfc, 0x1bfd,  // Offset: 1ad8 ~ 1adf
0x1bfe, 0x1bff, 0x1c00, 0x1c01, 0x1c02, 0x1c03, 0x1c04, 0x1c05,  // Offset: 1ae0 ~ 1ae7
0x1c06, 0x1c07, 0x1c08, 0x1c09, 0x1c0a, 0x1c0b, 0x1c0c, 0x1c0d,  // Offset: 1ae8 ~ 1aef
0x1c0e, 0x1c0f, 0x1c10, 0x1c11, 0x1c12, 0x1c13, 0x1c14, 0x1c15,  // Offset: 1af0 ~ 1af7
0x1c16, 0x1c17, 0x1c18, 0x1c19, 0x1c1a, 0x1c1b, 0x1c1c, 0x1c1d,  // Offset: 1af8 ~ 1aff
0x1c1e, 0x1c1f, 0x1c20, 0x1c21, 0x1c22, 0x1c23, 0x1c24, 0x1c25,  // Offset: 1b00 ~ 1b07
0x1c26, 0x1c27, 0x1c28, 0x1c29, 0x1c2a, 0x1c2b, 0x1c2c, 0x1c2d,  // Offset: 1b08 ~ 1b0f
0x1c2e, 0x1c2f, 0x1c30, 0x1c31, 0x1c32, 0x1c33, 0x1c34, 0x1c35,  // Offset: 1b10 ~ 1b17
0x1c36, 0x1c37, 0x1c38, 0x1c39, 0x1c3a, 0x1c3b, 0x1c3c, 0x1c3d,  // Offset: 1b18 ~ 1b1f
0x1c3e, 0x1c3f, 0x1c40, 0x1c41, 0x1c42, 0x1c43, 0x1c44, 0x1c45,  // Offset: 1b20 ~ 1b27
0x1c46, 0x1c47, 0x1c48, 0x1c49, 0x1c4a, 0x1c4b, 0x1c4c, 0x1c4d,  // Offset: 1b28 ~ 1b2f
0x1c4e, 0x1c4f, 0x1c50, 0x1c51, 0x1c52, 0x1c53, 0x1c54, 0x1c55,  // Offset: 1b30 ~ 1b37
0x1c56, 0x1c57, 0x1c58, 0x1c59, 0x1c5a, 0x1c5b, 0x1c5c, 0x1c5d,  // Offset: 1b38 ~ 1b3f
0x1c5e, 0x1c5f, 0x1c60, 0x1c61, 0x1c62, 0x1c63, 0x1c64, 0x1c65,  // Offset: 1b40 ~ 1b47
0x1c66, 0x1c67, 0x1c68, 0x1c69, 0x1c6a, 0x1c6b, 0x1c6c, 0x1c6d,  // Offset: 1b48 ~ 1b4f
0x1c6e, 0x1c6f, 0x1c70, 0x1c71, 0x1c72, 0x1c73, 0x1c74, 0x1c75,  // Offset: 1b50 ~ 1b57
0x1c76, 0x1c77, 0x1c78, 0x1c79, 0x1c7a, 0x1c7b, 0x1c7c, 0x1c7d,  // Offset: 1b58 ~ 1b5f
0x1c7e, 0x1c7f, 0x1c80, 0x1c81, 0x1c82, 0x1c83, 0x1c84, 0x1c85,  // Offset: 1b60 ~ 1b67
0x1c86, 0x1c87, 0x1c88, 0x1c89, 0x1c8a, 0x1c8b, 0x1c8c, 0x1c8d,  // Offset: 1b68 ~ 1b6f
0x1c8e, 0x1c8f, 0x1c90, 0x1c91, 0x1c92, 0x1c93, 0x1c94, 0x1c95,  // Offset: 1b70 ~ 1b77
0x1c96, 0x1c97, 0x1c98, 0x1c99, 0x1c9a, 0x1c9b, 0x1c9c, 0x1c9d,  // Offset: 1b78 ~ 1b7f
0x1c9e, 0x1c9f, 0x1ca0, 0x1ca1, 0x1ca2, 0x1ca3, 0x1ca4, 0x1ca5,  // Offset: 1b80 ~ 1b87
0x1ca6, 0x1ca7, 0x1ca8, 0x1ca9, 0x1caa, 0x1cab, 0x1cac, 0x1cad,  // Offset: 1b88 ~ 1b8f
0x1cae, 0x1caf, 0x1cb0, 0x1cb1, 0x1cb2, 0x1cb3, 0x1cb4, 0x1cb5,  // Offset: 1b90 ~ 1b97
0x1cb6, 0x1cb7, 0x1cb8, 0x1cb9, 0x1cba, 0x1cbb, 0x1cbc, 0x1cbd,  // Offset: 1b98 ~ 1b9f
0x1cbe, 0x1cbf, 0x1cc0, 0x1cc1, 0x1cc2, 0x1cc3, 0x1cc4, 0x1cc5,  // Offset: 1ba0 ~ 1ba7
0x1cc6, 0x1cc7, 0x1cc8, 0x1cc9, 0x1cca, 0x1ccb, 0x1ccc, 0x1ccd,  // Offset: 1ba8 ~ 1baf
0x1cce, 0x1ccf, 0x1cd0, 0x1cd1, 0x1cd2, 0x1cd3, 0x1cd4, 0x1cd5,  // Offset: 1bb0 ~ 1bb7
0x1cd6, 0x1cd7, 0x1cd8, 0x1cd9, 0x1cda, 0x1cdb, 0x1cdc, 0x1cdd,  // Offset: 1bb8 ~ 1bbf
0x1cde, 0x1cdf, 0x1ce0, 0x1ce1, 0x1ce2, 0x1ce3, 0x1ce4, 0x1ce5,  // Offset: 1bc0 ~ 1bc7
0x1ce6, 0x1ce7, 0x1ce8, 0x1ce9, 0x1cea, 0x1ceb, 0x1cec, 0x1ced,  // Offset: 1bc8 ~ 1bcf
0x1cee, 0x1cef, 0x1cf0, 0x1cf1, 0x1cf2, 0x1cf3, 0x1cf4, 0x1cf5,  // Offset: 1bd0 ~ 1bd7
0x1cf6, 0x1cf7, 0x1cf8, 0x1cf9, 0x1cfa, 0x1cfb, 0x1cfc, 0x1cfd,  // Offset: 1bd8 ~ 1bdf
0x1cfe, 0x1cff, 0x1d00, 0x1d01, 0x1d02, 0x1d03, 0x1d04, 0x1d05,  // Offset: 1be0 ~ 1be7
0x1d06, 0x1d07, 0x1d08, 0x1d09, 0x1d0a, 0x1d0b, 0x1d0c, 0x1d0d,  // Offset: 1be8 ~ 1bef
0x1d0e, 0x1d0f, 0x1d10, 0x1d11, 0x1d12, 0x1d13, 0x1d14, 0x1d15,  // Offset: 1bf0 ~ 1bf7
0x1d16, 0x1d17, 0x1d18, 0x1d19, 0x1d1a, 0x1d1b, 0x1d1c, 0x1d1d,  // Offset: 1bf8 ~ 1bff
0x1d1e, 0x1d1f, 0x1d20, 0x1d21, 0x1d22, 0x1d23, 0x1d24, 0x1d25,  // Offset: 1c00 ~ 1c07
0x1d26, 0x1d27, 0x1d28, 0x1d29, 0x1d2a, 0x1d2b, 0x1d2c, 0x1d2d,  // Offset: 1c08 ~ 1c0f
0x1d2e, 0x1d2f, 0x1d30, 0x1d31, 0x1d32, 0x1d33, 0x1d34, 0x1d35,  // Offset: 1c10 ~ 1c17
0x1d36, 0x1d37, 0x1d38, 0x1d39, 0x1d3a, 0x1d3b, 0x1d3c, 0x1d3d,  // Offset: 1c18 ~ 1c1f
0x1d3e, 0x1d3f, 0x1d40, 0x1d41, 0x1d42, 0x1d43, 0x1d44, 0x1d45,  // Offset: 1c20 ~ 1c27
0x1d46, 0x1d47, 0x1d48, 0x1d49, 0x1d4a, 0x1d4b, 0x1d4c, 0x1d4d,  // Offset: 1c28 ~ 1c2f
0x1d4e, 0x1d4f, 0x1d50, 0x1d51, 0x1d52, 0x1d53, 0x1d54, 0x1d55,  // Offset: 1c30 ~ 1c37
0x1d56, 0x1d57, 0x1d58, 0x1d59, 0x1d5a, 0x1d5b, 0x1d5c, 0x1d5d,  // Offset: 1c38 ~ 1c3f
0x1d5e, 0x1d5f, 0x1d60, 0x1d61, 0x1d62, 0x1d63, 0x1d64, 0x1d65,  // Offset: 1c40 ~ 1c47
0x1d66, 0x1d67, 0x1d68, 0x1d69, 0x1d6a, 0x1d6b, 0x1d6c, 0x1d6d,  // Offset: 1c48 ~ 1c4f
0x1d6e, 0x1d6f, 0x1d70, 0x1d71, 0x1d72, 0x1d73, 0x1d74, 0x1d75,  // Offset: 1c50 ~ 1c57
0x1d76, 0x1d77, 0x1d78, 0x1d79, 0x1d7a, 0x1d7b, 0x1d7c, 0x1d7d,  // Offset: 1c58 ~ 1c5f
0x1d7e, 0x1d7f, 0x1d80, 0x1d81, 0x1d82, 0x1d83, 0x1d84, 0x1d85,  // Offset: 1c60 ~ 1c67
0x1d86, 0x1d87, 0x1d88, 0x1d89, 0x1d8a, 0x1d8b, 0x1d8c, 0x1d8d,  // Offset: 1c68 ~ 1c6f
0x1d8e, 0x1d8f, 0x1d90, 0x1d91, 0x1d92, 0x1d93, 0x1d94, 0x1d95,  // Offset: 1c70 ~ 1c77
0x1d96, 0x1d97, 0x1d98, 0x1d99, 0x1d9a, 0x1d9b, 0x1d9c, 0x1d9d,  // Offset: 1c78 ~ 1c7f
0x1d9e, 0x1d9f, 0x1da0, 0x1da1, 0x1da2, 0x1da3, 0x1da4, 0x1da5,  // Offset: 1c80 ~ 1c87
0x1da6, 0x1da7, 0x1da8, 0x1da9, 0x1daa, 0x1dab, 0x1dac, 0x1dad,  // Offset: 1c88 ~ 1c8f
0x1dae, 0x1daf, 0x1db0, 0x1db1, 0x1db2, 0x1db3, 0x1db4, 0x1db5,  // Offset: 1c90 ~ 1c97
0x1db6, 0x1db7, 0x1db8, 0x1db9, 0x1dba, 0x1dbb, 0x1dbc, 0x1dbd,  // Offset: 1c98 ~ 1c9f
0x1dbe, 0x1dbf, 0x1dc0, 0x1dc1, 0x1dc2, 0x1dc3, 0x1dc4, 0x1dc5,  // Offset: 1ca0 ~ 1ca7
0x1dc6, 0x1dc7, 0x1dc8, 0x1dc9, 0x1dca, 0x1dcb, 0x1dcc, 0x1dcd,  // Offset: 1ca8 ~ 1caf
0x1dce, 0x1dcf, 0x1dd0, 0x1dd1, 0x1dd2, 0x1dd3, 0x1dd4, 0x1dd5,  // Offset: 1cb0 ~ 1cb7
0x1dd6, 0x1dd7, 0x1dd8, 0x1dd9, 0x1dda, 0x1ddb, 0x1ddc, 0x1ddd,  // Offset: 1cb8 ~ 1cbf
0x1dde, 0x1ddf, 0x1de0, 0x1de1, 0x1de2, 0x1de3, 0x1de4, 0x1de5,  // Offset: 1cc0 ~ 1cc7
0x1de6, 0x1de7, 0x1de8, 0x1de9, 0x1dea, 0x1deb, 0x1dec, 0x1ded,  // Offset: 1cc8 ~ 1ccf
0x1dee, 0x1def, 0x1df0, 0x1df1, 0x1df2, 0x1df3, 0x1df4, 0x1df5,  // Offset: 1cd0 ~ 1cd7
0x1df6, 0x1df7, 0x1df8, 0x1df9, 0x1dfa, 0x1dfb, 0x1dfc, 0x1dfd,  // Offset: 1cd8 ~ 1cdf
0x1dfe, 0x1dff, 0x1e00, 0x1e01, 0x1e02, 0x1e03, 0x1e04, 0x1e05,  // Offset: 1ce0 ~ 1ce7
0x1e06, 0x1e07, 0x1e08, 0x1e09, 0x1e0a, 0x1e0b, 0x1e0c, 0x1e0d,  // Offset: 1ce8 ~ 1cef
0x1e0e, 0x1e0f, 0x1e10, 0x1e11, 0x1e12, 0x1e13, 0x1e14, 0x1e15,  // Offset: 1cf0 ~ 1cf7
0x1e16, 0x1e17, 0x1e18, 0x1e19, 0x1e1a, 0x1e1b, 0x1e1c, 0x1e1d,  // Offset: 1cf8 ~ 1cff
0x1e1e, 0x1e1f, 0x1e20, 0x1e21, 0x1e22, 0x1e23, 0x1e24, 0x1e25,  // Offset: 1d00 ~ 1d07
0x1e26, 0x1e27, 0x1e28, 0x1e29, 0x1e2a, 0x1e2b, 0x1e2c, 0x1e2d,  // Offset: 1d08 ~ 1d0f
0x1e2e, 0x1e2f, 0x1e30, 0x1e31, 0x1e32, 0x1e33, 0x1e34, 0x1e35,  // Offset: 1d10 ~ 1d17
0x1e36, 0x1e37, 0x1e38, 0x1e39, 0x1e3a, 0x1e3b, 0x1e3c, 0x1e3d,  // Offset: 1d18 ~ 1d1f
0x1e3e, 0x1e3f, 0x1e40, 0x1e41, 0x1e42, 0x1e43, 0x1e44, 0x1e45,  // Offset: 1d20 ~ 1d27
0x1e46, 0x1e47, 0x1e48, 0x1e49, 0x1e4a, 0x1e4b, 0x1e4c, 0x1e4d,  // Offset: 1d28 ~ 1d2f
0x1e4e, 0x1e4f, 0x1e50, 0x1e51, 0x1e52, 0x1e53, 0x1e54, 0x1e55,  // Offset: 1d30 ~ 1d37
0x1e56, 0x1e57, 0x1e58, 0x1e59, 0x1e5a, 0x1e5b, 0x1e5c, 0x1e5d,  // Offset: 1d38 ~ 1d3f
0x1e5e, 0x1e5f, 0x1e60, 0x1e61, 0x1e62, 0x1e63, 0x1e64, 0x1e65,  // Offset: 1d40 ~ 1d47
0x1e66, 0x1e67, 0x1e68, 0x1e69, 0x1e6a, 0x1e6b, 0x1e6c, 0x1e6d,  // Offset: 1d48 ~ 1d4f
0x1e6e, 0x1e6f, 0x1e70, 0x1e71, 0x1e72, 0x1e73, 0x1e74, 0x1e75,  // Offset: 1d50 ~ 1d57
0x1e76, 0x1e77, 0x1e78, 0x1e79, 0x1e7a, 0x1e7b, 0x1e7c, 0x1e7d,  // Offset: 1d58 ~ 1d5f
0x1e7e, 0x1e7f, 0x1e80, 0x1e81, 0x1e82, 0x1e83, 0x1e84, 0x1e85,  // Offset: 1d60 ~ 1d67
0x1e86, 0x1e87, 0x1e88, 0x1e89, 0x1e8a, 0x1e8b, 0x1e8c, 0x1e8d,  // Offset: 1d68 ~ 1d6f
0x1e8e, 0x1e8f, 0x1e90, 0x1e91, 0x1e92, 0x1e93, 0x1e94, 0x1e95,  // Offset: 1d70 ~ 1d77
0x1e96, 0x1e97, 0x1e98, 0x1e99, 0x1e9a, 0x1e9b, 0x1e9c, 0x1e9d,  // Offset: 1d78 ~ 1d7f
0x1e9e, 0x1e9f, 0x1ea0, 0x1ea1, 0x1ea2, 0x1ea3, 0x1ea4, 0x1ea5,  // Offset: 1d80 ~ 1d87
0x1ea6, 0x1ea7, 0x1ea8, 0x1ea9, 0x1eaa, 0x1eab, 0x1eac, 0x1ead,  // Offset: 1d88 ~ 1d8f
0x1eae, 0x1eaf, 0x1eb0, 0x1eb1, 0x1eb2, 0x1eb3, 0x1eb4, 0x1eb5,  // Offset: 1d90 ~ 1d97
0x1eb6, 0x1eb7, 0x1eb8, 0x1eb9, 0x1eba, 0x1ebb, 0x1ebc, 0x1ebd,  // Offset: 1d98 ~ 1d9f
0x1ebe, 0x1ebf, 0x1ec0, 0x1ec1, 0x1ec2, 0x1ec3, 0x1ec4, 0x1ec5,  // Offset: 1da0 ~ 1da7
0x1ec6, 0x1ec7, 0x1ec8, 0x1ec9, 0x1eca, 0x1ecb, 0x1ecc, 0x1ecd,  // Offset: 1da8 ~ 1daf
0x1ece, 0x1ecf, 0x1ed0, 0x1ed1, 0x1ed2, 0x1ed3, 0x1ed4, 0x1ed5,  // Offset: 1db0 ~ 1db7
0x1ed6, 0x1ed7, 0x1ed8, 0x1ed9, 0x1eda, 0x1edb, 0x1edc, 0x1edd,  // Offset: 1db8 ~ 1dbf
0x1ede, 0x1edf, 0x1ee0, 0x1ee1, 0x1ee2, 0x1ee3, 0x1ee4, 0x1ee5,  // Offset: 1dc0 ~ 1dc7
0x1ee6, 0x1ee7, 0x1ee8, 0x1ee9, 0x1eea, 0x1eeb, 0x1eec, 0x1eed,  // Offset: 1dc8 ~ 1dcf
0x1eee, 0x1eef, 0x1ef0, 0x1ef1, 0x1ef2, 0x1ef3, 0x1ef4, 0x1ef5,  // Offset: 1dd0 ~ 1dd7
0x1ef6, 0x1ef7, 0x1ef8, 0x1ef9, 0x1efa, 0x1efb, 0x1efc, 0x1efd,  // Offset: 1dd8 ~ 1ddf
0x1efe, 0x1eff, 0x1f00, 0x1f01, 0x1f02, 0x1f03, 0x1f04, 0x1f05,  // Offset: 1de0 ~ 1de7
0x1f06, 0x1f07, 0x1f08, 0x1f09, 0x1f0a, 0x1f0b, 0x1f0c, 0x1f0d,  // Offset: 1de8 ~ 1def
0x1f0e, 0x1f0f, 0x1f10, 0x1f11, 0x1f12, 0x1f13, 0x1f14, 0x1f15,  // Offset: 1df0 ~ 1df7
0x1f16, 0x1f17, 0x1f18, 0x1f19, 0x1f1a, 0x1f1b, 0x1f1c, 0x1f1d,  // Offset: 1df8 ~ 1dff
0x1f1e, 0x1f1f, 0x1f20, 0x1f21, 0x1f22, 0x1f23, 0x1f24, 0x1f25,  // Offset: 1e00 ~ 1e07
0x1f26, 0x1f27, 0x1f28, 0x1f29, 0x1f2a, 0x1f2b, 0x1f2c, 0x1f2d,  // Offset: 1e08 ~ 1e0f
0x1f2e, 0x1f2f, 0x1f30, 0x1f31, 0x1f32, 0x1f33, 0x1f34, 0x1f35,  // Offset: 1e10 ~ 1e17
0x1f36, 0x1f37, 0x1f38, 0x1f39, 0x1f3a, 0x1f3b, 0x1f3c, 0x1f3d,  // Offset: 1e18 ~ 1e1f
0x1f3e, 0x1f3f, 0x1f40, 0x1f41, 0x1f42, 0x1f43, 0x1f44, 0x1f45,  // Offset: 1e20 ~ 1e27
0x1f46, 0x1f47, 0x1f48, 0x1f49, 0x1f4a, 0x1f4b, 0x1f4c, 0x1f4d,  // Offset: 1e28 ~ 1e2f
0x1f4e, 0x1f4f, 0x1f50, 0x1f51, 0x1f52, 0x1f53, 0x1f54, 0x1f55,  // Offset: 1e30 ~ 1e37
0x1f56, 0x1f57, 0x1f58, 0x1f59, 0x1f5a, 0x1f5b, 0x1f5c, 0x1f5d,  // Offset: 1e38 ~ 1e3f
0x1f5e, 0x1f5f, 0x1f60, 0x1f61, 0x1f62, 0x1f63, 0x1f64, 0x1f65,  // Offset: 1e40 ~ 1e47
0x1f66, 0x1f67, 0x1f68, 0x1f69, 0x1f6a, 0x1f6b, 0x1f6c, 0x1f6d,  // Offset: 1e48 ~ 1e4f
0x1f6e, 0x1f6f, 0x1f70, 0x1f71, 0x1f72, 0x1f73, 0x1f74, 0x1f75,  // Offset: 1e50 ~ 1e57
0x1f76, 0x1f77, 0x1f78, 0x1f79, 0x1f7a, 0x1f7b, 0x1f7c, 0x1f7d,  // Offset: 1e58 ~ 1e5f
0x1f7e, 0x1f7f, 0x1f80, 0x1f81, 0x1f82, 0x1f83, 0x1f84, 0x1f85,  // Offset: 1e60 ~ 1e67
0x1f86, 0x1f87, 0x1f88, 0x1f89, 0x1f8a, 0x1f8b, 0x1f8c, 0x1f8d,  // Offset: 1e68 ~ 1e6f
0x1f8e, 0x1f8f, 0x1f90, 0x1f91, 0x1f92, 0x1f93, 0x1f94, 0x1f95,  // Offset: 1e70 ~ 1e77
0x1f96, 0x1f97, 0x1f98, 0x1f99, 0x1f9a, 0x1f9b, 0x1f9c, 0x1f9d,  // Offset: 1e78 ~ 1e7f
0x1f9e, 0x1f9f, 0x1fa0, 0x1fa1, 0x1fa2, 0x1fa3, 0x1fa4, 0x1fa5,  // Offset: 1e80 ~ 1e87
0x1fa6, 0x1fa7, 0x1fa8, 0x1fa9, 0x1faa, 0x1fab, 0x1fac, 0x1fad,  // Offset: 1e88 ~ 1e8f
0x1fae, 0x1faf, 0x1fb0, 0x1fb1, 0x1fb2, 0x1fb3, 0x1fb4, 0x1fb5,  // Offset: 1e90 ~ 1e97
0x1fb6, 0x1fb7, 0x1fb8, 0x1fb9, 0x1fba, 0x1fbb, 0x1fbc, 0x1fbd,  // Offset: 1e98 ~ 1e9f
0x1fbe, 0x1fbf, 0x1fc0, 0x1fc1, 0x1fc2, 0x1fc3, 0x1fc4, 0x1fc5,  // Offset: 1ea0 ~ 1ea7
0x1fc6, 0x1fc7, 0x1fc8, 0x1fc9, 0x1fca, 0x1fcb, 0x1fcc, 0x1fcd,  // Offset: 1ea8 ~ 1eaf
0x1fce, 0x1fcf, 0x1fd0, 0x1fd1, 0x1fd2, 0x1fd3, 0x1fd4, 0x1fd5,  // Offset: 1eb0 ~ 1eb7
0x1fd6, 0x1fd7, 0x1fd8, 0x1fd9, 0x1fda, 0x1fdb, 0x1fdc, 0x1fdd,  // Offset: 1eb8 ~ 1ebf
0x1fde, 0x1fdf, 0x1fe0, 0x1fe1, 0x1fe2, 0x1fe3, 0x1fe4, 0x1fe5,  // Offset: 1ec0 ~ 1ec7
0x1fe6, 0x1fe7, 0x1fe8, 0x1fe9, 0x1fea, 0x1feb, 0x1fec, 0x1fed,  // Offset: 1ec8 ~ 1ecf
0x1fee, 0x1fef, 0x1ff0, 0x1ff1, 0x1ff2, 0x1ff3, 0x1ff4, 0x1ff5,  // Offset: 1ed0 ~ 1ed7
0x1ff6, 0x1ff7, 0x1ff8, 0x1ff9, 0x1ffa, 0x1ffb, 0x1ffc, 0x1ffd,  // Offset: 1ed8 ~ 1edf
0x1ffe, 0x1fff, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005,  // Offset: 1ee0 ~ 1ee7
0x2006, 0x2007, 0x2008, 0x2009, 0x200a, 0x200b, 0x200c, 0x200d,  // Offset: 1ee8 ~ 1eef
0x200e, 0x200f, 0x2011, 0x2012, 0x2017, 0x201a, 0x201b, 0x201e,  // Offset: 1ef0 ~ 1ef7
0x201f, 0x2020, 0x2021, 0x2022, 0x2023, 0x2024, 0x2027, 0x2028,  // Offset: 1ef8 ~ 1eff
0x2029, 0x202a, 0x202b, 0x202c, 0x202d, 0x202e, 0x202f, 0x2031,  // Offset: 1f00 ~ 1f07
0x2034, 0x2036, 0x2037, 0x2038, 0x2039, 0x203a, 0x203c, 0x203d,  // Offset: 1f08 ~ 1f0f
0x203e, 0x203f, 0x2040, 0x2041, 0x2042, 0x2043, 0x2044, 0x2045,  // Offset: 1f10 ~ 1f17
0x2046, 0x2047, 0x2048, 0x2049, 0x204a, 0x204b, 0x204c, 0x204d,  // Offset: 1f18 ~ 1f1f
0x204e, 0x204f, 0x2050, 0x2051, 0x2052, 0x2053, 0x2054, 0x2055,  // Offset: 1f20 ~ 1f27
0x2056, 0x2057, 0x2058, 0x2059, 0x205a, 0x205b, 0x205c, 0x205d,  // Offset: 1f28 ~ 1f2f
0x205e, 0x205f, 0x2060, 0x2061, 0x2062, 0x2063, 0x2064, 0x2065,  // Offset: 1f30 ~ 1f37
0x2066, 0x2067, 0x2068, 0x2069, 0x206a, 0x206b, 0x206c, 0x206d,  // Offset: 1f38 ~ 1f3f
0x206e, 0x206f, 0x2070, 0x2071, 0x2072, 0x2073, 0x2074, 0x2075,  // Offset: 1f40 ~ 1f47
0x2076, 0x2077, 0x2078, 0x2079, 0x207a, 0x207b, 0x207c, 0x207d,  // Offset: 1f48 ~ 1f4f
0x207e, 0x207f, 0x2080, 0x2081, 0x2082, 0x2083, 0x2084, 0x2085,  // Offset: 1f50 ~ 1f57
0x2086, 0x2087, 0x2088, 0x2089, 0x208a, 0x208b, 0x208c, 0x208d,  // Offset: 1f58 ~ 1f5f
0x208e, 0x208f, 0x2090, 0x2091, 0x2092, 0x2093, 0x2094, 0x2095,  // Offset: 1f60 ~ 1f67
0x2096, 0x2097, 0x2098, 0x2099, 0x209a, 0x209b, 0x209c, 0x209d,  // Offset: 1f68 ~ 1f6f
0x209e, 0x209f, 0x20a0, 0x20a1, 0x20a2, 0x20a3, 0x20a4, 0x20a5,  // Offset: 1f70 ~ 1f77
0x20a6, 0x20a7, 0x20a8, 0x20a9, 0x20aa, 0x20ab, 0x20ad, 0x20ae,  // Offset: 1f78 ~ 1f7f
0x20af, 0x20b0, 0x20b1, 0x20b2, 0x20b3, 0x20b4, 0x20b5, 0x20b6,  // Offset: 1f80 ~ 1f87
0x20b7, 0x20b8, 0x20b9, 0x20ba, 0x20bb, 0x20bc, 0x20bd, 0x20be,  // Offset: 1f88 ~ 1f8f
0x20bf, 0x20c0, 0x20c1, 0x20c2, 0x20c3, 0x20c4, 0x20c5, 0x20c6,  // Offset: 1f90 ~ 1f97
0x20c7, 0x20c8, 0x20c9, 0x20ca, 0x20cb, 0x20cc, 0x20cd, 0x20ce,  // Offset: 1f98 ~ 1f9f
0x20cf, 0x20d0, 0x20d1, 0x20d2, 0x20d3, 0x20d4, 0x20d5, 0x20d6,  // Offset: 1fa0 ~ 1fa7
0x20d7, 0x20d8, 0x20d9, 0x20da, 0x20db, 0x20dc, 0x20dd, 0x20de,  // Offset: 1fa8 ~ 1faf
0x20df, 0x20e0, 0x20e1, 0x20e2, 0x20e3, 0x20e4, 0x20e5, 0x20e6,  // Offset: 1fb0 ~ 1fb7
0x20e7, 0x20e8, 0x20e9, 0x20ea, 0x20eb, 0x20ec, 0x20ed, 0x20ee,  // Offset: 1fb8 ~ 1fbf
0x20ef, 0x20f0, 0x20f1, 0x20f2, 0x20f3, 0x20f4, 0x20f5, 0x20f6,  // Offset: 1fc0 ~ 1fc7
0x20f7, 0x20f8, 0x20f9, 0x20fa, 0x20fb, 0x20fc, 0x20fd, 0x20fe,  // Offset: 1fc8 ~ 1fcf
0x20ff, 0x2100, 0x2101, 0x2102, 0x2104, 0x2106, 0x2107, 0x2108,  // Offset: 1fd0 ~ 1fd7
0x210a, 0x210b, 0x210c, 0x210d, 0x210e, 0x210f, 0x2110, 0x2111,  // Offset: 1fd8 ~ 1fdf
0x2112, 0x2113, 0x2114, 0x2115, 0x2117, 0x2118, 0x2119, 0x211a,  // Offset: 1fe0 ~ 1fe7
0x211b, 0x211c, 0x211d, 0x211e, 0x211f, 0x2120, 0x2122, 0x2123,  // Offset: 1fe8 ~ 1fef
0x2124, 0x2125, 0x2126, 0x2127, 0x2128, 0x2129, 0x212a, 0x212b,  // Offset: 1ff0 ~ 1ff7
0x212c, 0x212d, 0x212e, 0x212f, 0x2130, 0x2131, 0x2132, 0x2133,  // Offset: 1ff8 ~ 1fff
0x2134, 0x2135, 0x2136, 0x2137, 0x2138, 0x2139, 0x213a, 0x213b,  // Offset: 2000 ~ 2007
0x213c, 0x213d, 0x213e, 0x213f, 0x2140, 0x2141, 0x2142, 0x2143,  // Offset: 2008 ~ 200f
0x2144, 0x2145, 0x2146, 0x2147, 0x2148, 0x2149, 0x214a, 0x214b,  // Offset: 2010 ~ 2017
0x214c, 0x214d, 0x214e, 0x214f, 0x2150, 0x2151, 0x2152, 0x2153,  // Offset: 2018 ~ 201f
0x2154, 0x2155, 0x2156, 0x2157, 0x2158, 0x2159, 0x215a, 0x215b,  // Offset: 2020 ~ 2027
0x215c, 0x215d, 0x215e, 0x215f, 0x216c, 0x216d, 0x216e, 0x216f,  // Offset: 2028 ~ 202f
0x217a, 0x217b, 0x217c, 0x217d, 0x217e, 0x217f, 0x2180, 0x2181,  // Offset: 2030 ~ 2037
0x2182, 0x2183, 0x2184, 0x2185, 0x2186, 0x2187, 0x2188, 0x2189,  // Offset: 2038 ~ 203f
0x218a, 0x218b, 0x218c, 0x218d, 0x218e, 0x218f, 0x2194, 0x2195,  // Offset: 2040 ~ 2047
0x219a, 0x219b, 0x219c, 0x219d, 0x219e, 0x219f, 0x21a0, 0x21a1,  // Offset: 2048 ~ 204f
0x21a2, 0x21a3, 0x21a4, 0x21a5, 0x21a6, 0x21a7, 0x21a8, 0x21a9,  // Offset: 2050 ~ 2057
0x21aa, 0x21ab, 0x21ac, 0x21ad, 0x21ae, 0x21af, 0x21b0, 0x21b1,  // Offset: 2058 ~ 205f
0x21b2, 0x21b3, 0x21b4, 0x21b5, 0x21b6, 0x21b7, 0x21b8, 0x21b9,  // Offset: 2060 ~ 2067
0x21ba, 0x21bb, 0x21bc, 0x21bd, 0x21be, 0x21bf, 0x21c0, 0x21c1,  // Offset: 2068 ~ 206f
0x21c2, 0x21c3, 0x21c4, 0x21c5, 0x21c6, 0x21c7, 0x21c8, 0x21c9,  // Offset: 2070 ~ 2077
0x21ca, 0x21cb, 0x21cc, 0x21cd, 0x21ce, 0x21cf, 0x21d0, 0x21d1,  // Offset: 2078 ~ 207f
0x21d2, 0x21d3, 0x21d4, 0x21d5, 0x21d6, 0x21d7, 0x21d8, 0x21d9,  // Offset: 2080 ~ 2087
0x21da, 0x21db, 0x21dc, 0x21dd, 0x21de, 0x21df, 0x21e0, 0x21e1,  // Offset: 2088 ~ 208f
0x21e2, 0x21e3, 0x21e4, 0x21e5, 0x21e6, 0x21e7, 0x21e8, 0x21e9,  // Offset: 2090 ~ 2097
0x21ea, 0x21eb, 0x21ec, 0x21ed, 0x21ee, 0x21ef, 0x21f0, 0x21f1,  // Offset: 2098 ~ 209f
0x21f2, 0x21f3, 0x21f4, 0x21f5, 0x21f6, 0x21f7, 0x21f8, 0x21f9,  // Offset: 20a0 ~ 20a7
0x21fa, 0x21fb, 0x21fc, 0x21fd, 0x21fe, 0x21ff, 0x2200, 0x2201,  // Offset: 20a8 ~ 20af
0x2202, 0x2203, 0x2204, 0x2205, 0x2206, 0x2207, 0x2209, 0x220a,  // Offset: 20b0 ~ 20b7
0x220b, 0x220c, 0x220d, 0x220e, 0x2210, 0x2212, 0x2213, 0x2214,  // Offset: 20b8 ~ 20bf
0x2216, 0x2217, 0x2218, 0x2219, 0x221b, 0x221c, 0x2221, 0x2222,  // Offset: 20c0 ~ 20c7
0x2224, 0x2226, 0x222c, 0x222d, 0x222f, 0x2230, 0x2231, 0x2232,  // Offset: 20c8 ~ 20cf
0x2233, 0x2238, 0x2239, 0x223a, 0x223b, 0x223c, 0x223e, 0x223f,  // Offset: 20d0 ~ 20d7
0x2240, 0x2241, 0x2242, 0x2243, 0x2244, 0x2245, 0x2246, 0x2247,  // Offset: 20d8 ~ 20df
0x2249, 0x224a, 0x224b, 0x224d, 0x224e, 0x224f, 0x2250, 0x2251,  // Offset: 20e0 ~ 20e7
0x2253, 0x2254, 0x2255, 0x2256, 0x2257, 0x2258, 0x2259, 0x225a,  // Offset: 20e8 ~ 20ef
0x225b, 0x225c, 0x225d, 0x225e, 0x225f, 0x2262, 0x2263, 0x2268,  // Offset: 20f0 ~ 20f7
0x2269, 0x226a, 0x226b, 0x226c, 0x226d, 0x2270, 0x2271, 0x2272,  // Offset: 20f8 ~ 20ff
0x2273, 0x2274, 0x2275, 0x2276, 0x2277, 0x2278, 0x2279, 0x227a,  // Offset: 2100 ~ 2107
0x227b, 0x227c, 0x227d, 0x227e, 0x227f, 0x2280, 0x2281, 0x2282,  // Offset: 2108 ~ 210f
0x2283, 0x2284, 0x2285, 0x2286, 0x2287, 0x2288, 0x2289, 0x228a,  // Offset: 2110 ~ 2117
0x228b, 0x228c, 0x228d, 0x228e, 0x228f, 0x2290, 0x2291, 0x2292,  // Offset: 2118 ~ 211f
0x2293, 0x2294, 0x2296, 0x2297, 0x2298, 0x229a, 0x229b, 0x229c,  // Offset: 2120 ~ 2127
0x229d, 0x229e, 0x229f, 0x22a0, 0x22a1, 0x22a2, 0x22a3, 0x22a4,  // Offset: 2128 ~ 212f
0x22a6, 0x22a7, 0x22a8, 0x22a9, 0x22aa, 0x22ab, 0x22ac, 0x22ad,  // Offset: 2130 ~ 2137
0x22ae, 0x22af, 0x22b0, 0x22b1, 0x22b2, 0x22b3, 0x22b4, 0x22b5,  // Offset: 2138 ~ 213f
0x22b6, 0x22b7, 0x22b8, 0x22b9, 0x22ba, 0x22bb, 0x22bc, 0x22bd,  // Offset: 2140 ~ 2147
0x22be, 0x22c0, 0x22c1, 0x22c2, 0x22c3, 0x22c4, 0x22c5, 0x22c6,  // Offset: 2148 ~ 214f
0x22c7, 0x22c8, 0x22c9, 0x22ca, 0x22cb, 0x22cc, 0x22cd, 0x22ce,  // Offset: 2150 ~ 2157
0x22cf, 0x22d0, 0x22d1, 0x22d2, 0x22d3, 0x22d4, 0x22d5, 0x22d6,  // Offset: 2158 ~ 215f
0x22d7, 0x22d8, 0x22d9, 0x22da, 0x22db, 0x22dc, 0x22dd, 0x22de,  // Offset: 2160 ~ 2167
0x22df, 0x22e0, 0x22e1, 0x22e2, 0x22e3, 0x22e4, 0x22e5, 0x22e6,  // Offset: 2168 ~ 216f
0x22e7, 0x22e8, 0x22e9, 0x22ea, 0x22eb, 0x22ec, 0x22ed, 0x22ee,  // Offset: 2170 ~ 2177
0x22ef, 0x22f0, 0x22f1, 0x22f2, 0x22f3, 0x22f4, 0x22f5, 0x22f6,  // Offset: 2178 ~ 217f
0x22f7, 0x22f8, 0x22f9, 0x22fa, 0x22fb, 0x22fc, 0x22fd, 0x22fe,  // Offset: 2180 ~ 2187
0x22ff, 0x2300, 0x2301, 0x2302, 0x2303, 0x2304, 0x2305, 0x2306,  // Offset: 2188 ~ 218f
0x2307, 0x2308, 0x2309, 0x230a, 0x230b, 0x230c, 0x230d, 0x230e,  // Offset: 2190 ~ 2197
0x230f, 0x2310, 0x2311, 0x2313, 0x2314, 0x2315, 0x2316, 0x2317,  // Offset: 2198 ~ 219f
0x2318, 0x2319, 0x231a, 0x231b, 0x231c, 0x231d, 0x231e, 0x231f,  // Offset: 21a0 ~ 21a7
0x2320, 0x2321, 0x2322, 0x2323, 0x2324, 0x2325, 0x2326, 0x2327,  // Offset: 21a8 ~ 21af
0x2328, 0x2329, 0x232a, 0x232b, 0x232c, 0x232d, 0x232e, 0x232f,  // Offset: 21b0 ~ 21b7
0x2330, 0x2331, 0x2332, 0x2333, 0x2334, 0x2335, 0x2336, 0x2337,  // Offset: 21b8 ~ 21bf
0x2338, 0x2339, 0x233a, 0x233b, 0x233c, 0x233d, 0x233e, 0x233f,  // Offset: 21c0 ~ 21c7
0x2340, 0x2341, 0x2342, 0x2343, 0x2344, 0x2345, 0x2346, 0x2347,  // Offset: 21c8 ~ 21cf
0x2348, 0x2349, 0x234a, 0x234b, 0x234c, 0x234d, 0x234e, 0x234f,  // Offset: 21d0 ~ 21d7
0x2350, 0x2351, 0x2352, 0x2353, 0x2354, 0x2355, 0x2356, 0x2357,  // Offset: 21d8 ~ 21df
0x2358, 0x2359, 0x235a, 0x235b, 0x235c, 0x235d, 0x235e, 0x235f,  // Offset: 21e0 ~ 21e7
0x2360, 0x2361, 0x2362, 0x2363, 0x2364, 0x2365, 0x2366, 0x2367,  // Offset: 21e8 ~ 21ef
0x2368, 0x2369, 0x236a, 0x236b, 0x236c, 0x236d, 0x236e, 0x236f,  // Offset: 21f0 ~ 21f7
0x2370, 0x2371, 0x2372, 0x2373, 0x2374, 0x2375, 0x2376, 0x2377,  // Offset: 21f8 ~ 21ff
0x2378, 0x2379, 0x237a, 0x237b, 0x237c, 0x237d, 0x237e, 0x237f,  // Offset: 2200 ~ 2207
0x2380, 0x2381, 0x2382, 0x2383, 0x2384, 0x2385, 0x2386, 0x2387,  // Offset: 2208 ~ 220f
0x2388, 0x2389, 0x238a, 0x238b, 0x238c, 0x238d, 0x238e, 0x238f,  // Offset: 2210 ~ 2217
0x2390, 0x2391, 0x2392, 0x2393, 0x2394, 0x2395, 0x2396, 0x2397,  // Offset: 2218 ~ 221f
0x2398, 0x2399, 0x239a, 0x239b, 0x239c, 0x239d, 0x239e, 0x239f,  // Offset: 2220 ~ 2227
0x23a0, 0x23a1, 0x23a2, 0x23a3, 0x23a4, 0x23a5, 0x23a6, 0x23a7,  // Offset: 2228 ~ 222f
0x23a8, 0x23a9, 0x23aa, 0x23ab, 0x23ac, 0x23ad, 0x23ae, 0x23af,  // Offset: 2230 ~ 2237
0x23b0, 0x23b1, 0x23b2, 0x23b3, 0x23b4, 0x23b5, 0x23b6, 0x23b7,  // Offset: 2238 ~ 223f
0x23b8, 0x23b9, 0x23ba, 0x23bb, 0x23bc, 0x23bd, 0x23be, 0x23bf,  // Offset: 2240 ~ 2247
0x23c0, 0x23c1, 0x23c2, 0x23c3, 0x23c4, 0x23c5, 0x23c6, 0x23c7,  // Offset: 2248 ~ 224f
0x23c8, 0x23c9, 0x23ca, 0x23cb, 0x23cc, 0x23cd, 0x23ce, 0x23cf,  // Offset: 2250 ~ 2257
0x23d0, 0x23d1, 0x23d2, 0x23d3, 0x23d4, 0x23d5, 0x23d6, 0x23d7,  // Offset: 2258 ~ 225f
0x23d8, 0x23d9, 0x23da, 0x23db, 0x23dc, 0x23dd, 0x23de, 0x23df,  // Offset: 2260 ~ 2267
0x23e0, 0x23e1, 0x23e2, 0x23e3, 0x23e4, 0x23e5, 0x23e6, 0x23e7,  // Offset: 2268 ~ 226f
0x23e8, 0x23e9, 0x23ea, 0x23eb, 0x23ec, 0x23ed, 0x23ee, 0x23ef,  // Offset: 2270 ~ 2277
0x23f0, 0x23f1, 0x23f2, 0x23f3, 0x23f4, 0x23f5, 0x23f6, 0x23f7,  // Offset: 2278 ~ 227f
0x23f8, 0x23f9, 0x23fa, 0x23fb, 0x23fc, 0x23fd, 0x23fe, 0x23ff,  // Offset: 2280 ~ 2287
0x2400, 0x2401, 0x2402, 0x2403, 0x2404, 0x2405, 0x2406, 0x2407,  // Offset: 2288 ~ 228f
0x2408, 0x2409, 0x240a, 0x240b, 0x240c, 0x240d, 0x240e, 0x240f,  // Offset: 2290 ~ 2297
0x2410, 0x2411, 0x2412, 0x2413, 0x2414, 0x2415, 0x2416, 0x2417,  // Offset: 2298 ~ 229f
0x2418, 0x2419, 0x241a, 0x241b, 0x241c, 0x241d, 0x241e, 0x241f,  // Offset: 22a0 ~ 22a7
0x2420, 0x2421, 0x2422, 0x2423, 0x2424, 0x2425, 0x2426, 0x2427,  // Offset: 22a8 ~ 22af
0x2428, 0x2429, 0x242a, 0x242b, 0x242c, 0x242d, 0x242e, 0x242f,  // Offset: 22b0 ~ 22b7
0x2430, 0x2431, 0x2432, 0x2433, 0x2434, 0x2435, 0x2436, 0x2437,  // Offset: 22b8 ~ 22bf
0x2438, 0x2439, 0x243a, 0x243b, 0x243c, 0x243d, 0x243e, 0x243f,  // Offset: 22c0 ~ 22c7
0x2440, 0x2441, 0x2442, 0x2443, 0x2444, 0x2445, 0x2446, 0x2447,  // Offset: 22c8 ~ 22cf
0x2448, 0x2449, 0x244a, 0x244b, 0x244c, 0x244d, 0x244e, 0x244f,  // Offset: 22d0 ~ 22d7
0x2450, 0x2451, 0x2452, 0x2453, 0x2454, 0x2455, 0x2456, 0x2457,  // Offset: 22d8 ~ 22df
0x2458, 0x2459, 0x245a, 0x245b, 0x245c, 0x245d, 0x245e, 0x245f,  // Offset: 22e0 ~ 22e7
0x246a, 0x246b, 0x246c, 0x246d, 0x246e, 0x246f, 0x2470, 0x2471,  // Offset: 22e8 ~ 22ef
0x2472, 0x2473, 0x249c, 0x249d, 0x249e, 0x249f, 0x24a0, 0x24a1,  // Offset: 22f0 ~ 22f7
0x24a2, 0x24a3, 0x24a4, 0x24a5, 0x24a6, 0x24a7, 0x24a8, 0x24a9,  // Offset: 22f8 ~ 22ff
0x24aa, 0x24ab, 0x24ac, 0x24ad, 0x24ae, 0x24af, 0x24b0, 0x24b1,  // Offset: 2300 ~ 2307
0x24b2, 0x24b3, 0x24b4, 0x24b5, 0x24b6, 0x24b7, 0x24b8, 0x24b9,  // Offset: 2308 ~ 230f
0x24ba, 0x24bb, 0x24bc, 0x24bd, 0x24be, 0x24bf, 0x24c0, 0x24c1,  // Offset: 2310 ~ 2317
0x24c2, 0x24c3, 0x24c4, 0x24c5, 0x24c6, 0x24c7, 0x24c8, 0x24c9,  // Offset: 2318 ~ 231f
0x24ca, 0x24cb, 0x24cc, 0x24cd, 0x24ce, 0x24cf, 0x24d0, 0x24d1,  // Offset: 2320 ~ 2327
0x24d2, 0x24d3, 0x24d4, 0x24d5, 0x24d6, 0x24d7, 0x24d8, 0x24d9,  // Offset: 2328 ~ 232f
0x24da, 0x24db, 0x24dc, 0x24dd, 0x24de, 0x24df, 0x24e0, 0x24e1,  // Offset: 2330 ~ 2337
0x24e2, 0x24e3, 0x24e4, 0x24e5, 0x24e6, 0x24e7, 0x24e8, 0x24e9,  // Offset: 2338 ~ 233f
0x24ea, 0x24eb, 0x24ec, 0x24ed, 0x24ee, 0x24ef, 0x24f0, 0x24f1,  // Offset: 2340 ~ 2347
0x24f2, 0x24f3, 0x24f4, 0x24f5, 0x24f6, 0x24f7, 0x24f8, 0x24f9,  // Offset: 2348 ~ 234f
0x24fa, 0x24fb, 0x24fc, 0x24fd, 0x24fe, 0x24ff, 0x254c, 0x254d,  // Offset: 2350 ~ 2357
0x254e, 0x254f, 0x2574, 0x2575, 0x2576, 0x2577, 0x2578, 0x2579,  // Offset: 2358 ~ 235f
0x257a, 0x257b, 0x257c, 0x257d, 0x257e, 0x257f, 0x2580, 0x2590,  // Offset: 2360 ~ 2367
0x2591, 0x2592, 0x2596, 0x2597, 0x2598, 0x2599, 0x259a, 0x259b,  // Offset: 2368 ~ 236f
0x259c, 0x259d, 0x259e, 0x259f, 0x25a2, 0x25a3, 0x25a4, 0x25a5,  // Offset: 2370 ~ 2377
0x25a6, 0x25a7, 0x25a8, 0x25a9, 0x25aa, 0x25ab, 0x25ac, 0x25ad,  // Offset: 2378 ~ 237f
0x25ae, 0x25af, 0x25b0, 0x25b1, 0x25b4, 0x25b5, 0x25b6, 0x25b7,  // Offset: 2380 ~ 2387
0x25b8, 0x25b9, 0x25ba, 0x25bb, 0x25be, 0x25bf, 0x25c0, 0x25c1,  // Offset: 2388 ~ 238f
0x25c2, 0x25c3, 0x25c4, 0x25c5, 0x25c8, 0x25c9, 0x25ca, 0x25cc,  // Offset: 2390 ~ 2397
0x25cd, 0x25d0, 0x25d1, 0x25d2, 0x25d3, 0x25d4, 0x25d5, 0x25d6,  // Offset: 2398 ~ 239f
0x25d7, 0x25d8, 0x25d9, 0x25da, 0x25db, 0x25dc, 0x25dd, 0x25de,  // Offset: 23a0 ~ 23a7
0x25df, 0x25e0, 0x25e1, 0x25e6, 0x25e7, 0x25e8, 0x25e9, 0x25ea,  // Offset: 23a8 ~ 23af
0x25eb, 0x25ec, 0x25ed, 0x25ee, 0x25ef, 0x25f0, 0x25f1, 0x25f2,  // Offset: 23b0 ~ 23b7
0x25f3, 0x25f4, 0x25f5, 0x25f6, 0x25f7, 0x25f8, 0x25f9, 0x25fa,  // Offset: 23b8 ~ 23bf
0x25fb, 0x25fc, 0x25fd, 0x25fe, 0x25ff, 0x2600, 0x2601, 0x2602,  // Offset: 23c0 ~ 23c7
0x2603, 0x2604, 0x2607, 0x2608, 0x260a, 0x260b, 0x260c, 0x260d,  // Offset: 23c8 ~ 23cf
0x260e, 0x260f, 0x2610, 0x2611, 0x2612, 0x2613, 0x2614, 0x2615,  // Offset: 23d0 ~ 23d7
0x2616, 0x2617, 0x2618, 0x2619, 0x261a, 0x261b, 0x261c, 0x261d,  // Offset: 23d8 ~ 23df
0x261e, 0x261f, 0x2620, 0x2621, 0x2622, 0x2623, 0x2624, 0x2625,  // Offset: 23e0 ~ 23e7
0x2626, 0x2627, 0x2628, 0x2629, 0x262a, 0x262b, 0x262c, 0x262d,  // Offset: 23e8 ~ 23ef
0x262e, 0x262f, 0x2630, 0x2631, 0x2632, 0x2633, 0x2634, 0x2635,  // Offset: 23f0 ~ 23f7
0x2636, 0x2637, 0x2638, 0x2639, 0x263a, 0x263b, 0x263c, 0x263d,  // Offset: 23f8 ~ 23ff
0x263e, 0x263f, 0x2641, 0x2643, 0x2644, 0x2645, 0x2646, 0x2647,  // Offset: 2400 ~ 2407
0x2648, 0x2649, 0x264a, 0x264b, 0x264c, 0x264d, 0x264e, 0x264f,  // Offset: 2408 ~ 240f
0x2650, 0x2651, 0x2652, 0x2653, 0x2654, 0x2655, 0x2656, 0x2657,  // Offset: 2410 ~ 2417
0x2658, 0x2659, 0x265a, 0x265b, 0x265c, 0x265d, 0x265e, 0x265f,  // Offset: 2418 ~ 241f
0x2660, 0x2661, 0x2662, 0x2663, 0x2664, 0x2665, 0x2666, 0x2667,  // Offset: 2420 ~ 2427
0x2668, 0x2669, 0x266a, 0x266b, 0x266c, 0x266d, 0x266e, 0x266f,  // Offset: 2428 ~ 242f
0x2670, 0x2671, 0x2672, 0x2673, 0x2674, 0x2675, 0x2676, 0x2677,  // Offset: 2430 ~ 2437
0x2678, 0x2679, 0x267a, 0x267b, 0x267c, 0x267d, 0x267e, 0x267f,  // Offset: 2438 ~ 243f
0x2680, 0x2681, 0x2682, 0x2683, 0x2684, 0x2685, 0x2686, 0x2687,  // Offset: 2440 ~ 2447
0x2688, 0x2689, 0x268a, 0x268b, 0x268c, 0x268d, 0x268e, 0x268f,  // Offset: 2448 ~ 244f
0x2690, 0x2691, 0x2692, 0x2693, 0x2694, 0x2695, 0x2696, 0x2697,  // Offset: 2450 ~ 2457
0x2698, 0x2699, 0x269a, 0x269b, 0x269c, 0x269d, 0x269e, 0x269f,  // Offset: 2458 ~ 245f
0x26a0, 0x26a1, 0x26a2, 0x26a3, 0x26a4, 0x26a5, 0x26a6, 0x26a7,  // Offset: 2460 ~ 2467
0x26a8, 0x26a9, 0x26aa, 0x26ab, 0x26ac, 0x26ad, 0x26ae, 0x26af,  // Offset: 2468 ~ 246f
0x26b0, 0x26b1, 0x26b2, 0x26b3, 0x26b4, 0x26b5, 0x26b6, 0x26b7,  // Offset: 2470 ~ 2477
0x26b8, 0x26b9, 0x26ba, 0x26bb, 0x26bc, 0x26bd, 0x26be, 0x26bf,  // Offset: 2478 ~ 247f
0x26c0, 0x26c1, 0x26c2, 0x26c3, 0x26c4, 0x26c5, 0x26c6, 0x26c7,  // Offset: 2480 ~ 2487
0x26c8, 0x26c9, 0x26ca, 0x26cb, 0x26cc, 0x26cd, 0x26ce, 0x26cf,  // Offset: 2488 ~ 248f
0x26d0, 0x26d1, 0x26d2, 0x26d3, 0x26d4, 0x26d5, 0x26d6, 0x26d7,  // Offset: 2490 ~ 2497
0x26d8, 0x26d9, 0x26da, 0x26db, 0x26dc, 0x26dd, 0x26de, 0x26df,  // Offset: 2498 ~ 249f
0x26e0, 0x26e1, 0x26e2, 0x26e3, 0x26e4, 0x26e5, 0x26e6, 0x26e7,  // Offset: 24a0 ~ 24a7
0x26e8, 0x26e9, 0x26ea, 0x26eb, 0x26ec, 0x26ed, 0x26ee, 0x26ef,  // Offset: 24a8 ~ 24af
0x26f0, 0x26f1, 0x26f2, 0x26f3, 0x26f4, 0x26f5, 0x26f6, 0x26f7,  // Offset: 24b0 ~ 24b7
0x26f8, 0x26f9, 0x26fa, 0x26fb, 0x26fc, 0x26fd, 0x26fe, 0x26ff,  // Offset: 24b8 ~ 24bf
0x2700, 0x2701, 0x2702, 0x2703, 0x2704, 0x2705, 0x2706, 0x2707,  // Offset: 24c0 ~ 24c7
0x2708, 0x2709, 0x270a, 0x270b, 0x270c, 0x270d, 0x270e, 0x270f,  // Offset: 24c8 ~ 24cf
0x2710, 0x2711, 0x2712, 0x2713, 0x2714, 0x2715, 0x2716, 0x2717,  // Offset: 24d0 ~ 24d7
0x2718, 0x2719, 0x271a, 0x271b, 0x271c, 0x271d, 0x271e, 0x271f,  // Offset: 24d8 ~ 24df
0x2720, 0x2721, 0x2722, 0x2723, 0x2724, 0x2725, 0x2726, 0x2727,  // Offset: 24e0 ~ 24e7
0x2728, 0x2729, 0x272a, 0x272b, 0x272c, 0x272d, 0x272e, 0x272f,  // Offset: 24e8 ~ 24ef
0x2730, 0x2731, 0x2732, 0x2733, 0x2734, 0x2735, 0x2736, 0x2737,  // Offset: 24f0 ~ 24f7
0x2738, 0x2739, 0x273a, 0x273b, 0x273c, 0x273d, 0x273e, 0x273f,  // Offset: 24f8 ~ 24ff
0x2740, 0x2741, 0x2742, 0x2743, 0x2744, 0x2745, 0x2746, 0x2747,  // Offset: 2500 ~ 2507
0x2748, 0x2749, 0x274a, 0x274b, 0x274c, 0x274d, 0x274e, 0x274f,  // Offset: 2508 ~ 250f
0x2750, 0x2751, 0x2752, 0x2753, 0x2754, 0x2755, 0x2756, 0x2757,  // Offset: 2510 ~ 2517
0x2758, 0x2759, 0x275a, 0x275b, 0x275c, 0x275d, 0x275e, 0x275f,  // Offset: 2518 ~ 251f
0x2760, 0x2761, 0x2762, 0x2763, 0x2764, 0x2765, 0x2766, 0x2767,  // Offset: 2520 ~ 2527
0x2768, 0x2769, 0x276a, 0x276b, 0x276c, 0x276d, 0x276e, 0x276f,  // Offset: 2528 ~ 252f
0x2770, 0x2771, 0x2772, 0x2773, 0x2774, 0x2775, 0x2776, 0x2777,  // Offset: 2530 ~ 2537
0x2778, 0x2779, 0x277a, 0x277b, 0x277c, 0x277d, 0x277e, 0x277f,  // Offset: 2538 ~ 253f
0x2780, 0x2781, 0x2782, 0x2783, 0x2784, 0x2785, 0x2786, 0x2787,  // Offset: 2540 ~ 2547
0x2788, 0x2789, 0x278a, 0x278b, 0x278c, 0x278d, 0x278e, 0x278f,  // Offset: 2548 ~ 254f
0x2790, 0x2791, 0x2792, 0x2793, 0x2794, 0x2795, 0x2796, 0x2797,  // Offset: 2550 ~ 2557
0x2798, 0x2799, 0x279a, 0x279b, 0x279c, 0x279d, 0x279e, 0x279f,  // Offset: 2558 ~ 255f
0x27a0, 0x27a1, 0x27a2, 0x27a3, 0x27a4, 0x27a5, 0x27a6, 0x27a7,  // Offset: 2560 ~ 2567
0x27a8, 0x27a9, 0x27aa, 0x27ab, 0x27ac, 0x27ad, 0x27ae, 0x27af,  // Offset: 2568 ~ 256f
0x27b0, 0x27b1, 0x27b2, 0x27b3, 0x27b4, 0x27b5, 0x27b6, 0x27b7,  // Offset: 2570 ~ 2577
0x27b8, 0x27b9, 0x27ba, 0x27bb, 0x27bc, 0x27bd, 0x27be, 0x27bf,  // Offset: 2578 ~ 257f
0x27c0, 0x27c1, 0x27c2, 0x27c3, 0x27c4, 0x27c5, 0x27c6, 0x27c7,  // Offset: 2580 ~ 2587
0x27c8, 0x27c9, 0x27ca, 0x27cb, 0x27cc, 0x27cd, 0x27ce, 0x27cf,  // Offset: 2588 ~ 258f
0x27d0, 0x27d1, 0x27d2, 0x27d3, 0x27d4, 0x27d5, 0x27d6, 0x27d7,  // Offset: 2590 ~ 2597
0x27d8, 0x27d9, 0x27da, 0x27db, 0x27dc, 0x27dd, 0x27de, 0x27df,  // Offset: 2598 ~ 259f
0x27e0, 0x27e1, 0x27e2, 0x27e3, 0x27e4, 0x27e5, 0x27e6, 0x27e7,  // Offset: 25a0 ~ 25a7
0x27e8, 0x27e9, 0x27ea, 0x27eb, 0x27ec, 0x27ed, 0x27ee, 0x27ef,  // Offset: 25a8 ~ 25af
0x27f0, 0x27f1, 0x27f2, 0x27f3, 0x27f4, 0x27f5, 0x27f6, 0x27f7,  // Offset: 25b0 ~ 25b7
0x27f8, 0x27f9, 0x27fa, 0x27fb, 0x27fc, 0x27fd, 0x27fe, 0x27ff,  // Offset: 25b8 ~ 25bf
0x2800, 0x2801, 0x2802, 0x2803, 0x2804, 0x2805, 0x2806, 0x2807,  // Offset: 25c0 ~ 25c7
0x2808, 0x2809, 0x280a, 0x280b, 0x280c, 0x280d, 0x280e, 0x280f,  // Offset: 25c8 ~ 25cf
0x2810, 0x2811, 0x2812, 0x2813, 0x2814, 0x2815, 0x2816, 0x2817,  // Offset: 25d0 ~ 25d7
0x2818, 0x2819, 0x281a, 0x281b, 0x281c, 0x281d, 0x281e, 0x281f,  // Offset: 25d8 ~ 25df
0x2820, 0x2821, 0x2822, 0x2823, 0x2824, 0x2825, 0x2826, 0x2827,  // Offset: 25e0 ~ 25e7
0x2828, 0x2829, 0x282a, 0x282b, 0x282c, 0x282d, 0x282e, 0x282f,  // Offset: 25e8 ~ 25ef
0x2830, 0x2831, 0x2832, 0x2833, 0x2834, 0x2835, 0x2836, 0x2837,  // Offset: 25f0 ~ 25f7
0x2838, 0x2839, 0x283a, 0x283b, 0x283c, 0x283d, 0x283e, 0x283f,  // Offset: 25f8 ~ 25ff
0x2840, 0x2841, 0x2842, 0x2843, 0x2844, 0x2845, 0x2846, 0x2847,  // Offset: 2600 ~ 2607
0x2848, 0x2849, 0x284a, 0x284b, 0x284c, 0x284d, 0x284e, 0x284f,  // Offset: 2608 ~ 260f
0x2850, 0x2851, 0x2852, 0x2853, 0x2854, 0x2855, 0x2856, 0x2857,  // Offset: 2610 ~ 2617
0x2858, 0x2859, 0x285a, 0x285b, 0x285c, 0x285d, 0x285e, 0x285f,  // Offset: 2618 ~ 261f
0x2860, 0x2861, 0x2862, 0x2863, 0x2864, 0x2865, 0x2866, 0x2867,  // Offset: 2620 ~ 2627
0x2868, 0x2869, 0x286a, 0x286b, 0x286c, 0x286d, 0x286e, 0x286f,  // Offset: 2628 ~ 262f
0x2870, 0x2871, 0x2872, 0x2873, 0x2874, 0x2875, 0x2876, 0x2877,  // Offset: 2630 ~ 2637
0x2878, 0x2879, 0x287a, 0x287b, 0x287c, 0x287d, 0x287e, 0x287f,  // Offset: 2638 ~ 263f
0x2880, 0x2881, 0x2882, 0x2883, 0x2884, 0x2885, 0x2886, 0x2887,  // Offset: 2640 ~ 2647
0x2888, 0x2889, 0x288a, 0x288b, 0x288c, 0x288d, 0x288e, 0x288f,  // Offset: 2648 ~ 264f
0x2890, 0x2891, 0x2892, 0x2893, 0x2894, 0x2895, 0x2896, 0x2897,  // Offset: 2650 ~ 2657
0x2898, 0x2899, 0x289a, 0x289b, 0x289c, 0x289d, 0x289e, 0x289f,  // Offset: 2658 ~ 265f
0x28a0, 0x28a1, 0x28a2, 0x28a3, 0x28a4, 0x28a5, 0x28a6, 0x28a7,  // Offset: 2660 ~ 2667
0x28a8, 0x28a9, 0x28aa, 0x28ab, 0x28ac, 0x28ad, 0x28ae, 0x28af,  // Offset: 2668 ~ 266f
0x28b0, 0x28b1, 0x28b2, 0x28b3, 0x28b4, 0x28b5, 0x28b6, 0x28b7,  // Offset: 2670 ~ 2677
0x28b8, 0x28b9, 0x28ba, 0x28bb, 0x28bc, 0x28bd, 0x28be, 0x28bf,  // Offset: 2678 ~ 267f
0x28c0, 0x28c1, 0x28c2, 0x28c3, 0x28c4, 0x28c5, 0x28c6, 0x28c7,  // Offset: 2680 ~ 2687
0x28c8, 0x28c9, 0x28ca, 0x28cb, 0x28cc, 0x28cd, 0x28ce, 0x28cf,  // Offset: 2688 ~ 268f
0x28d0, 0x28d1, 0x28d2, 0x28d3, 0x28d4, 0x28d5, 0x28d6, 0x28d7,  // Offset: 2690 ~ 2697
0x28d8, 0x28d9, 0x28da, 0x28db, 0x28dc, 0x28dd, 0x28de, 0x28df,  // Offset: 2698 ~ 269f
0x28e0, 0x28e1, 0x28e2, 0x28e3, 0x28e4, 0x28e5, 0x28e6, 0x28e7,  // Offset: 26a0 ~ 26a7
0x28e8, 0x28e9, 0x28ea, 0x28eb, 0x28ec, 0x28ed, 0x28ee, 0x28ef,  // Offset: 26a8 ~ 26af
0x28f0, 0x28f1, 0x28f2, 0x28f3, 0x28f4, 0x28f5, 0x28f6, 0x28f7,  // Offset: 26b0 ~ 26b7
0x28f8, 0x28f9, 0x28fa, 0x28fb, 0x28fc, 0x28fd, 0x28fe, 0x28ff,  // Offset: 26b8 ~ 26bf
0x2900, 0x2901, 0x2902, 0x2903, 0x2904, 0x2905, 0x2906, 0x2907,  // Offset: 26c0 ~ 26c7
0x2908, 0x2909, 0x290a, 0x290b, 0x290c, 0x290d, 0x290e, 0x290f,  // Offset: 26c8 ~ 26cf
0x2910, 0x2911, 0x2912, 0x2913, 0x2914, 0x2915, 0x2916, 0x2917,  // Offset: 26d0 ~ 26d7
0x2918, 0x2919, 0x291a, 0x291b, 0x291c, 0x291d, 0x291e, 0x291f,  // Offset: 26d8 ~ 26df
0x2920, 0x2921, 0x2922, 0x2923, 0x2924, 0x2925, 0x2926, 0x2927,  // Offset: 26e0 ~ 26e7
0x2928, 0x2929, 0x292a, 0x292b, 0x292c, 0x292d, 0x292e, 0x292f,  // Offset: 26e8 ~ 26ef
0x2930, 0x2931, 0x2932, 0x2933, 0x2934, 0x2935, 0x2936, 0x2937,  // Offset: 26f0 ~ 26f7
0x2938, 0x2939, 0x293a, 0x293b, 0x293c, 0x293d, 0x293e, 0x293f,  // Offset: 26f8 ~ 26ff
0x2940, 0x2941, 0x2942, 0x2943, 0x2944, 0x2945, 0x2946, 0x2947,  // Offset: 2700 ~ 2707
0x2948, 0x2949, 0x294a, 0x294b, 0x294c, 0x294d, 0x294e, 0x294f,  // Offset: 2708 ~ 270f
0x2950, 0x2951, 0x2952, 0x2953, 0x2954, 0x2955, 0x2956, 0x2957,  // Offset: 2710 ~ 2717
0x2958, 0x2959, 0x295a, 0x295b, 0x295c, 0x295d, 0x295e, 0x295f,  // Offset: 2718 ~ 271f
0x2960, 0x2961, 0x2962, 0x2963, 0x2964, 0x2965, 0x2966, 0x2967,  // Offset: 2720 ~ 2727
0x2968, 0x2969, 0x296a, 0x296b, 0x296c, 0x296d, 0x296e, 0x296f,  // Offset: 2728 ~ 272f
0x2970, 0x2971, 0x2972, 0x2973, 0x2974, 0x2975, 0x2976, 0x2977,  // Offset: 2730 ~ 2737
0x2978, 0x2979, 0x297a, 0x297b, 0x297c, 0x297d, 0x297e, 0x297f,  // Offset: 2738 ~ 273f
0x2980, 0x2981, 0x2982, 0x2983, 0x2984, 0x2985, 0x2986, 0x2987,  // Offset: 2740 ~ 2747
0x2988, 0x2989, 0x298a, 0x298b, 0x298c, 0x298d, 0x298e, 0x298f,  // Offset: 2748 ~ 274f
0x2990, 0x2991, 0x2992, 0x2993, 0x2994, 0x2995, 0x2996, 0x2997,  // Offset: 2750 ~ 2757
0x2998, 0x2999, 0x299a, 0x299b, 0x299c, 0x299d, 0x299e, 0x299f,  // Offset: 2758 ~ 275f
0x29a0, 0x29a1, 0x29a2, 0x29a3, 0x29a4, 0x29a5, 0x29a6, 0x29a7,  // Offset: 2760 ~ 2767
0x29a8, 0x29a9, 0x29aa, 0x29ab, 0x29ac, 0x29ad, 0x29ae, 0x29af,  // Offset: 2768 ~ 276f
0x29b0, 0x29b1, 0x29b2, 0x29b3, 0x29b4, 0x29b5, 0x29b6, 0x29b7,  // Offset: 2770 ~ 2777
0x29b8, 0x29b9, 0x29ba, 0x29bb, 0x29bc, 0x29bd, 0x29be, 0x29bf,  // Offset: 2778 ~ 277f
0x29c0, 0x29c1, 0x29c2, 0x29c3, 0x29c4, 0x29c5, 0x29c6, 0x29c7,  // Offset: 2780 ~ 2787
0x29c8, 0x29c9, 0x29ca, 0x29cb, 0x29cc, 0x29cd, 0x29ce, 0x29cf,  // Offset: 2788 ~ 278f
0x29d0, 0x29d1, 0x29d2, 0x29d3, 0x29d4, 0x29d5, 0x29d6, 0x29d7,  // Offset: 2790 ~ 2797
0x29d8, 0x29d9, 0x29da, 0x29db, 0x29dc, 0x29dd, 0x29de, 0x29df,  // Offset: 2798 ~ 279f
0x29e0, 0x29e1, 0x29e2, 0x29e3, 0x29e4, 0x29e5, 0x29e6, 0x29e7,  // Offset: 27a0 ~ 27a7
0x29e8, 0x29e9, 0x29ea, 0x29eb, 0x29ec, 0x29ed, 0x29ee, 0x29ef,  // Offset: 27a8 ~ 27af
0x29f0, 0x29f1, 0x29f2, 0x29f3, 0x29f4, 0x29f5, 0x29f6, 0x29f7,  // Offset: 27b0 ~ 27b7
0x29f8, 0x29f9, 0x29fa, 0x29fb, 0x29fc, 0x29fd, 0x29fe, 0x29ff,  // Offset: 27b8 ~ 27bf
0x2a00, 0x2a01, 0x2a02, 0x2a03, 0x2a04, 0x2a05, 0x2a06, 0x2a07,  // Offset: 27c0 ~ 27c7
0x2a08, 0x2a09, 0x2a0a, 0x2a0b, 0x2a0c, 0x2a0d, 0x2a0e, 0x2a0f,  // Offset: 27c8 ~ 27cf
0x2a10, 0x2a11, 0x2a12, 0x2a13, 0x2a14, 0x2a15, 0x2a16, 0x2a17,  // Offset: 27d0 ~ 27d7
0x2a18, 0x2a19, 0x2a1a, 0x2a1b, 0x2a1c, 0x2a1d, 0x2a1e, 0x2a1f,  // Offset: 27d8 ~ 27df
0x2a20, 0x2a21, 0x2a22, 0x2a23, 0x2a24, 0x2a25, 0x2a26, 0x2a27,  // Offset: 27e0 ~ 27e7
0x2a28, 0x2a29, 0x2a2a, 0x2a2b, 0x2a2c, 0x2a2d, 0x2a2e, 0x2a2f,  // Offset: 27e8 ~ 27ef
0x2a30, 0x2a31, 0x2a32, 0x2a33, 0x2a34, 0x2a35, 0x2a36, 0x2a37,  // Offset: 27f0 ~ 27f7
0x2a38, 0x2a39, 0x2a3a, 0x2a3b, 0x2a3c, 0x2a3d, 0x2a3e, 0x2a3f,  // Offset: 27f8 ~ 27ff
0x2a40, 0x2a41, 0x2a42, 0x2a43, 0x2a44, 0x2a45, 0x2a46, 0x2a47,  // Offset: 2800 ~ 2807
0x2a48, 0x2a49, 0x2a4a, 0x2a4b, 0x2a4c, 0x2a4d, 0x2a4e, 0x2a4f,  // Offset: 2808 ~ 280f
0x2a50, 0x2a51, 0x2a52, 0x2a53, 0x2a54, 0x2a55, 0x2a56, 0x2a57,  // Offset: 2810 ~ 2817
0x2a58, 0x2a59, 0x2a5a, 0x2a5b, 0x2a5c, 0x2a5d, 0x2a5e, 0x2a5f,  // Offset: 2818 ~ 281f
0x2a60, 0x2a61, 0x2a62, 0x2a63, 0x2a64, 0x2a65, 0x2a66, 0x2a67,  // Offset: 2820 ~ 2827
0x2a68, 0x2a69, 0x2a6a, 0x2a6b, 0x2a6c, 0x2a6d, 0x2a6e, 0x2a6f,  // Offset: 2828 ~ 282f
0x2a70, 0x2a71, 0x2a72, 0x2a73, 0x2a74, 0x2a75, 0x2a76, 0x2a77,  // Offset: 2830 ~ 2837
0x2a78, 0x2a79, 0x2a7a, 0x2a7b, 0x2a7c, 0x2a7d, 0x2a7e, 0x2a7f,  // Offset: 2838 ~ 283f
0x2a80, 0x2a81, 0x2a82, 0x2a83, 0x2a84, 0x2a85, 0x2a86, 0x2a87,  // Offset: 2840 ~ 2847
0x2a88, 0x2a89, 0x2a8a, 0x2a8b, 0x2a8c, 0x2a8d, 0x2a8e, 0x2a8f,  // Offset: 2848 ~ 284f
0x2a90, 0x2a91, 0x2a92, 0x2a93, 0x2a94, 0x2a95, 0x2a96, 0x2a97,  // Offset: 2850 ~ 2857
0x2a98, 0x2a99, 0x2a9a, 0x2a9b, 0x2a9c, 0x2a9d, 0x2a9e, 0x2a9f,  // Offset: 2858 ~ 285f
0x2aa0, 0x2aa1, 0x2aa2, 0x2aa3, 0x2aa4, 0x2aa5, 0x2aa6, 0x2aa7,  // Offset: 2860 ~ 2867
0x2aa8, 0x2aa9, 0x2aaa, 0x2aab, 0x2aac, 0x2aad, 0x2aae, 0x2aaf,  // Offset: 2868 ~ 286f
0x2ab0, 0x2ab1, 0x2ab2, 0x2ab3, 0x2ab4, 0x2ab5, 0x2ab6, 0x2ab7,  // Offset: 2870 ~ 2877
0x2ab8, 0x2ab9, 0x2aba, 0x2abb, 0x2abc, 0x2abd, 0x2abe, 0x2abf,  // Offset: 2878 ~ 287f
0x2ac0, 0x2ac1, 0x2ac2, 0x2ac3, 0x2ac4, 0x2ac5, 0x2ac6, 0x2ac7,  // Offset: 2880 ~ 2887
0x2ac8, 0x2ac9, 0x2aca, 0x2acb, 0x2acc, 0x2acd, 0x2ace, 0x2acf,  // Offset: 2888 ~ 288f
0x2ad0, 0x2ad1, 0x2ad2, 0x2ad3, 0x2ad4, 0x2ad5, 0x2ad6, 0x2ad7,  // Offset: 2890 ~ 2897
0x2ad8, 0x2ad9, 0x2ada, 0x2adb, 0x2adc, 0x2add, 0x2ade, 0x2adf,  // Offset: 2898 ~ 289f
0x2ae0, 0x2ae1, 0x2ae2, 0x2ae3, 0x2ae4, 0x2ae5, 0x2ae6, 0x2ae7,  // Offset: 28a0 ~ 28a7
0x2ae8, 0x2ae9, 0x2aea, 0x2aeb, 0x2aec, 0x2aed, 0x2aee, 0x2aef,  // Offset: 28a8 ~ 28af
0x2af0, 0x2af1, 0x2af2, 0x2af3, 0x2af4, 0x2af5, 0x2af6, 0x2af7,  // Offset: 28b0 ~ 28b7
0x2af8, 0x2af9, 0x2afa, 0x2afb, 0x2afc, 0x2afd, 0x2afe, 0x2aff,  // Offset: 28b8 ~ 28bf
0x2b00, 0x2b01, 0x2b02, 0x2b03, 0x2b04, 0x2b05, 0x2b06, 0x2b07,  // Offset: 28c0 ~ 28c7
0x2b08, 0x2b09, 0x2b0a, 0x2b0b, 0x2b0c, 0x2b0d, 0x2b0e, 0x2b0f,  // Offset: 28c8 ~ 28cf
0x2b10, 0x2b11, 0x2b12, 0x2b13, 0x2b14, 0x2b15, 0x2b16, 0x2b17,  // Offset: 28d0 ~ 28d7
0x2b18, 0x2b19, 0x2b1a, 0x2b1b, 0x2b1c, 0x2b1d, 0x2b1e, 0x2b1f,  // Offset: 28d8 ~ 28df
0x2b20, 0x2b21, 0x2b22, 0x2b23, 0x2b24, 0x2b25, 0x2b26, 0x2b27,  // Offset: 28e0 ~ 28e7
0x2b28, 0x2b29, 0x2b2a, 0x2b2b, 0x2b2c, 0x2b2d, 0x2b2e, 0x2b2f,  // Offset: 28e8 ~ 28ef
0x2b30, 0x2b31, 0x2b32, 0x2b33, 0x2b34, 0x2b35, 0x2b36, 0x2b37,  // Offset: 28f0 ~ 28f7
0x2b38, 0x2b39, 0x2b3a, 0x2b3b, 0x2b3c, 0x2b3d, 0x2b3e, 0x2b3f,  // Offset: 28f8 ~ 28ff
0x2b40, 0x2b41, 0x2b42, 0x2b43, 0x2b44, 0x2b45, 0x2b46, 0x2b47,  // Offset: 2900 ~ 2907
0x2b48, 0x2b49, 0x2b4a, 0x2b4b, 0x2b4c, 0x2b4d, 0x2b4e, 0x2b4f,  // Offset: 2908 ~ 290f
0x2b50, 0x2b51, 0x2b52, 0x2b53, 0x2b54, 0x2b55, 0x2b56, 0x2b57,  // Offset: 2910 ~ 2917
0x2b58, 0x2b59, 0x2b5a, 0x2b5b, 0x2b5c, 0x2b5d, 0x2b5e, 0x2b5f,  // Offset: 2918 ~ 291f
0x2b60, 0x2b61, 0x2b62, 0x2b63, 0x2b64, 0x2b65, 0x2b66, 0x2b67,  // Offset: 2920 ~ 2927
0x2b68, 0x2b69, 0x2b6a, 0x2b6b, 0x2b6c, 0x2b6d, 0x2b6e, 0x2b6f,  // Offset: 2928 ~ 292f
0x2b70, 0x2b71, 0x2b72, 0x2b73, 0x2b74, 0x2b75, 0x2b76, 0x2b77,  // Offset: 2930 ~ 2937
0x2b78, 0x2b79, 0x2b7a, 0x2b7b, 0x2b7c, 0x2b7d, 0x2b7e, 0x2b7f,  // Offset: 2938 ~ 293f
0x2b80, 0x2b81, 0x2b82, 0x2b83, 0x2b84, 0x2b85, 0x2b86, 0x2b87,  // Offset: 2940 ~ 2947
0x2b88, 0x2b89, 0x2b8a, 0x2b8b, 0x2b8c, 0x2b8d, 0x2b8e, 0x2b8f,  // Offset: 2948 ~ 294f
0x2b90, 0x2b91, 0x2b92, 0x2b93, 0x2b94, 0x2b95, 0x2b96, 0x2b97,  // Offset: 2950 ~ 2957
0x2b98, 0x2b99, 0x2b9a, 0x2b9b, 0x2b9c, 0x2b9d, 0x2b9e, 0x2b9f,  // Offset: 2958 ~ 295f
0x2ba0, 0x2ba1, 0x2ba2, 0x2ba3, 0x2ba4, 0x2ba5, 0x2ba6, 0x2ba7,  // Offset: 2960 ~ 2967
0x2ba8, 0x2ba9, 0x2baa, 0x2bab, 0x2bac, 0x2bad, 0x2bae, 0x2baf,  // Offset: 2968 ~ 296f
0x2bb0, 0x2bb1, 0x2bb2, 0x2bb3, 0x2bb4, 0x2bb5, 0x2bb6, 0x2bb7,  // Offset: 2970 ~ 2977
0x2bb8, 0x2bb9, 0x2bba, 0x2bbb, 0x2bbc, 0x2bbd, 0x2bbe, 0x2bbf,  // Offset: 2978 ~ 297f
0x2bc0, 0x2bc1, 0x2bc2, 0x2bc3, 0x2bc4, 0x2bc5, 0x2bc6, 0x2bc7,  // Offset: 2980 ~ 2987
0x2bc8, 0x2bc9, 0x2bca, 0x2bcb, 0x2bcc, 0x2bcd, 0x2bce, 0x2bcf,  // Offset: 2988 ~ 298f
0x2bd0, 0x2bd1, 0x2bd2, 0x2bd3, 0x2bd4, 0x2bd5, 0x2bd6, 0x2bd7,  // Offset: 2990 ~ 2997
0x2bd8, 0x2bd9, 0x2bda, 0x2bdb, 0x2bdc, 0x2bdd, 0x2bde, 0x2bdf,  // Offset: 2998 ~ 299f
0x2be0, 0x2be1, 0x2be2, 0x2be3, 0x2be4, 0x2be5, 0x2be6, 0x2be7,  // Offset: 29a0 ~ 29a7
0x2be8, 0x2be9, 0x2bea, 0x2beb, 0x2bec, 0x2bed, 0x2bee, 0x2bef,  // Offset: 29a8 ~ 29af
0x2bf0, 0x2bf1, 0x2bf2, 0x2bf3, 0x2bf4, 0x2bf5, 0x2bf6, 0x2bf7,  // Offset: 29b0 ~ 29b7
0x2bf8, 0x2bf9, 0x2bfa, 0x2bfb, 0x2bfc, 0x2bfd, 0x2bfe, 0x2bff,  // Offset: 29b8 ~ 29bf
0x2c00, 0x2c01, 0x2c02, 0x2c03, 0x2c04, 0x2c05, 0x2c06, 0x2c07,  // Offset: 29c0 ~ 29c7
0x2c08, 0x2c09, 0x2c0a, 0x2c0b, 0x2c0c, 0x2c0d, 0x2c0e, 0x2c0f,  // Offset: 29c8 ~ 29cf
0x2c10, 0x2c11, 0x2c12, 0x2c13, 0x2c14, 0x2c15, 0x2c16, 0x2c17,  // Offset: 29d0 ~ 29d7
0x2c18, 0x2c19, 0x2c1a, 0x2c1b, 0x2c1c, 0x2c1d, 0x2c1e, 0x2c1f,  // Offset: 29d8 ~ 29df
0x2c20, 0x2c21, 0x2c22, 0x2c23, 0x2c24, 0x2c25, 0x2c26, 0x2c27,  // Offset: 29e0 ~ 29e7
0x2c28, 0x2c29, 0x2c2a, 0x2c2b, 0x2c2c, 0x2c2d, 0x2c2e, 0x2c2f,  // Offset: 29e8 ~ 29ef
0x2c30, 0x2c31, 0x2c32, 0x2c33, 0x2c34, 0x2c35, 0x2c36, 0x2c37,  // Offset: 29f0 ~ 29f7
0x2c38, 0x2c39, 0x2c3a, 0x2c3b, 0x2c3c, 0x2c3d, 0x2c3e, 0x2c3f,  // Offset: 29f8 ~ 29ff
0x2c40, 0x2c41, 0x2c42, 0x2c43, 0x2c44, 0x2c45, 0x2c46, 0x2c47,  // Offset: 2a00 ~ 2a07
0x2c48, 0x2c49, 0x2c4a, 0x2c4b, 0x2c4c, 0x2c4d, 0x2c4e, 0x2c4f,  // Offset: 2a08 ~ 2a0f
0x2c50, 0x2c51, 0x2c52, 0x2c53, 0x2c54, 0x2c55, 0x2c56, 0x2c57,  // Offset: 2a10 ~ 2a17
0x2c58, 0x2c59, 0x2c5a, 0x2c5b, 0x2c5c, 0x2c5d, 0x2c5e, 0x2c5f,  // Offset: 2a18 ~ 2a1f
0x2c60, 0x2c61, 0x2c62, 0x2c63, 0x2c64, 0x2c65, 0x2c66, 0x2c67,  // Offset: 2a20 ~ 2a27
0x2c68, 0x2c69, 0x2c6a, 0x2c6b, 0x2c6c, 0x2c6d, 0x2c6e, 0x2c6f,  // Offset: 2a28 ~ 2a2f
0x2c70, 0x2c71, 0x2c72, 0x2c73, 0x2c74, 0x2c75, 0x2c76, 0x2c77,  // Offset: 2a30 ~ 2a37
0x2c78, 0x2c79, 0x2c7a, 0x2c7b, 0x2c7c, 0x2c7d, 0x2c7e, 0x2c7f,  // Offset: 2a38 ~ 2a3f
0x2c80, 0x2c81, 0x2c82, 0x2c83, 0x2c84, 0x2c85, 0x2c86, 0x2c87,  // Offset: 2a40 ~ 2a47
0x2c88, 0x2c89, 0x2c8a, 0x2c8b, 0x2c8c, 0x2c8d, 0x2c8e, 0x2c8f,  // Offset: 2a48 ~ 2a4f
0x2c90, 0x2c91, 0x2c92, 0x2c93, 0x2c94, 0x2c95, 0x2c96, 0x2c97,  // Offset: 2a50 ~ 2a57
0x2c98, 0x2c99, 0x2c9a, 0x2c9b, 0x2c9c, 0x2c9d, 0x2c9e, 0x2c9f,  // Offset: 2a58 ~ 2a5f
0x2ca0, 0x2ca1, 0x2ca2, 0x2ca3, 0x2ca4, 0x2ca5, 0x2ca6, 0x2ca7,  // Offset: 2a60 ~ 2a67
0x2ca8, 0x2ca9, 0x2caa, 0x2cab, 0x2cac, 0x2cad, 0x2cae, 0x2caf,  // Offset: 2a68 ~ 2a6f
0x2cb0, 0x2cb1, 0x2cb2, 0x2cb3, 0x2cb4, 0x2cb5, 0x2cb6, 0x2cb7,  // Offset: 2a70 ~ 2a77
0x2cb8, 0x2cb9, 0x2cba, 0x2cbb, 0x2cbc, 0x2cbd, 0x2cbe, 0x2cbf,  // Offset: 2a78 ~ 2a7f
0x2cc0, 0x2cc1, 0x2cc2, 0x2cc3, 0x2cc4, 0x2cc5, 0x2cc6, 0x2cc7,  // Offset: 2a80 ~ 2a87
0x2cc8, 0x2cc9, 0x2cca, 0x2ccb, 0x2ccc, 0x2ccd, 0x2cce, 0x2ccf,  // Offset: 2a88 ~ 2a8f
0x2cd0, 0x2cd1, 0x2cd2, 0x2cd3, 0x2cd4, 0x2cd5, 0x2cd6, 0x2cd7,  // Offset: 2a90 ~ 2a97
0x2cd8, 0x2cd9, 0x2cda, 0x2cdb, 0x2cdc, 0x2cdd, 0x2cde, 0x2cdf,  // Offset: 2a98 ~ 2a9f
0x2ce0, 0x2ce1, 0x2ce2, 0x2ce3, 0x2ce4, 0x2ce5, 0x2ce6, 0x2ce7,  // Offset: 2aa0 ~ 2aa7
0x2ce8, 0x2ce9, 0x2cea, 0x2ceb, 0x2cec, 0x2ced, 0x2cee, 0x2cef,  // Offset: 2aa8 ~ 2aaf
0x2cf0, 0x2cf1, 0x2cf2, 0x2cf3, 0x2cf4, 0x2cf5, 0x2cf6, 0x2cf7,  // Offset: 2ab0 ~ 2ab7
0x2cf8, 0x2cf9, 0x2cfa, 0x2cfb, 0x2cfc, 0x2cfd, 0x2cfe, 0x2cff,  // Offset: 2ab8 ~ 2abf
0x2d00, 0x2d01, 0x2d02, 0x2d03, 0x2d04, 0x2d05, 0x2d06, 0x2d07,  // Offset: 2ac0 ~ 2ac7
0x2d08, 0x2d09, 0x2d0a, 0x2d0b, 0x2d0c, 0x2d0d, 0x2d0e, 0x2d0f,  // Offset: 2ac8 ~ 2acf
0x2d10, 0x2d11, 0x2d12, 0x2d13, 0x2d14, 0x2d15, 0x2d16, 0x2d17,  // Offset: 2ad0 ~ 2ad7
0x2d18, 0x2d19, 0x2d1a, 0x2d1b, 0x2d1c, 0x2d1d, 0x2d1e, 0x2d1f,  // Offset: 2ad8 ~ 2adf
0x2d20, 0x2d21, 0x2d22, 0x2d23, 0x2d24, 0x2d25, 0x2d26, 0x2d27,  // Offset: 2ae0 ~ 2ae7
0x2d28, 0x2d29, 0x2d2a, 0x2d2b, 0x2d2c, 0x2d2d, 0x2d2e, 0x2d2f,  // Offset: 2ae8 ~ 2aef
0x2d30, 0x2d31, 0x2d32, 0x2d33, 0x2d34, 0x2d35, 0x2d36, 0x2d37,  // Offset: 2af0 ~ 2af7
0x2d38, 0x2d39, 0x2d3a, 0x2d3b, 0x2d3c, 0x2d3d, 0x2d3e, 0x2d3f,  // Offset: 2af8 ~ 2aff
0x2d40, 0x2d41, 0x2d42, 0x2d43, 0x2d44, 0x2d45, 0x2d46, 0x2d47,  // Offset: 2b00 ~ 2b07
0x2d48, 0x2d49, 0x2d4a, 0x2d4b, 0x2d4c, 0x2d4d, 0x2d4e, 0x2d4f,  // Offset: 2b08 ~ 2b0f
0x2d50, 0x2d51, 0x2d52, 0x2d53, 0x2d54, 0x2d55, 0x2d56, 0x2d57,  // Offset: 2b10 ~ 2b17
0x2d58, 0x2d59, 0x2d5a, 0x2d5b, 0x2d5c, 0x2d5d, 0x2d5e, 0x2d5f,  // Offset: 2b18 ~ 2b1f
0x2d60, 0x2d61, 0x2d62, 0x2d63, 0x2d64, 0x2d65, 0x2d66, 0x2d67,  // Offset: 2b20 ~ 2b27
0x2d68, 0x2d69, 0x2d6a, 0x2d6b, 0x2d6c, 0x2d6d, 0x2d6e, 0x2d6f,  // Offset: 2b28 ~ 2b2f
0x2d70, 0x2d71, 0x2d72, 0x2d73, 0x2d74, 0x2d75, 0x2d76, 0x2d77,  // Offset: 2b30 ~ 2b37
0x2d78, 0x2d79, 0x2d7a, 0x2d7b, 0x2d7c, 0x2d7d, 0x2d7e, 0x2d7f,  // Offset: 2b38 ~ 2b3f
0x2d80, 0x2d81, 0x2d82, 0x2d83, 0x2d84, 0x2d85, 0x2d86, 0x2d87,  // Offset: 2b40 ~ 2b47
0x2d88, 0x2d89, 0x2d8a, 0x2d8b, 0x2d8c, 0x2d8d, 0x2d8e, 0x2d8f,  // Offset: 2b48 ~ 2b4f
0x2d90, 0x2d91, 0x2d92, 0x2d93, 0x2d94, 0x2d95, 0x2d96, 0x2d97,  // Offset: 2b50 ~ 2b57
0x2d98, 0x2d99, 0x2d9a, 0x2d9b, 0x2d9c, 0x2d9d, 0x2d9e, 0x2d9f,  // Offset: 2b58 ~ 2b5f
0x2da0, 0x2da1, 0x2da2, 0x2da3, 0x2da4, 0x2da5, 0x2da6, 0x2da7,  // Offset: 2b60 ~ 2b67
0x2da8, 0x2da9, 0x2daa, 0x2dab, 0x2dac, 0x2dad, 0x2dae, 0x2daf,  // Offset: 2b68 ~ 2b6f
0x2db0, 0x2db1, 0x2db2, 0x2db3, 0x2db4, 0x2db5, 0x2db6, 0x2db7,  // Offset: 2b70 ~ 2b77
0x2db8, 0x2db9, 0x2dba, 0x2dbb, 0x2dbc, 0x2dbd, 0x2dbe, 0x2dbf,  // Offset: 2b78 ~ 2b7f
0x2dc0, 0x2dc1, 0x2dc2, 0x2dc3, 0x2dc4, 0x2dc5, 0x2dc6, 0x2dc7,  // Offset: 2b80 ~ 2b87
0x2dc8, 0x2dc9, 0x2dca, 0x2dcb, 0x2dcc, 0x2dcd, 0x2dce, 0x2dcf,  // Offset: 2b88 ~ 2b8f
0x2dd0, 0x2dd1, 0x2dd2, 0x2dd3, 0x2dd4, 0x2dd5, 0x2dd6, 0x2dd7,  // Offset: 2b90 ~ 2b97
0x2dd8, 0x2dd9, 0x2dda, 0x2ddb, 0x2ddc, 0x2ddd, 0x2dde, 0x2ddf,  // Offset: 2b98 ~ 2b9f
0x2de0, 0x2de1, 0x2de2, 0x2de3, 0x2de4, 0x2de5, 0x2de6, 0x2de7,  // Offset: 2ba0 ~ 2ba7
0x2de8, 0x2de9, 0x2dea, 0x2deb, 0x2dec, 0x2ded, 0x2dee, 0x2def,  // Offset: 2ba8 ~ 2baf
0x2df0, 0x2df1, 0x2df2, 0x2df3, 0x2df4, 0x2df5, 0x2df6, 0x2df7,  // Offset: 2bb0 ~ 2bb7
0x2df8, 0x2df9, 0x2dfa, 0x2dfb, 0x2dfc, 0x2dfd, 0x2dfe, 0x2dff,  // Offset: 2bb8 ~ 2bbf
0x2e00, 0x2e01, 0x2e02, 0x2e03, 0x2e04, 0x2e05, 0x2e06, 0x2e07,  // Offset: 2bc0 ~ 2bc7
0x2e08, 0x2e09, 0x2e0a, 0x2e0b, 0x2e0c, 0x2e0d, 0x2e0e, 0x2e0f,  // Offset: 2bc8 ~ 2bcf
0x2e10, 0x2e11, 0x2e12, 0x2e13, 0x2e14, 0x2e15, 0x2e16, 0x2e17,  // Offset: 2bd0 ~ 2bd7
0x2e18, 0x2e19, 0x2e1a, 0x2e1b, 0x2e1c, 0x2e1d, 0x2e1e, 0x2e1f,  // Offset: 2bd8 ~ 2bdf
0x2e20, 0x2e21, 0x2e22, 0x2e23, 0x2e24, 0x2e25, 0x2e26, 0x2e27,  // Offset: 2be0 ~ 2be7
0x2e28, 0x2e29, 0x2e2a, 0x2e2b, 0x2e2c, 0x2e2d, 0x2e2e, 0x2e2f,  // Offset: 2be8 ~ 2bef
0x2e30, 0x2e31, 0x2e32, 0x2e33, 0x2e34, 0x2e35, 0x2e36, 0x2e37,  // Offset: 2bf0 ~ 2bf7
0x2e38, 0x2e39, 0x2e3a, 0x2e3b, 0x2e3c, 0x2e3d, 0x2e3e, 0x2e3f,  // Offset: 2bf8 ~ 2bff
0x2e40, 0x2e41, 0x2e42, 0x2e43, 0x2e44, 0x2e45, 0x2e46, 0x2e47,  // Offset: 2c00 ~ 2c07
0x2e48, 0x2e49, 0x2e4a, 0x2e4b, 0x2e4c, 0x2e4d, 0x2e4e, 0x2e4f,  // Offset: 2c08 ~ 2c0f
0x2e50, 0x2e51, 0x2e52, 0x2e53, 0x2e54, 0x2e55, 0x2e56, 0x2e57,  // Offset: 2c10 ~ 2c17
0x2e58, 0x2e59, 0x2e5a, 0x2e5b, 0x2e5c, 0x2e5d, 0x2e5e, 0x2e5f,  // Offset: 2c18 ~ 2c1f
0x2e60, 0x2e61, 0x2e62, 0x2e63, 0x2e64, 0x2e65, 0x2e66, 0x2e67,  // Offset: 2c20 ~ 2c27
0x2e68, 0x2e69, 0x2e6a, 0x2e6b, 0x2e6c, 0x2e6d, 0x2e6e, 0x2e6f,  // Offset: 2c28 ~ 2c2f
0x2e70, 0x2e71, 0x2e72, 0x2e73, 0x2e74, 0x2e75, 0x2e76, 0x2e77,  // Offset: 2c30 ~ 2c37
0x2e78, 0x2e79, 0x2e7a, 0x2e7b, 0x2e7c, 0x2e7d, 0x2e7e, 0x2e7f,  // Offset: 2c38 ~ 2c3f
0x2e80, 0x2e82, 0x2e83, 0x2e85, 0x2e86, 0x2e87, 0x2e89, 0x2e8a,  // Offset: 2c40 ~ 2c47
0x2e8d, 0x2e8e, 0x2e8f, 0x2e90, 0x2e91, 0x2e92, 0x2e93, 0x2e94,  // Offset: 2c48 ~ 2c4f
0x2e95, 0x2e96, 0x2e98, 0x2e99, 0x2e9a, 0x2e9b, 0x2e9c, 0x2e9d,  // Offset: 2c50 ~ 2c57
0x2e9e, 0x2e9f, 0x2ea0, 0x2ea1, 0x2ea2, 0x2ea3, 0x2ea4, 0x2ea5,  // Offset: 2c58 ~ 2c5f
0x2ea6, 0x2ea8, 0x2ea9, 0x2eab, 0x2eac, 0x2ead, 0x2eaf, 0x2eb0,  // Offset: 2c60 ~ 2c67
0x2eb1, 0x2eb2, 0x2eb4, 0x2eb5, 0x2eb8, 0x2eb9, 0x2eba, 0x2ebc,  // Offset: 2c68 ~ 2c6f
0x2ebd, 0x2ebe, 0x2ebf, 0x2ec0, 0x2ec1, 0x2ec2, 0x2ec3, 0x2ec4,  // Offset: 2c70 ~ 2c77
0x2ec5, 0x2ec6, 0x2ec7, 0x2ec8, 0x2ec9, 0x2ecb, 0x2ecc, 0x2ecd,  // Offset: 2c78 ~ 2c7f
0x2ece, 0x2ecf, 0x2ed0, 0x2ed1, 0x2ed2, 0x2ed3, 0x2ed4, 0x2ed5,  // Offset: 2c80 ~ 2c87
0x2ed6, 0x2ed7, 0x2ed8, 0x2ed9, 0x2eda, 0x2edb, 0x2edc, 0x2edd,  // Offset: 2c88 ~ 2c8f
0x2ede, 0x2edf, 0x2ee0, 0x2ee1, 0x2ee2, 0x2ee3, 0x2ee4, 0x2ee5,  // Offset: 2c90 ~ 2c97
0x2ee6, 0x2ee7, 0x2ee8, 0x2ee9, 0x2eea, 0x2eeb, 0x2eec, 0x2eed,  // Offset: 2c98 ~ 2c9f
0x2eee, 0x2eef, 0x2ef0, 0x2ef1, 0x2ef2, 0x2ef3, 0x2ef4, 0x2ef5,  // Offset: 2ca0 ~ 2ca7
0x2ef6, 0x2ef7, 0x2ef8, 0x2ef9, 0x2efa, 0x2efb, 0x2efc, 0x2efd,  // Offset: 2ca8 ~ 2caf
0x2efe, 0x2eff, 0x2f00, 0x2f01, 0x2f02, 0x2f03, 0x2f04, 0x2f05,  // Offset: 2cb0 ~ 2cb7
0x2f06, 0x2f07, 0x2f08, 0x2f09, 0x2f0a, 0x2f0b, 0x2f0c, 0x2f0d,  // Offset: 2cb8 ~ 2cbf
0x2f0e, 0x2f0f, 0x2f10, 0x2f11, 0x2f12, 0x2f13, 0x2f14, 0x2f15,  // Offset: 2cc0 ~ 2cc7
0x2f16, 0x2f17, 0x2f18, 0x2f19, 0x2f1a, 0x2f1b, 0x2f1c, 0x2f1d,  // Offset: 2cc8 ~ 2ccf
0x2f1e, 0x2f1f, 0x2f20, 0x2f21, 0x2f22, 0x2f23, 0x2f24, 0x2f25,  // Offset: 2cd0 ~ 2cd7
0x2f26, 0x2f27, 0x2f28, 0x2f29, 0x2f2a, 0x2f2b, 0x2f2c, 0x2f2d,  // Offset: 2cd8 ~ 2cdf
0x2f2e, 0x2f2f, 0x2f30, 0x2f31, 0x2f32, 0x2f33, 0x2f34, 0x2f35,  // Offset: 2ce0 ~ 2ce7
0x2f36, 0x2f37, 0x2f38, 0x2f39, 0x2f3a, 0x2f3b, 0x2f3c, 0x2f3d,  // Offset: 2ce8 ~ 2cef
0x2f3e, 0x2f3f, 0x2f40, 0x2f41, 0x2f42, 0x2f43, 0x2f44, 0x2f45,  // Offset: 2cf0 ~ 2cf7
0x2f46, 0x2f47, 0x2f48, 0x2f49, 0x2f4a, 0x2f4b, 0x2f4c, 0x2f4d,  // Offset: 2cf8 ~ 2cff
0x2f4e, 0x2f4f, 0x2f50, 0x2f51, 0x2f52, 0x2f53, 0x2f54, 0x2f55,  // Offset: 2d00 ~ 2d07
0x2f56, 0x2f57, 0x2f58, 0x2f59, 0x2f5a, 0x2f5b, 0x2f5c, 0x2f5d,  // Offset: 2d08 ~ 2d0f
0x2f5e, 0x2f5f, 0x2f60, 0x2f61, 0x2f62, 0x2f63, 0x2f64, 0x2f65,  // Offset: 2d10 ~ 2d17
0x2f66, 0x2f67, 0x2f68, 0x2f69, 0x2f6a, 0x2f6b, 0x2f6c, 0x2f6d,  // Offset: 2d18 ~ 2d1f
0x2f6e, 0x2f6f, 0x2f70, 0x2f71, 0x2f72, 0x2f73, 0x2f74, 0x2f75,  // Offset: 2d20 ~ 2d27
0x2f76, 0x2f77, 0x2f78, 0x2f79, 0x2f7a, 0x2f7b, 0x2f7c, 0x2f7d,  // Offset: 2d28 ~ 2d2f
0x2f7e, 0x2f7f, 0x2f80, 0x2f81, 0x2f82, 0x2f83, 0x2f84, 0x2f85,  // Offset: 2d30 ~ 2d37
0x2f86, 0x2f87, 0x2f88, 0x2f89, 0x2f8a, 0x2f8b, 0x2f8c, 0x2f8d,  // Offset: 2d38 ~ 2d3f
0x2f8e, 0x2f8f, 0x2f90, 0x2f91, 0x2f92, 0x2f93, 0x2f94, 0x2f95,  // Offset: 2d40 ~ 2d47
0x2f96, 0x2f97, 0x2f98, 0x2f99, 0x2f9a, 0x2f9b, 0x2f9c, 0x2f9d,  // Offset: 2d48 ~ 2d4f
0x2f9e, 0x2f9f, 0x2fa0, 0x2fa1, 0x2fa2, 0x2fa3, 0x2fa4, 0x2fa5,  // Offset: 2d50 ~ 2d57
0x2fa6, 0x2fa7, 0x2fa8, 0x2fa9, 0x2faa, 0x2fab, 0x2fac, 0x2fad,  // Offset: 2d58 ~ 2d5f
0x2fae, 0x2faf, 0x2fb0, 0x2fb1, 0x2fb2, 0x2fb3, 0x2fb4, 0x2fb5,  // Offset: 2d60 ~ 2d67
0x2fb6, 0x2fb7, 0x2fb8, 0x2fb9, 0x2fba, 0x2fbb, 0x2fbc, 0x2fbd,  // Offset: 2d68 ~ 2d6f
0x2fbe, 0x2fbf, 0x2fc0, 0x2fc1, 0x2fc2, 0x2fc3, 0x2fc4, 0x2fc5,  // Offset: 2d70 ~ 2d77
0x2fc6, 0x2fc7, 0x2fc8, 0x2fc9, 0x2fca, 0x2fcb, 0x2fcc, 0x2fcd,  // Offset: 2d78 ~ 2d7f
0x2fce, 0x2fcf, 0x2fd0, 0x2fd1, 0x2fd2, 0x2fd3, 0x2fd4, 0x2fd5,  // Offset: 2d80 ~ 2d87
0x2fd6, 0x2fd7, 0x2fd8, 0x2fd9, 0x2fda, 0x2fdb, 0x2fdc, 0x2fdd,  // Offset: 2d88 ~ 2d8f
0x2fde, 0x2fdf, 0x2fe0, 0x2fe1, 0x2fe2, 0x2fe3, 0x2fe4, 0x2fe5,  // Offset: 2d90 ~ 2d97
0x2fe6, 0x2fe7, 0x2fe8, 0x2fe9, 0x2fea, 0x2feb, 0x2fec, 0x2fed,  // Offset: 2d98 ~ 2d9f
0x2fee, 0x2fef, 0x2ffc, 0x2ffd, 0x2ffe, 0x2fff, 0x3004, 0x3018,  // Offset: 2da0 ~ 2da7
0x3019, 0x301a, 0x301b, 0x301c, 0x301f, 0x3020, 0x302a, 0x302b,  // Offset: 2da8 ~ 2daf
0x302c, 0x302d, 0x302e, 0x302f, 0x3030, 0x3031, 0x3032, 0x3033,  // Offset: 2db0 ~ 2db7
0x3034, 0x3035, 0x3036, 0x3037, 0x3038, 0x3039, 0x303a, 0x303b,  // Offset: 2db8 ~ 2dbf
0x303c, 0x303d, 0x303f, 0x3040, 0x3094, 0x3095, 0x3096, 0x3097,  // Offset: 2dc0 ~ 2dc7
0x3098, 0x3099, 0x309a, 0x309f, 0x30a0, 0x30f7, 0x30f8, 0x30f9,  // Offset: 2dc8 ~ 2dcf
0x30fa, 0x30fb, 0x30ff, 0x3100, 0x3101, 0x3102, 0x3103, 0x3104,  // Offset: 2dd0 ~ 2dd7
0x312a, 0x312b, 0x312c, 0x312d, 0x312e, 0x312f, 0x3130, 0x3131,  // Offset: 2dd8 ~ 2ddf
0x3132, 0x3133, 0x3134, 0x3135, 0x3136, 0x3137, 0x3138, 0x3139,  // Offset: 2de0 ~ 2de7
0x313a, 0x313b, 0x313c, 0x313d, 0x313e, 0x313f, 0x3140, 0x3141,  // Offset: 2de8 ~ 2def
0x3142, 0x3143, 0x3144, 0x3145, 0x3146, 0x3147, 0x3148, 0x3149,  // Offset: 2df0 ~ 2df7
0x314a, 0x314b, 0x314c, 0x314d, 0x314e, 0x314f, 0x3150, 0x3151,  // Offset: 2df8 ~ 2dff
0x3152, 0x3153, 0x3154, 0x3155, 0x3156, 0x3157, 0x3158, 0x3159,  // Offset: 2e00 ~ 2e07
0x315a, 0x315b, 0x315c, 0x315d, 0x315e, 0x315f, 0x3160, 0x3161,  // Offset: 2e08 ~ 2e0f
0x3162, 0x3163, 0x3164, 0x3165, 0x3166, 0x3167, 0x3168, 0x3169,  // Offset: 2e10 ~ 2e17
0x316a, 0x316b, 0x316c, 0x316d, 0x316e, 0x316f, 0x3170, 0x3171,  // Offset: 2e18 ~ 2e1f
0x3172, 0x3173, 0x3174, 0x3175, 0x3176, 0x3177, 0x3178, 0x3179,  // Offset: 2e20 ~ 2e27
0x317a, 0x317b, 0x317c, 0x317d, 0x317e, 0x317f, 0x3180, 0x3181,  // Offset: 2e28 ~ 2e2f
0x3182, 0x3183, 0x3184, 0x3185, 0x3186, 0x3187, 0x3188, 0x3189,  // Offset: 2e30 ~ 2e37
0x318a, 0x318b, 0x318c, 0x318d, 0x318e, 0x318f, 0x3190, 0x3191,  // Offset: 2e38 ~ 2e3f
0x3192, 0x3193, 0x3194, 0x3195, 0x3196, 0x3197, 0x3198, 0x3199,  // Offset: 2e40 ~ 2e47
0x319a, 0x319b, 0x319c, 0x319d, 0x319e, 0x319f, 0x31a0, 0x31a1,  // Offset: 2e48 ~ 2e4f
0x31a2, 0x31a3, 0x31a4, 0x31a5, 0x31a6, 0x31a7, 0x31a8, 0x31a9,  // Offset: 2e50 ~ 2e57
0x31aa, 0x31ab, 0x31ac, 0x31ad, 0x31ae, 0x31af, 0x31b0, 0x31b1,  // Offset: 2e58 ~ 2e5f
0x31b2, 0x31b3, 0x31b4, 0x31b5, 0x31b6, 0x31b7, 0x31b8, 0x31b9,  // Offset: 2e60 ~ 2e67
0x31ba, 0x31bb, 0x31bc, 0x31bd, 0x31be, 0x31bf, 0x31c0, 0x31c1,  // Offset: 2e68 ~ 2e6f
0x31c2, 0x31c3, 0x31c4, 0x31c5, 0x31c6, 0x31c7, 0x31c8, 0x31c9,  // Offset: 2e70 ~ 2e77
0x31ca, 0x31cb, 0x31cc, 0x31cd, 0x31ce, 0x31cf, 0x31d0, 0x31d1,  // Offset: 2e78 ~ 2e7f
0x31d2, 0x31d3, 0x31d4, 0x31d5, 0x31d6, 0x31d7, 0x31d8, 0x31d9,  // Offset: 2e80 ~ 2e87
0x31da, 0x31db, 0x31dc, 0x31dd, 0x31de, 0x31df, 0x31e0, 0x31e1,  // Offset: 2e88 ~ 2e8f
0x31e2, 0x31e3, 0x31e4, 0x31e5, 0x31e6, 0x31e7, 0x31e8, 0x31e9,  // Offset: 2e90 ~ 2e97
0x31ea, 0x31eb, 0x31ec, 0x31ed, 0x31ee, 0x31ef, 0x31f0, 0x31f1,  // Offset: 2e98 ~ 2e9f
0x31f2, 0x31f3, 0x31f4, 0x31f5, 0x31f6, 0x31f7, 0x31f8, 0x31f9,  // Offset: 2ea0 ~ 2ea7
0x31fa, 0x31fb, 0x31fc, 0x31fd, 0x31fe, 0x31ff, 0x3200, 0x3201,  // Offset: 2ea8 ~ 2eaf
0x3202, 0x3203, 0x3204, 0x3205, 0x3206, 0x3207, 0x3208, 0x3209,  // Offset: 2eb0 ~ 2eb7
0x320a, 0x320b, 0x320c, 0x320d, 0x320e, 0x320f, 0x3210, 0x3211,  // Offset: 2eb8 ~ 2ebf
0x3212, 0x3213, 0x3214, 0x3215, 0x3216, 0x3217, 0x3218, 0x3219,  // Offset: 2ec0 ~ 2ec7
0x321a, 0x321b, 0x321c, 0x321d, 0x321e, 0x321f, 0x322a, 0x322b,  // Offset: 2ec8 ~ 2ecf
0x322c, 0x322d, 0x322e, 0x322f, 0x3230, 0x3232, 0x3233, 0x3234,  // Offset: 2ed0 ~ 2ed7
0x3235, 0x3236, 0x3237, 0x3238, 0x3239, 0x323a, 0x323b, 0x323c,  // Offset: 2ed8 ~ 2edf
0x323d, 0x323e, 0x323f, 0x3240, 0x3241, 0x3242, 0x3243, 0x3244,  // Offset: 2ee0 ~ 2ee7
0x3245, 0x3246, 0x3247, 0x3248, 0x3249, 0x324a, 0x324b, 0x324c,  // Offset: 2ee8 ~ 2eef
0x324d, 0x324e, 0x324f, 0x3250, 0x3251, 0x3252, 0x3253, 0x3254,  // Offset: 2ef0 ~ 2ef7
0x3255, 0x3256, 0x3257, 0x3258, 0x3259, 0x325a, 0x325b, 0x325c,  // Offset: 2ef8 ~ 2eff
0x325d, 0x325e, 0x325f, 0x3260, 0x3261, 0x3262, 0x3263, 0x3264,  // Offset: 2f00 ~ 2f07
0x3265, 0x3266, 0x3267, 0x3268, 0x3269, 0x326a, 0x326b, 0x326c,  // Offset: 2f08 ~ 2f0f
0x326d, 0x326e, 0x326f, 0x3270, 0x3271, 0x3272, 0x3273, 0x3274,  // Offset: 2f10 ~ 2f17
0x3275, 0x3276, 0x3277, 0x3278, 0x3279, 0x327a, 0x327b, 0x327c,  // Offset: 2f18 ~ 2f1f
0x327d, 0x327e, 0x327f, 0x3280, 0x3281, 0x3282, 0x3283, 0x3284,  // Offset: 2f20 ~ 2f27
0x3285, 0x3286, 0x3287, 0x3288, 0x3289, 0x328a, 0x328b, 0x328c,  // Offset: 2f28 ~ 2f2f
0x328d, 0x328e, 0x328f, 0x3290, 0x3291, 0x3292, 0x3293, 0x3294,  // Offset: 2f30 ~ 2f37
0x3295, 0x3296, 0x3297, 0x3298, 0x3299, 0x329a, 0x329b, 0x329c,  // Offset: 2f38 ~ 2f3f
0x329d, 0x329e, 0x329f, 0x32a0, 0x32a1, 0x32a2, 0x32a4, 0x32a5,  // Offset: 2f40 ~ 2f47
0x32a6, 0x32a7, 0x32a8, 0x32a9, 0x32aa, 0x32ab, 0x32ac, 0x32ad,  // Offset: 2f48 ~ 2f4f
0x32ae, 0x32af, 0x32b0, 0x32b1, 0x32b2, 0x32b3, 0x32b4, 0x32b5,  // Offset: 2f50 ~ 2f57
0x32b6, 0x32b7, 0x32b8, 0x32b9, 0x32ba, 0x32bb, 0x32bc, 0x32bd,  // Offset: 2f58 ~ 2f5f
0x32be, 0x32bf, 0x32c0, 0x32c1, 0x32c2, 0x32c3, 0x32c4, 0x32c5,  // Offset: 2f60 ~ 2f67
0x32c6, 0x32c7, 0x32c8, 0x32c9, 0x32ca, 0x32cb, 0x32cc, 0x32cd,  // Offset: 2f68 ~ 2f6f
0x32ce, 0x32cf, 0x32d0, 0x32d1, 0x32d2, 0x32d3, 0x32d4, 0x32d5,  // Offset: 2f70 ~ 2f77
0x32d6, 0x32d7, 0x32d8, 0x32d9, 0x32da, 0x32db, 0x32dc, 0x32dd,  // Offset: 2f78 ~ 2f7f
0x32de, 0x32df, 0x32e0, 0x32e1, 0x32e2, 0x32e3, 0x32e4, 0x32e5,  // Offset: 2f80 ~ 2f87
0x32e6, 0x32e7, 0x32e8, 0x32e9, 0x32ea, 0x32eb, 0x32ec, 0x32ed,  // Offset: 2f88 ~ 2f8f
0x32ee, 0x32ef, 0x32f0, 0x32f1, 0x32f2, 0x32f3, 0x32f4, 0x32f5,  // Offset: 2f90 ~ 2f97
0x32f6, 0x32f7, 0x32f8, 0x32f9, 0x32fa, 0x32fb, 0x32fc, 0x32fd,  // Offset: 2f98 ~ 2f9f
0x32fe, 0x32ff, 0x3300, 0x3301, 0x3302, 0x3303, 0x3304, 0x3305,  // Offset: 2fa0 ~ 2fa7
0x3306, 0x3307, 0x3308, 0x3309, 0x330a, 0x330b, 0x330c, 0x330d,  // Offset: 2fa8 ~ 2faf
0x330e, 0x330f, 0x3310, 0x3311, 0x3312, 0x3313, 0x3314, 0x3315,  // Offset: 2fb0 ~ 2fb7
0x3316, 0x3317, 0x3318, 0x3319, 0x331a, 0x331b, 0x331c, 0x331d,  // Offset: 2fb8 ~ 2fbf
0x331e, 0x331f, 0x3320, 0x3321, 0x3322, 0x3323, 0x3324, 0x3325,  // Offset: 2fc0 ~ 2fc7
0x3326, 0x3327, 0x3328, 0x3329, 0x332a, 0x332b, 0x332c, 0x332d,  // Offset: 2fc8 ~ 2fcf
0x332e, 0x332f, 0x3330, 0x3331, 0x3332, 0x3333, 0x3334, 0x3335,  // Offset: 2fd0 ~ 2fd7
0x3336, 0x3337, 0x3338, 0x3339, 0x333a, 0x333b, 0x333c, 0x333d,  // Offset: 2fd8 ~ 2fdf
0x333e, 0x333f, 0x3340, 0x3341, 0x3342, 0x3343, 0x3344, 0x3345,  // Offset: 2fe0 ~ 2fe7
0x3346, 0x3347, 0x3348, 0x3349, 0x334a, 0x334b, 0x334c, 0x334d,  // Offset: 2fe8 ~ 2fef
0x334e, 0x334f, 0x3350, 0x3351, 0x3352, 0x3353, 0x3354, 0x3355,  // Offset: 2ff0 ~ 2ff7
0x3356, 0x3357, 0x3358, 0x3359, 0x335a, 0x335b, 0x335c, 0x335d,  // Offset: 2ff8 ~ 2fff
0x335e, 0x335f, 